I develop on a 4gb remote machine and most of the ram is taken up by vscode
How much gb RAM do y’all have and should I go for 32gb or do you think 16gb is enough?
and i get another error now
1.8.2
I reinstalled
kinda but not really, following this https://swaroopmaddu.medium.com/solana-installation-in-macbook-m1-b08582d50db1 already helped, but I'm not there yet
hey, got the same, did you solve it
a lot of those messages
Hi everyone, anyone else getting this when running `anchor deploy`? 
```msg 31mX2xNoURxsuSSSeZxgnM2LeoFST6P24tJ4rdGpr2YB
msg 31mX2xNoURxsuSSSeZxgnM2LeoFST6P24tJ4rdGpr2YB
msg 31mX2xNoURxsuSSSeZxgnM2LeoFST6P24tJ4rdGpr2YB
msg 31mX2xNoURxsuSSSeZxgnM2LeoFST6P24tJ4rdGpr2YB
msg 31mX2xNoURxsuSSSeZxgnM2LeoFST6P24tJ4rdGpr2YB
msg 31mX2xNoURxsuSSSeZxgnM2LeoFST6P24tJ4rdGpr2YB
msg 31mX2xNoURxsuSSSeZxgnM2LeoFST6P24tJ4rdGpr2YB
msg 31mX2xNoURxsuSSSeZxgnM2LeoFST6P24tJ4rdGpr2YB
msg 31mX2xNoURxsuSSSeZxgnM2LeoFST6P24tJ4rdGpr2YB
⠈   0.0% | Waiting for next block, 217 pending...   [block height 3; re-sign in 300 blocks]```
Wondering if anyone has had success using update_metadata_accounts in a CPI for Metaplex. I keep getting unauthorized signer errors haha
is it not possible even if I actually input the corresponding account in the list of accounts passed in?
O_O oh no 🙂
don't think you can
Can anyone remember how to go from `PubKey` to `AccountInfo` again?
Can you please explain how, or show me docs I can read on this?
those are the same error
I see. I currently get two error (0x137 and 311)
oh, i can see someone already said this
in anchor anything over 300 is a custom program error, specific to that program
Maybe an additional question, can I add any other crate 😅 cause all of them throwing an error 🤷🏼‍♂️ what do I miss?
ha sorry no I was asking a question aswell
Im guessing 0x137 as 311 is the ussual run time error code?
Looking at the explorer, I can see the following:
> Program returned error: custom program error: 0x137
> Runtime error: custom program error: 311

Which error is related to the program being run?
Hi, can someone tell me how to use the Solana-sdk in an anchor project?
This does not build via `anchor build`.
The confusing thing is, in a default rust project this works fine in the same project.
I want to have access to the `solana_sdk::signature::*` crate.
<@!134416332509675520> you strike me as someone who has looked at the metaplex repo
Is anyone here working or familiar with the Metaplex Auction House?
ah ok thanks
that's standard
it starts from 0x130
I feel like im missing something
How to use system_instruction::transfer in anchor? I tried importing solana_program, but it didn't work
btw how did you get that its the 8th error
thank you
yup
probably some try catch somewhere ¯\_(ツ)_/¯
weirdly, if you misspell the name of the contract, the entire workspace goes blank (becomes {}) instead of giving you an error
the problem ended up being incorrect capitalization - anchor out of the box inserted this line:
```
const program = anchor.workspace.AnchorPlay1dec;
```

but it had to be :
```
const program = anchor.workspace.AnchorPlay1Dec; //capital D in Dec
```
what might be a reason for having an empty `workspace`? When I console.log it, I get back `{}`. I'm using a fresh starter repo, created with `anchor init`

The test error I'm getting:
```
TypeError: Cannot read properties of undefined (reading 'rpc')
      at /Users/ilmoi/Downloads/anchor_play_1dec/tests/anchor_play_1dec.ts:17:30
      at Generator.next (<anonymous>)
      at /Users/ilmoi/Downloads/anchor_play_1dec/tests/anchor_play_1dec.ts:27:71
      at new Promise (<anonymous>)
      at __awaiter (tests/anchor_play_1dec.ts:23:12)
      at Context.<anonymous> (tests/anchor_play_1dec.ts:15:36)
      at processImmediate (node:internal/timers:464:21)
```
`#[error]
pub enum ErrorCode {`
you mean the lines starting with
thanks <@!194280119710253068>
8th one is 0x137
check the defined errors then
yes I have the source rs files
do you have the source?
ah ok. I am currently testing an already deployed program by metaplex
in the target folder or a subfolder in it
if you used `anchor build` it'll generate a JSON IDL file
You mean programmatically fetch it or is it a static file I can look at?
0x137 is the 8th error
check the IDL
is there a way to identify the descriptive error from a custom program ? e.g. I receive this error, but want to know what it maps to:

> Custom program error: 0x137
Try searching for `system_instruction::transfer` for some examples
In this case you would need to do a cross-program invocation to the system program (since the system program is presumably what owns the payer if they're a user wallet)
any docs on how to transfer sol ?
You can definitely do this, you'll just have to transfer some sol from the payer to the account in question. You'll have to do this yourself though, no anchor magic to help you.
who initializes the program
I see, and who would be funding this account with SOL?
inside an account owned by the program
from what I know, the former is only useful to make rent-exempt programs
<@!219361461783363584> do you want to store SOL inside the actual program? or do you want to store SOL inside an account owned by the program?
Hello, on initialization how can i store some solana in the contract until certain action?
https://discord.com/channels/889577356681945098/889702325231427584/915553450606080020
lol
ok I have a field like this `activated: bool`. Then if i try to check it at the beginning of my function

`if !ctx.accounts.user_config.activated { return error... }`

I am seeing `The given account is not owned by the executing program`
unlikely there's an example for something so specific. Just have a flag variable in your PDA struct `isAccountInitialized` and add a check at the start of the function (or use `access_control`) to check if the account has been inited
sorry I am having a bit of trouble working this out you couldn't point me in the direction of a doc/example please
i have a whole thread in another channel recently talking about how hard it is to find really important basic stuff about system program in the solana program rust docs
not sarcastic at all!
not sure if your being /s but it is def kinda hidden and the search bar is not too helpful 😛 thank you very much!
thanks, appreciate the help
I always forget which heading it's stored under
<https://docs.rs/anchor-lang/0.18.2/anchor_lang/derive.Accounts.html> like this? It's really well hidden
You can check this in your instruction if you want, just be checking to see if the account has the right owner/any data in it
thanks
There was just a big discussion about this in the anchor-contributors channel, can take a look
I'm not 100% but I think you would need to verify it client side then trigger the logic
I am creating PDAs to store some user config but I have some logic that occurs once both users have created accounts however I would like to restrict the function from being executed if an account hasn't yet been initialised
on a similar note does anyone know how I can check if an account has been created/initialised?
something like
```
#[access_control(
        is_owner(ctx.accounts.owner)
    )]
```
Hey guys. What is the best way to restrict a function to only be called by the account which deployed the program?
though would be good if the docs had description for `init, zero, payer, seed, etc` (or maybe I just canni find)
I see, thanks
https://docs.rs/anchor-lang/0.16.1/anchor_lang/attr.zero_copy.html
what is the meaning of `#[account(zero_copy)]`
Ok no problem thanks very much.
You're probably better off just using a vector of key-value pairs
Anchor's IDL doesn't support it yet unfortunately
Hey guys, What am I doing wrong with BTreeMap? I understand HashMap is not working on chain, but I thought BTreeMap worked fine? 
However I get this error. 
```IdlError: Type not found: {"name":"winner","type":{"defined":"BTreeMap<String,u32>"}}```
When I try to implement and empty one using: 
```winner: BTreeMap::new(), ```
True, I understand the design choice
you get one state account per program
entirely unflexible though
Sure, but it uses static seeds without requiring devs to find the address. Functionally identical with less boilerplate code imo
the alternatives are much much worse?
also finding program addresses is a great thing
state is a PDA, just with a bit of wrapper
Ok thanks! I just find it disturbing that you have to find so many program addresses before doing any calls, I thought a state was a nice solution to reduce the number of PDAs
the compiler says it's deprecated because it's deprecated. Just use PDAs
Hi! I would like to know if the `#[state]` macro is still okay to use?
The compiler says it's depracted and that PDA with static seeds should be used instead but that would require adding an endpoint to initialize the account (instead of using a custom constructor for the state).
You haven't specified anything about the account itself that lives *at* that program-derived address.
By generate do you mean "find" the PDA? I'm not totally sure I'm answering your question, but what you've written there says: you (the client) had better pass me an account whose address is program-derived from my own programId, with those seeds and that bump.
Also consider putting your u8s into a dedicated struct
Yeh borsch can be weird with u8s
Oh it was an instructions issue sorry
I figured out my issue. In the list of inputs, when String input is later than the u8 inputs, it doesn't work. Not sure why. I changed the order of inputs to have the String first and it resolved.
You need to allocate enough space up front when creating the account
I got this error recently when trying to serialized too much data on an account than the account has allocated space for
You should read through the example code from IDO pool
Hi all I am getting a variation of errors either regarding 
1. Signature Verification Failed 
2. Program Executable doesnt own the underlying account. 


Here is how my accounts are setup. I believe the error is regarding the constraints on my token account and pda. Anyone understand what can be wrong 

```
const TREE_PDA_SEED: &[u8] = b"tree";

#[derive(Accounts)]
#[instruction(bump: u8)]
pub struct InitializeProgram<'info> {
    #[account(mut, signer)]
    pub initializer: AccountInfo<'info>,
    #[account(
        init,
        payer = initializer,
        space = 8 + std::mem::size_of::<BabyData>())]
    pub baby_data: ProgramAccount<'info, BabyData>,
    #[account(
        init,
        payer = initializer,
        space = 8 + std::mem::size_of::<WhiteData>())]
    pub white_data: ProgramAccount<'info, WhiteData>,
    #[account(
        init,
        payer = initializer,
        space = 8 + std::mem::size_of::<UlistData>())]
    pub ulist_data: ProgramAccount<'info, UlistData>,
    #[account(mut, signer)]
    pub usdc_token_account: Account<'info, TokenAccount>,
    #[account(mut, signer)]
    pub sol_token_account: Account<'info, TokenAccount>,
    #[account(seeds = [TREE_PDA_SEED.as_ref()], bump = bump)]
    pub pda_account: AccountInfo<'info>,
    #[account(mut)]
    pub treasury_wallets: Account<'info, TreasuryWallets>,
    pub system_program: Program<'info, System>, 
    pub token_program: Program<'info, Token>,
    pub clock: Sysvar<'info, Clock>,
}
```

Anyone have any ideas on how these constraints are preventing from my rpc endpoint in my tests from doing literally anytthing

nvm this works with the test-validator running in a seperate window, but now for some reason (even the though file exists) my OS says it doesnt

Does anyone know how to address tcp request failed due to macOS rejecting it, only happens with anchor deploy, doesnt happen with solana program deploy
Such as one of the account structs having extremely large number of data fields? I read that each account could hold up to 16MB of data, my account has about 32 inputs, most of which are u64s and a [u8;32] array. I cannot see this being an issue. However, I have removed all the inputs and almost hardcoded the entire flow to debug this. I am still having this issue.
Is there any reason why this error would be coming up even though all the inputs are correctly sent and checked
ProgramError: 102: The program could not deserialize the given instruction
https://github.com/BeringWaters/solana-arweave-bridge

anyone figure out how to get this running
I'm getting the following error: `IdlError: Type not found: {"name":"d","type":{"defined":"TestData"}}` when running `anchor test`
Here's the relevant section of code:
```#[account]
pub struct Test {
    d: TestData,
}
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct TestData([u8; 32]);```

If I change the code to the following it works without issue:
```#[account]
pub struct Test {
    d: [u8; 32],
}
```

I can use the second version but I'm curious why the first snippet doesn't work?
this should be a feature if it’s not already
maybe, if you get access to that, you can just manually deserialize the extra arg
anchor should give you remaining_data the same way you get remaining_accounts
but tbh an extra optional arg shouldn’t be backward incomplatible
when the request schema change is backward incompatible
v2 is pretty common in my experience also outside of blockchain
v2 works if you use a handler and default the old calls to a new value
but i see what you mean
the instruction data somehow
i’d expect you to still be able to fetch them
yes, it would return Err on deserialization
thanks! lifesaver
but i guess old calls no longer deserialize
i thought anchor only hashes the instruction name not also the args
typescript clients will be able to fetch the logs from the failing txn
In general you would make some hacky shit to allow the old structure and the new one, but with the anchor deser you kind of lost control since it is generic
is this a problem only with anchor?
`msg!` doesn't get printed to the logs if the transaction fails. even with `trace` as log level (as advised by the solana debugging page). but logs from failing transactions are exactly what I need when debugging. am I just doing something wrong or is it not possible at this time without returning prematurely to make sure the logs are printed?
When instruction data needs to be update, is the only solution to cry? I have to add one new argument and it seems like upgrading the program can only screw everyone using it.

Or duplicate all endpoints with a V2, lol?
no custom error code or anything
any ideas whats going on here
```     Error: Raw transaction 4YEwSxbmHKRXxGQtTieND3u6Tu3KwtarctbGdHT1WQRF36Ck3AyL8Amfe4DGzcBQJtUxpxaWKx8F4YwnzoXGFwRd failed ({"err":{"InstructionError":[0,"ProgramFailedToComplete"]}})
      at sendAndConfirmRawTransaction (node_modules/@solana/web3.js/src/util/send-and-confirm-raw-transaction.ts:40:11)
      at processTicksAndRejections (internal/process/task_queues.js:95:5)
      at Provider.send (node_modules/@project-serum/anchor/src/provider.ts:114:18)
      at Object.rpc [as burn] (node_modules/@project-serum/anchor/src/program/namespace/rpc.ts:24:23)
```
hey ive started to encounter a strange error with one of my tests
So like would I just reference 

```
    let pda_account = ctx.accounts.pda_account.key();

```

In my handler and that is it 🙂
Thanks cqfd.. butt like how do you generate the pda. Do these constraints like automatically generate a pda that pda_account would be referencing
```
#[account(seeds = [TREASURY_PDA_SEED.as_ref()], bump = _bump_seed)]
    pub pda_account: AccountInfo<'info>,
```

does that what this code mean
So the account in question is that `pda_account`? You can get its address as just `pda_account.key` (that'll be equal to the PDA you found on the client)
So then quick question. Lets say my handler is excepting  a bump from my cleint. How do I reference the pda for the pump being passed. So here is an account: 
```
 #[account(seeds = [TREASURY_PDA_SEED.as_ref()], bump = _bump_seed)]
    pub pda_account: AccountInfo<'info>,
```
and I am saying this account is a pda_account. Then in my actual handler, I am 

```
pub fn handler(ctx: Context<InitializeProgram>, _bump_seed: u8) -> ProgramResult {

```
and in my program I want to set the authority of one of my accounts to a pda.. but like how do I reference to this pda after I pass in my bump from the client side... lol kinda confused

```
token::set_authority(
        ctx.accounts.into_set_usdc_authority_context(),
        AuthorityType::AccountOwner,
        Some(pda),
    )?;

```
ty
<#889601099735126077>
No
looking for experienced smart contract developer for an exciting project - paying well!
Is there a function if you have the bump and the program id to find the pda value
Aweosme so look at the idopool example then is what your suggesting, right?
Though it's missing the ATA stuff, which came just after it was written
To demo a lot of the new PDA constraints
This was part of the goal of the IDO pool
Hi does anyone know of a really great repos that show you how to add constraints to your pda accounts and then tests that simulate an rpc account with a pda present
It works! blimey!
interesting, thanks
Think it should be as a Buffer/Uint8Array, `Buffer.from([0, 0])` etc.
am I doing this right? I'm using a JS array
the `B()` is just a shortcut for `BigNumber`
mm i see, the program compiles, but I struggle to write unit tests against it
Yeah
It would need to be a Vec<u8> I think
Is something like this possible?
Hey <@!134416332509675520> is there any way to accept an arbitrary array as instruction data in Anchor?
Wow that takes a lot of words to say
Do any of the tests cover passing a C-like struct variant of an enum from the client?
good to know! scary!
Heh, so yeah 😛
It's just an integer, 0 for the first one, 1 for the second, etc.
<@!134416332509675520> do you know if that first byte is an incremental integer or if it's some kind of "hash" that identifies the name of the enum and it's properties? basically, if I was to update the enum in the future, do I need to be really careful about where I add the position of the new enum item?
Yep, 1 byte to specify the variant, then the rest is serialized as if it were a struct
aha! the `1` is the `u8` enum identifier?
Mmm, right—yeah, the space in general needs to be 1 + biggest variant
<@!134416332509675520> would you say that, to derive `Default`, it should return some item that is as big as the largest enum?
I just wonder if you already have came across these bugs or like you are a fricking genius? haha. Wow, that worked. Thanks a bunch <@!134416332509675520>
At any rate it's true you can't derive Default, but you can impl Default if you really want to (feels sketchy to me/don't super like it, but eh)
One sec
I'll check onto it.
Oh really?
Ah, ok, you should probably just fix it the right way and impl ~~Defer~~ Deref (my guess is the token thing does this, could be an example for you)
Why do you need to derive default? I guess you're skipping `space =` somewhere else?
Awesome question. It yells stating that it's a private field
What if you do `self.nft_metadata.0.update_authority`
Hi!

I have an enum that I'd like to serialize into an Account. It looks like this:

```
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Copy, Eq, PartialEq)]
pub enum DexInstruction {
    Foo{
        c: u64,
        d: Pubkey,
    },
    NullableInstruction{
        a: u8,
        b: u8,
    }
}
```

It looks like I cannot derive `Default` so I'm wondering what is the best way to bypass this restriction? thanks!
Did you implement Deref for your Metadata wrapper type?
<@!185307556032413697> would be really nice if you could find a minimal reproducing example / paste the code, this is a lot of code and text to read and get into!
Sorry 😦 Was seeking the help from core-devs.
dont @ people
I have the same question 🙂
Apologies for spamming the chat room, but I'm super new to this whole ecosystem, and so like I'm super lost on why exactly it is happening.
Oh, BTW this is the `try_deserialize_unchecked` for `TokenAccount`, and as you can see the `Pack` trait is being implemented which is the manual way ..


///////////////////////////////////////////////////////////////////////////////////////////////

ah right in this case `somePublicKey` is the owner...  got confused haha Thanks Alan!
Mm, somePublicKey there is the owner of the token account, not the token account's address, so not sure what you mean
just curious about what will the error be
another silly question,  if I initiate a token account as the follows
```
    someTokenAccount = await someMint.createAccount(somePublicKey);
```
Does it mean this `somePublicKey` cannot be used to initialized as owned by system account anymore?
Can instead fetch the account manually I guess
Yeah, probably
ah so its a matter of the explorer not showing the SOL inside it
You can send sol to whatever account you want, it'll just chill there (might be hard to get back though)
Hi there go a question lets say Ive got a token account https://explorer.solana.com/address/8kQ67VMZPBmDHqE7r6Spw5PgUEj6rPRXJBU5A4PLT9bR?cluster=devnet. And what exactly happens behind the scene if I try to airdrop sol into it? I experimented with a few airdrops, the balance didnt show up but the txn went on chain
how interesting, let me play with this
Can try this kind of thing? https://discord.com/channels/889577356681945098/889577399308656662/918566634938069073
ouch, here's a problem I don't know how to solve..

so my ix now verifies whether the passed in account is a real metadata account created by Metaplex - but when I do local testing with `anchor test` there is no metaplex! and I don't think I could even deploy it to that address because I don't have the keypair

does that mean I can't locally test anymore?
instead of using `remaining_accounts` which feels a bit messier?
just thinking out loud about optional accounts in anchor - what if I was  to simply pass a null Pubkey when I don't need the account?
Thanks a lot!
Aha makes sense; I was testing a multisig account and wanted to use my faucet to send some tokens to it
By default the getAssociatedTokenAddress checks for this, but you can pass a flag to tell it to not care
You can verify with `PublicKey.isOnCurve(receiver.toBytes())`
That's because that new PublicKey is off the ed25519 curve (are you doing that deliberately?)
I created a faucet and now want to add the feature of creating an associated token account for a PK that you don't own, yet do pay for: 
```
#[derive(Accounts)]
#[instruction(mint_bump: u8, amount: u64)]
pub struct Airdrop<'info> {
    #[account(
        init_if_needed,
        payer = payer,
        seeds = [b"faucet-mint".as_ref()],
        bump = mint_bump,
        mint::decimals = 6,
        mint::authority = mint
    )]
    pub mint: Account<'info, Mint>,

    #[account(
        init_if_needed,
        payer = payer,
        associated_token::mint = mint,
        associated_token::authority = receiver
    )]
    pub destination: Account<'info, TokenAccount>,
    pub payer: Signer<'info>,
    pub receiver: AccountInfo<'info>,
    pub system_program: Program<'info, System>,
    pub token_program: Program<'info, Token>,
    pub associated_token_program: Program<'info, AssociatedToken>,
    pub rent: Sysvar<'info, Rent>,
}
```
In my tests; I initialize the receiver as `const receiver = new PublicKey("8hpvAu6cq6qzVM4NpXp9bH2uuT4PEYMJvrXKrSd5tdfR");` and fetch the associated token account as 
```let associatedTokenAccount = await Token.getAssociatedTokenAddress(
      ASSOCIATED_TOKEN_PROGRAM_ID,
      TOKEN_PROGRAM_ID,
      mintPda,
      receiver,
    );```
When I perform the final call; I get the error: `Owner cannot sign: 8hpvAu6cq6qzVM4NpXp9bH2uuT4PEYMJvrXKrSd5tdfR`
. 
However, if I make a random keypair with `anchor.web3.Keypair.generate()` and pass its pk as the receiver, the tests do pass. 
. 
Question: Is there a way to initialize an associated token address for a wallet you don't own?
never hurts in this industry:)
will do, to be double sure
I think so... would have to think about that some (I would just verify the owner anyway)
that should be enough right?
I'm checking the PDA's address, which if it's correct, implies it was derived from metaplex's program
for sure
Yeah, just gotta be careful to check the account really is owned by metaplex etc.
I think there's a metaplex helper, Metadata::from_account_info
in that case (1) seems simpler
yup
(Only anchor programs use that discriminator thing)
Ok, then you wouldn't need to chop them off
so I would cut it off either way I guess
no it doesn't
Also, does the metaplex struct actually use an 8 byte discriminator?
You could also just deserialize manually, just need to remember to check ownership etc.
The anchor-y thing to do would be 2 (with your suggestion to wrap the metaplex struct). This is what anchor does for e.g. TokenAccount and Mint.
trying to auto deserialize Metaplex's metadata throws a trait error:
```
the trait bound `metaplex_token_metadata::state::Metadata: anchor_lang::AccountSerialize` is not satisfied
```

which makes sense. What's the recommended way to handle this?

Some approaches I thought of:
1. Deserializing manually. In this case I'd cut off the first 8 bytes and take the remaining string and borsh deserialize it
2. Implementing the missing traits on Metaplex's struct. Afaik I can't implement a foreign trait on a foreign struct, but I could put their struct inside my own and implement the traits. Is that a viable approach? Or will (1) be simpler?

Any examples would help
Can use `address = <the metaplex address>`
+ manually verifying program's address
I see - and an alternative would be to simply use AccountInfo?
Not sure anchor already has a built-in way to do that (I saw someone posted some code for this in the discord though)
also another question, how would I pass in `Metaplex` as the program in this format:
```
    pub system_program: Program<'info, System>,
```
nice
Yep, any boolean expression will work
can I do constraint = some_function() and define the function somewhere else? (otherwise gets messy)
ok that's cool
You'll have to write your own constraint or something
Unfortunately no, not yet (anchor needs to add a new attribute for this)
when I'm verifying seeds of a PDA, it looks something like this:
```rs
    #[account(mut,
              seeds = [
                  b"deposits".as_ref(),
                  reserve.key().as_ref(),
                  depositor.key.as_ref()
              ],
              bump = bump)]
    pub deposit_account: AccountInfo<'info>,
```
but what if the PDA wasn't created by this program, but by some other? do I just add `program = program_id` or something?
I'll check it out, thanks for you help! 😀
I keep posting this, but this escrow example includes program-controlled token accounts: https://github.com/cqfd/quidproquo
thanks
got it
It's just `constraint = <some boolean expression>`
cool, never tried that one before
Will have to use a raw `constraint = ...` for that
when I'm doing `has_one = x`, is it somehow possible to do this check when the account passed doesn't match the name stored in state?

eg in state struct it's called `field1`, but the account I passed in is called `field1something`
And no need for it to be an associated-token account most likely
You would need the authority of the token account to be some program-derived address derived from the program
lol woops
Ah, ok, so what you've written above won't do that 😛
Now I'm trying to create a token account owned by the program, so that the program can hold and transfer the created SPL token.
But sounds like that already exists
You're saying you want to `init` an associated token account for that mint, owned by the authority
Maybe I'm misunderstanding your snippet
So what account are you trying to create then here?
Yeah, that's the minted tokens account, which I got when running: `spl-token create-account <mint_address>`
cargo install --git https:// github.com/project-serum/anchor --tag v0.18.0 anchor-cli --locked returns the error shown in the txt file, is anyone familiar with this? running mac os 11.6.1 intel
Does that account already exist then? You won't be able to create it twice
The address is the minted tokens account address, which is what I'm passing for `token`
I tried that and I get a different error:
'Allocate: account Address { address: 8gm922jSB69HbURE6uiUfKtrDTusvZVV288gqhnq8rQ7, base: None } already in use'
Yeah
Does that account need to be based for the `token`?
The error here is happening though because the associated token program declares that you need to pass an account with a certain address (derived from the owner + mint), and you're not passing the right account from the client
Ok, let me try that out, thanks
Ah, ok, looks like your call in js is doing `getTokenAddress(mint, tokenMint)`, rather than `getTokenAddress(authority, mint)`
This is how I'm getting the associated address:
```
export const getTokenAddress = async (
  walletAddress: anchor.web3.PublicKey, 
  tokenMintAddress: anchor.web3.PublicKey,
): Promise<[anchor.web3.PublicKey, number]> => {
  return anchor.web3.PublicKey.findProgramAddress(
    [ walletAddress.toBuffer(),
      spl.TOKEN_PROGRAM_ID.toBuffer(),
      tokenMintAddress.toBuffer() ],
    spl.ASSOCIATED_TOKEN_PROGRAM_ID,
  );
};
```
Are you sure you're calculating the `token`'s associated address correctly?
```
#[derive(Accounts)]
pub struct CreateTokenAccount<'info> {
  
  #[account(
    init,
    payer = authority,
    associated_token::mint = mint,
    associated_token::authority = authority,
  )]
  pub token: Account<'info, TokenAccount>,

  #[account(mut)]
  pub authority: Signer<'info>,

  #[account(mut)]
  pub mint: Account<'info, Mint>,

  #[account(address = system_program::ID)]
  pub system_program: AccountInfo<'info>,
  pub token_program: Program<'info, Token>,
  pub associated_token_program: Program<'info, AssociatedToken>,
  pub rent: Sysvar<'info, Rent>,
}
```
show the struct in rust that defines all your accounts
Hi guys, I'm trying to create a token account that's owned by the program, but I'm having some trouble getting it to work. Any help would be appreciated, thanks.

Client:
```
const [mint, mintBump] = await anchor.web3.PublicKey.findProgramAddress([], program.programId);
const [token] = await getTokenAddress(mint, tokenMint);

await program.rpc.createToken({
  accounts: {
    token: token, 
    mint: tokenMint,      // SPL token mint address
    authority: authority, // My wallet public key
    systemProgram: anchor.web3.SystemProgram.programId,
    tokenProgram: spl.TOKEN_PROGRAM_ID,
    associatedTokenProgram: spl.ASSOCIATED_TOKEN_PROGRAM_ID,
    rent: anchor.web3.SYSVAR_RENT_PUBKEY,
  },
});
```
Error:
```
logs: [
    'Program 4dBAERTMc229cbxK7egGb5ZQKmp7x8EwcjqUTLDntx9j invoke [1]',
    'Instruction references an unknown account 8gm922jSB69HbURE6uiUfKtrDTusvZVV288gqhnq8rQ7', // This is the SPL token's account address.
    'Program 4dBAERTMc229cbxK7egGb5ZQKmp7x8EwcjqUTLDntx9j consumed 200000 of 200000 compute units',
    'Program 4dBAERTMc229cbxK7egGb5ZQKmp7x8EwcjqUTLDntx9j failed: An account required by the instruction is missing'
  ]
```
thanks for the help and for the link!
Kind of surprisingly, the compute budget is currently per *instruction*, not tx: https://jstarry.notion.site/Transaction-Fees-f09387e6a8d84287aa16a34ecb58e239
Thanks again. will they all share compute budget?
You would have to compose together individual instructions into a bigger transaction: `program.instruction.xxx`
love it
all-star crew came to party in native chat
just making sure everyone is alive in here.  good. 🙂
Thanks. follow up: is there a way to group program.rpc.xxx() calls so the signer only needs to approve once? If so, will they share compute budget?
Yep, more stuff happens after the end of your instruction, e.g. any changes you made to structs need to be written back out to account storage.
My hunch is that there must be some serialization/deserialization going on once an instruction completes
Morning all, I'm logging my used compute via `sol_log_compute_units` at the very end of my instruction, right before `Ok(())`.  When i check the logs, i see this:
```
Program consumption: 131950 units remaining
> Program GG...P56 consumed 193133 of 200000 compute units
```
It seems somehow a ton of compute is being used by Ok()? What could cause the spike in compute used at the very end of my instruction?
Hi can I do a test coverage report in Anchor? And how to manipulate time like forwarding in time?
yes, you can find events in examples in Anchor repo
Does solana blockchain support emitting events?
you can copy most of our helper code to get yourself setup, super straight forward, see https://github.com/blockworks-foundation/voter-stake-registry/blob/master/programs/voter-stake-registry/tests/test_basic.rs#L12, follow that call
same 😦 , i hate writing tests on js/ts...
which i will do one day, between now and never
like https://github.com/solana-labs/solana/issues/20279
there are missing things in solana-test-validator to deliver the same
it is quite more advanced given how easy it is to setup things
Yeah. I personally don't write any tests in rust yet besides the little embedded `#[test]` ones (love those), but I'd like to learn about the rust support
are you talking about rust tests in solana? check out some of the <#889584618372734977> channel i was asking about it there recently
You can write some simple logic tests with e.g.
```.rs
#[test]
fn your_test() {
  assert_eq(99, 100 - 1);
}
```
😁 https://twitter.com/armaniferrante/status/1434554725093949452
also do tests to check a solana program is written differently than a normal test in rust ?
<@!134416332509675520>  would help a ton if you could give a few pointers to get started with
😦
But in general, yeah, you're going to have a bad time haha if you follow the docs too closely 😛
the instruction part still requires you to specify the program id
it is, via the instructions
Maybe the docs are out of date, yeah
I'm unclear what you're still wondering about 🤔
and the docs havent been changed to reflect the change if any.
yes but its not being passing in to the CPI.
you still have to include the program in your original set of accounts
it doesn't really matter either way
i tried looking at the solana changelog notes to see if they documented it, still no luck 😦
also on that note, i have been wanting to learn testing on rust and importantly solana, in order to test without deploying and interacting it via clients, any idea where could i get a start ?
that is very sus
yep, no fails
i'm going to delete from more CPIs to double check
and wow, it doesn't fail
i've deleted program from an spl cpi and am running a test now
<https://github.com/solana-labs/solana/blob/6f3f6eddb2de5ef3581264f8d6693361bdabd2f6/sdk/program/src/program.rs#L10>
not sure if it was this or not
i remember there was something that changed about CPI that should reduce compute cost
it's possible this is something new
Actually it would be funny if I'm just totally wrong about this—I see that armani is passing the system_program to anchor's create_account calls
the first challenge is finding the invoke source
Wonder how easy it would be to see that in the invoke source (probably hard lol)
The program id you're calling is embedded in the instruction, so I guess so, yeah
As far as I understand you only have to pass the accounts that were asked for via AccountMetas etc.
solana just picks it up implicitly?
Yeah you don't have to explicitly pass the program account (though the call will fail if it wasn't passed from the client) [edit: slightly less certain about this now]
you should just try to run it
i can't see the screenshot they shared
he seems to disagree he is the creator of that recipe on solana cookbook

you can see it's required here too
<https://github.com/project-serum/anchor/blob/master/spl/src/token.rs#L25-L34>

you should make a pull request
well spotted!
yeh, it's definitely missing
but you're right, they leave it out in the rust CPI
they included it there
i was looking at the TS example
yeh, they might have just left it out
it's possible it's a bug
also an hour ago a solana dev said i will need to pass token program in the list of accounts.
this is what confuses me ^

ok, let me look and see if i can come up with a more satisfactory explanation
<https://github.com/solana-labs/solana-program-library/blob/master/token/program/src/instruction.rs#L93-L105>
yes i get that but doesnt invoke require the program account is passed whose program id u refer in the instruction ?
the instruction to the token program doesn't need to refer to itself
and the accounts that the instruction needs
the public keys of the accounts the transaction needs
remember there's two parts to a transaction
he is retreiving the token account from the client but not passing it into the invoke instruction
it's there
^ the above example is a simple spl token transfer
but then why is there no need to pass the token account into the list of accounts in this example ? https://solanacookbook.com/recipes/programs.html#how-to-do-cross-program-invocation
Yes
in its list of accounts passed?
hey does invoke require the program account of the program you are trying to cpi into ?
Lol, I see what you're doing here
Boxing them would probably have zero effect?
Yeh, I'm confused how unchecked accounts can blow the stack
https://solscan.io/tx/5WHmS2T1phB1tuVQnUTazszjrv9Ho219AMTq1jLwYBaac2RqxThwKDTbnjGi6muhCUk8utcdacsvauwUpDNraofS 32 accounts lol
I am a bit confused, so i fixed it by essentially redoing what the context is doing...
```
        let amm_authority = UncheckedAccount::try_from(next_account_info(remaining_accounts_iter)?.clone());
        let serum_program = UncheckedAccount::try_from(next_account_info(remaining_accounts_iter)?.clone());
        let user_source_token_account = UncheckedAccount::try_from(next_account_info(remaining_accounts_iter)?.clone());
        let user_intermediate_token_account = UncheckedAccount::try_from(next_account_info(remaining_accounts_iter)?.clone());
        let user_destination_token_account = UncheckedAccount::try_from(next_account_info(remaining_accounts_iter)?.clone());
        let user_source_owner = Signer::try_from(next_account_info(remaining_accounts_iter)?)?;
```
Delicious, I am doing that abject stuff so i can reuse an account struct to create a CpiContext
I like this one `Stack offset of -4096 exceeded max offset of -4096 by 0 bytes, please minimize large stack variables`
`Stack offset of -4104 exceeded max offset of -4096 by 8 bytes, please minimize large stack variables`
no rage quit, proceed to armani hack
rage quit
cannot work
ok 440 bytes away, using reorganization
I refuse
mmmmmh
Use remaining_accounts and manually take them out.
what can i do here? they are all UncheckedAccount
Hopefully the stack restrictions are gone in 1.9
https://solscan.io/tx/5uCrjE2LeAqxett4DzsSegGcChEdChiyuEgfFTrME56TfJENS2f7KQCa9bHnLBrcC3iThbdBUkgwsSxNkC4p4tFZ how unfair, my many accounts ix hits the stack limit
Perfect
ended up with ```    #[account(
        mut,
        constraint = cpi_auth_account.key == &state_account.load()?.cpi_auth_pubkey,
        seeds = [
            b"FABRIC".as_ref()
        ],
        bump = state_account.load()?.nonce
    )]```
thank you <@!134416332509675520> <:pepelove:866983238295486467> <a:narutorun:880176525784281129>
working!
<:hur:866983240928722954>
Yeah, that's why I got confused looking at this earlier—that looks so plausible lol that I glazed over the `seeds = [...]` part
if i set the state nonce as the bump returned when searching from the cpiAuthAccount, could i keep my seeds as ```        let seeds = &[
            b"FABRIC".as_ref(),
            &[state.nonce]
        ];```
following now, thank you <@!134416332509675520> <:pepelove:866983238295486467>  let me give this a crack
Yeah (ideally it would be cool if anchor could calculate bumps for fixed seeds *statically*, but don't think that works yet)
oh! id need to pass the bump to the contract, save it and fetch the bump from the contract when constructing the seeds?
ill get that updated. once updated, how would i be using the bump when finding the cpiauthaccount?
And then you could store the resulting bump somewhere
Ok. I would have expected the seeds to just be ["FABRIC"]
think this is my misunderstanding of how `findProgramAddress` in the js library works and how to construct seeds within the rust contract
So when you do `getCpiAuthAccount(nonce)`, what is that nonce for?
its not variable, there should only ever be one
pass the correct bump which is outputted from `getCpiAuthAccount` (it isnt but can be modified to)? or did i miss the mark here
I'm not sure what you ought to do—is the state nonce variable? Is there only supposed to be one of these cpiAuthAccounts?
So I have to re-find the address to see what the right bump is—ideally you would pass that into the program from the client
Here's the working code:
```.rs
        let (ostensible_address, recalculated_bump) = Pubkey::find_program_address(&[
            b"FABRIC".as_ref(),
            &[state.nonce]
        ], &ID);
        msg!("{} vs {}", ostensible_address, ctx.accounts.cpi_auth_account.key());

        let seeds = &[
            b"FABRIC".as_ref(),
            &[state.nonce],
            &[recalculated_bump]
        ];

        let signer = &[
            &seeds[..]
        ];
        let mint_cpi_context = CpiContext::from(&*ctx.accounts).with_signer(signer);
        token::mint_to(mint_cpi_context, amount.val.try_into().unwrap())?;
```
derp. should the bump be used when init'ing the contract as the nonce or otherwise?
Currently you're throwing it away
Basically you need to know the bump that the underlying findProgramAddress returns, in addition to the actual PDA address
the sdk function for getCpiAuthAccount? yes
Is that function under your control?
Ok, so that's fine
Ah, no, if you want to sign for it in your program (which I guess you do), then it needs to be derived from your program
should the program id be token program id?
program id of the contract
This program?
Actually, which program is that derived from?
`./src/sdk/src/synths.ts`
I'm trying to find the implementation of getCpiAuthAccount
i do but i felt like i was using it incorrectly
state.nonce
`state.nonce` or `the_bump_for_the_two_seeds_above`?
So I wonder if you actually want to use that nonce *as a seed*?
confusion admittedly. `the_bump_for_the_two_seeds_above` would be?
So the actual seeds have to look like
```.rs
let seeds = &[
            b"FABRIC".as_ref(),
            &[state.nonce],
            &[the_bump_for_the_two_seeds_above]
        ];
```
But when you go to sign for the account, you *also* need the *other* bump!
The issue is actually kind of funny/wondering if it's a confusion or "deliberate": your seeds for that account *include a nonce*, which you're using as an additional seed.
what did i miss <:wut:901895994961190932>
man of the damn day <:pepelove:866983238295486467>
But fixed that one thing
yeah i need to get to that next lol
Some other stuff fails later on
<:hur:866983240928722954>
<:what:866983240992292874>
Heh, fixed it 🧠
make sure to build the sdk first
`npm run test::core`
core should be enough to see the error
Which tests should I run?
invited kind sir <:pepelove:866983238295486467>
Cool, it's https://github.com/cqfd
You may have to install from source (not via the installer—the latest master is 1.9.0)
no problem, head scratcher, let me know if you figure it out
thank you for trying!
```
solana --version
solana-cli 1.8.5 (src:devbuild; feat:52865992)

anchor --version
anchor-cli 0.18.2
```
maybe double check `solana --version`, otherwise im out of ideas 😁
yeah, it's the same
```
[
    'Program AcH1zxFt1fxm421DfqgzPBNvRa9UEdVShEoAx3Gxx7YS invoke [1]',
    'Program AcH1zxFt1fxm421DfqgzPBNvRa9UEdVShEoAx3Gxx7YS consumed 3583 of 200000 compute units',
    'Program AcH1zxFt1fxm421DfqgzPBNvRa9UEdVShEoAx3Gxx7YS success',
    'failed to verify account 255i2rZeKqJfNA8FYopWZ8NeYTLVTEF9j6VXt8DMQd4F: instruction modified the program id of an account'
  ]
```
i thinkg it's a different one
oh no, wait
gives me the same error
kill that and just run `anchor test`
yes, running it like `solana-test-validator --no-bpf-jit` like the m1 guide on that course suggests
whats your GH user? ill invite you to the repo
do you have your own solana-test-validator?
any idea what could the problem be then?
well... isn't that lovely... haha
that code runs fine for me on solana 1.8.5 and anchor 0.18.2 on an M1
0.18.2
what version of anchor?
Any idea on how to solve this model for anonymous public accounts?
the initial fetch works fine. The error occurs when calling the `addGif` function
and here is how I'm calling it:
```
  const provider = anchor.Provider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.Myepicproject;

  const baseAccount = anchor.web3.Keypair.generate();

  // Call start_stuff_off, pass it the params it needs!
  let tx = await program.rpc.startStuffOff({
    accounts: {
      baseAccount: baseAccount.publicKey,
      user: provider.wallet.publicKey,
      systemProgram: SystemProgram.programId,
    },
    signers: [baseAccount],
  });

  console.log("📝 Your transaction signature", tx);

  // Fetch data from the account.
  let account = await program.account.baseAccount.fetch(baseAccount.publicKey);
  console.log('👀 GIF Count', account.totalGifs.toString())


  // You'll need to now pass a GIF link to the function! You'll also need to pass in the user submitting the GIF!
  await program.rpc.addGif("https://tenor.com/view/grim-syndicate-grim-gif-23589202", {
    accounts: {
      baseAccount: baseAccount.publicKey,
      user: provider.wallet.publicKey,
    },
  });
```
So hopefully you don't mind... let me know if I should remove. Here is the code for the contract:
```
use anchor_lang::prelude::*;

declare_id!("AcH1zxFt1fxm421DfqgzPBNvRa9UEdVShEoAx3Gxx7YS");

#[program]
pub mod myepicproject {
  use super::*;
  pub fn start_stuff_off(ctx: Context<StartStuffOff>) -> ProgramResult {
    // Get a reference to the account.
    let base_account = &mut ctx.accounts.base_account;
    // Initialize total_gifs.
    base_account.total_gifs = 0;
    Ok(())
  }

  // The function now accepts a gif_link param from the user. We also reference the user from the Context
  pub fn add_gif(ctx: Context<AddGif>, gif_link: String) -> ProgramResult {
        // Get a reference to the account and increment total_gifs.
        let base_account = &mut ctx.accounts.base_account;
        let user = &mut ctx.accounts.user;

        // Build the struct.
        let item = ItemStruct {
          gif_link: gif_link.to_string(),
          user_address: *user.to_account_info().key,
        };

        // Add it to the gif_list vector.
        base_account.gif_list.push(item);

        base_account.total_gifs += 1;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct StartStuffOff<'info> {
    #[account(init, payer = user, space = 9000)]
    pub base_account: Account<'info, BaseAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program <'info, System>,
}

// Specify what data you want in the AddGif Context.
// Getting a handle on the flow of things :)?
// Add the signer who calls the AddGif method to the struct so that we can save it
#[derive(Accounts)]
pub struct AddGif<'info> {
  #[account(mut)]
  pub base_account: Account<'info, BaseAccount>,
  #[account(mut)]
  pub user: Signer<'info>,
}

// Create a custom struct for us to work with.
#[derive(Debug, Clone, AnchorSerialize, AnchorDeserialize)]
pub struct ItemStruct {
    pub gif_link: String,
    pub user_address: Pubkey,
}

// Tell Solana what we want to store on this account.
#[account]
pub struct BaseAccount {
    pub total_gifs: u64,
    // Attach a Vector of type ItemStruct to the account.
    pub gif_list: Vec<ItemStruct>,
}
```
I did try searching the discord before asking, but doesn't look like anyone else here shared the code yet... I only see another person with the same function but asking about something else
1.8.5
but I'm already on the latest solana build...
I did run into a different issue earlier today that updating fixed it
I think this has happened a few times (try searching the discord). If I remember right people had to update their solana install
or my own mistake
since i'm not sure it's really a bug
sounds like here
i'm def a newbie on solana/anchor, so I'd be happy to share the code. Just thought I'd ask if here or github would be better...
maybe you are running your own validator and init'ing an account twice or something
here is some things that could cause it https://github.com/solana-labs/solana/blob/b8837c04ec3976c9c16d028fbee86f87823fb97f/program-runtime/src/pre_account.rs#L47-L59
different solana versions perhaps?
well, the same code on non m1 computers seems to be working fine, and only people running into the problem seem to be m1 users...
thats not an m1 issue, its an error in your code somewhere
Hey! I seem to be having an m1 issue, since noone else who's been doing the `buildspace` course seems to have ran into this...  the error itself is `instruction modified the program id of an account` . Is here the best way to talk about it? Or should I open an issue on the github?
Mm, not sure what else to suggest remotely, if you've got this in a repo I could debug more quickly locally
Oh, sorry, I guess that's also not related to the current error message, my bad 🤦‍♂️
To the mint
Can you add something like
```.rs
constraint = fusd_token_account.mint_authority == COption::Some(cpi_auth_account.key())
```
`     Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account`
okay cool, same error
agreed lol
Don't think that's the current problem
Yeah
and I would be passing in `TOKEN_PROGRAM_ID` right?
updated and building
`token_program_account: Program<'info, Token>`
what should be `Program<'info, Token>`?
But I think the thing you've got would end up being the same thing basically
Oh, hmm, you should definitely be doing `Program<'info, Token>`, not what you have above
i am running a test but agreed, could this mean im passing the wrong token program account in?
Still confused why you don't see anything about the token program in your logs
small operations to account data, no transfers or other mints
Are you doing anything else in your instruction function?
getting the same error
sure
yeah `2zUzSdE9r1knvzE3ZnZoLnKGqyGn9ZZVAJDDgDcTvw5v` is the account passed in
I imagine there's no difference, but just to be safe
Use `b"FABRIC".as_ref()` rather than to_bytes (not actually sure if there's a difference)
Also, just to be safe, can you write the seeds exactly the same way in the cpi call as in the seeds = [...] part?
Is 2zUzSdE9r1knvzE3ZnZoLnKGqyGn9ZZVAJDDgDcTvw5v definitely the cpi_auth_account?
Hmm, I'm surpised you don't see any token program logs in there
```Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account 
    Program taNXtfA9Z6EEBte9JGMVfuwg2rknnDxag1C1YPFJpeY invoke [1]
    Program log: FABRIC: mint
    Program log: Slot: 56
    Program log: Last updated: 18446744073709551615
    Program log: Max delay: 4500
    Program log: Slot: 56
    Program log: Last updated: 50
    Program log: Max delay: 4500
    Program log: total debt: 0
    Program log: user debt: 0
    Program log: max debt: 150000000000000000000000
    Program log: maximum mintable: 150000000000000000000000
    Program log: user debt: 0
    Program log: amount: 25000000000
    Program log: debt after mint: 25000000000
    Program log: state debt shares: 0
    Program log: amount: 25000000000
    Program log: total debt: 0
    Program log: new shares: 25000000000
    Program log: state debt shares: 25000000000
    Program log: new supply: 25000000000
    2zUzSdE9r1knvzE3ZnZoLnKGqyGn9ZZVAJDDgDcTvw5v's signer privilege escalated
    Program taNXtfA9Z6EEBte9JGMVfuwg2rknnDxag1C1YPFJpeY consumed 200000 of 200000 compute units
    Program taNXtfA9Z6EEBte9JGMVfuwg2rknnDxag1C1YPFJpeY failed: Cross-program invocation with unauthorized signer or writable account
Translating error SendTransactionError: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account
    at Connection.sendEncodedTransaction (/Users/0x/Documents/dev/projects/fabric-rust-contracts/src/program/fabric_synths/node_modules/@solana/web3.js/src/connection.ts:3689:13)
    at processTicksAndRejections (internal/process/task_queues.js:95:5)
    at Connection.sendRawTransaction (/Users/0x/Documents/dev/projects/fabric-rust-contracts/src/program/fabric_synths/node_modules/@solana/web3.js/src/connection.ts:3649:20)
    at sendAndConfirmRawTransaction (/Users/0x/Documents/dev/projects/fabric-rust-contracts/src/sdk/node_modules/@solana/web3.js/src/util/send-and-confirm-raw-transaction.ts:25:21)
    at Provider.send (/Users/0x/Documents/dev/projects/fabric-rust-contracts/src/sdk/node_modules/@project-serum/anchor/src/provider.ts:114:18)
    at Object.rpc [as mint] (/Users/0x/Documents/dev/projects/fabric-rust-contracts/src/sdk/node_modules/@project-serum/anchor/src/program/namespace/rpc.ts:24:23) {
  logs: [
    'Program taNXtfA9Z6EEBte9JGMVfuwg2rknnDxag1C1YPFJpeY invoke [1]',
    'Program log: FABRIC: mint',
    'Program log: Slot: 56',
    'Program log: Last updated: 18446744073709551615',
    'Program log: Max delay: 4500',
    'Program log: Slot: 56',
    'Program log: Last updated: 50',
    'Program log: Max delay: 4500',
    'Program log: total debt: 0',
    'Program log: user debt: 0',
    'Program log: max debt: 150000000000000000000000',
    'Program log: maximum mintable: 150000000000000000000000',
    'Program log: user debt: 0',
    'Program log: amount: 25000000000',
    'Program log: debt after mint: 25000000000',
    'Program log: state debt shares: 0',
    'Program log: amount: 25000000000',
    'Program log: total debt: 0',
    'Program log: new shares: 25000000000',
    'Program log: state debt shares: 25000000000',
    'Program log: new supply: 25000000000',
    "2zUzSdE9r1knvzE3ZnZoLnKGqyGn9ZZVAJDDgDcTvw5v's signer privilege escalated",
    'Program taNXtfA9Z6EEBte9JGMVfuwg2rknnDxag1C1YPFJpeY consumed 200000 of 200000 compute units',
    'Program taNXtfA9Z6EEBte9JGMVfuwg2rknnDxag1C1YPFJpeY failed: Cross-program invocation with unauthorized signer or writable account'
  ]
}
    1) Mint 250 fUSD```
Can you post the program logs?
```// mint accounts
#[derive(Accounts)]
pub struct MintCtx<'info> {
    #[account(
        mut,
        seeds = [b"fstate1".as_ref()], 
        bump = state_account.load()?.bump, 
        constraint = state_account.to_account_info().owner == program_id,
        constraint = state_account.load()?.admin_pubkey == *admin_account.key
    )]
    pub state_account: Loader<'info, State>,

    #[account(
        mut,
        constraint = assets_list_account.to_account_info().key == &state_account.load()?.assets_list,
        constraint = assets_list_account.to_account_info().owner == program_id
    )]
    pub assets_list_account: Loader<'info, AssetsList>,

    #[account(
        constraint = admin_account.key == &state_account.load()?.admin_pubkey
    )]
    pub admin_account: AccountInfo<'info>,

    #[account(
        mut,
        constraint = fusd_token_account.to_account_info().key == &assets_list_account.load()?.synthetics[0].asset_address
    )]
    pub fusd_token_account: Account<'info, anchor_spl::token::Mint>,

    #[account(
        mut,
        constraint = &to_account.mint == fusd_token_account.to_account_info().key
    )]
    pub to_account: Account<'info, TokenAccount>,

    #[account(
        address = token::ID
    )]
    pub token_program_account: AccountInfo<'info>,

    #[account(
        mut,
        has_one = owner
    )]
    pub user_account: Loader<'info, UserAccount>,

    #[account(
        mut,
        signer
    )]
    pub owner: AccountInfo<'info>,

    #[account(
        mut,
        constraint = cpi_auth_account.key == &state_account.load()?.cpi_auth_pubkey,
        seeds = [
            b"FABRIC".as_ref(), 
            &[state_account.load()?.nonce]
        ],
        bump
    )]
    pub cpi_auth_account: AccountInfo<'info>,
}```

cpiAuthAccount is correct and matches the right seeds <:thonk:895614589562150913>
``` let seeds = &[
            "FABRIC".as_bytes(),
            &[state.nonce]
        ];
        let signer = &[
            &seeds[..]
        ];
        let mint_cpi_context = CpiContext::from(&*ctx.accounts).with_signer(signer);
        token::mint_to(mint_cpi_context, amount.val.try_into().unwrap())?;
```
annoyingly getting a cpi error even though the mint authority of `fusd_token_account` is `cpi_auth_account`
Ok, cool, then should work
it is, good point 

` pub fusd_token_account: Account<'info, anchor_spl::token::Mint>,`
Yes. But your names above are a bit confusing—is `fusd_token_account` a `Account<'info, Mint>`? It sounds like it would be a `Account<'info, TokenAccount>`, which won't work
```impl<'a, 'b, 'c, 'info> From<&MintCtx<'info>> for CpiContext<'a, 'b, 'c, 'info, MintTo<'info>> {
    fn from(accounts: &MintCtx<'info>) -> CpiContext<'a, 'b, 'c, 'info, MintTo<'info>> {
        let cpi_accounts = MintTo {
            mint: accounts.fusd_token_account.to_account_info(),
            to: accounts.to_account.to_account_info(),
            authority: accounts.cpi_auth_account.to_account_info(),
        };
        let cpi_program = accounts.token_program_account.to_account_info();
        CpiContext::new(cpi_program, cpi_accounts)
    }
}
```
if i am using the above, does `fusd_token_account` need to have the mint authority of `cpi_auth_account`?


///////////////////////////////////////////////////////////////////////////////////////////////

From 300 onwards are custom error which we declare inside the program from 100-299 they are anchor defined system error which you can find here :  https://github.com/project-serum/anchor/blob/master/lang/src/error.rs
I have another question about this...for future custom program errors...is the number (whether it's fifth, sixth, third, etc) always two higher than the code? So in that case it was 304 and you said the 5th one down...which was correct btw. I ask because I have another which is Error code 167 which I'm wondering is the 3rd one down...?
woah this is cool
there isn't any cli command to gen a new keypair + replace the program id in `declare_id()` and `anchor.toml` is there?:)
thanks!
given that solana did not have any tutorials etc. a couple months back
ah this is you! I watched all your videos, they were pretty good honestly
yeah this is the only problem with the Solana token program. You can't extend the functionality of the token like you can with eth
can u add me, i was wanting to ask you about something
yeh, my name henry
oh wait, ur henry?
honestly, probably never going to make another video after this
You're the absolute boss
https://youtu.be/7D7fKcZond8 <@!199918208436797449>
i don't have much public stuff at the moment
<@!248066053161222144> Could you teach me your github URL?
I hope to follow it.
I understood, Thank you so much
but like i said, you can make your own program that owns all the token accounts or is the only program allowed to move tokens between accounts
people will not be able to use your token with phantom
there are alternative options but you will need to design them yourself
How about making new token program that extends the SPL Token program?
you cannot
<@!248066053161222144> I think my explanation was poor. sorry.
I'm going to make a token<GOL>(1) what applies 5% fee.
Goal is that if Alice sends 100 token to Bob, Bob receives 95 and a service(fixed address) receives 5.
When Alice sends the token by **the wallet(Phantom)** to Bob(2), I need to apply fee(5%) too.
How can I do make like this token?
has anyone ever faced and solved this issue?
```
error[E0080]: evaluation of constant value failed
  --> /usr/local/cargo/registry/src/github.com-1ecc6299db9ec823/switchboard-utils-0.1.32/src/lib.rs:19:18
   |
19 | #[derive(Default,AsBytes,FromBytes,Clone,Debug)]
   |                  ^^^^^^^ attempt to divide `1_usize` by zero
   |
   = note: this error originates in the derive macro `AsBytes` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0080`.
error: could not compile `switchboard-utils` due to previous error
```
This seems to be exactly what I was looking for. Thank you ser
compiling now
The weird hack we have noticed that seems to work: The users are able to do the transactions successfully if they transfer the NFT from their existing wallet A (where the NFT sits) to their another wallet B, and then perform the transactions from their second wallet B.
Not sure why, but that's what it's saying
Ok, yeah, that's the token program telling you that the source account doesn't actually have enough tokens
This is a snapshot of the error log that was printed when the transaction was executed. I hope this helps.
Where can I see the video?
Do you have a full program log to look at?
Hey guys <@!134416332509675520> 
There's an unusual error users are facing on our platform. Our contract has a transfer instruction that transfers the NFT from the user's wallet to another account. Many users' transactions fail because of the "custom error: 0x1 insufficient funds" error, even though they have enough SOL as well as the NFT in their wallet for the transaction.
Are there any other reasons due to which this error might be occurring? Should we be looking at something specific? Thanks! 🙂
👍 👍 👍
the keyboard tapping is too much
might just rerecord again later
and i used my laptop mic this time instead of the professional mic
and 45 minutes of that is just setting up the mint accounts and token accounts using classic solana commands 😅
but it's 55 minutes long
ok recorded a video
I appreciate your effort. I'll try to find the way.
you have to think about the problem more sorry
sorry, I didn't get the point.
How can I do?
you have to make them send the transaction to your program
so I hope to know how to override the transfer of SPL Token program or inject my logic?
Regards
Thank you.
I made a program what transfers the token and at that time, I had applied fee.
but if the user doesn't use my program and transfer the token on Wallet directly, I can't apply fee because it **doesn't call **my program.
does anyone know how to write a client which communicate with solana program is written with anchor? Is it possible with web3js or other programming libraries
That would be very useful for a lot of people
Just for you Louis I feel inspired to record a very simple cookbook style video that shows how to make a wrapper for sending tokens from one account to another via spl token CPI
And I think I could do it with a SPL token with a 1 supply
I'm trying to emit a NFT for each gif link
I did the buildspace tutorial on anchor, we coded a smartcontract that store gifs links and I'm trying to upgrade it just to learn how to code
But I think Brian friel has done more recent tutorials, not 100% sure what they're on though, sorry
That's precisely what I'm looking for
But in this video I do go through a CPI transfer of the spl token program
There is definitely a more up to date version though
Oh noice
https://youtu.be/i6Ycr5nhjH8
It would be super dope
You're right, i need to ask Armani about pinning stuff in there maybe
I made some videos a while ago but they're out of date
I already checked this channel but there's a lot in it so maybe i missed something
I haven't looked at them tbh
Ok thanks !
Check <#889606719829835816>
I found some in pure solana but not in anchor
You can make a program which does CPI to the spl token program to transfer funds
Do you have an exemple of those tutorials in anchor ?
Like I said, you need to go through some tutorials
is there any package which can resolve .sol addresses?
Can I make the program that extends the SPL Token program?
May I ask one?
<Or write a program to do that> I think so I should make a program.
Thank you.
Or write a program to do that
No you would need to either apply a separate instruction or transaction in which you take a fee
when using the SPL Token, it is possible to apply fee?
The point is that I have to apply the fee when the users send the token through their Wallet in direct.
and I used the SPL Token.
Thank you.
I already understood smart contract.
But you need to go through some tutorials first
You can do this using a program
Do you understand the basics of smart contract programming?
Hi Everyone.
Hope you all are doing good.
May I ask about token?
I'm going to make a token.
I want to apply fee when the user sends the token via wallet.
To do this, I think I can't use standard SPL Token.
Could you give me a sample code?
Regards
The current state of the blockchain could look different than in the past. No blockchain stores its own history as part of the active state (except via the hash of the previous block data that links blocks together)
It's a blockchain. There is a history of the state of every block that ever happened
Nope, you need to store the seed somewhere. It's not possible to go from pubkey back to seeds unless you have a quantum computer
Have you looked at the lib.rs there is an example of using seeds with account loader? Does this not work for you <https://github.com/project-serum/anchor/blob/1c5c6a8aba817d9a1e1ae49ad5c95c845cda5530/tests/zero-copy/programs/zero-copy/src/lib.rs#L108>
Hey degens,  hope you all are doing absolutely great. Just want to clarify one doubt.

In solana we have to pay rent for accounts (both type data and program). If we don't able or want to pay rent for next epoch, our accounts, get wiped off from solana cluster. Is that mean there is no concept of **permanent history on solana**.
Or its more like solana acts only as ram, there is no concept of ssd/hdd in solana.
what's the error you are getting when running this test ?
If anyone can provide sample code. I will be very thankful 🙏
Hi Everyone.
Hope you all are doing good.

I am new to solana and rust. Can any one help me how can i create token staking contract in anchor, rust. I created one in solidity but i dont understand how can i do this in rust..
<@!832140329301311488> I suppose the question is, how would I integrate what you recommend into my system?
but yes, mocha tests indeed
but I'm not sure how that would work
I'm trying to use the `claim` handler
<@!832140329301311488> 
https://github.com/AJTJ/dutch_auction/blob/master/tests/test_anchor.ts#L70
just the default
U r writing mocha tests ?
let provider = anchor.Provider.env();
  anchor.setProvider(provider)
hm, I'm getting `Property 'confirmTransaction' does not exist on type 'Provider'.`
you are much appreciated
```let payer = anchor.web3.Keypair.generate();

await provider.connection.confirmTransaction(
      await provider.connection.requestAirdrop(payer.publicKey, LAMPORTS_PER_SOL),
      "confirmed"
    );```
Are there any simple resources for understanding that?
I'm struggling with how to create a dummy account in my `test.ts` in order to make a transfer of lamports in my program.
Will a `0x1` error or `Error: insufficient funds` error occur only ever be because the payer doesn't have enough SOL? The account I'm signing the transaction with has 5+ devnet SOL in this case
Is there a way to get the seed for a mint after it has been created?
be good to get some clarification
wait a minute, unless it's derived from a ProgramAccount via to_account_info()
looks like you can overrite it
nice! what was the answer? in case anyone searches later on
nvm i have my answer
Hey, when I write to the data of an AccountInfo struct. Is index 0 the first index after the discriminator or is it possible for me to overwrite the discriminator accidentally?
hey all, tl;dr my goal is to create a zero copy account that lives at a PDA address. struggling with it. It seems I cant use anchor `init`, as i need to allocate with a separate instruction. Maybe it's possible to create and allocate the space for the account client side, and then transfer the address of the account to a PDA via a rpc instruction? Working off of this example here: https://github.com/project-serum/anchor/blob/1c5c6a8aba817d9a1e1ae49ad5c95c845cda5530/tests/zero-copy/tests/zero-copy.js#L147
98% of problems I have somehow <@!134416332509675520>  has already solved <:pepehype:410519976995454987>
Regards
Could you give me a sample code?
I'm going to make a token.
I want to apply fee when the user sends the token via wallet.
To do this, I think I can't use standard SPL Token.
Hello, Nice to meet you.
May I ask about token?
talking about front ends, I might have found the state of the art: https://blog.sia.tech/announcing-homescreen-decentralized-frontends-for-web3-113a3564530d
yes: https://github.com/project-serum/anchor/blob/423ddde30af8ba7de29e3de09a77e8a1254d9766/lang/syn/src/idl/file.rs#L136
ok cool
It's automatic unless you go out of your way to use a different one in your #[error] enum
Oh so this offset is applied automatically? Or is this const for us to use.
New versions of anchor do this, yeah: https://github.com/project-serum/anchor/blob/master/lang/src/lib.rs#L306
I saw that Anchor lang error codes got updated. Does that mean we now should set the application-level Error enum to start at >5000 to avoid mixing up the range?
And made a README about it! Nice. I'll check it out. I actually already developed some stuff on Solana but it's time to really understand why stuff works rather than just getting them to work, if you know what I mean haha
I went the traditional route:) https://github.com/ilmoi/solana-onboarding
jumping into the deep end, that's awesome man
I think I'll just hang around here and question-hitchhike my way to learning Rust
Code-as-doc all the way haha
It seems to check initialization and ownership
thanks, super useful!
https://github.com/project-serum/anchor/blob/master/lang/src/account.rs#L36
Pretty sure it will do it automatically
will this do the standard anchor checks (eg disc) or do I need to do manually?
Account::<TheType>::try_from, not bad
Ah, cool, I wasn't sure how to specify the generic like that
Think you ought to be able to use `let account: Account<'_, TheType> = Account::try_from(the_account_info)?;`
trying!
nice!
https://github.com/project-serum/governance-registry/blob/89ef88aef0281b5b3b321369ca2e5eb635be8e10/programs/governance-registry/src/lib.rs#L350
Hmm all the references I can find don't deserialize, because they simply use the remaining_accounts as input to CPIs
Actually I  guess `try_from` would be the first thing to try, before going **unchecked** lol
let me try
that's a good idea
I know that client side I've use `try_from_unchecked`  or something like that. Not sure if that's usable program-side
I see. Let me see if I can find an example
kinda like this: `Metadata::from_account_info(&ctx.accounts.gem_metadata)` but for my own custom accounts
so it's already `AccountInfo` - what I now need is to get it into `Account<Whatever>`
then you could use `.to_account_info()` as per usual, no?
exactly
yup
Is that where you'd use `remaining_accounts`?
context: it's an optional account so I can't deserialize inside the validator struct like I would normally 😦
how would I deserialize an anchor-prepared account from inside the handler?

ie I want to do use this: `AccountInfo<'info>`

instead of this: `Account<'info, DesiredAcc>`

and deserialize manually. is there some sort of method like `try_from`?
you asked for an update, installing the pre-release version of solana 1.8.8 made it work without any other change
thanks!
well I'll be damned... solana 1.8.8 works 🤦‍♂️
<@!707604162673639504> but there's no web3 native version for hosting a next.js app?
as a side node... every time I update solana with a checkout, whenever I try to run it I get back 
```
zsh: killed     solana --version
```

i have to restart the computer for it to work again... do you have the same experience and know a workaround?
Yeah, not 100% sure this is necessary, but that's what I'm running on M1 and don't have the same problem you're seeing
oh shit... there are stable pre-releases...
on git
latest stable seems to be 1.8.5
you mean a non stable version of solana?
Compiling solana itself from a git checkout
I meant solana 😛
anchor
Sorry, do you mean anchor 0.19.0, or solana 1.9.0 (confusing lol)
using 0.19.0 still gives me the same error... 😦
it's not like you spend 2 days getting stupid ec2 to do what you want
it's 1 click deployment
you can probably try both within the span of an hour
nope havent tried
<@!707604162673639504> have you used vercel?
I couldn't have more positive things to say - especially after coming from aws + terraform deployment background 😄
give netlify a go
<@!707604162673639504> it is a next.js app that serves the react app. Everything else is on solana and filecoin
my experience with netlify has been amazing, assuming it's pure front-end, no backend
a lot of people use Vercel I believe
got it
then wait 1-2s, then let the test run
no I create one before each test in  a `before()` statement
Is it still using a gcloud/aws/vercel/heroku? or are people using other options to host web3 frontends?
what's the best practice state of the art for doing that for a dapp? Like what's the best way to host a react app in the web3 world?
So you created it once, dumped it to file, and then used that file in test.genesis?
Hi guys I have a question about the best practice for hosting the frontends for the dapp
1-2s with `anchor test` worked
1-2s pause did the trick, for the metadata account creation? I remember having to wait much longer when using that `create_metadata_accounts` command
to be fair, the test.gensis part worked flawlessly. But creating a metadata account and getting the program to correctly read it was like a 2h job 😄
Not a mod or anything, but it could be good to avoid pinging on every message 😄
You can't deploy multiple accounts to the same address, so it'll fail
<@!134416332509675520> what happens if I try to use a keypair that's already been used by somebody else?
For some reason I thought it was magic-er than that, good/bad to know lol
<@!134416332509675520> so it is autogenerated by anchor?
Oh, really
so I thought I'd share
it's just that it took A LOT of dancing around
yeah it did, the steps above are for test.genesis
No, I mean the keypair in `target/deploy/<yourprogname>-keypair.json`
Ah, so the test.genesis thing didn't work?
<@!134416332509675520> by deploy keypair, do you mean the wallet address and private key?
If you want to use a different keypair on different clusters, then yeah, you'll have to edit the declare_id again (and then remember to *rebuild*!)
The deployed program_id depends on the target/deploy keypair
also if I deploy it on a different machine or chain, it's going to have a different program id, whereas the it's hardcoded in declare_id? <@!134416332509675520>
oof finally got this working! for anyone trying this in the future:

1. go build the token metadata program
2. drop the built .so file into a directory of your choice
3. set a path to that dir like in the example Alan linked
4. you'll need to create a metadata PDA js-side. It's painful, best shortcut I found is this - https://github.com/metaplex-foundation/js/blob/main/src/actions/createMetadata.ts
5. (!) IMPORTANT - after you create the pda pause your execution (use an async pause function) for 1-2s. Yes, even on localnet this is necessary and was the reason I wasted a good hour figuring out why test kept crashing
6. Finally here's the validator I wrote
```rs
fn assert_valid_metadata(
    gem_metadata: &AccountInfo,
    gem_mint: &Pubkey,
    metadata_program: &Pubkey,
) -> bool {
    // 1 verify the owner of the account is metaplex's metadata program
    assert_eq!(gem_metadata.owner, metadata_program);

    // 2 verify the PDA seeds
    let metadata_seed = &[
        b"metadata".as_ref(),
        metadata_program.as_ref(),
        gem_mint.as_ref(),
    ];
    let (metadata_addr, _bump) = Pubkey::find_program_address(metadata_seed, &metadata_program);
    assert_eq!(metadata_addr, gem_metadata.key());

    true
}
```
what would be the declare id the first time we're deploying?
<@!134416332509675520> thanks it worked
But you need to be careful to edit the `declare_id!` and then *rebuild* before re-deploying
Right, that's expected (you haven't changed it)
Ok, do you also run `anchor build` or something?
it shows the same program id as before
<@!134416332509675520> I did run solana program deploy /Users/prikshetsharma/Desktop/mibexy/target/deploy/mibexy.so
Like, if you make a change, how do you actually see its effect?
After you changed the `declare_id!`, what did you do?
<@!134416332509675520> I don't know how to deploy?
I guess it's running on your local validator?
How are you deploying it though?
<@!134416332509675520> I'm running with: clear && ANCHOR_WALLET=/Users/prikshetsharma/my-solana-wallet/my-keypair.json node client.js
At any rate, the mismatch I describe above is 100% a problem and will lead to the error message you see (there are other ways to get the error too though)
I'm saying it's the cause of that error 😛
How are you running the program? Are you deploying it? Or just using `anchor test`, no deploy?
Could it have something to do with:
Error: 167: The given account is not owned by the executing program
<@!134416332509675520> still getting the error after replacing the declare_id with this id
Whoops, what @.manOs said!
If you look at this program log here, your program id is 3Hu85D1dwvdXobYuN6A8A4Xe6joKFVw5QYK9fNFDN2Jc, which doesn't match your `declare_id!`
Could it just be a mismatch in the address to which the program gets deployed?
`declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");`
vs.
`const programId = new anchor.web3.PublicKey('3Hu85D1dwvdXobYuN6A8A4Xe6joKFVw5QYK9fNFDN2Jc');`
Ok things are constantly moving, it seems the Anchor lang error codes have changed since I last looked/cloned. Now it spans a much bigger range. However I don't think you are running that version just yet so what I wrote above still holds (and the general concept remains)
At least that's the starting point
Bookmark:
- https://www.rapidtables.com/convert/number/hex-to-decimal.html
- https://github.com/project-serum/anchor/blob/master/lang/src/error.rs

You will likely come back there **often** if you're anything like me.
Here you will find that 0xa7 is 167 in decimal. If you are using anchor, any error code thrown in the 100 - 300 means you face an Anchor lang error (and not a *application-level* error).

In this case the error is:
```rust
    #[msg("The given account is not owned by the executing program")]
    AccountNotProgramOwned,
```
How do I fix this?

g
But running this code like so:
```
clear && ANCHOR_WALLET=/Users/prikshetsharma/my-solana-wallet/my-keypair.json node client.js
```
And the following client.js:
```
// client.js is used to introduce the reader to generating clients from IDLs.
// It is not expected users directly test with this example. For a more
// ergonomic example, see `tests/basic-0.js` in this workspace.

const anchor = require('@project-serum/anchor');
const { SystemProgram } = anchor.web3;

// Configure the local cluster.
anchor.setProvider(anchor.Provider.local());

async function main() {
    const idl = JSON.parse(require('fs').readFileSync('./target/idl/mibexy.json', 'utf8'));
    const programId = new anchor.web3.PublicKey('3Hu85D1dwvdXobYuN6A8A4Xe6joKFVw5QYK9fNFDN2Jc');
    const program = new anchor.Program(idl, programId);
    const postAccount = anchor.web3.Keypair.generate();
    await program.rpc.post("Hello World!", {
        accounts: {
            postAccount: postAccount.publicKey,
            user: program.provider.wallet.publicKey,
            systemProgram: SystemProgram.programId
        },
        signers: [postAccount]
    });
}

console.log('Running client.');
main().then(() => console.log('Success'));
```
I have the following lib.rs:
```
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod mibexy {
    use super::*;

    pub fn post(ctx: Context<Initialize>, data: String) -> ProgramResult {
        let post_account = &mut ctx.accounts.post_account; 
        post_account.post = data;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 128)]
    pub post_account: Account<'info, Post>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program <'info, System>,
}

#[account]
pub struct Post {
    pub post: String
}
```


///////////////////////////////////////////////////////////////////////////////////////////////

saw some stuff in discord searches about using `UncheckedAccount` & deserializing manually in the handler itself, but wanna better understand if that's correct / considered best practice for my situation
hey all, seems like i'm blowing the stack frame limit with one of my larger account structs (2412 bytes for this specific account type, still below the limit itself iiuc). when i `Box` the account, it removes the error for my specific instruction handler, but still has one for `try_from_unchecked`
```bash
Error: Function _ZN11anchor_lang7account16Account$LT$T$GT$18try_from_unchecked17h82f26aa417ce691eE Stack offset of -7440 exceeded max offset of -4096 by 3344 bytes, please minimize large stack variables
```
in addition to `Box`ing the `Account`, do i need to do some additional work to prevent anchor from allocating vars to the stack during deserialization?
yup
thanks!
https://github.com/project-serum/anchor/blob/master/ts/src/program/namespace/account.ts#L216
Just out of curiosity, is `program.account.x.all();` a wrapped `getProgramAccounts` call ? (with filters I suppose)
thanks guys!
yeah, just got what he meant, that's actually right
My understanding could be flawed though lol
Your explanation is not at fault, but I am not understanding 100%. My general understanding is that however simple/complex the program is, if you want to manipulate a set of accounts (send SOL, set_authority, etc) you **need** to pass each and every one of them in the call that mutates them.
In your case that would mean pass all the beneficiaries, and the issue then becomes "how can I fetch the beneficiaries to build the call?", which could be achieved through storing the vector of Pubkeys in an account at initialization time, and fetching them before building the call, as alan mentioned.
The thing is that in my program, a token owner will first store this set of accounts and later every time that someone else trades the token, a specific amount of SOL (taken from the transaction fee) will be send to these accounts previously stored. So the processes of setting the accounts that you want to automatically send the fee and send the sol occurs in different moments and with different users. That’s why I can’t do what you are suggesting, do you get what I mean? hope i was clear
so if you have something like:

```rust
#[derive(Accounts)]
pub struct MyEndpoint<'info> {
   pub signer: Signer<'info>,
   pub thing: Account<'info, BaseAccount>,
}
```
and pass 3 accounts in the call, the third one would end up in `ctx.remaining_accounts`, and you would handle it (validation + business logic) manually in the function
And then in order to send them sol, you'd have to then eventually pass all of them back into your program from the client
I don't think that's how you use `remaining_accounts`. Instead, I would say that the `ctx` object you get in the program endpoint stores all accounts which have not been deserialized according to your 
```
#[derive(Accounts)]
pub struct MyEndpoint<'info> {}
```
 struct
You would have to just store their Pubkeys
so I wanted to do something like this, but this doesn't work

`#[account]
pub struct BaseAccount<'info> {
    pub remaining_accounts: Vec<AccountInfo<'info>>,
}`
my program needs to store a variable number of accounts to later send some SOL to them
Might honestly be easier with the `remaining_accounts` feature, not sure.
No, still have to write them out manually 😬
Just wanted to ask, has the array-support changed?
i.e. is something like this (array of length 8) allowed as input? or do I still have to manually write out all of them?
```
#[derive(Accounts)]
pub struct Example<'info> {
    #[account(mut, signer)]
    pub authority: AccountInfo<'info>,
    pub array_of_accounts: [Account<'info, ExampleAccount>;  8] 
}
```
It worked! thanks so much for the explanation too, really appreciate it.
Whereas with an associated token account, it lives at an address derived from the associated token program, so doesn't (can't!) sign from the client
What you've written above implies that the token account will live at a keypair address, and hence need to sign from the client
You'll need to change that to be `associated_token::` rather than `token::`
So I just ran it with this code:
```
  #[account(
    init_if_needed,
    payer = payer,
    token::mint = token_mint,
    token::authority = payer,
  )]
  pub to_token_account: Account<'info, TokenAccount>,
```

and got this error:
`Translating error Error: Signature verification failed`
Can't help without more information than that 😛
Hi Alan, I initially tried that and was getting a different error...
You'll either have to initialize it on the client, or do some kind of `init_if_needed` thing in your anchor program
So the `to_token_account` isn't an actual TokenAccount, which triggers that error (rather than being owned by the spl token program, the account is owned by the system_program, because it hasn't been initialized yet)
You likely haven't initialized a token account for the destination (you're passing an uninitialized account there, not an actual token account)
Program:
```
anchor_spl::token::transfer(
  CpiContext::new_with_signer(
    ctx.accounts.token_program.to_account_info(),
    anchor_spl::token::Transfer {
      from: ctx.accounts.from_token_account.to_account_info(),
      to: ctx.accounts.to_token_account.to_account_info(),
      authority: ctx.accounts.from_token_account.to_account_info(),
    },
    &[&[
      ctx.accounts.token.key().as_ref(),
      &[ctx.accounts.token.token_bump],
    ]],
  ),
  100,
)?;

...

#[derive(Accounts)]
pub struct Send<'info> {
  
  #[account(mut)]
  pub token: Account<'info, TokenData>,
  
  #[account(mut)]
  pub payer: Signer<'info>,
  
  // This is the PDA.
  #[account(mut, seeds = [token.key().as_ref()], bump = token.token_bump)]
  pub from_token_account: Account<'info, TokenAccount>,

  // This is the token account owned by `payer`.
  #[account(
    mut,
    // associated_token::mint = token_mint,
    // associated_token::authority = payer,
  )]
  pub to_token_account: Account<'info, TokenAccount>,

  #[account(address = token.token_mint)]
  pub token_mint: Account<'info, Mint>,

  pub system_program: Program<'info, System>,
  pub token_program: Program<'info, Token>,
}

```
Hi guys, I have a PDA that stores some SPL token, but when I try to send tokens from the PDA to a random token account I get the below error. The account receiving the tokens (`to_token_account`) doesn't need to be owned by the program and I can't figure out where I'm going wrong.

Error:
```
Error: 167: The given account is not owned by the executing program.
logs: [
  'Program 7MUa3HbbMEuBiqg2b5qPS8Qyeqtuh5HFD8LHvYpUBhvg invoke [1]',
  'Program log: Custom program error: 0xa7',
  'Program 7MUa3HbbMEuBiqg2b5qPS8Qyeqtuh5HFD8LHvYpUBhvg consumed 6397 of 200000 compute units',
  'Program 7MUa3HbbMEuBiqg2b5qPS8Qyeqtuh5HFD8LHvYpUBhvg failed: custom program error: 0xa7'
]
```

Client:
```
const payer = anchor.web3.Keypair.generate();
const [payerToken] = await anchor.web3.PublicKey.findProgramAddress(
  [ 
    payer.publicKey.toBuffer(),
    spl.TOKEN_PROGRAM_ID.toBuffer(),
    tokenMint.toBuffer() 
  ],
  spl.SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,
);
...
await program.rpc.send({
  accounts: {
    token: account.publicKey,       // The wallet that created the token PDA.
    payer: payer.publicKey,         // A random 'user' wallet.
    fromTokenAccount: tokenPda,     // The token PDA.
    toTokenAccount: payerToken,     // The token account that should receive the tokens.
    tokenMint: tokenMint,           // The token's mint address.
    systemProgram: anchor.web3.SystemProgram.programId,
    tokenProgram: spl.TOKEN_PROGRAM_ID,
  },
  signers: [
    payer,
  ],
});
```
Yeah, the state address would be just a regular program-derived address, based on whatever seeds you pick etc.
<@!134416332509675520> thank you 🙂 now the program can compile. 

Another question: if I want to use account client to retrieve the account, ex: `program.account.myAccount(<adddress>)`, I should calculate the state account beforehand. So I suppose the PDA is derived the `program_id` and the given seed?
Not totally sure what you mean, can you say more?
Okay thanks, I did that + reinstall anchor cli, it now works
Ah, ok, not sure what's up there—you'll have to figure out what is outdated about your system, since 1.7.15 is old (the latest is more like 1.8.6 or something, or even 1.9.0 if you're installing from master)
I tried it
```▲ (Kens-MBP.local) solana-twitter solana-install update
Install is up to date. 1.7.15 is the latest compatible release
```
Think you'll need to update your solana install (1.7.15 is quite old)
I only did `anchor init ... && anchor build`
Hi guys, i'm running into this issue and I cant quite figure it out:
```
▲ (Kens-MBP.local) solana-twitter anchor build              
BPF SDK: /Users/kkakura/.local/share/solana/install/releases/1.7.15/solana-release/bin/sdk/bpf
Running: rustup toolchain list -v
Running: cargo +bpf build --target bpfel-unknown-unknown --release
error: failed to download `solana-frozen-abi v1.9.0`

Caused by:
  unable to get packages from source

Caused by:
  failed to parse manifest at `/Users/kkakura/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-frozen-abi-1.9.0/Cargo.toml`

Caused by:
  feature `edition2021` is required

  consider adding `cargo-features = ["edition2021"]` to the manifest
```
Any idea please ?
The equivalent to state would e.g. be a PDA with static/fixed seeds, like `seeds = [b"the-state".as_ref()]` (or whatever you want to call it).
Hi, is it possible to store a set of remaining accounts in my program's account?
```
use of deprecated macro `state`: #[state] will be removed in a future version. Use a PDA with static seeds instead
```

Hi <@!501570363566587905> , I wonder what is the proper syntax to replace `state` with PDA + static

From this line:

https://github.com/project-serum/stake/blob/armani/cfo/programs/lockup/src/lib.rs#L18
nvm, node 16 solves the problem
thanks for the info, switching to node 16 does help get away from the FetchError, though now I run into a second error 🤔
i cant find anchor.Wallet in @project-serum/anchor ts 0.19.0
``
thread 'main' panicked at 'Inside a workspace', cli/src/lib.rs:1099:47
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
``
when i run this i get a panick
does anyone happen to have some extra devnet SOL?
``anchor idl fetch <pk>``
from just its pk
how can i tell if a program is created with anchor or without?
Oh, I think this is good idea. 
but I'm not sure. but can you sign when mint the token?
Maybe you should set PDA for mint authority.
I hope you try it.
That wouldn't require a new token program?
Is it possible to set the mint authority as another program, and have that program automatically mint new tokens?
How do I do that?
Hi, I think you should deploy new token program first what extends SPL Token program.
The list of wallets is stored in another program
To certain x wallets changing each time
I tried sending `purchaser` tokens in order to complete the transaction
Hey mate,  I'm getting this error
```
Error: failed to send transaction: Transaction simulation failed: This account may not be used to pay transaction fees
```
I'm wondering if perhaps the `purchaser` was not instantiated correctly
```ts
    const authority = provider.wallet;
    const purchaser = anchor.web3.Keypair.generate();

    await provider.connection.confirmTransaction(
      await provider.connection.requestAirdrop(purchaser.publicKey, 3000),
      "confirmed"
    );

    await program.rpc.claim({
      accounts: {
        auction: provider.wallet.publicKey,
        authority: authority.publicKey,
        purchaser: purchaser.publicKey,
      },
      signers: [purchaser],
    });
```
How are the new tokens supposed to be distributed?
That the mint authority can’t manipulate at will?
How do you program a constant yearly inflation rate?
Is it possible to set an inflation rate on spl token?
thanks!
```
await program.rpc.claim({
      accounts: {
        auction: provider.wallet.publicKey,
        authority,
        purchaser.publicKey, <-- here
      },
      signers: [purchaser]
    });
```
since `purchaser` is of type `Signer` you need to pass the publicKey of it in the `accounts` map
`Signer` is a wrapper around `AccountInfo`. All `AccountInfo` fields expect publicKey from the client
sorry, could you explain that one a bit more? I'm not entirely sure what I'm missing!
`purchase.publicKey` in `accounts` list
<@!401533121817739265> for this function
```
    await program.rpc.claim({
      accounts: {
        auction: provider.wallet.publicKey,
        authority,
        purchaser,
      },
      signers: [purchaser],
    });
```
```
     TypeError: x.pubkey.equals is not a function
```
https://docs.rs/spl-token/latest/spl_token/state/struct.Mint.html
decimals is of type u8. so thats the limit
Hi I am trying to get USDC from devnet faucet
Is there a limit on the number of decimal points?
needed to dereference twice
nvm
<@!401533121817739265> I'm getting an error here with both of these
```rs
purchaser.try_borrow_mut_lamports()? -= current_price;
authority.try_borrow_mut_lamports()? += current_price;
```
```
let current_price: u64
binary assignment operation `-=` cannot be applied to type `std::cell::RefMut<'_, &mut u64>`
```
why not? depends on how many decimal points you specified in the mint.
yes exactly
This makes so much sense, because every transaction *needs* a signer doesn't it?
0.5 token for example?
Can an spl token be fractionalized?
getting this error:
```
node_modules/@project-serum/anchor/dist/cjs/idl.d.ts:71:35 - error TS1005: ',' expected.

71     array: [idlType: IdlType, size: number];
```
Hello
that makes sense
```
await program.rpc.claim({
      accounts: {
        auction: provider.wallet.publicKey,
        authority,
        purchaser,
      },
      signers: [purchaser]
    });
```
in your test pass `purchaser` as a signer
ohh, this makes sense.
if its not, then you can directly transfer lamports to the authority
For this to work, you'd have to declare `pub purchaser: Signer<'info>,` to `Claim`. 
```
#[derive(Accounts)]
pub struct Claim<'info> {
    #[account(mut)]
    pub auction: Account<'info, Auction>,
    pub authority: AccountInfo<'info>,
    pub purchaser: Signer<'info>
}
```

and then try transferring `current_price` amount of lamports from `purchaser` to `auction` which I presume is a PDA
no problem, thanks for your time! First I would like `purchaser` to "purchase" by spending some lamports
sorry I thought you wanted to transfer the auction to the purchaser and close it.
does that make sense?
since it is `purchaser` spending the money, right?
oh I see.
I mean, I would want to pass lamports from `purchaser` to `auction`
for this to work, `auction` must be a PDA. Otherwise there is no way for `purchaser` to get the auctioned lamports
`auction.close(ctx.accounts.purchase.to_account_info())?;`
basically you would need to transfer the lamports from `auction` account to `purchaser` account. You could just close the `auction` account and pass `purchase` account info in to it
is `auction` account a PDA?
<@!401533121817739265> maybe this is more representative of my relative lack of knowledge in the process. Basically, I imagine that I would like an `authority` who creates/starts the auction, and then I would like a `purchaser` who bids/purchases the item.
yea, it isn't used yet I'm not sure how to include it.
what is purchaser's role in the program? I don't see it being used in the rust code
is the purchaser the authority?
oh interesting, but that doesn't send the `purchaser` info does it?
yeah so your authority is a Signer here. You would have to pass signers list in your rpc call
```
await program.rpc.claim({
      accounts: {
        auction: provider.wallet.publicKey,
        authority,
      },
      signers: [authority]
    });
```
I tried including `purchaser` info in there at one point
of course, thanks!
```rs
#[derive(Accounts)]
pub struct Claim<'info> {
    #[account(mut)]
    pub auction: Account<'info, Auction>,
    pub authority: Signer<'info>,
}
```
<@!454291700945387520> could you post what your `Claim` struct looks like?
trying all sorts of things
trying to figure out how I would write the test for this
```ts
  it("The price can be paid, ending the auction", async () => {
    const authority = provider.wallet.publicKey;
    const purchaser = anchor.web3.Keypair.generate();

    // await provider.connection.confirmTransaction(
    //   await provider.connection.requestAirdrop(purchaser.publicKey, 2000),
    //   "confirmed"
    // );

    // await provider.confirmTransaction(
    //   await provider.connection.requestAirdrop(purchaser.publicKey, 2000),
    //   "confirmed"
    // );

    // let purchaser = await serumCmn.createAccountRentExempt(
    //   program.provider,
    //   purchaserId.publicKey,
    //   300000
    // );

    await program.rpc.claim({
      accounts: {
        auction: provider.wallet.publicKey,
        authority,
      },
    });

    const account = await program.account.auction.fetch(authority);
    console.log({ account });
  });
```
<@!832140329301311488> 
I'm trying to figure out how to write a test that will perform this transaction correctly for the `claim` endpoint.
Obviously I need to send it the `purchaser` data, but I'm not sure how, I understand that the purchaser would need to sign the smart contract somehow.
```rs
    pub fn claim(ctx: Context<Claim>) -> ProgramResult {
        // NOTES FOR PROD
        // - This is not proper escrow software
        // - Currently the purchasing account is just paying to end the auction. They deserve a prize eventually.

        let auction = &mut ctx.accounts.auction;
        let authority = &mut ctx.accounts.authority;

        if auction.is_ended {
            msg!("auction is ended");
            Ok(())
        } else {
            let clock = Clock::get()?;
            let current_timestamp = clock.unix_timestamp;

            // end the auction if it is past the end_time
            if current_timestamp as u64 > auction.end_time {
                auction.is_ended = true;
                msg!("auction is ended");
                Ok(())
            } else {
                let authority_info = authority.to_account_info();
                let current_price =
                    get_current_price(current_timestamp, auction.slope, auction.y_intercept);
                // HERE I WOULD LIKE TO TRANSFER THE FUNDS
                // let taken = purchaser.try_borrow_mut_lamports -= current_price;

                auction.is_ended = true;
                Ok(())
            }
        }
    }
```
At the very least you need some kind of instructions file
Is there a way to make a CPI without importing the actual library of the program?
Thanks! I now see what the error is!
https://www.notion.so/Debugging-Custom-Anchor-Errors-b8540dd418c44a4e939ab17c56a3fd3b
got it, thx! 🙂
In general you have to CPI to it, unless someone has written some anchor-y helper functions (e.g. how anchor_spl works)
hey guys, when I have external program dependencies like this here: https://github.com/project-serum/swap/blob/master/Anchor.toml

what is the the best way to make RPC calls to the program? is there some anchor-way to elegantly interact with it, or do I have to do standard solana CPIs to interact with it?
The video doesn't even cover PDAs or any of the anchor constraint tokens
Over half the video length is spent just setting up the accounts. Can't wait for anchor to have first class support for spl token program


///////////////////////////////////////////////////////////////////////////////////////////////

i'm developing an anchor app in react locally.

assume some transaction X.

sometimes, this transaction fails (computational budget exceeded), always prefaced with the first screenshot.

sometimes, it succeeds, always prefaced with the first screenshot.

what's going on?
I don't know about the ability to use env vars, but if the issue is setup sharing, why not track the localnet keypairs in the repo?
is there a way to include the programId inside `Anchor.toml` and inside `lib.rs` through an environment variable? the typical rust-approaches, fail, but it's quite cumbersome to do version control / collaborate with multiple users on local-net with this logic
oh really just simple I already did it then 😅  thanks
If all you want is to check the seeds/bump, just use the `seeds = [...], bump = the_bump` constraints (no init)
Does anyone know how to advance the blockhash in anchor test?

 I was working on tutorial 2 - the increment counter, and decided to call increment twice in the test. Anchor test gave me the error : 

Error: failed to send transaction: Transaction simulation failed: This transaction has already been processed

I checked and it seems it might be because the anchor simulator does not advance the blockhash, so sending the same command twice in the same blockhash is blocked because it would lead to a double spend attack
I notice with `init_if_need` just check `seed/bump` if the account is already created but it's not ideal for me because I don't want to init
Hello, I have a global state account as a pda of the program. how can I check if the account in the instructions are same as the pda(same seed/bump)?
await provider.connection.getRecentBlockhash()
and you can get the current blockhash, not sure what you need timestamp for
I think you can use the warp time to slot util from solana program to advance the slot
Hi guys,
How can I advance time when I write test?
How can I get current block timestamp of network while writing tests?
or is there something I could use to validate a token account's mint?
how do you guys handle the security of token accounts (having a specific mint), if I'm dealing with AccountInfo? 

I know with TokenAccounts, I can use a constraint on the mint, and with ata's, I can use spl_token's associated token mint. 

but should I just use the TokenAccount struct to handle the security aspect?
I'm still going to buy it I think it the pros outweigh the cons :/
better choice when doing Solana dev, it's a huge pain on an M1 😦
Nope, 2018 intel
do you have a M1 Mac btw?
the solution to this ended up being adding these lines to anchor.toml:
```toml
[[test.genesis]]
address = "3zgGJ7xjcEjr294KcDnxLgbDQTQoArd9ReY7DzXqPbUk"
program = "../gem-bank/target/deploy/gem_bank.so"
```
this is for a program that's stored in another repo and that I'm importing in
getting `Error: 169: Program account is not executable` when trying to CPI call another program. Any ideas? No mention of this error in discord history:(
```
▲ (Kens-MBP.local) ~ anchor --version
anchor-cli 0.19.0
▲ (Kens-MBP.local) ~ solana --version 
solana-cli 1.9.0 (src:7782d34b; feat:378846963)
```
why is it that sometimes my IDL has an address at the bottom under "metadata", and sometimes it doesn't?
Hi, I would really need BTreeMap support to be added to Anchor. Is there any way I can help with that?
hey, I'm running into the same issue - which versions (anchor & solana) did you end up using?
yes, `program.account.[name].all()`
Is it possible to fetch all accounts of specific type from client?
https://github.com/metaplex-foundation/metaplex/blob/572bcf073f51b3f013f1820123f74ae50dfe10b1/rust/auction-house/src/lib.rs#L989
what is transfer_authority?
Did you fix the cross-program invocation error?
Yea, fixes that a while back. Might have been the cause
Are you using two different versions of anchor_lang and anchor_spl in your Cargo.toml? (Won't work)
Thanks mate!
Fixed a few things up, should get you past the issues you were having. Still some other bugs I unfortuntately don't have time to look at rn. GL!
https://github.com/AJTJ/dutch_auction/pull/2
huh, interesting. I'm not sure what I'm doing incorrectly in my code that it is achieving.
This is a good one
https://github.com/project-serum/anchor/blob/master/tests/spl/token-proxy/programs/token-proxy/src/lib.rs
appreciate it, I'm sifting through other examples
Gotcha let me think
<@!702264277326626878> does that make sense?
I would like to give the `purchaser` authority over the `mint` and I believe that the `mint` is owned by the `owner` at the moment
Who are you trying to change authority from and to?
getting a new error now
```rs
Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account
```
I think that solved it!
It's because you're loading the `token_program` as mutable (this is an external program that you definitely shouldn't be writing to)
has anyone encountered this?
```
 Error: failed to send transaction: Transaction simulation failed: Transaction loads a writable account that cannot be written
```
I'm attempting to transfer a mint like so:
```rs
anchor_spl::token::set_authority(
    CpiContext::new(
        ctx.accounts.token_program.to_account_info(),
        anchor_spl::token::SetAuthority {
            current_authority: ctx.accounts.authority.to_account_info(),
            account_or_mint: ctx.accounts.mint.to_account_info(),
        },
    ),
    spl_token::instruction::AuthorityType::AccountOwner,
    Some(*purchaser.to_account_info().key),
)?;
```
here is the struct
```rs
#[derive(Accounts)]
pub struct Claim<'info> {
    #[account(mut)]
    pub auction: Account<'info, Auction>,

    #[account(mut)]
    pub token_program: Program<'info, Token>,

    #[account(mut)]
    pub mint: Account<'info, Mint>,

    #[account(mut)]
    pub authority: AccountInfo<'info>,

    #[account(mut)]
    pub purchaser: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```
and here is how it is being called in the client
```ts
    let tx = await program.rpc.claim({
      accounts: {
        auction: auction.publicKey,
        authority: owner.publicKey,
        systemProgram: SystemProgram.programId,
        mint: mint,
        tokenProgram: spl.ASSOCIATED_TOKEN_PROGRAM_ID,
        purchaser: purchaser.publicKey,
      },
      signers: [purchaser],
    });
```
I think the original `#[state]` is quite handy in some ways for it provided a nested account definition. Wonder whats the reason to deprecate it and whats the proper alternative way using `#[account]` to achieve the following:

```
#[program]
pub mod my_program {
  #[state]
  pub struct my_state {
  }
  
  impl my_state {
    pub fn func_1 {}
    pub fn func_2 {}
  }
}
```
ty
great got it
use std::str::FromStr;
make sure to
Pubkey::from_str("your pubkey here").unwrap()
haha yeah I was about to post more

? is this a problem or

Any idea whats wrong? I'm using  `Solana 1.8.5` and `anchor 0.18.2`
I am unable to deploy program  to  localnet. Finalizing transaction takes lot of time and then It fails to deploy. 
```Error: Deploying program failed: unable to confirm transaction. This can happen in situations such as transaction expiration and insufficient fee-payer funds
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.```
oh nice, looking forward to seeing it
It's down to how you do your PDA, let me open a PR
<@!597977239992139796> and <@!702264277326626878> definitely curious if you can pinpoint the signer issue. We've been looking at this for a while. Thought it was a versioning thing as well. I dunno
still got the same error, unfortunately
yes please try again?
like so?
```rs
pub struct Create<'info> {
    #[account(init, payer = authority, space = 64 + 64)]
    pub auction: Account<'info, Auction>,

    #[account(mut)]
    pub authority: Signer<'info>,
    pub system_program: Program<'info, System>,

    #[account(
        init,
        payer = authority,
        mint::decimals = 0,
        mint::authority = authority
    )]
    pub mint: Account<'info, Mint>,
    pub token_program: Program<'info, Token>,
    pub rent: Sysvar<'info, Rent>,
}
```
<@!454291700945387520>  I think you need to add `#[account(mut)]` to the authority account since it's payer of other pdas?
yea, I'm not sure what signers to include
Yeah so looks like it's failing on signature verification, meaning you don't have all the signers you need. My guess is it's because you're creating the mint account, hence it needs to be signed for. How is your mint defined? I take it the `auction` key is the authority?
even without the mint, and just trying to init the `auction` account, still same error
i can corroberate Doom's issue. ive personally tried like a thousands things, it's really getting ridiculous. any help is appreciated
It was functioning properly before I started adding the mint things
I'm having an accounts issue, and I'm not able to figure out what is causing it.
Here is my `Create` struct.
```rs
#[derive(Accounts)]
pub struct Create<'info> {
    #[account(init, payer = authority, space = 64 + 64)]
    pub auction: Account<'info, Auction>,
    pub authority: Signer<'info>,
    pub system_program: Program<'info, System>,
`
    #[account(
        init,
        payer = authority,
        mint::decimals = 0,
        mint::authority = authority
    )]
    pub mint: Account<'info, Mint>,
    pub token_program: Program<'info, Token>,
    pub rent: Sysvar<'info, Rent>,
}
```
here is the handler calling it
```rs
    pub fn initialize(
        ctx: Context<Create>,
        // parameters removed for brevity
    ) -> ProgramResult {
        auction.authority = ctx.accounts.authority.key();
        // business logic removed for brevity
        Ok(())
    }
```
and here is where it is being called in my ts file
```ts
    const provider = anchor.Provider.env();
    anchor.setProvider(provider);
    const providerWallet = provider.wallet;
    const auction = anchor.web3.Keypair.generate();

    let tx = await program.rpc.initialize(
      // params removed for brevity
      {
        accounts: {
          mint: mint,
          auction: auction.publicKey,
          authority: providerWallet.publicKey,
          systemProgram: SystemProgram.programId,
          tokenProgram: spl.TOKEN_PROGRAM_ID,
          rent: anchor.web3.SYSVAR_RENT_PUBKEY,
        },
        signers: [auction],
      }
    );
```
No matter what I do I keep getting this error:
```
     Error: Signature verification failed
      at Transaction.serialize (node_modules/@solana/web3.js/src/transaction.ts:583:13)
      at Provider.send (node_modules/@project-serum/anchor/src/provider.ts:112:22)
      at processTicksAndRejections (internal/process/task_queues.js:95:5)
      at Object.rpc [as initialize] (node_modules/@project-      
      serum/anchor/src/program/namespace/rpc.ts:24:23)
```
Any issue with just directly converting to a `u64` with `unsigned_abs()`?
ack
o wait, probably makes time math easier, duh
also, why the fuck is unixtimestamp an i64 in rust? Am I missing something <:room_temp_iq:797341877111095316> ?
🐒
I shall test it out
Hmmm, my gut tells me I should create an account in program A. Later on, when program A needs to call program B, it will use that account to sign. If the signer is not that account, program B gets angry and throws an error
Alright my big brains homies. Let's say I have program A, and program A invokes a function in program B. Is there a way to say on Program A can invoke the function?
any examples of making calls to native invoke_sign with PDAs?
chill out dude, i didnt know it was outdated
try it out
idk what to tell you. i just get all my errors from parsing the typescript. it gives me the error message directly, makes it easier.
```
the trait bound `anchor_spl::token::Mint: anchor_lang::AccountSerialize` is not satisfied
perhaps two different versions of crate `anchor_lang` are being used?
```
I'm getting name collisions it seems
thanks!
read the article carefully and you will get it
```
const tx = await program.rpc.myhandler( {
      accounts: {
        //accounts
      },
      signers: [signer],
    }).catch((e) => {
      console.log("failed:");
      console.log(e.code, e.msg);
    });
```
Sorry if I’m missing something obvious
So which one is 165
Right but it starts from 100, then lists 3 values (101, 102, 103) and then jumps to 1000
also, in typescript you can get the error message
each enum gets it's number from the order it's in
For example, what does 165 map to and how?
Thanks yeah saw this, but I’m missing how to convert the 165 to one of those enum values
for your bookmarks
https://www.notion.so/Debugging-Custom-Anchor-Errors-b8540dd418c44a4e939ab17c56a3fd3b
It's the bump calculated in your previous snippet, from the findProgramAddress call (sounds like you might want to search the discord for threads on program-derived addresses—have been quite a few so far)
```rs
#[derive(Accounts)]
#[instruction(mint_bump: u8)]
pub struct InitMint<'info> {
    #[account(
        init,
        payer = payer,
        seeds = [],
        bump = mint_bump,
        mint::decimals = 0,
        mint::authority = mint
    )]
```
what is the `mint_bump`?
ah I see
The mint creation happens inside the program itself (look for an `init` attribute over a Mint)
Nope—that's finding a specific program-derived address
ok interesting, so I found this code
```ts
const [mint, mintBump] = await anchor.web3.PublicKey.findProgramAddress([], program.programId);
```
I'm guessing this is how you create a mint, yea?
The Mint account keeps track of some stuff about the brand itself: how many decimals it has, who has authority to make more of the coin (e.g. you can't just randomly make more USDC, or AlanCoins for that matter), what the current supply of the mint is, etc.
A Mint represents a given "brand" of tokens, like AlanCoin. You might store 10 AlanCoins in your AlanCoin token account.
<@!134416332509675520> I'm going through your `token_studies` project
hm, maybe this is a beginner question, but can you tell me what a "mint" is and how it relates to "tokens"?
But I'm wondering if you're actually asking a different question, about authority stuff (that's not the same thing as program ownership)
Nope—you can only set program ownership once actually 😛 So not possible to change it if it's already something different than the system program
is it as simple as `account.authority = otherAccount.publicKey`? Or something along those lines?
program ownership
Which one lol
yea!
Do you mean program ownership? Or like, ownership over some tokens?
thanks <@!915682383905316864>. yeah explored zero_copy but my understanding is that it is typically used for exceeding the 10kb limit, not necessarily the 4kb stack frame limit. i'm also storing this data in a PDA,  & i think zero_copy can't be used on a PDA, since it requires an initial `createInstruction` call (e.g. https://github.com/project-serum/anchor/blob/db193d824887f12881c93853f3c4821cca5d09b1/tests/zero-copy/tests/zero-copy.js#L60 from the zero_copy example). not actually sure about this though, can anyone confirm?
how do I transfer ownership of an account?
How do we parse the error codes now?

```Error processing Instruction 1: custom program error: 0xa5```
0xa5 = 165

How do I read what that maps to here? https://github.com/project-serum/anchor/blob/master/lang/src/error.rs
https://github.com/solana-labs/solana-program-library/blob/master/token-swap/program/src/curve/fees.rs#L54
and for anyone else
I guess what I'm looking for is best practices for dealing with division and fractional values in an anchor program
<@!134416332509675520> semi-related question, is it good practice to do all your floating point math inside functions like I'm doing here and then just move the decimal around to hold onto the accuracy?
(Your program can't spend that account's money, so you instead have to ask the program that *does* own it to do it for you)
Yeah, if the account is owned by the system_program then that's the only way to transfer money from it
<@!134416332509675520> what do you think of this solution?
https://github.com/AJTJ/dutch_auction/blob/master/programs/dutch_auction/src/lib.rs#L97
That error means a program tried to spend some account's money, but the program doesn't actually own the account (not possible—only an account's owning program is allowed to mutate its date or spend its money)
yea, I think I sorted it out, with help from <@!903369685570035822>
Are you doing any `try_borrow_mut_lamports` stuff?
two questions having hard time finding answers for. sorry for long text
1. if i do not have a new account type, am I supposed to just use `AccountInfo`?  if I use this i cant seem to use [init, seeds, bump etc]
if i use this it works when declare type, but i dont have an idoAccount, its just an account. and I want to init and pass seeds?
`pub ido_account: Box<Account<'info, IdoAccount>>,`
in my case its just an account, not idoAccount, what would I put? if I want anchor to init just a regular account in the new syntax?

2. when trying to use this account as a pda and to sign with invoke_signed on native function like token transfer or swap directly,  it says unquthorized signer, signing does not work calling this or other native functions, but the same approach works calling anchor version of cpi. I know anchor has an spl wrapper for token, but not for swap or other protocols. when I try to get the seeds and sign it gets rejected as wrong signer.
this type of things work for non native calls but using the same signer for native does not?
`        let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer);`
thnx for any help
Forgot to specify an account as signer + to sign with it maybe? Hard to tell from the error only 😅
strugging with this error
```
     Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: instruction spent from the balance of an account it does not own
```
On the other hand I do not see in `UncheckedAccount` the serialization/deserialization implementations I can see for instance in `TokenAccount` (https://github.com/project-serum/anchor/blob/8e52242b8ca838a44e135b48af758fa2b643176c/spl/src/token.rs#L323). Someone else will have to pitch in to confirm/infirm if `UncheckedAccount` is an alternative to `zero_copy`, and to point to the idiomatic way to solve your issue.
From what I can see, `UncheckedAccount` seems more geared towards avoiding unnecessary checks (for instance if that account is only forwarded to a CPI call, with checks already perform on the other end of it).
I actually do not know about UncheckedAccount, but I believe `#[account(zero_copy)]` on the struct for which you wanna avoid stack/heap allocation + `ctx.accounts.my_account.load()?` is the only way to go if it currently blows past the limit (you probably saw this example: https://github.com/project-serum/anchor/blob/db193d824887f12881c93853f3c4821cca5d09b1/tests/zero-copy/programs/zero-copy/src/lib.rs)


///////////////////////////////////////////////////////////////////////////////////////////////

whenever I'm using `init_if_needed` - is there a good way to check within the handler whether the PDA actually had to be init'ed or existed before?
makes sense, thank you for the clarification!
Hi, I would like to build a smart contract which  store a list of data (like strings), but I would also like that my smart contract check if that data is not already stored. Currently I make an account to store each data added in the list, but I don't know how to list them (since multiple account could use the smart contract) in order to check if the string is not already anchored
I think the Authority keypair would refer to the wallet of the payer here. You need SOL to deploy a program, which means you need to sign for the deployment (e.g. using a keypair to sign for it).
You also need an address where to deploy the program. You can specify your custom keypair to `solana program deploy` (via the `--program-id` option) if you already have keypair. If you don't, you can simply run `solana program deploy <PROGRAM>`, and a new keypair will be automatically generated and used.
does this make sense
We need 2 keypairs in order to deploy:

Our Program Authority keypair, and
Our Program Keypair
https://github.com/DougAnderson444/solblog/#deploy-to-devnet
one is `target/deploy/projname-keypair.json` other one is inside my client side code, probably got confused because I was following a youtube video and it was creating a separate script to deploy everything to devnet
Usually there's just one, in `target/deploy/probname-keypair.json`
What are your two keypairs called?
it should just be one keypair
but that makes way more sense
hmm how did I end up with 2 keypairs 😄
Aren't they the same keypair? 🤔
I understand the one for deploy is related to upgrading the program, but I'm confused what the keypair generated by anchor build is for in the life cycle of the program
can someone help me understand the conceptual difference between the keypair generated when running anchor build and the keypair used when running anchor deploy?
hmm thank you for your answer, that could be cool, but I don't see any date so I can't estimate when this might happen :/
Not that I can find, The Graph is supposedly adding support for Solana though https://twitter.com/graphprotocol/status/1457739966457552901?lang=en
I got the same issue with Apple M1 Macbook pro.
I eventually workaround the issue by restart the solana-test-validator with `--no-bpf-jit`,
The reason it that the BPF JIT has not been supported on arm64 yet.
More details in this link: https://github.com/solana-labs/solana/issues/18033#issuecomment-962718203
Is there any eligible way to increase the timestamp on test environment, I wrote the vesting program and want to test the release schedule so it would be great if I can increase the cluster time as the interval period
How to mint NFT with image from rust smart contract ?
I have another question, is there any public or open-source indexer on solana ?
ah nice, this sounds super sensible, thanks a lot!
I would track it outside of the target folder. Then you create a small bash script for deployment, that feeds the tracked dev private key to the deploy command's `program-id` option
the address/pubkey of the program is exclusively derived from the keypair used for deployment (you can check with `solana-keygen pubkey my-keypair.json`). A keypair gets automatically generated for you at deploy time unless you provide it yourself through the `solana program deploy`'s `--program-id` option.
I will have to do some validation though I suppose since its possible that any clown could transfer a token to that pda, but other than that I think it will work. If anyone knows a more elegant way lemme know 🙏
Sure but I wont know who the uses are apriori or their pubkeys. I have a good enough solution for this though, I am just using the same "vault account" (just a pda) for all users, so I can just get getTokenAccountsByOwner(vault_pda_account), and that will get me all staked nfts. Then I can lookup last owner of each of those to get the user pubkeys.
technically you can, but its not that easy I'd assume. just working without anchor is already a pin 😅
Hi ! I have a question of curiosity, is that possible to build a spl token without spl-token program ? Like can I code my own token in rust and deploy it ?
and when i copy a local keypair file, i guess I have to delete all `/target` folders (otherwise the build and keys are cached)?
hey guys, just checking; how are programId's determined actually? Is it based on the local keypair, or do other factors come into play as well
maybe I miss some details, but I think you don't need to have a masterlist which tracks everything you can filter for example all nfts from a specific user by using getProgramAccounts(). Here you have a filter field where you can filter in the account data.
`Property 'workspace' does not exist on type 'typeof import("/home/XXX/Solana/Project/node_modules/@project-serum/anchor/dist/cjs/index")'`
Folks does anybody know how to make sure the anchor errors (https://github.com/project-serum/anchor/blob/master/lang/src/error.rs) are also included in my IDL so that the client can decode them too?
We just upgraded to anchor 0.19.0 and it seems no workspaces are being populated when loading the idl in tests.  Anyone else see this issue?
another related question - when I factor out the `ErrorCode` enum into a separate library (shared by numerous programs in the project) - the errors stop printing correctly (eg I now get `custom error: 0x123` instead of the msg defined on it `x and y have gone wrong`.

it's not the end of the world (you can still go lookup which error it is once you convert hex to `30x` code, but it makes it impossible to re-order errors in the enum (your tests start to break).

any ideas if that's solvable at all?
ok I see... that creates a problem then:

- I have a foreign error type inside a library
- I need to convert it to ProgramError, which also is a foreign type
- I can't do impl From
- the only thing that comes to mind is replacing ProgramError with a custom defined error type and doing impl there... but that feels too much overhead for such a simple problem
- the other option is to start using map_err where no automatic conversion possible

is there a simpler solution I'm missing?
I'm getting the error `Error creating BaseAccount account: Error: Wrong input type for account "user" in the instruction accounts object for instruction "startStuffOff". Expected PublicKey or string.` and I don't know why. This is coming from a React frontend that's calling a deployed Solana program which I tested locally with Anchor and works.

Anyone know what might be causing the error?
I need to verify that a user owns a specific NFT before performing an action. Would the following constraints work for verifying that?

```
    #[account(constraint=nft_token_account.key().eq(
        &Pubkey::find_program_address(
            &[
                nft_owner.key().as_ref(),
                spl_token::id().as_ref(),
                mint.key().as_ref(),
            ],
            &anchor_spl::associated_token::ID,
        ).0
    ))]
    nft_token_account: Account<'info, TokenAccount>,
    mint: UncheckedAccount<'info>,
```

Also, how can I verify the token mint account (currently using `UncheckedAccount`)? Is it a PDA as well?
https://github.com/metaplex-foundation/metaplex/blob/master/rust/nft-candy-machine/src/lib.rs#L156-L174
you can check the candymachine contract.. you use a CPI for spl-token-metadata
what is the meaning of this error msg? `A raw constraint was violated`
Hi All,
How can i create metadata account on solana from anchor?
or Anyone have any references for it?
thanks
https://github.com/project-serum/anchor/pull/705 added here
funny, that answers my question from an hour prior over here: https://discord.com/channels/889577356681945098/889702325231427584/920089061954289754
Yeah, thanks 🙂 You know of any reason to use one or the other?
this is the equivalent of #[account(signer)]
You mean that I don't need the  #[account(signer)] attribute if the Struct is of type Signer?
What do you mean?
it will throw for you
`the_account: Signer<'info>`
Anyone have any references to creating a sol token account for a program (that persists)?
Out of curiosity, how would you do this?  #[account(signer)] on an Account and then just  compare that accounts pub key with a constant and throw and error if it does not match?
Not directly no, but you can always require the client to pass an account with a known address + make the account sign.
Since in eth this would be something simple like 

```       owneraddress = msg.sender ;
   require(owneraddress == msg.sender);
``` 

Wondering if something similar can be done for sol programs
Do any smart devs know 👀
Is it possible to check in a sol program if the executor is a certain pubkey? i.e. so that only I can call my own programs?
Let’s dive then, thanks! 🤿
hmm... this makes sense xD
In general you would need to go source-diving into the program's code 😬
does anyone use enums like this? I am trying to find examples but havent found any good example of using enum in anchor deserialization in js. Even when i use `#[repr(u8)]` is still deserialized as an object in js
does sol also require a token account?
Using Anchor we can see the defined `struct` , and set the `offset` according to that. But how can we know this structure on regular programs? in order to know what the `offset` should be.
<@!707604162673639504> <@!134416332509675520> just a quick dumb question, how can I know the account structure of a particular program? 👀  I'm trying to filter accounts from the `Token Program` (`TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA`) using `memcmp` filter.
Rust doesn't do automatic double conversions like you're attempting to use above (from GemCommonError -> ErrorCode -> ProgramError), even if the impls are there for it to happen
`ProgramError` isn't anchor's error type, it's the built-in solana one. You might want to convert that `GemCommonError` into a ProgramError, not an anchor ErrorCode
not a dumb question at all! I went back and checked, but unfortunately yeah it seems the enum is public and it's imported ok in the fiel where I'm using `?`
dumb question but: are these snippets and the place where you use `?` in the same file, or made `pub` and all?
tried, it wont let me do that coz I'm implementing a foreign trait for a foreign type
sounds like a Rust issue, maybe brushing up on their docs would help? but i myself dont know :/ wild suggestion, maybe copy that first block and paste it right below it and then change `for ErrorCode` to `for ProgramError`? (like i said, im random guessing lmao). let me know if that works 🙂
my impression was that I only had to convert to `ErrorCode` and from there Anchor would to the conversion to `ProgramError`. But that's not the case?
stuck with trying to implement the From trait for a custom error from a lib:

this is what I have:
```rs
impl From<gem_common::GemCommonError> for ErrorCode {
    fn from(e: gem_common::GemCommonError) -> Self {
        match e {
            gem_common::GemCommonError::ArithmeticError => ErrorCode::ArithmeticError,
            gem_common::GemCommonError::AccountDidNotSerialize => ErrorCode::AccountDidNotSerialize,
        }
    }
}
```

ie I convert the custom error into an instance of anchor's ErrorCode:
```rs
#[error]
pub enum ErrorCode {
    // --------------------------------------- generic
    #[msg("failed to perform some math operation safely")]
    ArithmeticError,
}
```

but I'm still getting `^ the trait From<GemCommonError> is not implemented for anchor_lang::prelude::ProgramError` whenever I try to use `?`. What am I missing to get this working?


///////////////////////////////////////////////////////////////////////////////////////////////

thanxs a ton <@!832140329301311488>
thanxs it is now working, I created a new anchor project and replace all existing logic into new one, and everything is start working like charm
Do you have any solution for my installation error?
unlikely though i could be wrong
Is it possible to use assembler instruction in anchor?
How can I fix this issue?
I am getting this issue when run 

`cargo install --git https://github.com/project-serum/anchor --tag v0.19.0 anchor-cli --locked`
I'm trying to think where I would implement that trait, the struct currently has:
```
#[derive(Debug, Copy, Clone, AnchorSerialize, AnchorDeserialize)]
pub struct FarmerRewardTracker {
```
and I think the anchor version should be enough?
is there a way to use `RefCell` with anchor?

I have a parent struct that has a `RefCell<ChildStruct>` field, and when I try to compile I get:
```
the trait bound `RefCell<farmer::FarmerRewardTracker>: BorshDeserialize` is not satisfied
```
can you copy the struct containing this
yeah this is the only constraint in my program
Are you sure this is the attribute which is failing ?
the same thing
Getting any error ?
Is there something I have to do to correctly update an Account?
is this correct ?, It didn't seems working
```
#[account(mut, constraint = admin_acccount.key() == ADMIN_PUBKEY.parse::<Pubkey>().unwrap() @ErrorCode::AdminMisMatch)]

pub admin_acccount: AccountInfo<'info>,
```
BTW anybody tried 1.9 release with flexible compute units ? I was looking for JS/TS bindings for instruction but couldn't find any.
Looking for math gigabrain that can help with logarithm math on chain ;C
#[account(mut, address=  ID  @CustomError::NotAuthorized)]
    pub authority: Signer<'info>
How to add a error in raw constraint
how can I fix it?
thank you. I installed libssl-dev. after install it, solved problem.
But I am getting other error.
How can I create image NFT on specific function execution in React? Any advice would be helpful..
Is there a limit to how many results `program.account.myAccount.all()` can return?
what's the cleanest way to do a sol transfer using anchor? invoke a system_instruction::transfer?
my enum in the contract is just:
```
pub enum Type{
  Variant1,
  Variant2,
}```
How do I pass an enum into an instruction call as an argument (anchor web3 js client)  `program.transaction.someIx(enum, {accounts: <>})`? I'm getting `unable to infer src variant'` error. Seems like buffer-layout has trouble encoding the `enum` object. I have `const enum = new BN(0)` as I want the first variant.
install openssl
it is getting an error. not successfully exit openssl
how to install anchor v0.19.0?
That might avoid you some time waste. I don't really have a good idea what could be the issue
Yeah, can do that for now. Thanks.
I know this is not the best, but how about for now at least you do run a validator manually, and use the `--skip-local-validator` option of `anchor test`? 😕
But the symptoms do look the same. The issue goes away if I run cargo clean (I've seen this on a github issue for some other problem someone had)
nope, I know about this issue already.
and you are not starting your own validator?
Ledger location: .anchor/test-ledger
Log: .anchor/test-ledger/validator.log
Initializing...
I did. Nothing useful there:
Have you checked if there is any helpful error log in `test-ledger/validator.log` maybe?
Hi all, I have this very annoying issue when developing.
**anchor test** only works after the first time I do **anchor build**, if I do test then build and then test, I get an error with solana-test-validator (it just crashes without any errors). But if I run cargo clean, build and test then it works as expected. Any workarounds for this issue, I hate wasting time doing full builds all  the time. Thanks.
`anchor test` doesn't deploy to devnet/testnet/mainnet (at least not by default). It only spins up a local validator
how do you do anchor test without it trying to deploy everytime?
might be a silly question
hey guys
originally but changed it to match just to try somethin
** complete task is where the issue is. I also had 
```rust
if worker.task.in_none()
```
I'm sure I'm doing something really dumb
I have a weird issue 
```rust
#[account]
pub struct WorkerAccount {
    pub mint_key: Pubkey,
    // pub mint_seed: [u8; 4], // 4 bytes (4294967296) (don't use strings in the future ya dummy!)
    pub task: Option<Task>
}

#[derive(Debug, Clone, PartialEq, AnchorDeserialize, AnchorSerialize)]
pub struct Task {
    tile_public_key: Pubkey,
    complete_time: i64
}
```
So I have a worker account and a worker can have a task so I wrap it in an option. Now, when I assign a task to a work account, I can see that the task is assigned through the javascript api.

```
{
  mintKey: PublicKey {
    _bn: <BN: bbeeec83e1d0837f280b26cbad390b30cda5c985c0c8eb8995e6b41fce1c50e5>
  },
  task: {
    tilePublicKey: PublicKey {
      _bn: <BN: 3dbcb76ff9c7502dc635273c8068fb1040cbd3d27621f9103eed40562eee1d07>
    },
    completeTime: <BN: 61b96ac8>
  }
}
```

However, in my program, when I try and do a check to see if that task exists, it does not. What's really odd is when I call assign task, the task is there if I've already assigned one. However, no matter what, when I call  complete_task it isn't
```rust
pub fn assign_task(ctx: Context<AssignTask>) -> ProgramResult {
        let worker = &mut ctx.accounts.worker_account;
        let worker_token_account = &ctx.accounts.worker_token_account;
        let signer = & ctx.accounts.signer;

        let tile_account = &ctx.accounts.tile_account;

        worker_checks(&worker, worker_token_account, signer)?;

        if worker.task.is_some() {
            return Err(ErrorCode::WorkerAlreadyHasTask.into());
        }

        let task = Task {
            tile_public_key: tile_account.key(),
            complete_time: Clock::get().unwrap().unix_timestamp + 120 // adds two minutes from now
        };
        worker.task = Some(task);

        Ok(())
    }

    pub fn complete_task(ctx: Context<CompleteTask>, resource_mint_bump: u8, resource_mint_seed: String) -> ProgramResult {
        let worker = &mut ctx.accounts.worker_account;
        let worker_token_account = &ctx.accounts.worker_token_account;
        let signer = & ctx.accounts.signer;

        let tile_account = &ctx.accounts.tile_account;

        worker_checks(&worker, worker_token_account, signer)?;

        msg!("worker: {:?}", worker.task);
        match worker.task.as_mut() {
            Some(_) => {},
            None => return Err(ErrorCode::NoWorkerTask.into())
        }

        let task = worker.task.as_ref().unwrap();
        let current_time = Clock::get().unwrap().unix_timestamp;
        if task.complete_time < current_time {
            return Err(ErrorCode::WorkerHasNotCompletedTheTask.into());
        }

        // mint the resource

        Ok(())
    }
```
Would be easier to debug if you post a full program log—but sounds like you're maybe passing the right kind of account? Or an account that hasn't been initialized, etc.
"An account's data contents was invalid" - what does this error means?
oh right that makes sense
You can store a field in your struct with e.g. `is_initialized: bool` (won't be set if init was needed)
interesting, what do you mean by a "one time initializer field"?
not really unless it's an account controlled by your program, in which case you can use a one time initializer field
syntax is the same
what is the equivalent syntax for this in anchor


///////////////////////////////////////////////////////////////////////////////////////////////

Ok, super clear. I need to be more careful. Also, can I withdraw the SOL from this account? It says ◎0.00219936 (I don't really care, it's on devnet, I just want to know)
It may be possible soon, but not yet (so yeah, if you think you're going to be adding fields to an account, good idea to pre-allocate some extra space)
Is it possible to extend an account? Or do I have to create another one?
If you've already allocated an account with 188 bytes, but there's no space for new fields, then adding a new field won't work
Or is the space already the exact right amount?
No, I mean, does it have room for additional fields?
Sorry, I'm new to this, do I have to allocate an account?
Yes, it's only 188 byte(s)
Is there enough space in your account to support adding a new field?
Hello guys, I'm looking for a way make my program retro-compatible, I added a field to an account, and now I have a 3003 error ( probably AccountDidNotDeserialize) when a try to update the account 😦
I figured it out: I was passing in a "&" in the function parameters for the instruction
What does this mean? Do I need to implement something?
the function or associated item `deserialize` exists for struct `instruction::Test`, but its trait bounds were not satisfied

doesn't satisfy `instruction::Test: anchor_lang::AnchorDeserialize`

note: the following trait bounds were not satisfied:
      `&'static [u8; 64]: anchor_lang::AnchorDeserialize`
Have you searched and gone through the history for "The given account is not owned by the executing program", like https://discord.com/channels/889577356681945098/889577399308656662/919557535852281906
Anybody has an idea about what the issue could be? Do I somehow have to make the 3rd party program into a signer?
Hi all. I'm trying to make a cpi call to a specific function from a 3rd party program. What I did is I looked at the source code and replicated the context needed for the call. As far as I can tell, the signers are the same in both. However when I run it I get the following error ```     Error: 167: The given account is not owned by the executing program
```- I also have the 3rd party program in the context of my contract and in the front-end I pass the programId.
I don't understand why during almost 1 hour I was still able to fetch the data
Yes! Ok now it is not anymore a ProgramAccount and I cannot fetch the data.
Yeah, when I try to fetch that account from mainnet-beta I get an empty account (no data)
And just to double check, your connection cluster is set to mainnet there?
`(await program.account.state.all())[0].account`
How are you fetching its data?
https://explorer.solana.com/address/Fh28vPTViAdLRo1C4GByT278G9oNs1MKWiyS3U9c18GC
Can you link to it on the explorer?
The account still has data in it? That doesn't make sense to me (accounts with zero sol can't really have data, since they get immediately rent/garbage collected)
Hi guys, I have closed an ProgramAccount with the close constraint on mainnet. I can see that the rent has been recovered and that the account is a simple address with no SOL on it. However, it's still associated to my program and I can still fetch the data from it. Any idea why? On localnode, the account is properly closed
yeah I might have it messed it up in my head, thanks anyways!
Mm... still not sure I'm following 🤔 If there's some movement of tokens, then yes, at some point some program is CPI'ing to the token program to do the transfer
sorry, to frame it simpler, does the invoke signed call imply that the cpi transfer call is going to be executed in another program?
implicitly
Automatically?
so if I do a deposit to marinade, let's say, from that PDA, would the token::transfer cpi call be automatically called?
Ok, so it lives at a PDA
a token account owned by the program, yes
What do you mean by program account? Just a token account?
so normally, to transfer funds out of a program account, I'm doing the usual stuff

    let cpi_ctx = CpiContext::new(token_program.clone(), cpi_transfer_accounts).with_signer(signer);
    token::transfer(cpi_ctx, amount)
What fails/what do you think won't work?
I'm not following 🤔
let's say I have a collateral vault, and in my program, I need to do a cpi transfer call to withdraw the funds. if I want to transfer funds out of it, in let's say Serum or another program, even though I have a CPI Serum call that it's signed, would the cpi token transfer call be automatically called?
if I need to do a cpi call to the token program to transfer funds out of a program owned account, does that imply that I cannot use that account in a cpi call to another program?
https://github.com/project-serum/anchor/pull/975/files/4468efb4377adfc3915562dc4a5c5a7521ed9a12
Hey so it looks like support for hardware wallets was added in this merge two days ago. Can I run `cargo install --git https://github.com/project-serum/anchor anchor-cli --locked ` to get master or is there another flag I need to use?
Even if you are aware of it. It can happen that you change the instruction args and forget about the macro
Yeah haha. Would really love to see ideas for a way to fix this, since it can be genuinely extremely surprising if you're not aware of it.
maybe it should be rename to `instruction_i_know_what_im_doing` or something
dangerous stuff
ah I see. That makes  sense.
This is super annoying but there's no good fix for it yet 😦
It's supported, but there's a big gotcha: you need to match the arguments from your instruction function!
is `#[instruction(<>)` macro officially supported? I mean using it like this:
```
#[derive(Accounts)]
#[instruction(capacity: u16)]
pub struct SomeIx<'info> {
   ...
}
```

I'm getting some very weird behavior where capacity somehow becomes 512 when I pass 2 (it's properly deserialized as 2 in the intruction method)
But you can make the token's authority whatever you want
The token's authority is its own address (which is program-derived), so ultimately the program has authority over it
And we will get token on which program has an authority?
I would probably store the token at a program-derived address then, something like
```.rs
#[account(
    init,
    payer = the_payer,
    seeds = [ something that makes sense ],
    bump = the_bump,
    token::mint = the_mint,
    token::authority = the_account, // itself!
)]
pub the_account: Account<'info, TokenAccount>
```
So the token lives in it.
My program should have authority, yes.
I'm new to this and my questions might be blurry..
Ok, so your program has authority over the token?
On initialization I want to create NFT. And then on other function(exchange) I want to transfer this NFT.
Not sure what that means 🤔 The question above is mainly just about what address you want the token account to live at
I want this token to live in the program account until specific action.
Thanks. Who is the payer?
deep understanding is needed.
Or maybe `associated_token::` instead of `token::` if you want it to be an associated token account
Yeah, something like
```.rs
#[account(init, payer = the_payer, token::mint = the_mint, token::authority = whoever_owns_the_tokens)]
pub the_token_account: Account<'info, TokenAccount>
```
Yeah, I actually don't know why they do that (a PDA under the hood is a sha256 hash of seeds + bump + program_id (plus a fixed string), so the program_id has already been included in the hash
```
let metadata_seeds = &[
        PREFIX.as_bytes(),
        program_id.as_ref(),
        mint_info.key.as_ref(),
    ];
```
the metaplex metadata account seeds use the program_id ...
wanted to add this to anchor since everybody wants that
yeah i have alreayd pinged him
I should use "init" instead of "mut" ?
<@!134416332509675520> 
```
Token.createCloseAccountInstruction(
      TOKEN_PROGRAM_ID,
      wallet.publicKey,
      quoteCurrencyAccount, // wSOL account public key
      quoteCurrencyAccount, // wSOL account public key
      [],
  )
```
This is the error that I have.
```
Error: Signature verification failed
    at Transaction.serialize (transaction.ts:583)
    at sendSignedTransaction (send.tsx:826)
    at sendTransaction (send.tsx:749)
    at async placeOrder (send.tsx:467)
    at async handlePlaceOrder (MarketDetail.tsx:197)
```
jstarry is your man for this
we need to add this anchor!
No, that's expecting you to pass in a token account that has already been initialized
With this, the account for the nft will be created? 
```#[account(mut)]
    pub nft: Account<'info, TokenAccount>```
https://discord.com/channels/428295358100013066/517163444747894795/921028789692170240 maybe sb here can help
yeah, here is the key point, and now it works, thanks
Can I see the program log?
Do you get an error?
Yes
Just to make sure I understand, are you actually invoking that instruction?
<@!134416332509675520> Thank you!!! You're a life saver. 
I have another question, what to do if I want to close the wSOL account. I tried to use Token.createCloseAccountInstruction, but nothing happens.
```
Token.createCloseAccountInstruction(
      TOKEN_PROGRAM_ID,
      wallet.publicKey,
      quoteCurrencyAccount,
      quoteCurrencyAccount,
      [],
  )
```
Mint accounts are owned by the spl token program, not the system program
But you need to use your own program id because that's how your program can sign for the address
That argument needs to be your own program id (hence why I was saying that it's weird to also include it in the seeds)
No—also, that argument isn't about program ownership at all
the owner of mint account is system program?
That definitely won't work
That doesn't make sense to me, why are you deriving an address based on the system program, rather than *your* program?
Ah, wait, why are you doing `common.SystemProgramID` there?
```
mintId := 19980101
seeds1 := [][]byte{}
buf := make([]byte, 8)
binary.LittleEndian.PutUint64(buf, uint64(mintId))
seeds = [][]byte{
        []byte("mint"),
        common.PublicKeyFromString(nft.ProgramID).Bytes(),
        []byte(uuid),
        buf,
    }
mint, mintBump, _ := common.FindProgramAddress(seeds, common.SystemProgramID)
fmt.Println("Mint address: ", mint, mintBump)
```
i use golang currently
Can you post how you're finding the PDAs address in JS?
Ok, looks good (and you don't need all those lifetime parameters)
```
pub fn mint_nft<'info>(ctx: Context<'_, '_, '_, 'info, MintNFT<'info>>, bump:u8) -> ProgramResult {
  msg!("");
}
```
instruction has bump as input
Does your instruction function take any other arguments? Can you post it?
Also odd that you're using `&ID.key().as_ref()` in there (doesn't really make sense to me since the program's id is *already* an ingredient in the address, so not sure why you would want to pass it again)
You have fairly complicated seeds there... how confident are you that you're using them the same way in JS and in your rust program?
```
#[derive(Accounts)]
#[instruction(bump: u8)]
pub struct MintNFT<'info> {
    nft_metadata: ProgramAccount<'info, NftMetadata>,
    candy_machine: ProgramAccount<'info, CandyMachine>,
    #[account(mut, signer)]
    payer_account: AccountInfo<'info>,
    wallet: AccountInfo<'info>,
    receiver_ata_account: AccountInfo<'info>,
    #[account(init,
        seeds=["mint".as_bytes(), &ID.key().as_ref(), candy_machine.data.uuid.as_bytes(),&nft_metadata.mint_id.to_le_bytes()],
        payer = payer_account,
        mint::decimals = 0,
        mint::authority=payer_account,
        bump=bump)]
    mint: AccountInfo<'info>,
    #[account(mut)]
    metadata: AccountInfo<'info>,
    #[account(mut)]
    master_edition: AccountInfo<'info>,
    token_metadata_program: AccountInfo<'info>,
    token_program: AccountInfo<'info>,
    system_program: AccountInfo<'info>,
    rent: Sysvar<'info, Rent>,
}
```

rpc response error: {"code":-32002,"message":"Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account","data":{"accounts":null,"err":{"InstructionError":[0,"PrivilegeEscalation"]},"logs":["Program 23qZep7pEXALf4GxqHuX8egemfLPvDVgs7gnLvrZmgw4 invoke [1]","BPfceJDENor84CtcxPBJF1xVcZdy2qpGtsC6QcvJbULd's signer privilege escalated","Program 23qZep7pEXALf4GxqHuX8egemfLPvDVgs7gnLvrZmgw4 consumed 200000 of 200000 compute units","Program 23qZep7pEXALf4GxqHuX8egemfLPvDVgs7gnLvrZmgw4 failed: Cross-program invocation with unauthorized signer or writable account"]}}

hi, any idea about this inscrutcion error ?
I think you additionally need to use the `SyncNative` instruction, which pokes the account to realize that it now has more sol in it, and should reflect that fact in its token balance
Hello! I have an issue with wrapped solana.
I called Token.createAssociateTokenAccountInsruction to create the wSOL account and SystemProgram.transfer to transfer SOL to said account.
The expected behavior is that I would have 1 wSOL in the newly created account.
What I have is 1 SOL deducted from main account into the wSOL account, but 0 wSOL balance in the wSOL account.
Transaction in explorer: https://explorer.solana.com/tx/3KGez3CguJdHaAPiMf5uE5sGfLFsWEBzxb29Z7tCN3DUGAxLVKCVimmv4qzvhgsBtWMFoWUYTcaVesQ4wPFJrEri?cluster=devnet
```
const ata = await Token.getAssociatedTokenAddress(
    ASSOCIATED_TOKEN_PROGRAM_ID,
    TOKEN_PROGRAM_ID,
    new PublicKey('So11111111111111111111111111111111111111112'),
    wallet.publicKey,
  );
  const transaction = new Transaction();
  transaction.add(
    Token.createAssociatedTokenAccountInstruction(
      ASSOCIATED_TOKEN_PROGRAM_ID,
      TOKEN_PROGRAM_ID,
      new PublicKey('So11111111111111111111111111111111111111112'),
      ata,
      wallet.publicKey,
      wallet.publicKey,
    ),
  );
transaction.add(SystemProgram.transfer({
    fromPubkey: wallet.publicKey,
    toPubkey: ata,
    lamports: 10 ** 9,
}));
await sendTransaction({
    transaction,
    wallet,
    connection,
    signers: [],
    sendingMessage: 'Sending...',
});
```
Thanks in advance for any help on the issue.
Thanks <@!134416332509675520> , that works!.👍
Yeah, but I think you'll have to use `#[derive(AnchorSerialize, AnchorDeserialize, Clone)]` on top of `TokenInfo` too.
that worked!, thanks
can i use the value field as one more struct <@!134416332509675520> like :-
#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub struct KeyValuePair {
    pub key : u32,
    pub value: TokenInfo
}

pub struct TokenInfo {
    mint_token_account: Pubkey,
    mint_token_amount: u64,
    a_token_account: Pubkey,
    owner: Pubkey
}
`how to use a custom struct inside an account struct`, sufficiently generic
this seems like an easy kind of cookbook entry
Yeah, `KeyValuePair` isn't an account storage format all by itself, you'd instead do
```.rs
#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub struct KeyValuePair {
  ...
}
```
i think it's like `AnchorDeserialize` but there's probably a few others you need
try to check out some of the examples in anchor/test to see about using structs inside account structs
you're missing some derive macros above KeyValuePair
Hi how can i declare a Vec<key,pair> inside a account, while i try to create a struct for the key pair its throws an 
error:- IdlError: Type not found: {"type":{"defined":"KeyValuePair"}}

my code:-
#[account]
pub struct Account {
    pub bump_seed: u8,
    pub owner: Pubkey,
    pub reserves: Vec<KeyValuePair>,
}

#[account]
pub struct KeyValuePair {
    pub key : u32,
    pub value: String
}
No I think you have to access the account info directly from the accounts context struct. Account infos really only live there as far as I know
<@!134416332509675520>let me try that, thanks
If you really want to still use a BTreeMap in your rust code, you'd do what borsh would have done for you: go turn that vec of key-value pairs into a BTreeMap 🙂
Not yet. Honestly, your simplest option is to not use a BTreeMap and instead store a `Vec` of key-value pairs (that's actually what your BTreeMap would get serialized to anyway, so it's not *that* bad)
Hi <@!134416332509675520> , there is any other way can i make that work and test the BTreeMap
aah then it make complete sense
the receiver of the close instruction should be present as the accountInfo in the instruction, I think
It didn't seems working though 😅
close the escrow and transfer whatever lamports it has to the admin key
can I do this way ?
```rust
mod constants {
    pub const ADMIN_PUBKEY: &str = "8bqg5cakaDP88XRcNzBxngcpX9tTuK1XRHxg9iF35EEx";
}

    #[account(mut, close = ADMIN_PUBKEY.parse::<Pubkey>().unwrap(), constraint = escrowed_vault.receiver == receiver.key())]
    pub escrowed_vault: Account<'info, EscrowVault>,
```
mm interesting
It means close the account at the end of the instruction (the account needs to be owned by your program) and transfer whatever lamports it has (for rent, say) to the `destination` account.
also I'm digging in your repo and found a attribute `close = receiver,`😛. What doest it mean
^
Anchor doesn't support the IDL side yet unfortunately (not sure if someone is working on a PR for this)
yeah I did, now everything is working fine
It make sense
You'll have to do the `try_borrow_mut_lamports` stuff (try searching the discord)
aah got it
If your program owns the account, then *only your program* can mutate the account's data or spend its money (so above, asking the system program to spend it doesn't make sense—it's up to your program to do it!)
Hey guys, What am I doing wrong with BTreeMap? I understand HashMap is not working on chain, but I thought BTreeMap worked fine? 
However I get this error. 
IdlError: Type not found: {"name":"reserves","type":{"defined":"BTreeMap<Pubkey,Reserves>"}}

When I try to implement and empty one using: 
winner: BTreeMap::new(),
Ok, then even if you were signing correctly the above snippet wouldn't work 😛
(That shouldn't matter for this particular error message—you're not signing correctly—but I'm curious)
current program
Which program owns the account?
I'm trying to sign from escrowed_vault, `escrowed_vault` It is a PDA
The error means that you're somehow not passing those seeds+bump correctly
So you're trying to sign for `escrowed_vault` here? Which program owns that account?
giving an error `"92avznPY7JBBusQT8BDAvNmgcR7oXupM4SEcTeoNoSmA's signer privilege escalated",`
I'm trying to do this, what is wrong in this snippet, can't able to debug it
just a second question
```rust
        let ix = anchor_lang::solana_program::system_instruction::transfer(
            &ctx.accounts.escrowed_vault.key(),
            &ctx.accounts.receiver.key(),
            ctx.accounts.escrowed_vault.lamports,
        );
        anchor_lang::solana_program::program::invoke_signed(
            &ix,
            &[
                ctx.accounts.escrowed_vault.to_account_info(),
                ctx.accounts.receiver.to_account_info(),
            ],
            &[&[ctx.accounts.escrowed_vault.sender.as_ref(), b"kk".as_ref(), &[ctx.accounts.escrowed_vault.vault_account_bump]]],
        )?;
```
thanks you are awesome 🚀
Do you mean look up an *additional* AccountInfo, dynamically, based on its Pubkey? donderper is saying that no, that's not possible in solana—the client has to specify ahead of time all the accounts the tx cares about.
You'd have to do `**ctx.accounts.escrowed_vault.to_account_info()...`
<@!134416332509675520> any suggestion
Hi <@!299956114399690752> are you resolved the problem, if you got resolve. can you please share me the solution your done. I'm also facing the similar issue that your faced.
<#889586731987394680>
given as error 
```no method named `try_borrow_mut_lamports` found for struct `anchor_lang::Account<'_, EscrowVault>` in the current scope
```
```rust
    **ctx.accounts.escrowed_vault.try_borrow_mut_lamports()? -= ctx.accounts.escrowed_vault.lamports;
    **ctx.accounts.receiver.try_borrow_mut_lamports()? += ctx.accounts.escrowed_vault.lamports;
```

this is not working
cool thanks
just search invoke_signed in their organization on gh
yes, plenty in anchor's and solana's githubs
is there any example for this
you need to call invoke_signed and pass the pda seeds
but is there any way I can translate a pubkey to an account info, from a program account, inside context? inside my instruction, they are already interpreted as account info
giving an error `"GSJ6JqJNBy3CDQ9KxvQaTgZRCAkzK2WdzJ7hmUws61b's signer privilege escalated"`
I tried this, but it is not working
```rust
        // transfering sol from escrow vault to receiver
        let ix = anchor_lang::solana_program::system_instruction::transfer(
            &ctx.accounts.escrowed_vault.key(),
            &ctx.accounts.receiver.key(),
            ctx.accounts.escrowed_vault.lamports,
        );
        anchor_lang::solana_program::program::invoke(
            &ix,
            &[
                ctx.accounts.escrowed_vault.to_account_info(),
                ctx.accounts.receiver.to_account_info(),
            ]
        )?;
```
How can we transfer native sol form PDA, to receiver
No, all accounts you need to use in a program function must be passed in as public keys by the transaction
and using a program account struct to retrive the program owner seems to only give me the pubkey in context, and I need account info
is there any way I can pass the payer for a program account without exposing it in context? I'll like to init a program account and be owned by the program, without having the user pass the program owner pubkey to the instruction call. 

I need to initialize and close the account in the same instruction prompted by the user, so trying to explore some workarounds
make that 1000x 🙂
And 10x expensive lol
Especially in Solana lol. Solidity is 10x easier.
Nothing is simple in blockchain development..
No, same as there is no such function in C++ or Go. Rust is just a general purpose language.
So there is no simple function available in rust that in function NFT is created with specific info attached to 😆
But the code is a good start on how to create a valid NFT. The difference would be you would not have a candy machine program with everything preconfigured, but you would allow some parameters to be passed to it. In that case you need to make sure you secure it properly, because someone can just come and give it parameters to create the rarest/best possible NFT every time.
No, likely not without changing it heavily.
That can be done by Metaplex?
Ah I see.
So I want that on some button click on website contracts function executes and NFT is created by some info passed from that button click.
This is a good video explaining and showing how it works: https://www.youtube.com/watch?v=_36JcJRAHHI
You don't need to write your own contract, just use the candy-machine.
If you have any experience in this subject I would like your advice
Yes. Have checked Metaplex but couldn't managed to suit anything from there to my contract..
Sanity check question: All accounts can hold SOL balance, regardless of account type - and if I take a SOL account as argument to a program, there is no need to check the mint type, correct?
This is how NFTs work usually, yes. Are you new to Solana? Take a look at metaplex project.
I have an itch to help with this, but need to do other work first. Will assign+comment in the issue if I start with anything.
Somehow I want this NFT to contain image so when I transfer it to other persons account he can see it..
You mean to store the metadata inside the account, and not on Arweave?
How can I Create NFT with metadata in Solana contract using rust?
and trying to perform this operation
```rust
        let ix = anchor_lang::solana_program::system_instruction::transfer(
            &ctx.accounts.escrowed_vault.key(),
            &ctx.accounts.receiver.key(),
            ctx.accounts.escrowed_vault.lamports,
        );
        anchor_lang::solana_program::program::invoke(
            &ix,
            &[
                ctx.accounts.escrowed_vault.to_account_info(),
                ctx.accounts.receiver.to_account_info(),
            ]
        )?;
```
why am I getting signer privilege escalated
```"GSJ6JqJNBy3CDQ9KxvQaTgZRCAkzK2WdzJ7hmUws61b's signer privilege escalated"```

```
receiver public address :: 7WEPPtzkko4735VfAa8jNiEkxhMMofUqjGcaTrKmPAtb
sender public address (default wallet [id.json]:: 7Hjfz7iC8DwaY8mNg2hT9JfSstT5ovw42d8J9YbN3LCU
Escrowed account :: GSJ6JqJNBy3CDQ9KxvQaTgZRCAkzK2WdzJ7hmUws61b
```

```javascript
      // unloack vault
      const vault_receiver = anchor.web3.Keypair.generate();
      await program.rpc.unlock({
        accounts: {
          escrowedVault: escrowed_vault,
          receiver: vault_receiver.publicKey,
          systemProgram: anchor.web3.SystemProgram.programId
        },
        signers: [vault_receiver]
      })

```


```rust
#[derive(Accounts)]
pub struct Unlock<'info> {
    #[account(mut, constraint = escrowed_vault.receiver == receiver.key(),)]
    pub escrowed_vault: Account<'info, EscrowVault>,

    #[account(mut)]
    pub receiver: Signer<'info>,

    pub system_program: Program<'info, System>,
    
}

```
lmk if you find a resolution. running anchor 1.9.0 and solana 1.9.1
qme too
still doesnt' work
about to try making sure they're both on solana 1.8.5
it works on my other machine, same anchor version
getting a lot of things like `can't compare &anchor_lang::prelude::Pubkey with anchor_lang::prelude::Pubkey`
thank you very much!
There's a reload function in cpiaccount and I think in account as well
if I cause account data change using CPI, how can I see the updated values in the rest of my function? the changes caused by the CPI are not reflected in the account
anyone getting `failed to parse manifest at /Users/connorohara/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-frozen-abi-1.9.0/Cargo.toml`
I was expecting```       "args": [
        {
          "name": "locations",
          "type": {
            "vec": "u8"
          }
        }```
Any idea why this: ``` pub fn handler<'a, 'b, 'c, 'info>(
    ctx: Context<Whatever>,
    locations: Vec<u8> ``` ends up in the idl as ```       "args": [
        {
          "name": "locations",
          "type": "bytes"
        },```?
```rs

pub struct Liquidate<'info> {
    pub state: Box<Account<'info, State>>,
    pub authority: Signer<'info>,
    #[account(
        mut,
        has_one = authority
    )]
    pub liquidator: Box<Account<'info, User>>,
    #[account(
        mut,
        constraint = &user.positions.eq(&user_positions.key())
    )]
    pub user: Box<Account<'info, User>>,
    #[account(
        mut,
        constraint = &state.collateral_vault.eq(&collateral_vault.key())
    )]
    pub collateral_vault: Box<Account<'info, TokenAccount>>,
    #[account(
        constraint = &state.collateral_vault_authority.eq(&collateral_vault_authority.key())
    )]
    pub collateral_vault_authority: AccountInfo<'info>,
    #[account(
        mut,
        constraint = &state.insurance_vault.eq(&insurance_vault.key())
    )]
    pub insurance_vault: Box<Account<'info, TokenAccount>>,
    #[account(
        constraint = &state.insurance_vault_authority.eq(&insurance_vault_authority.key())
    )]
    pub insurance_vault_authority: AccountInfo<'info>,
    pub token_program: Program<'info, Token>,
    #[account(
        mut,
        constraint = &state.markets.eq(&markets.key())
    )]
    pub markets: Loader<'info, Markets>,
    #[account(
        mut,
        has_one = user
    )]
    pub user_positions: Loader<'info, UserPositions>,
    #[account(
        mut,
        constraint = &state.trade_history.eq(&trade_history.key())
    )]
    pub trade_history: Loader<'info, TradeHistory>,
    #[account(
        mut,
        constraint = &state.liquidation_history.eq(&liquidation_history.key())
    )]
    pub liquidation_history: Loader<'info, LiquidationHistory>,
    #[account(
        mut,
        constraint = &state.funding_payment_history.eq(&funding_payment_history.key())
    )]
    pub funding_payment_history: Loader<'info, FundingPaymentHistory>,
}
```
anyone know how I would populate this context? via off-chain solana-sdk rust, not using javascript
anyone around that could help me try and wrap my head around derivaion paths on a Ledger and Solana?
I feel I use this chat as a rubber ducky a bit to much. Sorry 🙂
Figured it out:
treasuryAccount = await Token.getAssociatedTokenAddress(
      ASSOCIATED_TOKEN_PROGRAM_ID,
      TOKEN_PROGRAM_ID,
      NATIVE_MINT,
      **program.provider.wallet.publicKey,**
    );
This is driving me nuts, can someone take a look at this: what account am I missing, and where does the account 2QYHKaRnJujmyECT6jhHBi4xU7JTovdcq2ZBZUdHAwBZ come from? It keeps reporting this exact account on localhost, devnet and across different invocations.
any easy way to handle 3p errors that are not implemented with anchor?
I've redeployed the program (devnet), but still getting the same error
Anchor usually keeps this kind of stuff from happening? Are you on localnet? If not, have you updated your idl?
I see this in the log: Instruction references an unknown account 2QYHKaRnJujmyECT6jhHBi4xU7JTovdcq2ZBZUdHAwBZ, but where this comes from actually? 😮
Very descriptive error here:
Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: An account required by the instruction is missing
-> how can I figure out which account is missing? I'm passing all that are defined in the accounts struct :/
no one announced it in that issue so I assume not. pls push a WIP pr asap / assign yourself via comment if you want to own this. <@!501570363566587905> doing this is possible but is there anything that needs to be done before?
...taking the longest road ever to circle back to anchor, hopefully more updates coming soon. in the mean time https://solanacookbook.com will start to host some anchor recipes.  if anyone has some common question/answers or code snippets to contribute in the mean time, please jump in!   This will be expanding greatly.  Hosting guides, integrations, protocols, cross talk, and.. much more. keep slayn dragons (or riding them). 🐉
i.e. processed
What is the commitment I need to set that takes the shortest amount of time to process
yea, you'll want to do the math but you'll have to fund each account with 2 years of rent
whoa..   cool.  🙂
could be the hardware struggling to keep up or specific rpc queries making it fall behind.
for rent?
if you got the sol
That did fix it. Bless you ❤️ ❤️ ❤️
feasible to store millions of hashes on-chain or nah?
Do I just need to wait x amount of time in my test?
what would cause a node to be behind?
Thanks! Is someone already working on an implementation?
web2 dev terminology 🐒
endpoint is probably the wrong term, I just mean a different function call in my program
or what do you mean when you say "endpoint"?
this means the node is behind
I call a different endpoint however and I'm getting back the account in it's original state
When I query for the account through the javascript API I get back the up to date version and if I call the endpoint that updated the account, it's correct
I'm having a weird issue where my anchor program is loading an old version of an account
Hi, I'm trying to install anchor on MacOS with this command line: cargo install --git https://github.com/project-serum/anchor anchor-cli --locked, and i keep having this issue as it shows on the terminal picture above, any help would be welcome, thank you
<@!887234715940175895> fyi we have an issue for discussion on this https://github.com/project-serum/anchor/issues/1004
Can definitely be done.
Yea same category of thing though
and while I'm making a wishlist: it'd also be neat if information about sysvar accounts and system program accounts were in the idl - that way they could be autofilled. But that's less important imo
agreed
yeah, the general case is impossible, but most uses should be doable
tag <@!347689664855015424>
We can probably do something like declaratively define pda derivations as long as the seeds are constants or other accounts in the ix.
that's the main complication for me
Yeah. I kind of wish pda seeds were available in the idl somehow
The accounts really make this type of thing challenging.
Not that I know of. Looks sweet.
I made a proof-of-concept for interacting with anchor programs from the command line based on the program idl -- does something like this exist already elsewhere? https://github.com/ckamm/anchor-generic-cli


///////////////////////////////////////////////////////////////////////////////////////////////

ah great, ill start with checking that then, I do believe the account has not been initialized. I do remember struggling with using the create vs find method. There wouldn't happen to be a way to first try find and then if not found, create? That would be very useful in this case
If that's the case, the error should become clearer soon with a coming version (distinction between wrong owner/not init)
I think the check for `AccountNotInitialized` happens first (at least in master)
Yeah, if the takerDepositAccount hasn't been initialized yet (above you're just calculating its address), then you could get the error you're seeing
I've checked the escrow account and the owner is the correct program
thank you, ill look into this. I do suspect its probably to do with my derived accounts, I'm thinking the ``takerDepositAccount``
```ts
export const exchangeEscrow = async (
  connection: Connection,
  taker: PublicKey,
  wallet: PhantomWalletAdapter,
  initializer: PublicKey,
  initializerDepositTokenAccount: PublicKey,
  initializerReceiveTokenAccount: PublicKey,
  creatorDepositTokenMint: PublicKey,
  creatorReceiveTokenMint: PublicKey,
  escrowAccount: PublicKey
) => {
  console.log(escrowAccount.toBase58())
  // @ts-ignore
  const { programId, program } = await providerEscrowSetup(connection, wallet);

  const takerRecieveAta = await createAssociatedTokenAddress(
    taker,
    new anchor.web3.PublicKey(creatorDepositTokenMint)
  );
  // @ts-ignore

  const takerDepositAccount = await PublicKey.findProgramAddress(
    [
      taker.toBuffer(),
      TOKEN_PROGRAM_ID.toBuffer(),
      await new anchor.web3.PublicKey(creatorReceiveTokenMint).toBuffer(),
    ],
    ASSOCIATED_TOKEN_PROGRAM_ID
  );

  const { vaultAccountPDA, vaultAuthorityPDA } = await getVaultAccounts(
    programId
  );

  try {
    program.rpc.exchange({
      accounts: {
        taker,
        takerDepositTokenAccount: takerDepositAccount[0],
        takerReceiveTokenAccount: takerRecieveAta,
        initializerDepositTokenAccount: initializerDepositTokenAccount,
        initializerReceiveTokenAccount: initializerReceiveTokenAccount,
        initializer: initializer,
        escrowAccount: escrowAccount,
        vaultAccount: vaultAccountPDA,
        vaultAuthority: vaultAuthorityPDA,
        tokenProgram: TOKEN_PROGRAM_ID,
      },
    });
  } catch (e) {
    console.log(e);
  }
};
```
For your particular problem, I'd say either you pass a TokenAccount that isn't one, or your EscrowAccount has the wrong owner.
and heres my frontend implementation
it may not help with this particular problem, but for debugging I compile against a modified version of anchor that adds logging the start of try_accounts and account constraints for each account: https://github.com/microwavedcola1/anchor/commit/e1006a56180409fa4faf528445c1899ff44a632e
I've ruled out the escrow account, vault account, authority and token program
```rust
#[derive(Accounts)]
pub struct Exchange<'info> {
    #[account(signer)]
    pub taker: AccountInfo<'info>,
    #[account(mut)]
    pub taker_deposit_token_account: Account<'info, TokenAccount>,
    #[account(mut)]
    pub taker_receive_token_account: Account<'info, TokenAccount>,
    #[account(mut)]
    pub initializer_deposit_token_account: Account<'info, TokenAccount>,
    #[account(mut)]
    pub initializer_receive_token_account: Account<'info, TokenAccount>,
    #[account(mut)]
    pub initializer: AccountInfo<'info>,
    #[account(
        mut,
        constraint = escrow_account.taker_amount <= taker_deposit_token_account.amount,
        constraint = escrow_account.initializer_deposit_token_account == *initializer_deposit_token_account.to_account_info().key,
        constraint = escrow_account.initializer_receive_token_account == *initializer_receive_token_account.to_account_info().key,
        constraint = escrow_account.initializer_key == *initializer.key,
        close = initializer
    )]
    pub escrow_account: Box<Account<'info, EscrowAccount>>,
    #[account(mut)]
    pub vault_account: Account<'info, TokenAccount>,
    pub vault_authority: AccountInfo<'info>,
    pub token_program: AccountInfo<'info>,
}
```
You want to post the program  `Accounts` struct here? I can help you try to spot if you want
would be so less daunting if i could just know which one it is
is 10 a lot for solana lol
No easy way. Do you have a lot?
is there a way to know which one or do i just have to figure that out
It means one of the accounts you pass with the type `Account<info, XXX>` is wrong
i see i see
lol they are xD
The error actually means that this account's owner should be program X (say SPL token program), but your are passing an account owner by Y (say the System program)
our NFTs are quite similar 😛
hard to tell without looking at the code. Might be the PDA authority thats not assigned correctly
``Uncaught (in promise) Error: 167: The given account is not owned by the executing program``
does anyone know what this error could mean? Am I passing in a wrong account somewhere?
I think you do need SOL in the deploying account, as much as was needed during initial deployment, but it will be returned to you immediately at the end of the uploading if it is only an upgrade.
Bump 🙏
You'd simply have to run the deploy command again (with your custom program ID option if needed), and it would upgrade it (unless you have marked it immutable)
it is possible on mainnet, so I guess devnet is no different?
Is it possible to re-deploy a program to the same address on devnet (with changes)?
<@!501570363566587905> do you have any recommendation on this issue?
I'm getting the same error now. What does generally cause this? I'm trying to make a cpi call to a 3rd party prorgam and I get this if I try to test on devnet. on localnet they run fine.
Got ya, I will remove code, that broke everything and hope it fixes the problem
Not sure—I'm just saying you should think about each error carefully and then go fix them 😛
The one I changed is 3rd in test cases or it doesn't matter?
So try fixing the first one
Generally if one test fails it'll blow up others that run afterwards
But I haven't changed anything in 2nd test, no idea why it failed too
It worked fine, but I tried to add one more token account and transfer it
Lots of information in there (an account address is already in use, for example)
Yep
This?

They probably got printed higher up in your test output
Where can I find them?
Go find that in the program logs
At any rate, `Cross-program invocation with unauthorized signer or writable account` is the important part!
That's better, but I mean the actual program logs, not just the stack trace in JS
`  1) anchor-escrow
       Sending Money From Vault To Freelancer:
     Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account
      at Connection.sendEncodedTransaction (node_modules/@solana/web3.js/src/connection.ts:3689:13)
      at processTicksAndRejections (internal/process/task_queues.js:97:5)
      at Connection.sendRawTransaction (node_modules/@solana/web3.js/src/connection.ts:3649:20)
      at sendAndConfirmRawTransaction (node_modules/@solana/web3.js/src/util/send-and-confirm-raw-transaction.ts:27:21)
      at Provider.send (node_modules/@project-serum/anchor/src/provider.ts:114:18)
      at Object.rpc [as exchange] (node_modules/@project-serum/anchor/src/program/namespace/rpc.ts:24:23)

  2) anchor-escrow
       Initialize escrow and cancel escrow:
     Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: custom program error: 0x0
      at Connection.sendEncodedTransaction (node_modules/@solana/web3.js/src/connection.ts:3689:13)
      at processTicksAndRejections (internal/process/task_queues.js:97:5)
      at Connection.sendRawTransaction (node_modules/@solana/web3.js/src/connection.ts:3649:20)
      at sendAndConfirmRawTransaction (node_modules/@solana/web3.js/src/util/send-and-confirm-raw-transaction.ts:27:21)
      at Provider.send (node_modules/@project-serum/anchor/src/provider.ts:114:18)
      at Object.rpc [as initialize] (node_modules/@project-serum/anchor/src/program/namespace/rpc.ts:24:23)`
Think you'll have to be more specific
Mm, this is a pretty general question, not totally sure what you mean
Hi <@!134416332509675520> I'm bit confusing with the program account and the app account, and the managing the data in the accounts, can you explain. how that actually works? and in terms of accounts and its storing of data.
Like, strictly speaking you could store sol in a token account (you can send sol to whatever account you want), but the only way to get it out would be to *close* the token account.
Mm, you can only store an NFT within a token account. How are you storing sol in there too? How are you going to get the sol out of the token account?
Or should I create separate account for it?
Can I store NFT within that account?
I'm storying some Solana in the account.
Can you say more? Not sure what you mean
Can I transfer token with lamports + other token (NFT) to one account?
ok
Hey man, nope I couldn't, never got an answer and switched focus to something else. I do think this is a cool thing to have, specially if you're doing an event-oriented dapp to enable real-time updates. If you find a solution please reach out, would love to have this.
We're trying to create NFT and transfer it to the other account.
hey <@!706541980032827454> were you able to solve this issue?
In general it's much easier for us to help you debug if you post full program logs rather than snippets
Anyone knows, what can be problem? I fixed previous one
` Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Program failed to complete`
is there a recommended decimals library to use for on-chain calculations?
`pub fn exchange(ctx: Context<Exchange>) -> ProgramResult {`
vs
`await program.rpc.exchange(mintBump, { accounts: {`

I don't see the mintBump argument contract-side
can you paste the IDL file as well?
https://pastebin.com/SKG629Fv this is contract
https://pastebin.com/UknL3uvh this is test
If you can, paste the full snippet, containing both the rpc call, and the declarations of all the variables involved in it
happens a lot
It's a bit tough to see tbh. Are you passing your arg as a BN?
otherwise look for a typo
make sure your keypair is marked as <Keypair>
Any ideas what can be problem? I send everything, what we expect in rust
Yes but how can I create NFT in the rust ?
an NFT is just a token - you can send it like you would send any other token. If you're using anchor, you'd use `token::transfer`
without any metadata (i guess?).
Just an NFT
what's an "empty NFT"?
So I can not send empty NFT using only rust ?
https://docs.metaplex.com/ - this has everything about how their standard and programs work
NFTs have nothing to do with anchor - what you want is metaplex
Any advice or example ? 😔
nice😊
btw your tutorial got me started in the space:)
thanks
got it
lamports may only be decreased (increase might be allowed, not sure rn) by the program that owns the account. thats whats important to remember
How can I create NFT in the rust program account and then transfer it to other persons wallet on specific function execution?
so if the payer = a PDA owned by my program I need to use `borrow_lamports`, while if it's a normal account then I use `system_ix`?
ohhhh interesting
you do it yourself when origin account is owned by your program
u use this when the account is owned by the system program
system_instruction::transfer and adding/subtracting lamports yourself are not interchangeable just fyi
looks good to me since I'm guessing the lamports is being held by a PDA but not an expert to comment
is that a preferred approach over this tho? feels hacky
```rs
            invoke_signed(
                &system_instruction::transfer(treasury.key, authority.key, amount),
                &[
                    treasury.to_account_info(),
                    authority.clone(),
                    ctx.accounts.system_program.clone(),
                ],
                &[&treasury_signer_seeds],
            )?;
```
oh interesting
Try searching - try_borrow_lamports
or is using this the best way - `system_instruction::transfer`?
couldn't find anything after doing a search for `transfer` or `lamport`
stupid question time: I've seen plenty of examples in anchor repo of token transfers, but what about normal (lamport) transfers? does anchor have a method for that?
You want to reload when a CPI call in the same function has changed the data of the account and you want re-read it from the chain
what is the best way to mint a new token?
minting token? and transferring the token inside the program?
Hi <@!448034961652449283><@!831450660146642974>
We are building a rust server
Is there a way to use the IDL in anchor-client on the rust side
but kind of hard to catch them all ...
we did temp patches in some places in our libraries by using string instead of public key
🙏
https://github.com/project-serum/anchor/commit/517838e494fd0210afa73113b2d5bdc6f244d11f
patch: 
https://github.com/project-serum/anchor/commit/a7e80079dab0beffea77c3336b0680fc11b4e128
offending commit:
this is creating issues for us in prod
<@!501570363566587905> would you mind publishing a patch to the anchor js client?
<@!448034961652449283> ^
could someone approve this?
https://github.com/project-serum/anchor/pull/1137 this is what I need
```solana address -k target/deploy/myepicproject-keypair.jso```
and 
```solana address```
 gives different addresses
is there an alternative to this?
due to which I am unable to construct Wallet in my ts code
Seems like this PR https://github.com/project-serum/anchor/pull/1108/files removed Wallet export from index.ts
same error I will build and try again
erm, no, don't think so. won't hurt tho.
and my address changed do I have to build again?
k, lets get at least 10 SOL in there. (i had to add 2 at a time on devnet. on localhost, you can add an arbitrary amount.)
it was 6 before but I typed solana-keygen recover and got I think resetted to 0
what does `solana balance <your local wallet pubkey>` give? what is the deploy command?
ps, this worked for me as well.
were you able to airdrop yourself 10 SOL in one command on devnet?

i'm getting errors that the max airdrop is 2 SOL.

i'm able to run this `solana airdrop 2 <my-address>` multiple times without issue, though.
I'm getting this error when I try to deploy my solana program with anchor deploy. any idea?
i guess a follow up question is, when is `reload()` needed exactly?
when calling `reload()` on an `Account`, i get this error:
https://github.com/project-serum/anchor/blob/master/lang/src/error.rs#L71
`AccountDiscriminatorMismatch`
it's a data PDA account and also has a `Box<>` around it. Any ideas on what causes this?
I am trying to use Anchor typescript package out of `anchor init` setup, I see that when I try to initialize a provider `ANCHOR_PROVIDER_URL` is not set. What is a good way to pass these config options to my node js project
I tried setting `programs.mainnet` and `programs.devnet` in `Anchor.toml` but it doesnt seem to have any effect
Is there a way to dynamically set `declare_id`?
how would I go about creating a new Wallet from a `Keypair`
hi I was using `anchor.Wallet` from the `typescript` package quite exclusively in 0.18.2 but upgrading to 0.19.0. I see that its no longer a type. What is the recommended alternative?
https://discord.com/channels/889577356681945098/899315988087054397/920967740687286302 Also, if anyone has time to answer this that would be great.
Half of the team is on M1. We are not able to use `err.msg` or anything.
I am running tests with anchor test
it usually show for me without any special setup
was it after `anchor build`?
It did not. I have to setup the default target in cargo to bpf or something for those warnings?
Usually if you get this you also get a warning at compile time telling you the stack is blown
Doesn's sound like much
Thanks that worked!
Thanks <@!915682383905316864>  : )
4 pubkey, 3 u8, 2 u64
but only those and not AccountInfo  / Signer / Program
put a `Box<>` around your `Account<'info, Something>` variables
Alan was helping I think two other devs today with this issue. I believe he mentioned using Rust's `Box<T>` as a way to move these variables to the heap.
I moved anchor's `#[error]` into a separate lib to share it between a number of inter-related programs, and now I'm getting `0x156` type print outs during `anchor test`, without he description for the error. When it was in the same crate the actual error would print. 

Can anything be done? Or am I stuck choosing between convenience and deduplication? 🙂
This means stack size exceeded
Is your program holding a lot/heavy variables?
I am trying to add `pubkey` of an account to a PDA.
```
 Program B7PiFKNiBvQPMVtsJt8bM86U69a1ivev4VvnkLViMiUZ consumed 6004 of 200000 compute units
    Program failed to complete: Access violation in stack frame 5 at address 0x200005ff8 of size 8 by instruction #1440
    Program B7PiFKNiBvQPMVtsJt8bM86U69a1ivev4VvnkLViMiUZ failed: Program failed to complete
```

Access violation in stack frame 5 at address 0x200005ff8 of size 8 by instruction #1440
What does this mean?
Is there a way to get Anchor automatically `create_associated_token_account` using constraints vs doing it in the processor?
That works, cheers 👍 . I think I really over-complicated it here!
have you tried `Buffer.from([0, 1])` or something like that?
If i change it to u16 I get ```      "args": [
        {
          "name": "locations",
          "type": {
            "vec": "u16"
          }
        },```,  which is what I expect. But if it's Vec<u8> I get ```  "args": [
        {
          "name": "locations",
          "type": "bytes"
        },```, which I don't know how to deal with on TS end because there's so many ways to encode bytes
in the IDL file, is there an expected type specified for that particular argument?
I am having issues deserializing my accounts in Rust (not Anchor program)... does anyone have expereince doing this?
If I change it to ```pub fn handler<'a, 'b, 'c, 'info>(
    ctx: Context<Whatever>,
    locations_u16: Vec<u16>, ```, then the idl shows the vec as expected and everything is happy
```    let loc = [0, 1];
    try {
        await program.rpc.Whatever(
          loc,
...etc``` throws TypeError: Blob.encode[data] requires (length 2) Buffer as src
`let loc = [0, 1];` threw the same way?
Tried a few other variations as well: ```    
    let locations: Uint8Array = new Uint8Array([0, 1]);
    let buff = locations.buffer;
    let loc = [0, 1];
    let buf = bs58.encode(loc);```
TypeError: Blob.encode[data] requires (length 2) Buffer as src
What error do you get?
How do I deal with a Vec of u8 on the TS side? The idl for this: ```pub fn handler<'a, 'b, 'c, 'info>(
    ctx: Context<Whatever>,
    locations: Vec<u8> ``` is this: ```       "args": [
        {
          "name": "locations",
          "type": "bytes"
        },``` so on the TS side I'm trying to treat it like a byte array: ```let locations: Uint8Array = new Uint8Array([0, 1]);``` But it's not happy
will try that , thanks
I could not use this type inside a acount struct
You're probably going to have to instead use a vector of key-value pairs
Doesn't currently really work unfortunately 😬
how to store state accounts in Hashmap or BtreeMap 
I am trying to achieve this ,
pub type MyMap = BTreeMap<Pubkey, MyAccount>
Yep. Not a panacea but is super easy to try.
It just moved it from the stack to the heap?
Soooo, what is this Box thing doing?
Saving my butt again, <@!134416332509675520>
ok. wow. I spent ~1.5 hours trying to fix this. and this line just worked.
uff I found it, Shouldn't need Default unless I ain't specifying space
Not totally sure why the upgrade caused that (guess the new version is doing more stuff), but you're running out of stack space. Easiest thing to try is to box some account, Box<Account<'info, Whatever>>
I upgraded my Anchor version from 0.16 to 0.19 and changed some deprecated `ProgramAccount`s to `Account`s. Now one of them is giving me this error ```Program failed to complete: Access violation in stack frame 3 at address 0x200003f20 of size 8 by instruction #60350``` Any ideas?
I am not sure what am I missing in my Accounts struct , but I am getting this  error

no function or associated item named `default` found for struct `MyStruct` in the current scope. items from traits can only be used if the trait is implemented and in scope
the following trait defines an item `default`, perhaps you need to implement it:
candidate #1: `Default


///////////////////////////////////////////////////////////////////////////////////////////////

Ok... just saw it and got really curious... thanks!
What was the rough idea for this state feature? To be able to access state from the program without needing to provide the PDA from the client?
Constructor for the state feature. Best to not use it now as it's deprecated in favor of regular PDAs.
Ok I just looked around in the codebase and it might be what allows the "global program state" abstraction. Maybe one of the core devs have better pointers for you.
as I am reading this...
This seems like black magic not enabled by Solana
```/// The Ctor accounts that can be used to create any account within the program
/// itself (instead of creating the account on the client).
///
/// This is used to create accounts at deterministic addresses, as a function of
/// nothing but a program ID--for example, to create state global program
/// structs and program IDL accounts. It's currently used **internally** within
/// the Anchor `#[program]` codegen.```
Who knows what the Ctor is???
Has really helped me understand Anchor under the hood
Interesting. Might be a good thing to explore to some aspects of Rust. I'll take a look.
On some requests
Also Actix is faster than Rocket, but I don’t really care about that, ie the difference between a 35 ms response and a 40 ms response
I have learned A LOT about async rust and tokio and actors and such
Actix. I like the sugar of Rocket, but their WS support is non existent. From what I can tell, it will be coming out within a few months
(if there is such a thing haha)
What web framework are you using, in Rust?
Yea, haha. Thought so…
You might not have the same websocket limitations if you have a backend in the middle, yes. Or at least you are more in control and it becomes more of a "standard" scaling issue then I guess.
A rust backend to be exact haha
We are using a backend
Oh, gotcha. Cool
Well if you're handling this on a backend this is a different problem. I assumed the context was a pure frontend dapp, since the original discussion (https://discord.com/channels/889577356681945098/889577399308656662/921676356939554817) hovered around making the browser client more responsive through subscriptions
I don’t understand why having a million users would mean you would need to open a million WS connections with an RPC node
Interesting. Why can you not have one connection to the backend listening, and then let the server handle the 1000,000th person
https://discord.com/channels/889577356681945098/889577399308656662/921676494261071892
👆 
Issue is about scaling when you get your million user opening websockets simultaneously I guess
so no need to persist the value on the client then (since compute is free)?
so persisting on Anchor side to save compute, right?
You can recalculate the bump within your program (it's a deterministic function of the seeds), but that costs compute.
Your program needs to know the seeds *and* the bump in order to sign for that address.
what's the point of returning bump value to the caller of `PublicKey.findProgramAddress`? Do we have to persist this value on the client somehow? Finally, why do we have to persist the bump value on Anchor side?
Yea, was doing some studying of the source code and came upon it… don’t know why more ppl don’t use it haha
Haha no worries. Temporary solution though, it would for instance not pass any CI you got setup
Came in clutch to save my hours of frustration haha.
Oh wow, that worked. Thank you so much <@!915682383905316864> 🙂
Oh that's amazing. Will try that now.
for my own testing I simply replaced:
```ts
export * from "./program/index.js";
//# sourceMappingURL=index.d.ts.map
```
with
```ts
export * from "./program/index.js";
export declare const workspace: any;
export declare const Wallet: import("./nodewallet").default;
//# sourceMappingURL=index.d.ts.map
```
in node_modules/@project-serum/anchor/dist/cjs/index.d.ts
I'm just wondering how to get those changes in my node_modules haha. (Obviously before a release BTW)
Are you wondering how to take those changes in before a new release, or how to be sure those changes have been released?
Like, what's the right way of making sure the updated PR changes are reflected in my node_modules?
Is there a way I can just GROK into the node_modules or something?
Oh, thank you so much 🙂
It is purely a typing issue though. You will be able to build/run.
A fix has been proposed here: https://github.com/project-serum/anchor/pull/1137
From my test it seems to work, but it's not approved yet.
Oh dang 😦
There is actually nothing much you can do at the moment, this issue appeared due to a recent commit to allow a browser build
So my question is like, what's the right way to import `Wallet` type inside a Node script by activating the toggle of "Hey, I'm not a browser"?
When I looked upon the source code of anchor, there seems to have this `isBrowser` check, to only export the Wallet if it's not browser?
When I try to import `Wallet` from anchor, it says this error BTW
Hey y'all. Super beginner question, but how am I supposed to export the Wallet type from the JS anchor?
Okay I'll read up on it!
This only happens because of this https://github.com/project-serum/anchor/blob/master/lang/src/accounts/account.rs#L159
awesome! thanks again alan you're a saviour 🙂
Yep, Rust automagically says "hmm, there's no .owner on an Account<...>, but I guess there is one on its underlying account thing"
So that is the reason why we dont need to do ctx.accounts.vault.account.owner?
`Account<'info, Whatever>` implements the Deref trait with target = Whatever.
This is Rust's `Deref` trait in action. https://doc.rust-lang.org/book/ch15-02-deref.html
between that and the param owner
and account clearly has a param "account": here :
when the vault Struct is an Account:
How am I allowed to do this :
Thanks for the quick response, I thought as much but just wanted to check.
Not as far as I'm aware, no.
Maybe I missed this but is there an easy way to reset at some point in your tests so you start with a freshly initialized set of accounts?
In your solana program, you could pass the address in as an account, and then if no account lives there you'll get an "empty" AccountInfo for it at runtime: no data, zero lamports, owned by the system_program (this is what happens whenever you `init` an account from within your program by the way: you pass its address from the client like any other account, despite there not being any account *at* that address yet)
In JS you could do `await program.provider.connection.getAccountInfo(theAccountAddress)` and see if you get something non-null
Ah thats my misconception. How would you go about finding out whether an account exists at a given address?
And no, `findProgramAddress` and `createProgramAddress` have nothing to do with whether an *account* exists at that address (and the address itself always "already exists", you aren't really making anything, you're just "finding" it)
You basically just have to try fetching the account and see if it exists.
I'm gonna give the subscribe method a try and see where that gets me...
I'll give that a try! Thanks man
off the shelf
it is on the rpc object
https://github.com/project-serum/anchor/blob/0f8de4f6af21c63df12f1ef5d59ca1b34fac6746/ts/src/program/namespace/state.ts#L193-L214
Thanks man!
I'll have to think out of the box on this one lol
it is indeed dirty
Yeah limits will def be a problem down the line... Is just that it feels like hack to keep polling
they boom it all implodes
if too many users show up at the same time
so if you do use websockets in your app it could reach the node limit
but there is a limit per node, something like 2k websockets
they are fine for intense singular backend clients
websockets are quite problematic
In reality I'm trying to listen to custom events from a client app in the browser, I want the ui to feel like it's in realtime.. my current solution has been subscribing to program account changes, that works for created/updated accounts, but Id like to also act upon other events
are you looking for the subscription or for a parse the logs of a simulation?
Hey man, is there some example doing what you describe that I can look at?
yeah i'm trying to remove the tx-wide compute cap since it's not active on mainnet yet, will probably just roll back my solana version to before that feature was added
if you just want to quickly test removing a feature not yet on mainnet
and yes it is quite a pain
i don't think so
By default `solana-test-validator` seems to activate all features (they are all `active since slot 0`). Is there a way to turn a certain feature off? There's a `solana feature activate` CLI command, but no `deactivate` it seems
understood. So im curious if you've come across that issue, where you either need to find a PDA or create one. I haven't found a good solution using web wallets because of the ``Token`` class issues as you say; is there a decent way to do this, or does ``createProgramAddress`` check if its already created?
That's the odd part
I'm using the official dockerfile: https://hub.docker.com/layers/projectserum/build/v0.19.0/images/sha256-59f3c7201a5ea2d7a08d923a23669a1855c18d08f9c604351b7a24f8bdd3debd?context=explore
I think if I remember right you need a newer version of solana? 1.8.0 is kind of old
I'm trying to set up some CircleCI tests for my Anchor project, but keep hitting this error:```BPF SDK: /root/.local/share/solana/install/releases/1.8.0/solana-release/bin/sdk/bpf
Running: rustup toolchain list -v
Running: cargo +bpf build --target bpfel-unknown-unknown --release
    Updating crates.io index
error: failed to download `solana-frozen-abi v1.9.1`

Caused by:
  unable to get packages from source

Caused by:
  failed to parse manifest at `/root/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-frozen-abi-1.9.1/Cargo.toml`

Caused by:
  feature `edition2021` is required

  consider adding `cargo-features = ["edition2021"]` to the manifest

Exited with code exit status 1``` Anyone have ideas?
but we do have all sorts of polyfills
Mmmmh, we are using events parsing from logs returned from a simulation, not sure if that hits the part with assert
Did you ever figure this out?
The issue is just that the `Token` class's api is weird/inconvenient :/ I think they're refactoring it, but until then you kind of just have to manually build + send instructions that talk to the token program (basically, go source-diving into the Token class and just copy-paste stuff + do it yourself)
Haven't successfully signed and completed a `Transaction` with the resulting `TransactionInstruction` though
I figured it out, it expects `anchor.BN`'s as arguments
Hello, sorry to tag you, but I'm wondering if you found a solution to this issue
No worries, appreciate the help
sorry I thought it was for tests
As in i want the user / signer to be the web wallet
Right but doesnt that defeat the purpose of using web
`Keypair.generate()` will create a brand new keypair (public + private together) which can be used to sign what you want.
Im unfamiliar with this is it possible via web?
Well I have to for the dapp
do we have any other anchor based scaffolds/templates/boilerplates anyone can recommend?  

there is anchor init, any other options?
https://project-serum.github.io/anchor/cli/commands.html#init
couldnt you just pass your own fake signer?
Do you have to use a web wallet for tests?
will review thanks
i know that program has a ``findOrCreate`` method
its not quite 1 to 1 from the tests
The only problem I've had with that, is that the ``Token`` object requires a signer in instantiation, and with a web wallet I'm having a difficult time implementing it
not sure if this is what your looking for but you can check it out: https://github.com/solana-labs/solana-program-library/blob/e29bc53c5f572073908fb89c6812d22f6f5eecf5/token/js/client/token.js#L536
probably what <@!401533121817739265> wrote above
ah yeah that's exactly what I've been using
what if you want the frontend to create them?
```
 mintB = await Token.createMint(
      provider.connection,
      payer,
      mintAuthority.publicKey,
      null,
      0,
      TOKEN_PROGRAM_ID
    );
initializerTokenAccountB = await mintB.createAccount(initializerMainAccount.publicKey);
```
https://github.com/ironaddicteddog/anchor-escrow/blob/master/tests/anchor-escrow.ts
Has an example of how you could init a token account in tests
I use annotations like (only sensible if you want your program to create these)
```
    #[account(
        init_if_needed,
        associated_token::authority = authority_acc,
        associated_token::mint = mint_acc,
        payer = payer_acc
    )]
```
lemme check
I think I saw a function called `getOrCreateAssociatedAccount`  once. Not sure if it was in a third party library though


///////////////////////////////////////////////////////////////////////////////////////////////

Ahh bless 🙇‍♂️
i.e. when I have init_if_needed, how do I know I'm initializing or not?
What's a good way to check if an account is being initialized or already has been created?
But now the program I'm calling is actually the metaplex token metadata program, do u know if there is a good way to debug it?
Yes I also suspect this being the case
alright, i'll have a look again. thanks a lot! 🙂
I think you can simply pass the path to the keypair to it
Not needed for `build`, but needed for deploy. See the `--program-id` option of `anchor deploy`
hmm i see, I think I got confused because I didnt figure out how to pass the new keypair to anchor build / anchor deploy (or I just realize, is this actually needed?)
wow thanks a lot. this helps us with our problem
copy-paste from their discord:
```
Please see rpc-support-faq if you have questions!

Mainnet Endpoint
https://ssc-dao.genesysgo.net/

☝️ Handles both https and wss connections. Unlimited RPS, unlimited data, global DNS load balancing for lowest latency, backed up by 300+ bare metal servers in 9 countries across 3 different continents. Also has the full ledger history back to the genesis block.

👇 Devnet endpoints, they're uglier bc it's just devnet but they work just fine!
Private Cluster Devnet 
https://psytrbhymqlkfrhudd.dev.genesysgo.net:8899/
wss://psytrbhymqlkfrhudd.dev.genesysgo.net:8900/

This network is our actual live network that powers the largest projects on Solana.

There is not a "better plan" bc this network has literally all the possible throughput a RPC network of 300+ bare metal 4ghz 1TB RAM machines can produce.

Yes, it is available at no cost. 
```
One way this can happen is if the CPI requires a certain PDA to get passed. If you accidentally miscalculate the PDA you'll end up passing the right *number* of accounts, but the expected PDA won't be there.
I believe they also have a devnet endpoint. Check out their discord, they have a channel with the URL info
This probably means you're doing a CPI but accidentally not passing the correct accounts.
if you opt for 2, look into genesysgo. They have mainnet network publicly and freely accessible until end of the year (which is now soon) but there are talks of prolonging it
You have two options:
1. optimize your calls (batch, lazy load, etc)
2. switch to an unlimited provider
You are being rate-limited by the RPC provider. Are you using the public network?
gotcha. thanks! I thought you could just put the programId as the owner in createWithSeed, but what i missed here is that in order to create the account, the caller has to be able to sign the transaction (which it can't if you set programId as owner).
Hey everyone,  we're getting this while trying to run our tests on devnet. We need to test on devnet a bit since we're interacting with a different program. ```  Error: 429 Too Many Requests:  {"jsonrpc":"2.0","error":{"code": 429, "message":"Too requests for a specific RPC call, contact your app developer or support@rpcpool.com."}, "id": "ac8988d5-7d6d-4c31-9b53-6ea743a3e057" } ``` Does anyone know how to fix this? Should we change rpc providers?
that way you don't rely on the one generated in `target` at all
You will definitely get different keypairs generated by the `build` step, on two fresh builds. That's why an easy way it to track 1 keypair file *outside* of the target folder
why are you worried about `anchor build`? I think we discussed this a while back, maybe I wasn't completely clear
do you have the IDL file? it sounds like you have forgot to add an argument basically
but how would i specify this when doing `anchor build` or can i just switch the keypair after I run `anchor build`?
Hi does anyone know where this error message is coming from? ```An account required by the instruction is missing``` I dont find it in the anchor framework nor in the solana program code...
is there any way that I can change the owner of the mint account on start of solana test validator on local?
you could just share the same keypair inside the same repo
ah, and this one gets generated from scratch if not specified otherwise? also, what best practice would you recommend if multiple-people work on the same project?
why are you sending this kind of message to me.

I am trying to deploy the anchor basic example, but failed with the message,

eploying workspace: http://localhost:8899
Upgrade authority: /Users/user/.config/solana/id.json
Deploying program "basic-1"...
Program path: /Users/user/Desktop/asdansd/examples/tutorial/basic-1/target/deploy/basic_1.so...
Error: RPC request error: cluster version query failed: error sending request for url (http://localhost:8899/): error trying to connect: tcp connect error: Connection refused (os error 61)
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }

any help please?
I made it work, thank you so much. mea culpa cause I was using 0.13.38 and I didn't have the makeConsumeEventsInstruction
Got it. That keypair isn't the one used for the program id, so yeah, I'd expect you both to get different program ids (the program id keypair is in target/deploy/your_prog_name-keypair.json)
this one: `Keypair Path: /Users/username/.config/solana/id.json`
Which keypair are you referring to? Where is it located on the filesystem?
Me and a friend of mine have the exact same local keypair, but when we do `anchor build` we get different program-id's. Is this expected?
yeah, that's my use case, too
You can also just run the default rust crank from the dex repo but I use this for local net tests
thank you so much, much appreciated!
```javascript
// TODO Eventually return these as instructions to be added to the main rpc call
async function crankEventQueue(provider, marketClient) {
  let eq = await marketClient.loadEventQueue(provider.connection);
  let count = 0;
  while (eq.length > 0) {
    console.log("begin")
    const accounts = new Set();
    for (const event of eq) {
      accounts.add(event.openOrders.toBase58());
      // TODO in Daffy's code they have a max of 10 pubkey per consumeEvents call
    }
    let orderedAccounts = Array.from(accounts)
      .map((s) => new PublicKey(s))
      .sort((a, b) => a.toBuffer().swap64().compare(b.toBuffer().swap64()));
    console.log("Here are the ordered accounts to be processed", orderedAccounts);
    let openOrdersRaw = await provider.connection.getAccountInfo(orderedAccounts[0]);
    let thisOpenOrders = OpenOrders.fromAccountInfo(orderedAccounts[0], openOrdersRaw, DEX_PID);
    console.log("loaded up open orders: ", thisOpenOrders.owner);




    const tx = new anchor.web3.Transaction();
    tx.add(
      marketClient.makeConsumeEventsInstruction(orderedAccounts, 20)
    );
    await provider.send(tx);
    eq = await marketClient.loadEventQueue(provider.connection);
    console.log("end")
    count += 1;
    if (count > 4) {
      console.log(orderedAccounts);
      break
    }
  }
}
```
Hmm can't find it
I'm trying to find it now
ok, thanks. I'll give it a search, thanks a lot anyways!
I don't know about the cloning part. You just have to run a consume events crank. I've posted JavaScript code for this before
I was looking at this for the chronological order of instructions
got it, so in order to run a crank separately, I have to basically clone the serum market and run the consume events instruction, right?
Also if it's a public market then sure, you can probably just trust the cranker runners. But there's no harm in also running a crank as well. Though it would be unrelated to your program that does all the CPI
yep, I have that
No harm in just trying it out
There's an anchor dex CPI for closing open orders accounts
My best guess would be that consume events needs to be run before the open orders can be closed. Even if it's a taker order. However I would still give it a try, just attempt to close the open orders account after the taker order + settle
got it, thanks! 

it's a public market, let's say sol/usdc, and the user is the taker. on localnet, it settles in the same transaction, funds are received as expected, but the issue is testing closing the open orders account after the settlement. 

and the cpi library that serum offers doesn't include the consume event instruction, so that's why I was asking.
You can try submitting crank stuff but the way the event queue works is that it only takes ordered pubkeys, so even if you submit your own pubkey it's like not the first in the list, you just have to wait for it to be cranked. Either by yourself or someone else. Unless you're a taker, if you're a taker then it's fine, you should be able to settle in the same transaction
It really depends whether you are personally responsible for creating the market you're trading on
That is why I can create with seed 0 a stake account like everyone else and it works
So the scheme is unique per wallet
Create with seed includes the signer pubkey in the derivation
given that 
- Pubkey::createWithSeed can create any address
- SystemInstruction::createAccount can allocate any account given a key
- Pubkey::create_program_address is just createWithSeed with seeds [seeds, programId, "ProgramDerivedAddress", bump]
- bump is a u8

is this a possible attack vector on contract that utilizes on PDA?
- attacker looking at the seeds of the PDA
- recreate the address with createWithSeed[seeds, programIdOfAttacked, "ProgramDerivedAddress", bump]
- createAccount on all 256 (u8::max) bumps with themselves as a owner
- squat on them and if the program tries to create an account with the same seeds, it'll always be taken because all the bumps are taken?
the main reason I want to use it is to close the open orders account, which remains open
because I want to make sure my order gets settled in the same transaction, I’m doing a swap (new order + settle)
does relying on crankers include any risk?
about the crank mechanism. should I include the consume events instruction explicitly, or should I rely on crankers?
Synthetify have a decimal library too that people like
You can do a Anchor macro on an account like this if that's easier
``` #[account(
        seeds = [b"FooHash".as_ref()],
        bump = Pubkey::find_program_address(&[br"FooHash"], &id()).1
    )]```
What do people recommend for doing decimal math in Rust/Solana? Is there a popular cargo package. It appears SPL has kinda written their own: https://github.com/solana-labs/solana-program-library/blob/master/token-lending/program/src/math/decimal.rs
Ok, thanks!
You'd need to know the seeds. Going in the other direction would require inverting the hash function, which, yeah, you can't really do.
or just pda => bump
findProgramAddress is: [seeds + programID => pda + bump], right? i'm wondering if it's possible to do: [pda + programID => bump]
Unlikely you will get many answers here but I will try to read them at least if they're short
What kind of questions
findProgramAdress
the serum dev channel seems to be dead, as in no one is responding. could we ask some questions here around serum?
not totally clear on the equation there
does anyone happen to know how to get a bump from a PDA and programID in ts?
any time something fails 50% of the time it's usually a bump issue
I'm logging the values for these, in the solscan logs theres the beginning balance, reclaimed lamports, and ending balance so I know this code is correct. Also when testing it I only hit this error when I enter the if block that calls the revoke
A bit more specifically I would verify that the last `checked_add` is not adding the amount behind the reference to `trade_state.lamports()`  (==0 at this point), rather than what is intended as the initial value (first line)
Have you logged the values of the accounts you are transferring lamports between, here:
```rust
        let curr_lamp = trade_state.lamports();
        **trade_state.lamports.borrow_mut() = 0;

        **fee_payer.lamports.borrow_mut() = fee_payer
            .lamports()
            .checked_add(curr_lamp)
            .ok_or(ErrorCode::NumericalOverflow)?;
```
or at least at the end of this snippet, just to make sure that the balances are as expected (i.e. swapped) at that point?
I also asked this in Metaplex discord but figured this might be a general solana thing too:

Does anyone know what would cause this error: 
Program returned error: sum of account balances before and after instruction do not match

When performing a revoke instruction?  https://github.com/metaplex-foundation/metaplex/blob/d24e9bdc70bd156b1873ec3733481702e09f4851/rust/auction-house/src/lib.rs#L547-L562

This is the tx that is failing https://solscan.io/tx/4BFswfF3y1URijbBdhcxipQPPSpoA2RLtFUvxdKhMajFcjb2dEGeSk1VEuxJfAeYgLRUHdDPkX2hM5HXP3HVf2WT?cluster=devnet

I know it's happening during the revoke because I added some logs around it and this error  doesn't occur if it doesn't enter that if block.
I have a test that non-determenistically fails.

1. I call an instruction to update 2 PDAs, which it does
2. I do the test, both are updated
3. I call the same instruction again, which should produce another update to both PDAs
4. This time only one is update of the two

Worst part it's non-determenistic, happens in about 50% of cases. Running on localnet with `anchor test`

Any thoughts?
I'm having a light typescript issue with anchor's tests

whenever I have a struct nested inside a struct in Rust - and try to access it like this js side:
```js
relevantAccount.parentStruct.childStruct
```

the childStruct isn't recognized by TS. It's a minor issue but results in like 50 `ts-ignores` in the file. Is there anything that can be done?


///////////////////////////////////////////////////////////////////////////////////////////////

Gotcha thats the one 🙂

Sorry, can you show the actual rust function? The `pub fn initialize` part


Can you show your instruction function?
getting the too many arguments error even when my program accepts a bump and an object of accounts and signers

Did you fix it <@760117293689733160>
Yeah, basically
to calculate how much is left
oh ok, so you'd have to go through the data and see where the zeros start
That's just how big the `.data` field is, if you did e.g. `await program.provider.connection.getAccountInfo(theAccountAddress)`
hmm, okay, is there a way to see how many bytes total has been allocated for the account?
Solana itself doesn't know what those bytes mean, so to calculate how many bytes are left, so you'd have to figure that out manually
You would have to just fetch the account and see how big its data field is
Is there an on-chain way in anchor to query the current space stats of an account? Off chain too actually, but mainly on chain
Basically just how much total space is the account allocated for, how much space has it used, how much is left, etc
yeah that would be nice
Hey, I can screenshare for about 20 mins now if that works?
wtf i did a factory reset and downloaded everything like it is said in the docs
THIS SHIT IS KIDDING ME
getting `error: no such subcommand: build-bpf` when running `anchor build`
yeah anchor is installing right now 255/547 installed
Gonna take a while 🙃
Yeah so if from a fresh clone you try running anchor init and anchor test, lmk if it works
thanks!!
this gives me a lot of hope haha 😦
i have an intel but will switch to m1 pro in 2 weeks.
I am having a lot of trouble getting anchor to run on my Intel MacBook, even when I clone the base repo and run anchor init and anchor test, it says the executable directory doesn't exist. It runs when I create it with the js flag though
Are you running a m1?
<https://youtu.be/oD1umX_DnUw>
I made a video a while ago that's still mostly valid
But only if you really have some spare time left. Don't want to waste your time with something like this
<@!134416332509675520> 
Hey, we talked 2 days ago where we tried to get my `anchor build` going 🙂
After endless trying I decided to factory reset my macbook air. I somehow manage to delete my systems software. (Dont ask how i managed to do that). After like a day or so i figured out what happened.

I am now setting everything up and if you got a little time I would really appreciate a little walk through how to set solana, rust and anchor up. 
Don't want to mess up again 😆 
(I know how to do it and already did but so afraid that it won't work again with the bpf loaders and `anchor build`)
I'd try the web3.js client to confirm. Wouldn't be surprised to see duplicates.
(if there is an existing one)
is there a way to find the public key of an existing spl-token faucet on devnet?
```connection.onAccountChange(keyPair.publicKey, async function (accountInfo) {
            console.log(accountInfo.data.toJSON());
            console.log(accountInfo.lamports / LAMPORTS_PER_SOL);
            try {
                const response = await connection.getConfirmedSignaturesForAddress2(keyPair.publicKey, undefined, 'finalized');
                console.log(response);
            } catch (error) {
                console.error(error);
            }
        }, 'confirmed')```

I'm listening to 10000 different public keys using the above function. Is this ok, or there is a better way to do it? Thanks in advance
Just to add I'm testing it on devnet
does the RPC's `logsSubscribe` send duplicate log messages or am I doing something wrong in my websocket client?
<https://spl.solana.com/token#wrapping-sol>
oh sounds great! many thanks for your help!
there might be some official solana documentation on wrapping sol as well
they handle sol wrapping in the client
you could check out serum/swap repo
there's no good resources to point you too unfortunately
ohh interesting, any resources I can find related to wrapped SOL? Or its just some Mint I can create on the fly myself?
just use wrapped sol as the mint
Hi there,
Im looking at serum related code in Anchor https://github.com/project-serum/anchor/blob/master/spl/src/dex.rs#L278, just wonder if its possible to have one currency in the market being SOL instead of both needing to be Mint accounts?
Got this error outta nowhere in test file...```Argument of type '[any, BN, BN, BN, any, { accounts: { initializer: PublicKey; vaultAccount: any; mint: any; initializerDepositTokenAccount: any; initializerReceiveTokenAccount: any; escrowAccount: PublicKey; systemProgram: PublicKey; rent: PublicKey; tokenProgram: PublicKey; }; instructions: TransactionInstruction[]; signers: Keypai...' is not assignable to parameter of type '[...(number | BN | PublicKey)[], Context<Accounts<{ name: "initializer"; isMut: true; isSigner: true; } | { name: "mint"; isMut: false; isSigner: false; } | { name: "vaultAccount"; isMut: true; isSigner: false; } | ... 7 more ... | { ...; }>>]'.
  Type at position 5 in source is not compatible with type at position 1 in target.
    The types of 'accounts' are incompatible between these types.
      Type '{ initializer: PublicKey; vaultAccount: any; mint: any; initializerDepositTokenAccount: any; initializerReceiveTokenAccount: any; escrowAccount: PublicKey; systemProgram: PublicKey; rent: PublicKey; tokenProgram: PublicKey; }' is missing the following properties from type 'Accounts<{ name: "initializer"; isMut: true; isSigner: true; } | { name: "mint"; isMut: false; isSigner: false; } | { name: "vaultAccount"; isMut: true; isSigner: false; } | { name: "initializerDepositTokenAccount"; isMut: true; isSigner: false; } | ... 6 more ... | { ...; }>': user, vaultInitializerSol```
You are the legend
I'm doing `.key` at the end
lol
Heh, I typed out the answer 😉
Yes but question for me is, how?
Just gotta follow the error message, it's telling you you need to pass a Pubkey there, not an AccountInfo: `ctx.accounts.vault_initializer_sol.key`
```41 |         system_instruction::transfer(&payer, ctx.accounts.vault_initializer_sol, project_price);
   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&anchor_lang::prelude::Pubkey`, found struct `anchor_lang::prelude::AccountInfo`

For more information about this error, try `rustc --explain E0308`.```
Don't even need to init anything, just send it some money in your instruction handler.
You could something like this:
```.rs
#[derive(Accounts)]
pub struct Whatever<'info> {
  #[account(mut, seeds = [b"the_vault".as_ref()], bump)
  the_vault: AccountInfo<'info>,
  ...
}
```
Ah Perfect thanks a lot, I’ll take a look at that
So, I want on initialization, initializer to store sol in program(vault) until specific action. I think I might need temporary program account for that but I don't know how to declare account with correct types..
Here's mine fwiw: https://github.com/cqfd/quidproquo
You're going to actually want to use program-derived addresses for that, take a look at the various escrow examples floating around
Hmm 🤔 I want to generate a temp keypair to which I can transfer token. But it need to be persisted to an account for a short time
Don't think you even can do that in your solana program—what are you trying to do? Why would you want a keypair on-chain?
Depending on what you're doing, you might not even need to create an account at all. You can just send the destination address some money. If it lives at a program-derived address, you can then subsequently resend the money somewhere else by using the system_program `transfer` instruction, and sign with the PDAs seeds + bump.
Thanks, it works but did not solve my problem 😅 I want to generate a keypair, any advice for a crate here?
try importing solana-program
Another day another try 😁 how do I use the solana-sdk in my anchor project? Importing the crate in the Cargo.toml breaks the „anchor build“ command 🤷🏼‍♂️
how can i create account for that?
Anyone get and fix this error when using next.j? 

error - ./node_modules/@project-serum/anchor/dist/esm/workspace.js:20:0
Module not found: Can't resolve 'fs'

Import trace for requested module:
./node_modules/@project-serum/anchor/dist/esm/index.js
./pages/createBounties.tsx
Figured out my issue. I was passing in the wrong program ID. IDK why I expected the line `anchor_lang::declare_id!("cndyAnrLdpjq1Ssp1z8xxDsB8dxe7u4HL5Nxi2K5WXZ");` would enforce that the program ID is `cndyAnrLdpjq1Ssp1z8xxDsB8dxe7u4HL5Nxi2K5WXZ` when deployed to localnet 😠
Yes we will, but it will probably be tomorrow when my mind is fresh hahaha
Sg, we'll get it potatoe don't give up 🙏
idk I think I am calling it a night, my head hurts lol 😭 Ill let you know if I figure it out, let me know if you figure anything out haha
Who owns a PDA before it is initialized?
Honestly I just copied the candy machine code for allocating a PDA, not sure why I can't get it to work
I also have the signer paying for the struct marked as mutable 🤔  Maybe they don't have enough lamports?
Yep, I'm printing them out on my JS client and I'm getting the same seed + PDA that is showing up in my error logs + print statements
Are you absolutly sure your seeds match?
I see, I think I have a slightly different situation since I'm failing to instantiate the account (which happens in the generated anchor code IIRC)
Ya I did for this ```update_metadata_accounts(
                *ctx.accounts.token_metadata_program.key,
                *ctx.accounts.meta_data.key,
                *ctx.accounts.signer_account.to_account_info().key,
                None,
                Some(new_data),
                Some(true),
            )```
Simple q, where'd you print the instruction out above? Like what file did you add the `msg!` call?
Yup lol Seems like we are all stuck on this 😭
Lol you're also working with Metaplex? Nice
Ya, mine is already initiated
You've already instantiated your PDA correct? I'm running into errors trying to instantiate mine
```Program log: Instruction { program_id: metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s, accounts: [AccountMeta { pubkey: Gi2KRtkh7VW3ZzbhocdC852R3F6y71N7fk4HyvJBR12M, is_signer: false, is_writable: true }, AccountMeta { pubkey: BmqrjqkZ1911XEoWHfjkh7ytMn1wsjTWmGWM9C2Wfmd, is_signer: true, is_writable: false }]```  Well It looks like the metadata account is being passed as writable but not a signer, and the PDA is passed as a signer but not writable
Just to make sure I'm passing in the seeds correctly
Adding some log statements within the macros as well, for example: `seeds=[{msg!("SEED be {:?}", PREFIX.as_bytes()); PREFIX.as_bytes()}]`
I also simplified my `seeds` down to just the string `candy_machine` (as bytes) and I'm still getting the error. Trying to narrow this down
np, we in this together potatoe
I will take a look at this. Thank you for the reference!!
Also took a look at this issue: https://github.com/solana-labs/solana/issues/14522

Is it possible the error is due to a read-only account being passed as writable?
Ya, I read through that, but I have checked so many times that #1, the PDA has update authroity and #2 I am using identical seeds
This thread is helping out a bit: https://discord.com/channels/889577356681945098/889702325231427584/912655014525292555

Are you also getting the `signer privilege escalated` error?
Ya, I am doing something similar, I just dont know where we are going wrong haha
Error: `Cross-program invocation with unauthorized signer or writable account`
I'm actually having a similar issue with a fork of the candy machine Metaplex. How are you passing in the seeds in the anchor macro?

I'm passing it in as follows:

```
    #[account(init, seeds=[PREFIX.as_bytes(), mint.key().as_ref()], payer=payer, bump=bump)]
    rbac: ProgramAccount<'info, RbacMetadata>,
    #[account(mut, signer)]
    payer: AccountInfo<'info>,
     #[account(mut)]
    mint: UncheckedAccount<'info>,
```

Any way to debug what address is created from this anchor macro? Saw some people mention `cargo expand`?
Is there a way to enforce that an instruction is called via CPI?
`instruction modified the program id of an account`
but i think there's just something wrong with 1.8.5
but got it working with https://github.com/metaspan/solana-docker-mac-m1
i'm having inssues with this
The longer I stare at it, the more I come up with bizarre solutions 😂
Ya, I've been stuck for a few days lol 😂
this is v similar code to whats in the metaplex repo and its literally what Im trying to test rn but cant haha
This actually works for you? lol I have almost the same thing and I keep getting unauthorized signer error.
this is to update the data not change update authority
update_auth_seeds is just any random set of seeds that your program owns and already has update auth
this is the way I'm passing it into the cpi

I'm no help when it comes to Mac sorry lol
just found this issue, exactly what I'm getting it seems the command in the docs installs the wrong version?
Yup, that's why I don't know if it's metaplex CPI  being mad or Anchor
https://github.com/project-serum/anchor/issues/945
on Mac, the reason is that I am running out of options for why anchor isnt working lol, reinstalled anchor twice now, solana is working fine but not sure what to do anymore
are you passing signers as &[&signers] -> where signers is an array of seeds
On which OS? I did it once on Windows. Is there a certain reason why?
I'm passing the right seeds I believe haha
I'm calling update_metadata_accounts. I can create the instructions, but I can't seem to sign them
Also does anyone know a good way of uninstalling solana and solana-cli? should I just delete the .config file it generates, trying to understand why my anchor isnt working
im assuming you are using update_metadata call then? Do you initialize an account inside your program with the correct seeds?
I am trying to call a metaplex program, but im using my PDA as a signer and giving my PDA update authority.
```
'use strict'

import {clusterApiUrl, Connection, PublicKey} from '@solana/web3.js';

const connection = new Connection(clusterApiUrl('devnet'), 'confirmed');

const newPublicKey1 = new PublicKey('5mYzrPBVLZCutvGCKLrQ1V5tNE81agZXNHkRGpCtLU3E');
const newPublicKey2 = new PublicKey('J8ftRpHq8zPKJHB5miQP1W8GkoTxtL12PhKWXrCR83cq');

connection.onAccountChange(newPublicKey1, function (accountInfo) {
    console.log(accountInfo.data.toJSON());
});

connection.onAccountChange(newPublicKey2, function(accountInfo) {
    console.log(accountInfo.data.toJSON());
})

```

This is the program I have written to listen to update on the specified public keys. This is correct, right? Or would you suggest me to do something different
maybe post the seeds you are using? is it for a custom program or a metaplex program that you are trying to call?
Lmk if you want to work on this together. I'm stuck on exactly the same thing
Ohhh lol well then I'm not sure haha
thats the thing haha, I bought the intel processor specifically to avoid problems
https://swaroopmaddu.medium.com/solana-installation-in-macbook-m1-b08582d50db1
Ya the new M1 processor is giving a lot of people troubles haha there is a guide though somewhere
I have also been going crazy trying to get anchor's minimal example to work, I did a fresh install of everything including anchor (on a new macOS) and when I run anchor init and try anchor test within the program it says unable to start validator with an error log of "Error: program file does not exist: <path to the .so executable>"
I have been going crazy trying to figure this out lol 'Cross-program invocation with unauthorized signer or writable account'  means I messed up my signer seeds right?  Is that dependent on the instructions I send, or is my program saying it cannot sign for those seeds?
oh wow I didn't know that
All vectors take up 24 bytes on the stack, regardless of how many elements they have (the data itself goes in the heap, not on the stack)
but usually yes
the serialization is decided by the program at the other side
<@!831450660146642974> I assume that a bool still takes up the full byte, right?
risk? probably not, you always put the same data into it anyway
ugh! tough 🙂
<@!831450660146642974> do you know if there is any risk in creating a unbound vector on the stack for Solana program execution?
in my case above it is even more yucky, i am calling an anchor program for a program that doesn't expose a crate with the bindings 😒
Yes
I see, so in this case I would create a bytes vector. First byte will be the instruction index, then I can serialize the instruction
Thanks, unfortunately I am not integrating with the Token program
but if you are using the token program all the instructions are already around in anchor_spl, i think
```
   let mut data = Vec::new();
   data.push(<stuff>)
...
    let accounts = vec![
        AccountMeta::new_readonly(*ctx.accounts.pool.key, false),
        AccountMeta::new_readonly(*ctx.accounts.pool_signer.key, false),
        ...<More>
    ];

    let ix = solana_program::instruction::Instruction {
        program_id: *ctx.accounts.other_program.key,
        accounts,
        data,
    };
    solana_program::program::invoke(&ix, &ctx.accounts.to_account_infos())
```
is there any way to do that without having to import every instruction?
<@!831450660146642974> how can I create an arbitrary instruction in Anchor if I know the parameter struct and the index of the instruction?
I think transfer checked is for offline signing, some story about signing something without getting weirded by decimals
I didn't know I was using `TransferChecked` under the hood, it's clear now. Thanks
thank you! that was the missing piece 🙂 I appreciate it
AHA!
the transfer with decimals is TransferChecked
but look at the file above, definitely hardcoded as 0x03
sorry <@!831450660146642974> I mean instruction
event? Not sure what event means
However, `Transfer` event is the 4th index (so I would expect the first byte to be `0x03` So why is it like 13 instead?
in the same file you can see the encoding for other instructions
For example I'm looking at a token transfer event
```
0c 40 1c f6 20 00 00 00 00 09 
```
I can recognize the amount that I'm sending `553000000` and the decimals `9`
One single byte, 1
https://github.com/solana-labs/solana-program-library/blob/master/token/program/src/instruction.rs#L550
So just to be clear sollet.io can be defined as a program here, right?
For example, if I was to call `InitializeAccount` on a Token, what does that look like from bytes perspective?
Hey guys, do you know how instructions are encoded/serialized on Solana?
Each account owned by some program, it's can be SystemProgram, SplToken, your program, my program, etc. So that 10k accounts which you want to monitor... who own them? Then you can subscribe on accounts updates by this program.
I might be dumb to ask this but what do you mean by "all accounts owned by a specific program"?
`onAccountChange` allow you to watch only for 1 account, `onProgramAccountChange` allow to watch on all accounts owned by specific program. If you need monitor SOL balance then need subscribe on SystemProgram.
I can be wrong but worth to try.
https://solana-labs.github.io/solana-web3.js/classes/Connection.html#onAccountChange
<@!448034961652449283> I think `onAccountChange` would be more appropriate, dont you think?
anyone have a minimal viable pyth integration with testing example?
Looking
ok, I was wrong about `logSubscribe`. You need to subscribe on SystemProgram account so you will receive new account state on each change.
https://solana-labs.github.io/solana-web3.js/classes/Connection.html#onProgramAccountChange
And again thank you <@!448034961652449283>
I tried it again and it did work. My next query would be is there a way that I can get the lamports as well?
Not sure why you did not received messages, try to subscribe with empty filter
Also this is the public key that I'm using `5mYzrPBVLZCutvGCKLrQ1V5tNE81agZXNHkRGpCtLU3E`
I was testing websocket using Postman though
js
js / rust?
Am I doing anything wrong?
I did test this rpc api with ws connection and mentioned my public key but, I received no message on it.

```
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "logsSubscribe",
  "params": [
    {
      "mentions": [ "11111111111111111111111111111111" ]
    },
    {
      "commitment": "finalized"
    }
  ]
}
```
I used sollet to request airdrop but didn't receive any message on my websocket
Thanks!
`"my-key".parse::<Pubkey>().unwrap()`
rust or clientside?
The above error occurs when I try to initialize an AccountInfo for program_pda dont really understand what it means
Is there an easy way to convert a string to a pubkey in anchor
Yes, `logSubscribe`
And thank you for replying <@!448034961652449283>
Just to be clear you are talking about `logSubscribe`, right?

https://docs.solana.com/developing/clients/jsonrpc-api#logssubscribe


Why you need 10k connections? 1 `logs` subscription should be enough <:think:760605713189306449>
Hey everyone.

I'm integrating solana to our application and as a developer I need to have 10000 concurrent ws connection so that I can update all the associated wallets as and when they have been updated. But while testing my application on devnet and testnet. I observed few things and wanted to ask few question related to it.

1. Is project serum hosted node is rate limited?
2. While testing accountSubscribe method on devnet and testnet, data field returned is empty, is this expected?
3. What would you suggest us to do if we want to create at least 10000 cocurrent connections?

Thanks in advance!
you can still get away with 16 tho
16gb was good enough like 5 years ago, tbf though i do run a lot of things at once
32gb


///////////////////////////////////////////////////////////////////////////////////////////////

I bit the bullet and all my tests are now cryptically checking for `to.be.rejectedWith(0x123)`

It's really not great but I couldn't find a fix. Did you find something better?
Yay works! Can directly use `#[derive(AnchorSerialize, AnchorDeserialize, Clone)]`  for Ser/de
Aight
(While tweaking the rest of the impl stuff to match)
Hmm, try doing
```.rs
pub struct Padding {
  pub padding: [u8; 200]
}
```
problem is simply the IDL, I've tried variation of derive and implementation, pub.. Pretty much everything I could think and/or find here, but to no avail 😦
Well in the end the issue is not my typescript interface (in the client for sake of use for front end guys)
hey im new to rust and i tried setting up anchor but i havent had success yet. This is whhat i get 
```
error: failed to run custom build command for `ring v0.16.20`
Caused by:
  process didn't exit successfully```
Why do you need to do any TS types at all?
Well anchor padding is not a fun ride
Oh yes you'r right it's IDL error
What does `index` on events actually do?
Not sure how to type that reserved in TS from RS
```
export class Account {
  bump!: number;
  _reserved!: any; // [u8; 1024]
```
Not the IDL, it's just that typescript is then lost to deserialize the type
Oh, does it mess up the IDL?
unplanned issue popping up, and my low TS skill blocking <a:pepelaugh:834817527900799078> 
Do you know how to represent that in a typescript interface?
u shouldnt need to zip them tho u can just run an iterator over the discriminator
if you have to manually set a discriminator u can do it like this. just make sure to import the discriminator trait from anchor w/ use::anchor_lang::Discriminator
Got it thanks!
You basically just keep generating random keypairs until you get one that looks cool 😎
Check out solana-keygen grind
Out of curiosity, does anyone know why some certain programs can have a prefix? E.g. token program ID has prefix `token` , serum Dex program has prefix `Dex` and stuff
I missed adding program address in anchor.toml file and in declare_Id() , after adding that it works..
Anyone here have resources on NFT staking for a token reward?
Run into this last night
You ever figure out if this is the case <@!707604162673639504> ?
Alright thanks as always for the boosting Alan, cheers!
Yeah every time you update the program you could just tweak the padding struct definition
In that case the padding would resize and that would evolve too. I think solution one is better in my case
Ok just wanted to confirm that was "acceptable"
Then you can say `padding: Padding`
```.rs
#[derive(Clone)]
pub struct Padding([u8; 200]);

impl AnchorSerialize for Padding {
    fn serialize<W: std::io::Write>(&self, writer: &mut W) -> std::io::Result<()> {
        writer.write_all(&self.0)
    }
}

impl AnchorDeserialize for Padding {
    fn deserialize(_: &mut &[u8]) -> Result<Self, std::io::Error> {
        Ok(Self([0u8; 200]))
    }
}
```
Or you'd just have to make your own wrapper type around a byte array and impl the borsh stuff for it
Ah, true. Well, the issue you're running into above is that rust doesn't make it super easy to impl traits for arbitrary length arrays 🤦‍♂️ So you could go one step hackier and do something silly like
```.rs
_padding1: [u8; 128] // it's implemented for powers of 2 lol
_padding2: [u8: 64]
```
do you have a code example where this is implemented? I wonder what's the best practice to keep track of padding left etc. The _padding: [u8, xx] was quite explicit in that regard
👍
It would be in the `space =` attribute
Oh I see, is there a macro for that or that's during the initial ix?
Ah, you don't need to add any padding yourself, just pre-allocate some extra space
I try to use `pub _padding: [u8; 200],`
thanks
Yep for later upgrades
What do you mean by padding? Just allocating additional space?
probably the same type exists for uint16s
i just use `Uint8Array.from([0])` and this works fine inside of findProgramAddress
Does anyone has example of padding accounts in anchor?
thanks, I was just diving into the Buffer documentation. was going to try a different approach but this looks like it works as well
Then `myU16.toArrayLike(Buffer, 'le', 2)` --> <Buffer 34 12>
You'll have to do something like `const myU16 = new anchor.BN(0x1234)`
I believe you'll have to specify endianness on the client when doing `findProgramAddress`, because anchor doesn't help with that.
I imagine the instruction data will come through correctly (as it's handled by anchor) and the solana vm probably has a defined endianness so `to_bytes` will result in the same array being created on any validator in which case it will just work? but I want to ask here in any case
if I have some `u16` instruction data that I want to use as a seed for a `PDA`, do I just say `s.to_bytes()` or do I need to specify endianness? can I ignore endianness when using the typescript client?
Ok let's take it from the top. Let's say you delete your `target/` folder right now, and run `anchor build`, do you get a `<program name>.json` file created in `target/` , where `<program name>` == crate name == module name (specified in 
```rust
#[program]
pub mod my_module {
```
)
the issue is my IDL is not getting updated , the address in the idl is different from the actual deployed address
hmm well your IDL was generated with the name "pair" so I guess those match. There was once a guy who was loading the wrong IDL file, so I thought you could have the same issue.
what is the program crate/module name?
The IDL is not getting updated even if i delete and and regenerate , so how should i fix this any idea?
No, you can happily use AccountLoader for accounts up to the full 10mb, but you're correct that you can't do so with a CPI to the system_program (the 10kb limit part). So indeed, you can't use `init` at all if you want to have a big account (any use of `init` implies a CPI). You'll have to allocate the account in a separate instruction, and then likely use `#[account(zero)]` in your initialization instruction function.
Hi! I want to ask does anyone knows what the error means?
```
Transaction failed: Instruction: SyncNative
```
Related transaction on explorer. URL: https://solscan.io/tx/4KZARGXNvb1RYNETLpRxdeHH1v5couKbSatnoWbjjxinrCFewSQq1KmQKFEF9sw5TtQo8oFtYbnMKnjq6ZaWUE5e?cluster=devnet
```
> Program returned error: custom program error: 0x22
```
i have deleted my IDL and generated new but still the err occurs
your program might also be using an out of date IDL

Are you setting up the program wrong maybe? On the js side, how to you get your `program` object used for RPC calls?
whatever the functions i call i this specific contract it returns fallback err

and it tries to fallback to using a fallback function, but there is none
yeh, it usually means you've sent an unknown instruction to the program
Could it be a mismatch between the name of the function program-side, and `mintLiquidity`?
can you post your IDL?
does anyone know what this err means...
note: the reason why i'd want to use accountloader over Box is because this particular ix is for initializing. There will be another ix that interacts with a lot of these `Bar` accounts that will blow both the stack & heap. So it has to be zero-copied
i'm attempting to initialize a PDA account of size ~3kb with 
```
#[derive(Accounts)]
pub struct CreateBar<'info> {
    #[account(
        init,
        seeds = [...],
        bump,
        payer = authority
    )]
    bar: AccountLoader<'info, Bar>,
}

#[account(zero_copy)]
#[derive(Default)]
pub struct Bar {
    pub data: [InnerBar; 70],
}

#[zero_copy]
#[derive(Default)]
pub struct InnerBar {
   ...data
}

pub fn handler(
    ctx: Context<CreateBar>,
) -> ProgramResult {
    Ok(())
}
```

The solana stack is ~4kb. With the setup i have up top, i'm over the stack size. (looking into the anchor constraint code, init calls .to_account_info(), which i think is where it tries to load the account back onto the stakc)

Given that CPI::init accounts have a maximum of 10kb, does this mean that any attempts at init-ing anything larger than the stack have to be done with Box<Account<...Bar>>? And does this mean we can't initialize anything larger than the stack if we want to use AccountLoader?
sure but it's a hassle
ATAs are always PDAs
ATA - and for associated token accounts,  is this the proper way to initialize do I using associated_token mint?  if my associated token account is also a PDA do I just also include seeds and bump? or what is the approach for a PDA ATA account?  thanks! 
`
#[account(
        init,
        payer = payer,
        associated_token::mint = mint,
        associated_token::authority = payer,
    )]`
when doing initialization, instead of account(init,    can I call my own function for custom initialization?
imo instead of `init_if_needed` you ought to be using one or more explicit initialization functions for all of the accounts, depending on your needs
I get your point though
Yeah, I'm just using `init_if_needed` to avoid dealing with uninitialized accounts on the client side
not you of course, just in general
there's been a lot of people asking for `init_if_need` and similar kinds of dependent initialization functions that they think would save time and effort
i don't think the design pattern of just checking whether data already exists in an account is widely known or understood by new devs
it's probably best to use a cleaner and easier to implement design than over optimising (unless there's a strong reason / use case)
no worries
You wouldn't have to always fail the transaction if you checked ahead of time with an rpc call to load the existing data, or a transaction simulation, whether or not the new data would cause an overflow. It would only happen when two people in short succession submitted the same transaction
couldn't you fail the transaction and just have a separate function to deal with this situation where a new PDA is needed with additional data
what's the rough use case? You're afraid that the function will try to add too much data to an existing PDA and since you can't resize the PDA's account space you have to init a new one
it's not typically recommended if you can avoid it
though i've never inited an account's data by hand before
you'll have to add the discriminator data manually yourself
but at this stage there might actually be a helper function to do this
the discriminator is calculated something like `sha256("account:{struct_name}")[0:8]`
let us know if you get it working, i'm curious to see it done as well
they're the two largest open source anchor code bases i know of
i'm trying to remember if there's any examples in the wild i've seen doing it. You could search through Jet or Synthetify to see if they do it
you could probably make an implementation for making a context, just like how we do with CpiContext
a context is just a struct with a bunch of account info on it
i haven't seen it done that much either tbh
just call the function
while deploying a contract i am getting this err, it was working fine untill yesterday
ty for help friends, time to hit the shower
I spent an hour thinking my accounts were messed up, I was doing the authority change wrong, etc. simplest thing is always the culprit
So I had two diff programs (exact same code) running and indeed the ids were mixed up
did you update your programId in `declare_id!()` according to the output from your `anchor keys list`?
It could mean a lot of specific things. It would help if you posted the code that throws the error  as well as the client side code making the request. 

Usually it comes from something simple, like not init an account or not passing in the correct signer
Anyone know what this could mean?
`Error: 3007: The given account is not owned by the executing program`
youre right!! interesting... the pubKey somehow seems different
lemme me have a look on this real quick
I think it would have to be that `edition_mark_pda`. I would quadruple check you're passing it correctly as an account in `mint_new_edition_info` (I haven't looked carefully)
you mean here right? https://github.com/metaplex-foundation/metaplex/blob/master/rust/token-metadata/program/src/instruction.rs#L378 yea... Ive not seen so far anything passed wrong
am using this ```pub fn assert_derivation(
    program_id: &Pubkey,
    account: &AccountInfo,
    path: &[&[u8]],
) -> Result<u8, ProgramError> {
    let (key, bump) = Pubkey::find_program_address(&path, program_id);
    if key != *account.key {
        return Err(MetadataError::DerivedKeyInvalid.into());
    }
    Ok(bump)
}```

from the `spl-token-metadata` crate
Try hopping to source on the `mint_new_edition_from_...` function, you'll probably see which PDAs it expects you to pass
Before this code I also had logic checking all the PDA accounts address derivation correcntess
yea essentially Im trying to use this instruction https://github.com/metaplex-foundation/metaplex/blob/master/rust/token-metadata/program/src/instruction.rs#L206
my code
```
        let mint_new_edition_info = vec![
            ctx.accounts.master_edition_metadata.to_account_info(),
            ctx.accounts.new_edition_metadata.to_account_info(),
            ctx.accounts.new_edition_account.to_account_info(),
            ctx.accounts.master_edition_account.to_account_info(),
            ctx.accounts.new_edition_mint.to_account_info(),
            ctx.accounts.master_edition_token_account.to_account_info(),
            ctx.accounts.master_edition_mint.to_account_info(),
            ctx.accounts.new_edition_buyer.to_account_info(),
            ctx.accounts.token_metadata_program.clone(),
            ctx.accounts.token_program.to_account_info(),
            ctx.accounts.system_program.to_account_info(),
            ctx.accounts.new_edition_marker.to_account_info(),
            ctx.accounts.rent.to_account_info(),
        ];
        let instruction = mint_new_edition_from_master_edition_via_token(
            metaplex_token_metadata::id(),
            ctx.accounts.new_edition_metadata.key(),
            ctx.accounts.new_edition_account.key(),
            ctx.accounts.master_edition_account.key(),
            ctx.accounts.new_edition_mint.key(),
            ctx.accounts.new_edition_buyer.key(),
            ctx.accounts.new_edition_buyer.key(),
            ctx.accounts.new_edition_buyer.key(),
            ctx.accounts.new_edition_token_account.key(),
            ctx.accounts.new_edition_buyer.key(),
            ctx.accounts.master_edition_metadata.key(),
            ctx.accounts.master_edition_mint.key(),
            edition,
        );


        solana_program::program::invoke_signed(
            &instruction,
            mint_new_edition_info.as_slice(),
            signer,
        )?;

```
Every instruction declares which accounts (addresses, anyways) need to be passed. Can you post some code?
I seem to have check all the PDAs in my own handler.. not sure what's missing there. Out of curiosity tho, since I found `An account required by the instruction is missing` actually came from the solana program (the framework code), therefore dont think it reached the token metadata program Im calling, how does the program somehow know Im passing the wrong address?
But part of solana's whole performance model is that the client has to declare which accounts it's interested in.
I mean, it's not literally impossible to build an `AccountInfo` struct (it's just a struct, after all), but it won't do what you want it to do.
Can you show me an example?
I can't understand how they do this
Is it absolutely impossible?
I saw some of the open sources used dynamically build an AccountInfo
That unfortunately won't work in solana. You always have to pass any accounts your transaction cares about in from the client, no exceptions (so if I'm understanding the rest of the thread, what you're doing above won't work, it's not possible to dynamically build an AccountInfo from within your rust program, you have to pass that account in from the client)
hardcode it into the app
set the const client side
Please help me how can I do this
I just intended to set the const pubkey in the rust side and make transaction to this address
if the client don't know this address then how can he match that address?
yes
I think #[account(address=<pubkey>)] is a strict rule of the account info that checks the address is equal with the input pubkey
is that right?
well, maybe change it to an AccountInfo on the rust side, and hardcode the public key client side
hardcode a public key into your app
BTW how we can white this param in client side?
```#[account(
      mut,
      address = Pubkey::from_str("pubkey string here").unwrap()
    )]
    pub requestor: Signer<'info>,```
i would just pass it in as an account
so it seems you are using the vault address as the requestor
I think you are right 
This is the life time error
How can I fix this?
Please teach me how can figure out this problem
I tried but not working
Does it seems like the life time error?
no, the underlined bit is currently `vault_address.clone()`, and the message hints that you can use `&vault_address` so just try to revert this one?
I think you mean this
&vault_address      ---------> vault_address.clone()
right?
(I mean reverting to `&vault_address` for this one)
Does following the help message here work?
Thank you but i am getting this error
I just wanted to match the param type of the AccountInfo::new() function
requestor seems to be already passed in...
why does x have to be mutable, and why are you manually instantiating an accountinfo?
use `vault_address.clone()` instead of  `&vault_address` everywhere in `invoke`
```
error[E0425]: cannot find function `is` in this scope
  --> /home/arowana/.cargo/registry/src/github.com-1ecc6299db9ec823/atty-0.2.14/src/lib.rs:98:6
   |
98 |     !is(stream)
   |      ^^ not found in this scope

error[E0432]: unresolved import `crate::sys`
 --> /home/arowana/.cargo/registry/src/github.com-1ecc6299db9ec823/socket2-0.4.2/src/sockaddr.rs:5:12
  |
5 | use crate::sys::{
  |            ^^^ could not find `sys` in the crate root

error[E0432]: unresolved imports `crate::sys`, `crate::sys`
  --> /home/arowana/.cargo/registry/src/github.com-1ecc6299db9ec823/socket2-0.4.2/src/socket.rs:21:12
   |
21 | use crate::sys::{self, c_int, getsockopt, setsockopt, Bool};
   |            ^^^   ^^^^ no `sys` in the root
   |            |
   |            could not find `sys` in the crate root

error[E0432]: unresolved import `sys`
   --> /home/arowana/.cargo/registry/src/github.com-1ecc6299db9ec823/socket2-0.4.2/src/lib.rs:129:5
    |
129 | use sys::c_int;
    |     ^^^ use of undeclared crate or module `sys`
```
Build is exploding, seems to be an underlying deps that changed but I cannot find how to resolve
any guidance, why I am getting this error 🤔
Hey guys, I am getting this error while testing.

  logs: [
    'Program CUS1qwyVkxg2Pbt35iPU5x133Nfg2oaiUsshKhnRvWfH invoke [1]',
    'Program log: Custom program error: 0x65',
    'Program CUS1qwyVkxg2Pbt35iPU5x133Nfg2oaiUsshKhnRvWfH consumed 1307 of 200000 compute units',
    'Program CUS1qwyVkxg2Pbt35iPU5x133Nfg2oaiUsshKhnRvWfH failed: custom program error: 0x65'
  ]


I am trying out this test code 

  it("Triggers the depoist API)", async () => {
    /* Call the depoist function via RPC */
    let tx = await program.rpc.deposit();


    pub fn deposit(
        ctx: Context<Deposit>,
    ) -> ProgramResult {
        Ok(())
    }

#[derive(Accounts)]
pub struct Deposit {}
Or blow on it, classic localnet
that's surprising, seems to have everything where it should. Try to turn it on and off <:kekdoge:844662080720338975>
Hello JB, I’ve ditched localnet and only use devnet for now
hey, <@!443079510053748743>  I read through this but I still get `Attempt to load a program that does not exist` when running `anchor test --skip-local-validator` . the solana-test-validator is running in another tab and I can solana account {program} and its there, and i print provider.connection and its pointed to localhost in the test so not sure how its pointed somehwhere else
Hi, @here Anyone can help me?
`{
            let vault_address: Pubkey = Pubkey::from_str("6PpUjY5Tf8wzeR9uBQX2JRpgvcDKMi1Xb7asrAhYS2rZ").expect("Unable to parse program Id.");
            let mut x: u64 = 0;
            let requestor: &AccountInfo = &ctx.accounts.requester;
            // *x = 0;
            invoke(
                &system_instruction::transfer(
                    ctx.accounts.requester.key,
                    &vault_address,
                    FIXED_FEE,
                ),
                &[
                    requestor.clone(),
                    AccountInfo::new(&vault_address, true, false, &mut x, &mut [], &vault_address, false, 0),
                    requestor.clone(),
                ],
            )?;
        }`
I got this error
What's the best way to listen for account creations / changes in Solana? Or should I just emit an event with `anchor_lang::emit` everytime an account is created / modified?
not sure where to ask this: are there any resources/tutorials for how to get anchor clients working on iOS/Android?
Havn't looked into it deeply but getting some errors about the size of the array, how does Padding works with anchor accounts?


///////////////////////////////////////////////////////////////////////////////////////////////

Take a look at https://paulx.dev/blog/2021/01/14/programming-on-solana-an-introduction/. This is an example of atomic switch of different tokens. Hope it can give a clue to your question.
Hi there,
I want to transfer usdt tokens from one account to another in rust contract.
Can any one provide me any example or help me.
I will be very thankful.
actually - I take it back! I tried .only, .skip like you suggested and it's much faster than commenting in/out chunks of tests! Thank you for the tip 🙏
You can do whatever you want in a constraint, e.g. `constraint = some_function_you_wrote()`
Hi All!
I tried to verify ed25519 signature inside rust program. Anybody succeeded in that?
My tries:
Locally on the pure rust next code works just fine:
```    // Use Salty
    let raw_sig = ed25519_dalek::Signature::from_bytes(&sig_bytes).unwrap();
    let sig = salty::signature::Signature::from(raw_sig);
    let key = salty::signature::PublicKey::try_from(&solana_address.to_bytes()).unwrap();
    let result = key.verify(&raw_bytes, &sig);
    assert!(result.is_ok());

    // Use ed25519_dalek
    let signature: ed25519_dalek::Signature = ed25519_dalek::Signature::from_bytes(&sig_bytes).unwrap();
    let public_key: ed25519_dalek::PublicKey = ed25519_dalek::PublicKey::from_bytes(&solana_address.to_bytes()).unwrap();
    let result2 = public_key.verify(&raw_bytes, &signature);
    assert!(result2.is_ok());```
But inside solana
- first attempt using salty exceed the limits of compute units. Particularly next instruction:
`salty::signature::PublicKey::try_from(`
- second attempt using ed25519_dalek leads to runtime error:
` Program failed to complete: Access violation in stack frame 11 at address 0x20000bd28 of size 8 by instruction #16835`
It caused by 
`ed25519_dalek::PublicKey::from_bytes(`
Also I see compile time errors if using ed25519_dalek, however program compiled and deployed:
`Error: Function _ZN116_$LT$curve25519_dalek..edwards..EdwardsBasepointTableRadix16$u20$as$u20$curve25519_dalek..traits..BasepointTable$GT$6create17h799db29315261438E Stack offset of -32120 exceeded max offset of -4096 by 28024 bytes, please minimize large stack variables`

So, the question is: does anybody used ed25519 sign verification successfully in the solana blockchain program?
I just needed to put the registration after the nft is actually minted 😅 solved
hm so this is inside the js files themselves? that's not super convenient. Is there a way to do it from the terminal when typing `anchor test`?
I guess I can just check this in the function lol
The problem is I cant trust the token account or pda account to be the programs, anything could be passed in..
<@!134416332509675520> Definitely. I guess my question is whether that pda account key can be generated in the program? I know you can do that in the functions themselves, but wasn't sure where i'd generate it to pass into a constraint
You could do something like `constraint = the_token_account.owner == the_pda_account.key`. Does that work?
Hi, i try to token transfer using anchor_spl
anchor_spl::token::transfer(
            CpiContext::new(
                ctx.accounts.token_program.to_account_info(),
                anchor_spl::token::Transfer {
                    from: ctx.accounts.destination.to_account_info(),
                    to: ctx.accounts.payer.to_account_info(),
                    authority: ctx.accounts.mint.to_account_info(),
                },
            ),
            amount_to_mint,
        )?;

its throw error:-
'Program 4njkVvH3j9UKMeAcxDkM2ofD827jhinCmv8zLw8NEhWZ invoke [1]',
'Program log: Instruction: Deposit',
'Program log: Custom program error: 0xbc0',
'Program 4njkVvH3j9UKMeAcxDkM2ofD827jhinCmv8zLw8NEhWZ consumed 5718 of 200000 compute units',
'Program 4njkVvH3j9UKMeAcxDkM2ofD827jhinCmv8zLw8NEhWZ failed: custom program error: 0xbc0'

i dn't know what am i missing here
it.skip and describe.skip is also useful
Try it.only
Makes sense thank you, just need a workflow for each mint. Another quick question: how can we check that a passed in token account is actually owned by the program pda in the contract? If I use an anchor constraint, would I need to re-derive the pda in the contract and check it matches the owner of the passed in token account? Thinking of doing some sort of impl on the context to do this.
Using something like getAccountInfo
You just look up the account in the client
Yes
Is there a way to check if a token account exists for a given pda? i.e. check if token account exists otherwise create one
is there a way to tell anchor which specific test to run?
How to make this work in anchor? (
how can I use it? should it be in my function or should it be outside
https://docs.rs/spl-token-metadata/latest/spl_token_metadata/instruction/fn.create_metadata_accounts.html
(I'm mixing two different anchor program IDLs here, is that  valid?)
Please advise.
Individually the calls work, and my understanding is that a Transaction can consist of TransactionInstructions to more than one program.
I haven't gone deep into the Transaction building in the native solana/web3.js or the program.namespace that anchor builds with t he IDL, so I'm probably missing something obvious here.
Im getting this error:
``` return await program.rpc.mintNft({
    accounts: {
      config,
      candyMachine: candyMachine.id,
      payer: payer,
      wallet: treasury,
      mint: mint.publicKey,
      metadata,
      masterEdition,
      mintAuthority: payer,
      updateAuthority: payer,
      tokenMetadataProgram: TOKEN_METADATA_PROGRAM_ID,
      tokenProgram: TOKEN_PROGRAM_ID,
      systemProgram: anchor.web3.SystemProgram.programId,
      rent: anchor.web3.SYSVAR_RENT_PUBKEY,
      clock: anchor.web3.SYSVAR_CLOCK_PUBKEY,
    },
    signers: [mint],
    instructions: [

      //*** BEGIN ADD CUSTOM INSTRUCTION CALL HERE***///
      customMetadataProgram.instruction.registerNft({
        accounts: {
          staker: payer,
          nftAccount: token,
          nftMetadataPda: nftMetadataPda,
          statePda: statePda,
          systemProgram: anchor.web3.SystemProgram.programId,
          tokenProgram: TOKEN_PROGRAM_ID,
        },
      }),
      //*** END ADD CUSTOM INSTRUCTION CALL HERE***///

      anchor.web3.SystemProgram.createAccount({
        fromPubkey: payer,
        newAccountPubkey: mint.publicKey,
        space: MintLayout.span,
        lamports: rent,
        programId: TOKEN_PROGRAM_ID,
      }),
      Token.createInitMintInstruction(
        TOKEN_PROGRAM_ID,
        mint.publicKey,
        0,
        payer,
        payer
      ),
      createAssociatedTokenAccountInstruction(
        token,
        payer,
        payer,
        mint.publicKey
      ),
      Token.createMintToInstruction(
        TOKEN_PROGRAM_ID,
        mint.publicKey,
        token,
        payer,
        [],
        1
      ),
    ],
  });
}```
I'm modifying a candymachine mint page to add an additional instruction to my own metadata contract upon mint like this:
Thank you <@!134416332509675520> .  Always much appreciated!
I have not :(. Alas, I might have to also bit the bullet and follow your strategy
Yeah. It's a bummer, but I don't think there's a known way to fix it.
which means all the bump arguments should be place at the front in the arg list?
If not, then the unnecessary params should be placed in #[instruction] to just get the reparsing done?
thanks alan! i figured out what was wrong (for anyone searching). if you are init-ing via accountloader, you have to specify space. Otherwise anchor will try to load your account to figure out the size from by calling Type::default. if your type is huge it'll blow your stack
So yeah, you unfortunately need to get the order right.
The way the `#[instruction(...)]` annotation works is that it just *re-parses* the arguments.
I wonder why those arguments should be in same order.
Isn't it enough to match them using their name and type?

I run into the same problem - when the two arguments were in different order than in ix, the program results in ``Provided seeds do not result in a valid address``, otherwise performs well.

Please let me know if this is intended or unavoidable logic. Thank you.
I ment how to check if it's an NFT from whithin Rust, so if a program gets passed a mint address, how can it verify if it was passed an NFT or a "normal" SPL-token
I realise I havent asked the right question haha
Or perhaps if its a metaplex nft you can check for the metadata associated with the token account that is metaplex specific
You can check the mint address against nft collections' mint address
Hey guys, how can I determine if the SPL Token Account is an NFT inside the rust program?
What's the purpose of sending raw transaction e.g.:
```  const rawTransaction = transaction.serialize();
  const txid = await provider.connection.sendRawTransaction(
```
instead of sending a normal one?
so `program.instruction.<method>` can return a `TransactionInstruction`, does the context absolutely need to contain the payer's keypair or can I sign a transaction with that instruction added to it with the keypair and forgo passing the actual keypair?
When you run anchor build, what is the path for the bpf sdk?
omg.... the account I was passing in wasn't `mut`.. I probably lost a good 2 years of my life and half my hair debugging this
has anyone ever had a problem with anchor not serializing a value? like it clearly gets updated when the insturction is called, but on next instruction call it's again as if it was never touched
I'm following this post
https://dev.to/nickgarfield/how-to-install-solana-dev-tools-on-an-m1-mac-kfn
and in the middle of doing a reinstall from scratch via source
installed from source the first time
How did you install in the first place? I install from source (not using the installer)
actually 1. how do I update solana version, and second will the update overwrite the effort i did it to get it to work on M1?
Ah, yeah, that means your solana version is too old (not an M1 issue)
I'm doing a reinstall right now
Either solana-frozen-abi v1.9.1 cannot be installed or need to add edition2021
What kind of problems are you having? I haven't had any issues since getting things set up the fist time.
has anyone figured out a consistent set up on an M1 mac that works everytime?
It's pretty challenging trying to use Solana on an M1 mac. I'll get my configuration to work once, and then the next project it will completely fail.
if i put a non-anchor program into an anchor workspace, does `anchor test` deploy it to localnet? If so, how can I get its address?
Hi, anyone knows how to implement burn rate and redistribution rate in solana spl-token?
I know this is possible in solidity but I am not sure if it is possible or not in solana.
It runs Solana test validator
does `anchor test` run a validator or does it just simulate transactions?
How is the docs situation looking? Love this framework, but the lack of docs is *challenging* to say the least.


///////////////////////////////////////////////////////////////////////////////////////////////

Ok brilliant thanks
Ok, that's the problem. Don't do `Account<'info, WinnerAccount>`, just do `AccountInfo<'info>` instead (it's not an account owned by your program + doesn't have any data—it's just a regular wallet account)
I get it from the signer of the transaction when they place a bet. I'm not sure I init anywere which must be the problem. 
at the moment I pass it as ctx with this struct. 
```
#[derive(Accounts)]
pub struct PlaceBet<'info> {
    #[account(mut)]
    pub base_account: Account<'info, BaseAccount>,
    #[account()]
    pub player: Signer<'info>,
    pub system_program: Program<'info, System>,
}```
then use this to add it to the struct I store.
```
let bet = EntryStruct{
            user: *player.to_account_info().key,
            prediction: pred,
            stake_bal: stake_bal as u64
        };```
Like, where are you getting the `user: Pubkey` from in that EntryStruct? How did you determine which pubkey to use?
In your example above, where are you actually creating a `WinnerAccount`? E.g. with anchor's `init` attribute
Cool thanks. just trying to iron out where I go wrong
Yeah, all you need is their Pubkey
In my program I take entries into a betting pool and then when the result is confirmed we payout winners, when a user enters we save the entry into a Vec of structs with the following info. Is this enough info on the user to be able to pay them winning later? 
```#[derive(Debug, Clone, AnchorSerialize, AnchorDeserialize)]
pub struct EntryStruct{
    pub user: Pubkey,
    pub prediction: String,
    pub stake_bal: u64,
}```
Ok cool thanks for your help.
It's possible to store an accountInfo in a struct? 🤔
Ok, yeah, there's no account there—will have to figure out whatever bug that entails about your program
it returns null when I run ```
console.log(await program.provider.connection.getAccountInfo(new anchor.web3.PublicKey(winners.user.toString())))```
Have you actually fetched the account though? Does it return null or an actual account?
yep I can log the string fine
I would store an actual pubkey in the account though
My guess is that it's an uninitialized account, which leads to the 0x67 error
Can you log that string at least? You're going to have to fetch the account to see if anything lives there
Yeah ok I think that's the issue I get the winners key from a array of structs where the key is stored as a string.
That's why the toString() you're doing is kind of odd, I'd expect you to be working directly with a pubkey
Ok, do `new anchor.web3.PublicKey(winners.user.toString())` in there
yes, I got.
```TypeError: publicKey.toBase58 is not a function
    at Connection.getAccountInfo (/Users/jobymacbookpro/Documents/solana/myepicproject/node_modules/@solana/web3.js/lib/index.cjs.js:5459:71)
    at processTicksAndRejections (internal/process/task_queues.js:95:5)
    at async main (/Users/jobymacbookpro/Documents/solana/myepicproject/tests/myepicproject.js:82:15)
    at async runMain (/Users/jobymacbookpro/Documents/solana/myepicproject/tests/myepicproject.js:103:5)```
My guess is no
You just need to figure out if you're loading the right address
Mm, not sure—have you tried doing that console.log? 😛
Ok so how the program is supposed to work is I get a list of winners, which are the public keys of the winners. They a loop through the winners and pay each one perhaps I am storing the winner key wrong in the list?
You need to pass in the address of the account you want to fetch
What do you mean? Have you tried doing `await program.provider.connection.getAccountInof(winners.user.toString())`?
Could be it, when I run the log you suggested I get the info about the base account (program account), but not about the winnersAccount.
That's not enough unfortunately to tell if you've already initialized the account
I can't remember if you can pass a string for the accounts (I guess you must be able to, huh)
That `.toString()` looks super suspicious to me (not sure, maybe it works?)
While it runs this is how I call if from the js tests. 
```
await program.rpc.payWinnerLamps(winners.stakeBal, 1, winners.id , {
    accounts: {
      baseAccount: baseAccount.publicKey,
      winner: winners.user.toString(),
      systemProgram: SystemProgram.programId,
      owner: provider.wallet.publicKey,
    }
  })
```
ok let me try that.
My guess is that it'll be the system program (0 as a BN)
And see what its owner looks like
You can check in JS with something like
```.js
console.log(await program.provider.connection.getAccountInfo(theAccountAddress))`
```
Have you actually initialized it? Doesn't matter that it's empty
Fairly sure, winner account struct looks like this if that's helpful? 
```#[account]
pub struct WinnerAccount{}
```
My guess is that somehow base account or winner account aren't initialized, or something like that
Ok, are you sure then that you're passing in the right accounts?
yes
No, in your rust file
in the anchor.toml?
Does `Cq1TSA1obVQZzw2YYxvFN6Q5ia5TYxSbwyZQ9JwQCbBL` match your `declare_id!`?
```ProgramError: 167: The given account is not owned by the executing program
    at Function.parse (/Users/jobymacbookpro/Documents/solana/myepicproject/node_modules/@project-serum/anchor/dist/cjs/error.js:40:20)
    at Object.rpc [as payWinnerLamps] (/Users/jobymacbookpro/Documents/solana/myepicproject/node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:16:58)
    at processTicksAndRejections (internal/process/task_queues.js:95:5)
    at async main (/Users/jobymacbookpro/Documents/solana/myepicproject/tests/myepicproject.js:82:3)
    at async runMain (/Users/jobymacbookpro/Documents/solana/myepicproject/tests/myepicproject.js:100:5) {
  code: 167,
  msg: 'The given account is not owned by the executing program'
}```
sure this the output I get. 
```Transaction simulation failed: Error processing Instruction 0: custom program error: 0xa7 
    Program Cq1TSA1obVQZzw2YYxvFN6Q5ia5TYxSbwyZQ9JwQCbBL invoke [1]
    Program log: Custom program error: 0xa7
    Program Cq1TSA1obVQZzw2YYxvFN6Q5ia5TYxSbwyZQ9JwQCbBL consumed 13498 of 200000 compute units
    Program Cq1TSA1obVQZzw2YYxvFN6Q5ia5TYxSbwyZQ9JwQCbBL failed: custom program error: 0xa7
Translating error SendTransactionError: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: custom program error: 0xa7
    at Connection.sendEncodedTransaction (/Users/jobymacbookpro/Documents/solana/myepicproject/node_modules/@solana/web3.js/lib/index.cjs.js:6591:13)
    at processTicksAndRejections (internal/process/task_queues.js:95:5)
    at async Connection.sendRawTransaction (/Users/jobymacbookpro/Documents/solana/myepicproject/node_modules/@solana/web3.js/lib/index.cjs.js:6550:20)
    at async sendAndConfirmRawTransaction (/Users/jobymacbookpro/Documents/solana/myepicproject/node_modules/@solana/web3.js/lib/index.cjs.js:8513:21)
    at async Provider.send (/Users/jobymacbookpro/Documents/solana/myepicproject/node_modules/@project-serum/anchor/dist/cjs/provider.js:85:22)
    at async Object.rpc [as payWinnerLamps] (/Users/jobymacbookpro/Documents/solana/myepicproject/node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:11:31)
    at async main (/Users/jobymacbookpro/Documents/solana/myepicproject/tests/myepicproject.js:82:3)
    at async runMain (/Users/jobymacbookpro/Documents/solana/myepicproject/tests/myepicproject.js:100:5) {
  logs: [
    'Program Cq1TSA1obVQZzw2YYxvFN6Q5ia5TYxSbwyZQ9JwQCbBL invoke [1]',
    'Program log: Custom program error: 0xa7',
    'Program Cq1TSA1obVQZzw2YYxvFN6Q5ia5TYxSbwyZQ9JwQCbBL consumed 13498 of 200000 compute units',
    'Program Cq1TSA1obVQZzw2YYxvFN6Q5ia5TYxSbwyZQ9JwQCbBL failed: custom program error: 0xa7'
  ]
}```
And can you show the full program log when things fail? Way easier to debug with that
The 0x67 error would be coming from either Account<'info, BaseAccount> or Account<'info, WinnerAccount>
No I don't think so, when did it come out?
Here is the struct. 
```
#[derive(Accounts)]
pub struct WinnerToPay<'info>{
    #[account(mut)]
    pub base_account: Account<'info, BaseAccount>,
    #[account()]
    pub winner: Account<'info, WinnerAccount>,
    pub system_program: Program<'info, System>,
    pub owner: Signer<'info>
}
```
have you upgraded to solana 1.9.0?
That error wouldn't be raised at that point in the code. Can you post your derive(Accounts) struct?
Hey guys I am working on a project and I have an account which I believe to be owned by the program. As it hold data and receives SOL with no issues. However when I try to transfer SOL out of the account I get an error. 
``` ProgramError: 167: The given account is not owned by the executing program ```
This is the function I am using to try the transfer. 
```
assert!(ctx.accounts.owner.key() == base_account.pool_list[i].user_address, "Not the pool owner");
            assert!(base_account.pool_list[i].closed, "Pool not closed yet");
            let win_stakes = base_account.pool_list[i].win_stake;
            let per = (stake / win_stakes) as f64;
            let amount = (base_account.pool_list[i].pool_balance_after_fees as f64 * per) as u64; // we use after fees pool bal so there is money left to pay fees 
            // now transfer the ammount in lamports to the winners
            
            let from = base_account.to_account_info(); //base_account.to_account_infos();//.to_account_info();
            let to = ctx.accounts.winner.to_account_info();
            **from.try_borrow_mut_lamports()? -= amount;
            **to.try_borrow_mut_lamports()? += amount;
            
            let mut ei = 0;
            let mut en: Option<WinnerStruct> = None; 
            for e in &base_account.pool_list[i].winners{
                if e.id == entry_id{
                    en = Some(WinnerStruct{
                        id: e.id,
                        user: e.user.to_string(),
                        stake_bal: e.stake_bal,
                        paid: true,
                    });
                    
                }
                ei += 1; 
            }
            if let Some(x) = en{
                base_account.pool_list[i].winners[ei]= x;
            };
```
Can anyone suggest what the issue might be?
Does `program.provider.sendAll` Still send all transactions if some fail simulation?
yup, just ran the tests, u128 seems to be working fine
Awesome
It looks like Serum Denvet was deployed mid August, I was able to trace back the commit from Git and identify my error
Ah, interesting, I hadn't noticed anchor already supports u128
but anyway, I appreciate all the help! Thanks a ton guys
I know I know - I'm just trying everything else before I go there

eg I don't really need u192 precision, I can do with u128, so I rewrote my fixed point lib to use u128. that solves the Newtype problem

next I needed to import it, hence this conversation
(Not great, would like to see a better approach)
That's why I'm suggesting to just forget about embedding that type in the IDL
argghhh
I'm a bit fuzzy on the IDL generation, but yeah, my understanding is that this unfortunately won't work to share the type like this :/
<@!862377421214449687>  tbh it sounds like there isn't a way 😦 that sort of makes sense - I guess to generate the IDL anchor runs some sort of macro, which ofc isn't going to go and parse every imported crate for types. So if I want it in the IDL it has to be defined within the crate. I was just hoping maybe by importing it smartly somewhere I could trick the macro to see it

I've tried adding stuff like this to the lib file, but no luck
```
pub use gem_common::number128::*;
pub use gem_common::number128::Number128 as Number123;
```
in `gem_bank`?
what do your imports look like?
looks legit to me
as you can see I'm importing the common lib, which contains the type
this is what I have (sorry for the screenshot, I just thought it was easier)
(Not great)
And then use your MyDecimal code purely in Rust, as a library
I think the hackiest solution is to just skip trying to have that MyDecimal type show up in the IDL. Just have it be [u8; 3 * 8]
mmm I see, how is your crate set up?
```
crate-type = ["cdylib", "lib"]
```
?
but then I need to copy paste it 3 times 😦
if I move it into the crate - then it works ok
oh I see..
which leads to this:
```
IdlError: Type not found: {"name":"rewardRate","type":{"defined":"MyDecimal"}}
```
it simply doesn't register in the IDL, that's all
what error is it giving you?
ok what I'm saying is:

I have a type like this: 
```
pub struct MyDecimal {
  u192: [u8; 3 * 8]
}
```

and I have a bunch of methods implemented on it, eg `as_u64` etc. Alltogether it's like a 200 line file.

I'd like to keep it as a separate crate and import it into the 3 other crates that need it

rn it doesn't work:( and I'm desperately hoping there might be a way
Hmm, I'm actually not sure it'll work if you put it in a separate crate :/
maybe there's some sort of import I can do somewhere to get it to register the type from a separate lib
Ah, so something like
```.rs
pub struct MyU192 {
  u192: [u8; 3 * 8]
}
```
yup
A type that will show up in the IDL?
this is a 2nd issue - where do I define the type - in the core crate, or in a separate lib
But that's the idea anyway
Actually not sure I did that right, I can't find the actual error location 🤔
the U192 part we discussed, and I'll do the painful serde
I'm absolutely mindblown, thank you
no no, forget about that
As far as I know there just isn't any way currently to treat that U192 as an IDL first-class citizen
If you want to use this U192 type then no, you'd have to store a [u8; 3 * 8] on chain, and then just share that library code to deserialize it
sorry for being annoying 😄 - is there absolutely no way of keeping a struct in a separate lib and importing it in (and having it included in the IDL)?

I have a math library that's shared by 3 anchor crates. I would have to copy paste the code in into each of the 3 😦
So 0x1000c15 means 1 --> error is in src/state.rs, 0xc15 = 3093 = line number in that file. I'm not sure what version of serum dex is currently deployed though
Serum uses a funny/neat error encoding scheme: https://github.com/project-serum/serum-dex/blob/master/dex/src/error.rs#L141
I'm trying to initialize a market on DevNet and I get the following error: 
```
    'Program DESVgJVGajEgKGXhb6XmqDHGz3VjdgP7rEVESBgxmroY failed: custom program error: 0x1000c15'
```

I couldn't find this error anywhere in the documentation
Does anyone here have Serum experience? I'
okay then, let me try that, thanks <@!134416332509675520>
If you don't want it to live at an address like that, then you'll have to do `token::mint = mint, token::authority = mint`
Ok, right, that's incorrect: associated token accounts have to live at specific kinds of addresses
I'm not determining any account address in there, i create a keypair  like `const mintTokenAccount = anchor.web3.Keypair.generate();`
and use the `publickey` as the `mintTokenAccount` address.
How are you determining `mintTokenAccount` in JS?
My guess is that you're not calculating the associated token address correctly on the client
yeah, sure
```
#[derive(Accounts)]
#[instruction(bump_seed:u8)]
pub struct InitMintAndAssociated<'info> {
    #[account(
        init_if_needed,
        payer = owner,
        seeds=[],
        bump =bump_seed,
        mint::decimals = 6,
        mint::authority = mint
        )]
    pub mint: Account<'info, Mint>,
    #[account(
            init,
            payer = owner,
            associated_token::mint = mint,
            associated_token::authority = mint
            )]
    pub mint_token_account: Account<'info, TokenAccount>,
    #[account(mut)]
    pub owner: Signer<'info>,
    pub token_program: Program<'info, Token>,
    pub associated_token_program: Program<'info, AssociatedToken>,
    pub system_program: Program<'info, System>,
    pub rent: Sysvar<'info, Rent>,
}
```

error its throws:-
Transaction simulation failed: Error processing Instruction 0: An account required by the instruction is missing
Program 4njkVvH3j9UKMeAcxDkM2ofD827jhinCmv8zLw8NEhWZ invoke [1]
You're going to need to post more information than that—can you show the full program log?
Hi <@!134416332509675520> can you please take look.
gotcha thanks alan!
At any rate yeah it's probably easier to just remember the 7*2/mb amount.
Hmm, I'm not sure yet from looking at the cli source why they'd be off by a factor of two (at first glance it looks like it should be accounting for it, but guess not)
this seems to be accurate!! I just tried it out
would you explain more?
You can do `ls -l target/deploy` to see how big your program is
You should expect to pay 7 sol * 2 / mb of code (times 2 because the upgradeable loader defaults to giving you 2x space in case subsequent deploys need more space)
I tried looking at the cli source for a bit—is the amount you're being asked to pay consistent with what you'd guess for rent exemption?
Hi <@!134416332509675520> , i'm facing an issue with create an mint and its associated account inside the same derived account, its throw an error:- can you please take a look.
`pub struct InitMintAndAssociated{
#[account(init_if_needed,payer = owner,seeds=[],bump =bump_seed,mint::decimals = 6,mint::authority = mint)]
pub mint: Account<'info, Mint>,

#[account(init_if_needed,payer = owner,associated_token::mint = mint,associated_token::authority = owner)]
pub mint_atoken_account: Account<'info, TokenAccount>,
}`
I think on mainnet it's also the same :P. I've experienced it
I was wondering why do I pay twice on devnet too!
In general `Account<'info, Whatever>` makes sure the account is owned by whatever program is expected to own a Whatever (e.g. a `Account<'info, TokenAccount>` makes sure the account is owned by the spl token program)
Yeah, that would be the normal way to check ownership
:chefs-kiss: thats exacltly what I wanted to know , thanks
Also, if the account stores one of your structs, then `Account<'info, YourStruct>` checks this already
Ah, `ID`, or `id()`
yeah, I think the question is how can I access the current program's id to put on the right hand side of the constraint?
Yeah, I unfortunately wouldn't expect the IDL generation to work correctly unless everything is in your actual project
Yep, there's the `owner =` attribute (you can also just use a regular `constraint =` if you want
**code:**

- this is missing permissions, i see an invoke_signed function but i dont know where to get the user account's seeds inside my program? the user only signed the transaction on frontend so far

```
        let ix = anchor_lang::solana_program::system_instruction::transfer(
            &ctx.accounts.user.key(),
            &ctx.accounts.dest.key(),
            amount,
        );

        anchor_lang::solana_program::program::invoke(
            &ix,
            &[
                ctx.accounts.user.to_account_info(),
                ctx.accounts.dest.to_account_info(),
            ],
        )?;
```
**my goal:** in my anchor program, call system_program transfer instruction to transfer lamports from an account owned by SystemAccount (not PDA) to another arbitrary SystemAccount

**my current setup:**
- a frontend with wallet integrated that allows user to sign transactions from browser
- calling my anchor instruction via RPC from frontend
- an anchor program with an instruction containing CPI call to SystemProgram

**problem:** 
- in my program i try to do a CPI to system_program to transfer lamports but don't have permission to transfer from user's wallet, i'm using `invoke`, how do i sign the transaction in my program?
(my own custom library that is, not a crate)
maybe it has something to do with the type being defined in a separate library that I'm importing?
still getting the error
hm the problem is it already has it
Hi, would like to know if there is a way to est. the program deployment fees? I always end up spending 2x the fees than what's suggested by the cli when deploying the program. E.g. my cli said
```
XXX has insufficient funds for spend (3.2884956 SOL) + fee (0.002355 SOL)
```
I ended up spending 2 * (3.2884956 + 0.002355) upon successful deployment. Any ideas? Thanks
hey folks how can I check if a PDA belongs to this program in an anchor constraint attribute?
hit there, I'm trying to extend the basic-3 example (from the docs) by introducing some access control. More specifically, there is the puppet and the puppet_master programs; the latter does a CPI to the former. In the original example the `set_data` method can be called by anyone. I want to restrict it so it can only be called by the PDA owned by the puppet_master.

I have attached the two programs below. The issue I experience is that the `is_signer` of the PDA is set to false although I used `CpiContext::new_with_signer`before executing the CPI. 

I would be grateful if you can guide me; PDAs look a very confusing concept and there is not much docs in terms of how to properly use it within Anchor (unless I'm missing something).

https://gist.github.com/ppoliani/4f02c01b0fa069c69238c05ed1f2c6f9
How about using `#[derive(AnchorSerialize, AnchorDeserialize, Clone)]` on that struct? I'm assuming you use that struct in the field of an account you define
how would I tell anchor about a custom type I'm using ?

getting this error on testing:
```
IdlError: Type not found: {"name":"rewardRate","type":{"defined":"Number"}}
```
Or .fetch
getAccountInfo
how can a check if an account has been created after using ``findProgramAddress`` ?
what is has_one
anyone else found a better way to handle enums? they deserialize as objects with keys and empty value in anchor even when i add `#[repr(u8)]`
interesting, i dont know the difference. do you have any articles or starting points where i can learn more?
in general, when it comes to solana, the code is the docs.
you're not gonna find a lot of info out there, because the impl is changing too fast
also depends how u tried to update it.
solana deploy is different than solana program deploy
thanks
It's final as far as I know, at least currently (sounds like you'll be able to resize accounts at some point)
If I attempt to redeploy my program, and it exceeds the space allocated for it (twice the initial program size by default with anchor), will more space be allocated? or is program size final?
noobuntu 20.04
I am a noob so ubuntu
What linux distro do most of you use for solana development? Which ones are better than others?
new anchor versions seem to not include `Wallet` despite it being a param for `Provider` construction
does anyone have a pointer to a doc/wiki that explains how instruction data is serialized? I see that it uses borsh, but what's the actual format?
Has anyone successfully completed a transaction with anchor without including the signer keypair in the context? i.e. signing the transaction remotely

Update: got it to work once I was using `program.transaction` instead of `program.instruction`, not sure if PEBCAK
I know
Does anyone know how to create a new Serum market?
Thanks <@!920245315926376470>  
I will check this .
Ok, I found third way to verify ed25519 sign. It looks like most natural way for solana. Here it is:
```    let sol_sig = solana_sdk::signature::Signature::new(&sig_bytes);
    let res = sol_sig.verify(&solana_address.to_bytes(), &raw_bytes);
    assert!(res);```
There is only one problem: it works well on pure rust but adding solana-sdk to the anchor project cause build errors:
```error[E0425]: cannot find function `is` in this scope
  --> /home/elderjoy/.cargo/registry/src/github.com-1ecc6299db9ec823/atty-0.2.14/src/lib.rs:98:6
   |
98 |     !is(stream)
   |      ^^ not found in this scope```
Any advice to solve this errors?


///////////////////////////////////////////////////////////////////////////////////////////////

About initializing accounts at PDAs, I would suggest not thinking of it any differently as initializing an account at a regular keypair address. You need to ask the system program to allocate the account, and that requires a signature; you then just have to think "ok, how can I produce a signature for this PDA address?". Everything else follows from that.
I was looking for a simple example where the program just takes a fee to its token account
thanks a lot, will check this out
https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo/src/lib.rs#L182
https://github.com/cqfd/quidproquo has an example of a token account that lives at a PDA
Do you happen to have a good example? I was looking at ido and cashiers check but unsure
Init-ing an account that lives at a PDA always requires the intervention of the deriving program, yeah
Does this mean creating a new token account for a pda must be done in the program as well?
whenever u create an account, u have to sign for the Pubkey at which the account is being created. with a normal keypair, you just sign the create ix with the private key. but PDAs don't have private keys—and only a program can sign for its PDAs. the only way for the program to sign for the PDA is inside the program
wdym. i don't think so
That's the bit I was wondering about. What we are really saying here is that the way to do this is to restrict the use of that endpoint then.
best way to understand is just to try creating an account at a PDA outside of a program
the instruction that inits the PDA can be scoped to an authority
the fact that a PDA is necessarily created by the program does not mean it was created by a specific authority
There might be a fundamental misunderstanding on my part here, but I still don't get why "is PDA" equates "is mine"
cool cool. yeah u can tell based on the pubkey. there's a method for Pubkeys in web3js called "isOnCurve"
yea
you're saying like how would u make sure that all of the accounts you're fetching  on the client are actually PDAs?
i think it's easy to do that part, but what about off-chain fetching of the PDAs? you'd want to have the seeds stored somewhere to grab and derive
not really all the accounts in the ix but just the post account
yes, you just have to require that all the accounts passed into createPost are PDAs
Does it matter though? If we take the analogy of a blog for instance, and the `BlogProgram` has a `CreatePost` call. Anyone can create a post, and have sole authority on updating that post later, if the program enforces the correct signature checks. That doesn't solve the problem that when, from a client, I query all accounts of type `Post` I will receive all the posts, even the ones created by other people. Does it?
ahh yea i made the incorrect assumption then that a PDA can be inited outside the context of a program
anyone can create accounts owned by your program, but only your program can create accounts stored at an address that is program-derived aka a PDA
The issue is in the fact that anyone can create an account owned by that program. If I am only interested in the accounts I created, how can I filter only those without some kind of whitelist? I cannot rely on data written in the account, since anyone could specify the same "owner" as me.
instead of a whitelist, you could use the existance of a PDA as proof of whitelisting--kind of like an auth token
had a convo with <@!915682383905316864> about whitelisting PDAs inited by a specific account. what's the most idiomatic way to go about this? I'm thinking of keeping a list on chain of seeds used to derive the account inited by specific account
Copy's ok actually, it'll still refer to the same underlying lamport storage
I think I figured it out I was doing a calculation on the lamports which was wrong.
Is `base_account` a reference to the context account? Maybe you are withdrawing lamports from a copy, and adding the the actual account, so ending up with a different sum.
How about logging both `ctx.accounts.winner.to_account_info().lamports()` and `ctx.accounts.base_account.to_account_info().lamports()` after this snippet?
I call the payment function with the following. 
```
let amount = (base_account.pool_list[i].pool_balance_after_fees as f64 * per) as u64; 
// we use after fees pool bal so there is money left to pay fees 
// now transfer the ammount in lamports to the winners
let from = base_account.to_account_info(); 
let to = ctx.accounts.winner.to_account_info();

**from.try_borrow_mut_lamports()? -= amount;
**to.try_borrow_mut_lamports()? += amount;
```
alright, thx! 🙂
Yep, `.amount` on an `Account<'info, TokenAccount>`
turns out i was printing the wrong stuff. i was calling `.lamports()` to read how many tokens that account had, which is wrong. do you know by any chance if there is something like `.lamports()` but for tokens? (similar to Token.amount in the typescript API?)
he also has this one. this is not written in anchor though, but the explanations here are much fuller https://paulx.dev/blog/2021/01/14/programming-on-solana-an-introduction/
Thank you <@!350632015852208140>, I will check that
Ok cool I’ll post the request when I’m back at my desk
thanks a lot!!! 🙂
alright. I will trust your judgement and look into this 😅  i was trying to rule out this case all along but maybe some decimal stuff. man decimals are annoying to deal with
I've seen this error before, it means you're low on tokens
Maybe something with the decimals?
maybe its super program-specific though
but this is weird, because i want to send `100` tokens, but it tells me that there are `2039280`. or am i missing something?
Error: insufficient funds, from with the token transfer
Ok, yeah, there's your problem: you don't have enough tokens in the source account
everything with `Program log` I produce with `msg!` macros
Ah, you mean just this?
```
    'Program 3vTbhuwJwR5BadSH9wt29rLf91S57x31ynQZJpG9cf7E invoke [1]',
    'Program log: Amount to send it: 100',
    'Program log: x to y: true',
    'Program log: by_amount_in: true',
    'Program log: sqrt_price_limit: 948683298050',
    'Program 77yFpTqxesQNz7Styk6yTRBaEcW9LxDKPvA46HfuA77z invoke [2]',
    'Program log: Amount in: 100',
    'Program log: Amount to 2039280',
    'Program log: Amount from 2039280',
    'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [3]',
    'Program log: Instruction: Transfer',
    'Program log: Error: insufficient funds',
    'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 2403 of 51364 compute units',
    'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA failed: custom program error: 0x1',
    'Program 77yFpTqxesQNz7Styk6yTRBaEcW9LxDKPvA46HfuA77z consumed 173878 of 173878 compute units',
    'Program 77yFpTqxesQNz7Styk6yTRBaEcW9LxDKPvA46HfuA77z failed: custom program error: 0x1',
    'Program 3vTbhuwJwR5BadSH9wt29rLf91S57x31ynQZJpG9cf7E consumed 200000 of 200000 compute units',
    'Program 3vTbhuwJwR5BadSH9wt29rLf91S57x31ynQZJpG9cf7E failed: custom program error: 0x1'
```
Or if you're running in the browser etc. it will show up in your console
If you're running an anchor test it will print the log output for failed txs
How are you producing a failure?
That won't include failed txs
ah, from ` test-ledger/validator.log`?
Failed transactions don't show up there, you'd need to pluck them from your test failures
Ah, are you finding these from the validator logs?
and this is the CPI / program that gets called (A):
```
Streaming transaction logs mentioning 77yFpTqxesQNz7Styk6yTRBaEcW9LxDKPvA46HfuA77z. Confirmed commitment
Transaction executed in slot 19:
  Signature: 2bQVbjmYo1vBsw1yFQpZLNnyHoSBPEpeyu7dt1hbSu8atFmJb9ZrJeyaVjMjraGZeog8U8SWJRRY1ajDjdTaz1yW
  Status: Ok
  Log Messages:
    Program 77yFpTqxesQNz7Styk6yTRBaEcW9LxDKPvA46HfuA77z invoke [1]
    Program 11111111111111111111111111111111 invoke [2]
    Program 11111111111111111111111111111111 success
    Program 77yFpTqxesQNz7Styk6yTRBaEcW9LxDKPvA46HfuA77z consumed 12259 of 200000 compute units
    Program 77yFpTqxesQNz7Styk6yTRBaEcW9LxDKPvA46HfuA77z success
Transaction executed in slot 20:
  Signature: 66e2X66ZCQBo4nJVsPzAcDA2UbKj6Kr8QADTJrLsuAq2EZh92ykyug2GXCJF4z5RmQZsuBRGKnEiJs5ss4ryyTpP
  Status: Ok
  Log Messages:
    Program 77yFpTqxesQNz7Styk6yTRBaEcW9LxDKPvA46HfuA77z invoke [1]
    Program 11111111111111111111111111111111 invoke [2]
    Program 11111111111111111111111111111111 success
    Program 77yFpTqxesQNz7Styk6yTRBaEcW9LxDKPvA46HfuA77z consumed 14871 of 200000 compute units
    Program 77yFpTqxesQNz7Styk6yTRBaEcW9LxDKPvA46HfuA77z success
Transaction executed in slot 23:
  Signature: 3cYcJRMuFBAjJJkLRXcof2mDBaY1uXQXuVpKboTGwbGx3XHavDHn3MQq4xDKSsQqzRTEoGPT5r4qve3oxKhGoyPH
  Status: Ok
  Log Messages:
    Program 11111111111111111111111111111111 invoke [1]
    Program 11111111111111111111111111111111 success
    Program 77yFpTqxesQNz7Styk6yTRBaEcW9LxDKPvA46HfuA77z invoke [1]
    Program 11111111111111111111111111111111 invoke [2]
    Program 11111111111111111111111111111111 success
    Program 77yFpTqxesQNz7Styk6yTRBaEcW9LxDKPvA46HfuA77z consumed 47590 of 200000 compute units
    Program 77yFpTqxesQNz7Styk6yTRBaEcW9LxDKPvA46HfuA77z success
```
this is the program (B) that does the CPI call. (it does a couple transactions before, and can't seem to find errors here..)
``` 
Streaming transaction logs mentioning 3vTbhuwJwR5BadSH9wt29rLf91S57x31ynQZJpG9cf7E. Confirmed commitment
Transaction executed in slot 17:
  Signature: 3H7rFsCBDE21QqhHVkeaLxJymmY8uvxVyyyR7L9b42eJCg63DLDRUB49nhQkX5Jf583wp6vxFvR695S5J42fBJX5
  Status: Ok
  Log Messages:
    Program 3vTbhuwJwR5BadSH9wt29rLf91S57x31ynQZJpG9cf7E invoke [1]
    Program log: Health ok!
    Program 3vTbhuwJwR5BadSH9wt29rLf91S57x31ynQZJpG9cf7E consumed 3241 of 200000 compute units
    Program 3vTbhuwJwR5BadSH9wt29rLf91S57x31ynQZJpG9cf7E success
Transaction executed in slot 33:
  Signature: jKmjD3rJnkvFKU9jQRL6VggV5YXUDPuhp1V3Tjb1BbmPVcaPCMcsZ1NpEE3kKnbs39DFqAX5qXzV79a2fWqp6Hw
  Status: Ok
  Log Messages:
    Program 3vTbhuwJwR5BadSH9wt29rLf91S57x31ynQZJpG9cf7E invoke [1]
    Program 11111111111111111111111111111111 invoke [2]
    Program 11111111111111111111111111111111 success
    Program 3vTbhuwJwR5BadSH9wt29rLf91S57x31ynQZJpG9cf7E consumed 19483 of 200000 compute units
    Program 3vTbhuwJwR5BadSH9wt29rLf91S57x31ynQZJpG9cf7E success
```
That will provide a bunch of info
Or even just your program log
hmm, let me try to do that in an ingestible manner xD
Also, can you post your program log?
Can you post your code? Probably easier to debug that way
sorry for the confusion, I should be more explicit. Basically, I assume the existence of three accounts:
(A) the program-address of the program that I am doing CPI calls on
(B) the program-address that does the CPI calls
(C) my own wallet (stored as a keypair)

(C) has plenty of funds. (B) has no funds. I am calling the program (A) through (B) (hence, CPI). All (token) accounts seem to be right, and seem to have enough token-funds. But I'm getting a 
` Error processing Instruction 0: custom program error: 0x1` error, which makes me question if maybe (B) is trying to pay for the CPI call. Does this explain this better?
So what do you mean by "payer" here?
Mm, not totally sure I'm following—the CPI has certain expectations about the accounts you feed it, but there aren't any additional fees. So you just need to pass it accounts that make sense.
hmm I see. so the CPI callee has to allow for the initial caller to define the payer in a way? basically if the CPI call only allows the PDA to be the payer (instead of the original RPC caller), then the CPI definition would have to be changed, right?
So you'd just have to make sure that you're passing the right accounts into the CPI (if the CPI expects one account to pay for something, e.g. initializing an account, make sure you pass an account that has money, etc.)
The tx fees are assessed for the transaction as a whole, not individual instructions/CPIs.
hey guys, i have a quick question. when invoking a CPI call, is there any way to specify who the payer for this transaction is? or does the RPC-invoked pay all expenses by default? 

I am currently getting a `Error processing Instruction 0: custom program error: 0x1` within the CPI call, and my PDA does not have any funds be default. (but the user invoking the commands does have plenty)
Right, only the owning program can mutate an account's data—being able to sign for the address is not (necessarily) relevant.
We would need to see your instruction function to debug further.
That error can actually arise for pretty odd/tricky reasons, but usually it's self-explanatory. Are you doing some lamport stuff incorrectly?
Is this account marked as mutable in your Accounts structs?
this should answer your question: https://hackmd.io/@ironaddicteddog/anchor_example_escrow
I’m sending from the program account to an external account.
Are you closing an account? Are you sending to any accounts, that you have not declared?
hey guys, has anyone had this error before? 
```SendTransactionError: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: sum of account balances before and after instruction do not match
    at Connection.sendEncodedTransaction```
Nvm, pressed typescript in the anchor GitHub 🤦🏻‍♂️
Is there good documentation of like every anchor function? I feel like I can’t find just a list of functions and what they do.
Hey, How do we create an Escrow which stores the SOLs?
haha I'll take your word for it
you are a good dev.
awesome! ty very much.
(this is pseudocode)
in essence:
```
const ix1 = program.instruction.init();
const ix2 = program.instruction.update();
const tx = new Transaction();
tx.add(ix1, ix2);
await program.provider.send(tx);
```
how can i call two instructions - init, update  in one tx
oh, sorry. doesn't make sense to me
then build your own Transaction object (`web3.js`) and use `program.provider.send()` or something like that to send it
you are using the `rpc` namespace when doing `program.rpc.init()`
instead, you can build the instruction without sending it using the `instruction` namespace: `program.instruction.init()`
hi, hello
how can i combine several rpc calls into one transaction
ex; program.rpc.init()
program.rpc.update()
if i call these functions, two transactions are issued
how can i combine them into one tx?
help me
SOLVED (i think): initializing the ProgramAccount sets the owner metadata to the current program_id, so the private key used to sign it initially is irrelevant after that point?
Am I missing something basic here?
```    const multisig = anchor.web3.Keypair.generate();
 ...
    await program.rpc.createMultisig(owners, threshold, nonce, {
      accounts: {
        multisig: multisig.publicKey,
        rent: anchor.web3.SYSVAR_RENT_PUBKEY,
      },
      instructions: [
        await program.account.multisig.createInstruction(
          multisig,
          multisigSize
        ),
      ],
      signers: [multisig],
    });```
But the instruction initializing it is signed by a normal keypair
which is allegedly "owned by an account"
```/**
 * @hidden
 *
 * Deserialized account owned by a program.
 */
export type ProgramAccount<T = any> = {
  publicKey: PublicKey;
  account: T;
};```
It's annotated as a "ProgramAccount"
```#[derive(Accounts)]
pub struct CreateMultisig<'info> {
    #[account(zero)]
    multisig: ProgramAccount<'info, Multisig>,
}```
I think there might be an vulnerability in the multisig example in the anchor tests directory.
The Multisig account that stores the owners, threshold and nonce is not a PDA, it's a normal account.
Isn't it possible for whoever holds the multisig account keypair to arbitrarily change the owners after having set everything up?
Seems like a single point of failure to me.
No idea what happened, but one of my account suddenly not generated in the IDL and there is no error, what could possibly happen I don't find any logical explanations
Oh awesome thank you !
You just have init the mint before initing the token account
There's a mint example there
Look at the IDO pool example again
No
Create a mint object in javascript and pass it through?
I guess we have to provide all that ourselves ?
Cause there is no mint for that
How would we now initialise our own pool token
<@248066053161222144> that worked a treat thank you!
oh ok ill use the right bump then
hence why we were using init_if_needed
You need to use the bump you get from findProgramAdress
we plan to initialize once however in our testing we may call init over and over just to see if works ok
It's specific
No
so thats fine right?
yea but the same bump with different seeds?
Also you're using the same bump twice
Assumedly you only plan to run initialize once
Put init instead
just remove it altogether or put init instead?
I don't know
oh how come?
Turn off `init_if_needed`
Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account
but now im getting
ive done this <@!248066053161222144>

You want to check account.mint.key()
Anchor/tests
in which repo?
And PDA authorities
Check out the IDO pool example in tests to see how to init token accounts with PDAs
i tried this before and it didn't work

```
    #[account(mut)]
    pub user: Signer<'info>,
    #[account(mut,
        constraint=order_account.mint==user.key(),  //here user.key() is work
    )]
    pub order_account: ProgramAccount<'info, Order>,
    #[account(init,
        payer = user,
        associated_token::mint = mint,
        associated_token::authority = user,    //here user.key() is error, only user is enough, why
    )]
```
There are key words for this
Honestly this really isn't how we normally init token accounts in anchor
so its a pda?
like i get authority like this
I don't know

in my JS code im passing the authority by deriving it from the account
but my account and authority are correct?
you hero
doing that now 🙂
That's how I do it
You should look up jet protocols source for an example, with the keyword I showed you
oh right ok ill remove that
They're there by default already
You don't need to have the program id in the seeds btw
just need signer info?

so youre syaing this on its own is fine
And you need to add stuff inside the ()
Cpi_ctx.with_signer()
or in the accounts in the instruction
so do you think the issue is in my instruction parameters
oh ok thank you
.with_signer is the keyword
They add PDA signers
Look up jet protocols source
yea my instruction looks like this

If your authority is a PDA you need to add a signer
It looks like you don't add a signer
can't they be the same?
in the function above whats the difference between account and authority?
Oh well
Insufficient information to answer
as it might not be a beginner question...
ill stick to this
sorry aobut that
what am i doing wrong?
Please stick to one channel then
but this fails and says "invalid account information"
im trying to create a usdc token account for my program in an instruction

i posted this on the beginner chat as well
ok, i'll check it by line
Not sure which line is causing this for you though
As the error states
You can't convert a pubkey to account info
```
#[derive(Accounts)]   // here show error
pub struct BuyNftToken<'info> {
    #[account(mut)]
    pub user: Signer<'info>,
    #[account(mut)]
    pub seller: AccountInfo<'info>,
    #[account(mut,
        constraint=order_account.mint==mint.key(),
        constraint=order_account.user==*seller.key,
    )]
    pub order_account: ProgramAccount<'info, Order>,
    #[account(init,
        payer = user,
        associated_token::mint = mint,
        associated_token::authority = user.key(),
    )]
    pub user_ata_account: Account<'info, TokenAccount>,
    #[account(
        constraint= mint.decimals==0,
        constraint= mint.supply==1)]
    pub mint: Account<'info, Mint>,
    #[account(mut,
        constraint=mp_ata_account.amount==1,
        constraint=mp_ata_account.mint==mint.key(),
        constraint=mp_ata_account.owner==mp_pda_account.key()
    )]
    pub mp_ata_account: Account<'info, TokenAccount>,
    pub mp_pda_account: ProgramAccount<'info, Marketplace>,
    pub token_program: Program<'info, Token>,
    pub associated_token_program: AccountInfo<'info>,
    pub system_program: Program<'info, System>,
    pub rent: Sysvar<'info, Rent>,
}
```
hi, any problem with this error?

no method named `to_account_info` found for struct `anchor_lang::prelude::Pubkey` in the current scope
method not found in `anchor_lang::prelude::Pubkey`
if i am not wrong the .json file is the bytes of private key then public key
lol well in my quest to edit the CLI to allow remote signing of deploys I removed the "msg <address>" spam when deploying
```
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub struct PoseidonSbox(pub i8);
```
```
#[derive(Clone, Copy)]
pub struct FixedPoseidonBN254Parameters {
    /// The round key constants
    pub round_keys: [ark_bn254::Fr; 195],
    /// The MDS matrix to apply in the mix layer.
    pub mds_matrix: [[ark_bn254::Fr; 3]; 3],
    /// Number of full SBox rounds
    pub full_rounds: u8,
    /// Number of partial rounds
    pub partial_rounds: u8,
    /// The size of the permutation, in field elements.
    pub width: u8,
    /// The S-box to apply in the sub words layer.
    pub sbox: PoseidonSbox,
}
```
Mm, yeah, this is pretty limited. What is a FixedPoseidonBN254Parameters under the hood?
Is there something I should add on the TS side?
```
#[account(zero_copy)]
pub struct MerkleTreeAccount {
    pub initializer_key: Pubkey,
    pub current_root_index: u8,
    pub next_index: u32,
    pub levels: u8,
    pub roots: [[u8; 32]; 32],
    pub filled_subtrees: [[u8; 32]; 32],
    pub params: HashParams,
}

#[zero_copy]
pub struct HashParams {
    params: FixedPoseidonBN254Parameters,
}
```
How to ensure the IDL can generate types?
Still stuck here 😦 `IdlError: Type not found: {"name":"params","type":{"defined":"FixedPoseidonBN254Parameters"}}`
Perfect thanks!
I can't really give an interesting answer to this but solana certainly tries to make it accurate-ish: https://docs.solana.com/developing/runtime-facilities/sysvars#clock
Wondering how safe is the on chain clock? I can tolerate a few minutes to seconds of difference but wouldn't want someone to figure out how to jump the clock forward a bunch
Look on the bright side, if you make some zk stuff early on Solana people will be really impressed and give you a lot of money
Not sure if there's a way to skip IDL generation (don't think solana itself cares about const generics, since they're just type system things)
this chain makes zk apps a nightmare
ok
ugh lol
Don't think const generics work with the IDL generation, no :/
And are there examples of writing anchor tests in Rust? Noob question I'm sure
Is it possible the const generics cause issues with Anchor/Solana?
What are ways to debug this error?
```
IdlError: Type not found: {"name":"params","type":{"defined":"FixedPoseidonParameters::<ark_bn254::Fr,195,3,3>"}}
```
They accomplish the same thing, but `Signer` is slightly nicer since the type itself tells you that they signed (it's baked in statically, whereas the other version doesn't change the type)
Is there a difference between: 

```
pub authority: Signer<'info>
```

and 

```
#[account(signer)]
pub authority: AccountInfo<'info>
```

or do they accomplish the same thing?


///////////////////////////////////////////////////////////////////////////////////////////////

`init_if_needed` implies `mut` automatically actually
Maybe if Staked is already init, then you need `mut` attribute as well on Staked account in order to overwrite its data.
Details coming up then 😄
Are you sure you haven't over-simplified the example?
I'm confused how your snippet could run (that `init_if_needed` attribute doesn't make sense as you've written it)
Hi everyone, I have a simple but weird problem about serialization of Pubkey to an Account, attaching a simplified version of the setup that I'm getting the error from.

On line 7, I get: Program log: panicked at 'Slice must be the same length as a Pubkey: TryFromSliceError(())', /home/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-program-1.8.6/src/pubkey.rs:134:18

Solana channel has the same question here https://discord.com/channels/428295358100013066/517163444747894795/838536367108784130, I could not figure out the application of the answer to Anchor.

Does anyone have an idea or workaround about this issue?
Using svelte

Does anyone know how to fix this
ty for help, will try that out 🤝
Yeah I guess you can just use a `u8` or something instead of the enum 🤔
How we did it:
rust: https://github.com/drift-labs/protocol-v1/blob/master/programs/clearing_house/src/controller/position.rs#L15
typescript: https://github.com/drift-labs/protocol-v1/blob/master/sdk/src/types.ts#L9

Pretty much a complete hack since the class has no properties but you can use `PositionDirection.Long` syntax which sufficed
😭
Not really. Might just be better to not use enums in the api.
I think the way we did it is pretty shitty and starting to bite lol
Anybody have a nice way they're typing the rust enums on typescript side?
This was a good read! Thanks <@!134416332509675520> <:SMBHeart:886685780565708840>
Hum ok indeed, one more account to pass, do a sol tx, native sync call, thanks Alan
That means you've somehow got a 252 in your data when you should have had a 0 or a 1. Are you maybe fetching the wrong account?
Yeah, can you just pass the wrapped sol token account and then do the lamport transfer within your program?
Trying to get an ix below 1234 bytes :/
So how you withdraw from an account depends on which program owns it. If your own program owns the account, then you can just take its money (try searching for try_borrow_mut_lamports). If the account is owned by the system program, then you have to ask the system program to do the transfer (with system_instruction::transfer). If some other program owns the account, then you'll have to see if the program exposes some instruction to do the transfer—if not then you're out of luck, no way to move the lamports.
The trickiness with withdrawing from an account is that *only the program that owns the account can do it*. In general, if you want to mutate an account's data or spend its money, you have to ask its owning program to do it for you.
Hmm, pretty sure there's never been any anchor violation here (you'll definitely get a solana error if you *do* mutate a non-writable account). It would be cool if anchor prevented this statically though, yeah.
`constraint = incoming_account.lampors() >= amount` [edit: whoops, you already had got that 😛 sorry]
You can do `bump,` rather than `bump =`, and then anchor will re-calculate it for you. Not 100% sure I understand why you want to do this though, but you can.
No, you can withdraw from PDA accounts just fine—the PDAness of the address doesn't affect withdrawing in any way actually
Is there a way to wrap sols program side instead of client side?
```
#[account(mut, constraint = incoming_account.lamports() >= amount)]
incoming_account: AccountInfo<'info>,
```

This one is working 😊
I need to put constraint like this one but it is saying type mismatch between LHS and RHS of the constraint
```
#[account(mut, constraint = incoming_account.lamports.as_ref() >= amount)]
incoming_account: AccountInfo<'info>,
```
How do we put constraint on the lamport/SOL balance of a AccountInfo that is coming as input?
I remember previously there will be write access violation
i.e. not annotating the account as mut but mutate the content in the account will throw no error but keep the original account content
Did anyone experience the issue that Anchor now does not do the mut check?
that's correct. anchor's constraints are there to verify that the address passed in is derivable using the seeds & bump provided to it. In my use-case, i want to enforce that the contract will only take in accounts derived with the same seeds but only with the canonical bump. So i want the verification to check the address with `find_program_address` rather than deriving it with the provided `seeds + bump`.
As I understand it, you don't really _provide_ the bump, it's determined by the seeds. You need it to get the derived address 🙂
is there a way to use `init` &`seed` constraint without providing the `bump`? 

I see that the init code branch does have a case where it uses `find_program_address`  if the `bump` does not exists here: 
https://github.com/project-serum/anchor/blob/master/lang/syn/src/codegen/accounts/constraints.rs#L306

however, when i try it out like this:
```
    #[account(
      init,
      payer = funder,
      seeds = [b"seeeeeds"],
      space = NewAccount::LEN)]
    pub new_account: AccountLoader<'info, NewAccount>,
```
I get a `bump must be provided with seeds` error from the parser:
https://github.com/project-serum/anchor/blob/master/lang/syn/src/parser/accounts/constraints.rs#L410
hello guys, what's mean this error ? `Error: Invalid bool: 252` it provide from code bellow: 
`await program.account.config.fetch(configAddress)`
other than lowering the accounts in the insturction

any good ways to reduce stack usage?
is there a way to view program account data? either through a ui or by querying for it somehow?
Also <@!134416332509675520> looks like I can't withdraw from PDA accounts with data (referenced here https://github.com/project-serum/anchor/issues/1172)
So another question <@!134416332509675520> you've got 
```
 #[account(mut)]
    pub offer_maker: Signer<'info>,
```

but in your test when passing `signers` you pass in `offer` and not `program.provider.wallet.publicKey` which is the `offerMaker` public key. Why?
🤝
Got it, so I would do it this way
You need the vault to be a PDA so your program has control over it
So that looks correct?
It's returned by the call to findProgramAddress
Could literally just pass a pubkey for the `vault_account` since it takes SOL
Mm, I'm confused, you've already got the vaultAccountBump right there
So kinda confused how to obtain `vaultAccountBump` without that?
I don't need a token account
Should this work 

```
    const bet = anchor.web3.Keypair.generate();

    const [vaultAccount, vaultAccountBump] =
      await anchor.web3.PublicKey.findProgramAddress(
        [bet.publicKey.toBuffer()],
        program.programId
      );

    let tx = await program.rpc.make(vaultAccountBump, new anchor.BN(100), {
      accounts: {
        bet: bet.publicKey,
        betMaker: program.provider.wallet.publicKey,
        vault_account: vaultAccount,
        rent: anchor.web3.SYSVAR_RENT_PUBKEY,
        systemProgram: anchor.web3.SystemProgram.programId,
      },
    });
```
So I'm doing a) sets up the offer (just amount of offer in SOL, maybe more deets later) and b) transfers the offer makers half of the deal but it's SOL
When someone makes an offer in my program, it a) sets up the state of the offer (what do you want in return, etc.), and b) escrows the offer maker's half of the deal
You also need to pass in the account, but you don't need to init anything there (you just transfer it some sol)
I need to create an account for where to store the offer maker's tokens
Ah, no, offer is your bet structure
For me it's just SOL
I think I get it, in your case `offer` is the token
I have to init a token account (the escrowedMakerTokens)
I now understand the bump and seed concept, thanks <@!134416332509675520> 🙂
```
  it("lets you make and accept offers", async () => {
    const offer = anchor.web3.Keypair.generate();

    const [escrowedMakerTokens, escrowedMakerTokensBump] = await anchor.web3.PublicKey.findProgramAddress(
      [offer.publicKey.toBuffer()],
      program.programId
    );

    await program.rpc.make(
      escrowedMakerTokensBump,
      new anchor.BN(100),
      new anchor.BN(200),
      {
        accounts: {
          offer: offer.publicKey,
          offerMaker: program.provider.wallet.publicKey,
          escrowedMakerTokens: escrowedMakerTokens,
          tokenProgram: spl.TOKEN_PROGRAM_ID,
          rent: anchor.web3.SYSVAR_RENT_PUBKEY,
          systemProgram: anchor.web3.SystemProgram.programId,
      },
      signers: [offer]
    });
  });
```

So this is your test but in my case, I'm confused about the value of `escrowedMakerTokens`
Okay, I think I'm just reading the tests wrong then... one sec
You're going to store sol in an account, and its address is that PDA
```
 pub fn make(ctx: Context<Make>, vault_account_bump: u8, bet_amount: u64) -> ProgramResult {
        // Store state about the bet being made.
        // For when bet keeps withdrawn or actually rolled.
        let bet = &mut ctx.accounts.bet;
        bet.gambler_key = ctx.accounts.bet_maker.key();
        bet.amount = bet_amount;
        bet.vault_account_bump = vault_account_bump;

        let gambler = &ctx.accounts.bet_maker;
        let vault = &ctx.accounts.vault_account;
        let system_program = &ctx.accounts.system_program;

        // Transfer the gamblers SOL to the vault account
        invoke(
            &system_instruction::transfer(gambler.key, vault.key, bet_amount),
            &[
                gambler.clone(),
                vault.clone(),
                system_program.to_account_info(),
            ],
        )?;
        Ok(())
    }
```
No dude I'm the confused one for sure
Modified it as such:
```
#[account]
pub struct Bet {
    // public key of degen gambler
    pub gambler_key: Pubkey,
    // how much money are we gambling
    pub amount: u64,
    // we're going to store gamblers SOL in an account
    // that lives at a PDA, with seeds given by the "Bet" accounts address
    // storing the bump will save client from passing it
    pub vault_account_bump: u8,
}
#[derive(Accounts)]
#[instruction(vault_account_bump: u8, bet_amount: u64)]
pub struct Make<'info> {
    // this can also be written as
    // #[account(mut)]
    // pub bet_maker: Signer<'info>,
    #[account(mut, signer)]
    pub bet_maker: AccountInfo<'info>,
    // bet being made
    #[account(init, payer = bet_maker, space = 8 + 32 + 32 + 8 + 1)]
    pub bet: Account<'info, Bet>,
    // now create a vault or escrow account
    // f you're using an account info, you actually don't even need to init it at all
    // (you can just chuck some lamports in there).
    // Given that it'll be owned by the system program,
    // it's authority is automatically its own address (which is fine since it's a PDA)
    #[account(
        mut,
        seeds = [bet.key().as_ref()],
        bump = vault_account_bump,
    )]
    pub vault_account: AccountInfo<'info>,
    // variables we need regardless of what we're doing
    pub token_program: AccountInfo<'info>,
    pub system_program: Program<'info, System>,
    rent: Sysvar<'info, Rent>,
}
```
Why does that matter? I think I'm confused
So <@!134416332509675520> that makes a lot of sense! But I don't have a token or token account in this because using SOL.
Offer Gambler
You don't get ot pick it
Got it
The bump is determined by the seeds
Ahhhhhhhh
The bump is whatever you get when you use findProgramAddress based on the seeds you choose
Mm, not sure what you mean 🤔
In your tests in `quidproquo.ts` you get this:

```
 it("lets you make and accept offers", async () => {
    const offer = anchor.web3.Keypair.generate();

    const [escrowedMakerTokens, escrowedMakerTokensBump] = await anchor.web3.PublicKey.findProgramAddress(
      [offer.publicKey.toBuffer()],
      program.programId
    );
```

But in my case I don't have a token right, it's just SOL. So I don't need `escrowedMakerTokens` but I do need the bump for the PDA?
So I've got this but now trying to actually determine what is `escrowed_maker_tokens_bump` when calling the `Make` function, since I don't have a token here and just SOL, should I set this to a static value?
Basically as long as you can remember where you put the sol (what the seeds were), then you're good
With `mut` too
Yeah, that's fine
```
    #[account(
        mut,
        seeds = [offer.key().as_ref()],
        bump = escrowed_maker_tokens_bump,
    )]
    pub escrowed_maker_tokens: AccountInfo<'info>,
```
You'd just need to decide what seeds you want to use for the sol destination
To pass in order to use for the escrow account that now holds SOL
What do you mean? I don't really have a "mint" or "alanTokens" or anything so unsure how to get the `bump`
Or, not sure, I'm not totally sure what you're changing
The PDA address part would be the same I think
<@!134416332509675520> so now since I'm doing SOL, here in your tests,

```
    const offer = anchor.web3.Keypair.generate();

    const [escrowedMakerTokens, escrowedMakerTokensBump] = await anchor.web3.PublicKey.findProgramAddress(
      [offer.publicKey.toBuffer()],
      program.programId
    );
```

Should I still expect `escrowedMakerTokens` from the findPDA? or just the bump I'm using for the escrow account?
```
    const offerMaker = anchor.web3.Keypair.generate();

    const [escrowedMakerTokens, escrowedMakerTokensBump] = await anchor.web3.PublicKey.findProgramAddress(
      [offerMaker.publicKey.toBuffer()],
      program.programId
    );
```
deserialize(schema, Order, Buffer.from(accountInfo.data).slice(8));
yeah, i chop off 8bytes,  my option token_mint is None and error like this:
Unexpected 32 bytes after deserialized data
You probably need to chop off the first 8 bytes of the account data (anchor uses it for the account discriminator)
```
pub struct Order {
    account_type: Header,
    mint: Pubkey,
    user: Pubkey,
    token_mint: Option<Pubkey>,
    price: u64,
}
---------------------
const OrderSchema = new Map([
  [
    Order,
    {
      kind: "struct",
      fields: [
        ['accountType', 'u8'],
        ['mint', [32]],
        ['user', [32]],
        ['tokenMint', { kind: 'option', type: [32] }],
        ['price', 'u64'],
      ]
    }
  ]
]);

async function parseOrder(schema: Schema, account: PublicKey) {
  const conn = await getConnection();
  const accountInfo = await conn.getAccountInfo(account);
  return deserialize(schema, Order, accountInfo.data);
  console.log('order', Order);
}
```
hi, i want to parse Order use borsh-js, how to handler this option, my way is wrong.
`init` implies `mut`
Why don't you do it in your code though you're going to be sending in tokens which probably also counts as a write/mutation?
Ah, yeah, that's important (since you're going to be sending it sol—that counts as a write/mutation etc.)
Or does it not matter?
The escrow account?
Would I make it `mut`?
All good!
Would love to buy you coffee 🙂
Okay let me try that, thanks <@!134416332509675520> 🙂 also, trying to modify your program now instead of the tutorial and the comments in yours are real nice
Yep
Definitely need to make sure it's one of your/our PDAs though
But I'd keep the `seeds` and `bump` to derive the `pda` correctly?
So can just get rid of the `payer =` part
If you're using an account info, you actually don't even need to init it at all (you can just chuck some lamports in there). Given that it'll be owned by the system program, it's authority is automatically its own address (which is fine since it's a PDA)
Like this? If I don't provide these constraints then:
1) Who do I set the authority to? Should I just set it to the `offer_maker`?
2) I still needs `seeds` and `bump` to be able to reference the PDA later right?
```
    #[account(
        payer = offer_maker,
        seeds = [offer.key().as_ref()],
        bump = escrowed_maker_tokens_bump,
    )]
    pub escrowed_maker_tokens: AccountInfo<'info>,
```
I guess you could either use wrapped sol (a tokenized version of sol), or make the escrow account just be an `AccountInfo` owned by the system program (don't even need to init it) and just transfer it sol
So in this can, I don't need a mint address I'm guessing or do I use the sol token mint address as static in the constraint?
Yo! I've got some questions, your escrow is so much better. Learning tons. So if I want to exchange SOL for tokens, in your escrow program, we need to store the offer makes SOL, not tokens, how would this change:

```
    // This is where we'll store the offer maker's tokens.
    #[account(
        init,
        payer = offer_maker,
        seeds = [offer.key().as_ref()],
        bump = escrowed_maker_tokens_bump,
        token::mint = maker_mint,
        // We want the program itself to have authority over the escrow token
        // account, so we need to use some program-derived address here. Well,
        // the escrow token account itself already lives at a program-derived
        // address, so we can set its authority to be its own address.
        token::authority = escrowed_maker_tokens,
    )]
    pub escrowed_maker_tokens: Account<'info, TokenAccount>,
```

Thanks for the repo <@!134416332509675520> 🙂
Here's a different escrow example that has a dynamic seed: https://github.com/cqfd/quidproquo
It's just for the purpose of the example (yeah, in real life you'd need something dynamic)
Looking at the escrow program here https://hackmd.io/@ironaddicteddog/solana-anchor-escrow#References and have a question:

```
   #[account(
        init,
        seeds = [b"token-seed".as_ref()],
        bump = vault_account_bump,
        payer = initializer,
        token::mint = mint,
        token::authority = initializer,
    )]
    pub vault_account: Account<'info, TokenAccount>,
```

Why is the seed "b"token-seed" and not something dynamic in this case for the vault account?
At least if the address is derived from your program
Is using the 'seeds' and 'bump' account attributes the recommend way to check that a passed in account is a pda?
I wouldn't decompile but rather look at a few key instructions
Usually it is quite guessable, unless the program is really complex.
Ok yeah sounds like decompiling is hard 😛
Anyways, cool problem, I'm curious what you come up with
But I'm not actually sure how feasible it is to get that info from decompiling 🤔 Would love to know more about that!
But being able to decompile the source would tell you account structures, program arguments, etc.
Right (I'm fairly familiar with solana)
The uploaded program can only have const parameters (defined at compile time and immutable), which is not useful to most devs, so they use an account
I'm a noob at this [edit: meaning decompiling .so files], but I would have guessed that would be easier (also, program parameters go in instruction data too, not just accounts)
Ah, ok. Yeah, have you tried decompiling the uploaded program?
Since a program can't have state developers load them into accounts. I want to know the programs parameters, so I have to decode the account to figure out what they are.
Honestly, that's how I would like to guess schemas if I really had to
I would love to know more about decompiling uploaded .so files
and you can never really verify an upgradable program
Yes, definitely agree that verifying proprietary programs is yucky
Can you say more about that? Not sure what that means
not for their Auctions
verification of proprietary program behavior seems like one of the biggest problems in Solana
Ok, maybe I'm being dumb, I'm a little skeptical that this will work well in general, but happy to be proved wrong!
Do they not describe that kind of thing her? https://github.com/Bonfida/solana-name-service-guide
Plus in general I have to inspect accounts to check that the parameters are really what developers say they are, while not providing a schema
Bonfida naming service
What programs are you trying to guess schemas for?
was playing with this
🤔 Not clear to me how that will work well in general (even pubkey bytes are often pretty arbitrary—though yeah, I suppose you can use heuristics like checking if an account lives there)
```const borsh = require('borsh');
const { PublicKey } = require('@solana/web3.js')

class Assignable {
    constructor(properties) {
        Object.keys(properties).map((key) => {
            this[key] = properties[key];
        });
    }
}

class Test extends Assignable { }

const value = new Test({ x: "AAAA", y: "BBB", z: 'CCC' });
const schema = new Map([[Test, { kind: 'struct', fields: [['x', 'string'], ['y', 'string'], ['z', 'string']] }]]);

const buf = borsh.serialize(schema, value);
const sampleBuffer = "6f0eb7aa75c05820fc23575a706192a403d0bf2435f41ee93b85be51cb7aea9bb3c831b5cfd8ec805d0e628ad659d3983af7c8f70416d7630491498deb9aaee7e3ad85b4b889805fecdf748cb1f23adbdb488092ce27a2f18c48b167370d46b500";
const sampleBuffer2 = "2a37ece4aa41d80ec09c314e7d41b6667954b8450e15afaab8503b2ab0407b79b3c831b5cfd8ec805d0e628ad659d3983af7c8f70416d7630491498deb9aaee7780c2893eeb09feb89ad49bb7111a956ae3615f3bac869bbab810222008370cf00";
console.log(buf.toString('hex'));

function splitString(string, size) {
    var re = new RegExp('.{1,' + size + '}', 'g');
    return string.match(re);
}

const sampleBufferBytes =
    console.log(splitString(sampleBuffer, 64));
console.log(splitString(sampleBuffer2, 64));

console.log(splitString(sampleBuffer, 64).map((x) => x.split('')
    .map((el, ix, arr) => ix % 2 ? null : el + arr[ix + 1])
    .filter(el => el !== null)
    .map(x => parseInt(x, 16))).map(x => new PublicKey(x).toString()));


```
bingo
try different schemas until you get data that looks valid
What does brute forcing mean here?
pubkeys are fixed length and are easy to verify that they are valid using the RPC
it seems pretty trivial to brute force unless there are a lot of fields
I had some early success with this manually
idk if one exists
I have considered the possibility of writing a brute forcer though
you're not supposed to be able to find a schema easily
Not really possible to do that in general (the bytes are arbitrary). Best bet is to just go source-diving in the program
pubkeys are easy to pick out of the blob
I am talking about trying to find possible schemas given a blob of bytes
From what I have seen Borsch wants a schema
or just borsch in Rust
borsch-js
Want to make sure I am not reinventing the wheel before I write a script for it
Is there a tool out there that helps me with reverse engineering Account data?
I am not quite sure exactly how to do it, honestly, because I've only seen it done and failed at my attempts so far, but it's possible hahaha, use borsch-js
Yes, you need to deserialize the token account data to read it
Can we check a token account's authority from JS?
perfect. thank you!!
Yep
ok got it, thanks for clarification. so if a user signs a an rpc transcation call to MyProgram, am i able to do a cpi call to the SystemProgram within MyProgram to make the transaction?
(so your assumption was correct)
No, if your program doesn't own the account then you'll have to ask whichever program *does* own it to do the transfer for you (usually the system program)
oh wow ok. I will try this. i assumed that the program is not allowed to debit an account it does not own, regardless if the transaction has been signed. thanks for the clarification
then I believe ur program should be able to debit the account
yes the user would sign the transaction.
is the user signing the tx?
Hey all, Let's say i have scenario where a user deposits  `1 SOL`  in escrow. An admin account will take about 5% (0.05 SOL) and the rest (0.95 SOL) goes into an escrow.
The input accounts to the program would be `user_account` owned by SystemProgram, an `escrow_account` owned by  MyProgram and `admin_account` owned by SystemProgram. I understand MyProgram cannot debit the `user_account` since it does not own it. but is it possible to do an CPI call within the program to debit the `user_account` and credit the `escrow_account` and `admin_account` ? If not, what is the best way to split the `1 SOL` deposited by the user into two seperate accounts?
Seems that the ts IDL and the json IDL have different case for Accounts names
or just have init the program with some authority over the ix that's init-ing the pda, and check the signer = authority when that ix is invoked
True true I see what you’re saying. Someth that’s probably easier than trying to trace the person performing init is to require a token in order to call an ix in your program. So u can only call the ix if you own a token acct with a specific token
That is true, but also anyone can trigger the program to create these new accounts, unless a specific pubkey check is enforced in the contract
anyone can make a token account and set ur program’s pda as the owner. This is different from initializing an account where the pubkey is a PDA. Only ur program can create new accounts stored at PDAs
i think u are looking at it only from the perspective of token accounts
and is it ok to use solana 1.9.2 with it?
just checking, does anchor 0.19.0 use solana 1.8.5 or solana 1.9.2?
whoa this is exactly what i need. Thanks!
Is that enough to get you going?
https://discord.com/channels/889577356681945098/889577399308656662/923537673560408124
Provided that both your instructions together do not exceed the maximum transaction size, you can group them together
Still confused here. As I understand it a PDA is simply a way to let the program manipulate an account by signing for it. The user-space "owner" of any account owned by the program created through this PDA will be... the PDA. I don't see what this has to do with whitelisting when querying accounts owned by a program.
Hi all, I have a question about doing multiple rpc calls. I have two functions `create_account` and `deposit_sol`. I'd like to do multiple rpc calls with a single approval. 

For example, users will click donate, and it will create an account if there isn't already, and then donate the amount of sol. What is the most natural way to do this?


///////////////////////////////////////////////////////////////////////////////////////////////

Please post a code snippet/error log.
I think one problem might be that `user` is defined as a Signer type, but then client-side in the rpc you're only including the postAccount keypair in the signers array.
In a program, is it possible to read the state of a PDA  `Loader`  with `load_mut` while in the same instruction signing a CPI with the same PDA by using its `AccountInfo` (accessed via  `to_account_info` ) as the signing authority?

I noticed that when I call both `load_mut` (to access state) and `to_account_info` (used for the PDA authorized CPI) on the same PDA, I keep getting the runtime error: `instruction tries to borrow reference for an account which is already borrowed`

Would appreciate any guidance here 🙂

I've also searched for this error message within this server and haven't found anything related to my issue.
is there an nft standard for solana that I can copy and extend?
No. Absolute max is 10mb (and it'll cost you 70 sol to rent-exempt!)
is it possible to create an account with unlimited size?
Yeah, I guess I just call them "caller" and "callee"
got it, thx! 🙂 is there a name for the program that is being CPI called, and the program that does the CPI call? i.e. CPI callee and CPI caller I guess?
My guess though is that your `declare_id!` is wrong (take a look at the program log and see if you see 3Hu85D1dwvdXobYuN6A8A4Xe6joKFVw5QYK9fNFDN2Jc being printed for you program)
Can you post the full program log? Much easier to debug that way
Not totally sure I'm following your question... I think it will depend on context. The only hard rule about ownership is the one about how only the owning program can mutate one of its accounts, or spends one of its account's money.
```
use anchor_lang::prelude::*;

declare_id!("3Hu85D1dwvdXobYuN6A8A4Xe6joKFVw5QYK9fNFDN2Jc");

#[program]
pub mod mibexy {
    use super::*;

    pub fn post(ctx: Context<Initialize>, data: String) -> ProgramResult {
        let post_account = &mut ctx.accounts.post_account; 
        post_account.post = data;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 128)]
    pub post_account: Account<'info, Post>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program <'info, System>,
}

#[account]
pub struct Post {
    pub post: String
}
```
<@!350632015852208140> I posted the whole test. You want the lib.rs code?
one of the PDAs youre passing over are not generated by the program would be my first guess. what are the RPC calls doing? can you post minimal code?
How to fix this?
But I'm getting this error on anchor test:
```
Error: 167: The given account is not owned by the executing program
```
I have the following test:
```
import * as anchor from '@project-serum/anchor';
import { Program } from '@project-serum/anchor';
import { Mibexy } from '../target/types/mibexy';

describe('mibexy', () => {

  // Configure the client to use the local cluster.
  anchor.setProvider(anchor.Provider.env());

  const program = anchor.workspace.Mibexy as Program<Mibexy>;

  it('Is initialized!', async () => {
    // Add your test here.
    const postAccount0 = anchor.web3.Keypair.generate();
    const tx0 = await program.rpc.post("Hello World!", {
                 accounts: {
                     postAccount: postAccount0.publicKey,
                     user: program.provider.wallet.publicKey,
                     systemProgram: anchor.web3.SystemProgram.programId
                 },
                 signers: [postAccount0]
             });
    console.log("tx0: " + tx0);
    const postAccount1 = anchor.web3.Keypair.generate();
    const tx1 = await program.rpc.post("Great stuff!", {
                 accounts: {
                     postAccount: postAccount1.publicKey,
                     user: program.provider.wallet.publicKey,
                     systemProgram: anchor.web3.SystemProgram.programId
                 },
                 signers: [postAccount1]
             });
    console.log("tx1: " + tx1);
  });
});
```
can you post some code? of the context, and the logic?
whenever I execute a CPI call, and I initialize an account within that CPI call, I have the following question:
should the program that executed the CPI call  own this account, or should the program that is being called own this account? or does this depend on the context? 

I am playing around with a program right now, and it is the latter (bcs the underlying CPI program has to further process this..)
any idea why my state account data isn't updating ? <:thonk1:801847763527925821> even though they're mutable
Ahh okay thanks!
Mm, as written you don't have a choice, since `zero_copy` doesn't support heap allocations (Strings in rust live on the heap).
Or just a "stylistic" choice?
In this example we are usint a array of u8's to store something that could be stored in a String (ie. the name prop on ChatRoom). Is there a reason to use a u8 array instead of a String?
well, anything that changes the account but without `account(mut)` attached will silently keep the account data intact.
Can you post some example code?
The problem is that previously Solana would throw me a write violation but not anymore these days.
Correct, no problem. Associated token account is still initialized via spl token program's `initialize_account`, so ata accounts and generic token accounts are the same.
also, is there any issue with the token address being off-curve? the owner still has exclusive control over it in any case, right?
thanks! 🙂
lololol
Yep.
so you can have multiple token accounts that have the same mint authority, and same owners?
So yeah, Token.createAccount makes a token account that lives at a random address, whereas associated token account addresses are program-derived from the associated token program, with seeds based on the mint and the owner (so deterministic)
An associated token account is a token account that lives at a special kind of address (whereas a token account in general could live at any address you want)
quick question, what is the difference between `Token.createAccount` and `Token.createAssociatedTokenAccount`? I just realized I had this huge bug in my code where I used the former instead of the latter, so I am now confused about what `Token.createAccount` is used for? 

Calling `Token.createAccount` twice generates two different addresses. Probably a really simple stupid bug form my side
Yes, init_if_needed implies mut and I can get away without specifying space since my account has Default.
Cheers!
First of all, I cannot appreciate you guys more. This was my first time getting this kind of response from a community, thanks so much 🙂

On the other hand, I was trying to recreate the same situation on the tutorial codes, they worked wonderfully 😄
After that tried to gut the working code until the point of no fat except the error, failed.

Realized I have the error on the missed "overly simplified" parts. 🤦‍♂️ 

Thanks to you guys so much again. Sorry for inconvenience.
youre definitely missing the `payer` constraint and the `space` constraint on the `pub staked: Account<'info, Staked>`. An alternative to adding the `space` constraint is adding  `#[derive(Default)]` to the `Staked` struct


///////////////////////////////////////////////////////////////////////////////////////////////

Not as far as I know—I was actually thinking of porting that to anchor too!
https://github.com/solana-labs/solana-program-library/tree/master/stateless-asks

Is there an anchor implementation for this?
Kinda scary updating a program that's already running so sorry if its a silly question 😅
I'm looking to upgrade a program from 0.16.2 to at least 0.18.2. I really shouldn't have any issues if I haven't been using cpi's, right? Just looking at the changelog it only looks like cpi related functionality had breaking changes
🙂
nvm nvm
hmm still cant pinpoint the error
Oh that's confusing
gotcha makes sense
It just happens to be the same (they live in different namespaces)—you could change it if you want
Why would our error enum name be the same as our context?
I dont understand why we pull `Hello` in the ErrorCode
oo true
Just adding a semi-colon would *ignore* the error
You'd need to do `return Err(...);`

And adding the semi-colon in your example also won't work
😛
Looks like you changed the code though 😉
I get this error if  dont add the semicolon

You actually don't want the semi-colon there (the code is implicitly returning the Err)
heads up - this example is missing a semicolon after `Err(ErrorCode::Hello.into())`

https://project-serum.github.io/anchor/tutorials/tutorial-4.html#defining-a-program
Yeah (although I would probably just not do the minting in that instruction at all—it was just a goofy example, the important part is just creating the mint itself)
Stack space issues
Why use `Box<Account<'info, TokenAccount>>,` versus `Account<'info, TokenAccount>`
So we coulldve used `init` there instead of `init_if_needed`?
If anyone has info there please let me know
I won't be launching for at least 4 months at an optimistic view so I'm hoping by the time I do, rent will be cheaper. Both for my primary program and for the large number of NFTs it would look to create
Rent be expensive lately 🙂
I have seen tweets that mention rent fees being recalced/reconsidered in the future, potentially with savings like 10x, but nothing concrete. Has there been any source for this that is reliable?
thanks
hi any ways to generate rust client for serum dex?
If you use `init` and there's already an account there, then the tx will fail/rollback
Ah, yeah, the token account there is just a random artifact of writing this on a stream
https://github.com/cqfd/anchor-token-studies/blob/main/programs/token-studies/src/lib.rs#L100

- Why `init_if_needed`?  We're always going to initialize the token account because it's for a new mint, right?
- What are the consequences of using `init` when an account is already initialized at that address?
alan ur rlly carrying me through my career w Solana
gotchaa thanks alan
And yeah, decimals = 0 means just integer numbers of tokens
So empty seeds are still seeds (they're just empty)
`seeds` can be whatever you want, so in this case since the program doesn't do anything else, empty seeds for the mint are fine
A few questions...
- why is `seeds=[]` ? Why not add seeds
- why is `decimals=0`? That means we can't have like 1.5 tokens of the mint, right?
awesome
You have more repos??? LOL wow
https://github.com/cqfd/anchor-token-studies/blob/main/programs/token-studies/src/lib.rs#L93
And then because the mint lives at a PDA, the program has authority over it
So you could e.g. have the `mint::authority = the_mint` (the mint's authority is its own address!)
I want the mint to be owned by the program so I can create and burn new tokens
Ah, yeah, you can use `mint::decimals` and `mint::authority` instead
This creates a new tokenACCOUNT. But I want to programmatically create a new mint, not token account
```#[account(
        payer = offer_maker, 
        seeds = [offer.key().as_ref()],
        bump = escrowed_maker_tokens_bump,
        token::mint = maker_mint,
        token::authority = escrowed_maker_tokens,
    )]
    pub escrowed_maker_tokens: Account<'info, TokenAccount>,```
Sure. What have you tried? Does something end up failing?
Cant seem to find an example of that online
sweet. Also, can I mint a token at a PDA in Rust?
Yeah it's just a public key
Ah, yeah, that's fine
I think this is just the public key of the program
This line
`declare_id!("8VpEUzf68yWQaT1meH8hpjbUKRtL6dLS9UJkPGNEFyT4");`
The keypair? Don't push the private key, no
Is it safe for me to push my program ID to a remote repo? (I'm pretty sure the answer is yes, but just wanna make sure)
Although u say it's "kinda-hacky" it is the recommended way to access this type of big data struct though right?
Alright! Thanks alan!
You can still try doing `&mut ctx.account.chat_room`, but all you'll get is an exclusive reference to the AccountLoader thing—*not* to a ChatRoom. The reason why the analogous code works for an Account<'info, Whatever> is that Account (but not AccountLoader!) impls Rust's Deref/DerefMut traits
1. Yeah, definitely can't load a `ChatRoom` struct on the stack (way too big for solana's 4kb stack frames), or even on the heap for that matter (32kb).
2. You can use it in a program just fine, provided you do the AccountLoader/zero_copy stuff. The data itself is only accessed via a pointer to a non-stack/non-heap part of memory (the 0x4 part here https://docs.solana.com/developing/on-chain-programs/overview#memory-map)
3. Not sure what you mean here, zero_copy is just a trick to use that non-stack, non-heap part of the memory map. It's still just regular rust code though.
3.1. `.load_mut` is the kinda-hacky AccountLoader trick that lets squint at the underlying AccountInfo's `.data` as if it were a `ChatRoom` struct (over in that weird-but-spacious 0x4... part of the address space)
3.1. What is the difference between doing this  in order to access and be able to write data and the normal way of just using &mut ctx.accounts.chat_room?
3. Is it zero copy because the kernel, in order to write to it, can still reference it in it's serialized state without having to pass it to the program level?
2. Essentially this makes the ChatRoom struct an Account that can only truly be read from calling it using e.x program.account.chatroom.fetch() in js but never loaded into a program?
1.Is it true that the messages param in the ChatRoom struct is to large for any solana program to load it since it is to big?
Looking at this picture
I have been having some trouble with understanding the restrictions on the solana runtime and how effects the rust/anchor we write.
Yeah, good question. You can see the solana memory map here: https://docs.solana.com/developing/on-chain-programs/overview#memory-map. It turns out that AccountInfo `.data` is in the 0x4 section ("program input parameters", makes sense I guess); you can see this experimentally by doing something like
```.rs
pub fn your_ix(ctx: Context<Ix>) -> ProgramResult {
  // https://riptutorial.com/rust/example/24222/displaying-raw-pointers
  msg!("{:p}", *ctx.accounts.some_account_info.try_borrow_data()?);
}
```
You can kind of just do it—nothing anchor specific here, just rust. You can define the function wherever you want and call it from within your instruction function.
You always have to pass in any accounts your tx cares about (no way around this in solana).
I believe you need to pass in every account you want to read/modify. For modify you would need to use the `#[account(mut)]` attribute. There's a limit of ~35 accounts per transaction. Some more info here about a proposal for increasing this in the future https://docs.solana.com/proposals/transactions-v2
Hey all - I understand that in the Solana runtime the max stack frame is limited to `4KB` and the heap is `32KB`.

Q1 - Where does the `data` on an `AccountInfo` live during runtime? Is it something completely separate from the stack and heap that our program has access to?


Also can someone verify if the following two statements are accurate?

A. When using `AccountLoader`, if I call `load`, this creates a reference on the stack that points to the `data` of the `AccountInfo`. 

B. When using `AccountLoader`, if `load` is first called to do read-only operations, and then `load_mut` is called to do some mutations, these operations are not expensive / redundant because it's just borrowing the same `data`.
For an instruction, Do I have to pass in each and every account I want to modify? Or can I just pass in an account that has `AccountInfo` references to all the accounts I want to modify?
Where can I find an example of: how to make an internal function in anchor that is NOT an instruction?
good question ^
hey guys how do we deal with declare_id and collaborating with other devs? Are we supposed to share the keypair.json?
Thankss alan da man
Ownership of the program is just about what address you deploy it to (you'll need to sign for the address). By default anchor will generate a fresh keypair for you when you run `anchor build`, inside `target/deploy`, but you can provide your own.
When I do `anchor init`, it creates a program. How is the ownership of this new program decided?
ah nvm just another padding issue with zerocopy
im attempting to fetch an account during a unit test, and its returning this error:

```
     TypeError: Cannot read properties of null (reading 'property')
      at Union.decode (node_modules/buffer-layout/lib/Layout.js:1692:16)
      at Structure.decode (node_modules/buffer-layout/lib/Layout.js:1234:32)
      at Sequence.decode (node_modules/buffer-layout/lib/Layout.js:1090:34)
      at Structure.decode (node_modules/buffer-layout/lib/Layout.js:1234:32)
      at WrappedLayout.decode (node_modules/@project-serum/borsh/src/index.ts:92:37)
      at Structure.decode (node_modules/buffer-layout/lib/Layout.js:1234:32)
      at AccountsCoder.decode (node_modules/@project-serum/anchor/src/coder/accounts.ts:53:19)
      at AccountClient.fetchNullable (node_modules/@project-serum/anchor/src/program/namespace/account.ts:153:33)
      at runMicrotasks (<anonymous>)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at AccountClient.fetch (node_modules/@project-serum/anchor/src/program/namespace/account.ts:165:18)
```

the account does exist, i can look it up on a localnet block explorer and see the account, so its definitely not because the account doesnt exist <a:aPES_Think:493353113332219924>
is there a way to reference the `updateAuthority` of a program from within the program? I find it would be very useful if we can verify that an account is owned by the same authority that deployed the program from within that program
I have a CPI caller that has as program context the following account:

``` 
pub position: AccountLoader<'info, Position>,
``` 

Now the CPI callee requires this exact same account, but initializes this:

```
    #[account(init,
        seeds = [b"seedExample",
        owner.to_account_info().key.as_ref(),
        &position_list.load()?.head.to_le_bytes()],
        bump = bump, payer = owner,
    )]
    pub position: AccountLoader<'info, Position>, 
``` 

In the frontend, I create a PDA using the following (usual) logic). 

``` 
const [positionAddress, positionBump] = await PublicKey.findProgramAddress(
                        [Buffer.from(utils.bytes.utf8.encode(POSITION_SEED)), this.poolAccount.toBuffer(), indexBuffer],
                        this.cpiCaller.programId
                    )
``` 

and I pass this in as an account into the RPC call

``` 
accounts: {
  position: positionAddress.toString(),
}
``` 

No matter what I put in as the program-id to the `findProgramAddress`, I keep getting this error:

``` 
    'Program 3vTbhuwJwR5BadSH9wt29rLf91S57x31ynQZJpG9cf7E invoke [1]',
    'Program log: Custom program error: 0xa7',
    'Program 3vTbhuwJwR5BadSH9wt29rLf91S57x31ynQZJpG9cf7E consumed 3089 of 200000 compute units',
    'Program 3vTbhuwJwR5BadSH9wt29rLf91S57x31ynQZJpG9cf7E failed: custom program error: 0xa7'
    Error: 167: The given account is not owned by the executing program
``` 

I get the same error when I generate the PDA with the `this.cpiCallee.programId`  (instead of the Caller). 
I don't get this error when I change the account type from `AccountLoader` to `AccountInfo`. 

Any idea what I could be doing wrong, or where else I could be checking? The account I am trying to pass on to the CPI call is not initialized yet, and in the documentation I think I read that `AccountLoader` requires to be initialized before used. Is this true?

Would appreciate any pointers and help! 🙂
check out metaplex. they also help you create NFTs using candy-machine if thats of help
Yeah, sounds like you'll just have to be careful about the rust part. You could try doing the `.load_mut()` part inside of some `{ ... }` brackets so that the RefMut gets dropped, or maybe you could call `.to_account_info()` *before* doing the `.load_mut()` part, etc.


///////////////////////////////////////////////////////////////////////////////////////////////

in that case I'd do TS for both (coz it's internal - if it was a cli you'd actually be shipping to other devs then I'd consider rust)
Most likely cause of this line
```
const myProgram: anchor.Program = anchor.workspace.MyProgramName;
```
causing the mocha tests to stop executing? I'm not sure where to start looking for the bug here
has anyone successfully gotten a Ledger working with an Anchor program without using an existing wallet like Phantom?
Thanks! Im writng test on typescritp, but will consider switching to rust.
if not is there just a way to interface with the Swap API and get transactions to manually sign and send?
im trying to figure out how i can perform swaps with a Ledger using javascript, and it seems that using serum's swap API will be easiest. but I need to pass in an Anchor Provider to do that, and i'm not sure I can create one with a ledger device.
hey guys, is there any way to setup an anchor provider with a ledger device?
Our program has 2 sets of instructions: one to be called from the webpage, and another from the maintainer's computer. This program can be written in Rust without issue: the question is about the boilerplate I have to write. I'm not sure about what anchor generates
If you write your tests in Rust (and specifically if you use the ProgramTest struct) you can use this: https://github.com/solana-labs/solana/blob/master/program-test/src/lib.rs#L1014
and examples:
- https://github.com/solana-labs/solana/blob/77861e2d40e69b74adfa2fea9b1f54269c1d4c7a/program-test/tests/sysvar.rs#L40
- https://github.com/solana-labs/solana/blob/1adf255e3acecdb5f2f43d36e065bf071d496e3b/program-test/tests/warp.rs#L69

If I remember correctly the jumps might be finicky (not accurate), but it might be good enough for your goal
btw for anyone googling (discording?) this error in the future - the problem ended up being premature account deserialization at the caller program level.

what I did was:
- take an Account<'info, Whatever> at parent level
- then do #[account(init)] at child level
- the problem is of course the account doesn't exist when the parent tried to deserialize it into Whatever

the solution ended up being replacing Account<'info Whatever> with AccountInfo<'info>
in terms of actual libs - I don't even know what libs are used in TS for arg parsing:D maybe oen of these? https://openbase.com/categories/js/best-nodejs-cli-arguments-libraries
but most people aren't writing CLIs - they're writing front-ends that need sdks, hence the TS choice
if I was writing a pure CLI with no expectation of it being used in the front end, I would hands down opt for rust
Hi, Im looking for any convenient way of testing time-dependent programs (like vesting, staking).
I wonder if there is any way to manipulate cluster time in the test environment. Currently i am using sleep function, as seen in example programs, but dont really like it.
Is there any better way of testing time dependent logic?
I've used less TS than Rust, so that may explain why, but I think that TS is less ergonomic. For example, the lack of derive make me afraid that a CLI is harder to write
Thanks! Is there a tool in TS that looks like Rust's clap? What do people usually use?
you can still do it in rust, but most people prefer ts as it integrates with front ends
I'm saying that because the client is generated in TS
IIUC, I am supposed to write the CLI for my program in typescript?
yep
are they aligned with the output from `anchor keys list`?
I wonder if this might be related to the CPI call - because I keep checking the accounts (printing them out before they go into the RPC call) - and they look good to me.

I have 2 programs (both mine), one calling another. Works ok on localnet with `anchor test` but somehow fails on devnet. Tried re-deploying multiple times.

The IDs in `lib.rs` match the IDs I'm using in the front end. All other instructions work ok, but this one keeps throwing:
```
index.browser.esm.js?64b9:7051 Transaction simulation failed: Error processing Instruction 0: custom program error: 0xa7 
    Program 3bUquvD6S8EQbqGnMLhK9DXA1Pxn4D3mUtPE67rfJXZd invoke [1]
    Program log: Custom program error: 0xa7
    Program 3bUquvD6S8EQbqGnMLhK9DXA1Pxn4D3mUtPE67rfJXZd consumed 16459 of 200000 compute units
    Program 3bUquvD6S8EQbqGnMLhK9DXA1Pxn4D3mUtPE67rfJXZd failed: custom program error: 0xa7
```
and then
```
Error: 167: The given account is not owned by the executing program
```

Any thoughts anyone?
fml
typical black magic fuckery: when you run test - everything works dandy, when you run from front-end - Error 167
lol at this point I'm so desperate I will do that
I just keep commenting them until there's no errors <:kek:889992816296595456>
when you get a `Error: 167: The given account is not owned by the executing program` - is there a way to find out WHICH account specifically?
Thanks, my issue was fixed by applying the `{ ... }` brackets to make sure `RefMut`  from `load_mut` gets dropped after assigning the needed state values, and making sure `to_account_info` is called outside of this scope.
Thank you very much, alan. You are mysterious. It works well. but I adjusted package versions. here is my example
```
anchor-lang = "0.17.0"
anchor-spl = {version = "0.17.0"}
spl-token = {version = "3.2.0", features = ["no-entrypoint"]}
solana-program = "=1.7.11"
chainlink = { git = "https://github.com/smartcontractkit/chainlink-solana", package = "flux-aggregator", features = [
    "no-entrypoint",
] }
```
I want to use solana-program = "=1.8.0". How can I do?
I trimmed down the code to this just to get something working:

```
  const connection = new anchor.web3.Connection(
    "https://api.devnet.solana.com/",
    "recent"
  );

  // Address of the deployed program.
  const programId = new anchor.web3.PublicKey(
    "5nqz7wPBrZiUC3GSdFyNBdNmuwp1hGa6fWnC9mgLkVWp"
  );

  connection.onLogs(programId, (event, _) => {
    console.log("Event was received")
  });
```

The TX is here on devnet: https://explorer.solana.com/tx/4ckQ88KQAFmhA7RGR8ZrQhpXUJkqWkxEpYc5Hd5brzNBbgyD88sJTLTky1QMnQAQoJq92eYkAGpPGyKmBuK8hWTW?cluster=devnet

I can see the program log right here:

```
> Program log: A0jnii+LZmicPvmaGXVdejHFroUpbCsTh8tngSMOjFdf5zSvsIYQAhGSjFS9IL9ByxRZiGvckUykqQX/HA4D2GNokUWczhU1yF/JYQAAAADSX8lhAAAAAA==
```

Why isn't the code listening the event properly?
After reading through the Anchor discord, it seems that there's no way to query for historical state, and querying current state is difficult unless you have an account address or you want to use `getProgramAccounts`. Is there anything out there we can use for reads (given that `addEventListener` uses websockets and it commonly drops events?
Found the Anchor tests for event listeners and I seem to be doing the exact same thing (except they use the `program` variable and don't create an event manager, unfortunately even using the `program` variable doesn't work for me 😭).  Not sure why my setup isn't working. Maybe I created the `program` variable wrong in my new code? https://github.com/project-serum/anchor/blob/master/tests/events/tests/events.js#L25-L56
What is the best library method for listening to Solana events emitted with Anchor?
Does anyone know how to get event listeners on separate processes working? Wrote some code like the following in my tests:

```
  const idl = JSON.parse(
    require("fs").readFileSync("./solana-programs/rust/target/idl/nft_candy_machine.json", "utf8")
  );
  const myWallet = anchor.web3.Keypair.fromSecretKey(
    new Uint8Array(
      JSON.parse(require("fs").readFileSync(process.env.MY_WALLET, "utf8"))
    )
  );

  const connection = new anchor.web3.Connection(
    "https://api.devnet.solana.com/",
    "recent"
  );

  const programId = new anchor.web3.PublicKey(
    "<program ID>"
  );

  const walletWrapper = new anchor.Wallet(myWallet);

  const provider = new anchor.Provider(connection, walletWrapper, {
    preflightCommitment: "recent",
  });
  const program = new anchor.Program(idl, programId, provider);

  const eventManager: anchor.EventManager = new anchor.EventManager(
    programId,
    provider,
    program.coder,
  );

  eventManager.addEventListener('UserSubscriptionCreatedEvent', (event, _) => {
    console.log("Event listener called");
  });

  const subscription = await createUserSubscription(
    program,
    provider,
    showroomMetadata,
    user,
    pricingModel,
    startSubscriptionTimestamp,
    subscriptionDuration,
  );
```

And the log statement prints successfully when I run my tests. However, if I run the event listener in a separate process with the same exact code (omitted `eventManager` variable setup for simplicity), and then I run the above tests, the event listener from the separate process never logs:

```
async function runListener(): Promise<void> {
  eventManager.addEventListener('UserSubscriptionCreatedEvent', (event, _) => {
    console.log("received an event: ", event);
  });

  while (true) {
  }
}

runListener()
.then(() => {
  console.log("Finished")
})
.catch((error) => {
  console.log("Error:", error)
});
```

I'm on devnet so it's a publicly available network. I'm using the same program ID. Can anyone help?
I guess that means the only way to transfer is by directly mutating the `lamports` field on the account info.
TIL you can't transfer lamports from an account with data via the system program transfer instruction https://github.com/solana-labs/solana/blob/66fa8f966753b732facbbd66ff5b549be796ae3c/runtime/src/system_instruction_processor.rs#L190
You then just add some dummy features to your Cargo.toml: https://github.com/smartcontractkit/chainlink-solana/blob/develop/contracts/programs/access-controller/Cargo.toml#L15
Speaking of chainlink though, this is a good example of the conditional compilation approach I mentioned: https://github.com/smartcontractkit/chainlink-solana/blob/develop/contracts/programs/access-controller/src/lib.rs#L8
Not actually sure what people are supposed to do when they need to depend on a version of `program-solana`
This unfortunately doesn't work though with more recent versions of anchor, since they depend on a newer version of `solana-program` :/
I haven't used chainlink before, but I think they must have changed some package names (the old demo program still works because of its Cargo.lock file I think). I think you'll have to do
```.toml
chainlink = { git = "https://github.com/smartcontractkit/chainlink-solana", package = "flux-aggregator", features = [
    "no-entrypoint",
] }
```
Yeah, won't be able to pay for anything with your program id, but if you really wanted to sign for it you'd have to load the `target/deploy` keypair into your tests (not totally sure you want to do that though). But at the end of the day, signing for your program id would be the same as signing for any keypair address (gotta go find the private key).
respected alan,  help me with chainlink solution
Stop being rude or you're going to get banned.
damn that's a good point actually, thanks
lmao
am i actually out here getting bullied about my solana skillz by some rando online
bro, I understand the concept of PDAs
you misunderstood concept of solana structure and solana program. before programming, read documents first
What should be in `signers: [???],` to make my program sign the transaction?
I will move to <#889702325231427584> after
```
const tx = await program.rpc.initialize(
      {
        accounts: {
          payer: program.programId, 
        },
        signers: [???],
      });
```
but i mean in the javascript test
oh, it's a kind of beginner question. use PDA.
In my javascript tests, how do I make my program the signer of a transaction?
what's the matter?
```
[dependencies]
anchor-lang = "0.18.2"
anchor-spl = {version = "0.18.2"}
spl-token = {version = "3.2.0", features = ["no-entrypoint"]}
solana-program = "=1.8.0"
borsh = "0.9.1"
borsh-derive = "0.9.1"
chainlink = { git = "https://github.com/smartcontractkit/chainlink-solana", package = "chainlink-solana", features = ["no-entrypoint"] }
```
in my programs/chainlink-pro/cargo.toml file
hello, i am having trouble with solana chainlink
i successfully built solana-chainlink-demo project on github
and i did the same in anchor project
when i run anchor build, error occurs
```Failed to obtain package metadata: Error during execution of `cargo metadata`:     Updating git repository `https://github.com/smartcontractkit/chainlink-solana`
error: no matching package named `chainlink-solana` found
location searched: https://github.com/smartcontractkit/chainlink-solana```
help me
so i'll do that
Hmm ok, sounds like the first solution you said is the most simple & straightforward
Or scrap the dynamic approach and just use conditional compilation 😛
But yeah in general you just need to check that the signer's address is some address you're ok with
I will do the first thing you said then. Thank you!!
ah gotcha
You can figure out the upgrade authority for the program, but it's more involved than that
like in the context, have `pub program: Program`

And in the instruction, do `if signer.key() != program.owner { throw Error() } `
What do you mean by owner here?
It's also possible to figure out the upgrade authority dynamically, by loading your program's account (can search the discord) but that's more involved
Also could I pass in a `Program` object and check its owner?
But in general you'd just have to check that the Signer has the right address
You could also hardcode the address of the upgrade authority (I can't remember which address that is when you do a normal anchor deploy)
One way would be to require the signer to be the program's own program_id (presumably only the owner of the program has access to that keypair)
any idea <@!134416332509675520> ? 🤔
Question: How can I check if the `Signer` of the program is the owner of it?
That probably made no sense, but basically the idea is to create a new Account struct that stores the mint you want. Only the program owner can add the mint. That's how you gate people from putting in any mint.
I want run some standard validation checks on every anchor call. 
the authority in the program must match the caller/signer
accounts must match recorded accounts in program
am I supposed to use constraints or call the same checks in each call?
i dont see something like entry point where i can gate and validate in 1 location?
how best to do this?
Ok I think this is a way around it:
1. Create a new account struct that stores the mint... So like `pub struct ProgramMint { ... }`. 
2. Create an instruction that allows the program owner to instantiate a new `ProgramMint` with whatever mint they want. 
3. In your other instruction, check that the user passes in `ProgramMint`
hmm I wonder how all the protocols limit their services to just one type of token
Haven't tried doing this with anchor though
I think it would probably be easier to use conditional compilation https://doc.rust-lang.org/cargo/reference/features.html (don't think solana exposes the cluster at runtime)
I think I found a way around this, but it depends on this question:

Is there a way to check if we're in devnet or mainnet from the smart contract itself?
ahhh gotcha
I feel like it would be easier to just use a fake usdc mint/address in development, and then use the real one in production (not 100% sure the easiest way to do that logistically though, so might be wrong it's the easiest way)
I don't think you can do that, at least not manually like that (creating an account requires signing for its address, and you presumably can't sign for the usdc mint's real address). You could clone the account from mainnet though
(reasoning: I want to create a replica of USDT mint to make sure my program checks if mint has `address = USDT`)
`createMint` doesn't seem to let me do that
How do I create a mint at a certain address using the `spl-token` anchor library?
gotcha, that makes sense. Life saver!
I actually prefer the approach you have there (there's no point using an associated token address if you already have a natural address to use)
I feel like the cleanest version is to just store the vault at the associated token address though. Is it not normal for programs to store tokens at their own associated token addresses?
```
#[account(
        init, 
        payer = payer,
        seeds = [stablecoin_mint.key().as_ref()],
        bump = mint_bump,
        token::mint = stablecoin_mint,
        token::authority = vault,
)]
  pub vault: Account<'info, TokenAccount>,
```
Gotcha, so something like this?
Then you can pull the same trick and have the vault (which will now live at one of your own program's PDAs) be its own authority, just like for the mint.
One alternative is to not store the vault at an associated token address, but rather at another PDA derived from your own program (so use `token::mint` and `token::authority` rather than associated_token:: etc.
The authority here just needs to be any address derived from your program (so, yeah, the mint would work but looks a little odd).
I could do `associated_token::authority = mint`, where `mint` is owned by the program, but that feels wrong
I just wanna do `associated_token::authority = id()` but I can't because it's not an `AccountInfo` object
```
#[account(
        init, 
        payer = payer,
        associated_token::mint = usdt_mint,
        associated_token::authority = ???,
    )]
    pub vault: Account<'info, TokenAccount>,
```
yeah but im not sure how to set `associated_token::authority` to the program here
All good, approach b) worked 🙂
yeah i did that but `associated_token::mint` expects AccountInfo, and a module or ID != AccountInfo
from anchor try something like this https://github.com/project-serum/anchor/blob/master/spl/src/mint.rs
So I used approach b), which worked
`associated_token::mint = usdt::ID,`

Doesn't seem to work... I think it is expecting `AccountInfo`
oo i will try to make c) work, thanks 🙂
2) I think jet protocol's jet-v1 program has a concise and easy to read example of how to use the PDA pattern you're describing. You can use the pattern in more granular ways instead of 1 PDA auth for whole program, but just giving an example: https://github.com/jet-lab/jet-v1/blob/master/programs/jet/src/instructions/init_market.rs
1. a) pass mint pubkey as arg to rpc handler, b) pass in mint account in accounts struct if you need it to read or write then grab pubkey for constraints, c) if it's a small preknown set of mint keys, then you could include them directly in the program similar to how you include your program key with declare_id.
```
#[account(
        init, 
        payer = payer, 
        associated_token::mint = ???, 
        associated_token::authority = ???, 
)]
    pub vault: Account<'info, TokenAccount>,
```
- How do I set `associated_token::mint` equal to a specific ID (e.g. USDT)?
- How do I set `associated_token::authority` to the program itself? Do I need to use a PDA and pass in seeds and bump?
yeah, the TokenAccount was created with `authority = mint`
I'm not sure how token account was created, but if you assigned a pda that prog signs for program as the authority for token account during creation, then that pda is who should be used for constraint here
`mint` is located at a program PDA, and `authority = mint`, so authority is the program ? I think ?
The authority should be the program itself
Should the authority be the user who owns the vault token account? Assuming yes, something like this should work `token::mint = mint, token::authority == user_signer`. so we confirm mint pubkey on vault TokenAccount is same as mint account passed in, and the authority on vault TokenAccount is same as user pubkey who is passed in as a signer account.
```
#[account(  
    mut,
    seeds = [STABLECOIN.as_bytes()],  
    bump = mint_bump,
)]
    pub mint: Account<'info, Mint>, 

#[account(
    mut,
    associated_token::mint = mint, 
    associated_token::authority = mint
)]
    pub vault: Account<'info, TokenAccount>,
```

Is this enough to make sure that `mint` and `vault` are owned by our program?
I actually don't know lol, I've also been meaning to read the program more carefully 😅
That would be awesome, it basically sets transfer authority to a PDA right?


///////////////////////////////////////////////////////////////////////////////////////////////

<@!501570363566587905> is there any nice way to handle complex types like that in the IDL? Not sure what zknark's options are
My guesses are that Solana can't handle `i8` or it can't handle `ark_bn254::Fr`
```
/// The Poseidon permutation.
#[derive(Clone, Copy)]
pub struct FixedPoseidonBN254Parameters {
    /// The round key constants
    pub round_keys: [ark_bn254::Fr; 195],
    /// The MDS matrix to apply in the mix layer.
    pub mds_matrix: [[ark_bn254::Fr; 3]; 3],
    /// Number of full SBox rounds
    pub full_rounds: u8,
    /// Number of partial rounds
    pub partial_rounds: u8,
    /// The size of the permutation, in field elements.
    pub width: u8,
    /// The S-box to apply in the sub words layer.
    pub sbox: PoseidonSbox,
}

/// An S-Box that can be used with Poseidon.
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub struct PoseidonSbox(pub i8);
```
```
IdlError: Type not found: {"name":"params","type":{"defined":"FixedPoseidonBN254Parameters"}}
```
Still stuck on this error, anyone have ideas for debugging?
fuck <a:partydead:857358222095548467>
70 sol 😛
what will be the rent for 10mb account?
thanks 😄
The absolute max account size is 10mb = 10 * 2^20 bytes, and each pubkey is 32 = 2^5 bytes, so absolute max would be roughly 10 * 2^15 = 320 thousand
what are the maximum number of addresses which can be stored in a data account? (as vector)
thanks for guidence
thats great
Yes, that'll work fine (anchor is still just rust/solana)
i was just asking that 
if use solana dex as a cross program invocation in my own anchor program
will that work
Anchor is still rust, so not sure what you're asking 🤔
can anyone guide me into this
thanks will take a look
so like there are some solana contract like metaplex or dex codes in rust 
so if i have to integrate them with my anchor programe then i need to convert them to anchor or use rust else???
Take a look at how anchor_spl's `token` module works—you just invoke the spl token program the usual way, with `invoke_signed`
https://docs.rs/anchor-spl/latest/anchor_spl/index.html
i also have a noob question 
all the programs are in the rust in solana program github even slp token 
so how can i integrate that token with anchor do i need to change that code from rust to anchor or what is the optimal way
i think i understood from reading the CPI docs - appears to be 3 different seed used for PDA calls
rust noob question: under what circumstance would the 3 unused lifetime variables used? I see they are all referring to the slice of slice of slice of signer seeds... am I understanding that correctly? lol
In this case that's not the issue, since they get an error message about a signer privilege escalation (you're right though that you can get that error for a writable escalation, but you'll see that in the logs)
this usually happens for me when I forget to set an account as “mut” in the Context struct
Cool thanks
You can also look at logs in .anchor folder and you want to use msg!
I was putting solana-test-validator -r --log
never mind, you need 'solana logs' in another console
this is maybe more of a solana question, but I remember when I used solana-test-validator a couple months ago, the -log wasn't as messy as it is right now, is it possible to have a more easy to read log ?
noice thanks for the tip
Yeah, you were accidentally doing `[undefined, undefined] = ...` which doesn't work 😛
Thanks it worked, it's weird because they were declared as let before. Just deleted the first declaration, might need to change it a little bit if I need it for another test, but thank u very much
Yes, even then. The Solana runtime will prevent you from making any unathorized actions
Even if the winner account is a user account? I mean for example if you logged in with your account, and we paid some winnings to you, can we make your account mutable?
You're likely not signing correctly there
I can't seem to find that code, have you already posted it?
in the first instruction, transfer token from user to vault
Yeah if these variables don't exist before hand this will not work
Do `const [foo, bar] =`

line 84 is findProgramAddress
Where are you actually doing the transfer?
yeah it's the `vesting_info` account
but maybe I'm wrong. Where is line 84?
Not sure the destructuring syntax in right at the end
right
Ok, so `FFkmnSAYJQx4kf7rKodZw3U4u1BrXWYz8MBQUcFrKrwN's signer privilege escalated`
```
Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account
Program 4ZG7137ijWRxizX1W5dX4RGr9B6BJwC4CTsUAAXgQGJx invoke [1]
Program 11111111111111111111111111111111 invoke [2]
Program 11111111111111111111111111111111 success
Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [2]
Program log: Instruction: Transfer
Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 3121 of 163513 compute units
Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success
Program 65jfBQVzdjBiAPDd2gDAarqiZjzfQnHuMWY4NSKpK1hW invoke [2]
FFkmnSAYJQx4kf7rKodZw3U4u1BrXWYz8MBQUcFrKrwN's signer privilege escalated
Program 65jfBQVzdjBiAPDd2gDAarqiZjzfQnHuMWY4NSKpK1hW consumed 152236 of 152236 compute units
Program 65jfBQVzdjBiAPDd2gDAarqiZjzfQnHuMWY4NSKpK1hW failed: Cross-program invocation with unauthorized signer or writable account
Program 4ZG7137ijWRxizX1W5dX4RGr9B6BJwC4CTsUAAXgQGJx consumed 200000 of 200000 compute units
Program 4ZG7137ijWRxizX1W5dX4RGr9B6BJwC4CTsUAAXgQGJx failed: Cross-program invocation with unauthorized signer or writable account
Translating error SendTransactionError: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account
at Connection.sendEncodedTransaction 
 {
logs: [
'Program 4ZG7137ijWRxizX1W5dX4RGr9B6BJwC4CTsUAAXgQGJx invoke [1]',
'Program 11111111111111111111111111111111 invoke [2]',
'Program 11111111111111111111111111111111 success',
'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [2]',
'Program log: Instruction: Transfer',
'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 3121 of 163513 compute units',
'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success',
'Program 65jfBQVzdjBiAPDd2gDAarqiZjzfQnHuMWY4NSKpK1hW invoke [2]',
"FFkmnSAYJQx4kf7rKodZw3U4u1BrXWYz8MBQUcFrKrwN's signer privilege escalated",
'Program 65jfBQVzdjBiAPDd2gDAarqiZjzfQnHuMWY4NSKpK1hW consumed 152236 of 152236 compute units',
'Program 65jfBQVzdjBiAPDd2gDAarqiZjzfQnHuMWY4NSKpK1hW failed: Cross-program invocation with unauthorized signer or writable account',
'Program 4ZG7137ijWRxizX1W5dX4RGr9B6BJwC4CTsUAAXgQGJx consumed 200000 of 200000 compute units',
'Program 4ZG7137ijWRxizX1W5dX4RGr9B6BJwC4CTsUAAXgQGJx failed: Cross-program invocation with unauthorized signer or writable account'
]
}
```
do you have any idea why this isn't working ?
sure one sec
Can you post the full program log too?
actually I am not sure what should be the account attributes in the first instruction, I just make it as mut. is it correct?
`#[account(mut)]
    pub vesting_info: AccountInfo<'info>,`
the `vesting_info` in the first instruction is initialized as pda in the second instruciton
```
#[derive(Accounts)]
#[instruction(vault_account_bump: u8, presale_account_bump: u8)]
pub struct DepositPrivateSale<'info> {
    #[account(mut)]
    pub user: Signer<'info>,
    #[account(constraint = presale_account.fund_token == fund_mint.key())]
    pub fund_mint: Account<'info, Mint>,
    #[account(constraint = presale_account.reward_token == reward_mint.key())]
    pub reward_mint: Account<'info, Mint>,
    #[account(
        mut,
        constraint = depositor_fund_token_account.mint == presale_account.fund_token
    )]
    pub depositor_fund_token_account: Account<'info, TokenAccount>,
    #[account(
        mut,
        seeds = [presale_account.reward_token.as_ref(), FUND_VAULT_SEED.as_ref()],
        bump = vault_account_bump,
    )]
    pub vault_account: Box<Account<'info, TokenAccount>>,
    #[account(
        mut,
        seeds = [presale_account.reward_token.as_ref(), PRESALE_ACCOUNT_SEED.as_ref()],
        bump = presale_account_bump,
        constraint = presale_account.is_private_sale_over == false,
        constraint = presale_account.private_sale_start_time <= clock.unix_timestamp,
    )]
    pub presale_account: Box<Account<'info, PresaleAccount>>,
    #[account(
        init_if_needed,
        seeds = [reward_mint.key().as_ref(), user.key().as_ref(), RECIPIENT_INFO_SEED.as_ref()],
        bump,
        payer = user
    )]
    pub recipient_info: Box<Account<'info, RecipientInfo>>,

    #[account(owner = presale_account.whitelist_program)]
    pub whitelist: Account<'info, Whitelist>,
    #[account(mut)]
    pub vesting_account: Box<Account<'info, VestingAccount>>,
    #[account(mut)]
    pub vesting_info: AccountInfo<'info>,
    pub vesting_program: AccountInfo<'info>,
    pub token_program: AccountInfo<'info>,
    pub system_program: AccountInfo<'info>,
    pub clock: Sysvar<'info, Clock>,
}
```

```
#[derive(Accounts)]
#[instruction(vesting_account_bump: u8, amount: u64)]
pub struct UpdateRecipient<'info> {
    #[account(
        mut,
        constraint = *authority.key == vesting_account.authority,
    )]
    pub authority: Signer<'info>,
    #[account(mut)]
    pub payer: Signer<'info>,
    #[account(
        mut,
        seeds = [vesting_account.mint.as_ref(), b"vesting-seed".as_ref()],
        bump = vesting_account_bump,
        constraint = vesting_account.start_time == 0 || vesting_account.start_time >= clock.unix_timestamp as u64,
        constraint = amount > 0
    )]
    pub vesting_account: Box<Account<'info, VestingAccount>>,
    #[account(
        init_if_needed,
        seeds = [vesting_account.mint.as_ref(), payer.key.as_ref(), b"vesting-info".as_ref()],
        bump,
        payer = payer
    )]
    pub vesting_info: Account<'info, RecipientInfo>,
    pub system_program: AccountInfo<'info>,
    pub clock: Sysvar<'info, Clock>,
}
```
Sure!
can i share the code?
well actually i tried it and it says signer privilege escalated
Yep
I would have two programs, one program does cpi to the another program instruction which inits a pda. the payer of this pda is the signer of the first program. is this possible?
thx guys! 🙂
sry for asking so quickly, the classic "you ask it, you immediately find it"
That works too
or `.as_ref()`
Yeah, just an annoying rust type inference issue, do `b"bondPoolAccount".as_ref()`
changing it to 
``` 
&[[
                &b"bondPoolAccount"[..],
                &[ctx.accounts.bond_pool_account.bump_bond_pool_account]
            ].as_ref()]
``` did the trick
Cool thanks
getting typ mismatches
``` 
error[E0308]: mismatched types
   --> programs/solbond/src/instructions/purchase_bond.rs:123:17
    |
123 |                 &[ctx.accounts.bond_pool_account.bump_bond_pool_account]
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected an array with a fixed size of 15 elements, found one with 1 element
    |
    = note:   expected type `&[u8; 15]`
            found reference `&[u8; 1]`

For more information about this error, try `rustc --explain E0308`.
warning: `solbond` (lib) generated 18 warnings
error: could not compile `solbond` due to previous error; 18 warnings emitted
```
I had this 
```
CpiContext::new_with_signer(
            cpi_program,
            cpi_accounts,
            &[[
                ctx.accounts.bond_pool_account.generator.key().as_ref(), b"bondPoolAccount",
                &[ctx.accounts.bond_pool_account.bump_bond_pool_account]
            ].as_ref()],
        ),
``` 
in the CPI invocation call, but removing the generator account (like so)
``` 
CpiContext::new_with_signer(
            cpi_program,
            cpi_accounts,
            &[[
                b"bondPoolAccount",
                &[ctx.accounts.bond_pool_account.bump_bond_pool_account]
            ].as_ref()],
        ),
``` 
rust doesnt compile it any longer
is it possible to have a PDA seed that does not contain another public key, but consists of a string only?
Yes, the winner account needs to be mutable, because you are changing the balance of lamports
Hey guys I am using the following struct, to pay lamports from an account controlled by the program to an external account. 
```
#[derive(Accounts)]
pub struct WinnerToPay<'info>{
    #[account(mut)]
    pub base_account: Account<'info, BaseAccount>,
    #[account()]
    pub winner: AccountInfo<'info>,
    pub system_program: Program<'info, System>,
    pub owner: Signer<'info>
}```
with this function. 
```
let from = base_account.to_account_info(); 
let to = ctx.accounts.winner.to_account_info();
**from.try_borrow_mut_lamports()? -= amount as u64;
**to.try_borrow_mut_lamports()? += amount as u64;
```
Do I need to set the winner account to be mut? I get an error saying I am trying to change the balance of a read only account?
Look through any of the metaplex code like candy machine, token metadata, auction house, token entangler, fair launch, serum's dex stuff, etc

https://github.com/metaplex-foundation/metaplex

https://github.com/project-serum/serum-dex
GM! Does anyone know of a repository or some example code that does a cpi call to a program deployed on devnet or mainnet? Something beyond the anchor tutorial 🙂
Quick PR. If anybody has a suggestion on how to write a test lmk https://github.com/project-serum/anchor/pull/1199
Gotcha, thanks
I think it was just simple/didn't seem like too bad of an idea to get started with (they're changing it soon though): https://jstarry.notion.site/Transaction-Fees-f09387e6a8d84287aa16a34ecb58e239#67aeb39d8b2540019cb37792c6a2cd32
Is there some sort of reasoning behind the fairly small stack size/compute budget when you can circumvent it pretty easily with multiple ixs then? Just curious, thanks for any help
Oh okay cool! I thought my understanding might be off, thanks
you start with a fresh stack for each instruction
no
More of a tangential question than a thought that directly followed, my bad

I just mean if you're calling multiple instructions within a single transaction you can circumvent the compute budget, but not the stack size, because the stack size for the overarching transaction remains the same regardless of whether or not you're splitting up 1 big ix to multiple ixs, right? because you still have to load all accounts involved in any instruction within the transaction to ensure atomicity (..right?)
the consideration is more, how safe it is to split, can the logic do that? each instruction need to be valid on its own
Yeah, you can definitely split things up into multiple instructions (as you say, they all run together all-or-nothing in one transaction). Not sure what you mean about stack size considerations?
Are there any pitfalls to splitting up a single, large instruction into a single transaction with multiple, smaller ixs?

I'm assuming the runtime ensures atomicity from beginning to end regardless of 1 instruction or multiple...meaning the runtime does some sort of deep search of all instructions (and ixs within those ixs) within a single transaction to include all loaded accounts, effectively making this a non-viable solution for exceeding the stack size- but useful for circumventing the compute budget. 

Is my understanding correct?
Oh that's great news. thanks again alan
where the feature flag is used in the smart contract crate to control the codegen
Can do something like this https://github.com/project-serum/anchor/pull/446/files
are there examples of anchor using feature flag before
ah ok sounds good! will try to find time to add
https://github.com/project-serum/anchor/issues/1198
(so that you're not stuck)
Yes. We can add a feature flag to use `repr(packed)` though.
Does this mean if you already have a program on mainnet using zero copy you're stuck at anchor 0.19.2 🤔 
https://github.com/project-serum/anchor/pull/1106
Actually you can just send the sol to the pre-existing wrapped sol account (you annoyingly also have to use the SyncNative instruction though to update the wrapped token balance): https://github.com/solana-labs/solana-program-library/blob/master/token/program/src/instruction.rs#L375
Yeah that was my guess, kind of annoying workflow. Check if they have wsol, if not convert, etc.
I would guess that you need to convert to wSOL because it's still a completely different token.
Or can I send sol directly to a pda wsol token account?
If I want users to send sol to a pda token account, using wsol, do I need to convert the users sol to wsol and then do an spl transfer?
Instead of just limiting it to USDT. I want to program owner to be able to pass in a mint (e.g. USDT, USDC) and create the market
Thanks alan, that looks like a good solution. I realized that, for what I'm building, I actually want to just make a certain instruction callable only by the program *owner*
I think I'll go that way. Thanks for the help!


///////////////////////////////////////////////////////////////////////////////////////////////

how to do partialSign in anchor??
Hi everyone . I'm so glad to be here. I have a question, I'm writing NFT staking pool. But I need more resources to write. can someone help me?
hey guys, any idea why this error could occur?
``` 
Error: failed to get info about account 5qZJFsJQKjqqNakFurVMuGnMGDGwCMBBKcckDCuezPjd: TypeError: Network request failed
``` 

I am getting this in nextjs only (devnet), when i run this script normally it seems to work, and when I check the solana explorer there is data there. 

this is the code snippet I am running
``` 
        let bondPoolAccount = (await this.program.account.bondPoolAccount.fetch(this.poolAccount)) as BondPoolAccount;
```
Can someone please help me with this issue: https://github.com/project-serum/anchor/issues/1205
ok yea, at first I tried just wrapping that one large Account in Box and it seemed not to make a difference. But then I wrapped _all_ of the accounts (`Box<Account<'info, Token>>`) and the warning went away. weird.
I assume it's because I'm passing my program's state account which has data that is quite large, but I didn't expect that to have an effect on the instruction.. Not sure why it would
Search says to try using `Box` , will check that out in the morning.
```Error: Function _ZN11anchor_test9__private8__global10claim_hunt17h34c04369de733f73E Stack offset of -10024 exceeded max offset of -4096 by 5928 bytes, please minimize large stack variables
```
Ooph. My largest instruction passes 20 Accounts which I thought was fine (had read that you can pass ~30), but it seems I'm waaay over the limit somehow
I think I will just operate under ensuring nothing can be broken on the program's side, but if a user does decide to mess with things I won't protect them from screwing themselves over <:PES_HahaDead:585724566824026132>
Ah, yes, that would be quite nice
Strictly speaking there's also this https://docs.solana.com/implemented-proposals/instruction_introspection, but eh, probably hard to enforce invariants that way
That's my understanding, yeah
Right, so there's no way to ensure that things happen in a certain order without just making really really long instructions or preparing for it with a bunch of contingencies?
In general yeah, you have to assume adversarial clients—they could send the individual instructions in whatever way they want
is there any way I can ensure multiple instructions run in sequence other than bundling them together in a transaction client-side? 

That is mostly reliable, but in the case a user decides to grab the client code and alter it to create an impartial transaction for themselves, do I need to make sure there's no way the program can enter an unrecoverable state in between instructions
gotcha makes sense! thanks <@!134416332509675520>
Anchor does it automatically via the IDL (e.g. `await program.account.someAccountType.fetch(theAddress)` does the borsh stuff automaticaly)
Usually the program you're interacting with will (hopefully) have an sdk or something to do this for you
is there anyway to decode the data type though without building the borsh schema? it would be nice to be able to read the data without having to translate rust structs to borsh schemas in TS to decode the data from contracts you want to interact with
awesome, thanks <@!234110037629468672> . ended up looking into the solana-programs accounts and finding a borsh TS schema I could use to decode the data type I was looking for
It's not separate from anchor really, it just does it for you. You can look thru the anchor code or expand macros if you're curious how anchor does it although this is probably more complicated than just looking for a tutorial on deserializing data in solana accounts
does anyone know how to decode data in an account? this is separate from anchor, but when I pull an account from solana I notice it is just a buffer of data and I am unsure of how to decode it into something readable in my typescript code
Want to test sending SOL between two different users
Anyone know how to make multiple test accounts on Anchor.js for testing?
Yes. I needed to make my program backwards compatible. But found out it was added to the end of the account struct:
```rs
pub struct WrappedToken {
    #[doc = " Number of decimals of the wrapped token."]
    pub decimals: u8,
    #[doc = " Amount to multiply by to wrap the token."]
    #[doc =
      " Cached here for performance reasons, but equivalent to 10 **decimals"]
    pub multiplier: u64,
    #[doc = " Mint of the underlying token."]
    pub wrapper_underlying_mint: Pubkey,
    #[doc = " Program token account holding the underlying token."]
    pub wrapper_underlying_tokens: Pubkey,
    #[doc = " Mint of the token of this wrapper."]
    pub wrapper_mint: Pubkey,
    pub(crate) __nonce: u8,
}
```
anyone can help regarding this??
And removed in 0.14.0 https://github.com/project-serum/anchor/blob/master/CHANGELOG.md#breaking-changes-2
That was added in 0.4.3 https://github.com/project-serum/anchor/blob/master/CHANGELOG.md#043---2021-04-13
Hi I am getting this error when i run anchor test. Anyone know about this problem. this error is showing for every function call.
nvm. Sorry for the ping. Good old cargo expand helped me out.
`ConstraintMut: 140` - means that i declare account as non mutable, but it should be mutable?
Hi , I am trying to find keypair by using publicKey in JS/TS. can anybody help?
<https://github.com/project-serum/anchor/blob/ec6888a3b9f702bc41bd3266e7dd70116df3549c/lang/attribute/account/src/lib.rs#L237>
Hey <@!501570363566587905>. In anchor 0.12.0, did this `__nonce` field get added to the end of the struct or start of the struct?
https://github.com/project-serum/anchor/blob/ec6888a3b9f702bc41bd3266e7dd70116df3549c/lang/attribute/account/src/lib.rs#L220-L221
Maybe I'd get farther if I was able to add consts of the `ark_bn254::Fr`
Should I just try building this app without Anchor framework?
<@!134416332509675520> so since Anchor can't parse these types and seems I'm pretty compute limited
I just need them as that dang struct
granted I don't *need* to do modulo reduction since I know these elements are in the field
But yeah, wouldn't surprise me a ton if you just don't have enough compute for tricky cryptographic stuff 😬
I need to take these constants and convert them into `ark_bn254::Fr` on the fly.. let me check if I can do an unsafe encoding instead of modulo order
Ok think I'd need to see a github repo to really understand
```
impl CircomPoseidonHasher {
    pub fn hash(input: &[u8]) -> Result<Vec<u8>, Error> {
        msg!("Hashing...");
        let round_consts = BN254_X5_3_ROUND_CONSTS.iter().map(|x| {
            msg!("Round const: {:?}", x);
            ark_bn254::Fr::from_be_bytes_mod_order(x)
        }).collect::<Vec<_>>();
        let mds_matrix = BN254_X5_3_MDS_MATRIX
            .iter()
            .map(|x| x.iter().map(|y| ark_bn254::Fr::from_be_bytes_mod_order(y)).collect())
            .collect::<Vec<Vec<ark_bn254::Fr>>>();
        let params = PoseidonParameters::<ark_bn254::Fr>::new(
            round_consts,
            mds_matrix,
            FULL_ROUNDS,
            PARTIAL_ROUNDS,
            WIDTH,
            SBOX
        );
        let output: ark_bn254::Fr = <CRH<ark_bn254::Fr> as CRHTrait>::evaluate(&params, input)?;
        let value = output.into_repr().to_bytes_le();
        Ok(value)
    }
}
```
```
    'Program log: Hashing...',
    'Program log: Round const: [14, 233, 165, 146, 186, 154, 149, 24, 208, 89, 134, 214, 86, 244, 12, 33, 20, 196, 153, 60, 17, 187, 41, 147, 141, 33, 212, 115, 4, 205, 142, 110]',
    'Program log: Round const: [0, 241, 68, 82, 53, 242, 20, 140, 89, 134, 88, 113, 105, 252, 27, 205, 136, 123, 8, 212, 208, 8, 104, 223, 86, 150, 255, 244, 9, 86, 232, 100]',
    'Program log: Round const: [8, 223, 243, 72, 126, 138, 201, 158, 31, 41, 160, 88, 208, 250, 128, 185, 48, 199, 40, 115, 11, 122, 179, 108, 232, 121, 243, 137, 14, 207, 115, 245]',
    'Program log: Round const: [47, 39, 190, 105, 15, 218, 238, 70, 195, 206, 40, 247, 83, 43, 19, 200, 86, 195, 83, 66, 200, 75, 218, 110, 32, 150, 99, 16, 250, 220, 1, 208]',
    'Program log: Round const: [43, 42, 225, 172, 246, 139, 123, 141, 36, 22, 190, 191, 61, 79, 98, 52, 183, 99, 254, 4, 184, 4, 62, 228, 139, 131, 39, 190, 188, 161, 108, 242]',
    'Program log: Round const: [3, 25, 208, 98, 7, 43, 239, 126, 204, 165, 234, 192, 111, 151, 212, 213, 89, 82, 193, 117, 171, 107, 3, 234, 230, 75, 68, 199, 219, 241, 28, 250]',
    'Program log: Round const: [40, 129, 61, 202, 235, 174, 170, 130, 138, 55, 109, 248, 122, 244, 166, 59, 200, 183, 191, 39, 173, 73, 198, 41, 142, 247, 179, 135, 191, 40, 82, 109]',
    'Program log: Round const: [39, 39, 103, 59, 44, 203, 201, 3, 241, 129, 191, 56, 225, 193, 212, 13, 32, 51, 134, 82, 0, 195, 82, 188, 21, 9, 40, 173, 221, 249, 203, 120]',
    'Program log: Round const: [35, 78, 196, 92, 162, 119, 39, 194, 231, 74, 189, 43, 42, 20, 148, 205, 110, 251, 212, 62, 52, 5, 135, 214, 184, 251, 158, 49, 230, 92, 198, 50]',
    'Program Dw96F8NjN84googpni4mtSnCuAud9XkaPUFM1RJX53cK consumed 200000 of 200000 compute units',
```
I thought it was fixed
But why are you doing any compute at all?
I hit a compute limit at about the 11th element
You won't be able to use that `ark_bn254::Fr` type in an account as far as I know, not with anchor's IDL generation :/
Where did you hit a compute limit? I'm saying don't store that thing in an account at all, just in your program text
<@!134416332509675520> basically Anchor keeps complaining about `ark_bn254::Fr` if i put this in an account
I can try to expose `const fn`?
because I need to parse these constants into field elements (big endian module prime for 195 elements)
ugh I hit a compute limit
Yeah and just stick the value in there, `const THING: [[u8; 32]; 195] = ....;`
or do I need `static const`
ok, so just `const THING: [[u8; 32]: 195]`?
Storing it an a static array is fine since no stack size stuff to worry about
Why store it in an account?
Ah, can you just make it a static/const array in your source code?
yes
Like, it never changes?
Is that actually constant?
ah ok let me try
```
pub fn get_round_consts() -> [[u8; 32]; 195] {
    [
        [14, 233, 165, 146, 186, 154, 149, 24, 208, 89, 134, 214, 86, 244, 12, 33, 20, 196, 153, 60, 17, 187, 41, 147, 141, 33, 212, 115, 4, 205, 142, 110],
         ...
    ]
]
```
So, just directly mutate the `params.round_consts` array, rather than reassigning it (I'm a little fuzzy here tbh on stack implications)
wdym?
Can you just inline that logic?
That `round_consts` is already too big for the stack, so don't think you can just bundle it up into a helper function like that
so I ought to do this in stages?
initializing this struct
The solana stack frame is quite small, only 4kb
```
#[zero_copy]
pub struct HashParams {
    initialized: bool,
    round_consts: [[u8; 32]; 195],
    mds_matrix: [[[u8; 32]; 3]; 3]
}
```
Do those `get_` functions return something big?
Ah cool ok
Running out of stack space (I'm surprsied you didn't see that warning before, interesting)
It fails before "starting intialization"
```
    pub fn setup_params(ctx: Context<HashInitialize>) -> ProgramResult {
        msg!("HashInitialize");
        let mut merkle_tree_account = ctx.accounts.merkle_tree_account.load_mut()?;
        msg!("Starting initialization");
        merkle_tree_account.params.round_consts = get_round_consts();
        msg!("Initialized round consts");
        merkle_tree_account.params.mds_matrix = get_mds_matrix();
        msg!("Initialized mds matrix");
        merkle_tree_account.params.initialized = true;
        Ok(())
    }
```
Now I get
```
    'Program failed to complete: Access violation in stack frame 5 at address 0x2000057b0 of size 8 by instruction #12970',
```
Ok moved it over to raw bytes
Currently yes, though I imagine if that happens then they'll change the rental rate lol
https://tenor.com/view/anxiety-gif-18811591
so if solana hits $1000, devs have to pay more account fees
yeah. that makes sense
Yeah easiest takeaway is 7 sol / megabyte, or roughly $2/kilobyte
gotcha. thanks 😄
Basically, ~3500 lamports / (byte year), so 2 years of rent is 7 * 10^3 lamports / byte, and 1 lamport = 10^-9 sol... so! 7 * 10^-6 sol / byte
https://tenor.com/view/confused-no-nope-gif-13134027
https://github.com/solana-labs/solana/blob/master/sdk/program/src/rent.rs#L23 (and then rent-exemption multiplies by 2)
(i lost that sheet) <:mortydumb:908904337361743882>
do you have the sheet for rent calculation?
It's just bytes in storage at the end of the day
Well, you have to deserialize it no matter what
But we can try this
Hmm, we were running into compute exhaustion when serializing it is why we avoided such a route
The nuclear option would be to declare that field as raw bytes, and handle deserializing it into a FixedPoseidonBN254Parameters struct within your program (does the client ever need to interact with it? presumably no)
```
impl PoseidonSbox {
    pub fn apply_sbox<F: PrimeField>(&self, elem: F) -> Result<F, PoseidonError> {
            ...
        Ok(res)
    }
}
```
There's generics deeper in struct impls that's probably throwing this off
Hmm ok, and how does one just turn this stuff off?
It's not solana itself having a problem here actually, just anchor's IDL stuff


///////////////////////////////////////////////////////////////////////////////////////////////

Ok so I am pretty confused about this concept of transferring lamports from an account owned by the program. I've tried to follow some examples on the solana github. and I have got this code. 
```
let from = base_account.to_account_info(); //base_account.to_account_infos();//.to_account_info();
            let to = ctx.accounts.winner.to_account_info();
            **from.try_borrow_lamports()? -= amount;
            **to.try_borrow_lamports()? += amount;
```
On the try_borrow_lamports lines it get the following error. 
```
cannot assign to data in a dereference of `std::cell::Ref<'_, &mut u64>`

cannot assign

help: trait `DerefMut` is required to modify through a dereference, but it is not implemented for `std::cell::Ref<'_, &mut u64>`rustc(E0594)
```
look just three messages above!
(both of them written in achor, just not in the same repo)
how would I go about testing an anchor program that relies on another program, in a different repo?

is there a way to still use `anchor test`?
this is pretty handy. did not know this
If you add your external crate as a named dependency you should be able to import whatever you want from it
<https://github.com/project-serum/anchor/blob/master/spl/Cargo.toml>
Check out how the anchor spl crate does this when importing Solana program and serum dex
So you may need to point to this crate at a higher level
Hey does anyone know if there's a way to import account structs from external crates?

E.g. 
In the crate:
```
#[derive(Accounts, Clone)]
pub struct MarketAccounts<'info> { ... }
```
Importing this into a separate workspace:
```
use crate::myclient::context::MarketAccounts;
#[derive(Accounts)]
pub struct PlaceOrder<'info> { 
  pub market_accounts: MarketAccounts<'info>
}
```

The `Accounts` deserializer always seems to complain (error below). However when I copy paste the struct definition (e.g. no importing), it works fine. Any ideas?
```
unresolved import `__client_accounts_market_accounts`
use of undeclared crate or module `__client_accounts_market_accounts`
```
Just wondering, once you initiate and account, the size and the variables are pretty much locked right? If I had two u8 variables, I woulnd't be able to add a third later on without creating a whole new account?
Thank you, I figured out what I was trying to do haha
Yes it is, thanks for the pointer i'll dig into ```try_borrow_mut_lamports```
Sounds like it is, given that it's storing data in addition to lamports. That means you can't use the system program to transfer the lamports (that only works for accounts owned by the system program!). You'll have to manually decrement the lamports yourself (try searching for `try_borrow_mut_lamports`)
Is the base account program owned by your own program? (Is it an `#[account]` over a struct?)
No @s please, just ask your questions and someone will answer
Hello guys
I am writing test using anchor framework.
I need to use multiple wallets(signers) on tests and how can I do that?
All transactions are signed by provider.wallet.
This is the code i have so far. 
``` 
let ix = anchor_lang::solana_program::system_instruction::transfer(&base_account.key(), &ctx.accounts.winner.key(), amount as u64);

anchor_lang::solana_program::program::invoke(&ix, &[
                base_account.to_account_info(),
                ctx.accounts.winner.to_account_info(),
            ]).unwrap(); 
```
Hey guys I have an account which is acting as Base Account for my program to store data and lamports. I am now trying to transfer out some lamports to a user, but get a signing error. How would I identify the program as the owner signer?
this almost sounds too good to be true:D I can't wait to deploy my first anchor program live
almost anything you can do in `anchor test` will work in production
hm I wasn't sure if `anchor.workspace.ProgName` command is available when run outsidfe of `anchor test` - but I think what you're saying is that yes  it is
Thanks
this sir ? ``getParsedTokenAccountsByOwner``
this is one of its main strengths
but yes, anchor handles serialization and deserialization for you
i don't know what you mean by `outside of tests`
```
console.log("payer account balance: ", (await program.provider.connection.getBalance(program.provider.wallet.publicKey)).toString());
```
that works outside of tests too? I thought I would have to do it manually via borsh
Anyone knows what can be wrong?
Can't find method getBalance in anchor.web3.Connection
if you want to get an acccount and deserialize it just use `.fetch`
i don't know what you mean, anchor does it for you
I see. A related question - I've seen borsh serialization / deserialization done many different ways in TS, could you point me to a repo which contains what you would consider best practice?
Gotcha, thanks!
Assuming its pubkey is unique, at least 32 bytes
I see, do you know what's the size of a single account passed?
No fixed limit, just a question of whether you can fit them into the tx given it can only be 1232 bytes 😬
How many accounts can I pass via remaining accounts? Is there a limit?
`zero copy` isn't as well supported or developed, so probably best to stick with the borsh approach if you can
with different bump seeds, starting at 255 and working down
yeh, `findProgramAddress` is just a wrapper function that loops over `createProgramAddress`
oh yeah, you can just use `createProgramAddress`directly then - https://docs.rs/anchor-lang/0.18.2/anchor_lang/prelude/struct.Pubkey.html#method.create_program_address
by looking at `createProgramAddress` function I got my answer 🙂
`findProgramAddress`  searches  every time for the bump. When I know the seeds and bump I am sure I can create a buffer and create the publicKey from it.
hm what's wrong with calling `findProgramAddress` multiple times? Could you share a bit more context?
Hi, how can I reconstruct a PDA publicKey when I know the seeds and bump, I am now calling each time `findProgramAddress` which is not optimal
it's not but I'm doing exactly what I shouldn't be and prematurely optimizing:D
hm so it's not the first time I hear this - but I can't figure out what exactly is different in deserialization?

this seems to work exactly the same in both cases?
```
const shardrAcc = await program.account.shardr.fetch(shardrKp.publicKey);
```
Smooth brain needs more directions plz sir
<:harold:883179034605924373>
that's the keyword used in the constraints
just search for `associated_token_account`
Is there a code snippet somewhere which lets me recover the user's associated token account (if there is one)
Ah ok
(That's their purpose actually—to have a single obvious account to store a given user's tokens for some given mint)
You can only have one associated_token account per user +mint, so no need to worry about making multiple of them
Hi sirs
I have a program which takes in a user's token account as one of the Account inputs. My program has mint authority for this token.
I was going to handle the following logic in the dApp frontend:
1/ If user has an associated token account for the token, pass this to my program
2/ If user doesn't have one, create one and pass this to my program

I'm not sure how to implement this now though. It's easy to create a token account on the fly, but then I'd be creating one everytime, and users who mint more than once will end up with several accounts for the same token and split their balance across them.

What is the best way to handle the above
is your program really compute constrained?
```
[profile.release]
lto = "fat"
codegen-units = 1
[profile.release.build-override]
opt-level = 3
incremental = false
codegen-units = 1
```
if you add this to the root directory Cargo.toml file (the virtual cargo.toml not the program one)
some of it can be attenuated
the extra compute budget you're seeing is the deserialization
less awkwardness dealing with account variables
the dev UX is easier with borsh deserialization
it's actually not that big, but empirically I found that using zero copy reduces compute budget by ~20%

are there any reasons not to just use it every time for efficiency?
Thanks
Lol I think I skimmed through and missed the last row <:harold:883179034605924373>
`address = the_expected_pubkey`
I do have a Q though, I can't figure out which one of the following access controls is most relevant: https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html

I'd like to make sure that for one of the accounts i'm passing through the #[derive(Accounts)] macro, it has a specific account public key
lol woops
clear
or at least it's possibly this functionality was introduced at their behest <https://github.com/Synthetify/synthetify-protocol>
also if you need inspiration synthetify does inline accountLoader loading stuff
why is your state so big?
Not 100% sure you'll need to do this but my hunch is yes
Hence the need for something silly like wrapping it in braces (that will make sure to drop the Ref)
Basically the `load` functions use some rust types that do borrow-checking at runtime, not compile time (Ref and RefMut), so you can get runtime errors with them if you aren't careful—what I wrote above with that goofy inlined `.load()` might not work at runtime
Yeah, that's fine
would a normal `anchor test` be enough? or actual deployment?
Yeah
to check this do I just deploy to localnet and try to run the instruction?
very cool
I see
But can do goofy-looking things because any expression is ok, including stuff like `{ let hmm = whatever.load()?; hmm.count }`
Might not work at runtime haha, I can't remember if you'll hit a ref issue
woah this is mind bending - it compiled!
It just embeds whatever you wrote into some other chunk of code, so any expression at all is ok as long as it typechecks etc.
Just needs to be any expression that makes sense, so will have to do something like `that_account.load()?.count`
(my state account is zero_copy)
I'm getting an error that the field doesn't exist
will it work with `AccountLoader`?
works inside macros
`this_account.your_variable`
that's amazing
yeh
lol
omg you can deserialize the account right in the macro....?
Ah, sorry, yeah if it's just hanging out on one of the other accounts you can do
```.rs
seeds = [ whatever, (other_account.count + 1).to_buffer_somehow() ]
```
Having the client pass the variable in would be a step back
What's wrong with that approach
Yeh
is that what you meant?
yeah so I think that's what I have right now - 

I have a `VaultFactory` which stores total number of vaults created

Every time I create a vault I:
- deserialize it and grab current counter
- store it as `vault_id` on vault PDA itself
- increment `total_vault_count` on the factory PDA
That ought to work, though haven't tried it before
So like you could keep track of the number of vaults created so far and just do `vault_counter_account.num_vaults + 1`
hm can you explain a bit more?
Using an internal account variable
You could also use some nifty maths
Didn't see all the responses already
yup, already on it - looks like a beautiful piece of functionality
Yeh, search for `instruction`
Using `#[instruction(...)]`
Yep!
ok yes I see what you mean - I'll need the PDA derived client side to pass it in. 

so can I just pass in the vault id as a variable, and include that in the init macro?
But the client has to provide every one of those program-derived addresses itself
And then it's a matter of showing your program which seeds were used for each pda
So at some point the client knew what seeds to use
My point is that you'll have to do that calculation on the client, lol, since you need to provide all of those addresses in the rpc call
hmmm, good question. My initial hunch was no - but thinking about it, I probably could. The challenge then is, I  would need to verify a valid ID is passed in correct? And that still happens in the handler?
So you're doing that calculation on the client too?
I suspect the answer is no, but keen to hear what you guys think
is there a way to insert a variable into the init macro, which isn't available until after the handler starts up?

what I mean: I have a bunch of vaults, which are numbered 1 to N. For each vault I'd like the PDA to include the vault id (so N for Nth vault). It should look something like this:
```rust
#[account(init,
        seeds= [
            b"vault".as_ref(),
            // VAULT ID GOES HERE
        ],
        payer=owner,
        space=8+std::mem::size_of::<Vault>)]
pub vault: AccountLoader<'info, Vault>,
```

the problem is I don't know the vault ID until I deserialize the vault factory, and grab the latest ID from there (and increment it +1). Currently I do this in the handler.

Is there a more elegant way of solving this other than manually init'ing the PDA inside the handler, after I've gotten the id?
it can be even weirder than that. When you called `invoked_signed` using the seeds, the program id is silently added
I was so focused on seeds I forgot that the entire name means the prog id is in there 😄
LOL... missing the forrest for the trees here. Literally...
So if MyProgram1 and MyProgram2 are really different programs, then no clash, since their program ids are different.
A program-derived address under the hood is just a sha256 hash of seeds + bump + programId + "ProgramDerivedAddress", so the programId is already an ingredient.
which underlying hash do you mean?

my thinking was this: someone deploys their own version of MyProgram, and starts using it. For PDAs not to clash, it'd be nice if each PDA had program id inside of it.

Otherwise a situation like this might happen:
user X goes to MyProgram1 and gets a PDA of ['myprog',userXPk]
user X goes to MyProgram2 and uh oh can't get a PDA of ['myprog',userXPk] coz it would clash

or am I misunderstanding something?
But phantom 1 is the maker and it needs consume events to be called in order for it to show up as unsettled in their open orders
Phantom 2 is a taker and that has a consume events call sent along with it. Plus you could send a settle instruction as well automatically
yeah
ah ok
Unsettled
that is not the problem
the orders are fulfilled
Don't run serum markets unless you know how they work!
It's the basic thing that would cause orders to appear unfulfilled
either way, thanks
yeah... ahah
Surprised no one suggested it before
Lol, no worries
🙂
Ok, thank you very much. I will try with that
If you're not running a crank then the maker won't get the token as unsettled
is that the problem?
No, but I am on devnet
Are you running a crank on your custom market?
ok , my behaviour is this:

- Create a Sell order of 1 AToken for 10 BToken with my Phantom1 wallet

- With phantom2 wallet I create a buy order of 10 BToken for 1 AToken (exact opposite)

- The orders are matched!

- The phantom2 wallet gets 1 AToken as unsettled

- The phantom1 does not get the 10 BToken as unsettled
It's a very serum specific question unfortunately, one of their devs will have to look into it. Ask them to get bonfida to check it out for you
And I posted it , but written in a different way
yes, by <@!811818609340186654>
I didn't see anyone say this in the dev questions channel in response to your message, was it a dm?
Nope, if it's not a PDA (so, a keypair address) it will have to have already signed from the client.
I'm not sure what the point could be—the programId is already included in the underlying hash, so you're just including it twice 🤔
<@!501570363566587905> j told me you managed to find a bug in the auction house 'cancel' function. What did you do to resolve this? Would like to test it out.
do you guys think including `program-id` in PDA seeds is generally a good or bad pattern? I noticed some programs (metaplex) do, others (jet) don't

wondeer if anyone given this proper thought
I have done anchor deploy and it went successful
you haven’t deployed the program
I am getting "Transaction simulation failed: Attempt to load a program that does not exist" error, when I have that program function in lib.rs, anyone knows how to fix?
try `.toBytes()` instead of buffer
on successful anchor build with this line in lib.rs ```system_instruction::transfer(&payer, &ctx.accounts.vault_initializer_sol.key, project_price);``` in the test file error pops up saying: ```Type at position 5 in source is not compatible with type at position 1 in target.
    The types of 'accounts' are incompatible between these types``` this error had never been here until that build...
Its not a pda, so I am assuming that invoked_signed wouldnt work haha
Although now I am wondering, can I make a signer sign a CPI, and what would I used for the seeds?
🙌 🙌
this is how I'm passing the seeds

access_control
actually maybe it's this?
https://github.com/project-serum/anchor/blob/master/tests/interface/programs/counter/src/lib.rs#L31
you're probably not passing the seeds in the correct format
"Length of seeds is too long for address generation"

maybe need to reframe to think about accounts..
maybe that's not the right way to think about it
is there a good way to ensure that a CPI call is made from one other specific program? like a whitelist of sorts
That means you've run out of stack space (can try searching the discord for other threads). One common/easy fix is to just Box some of your Accounts: Box<Account<'info, Whatever>>. Various other fixes possible too but I need to go to bed 😴
A moderator from Serum said to post my question here. Sorry if it is off topic
Hi. 
I am building a marketplace that is using Serum to trade two tokens (one of them is an NFT aka a spl-token with metadata, but this is irrelevant)

When I make a SELL order and it is fulfilled by a different account, the account that bought it receives the base token as unsettled in their account. But, the person that put it for sale in the first place does not receive the quote token . It is NOT as unsettled in the market
I am using the serum dex UI and a tool in node i have built. But the quote unsettled balance does not show in any place
which is very very weird as the trade is completed sucessfully
```  {
    marketAddress: new PublicKey("2w71xbj3qQStuDXRwD1fjhw33S7jg3knLiUSiaK1nFMT"),
    programId: new PublicKey("DESVgJVGajEgKGXhb6XmqDHGz3VjdgP7rEVESBgxmroY"),
    deprecated: false,
    baseMintAddress: new PublicKey("CEzjdh3R5gGbbhsRE7JoPgeX6MaeeVriMWuFGgvkRpDi"),
    quoteMintAddress: new PublicKey("HDRkqEgS5inHgKqA6Hbk1dK84NQsyNdLNhytn7CHV5No"),
  },```
 
these are the details of the market
It was created with :
     ```   "baseLotSize": 1,
        "quoteLotSize": 0.001```
Hi guys, I 'm kind of stuck with a particular error:
```
Program failed to complete: Access violation in stack frame 3 at address 0x200003a10 of size 8 by instruction #13275
```

Kind of struggling how to troubleshoot these kinds of errors.. any advice?
got it. thanks a lot for the quick reply! :))
i hven't seen any examples of programmatically interacting with raydium/orca either unfortunatley
yeah
I guess one would create his own liquidity poll using Quarry, rather than connecting to other ones as I understand
im just trying to do liquidity mining right now, just programmatically. not sure why its so painful haha, i was hoping the pools would have incentive for this
not sure what you're trying to do
this is more of a create-your-own product, rather than interact with existing pools
https://github.com/QuarryProtocol/quarry
i haven't looked at this at all yet, but i think this quarry lib is getting at that use case
hey guys, does anyone know any liquidity pools where i can programmatically (through rust), add liquidity and generate yields? raydium and orca don't seem very supportive in their sdk's (they only / barely seem to offer frontend SDKs only)
This was pretty much the problem, I didnt pass the metadata account as mutable haha
Yep, should in general use `checked_add` etc.
how should I sent the mintAuthority?
yes I used trunc function so converto to64.
like, for addition
is there some special way to do math with tokens? Is there a possibility of running over the maximum number of a u64?
here what should I set for the "mintAuthority"?
`
    const instruction = TokenInstructions.mintTo({
        mint_token,
        destination: user_mint_vault,
        amount,
        mintAuthority: authority,
    });

    const tx = new anchor.web3.Transaction();
    tx.add(instruction);

    let sig = await provider.send(tx);`
Hope to know what should I set for authority.
but owner is not match error occured.
Hope to mint to my account like this
await mintTo(provider, mint_token, user_mint_vault, 1000);
and make mint_token and user_mint_vault.
I generate user=keypair.generate();
hi
Perfect. That's one mistake we'll both never make again 👌
now onto fixing the program errors 🙂
great yeah its working the issue was just the naming it generated two idls as you said
yeah I think you are right! wow ty I will test it
I actually changed it without thinking much about it, on my laptop and forgot about it ...
it should match the workspace name
in lib.rs
I believe you might have an issue with the module name
like one for something.json and another for fire_away.json
ah wait! its empty so it seems its generated two idls
It does seem related to the IDL. Can you log this right before the RPC call: `console.log(program.idl.instructions[0]);`
hmmm no dice. I am hitting an issue, but I think it is already passed yours, as it is program-side
this is a new mac intel so it could be I'm missing dependencies for chai typescript etc, but I thought they should just install locally from the package.json
I have had problems with my anchor ie. a fresh clone of anchor and anchor init ,then anchor test doesnt work, the only way it works is with the anchor init --javascript flag (not sure exactly why)
ty <@!915682383905316864> yup this is it <@!134416332509675520>
```
{
  "version": "0.0.0",
  "name": "fire_away",
  "instructions": [
    {
      "name": "initialize",
      "accounts": [
        {
          "name": "mintAccount",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "programPda",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "ownerWallet",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "metadataAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenMetadataProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rent",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "initNonce",
          "type": "u8"
        }
      ]
    }
  ],
  "metadata": {
    "address": "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"
  }
}
```
What does your target/idl file look like?
https://github.com/ajobi-uhc/mediaNFTtest just created one 🙂
you got a github I can clone and reproduce. or is it private?
is there a way to sign data using the anchor js lib? I.e. sign arbitrary data not a transaction
254
What do you get when logging `myBump` ?
just a bit confused that it says too many arguments even when I put in 1 arg, does seem to make too much sense rn


///////////////////////////////////////////////////////////////////////////////////////////////

test script:
```javascript
const anchor = require('@project-serum/anchor');
const assert = require("assert");
const { SystemProgram } = anchor.web3;

describe('myProgram', () => {
  const provider = anchor.Provider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.Myprogram;
  const baseAccount = anchor.web3.Keypair.generate();

  console.log("🚀 Starting tests...");

  // initialize the program
  it('initializes the program,', async () => {
    const tx = await program.rpc.initialize({
      accounts: {
        baseAccount: baseAccount.publicKey,
        user: provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      },
      signers: [baseAccount],
    });
    console.log("📝 Your transaction signature", tx);
    let account = await program.account.baseAccount.fetch(baseAccount.publicKey);
    assert.ok(account.totalThings.eq(new anchor.BN(0)));
  });

  // add a new thing
  it("creates a new thing", async () => {
    await program.rpc.addThing({
      accounts: {
        baseAccount: baseAccount.publicKey,
        user: provider.wallet.publicKey,
      }
    });

    let account = await program.account.baseAccount.fetch(baseAccount.publicKey);
    assert.ok(account.totalThings.eq(new anchor.BN(1)));
    console.log("🚀 DONE a new thing...");
  });
});

```
lib.rs:
```rust
use anchor_lang::prelude::*;

declare_id!("8fyNdtdeXQD1KykqXEki5Hg8JPtsUxVHhmQpF5tTcNK");

#[program]
pub mod myprogram {
    use super::*;
    pub fn initialize(ctx: Context<Initialize>) -> ProgramResult {
        let base_account = &mut ctx.accounts.base_account;
        base_account.total_things = 0;
        Ok(())
    }

    pub fn add_thing(ctx: Context<AddThing>) -> ProgramResult {
        let base_account = &mut ctx.accounts.base_account;
        base_account.total_things += 1;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 9000 )]
    pub base_account: Account<'info, BaseAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program <'info, System>,
}

#[derive(Accounts)]
pub struct AddThing<'info> {
    #[account(mut)]
    pub base_account: Account<'info, BaseAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
}

#[account]
pub struct BaseAccount {
    pub total_things: u64,
    // pub thing_list: Vec<ItemStruct>,
}
```
hello friends.  ive been staring at my code for hours trying to find out why I am getting the error `Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: instruction modified the program id of an account` after running my tests but i cannot find a solution.  I've pared it back to the basics and still have no idea whats going on.  Any help?
Trying to figure out where the errors arer located
Hi is therre a central list of rpc errors like this : index.js:1 Transaction simulation failed: Error processing Instruction 0: custom program error: 0x178c  that I can reference to understand what  0x178c error is referring to please 🙂
I want to use Event feature. and I wonder if Anchor supports such feature.
If there are so many tx, fetching would get more slower.
Haha. I know that.
Fetching the transaction history should have nothing to do with a specific program though. There are web3.js functions to get transactions in batch
but I can't see Event history.
So I decided to use #[event]  in Anchor.
Yeah, I want to fetch tx history very fast as on Ethereum.
Are you talking about graphql subscriptions?
Hmm. Anyhow Event is very useful for graphql. I want #[event] would work on solana.
I'm not too familiar with this feature, but isn't that supposed to be some way to make use of the logs to "return" a value? So I'd guess something should be there in the logs of that tx
How can I see my Event History?
Hi, I used #[event] and emitted Event, and then I can't find any Event history on Solana Explorer.
Hey is there any blog/tutorial on how to develop nft staking with custom spl Tokens?
thank you! very helpful comment
If by program account you mean "on the curve", PDA use cases afaik:
- if you need the program to be able to manipulate the account without the "creator" 's signature (e.g. a two-part, asynchronous trade like in escrows)
- if you need the address to be deterministic, for instance if you need the address to be unique per entity (e.g. ensure there is only 1 token escrow account per offer account by using the offer account pubkey in the PDA derivation)
is there any benefit of having a PDA over a program Account to store data?
yes, e.g. with `Account<'info, TokenAccount>`
or old string data is left in the account?
Do you need to make the string as long as the data allows?
Do strings not get there data over written?
```
{ slot: 104334603 }
{
  pubkey: 'xxxxxxxx',
  account: {
    lamports: 15144960,
    data: [
   'KTDnwhZNzesOAAAAd3d3Lmdvb2dsZS5jb20AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=',
      'base64'
    ],
    owner: 'xxxxxxxx',
    executable: false,
    rentEpoch: 241
  }
}
```
```
#[account]
pub struct StorageAccount {
    pub redirect: String,
}
```
```
export interface RedirectAcount {
  redirect: string;
}
const borshRedirectAcount: borsh.Layout<RedirectAcount> = borsh.struct([
  borsh.str("redirect"),
]);
```
I'm trying to borsch.struct it and deserialize but it got all this extra stuff at the beginning
```
 redirect: '\u0016M��\n' +
    '\u0000\u0000\u0000google.com\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\
```
Is it possible to convert a byte buffer to one of your idl's accounts
is it possible to read token balance from a program?
👍 😆
thank you
omg~ so sorry
Yep, that's the problem
maybe it is issue
I created those tokens in testnet but I am working on devnet now
Hha
Lol
right
AHHHH
I created token for testing using spl-token create-token.
```const seedMint = new PublicKey("Gi3Wnc5TVAus8Zz2rDd193Ujg4snULahKDzvocCMW9cx");
const usdcMint = new PublicKey("4TihkWq855F3GVxA4LGeMQmukRLYfd58c6izMUCp2b5p");```
The `seed_mint`, the `usdc_mint` I guess
You need to double check you're passing the right accounts to every one of them
Right, so any one of those `Account<'info, Whatever>` could be at fault
this
```#[derive(Accounts)]
#[instruction(presale_title: String, bumps: PoolBumps)]
pub struct Initialize<'info> {
    // State Accounts
    #[account(
        init,
        seeds = [presale_title.as_bytes()],
        bump = bumps.presale_account,
        payer = presale_owner
    )]
    pub presale_account: Account<'info, PresaleAccount>,
    // Contract Authority accounts
    #[account(mut)]
    pub presale_owner: Signer<'info>,
    // USDC Mint
    #[account(constraint = usdc_mint.decimals == USDC_DECIMAL)]
    pub usdc_mint: Account<'info, Mint>,
    // seed token Mint
    #[account(constraint = seed_mint.decimals == SEED_DECIMAL)]
    pub seed_mint: Account<'info, Mint>,

    // USDC POOL
    // #[account(
    //     init,
    //     token::mint = usdc_mint,
    //     token::authority = presale_account,
    //     seeds = [presale_title.as_bytes(), b"pool_usdc".as_ref()],
    //     bump = bumps.pool_usdc,
    //     payer = presale_owner
    // )]
    // pub pool_usdc: Account<'info, TokenAccount>,
    // // SEED token POOL
    // #[account(
    //     init,
    //     token::mint = seed_mint,
    //     token::authority = presale_account,
    //     seeds = [presale_title.as_bytes(), b"pool_seed".as_ref()],
    //     bump = bumps.pool_seed,
    //     payer = presale_owner
    // )]
    // pub pool_seed: Account<'info, TokenAccount>,

    // Programs and Sysvars
    pub system_program: Program<'info, System>,
    pub token_program: Program<'info, Token>,
    pub rent: Sysvar<'info, Rent>
}
#[account]
#[derive(Default)]
pub struct PresaleAccount {
    pub presale_title: [u8; 10], // Setting an arbitrary max of ten characters in the presale name
    pub bumps: PoolBumps,
    pub presale_owner: Pubkey, // owner of program
    pub usdc_mint: Pubkey,
    pub seed_mint: Pubkey,
    pub pool_usdc: Pubkey,
    pub pool_seed: Pubkey
}
```
ok
Can you show your entire derive(Accounts) block? Way easier to debug than with small snippets
```Transaction simulation failed: Error processing Instruction 0: custom program error: 0xbc4 
    Program 4cb5r9tRFvB28z3ywm5SW31ufnbBTs7NSD43RSxs7Pzg invoke [1]
    Program log: Instruction: Initialize
    Program log: Custom program error: 0xbc4
    Program 4cb5r9tRFvB28z3ywm5SW31ufnbBTs7NSD43RSxs7Pzg consumed 4543 of 200000 compute units
    Program 4cb5r9tRFvB28z3ywm5SW31ufnbBTs7NSD43RSxs7Pzg failed: custom program error: 0xbc4
Transaction error:  ProgramError: 3012: The program expected this account to be already initialized
    at Function.parse (/Volumes/Work/solana/contract/presale/node_modules/@project-serum/anchor/dist/cjs/error.js:40:20)
    at Object.rpc [as initialize] (/Volumes/Work/solana/contract/presale/node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:38:61)
    at processTicksAndRejections (node:internal/process/task_queues:96:5)
    at async module.exports (/Volumes/Work/solana/contract/presale/migrations/deploy.js:66:5) {
  code: 3012,
  msg: 'The program expected this account to be already initialized'
}```
I am gonna restart computer and try it again
This way, it worked 1 month ago, but not work now
```const [presaleAccount, presaleAccountBump] = await PublicKey.findProgramAddress(
      [Buffer.from(presale_title)],
      program.programId
    );
    bumps.presaleAccount = presaleAccountBump```
From the client part, I passed presaleAccount
Even though, I am using only the first account "presale_account", the error happened.
That error means you've passed in an account that, yeah, hasn't been created yet, but those both use `init` so wouldn't lead to that error
Are those your only accounts? I would be pretty surprised if they're the source of that error
This worked 1 month ago but not working now
```
    #[account(
        init,
        seeds = [presale_title.as_bytes()],
        bump = bumps.presale_account,
        payer = presale_owner
    )]
    pub presale_account: Account<'info, PresaleAccount>,

    #[account(
        init,
        token::mint = usdc_mint,
        token::authority = presale_account,
        seeds = [presale_title.as_bytes(), b"pool_usdc".as_ref()],
        bump = bumps.pool_usdc,
        payer = presale_owner
    )]
    pub pool_usdc: Account<'info, TokenAccount>,```
```ProgramError: 3012: The program expected this account to be already initialized```
I am getting this issue. anyone has any idea for this?
Thanks a lot <@!134416332509675520>
Wow!
Ohh, thats great!!
Just use `    "@project-serum/anchor": "^0.19.1-beta.1",` in your package.json

So, I think workaround right now could be to directly send a string address instead of a public key inside program constructor?
Aha, yes, it is released 🙂 0.19.1-beta.1
This is fixed in master, trying to see if it's fixed in a release though: https://github.com/project-serum/anchor/pull/1138
ah, it is really interesting. thank you for sharing good info. 👍
100kb = 0.7 sol or slightly more
So, is there any workaround until its resolved?
In general you should see how big your `target/deploy` .so file is
I did airdrop 5 SOL more and now it works.
Before I am using more BOX, it was enough with 2 SOL but it require 4 SOL now
Ohh, so its a bug in anchor library.
The build process ends up breaking that code unfortunately (bug in anchor)
The issue is here: https://github.com/project-serum/anchor/blob/v0.19.0/ts/src/program/common.ts#L64
Yes, It is all set and also it is working with yarn start locally. Issue is only after creating build.
<@!730245907580452917> I just figured it out lol, actually a pretty interesting bug!
I would airdrop yourself some more just to make sure (that's not very much)
yes, almost 4 SOL in devnet
Do you have enough sol to actually deploy?
```To resume a deploy, pass the recovered keypair as the
[BUFFER_SIGNER] to `solana program deploy` or `solana write-buffer'.
Or to recover the account's lamports, pass it as the
[BUFFER_ACCOUNT_ADDRESS] argument to `solana program close`.
========================================================================================
Error: Deploying program failed: Error processing Instruction 1: custom program error: 0x1
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.```
Now I am getting another issue
Okay, got it. let me try to do it now.
And redeploy from scratch
Will probably have to generate a fresh keypair for your program id (delete the keypair in target/deploy)
I think that means you ran out of space in your program account 😔
```Error: Deploying program failed: Error processing Instruction 0: account data too small for instruction
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.```

when anchor deploy, I am getting this issue.
good to go <@!134416332509675520> thank you for your help and what you do in here day in and day out <a:pepecheers:882319276432826379>
💩  yup, with more Box, it works, thank you so much
Are you sure your `idl.metadata.address` is set?
yes, I am getting issue, now let me use more Box and will you know.
So you're still getting stack issues? Have you tried using more Box's?
yeah thats what i meant, ill post results here in a sec and the larger logic so you can have a better look if it doesnt work, cheers!
You might honestly be able to just get rid of that one minus sign and see if it fixes things
Right, gonna see if something like this works.
yes, just done
You can post nice code blocks by do three backticks ` + newline + code etc. + three more backticks
This is my instruction for purchase
```#[derive(Accounts)]
pub struct DepositUsdcForSeedToken<'info> {
    // Payable account (User wallet)
    #[account(mut)]
    pub user_authority: Signer<'info>,
    // User's info
    #[account(
        mut,
        constraint = user_account.owner == user_authority.key()
    )]
    pub user_account: Account<'info, UserInfoAccount>,
    // User's USDC token account
    #[account(
        constraint = user_usdc.owner ==user_authority.key(),
        constraint = user_usdc.mint == usdc_mint.key()
    )]
    pub user_usdc: Account<'info, TokenAccount>,
    // USD coin
    #[account(mut)]
    pub usdc_mint: Account<'info, Mint>,

    // User's Seed token account
    #[account(
        constraint = user_seed.owner ==user_authority.key(),
        constraint = user_seed.mint == seed_mint.key()
    )]
    pub user_seed: Account<'info, TokenAccount>,
    // seed token
    // #[account(mut)]
    // pub seed_mint: Account<'info, Mint>,
    
    #[account(
        seeds = [presale_account.presale_title.as_ref().trim_ascii_whitespace()],
        bump = presale_account.bumps.presale_account,
        has_one = usdc_mint
    )]
    pub presale_account: Box<Account<'info, PresaleAccount>>,
    
    // Pool for USDC and seed
    #[account(
        seeds = [presale_account.presale_title.as_ref().trim_ascii_whitespace(), b"pool_usdc".as_ref()],
        bump = presale_account.bumps.pool_usdc)]
    pub pool_usdc: Account<'info, TokenAccount>,
    #[account(
        seeds = [presale_account.presale_title.as_ref().trim_ascii_whitespace(), b"pool_seed".as_ref()],
        bump = presale_account.bumps.pool_seed
    )]
    pub pool_seed: Account<'info, TokenAccount>,
    
    // Programs and Sysvars
    pub system_program: Program<'info, System>,
    pub token_program: Program<'info, Token>,
    pub rent: Sysvar<'info, Rent>,
}```
This is what you want to do:
```.rs
fn transfer_from_account_we_own(
    src: &mut AccountInfo, // we better own this account though
    dst: &mut AccountInfo,
    amount: u64,
) -> ProgramResult {
    **src.try_borrow_mut_lamports()? = src
        .lamports()
        .checked_sub(amount)
        .ok_or(ProgramError::InvalidArgument)?;
    **dst.try_borrow_mut_lamports()? = dst
        .lamports()
        .checked_add(amount)
        .ok_or(ProgramError::InvalidArgument)?;
    Ok(())
}
```
Yeah
You're right, I had a brain fart, the 'old_amount' here would be some_account.to_account_info().lamports() right?
Not `new_amount -= old_amount.checked_sub(something)` (that's different!)
You want to say `new_amount = old_amount.checked_sub(something)`
What do you mean?
Got it, but wouldn't setting lamports to that amount set the lamports for the accounts to just the amount and not add or subtract to their already existing balance?

I'm guessing that's not allowed

I can post the entire thing in a sec
Ah, also that snippet looks wrong, it should be just `=` not `-=` on the first line
Ok, I'd need to see your whole instruction probably
The error was still there before then, but you're right, for some reason I changed that statement! I can confirm that im subtracting and adding the same amount there
You would need to make sure you add and subtract the exact same amount
Ah, well, why are you doing a checked_sub for one but a regular add for the other? That's asymmetric and could potentially lead to your error (you might sub less than you then add)
nope no CPI's, just some simple state changes before those lamport related statements and thats it
Are you doing anything else in your instruction? Any CPIs?
Can someone please help me with this issue?
<@!134416332509675520> any chance you could take a look at the issue I posted above? if not no worries ill keep troubleshooting!
ah thank you!
If you `cargo expand` your anchor program you can see that anchor auto-generates a little dispatch table based on the first 8 bytes of the instruction data
It'll usually be (pseudo-code) `sha256("global:your_instruction_name")[..8]`
Yep, the first 8 bytes of the instruction data are for the "sighash"—it tells anchor which of your instruction functions to run
it looks like the last 20 of the 28 bytes correspond to the instruction data i had passed in - trying to determine what the first 8 bytes correspond to
I passed the context and 20 bytes into the instruction, and am seeing 28 bytes of instruction data on chain
Hi! I'm looking to understand more about how anchor encodes instruction data
thank you, i can take it from here. I'm also a few weeks into rust and this is the push to fully understand features
Maybe better to not include that `default` setup, eh, not sure 🤷‍♂️
Ok not 100% sure the most ergonomic way to use cargo features, I'm haven't used them before, but looks like you can then do e.g.
```
anchor build -- --no-default-features --features production
```
thank you!
And then in your program's Cargo.toml do
```.toml
[features]
...
default = [development]
production = []
development = []
```
The cargo features approach would look like (for example):
```.rs
#[cfg(feature = "production")]
const SOMETHING: u8 = 1u8;
#[cfg(feature = "development")]
const SOMETHING: u8 = 123u8;
```
for e.g is signer.pubkey === "<pubkey>" then; proceed;
oohhh! sorry, i'm new to anchor. The reason i asked is because i have a hard dependency in my project where only a certain public key can create a sort of  "genesis" contract call. I'd like to free switch values between dev and prod. That's why i was curious.
Yeah, definitely possible to do that—one way is with cargo features, but I'm actually not sure the easiest way to do that via the Anchor.toml file 🤔
gotcha, i was thinking it was possible to have a separate keypair/cluster
hello everyone, im getting the error: `Error processing Instruction 0: sum of account balances before and after instruction do not match` error when attempting to remove lamports balance from a program account (which is mutable, I checked) and add them to a user account's lamports balance (which is also mutable and a signer), here is the code:
`**bet_state.to_account_info().try_borrow_mut_lamports()? -= bet_state.to_account_info().lamports().checked_sub(bet_value_from_bettor_detail).ok_or(ProgramError::InvalidArgument)?;
**bettor.to_account_info().try_borrow_mut_lamports()? += bet_value_from_bettor_detail;`

Trying to figure out why this is the case? I've seen a few instances of the same issue in the past, but I havent been able to uncover a clear solution.

Hopefully this is clear enough, if not lmk!
No built-in support for that, but I guess you could hack something together maybe
<@!134416332509675520> hi! please is this possible?
Yeah, using too much stack space
i believe the data you are sending to the smart contract is larger than the space you allocated
hello guys, is it possible to use variables from anchor.toml in rust? I'd like to verufy a public key in the smart contract, but have different values passed during build
When I build the program, I am getting this issue, any idea pls?
Error: Function _ZN7presale9__private8__global8purchase17h220a967affc7f780E Stack offset of -4584 exceeded max offset of -4096 by 488 bytes, please minimize large stack variables
🙂
Oh, lol
No. I installed anchor again
And it *still* says that even after `cargo uninstall anchor`?
Users/<name>/,cargo/bin/anchor
Let me try to run
ah, haha, I understand.
Sorry, I think you're misunderstanding what I'm asking—I want to know what the exact command `which anchor` says when you run it at your terminal
After new setup, I will check if I have same issue.
I have no logs now since I delete all solana and anchor, rust from my mac.
I  had some issues so I decided re-setup.
What is the exact output?
Nope, `which anchor` wouldn't say that
0.19.0
I am sorry
1.9.0
What does `which anchor` say?
That's solana itself saying that (someone forgot to delete a log line lol)
<@!134416332509675520> do you have any idea for this?
btw when I run "anchor deploy" in my mac, I can see following logs:

msg <ADDRESS>
msg <ADDRESS>
msg <ADDRESS>
msg <ADDRESS>
msg <ADDRESS>
......
so I deleted all cargo directory 🙂
I tried to do it but seems not working
thanks alan
Probably `cargo uninstall anchor`
The IDL currently doesn't support this unfortunately, you'll have to just encode it as a `Vec<(Pubkey, bool)>` (a vector of key-value pairs)
I'm with you, single-file all day lol
how can I remove anchor installed from my Mac?
hey guys, I'm trying to implement a btreemap but the idl is giving me this error `IdlError: Type not found: {"type":{"defined":"BTreeMap<Pubkey,bool>"}}` how do I fix this?
we have a similar structure. i think it adheres to a good rule to limit file sizes to about 300 lines max. also most modern ide's support "jump to function" / "jump to usage" (webstorm, VSCode probably too), which makes it pretty accessible mentally imo
It is probably very good shit and i like the effort but how does one read a project with such structure?
https://github.com/gemworks/core/tree/main/programs/gem_bank/src
I find it a giga mental effort to get an overview of what is going on since every single bit is in a different file
also, aside from the data being stored on the heap, is there any other difference in the implementation?
I'm having this issue: "use of undeclared crate or module `__client_accounts_u8`"
How can I import this module or solve this problem?
I'm running out of stack frame space if I switch to basic Account. I saw the trick with Box<Account< ..>, but I was wondering why does this happen?
why is there a difference in size between ProgramAccount<'info, Whatever> and Account<'info, Whatever>?
oh wow! thank you. definitely checking this now
Heres the answer, thanks to cqfd (alan): here's an example of how you can access your program's upgrade authority at runtime: https://github.com/cqfd/anchor-upgradeable-loader
ha! I just faced this problem.
Problem & Solution for a bug I just faced:
- Problem: `src.toArrayLike is not a function`
- Solution: use `new anchor.BN(your_value_here)` instead of just `your_value_here`
assuming this code 

```rust
pub struct Launch<'info> {
    // this is owned by the current program
    #[account(
        init,
        payer = authority,
        space = LaunchControl::space(),
        seeds = [
            b"crashies",
            authority.to_account_info().key.as_ref(),
        ],
        bump = bump
    )]
    pub launch_control: Account<'info, LaunchControl>,

    #[account(mut)]
    pub authority: Signer<'info>,

    pub system_program: Program<'info, System>,
}
```

is it possible to determine if `authority` created the current program? 

Basically, I only want to allow an endpoint to run only if the `authority` also created the program. Is this possible?
hi guys
all good 😛
K, guess not 😛
"init must be provided before token authority"
i will try that 👍
Can you do `#[account(token::authority = vault.owner)]`? Not sure
separate question: is there any shortcut for this:
```
#[account(constraint = (token_acc.owner == vault.owner))
pub token_acc: Account<'info, TokenAccount>
```
gotchaa i see
There's no need for that flexibility, so might as well just force them to use an associated token address
Because this is the part where the offer taker completes the offer, and I want to force them to transfer their half of the deal to an "obvious" place. Otherwise they could be slightly annoying and transfer their tokens to a random token account (still owned by the offer maker, but with an annoying random address)
Not less memory, just different memory (heap vs stack)
```
#[account(
        mut,
        associated_token::mint = taker_mint,
        associated_token::authority = offer_maker,
    )]
    pub offer_makers_taker_tokens: Box<Account<'info, TokenAccount>>,
```
<@!134416332509675520>  Why did you use `associated_token::mint` here? Does that make this only work with associated token accounts?
gotcha, but it takes less memory?
Strictly speaking the Box version uses more compute
Why should I ever use `Account<'info, TokenAccount>`  over `Box<Account<'info, TokenAccount>>`?
this isn't an anchor question persay, but I was noticing when reading solana-programs code for some programs (like token-lending) that both bigint and bignumber are used. is there any reason why both are used instead of just big number for all of it
When running `anchor build` in the project folder i'm getting strange error `dyld: lazy symbol binding failed: Symbol not found: ____chkstk_darwin` Anyone else run into this?


///////////////////////////////////////////////////////////////////////////////////////////////

You can `--clone` the mainnet program actually (try `solana-test-validator --help` for more info)
Yep, i have all the JS code, program addresses, etc. I found an example where they defined the trait in rust and called this with invoke signed indeed.

I suppose the answer is no, but is there a way to test against the mainnet program? Or should I rather deploy a dummy that roughly acts like the program I'm targeting?
You can port those same calls to rust, building the instructions manually and then using `invoke_signed` etc.
Do you have examples of building its instructions? E.g. a JS SDK?
Hi! I'm trying to interact with another program from within my own program, but the external code is not open source, I only know its interface (parameters and accounts).
What's the recommended approach to make this work?
Okay so the `confirmTransaction` call was missing the commitment enum string. After plugging in `confirmed` to all of them it works now.
Hmm so this is interesting. If I make the test code wait for several seconds before I send the problematic transaction the local test will go through without problems. For the transaction happening before the problematic one, I'm even waiting for it to be `confirmed` using `await provider.connection.confirmTransaction`. Not sure why this isn't enough waiting
I also tried resetting the test validator ledger with `solana-test-validator --reset` to see if that would fail the test, and it still works with a brand new ledger
Hey everyone, I've been completely stuck with this for the last several days. My test code works perfectly with `anchor test --skip-local-validator` and a local `solana-test-validator` running, and I can confirm every transaction is being applied by looking through the accounts using the block explorer. But the *exact* same code will fail with the error message `invalid account data for instruction` when running `anchor test` . Any reason why this might be happening?
i think you can do it with the solana wallet adapter
any resources on how they're doing that? doesn't look like its with any localstorage or cookies
I've seen a lot of sites that keep wallets connected now, no need to reconnect after refresh
so it feels like a bug in the latest binary
but `/home/YourDad/.local/share/solana/install/releases/1.8.5/solana-release/bin/solana program deploy ...`
works
Is anyone having success with deployement on 1.9.2? I had to run the old binary to not hit a weird deadlock,
it keeps printing `msg <BUFFER_ADDRESS>`
wow so I theoretically don't even need to make a separate mint authority for each of my tokens (I have multiple token types the program will be in charge of) - I could have one mint authority that can mint all of my types of tokens if I want. 

Obvious in hindsight but damn. That's useful
hi all, what if any are the restrictions on what kinds of open source crates we can use in our contracts?
seriously
Can't thank you enough for all the help in recent days
Yep
word
right I just gotta run the find_program_address to get the right bump/pubkey first yea?
So just pick your favorite seeds, use findProgramAddress, and make that be the authority over the mind (no need to init the mint within your program)
You don't even need to init an account there—the address is all you need!
If you want the program to have authority over the mint, you just need to have the mint's authority be some program-derived address derived from the program
```    #[account(
        init_if_needed, 
        payer = owner,
        seeds = [b"gear_ma"],
        bump = gear_1_mint_authority_bump, 
    )]
    pub gear_1_mint_authority_pda: Account<'info, TokenAccount>,
```
Like run this first, get it's pubkey, and then transfer the mint authority to the pubkey with `spl-token authorize <token-mint> mint <new-pda-pubkey>`
Hey alan, here you mention one way to give a program the ability to mint and burn a token is to initialize the mint directly from one of the program's instructions.

What if I want to create a token mint outside the program, and then later transfer mint authority over to the program? 

At first I thought I could just do e.g `spl-token authorize <token-mint> mint <program-address>` to give it the ability, but I can't tell if I can actually sign for it at that point since the authority isn't a PDA...Maybe I need to init a unique PDA of the program, and then transfer the mint authority to that PDA?
got it to work with 

```rust
        let pot = &ctx.accounts.pot;
        let pot_info = pot.to_account_info().clone();
        let funder = &mut ctx.accounts.authority;
        let funder_info = funder.to_account_info().clone();

        let ix = system_instruction::transfer(funder.key, pot_info.clone().key, fund_amount);
        invoke(&ix, &[funder_info.clone(), pot_info.clone()])?;
        Ok(())
```

All i needed was to invoke the instruction. Thank you again!
gotcha
But also get rid of the `checked_sub` part (the system program will handle that for you)
that was the missing part. initially, i did a `system_instruction::transfer` but it didn't work. So, i tried using anchor spl and just found out that wasn't what i wanted
And using `invoke`
More like this, but in rust: https://solanacookbook.com/recipes/basic-transactions.html#sending-sol
yes. the user signing the transaction is the funder
You'll have to do a system_instruction::transfer instruction
So your program *doesn't* own their account
Oh, sorry, but the funder here is just the user signing the transaction right?
alright, lemme give this a try, thanks
No need to talk to the token program at all
If your program owns the source of the funds, you'll have to do it like that
```.rs
fn transfer_from_account_we_own(
    src: &mut AccountInfo, // we better own this account though
    dst: &mut AccountInfo,
    amount: u64,
) -> ProgramResult {
    **src.try_borrow_mut_lamports()? = src
        .lamports()
        .checked_sub(amount)
        .ok_or(ProgramError::InvalidArgument)?;
    **dst.try_borrow_mut_lamports()? = dst
        .lamports()
        .checked_add(amount)
        .ok_or(ProgramError::InvalidArgument)?;
    Ok(())
}
```
I'd like to keep some sol aside in a "savings contract"
Can you explain what you'd like to do? I'm not super clear from looking at your code
alright, is there an example repo on how i can handle this?
Right, that's the token program saying "wtf is this account 🤔" (because it's not a token account)
Transaction simulation failed: Error processing Instruction 0: invalid account data for instruction 
    Program 72jm9eLkpyzhp7Yyc8bWqTvhhQ7itNvpiUo9wohZkLtj invoke [1]
    Program log: Instruction: FundPot
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [2]
    Program log: Instruction: Transfer
    Program log: Error: InvalidAccountData
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 1448 of 192902 compute units
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA failed: invalid account data for instruction
    Program 72jm9eLkpyzhp7Yyc8bWqTvhhQ7itNvpiUo9wohZkLtj consumed 8546 of 200000 compute units
    Program 72jm9eLkpyzhp7Yyc8bWqTvhhQ7itNvpiUo9wohZkLtj failed: invalid account data for instruction
Also, try posting the entire program log, not the JS stack trace
Also, the `funder_balance.checked_sub` doesn't make sense (checked_sub doesn't have any side effects, it just returns a new balance! So that line wouldn't do anything)
Doesn't look like the `authority`/`funder` account is a token account, you can't do a token transfer like that
u mean the funder? <@!246080971965726720> it does have 500m sol inside
i ran into that yesterday
<@!322016887259004929>
you might now have sol in the account you're trying to call it from
Here's what the fund struct looks like

```rust
#[derive(Accounts)]
pub struct Fund<'info> {
    #[account(
        mut,
        seeds = [b"house", authority.to_account_info().key.as_ref()],
        bump  = pot.bump
    )]
    pub pot: Account<'info, PotAccount>,
    pub authority: Signer<'info>,
    pub token_program: AccountInfo<'info>,
    pub system_program: Program<'info, System>,
}
```

Whenever I run this, i keep getting 

```bash
Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: invalid account data for instruction
      at Connection.sendEncodedTransaction (node_modules/@solana/web3.js/src/connection.ts:3689:13)
      at processTicksAndRejections (internal/process/task_queues.js:95:5)
      at Connection.sendRawTransaction (node_modules/@solana/web3.js/src/connection.ts:3649:20)
      at sendAndConfirmRawTransaction (node_modules/@solana/web3.js/src/util/send-and-confirm-raw-transaction.ts:27:21)
      at Provider.send (node_modules/@project-serum/anchor/src/provider.ts:118:18)
      at Object.rpc [as fundPot] (node_modules/@project-serum/anchor/src/program/namespace/rpc.ts:25:23)
```

Here's how i'm calling the endpoint in javascript

```ts
await program.rpc.fundPot(toLamportsBigNum(amount), {
    accounts: {
      pot,
      authority: funder.publicKey,
      tokenProgram: TOKEN_PROGRAM_ID,
      systemProgram: anchor.web3.SystemProgram.programId,
    },
    signers: [funder],
  });
```

What am i doing wrong here?
Hi guys, I'm trying to send some lamports to a PDA.

```rust
    pub fn fund_pot(ctx: Context<Fund>, fund_amount: u64) -> ProgramResult {
        let pot = &ctx.accounts.pot;
        let funder = &mut ctx.accounts.authority;
        let funder_info = funder.to_account_info().clone();
        let funder_balance = **funder_info.lamports.borrow();

        // can funder handle transaction?
        funder_balance
            .checked_sub(fund_amount)
            .ok_or(HouseError::InsufficientFunds)?;

        let cpi_program = ctx.accounts.token_program.clone();
        let cpi_accounts = token::Transfer {
            from: funder_info.clone(),
            to: pot.to_account_info().clone(),
            authority: funder_info.clone(),
        };
        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
        token::transfer(cpi_ctx, fund_amount)?;

        Ok(())
    }
```
good now
lol, totally thought I checked that, but I looked at NODE_BROWSER for some reason.  Indeed, vscode seems to set it
But basically that Wallet export is conditional now: https://github.com/project-serum/anchor/blob/master/ts/src/index.ts#L23
Random guess, do you maybe have something that's inadvertently setting the BROWSER env var? (Hacky but can try doing `BROWSER= anchor migrate`)
I've seen this before, and remember beating my head against the wall then.  Make no sense.  I've cleared out `.anchor`, `target`, `node_modules`, etc.  Works fine from same folder if I run in a docker instance of `projectserum/build`
I'm beating my head against a wall here....  Why is all the sudden my local `anchor migrate` not working:

```Running migration deploy script
/home/redacted/.anchor/deploy.js:11
    const wallet = anchor.Wallet.local();
                                 ^

TypeError: Cannot read properties of undefined (reading 'local')```
Yep, you can make as many token accounts for the same owner + mint as you want (slightly odd to do, but it's possible)
Can you create multiple token accounts with the same owner? i.e. same address owns 3 token accounts of the same mint
hahaha exactly
lol, take a look at this video @50:31 https://youtu.be/LF2sfT8gbOE?t=3031
Went to bed broken, woke up fixed.
Haha, of-course it's magically building fine now?! SO strange
Can you post the full error?
very strange
I've tried a few versions 🤔 running 1.9.2 the latest testnet build now... when running anchor build/test on this version there's no output
You likely need to update your installation of solana itself
Any1 run into the issue: "error: failed to download `solana-frozen-abi v1.9.1`" when trying to build with anchor?
You actually apparently don't have to anymore!
that has to be run via rosetta, right?
1.8.11 is fine
E.g. I'm on an m1 and I'm running 1.10
Ah, no, you can update to the latest if you want (you'll have to install from source as far as I know)
solana-cli 1.8.5 (src:devbuild; feat:52865992)  --> im running on M1 and was told this is the most "up-to-date" that doesnt break on M1s
Everything else you have above looks totally fine, so I'm leaning towards that explanation
I feel like I vaguely remember this being something with a slightly out-of-date solana install 🤔
Ah, what version of solana are you running?
although it appears different to what the console says is going in the log:
here is the only thing in program-logs
```
Streaming transaction logs mentioning 8fyNdtdeXQD1KykqXEki5Hg8JPtsUxVHhmQpF5tTcNK. Confirmed commitment
Transaction executed in slot 4652:
  Signature: 48TcZTdjM8xXpxgW3GdyJYwqj933ES9QYhM8nw1GwJYEpuEhMDZi1cWmmWpKeMKtdc1HsUKe7LGQ9D1cvvsvnzam
  Status: Ok
  Log Messages:
    Program 8fyNdtdeXQD1KykqXEki5Hg8JPtsUxVHhmQpF5tTcNK invoke [1]
    Program 11111111111111111111111111111111 invoke [2]
    Program 11111111111111111111111111111111 success
    Program 8fyNdtdeXQD1KykqXEki5Hg8JPtsUxVHhmQpF5tTcNK consumed 9268 of 200000 compute units
    Program 8fyNdtdeXQD1KykqXEki5Hg8JPtsUxVHhmQpF5tTcNK success
```
The code you've posted here looks fine to me—can you post the full program log?


///////////////////////////////////////////////////////////////////////////////////////////////

Yep 👍
ah I understand yes programprovider.wallet.pubkey is the same as owner wallet so it signs the tx automatically
As pubkeys
Can you compare their addresses for me?
yeah loading it from env

Can you post that code?
How did you construct/set your provider though?
but I never provide the actual keypair in the insturctions only the public key
and loaded from fs'
no ownerWallet is from anchor.web3.Keypair.fromSecretKey
I am loading in the ownerwallet from local filesystem
How is the provider set up? Is that ownerWallet not the provider.wallet?

If you mark it as `Signer<'info>` then (barring a somewhat catastrophic bug in anchor) it will have signed, somehow, if your instruction function is able to run
How are you passing `owner_wallet` from the client?
I see ok, so the issue I am running into is that this program can be executed without having this owner_wallet sign, it still executes state changes.
Not strictly speaking, no—it enforces that that address signs, but whether you need to explicitly pass a keypair to `signers` depends on whether the address is the `program.provider.wallet.publicKey`, since that signs automatically, no matter what
asking this because even when I pass in an empty signers array with this instruciton, it still goes through, a bit confused
Does having owner_wallet: Signer enforce that when I call the respective instruction in the frontend, I have to pass in the owner_wallet as a keypair into the signer array?

anyone know why this happened, I deploy one indexer on heroku
```thread 'main' panicked at 'Something went wrong: ClientError { request: None, kind: RpcError(RpcRequestError("cluster version query failed: HTTP status client error (403 Forbidden) for url (https://api.devnet.solana.com/)")) }', src/solana.rs:15:10```
Thanks
#dev support might be more up to date on upcoming solana features
https://discord.gg/solana
Thanks for the tip, where is "the solana tech discord"?
it's a popular one
if you ask enough times there maybe they will escalate it and get the feature added
as far as i'm aware this isn't possible but check in the solana tech discord
Would also be interested, I just ended up having a feature gated set_time_offset instruction in the program
How to test a specific time passed in Solana test with JavaScript?
https://www.reddit.com/r/solanadev/comments/r8rk7e/how_to_test_the_specific_time_elapsed_for_local/
Hi, someone know the solution for this?
I think if you're doing a custom script thing it would maybe make more sense to just construct your provider manually (it's just a connection + a wallet). Or you can use `Provider.env()`, but that depends on some env vars being set—you've set ANCHOR_WALLET, but it also needs ANCHOR_PROVIDER_URL for the cluster (just sticking them in Anchor.toml doesn't set those env vars, ordinarily `anchor test` does I think)
Doing `anchor.getProvider` seems to basically just do `Provider.local()`, which isn't what you want (try jumping to source on getProvider, you'll see what the issue is).
That means you're passing the wrong kind of `Account<'info, Whatever>` somewhere—you were supposed to pass a Foo account but you accidentally are passing a Bar.
circling back to this, actually 0x12c is the first, my bad on that 😅
hey guys i'm trying to send a instruction to my solana program and i got this error from the js error.message:
`ProgramError: 162: 8 byte discriminator did not match what was expected`
Anyone knows what this error means?
Has anyone figured out a workaround to this issue: https://github.com/project-serum/anchor/issues/880 ? 

To summarize, I'm trying to make a JS script to interact with a program I've already deployed and tested to devnet. For some reason, it's targeting the wrong rpc endpoint. 

I run the script using: `ANCHOR_WALLET=<mykeypair> node client.js --provider.cluster devnet`

The script is:
```
const provider = await anchor.getProvider();
anchor.setProvider(provider);
const program = new anchor.Program(idl, provider);
```

The error is:
```
Translating error Error: failed to get recent blockhash: FetchError: request to http://localhost:8899/ failed, reason: connect ECONNREFUSED 127.0.0.1:8899
    at Connection.getRecentBlockhash (/Users/evanmarshall/Documents/solana/sol-rng/top/node_modules/@solana/web3.js/lib/index.cjs.js:5965:13)
    at processTicksAndRejections (node:internal/process/task_queues:96:5)
    at async Provider.send (/Users/evanmarshall/Documents/solana/sol-rng/top/node_modules/@project-serum/anchor/dist/cjs/provider.js:77:31)
    at async Object.rpc [as initialize] (/Users/evanmarshall/Documents/solana/sol-rng/top/node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:11:31)
    at async main (file:///Users/evanmarshall/Documents/solana/sol-rng/top/app/client.js:25:5)
node:internal/process/promises:246
```
My anchor.toml: 
```
...
[provider]
cluster = "devnet"
...
```

I'd really appreciate any help as it seems like the fix should be straightforward without just hardcoding devnet params
thanks <@!134416332509675520> !
oh that is definitely the issue here
Are you sure you're passing the right sysvar account? That error comes from just checking the account that comes in against "Sysvar1nstructions1111111111111111111111111"
How are you actually calling that function?
when you say pass it, are you referring to the account that's being checked? bc that is what i'm doing precisely
oh that's great to hear
I've used instruction inspection in a scratch anchor project, works great 😈
Yep, that will work, but you do need to pass it from the client as an account (trying to think what else could cause that)
i'm hitting an `Unsupported sysvar` when trying to do so
i was wondering if it is possible to load all the instructions in a function like in regular sol? for example using something like ```sysvar::instructions::load_current_index_checked```
hi everyone! nice to meet you all
Thank you <@!347689664855015424> !
This will help us contribute directly to anchor more instead of maintaining our own packages ..
https://github.com/project-serum/anchor/pull/1066
This is awsome!
ok, awesome, thank you
It'll have to be `try_borrow_mut_lamports`, not try_borrow_lamports
You can import locally via a relative path as well
ok so I would import it right from github?
```
serum_dex = { git = "https://github.com/project-serum/serum-dex", rev = "1be91f2", version = "0.4.0", features = ["no-entrypoint"], optional = true }
```
How would I catch and handle specific anchor transaction errors?


///////////////////////////////////////////////////////////////////////////////////////////////

Get the mint: https://docs.rs/spl-token/3.2.0/spl_token/state/struct.Mint.html
yo how do i call this random tokens supply?
Ok I will look up that term on Google. Thank you!
Might be easier (well, sort of) to see if you jump to the CpiContext struct source.
Those are elided lifetime annotations (rust thing). The CpiContext type holds a bunch of references, which in rust necessitates a bunch of lifetime parameters (every reference has some lifetime whether you need to explicitly write it out or not).
Do you know the answers to Q1 and Q2 of my above post?
gotcha, thanks <@!134416332509675520> !
Try jumping to source on some of its functions—they're just helpers to construct calls to the spl_token program (it's not its own program, just a collection of helper functions)
Also, is `anchor_spl::token` like a wrapper around `spl_token` contracts? If so, why should I use the anchor version over the original `spl_token` library?
https://hackmd.io/@ironaddicteddog/solana-anchor-escrow
Hi, I am doing this tutorial and have a few questions:

Q1) In the code snippet below, What does ` '_ ` mean in the CpiContext type? (line 1)
Q2) In the code snippet below, why is the output `<'_, '_, '_, 'info, ...>`, when we create a CpiContext with only *two* arguments?

```
    fn into_transfer_to_pda_context(&self) -> CpiContext<'_, '_, '_, 'info, Transfer<'info>> {
        let cpi_accounts = Transfer {
            from: self
                .initializer_deposit_token_account
                .to_account_info()
                .clone(),
            to: self.vault_account.to_account_info().clone(),
            authority: self.initializer.clone(),
        };
        CpiContext::new(self.token_program.clone(), cpi_accounts)
    }
```
Good luck!
got it! many thanks for your help <@!248066053161222144> !!
The redeemable token account is an internal PDA program account
There's some good examples there
Check out IDO pool in anchor/tests
You make like wrapper functions which do CPI to the token program
Yep
>  No, this is all custom functionality inside the program

I thought by this you mean its all up to my implementation, am I right?
Not sure again what you mean
And also maybe so they can't change the balance and mess up your internal maths. Though your program probably should be robust enough to handle that
ah so more like business logic related stuff right?
The main reason you want PDA token accounts is so that users can't delete them
I've never used delegate functionality in token accounts
No, this is all custom functionality inside the program
I see there seems to be a delegate functionality in TokenAccounts. Is this what you refer to as the `give users some limited control over them` , or its something else you're talking about?
Maybe this is true but you should still not create non-ATA accounts for users
I don't understand
is this because of the delegate stuff?
according to my observation on devnet, seems they do appear in phantom wallet even tho not being an associated token program
And the user can't close the token account whenever they want, it has to be done via CPI from the program
But they don't appear in a phantom wallet
I create PDA token accounts all the time and give users some limited control over them
You can use it to create token accounts but just know that they're internal token accounts, owned and signed for by the program
so in this case one should only use syntax like  below for creating non-token account right?
```
    #[account(
        init,
        seeds = [x.as_bytes(), b"y"],
        bump = bumps.x,
        payer = authority,
    )]
    pub another_account: Box<Account<'info, AnotherAccount>>,
```
(it wasn't like this in the beginning and it was indeed bad)
but it's recommended that you don't do that, because like you said, bad UX
you can create other token accounts for them if you want
and it's the ATA
in solana we decided to just have a standard for creating token accounts for users
I see, but in effect user A will find himself/herself having to token account with the same mint, which is bad UX I think
phantom will send to the associated token account or create it for them
I guess in this case I probably should make sure I dont use token account A to begin with, need an associated token account instead
how about if users are using lets say phantom wallet. Imagine the following scenario
if token account A (not created as associated token account) has 10 token X, and transfers 1 X to associated token account B. If owner of associated token account B wants to transfer it back to A on phantom wallet, is it likely that user will run into issue as token account A's owner (a system account) doesnt have an associated token account?
When you do a token transfer you have to specify the *token* account you're sending to, not the owner. So it's up to you to pick which account to send to (when in doubt, this is what associated token accounts are for)
Hi guys, another question here. Lets say a System account owns many token accounts of the same mint, if I send token of that mint to the account, which exact account will be credited?
That is for signing multiple txs, which would work, but yes if you want to compose in 1 tx <@!134416332509675520> replied already
thanks!!!
oh i missed that completely
Does `program.transaction.yourIxFunction` work for building the tx?
cc <@!831450660146642974> because i know jup does this and uses anchor
or is there somethng i am missing in the codebase out of the box
hello, just to confirm if i wanted to use anchor to do ```const signedTransactions = await window.solana.signAllTransactions(transactions);``` its not possible atm with the current rpc factory right  and i have to write my txn manually for this right now right?
ohh okk I will give it a check! Thanks a lot!
Best bet is probably to search the anchor codebase! Tons of examples of that one
is there any good example I can probably reference?
So if one signature covers "two" accounts, then you're all good
`Signer<'info>` just says "this account had better sign"
lets say the authority and the payer are the same, in this case just need to put one keyPair in the rpc call right?
I'm not sure what's going on in the metaplex snippet above though (I would have kind of guessed that the payer and the authority would be the same, but I guess not—I'm not familiar with their action stuff though)
You can use the `signers: [...]` argument to rpc calls to attach extra signatures beyond the one you get automatically from the provider.wallet. One common situation where you need this is when initializing an account that lives at a keypair address: its address has to sign from the client, so you'd add its keypair to the signers array.
I guess in general sense, lets say I have a wallet plugin connected to the site, and I think it can only sign with one key at a time right? Am curious how to get more keys to sign and whats the use case
Do you mean syntactically?
HI there, got a question when looking at the code here https://github.com/metaplex-foundation/metaplex/blob/master/rust/auction-house/src/lib.rs#L1295. I found 2 `SIgners` in this handler, may I know how to actually have > 1 keys singing the transaction at the same time?
hm, what I have in mind is:
- each PDA gets an id from 0 to N
- each time I create a PDA I increment the id by 1
- I store total number of PDAs on some other meta struct

then client side I read off total number, and generate PDAs on the fly like this: 
```
for id in total_number:
 fetch(['nft_pda', id])
```
Just to double check, looping over accounts is actually a bit awkward since you'll have to pass every one of them from the client 😬
actually, can I get some architectural advice from you? If you were to have a vault storing multiple NFTs, each in its own PDA, how would you go about seeding those PDAs?

I want to be able to both loop over the NFTs in the vault and access them one by one. 

If I do `['nft_pda', mint_pk]` direct access is easy but I how do I loop over all NFTs in a single vault?

If I don `['nft_pda', nft_id]` it's the opposite, looping is easy, but getting each one now takes a loop

Is there a third option?
oh that's really interesting, a token account that signs for itself
So that doesn't rule out using an associated token account, but yeah, I would personally probably not do that—like you said, I would make the token account live at one of my own PDAs and have its authority be its own address (that way it can kind of sign for itself—no need to use some extra PDA as its authority since it already lives at one)
It actually kind of depends on how you want to do things—the main important thing is that the token account you make/use has a sensible authority. So if the token account is an escrow thing, controlled by your program, just have to make sure its authority is some PDA derived from your program (so that your program can subsequently sign for it if you want to transfer the tokens somewhere else)
so, just to draw parallels, if I wanted to create a token account to receive a token from the depositor, I would NOT want the ATA, prcisely because I want to specify the seeds manually right? like so:
```rust
    #[account(init,
        seeds = [
            b"gem_box".as_ref(),
            vault.key().as_ref(),
            &(vault.gem_box_count + 1).to_le_bytes(),
        ],
        bump = bump,
        token::mint = gem_mint,
        token::authority = authority,
        payer = depositor,
    )]
    pub gem_box: Account<'info, TokenAccount>,
```

while for withdrawing I want an ATA for the user
it worked!
makes a ton of sense
Just to elaborate a bit, an associated token account is a token account that lives at a special PDA (derived from a different program, the associated token program), so not possible to sign for it from the client (you have to send an instruction to the associated token program if you want to make one).
I see, let me try
What you've done there is init_if_needed a regular, non-associated token account, and you haven't specified any seeds+bump, so yeah, you would need to sign for that address from the client
Sorry, if you want this to be an associated token account, you would have to say `associated_token::` there instead of `token::`
Ah
Can you paste your IDL for this function? Just so I can see the whole thing
maybe this part is wrong somehow:
```rust
    #[account(init_if_needed,
        token::mint = gem_mint,
        token::authority = receiver,
        payer = owner,
    )]
    pub gem_destination: Account<'info, TokenAccount>,
```
Do you know why your rust program seems to want that address to sign?
Does it need to? That's probably a bug, because you won't be able to sign for an ATA address from your client (it's a PDA under the hood, so not possible to sign for it from the client)
true, should have thought about that! Ok so my destination ATA needs to sign... but how does it sign if it doesn't exist?
You can open up the `target/idl` file and see for that instruction which accounts are expected to sign
so the tx is not even going to the node? interesting
Are there any other accounts that need to sign?
Ah, ok, sorry—that's indeed a client-side error I think
the logs above where from the previous test's output
the problem is - there aren't any in the terminal - only this:
```
Error: Signature verification failed
      at Transaction.serialize (node_modules/@solana/web3.js/src/transaction.ts:583:13)
      at Provider.send (node_modules/@project-serum/anchor/src/provider.ts:112:22)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at Object.rpc [as withdrawGem] (node_modules/@project-serum/anchor/src/program/namespace/rpc.ts:24:23)
```
How come? Can you show the actual logs if there are more accurate ones? 😛
sorry
ignore the logs
That's a different error, 0x8d = 141 = ConstraintHasOne
hmm stuck with `Error: Signature verification failed`:
```
logs: [
    'Program 4bctEZztjcDVUi1WgqYKDJ4LirBKhvg2aS9kDeaFfYbR invoke [1]',
    'Program 11111111111111111111111111111111 invoke [2]',
    'Program 11111111111111111111111111111111 success',
    'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [2]',
    'Program log: Instruction: InitializeAccount',
    'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 3449 of 184180 compute units',
    'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success',
    'Program log: Custom program error: 0x8d',
    'Program 4bctEZztjcDVUi1WgqYKDJ4LirBKhvg2aS9kDeaFfYbR consumed 25582 of 200000 compute units',
    'Program 4bctEZztjcDVUi1WgqYKDJ4LirBKhvg2aS9kDeaFfYbR failed: custom program error: 0x8d'
  ]
```

what new signature do I need to add due to `init_if_needed`?
it literally cuts 90% of boilerplate
dude anchor is unbelievable
wooooooah
You can probably use `init_if_needed` instead of `init` for this
This means that you're attempting to use the system_program to do a transfer from an account *your program owns*, which won't work (I think people get the impression that system_instruction::transfer is the general way to transfer money in solana programs, but it's not! It only works on accounts owned by the system_program, because in general in solana, only an account's owning program can mutate its data/spend its money—no exception for the system_program)
is there a convenient way to check for a missing ATA in anchor? use-case: I'm withdrawing tokens from the protocol and if the destination ATA doesn't exist, I'd like to create it
You will have to check if the metaplex program exposes an instruction to do this. Anytime you want to mutate an account's data, you have to ask its owning program to do so via some instruction—no other way to do it. (If your program is the one that owns the account, then yeah, you can just mutate it though.)
You definitely won't be able to make useful use of a mutable reference to a metadata account in your own program (assuming your program isn't the metaplex program itself). Any mutation you want to make to the metadata will have to be done via some CPI to metaplex.
does anyone know if it is possible to change the isMutable boolean from true to false?
I am running into an issue where I have a mutable reference to the metadata account and I change the isMutable to false, then I run updatemetadata accounts function. The issue is the change doesnt persist ie. the runtime doesnt acknowledge the change in the boolean value
Ya, I'll check back in if I end up using it in the next few days / weeks
ah i see
Ya same, it looks like you have to convert things to the precisenumbers class and use that. But I don't have the time for a deep dive, especially since what I am doing doesn't require it.
some 500 bc math technique to calc approx root hahahaha
even solidity does something weird to calculate square roots and stuff
i'll make a note to try out the spl-math lib some time
lol.that would work i suppose heh
Reporting back! I'm just going to convert everything to integers and put this off for another time 😂😂😂 Luckly my numbers are somewhat arbitrary, I'll just have to tip toe around anything too crazy.
Ya, I will let you know what I can figure out. I am a little new to blockchain technology, but it seems a little weird that we have to struggle this hard to round and do standard math
let me know if it works! i'm learning as well and would be curious to know if that spl math lib works
haha i feel you! i checked for floor/ceil in the serum and mango repositories and there isn't much except a custom floor implementation in serum... and mango uses checked_floor etc on the float types...i guess even though math ops are simple, they do use a bunch of cpu cycles... also the standard libraries probably have dependencies on stuff you can't use in solana
I just want to do some simple math 😭 Thank you for the link though!
my guess would be that you don't want cpu intensive computations being done on-chain so these libraries are probably optimized for some tradeoffs
perhaps https://docs.rs/spl-math/0.1.0/spl_math/ 
https://github.com/solana-labs/solana-program-library/tree/master/libraries/math

unless someone knows a better way 😅
sqrt
thanks for that!
great! it works! 

```   Program log: "NOW ====>"
    Program log: 1638673862```
nice, I think the `.unwrap()` was missed in my code, compiling again, let's seeeee
anyone have good advice on dealing with decimals and trying to use floor and ceil in a Solana program? I guess a lot of float functions aren't supported
only 2 lines extra added from the default that `anchor new` generates are 
```
        let clock = Clock::get().unwrap();
        msg!("{:#?}",clock.unix_timestamp);
```
```
use anchor_lang::prelude::*;

declare_id!("yhegVC63GCroni3ydkaHQgEbQ46sq6cGXuFWv6qgk2V");

#[program]
pub mod clocktest {
    use super::*;
    pub fn initialize(ctx: Context<Initialize>) -> ProgramResult {
        let clock = Clock::get().unwrap();
        msg!("{:#?}",clock.unix_timestamp);
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize {}
```
oh weird... this compiles for me
I think I need to learn a little bit more about the functions and structs... just tried to use the `msg!` ... and it says that my func don't derive debug ... just tried to put it there and got another error hahaha
Clock is in anchor prelude it looks like
that should work i believe
you can try

```
let clock = Clock::get()
msg!("{:?}",clock.unix_timestamp)
```
actually thats for bliockhash, i think there might be a simpler call for clock.. let me check
thanks for that <@!499334426828865547>
great! I'll try it out!
Someone knows the reason?
I get this error "Transfer: `from` must not carry data"
I was wondering to learn how to use the crates importing stds, everything I tried raise some error Lol
```

    pub fn my_instruction<'info>(ctx: Context<'_,'_,'_,'info, MyInstruction>) -> ProgramResult {
        let clock = &ctx.accounts.clock;
        msg!("clock {:#?} ", clock.unix_timestamp);
        Ok(())
    }

#[derive(Accounts)]
pub struct MyInstruction<'info> {
    pub clock: Sysvar<'info, Clock>
}
```
Hi, I am trying to transfer from PDA to a normal account for user with invoke_signed
so it'll look something like this
you need to pass the clock account
Not yet, whats the command to get the unix timestamp?
you can also get the clock unix timestamp which when combined with payer and your gif can create a unique id
did you figure it out?
https://pencilflip.medium.com/learning-solana-3-what-is-a-program-derived-address-732b06def7c1
Good read
wild
I had the same issue. For me, there was a discrepancy in Anchor.toml. I wanted to deploy to devnet but my anchor.toml was still ```cluster = "localnet"```
which route feels more anchor-esque?
hey frens. Let's say I wanted to maintain a list of records where the List OR Records are PDAs. There's two ways to go about it:
1. Create a `List` PDA. Serialize each record into the accounts `data` field. Access records with `element_size*index`
2. Create an account for each record by using a hardcoded seed + Nonce. This would require another `ListMeta` account that's created from a hardcoded seed and keeps track of the nonce
I'll do it right now!
that shows up in your local logs as well as the explorer
Greaaaaaat!
```
msg!("context accounts {:#?} ",ctx.accounts);
```
for example
do msg!()
Nice <@!499334426828865547> ! Thank's for the ideas! I'll try to do something like you told me... I just don't know how to debug in a rust program yet... just did a println!("{}", someVariable") but I don't see anything in the build or test ahahahah that's weird ... btw thank's a lot bro
oh thats ok, i'm still learning as well haha... i suppose you can use a combination of the payer address (which you can get from ctx.accounts) and recent blockhash... i've never done it but i see anchor_lang::prelude::RecentBlockhashes...
in the `let item ....` I want to pass something there to uid... how can I get this payer address or recent block hash? I'm really really new in this language ahhaha sorry for bothering you bro
take a look in my function please

```    pub fn add_gif(ctx: Context<AddGif>, gif_link: String) -> ProgramResult {
        let base_account = &mut ctx.accounts.base_account;
        let user = &mut ctx.accounts.user;
        // type ItemId = Id<u32>;

        // println!("{}", ItemId::new().to_string());
        // let num = rand::thread_rng().gen_range(0..100);
        // println!("{}", num);

        let item = ItemStruct {
            uid: "xxxx".to_string(),
            gif_link: gif_link.to_string(),
            user_address: *user.to_account_info().key,
            votes: 0,
        };

        base_account.gif_list.push(item);
        base_account.total_gifs += 1;
        Ok(())
    }```
What is the instruction mint_bump doing?
i'm also still learning anchor, but you can use the payer address + gif name for that right? or payer + recent block hash?
I'll be really happy if you can help in how to do that, bro ...
exactly my man!
oh so you just need a unique identifier to tag each gif?
I'm just learning it yet... I have a program that receive some gif links... and I want to delete it... so if a lot o people add the same gif, I'll lost the tracking in deleting the correct one... so I want to give an id for any gif added. that's why I want an id you know? Is there a simple way to do that?
if you need randomness for UUID-like bheavior, thats a bit different from a random number for say a dice roll in some game logic
you can use a hash of some chain information for that, or just PDA logic in general.. but it depends on how "random" you need it to be.. biggest reason for oracle VRFs is so that users cant exploit it... if you rng using block hash etc, then users can exploit that by inserting an instruction that checks for favorable outcomes and fails if its not satisfactory (forcing it to rollback)
if you want to emulate VRF behaviour, best is to post a txn that your own server is listening to and then generate the randomness off chain and execute the callback from your own server... basically the same bheavior that an oracle does for you except the RNG is on your own server I suppose

edit: until chainlink or another oracle VRF is present
i was trying to create a random string to fake an id
do you <@!134416332509675520> have an option for that??
that's why I'm trying to install rand
I want to create an id type in a struct
Actually, I have no idea what I'm talking about with randomness lol ^, but that's my understanding
If you really need a source of randomness you have to source it from the outside world, via some kind of oracle (not sure the easiest way to do this currently)
rand unfortunately doesn't work on chain
Yep, you can mutate data just fine, assuming your program owns the account—what have you tried so far?
yo guys, struggling in trying to use rand crate.... just did rand = "0.8.0" in my Cargo.toml but it raise error.... but I got this error on `anchor build` 

```➜  gifs anchor build
BPF SDK: /Users/lucassilveira/.local/share/solana/install/releases/1.8.6/solana-release/bin/sdk/bpf
cargo-build-bpf child: rustup toolchain list -v
cargo-build-bpf child: cargo +bpf build --target bpfel-unknown-unknown --release
   Compiling getrandom v0.2.3
error: target is not supported, for more information see: https://docs.rs/getrandom/#unsupported-targets
   --> /Users/lucassilveira/.cargo/registry/src/github.com-1ecc6299db9ec823/getrandom-0.2.3/src/lib.rs:224:9
    |
224 | /         compile_error!("target is not supported, for more information see: \
225 | |                         https://docs.rs/getrandom/#unsupported-targets");
    | |_________________________________________________________________________^

error[E0433]: failed to resolve: use of undeclared crate or module `imp`
   --> /Users/lucassilveira/.cargo/registry/src/github.com-1ecc6299db9ec823/getrandom-0.2.3/src/lib.rs:246:5
    |
246 |     imp::getrandom_inner(dest)
    |     ^^^ use of undeclared crate or module `imp`

For more information about this error, try `rustc --explain E0433`.
error: could not compile `getrandom` due to 2 previous errors
➜  gifs ```
```.rs
fn check_mint_authority(expected: Pubkey, mint: Mint) -> bool {
    mint.mint_authority == COption::Some(expected)
}
```
Try something like this:
cqfd is the daddy (or mommy) this discord server needs
why do they handle token amounts as `u128`? does the token program define the max amount as a `u64`?
I love you <@!134416332509675520>
This is a slightly janky scratch repo that does that, a program-controlled mint: https://github.com/cqfd/anchor-token-studies/
This must be how my boomer coworkers felt when we switched to react
Web3 is very humbling. I feel like I'm learning web development all over again
<@!417114615156047893> You figure this out? I have a similar need. I want to be able to call a program and that program mints and deposits tokens into the user's account for the given mint
***   let mintAuthForMe = match ctx.accounts.mint_account.mint_authority{
            Some( mint_auth ) => {
                if *mint_auth == *ctx.accounts.owner_wallet.key { return(mint_auth)};
            },
            None => {None}
        };***

Awesome just an issue im running into with  mint authority is that I cant seem to compare it with the owner pubkey it gives the following error
ok I'm an idiot - there was an error in js
is it possible to remove d from it?
let's say I have an account that has a list [a, b, c, d]
is it possible to remove something from an account on solana?
so weird coz the exact same 2 accounts work with the deposit ix.. but not the withdraw
Yep, that's what the mint authority is
I am trying to verify that the owner of the mint account is owner_wallet.key, ie the wallet owns the concerned mint account, is the best way to do this via mint authority?
***        let mintAuthForMe = match ctx.accounts.mint_account.mint_authority{
            Some( mint_auth ) => {
                if mint_auth == *ctx.accounts.owner_wallet.key { return(mint_auth)};
            },
            None => {None}
        }; ***
for future people with .so being in the wrong deploy directory, the simplest fix is just to copy and paste it into the root.
That error is actually what I was suggesting above—I don't think you're actually passing token accounts there
Nope, that wouldn't trigger that error
ohhhhhhhhhh wait a second. I think what it's telling me is that the signer on the sender token account is a normal Public key, and instead it has to be a PDA owned by the program, right?
hmm which of the two would this refer to? the receriver or the sender?
ok nice now getting something more descriptive: `Error: 167: The given account is not owned by the executing program`
oh interesting, let me try that
Got it, ok, that's definitely suspicious/makes me think you haven't actually initialized those token accounts (ordinarily in anchor you would declare them as `Account<'info, TokenAccount>`, which makes sure they look correct)
```rust
#[derive(Accounts)]
pub struct WithdrawGem<'info> {
    #[account(has_one = authority)]
    pub vault: Account<'info, Vault>,
    pub authority: Signer<'info>,
    #[account(mut)]
    pub gem_box: AccountInfo<'info>,
    #[account(mut)]
    pub gem_destination: AccountInfo<'info>,
    #[account(address = anchor_spl::token::ID)]
    pub token_program: Program<'info, Token>,
}
```
Ah, ok, cool, that's what I expected—yeah, are you sure those token accounts are valid? How did you declare them in your `derive(Accounts)` struct?
js magic 🚀
weirdly it appears under another tests that passed
I think this is it
```
logs: [
    'Program 4bctEZztjcDVUi1WgqYKDJ4LirBKhvg2aS9kDeaFfYbR invoke [1]',
    'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [2]',
    'Program log: Instruction: Transfer',
    'Program log: Error: InvalidAccountData',
    'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 1583 of 193434 compute units',
    'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA failed: invalid account data for instruction',
    'Program 4bctEZztjcDVUi1WgqYKDJ4LirBKhvg2aS9kDeaFfYbR consumed 200000 of 200000 compute units',
    'Program 4bctEZztjcDVUi1WgqYKDJ4LirBKhvg2aS9kDeaFfYbR failed: invalid account data for instruction'
  ]
```
I would expect you to be able to see it somewhere, e.g. in the console if this is in the browser, etc.
Sorry, I mean the actual solana log, not the js part
yup seems to be the case
If that authority already signed from the client, then you're all good
that is the entire program log:(
I see - question then, if I'm CPI transferring from an account NOT owned by a PDA, I don't need to add `.with_signer()` do I?

In other words this should be ok?
```
impl<'info> WithdrawGem<'info> {
    fn transfer_ctx(&self) -> CpiContext<'_, '_, '_, 'info, Transfer<'info>> {
        CpiContext::new(
            self.token_program.to_account_info(),
            Transfer {
                from: self.gem_box.to_account_info(),
                to: self.gem_destination.to_account_info(),
                authority: self.authority.to_account_info(),
            },
        )
    }
}

pub fn handler(ctx: Context<WithdrawGem>, amount: u64) -> ProgramResult {
    token::transfer(ctx.accounts.transfer_ctx(), amount)?;

    Ok(())
}
```
Although, wait, can you post the entire program log?
yeah thats what we were sorta doing for ethereum, but i was kinda wondering if there was something more complex for rust.
Looking for something simple and solid if possible, will check this out. thanks alan
That error means the token program looked at an incoming account and was like "wtf is this" lol
My guess is that you aren't passing actual valid token accounts to the CPI somehow
I haven't really thought about this but I think you can just do what the token-swap program does, where you represent the percentage as a numerator and a denominator, and then do `starting_amount.checked_mul(numerator)` followed by a `checked_div(denominator)` https://github.com/solana-labs/solana-program-library/blob/master/token-swap/program/src/curve/fees.rs#L54
getting `Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: invalid account data for instruction`

when trying to transfer from one token account to another.

Googling past chat history didn't help ¯\_(ツ)_/¯

Any ideas?
absolutely no idea
cool, do you know where in code it does this percentage-based math?
https://twitter.com/wilbarnes/status/1466925043905142794?s=21
would be appreciated
<@!171442868190314497> you have links for these?
its a good read up. ties into decimal rounding im assuming for your purposes
the spl token had a bug(?) recently and jet was one of the few implementors that didnt suffer from it i believe
jet protocol
i have a program im making and i want to calculate a percentage of a token amount to the nearest smallest unit of the token
is there a program that uses percentages in any way?
Yeah, I'm not sure what to recommend—I would personally go digging into anchor's cli etc. to figure out what's going wrong, but not sure if you want to do that 😛
Mm, is your code in a git repo anywhere? It would be helpful to see exactly what's going on
what would your recommended course of action here be?
i did change the wallet field in [provider] to use a different keypair thats about it
no its in the root
Did you like move your Anchor.toml file around? I'm trying to think how that could happen
this is on wsl
or if i can deploy from a diff source...
is the path anywhere in .lock .toml files so i can change it?
Weird, no idea how that would happen (it should automatically go in target/deploy)
is there any way to specify target when calling anchor build?
it seems anchor build is putting the ```.so``` file in ```./programs/<name>/deploy``` dir but anchor deploy is trying to find it from ```./target/deploy```
now its become a path issue 😅  but thank you so much
your comment helped a lot
ah no i called anchor init --javascript
is your issue that you are cloning fresh anchor init and then running anchor test but it still fails?
so your program name (the name of the folder) has to match the program name inside cargo.toml
so inside <your project root>/programs/< your program name>/Cargo.toml
is it the project name in cargo lock that must match the entire project's name?
can you give an example of the program name and folder name? im a bit lost on the heirarchy here, apologies
My typescript bindings were broken for some reason
There was also a seperate issue which was that I cloned anchor fresh and ran anchor test and it didn't work, rn the temporary fix I had was to run anchor init --javascript
Ah yes that was a wonderful day of eating glass haha so make sure that your program is named the same as the folder it's in, make sure you only have one target folder, make sure declare ID matches what's inside anchor.toml
<@!800894271737561121> I see your issue from earlier about `anchor test` not being able to find the binary, but don't quite understand how you were able to resolve it. If you could help me out I would appreciate it, ty 😄
If some account is specified as payer it should be also specify as mutable (because its SOL balance may change)?


///////////////////////////////////////////////////////////////////////////////////////////////

Anyone know if calling create_associated_token_account fails if the account is already created? OR should I just do that part client side?
Thanks <@!134416332509675520> !
https://discord.com/channels/889577356681945098/891724485177245717/914888692672389200
There's been some discussion about this in the anchor-contributors channel, it's not entirely straightforward (not impossible, but a bit tricky)
You won't be able to set the mint authority like that yourself—in solana, *all* account mutations have to go through the program that owns the account in question. In this case, a mint will be owned by the spl token program, so you have to send an instruction to the spl token program asking it to do the mutation for you (check out `anchor_spl::token::set_authority`)
What I do set instead of None?
mismatched types
expected enum `COption<anchor_lang::prelude::Pubkey>`
   found enum `Option<_>`
```rust
        let mint = &mut ctx.accounts.mint;
        mint.mint_authority = None;
```
I only wanted the user that deployed the program to be able to run a certain function
What do you mean by the owner of the program?
I see now https://github.com/project-serum/anchor/blob/master/examples/tutorial/basic-4/programs/basic-4/src/lib.rs
O that is very helpful
not sure if this answers your q
the PDA is derived from the mint of the NFT, not from the token account holding it, which means when NFT trades hands, the metadata PDA remains valid (mint never changes)
hmmm what do you mean by "link token to account"?

the way NFTs work is you have a token account and a metadata PDA associated with it - more here https://docs.metaplex.com/nft-standard
Maybe when the token is traded they just close the account and create a new one in the program
Another dummy question, can I link a single token to an account? If that token is traded so would the account. Trying to figure out how these big brains created NFTs with actual information
is there something equivalent for fetching all token accounts owned by the program? Or do I go the manual route with `getProgramAccounts`?
How do I get the owner of the program from the Context?
for anyone looking in the future the `misc` example in anchor repo does it
this is perfect - is there an example somewhere with how to use filters? so far struggling to get them to work
Or you can look at its source to see how anchor does it: https://github.com/project-serum/anchor/blob/master/ts/src/program/namespace/account.ts#L221
Could you use `program.account.yourAccountType.all()`?
I think you can use memcmp while filtering out a particular PDAs from the set of  PDA accounts owned by the program
anyone have @solana/web3.js code example for signing transaction? without a 3rd party wallet
<:GM:898732035445760001>
how do I recreate anchor's discriminator hashing client side in js? Is there an example somewhere?

use-case: I'm pulling all PDAs owned by the program and I'd like to filter for just one type of state account. I wanted to use the discriminator for that
<@!134416332509675520> btw in case you might be curious this ended up being a TERRIBLE idea:D

I did some testing today - it works ok as long as all requests to the contract are sequential, bu as soon as you spam the contract with 100 Promise.all() requests what ends up happening is you'll have like 10 requests that read off the contract id being eg 1 and will go ahead and try to create a PDA with seeds [`nft_pda 2`]. but obviously 9 of those 10 will fail.

So yeah this approach is a no go ¯\_(ツ)_/¯

I have some hope for the other approach (using mints - which is also what metaplex is doing), hoping to rely on this fn to quickly find accounts - https://docs.solana.com/developing/clients/jsonrpc-api#getprogramaccounts
thanks I am going to check
for anyone getting this problem, please check typescript version that your vscode is using.
afaik not in anchor, but spl has in https://github.com/solana-labs/solana-program-library/tree/master/token/program-2022
Hi all .. is there any example out there of how to implement a minter program with emissions ?
Loader is deprecated (they're almost the same thing though, AccountLoader does ownership checking)
What is difference between Loader and AccountLoader?
Can you show your `derive(Accounts)` struct? I sort of thought you'd get a static error if you forgot to pass the associated_token_program, and not sure what other address you might have forgotten to pass
looks like I am running into stack space limitaitons haha I already boxed the account. 😭
Hi all, Im using https://github.com/project-serum/anchor/blob/7b86aed638ca2b86099ca0d839ddb264690c3c26/spl/src/associated_token.rs#L9 in an attempt to create an associated token account
However I kept running into this 
```
Instruction references an unknown account 6cxPpGR759McGNfkt4PnhkJmvoWvfUwaVvgzKei7kSf5
```
error. Ive logged out all the accounts I passed in, seems this publicKey is showing out of nowhere, anyone has ideas? 
Many thanks!!
Thanks your example is great!
Can see a slightly janky example of a program-controlled mint here: https://github.com/cqfd/anchor-token-studies
Almost. The authority would be set to some address derived from the program (not literally the program itself)—this is how you let the program sign for mint operations.
In that case, should an empty Mint Account be passed as part of the Initialize Instruction? And then its authority be set to the program?
Yep, that's definitively doable
Hi Channel, I have a question: can you initialize a Mint inside of a program? My intention is for this mint to be controlled by some program, instead of an external wallet


///////////////////////////////////////////////////////////////////////////////////////////////

also sry for the noob questions, feels much more hacky than the rest of anchor
so I would have this section twice, one for each program?
``` 
[[test.genesis]]
address = "9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin"
program = "./deps/serum-dex/dex/target/deploy/serum_dex.so"
``` ?
it's just the same syntax i think `address + program`
also, how do I best do it if I need to include two programs within genesis?
thanks <@!134416332509675520>
this worked
```const tradeNoBuffer = AccountsCoder.accountDiscriminator(
      foresightProgram.account.tradeNo._idlAccount.name,
    );

    const tradeYesBuffer = AccountsCoder.accountDiscriminator(
      foresightProgram.account.tradeYes._idlAccount.name,
    );

    const fetchMultipleAccounts = await axios.post(
      provider.connection._rpcEndpoint,
      {
        jsonrpc: "2.0",
        id: "1",
        method: "getMultipleAccounts",
        params: [
          parseData,
          {
            commitment: "confirmed",
          },
        ],
      },
    );

    const tradeNoArray = [];
    const tradeYesArray = [];
    fetchMultipleAccounts.data.result.value.forEach((item) => {
      const myBuffer = Buffer.from(item.data[0], item.data[1]);

      const tradeNo = myBuffer.compare(tradeNoBuffer, 0, 8, 0, 8);
      if (tradeNo === 0) {
        tradeNoArray.push(
          foresightProgram.account.tradeNo._coder.accounts.decode(
            foresightProgram.account.tradeNo._idlAccount.name,
            myBuffer,
          ),
        );
        return;
      }
      const tradeYes = myBuffer.compare(tradeYesBuffer, 0, 8, 0, 8);
      if (tradeYes === 0) {
        tradeYesArray.push(
          foresightProgram.account.tradeYes._coder.accounts.decode(
            foresightProgram.account.tradeYes._idlAccount.name,
            myBuffer,
          ),
        );
        return;
      }
    });

```
<@!867369388608061470> will put in a snippet of the code that worked for us
thank you for the link
I can filter later based off that
but the AccountsCoder thing worked
the memcmp didnt work
ok
but it's a bit tricky, we're getting there though. `AccountsCoder.accountDiscriminator` is a function i didn't know about, that should help
i thought it would have been easy for us to just print out the return value from `getAccountInfo` and compare it in the logs against the discriminator
Ah, haha, sorry, should have read more carefully
but clearly we're incredibly incompetent when it comes to the 5 different byte encodings (bytes, hex, stringify, u64, u58, etc.)
we're just trying to use the account discriminator to check which of the two accounts it is
we have a public key, we know it's one of two account types
lol, just to clarify what we're actually doing here
am i doing something wrong lol
```    const test = AccountsCoder.accountDiscriminator(
      program.account.tradeNo._idlAccount.name,
    );

    const lolTwo = await axios.post(provider.connection._rpcEndpoint, {
      jsonrpc: "2.0",
      id: "1",
      method: "getMultipleAccounts",
      params: [
        pie,
        {
          commitment: "confirmed",
          memcmp: {
            offset: 0,
            bytes: bs58.encode(test),
          },
        },
      ],
    });```
Wait, even with the memcmp? I'm confused
its returning all the accounts 😦
maybe 1.9 will fix the init size issue with PDAs
there will probably be some IDLs bigger than 10kb though
We need to be careful when changing that so as not to breaking existing clients like solscan.
Ah yes. Before I knew PDAs could hold data.
(That's how anchor's program.account.someAccount.all works under the hood)
Does the memcmp thing work? I posted a link above that passes a buffer to memcmp
yes and I dont know which data is correct or incorrect without brute forcing a bunch of complicated fetch requests right now 😂
Yeah, turns out the `decode` function actually ignores the discriminator (I think it assumes you've already decided to use the right version of it)
so I am trying to fix this
Hello, I dont have a base58 address. I only have a discriminator I know that is constant and I am not sure how to convert that into a base58 which is required for memcmp afaik. Secondly, I am able to decode different accounts with the wrong discriminator and it will give me invalid data but it will look like correct data
at least i think that's what I think the link above is referring to
Gotta love that `fetchIdl` function when trying to interact with a closed source program who uses Anchor
the IDL address on chain
What are you referring to?
It really would be lurking if it were already there I guess lol
Oh, right 😛
I'm guessing he is in the case where he interacts with a third party program rather than his own?
armani needs to update the IDL address thing, hopefully we can do it as a breaking change once v1
And yeah, the idl is already lurking in target/idl in your project's root directory
not sure about where the upload goes, but you can simply use this and write the JSON to a file: https://github.com/project-serum/anchor/blob/master/ts/src/program/index.ts#L316
It goes in this funny address: https://github.com/project-serum/anchor/blob/master/lang/src/idl.rs#L99
right, but i'm talking about `program.account.my_account.decode()`
isn't discriminator only a "thing" inside anchor? he's doing a simple rpc call, to which it's just bytes
i would have thought the discriminator at the start would prevent this
it's weirder than that. He's able to decode one account with two different account decoders
still curious about this one 👀
if all you're trying to do is pull accounts and discriminate them based on the account type, I had the exact same problem yesterday and solved it using this code:
```ts
    const pdas = await gb.program.account.vault.all([
      {
        memcmp: {
          offset: 8, //need to prepend 8 bytes for anchor's disc
          bytes: bank.publicKey.toBase58(),
        },
      },
    ]);
```
Have you tried using the memcmp api? https://github.com/project-serum/anchor/blob/master/ts/src/program/namespace/account.ts#L231
do they? fPzkrwRLo6qrw and eHOqIMrz5Aqrw
Feel like there must be some automatic rpc way to do this though, lol
So you could take the first 16 chars of the sha, lol, and turn it into base64 I guess
ah ok
Think it's just hex, not base64
honestly the weirdest thing about all of this is that we have two different account types and they both have identical bytes for the first 25 bytes or something
Or does sha256 return it in hex?
and then compare it to the raw bytes
yeh, but sha256 returns base64. So we should do Buffer.from() on the output of sha256
Can you ask the rpc thing for actual buffers, not base64 strings?
oh fuck
Hmm. Isn't it trickier than that? 🤔 base64 characters could take multiple per byte (1-ish but could be 2)
yeh, isn't it just the first 8 u64 characters of the sha256 hash
and I am just searching for when they are used again
isnt it just 7873aa2 and
7cfce4a
the parrot one fixes the problem in the dumbest way possible
How are you slicing the 8 bytes etc? I guess will be kind of annoying given the encoding used above
lol, no. You have to use my new one!
and when I decode it using tradeYes or tradeNo as an  assumption it fills out correct data for one, but almost identical data for the other but if you try to fetch with it will fail for one and not the other
😦 nothing matches though
Does anyone know where I can find this version ?
So you're looking for the account discriminators? They'd be the first 8 bytes of the account data (taken from the first 8 bytes of that sha256 hash)
i guess it makes sense to hardcode, since on mainnet it will be a completely separate contract
and you said one can then just call `use serum_dex::subcrate::etc`? or do i have to do CPI and specify the programId for each CPI
also, then i guess `anchor test` should take care of everything else, right?
ah got it, thx! 🙂 so much appreciated!!
<https://github.com/project-serum/swap/blob/master/Anchor.toml>
which part of these sha256 are supposed to match with the buffered data
here is le output: 

```
7873aa20caf3e40a95113e1644d9a1fe19945773d95e33f38ffd8a33455487fe
7cfce4af044ba3aaacf36850ea92edf386fe66536c2fab11bf2442a82d7cf4ce
{
  data: [
    'eHOqIMrz5AqrwZX07kKMnAWYeFj64Vb8kFLqfe6JAFAIpghT1TWvOv8AZmlyc3RfbWFya2V0ICAgICAgICBmaXJzdEV2ZW50ICAgICAgICAgIP///v3/',
    'base64'
  ],
  executable: false,
  lamports: 1496400,
  owner: '7oyrzFtYfb8RYGBJ3YgosEXGFe3ezR9NpgeLCnCpcSRX',
  rentEpoch: 0
}
{
  data: [
'fPzkrwRLo6qrwZX07kKMnAWYeFj64Vb8kFLqfe6JAFAIpghT1TWvOv0AZmlyc3RfbWFya2V0ICAgICAgICBmaXJzdEV2ZW50ICAgICAgICAgIP3//////v8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAExuO9DeYCFlCzPCArQPgpcV0fGr0YKQHv6pC0F3UcIyAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=',
    'base64'
  ],
  executable: false,
  lamports: 2178480,
  owner: '7oyrzFtYfb8RYGBJ3YgosEXGFe3ezR9NpgeLCnCpcSRX',
  rentEpoch: 0
}```
here is le code:

```    const getData = await axios.post(provider.connection._rpcEndpoint, {
      jsonrpc: "2.0",
      id: "1",
      method: "getMultipleAccounts",

      params: [
        arrayOfAccoutns,
        {
          encoding: "base64",
          commitment: "confirmed",
        },
      ],
    });
    console.log(sha256.hash("account:TradeYes"));
    console.log(sha256.hash("account:TradeNo"));

    getData.data.result.value.map((item) => {
      console.log(item);
    });
  };```
hello  I am stuck. I am trying to reverse look up an object based off the first 8bits in js
hmm didn't come across it... is it in the serum-dex repository? is it this file here: https://github.com/project-serum/serum-dex/blob/master/scripts/travis/dex-tests.sh where the `.so` file is deployed to anchor test?
ohhh didn't know you had to do that - yes it worked

question - where is this uploading the IDL?

and another one - is there a way I can store the idl somewhere locally in my front-end and point the program to it instead of fetching it remotely? that would save the trouble of uploading it every time
yup, first I had to change deserialization from `AccountInfo<'info>` to `Account<'info, TokenAccount>` - that then led to another, more specific error, which pointed me to the fact that a token account wasn't initialized

TLDR make sure all your token accounts are initialized properly
you compile the other programs, load them at genesis, and in your contract import them as external crates
have you seen how serum/swap repo does it with the serum program?
any other, more elegant ways you can think of / came across?
easiest thing that comes to my mind is to deploy the partner contract on devnet, and run the tests on devnet with hard-coded contract addresses
hey guys, any idea how to most elegantly do anchor test with multiple, separately deployed contracts? I have one project that I am trying to hook up to a partner-project
Did you actually upload the IDL with `anchor idl init`?
hello everyone. got a question about the idl. What are some of the possible reasons that a struct will not be included in the generated idl .json file? I have a zero-copy, account struct referenced by an instruction via AccountLoader. I'm attempting to call program.accounts.fetch on it but i'm unable to get a reference of the struct
I saw through the thread, seems like you figured out what was wrong for you. Can you share what it was or point me to it if its already shared?
I'm trying to connect solana's wallet adapter to anchor and I'm stuck with fetching the idl.

Here's the code:
```ts
const idl = await anchor.Program.fetchIdl(programId, this.provider);
this.program = new anchor.Program<GemBank>(idl as any, programId, this.provider);
```
for some reason `idl` comes back as `null`

when I console log the provider and the programId I get:
- provider is connected to  `https://api.devnet.solana.com`
- programid is `EnJJ3BxBE3oZZMvBVqg8K9bSnGb7VREpPbZYuHEWLg1n`

the program clearly exists on devnet - https://explorer.solana.com/address/EnJJ3BxBE3oZZMvBVqg8K9bSnGb7VREpPbZYuHEWLg1n?cluster=devnet

what might I be missing?
Thanks You
I will try that out <@!830210968171839489>
For your particular example
```
&[&[
        ctx.accounts.offer_maker.key.as_ref(),          
        ctx.accounts.nft_mint.to_account_info().key.as_ref(),
        &[offer_bump]
]]
```
It's supposed to be the following format
```
&[&[&b"Xval"[..], &b"YVal"[..], &[nonce]]]
```
`error[E0308]: mismatched types
   --> programs/quidproquo/src/lib.rs:149:17
    |
149 |             &[&[[ctx.accounts.offer_maker.key.as_ref(), ctx.accounts.nft_mint.to_account_info().key.as_ref()], &[offer_bump]]]
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected &[u8], found array [&[u8]; 2]

error: aborting due to previous error`
Basically passing signer seeds whats the correct syntax to do it
Hey everyone, how would I go about calling instructions from the same program?
Ya I guess if I have a master list of all the token accounts I can lookup their owners, and if the owner is my contract, then I can look at the last transaction... that right?
(Thank alot for your help btw, your awesome!)
Okie dokes
Well, I can just set a low max per user and use an array or vec then...
But of larger concern now is how do I get a list of all the users that have staked NFTs through my contract?
Should I make a PDA to track them? or should I instead do something weird like lookup all the NFTs i minted and look at their Owner or last transaction?
So you'll end up allocating just 4 bytes, since borsh uses 4 bytes at the beginning to encode the length of the vec that follows.
Not enough 😛 Using `Default` for variable size things is a bad idea, since their default will be empty.
Hmm if I use a Box<Account<'info, MyStruct>> and then have a Vec<Pubkey> in MyStruct, and I never specify "space"... how much does it allocate by default?
Ya I need to be able to lookup set of specific staked NFT accounts for a given user PubKey, that way I can lookup their jpegs to display and other info.
Or do you need to know which one it is?
I should get better intuition for compute budget
How about doing +1 when they stake another one and -1 when they unstake
Can you just loop through?
Currently you only get one shot to allocate the right amount of space, but sounds like that will change in solana 1.9.0
(lol, maybe I just track the number of NFTs theyve staked and block them at 500... that way I can use my simple HashMap. But I am curious what the full solution to this is...)
Ah ok, I was trying out HashSet<PubKey> inside of an account with Box<Account<'info, UserStakeAccount>>...
But this allocates to the heap and will potentially overflow...

My use case is that users can stake NFTs for gov tokens. I have a PDA per user per NFT that tracks staking / unstaking events so I can calculate total time staked ~ their earned tokens.
But I also need a way to quickly lookup all of the staked NFTs assocaited with a users PubKey... hence the HashSet. Is there a better approach to this?
If I wind up going with arrays + zero_copy/AccountLoader stuff, can I have users pay for only the space they use?
Meaning in general if you really need that much space you're going to have to use arrays + zero_copy/AccountLoader stuff.
5k pubkeys = 5k * 32 = 160kb, which is way larger than solana's 32kb heap. So array it is 😛
there aren't that many data structures, you have array or vec
(most common use case is probably just 1 Pubkey in the set, but some will have hundreds or more...)
(the keys will be added one at a time by users)
I need a PDA which stores a set of PubKeys... up to a theoretical maximum of 5k. What data structure should I use?
Account<'info, Bla>, Bla being a #[account] in your program
Yes, it should, ty 🙌
alright got it! Thanks guys
Ah, got it—yeah, can find it in the `generate_init` function
changelog helps with this, it often includes the pull request id
the best way to find stuff is to look up the commit /pull request where the feature was added
the layout of anchor source is pretty confusing (imo)
> Yeah, init_if_needed does that "does this already exist" check.
Im actually just trying to find where this is done haha
I'm actually curious what you expected it to do, maybe the name is weird?
ohhh
yes understand, but I think `init_if_needed` also take me here https://github.com/project-serum/anchor/blob/master/lang/syn/src/codegen/accounts/constraints.rs#L456, just that ```ConstraintInit { if_needed: true }```
Yeah, init_if_needed does that "does this already exist" check.
it's different from straight `init`
`init_if_needed` will only "initialize if needed"
Based on this there should be an error, if I actually pass in an initialized account into `init_if_needed` constraint?
> If it goes to create the account but one already exists the system program will give an error
> Though maybe there is some other layer of error checking, I'm not sure
why would it show an error?
so lets say if I use the `init_if_needed` constraint, Im expecting even if the account is initiated, the handler still wont show error (also aligned with my observation). hmm Maybe I need to find where that error checking is done
Though maybe there is some other layer of error checking, I'm not sure
If it goes to create the account but one already exists the system program will give an error
Generally speaking if you're calling with the init constraint, anchor assumes the account is empty and tries to create it
Hi guys, so since I'm quite curious about the anchor framework, I dug in ... got a question here to ask, in this block https://github.com/project-serum/anchor/blob/master/lang/syn/src/codegen/accounts/constraints.rs#L456 for initializing associated token account, is there a place where the framework tries to check the account existence first? It seems like here it's merely trying to call the associated token program. Many thanks!
Nice! Yeah, that looks about right—although shouldn't the owner be `spl_token_metadata::ID` or something, not `spl_token::ID`?
<@!788122420765917184> I got this to compile and it look about right? Thanks a lot for your help 🙏
```#[derive(Clone)]
pub struct Metadata(spl_token_metadata::state::Metadata);

impl anchor_lang::AccountDeserialize for Metadata {
    fn try_deserialize(buf: &mut &[u8]) -> std::result::Result<Self, ProgramError> {
        Metadata::try_deserialize_unchecked(buf)
    }

    fn try_deserialize_unchecked(buf: &mut &[u8]) -> std::result::Result<Self, ProgramError> {
        let md = spl_token_metadata::utils::try_from_slice_checked(
            buf,
            spl_token_metadata::state::Key::MetadataV1,
            spl_token_metadata::state::MAX_METADATA_LEN)?;
        let metadata = Metadata(md);
        Ok(metadata)
    }
}

impl AccountSerialize for Metadata {
    fn try_serialize<W: Write>(&self, _writer: &mut W) -> std::result::Result<(), ProgramError> {
        // no-op
        Ok(())
    }
}

impl Owner for Metadata {
    fn owner() -> Pubkey {
        spl_token::ID
    }
}

impl Deref for Metadata {
    type Target = spl_token_metadata::state::Metadata;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}```
Ok, I will study it now.
https://docs.rs/anchor-spl/0.17.0/src/anchor_spl/token.rs.html#299
i think you might take inspiration from how `Mint` and `Token` are wrapped in `Anchor`
You should write the logic for deserialization, so it is accessed properly
I tried: `pub struct MyMetadata(Metadata);` but then its accessed using metadata.0, which i don't think will deserialize properly... should i wrap it another way?
You can wrap `Metadata` into your own type and implement those traits for it instead, or you can open an issue in their project and ask to implement (possibly as an optional flag) those traits there instead, maybe there are some defined already, actually
I tried implementing the trait but then I got error: cannot implement trait on struct not defined in this crate. This must be a common use case right? I just need metadata of an nft to verify it is part of a particular collection.
```103 |     pub nft_metadata_pda: Account<'info, Metadata>, 
      |                           ^^^^^^^^^^^^^^^^^^^^^^^^ the trait `anchor_lang::AccountSerialize` is not implemented for `spl_token_metadata::state::Metadata`
```
How do I pass a metaplex Metadata PDA into anchor accounts ctx?
Goo day! Is there a shorthand for verifying that an account is owned by my `program_id`?
https://tenor.com/view/ugh-whatever-alan-the-hangover-hair-flip-gif-5139754
Thank u good ppl
He’s Alan
I'm just funemployed lol (and like jumping to source)
who r u
dude how do u know all this stuff
VScode + rust-analyzer
Which IDE do u use?
Yeah, can see by hopping to source that it's just building some `invoke_signed` calls for you
ohhh i thought it was separate 😮
anchor_spl::token isn't a separate program, it's just some helper functions for talking to the spl token program
how does it know to do CPI? is it doing it to spl-token or anchor_spl::token?
Rent for the token account is payed for by the `initializer`.
The account lives at a program-derived address derived from your program, with those seeds and bump.
That's initializing an spl token account with that `mint` and with owner set to the `initializer`. It's making a cross-program invocation to the spl token program after allocating an account with the right amount of space etc.
Is it hitting spl-token or anchor_spl::token or neither?
What's happening under the hood?
Or if someone could just explain 🙏
Where can I read documentation about the last two parameters of `account(...)` here do?

```
    #[account(
        init,
        seeds = [b"token-seed".as_ref()],
        bump = vault_account_bump,
        payer = initializer,
        token::mint = mint,
        token::authority = initializer,
    )]
    pub vault_account: Account<'info, TokenAccount>,
```
Well, ok, someone else should chime in (I just debug stuff, I don't actually deploy anything—don't trust me)
Using anchor deploy or anchor upgrade?
Just make sure you've rebuilt with the correct id, and then redeploy
Without spending a fortune on redeploying it.
I've found out the "Why", the question now is "How"
No no. declare_id is different .. I've found out the issue.
Did you use a different id on mainnet vs devnet?
At any rate, not sure if the anchor build thing is the actual cause of your issue, but it has come up many times before, so I'm suspicious it could be
So, what should be the right command for solving declare_id bugs then?
Ok, anchor upgrade just redeploys
Yeah, I would normally use anchor build, and then anchor upgrade
Actually let me refresh my memory about anchor upgrade
Well, you need to `anchor build`
That won't cost an additional 5 sol I don't think 🤔 Since you've already rented that space
So like I don't have to anchor upgrade?
Oh really?
You can just redeploy
😦
I just wasted like 5 SOL
Common gotcha is editing your declare_id! and then rerunning `anchor deploy`—without rerunning `anchor build` first! That will deploy the stale .so file with the wrong id :/
167 is account not owned by program
You probably didn't update the program id in declare id
Would really be helpful if someone could shed some light on the same.
The scripts, Keypair generation, everything is literally the same. Only thing that's changed are the program ids and the connection endpoint.
Hey, I just have a quick emergency issue. I deployed a program on devnet and ran a script, and it worked just fine. But when I deploy the same program, over mainnet. It's erroring out as 0xa7. Any ideas why is that happening?
Correct.
To use the accounts DB postres exporter, one has to run a validator correct?
Favor PDAs and other read stores, e.g. the accounts DB postgres exporter.
Not efficient. If possible, don't use it at all.
Does anyone know how efficient  `getProgramAccounts` with `memcmp` is at scale? If a program has millions of program accounts, does the mem-compare search take a linear scan/filter approach?
make an ido with it to pay for the audit? 😀
Someone has to take the plunge and try something new though eventually
People only seem to want to use the parrot fixed version, just because everyone else has already used it
hell yea! Got it working. Thanks for the help today <@!134416332509675520>  <@!707604162673639504>
Someone should pay to get this audited lol.
I think it's decent
But hopefully it's better than the previous version!
I wrote this, it's not been audited
Thanks for your help 🙂
I understand its not audited but if these examples are not security proof then this is a serious issue IMHO
haha i think it was! for sure, so do with that what you will 🙂
I thought this code was built by armani (<3) so I could be confident about the way security was managed
Understood
afaik no such assurances can be made, those are examples only and do not come with any audit guarantees
https://github.com/project-serum/anchor/tree/master/tests/ido-pool
I just wanted to confirm that code in the anchor repo examples folder is free of security breach
Hello, I hope everyone is well
Aye Aye chief
The program will need to know them, yeah (sometimes they're guessable some other way, but in general you might need to pass them in as ix arguments and use the `#[instruction(...)]` macro—try searching the anchor codebase for examples)
ack, I think I do
Do I need to pass the seeds into the program?
Yep, it will fail if you try to create an account that already exists—you either need to check client-side or check within your program
I am thinking of just using the JS tools to handle this client side. https://github.com/solana-labs/solana-program-library/blob/edc6be2ae5d0c64abe06efa7656e1e99488a5548/token/js/examples/create_mint_and_transfer_tokens.js
I have the same question. Would appreciate any guidance
haha I actually wondered whether it was account or address when I wrote that! thanks for correcting ser 🤜🤛
This is big breakthrough moment
ahhh
`findProgramAddress` is deterministic based on the seeds + programId—use the same arguments and you'll always get the same address back
You need to use different seeds for each mint, like `[Buffer.from("first one")]`, `[Buffer.from("totally different mint")]`, etc.
GAH
Right, there you're using the same seeds ([]) over and over again
```javascript
  it('Creates the token mint', async () => {
    const [mint, mintBump] = await anchor.web3.PublicKey.findProgramAddress([], program.programId);

    const ourAssociatedTokens = await spl.Token.getAssociatedTokenAddress(
        spl.ASSOCIATED_TOKEN_PROGRAM_ID,
        spl.TOKEN_PROGRAM_ID,
        mint,
        program.provider.wallet.publicKey
    )

    // only initialized the first time?
    await program.rpc.initMint(mintBump, {
        accounts: {
            mint: mint,
            payer: program.provider.wallet.publicKey,
            destination: ourAssociatedTokens,
            systemProgram: anchor.web3.SystemProgram.programId,
            tokenProgram: spl.TOKEN_PROGRAM_ID,
            associatedTokenProgram: spl.ASSOCIATED_TOKEN_PROGRAM_ID,
            rent: anchor.web3.SYSVAR_RENT_PUBKEY
        }
    })
  });
```

You can, you just need to use a different address for the new mint
Well, when I create a mint in my program, it seems I can't create a mint again
Maybe I'm misunderstanding your question though 🤔
Each nft has its own mint!
*a program
interesting, so how do homies create a bunch of nfts from a smart contract?
Once you've made an account at some address, yeah, you can't create another one at the same address
On my long list of dumb questions, it seems I can only create a mint once in a program. Am I just doing something wrong? My current goal/exercise is create a mint, mint a token and create some metadata for that token
then yeah, a `Account<'info, MyThing>` will be owned by your program.
Anytime you do
```.rs
#[account]
pub struct MyThing {
  ...
}
```
Hopefully this is fun-pedantic and not pedantic-pedantic lol, but it's a program-derived *address*—the account itself is basically completely independent of the type of address it lives at (people get quite confused about this)
"program derived account"
PDA yeah
o wait, is an account by default owned by the program?
<:room_temp_iq:797341877111095316>
Do I create an account for the metadata and make the owner somehow be the mint?
hmm, I'm still confused on this PDA
ok, got it
i don't entirely know how it applies to constants in the IDL
use camel case in js and snake case in rust
that's expected
I found what I think is a little bug:

when I name my state struct all capitals, and try pulling it using  `program.account.XYZ.fetch()` client-side, I get `Error: Invalid account discriminator` 

as soon as I rename the struct NormalCase, the error goes away

should I submit an issue on GH or is this known/expected? <@!134416332509675520> <@!248066053161222144>
if it wasn't paying, it wouldn't be mut
it's mut because it's paying for stuff, which means the lamports balance on the account needs to be adjusted down
I've noticed that the Signer is always `mut`, but we don't even modify it. So why is it `mut`? Tutorial link: https://project-serum.github.io/anchor/tutorials/tutorial-2.html#defining-a-program

```
#[derive(Accounts)]
pub struct Create<'info> {
    #[account(init, payer = user, space = 8 + 40)]
    pub counter: Account<'info, Counter>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```


///////////////////////////////////////////////////////////////////////////////////////////////

another related question though - is there a similar function to close a non-token PDA?
LOL this is karma - as soon as I posted I realized the problem... I spent 2h changing every possible parameter for the PDA only to forget to add `#[account(mut)]` to the receiver's account (where sol will be deposited).
full logs:
```
logs: [
    'Program CAC7ta8MG92tLrMZSCWHYub2WYDAVvvQvY8frFi2R3HN invoke [1]',
    'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [2]',
    'Program log: Instruction: Transfer',
    'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 3121 of 182815 compute units',
    'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success',
    "Fks3e5UM7hpw9SQQJhwrDVPWy8QQrYkJhWueE9Ts5Gbj's writable privilege escalated",
    'Program CAC7ta8MG92tLrMZSCWHYub2WYDAVvvQvY8frFi2R3HN consumed 200000 of 200000 compute units',
    'Program CAC7ta8MG92tLrMZSCWHYub2WYDAVvvQvY8frFi2R3HN failed: Cross-program invocation with unauthorized signer or writable account'
  ]
```
stuck with `Cross-program invocation with unauthorized signer or writable account'`

I'm trying to close a PDA token account owned by my program, after all the tokens have been withdrawn.

accounts:
```rs
    pub authority: AccountInfo<'info>,
    #[account(mut,
        seeds = [
            b"gem_box".as_ref(),
            vault.key().as_ref(),
            gem_mint.key().as_ref(),
        ],
        bump = bump,
    )]
    pub gem_box: Account<'info, TokenAccount>,
```
and code:
```rs
    fn close_context(&self) -> CpiContext<'_, '_, '_, 'info, CloseAccount<'info>> {
        CpiContext::new(
            self.token_program.to_account_info(),
            CloseAccount {
                account: self.gem_box.to_account_info(),
                destination: self.receiver.to_account_info(),
                authority: self.authority.clone(),
            },
        )
    }

    if gdr.gem_amount == 0 {
        token::close_account(
            ctx.accounts
                .close_context()
                .with_signer(&[&vault.vault_seeds()]),
        )?;
    }
```

I've been following the example here - https://github.com/jet-lab/jet-v1/blob/master/programs/jet/src/instructions/close_deposit_account.rs#L141

I don't think the seeds are wrong because the exact same seeds work inside the same instruction to tranasfer the tokens out (before trying to close the account)

what else might I be missing?
Works like a charm, thanks!
Because you're missing an argument you'll end up using nonce = 1 since that was the actual first argument
Not the first thing I wrote
Oh, sorry, I can't read—your problem is probably what I just wrote
Ah, also, you need your `#[instruction(...)]` arguments to match the ix function arguments! You've got `amount` and `nonce`, you'll need both of those in the instruction thing, same order and types, etc.
Seems like the passing-in part is working fine, but yeah, you don't get to pick the bump—you calculate it with `PublicKey.findProgramAddress`
Can someone help me figure out what I'm doing wrong while trying to pass in a bump seed from client?
```javascript
    const nonce = new anchor.BN(bumpSeed);
    console.log("Nonce: ", nonce);
    const holdIx = program.instruction.hold( new anchor.BN('1'), nonce, {
 ```

Program:
```rust
    pub fn hold(ctx: Context<Hold>, amount: u64, nonce: u8) 
...
#[derive(Accounts)]
#[instruction(nonce: u8)]
pub struct Hold<'info> {
    #[account(
        init_if_needed, 
        seeds=[user.key.as_ref()], 
        // bump,
        bump={ msg!("Nonce is: {}", nonce); nonce},
        payer=user, 
        space = 8 + 32*2 + 8
    )]
...
``` 

Outputs are: 
```
Nonce:  <BN: ff>
Program log: Nonce is: 1
Error: Could not create program address with signer seeds: Provided seeds do not result in a valid address
```
this makes it work, no more errors. Thanks so much! 🙂
You'll in general have to think of a good value though
Ok for now just try something easy like 5000
I had a much higher amount before because at some point I thought the errors were due to not assigning enough space - like I said shooting in the dark
```Rust
#[derive(Accounts)]
#[instruction(locked_bag_bump: u8, user_nft: SomeNFT)]
pub struct Initialize<'info> {
    #[account(init,
        payer = user,
        seeds = [b"unbundle_program".as_ref(), &user.pub_key.to_bytes()]
        bump = locked_bag_bump,
        space = 64 + 64
    )]
    pub locked_nft: Account<'info, LockedNFT>,
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```
Default won't work here because you have variable-sized things (those Strings)
Basically I would get rid of all of those `Default` things, and assign space manually (annoying but easier to understand)
When did you assign too much space?
It may have occurred because I assigned too much space
Not really sure where it originates from to be completely honest. Sorry for shooting in the dark here, a lot of this is new to me
I'm confused
So how did you get that 10kb space error?
Ah, no, that shouldn't be a problem—though that Default there will be kind of useless, since the default for a string is ""
Maybe this just isn't possible then?
```Rust
#[account]
#[derive(Default)]
pub struct LockedNFT {
    pub authority: Pubkey,
    pub nft: SomeNFT,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug, Default)]
pub struct SomeNFT {
    id: u64,
    traitA: String,
    traitB: String,
    traitC: String,
    ...
}
```
Yeah, it's a struct that holds 6 String properties - I think that's the issue
ah
This is unfortunate but there's currently a limitation in solana that implies that PDA accounts can only be 10kb
Ah, lol, is your LockedNFT account huge?
```
  logs: [
    'Program EL94av2wtupKcZpJLFbAkrvLBeK9LUoEHzanvJi9zwak invoke [1]',
    'Program 11111111111111111111111111111111 invoke [2]',
    'Program 11111111111111111111111111111111 success',
    'SystemProgram::CreateAccount data size limited to 10240 in inner instructions',
    'Program EL94av2wtupKcZpJLFbAkrvLBeK9LUoEHzanvJi9zwak consumed 200000 of 200000 compute units',
    'Program EL94av2wtupKcZpJLFbAkrvLBeK9LUoEHzanvJi9zwak failed: Failed to reallocate account data'
  ]
```
I think that solves it! I just need to allocate the correct amount of space for it to work
yeah, let me try real quick
https://discord.com/channels/889577356681945098/889577399308656662/918187915480285205
I don't think you're passing the seeds correctly in JS, have you tried that suggestion above?
But sure
Maybe `user.key().as_ref()`
it should actually look like this:
```Rust
#[derive(Accounts)]
#[instruction(locked_bag_bump: u8, user_nft: SomeNFT)]
pub struct Initialize<'info> {
    #[account(init,
        payer = user,
        seeds = [b"unbundle_program".as_ref(), &user.pub_key.to_bytes()],
        bump = locked_bag_bump,
    )]
    pub locked_nft: Account<'info, LockedNFT>,
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```
I mean syntactically, in the rust code—where is that variable coming from?
one sec
oh I see what youre asking
it's just this before the test:

```TypeScript
const provider = anchor.Provider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.Unbundle;
```
Also yeah, maybe should be [Buffer.from("unbundle_program"), provider.wallet.publicKey.toBuffer()]
np
Ah, sorry, where does &pub_key come from in the snippet above?
Error may be from line 5
```TypeScript
const someNFT = { id: 1, traitA: 'some trait', ... };
before(async () => {
    [lockedNFTAccount, lockedNFTAccountBump] =
      await anchor.web3.PublicKey.findProgramAddress(
        [Buffer.from("unbundle_program", provider.wallet.publicKey)],
        program.programId
      );
  });

it("Initializes", async () => {
    await program.rpc.initialize(new anchor.BN(lockedNFTAccountBump), someNFT, {
      accounts: {
        user: provider.wallet.publicKey,
        lockedNFT: lockedNFTAccount,
        systemProgram: anchor.web3.SystemProgram.programId,
      },
    });
```
Yeah, although something is going wrong when anchor tries to sign for that PDA (in order to create the account there)
Hmm, are you sure you're passing your seeds correctly on the client? Can you show the JS code?
So my understanding is that the program owns the `locked_nft` PDA since it initializes it and therefore can write to it
user is the provider.wallet, yes
hmm, I don't think I am. I'm trying to do the simplest thing just to get it running:

```rust
pub fn initialize(ctx: Context<Initialize>, _locked_nft_bump: u8, user_nft: SomeNFT) -> ProgramResult {
        let signer_key = ctx.accounts.user.key();
        ctx.accounts.locked_nft.authority = signer_key;
        ctx.accounts.locked_nft.nft = user_nft;
        Ok(())
    }
```
And who is the user here? The provider.wallet?
Usually if you look carefully in the program log output you can see something about either a signer issue or a writable privilege issue
Ok, are you doing any subsequent signing for that PDA? Like, any other cross-program invocations?
this error is produced: `Cross-program invocation with unauthorized signer or writable account` though
that works to eliminate the error I was receiving 🙂
So no right-hand side or equals sign
As a quick experiment, what happens if you replace that `bump = ` constraint with just `bump,` ?
I have a question related to PDAs. I'm attempting to write a program that "unbundles" an NFT - which just means taking each individual attribute of the NFT and creating a new mint for the respective attribute. To rebundle, you would need to pass the correct information back to the contract.

My thinking is to use a PDA to map the metadata of the original NFT back to the user. so a seed/key would be like "unbundle_program:{UserPubkey}:{NFT_ID}" (originally I wanted to use a string of all the attributes as part of the seed, but this seems to be too long"). 

When I try to use the following code snippet, I get the error: `Could not create program address with signer seeds: Provided seeds do not result in a valid address`:

```rust
#[derive(Accounts)]
#[instruction(locked_bag_bump: u8, user_nft: SomeNFT)]
pub struct Initialize<'info> {
    #[account(init,
        payer = user,
        seeds = [b"unbundle_program".as_ref(), &pub_key.to_bytes()],
        bump = locked_bag_bump,
    )]
    pub locked_nft: Account<'info, LockedNFT>,
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[account]
#[derive(Default)]
pub struct LockedNFT {
    pub authority: Pubkey,
    pub nft: SomeNFT,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug, Default)]
pub struct SomeNFT {
    id: u64,
    traitA: String,
    traaitB: String,
    traitC: String,
    ...
}
```
It's just using sha256 under the hood.
Yeah—it's not impossible but it's extremely unlikely.
i suppose, based on the properties of it being a pre-resistant hash function, it should be so
thanks!
https://github.com/project-serum/anchor/blob/master/ts/src/error.ts
like 0x1c etc
is there a list of all non-custom program error codes?
is it guaranteed that the same PDA cannot be generated using a different pair of seeds?
thanks! 🙏
interesting! I'll take a look of that
to be sure rust doesn't move around fields
I would also add #[repr(C)]
``` #[account]
pub struct Counter {
  pub authority: Pubkey,
  pub count: u64,
}```
yes
mmmm, just thinking about it, the order should be how the `struct` is defined, right? I got this one:
oooh! I think I got it now, so the offset starts at `8` because the first 8 bytes references the discriminator, and the next one should be the pubkey (32 bytes). Is there any documentation that points out what is what within this bytes array? thanks!  🙏
if you do a get program accounts but looks for something else, then offset would be something else
in his case he is looking for some specific data, so the first 32 bytes after the disc to be the pubkey
I was having the same issue and your comment saved my ass, thanks! 🙏  - in which cases `offset`  would be different than `8` ? I'm a bit confused about that
Yeah, no idea why that wouldn't work (hard for me to imagine how it couldn't)
Ah, sorry 🤦‍♂️
And passing that data struct into it, https://docs.rs/spl-token-metadata/latest/spl_token_metadata/instruction/fn.update_metadata_accounts.html
No I am just trying to clone a strings value, and initialize another string that has that strings value plus another string ("--locked"), I am then passing that into the uri field for the update token metadata accounts. I am using the update_metadata_accounts endpoint
If so, definitely can't do that—in general in solana an account's data can only be mutated by its owning program, which in this case will be metaplex. If you want to mutate that account's data you'll have to find some way to ask metaplex to do it for you (via a CPI).
Just to make sure I'm reading right, are you trying to directly mutate the token metadata?
You should have a read over the new contract and test it out on dev net
Now the signer and the accounts all need to be from the same IDO in order to be valid
The issue is that the first contract wasn't using PDAs, so it was possible to use the same signer from a different IDO to drain funds
How would I go about adding the custom error message  (when using `#[error]`) to the program logs whenever an error is thrown?
https://blog.neodyme.io/posts/solana_common_pitfalls#integer-overflow-%26-underflow
devnet down? 👀
for reference that uri field works when I put in "randomstring".to_string()

never thought it would come to this but I cant seem to change the uri to another string in the following code for the Data struct, for context it gets slapped into update_metadata_accounts a metaplex function
basically i have several PDA accounts im going to pass in and then i want only one of them to be created based on some conditions, thats why i asked this, because i was going to create them with solana native code but then id miss out on borsch stuff
im going to initialize and account myself and store the data manually, how can i structure the data so that anchor can read it and deserialize it later, do i need to do some zero-copy stuff? (is there a specific example for this scenario)
Have you looked at the workshop materials from that neodyme video? https://workshop.neodyme.io/
Thanks for your help and your time ❤️
also, is the a documented description of the issue found by the parot team (if my memory is good) on the first version of the mango IDO contract ?
But I wanted to know if there are other ressources available
https://www.youtube.com/watch?v=vbkhhgeP30I
And of course this
https://research.kudelskisecurity.com/2021/09/15/solana-program-security-part1/
I came across this
Especially if its in the context of Anchor
I'm searching for anything that can be related to the security of the smart contracts
Hey guys I hope everyone is well
Probably yeah
so that's it ?? 
the public key that I need is that one ?
So `resp.value[0].pubkey` I guess
What are you wondering about? You're fetching a token account there, yeah—it's address is the `pubkey` part
that i get not a public Key
this is the output

Not totally sure I understand your question, but in solana when you send tokens, you have to send them to a token account (you can't exactly send them to a *person* per-se, just a token account "owned" by that person/wallet)
just want to understand what's the TOKEN_ACCOUNT here ?
exactly
So you're trying to send some tokens somewhere?
my problem , is that i don't understand from where to get the DESTINATION_TOKEN_ACCOUNT exactly
Quite possibly—best to just ask your question and then people will help out as they can!
hello can anyone help me with web3 js library ?
It's minting! Thanks a lot!
I think I get it. So if the seeds are empty I would pass this to the cpi:
`let seeds = &[&[], &[authority_bump]];`
You're basically purely using that address as a signer, so no need to pay rent etc. (Even zero-space accounts pay a little bit in rent.)
You'll just need to know whatever seeds+bump it has so you can subsequently sign for it
Interestingly you actually don't even need to `init` it at all, you can just pass it in!
Would this be the idiomatic way to init that account?
```
#[account(init, payer = payer, space = 0, seeds = [], bump = auth_bump)]
authority: AccountInfo<'info>,
```
If I set the update authority to a PDA though, it can't be changed though yes?
https://gist.github.com/ronanyeah/b91cdf071b83ca1e0256909ad581c2e5
I think update authority is probably the wrong thing to do since anyone can set it and so you can get fakes if you query based on that.
There's no great way to do that currently. Hardcoded lists are the way to go I think. That or checking the verified creators array.
I am still learning what the right way to get all the NFTs in a collection is. I have a nodejs script that works, based on update authority but its fairly gnarly, and I doubt it works for every collection. I'll put it in a gist
Which is what `exiled-apes/candy-machine-mint` seems to be allowing 😬
My smart contract/program will be setting the update authority, not the frontend
Anyone can set that address right? If that's the case, then that seems like a dangerous pattern to promote.
What's the motivation? So that you can query based on update authority?
Ah, interesting—not sure, I'm not familiar enough with nft stuff I think, but that's an interesting thing to consider
To be used kind of like an ERC721 contract address etc
BTW I have no intention of updating anything, but for my NFTs to be more 'discoverable' it's better if they share an update authority right?
(Otherwise you'll need to pass the authority PDA as an account)
If you make the mint it's own authority then you don't even need to pass in any other account—you just need to use its seeds+bump in the CPI
Oh sweet, ok thanks a lot, I'll let you know if I get it working
Or in this case you could even say `mint::authority = mint`, because the mint's own address is a PDA (sort of sneaky, but also fun)
So, e.g. you could use a single mint authority with `seeds = []`
Ok, you would want the mint authority to be any program-derived address derived from your program
So `mint::authority = my_authority` would be great if I could get it to work
Ah, ok, so the part I'm confused by is the why the mint authority is the payer (not necessarily incorrect obviously, just slightly confusing)
Here's the init:
```
#[account(
    init,
    payer = payer,
    seeds = [&config.count.to_le_bytes()],
    bump = mint_bump,
    mint::decimals = 0,
    mint::authority = payer
)]
mint: Account<'info, Mint>,
```
Mm, not necessarily—is the mint already initialized?
I want to have update authority, but it looks like `mint_to` expects the authority to sign the tx
I want users to initiate/pay for the `mint_to` tx, which requires them to sign the tx
(So, why would you need to change the authority?)
Wouldn't they have already signed from the client?
Ah, so the current authority over the mint is the payer?
Thank you. I'm weighing up a PDA vs just changing the update auth inside the program function straight after `mint_to`:
```
anchor_spl::token::set_authority(
    CpiContext::new(
        ctx.accounts.token_program.to_account_info(),
        anchor_spl::token::SetAuthority {
            current_authority: ctx.accounts.payer.to_account_info(),
            account_or_mint: ctx.accounts.mint.to_account_info(),
        },
    ),
    spl_token::instruction::AuthorityType::MintTokens,
    Some(admin_wallet),
)?;
```
Yep, if you want the program to sign then it'll have to be a PDA.
Yes, the authority will need to sign (either from the client if it's a keypair address or here, from within the program, if it's one of your program's program-derived addresses)
Or maybe its possible for the authority to be a PDA?
Does anyone know here if I need the authority account to sign the transaction here? I'm getting `Cross-program invocation with unauthorized signer or writable account` if the authority is not the payer/signer account. I want users to initiate the mint TX but I want the update authority for NFTs to be an account I control
```
let mnt = anchor_spl::token::MintTo {
    mint: ctx.accounts.mint.to_account_info(),
    to: ctx.accounts.destination.to_account_info(),
    //authority: ctx.accounts.authority.to_account_info(),
    authority: ctx.accounts.payer.to_account_info(),
};

anchor_spl::token::mint_to(
    //CpiContext::new_with_signer(ctx.accounts.token_program.to_account_info(), mnt, &[]),
    CpiContext::new(ctx.accounts.token_program.to_account_info(), mnt),
    1,
)?;
```
Ah nice, that seems straightforward - ty !
That's fine, just gotta teach anchor/borsh how to deserialize/serialize it:
```.rs
#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub struct CustomObject {
  ...
}
```
interesting, good to know!
Can I use a custom struct in Anchor code for data to be deserialized to, or can Anchor only deserialize data to accounts?
```
pub struct CustomObject {
  id: u64,
  ...
}

#[account]
#[derive(Default)]
pub struct UserAccount {
   pub authority: Pubkey,
   pub custom_obj: CustomObject,
}

pub fn init(ctx: Context<Initialize>, custom_obj: CustomObj) -> ProgramResult{
  ctx,accounts,user_account.authority = ctx.accounts.user.key();
  ctx.accounts.user_account.custom_obj = custom_obj;
}
```

The goal here is to be able to pass `CustomObj` into the program and store it in the `UserAccount`. I was also think an alternative to this would be to use Borsh to store the serialized data as a u8 vector instead of the actual `CustomObj`.

The problem is that my `CustomObj` struct doesn't implement `anchor_lang::AnchorSerialize` so I'm assuming I'd have to use something like Borsh with the aforementioned approach?
Ahhhh, I was wondering when that part was gonna come in lol
decimals
Or is minting into a wallet not the best way to go?
last question guys, anyone know why it says 100 tokens should have been minted, but my wallet only goes up .0000001?  https://solscan.io/tx/wZwGW6mk6aFuomF1NxxcDWNS6AvW3nGcsCuciAPndc45QaoArZhATHtkM2XdLpb7LWPsrcyDotaDFiQQA5FgRQy?cluster=devnet
thank you guys!
noice
yes
same here?
```
#[account(address = anchor_spl::token::ID)]
pub token_program: Program<'info, Token>,
```
ohhhhhhhh ok, this makes sense. I basically have this except with the seeds and bump. <@!134416332509675520> explanation makes sense haha That is probably why I was getting seed errrors
oh good to know
^ don't need the address check there, anchor does that automatically when you do Program<'info, AssociatedToken>
make sure you also include:
```rust
#[account(address = anchor_spl::associated_token::ID)]
pub associated_token_program: Program<'info, AssociatedToken>,
```
There aren't any seeds when you do this because anchor handles that stuff behind the scenes (you don't have any freedom with the seeds—they're determined by the mint and the authority)
replace the word "gem" with "token"
yup here's how you do it:
```rust
#[account(init_if_needed,
        associated_token::mint = gem_mint,
        associated_token::authority = receiver,
        payer = owner,
    )]
    pub gem_destination: Box<Account<'info, TokenAccount>>,
```
At the risk of being pedantic, associated token accounts actually don't belong to the associated token program—they belong to the *spl* token program, and its just their address that is *derived* from the associated token program.
I am just trying to send a custom made spl token to a users wallet 😭  But i need to init their associated token account for them right?
in that case you'd use `init_if_needed` and it won't init if something is alredy present
curious to know what turns out to be true
what's your end goal? what are you trying to achieve?
i think it assigns some "memory" to it for the first time. im not sure, maybe you could even pass on pda's that already have something written into it, would be curious to know..
let me test it out without the seeds lol
hmmmm I was under the impression that `init` actually does create the PDA
thats how i understand it at least
so its just a check, not creation
see there at the bottom - seeds are already determined
the seeds are there just to double-check that the PDA was indeed derived from the seed. if no seeds are defined (as much as I understand), it just doesnt check for any constraints
https://spl.solana.com/associated-token-account
coz it's associated token account which means 1)it's owner by ATA prog, 2)the seeds are determined for you
I guess a better question, is why arent there any seeds here https://github.com/project-serum/anchor/blob/f66eee7c6dac8cf78c306c336c862a685a05a7db/tests/misc/programs/misc/src/context.rs#L36
I am a little confused. Are people trying to initialize associated token accounts through Anchor with #[derive(Accounts)] ? Don't they belong to the associated token program? so we can only make unrelated PDAs from our program?
is there any advantage to uploading the IDL there vs just putting it into Public folder and fetching locally?
i had to do `anchor build` and update most programIds again, but wasnt too much effort
wow, i think this seemed to work! thanks a lot
i guess this is independent, because of this line here, which specifies how to run `anchor test`  https://github.com/project-serum/anchor/blob/468fe79473328bf08ff293cfe85181cfb1ddd2d1/tests/cfo/Anchor.toml#L14 , and this line does not include anything about the above script
also, here i see a similar script that doesn't immediately call `anchor test` : https://github.com/project-serum/anchor/blob/468fe79473328bf08ff293cfe85181cfb1ddd2d1/tests/cfo/scripts/localnet.sh

do you think i would have to write a similar bash script, or `anchor test`  alone should work?
yh makes sense
different from what i guessed but similar
thx man! :))
here's an example with multiple
<https://github.com/project-serum/anchor/blob/468fe79473328bf08ff293cfe85181cfb1ddd2d1/tests/cfo/Anchor.toml>
``` 
Workspace configuration error: Unable to deserialize config: duplicate field `address` for key `test.genesis` at line 19 column 1
```
yh, says duplicate fields. also here it says toml arrays look like this, https://stackoverflow.com/questions/48998034/does-toml-support-nested-arrays-of-objects-tables not an expert here so might be wrong..
does it give you an error?
this results in duplicate fields :/
this makes sense
i don't know how the calling program would "own" the two programs
this is my best guess
```
[[test.genesis]]
address = "9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin"
program = "./deps/serum-dex/dex/target/deploy/serum_dex.so"
address = "9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin"
program = "./deps/serum-dex/dex/target/deploy/serum_dex.so"
```
and does the calling program have to own these two programs, or is it ok if it does not own these?


///////////////////////////////////////////////////////////////////////////////////////////////

Does anyone know if there is a way to get the creation date/time of a Solana account?
I think the Metaplex spec gives priority to any on-chain metadata attributes over off-chain metadata. You can see more details here: https://docs.metaplex.com/nft-standard
I don't think this level of doc exists actually. I know that the other day I was looking for what I could set in `Anchor.toml` for test setup purposes, and looked around here for instance: https://github.com/project-serum/anchor/blob/master/cli/src/lib.rs#L1754
That led me to finding out I could do this for instance, to bootstrap the validator with mainnet programs:
```
[test.validator]
url = "https://api.mainnet-beta.solana.com"

[[test.genesis]]
address = "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"
program = "./tests/fixtures/programs/metadata.so"
```
At least with this you can find out if what you are looking for is available.
Or actually it seems like you just configure by program name
You happen to know where docs are on all environmental variables we can set here?
Perfect, thanks 🙂
hey - is it possible to store metadata of an NFT on-chain? cus the ``uri`` field in most NFTs usually leads to off-chain links, is it possible to have a fully on-chain NFT w/metadata?
How about something like that: https://github.com/project-serum/multisig/blob/master/Anchor.toml
Python can be used as a client, to interact with onchain programs
Is there an easy way to progrmatically set `declare_id` based on release environment? ie devnet, testnet, mainnet
You can't write the contract in python
That's in rust, c, c++
hello, is anchor-cli for windows provided by npm?
So help me with good udemy courses on python blockchain development
Hello I was Wondering anyone write smart contract using python? I am a begginer all the courses I see are in javaScript while there is Vyper which helps coding in python
ok. I need to use Signer instead of Wallet actually. Thanks
In the browser you presumably won't have access to the `.payer` field
Yeah. If you're in node though you can do something goofy like `(program.provider.wallet as NodeWallet).payer` if you want
Oh it's that the secret key has been unexposed?
In anchor? This thing? https://github.com/project-serum/anchor/blob/master/ts/src/provider.ts#L223
It's still referenced to in the doc, but no definition? (It seems, I'm TS illiterate)
Did the Wallet disappear from the typescript interface in 1.9.0? What should be used instead?
fixed, thank you <@!134416332509675520> <:pepelove:866983238295486467>
The cpi_auth_account—the only thing that needs to sign is whatever has authority over the `from` account
it being? :p
Then yeah, it's the only thing that needs to sign.
spot on
`cpi_auth_account` is the authority of `collateral_reserve_account`
token account owner is the authority of `user_collateral_account`
So it's the owner of the user collateral account?
auth in this case is `cpi_auth_account`
Why would it also need to sign? What is it the authority of?
got it
i assume cpiAuthAccount would be signing too
For a token transfer there's `from`, `to`, and `authority`. Only the `authority` needs to sign.
Actually, sorry, what do you mean by *also?
Yeah.
so as long as the user (token account owner) signs it *also, it should execute right?
And they would have to sign the tx from the client
The user's token account's authority would be the user's own wallet most likely
It's probably not haha.
maybe i am missing something. if I want to transfer tokens from a user's token account (i.e. `user_collateral_account`), how could this be owned by `cpi_auth_account` also?
<:pepelove:866983238295486467>
starting to understand
Basically, the owner has to say "I really do want this transfer to happen"
Transfer just asks for the owner of the tokens to sign
So not sure
That won't matter for the transfer
thanks Alan
The authority is about the source of the tokens
similarly, should the mint authority of my token be `cpi_auth_account`?
Yep.
should my `user_collateral_account` be owned by `cpi_auth_account`?
let me check, i thought i had the right address
Maybe a seed miscalculation? That would lead to finding a different address
Ok, I would double-check that (I looked at the token program source and 99% sure the error message is telling you that's not the right owner)
my authority is `cpi_auth_account` which owns `collateral_reserve_account` but not `user_collateral_account`

```// deposit CPI ctx
impl<'a, 'b, 'c, 'info> From<&DepositCtx<'info>> for CpiContext<'a, 'b, 'c, 'info, Transfer<'info>> {
    fn from(accounts: &DepositCtx<'info>) -> CpiContext<'a, 'b, 'c, 'info, Transfer<'info>> {
        let cpi_accounts = Transfer {
            from: accounts.user_collateral_account.to_account_info(),
            to: accounts.collateral_reserve_account.to_account_info(),
            authority: accounts.cpi_auth_account.to_account_info(),
        };
        let cpi_program = accounts.token_program_account.to_account_info();
        CpiContext::new(cpi_program, cpi_accounts)
    }
}
```
Ah, sorry, I think that error means you're using the wrong authority
Yeah, think so—both accounts need to be token accounts (and then the authority is whoever "owns" the source tokens)
would this imply one of the accounts passed into the transfer ctx is not owned by the token program?
new error <:FeelsWowMan:789057808808542219>
```Program log: Instruction: Transfer
    Program log: Error: owner does not match
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 2664 of 179769 compute units
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA failed: custom program error: 0x4```
resolved <:pepelove:866983238295486467>

also thankfully there's discord search!
Sure!
thank you so much for helping me out here 🙂
ah ok, that makes sense
No, it's still using a validator, it's just doing everything for you
but isn't it simulating execution then?
Anchor will spin one up and do some magic stuff to skip having to actually deploy
You just say `anchor test` with no validator running in the background
but what is the alternative
It's just too easy to make confusing mistakes
This is why I never ever deploy while testing lol
y
oh man, this is trick
I forgot to deploy it
oh wait
there should be an anchor cookbook getting set up soon
sorry, it didn't work. I put it correctly the first time, but then i changed the order because I thought perhaps the order of accounts matters
this should be pinned
You've put it on top of the user, not the todo list
Oh derp, you've put the seeds constraint on top of the wrong account 😛
```
Debugging Error: 146, 0x92, seeds constraint violated. A possible cookbook entry:
- check the seeds in the account struct
- check the seeds in the client, in findProgramAddress
- check the bump in account struct
- check the bump being passed from the client
- switch to just plain `bump,` if already using `bump = `
- comment out the entire offending accounts constraint "// #[account(..)]"
- check if the seeds error crops up elsewhere in your accounts constraints
- run anchor_lang::solana_program::pubkey::Pubkey::find_program_address() in the first line of the program function to check that the public key it produces is the same as the account's public key with the seeds error
- also check that the bump from find_program_address is the same as the one being passed in
- (really random) check if there is another account in the accounts context that is missing a `mut` constraint
```
feeling a little stupid i missed this lol. ive added the seed constraint as such:
```    #[account(
        mut,
        constraint = cpi_auth_account.key == &state_account.load()?.cpi_auth_pubkey,
        seeds = [b"FABRIC".as_ref()],
        bump = state_account.load()?.nonce
    )]
    pub cpi_auth_account: AccountInfo<'info>,```

not picking an endianness or anything. the above looks wrong to me as im not passing the nonce as a seed but as the bump. when searching for the address on the client side, can i pass over the bump to find the right address?
https://github.com/knivets/anchor-todo
No, don't think so—at any rate it will depend on how you're using that nonce as a seed on the rust side. Are you like picking an endianness or something?
let me publish it real quick
Is your code in a git repo anywhere? Would be easier for me to debug that way
still have a `Error: 146: A seeds constraint was violated` 😄
Much better
```
which anchor
/Users/knivets/.cargo/bin/anchor
```
`rm  /opt/homebrew/bin/anchor` helped 😄
I would just delete the /opt/homebrew/bin/anchor
Did you maybe install that anchor node thing back before you started using nvm?

Basically you've somehow still got an npm installed anchor, just gotta figure out how to nuke it
What does `npm list -g` say?
and anchor is still there after the command execution
it always gives the same output
npm uninstall -g doesn't work
So still that same `which anchor`?
```       
npm uninstall -g @project-serum/anchor-cli                                                                                             
up to date in 0.029s
```
Not in general, no
That seems wrong to me, what about `npm uninstall -g`
I think this is where binaries might be installed on m1?
yes, that's what i'm curious about too, I don't see any brew anchor commands in my history
It ought to be some cargo directory
I did run this command: `npm uninstall @project-serum/anchor-cli`
You can homebrew install anchor now? 🤔
try to build it with the newer version. update the reference anchor version in the cargo.toml file
```
which anchor
/opt/homebrew/bin/anchor
```
Did you uninstall the anchor-cli npm package? What does `which anchor` say?
yes, but is it possible to make it work with 0.19?
uninstall anchor cli and install the 0.18.0 tagged version
to fetch the correct address, is this the correct way to pass in the nonce as a seed? 
```public async getCpiAuthAccount(nonce: number) {
        const [cpiAccount, _] = await PublicKey.findProgramAddress(
            [Buffer.from(CPI_SEED), (new BN(nonce)).toBuffer()],
            this.programId
        );

        return cpiAccount;
    }```
do you know how to fix this `Globally installed anchor version is not correct. Expected "anchor-cli 0.18.0", found "anchor-cli 0.19.0".`?
<@!134416332509675520>  how can I pass the `Vec<UserData>` type to the program in the test?
`#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub struct UserData {
    /// User address
    pub user: Pubkey,
    /// Max allocation for this user in private presale
    pub private_allo: u128,
    /// Max allocation for this user in public presale
    pub public_allo: u128
}`
thanks alan, will give this a try
Got it, thank you <@!134416332509675520>
zero_copy is a way to tell anchor to skip using borsh for deserialization/serialization, basically
At any rate you should probably do `npm uninstall -g @project-serum/anchor-cli` or whatever
`#[account(zero)]` says expect the account to arrive without any discriminator bytes yet (generally because you created the account in a separate instruction and anchor hasn't had a chance yet to write the discriminator)
hello, does anyone knows what is the different between `zero` and `zero_copy`?
I'm pretty sure I did that, but it was a while ago so not 100% sure
You should install anchor's cli directly via cargo
This is mentioned in the installation instructions: https://project-serum.github.io/anchor/getting-started/installation.html#build-from-source-for-other-operating-systems
which one?
Think it's not related to your current issue but the npm package is only for linux
m1
yes
Are you on a mac?
Mm, that message means you shouldn't be using the npm anchor cli by the way

but now I have the same error
anyway, I just had to airdrop some lamports to that account
oh the `solana-test-validator -r`
Did which part?
did it remove my validator keypair?
```
To resume a deploy, pass the recovered keypair as
the [PROGRAM_ADDRESS_SIGNER] argument to `solana deploy` or
as the [BUFFER_SIGNER] to `solana program deploy` or `solana write-buffer'.
Or to recover the account's lamports, pass it as the
[BUFFER_ACCOUNT_ADDRESS] argument to `solana program close`.
```
I'm not totally sure if a declare_id! issue could lead to a seeds error (I think it could but would need to double check—at any rate what you've written above looks fine to me)
Can you double check something then, what if you rerun anchor build + anchor deploy, and then do anchor test (I guess after clearing your validator state, e.g. `solana-test-validator -r`)
i'm running a local `solana-test-validator `
yes, I first make sure to run `anchor deploy` and then run `anchor test`
It's surprisingly easy to make deployment mistakes
(I never run my tests that way for what it's worth—I always just let anchor spin up a validator for me/don't do any explicit deploy)
How are you running the tests? Sounds like you're deploying against an actual local validator?
yes
Just to double check, is your `declare_id!` correct?
```
'Allocate: account Address { address: Gy1FfVermkPdWhxJeQTcNvGc66Zu5igVeLvKRsnv3QzK, base: None } already in use',
```
ah, right because the account is already created on first test run
oooh, actually now both tests fail
My first version had an extra account for PDA like in your example, but it still threw an error
I was actually following your example here: https://github.com/cqfd/anchor-visitors/blob/master/tests/visitors.js
the first one works fine
so the second tests throws an error
```
const anchor = require('@project-serum/anchor');
const assert = require("assert");

const connection = new anchor.web3.Connection('http://127.0.0.1:8899');

describe('todo', async () => {
    const provider = anchor.Provider.env();
    anchor.setProvider(provider);
    const program = anchor.workspace.Todo;
    let todosAccount, accountBump = null;
    [todosAccount, accountBump] = await anchor.web3.PublicKey.findProgramAddress([
        provider.wallet.publicKey.toBuffer()], program.programId)

    console.log(todosAccount, accountBump);

    it('Is initialized!', async () => {
        const tx = await program.rpc.initialize(new anchor.BN(accountBump), {
            accounts: {
                todoList: todosAccount,
                user: provider.wallet.publicKey,
                systemProgram: anchor.web3.SystemProgram.programId,
            },
        });
        console.log("Your transaction signature", tx);
    });

    it('Is adding todos!', async () => {
        const tx = await program.rpc.add('hello world', {
            accounts: {
                todoList: todosAccount,
                user: provider.wallet.publicKey,
            },
        });
        console.log("Your transaction signature", tx);

        const res = await program.account.todoList.fetch(todosAccount);
        assert.ok(res.list[0] === 'hello world');
    });
});
```
Cool, that looks fine so far
```
use anchor_lang::prelude::*;

declare_id!("F3j2R9WWmDFwNHLcyo9KCdQzSHxPohf21Nw5Gzf1BM2X");

#[program]
pub mod todo {
    use super::*;
    pub fn initialize(ctx: Context<Initialize>, bump: u8) -> ProgramResult {
        ctx.accounts.todo_list.bump = bump;
        Ok(())
    }

    pub fn add(ctx: Context<Add>, content: String) -> ProgramResult {
        ctx.accounts.todo_list.list.push(content);
        Ok(())
    }
}

#[derive(Accounts)]
#[instruction(bump: u8)]
pub struct Initialize<'info> {
    #[account(init, seeds = [user.key.as_ref()], bump = bump, payer = user, space = 5000)]
    todo_list: Account<'info, TodoList>,
    user: Signer<'info>,
    system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct Add<'info> {
    #[account(mut, seeds = [user.key.as_ref()], bump = todo_list.bump)]
    user: Signer<'info>,
    todo_list: Account<'info, TodoList>,
}

#[account]
pub struct TodoList {
    bump: u8,
    list: Vec<String>
}

pub struct TodoItem {
    content: String
}
```
Can you post your #[derive(Accounts)] seed part, as well as how you're using the seeds in JS?
Hi! I keep getting `Error: 146: A seeds constraint was violated` even though I'm pretty sure my code is correct
So you sort of just can't turn it into a JS number
Yep, sounds like your BN is too big (JS numbers can only do integers precisely up to 2^53)
Getting an error while doing toNumber() for limited to 53 bits
If it isn't too big you can do `.toNumber()` (or if it's really big you'll have to be ok with `.toString()` probably)
How to convert a BN returned from data to readable form in JS side ?
also don't need to wrap either of these in a Box because no data deserialization happens on them
AccountInfo is deprecated too, use UncheckedAccount
Oh ok, that's right. Thanks 🙂
Can't wrap AccountInfo in a box currently, just Account<'info, Whatever>
Hey 🙂 
If i wanna wrap something in Box this is how i should do it right ?  
```
    #[account(mut)]
    master_metadata: Box<AccountInfo<'info>>,
```

But when wrapping i get some weird errors like : 
```
no function or associated item named `try_accounts` found for struct `RegisterItem<'_>` in the current scope
```

Any idea ?
I would add `seeds = [b"FABRIC".as_ref()], bump = state.nonce` to the cpi_auth_account's `#[account(...)]` annotation, just to make sure you're actually using the right seeds + bump etc.
Not sure what this question means—whenever you use `init` in anchor you've already specified which address to create the account at *from the client*; the program itself doesn't get to pick any addresses.
Ah, it won't be able to live on the stack—stack frames in solana are only 4kb
fixed old one, now I have `Error: 101: Fallback functions are not supported`
But I have created account, and when I log program.account I see that account
I am getting `    Error: Account does not exist`
with the difference being calling it client-side gives you a 10mb account limit vs 10kb on the CPI call?
does anchor's init (system.createAccount) return the same derivable address as calling the client-side createAccountWithSeed with the same program-id?
<:wut:901895994961190932>
BdhPejsK3U4LkmCrbSGU9aKxQr8Mv1ZrgPo7QGELpbWk matches the address passed in for `cpi_auth_account`
i get ```Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account 
    Program taNXtfA9Z6EEBte9JGMVfuwg2rknnDxag1C1YPFJpeY invoke [1]
    BdhPejsK3U4LkmCrbSGU9aKxQr8Mv1ZrgPo7QGELpbWk's signer privilege escalated``` as an error where
```// deposit accounts
#[derive(Accounts)]
pub struct DepositCtx<'info> {
    #[account(
        mut,
        seeds = [b"fstate1".as_ref()], 
        bump = state_account.load()?.bump, 
        constraint = state_account.to_account_info().owner == program_id,
        constraint = state_account.load()?.admin_pubkey == *admin_account.key
    )]
    pub state_account: Loader<'info, State>,

    #[account(
        mut,
        has_one = owner
    )]
    pub user_account: Loader<'info, UserAccount>,

    #[account(
        mut,
        constraint = &collateral_reserve_account.owner == cpi_auth_account.key
    )]
    pub collateral_reserve_account: Account<'info, TokenAccount>,

    #[account(
        mut,
        constraint = user_collateral_account.to_account_info().owner != collateral_reserve_account.to_account_info().key,
        constraint = &user_collateral_account.owner == owner.key,
    )]
    pub user_collateral_account: Account<'info, TokenAccount>,

    #[account(address = token::ID)]
    pub token_program_account: AccountInfo<'info>,

    #[account(
        mut,
        constraint = assets_list_account.to_account_info().key == &state_account.load()?.assets_list,
        constraint = assets_list_account.to_account_info().owner == program_id
    )]
    pub assets_list_account: Loader<'info, AssetsList>,

    #[account(
        mut,
        signer
    )]
    pub owner: AccountInfo<'info>,

    #[account(
        mut,
        constraint = admin_account.key == &state_account.load()?.admin_pubkey
    )]
    pub admin_account: AccountInfo<'info>,

    #[account(
        mut,
        constraint = cpi_auth_account.key == &state_account.load()?.cpi_auth_pubkey
    )]
    pub cpi_auth_account: AccountInfo<'info>,
}

// deposit CPI ctx
impl<'a, 'b, 'c, 'info> From<&DepositCtx<'info>> for CpiContext<'a, 'b, 'c, 'info, Transfer<'info>> {
    fn from(accounts: &DepositCtx<'info>) -> CpiContext<'a, 'b, 'c, 'info, Transfer<'info>> {
        let cpi_accounts = Transfer {
            from: accounts.user_collateral_account.to_account_info(),
            to: accounts.collateral_reserve_account.to_account_info(),
            authority: accounts.cpi_auth_account.to_account_info(),
        };
        let cpi_program = accounts.token_program_account.to_account_info();
        CpiContext::new(cpi_program, cpi_accounts)
    }
}```
brain is derping. getting a CPI error. any ideas?

```        let seeds = &[
            "FABRIC".as_bytes(),
            &[state.nonce]
        ];
        let signer = &[
            &seeds[..]
        ];
        let cpi_context = CpiContext::from(&*ctx.accounts).with_signer(signer);
        token::transfer(cpi_context, amount)?;```
```
use crate::hashing_params::HASH_PARAMS;
impl<F: PrimeField> CircomPoseidonHasher<F> {
    pub fn hash(input: &[u8]) -> Result<Vec<u8>, Error> {
        let params = PoseidonParameters::<F>::from_bytes(&HASH_PARAMS[..])?; // this line throw OOM
        let output: F = <CRH<F> as CRHTrait>::evaluate(&params, input)?;
        let value = output.into_repr().to_bytes_le();
        Ok(value)
    }
}
```
hmm i just keep getting out of memory error when using it
looks like `#[repr(C)]` maybe actually shuold (not for me) turn it into a number - or #[repr(u8)]
is this still the best way to handle enums in typescript serialized from anchor?
https://github.com/project-serum/anchor/blob/5d8b4765f2c5a2d0c5a26c639b10719e7b6f2fd1/tests/swap/tests/swap.js#L279-L283
would it be better to just treat the enum values as u8s?
error wasnt coming through correctly
yeah, i was hitting tx limit
did you resolve this?
Is it possible to have two asynchronous signers?
Yeah, interesting, I hadn't realized that serialization would trigger that check
AccountInfo is fine because I can just check `is_signer` in my code, but this warning seems like I'm wrong
It will serialize if I change one of the anchor accounts from `Signer` to `AccountInfo` but I get this warning:
> Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release.
So I want to sign a transaction on my server, have the client sign it and then submit it. When I try to serialize the tx with 1 signer I'm getting a signature failed error. It works ok if I sign with both wallets and serialize. Am I missing something? Partial sign doesn't seem to help
Otherwise it'll have to go in an account
Is that [u8; 6536] truly static? Can you just embed it non-lazily?
Nope 😦 Can't have any mutable global state at all (and I think lazy_static uses that under the hood, not totally sure though)
I've got a `[u8; 6536]` i somehow need to preserve in the program or in memory
Possible to use lazy_static to keep something larger in memory?
ah snap
eh maybe not, more to debug
```
    'Program log: Error: memory allocation failed, out of memory',
    'Program Dw96F8NjN84googpni4mtSnCuAud9XkaPUFM1RJX53cK consumed 200000 of 200000 compute units',
```
I can't even execute this hash function in Solana :/ lol
Do you know the process for getting precompiles into Solana? <@!134416332509675520>
We're using a zkSNARK friendly hash so might not be performant by Solana's standards
Thanks, I will check it out.. saw it a long time ago. AFAIK it uses keccak which might be more perfomant on Solana
thanks
Okey I get it
And that's the part that anchor doesn't yet help with (unless you call your smart contract via TJ/JS somehow)
So the only thing you'd be doing from mobile is calling your smart contract
Anchor is just for the smart contract side (and then gives you some JS/TS code to call your rust contract)
Mm, what do you mean by mobile?
what do you mean when u say you'd have to build your own clients?  does newly created client have to be compatible with anchor? I am actually asking if I deploy a program is written with anchor, do i have to use anchor on clientside? If I dont have to, how to use serializing and desearlizing
Have you checked out this program? https://github.com/saber-hq/merkle-distributor/ I haven't looked at it very closely tbh
Having multiple instructions doesn't really help me compute those hashes
Say hashing is the compute intensive activity (to build the merkle tree root)
Hmm ok not sure this will work or that I have the right mental model
interesting and awesome
If you mark an account as `mut` then solana knows it can't run other txs that involve that account in parallel
Say for example if another deposit comes in before the instructions have processed
Right, individual instructions run sequentially within a tx
So if I update the tree in the instruction, I don't need to worry about locking the state
Mm, what do you mean by sequentially?
Txes in Solana are executed sequentially too correct?
They'll just get run one after the other
The only limit is that the entire tx has to fit in 1232 bytes
And the program can somehow handle them intelligently
Yeah
Basically an individual message to a program
Can I execute 4 of the same instructions in one tx?
And what is an instruction exactly?
Anchor doesn't currently have any built-in client support for kotlin/java/swift etc. Just JS. So react-native should work ok but you'd have to build your own clients otherwise.
or may i use anchor on mobile development?
hey guys do you know about how to use anchor on mobile development
Thank youu 🙂
But in general you can also search for `tx.add(` to see the low-level way of building a tx and sticking in instructions
Actually guess it's called preInstructions and postInstructions now
These examples might be kind of hard to read, but you can search the anchor codebase for `instructions: [` and see a bunch of examples (that's one way of adding some additional ixs to run before the rpc call)
Are there examples of multiple instructions in a single tx?
Hmm ok, I guess I have to wrap my head around that
You could maybe take a look at https://docs.solana.com/developing/on-chain-programs/debugging#monitoring-compute-budget-consumption
Mm, not sure :/ You currently get a fresh compute budget per *instruction*, not tx, so if you can split your stuff up into multiple ixs within the same tx that's ok (but does that make any sense for a merkle insertion?)
I'm curious if you have any insights here as I'm new to Solana as of 2 weeks ago.
And I've heard one would need to break a single insertion into multiple txes.
Basically, I think Solana cannot process sizable merkle tree insertions in a single tx.
Lol—I tried doing that locally but forgot that #[test] macros run with overflow checking
```
    'Program failed to complete: exceeded maximum number of instructions allowed (200000) at instruction #21127',
```
Haha
Ah, got it 😛
Nonetheless I now have the error I think I expect, which is that the program fails to compile
Ok, silly me using `self.levels == 32`
🤔
`2u32.pow(self.levels as u32))` is just returning 0
Sick 🙂
amazing, ok I found the error
The `?` operator in rust is kind of like a throw though—it aborts right there
So yeah, you can "catch" it in the caller just be inspecting it (was it an error?)
Ah, it's just a regular function return value
Rust doesn't have throw per-se, just return like that
presumably I catch this in `deposit` but throw entirely, or does this throw automatically?
For example, in `insert` I have:
```
        if next_index == 2u32.pow(self.levels as u32) {
            return Err(MerkleTreeError::TreeFull);
        }
```
And how do I manually throw?
(Meaning an error return value)
Ah, if I understand your question right any error is an automatic rollback
Also how do I require a program not to err? Is there something similar to `require(truthy_value, ErrorMessage)` like in Solidity?
OK thanks
oo interesting
Can take a look in `.anchor/program-logs/` (think only failed tests print them othewise)
Yep, it'll log no matter what
and then it executes in test?
You can use `msg!`
and just inspect if the hash function is working
I would like to add `println!` statements
But the root update doesn't persist
Worth noting that the account does mutate (deposit_count increases)
Actually, where else do you want to print from? Maybe I misunderstood your question
but nothing possible without that
gotcha
You could definitely edit the anchor source to stick in more logs etc. (if you point directly at a local checkout in your Cargo.toml)
Is it possible to put print statements inside the rust and output in tests? <@!134416332509675520>
Sorry for the dump, just unsure how else to debug.
And `DepositInto`
```
#[derive(Accounts)]
pub struct DepositInto<'info> {
    #[account(mut, signer)]
    pub depositor: AccountInfo<'info>,
    #[account(mut)]
    pub vault_account: Account<'info, TokenAccount>,
    #[account(
        mut,
        constraint = deposit_token_account.amount >= anchor_metadata.deposit_amount
    )]
    pub deposit_token_account: Account<'info, TokenAccount>,
    #[account(mut)]
    merkle_tree_account: Loader<'info, MerkleTreeAccount>,
    #[account(mut)]
    anchor_metadata: Account<'info, AnchorMetadata>,
    pub system_program: AccountInfo<'info>,
    pub token_program: AccountInfo<'info>,
}
```
This is the insertion fn:
```
    pub fn insert(&mut self, commitment: [u8; 32]) -> Result<u32, MerkleTreeError> {
        let next_index = self.next_index;
        if next_index == 2u32.pow(self.levels as u32) {
            return Err(MerkleTreeError::TreeFull);
        }

        let mut curr_index = next_index;
        let mut curr_level_hash = commitment;

        for i in 0..self.levels {
            let (left, right) = if curr_index % 2 == 0 {
                self.filled_subtrees[i as usize] = curr_level_hash;
                (curr_level_hash, self.zeroes(i))
            } else {
                (self.filled_subtrees[i as usize], curr_level_hash)
            };

            curr_level_hash = self.hash_left_right(left, right);
            curr_index = curr_index >> 1;
        }

        let new_root_index = (self.current_root_index + 1) % 32;
        self.current_root_index = new_root_index;
        self.roots[new_root_index as usize] = curr_level_hash;
        self.next_index = next_index + 1;
        Ok(next_index)
    }
```
Hmm I naively would have expected that to work.
Basically all accounts are public—you can read any account's data
If you just want to read the data, no need to CPI: you can just pass that account's address as an account, and then you can read its data (e.g. `the_account.data`, or maybe `the_account.to_account_info().data`)
Hello! i was wondering if someone could help me read the account state of a PDA from another program? 

I'm not sure if CPI is the best here because i dont need to invoke anything from the other program and i just want to read the data associated with the PDA belonging to the other program
I'm trying to do a merkle tree insertion, not sure if there's an implementation online anyone is familiar with
Any ideas how to debug this? I also haven't figured out how to add logs to check what's going on
```
    pub fn deposit(ctx: Context<DepositInto>, commitment: [u8; 32]) -> ProgramResult {
        let mut merkle_tree_account = ctx.accounts.merkle_tree_account.load_mut()?;
        let _inserted_index = merkle_tree_account.insert(commitment);
        ctx.accounts.anchor_metadata.deposit_count += 1;
        Ok(())
    }
```
I'm trying to mutate a zero_copy account that I've loaded with the loader but the changes are not persisting
Hello
Ah, ok, got it
Maybe passing a vector of pubkeys into authority rather than a single pubkey and then checking that signer pubkey is in that array
What kind of syntax are you imagining? Not quite sure what you have in mind
this account was missing mut
```rust
    #[account(
        mut,
        seeds = [user.key().as_ref(), TRADE_NO_SEED.as_ref(), &trade_no.bracket_id, &trade_no.market_id, &trade_no.market_list_id],
        bump = trade_no.buy_no_bumps.trade_no
    )]
    pub trade_no: Box<Account<'info, TradeNo>>,
```
so weird that it was a completely unrelated account missing mut
i tried all the hacks i know of
Is there a way to use `has_one` with multiple pubkeys? I'd like to have a couple pubkeys with 'authority' and am able to verify them manually but would like to use the built in macros if possible
Ah ok
tried that and it didn't affect the error
Hacky trick, what if you remove the explicit bump and just use `bump,`?
sometimes the error is `failed: Cross-program invocation with unauthorized signer or writable account'` and other times it's a 146 error (`custom program error: 0x92`)
this is going to sound dumb but it was random
The runtime should tell you which error it is. Unauthorized signer or writable?
Should file an issue in the solana repo for this
no, it was a completely unrelated account that i was missing `mut` on
Is that the account paying for rent?
Hmm, the `writable privilege escalated` is definitely weird, given the init, if that really is the pda's address 🤔
that's so weird but i think you're right
I just had the exact same error and it turned out the problem lied in me not putting #[account(mut)] on another, unrelated to the PDA account. Maybe check if any other accounts that should be mutable arent?
```rust
    #[account(
        init,
        seeds = [user.key().as_ref(), OPEN_ORDERS_SEED.as_ref(), SELL_NO_SEED.as_ref(), &bracket.id, &bracket.market_id, &bracket.market_list_id],
        bump = bumps.open_orders,
        space = OPEN_ORDERS_SPACE,
        payer = user,
        owner = dex_program.key()
    )]
    pub open_orders: UncheckedAccount<'info>,
```
nice! I didn't think about cleaning up the discriminator. Will use anchor's implementation
which is an incorrect seeds error
also sometimes the error is `failed: Cross-program invocation with unauthorized signer or writable account'` and other times it's a 146 error (custom program error: 0x92')
so the seeds are correct
i double checked, `find_program_address` on chain returns the `8YJMMVY8QTBj8Ru3dA5F7LFDEFCC7LiAM7kcK6q1hVw5`
```
    "8YJMMVY8QTBj8Ru3dA5F7LFDEFCC7LiAM7kcK6q1hVw5's writable privilege escalated",
    'Program 7oyrzFtYfb8RYGBJ3YgosEXGFe3ezR9NpgeLCnCpcSRX consumed 200000 of 200000 compute units',
    'Program 7oyrzFtYfb8RYGBJ3YgosEXGFe3ezR9NpgeLCnCpcSRX failed: Cross-program invocation with unauthorized signer or writable account'
```
really basic error but running out of things to check
ok ok
And also, what you wrote there isn't really specific to a PDA (it'll work for any account owned by the program)
Meant to post this above, you can see how anchor implements `close` here: https://github.com/project-serum/anchor/blob/master/lang/src/common.rs
for anyone who comes looking in the future this is what I ended up implementing, which seems to work:
```rs
pub fn close_pda_account<T>(
    pda_to_close: &mut Account<T>,
    receiver: &mut AccountInfo,
) -> ProgramResult
where
    T: AccountSerialize + AccountDeserialize + Clone + Owner,
{
    let lamports_to_salvage = pda_to_close.to_account_info().lamports();
    if lamports_to_salvage > 0 {
        **receiver.lamports.borrow_mut() = receiver
            .lamports()
            .checked_add(lamports_to_salvage)
            .ok_or(ErrorCode::ArithmeticError)?;
        **pda_to_close.to_account_info().lamports.borrow_mut() = 0;
    }
    Ok(())
}
```
I see! - do you maybe have an example of a normal (non-anchor) PDA closure?
Ah, no, not yet, though seems like conditional attributes are really getting requested a lot lately
hm is there a way to make that attribute conditional? My program does own it, but I only want to close it if token amount drops to 0 on withdrawal, which is not guaranteed
In general closing an account depends on which program owns it, not really on what kind of address it has. If its owned by your program, you can use the `close = destination` attribute, but otherwise you have to go ask whichever program *does* own it to close it for you (like how you're doing above for the token program specifically).


///////////////////////////////////////////////////////////////////////////////////////////////

