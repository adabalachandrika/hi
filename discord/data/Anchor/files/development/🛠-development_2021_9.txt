hello anchorers


///////////////////////////////////////////////////////////////////////////////////////////////

Currently I am trying to make like a Wallet in SvelteKit, and the next will be to create a kind of templates for Solana and SvelteKit for Dapps. But I see I need to solve the waller adapter to make it possible.
yeah true, I was checking your PR yesterday (60 files...) but being honest, I don't have the time for that.
I did a draft version of that for my use-case, way simpler just to fulfill my needs.. afterwards I took the time to clean it up and raise the PR... my recommendation is that you look at the React and Angular versions and figure out some middle ground
Maybe in a few weeks but know is impossible.
Thanks. I don't have the time currently to make a wallet adapter for Svelte like you made for Angular.
<@!570237104412557314> https://github.com/project-serum/anchor/blob/master/ts/src/provider.ts#L228 there you can see how to create a wallet that matches the anchor's interface. You can tweak that to work with a freshly generated Keypair, if you want to use Phantom, Sollet or w/e, you'll need to write your own adapter.
```
proc-macro derive panicked

help: message: Invariant violation: composite constraints can only be raw or literalsrustc

```
anyone seen this after upgrading to 16.1?
Getting this in a lot of the account structs,

oh, this could be a `declare id` thing
<@!134416332509675520> interesting! thanks for the tip
Whoops, I suck at discord‚Äîyeah, I had to add a sleep into the escrow test to wait for a suitably fresh blockhash
How would be the code of a wallet instance?
you mean the `Unable to obtain a new blockhash` error? Asking because you replied to a comment above mine
If I try to run `anchor build`  within the `test/misc` folder in your `cqfd/fix-733` branch I get the following compilation error

`thread 'main' panicked at 'Code not parseable: Error("expected `,`")', lang/syn/src/idl/file.rs:337:58`
It has nothing to do with React, useWallet gives you a reference to a wallet that's updated via the wallet adapter life-cycle. If you get your hands on a wallet instance you can give it to the Provider constructor.
üëç
Thanks so much, I really appreciate it.
There's currently no alternative.
The API will probably look similar in the future, but without the actual `#[state]` global account.
How would be that code of the wallet?
I'll see if I can make a vanilla JS example today if I have time
Ah, ok‚Äîbut the return value of `useWallet` is just a wallet, not react specific
The strange thing is the use of a React Hook in a JS library.
I don't know if that is an error
I'm also on an M1 fwiw
<@!103986638320861184> interesting, I ran into that same error! A while ago that is
my question was implement interface for what if not state

that's why I am saying that I find pretty strange the use of `useWallet` for that
Perhaps! specifically I'm running the tests for the escrow example

I'm running the tests from within the anchor project (so assume latest  `master`) and `solana-cli 1.8.0`

Then just use a static seed, e.g., `#[account(init, seeds = [b"my-global-state".as_ref()], bump = <my-bump>)]` inside `#[derive(Accounts)]`
creating a new one
<@!570237104412557314> the `Provider` you're using above is from `@project-serum/anchor` right? I don't think it has anything to do with React, right?
Are you migrating an existing contract or creating a new one?
how do we implement interface?
Would be great. Feel free to open a PR!
Svelte and Vue work very well with Vanilla JavaScript. No hooks,  more simple...
Use a PDA `#[account(init, seeds, bump)]` instead.
You should receive a compiler warning.
It's already deprecated.
I can not understand why is there no a JS example. I mean, it seems the React implementation like the standard. Why not plain JS?
The second is the Waller Adapter. That exists just for React. I saw yesterday your PR for the Angular and some people was asking for the Vue and Svelte implementation in the Issues.
<@!501570363566587905> is state going to be deprecated?
The Nader's example is using as `wallet` argument a React Hook. I was checking the code and being honest, I don't know at this moment how to replace that. My first impression was that Anchor client side is optimized for React.
```const provider = new Provider(
      connection, wallet, opts.preflightCommitment,
    );```
With Anchor, my problem is this
Both.
So your problem is not using Anchor in Svelte, but rather hooking up a wallet into your Svelte app, right?
I know, but when I was checking the code of the useWallet() hook, I couldn't understand why that function can use a React Hook. I don't know at this moment how to find a replacement for that in Svelte. Svelte has getContext() and setContext(). The aim is the same but not the code.
that is not the same code that useContext() in react. I am wondering how a library is supposed to be done for JS can works with React Hooks on that way.
useWallet() retrieves a contextapi
I don't understand what you mean.
creating a provider and a program should work nearly identical in Svelte, I've never tried Svelte before though
you dont its just a drop in replacement
but why do you need a contextAPi?
```typescript
async function getProvider() {
    /* create the provider and return it to the caller */
    /* network set to local network for now */
    const network = "http://127.0.0.1:8899";
    const connection = new Connection(network, opts.preflightCommitment);

    const provider = new Provider(
      connection, wallet, opts.preflightCommitment,
    );
    return provider;
  }

  async function initialize() {    
    const provider = await getProvider();
    /* create the program interface combining the idl, program ID, and provider */
    const program = new Program(idl, programID, provider);
    try {
      /* interact with the program via rpc */
      await program.rpc.initialize("Hello World", {
        accounts: {
          baseAccount: baseAccount.publicKey,
          user: provider.wallet.publicKey,
          systemProgram: SystemProgram.programId,
        },
        signers: [baseAccount]
      });

      const account = await program.account.baseAccount.fetch(baseAccount.publicKey);
      console.log('account: ', account);
      setValue(account.data.toString());
      setDataList(account.dataList);
    } catch (err) {
      console.log("Transaction error: ", err);
    }
  }
```

Regarding the Nader article, the only part where he uses hooks is for app state. All the Anchor specific code is easily reproducible in TS
I'm currently writing the adapter in Angular, the code is open source, you could write your own adapter and open a PR
ok i will consider making a svelte tutorial but i think you can just use the contextapi in svelte as a replacement for the hooks
Even the wallet adapter. Everything regarding frontend is React.
Since that example is using react and hooks, I am wondering how I can make the front end.
I am trying to implement the article of Nader in Svelte.
Svelte
what would make it easier for you to digest? Vue? Jquery? svelte?
Using anchor? <@!570237104412557314>
Is there an example not using React for the frontend?
Ok I'll poke around (at least my new test passes üòõ).
I also can't seem to get my test to run by itself (anchor test -- -g some-pattern-to-identify-my-test), always times out.
Maybe it's a CLI version problem?
<@!103986638320861184> basically, my whole workflow for adding a misc test https://github.com/project-serum/anchor/pull/772 seems to be kinda janky. If I run all of the miscs tests at once (cd etc. and then do `anchor test`) many fail/time out.
There might be an improvement on refreshing the recent blockhash to avoid having duplicated transactions, even if the user explicitly wants so, but I haven't been able to document this issue properly, and given that I run solana on M1 and compile from source, there might also be something specific to my setup
any test example in particular? (so I can replicate and take a look)  -- In my experience I have stumbled upon problems with duplicated transactions causing the validator to hang, and I slightly change the inputs to make them execute properly
Correct. Though one wouldn't want to zero the account and one would want to check for the `is_closed` "tombstone" in the first 8 bytes. If it exists, then proceed with the manual close.
I have a program with close and it does send the lamports back to the target you specify
Yessir, as <@!501570363566587905> pointed out, there's an on-going issue because an immediate funding of the just closed account might lead to a zombie account, if you have a PDA, the user might not be able to create a new account with the same wallet
<@!103986638320861184> and <@!706541980032827454> , thank you!!, this means if I mark an account with `close` and then by the end of the instruction, the lamports will be transferred automatically ?
Dope, will read through it.
Are there any tricks I should know to run the misc tests? When I run them with `anchor test` I get a fair number of failed tests and timeouts `Error: Transaction was not confirmed in 30.00 seconds` (though a bunch of them do pass).
The main issue with it currently is that if a malicious program funds the closed account in the same transaction, then you can end up in a state where you have a "zombie" account. Since you have the closed discriminator set, you can't re-initialize the account.

The solution is to have some type of a force defund instruction.

There's some conversation on this topic here https://github.com/project-serum/anchor/pull/604 and https://github.com/project-serum/anchor/issues/613.
BTW - is it safe to use the close trait? I mean, is it in a sort of stable state?
Thank you sir <@!501570363566587905>
Example in plain solana here https://github.com/solana-labs/solana-program-library/blob/master/token/program/src/processor.rs#L623
I'm doing exactly as <@!103986638320861184> says and it works like charm. I know there's somewhere an example of how to do that in plain Solana, but I can't seem to find it
I also agree. In your example seems like you want to transfer `router_account` balance to `authority` so the attribute could be `close = authority`
can you show us the contents of your `struct CloseAccount`?
why don't you just use the `close = <target>` trait? https://docs.rs/anchor-lang/0.16.1/anchor_lang/derive.Accounts.html
yes, this is a simple close instruction where I am closing the created account of a Program by transferring lamports to the authority account 
```
pub fn close_account(ctx: Context<CloseAccount>) -> ProgramResult {
        require!(
            *ctx.accounts.authority.to_account_info().key == ctx.accounts.router_account.authority,
            ErrorCode::NotAuthorized
        );


        invoke(
            &system_instruction::transfer(
                &ctx.accounts.router_account.key(),
                &ctx.accounts.authority.key,
                ctx.accounts.router_account.to_account_info().lamports(),
            ),
            &[
                ctx.accounts.router_account.to_account_info().clone(),
                ctx.accounts.authority.clone(),
                ctx.accounts.router_program.clone(),
            ],
        )?;

        Ok(())
    }
```

And this is my testing snippet , 
```
it("should close the account and transfer the sols", async () => {
     try{
      await program.rpc.closeAccount({
        accounts :{
          routerAccount : routerAccount.publicKey,
          authority : provider.wallet.publicKey,
          routerProgram : program.programId
        },
      });
  

     } 
     catch(err){
       console.log(err);
     }
  
  });
```
seems like the account you are trying to close is not owned/created by your program

Do you have a code example that we can look at and tell you what the problem is?
Am i gonna have to learn chinese to learn Anchor now? ü§£
https://www.youtube.com/watch?v=nCGkO90817M
Hello all,
need help, is there any proper example  to close the account? I am trying to close the account but receiving the below error 
`The given account is not owned by the executing program`
my mind is exploding and i am still confused about how i would integrate pdas
any good examples of using pda with the simple counter program?
thanks - i knew it was something terribly simple lol
say instead of setting `payer: provider.wallet.publicKey` you would do    
`const payer = anchor.web3.Keypair.generate();` and then `payer: payer.publickKey` and also add that keypair to the signers of the transaction `signers: [payer]`
you can sign transactions with freshly generated keypairs
Yep these I've seen, but if you want to have one of these be of a specific adresse I'm unsure how to do. Maybe I should just do
Yeah - it seems like the examples encourage the use of auxiliary token accounts to simulate swaps and things like that that occur between 2 users
Havn't experimented with this yet but will need it too.
I'm also running into issue writing tests, specifically having a mintAuthority for the WrappedSol Sol1111... cause I have some hard checks in my program
is it possible to change the provider wallet in the mid-test?  i want different users to sign different transactions - NodeWallet doesn't publicly expose the constructor so seems this is something that shouldn't be done
Haha thank you for pinging me, I was inserting `console.log`s into the generated anchor js etc. and was like wtf, this pubkey is serializing fine ü§®
Oooohhh. Jeez. I was trying to reproduce whatever error you might be getting and happened to use basic-1 as a jumping off point, and totally forgot about the explicit space = 8 + 8 üòõ
When using `init`, yes.
Is this still valid?
In the state size decl : ```    #[account(
       ...
        space = 8 // all accounts need 8 bytes for the account discriminator prepended to the account
        + 32 // authority: Pubkey needs 32 bytes
        + 8 // data: u64 needs 8 bytes
    )]```
That state was the only reference I could find to the additional 8 bytes needed for account storage
I was missing the extra 8 bytes in `state = 8 + 32 + ....`
I don't recommend using state. It will be removed eventually.
Might be your issue too ^^^
https://docs.rs/anchor-lang/0.16.1/anchor_lang/prelude/attr.state.html
make sure your size has enough bytes in it... you need to add an extra 8 bytes for the account discriminator
Thanks for the help
Unfortunately, I can't do that until I have a phone number linked to my account. I reached out to Discord support since they claim my number is used by another account
you need to click on the verify roles
https://discord.gg/solana
Phone number authentication isn't working for me unfortunately
I was on that version earlier this morning and had the same issues
why can't you get in the solana dev discord?
weird, i'd try 1.7.11
Yea I am. Not an M1 though
you're using mac I assume
Yea looks like all those folders exist
can you see if those are proper files?
``` /Users/kam/.local/share/solana/install/active_release/bin/sdk/bpf```
--bpf-sdk <PATH>             Path to the Solana BPF SDK [default:...]
what's your default for
cargo build-bpf --help
paste this
solana-cargo-build-bpf 1.7.12
what's yours
: cargo build-bpf --version
solana-cargo-build-bpf 1.7.11
worked for me
thanks for the help
let me try cargo bpf
trying to execute it does no such file or directory
actually i'm getting the same issue as you
Yes, I removed it
Yea I installed 1.7.11 previously since some of the examples were referencing that version and had the same issue
did you fully remove the `.local/share/solana/` before reinstalling
at that same location
but for 1.7.11
locally rustc exists for me and it's an executable
assuming it's some broken symlink
seems something isn't building/installing correctly
I get ```No such file or directory```
`ls -la /Users/kam/.local/share/solana/install/releases/1.7.12/solana-release/bin/sdk/bpf/dependencies/bpf-tools/rust/bin/rustc`
can you do
somebody pls help me. my brains no good
Hi all. I can't get into the Solana developer discord. I can't build projects and keep getting the following error when running 
```cargo build-bpf```
```Running: rustup toolchain list -v
Running: rustup toolchain link bpf /Users/kam/.local/share/solana/install/releases/1.7.12/solana-release/bin/sdk/bpf/dependencies/bpf-tools/rust
error: not a file: '/Users/kam/.local/share/solana/install/releases/1.7.12/solana-release/bin/sdk/bpf/dependencies/bpf-tools/rust/bin/rustc'```
Any ideas how to fix this? I've installed and uninstalled the solana tool suite many times, tried different versions, and tried to build from source
I keep getting this error
See https://github.com/project-serum/anchor/blob/master/examples/tutorial/basic-0/client.js#L19
Any examples on how to create `new anchor.Program(idl, pubKey)`  in ts ? I'm getting an error when providing `idl` as a plain json in typescript ? I saw Saber they do it, but rather complex importing other modules...
Yeah, it's weird... not sure what's going on. Trying to dig into the code, but so far can't quite figure it out
Ah ok‚Äîyep, just got the same error locally üëÄ
``` Transaction simulation failed: Error processing Instruction 0: custom program error: 0xa3 
    Program 3v1Y5wFi4fn3wij7W6hJztdYoLgVqR9a4n8ARpaGNqW9 invoke [1]
    Program 11111111111111111111111111111111 invoke [2]
    Program 11111111111111111111111111111111 success
    Program 11111111111111111111111111111111 invoke [2]
    Program 11111111111111111111111111111111 success
    Program log: Custom program error: 0xa3
    Program 3v1Y5wFi4fn3wij7W6hJztdYoLgVqR9a4n8ARpaGNqW9 consumed 10835 of 200000 compute units
    Program 3v1Y5wFi4fn3wij7W6hJztdYoLgVqR9a4n8ARpaGNqW9 failed: custom program error: 0xa3 
```
<@!576846361362694145> what error are you getting when you try to pass a pubkey as an argument?
wen batch RPC requests?
Hmm, I'll give that a shot. But I would still love to know how to pass non-intergers as args through thr RPC
on the program side
no I mean I just did `myAccount.key` and used that for whatever I wanted to pass the key
Cool -- how did you access it in the program side?
Shouldn't .publicKey already be a BN? (I see BN2)
tbh I've just given up and used the key from the passed account
Convert pubkey to BN?
How did you make it work (or do only numbers work?)
as in 
```await program.rpc.initialize(
    provider.wallet.payer.publicKey,
        accounts: {
            myAccount: provider.wallet.payer.publicKey, 
            authority: provider.wallet.payer.publicKey, 
            systemProgram: SystemProgram.programId
        },
        signers: [provider.wallet.payer]
    });
```
haha I tried the same thing
I am trying to pass in pubKey through the IDL... not working so well
for me once I changed it to BN it all worked purrfectly
I'm having trouble passing the `args` through the `.rpc.method()` too
for the `BN` you need to use `new anchor.BN(1000)`
generally, each program would publish an instruction.rs, where you could find the wrapper functions to do a cpi
wanted to know how its done the other way round.. i have to call an anchor program from a non-anchor one, but dont know if i'd need to add some metadata or sth?
If you want to keep things anchory you can make a wrap around the program you need to follow what is done with Token (look at `transfer` in func and struct here https://docs.rs/anchor-spl/0.11.0/anchor_spl/token/index.html)
You can still call non anchor program as usual. Anchor is a sugary layer (under the hood it calls program as usual https://docs.rs/anchor-spl/0.11.0/src/anchor_spl/token.rs.html#12-34)
Whats the equivalent of instruction.rs here?
How do you do a cpi to an anchor program from a non-anchor one?
ah it wants BN because it's u64, got it
idl:
```
      "args": [
        {
          "name": "bump",
          "type": "u8"
        },
        {
          "name": "param1",
          "type": "u64"
        },
        {
          "name": "param2",
          "type": "u64"
        }
      ]
```
given the following instruction
```
#[instruction(bump: u8, param1: u64, param2: u64)]
```

is this how you call it? 
```
  const initInst = await workspace.rpc.init(stateAccount[1], 1000, 1000, {
    accounts: {
      userWallet: wallet.publicKey,
      stateAccount: stateAccount[0],
      systemProgram: SystemProgram.programId,
    },
    signers: [wallet],
  });
```

keep getting `TypeError: src.toArrayLike is not a function`
I suspect no data deser/serialization tool is perfect and you always need to fill the gap somehow
```
fn find_subsequence(haystack: &[u8], needle: &[u8]) -> Option<usize> {
    haystack.windows(needle.len()).position(|window| window == needle)
}
...
    // Offset crafting, and beautifully
    let mut metadata = nft::Metadata::default();
    metadata.data.creators = Some(vec![nft::Creator {
        address: *creator,
        share: 0,
        verified: false,
    }]);
    nft::puff_out_data_fields(&mut metadata); // The String filling metaplexy thing
    let metadata_data = metadata.try_to_vec().unwrap();
    let offset = find_subsequence(&metadata_data, &creator.to_bytes())
        .unwrap();
    println!("offset: {}", offset);```
a total beauty
just now i invented field offset calculator for variable length borsh struct
...
Vec
like Option and other funkies
but not for some footgunny types
space is autocalculated
you can write a derive macro that takes all elements and calculates, but you'd be reimplementing Anchor
Anchor serialization takes a bit more space than size_of reports I think
Got it

on the client? Currently using typescript, not rust 
And get_pack_size or whatever is called has an annotation that it doesn't work on chain

Currently doing
```typescript
const size = borsh.serialize(
  Schema,
  new MyAccount()
).byteLength;
```

which gives me '5'
Call size_of::<T>()
#[derive(Clone, ... should work here
I would know, I was that intern
hire an intern to do it by hand and add 8
any idea what the proper way to calculate space is?
```
#[account]
pub struct BaseAccount {
    pub nft_list: Vec<Nft>,
}

#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct Nft {
    pub name: u8,
    pub owner: u8,
    pub amount: u64,
    pub fees: u64,
    pub metadata: u8,
}

impl Clone for Nft{
    fn clone(&self) -> Self {
        unimplemented!()
    }

    fn clone_from(&mut self, source: &Self) {
        unimplemented!()
    }
}
```
Anyone know how to implement the clone trait for custom objects?
possibly, maybe
i believe
8 bytes aligned
that's because of alignment
just don't want to run into issues later
the counter example has a size of 4, and the attribute does 8+8 so I figured to just double lol did 8 + 5+5 and it worked
so 8+5+8?
I do +8 and it works
quick Q: when borsh serialize on my struct has a byte length of 5, how much space does my acc need? 
doc says it has a 8 byte discriminator, so would it just be 8 + 5?
and pushs to the array when i call increment.

Edit: It seems like I need to add the following trait to Nft:

```
#[derive(AnchorSerialize, AnchorDeserialize)]
```
Very basic program that stores an array of Nft objects
```
use anchor_lang::prelude::*;

declare_id!("3DW75BB2he5pFW6RDRAzpvvpDFtVUcFv1Kn46BVvzTRq");

#[program]
mod example1 {
    use super::*;

    pub fn create(ctx: Context<Create>) -> ProgramResult {
        let base_account = &mut ctx.accounts.base_account;
        base_account.nft_list.push(
            Nft{
                name: String::from("New name"),
                owner: String::from("owner"),
                amount: 10,
                fees: 0,
                metadata: String::from("metadata")
            }
        );
        Ok(())
    }

    pub fn increment(ctx: Context<Increment>) -> ProgramResult {
        let base_account = &mut ctx.accounts.base_account;
        base_account.nft_list.push(
            Nft{
                name: String::from("New name"),
                owner: String::from("owner"),
                amount: 10,
                fees: 0,
                metadata: String::from("metadata")
            }
        );
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Create<'info> {
    #[account(init, payer = user, space = 256 + 256)]
    pub base_account: Account<'info, BaseAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct Increment<'info> {
    #[account(mut)]
    pub base_account: Account<'info, BaseAccount>,
}

#[account]
pub struct BaseAccount {
    pub nft_list: Vec<Nft>,
}

#[account]
pub struct Nft {
    pub name: String,
    pub owner: String,
    pub amount: u64,
    pub fees: u64,
    pub metadata: String,
}
```
My program:
My test:
```
  const provider = anchor.Provider.env();
  anchor.setProvider(provider);
  it("Creates and initializes an account in a single atomic transaction (simplified)", async () => {
    const program = anchor.workspace.Example1;
    const baseAccount = anchor.web3.Keypair.generate();
    console.log('BASE ACCOUNT: ' ,baseAccount);
    console.log('program: ', program)
    await program.rpc.create({
      accounts: {
        baseAccount: baseAccount.publicKey,
        user: provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      },
      signers: [baseAccount],
    });

    const account = await program.account.baseAccount.fetch(baseAccount.publicKey);
    console.log('Count 0: ', account.count.toString())
    // assert.ok(account.count.toString() == 0);
    _baseAccount = baseAccount;

  });
```

I am trying to make an array of objects called nfts (as an a example), everything compiles fine, but it throws errors an error when i run my test:
Hi, the rust crate serum-swap cannot be imported with the new version of Anchor.
A dumb way to make one would be to put recognisable data in the field, serialize, find the data, get the offset from that
I am navigating the doc but I am not sure i am reading the right places
Borsh question, is it possible to get the offset of a field to craft a filter for getProgramAccounts for instance?
nope, won't be added here unfortunately
Sweet thanks
The user signs their transaction when they send tokens to the account specified for the program.
The program signs with the PDA when it is sending tokens back to users
Receiving account can be any
The sending account needs to sign
that's the point of pdas, only the program itself can sign for them
you will still have to sign it, with the pda
yeah, im confused about signing a tx that debits the pda tho. can you debit a pda inside the program that owns it without worrying about signing?
with Transfer()
you can just send normal SOL to a pda
if i want a pda to manage sending/receiving regular sol tokens, would i implement a tokenAccount with wrapped sol? or is there a way to do it without that
just because it's all still fresh, my painpoints were:
- not understanding all the attributes that are needed to make this work
- having to use `seed` to designate something as pda 
- not understanding that `#[instruction(bump: u8)]` maps to the method signature
- not realizing that bump = bump then refers to an argument in that method (I guess ordering doesn't matter either and it maps by name) 
- lacking documentation for attributes - https://docs.rs/anchor-lang/0.16.1/anchor_lang/derive.Accounts.html is not sufficient

I guess the hardest were the crypto error message. If one thing doesn't match I'm getting completely different build issues 


next challenge is gonna be replacing my invoke_signed with anchor cpi üòÖ
thanks a ton
sweet I got it working
I see
It uses the `Default` trait to size it but that's a bit wasteful.
why does https://github.com/project-serum/anchor/blob/master/tests/misc/programs/misc/src/context.rs#L50 not have to specify space here?
https://github.com/project-serum/swap/blob/master/programs/swap/src/lib.rs
any examples on cpi proxy calls to serum through another program?
got confused about the 
> All accounts created with Anchor are laid out as follows: 8-byte-discriminator || borsh serialized data. The 8-byte-discriminator is created from the first 8 bytes of the Sha256 hash of the account's type--using the example above, sha256("account:MyAccount")[..8]. The account: is a fixed prefix.
yeah size was the issue. 
When I manually create it, I had to use `space: 4` in create_account
Don't use `Buffer.from(string)`. Use `anchor.utils.bytes.utf8.encode('state')`
How big is your account? Is 16 bytes enough?
```ts
const deriveAddressFromSeed = async (
  seed: web3.PublicKey,
  derivationString: string,
  programId: web3.PublicKey
) => {
  const [address, nr] = await web3.PublicKey.findProgramAddress(
    [seed.toBuffer(), Buffer.from(derivationString)],
    programId
  );

  return address;
};

  const stateAccount = await deriveAddressFromSeed(
    workspace.programId,
    "state",
    workspace.programId
  );

  const initInst = await workspace.rpc.init(new anchor.BN(0), {
    accounts: {
      programItself: workspace.programId,
      userWallet: wallet.publicKey,
      stateAccount: stateAccount,
      systemProgram: SystemProgram.programId,
      rentSysvar: SYSVAR_RENT_PUBKEY,
    },
    signers: [wallet],
  });
```
okay if I leave out `bump = bump` and just change it to `bump` it runs at least. but getting `AccountDidNotDeserialize`, but it's getting close
What does your js side look like?
You're probably passing in the wrong bump from the client.
hrrrmmm `    'Program failed to complete: Could not create program address with signer seeds: Provided seeds do not result in a valid address',`
ok this one now at least builds
```
    #[account(
        init,
        seeds = [&ID.as_ref(), b"state".as_ref()],
        payer = user_wallet,
        bump = bump,
        space = 8 + 8
    )]
    pub state_account: Account<'info, StateAccount>,
```
Awesome. Think I got my PDA global state working! Done with my goal an hour early. Gonna have dinner.  Thanks <@!501570363566587905> <@!141059180969721856>  <@!137101040687382528> !
thanks for the help <@!283802509682802688>
usual pda code that I'm using
```
pub(crate) fn get_state_address_with_seed(program_id: &Pubkey) -> (Pubkey, u8) {
    Pubkey::find_program_address(&[&program_id.to_bytes(), br"state"], program_id)
}
```
dump question but how do I get around this? 
```
    #[account(init, seeds = [&ID.to_bytes(), br"state"], payer = user_wallet, bump)]
    pub state_account: Account<'info, StateAccount>,
```

```
370 |     #[account(init, seeds = [&ID.to_bytes(), br"state"], payer = user_wallet, bump)]
    |                                              ^^^^^^^^^ expected an array with a fixed size of 32 elements, found one with 5 elements
```
Example here https://github.com/project-serum/anchor/blob/master/tests/cfo/programs/cfo/src/lib.rs#L379
Can just do this out of the box.
?
Just need to add serialize: https://github.com/project-serum/anchor/blob/master/spl/src/token.rs#L337
It's possible indeed.
Thoughts on making `Program<'info, Token>` possible: https://github.com/project-serum/anchor/blob/master/tests/spl/token-proxy/programs/token-proxy/src/lib.rs#L53
That's the plan once we can hide the `bump` seed in the account header.
yeah
You mean a keyword?
(a `pda` would be lovely :D)
üëç
let me give that a go!
Correct.
I want to say yes, but i'll let Aramani confirm
and what designates an account as a pda? the `seed = ` part?
^
This  will create a normal account, not a PDA, and so the client must have the keypair sign the tx. Hence your error.
currently I'm doing 
```
    // #[account(init, payer = user_wallet, space = 8 + 8)]
    // pub state_account: Account<'info, StateAccount>,
```

but let me try
I may be wrong but isnt that what the macro ```     #[account(
        init,
        seeds = [b"my-seed", domain.as_bytes(), foo.key.as_ref(), &seed],
        bump = bump,
        payer = initializer,
    )]
    pub myPDA: Account<'info, DataU16>``` is for?
is `init` usable with pdas?
in the example in the docs, it's generating a new keypair as the signer, but I don't want the user to control that (https://project-serum.github.io/anchor/tutorials/tutorial-1.html#creating-and-initializing-accounts)
in my message above I'm trying to do `init` to create an account that the program itself uses for storing global state
For this I am deriving a PDA with a specific state seed (program_id + "state"). When I use anchors `init`, it wants me to pass the signer of the created account along, otherwise I I'm getting a `signature verification failed` 
But in this case, the user has no way to sign for the PDA because it's a PDA
Also, if you simply omit `bump = <target>` and just use `bump` (without the target) then `find_program_address` will be used automatically.
now that makes more sense
Yes. Usually you want to store the `bump` on the account where it's used, though, for easy access from within the `#[derive(Accounts)]` macro.
ok I had no idea haha. Thanks man! 
Then when I have multiple PDAs I would just add their bumps to the method signature?
Yes.
oh! so instruction == handler?
Same args as the method handler.
The instruction data.
hmm but what is it referring to with `bump = bump`? Probably the stuff in the instruction attribute? `#[instruction(domain: String, seed: Vec<u8>, bump: u8)]`
But where is that coming from üòÖ
If you don't check the correct `bump` is used, then your program might be vulnerable to subtle attacks, where an attacker passes in an account with the wrong bump.
This is important because you don't want to use just any bump, you want to use *the* canonical bump in the case you are using PDAs for deterministic addressing, e.g., a hashmap.
Right so `bump` is a convention enforced by the framework. It will append the seed to the end when it does the address calculation.

This is particularly useful when `init` is used along with `seeds`, because it will assert that the `bump` is *the* canonical bump. I.e., the one returned by `find_program_address`.
I might write up a tutorial after I go through this process.
can you expand further on the `bump = bump` part? That's the thing I didn't get. What is it doing with bump? Where does it put it or get it from? 
If I want to get the signer seed of the PDA I need to do something like 
```
        let payer_signer_seeds: &[&[_]] = &[
            &derivation_seed.key.to_bytes(),
            br"payer",
            &[payer_bumpseed],
        ];
```

but for that I need the bumpseed
https://giphy.com/gifs/LXHJRRjnviw7e
üëç
neat thanks for the very specific answer
Ok thats solvable
Yes, though this will not initialize an account. So the account here either needs to be a PDA signer (no data) or already have been initialized.
Thats what that does
Ok
Ahhhhhhhhhh
yeeeeee thanks bro
this, right? 
```
    #[account(seeds = [derivation_seed.key.as_ref(), b"payer".as_ref()], bump = bump)]
    pub payer: AccountInfo<'info>,
```
You need to pass in `seeds` and `bump` to use a PDA. Example here: https://github.com/project-serum/anchor/blob/master/tests/misc/programs/misc/src/context.rs#L50
Like whats the API for it
What does a PDA look like
yep I get that
so the counter example is using `init` and passes `myAccount` as signer along, because it wants the created account to be a signer 
but that doesn't work for 'global state' because we don't want the user to hold the PK of this state account. That's why I'm using a PDA now and can't use any of the accountmanagement from anchor
But Im not super sure what an anchor PDA looks like
yeah
It uses a regular programaccount
I dont think it does either
I don't think basic-1 uses a PDA? I haven't seen the docs in a while though so maybe that changed
What does 10 lines of PDA code look like so I know what to search for in the code base
haha exactly
üôÉ
Ah I see im not the only one who wants a PDA tutorial https://github.com/project-serum/anchor/issues/70
yeah that's exactly what I'm doing too. Use an account that's owned by the program and save stuff in there and use that as state
Should I rely on the counter example; (tutorials/basic-1) as a template for that?
Global state can be emulated with PDAs
Gotcha, is the #[state] identifier being removed too then? How do we managed shared program state? Accounts?
I was asking in the other chat yesterday about `init`. I want to create an account that the program itself can use, so I want the program to create it and be the owner of it. But with `init`, it expects to pass the account that's getting created as signer into the RPC call
Can `init` not be used in scenarios like that?
No this (i.e. `#[state]`) will be removed.
but the program in GH seems to be describing.... a PDA? or just some form of internal state management?
the corresponding (#4) one listed in the docs seems to be about errors: https://project-serum.github.io/anchor/tutorials/tutorial-4.html#defining-a-program
Does anyone know if theres a write up for this particular tutorial? https://github.com/project-serum/anchor/tree/master/examples/tutorial/basic-4
https://docs.rs/anchor-lang/0.16.1/anchor_lang/derive.Accounts.html#example

there's a table at the bottom
Is there a single place that documents, or at least shows, all the syntax possible inside #[account(...)]?
Not online in a repo yet (soon ü§´)
Crystal clear.  And huge appreciation for the code snippet. Do you have a link to the full program that originated from?
hey i saw that the old channel was going to be deleted in a few days. might be good to leave it up a bit it was prob one of the best places to search for errors
Perfect timing for the new server with Ignite going on. will certainly be asking some questions in the next few days. Huge shoutout to <@!501570363566587905> for creating such a great DSL - I'm just a moron and this stuff is a bit tough for me to figure out
roger! makes sense
So you end up having account validation logic leak into the handler.
It's also a bit annoying to use state because you can't define constraints on it in the accounts struct.
There shouldn't be more than one way to do the same thing. It's made obsolete by the ability to init PDAs.
Can anybody rehash why `#[state]` is being deprecated?
`                let seeds = &[
                    ctx.accounts.user_key.to_account_info().key.as_ref(),
                    &[inp_user_nonce],
                ];
                let signer = &[&seeds[..]];
                let cpi_accounts = Transfer {
                    from: ctx.accounts.user_token.to_account_info(),
                    to: ctx.accounts.token_recipient.to_account_info(),
                    authority: ctx.accounts.user_agent.to_account_info(),
                };
                let cpi_program = ctx.accounts.token_program.clone();
                let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer);
                token::transfer(cpi_ctx, inp_amount)?;`
Here's an example of the actual transfer:
You need to create PDA (program derived accounts) so that the contract can move tokens on its own.
No, an account can only be OWNED by one program, but it can be read by any program.
Can I have an account with multiple owner programs?
Specifically, I want one program to _mint_ SPL tokens for a user, but another program to handle transferring them.  Since an account is owned by the program that created it, can I split up these functions across multiple programs?  Thanks Anchorers.
Indeed.
so is this where we now redirect all the traffic to?  üôÇ
better update to 0.16 before then üòÇ
zam
I've taken my own backup of the chat logs. <@!248066053161222144>  confirmed it is not going to be imported here.
So much alpha in there
Is there a way to archive the anchor channel in the serum channel?
The function I'm using to place the order is almost exactly the same as the swap example:
```
        dex::new_order_v3(
            ctx,
            side.into(),
            NonZeroU64::new(limit_price).unwrap(),
            NonZeroU64::new(max_coin_qty).unwrap(),
            NonZeroU64::new(max_native_pc_qty).unwrap(),
            SelfTradeBehavior::CancelProvide,
            OrderType::PostOnly,
            client_order_id,
            limit,
        )
```
I'm trying to modify the Swap example in the anchor tests to place limit orders. I'm able to send the transaction to place the order on localnet, I see the transaction if I point solana explorer to my local validator, but I don't see the order in serum-ui or when using serumjs. I've tried manually running market.match(...), and running `crank consume-events` but nothing seems to matter. Any suggestions on what might cause orders to not show up?

I made some notes on my understanding, correct me where I may go wrong, going to simplify it further for others to understand.
This should address that https://github.com/project-serum/anchor/issues/695.
In reality, you would have control over the keypair used to deploy a program, and you would know ahead of time which ID to use. Since this was a newly generated anchor workspace my program had the default placeholder, rather than do that automatically on deploy I'd say to include somewhere in the docs to make sure to replace that with yours. I believe this is already there somewhere, I think, at least in my case it's a matter of not knowing
Seems like a lot of steps atm just to deploy
Hmm I wonder if is it possible to make it so the declare id is automatically generated on deploy
https://www.notion.so/Debugging-Custom-Anchor-Errors-b8540dd418c44a4e939ab17c56a3fd3b
I just spent more than I care to admit debugging this error `The given account is not owned by the executing program`. I had a simple program that worked perfectly using `anchor test`, but I was getting that error in the JS client. I had the default id `declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");` in my program, as well as in the `Anchor.toml` file. When running `anchor deploy` I noticed the ProgramId printed was different `E4kBuz9gC7T32LBKnH3kscxjay1Y3KqFkXJt8UHq1BN4`, so I changed it in `declare_id` and `Anchor.toml` and called `anchor deploy`, the error kept appearing.

It turns out to be a very dumb thing, make sure to `anchor build` AND THEN `anchor deploy`. After that the error disappeared, I made this message for my future self and I saw others having it too.
it's all good
lmk if you need a c# dev's assistance; thats my jam
its pretty straight forward
ok doing it now hopefully
any c# devs want to look into this https://awesomeopensource.com/project/Tyrrrz/DiscordChatExporter
Filed https://github.com/project-serum/anchor/issues/new
hmm, no this isn't the issue i was having
We should change this.
is that it
oh shit
I'll kickoff the chat here by letting everyone know that when upgrading a rust program from 0.13 to 0.15+ of anchor, the seeds array cannot have a training comma (inside the `[ ... ]`).  I spent far more hours troubleshooting this than I care to admit.


///////////////////////////////////////////////////////////////////////////////////////////////

is there a way to pass `--features` to the cargo build with anchor-cli?
That‚Äôs wild, didn‚Äôt think anyone else was even using the shell
I stumbled upon this same issue yesterday, and filed a pull request. If you wanted to try it out, check out my fork and run `cargo install --path cli --locked` to install that fixed version of the cli, which will allow you to use the provider wallet in the shell properly
https://github.com/project-serum/anchor/pull/778
https://pastebin.com/F7YJPeHH
Do you have full file by chance ?
Can I always just use anchor deploy?
so I dont really need the anchor upgrade?
Mainnet would also work if you change the cluster config. You can also use `solana program deploy`.
Quick question.
to "upgrade" a contract code, do I actually need to run `anchor upgrade <target/deploy/program.so> --program-id <program-id>` ?
because I am running  `anchor deploy` with the newly built code and it seems to be replacing.
on the `devnet` at least,  but I am asking also what would be the `mainnet` behaviour. Thanks
hey guys! great work on anchor btw!
do you know of any multisig wallets or wallets that split funds to other wallets as soon as they receive sols?
hey guys
trying to work through the the basic-1 test in  `anchor shell` . In the shell, `provider` is already defined and `provider.wallet` doesn't have a `publicKey`. So how should this line from the tests look in the shell? `user: provider.wallet.publicKey,`
```
    pub const SIZE: u64 = 400;

    #[state(SIZE)]
    pub struct BaseAccount {
        pub authority: Pubkey,
        pub nft_list: Vec<Nft>,
    }
```
It says i have not allocated enough space but i specified it here
```
use anchor_lang::prelude::*;

declare_id!("3DW75BB2he5pFW6RDRAzpvvpDFtVUcFv1Kn46BVvzTRq");

#[program]
mod example1 {
    use super::*;

    pub const SIZE: u64 = 400;

    #[state(SIZE)]
    pub struct BaseAccount {
        pub authority: Pubkey,
        pub nft_list: Vec<Nft>,
    }

    #[derive(Clone, AnchorSerialize, AnchorDeserialize)]
    pub struct Nft {
        pub name: String,
        pub owner: String,
        pub amount: u64,
        pub fees: u64,
        pub metadata: String,
    }

    impl BaseAccount {
        pub fn new(ctx: Context<Auth>) -> Result<Self> {
            Ok(Self {
                authority: *ctx.accounts.authority.key,
                nft_list: Vec::from([Nft {
                    name: String::from("New name"),
                    owner: String::from("owner"),
                    amount: 10,
                    fees: 0,
                    metadata: String::from("metadata")
                }]),
            })
        }

        pub fn increment(&mut self, ctx: Context<Auth>) -> Result<()> {
            if &self.authority != ctx.accounts.authority.key {
                return Err(ErrorCode::Unauthorized.into());
            }
            self.nft_list.push(
                Nft{
                    name: String::from("a"),
                    owner: String::from("a"),
                    amount: 10,
                    fees: 0,
                    metadata: String::from("a")
                }
            );
            Ok(())
        }
    }

}

#[derive(Accounts)]
pub struct Auth<'info> {
    #[account(signer)]
    authority: AccountInfo<'info>,
}
```
Trying to call increment function, did I do something wrong
```
  logs: [
    'Program 3DW75BB2he5pFW6RDRAzpvvpDFtVUcFv1Kn46BVvzTRq invoke [1]',
    'Program log: Custom program error: 0xa4',
    'Program 3DW75BB2he5pFW6RDRAzpvvpDFtVUcFv1Kn46BVvzTRq consumed 9532 of 200000 compute units',
    'Program 3DW75BB2he5pFW6RDRAzpvvpDFtVUcFv1Kn46BVvzTRq failed: custom program error: 0xa4'
  ]
```
So this only occurs once I set a field's value to an Some(x) i.e.

x.foo = Some(bar);

Then it complains account cannot serialize

It's a u64 if that helps.
I think I'll stick with just providing some extra space in case a user stores more, just need to watchout for benevolent dictators overflowing the memory üôÇ
In my case, the length is variable so I dont know what it is at compile time but do at runtime
your way is far cleaner.
```        let whatever_acct = ctx.accounts.whatever.to_account_info();
        let mut whatever_data = whatever_acct.data.borrow_mut();
        if let Ok(data_as_structs) = try_cast_slice_mut(&mut whatever_data[41..]) {
```
How would you go about deserializing it yourself in Anchor ?
What I've done is simply make the definition of the array `[MyStruct; 0]`, then deserialize it myself.  In that case, I specify space to represent what I actually need.
Thanks for the help. Appreciated üôÇ
heh, good point - you dont need to tell it the space if you're giving it a default
Looks like removing the space attribute made it work.
Yep, it would result in a UserAccount being 86. But I have tried using space as such: 
```
#[derive(Accounts)]
#[instruction(bump: u8)]
pub struct CreateUserAccount<'info> {
    #[account(init, seeds = [b"accountv1", authority.key.as_ref(), &[bump]], space=86, payer=payer )]
    user_account: Loader<'info, UserAccount>,
```
And it still crashes
86 you mean?
Let's say I just want 10 structs of two bytes. Updated it to 20.
I think you want
`991], // (2048 - 66) / 2`
you're setting your custom array to 1982 Cust's.  Each of which is 2 bytes.
I am trying to make the user account 2048, with my custom array 1982 in size to make space for other future structs.
Is that supported?
I've only tried Option
Did you tried Option or COption? https://docs.rs/solana-sdk/1.7.12/solana_sdk/program_option/enum.COption.html
Does anchor support Option<Type>?

I tried adding it and one of my instructions gives back 
`AccountDidNotSerialize`
`1982], // 2048 - 66`

Are you making the account size 2048?  Cust is 2 bytes, not 1. `1982 * 2 + 66`
Hi all, I am trying to update some code to use zero-copy and replace former associated accounts with the new flow (seeds)
I am stuck on how to handle vec! of a custom type. I tried the following:
```
#[account(zero_copy)]
pub struct UserAccount {
    pub authority: Pubkey,     // 32
    pub bump: u8,              // 1
    pub owner: Pubkey,         // 32  Identity controling account
    pub version: u8,           // 1   Version of account struct
    pub array_of_structs: [Cust; 1982], // 2048 - 66
}

impl Default for UserAccount {
    fn default() -> Self {
        UserAccount {
            authority: Pubkey::default(),
            bump: 0,
            owner: Pubkey::default(),
            version: 0,           
            array_of_structs: [Cust {
                state: 0,
                sthg: 0,
            }; 1982],
        }
    }
}

#[zero_copy]
#[derive(Default)]
pub struct Cust {
    pub state: u8,
    pub sthg: u8,
}
```
If Cust has one field (let's say "state") it works, but whenever I add another ("sthg") it produces the following err: `Program log: panicked at 'range end index 8 out of range for slice of length 0'`
I need several fields in my Cust and one of them is a Pubkey.
Any idea what I am missing here ?
how do i write a rust client that uses a hardware wallet instead of a keypair?
Anyone have a good pattern to use for optional accounts to an instruction?  Or is it just reading them primitively from the end of the accountinfos?
no prob.  saves you space on the tx not using a separate pda authority when you don't really need to.
Yep!  Said differently, the program generated address of the created mint is also the authority for the mint.
> but I want my mint::authority to be the PDA
What PDA?  The address of itself?  `mint::authority = mint` works, I use that.
still cant access https://anchor.projectserum.com/ looks down >.>
Nice! Thanks i will try this.
ah it's because I should actually be looking at what happens here `encodeFn(idlIx.name, toInstruction(idlIx, ...ixArgs)),`
You can try add cache for cargo and solana.
```yaml
      - uses: actions/cache@v2
        name: Cache Cargo registry + index
        with:
          path: |
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
          key: cargo-${{ runner.os }}-v0000-${{ hashFiles('**/Cargo.lock') }}
      - uses: actions/cache@v2
        name: Cache Solana Tool Suite
        with:
          path: |
            ~/.cache/solana/
            ~/.local/share/solana/
          key: solana-${{ runner.os }}-v0001-${{ env.solana_verion }}
```
currently trying to figure out exactly what the `ix` looks like when `layout.encode(ix, buffer);` gets called. Sadly JS doesn't agree with my idea of just adding `console.log` to my `node_modules` and hoping for the ebst
Also anyone setup github workflows with anchor such that it doesn't take like 15 minutes to build?
and especially not sure of this
I am sure of nothing
Can we make the idl output consistent, fwiw I found if you build alone, idl has no metadata with program address but after you run tests, it is added
Had a q that i think disappeared on the last chat -
I meant number of accounts, not raw size
the discriminators are quite large at the moment, armani is thinking about making them 4 bytes
and yes, the 8 bytes discriminator was the reason why my borsh deserialization ended up funky
I answered my own question, we can just .slice() on the buffer and only get the bytes we want
no, it doesn't lower what accounts are required
how do you properly borsh.deserialize an account managed by anchor in javascript? I am running into some issues and I'm guessing it's the 8 byte discriminator
you could also try to cut down on the data you're sending along with the function
the discriminators are 8 bytes yes
okay thanks, I believe using anchor makes that max number of accounts even lower right? due the validations that anchor adds
the only places you can save accounts are on the sysvar accounts which can be loaded inside programs now
it looks like it successfully inits the fourth token account but then before it reaches the function itself it _nopes_ out
https://pastebin.com/2pEEtKzB
in a moment of inspiration i realised i could just add `pubkey` as an argument to `try_from_unchecked` and everything compiled ok. But still getting the stack overflow error
We are reaching the limit of max numbers of accounts when calling a function in a program,  which currently is ~30 accounts. Is there any workaround for this, besides splitting the tx into several txs?
But I can not implement it
```export interface Wallet {
  signTransaction(tx: Transaction): Promise<Transaction>;
  signAllTransactions(txs: Transaction[]): Promise<Transaction[]>;
  publicKey: PublicKey;
}```
This is the Wallet interface:
I see on TS has two methods, but I can not implement them successfully.
```const provider = new Provider(
    connection, wallet, opts.preflightCommitment,
  );```
How would be the `wallet` parameter in this function?
<@!501570363566587905>
Are you sure? Something definitely gets written to the buffer here since otherwise the test would fail. https://github.com/project-serum/anchor/blob/fe355ed15960f554dc5c3d27a447ec0b75c7113d/ts/src/coder/instruction.ts#L85
github link https://github.com/project-serum/anchor/blob/fe355ed15960f554dc5c3d27a447ec0b75c7113d/ts/src/coder/instruction.ts#L78
What is the proper way to `cargo install` anchor-cli with the latest stuff in `master`?

I've been able to do a `cargo build` and then use the binary in `target/release/anchor` - however I was wondering if there was a way to do so using `cargo install` to handle the path and stuff.

I tried doing a `cargo install` with a local path, but I'm definitely doing something wrong

```
cargo install --path . anchor-cli --locked
error: found a virtual manifest at `/Users/david/Desktop/dev/crypto/anchor/Cargo.toml` instead of a package manifest
```

Another option is to just keep the binary in that `target/release/anchor` and add that folder to my PATH or something.

Thanks!

---
UPDATE: Ok I think I have figured it out. 

Within the Anchor folder:

`cargo install --path cli --locked`
for example, in basic-1 the `layout` struct looks like this:
```Structure {
  span: 8,
  property: 'initialize',
  fields: [
    BNLayout { span: 8, property: 'data', blob: [Blob], signed: false }
  ],
  decodePrefixes: false
}```
and the `ix` that we try to encode looks like this:
```{
  name: 'initialize',
  accounts: [
    { name: 'myAccount', isMut: true, isSigner: true },
    { name: 'user', isMut: true, isSigner: true },
    { name: 'systemProgram', isMut: false, isSigner: false }
  ],
  args: [ { name: 'data', type: 'u64' } ]
}```
and since `ix` doesn't have a `data` field, it appears nothing gets written to the buffer, so there was no point in calling `layout.encode(ix, buffer)`
trying to understand why the `InstructionCoder._encode` method tries to do encoding on the `ix` object. In the examples I'm looking at this `data` object is just a buffer of zeros because nothing gets written to the buffer, because nothing in `ix` matches what's in `layout`
Sounds like a bug.
Boxing worked.  Note: boxing not available on accounts marked `close` due to missing trait impl.  Not sure if by design or not
Boxing should deal with most of the issues. <@!248066053161222144>'s is the first upgrade I've seen that didn't address it.
Dealing with similar stack issue under latest anchor.  Haven't tried boxing anything yet
alright, i'm giving up for the evening. <@!501570363566587905> I'm not sure if it's possible to roll back to CpiAccounts / ProgramAccounts to see if this gets rid of the stack overflow (which only appeared in the newer version of anchor)
I do have the IDL for the metaplex programs; the issue is metaplex uses a uint8 instruction key (anchor uses an 8 byte sighash), and doesn't use account  discriminants (initial 8 bytes that determine the account type in anchor programs).

You'd have to write a custom generator to solve that.

But anyway doesn't metaplex already have JavaScript clients?
it's not clear but it might just be a bug linked to the CpiAccounts that are using `init`
yeh, i think `tryFromUnchecked` is getting passed the program Id as well or something
this is presumably a bug with CpiAccount now then?
```

error[E0061]: this function takes 1 argument but 2 arguments were supplied
    --> programs/prediction-market/src/lib.rs:1505:10
     |
1505 | #[derive(Accounts)]
     |          ^^^^^^^^
     |          |
     |          supplied 2 arguments
     |          expected 1 argument
     |
note: associated function defined here
    --> /root/projects/anchor/lang/src/cpi_account.rs:33:12
     |
33   |     pub fn try_from_unchecked(info: &AccountInfo<'a>) -> Result<CpiAccount<'a, T>, ProgramError> {
     |            ^^^^^^^^^^^^^^^^^^
```
ah ok, i figured out where they were coming from
now that programAccount and CpiAccount are back
a bunch of these on the account structs
```
this function takes 1 argument but 2 arguments were supplied
```
still working my way backwards with all these compile errors
oh cool
Also `&ID`
ok for anyone who wants an `&Pubkey` of the currently executing program can now just use `&id()` once `declare_id!` has been called
ah ok i found it <https://docs.rs/solana-program/1.4.3/solana_program/macro.declare_id.html>
does declare id return a pubkey?
how would that work
Though declare_id! is more efficient.
You can get Pubkey from a string via `FromStr`, i.e. `.parse()`
in the rust docs
it doesn't look like there's a `new_from_string`
sure , thanks again :))
`::try_from` wants `program_id: &Pubkey,` is there an easy way to get the pubkey of the program
ok, i probably have to revert Box<> everywhere
No it's internally boxed.
it's giving a compile error 
```
expected struct `std::boxed::Box`, found struct `anchor_lang::ProgramAccount`
```
do we need to add Box around ProgramAccount too?
Related. Stack size will likely get bumped to 8kb in the future https://github.com/solana-labs/solana/issues/13391.
They do. Though I'd like to remove them at some point, ideally.
do those still work? Ok, i'll switch back to them
(on v0.16.1)
What about if you use `ProgramAccount` and `CpiAccount`?
nope
Does this not happen on an older version?
it runs out while still initing accounts, i think
<https://pastebin.com/WSyMyYsb> account struct
Ah, you need to cd into programs/your_prog_name/ (the one that has a Cargo.toml in it, plus your anchor source code)
yes I tried that but getting an error, 
`manifest path <somepath> is a virtual manifest, but this command requires running against an actual package in this workspace`
I am not sure from where to run that command
but let me double check again
all of the old CPI accounts and program accounts are boxed
yeh
Did you try to box?
`    'Program failed to complete: Access violation in unknown section at address 0xc2d7254f88000100 of size 8 by instruction #244782',`
getting stackoverflow errors after upgrading to v16.1
That will help you hop right to the codegen stuff
Ah, actually, the other big tip is to just `cargo expand` your program and then go search the codebase for whatever you find interesting
thank you for this info! really useful :))
So e.g. if you want to see what happens when you decorate a struct with `#[account]`, that's a `#[proc_macro_attribute]` and lives in lang/attribute/account/src/lib.rs
One tip, you can search through the codebase for "[proc_macro" and see all of the "macro entrypoints" (most of them immediately delegate to other places, so not necessarily super easy to read at first, but it's a start)
Yes you are absolutely correct :))
Heh, yeah, it's actually been a great way to learn how Rust proc macros work ü§ì
This is exactly what I was looking for, thank you!!, anchor is all magic, there is so many things that are happening behind the scenes!
You can see where the macro magic happens here: https://github.com/project-serum/anchor/blob/master/lang/syn/src/codegen/accounts/constraints.rs#L368
<@!687316047409446938> do you mean what code gets generated to handle account creation?
Thanks you !! , but now I am searching for where init code is written, is it in the same lib.rs file that I pointed out earlier ?
https://github.com/project-serum/anchor/blob/master/examples/tutorial/basic-1/programs/basic-1/src/lib.rs#L24-L25
This is what `#[account(init)]` does.
Hello all, I got another question and need your advice, is there a way to create account inside of an instruction itself? I saw this code here ( https://github.com/project-serum/anchor/blob/beace2c0008e7c32b9d56ccf50d368efa405a2ff/cli/src/lib.rs#L1699) which creates a new account. I am not sure whether we could use client inside of a program instruction (I am trying to automate the creation of accounts dynamically inside of an instruction)
<@!838168894241505283> has something with regards to generating idl from non anchor. I think he even did it because of metaplex too
Is there a way to get the idl of a non-anchor project? I would like to get the idl for the metaplex metadata program so i can query for the json on my react app
Usually an issue is nice if it's more work, but this should be straight forward.
PR is fine.
Right on, do you want me to submit an issue first? or are you OK with a straight PR
PR would be great.
I think it makes sense to expose that method as a static method on `AccountCoder` though.
I figured that was the reason so I copy-pasted rather than submit an issue
Things are mostly exposed on an as needed basis. I'm generally a little hesitant since exposing means we can't break it in the future üòõ
Is there a reason for not exporting `accountDiscriminator` in anchor TS? I'm using it for filtering program accounts but since it isn't exposed I copy pasted it, is there something I'm missing? I could raise the PR to expose it
https://github.com/tigthor/serum-anchor/blob/f710f459cb51c13c861107a438e6954f456ddff4/examples/tutorial/basic-5/programs/basic-5/src/lib.rs Is there a lot that needs to be refactored to make it work?
Ok sir, hope it comes back then basic examples are a great starting point for noobs. The tests examples are good too, but a bit complicated for beginners
do you have mocha globally installed?
for some reason my tests fail when they are anything but typescript files. is this normal?
We need to make a new one.
It was removed because it used the old `#[associated] ` attribute.
What happened to the basic-5 tutorial on pdas? <@501570363566587905>


///////////////////////////////////////////////////////////////////////////////////////////////

What would be the best way of implementing some sort of priority queue where certain elements in the middle of this queue can be removed? I could imagine the compute limit may get hit quite quickly with the constant shuffling of elements. Basically something similar to Rust's `std::collections::VecDeque`(or could I just use this?)
my mistake
I was on devnet
It says I don't have enough balance, but it looks like I should. Has anyone seen this error before?
Hey guys! I'm having a problem deploying a program, specifically running `anchor test`
Fair enough, Buffer is a class so I can use the native `instanceof` operator from TS
issue looks good. We can avoid the breaking changes by allowing on to use a `Buffer | GetProgramAccoutnsFilter[]`, which is not uncommon in js APIs.
in my case i dont want it to "embed" the other account but rather just re-use the struct / fields of that struct. i.e. The program stores 2 different kinds of things, 1 is of account with data of type A `{first_name: String, last_name: String}`, and the other is data of type B where B is `{a: A, additional_field: String}` they dont have to overlap or share data but rather just re-use the data structure of A in B

EDIT: I think one way i could do this is define the common struct outside without account macro and just use it in 2 different accounts that have `account` macro
The latter. An account can't embed another account. It can only have a reference via a Pubkey.
issue submitted ser, would love some feedback before nose-diving it ü§™
just checking if anyone knows i am doing something wrong or is IdlCoder not supposed to allow an account that has a field that depends on another account
I'll submit an issue so we can discuss it further
Awesome let's do it!
I'd love it if I could give the all method some filters matching `GetProgramAccountsFilter[]` and the method just do filters: `[discriminatorFilter, ...providedFilters]`
so it can be both, each a different PR though
more than just an offset, I'd say to make it a bit more flexible.. Right now it only accepts a Buffer so no offset can be given, but I need a more complex filtering, based on 2 different accounts with different offsets
(that sounds great to me)
Is the task here to just add an offset parameter for the all filter?
I was trying to use `program.account.<my-account>.all()` method and wanted to add some additional filters, one of which needs some offset. Looking at this https://github.com/project-serum/anchor/blob/master/ts/src/program/namespace/account.ts#L191 I won't be able to do so. As of now, I'm doing the request using connection.getProgramAccounts(<my-filters>), I'd like to do a PR to allow filtering when getting multiple accounts, is that something we'd like to have? if so, should that be part of the `all` method or a new one?
yep that works, thanks frens
make sure to `anchor build` after the change and before `anchor deploy`, I forgot and spent a long time trying to figure it out
Eventually we'll have a macro that dynamically does the update, but for now you need to manually embed it.
That's the problem. yes you need to change the latter two.
I got the program ID from `anchor deploy` and it matches what's in the logs: `Program 4vizBf9NfJw2FK81ihn12ELxdfedKX9hw54Fy4cz5KBA failed: custom program error: 0xa7` but not what's in Anchor.toml and `declare_id`. So should I change the latter two?
Make sure everything in declare_id and Anchor.toml actually lines up with the address being used on chain.
Probably need to use the correct program id.
when I naively copy code from the basic-1 tests and run it with `node client.js`, my call to `program.rpc.initialize` fails with error 167: `The given account is not owned by the executing program`

The tests still pass for me, so is there something I need to change in `client.js`?
I have a separate question if okay  üò¨ i am noticing that the IdlCoder seems to not like when I have an account that also depends on another account (i.e. i define an account with account macro that has a field that is a struct that is an another defined account). is doing that not allowed?
make sense so basically the example is a separate program that depends on the state of spl_token account and so it needs to be made sure that account is owned by spl token program and not a random account
The `spl_token` program ID is used, however, when `token` is deserialized.
In the example above it's not used because there are no accounts defined for `my_program`.
Where are we using the generated `ID` in the example above? (Besides how the generated `Owner` trait uses it that is)
The `declare_id!` is still needed for the program being defined (here `my_program`). It's not needed for the program being imported (here the spl token program)
But in general, we might want to verify that we received an account from one of our own programs (not the currently executing one!), say, in which case we really do need to be able to check that its owner matches some address.
Mm, ok. Just to say part of that back, in this specific example the SPL token program already has some known program_id (I see spl-token has a `solana_program::declare_id!("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");` of its own), so our own `declare_id!("...")` isn't necessary here, right?
Here's a simple example. Suppose you have a program that does something based on the state of an SPL token account, e.g.,

```rust
declare_id!("...");

#[program]
mod my_program {
  pub my_ix(ctx: Context<MyAccounts>) {
     if token.amount > 0 { 
         // do something 
     }
  }
}

#[derive(Accounts)]
pub struct MyAccounts<'info> {
  pub token: Account<'info, TokenAccount>,
}
```

In order for this to be safe, we need to ensure the given `token` is actually owned by the SPL token program; otherwise, one could simply inject an arbitrary account. 

With `Account`, and the `Owner` trait (which is implemented by `#[account]` and `declare_id`) this check is done automatically,
<@!337064922313916417> did you end up figuring out what this was?
We used to not require `declare_id!`, but a lot of people forgot both these checks. Hence why we now require one to statically define the id.
That's one. The other is when you include an account from a different program, you need to always check the owner, which is not the `program_id` given by the runtime.
I guess one situation is so you can verify that a CPI invocation to one of your own programs is really going to the right address?
I've been thinking a bit about the `declare_id!` macro, and wanted to ask a quick q about when a *statically known* program id is necessary (given that solana passes you your `program_id` at runtime too).
Is there a way to get serum last price through market account?
You can deploy with `solana program deploy` to unblock yourself fwiw.
All I did was edit the keypair files to our new grinded keys
Are all the anchor commands broken? Maybe a bug in your Anchor.toml?
Anything I can try to fix it, same error on deploy
Unrelated <@!840683071496912916>  this is fixed in the next version https://github.com/project-serum/anchor/issues/733.
I'm not sure. Sounds like a bug. That command will just iterate through all those files and basically run `solana address -k <keypair>`.
For what it's worth solana address -k each/individual/keypair works
```
   0 drwxr-xr-x  10  staff   320B Sep 23 10:27 .
   0 drwxr-xr-x   8  staff   256B Sep 23 10:27 ..
   8 -rw-------   1  staff   226B Sep 23 10:27 spl_token_account_split-keypair.json
 560 -rwxr-xr-x   1  staff   279K Sep 20 17:19 spl_token_account_split.so
   8 -rw-------   1  staff   224B Sep 23 10:27 spl_token_bonding-keypair.json
 776 -rwxr-xr-x   1  staff   385K Sep 20 17:39 spl_token_bonding.so
   8 -rw-------   1  staff   226B Sep 23 10:27 spl_token_staking-keypair.json
 776 -rwxr-xr-x   1  staff   385K Sep 20 14:08 spl_token_staking.so
   8 -rw-------   1  staff   231B Sep 23 09:56 spl_wumbo-keypair.json
1088 -rwxr-xr-x   1  staff   542K Sep 20 14:08 spl_wumbo.so
```
That's a new one. üòÖ . What does `ls target/deploy/` look like for you?
Any idea what would cause this:
```
$: anchor keys list
Error: expected `!`
```
Probably the web ui is reusing an address. I've battled these before with some of our larger txs like routed swaps. Gets even worse when the ui tacks on ata creations and such - be sure to account for that
The distinction is basically, a provider that auto signs and pays vs one that does not.
It won't necessarily fail, since the `signers` argument can be used.
This is defined by the solana runtime / network MTU. If you have different args and addresses then your error is probably expected. Duplicate addresses, for example, get deduplicated, bringing down the tx size.
Yes this was fixed in v0.16.1.
the anchor/spl directory is a wrapper for the spl token program i was told, is there a documentation on how it works , perhaps a tutorial for the anchor wrapper ?
I guess we'll see it in the next release, thanks for that!
https://tenor.com/view/the-office-bow-michael-scott-steve-carell-office-gif-12985913
Btw seeds can (hopefully) take a trailing comma now üòé https://github.com/project-serum/anchor/pull/777
ok, another weird one.
I'm getting `Translating error Error: Transaction too large: 1237 > 1232`, where is that limit set?
and why in one place (my frontend) this transaction goes through and in the other (anchor tests) it doesn't.
transactions are almost exactly the same (same shape and number of args, just different addresses)
maybe insufficient funds or smth?
dunno, but 0x1 is one of solana native errors, so you might want to check there
Any advice?
```Error: Deploying program failed: Error processing Instruction 1: custom program error: 0x1
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }.
```
Having this error when deploying to devnet:
I mean is not really a programming issue, I'm just so used to trailing commas in JS that I'd never assume it's an issue
yeah, I don't have any good advice then. rust is messed up XD
Rust
js or rust?
I said one hour because I feel ashamed of how much I actually spent rofl. That seeds array gets me every time.
well... it's marked as mut and I'm not doing any direct CPI calls (using `&system_instruction::transfer(`)
That's one of the best error messages in the whole dev process!  Means what it says.  Usually an account not marked `mut` or a cpi call with a PDA not using `with_signed`
just 1 hour?!  was it inside the seeds array?  That bug gets me nonstop
any hints on what may be causing this?
```
    "CXTXCXzEC1q4baujYDA3bGtce14aovAiDM1MbGv4pLjx's writable privilege escalated",
    'Program SLot3MfJ8RbsJR2KbJtxVcnsP2MQvcHW5DKnuT81s2U consumed 200000 of 200000 compute units',
    'Program SLot3MfJ8RbsJR2KbJtxVcnsP2MQvcHW5DKnuT81s2U failed: Cross-program invocation with unauthorized signer or writable account'
```

it's defined as
```
    #[account(mut)]
    payer: AccountInfo<'info>,
```
I spent an hour yesterday because of a trailing comma, I feel your pain
isn't it always something silly like a minor version or missing a semi-colon somewhere
np bro
have fun lol
Thanks Dan, doing it alllllll now
I think this relates to the CLI itself, but I'd update everywhere just as a good habit
*anchor is everywhere*
Like, everywhere right? Cargo.toml... CLI.... javascript, lol
I'll upgrade to the minor version, was using 16.0
Cool, that makes sense
Huh, I'd double check. I had that issue and updating solved it
Wait, crap... missing the .1
From the 0.16.1 changelog:

> Fixes
> lang: Signer type now sets isSigner to true in the IDL (#750).
Yep
<@!576846361362694145> https://github.com/project-serum/anchor/blob/master/CHANGELOG.md#fixes
Do you have anchor@0.16.1?
Just use the old way?
I thought Signer was supposed to get rid of the (signer) macro, but perhaps I'm missing something else
```
    #[account(signer)]
    pub authority: Signer<'info> 
```

Yep, but when I try to use `#[account(signer)]` with `Signer` vs code gives me a warning


is `Signer` supposed to generate `isSigner: true` in the IDL? Am I missing something?
https://discord.com/channels/889577356681945098/889577399308656662/889597013816115220
just catch and print it...
Seems like your question relates to this https://github.com/project-serum/anchor/issues/613 I think you're right
hey anyone here who has created tokens and nft  in particular  on solana, using anchor are there any resource focused towards this, if you know any do share.
I'm wondering if having something like: `ProgramWriter` and `ProgramReader` classes would solve this without ergonomy issues for consumers
tbh when I read your "hack", I thought to myself, crap, I should've thought of that instead lol
for now, apply the "wallet doing nothing" hack, to get the nice fetch calls
I'm currently using `@solana/web3.js` for querying the accounts and decode them manually, which is extremely annoying, I feel like I'm re-inventing the wheel. I was thinking on having two instances of the same program, one for rpc calls and one for querying. From my understanding, you're doing that.

That leads me to the idea that maybe we need two different Program classes, one that's fully loaded with a wallet and one that's some sort of "readonly" program. That way we avoid throwing when the wallet is not set while consumers have to make sure they're using the right program class depending on their needs.
Does anyone has any examples of creating, storing and retrieving data using a btreemap in the program code? Not using javascript api. Thanks
If I want my program to do CPI with the test/escrow program, should I have the user pass the escrow_account as parameter, and pass it forward to the child call of `escrow.initialize_account(...)`?
I think I'm doing something weird and the error are not explicit. I wanted to keep the escrow program as it is to have a tested/reliable layer to build upon, but seems that having this kind of account initialization is not correct
Or maybe I should have a state in the parent program, which keep the adresse of a PDA that I passe to `escrow.initialize_account()`?
running `npm i -g @project-serum/anchor-cli@0.16.1` in a github actions workflow gives this error whenever `anchor` is called:

```
anchor: command not found
```

not sure what the issue is, it was working fine installign via cargo <a:aPES_Think:493353113332219924>
convert the number from hex -> integer, if the number is >=300 its an error from your program, look into the errors section of the idl that gets generated when building your anchor project.

if its < 300 look for the number in https://github.com/project-serum/anchor/blob/master/lang/src/error.rs#L5
```
Transaction simulation failed: Error processing Instruction 0: custom program error: 0x66 
    Program Cbwh7thGVtAe5CfbTcWdP23VztjHFLhhYG4ebLNURWtR invoke [1]
    Program log: Custom program error: 0x66
```
Hmm how do we map the error codes on Anchor?
this is weird
Thanks <@!784156219861762109>
yeah somethings wrong with anchor-cli 0.16.1
anchor 0.16.0 fixed it!
wow
hmmmmm
I'm on 0.16.1 and it works
I am trying to downgrade to 0.16.0 now
0.16.1
instead of the example
anyway, I just did a fresh `anchor init` and it works, so maybe just try that
whats ur anchor cli version
https://tenor.com/view/rage-angry-pissed-off-office-throw-gif-17229290
üò´
```
Running: /Users/aaron/.local/share/solana/install/releases/1.7.11/solana-release/bin/sdk/bpf/scripts/strip.sh /Users/aaron/Desktop/anchor/examples/tutorial/basic-0/target/bpfel-unknown-unknown/release/basic_0.so /Users/aaron/Desktop/anchor/examples/tutorial/basic-0/target/deploy/basic_0.so
Running: /Users/aaron/.local/share/solana/install/releases/1.7.11/solana-release/bin/sdk/bpf/dependencies/bpf-tools/llvm/bin/llvm-readelf --dyn-symbols /Users/aaron/Desktop/anchor/examples/tutorial/basic-0/target/deploy/basic_0.so

To deploy this program:
  $ solana program deploy /Users/aaron/Desktop/anchor/examples/tutorial/basic-0/target/deploy/basic_0.so
The program address will default to this keypair (override with --program-id):
  /Users/aaron/Desktop/anchor/examples/tutorial/basic-0/target/deploy/basic_0-keypair.json
Failed to run test: mocha -t 1000000 tests/: No such file or directory (os error 2)
```
```
Error: No test files found: "test"
```
let me try that it threw an error because its in /test not /tests
ok, have u tried with npx?
ser I did that but it still giving me the same error
looks like you didn't follow the installation instruction. 
npm install -g mocha
npm i -g @project-serum/anchor-cli
```
Running: /Users/aaron/.local/share/solana/install/releases/1.7.11/solana-release/bin/sdk/bpf/scripts/strip.sh /Users/aaron/Desktop/anchor/examples/tutorial/basic-1/target/bpfel-unknown-unknown/release/basic_1.so /Users/aaron/Desktop/anchor/examples/tutorial/basic-1/target/deploy/basic_1.so
Running: /Users/aaron/.local/share/solana/install/releases/1.7.11/solana-release/bin/sdk/bpf/dependencies/bpf-tools/llvm/bin/llvm-readelf --dyn-symbols /Users/aaron/Desktop/anchor/examples/tutorial/basic-1/target/deploy/basic_1.so

To deploy this program:
  $ solana program deploy /Users/aaron/Desktop/anchor/examples/tutorial/basic-1/target/deploy/basic_1.so
The program address will default to this keypair (override with --program-id):
  /Users/aaron/Desktop/anchor/examples/tutorial/basic-1/target/deploy/basic_1-keypair.json
Failed to run test: mocha -t 1000000 tests/: No such file or directory (os error 2)
```
I am running the file directly from basic-1
depends on your project structure, used testing frameworks and a number of other things.
aif you use defaults and it still doesn't work - try `npx mocha`
When I run 
```
anchor test
```
I get 
```
Failed to run test: mocha -t 1000000 tests/: No such file or directory (os error 2)
```
anyone get this issue with anchor?
at least you get a fair heads up that it doesn't work, without failing somewhere down the track
I feel like having an full interface that throws on some calls is a bit poopy, but maybe the best we can do for now
still doesn't work though, it gets weird when you do rpc.<method> it will send something that isn't signed, or fail weirdly in one of the steps.
ah. `remainingAccounts`... that was it
clarification: for example `mylist: [AccountInfo<'info>;4]`
and that obviously doesn't work xd
neither does `Vec<AccountInfo<'info>>`
stupid quesiton - is there any way to provide a list of AccountInfos under `#[derive(Accounts)]`?
if not - what was the syntax to provide "other accounts"? I can't seem to find an example now, but I remember it being there
ReadOnlyProvider could be an option. it would for example give access to account -  `fetch` function and not the more generic `rpc`. maybe? just an idea
it's per tx fixed amount (plus more for # of signers I think)
How does sol paying work for a function kinda like payable for solidity?
And if someone sends lamports to it, the account gets bricked?
Hey, when you close an account, there's some logic in anchor to invalidate the 8byte discriminator until the end of the slot right? Or have I got that wrong
after I stopped validator
ah solved
Any suggestions? I've started `solana-test-validator`
``` 1) basic-0
       Uses the workspace to invoke the initialize instruction:
     Error: failed to send transaction: Transaction simulation failed: Attempt to load a program that does not exist
```
in the basic-0 example, I ran into this error when doing "anchor test"
That would be cleaner I agree
The alternative I was thinking was to make the provider an interface. Then you can have multiple implementations, one with a wallet that signs and one without. Then you don‚Äôt need the dummy wallet.
This way, our application can load state, and only when a user connects with their wallet, we create a `Client` with a provider that has a valid wallet.
Something like

```
export class DummyWallet implements Wallet {
  constructor() {}

  async signTransaction(_tx: Transaction): Promise<Transaction> {
    throw Error("Not supported by dummy wallet!");
  }

  async signAllTransactions(_txs: Transaction[]): Promise<Transaction[]> {
    throw Error("Not supported by dummy wallet!");
  }

  get publicKey(): PublicKey {
    throw Error("Not supported by dummy wallet!");
  }
}
```

But not sure if best practice.
What we've done in our SDK is to make the wallet optional and default to a dummy implementation that throws when any of the interface functions get called.
Can you suggest an alternative API to make the discussion more concrete?
Armani suggested to make Provider more flexible, notably for avoiding signing simulation.
But that makes the API a bit odd, because we will then end up with something that actually cannot sign for transactions, while still being able to be called. Kind of annoyingly nonergonomic for users
The current workaround that i shamelessly use everywhere is to pass in a null, or a stub that does nothing, then program is used for view only business like "fetch, simulate..."
I would like to discuss some "smell" around anchor Provider, first it takes a `Wallet`, which is a problem to craft a `Program` when one wants a view only API
ah ok then i would rec the issue i linked i think its the goto place to talk about this issue in general; havent tried any of this myself
no im scraping blockchian accounts that are from programs built with different anchor versions, so attempting to import the crates causes a dependency conflict
Are you scraping from github? I am really confused as to what you are doing, but you can get all the code with solana program dump and here is a github with some issue to doing a checksum : https://github.com/solana-labs/solana/issues/12232
im writing a service that scrapes anchor accounts from multiple programs that are written in different anchor versions, so I can't import the crates they're defined in directly due to compilation errors when using different anchor versions.

whats the best way to work around this? the only thing i can think of is copying the account types and defining them in the repository the service is written in, and then tagging the accounts with `#[account]` and `#[account(zero_copy)]` and using the `try_deserialize_unchecked` method to skip discriminator validation but there's a lot of manual overhead involved in this, and some potential issues can arise from needing to keep the accounts in synced with their upstream changes.

wondering if there's anything i might be missing that can make this easier <a:aPES_Think:493353113332219924>
Thanks for helping me think through it
I think the issue is I need a layer of abstraction (likely as a puppet CPI) for the real meat of my program, but a meta layer above it.
Ok thats helpful thank you!
The PDA can be thought of as two things

1. An account with a deterministic address
2. A program signer (usually acting as the authority of something)

(though often you can use one PDA for both cases)

For 2, which sounds like what you care about in this case, you just need to gate the signature behind some conditional program logic. For example, if the user is on the escrow account and the condition is met, then use the PDA to sign a CPI to complete the escrow.
I had a bit of a conceptual question about using anchor and PDAs as a form of shared state between 2 potential wallets. Let's say it's like an escrow program. One user initializes the program, and the PDAs that will hold tokens is created. Would the right flow be to have that user share the PDA to the second user it wants to complete the transaction with? Is there some other concept of a 'session' id I should be using instead or is this the right pattern I should stick with?
or i misunderstand
i think
I did that with the `slope` PR
I can live with 4 min build times, just not 16 üòÜ
‚ù§Ô∏è
Thank <@!448034961652449283> ‚ù§Ô∏è
Amazing stuff
yup
By 12 minutes!
`npm install @project-serum/anchor-cli` in your CI and your build will speed up significantly.
<@!448034961652449283> I saw your workflow doesn't have the 
```
cargo install --git https://github.com/project-serum/anchor --tag v${ANCHOR_VERSION} anchor-cli --locked
```
Is that in your make file? That seems to be the slowest command for me.
awesome thanks
Correct.
Means it hasn't been initialised?
What's the implication of the account discriminator being zero? does that just mean that the account hasn't been assigned a custom struct type?
When I try to init the IDL on chain, i always get the same error despite having a lot of funds.

"Error: unable to confirm transaction. This can happen in situations such as transaction expiration and insufficient fee-payer funds

Caused by:
    unable to confirm transaction. This can happen in situations such as transaction expiration and insufficient fee-payer funds"
When I deploy a program through anchor deploy, do I also need to do a "anchor idl init"? 

My front end is having problems with the  anchor.Program.fetchIdl(...) command and all I've done is redeployed a known good contract through "anchor deploy"
i shouldn't have assumed it'd somehow magically autogen an id and add it to the file just because i updated dependencies
guess i can just input a custom one
no i get it. i updated the repo dependencies but it didn't autogen an ID for the program
You might be able to `cargo expand` and just double check that you've got an ID etc.
(Not sure what might have changes relative to 0.13.2 though!)
ohhh right ok
<@!141059180969721856> I think that means something went wrong with your `declare_id!` (that generates a static ID variable that gets references by the macro output stuff as `crate::ID`)
is this a cache related issue?
getting this over one of the account structs in my program after updating to 0.16.0 from 0.13.2
is there any specific resources towards nft smart contracts using anchor
hey if anyone new here who has erc20 and other token standard experience on the ethereum chain wanted to learn how to create a nft token and move onto creating a marketplace on solana using anchor
~~For accounts that are modified by a cpi, how do you re-read them?  I seem to remember that you have to reinit the Account struct somehow~~

answer: `reload` https://docs.rs/anchor-lang/0.16.1/anchor_lang/struct.Account.html#method.reload
bumps are deterministic
Yes you can use the crate as you would from an anchor program. See this example https://github.com/project-serum/anchor/blob/master/examples/tutorial/basic-3/programs/puppet-master/src/lib.rs#L12-L17.
Are there any resources for making a CPI call to an anchor program from a non anchor program?
Would be nice to not have to hardcode each one.
For that PR in particular, I wonder if there's a way to pass through all cargo args via the anchor cli.
Thank you!
I would attempt to reach out and join forces (PR yours into theirs).  If they ghosted/abandoned - just make a new PR and reference the other.
Hey, so what is the kind of etiquette for a pr if someone already made a draft pr but you went a bit further on your own fork. Do I make another draft pr?
hey guys! When using the `spl-memo` program via `CPI` in Anchor, what would we do with the `Instruction` that  `build_memo` returns, so that a memo is included in the `pupper_master` transaction?
perfect, will do that.  using as a production toggle for some constants - open to other suggestions
In the mean time you can add the features directly to your Cargo.toml.
Its currently being worked on.
https://github.com/project-serum/anchor/pull/440


///////////////////////////////////////////////////////////////////////////////////////////////

I believe that is it.
Typical strategy here is allocate accounts in a preceding instruction and assign to program.  For organizing them you can use several strategies, one would be a base shared pubkey and using createFromSeed to derive off it; initializing caller would have privkey for the base.  It's an annoying limitation tbh; makes some designs overly complex.

Hopefully someone can chime in with something better
`pub const MAX_PERMITTED_DATA_INCREASE: usize = 1_024 * 10;` bytes
Might be happening here: https://github.com/solana-labs/solana/blob/master/programs/bpf_loader/src/syscalls.rs#L2242
I thought it was like 30k but seems it's far less.
Yea it's not a lot relative to the max I think.
I assume that‚Äôs not a lot
<@!831450660146642974> do you recall?
whatever the max size the runtime allows to create on cpi
Size*
Whats max currently?
I filed an issue in the solana repo somewhere a while ago but it might be hard to find...
No. There's a CPI restriction on this if i recall correctly.
Just guessing, are you passing in a bump from the client? The bump depends on the PDA's program_id, so if the program_id changed for some reason, you'd have to recalculate the bump with `find_program_address`
This might be problem with bump
Can you combine PDA and 10mb limit ?
When I all spl_token_transfer, I get a "Program failed to complete: Could not create program address with signer seeds: Provided seeds do not result in a valid address" error. 

The didn't change any of the parameters that I was passing into the function call. Anyone know why this might happen?
Please create an issue if definition is not correct..
it looks like it's already defined for Token in the anchor-spl crate, but it's not coming in correctly. i'll just use ur rec to make a custom one. thanks!
No, you need to define type which implement `anchor_lang::Id`, something like this (maybe there already version for SplToken, idk):
```rust
#[derive(Debug, Clone, Copy)]
pub struct Dex;

impl anchor_lang::AccountDeserialize for Dex {
    fn try_deserialize(buf: &mut &[u8]) -> Result<Self, ProgramError> {
        Self::try_deserialize_unchecked(buf)
    }

    fn try_deserialize_unchecked(_buf: &mut &[u8]) -> Result<Self, ProgramError> {
        Ok(Self)
    }
}

impl anchor_lang::Id for Dex {
    fn id() -> Pubkey {
        ID
    }
}
```
hmmm. im just trying to use Program<'info, Token> to enforce that the program passed is the token program. do i have to explicitly declare that id? the id for my program is declared
it's unsafe
That was fast üôÇ
and honestly idk if it even make sense
i got stuck on test
https://github.com/project-serum/anchor/pull/792
ohh maybe i didn't update the IDL after i changed it ü§¶‚Äç‚ôÇÔ∏è
Is there something special I have to do to pass the account as `is_writable` from web3?
If you look in your project's generated IDL (./target/idl/program-name.json), do you see the right `isMut` flags?
<@!696186010328891392> that error ultimately happens here https://github.com/project-serum/anchor/blob/master/lang/syn/src/codegen/accounts/constraints.rs#L175, so I think your PDA is somehow making it to your instruction handler without having been marked as `is_writable`.
<@!501570363566587905> when office hours ?
Hey! Trying to modify an existing PDAs data. I'm marking the PDA as mut but it's throwing "A mut constraint was violated" - what does this mean?

Declaring like so:
```
#[account(
mut,
seeds = [user.key.as_ref(), b"data".as_ref(), namespace.as_bytes()],
bump = bump,
)]
pub data_record: ProgramAccount<'info, UserDataRecord>,
```
Did you declared program id with `declare_id!` macros?
obvi i can just pass it as accountInfo and it will work but not secure
when i try declare an account type with Program (incl in anchor prelude), it throws an errow w/ "could not resolve accounts symbol." Has anyone run into this? everything is in scope
Wish there was someone else here to add credibility lol - Where's that armani when you need him!?  Who allowed him to sleep?
ok, ty
This effectively limits pda accounts to that size.
When you get up to the size you're talking, the limit isnt anchor - the limit is inherent in the bpf.  You might be able to push it a little farther, but there is 100% a limit to the cpi created size (nowhere NEAR 10mb).  Looking for a more well spoken/documented example or something.  But you can repro by just having a program cpi into `SystemInstruction::CreateAccount` with increasing sizes until it breaks.
does init use default()? that may be a problem
throw at 10k+
how large is the account?
on init, also I'm using zero_copy
this one looks like maybe fix with Box.  Or is this the same problem with init on a PDA?
Not sure I've seen this limitation documented - it's unfortunately one of those trial by fire nuances.
```Error: Function _ZN55_$LT$amm..account..Pool$u20$as$u20$core..fmt..Debug$GT$3fmt17h08981b14bc52fd9dE Stack offset of -25312 exceeded max offset of -4096 by 21216 bytes, please minimize large stack variables``` also this
```    'Program failed to complete: Access violation in stack frame 1 at address 0x200001006 of size 8 by instruction #40560',``` this one
Interesting. Thanks. Where I can read about this? Maybe you know specific error which will be thrown?
same tx is fine, just a preceeding instruction to allocate it using system program
limit is the same ?
so I can not create 1mb account and use it in same instruction? i.e. I need create it first and can use in another tx?
What about programs created by program
exacly, ty
then remembered correctly, any idea why am I getting stack overflows at init?
Note, those larger accounts have to be created outside your operation, then passed in.  Within an operation account size of new accounts is very limited (~30k?).
Right now -- 10mb. https://docs.solana.com/developing/programming-model/accounts#creating
That'd be amazing
what is the size limit of pda?
i will try to implement it today
BTW any reason for not using zero_copy for everything ?
we are basically implementing own load function
Pyth oracle i think is using this pattern
Interesting. Missed it searching for "Cpi Loader" on Gh. Are there any examples on how to deserialise a zero-copy account without Loader ?
We even have an issue for CpiLoader: https://github.com/project-serum/anchor/issues/643
Use AccountInfo or cry for help from <@!501570363566587905> to implement LoaderCPI
How would you - from a parent program - call a function in a child program, that changes the state of the child program (here, my pool) ?
Loader does not support CPI
thanks
Another question: I am trying to use Loader within a CPI, following a migration away from former associated accounts.
In my child program I have sthg like:
```
#[derive(Accounts)]
pub struct Lock<'info> {
    #[account(mut, seeds = [b"statev1".as_ref(), &[pool_state_account.load()?.bump]])]
    pub pool_state_account: Loader<'info, PoolState>,
    #[account(mut)]
    pub user_usdt_token_account: CpiAccount<'info, TokenAccount>,
```
How do you reference the pool state account from within the parent program ?
Tried both of the following options:
```
    // #[account(mut, seeds = [b"statev1".as_ref(), &[pool_state_account.load()?.bump]])]
    #[account(mut)]
    pub pool_state_account: Loader<'info, PoolState>,
```
`log_xx` autocompletion will find it
There is a log func to print them, so should look into the source how it retrieve it
yes
Is there easy way to get compute units in middle of program ?
This should be pinned and in the docs, saves so much time. Thanks, good man.
Hi <@!248066053161222144> I saw `CpiAccount` was being deprecated. Can you confirm this ? Should we just use `Account` now ?
It's a parsing error. Anchor looks for `target/idl/project-name.json` while there is `target/idl/project_name.json` (mind the diff between middle and lower dash)
Has anyone encountered this error?
`Error: Error loading workspace IDL for project-name`
Yeah but as the writer of the smart contract you can figure it out and apply the correct validations there.
the problem with that is there is no info as to what those accounts are...
Hey team, we're upgrading with anchor, but it keeps retrying, does it mean that if we have a transaction going on, we can't upgrade?
Thanks my dear Pomeranian <:pepenerd:834811863581065297>
You can use remaining accounts for variable number of accounts.
```
    let remainingAccounts = accs.map((acc) => {
      return { pubkey: acc.publicKey, isSigner: false, isWritable: true };
    });

    await program.rpc.foo({
      accounts:{...},
      remainingAccounts: remainingAccounts
    });   
```
Yep, I think optionnal is difficult with size of accounts, basically would always take the space, there is an UncheckedAccount that might do that I'm unsure? But I would love to see an exemple with the associated JS tests to understand better
I was just trying to do something like that yesterday. would be great to have support for that.
another pretty useful thing would be optional accounts
Wow nice. Thanks!
<@!443079510053748743> ~~do you mean a dynamic number of accounts? So like sometimes 5, sometimes 8, etc.?~~ whoops ignore me, misread your question
Wondering how to pass them from the JS test
Hello, anyone has an exemple on how to provide a list of N accounts in an instruction?
https://github.com/project-serum/anchor/pull/685 would be perfect, but in the meantime, should just use remaining account with an iterator?
Yeah probably cleanest to write an anchor CPI wrapper around the instructions you want to invoke
https://tenor.com/view/thank-you-thanks-gif-19684718
Then that makes sense
no different connection instances
<@!337064922313916417> I was thinking of e.g. this anchor file, which wraps making lower-leverl CPI calls to the spl_token program: https://github.com/project-serum/anchor/blob/master/spl/src/token.rs
Are you trying on a singular Connection instance?
Thanks, are you referring to the examples here or sth else? https://github.com/solana-labs/solana-program-library/tree/master/examples/rust/cross-program-invocation
hmm interesting, I just tested it on two dif programs and both came out to sub id 1
But if you subscribe for 4 different accounts, you should get increasing ids.
I think they optimise it under the hood, so if you're subscribing for on logs 4 times, it should be 1 subscription i imagine
thats definitely not happening on my end, running 4 in parallel and they are all sub id 1
each subscription
Yeah I believe it's monotonically increasing when you have a connection
Oh, sorry, maybe I misunderstood your question‚ÄîI guess the spl examples use anchor wrappers around the actual SPL program. But I think you'd just do a regular cross-program invocation to the non-anchor program (that's what the spl wrapper stuff does under the hood)
hmm the subscription ID is always 1 is that normal?
<@!337064922313916417> the spl examples are all like that (the spl program isn't written in anchor)
A basic question: if our contract is written in anchor, how can our contract interact with another contract that is not using anchor? And any code example for that?
nvm this clears it up
``` this._onLogsSubscriptionId = this._provider.connection.onLogs(
      this._programId,
      (logs, ctx) => {
        if (logs.err) {
          console.error(logs);
          return;
        }
        this._eventParser.parseLogs(logs.logs, (event) => {
          const allListeners = this._eventListeners.get(event.name);
          if (allListeners) {
            allListeners.forEach((listener) => {
              const listenerCb = this._eventCallbacks.get(listener);
              if (listenerCb) {
                const [, callback] = listenerCb;
                callback(event.data, ctx.slot);
              }
            });
          }
        });
      }
    );```
does this just get discarded/not returned when using "provider.connection.onLogs()" to get a log feed?
On the subscription you get the subscription id as a return value. You should store it and use that id when you want to unsubscribe.
sure lets do it
<@!438874996614365185> I'm down to try pairing again for a bit if you want? Might be easier to debug on video than over text.
it did have this vec in it, but tried it empty too same error
```rust
#[account]
#[derive(Default)]
pub struct PendingTokenInfos {
    // pub pending_token_infos: Vec<PendingTokenInfo>,
}
```
is there a way to kill a provider.connection.onLogs() ws connection? The RPC docs show a subscription ID result , but I cant figure out how to get that id value https://docs.solana.com/developing/clients/jsonrpc-api#logssubscribe
Fyi, ProgramAccount has been deprecated in favor of Account
Hmm it looks right to me, I assume account struct for PendingTokenInfos is empty?
```js
    const provider = await getProvider()
    const program = new Program(idl, programID, provider);
    const [pendingTokensAccount, bump] = await PublicKey.findProgramAddress(
      [Buffer.from(utils.bytes.utf8.encode("pending_token_infos"))],
      program.programId
    );
    console.log(program, pendingTokensAccount.toBase58());
    try {
      await program.rpc.initialize(bump, {
        accounts: {
          pendingTokensAccount,
          user: program.provider.wallet.publicKey,
          // rent: web3.SYSVAR_RENT_PUBKEY,
          systemProgram: web3.SystemProgram.programId,
        }
      });
```
not actually sure what the "rent" thing is but i see it in here - i assume its something to do with calculating rent exception https://github.com/project-serum/anchor/blob/master/tests/misc/tests/misc.js#L307

now that im noticing though this PDA also has a Vec as part of the data so maybe i need to also specify a space in the account otherwise how does it know
```
pub pending_tokens_account: Account
```
I usually put ProgramAccount instead of Account there. How did you initialize the PDA on client side?
omg hahah the declare_id wasnt right and i was about go crazy - but even fixing that same error still 
<@!134416332509675520> `#[derive(Accounts)]` looks like this
```
#[derive(Accounts)]
#[instruction(bump: u8)]
pub struct Initialize<'info> {
    #[account(
        init,
        seeds = [b"pending_token_infos".as_ref()],
        bump = bump,
        payer = user
    )]
    pub pending_tokens_account: Account<'info, PendingTokenInfos>,
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```
Very likely your `declare_id` is inconsistent with the deployed address.
<@!438874996614365185> what does your `#[derive(Accounts)]` struct look like for this instruction?
Maybe your seed on JS side doesn't match the rust side
ive been banging my head against the wall about this
```index.js:1 Transaction simulation failed: Error processing Instruction 0: custom program error: 0xa7 
    Program Hat4JBCvCMe4NBWPUXo1SU8HH2ppQt2Zpc7DWGwUfvhB invoke [1]
    Program 11111111111111111111111111111111 invoke [2]
    Program 11111111111111111111111111111111 success
    Program log: Custom program error: 0xa7```
my instruction handler is empty so I think something in anchor is throwing this error. i am basically just trying to initialize a PDA. am I correct in thinking 0xa7 error is 167 which is?https://github.com/project-serum/anchor/blob/3958533750c83c3e90709448c4f30ed9cce0b9b8/lang/src/error.rs#L68
Actually (will double check) I think putting mocha in the package.json only works if you run the mocha tests with `npm run some-script-name`, so misc I think is installing mocha as a dependency but then just using the global one
Having mocha in the package.json sounds good as well.
This sounds good to me.
But curious if anyone would expect something fancier (idk, maybe `anchor test` runs `npm install`, or we run `npx mocha` instead of expecting people to have `mocha` installed globally
There are a few tutorials on creating tokens using the spl, is there any tutorial to create tokens using the anchor wrapped rof spl ?
I think the quickfix is to do what e.g. the misc tests do, and just stick a package.json in the root of each test. Then you can `npm install` before you `anchor test`, etc.
Do people have thoughts on the desired workflow for test dependencies? https://github.com/project-serum/anchor/issues/717
Or clone or whatever the flag is
Just chain ‚Äîcopy commands
not sure if there is a way to spinup the entire ledger
You can selectively clone accounts
is there a way to use a copy of devnet or mainnet on your test-validator like you can do on hardhat for eth
Solana.com was having dns issues earlier, not sure if ongoing still
sure gimme a sec
<@!706541980032827454> if you want to pair on your stuff for a bit, I'm down
Seems like the devnet RPC is oversubscribed. I swapped to a private paid one and everything deployed without issue
is there something I have to do beside cd into `tests/misc` and run `anchor test`?
I even restarted my station just to double check
oh crap, that's bad for me then üò¶
I'm running all the misc test successfully though so <@!706541980032827454>'s issue is a version mismatch or typo in the file I'm guessing.
It regressed in https://github.com/project-serum/anchor/pull/770
Assuming I kill any stubborn clusters though, I can run the misc tests (but with one failure, "Can CPI to state instructions")
I've got a fix incoming.
Yea I saw that.
I keep having to manually kill the `solana-te` process listening on :8899 (I've installed solana from source, just git pulled/rebuilt etc.)
Seems like the cluster listening on :8899 isn't shutting down cleanly or something ü§î
Hmm, weird, I'm actually also having a problem running tests, though a different one.
Having same issue while deploying to devnet. Have around 5 SOL, should be plenty. Anything I should check ?
The build seems to be fine, right after it finishes that shows the "To deploy this program" message, the error pops and I don't see a single message from mocha
switched to master in my fork which is even with the upstream master, run `anchor test` from `/tests/misc` and got the same error message
I havent changed a thing of misc, just trying to make sure the test succeed before diving in
Maybe you have a missing `,` in your account constraints?
by build you mean cargo build-bpf inside tests/misc?
my rust is... pretty rusted lol
If I run `anchor --version` I get anchor-cli 0.16.1, I installed it via npm
Try building and using the master version.
Your CLI is surely out of date.
Heyoo, were you able to get around this?
I'm trying to run the test suite for tests/misc. I follow these steps:

- `cd tests/misc` 
- `yarn`
- `anchor test`

I have solana@1.7.12, anchor@0.16.1, and I'm currently in Ubuntu 18.04. It seems like it compiled but I'm seeing the below error and I don't see the usual messages from the test suite.

thread 'main' panicked at 'Code not parseable: Error("expected `,`")', lang/syn/src/idl/file.rs:338:58
Though some of the apis like the spl token program still require you to provide the account unfortunately.
Correct this is live on mb.
is mb chain running a version that allows sysvar access w/o including in accounts? ex `clock::Clock::get()`. guessing so; its in the main docs now as a way to retrieve the sysvars. really weird to already feel like a veteran in this space - "Back in my day, we had to take sysvars as account inputs"
Would be awesome!
I may take that one on tonight - I need to get more into the weeds.
awesome, figured I can't be the only one.  yeah I like the `?`  Would also be nice for other constraining attributes.
I like the proposal to use `?` here https://github.com/project-serum/anchor/issues/509
<@!445019022338031618> not sure what you mean‚Äî`anchor build` and `anchor deploy` use the rs files?
i assume anchor wont work only on .rs files
Has anyone done any thinking or proposal around custom errors from raw constraints?  I'd love to replace a lot of validation with constraints, but then I'm down to a single error message.
<@!134416332509675520>  the anchor spl wrapper which only has rs files i can build and test using cargo right ?
should i just copy all the npm i commands into a local package json inside the test folder and that should do the trick
Yeah, you just need the packages to be installed somehow when you run `anchor test`
commands*
would it be as simple as copying all the npm install ocmmands into a package json ?
really*
xD <@!134416332509675520>  could u relaly do that ?
trying out testing with JS file auto created by Anchor and facing problem. anchor.Provider.env() and hence, ANCHOR_PROVIDER_URL is undefined, how do i define it?
I can try fixing the underlying gh issue: https://github.com/project-serum/anchor/issues/717
Ah, no, just copy those npm install -g commands (they were just an example)
is there a way to install all the packages listed in travis.yml ?
ok will look at them
<@!445019022338031618> but just as an example, if you look in the `.travis.yml` file in the root of anchor project repo, you can see how the tests get run‚Äîthere are a bunch of `npm install -g` commands in there.
We should add package.json files to all the tests.
<@!445019022338031618> ah, whoops, you'll have to install that one too (the anchor tests don't currently declare their dependencies separately, not totally sure why). But if you look at the `token-proxy.js` test file you're running, there are several `require`s in there. You'll need to install them all one way or another.
and try again ?
do i first uninstall the global version
however anchor --version works fine on console
btw installing anchor dint make any node_modules folder
Error: Cannot find module '@project-serum/common'
Require stack:
it now says
There's a brief mention of the NODE_PATH weirdness in the installation instructions (though easy to miss it): https://project-serum.github.io/anchor/getting-started/installation.html#build-from-source-for-other-operating-systems
Or you could just run `npm install @project-serum/anchor` from within the directory you're trying to test, but that will add a node_modules folder etc. Eh.
^ yeah, you're missing the NODE_PATH update
<@!445019022338031618> the tests currently expect some node packages to be installed. You can either install them globally, `npm install -g @project-serum/anchor`, and update the NODE_PATH env variable (e.g. sometimes I run tests as `NODE_PATH=$(npm root -g) anchor test`)
i did a global installation so idk why is it giving that error
"Cannot find module '@project-serum/anchor'"
i get the error
<@!134416332509675520>  hey i wanted to checkout the solana spl wrapper so cloned the directory went to the tests section to see it for myself but when ever i do "anchor test"  while on this directory "https://github.com/project-serum/anchor/tree/master/tests/spl/token-proxy"


///////////////////////////////////////////////////////////////////////////////////////////////

https://github.com/metaplex-foundation/metaplex/blob/d1dedeacdd967ad7fc6d8003718952394875ac91/js/packages/fair-launch/src/connection.tsx#L355

Appears to be what metaplex is doing, so I assume it works
interesting - will try
Figured it out... fun fact, if you skipPreflight on the later transactions when you send them, it'll work
we've worked around transaction size by trying to find logical ways to separate different initializations or making users collect funds rather than sending them out
yeah - can be bad ux
Yeah, and the small transaction size limits make it impossible to put everything in one txn
i've been trying to find solution for this bc metaplex metadata chicken or the egg problem
Is it possible to send multiple transactions, each one after the last was confirmed, and only have one wallet approval dialog? It seems s this might not be possible, since recentBlockhash must be set before signing, but the blockhash would be different after each confirm finishes.
If you don't have linux it will fallback to your cargo installation.
Yes that package is linux only.
ohhh it's b/c I'm on OSX right?
Where do you keep the executables for various cli versions?
```
$ npx anchor build
Only x86_64 / Linux distributed in NPM package right now.
Trying globally installed anchor.
Globally installed anchor version is not correct. Expected "anchor-cli 0.16.1", found "anchor-cli 0.16.0".
```
Would be cool to have some type of version management baked into the cli, though.
Another way is to use the docker images to juggle between each version.
then execute with `npx anchor build` so it takes the project's anchor-cli and not the global one <@!392918378559438848>
to install in your project
`npm install --save-dev @project-serum/anchor-cli`
Hmmmm anyone have a good solution on managing different versions of anchor cli?
yes, I got burned with that. If they do not (you missed one, for example), everything compiles, but you get `InstructionDidNotDeserialize` during runtime. Anchor could use more error logs, something like `msg!("Args deserialize err: check #[instruction(...)] decorator")`
thanks, will try it out
Yea it's all just rust at the end of the day.
so just including this and running native builds (without the anchor suite) would work?
didnt know that this can be used by non-anchor programs as well
Example https://github.com/project-serum/anchor/blob/master/examples/tutorial/basic-3/programs/puppet-master/src/lib.rs#L17
This is already avaiable. If you use `features = ["cpi"]` in your Cargo.toml, the program will expose a `cpi` module that has all the methods available.
exactly
So the goal is to CPI/call anchor programs from non anchor programs?
specifically is there a way to generate a native rust interface (which can be used by bare programs) for https://github.com/Synthetify/synthetify-protocol/blob/master/programs/exchange/src/context.rs
essentially need to CPI into an anchor program. from a native rust program. the bare metal programs have an elaborate instruction interface (mostly in instruction.rs) which can be directlly plugged while building.
Can you elaborate on the use case? I don't fully understand why this is needed for non-anchor programs.
there must be some way to generate an instruction.rs type file programmatically no? would be glad to work on some tooling if thats possible
given the new structs like `UncheckedAccount` what is the preferred one for PDA signers?  Was previously using `AccountInfo`  I am doing seed+bump validation. on all PDAs
CPI from non anchor to Anchor
And generally no. You need to do it manually.
What do you mean by interface? An IDL or something else?
https://github.com/project-serum/anchor/blob/master/CHANGELOG.md#features-10
Is there way to generate interface for non anchor programs <@!501570363566587905> ?
changelog it is then. Do you remember which version? can't find `#[instruction` in changelog
Docs need some refreshing. üòõ
Only requirement is that the parameters there need to match the method handler.
I was going to say here https://docs.rs/anchor-lang/0.16.1/anchor_lang/derive.Accounts.html but I don't think it says much specifically about the `#[instruction]` one üôÇ
Only documented in code and change log
are the decorators like `#[instruction(bump: u8)]` documented somewhere?
I like how you didn't even have to make a separate program to get it to work, just add an extra instruction to transfer out the winnings
Yeh, you need to use the `instruction` key word
```pub fn create_exchange_account(ctx: Context<CreateExchangeAccount>, bump: u8) -> Result<()> {
``` it would be this bump
you can use parameters of a function inside a context ````#[derive(Accounts)]
#[instruction(bump: u8)]
pub struct CreateExchangeAccount<'info> {
    #[account(init, seeds = [b"accountv1", admin.key.as_ref()], bump=bump, payer=payer )]
    pub exchange_account: Loader<'info, ExchangeAccount>,
```

Q: I want to create a PDA account, with some data, but the PDA seeds are instruction parameters (seeds are not static)
Here's how I'm solving it, using "low-level" anchor... but: is there a more "anchory" way to do this?
Anyone have example of CPI from non anchor to Anchor program ?
Any way to debug the stack size issue with some info about the `Accounts`'s elements weight
Nice, thanks for sharing
but i think the "about random" is fine, as long as sums are small and play is committed properly
My first hackathon project was an attempt at a lottery, with questionnable randomness https://github.com/Arrowana/solanalotto
Thanks! My code never been released, was for a test project
139 lines of code lol
I hope you will enjoy the storytelling
https://github.com/Arrowana/cope-roulette-pro here is my writeup
so you can just fail the transaction when you don't like it
but it isn't committed separately
yes, they are doing this
it isn't a randomness issue actually but how it is used
Previously I used state struct hash + oracle BTC price, repartition might suck, but can it still be considered "Acceptable" random? Was waiting for VRF at the time
I just want to know how dumb it was
What were they using?
<@831450660146642974> you gotta give us the deets about that cope fake randomness thing
Abstraction is convenient, and I would not not use Anchor, but from time to time it make things a bit convoluted
Yeah I definitely think it‚Äôs good that people don‚Äôt have to think about binary serialisation
IMHO, since I started using Anchor I no longer have to think about the account layout, which to me, is a win. Although I haven't gone in depth in a comparison between Borsh and other alternatives
_f e e l s_
I wanna know how it makes people *feel*
Yes
It's what's used by Anchor internally, AnchorSerialize/Deserialize are just aliases if I saw correctly
What do people here think about Borsh? The only opinion I‚Äôve ever seen is from the Borsh website, and according to the website Borsh is Very Good
any tip?
I have been blowing the stack size for a while now, I was using `Account<_, DataAccount>` instead of deserializing with borsh, saved ~1000bytes

But I have a remaining 48 extra bytes, and I dont know what to change to reduce it, commenting the code or removing accounts doesn't seem to affect it
thank uu. very clutch. this was it.
Guessing you've got a 0.15.0 for `~/.cargo/bin/anchor --version`
<@!625881690614661121> mm, I haven't used the anchor-cli npm package. I guess you've npm installed anchor-cli, but you're not on x86_64 (are you on an M1 mac?), so you have to use the actual cargo binary anchor. Did you also `cargo install` anchor?
correct
sanity check, this appears to work fine but just wanna make sure im not secretly violating assumptions: i can have an `Option` type as a param to an anchor call right? and then on rust side pass `Some(1)` or `None` and on js side pass `1` or `null`?
when i check global installs  w/ npm list -g, the cli v0.16.1 is there
got a little twisted trying to update my anchor cli. Now none of the anchor commands work. any ideas?
Also you can always pull the docker images and build in there for whatever version you want.
ty!
got it
And build locally.
Just  checkout that `v0.11.1` tag
<:rope:691022802643582986>
The submodule isn't working because the branch was deleted.
yarghhh sorry about that
```
‚ûú  ~ cargo install --git https://github.com/project-serum/anchor --tag v0.11.1 anchor-cli --locked

    Updating git repository `https://github.com/project-serum/anchor`
    Updating git submodule `https://github.com/project-serum/stake.git`
error: failed to update submodule `examples/cfo/deps/stake`

Caused by:
  object not found - no match for id (a72e59a9b263b7e083af737669f12f5e3ee1997c); class=Odb (9); code=NotFound (-3)
```

any idea why i cant install 0.11.1 <a:aPES_Think:746135856783425680>
correct
Amazing - so it _is_ possible to fix a program while it's live, without changing the address and breaking its clients?
No guide that I'm aware of. Generally what you want to do is 

* write buffer: `solana program write-buffer`
* transfer buffer authority to DAO or multisig or ledger (or whatever): `solana program set-buffer-authority`
* upgrade program by generating a `BpfLoader::Upgrade`  instruction (data: `[3, 0,0, 0]`) with all the correct accounts and executing it via the dao or multisig
Thanks for the help! Will definitely go DAO. I should have been more precise - I'm asking about the _mechanics_ of upgrading programs. Is there a guide for how to replace programs? I'm wondering whether you can do it "in place" and keep the same pk address. Or, if not, if the recommendation is to break up a program into modules called by CPI, or . . .
This feels like a thing to add to solana_sdk
i see, proc macro for compile time magic
I'm attempting to test a program that does validation off of structs from the Metaplex programs and I'm struggling to test it. If i clone the needed metaplex accounts on my test validator, i can't run my anchor tests. any ideas on how i can properly test?
Yeah, `declare_id!` parse str to bytes at compile time and create Pubkey from bytes in program
The declare_id macro transforms into `Pubkey::new_from_array` which doesn't do any string parsing.
ah
That has all the runtime overhead though.
no guarantees though lol, it builds that's all
```#[macro_export]
macro_rules! pk_from_str {
    ($a:expr) => {
        {
            Pubkey::from_str($a.into())
                .unwrap()
        }
    };
}```
This seems to work
Can probably just copy most of `declare_id` https://github.com/solana-labs/solana/blob/master/sdk/macro/src/lib.rs
I noob
first macro ever
i am
Roll your own.
if that makes sense
I know declare_id but i wonder if solana_sdk has the same but to drop in place a Pubkey
to avoid the result business at runtime
Is there a macro to define a public key at compile time from a str to be a Pubkey
Or a multisig if you want to be more nimble.
Yes. Best practices is to use a DAO for such a mechanism.
Hello Solana hive-mind: are there general guidelines for **upgrading** programs? 
Say I spot a logic bug -- can I replace my program at the same address? Any best practices for this situation?
Provide your bump seed as a struct argument instead of a function argument. There is some edge case serialization bug.

So do the following

```rust
#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct Seeds {
pub bump: u8,
}
```
Thanks for the tip on alias + `npm link` that made the DX way better


///////////////////////////////////////////////////////////////////////////////////////////////

It all gets clearer when you think of solana as an operating system and accounts as the memory required for a certain program execution.
The PDA to be created is just another pointer to a certain region in memory, a predictable pointer address actually.  When creating a PDA account what you are saying to the solana operating system is to Allocate the memory space at this address for you. 

So why would it be weird for a still non allocated memory pointer to be passed to the program ? It is at the end a region of memory the program execution will use thus is needs to be specify for the program to be allowed access and not get a segfault from the kernel.

This way of framing solana has been helpful to me.
I remember reading somewhere a macro to get current programId, like key!() or something, cannot find it back <:pepeThink:844646497911046164>
Yep. Definitely kind of a funny thing to get used to. For me it's helpful to think of this in terms of the low-level solana entrypoint signature you/anchor has to implement, `(program_id: &Pubkey, accounts: &[AccountInfo], data: &[u8]) -> ProgramResult`. *Any* account your program wants to interact with needs to arrive via that `&[AccountInfo]` slice‚Äîwhich in the case of account creation is quite odd to think about, because `AccountInfo` gives you access to the account's lamports, its data, etc. I thought that was super confusing at first, since, like, you haven't even created the account yet, so what data are you looking at ü§î? The answer is that this is just how solana works, you get passed a kind of uninitialized version of the account(info), and it's only when you subsequently pass it along via CPI to the system_program that the account gets "created" (really, "initialized", with the right lamports + data allocation + owner).
Yes
To me the reason is that if the account you create is a PDA then the program needs to create it, so this one requires the seed and nonce.
This is how i do it : 
```
    #[account(
    seeds = ["init".as_bytes()],
    bump = initaccount_nonce,
    )]
    meta_data: ProgramAccount<'info, MetaData>,
```

Here is another way to do so : 
https://github.com/project-serum/anchor/blob/master/tests/cashiers-check/programs/cashiers-check/src/lib.rs#L106
Interesting - so, for new accounts, a program cannot create one _unless_ the intended address for the new account is passed in with the transaction headers?
is this possible? or all Account<> passed to the anchor method has to be initialized?
Perhaps I'm missing some macro attribute in the Initialize struct
In standard rust (without Anchor) I'd do this during the PDA creation, just passing the `total_amount` as a parameter
``` &system_instruction::create_account(
            &issuer.key,
            &pda.key,
            total_amount + cluster_rent.minimum_balance(struct_size),
            struct_size as u64,
            &pid,
        ),
        &[issuer.clone(), pda.clone(), system_program.clone()],)?;
```
How does one transfer lamports from user `provider.wallet` to pda? I have the following code:

```
#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = issuer)]
    pub pda: Account<'info, CustomAccStruct>,
    #[account(mut)]
    pub issuer: Signer<'info>,
    pub system_program: Program<'info, System>,
}

 pub fn initialize(ctx: Context<Initialize>,
                  total_amount: u64) -> ProgramResult {
        let pda = &mut ctx.accounts.pda;
        **ctx.accounts.pda.issuer.try_borrow_mut_lamports()? -= total_amount;
        **pda.to_account_info().try_borrow_mut_lamports()? += total_amount;

        Ok(())
    }
```
And I'm getting ` Instruction 0: instruction spent from the balance of an account it does not own
`
I am trying to pass an uninitialized mint to my program for CPI with:
`
#[account(zero)]
pub mint: Account<'info, Mint>
`
but the program crashes. Does anyone what should I do?
ya i got it working it was a problem with the way i named the library in `[lib]` in Cargo.toml
Were you able to get around it? In my case it was due to declare_id not being correct, you have to use the publicKey from the keypair that anchor uses
Anyone one over here who has interacted with metaplex core contracts via cpi ? is it possible to do that to interact with a non-anchor program from anchor as for a anchor program the cpi feature exposes all methods not sure how would it go from interaction on an anchor smart contract let say t o a metaplex contract.
Thanks!! I actually got around this by building the anchor-cli locally just like you stated. <@134416332509675520> helped me out
Iim actually still getting this `The given account is not owned by the executing program` error but ive double checked my declare_id, anchor.toml programIds match and printed the one being used from the test and its all the same, but i still get that error running `anchor test`

^ well i solved this by updating the `[lib]` `name` it was incorrect before since i had updated it. But now i changed it back and it still works so not sure what happened there I think maybe i had the old name still in the cargo build cache or something
like tokens I used to hold yesterday
has anyone ever ran into an issue where `getParsedTokenAccountsByOwner` returned old data
hi everyone!
<@!134416332509675520> <@731429096013168642> thank you both for helping me figuring this out! Storing the data in PDA or in the user account‚Äôs data is probably what I am looking for. I believe the official docs has some examples for PDA, and will try to see if marinade.finance is open source to look into it as an example, or if you know of more simplified example, that would be great. Again thank you both so much for helping out!
that feel when you spent ~2 days trying to fix a "bug" in your rust program but turns out it was your JS test that was wrong <:NotLikeThis:783371553727053865>
Ok, cool (lol, this has been kind of fun to debug, I'm ok with a slightly weird setup for now ü§†)
I'd swap out for x86 if you can (for solana development).
No guarantees the validator is going to work as expected with the m1.
That sounds likely related.
Other peculiarities of my setup: I'm on an M1 mac and building solana from source (idk, maybe debug builds are super slow?).
Nope, my tests are spinning up their own validator. Is that what you mean?
Any chance you're running against devnet/mainnet and not localhost? Not sure what else it could be. ü§î
Currently my misc tests are all passing, but I'm not sure why üòµ‚Äçüí´
Does anyone else run into `Transaction was not confirmed in 30.00 seconds.` errors when running tests? I asked about this a few days ago + thought I had fixed it, but it turns out I hadn't and I'm honestly pretty puzzled about what the validator is doing when it gets stuck like this. I've tried tailing the `.anchor/test-ledger` logs (some txs retry over and over then give up), wiresharking `localhost:8899` and `localhost:8900` , reading the solana rpc source (don't understand it yet).
Example here https://github.com/project-serum/anchor/blob/b1ef7431eca809dbca41601008fa220e19b8dee7/tests/swap/Anchor.toml#L8-L10
Haven't tried that myself but looks like this is the commit that added it (includes an example Anchor.toml file): https://github.com/project-serum/anchor/commit/b3803aec03fbbae1a794c9aa6a789e6cb58fda99
i saw it once in an `anchor.toml` file maybe? i dont remember the syntax
how do i specify for a program binary i have to be included in localnet at genesis?
There is a test in the tests/misc with a trailing comma in the `seeds` attribute, which was a bug has already been fixed on master (and the test was added), but I am not sure if a new release > 0.16.1 with this bug fix has been tagged. 
Either ignore that test until a new release comes out, or build your anchor cli from your checked out source in master with
`cargo install --path cli --locked`
A secondary option, if you need to create random keys/can't use PDAs, is to do so but make the account program owned AND store the user account in the account-data, later you can use a RPC call, getProgramAccounts filtering by the offset in the account data to get all the accounts related to a specific user. That's how we do TicketAccounts (Delayed-Usntake) in Marinade.Finance
The first approach would be to create a PDA, for example using the user account as seed
`anchor <command> --provider.cluster <slug | url>`
Is there a way to customize the RPC_URL used by the anchor-cli?
Not totally sure I'm answering your question in a good way, but if the account is a regular/non-program-derived account, then yeah, I think you'll just have to remember the keypair info (e.g. if you want to sign for it, you'll need to know the private key). But for program-derived addresses, the "seeds" for the account (which basically name it) will be something meaningful, e.g. a static string, or, I don't know, some other account's public key.
Thanks for explaining that. It definitely helps to verify my understanding. The challenge I am trying now to learn how to overcome is: what are the best practices to reference back an already created account? Do people serialize and store it somewhere? Like centralized backend or in browser?
Yep. Definitely feels a bit weird at first that the client has to specify *all* of the accounts the program will need to use (e.g. that's why you need to explicitly pass in the `system_program` when creating an account). In fact, about the account life cycle, when creating an account you have to pass in the (address of the) account you're creating üôÉ The account starts off in an uninitialized state (zero lamports and empty data, owned by the system program), and then e.g. `system_program::create_account` updates it to have some amount of lamports + the right allocation of data, plus possibly a new owner.
a n00b question, all states are stored on accounts. For the program to be able to modify the account state, it has to be the owner of that account right?
Now I am trying to make sense of the life cycle of the account (who create, store and reference later). So any pointers would be really great.

What I see from some of the examples so far, the client creates an account, and passes to our program, our program then mutate this account. Later on if we want to use the state stored in the said account, the client will have to find a way to reference back to this account and pass it again to the program. Is my understanding right?
Somehow this doesn't feel right to me but I didn't manage yet to find better explanation. And would really appreciate some pointers


///////////////////////////////////////////////////////////////////////////////////////////////

https://grep.app/search?q=program.coder.events.decode üòÖ
btw explorer imports mango's typescript client, so if the idl is there, it could be picked up to render these messages as human readable
After I get the IDL where do I get the code for event parser?
yeah I think I can add another project to the workspace and make that one export a bunch of anchor events
https://github.com/project-serum/anchor/blob/master/examples/tutorial/basic-0/programs/basic-0/src/lib.rs
I.e. just use this, add your `#[event]` and then run `anchor build` and take the idl from `/target/idl/basic_0.json`
And just use that for generating the event decoder.
With the event.
You can write a dummy program.
Yeah I'm willing to use the anchor stuff, but got scared away because of the handwriting the IDL
`program.coder.events.decode("<log-here>")` will return the deserialized type.
This allows one to deserialize any log for a program, given its IDL.
The way anchor does it is `sha256('event:<EventName>')[..8] || base64(Borsh(EventStruct{ ... } ))`
Here's an example of what I mean: https://explorer.solana.com/tx/3yP9hwCwcuxaCbm3yJdpscG1A8fphKHW5TfWVx5TzxS1U6s4mahY92XTjCG7ZNTDr9p8H1eyT7iivAcAktP3MFHn?cluster=devnet
Here's how I think it could work:
When you log a b64 encoding string, there is a prologue like this: "log:" or "event:" and parsers can filter lines with `if line.startswith('log:')`. All the content that comes after that has to be parsed given some parser provided by the devs of that programid. For example, mango would provide a parser to take the b64 string that follows and return a human readable string. That human readable string can be printed in the solana explorer. <@!837011211795038260> knows the most about solana explorer so maybe he can provide some insight
<@!501570363566587905> Do you think we could coordinate on a standard format for how we log events. I'm afraid of new technology and fancy things like IDLs so I just created my own borsh serialized structs and deserialization code in the typescript. But I'm willing to follow some general format so the solana explorer can parse.
Hey guys let me know if this question doesn't fit here. But does anyone know of a place I can archive data. I saw something like arweave but my preference would be to do something like a cpi but I guess I could emit events and go from there. Thank you!
Understood
design questions aren't really anchor related development questions
My understanding from the source code is that `#[account(mut)]` is purely a constraint/precondition, https://github.com/project-serum/anchor/blob/master/lang/syn/src/codegen/accounts/constraints.rs#L174; the actual account persistence stuff happens in the `AccountsExit` trait, https://github.com/project-serum/anchor/blob/master/lang/src/account.rs#L85, which seems to just auto-persist an `Account<'info, T>`'s `data` if it belongs to the program.
In basic-3, the Initialize accounts struct uses the #[account(mut)]  attribute to decorate the user field/account. Even when I remove the attribute from user in the Initialize accounts struct, the puppet program still builds and the unit tests still pass. In other words, I believe that user is still used to pay for the puppet PDA's rent exemption balance regardless of whether it is decorated with #[account(mut)]. What is the edge case or best practice reason why user might need to have the account(mut) attribute? What situation would require it? I figured removing the attribute would break the code because transferring lamports would be considered state change that needs to persist, but my guess now is the system_program handles that state.
Only on init. Without init, create_program_address is used to save compute.
ie Is this check running on every initialization of the encapsulating context or initialization of the pda
Does this mean bumps for pda accounts are only checked against `find_program_address` on init or is the bump match always checked for pdas
`Seeds for the program derived address an AccountInfo struct represents. If bump is provided, then appends it to the seeds. On initialization, validates the given bump is the bump provided by Pubkey::find_program_address`
I wanted to clarify the behavior surrounding bump checks for pdas here
https://docs.rs/anchor-lang/0.16.1/anchor_lang/derive.Accounts.html
Soorry i cant fix that problemüò©
Please don't ping.
<@!117243115676499972>
<@!448034961652449283>
<@!501570363566587905>
what im doing mistakely?
please help whats my problem?
finally when i try anchor test and always getting this error
then i change local to env()
i successfully change program id with my programid
then i deploy program correctly.
he i install ido-pool correctly

You can also do it via the system program's createAccount instruction.
https://github.com/project-serum/anchor/blob/master/examples/tutorial/basic-1/programs/basic-1/src/lib.rs#L24
Is there an example of allocating the size?
Thanks, gang.  Is there any reason why I would prefer a vec over an array?
Sounds like there is the issue that I need to set a budget _up front_ -- so the benefits of a dynamically sized vec aren't really enjoyed, in the end.
It workers but you need to allocate up front the data size required for the vec.
Was just about to write this, yeah and its a no go if you want to do a zero copy. I think its better to go with an array and just put the max size you think its gonna be.
E.g. a vec of 3 pubkeys turns into the bytes [3, 0, 0, 0, <pubkey1>..., <pubkey2>..., <pubkey3>...]
Strictly speaking I think it just "works", since Borsh is happy to serialize/deserialize vectors. I imagine it's a bit tricky in practice though because you'll have to decide ahead of time how much space to allocate for the storage?
Funny as I was just about to ask this right now.
Do you mean solana-cli-tools?
https://docs.solana.com/cli/install-solana-cli-tools#build-from-source

I built cli from source. It was tough.
Any neat Anchor-isms for **vectors** & other **dynamically sized** data in accounts?  Do I need to roll my own de-serializer for unpacking a vector (eg: https://github.com/solana-labs/solana-program-library/blob/master/token-lending/program/src/state/obligation.rs#L411)

Or do vectors "just work"?

I am trying to store data like so:
```
#[account]
pub struct Config {
    owners: Vec<Pubkey>,
}
```
I'm currently able to run the ido-pool tests on my M1. One thing that (maybe? ü§∑‚Äç‚ôÇÔ∏è) has helped: try git pulling + rebuilding solana from source.
unfortunately I don't know but I'll try to find out!
Awesome. Just need to wait for it to be released before unblocking. Do you know the target release it's scheduled for?
Hey <@!501570363566587905>  I just saw the pr for return values on solana https://github.com/solana-labs/solana/pull/19548 got merged so I think this means that https://github.com/project-serum/anchor/issues/20 is no longer blocked.

Interestingly, I got a different error for ido-pool:
It worked once, the very first time I installed it. But it keeps failing after that, even if I reinstalled the repo.
Thread
Ok sure
Just try it locally by creating multiple accounts, I'm not aware of an example in the anchor repo that uses it.
https://github.com/project-serum/anchor/blob/master/ts/src/program/namespace/account.ts#L203
It can be great help
Is there any working example for this
Intresting, I'll have a look into, account all api
Does escrow fail every time you run it?
Could you just track those attributes like timestamp of articles and votes for popularity on the solana account, then to aggregate all you can fetch all program accounts for a specific type via anchor's `await program.account.<account>.all()` api.
The test that my computer has the most trouble with is the big one, tests/misc
......
I had no issue with other program (yet). But I only went thru simple examples. Let me try with different program but a bit complex one
List features?
Oh really, it's computer's problem. I only have m1 mac (ditched intel), guess i need to ssh into aws or something....
I have no idea, how to implement list features. What I have done yet is, create a PDA for every new author, save their article on ipfs and save the ipfs cid and all the basis info in solana
Does that error happen sometimes? Or every time lol
Which part are you stuck on?
<@&889579250720575488> any suggestions
Bummer, it seems like the solana test validator can be oddly sluggish on M1 macs. I have one too, and don't have a reliable fix (I spent a fair amount of time trying to figure out what was going wrong but gave up eventually).
Yes I am on M1 mac
Ooh, interesting, someone else with a `Transaction was not confirmed in 30.00 seconds` error. I get those too sometimes. Are you on an M1 mac?
Hello
I'm studying the escrow program right now but the test is failing. I didn't touch the program. This is what I did:

1. Cloned the project-serum/anchor
2. cd anchor/tests/escrow
3. yarn
4. anchor test

And got:
Nice, you can PR on solana sdk
If you really wanted to you could add a proc-macro sub-crate to your project and crib off the `declare_id` implementation: https://github.com/project-serum/anchor/compare/master...cqfd:static-pubkey-example?expand=1
Yeah, this came up the other day too, someone suggested it should probably get added to solana.
Should look into the metaplex repo /rust , they have the documentation there iirc
is there a way to modify `declare_id!` to be used to be used in place of `Pubkey::from_str()` to do compile time parsing?

ie if i have a function that returns the id of an account:
```rust
pub fn foo() -> Pubkey {
    Pubkey::from_str("...").unwrap()
```

replace the `Pubkey::from_str(...)` a modified `declare_id!`
was also confused why it kept telling me id doesn't exist
for jetbrains stuff, you have to enable the experimental macros flag for it to be able to find it
ty
```
/// Defines the program's ID. This should be used at the root of all Anchor
/// based programs.
#[proc_macro]
pub fn declare_id(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
    let id = parse_macro_input!(input as id::Id);
    proc_macro::TokenStream::from(quote! {#id})
}
```
where is the `declare_id!` macro defined <a:aPES_Think:493353113332219924>
Hi, is there an example of how to get data from an external contract?
`T: ZeroCopy + Owner` is all it takes to make the AccountLoader work with a CPI ?
What is the best approach to create a variable size array at creation time for zero_copy?
I am thinking about an array big enough, but that can actually be created smaller by having less space in the account + another variable that is the actual max
ok N
https://github.com/project-serum/anchor/blob/3958533750c83c3e90709448c4f30ed9cce0b9b8/tests/cfo/Anchor.toml#L29-L43
Does this syntax allow N programs? or only 1?
if i want to interact with the metaplex tokenmeta data contract via cpi how would i go about doing it , for e.g for a anchor program the cpi exposes all methods of an anchor program
has anyone made a simple nft and decorated it using the metaplex token metadata contract ?
worked fine with AnchorWallet
üòÑ
from copy/pasting wallet code
This is the best package so far, to save us all
didn't expect use-wallet to ship with something anchor specific
I wrote my own crappy version, then i discovered this
oh sweet thanks
the code is the doc
https://github.com/solana-labs/wallet-adapter/blob/5dc59c463a912338e0c1483d2e4e5aca9c5cb96a/packages/core/react/src/useAnchorWallet.ts#L11-L20
the `adapter` from `useWallet` is not type compatible with anchors provider
hey guys, any docs how to integrate anchor provider with a wallet adapter?
We're waiting for a Kudelsky audit to open source. I'm sure there will be an announdement in our discord. There's a link at the bottom here: https://marinade.finance/app/staking
has anyone managed to create an nft via anchor ?
Yes that was a Derp and Derper moment. Misnamed variable and updating from 1.14 to 1.16.1 confused me
But ask in the Solana discord
I suspect it is like this because it is some sort of native call, otherwise they would not have a dedicated program to do that.
You mostly shouldn't need to refer to the program id in the accounts struct. What's your use case?
At the end of the day, it‚Äôs the same amount of computation right? Unless cross program invocations don‚Äôt count towards the compute budget or are cheaper, why would it be more expensive?
That seems perfectly fine right? You are creating as many accounts as you need :p
Oh but that does not work in the `Accounts` struct :/
Found it back! ty
How to reference to your own program in an instruction, like `Program<'_, Token>` but as my declaredId
call this thing, it might be too expensive otherwise
i think that's a mistake
Interesting. Not really sure what the status of that program is (is it live?), or how exactly to call into it. I think I might try and implement a really compact version of ed25519 signature verification on my own instead
But ipfs solution is also good though
Suppose we have 10k article then 10k pda account
But is it good idea to create new pda account for every article
This sounds absolutely cool
Each time you create a new article account, you just initialize a new pda with seeds [..., user.num_articles] and do user.num_articles +=1
It would probably be easier for you to track an article listing index, and with each article have a max amount of characters, and then the article is a PDA that uses the index as a seed
But listing article is
Yeah storing article is not a big problem
have you considered using something like ipfs or arweave for storing the actual text content of the articles, profile bio, etc...?
I know it's a noob question, but really want to know about it üôÇ
and my next question is when we create a new account, or PDA we have to specify the account size, what my understanding for account size, is how much space we are going to  reserve for the account data space. I didn't able to digest it, how can we assume how much data we want to  reserve for a  account, like author can write unlimited articles etc.
In solana user data is stored in account data space. Each user have their own account, and the data associated with them, is gonna store on their account. so how can we keep track of articles count, author count etc.
I'm planning to make a bogging platform on top on solana with help of anchor.
so my question is how can I, implement explore feature for example list all recent published article, most loved article etc.
https://github.com/solana-labs/solana/blob/8b9e472a6cc31decf0d064901c7b13c37741355f/programs/ed25519/src/lib.rs
Seems to be a program of its own
Is it possible to verify a message with an ed25519 signature on-chain in a userspace program?
Yep, misunderstood that. So issue with my local version anyway is that I was doing `#[instruction(nonce: u8)]`, which, yeah, only works correctly if the nonce is the first arg.
Those instruction args to match the method args exactly.
I was under the impression you could do `#[instruction(some_arg: T)]` and it would magically pluck it out of the instruction arguments, but looks like it tries them left to right with the raw ix data.
<@!117243115676499972> I got a little nerdsniped by your bug‚ÄîI can reproduce it and think I see the problem at least with my local version. What does your `#[instruction(...)]` annotation look like?
Yes, pyth prices are very variable as demonstrated
Seems fine as long as you don‚Äôt mind the prices being variable
Is it fine to have anchor set for localnet but one program that query pyth on devnet in the tests? ( differents providers with different url)
^ One trick I learned the other day, you can run mocha tests in the chrome debugger by running them as `mocha --inspect-brk <other args>`, then go to `chrome://inspect`. Was helpful to be able to break in `RpcFactory` `build` to poke around the `tx` that was getting sent.
Log the instruction data on the js client or recreate the test with a rust client. Either should work.
hey, running into a generic error when making an rpc call to initialize a vault based on my implemented module. ```Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: invalid account data for instruction```. Where should I start in debugging this? I logged all the account data, and they're all valiid pubkeys
What's the process to determine that out of curiosity
I guess the next question to answer is whether the bug is on the javascript client serializer or the rust deserializer.
Borsh works way too hard man really late shifts
Good question. Not that I know of. Try asking in the solana discord.
Any way to log the stack size at runtime?
when it has serialized that many u64 it must be tired, and gives up on the u8
Yeah my other instructions parse nonce first haha
sweet thanks üëç
Example here https://github.com/project-serum/anchor/blob/master/tests/cfo/Anchor.toml#L5
We need to merge [[test.genesis]] into [programs.localnet]. But basically you can specify other programs there that you might want available in your workspace.
i tend to have nonce first, so that is why i never had this bug
what does the data under `[programs.localnet]` represent? seems like the data under `[test.genesis]` gives the program all it needs to insert the binary at genesis and give it an address, no?
Thanks
Hum f I wish I knew that yesterday haha
Been zero copying even the small account
Did you switch to using `Account`? If so, use `Box<Account>` when you blow the stack.
Blowing the stack much more consistentely with anchor 1.6.1 compared to 1.14, anything I'm doing wrong? When should or not use Program instead of AccountInfo
Only happens when nonce is passed at the end of the args
Nonce first is also fine!
Makes me think it's a serialization bug.
Nonce only is fine.
but it appears that the value in the nonce is being passed through accurately?
Sec trying it out
Or putting the nonce first
What happens if you remove all the other args and just have the nonce?
What's interesting about this bug is that it seems to only show when you have multiple arguments.
something like that
```
    await this.program.rpc.initializePrices(
      new BN(utils.getNativeAmount(markPrice)),
      new BN(utils.getNativeAmount(initialMarginBuy)),
      new BN(utils.getNativeAmount(initialMarginSell)),
      new BN(utils.getNativeAmount(maintenanceMarginBuy)),
      new BN(utils.getNativeAmount(maintenanceMarginSell)),
      new BN(utils.getNativeAmount(liquidationIncentive)),
      nonce,
      {
        accounts: {
          prices: prices.publicKey,
          zetaGroup: this._zetaGroupAddress,
          prices,
          authority: this.provider.wallet.publicKey,
          systemProgram: SystemProgram.programId,
        },
       }
    );
```
I don't expect any js code to be actually production ready, it is barely possible to write working code, so surely borsh js is bugged
what was the code before the struct?
I call it from JS yeah
Called from js is that right?
Must be a problem with borsh.
ü§î
It's a serialization bug - putting it into a struct worked
maybe it is out of whack there
How about the js code calling this?
Sure
To rule out any serialization bug.
Can you try putting all those into a struct.
```
    pub fn initialize_prices(
        ctx: Context<InitializePrices>,
        mark_price: u64,
        initial_margin_buy: u64,
        initial_margin_sell: u64,
        maintenance_margin_buy: u64,
        maintenance_margin_sell: u64,
        liquidation_incentive: u64,
        _nonce: u8,
    ) -> ProgramResult {
 ```
What do your args look like to the method?
Seems pretty odd haha, i've tried changing the seeds as well
<@!501570363566587905> ?
Yeah whoops, thinking some more lol
Oh wait, am I misremembering create_program_address
create_program_address uses the nonce you provide in the seeds
<@!117243115676499972> ~~are you sre the bump/nonce is right? When you call `create_program_address`, it's possible that solana needed to come up with *another* bump, because the stuff you passed in didn't generate a valid PDA (an address off the curve etc.)~~
e.g. using this raw checking in the smart contract 

```
        let pda = Pubkey::create_program_address(
            &[PRICES_SEED.as_bytes().as_ref(), ctx.accounts.zeta_group.key().as_ref(), &[_nonce]],
            ctx.program_id,
        )?;

        msg!("PDA : {:?}", pda);
        msg!("Passed in PDA: {:?}", ctx.accounts.prices.key());
```
Produces this in logs
```
Program log: PDA : ANebHnAiwcHTyzs6oyruEwhHYPxTcNVAN8UgUVZxVqbC
Program log: Passed in PDA: ANebHnAiwcHTyzs6oyruEwhHYPxTcNVAN8UgUVZxVqbC
```

But using this in the PDA initialisation fails

```
    #[account(
        init,
        seeds = [PRICES_SEED.as_bytes().as_ref(), zeta_group.key().as_ref()],
        bump = nonce,
        payer = authority,
    )]
```
Seems weird since every other account in my program is also a PDA and those work fine (same method and function calls etc...)
Hey, has anyone run into some rogue issues with PDA on account initialization?

So I have this PDA that i'm initializing an account with, and using the #[account(init, seeds[..] ...), results in `Program failed to complete: Could not create program address with signer seeds: Provided seeds do not result in a valid address`

However, if I just pass in the raw PDA as an AccountInfo, and check the PDA created from the signer seeds + nonce passed in manually via `create_program_address` they are the same pubkey string and `create_program_address` doesn't throw.

This leads me to think that something is wrong with my Accounts struct but there is nothing apparent.  üòì
There's no instruction versioning, though that would be great to add in a future version.
`git checkout v0.13.0`.
Checkout the git tag and build from source directly.
... having some trouble downgrading to an older version of anchor-cli:
```
$ cargo install --git https://github.com/project-serum/anchor --tag v0.13.0
    Updating git repository `https://github.com/project-serum/anchor`
    Updating git submodule `https://github.com/project-serum/stake.git`
error: failed to update submodule `examples/cfo/deps/stake`

Caused by:
  object not found - no match for id (3dc83f47b66a8a4189a637368c49dca1341c6b23); class=Odb (9); code=NotFound (-3)
```
Is there any sort of version control for program upgrades? Like determining difference between historical tx's for different iterations of the smart contract
Nice thats awesome, thanks
The program will error. Try it out!
I was wondering about something, never tested it. If i have two accounts of different type but of similar structures like :
```
struct A {
 U: u64
}

struct B {
 U: u64
}
```
And i have a program that expect a struct A, can someone use an account containing struct B while using the programs method ?
They will fail.
Out of curiosity, if I reference an account that was already initialized, what will the `init` constraint do?  Is it safe for me to call instructions multiple times with the same account passed in under the `#[account(init, ...)]` constraint?
I think the alternative pattern of invoking `createAccount` in a prior instruction was probably more convenient prior to Anchor, since it's a bit of a pain to setup all the CPI code manually everytime you want to create an account. But with `init`, that's no longer the case.
Correct.
Good to know.  And, I understand that's what the `init` constraint in the `account` attributes takes care of for us transparently? https://github.com/project-serum/anchor/blob/2c827bc839f7e67c25597c055c373833314583c0/lang/syn/src/codegen/accounts/constraints.rs#L373
In most cases no it doesn't matter. I prefer doing everything inside of one instruction, though, since it's less boilerplate and more intuitive to me.
(I'm going through this guide: https://paulx.dev/blog/2021/01/14/programming-on-solana-an-introduction/#trying-out-the-program-understanding-alice-s-transaction -- in which case the end-user is creating the account, only to transfer its ownership to the program.  This seems like an extra step to have the SystemProgram own an account for a brief moment, but maybe that's how it has to be?)
This is hugely helpful.  Bonus question! Is there a general best practice  between the alternatives: creating the account ahead of time, or passing in an un-initialized account address to a program?
I want a program to own a new account.  I can either call `SystemProgram.createAccount` as a _user_ and transfer the ownership to the program, or I can have the program create the account itself.  Is there a reason why I should prefer one rather than the other?


///////////////////////////////////////////////////////////////////////////////////////////////

To get a better understanding
Alright will look it up
A trait wasn't made. An existing--and very common `From` trait--was implemented. Otherwise, everything else is correct.
For each struct*
Or is it different for every account causing the need for it to be implemented seperately for each trait
Question is cdnt this be implemented generically and could be imported from a package
Aha so instead of creating another fn u just made a trait for it
But it's quite nice to move that CpiContext transformation out of the instruction handler, imo.
You could also just use a regular function.
I was confused a lot trying to figure out that trait code xD
By the way <@134416332509675520>  is there a demand of a tutorial for creating tokens/nft via anchor is it something  we will see more of in the future
Tyyyy
Ohhhh
Those are just standard Rust helper things‚Äîthey aren't really strictly necessary. In the instruction handlers, when you do `token::transfer(ctx.accounts.into(), amount)` etc., Rust uses those `From` trait implementations when caling `.into()`. They're just a standard Rust way to convert from one type to another‚Äîyou could do the conversions manually, it's just that people expect conversions to happen via `.into()`. Just a rust convention.
Yessss
replied to wrong person, sorry.
I don't have many answers for you because I haven't gone down that path.  I'm just pointing out that there is a distinct difference from Puppeteering.
Ah, sorry, I was asking <@!445019022338031618> what traits he was asking about
Do you mean e.g. the `From<&mut ProxyMintTo<'info>> for CpiContext` things in token-proxy's lib.rs?
It's CPI into a non-anchor program, so it's making an anchor proxy for that program.  Puppet program is different- it is anchor to anchor.
the token wrapper you're looking at is calling a non-anchor program. That is likely related to what you're seeing.
For cpi don't we just take the accounts from Js , import the struct from the puppet program and make a cpincontext out of that ?
<@501570363566587905>  what is the need for creating traits for CpiContext ?
Any reason that here:
https://github.com/project-serum/anchor/blob/master/ts/src/error.ts#L11
it doesn't use `super(code + ': ' + msg)`?  params is never used internally here.
Alternatively, if for some reason we want to maintain this `msg` separate from `super.message`, on line 35 and 40 add the param `errorCode + ': ' + errorMsg`?  I can PR if I'm not missing some reason we're passing through params that dont exist.
Anyone who used these examples could explain ?
I think its a mocha issue.  If I inline a catch for an error and print it - it looks good:
```ProgramError
    at Function.parse (/usr/lib/node_modules/@project-serum/anchor/dist/cjs/error.js:40:20)
    ... redacted
  code: 163,
  msg: 'Failed to deserialize the account'```
but when mocha prints at end of test run, it doesnt use tostring
Ok, yeah, agreed that it's annoying
It becomes frustrating when many tests have expected onchain errors - so the actual error gets lost in the sea of other expected errors
Oh, got it.
I do, but not in the context of the test failure.  just as "background noise".
debugging now, it parses properly - just doesn't display on output from tests
You mean you don't see errors like this?
In my anchor tests, I never get actual chain program errors bubbling up, it always just has:
```  Error
      at Function.parse (/usr/lib/node_modules/@project-serum/anchor/dist/cjs/error.js:40:20)```
and I have to go dig up the onchain messages from the output above. The line references where the error parsing should be happening, but its failing - or is this just how the error is shown in tests?  I can dig farther if needed.
Is this normal!?
> authority account
these are usually keypairs, but not actual accounts (but they can be).  Point is that when an account reference has _authority_ in the internal name, I assume it's used just as signing to prove ownership and no data on that account.
Or enum type
In the spl token proxy example in tests, what is the need for traits and enum type, there is strait for each of the proxy functions, but I don't understand the need for traits.
It*
Ya got ot
So I need to create token account , mint accountz another token account, authority account
PDA _must_ be created by the program.
Situation is creating a nft
Are pda generally created in rust by the program itself using the account macro
depends on the situation
What is the better thing to do ?
depends on the program
Or we can do it in rust too
<@99911938955309056>  we make all accounts on the Js side right ?
https://docs.rs/anchor-lang/0.16.2/anchor_lang/derive.Accounts.html
Is there documentation on the account macro to see what parameters it takes , use case is to make a pda using a seed, butnidk what parameter it takes.
One more thing
Hmm I guess I could give it a go
that's exactly how you move out of noob status üôÇ
Only problem Is am a total newbie to rust, I could try making one looking at your spl wrapper
Albeit I only need one wrapper that is the create metadata function
Hmm although I would try making anchor wrappers for a few  functions in token metadata
Candy machine is a separate program from the metadata program. But yes, you can also use candy machine.
Isn't the candy machine using a anchor wrapper to generate an nft and it's metadata ?
There is not. You can create one though.
Also <@501570363566587905>  is there a wrapper for the metaplex token metadata contract in order to generate metadata for a token I create using anchor wrapper for spl ?
Account will also add two additional safety checks

* Check the "owner" of the underlying account info is correct
* Check the "type" of the data is correct

For this reason, AccountInfo is better called `UncheckedAccount`.
`Account` would represent anything you have a struct def for and want deserialization over its state.  `AccountInfo` is just going to give you a raw data property.
I think u misunderstood me, I wanted to know diff between Account , Accountinfo, are they interchangeable if not what kind of accounts come under account vs accountinfo
~~lol, that one get rolled up too recently? That's a shame, I liked that explicitly popped out.  U sure? Not working like that here.  It's the token program account - not the token account~~
no
Program<'info, token> would now be Account<'info, Token>
Just to clarify for any lurkers, this is fine:
cloning what?
In that case, I'd think it's written not inline for readability / debuggability.
aha, indeed - then the lifetime is fine.
Yeah, have to inline the whole call to `token::transfer` [edit: rereading your screenshot]
Why are you cloning it
temp borrow on the nonce u8 array
eh, I disagree, I have issues attempting to inline this. Can you show the rest of that line <@!445019022338031618> ?
Exactly what i meant
The compiler is smart enough to do it inline
`CpiAccount` and `ProgramAccount` have recently (0.15.0?) been rolled into just `Account`.  `Account` would represent anything you have a struct def for (Cpi or "Local").  

since spl token has an anchor wrapper already, we'd specify these things as:
`Program<'info, Token>` (the token program)
`Account<'info, Mint>`  (a mint)
`Account<'info, TokenAccount>` (a token account)
`Signer<'info>` (an owner or delegated authority of anything needed, like mint authority or token owner)
Could u use the same example u explained the concept with
Wow this was a great explanation , could u also tell what kind of accounts we make in anchor terms, we mainly use 2 types, account and account info, how do I know which account is account(cpiccount,program account), account info?
I poked around to see if I understood the rust, it's easy to run into little lifetime issues if you move things around (`temporary value dropped while borrowed`). Inlining everything works though üôÇ
Yes
Do you mean why write it that way, rust-wise? I guess there is quite a lot of rust weirdness packed into a few lines there
this explains so much. I need to `wsl --shutdown` more often to freshen these test machines. 900 "init" processes running.

I think I just found the problem, because when I tried to start up a separate local validator, I'm getting a conflict.  I think I've got a rogue local validator running
Hmm. Could the way you're initializing the provider on the js side have changed?
everything is accounts.  your wallet is a system owned account, spl token program is an executable account. when you create a mint, you create a mint account owned by spl token program (using the spl token program). when you want to receive a token, you create a token account (using the spl token program), owned by token program. When you mint tokens to that token account, you call the token program and provide it all these accounts and sign for the mint authority (in a simple case, your wallet account).

It's not easy to explain - requires a LOT of reading of the accounts page on docs.solana.com
<@!306185268879425538> hi standaa months ago you were getting this error: ```Property 'rpc' does not exist on type 'StateNameSpace'
``` and I am getting it today. To be clear it works when you do anchor test, but it doesnt work when I try to put it in my client. Did you find out what the problem is?
The only thing confusing me is how to think about all of this via accounts, how do i think abt it in the solana /anchor way be it any solution for e.g creating a token.
hey i wanted to clarify my understanding on how tokens are created vs in ethereum , here it goes 
So in solana via the spl we initialize a mint(a token, we get its address  store it  in a token account) we then mint this token give it a supply etc, where we give the recipient the system program, the spl token program id. alas our token is made, we can now transfer it or call any other function on it
yeah thats all set to the default. same in the anchor.toml.  i nuked the `.anchor` directory to be sure its starting a fresh ledger; no dice
I think anchor test defaults to looking for "~/.config/solana/id.json", so I wonder what your `solana config get` says for your keypair path.
I think that happens here https://github.com/project-serum/anchor/blob/master/cli/src/lib.rs#L1591. Did you change your `solana config` at all?
So starting last night, anchor tests are all starting with an empty wallet balance for my provider wallet.  Any idea what's causing that, and what is meant to bootstrap the test ledger with lamports for the provider?  I'm assuming it is down in anchor-cli, but figured I'd ask here
Why are we doing this dark magic
https://github.com/project-serum/stake-v2/blob/master/programs/lockup/src/lib.rs#L118-L123

create seeds which is a reference to a slice, create signer by cloning seeds and create a reference to slice which stores a reference to the clone of seeds
Great, thanks a lot for the help!
correct
Ahhh right, so upon calling my program, it will read the data and deserialize -> token_account. I then mint to the account, the `data` gets changed but the token_account remains unchanged, I would need to deserialize again from that updated data if I wanted an updated token_account - is that right?
that isn't exactly how it works, the accounts are accessed directly by the runtime
https://github.com/solana-labs/solana/blob/4e2754341514cd181ae3f373cc2548bd22e918b8/sdk/program/src/account_info.rs#L22

so when doing the cpi to mint, the token program writes to the data. It is just not updating the TokenAccount because TokenAccount has an `amount` that isn't tied to the underlying data anymore  https://github.com/solana-labs/solana-program-library/blob/master/token/program/src/state.rs#L129-L139
Thank you, starting to make a bit more sense. 
https://github.com/project-serum/anchor/blob/master/spl/src/token.rs#L25
So it looks like the accounts get cloned and then the data within those cloned accounts gets modified?
the token account is parsed once at the start, changing the raw data (minting) does not affect my_token_account
Could someone kindly explain why I'm seeing this behaviour if it's obvious.  Example code:
```
        let cpi_accounts = MintTo {
            mint: ctx.accounts.my_mint_account.to_account_info(),
            to: ctx.accounts.my_token_account.to_account_info(),
            authority: ctx.accounts.my_mint_account.to_account_info().clone(),
        };

        let seeds = &["my-seed".as_bytes(), &[nonce]];
        let signer = &[&seeds[..]];
        let cpi_ctx = CpiContext::new_with_signer(ctx.accounts.token_program.clone(), cpi_accounts, signer);

        token::mint_to(cpi_ctx, amount)?;

        msg!("Amount after: {:?}", ctx.accounts.my_token_account.amount);
```
It's still showing the amount in this account as 0 in Rust after the CPI, but if I check the account via the JS client after the transaction has completed, it has in fact minted correctly and amount/supply is fine. I checked with a couple of the examples programs in the Anchor repo and it's the same there if I log right after. What am I missing?
if you have one already just put it in the target folder `target/deploy/` - you also need to add it to your anchor.toml + declare_id! if you haven't already
When running `anchor build` with an empty target folder, anchor generates a key pair. Is there a way to override this to use a custom one?
The official jsonrpc docs might be more complete https://docs.solana.com/developing/clients/jsonrpc-api#getprogramaccounts
Oh wow <@!134416332509675520>
Isn't the library ultimately talking to the jsonrpc stuff? Slightly surprising to me that you'd have options for how to encode the entire response, not just the data parts (only the data parts can be big).
Ah, hmm. As far as I can tell from the solana source it looks like the encoding is supposed to be for the account's data, not the response.
That‚Äôs the encoding for the entire output I just want the data section
<@!721781658906525837> looks like the docs mention an optional encoding scheme https://michaelhly.github.io/solana-py/api.html#solana.rpc.api.Client.get_program_accounts
In this example, they are using the python api to get all accounts owned by a program. I am struggling to figure out how to decode the data key. Is it a base58, how could I confirm that? I have tried: 
`b_str = str.encode(str)`
`output = b58decode(b_str)`

I have looked through this: https://michaelhly.github.io/solana-py/api.html
but have not found anything that works. 
Any hints/tips would be helpful
Is there a plan to support C-like enums? Id like to have a bitvector where each bit is represented by an enum but it seems that c-like enum values are not saved to the idl
In the metaplax data there is a "creators" field. It can be flagged as signed for each creator.  This is how you'd grab a collection (indexing on this is another whole thing tho)
meanwhile, once more `cargo test-bpf` back in business
This would be awesome!
https://github.com/solana-labs/solana/issues/20279 it can be done almost, but the PR will involve some pain
but --clone goes through `clone_accounts`
that is a shame because the underlying thing actually can do arbitrary data
https://github.com/solana-labs/solana/blob/62c8bcf56582cd0e9c93c45f8eb75773bba97ce2/core/src/test_validator.rs#L203-L225
oh ok i thought it could do both
You can clone, but you can specify arbitrary account data at genesis time.
or are you saying adding those at runtime?
we can do --clone for those can't we?
The validator doesn't expose this functionality though.
ah yes exactly that
Then we can have predefined scenarios with spl token accounts, dex acccounts, etc.
The other thing that would be amazing would be the ability to create custom accounts in a localnet with arbitrar state.
This could be useful in some cases
I was dreaming yesterday of tempering with the USDC mint authority and making myself a whale on localnet
then fiddle with it
you can dump an entire program state, let's say a market
i think a file is pretty powerful
it seems to work with a url or a even a file
That would be quite nice.
Does this work for accounts?
Yea we should do that.
https://github.com/project-serum/anchor/issues/533
So solana-test-validator --clone isn't implemented in anchor yet
cool, ok thank you
Just that the rust client is not setting the isSigner correctly, which means the tx always fails in the event another duplicate account doesnt coincidentally set isSigner.
https://github.com/project-serum/anchor/blob/master/lang/src/signer.rs#L26
Still checking in the program.
or was it still checking that it is in fact a signer in the program?
lol that is pretty dangerous stuff
I see, so it use to do nothing at all
Fixed here https://github.com/project-serum/anchor/pull/762
I'll publish now.
Try the latest master cli.
Ah yea that's fixed separately in the next release I think.
but i am using the rust instruction
isSigner is set
See if isSIgner is set properly.
Can you inspect the IDL?
0.16.1
What version are you on?
it must be not marking it as signer possibly, thus giving KeypairPubkey mismatch
then it is bugged, i just tested again
If not this is a bug.
I causes a KeypairPubkey mismatch, which is odd
There is something i don't get with the new `Signer<'info>` I used it where i use to have a `#[account(signer)]` but it doesn't work in all cases
cool, it s not like im moderating here üòÄ, if you do that little test let know how it went.
But yes probably off topic sorry
100% correct - I was more trying to address the question of how do you query for all NFTs of a collection - if you are presented w/ an NFT it is easy (creators for one) to verify it's apart of a collection, but the question I can't seem to figure out is how to discover those in the first place
but you cant fake the verified creators.  anyway, its more of a metaplex discord type of discussion.
Right so in that case then mint authority is somewhat useless to "verifying" because each token will have a unique mint authority (the masteredition account)
If you done createMasterEdition, which should be done to be considered a NFT, then the authority is transfered to the MasterEdition account. It also locks the number of editions, so if supply is 0, no copies are possible.
Also one of the other problems I see w/ using mint_authority as truth is that it doesn't prevent the original creator from printing more. e.g. "10k NFT launch" Unless you check the program that is doing the minting, then they could just mint another 5k and if you only mint authority then those will seem like part of the original "collection"
So create new mint, mint 1 token, add metadata, then set_authority on original mint to collection you want to replicate ? Might write a test for this real quick to see if it works
I suppose I haven't tried this yet, but I figured you could just run set_authority on the TokenMint and change it to whichever collection you are trying to fake - the question would be if you can set_authority on something without signing it with that account?
How would you fake mintAuthority?
FWIW I think some of the NFT marketplaces require a JSON list of all minted Token IDs and use that to verify projects
You can't just go off mintAuthority otherwise they would be easily faked, so I think you'd have to look at the original minting
I believe the only way to do this is to find the original program and look at all mint instructions? Been wondering this myself - if anyone has a better answer would love to hear it
Yeah, PDAs don't have keypairs (they're deliberately constructed to not lie on the elliptic curve, so they don't have private keys). If you need to sign for them then you need to know their seeds + bump.
Looks like not possible, have to use seeds and `invoke_signed()`
Thank you <@!117720371548913670>, by the way. üôÇ
Do I necessarily need **seeds** (and a bump?) if I want to transfer tokens from the PDA to some other address (assuming I don't have PDA's keypair)?
does anyone know how nft collections can be queried (e.g. find all token accounts for degen apes)? doesn't seem like there's anything associated with the accounts that would group them together other than data in the uri
This link displays the old API. The new one doesn't require you to provide the `EventName` as a string. It's, instead, inferred from the log itself.
If you want to just parse a single log line, you can use this https://project-serum.github.io/anchor/ts/classes/eventcoder.html#decode.
So you have a couple options. If you want to parse the entire `logs[]` for the given transaction, you can use https://project-serum.github.io/anchor/ts/classes/eventparser.html#parselogs.


///////////////////////////////////////////////////////////////////////////////////////////////

yeah should be fine. just need to make sure nothing weird happens when I add it to the mango-v3 workspace.
Yea it's hacky, but just use a dummy instruction and program to generate the IDL for now.
Also noticing idl only gets created if there's a program. I can just have a bunch of `#[event]` structs
We should change the parseLogs API to return an array of events, instead of that silly callback.
it should be a lot easier to create the transaction than some of the other votes because it's just a SPL token transfer
i'll happily submit the proposal
Please make proposal I will vote in favor
if you could share this when you're done that would be great. might start doing this as well
Let me know if you have any problems with the code above.
I will now gladly accept a grant for retroactive funding from the mango DAO. Thank you ser.
```typescript
import { EventParser, Coder } from '@project-serum/anchor';
const idl = {...}; // your idl here
const coder = new Coder(idl);
const parser = new EventParser(programId, coder);

// Parse a string[] of logs from a transaction.
parser.parseLogs(logs, (event) => console.log(event));

// Parse a single log.
coder.events.decode(log);
```
I plan on replacing all our logs with Anchor events. We already have this scraper written in ts and that scraper just needs to parse the events and write into the SQL db
oh ok the tests are good. I'm just trying to speed up my development by copying over code. It's the set up stuff in js that scares me the most üòÉ
Just the tests. Can you elaborate the user story? Do you already have the `string[]` and just need to decode it?
<@!501570363566587905> do you know of any examples where the event parsing is being used on the client side?
Any time you want to `init` an account, you ultimately need to pass in the system program as one of your accounts (that's just because in solana you always need to pass in all accounts you'll reference, including any programs you CPI). Anchor in particular just expects you to always name the system program account as `system_program: Program<'info, System>`.
Got it thanks for the clarification
ATA is just a seeds convention for a PDA that gets attached to the associated token program, which allows token accounts to be created on someone else's behalf
you can just set your own seeds
it would be a PDA owned token account, and it's not necessary
Would a program owned token account use the associated token account?
Do I miss anything or does that allow anyone to mess with this
(quoting these lines specifically https://docs.rs/spl-token-metadata/0.0.1/src/spl_token_metadata/utils.rs.html#808)
The check in the metaplex `spl-token-metadata` create_metadata_account seems like a fence
Not something very anchory... But if I have a mint authority account without associated metaplex metadata, that I can derive the adresse myself, and that this account has been revoked the authority...

Can I arbitrarily create that data account at the given adresse and fill it with my data?
becuse its already system account and dont have an any solana.
i think it can not initialize with faucet
this program works when i remove init func.
Any error associated with it ?
What do you think the solution might be ?
That it cannot find the system program i guess
im trying to upgrade this old program .

what cannot find value `system_program` in this scope means?
the command ```anchor build``` is giving out an empty target folder. anyone know why?
the only enums I found are in `pyth` and `swap` and those are all unit-like
do any of the IDLs from the examples have an enum with a C-like struct variant?
Oups
I actually don't think I can add the ed25519 program with `--bpf-program`, since it doesn't build to a bpf program right?
That would require idl importing/merging. Should be doable in the future.
<@!501570363566587905> seems like there is a pretty steep limitation with composite, I cannot use any Accounts that is imported
Looks like this is targeted for the 1.8.0 release btw https://github.com/solana-labs/solana/blob/master/programs/ed25519/Cargo.toml#L13
I always struggled to understand how this works lol
i installed the latest and still can't see the feature
Yeah so I've noticed üòû  that's what happens when SOL price jumps through the roof vs. a couple months ago
unfortunately the solana discord is now 95% "How do I M@ke a NFT plz?" creating significant noise and not much get through
Trying this out shortly, and will report back üëç
unless this requires some underlying voodoo, it should work
Got it, ok that makes sense
no copying, build it from source and add it with --bpf-program
In terms of adding it myself, I'm basically copying over the program, rebuilding, and then re-running the `solana-test-validator`?
Ok so it doesn't look like it's here: https://github.com/solana-labs/solana/tree/v1.7.12/programs
I am not sure, but if it isn't there you can easily add it yourself
Sorry just to back up for a sec, if I'm running a `solana-test-validator` on the latest testnet release (1.7.12), would I have the ed25519 verify program locally?
most likely not on mainnet then
...
added 25 days ago
Yeah I'm not seeing it there either
to see if something is turned on `solana feature status -um` but i cannot find it there somehow
alright will give this a shot tonight, thanks
https://github.com/solana-labs/solana/blob/master/sdk/src/ed25519_instruction.rs#L27 it is in the sdk
just give it a go and see
I've bumped this a couple times in the solana discord but not getting any responses from anyone there. Would really appreciate being pointed in the right direction here if that's possible. ed25519 signature verification is really important to what I'm building, and I even rolled my own on-chain version (which predictably exceeded the compute budget). Is there anyone I can ping about this?
https://github.com/solana-labs/solana/blob/8b9e472a6cc31decf0d064901c7b13c37741355f/docs/src/developing/runtime-facilities/programs.md#ed25519-program
or maybe it's not clear
The comment `// Should be already checked by now.` seems to indicate it is
I have actually never tried to use it, the solana discord would be better for htis
Hey, I'm following up on your message from yesterday with 2 questions:

1. Are you sure this program is callable? The instruction appears to just be a no-op (https://github.com/solana-labs/solana/pull/19266/files#diff-f7537a31cded4dae8943299ed6c7dc2b5c3eacf40ff99ee17e4c50cea9effe26R11) and I found this issue  https://github.com/solana-labs/solana/issues/19843 which suggests that this might not be usable.

2. If that program is callable from another program, do you know where I can track its status, and figure out when the scheduled devnet, testnet, and mainnet releases are? Arbitrary verification of ed25519 signed messages is something that's crucial to a project I'm building for the hackathon and was planning on having my project ready on devnet by the deadline.
nice
Yes.
I am thinking it might be less terrible to actually provide the accounts one by one, as the max number of account is known
If i want to go composite but I have 2 `"Accounts"` that actually need variable numbers of accounts, I am screwed, am I?
Thanks, I'll try that üôÇ
Ah yeah I didn't use a custom space, I just used the default for the struct.
This is very likely the problem.
None --> [0], Some(x) --> [1, <x bytes>]
One way you could get that is if you forget to allocate the +1 of space that borsh uses to serialize the option.
Hey had a q from before - Has anyone run into issues serializing an `Option<T>` into an account? I initialize the account with `None` which is fine, but once I try to write `Some<T>` into the Option, I get `AccountDidNotSerialize` error.
The problem was with lifetimes in the function argument. For some reason I've added those.

I've just removed the lifetimes from the argument, and it worked.
Perhaps someone in the future finds this useful. üôÇ
You might take a look at how `spl/src/tokens.rs` wraps `invoke_signed` invocations to the SPL token program, they pass seeds as an argument (bundled into a CpiContext). I haven't looked at it closely yet but lots of lifetime parameters around.
Thank your
How do I pass the `signer_seeds` as a parameter without encountering lifetime issues like this `temporary value dropped while borrowed`
I'm making a wrapper of my own around `invoke_signed`:

```
let seeds = &[      ctx.accounts.vesting.to_account_info().key.as_ref(),
            &[ctx.accounts.vesting.nonce],
        ];
        let signer = &[&seeds[..]];
my_wrapper(acc_info_0,
      acc_info_1,
      account_info_2,
      token_program,
      signer, // <------- This is the param I want to pass
      amount,
      );
```
We need a wall of shame counter for people that tag Armani. To keep score. üòÇ
<@!501570363566587905> I do apologise for tagging but can you check tg? i had a question for you yesterday.
thanks
If you go `Vec` you just need to be sure to allocate enough space for the size of the `Vec` that you expect
`vec` would have been fine, but my use case I ended up using [] since its a small fixed size.
<@!99911938955309056> I am trying to find a data structure where I can have dynamic amount of spot market informations inside an account. I guess you were discussing about `vec` and array. are you still using `vec` or ended up using array?
Fair enough. Might be an idea for the future. Being able to google them would be good addition
Nothing that I know of. Searching the discord is the best tool right now.
<@501570363566587905> I wonder if there is an existing knowledge base compiled from the questions/answers happening here? I believe this would be really valuable and potentially more discoverable
yeah - it's an edge case.
We'd need to add a new section to the IDL for constants.
Yea that's not available atm.
yeah
By constant you mean a variable?
heh, fails when the size in the array is a constant tho.  That's a bug in the syn.
Yes it should.
If I use `[Pubkey; 5]`, it'll pick that up, right?
I have a fixed size Vec.  Perhaps should just use `T[5]`
Ah gotcha.
This is specific to `Vec`
It already does.
To avoid extra client code?
for the createInstruction to intellgently use it I suppose.
Why do you need it in the IDL?
üëç  yeah I see the sizeOverride.  Just was wishing there was a way to markup the rust to get it to bubble into the idl.
No changes to the IDL are necessary though.
The rust client doesn't do the math yet, if I recall correctly.
The ts client already does the math. But for, e.g., for a vec, one still needs to be explicit.
**When using variable length fields (ex: Vec)**, what's the best way to be explicit on an account size in order for clients' createInstruction to use the proper size?  Is there a way to get that into the IDL, or do clients have to do the math?


///////////////////////////////////////////////////////////////////////////////////////////////

I think your braces are off there, it should be `seeds = &[ &[PDA_SEED, pubKey.as_ref(), &[_bump_seed] ] ]` I think
I want to generate seeds for a pda with multiple inputs and a bump seed. I've only really seen documentation for generating seeds for a pda with one input (seed string) and a bump seed. Any help on how to format? Here's some sample code attached.

If I do it this way bump_seed generates an error saying expected &[u8], found u8
The `has_one` macro attribute
```#[account(mut, has_one = pda_token_acc)]
    pub pda: Account<'info, MyStruct>,
    pub pda_token_acc: Account<'info, TokenAccount>,
```
effectively translates to the account validations check like this:

```if ctx.accounts.pda_token_acc.key() != ctx.accounts.pda.pda_token_acc { Err(ProgramError::InvalidArgument)? };
```
amirite?
wrap your test cases with try/catch block, by this  you would atleast see the errors properly :))
`solana config get`?
Hi ! we can't use Vec<Account<'info, T>> yet, is there another way to do the same thing ?
`account` must be owned by the system program.
which exactly checks this constraint  `owner = system_program`?
```
#[account(owner = system_program)]
pub account: AccountInfo<'info>,
#[account(address = system_program::ID)]
pub system_program: AccountInfo<'info>,
```
although all of this should be fine by default in the example repo
Yea, I'd change the wallet in anchor.toml
that's my best guess
or they're missing the right programId in anchor.toml
it probably means they don't have the right programId declared
This is your error code and what it means
[
    LangErrorCode.AccountNotProgramOwned,
    "The given account is not owned by the executing program",
  ],
you can try running the new pull request, the first 3 tests run fine, i just haven't finished all of them yet
Okey i continue waitingü•≤

https://github.com/project-serum/anchor/pull/699/files
but it won't be done for a few more days
i'm working on an update to ido-pool
For example when i download ido-pool
can you be more clear about what you want your program to do and what you're having trouble with
oh this is rich kids of solana
Its very difficult and not works
anchor/tests
If anyone can share this program with me i send 1 solana instantly
Hello guys i need very simple example token mint deposite and withdrawal example for anchor
There are some examples of js tests checking error codes in the tests/ directory, e.g. https://github.com/project-serum/anchor/blob/master/tests/lockup/tests/lockup.js#L121
<@!501570363566587905> Are you open to adding a prologue in the `emit!` macro? One issue I discussed with <@!705250151291158528> is when we add a new anchor event to the program but the client doing the scraping of events doesn't yet have the updated IDL. In that case scraper will just move on thinking that line wasn't a valid log event

EDIT: turns out easiest thing here is to just add a msg! above emit!. Doesn't cost much at all
also is there a way to check my anchor config file ?
how do i check on which net is anchor deploy trying to deploy ?
getting this error while trying to deploy metaplex nft candy machine smart contract
"Error: Account 5TYATQXThFAEPHgGKTY4CLTs3PAw2ZzV6Nycauuwn86M has insufficient funds for spend (2.50613592 SOL) + fee (0.00788 SOL)
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }."
Hi guys! there‚Äôs a constraint I have in my struct, something like: #[account(‚Ä¶ constraint = A = B)] , when I write a failure test case where in A ‚â† B, I see an error in the console but it doesn‚Äôt get caught in the catch block. The RPC calls fails due to SendTransactionError. Can anyone please help share a sample test that can demonstrate how to handle the failure test case properly? üôÇ
Is it possible close an account and recover its balance? the target account is a candymachine config account created by me but now it is owned by the candymachine program. But it would be very useful for any account with a use onetime behaivour.
yes, i do that sometimes but you lose the simplicity
and use program.instruction.<method>
You could just construct your own transaction to let things happen in your desired order
Quite problematic to move away from it when something has to happen after
the `program.rpc.<method>` does not allow for postInstructions, should it?
this was useful by the way, thanks. I hadn't thought of debugging PDA seed errors this way

In the end it turned out it was a different seed than i originally thought that was causing the error and that the string was indeed not the same in the two of them. But this approach definitely helped me to get there quicker for sure
It's also possible to use https://crates.io/crates/solana-program-test in some cases
is devnet the best way to test integrations with other protocols via cpi? 

i‚Äôve been trying this on localnet but there‚Äôs a good amount of manual, protocol-specific setup involved after deploying their contracts
Yep the usual, but it's back up now. Been having this consistently. But yep I'll wait
Maybe fake news but someone in a chat mentioned devnet was having some problems
Deploys fine to localnet/testnet, any leads? I doubt that's related to anchor, but Solana discord pointed back here
I'm unable to upload program to Devnet, even resuming the deployment does not work. Always having `
Error: Data writes to account failed: Pubsub error: ConnectionError(Protocol(HandshakeIncomplete))` error
Sounds like a bug.
yes
Are you implementing `#[derive(AnchorSerialize, AnchorDeserialize)]` on the custom type and do you have the types set as `pub`.
is USDC/USDC possible?
wen USDC/SOL
please do coin transitive
the PRT manics have a PRT/SOL
actually cost should be around almost 0, with the account indexing thing
cannot do coin
Oops haha
ah true, it only swap transitive with common pc
In `SwapTransitive` the pc is the same on both markets. So `pc_wallet` is pulled out to dedup.  https://github.com/project-serum/swap/blob/master/programs/swap/src/lib.rs#L401-L402
To avoid duplicate variables.
I just modify code until it works
i suspected the stack size issue above, not sure. I have to admit i don't know what withcraft Accounts is involved in
I honestly reckon there isn't a reason why it's outside, was confused by this a while ago too.
is there a way to debug why the idl produced by `anchor build`  is missing one of the accounts and types i have defined? <a:aPES_Think:493353113332219924>
I am heavily copying this code so i need to know the whys
https://github.com/project-serum/swap/blob/master/programs/swap/src/lib.rs#L585-L617 question for the guru, why is coin_wallet in MarketAccounts but pc_wallet in the Accounts above Swap?
<@!812755783405797376> https://github.com/project-serum/anchor/compare/master...cqfd:rust-submodule-example?expand=1
Yeah 2 secs
Do you have a link?
Hm, this seems to work fine for me (or at least I can use submodules in other directories etc. from my main program file, just have to be kind of careful about the rust rules for modules in separate files etc.)
when installing anchor cli via npm on github actions, where does the cli actually get installed? is it `/usr/local/lib/node_modules/@project-serum` as is the usual path for ubuntu installs?
kk thats what i thought ty <a:salute:741132551724204083>
it is the same budget for 1 instruction at the top, so if you do any CPI, it is in the same 200k budget
how does compute limits work with a program that dispatches instructions to other programs?

lets say i have program `A` with instruction `1` that calls program `B` with instruction `1` that calls program `C`.

Essentially when constructing the transaction you would create an instruction to program `A` calling instruction `1`. internally the program will create instructions and dispatch calls to `B`, which dispatches a call to `C`.

does the entrie call graph here `A -> B -> C` have an allocation of 200k compute units, or does each individual call `A->B`, `B->C` have 200k units allocated each?

i know if you call `A`, `B`, and `C` from a transction you create client-side with each being an individual instruction, they would each have 200k units, however im at a bit of a loss how this works when the instruction you make to a program triggers another instruction
Thank you for trying to help me üôÇ
Oh could be, I'm a rust novice. I've seen a lot of project just use the lib.rs when using anchor, not sure why but there might be some special limitation then. Sorry for unhelpful link <:pepeThink:844646497911046164>
the cargo build succeeds, its the anchor cli thats failing i think
I read online that mod.rs in sub directory is deprecated
interesting im inlining the mod from `src/math/fee.rs` into my `src/lib.rs`
Probably this chapter, specifically 7.3 https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html
let me find a link for you
It's rust specific, each sub dif must contain a mod.rs with inside "mod file". And top level muse also include that "mod directory_name"
If I remove the subdirectory the issue goes away
I also get that when I run `anchor keys list`
I'm trying to have a sub directory in my anchor program e.g. there's `src/lib.rs` and then `src/math/fee.rs` but when I do that and run `anchor build` I get `Error: could not find file`
How to have anchor conditionally deploy on devnet or localnet? 
Should I specify `[programs.localnet]` twice for different cluster with same adresses?
Cool, I'll try the classic way to create a PDA account, too used to anchor now haha
lgtm
Just incase i'm being silly...  the zero copy implementation I have replaces Box<Account..>> with Loader and the accounts look like this

```
#[zero_copy]
#[derive(Default)]
pub struct ProductGreeks {
    pub theo: u64,
    pub delta: u32,
    pub gamma: u32,
    pub volatility: u32,
    pub update_timestamp: u64,
}

#[account(zero_copy)]
pub struct Greeks {
    pub nonce: u8,
    pub product_greeks: [ProductGreeks; 138],
}

impl Default for Greeks {
    #[inline]
    fn default() -> Greeks {
        Greeks {
            nonce: 0,
            product_greeks: [ProductGreeks {
                ..Default::default()
            }; 138],
        }
    }
}
```
I thought it was a zero copy...
With zero copy this shouldn't be a problem since you don't actually load in all the account data onto the stack.
I wanted all the space i could get so it isn't a pda because pda have a size limitation somehow
ok
That won't work with a PDA though. :/
`zero`
no
So if you ever have one of those on the stack (how does the heap work in solana?) you're already kind of screwed?
Possibly dumb question, just to see if I'm following: a `Greeks` account struct is something like 1 + 138 * (8 + 4 + 4 + 4 + 8) ~= 3865 bytes, which is already pretty close to the 4k stack limit‚Äîis that the issue we're talking about?
Did you `init` it via the derive macro?
tens of thousands of bytes
it is actually weird, i tried with a gigantic array and it works just fine
Fwiw this problem will go away in your case once this issue is addressed https://github.com/solana-labs/solana/issues/13391
I'm not sure.
I'm a little surprised the stack is blowing with zero copy.
Thanks! I'll try that. What's the underlying reason here?
Unfortunately the easiest work around right now is to pass in `UncheckedAccount` and manually create the PDA, as you would without Anchor.
So this one complains about `BorshSerialize` not being implemented for 138. The zero_copy complains about stack blowing up.
Was just copying the anchor examples though.
Yes - I think so. (Unless I didn't do it correctly..)
Does zero copy still blow the stack?
```
#[derive(Accounts)]
#[instruction(nonce: u8)]
pub struct InitializeGreeks<'info> {
    #[account(
        init,
        seeds = [GREEKS_SEED.as_bytes().as_ref()],
        bump = nonce,
        payer = admin,
    )]
    pub greeks: Box<Account<'info, Greeks>>,
    pub admin: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```
Can you also share the `#[derive(Accounts)]` struct?
So that's what I got up to with trying Box
```
#[derive(Default, Copy, Clone, AnchorSerialize, AnchorDeserialize)]
pub struct ProductGreeks {
    pub theo: u64,
    pub delta: u32,
    pub gamma: u32,
    pub volatility: u32,
    pub update_timestamp: u64,
}

#[account]
pub struct Greeks {
    pub nonce: u8,
    pub product_greeks: [ProductGreeks; 138],
}

impl Default for Greeks {
    #[inline]
    fn default() -> Greeks {
        Greeks {
            nonce: 0,
            product_greeks: [ProductGreeks {
                ..Default::default()
            }; 138],
        }
    }
}
```
Can you share the derive accounts struct?
Did you try boxing the other vars in the accounts?
I can't use Box because my array size isn't implemented by Borsh, it's currently length 138, but could be greater than that - I'm hoping there's a simple fix? üòõ
Did you try boxing?
Hey, so read the messages around here for initializing a PDA within an anchor instruction greater than some size. My account should only be around 3kb~ and I am running into the same issues mentioned above

```
Error: Function _ZN73_$LT$zeta..context..InitializeGreeks$u20$as$u20$anchor_lang..Accounts$GT$12try_accounts17h78806ff135be0a45E Stack offset of -4464 exceeded max offset of -4096 by 368 bytes, please minimize large stack variables
```

Still wasn't sure about the recommended approach to solve this - Am trying using zero_copy as well. 

<@!99911938955309056> could you explain your solution to organising accounts?
Oh I see it doesn't pass the slop into the docker exec command.
can do it, but it doesnt pass on the slop.
Probably... I just realized I should be in the beginner questions group. I am just trying to learn Anchor and this stuff is slightly above my head... I'm just going to reset and see if I can get my program to work from there
I guess you could also have an out-of-date IDL file in your project's target/idl? But anchor test usually rebuilds everything.
Mm... trying to think how you could get in that state. Are you running your own solana-test-validator or are you letting `anchor test` spin it up? (E.g. what does `lsof -i :8899` say when you aren't running any tests?)
I'm using anchor test
That anchor error means InstructionFallbackNotFound (0x65 == 101, you can see the full error mapping in ts/src/error.ts). How are you invoking your program? Not sure how you get that error unless you're invoking an instruction that doesn't actually exist.
What does this mean?
Transaction simulation failed: Error processing Instruction 0: custom program error: 0x65
Can you do `anchor build --verifiable -- --features...`
^ this is accurate, doesn't impact me, but something to be aware of.  In my case, we use features just for activating test code.  featureless would always be the one running through verifiable, so this is fine
looks like slop was added - so `anchor build -- --features "feature1 feature2"` works, but  `--verifiable` support was missed?  Looking at commits.
Thank you!
Yes see `.anchor/program-logs/`
or something?
Is there like a log
How do I read a smart contract's msg! in anchor test?
List is here https://github.com/project-serum/anchor/blob/master/lang/syn/src/idl/mod.rs#L112
Probably true, but still not a good idea imo to use usize for any API types.
true, but I heard solana only runs on 64bit
Need types with well defined size.
usize isn't valid since it's architecture dependent.
obv it's not that important because usize is just u64 in practice
sweet this works. What if I wanted to add something like usize into anchor? Is there a list of accepted types somewhere?
Yea you'll need to use i128 across the IDL boundary and translate to/from your type.
I think it'll be hard adding support for I80F48 which is just a transparent wrapper around i128. Should be easier to just take the js i128 BN and pass it into our I80F48 class
okay so went through some previous similar errors, this is related to insuff funds. tho i have funds.
<https://github.com/solana-labs/solana/tree/master/programs/bpf_loader/src>
weird, i don't know where they store the error.rs
My intuitive guess is that your error is from the solana program used for deploying and that a `1` error is insufficient funds but i will check
https://www.rapidtables.com/convert/number/hex-to-decimal.html?x=0x1
whats error 0x1?
heya! got a deployment error  ``` Deploying program failed: Error processing Instruction 1: custom program error: 0x1 ```
You can add types via

```
#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct MyType {...}
```

And it will work. You can use that type as a field in your `#[event]`
What's the type?
Do you know the procedure if I want to add support for a new type in the idl?
You mean `#[index]` ? It's not. You can remove it.
I'm guessing the label field also not necessary
yeah true. the IDL helps a lot
haha I meant other indexers.
I am a loyal subject
not interested in anchor competitors
(You could also easily build this yourself i you wanted)
You just give it an IDL and it populates a databse with a graphql endpoint.
Also <@!748249199606497502> , if you use Anchor events, you'll be able to use vybe network and any other competitor that pops up, which will provide a service to build an automatic index on Anchor events.
(I spent about an hour trying to figure it out haha)
That is it! Thank you!!!!!
that might be it?
did you declare the program id in the anchor.toml
Error: failed to send transaction: Transaction simulation failed: Attempt to load a program that does not exist
I am having issues with anchor test after the update to 0.16.2... I am relatively new to anchor so might just be me, but does anyone have thoughts


///////////////////////////////////////////////////////////////////////////////////////////////

