Thank you very much!
This is a change in newer versions of anchor.
That's saying when you use `init`, don't do `seeds = [...], bump = some_bump`; instead do `seeds = [...], bump,` (no equals sign after bump anymore)
was wondering if anyone has ever encountered this before and knows how to fix it.

Hello guys, I'm having some issues when trying to deploy my code with `anchor deploy`. Getting this error: thread 'main' panicked at 'Code not parseable: Error("bump targets should not be provided with init. Please use bump without a target.")', lang/syn/src/idl/file.rs:357:58
ooo interesting, ok I jotted this trick down for if I need it in the future. Thanks!
I tried that on drift's codebase and it chopped the size down to 943kb (at the cost of a bunch of stack space errors, lol, so can't win them all)
To your top-level Cargo.toml
One trick you can try is adding 
```.toml
[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
```
But for comparison, drift's program is 1.2mb
also not sure if u had a chance to see my DM 👀
hahah fair
I don't write programs, I just answer discord questions lol
how much are ur programs alan?
It's 1.1 MB
target/deploy/
where can i find my .so file?
I don't think there's a max.
It depends on how big your`.so` file is (each tx can only upload about 1kb at a time)
My program is taking 1000 transactions to deploy. Is that a lot? What's the maximum limit?
I wanna log something out in the dep program
yes Im just playing around with both
I thought you switched to cloning?
interesting tho, I made some changes (added msg!) in the deps programs, and seems it didnt not change during invocation
working like a charm!!
ah sorry let me do that also
You need to clone it too
Right, that's what I meant above about the upgradeable loader program data account
I just tried 
```
[test.validator]
url = "https://api.mainnet-beta.solana.com"
[[test.clone]]
address = "hausS13jsjafwWwGqZTUQRmWyvyxn9EQpqMwV1PBBmk"
```
err from `anchor test`
```Transaction simulation failed: Attempt to load a program that does not exist ```
😆
speaking of this.... is there a way to check programmatically? or can only rely on the officially release data?
But at least you know you're hitting the exact same code as on mainnet
One downside, fyi, is that it can be kind of tricky to figure out which version of code is actually deployed on mainnet :/
wow this is pretty brilliant
ah and those programs get deployed in my local test validator during anchor test?
Yep.
It lives in an account after all
You fetch the entire program from mainnet
Which you can get by doing
```.js
const programDataAddress = findProgramAddressSync(
    [theProgramIdInQustion.toBytes()],
    new anchor.web3.PublicKey("BPFLoaderUpgradeab1e11111111111111111111111")
  )[0];
```
but without locally built binary, how does my localnet know where how to run the logic? Or it fetch the binary from the test validator?
And for cloning program accounts you generally need to clone *both* the main program_id address as well as the upgradeable loader program address
The syntax changed in recent versions though, think it's now `[[test.validator.clone]]` instead of `[[test.clone]]`
Example syntax
```.toml
[test.validator]
url = "https://api.mainnet-beta.solana.com"
[[test.clone]]
address = "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"
[[test.clone]]
address = "PwDiXFxQsGra4sFFTT8r1QWRMd4vfumiWC1jfWNfdYT"
[[test.clone]]
address = "GvDMxPzN1sCj7L26YDK2HnMRXEQmQ2aemov8YBtPS7vR"
[[test.clone]]
address = "WMW5xc3HypXwTnPesyUT49uLsyHwNURsWAEk39onKuk"
```
You can also, by the way, just clone that account from mainnet etc., rather than building the dependency locally
Yeah, it uses some "genesis block" trickery
ahh another question ~~
in my local test Ive been using this practice in `Anchor.toml` to test integration with other program
```
[[test.genesis]]
address = "hausS13jsjafwWwGqZTUQRmWyvyxn9EQpqMwV1PBBmk"
program = "./deps/metaplex-program-library/target/deploy/mpl_auction_house.so"
```
in fact the binary `./deps/metaplex-program-library/target/deploy/mpl_auction_house.so` is also built by me locally, but this address `hausS13jsjafwWwGqZTUQRmWyvyxn9EQpqMwV1PBBmk` is the prod address of the program. May I know if there is some kind of mocking mechanism going on there? Otherwise Im sure my local keyPair wont give me `hausS13jsjafwWwGqZTUQRmWyvyxn9EQpqMwV1PBBmk`
thanks so much <@!134416332509675520> ! Have a great day!
Yeah
follow up question lets say I'd like to integrate another open source solana program, but no package is published on crate.io. That means I will need to pull from their git as my dependencies, will that also have the "cpi" feature for me to switch on?
But yeah you should just update to 0.20.1 probably lol
But haven't thought that through very much
I think the fix for this is to have a separate, slow-moving crate for anchor's types/traits etc. that don't change between most version bumps.
Yeah, I'm not sure the best way to handle situations like this, unfortunately :/ I think it's effectively a bug in anchor tbh, since it's very easy to have multiple copies of anchor-lang floating around in dependencies and they don't interact nicely with each other.
wow turns out mpl-auction-house was compiled against 0.20.1
Check you Cargo.lock and see if two different versions are floating around?
I checked the lib and my local should be both using 0.19
I guess something to do with lifetime
yup this Ive read also
let me reproduce that error again 😆
Look at the https://book.anchor-lang.com/chapter_3/CPIs.html for an example of CPIing to another anchor program dependency
What goes wrong? I think it will be easier to get that import working than to try to reverse engineer it yourself
Something like that, yeah
you mean like this ```mpl-auction-house = {version="1.0.2", features = ["no-entrypoint", "cpi"]}``` right?
I tried to import the https://crates.io/crates/mpl-auction-house, but no luck getting it work
Using `features = ["cpi"]` I think
There ought to be a way to just depend on the auction house program, since it's already an anchor program
Oh. Why are you coding that yourself? That won't work, since you won't include the sighash
I coded that instruction myself ```
#[repr(C)]
#[derive(BorshSerialize, BorshDeserialize, PartialEq, Debug, Clone)]
pub struct CreateAuctionHouseArgs {
    bump: u8,
    fee_payer_bump: u8,
    treasury_bump: u8,
    seller_fee_basis_points: u16,
    requires_sign_off: bool,
    can_change_sale_price: bool,
}

/// Instructions supported by the Metadata program.
#[derive(BorshSerialize, BorshDeserialize, Clone)]
pub enum AuctionHouseInstruction {
    CreateAuctionHouse(CreateAuctionHouseArgs),
}

```
dont think it has a `.data()` function
Does it work if you just call `.data()` on that AuctionHouseInstruction thing? rather than .try_to_vec().unwrap()
Im not sure if its because of the fact that auction-house is anchor based so I cannot do it in the plain old solana CPI way due to the discriminator( I guess this is anchor framework specific right?)
and call it via
 ```
        // payer will pay for authority
        solana_program::program::invoke(
            &create_auction_house(
                ctx.accounts.ah_program.key(),
                ctx.accounts.treasury_mint.key(),
                ctx.accounts.payer.key(),
                ctx.accounts.authority.key(),
                ctx.accounts.fee_withdrawal_destination.key(),
                ctx.accounts.treasury_withdrawal_destination.key(),
                ctx.accounts.treasury_withdrawal_destination_owner.key(),
                ctx.accounts.auction_house.key(),
                ctx.accounts.auction_house_fee_account.key(),
                ctx.accounts.auction_house_treasury.key(),
                authority_bump,
                fee_payer_bump,
                treasury_bump,
                seller_fee_basis_points,
                requires_sign_off,
                can_change_sale_price
            ),
            creator_ah_info.as_slice(),
        )?;

```
maybe I paste my code here
```
#[allow(clippy::too_many_arguments)]
pub fn create_auction_house(
    ah_program_id: Pubkey,
    treasury_mint: Pubkey,
    payer: Pubkey,
    authority: Pubkey,
    fee_withdrawal_destination: Pubkey,
    treasury_withdrawal_destination: Pubkey,
    treasury_withdrawal_destination_owner: Pubkey,
    auction_house: Pubkey,
    auction_house_fee_account: Pubkey,
    auction_house_treasury: Pubkey,
    bump: u8,
    fee_payer_bump: u8,
    treasury_bump: u8,
    seller_fee_basis_points: u16,
    requires_sign_off: bool,
    can_change_sale_price: bool,
) -> Instruction {
    let accounts = vec![
        AccountMeta::new_readonly(treasury_mint, false),
        AccountMeta::new_readonly(payer, true),
        AccountMeta::new_readonly(authority, false),
        AccountMeta::new(fee_withdrawal_destination, false),
        AccountMeta::new(treasury_withdrawal_destination, false),
        AccountMeta::new_readonly(treasury_withdrawal_destination_owner, false),
        AccountMeta::new(auction_house, false),
        AccountMeta::new(auction_house_fee_account, false),
        AccountMeta::new(auction_house_treasury, false),
        AccountMeta::new_readonly(spl_token::id(), false),
        AccountMeta::new_readonly(solana_program::system_program::id(), false),
        AccountMeta::new_readonly(AssociatedToken::id(), false),
        AccountMeta::new_readonly(sysvar::rent::id(), false),
    ];

    Instruction {
        program_id: ah_program_id,
        accounts,
        data: AuctionHouseInstruction::CreateAuctionHouse(CreateAuctionHouseArgs {
            bump,
            fee_payer_bump,
            treasury_bump,
            seller_fee_basis_points,
            requires_sign_off,
            can_change_sale_price,
        })
        .try_to_vec()
        .unwrap(),
    }
}

```
I went with the plain old solana invocation kinda way
It uses the first 8 bytes of the instruction data, the "sighash", which in pseudocode is sha256("global:the_instruction_fn_name")
oh cuz you havent signed
i cant get it tho
I suspect my CPI call couldve been done wrongly but havent figured out what exactly I did wrong.
out of curiosity, how does a program distinguish which instruction Im sending to it? I remember there is this 8 bytes identifier, but where do I find it?
Looks like you're invoking the contract at least. Do you know how to find that error code? It's from an older version of anchor, https://github.com/project-serum/anchor/blob/v0.18.2/ts/src/error.ts#L56, and means you're somehow not sending a correct instruction (the contract doesn't know what your instruction means).
Hi all, Im trying to create a wrapper on top of the metaplex auction house contract, I added the program under the `deps` in my repo for testing, somehow it keeps returning 
```
  logs: [
    'Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS invoke [1]',
    'Program log: Instruction: CreateAuctionHouseWithProxy',
    'Program log: CPI',
    'Program hausS13jsjafwWwGqZTUQRmWyvyxn9EQpqMwV1PBBmk invoke [2]',
    'Program log: Custom program error: 0x65',
    'Program hausS13jsjafwWwGqZTUQRmWyvyxn9EQpqMwV1PBBmk consumed 4245 of 184689 compute units',
    'Program hausS13jsjafwWwGqZTUQRmWyvyxn9EQpqMwV1PBBmk failed: custom program error: 0x65',
    'Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS consumed 19556 of 200000 compute units',
    'Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS failed: custom program error: 0x65'
  ]
```
I checked previous messages in the channel but did not find anything useful so far
any idea is appreciated !!
Ah, interesting! Nice find
Ah, no, looks like you're just making the instruction—you're not actually *invoking* it, with `invoke`/`invoke_signed`.
this you can get in the inside the transaction object itself already I believe
Hey. Is it possible to know the transaction signature without authority signatures?
can the `anchor-client` lib be used to call non anchor programs?
<@!134416332509675520> just a post-mortem on the issue I was having on a null memory access violation
used `program.instruction` instead of `program.rpc`
changed `&str` to `String` now it's fine
```
pub fn update_metadata(ctx: Context<UpdateMetadata>, md_bump: u8, program_as_owner_bump: u8, new_name: &str) -> ProgramResult
```
^ this causes the error
```
pub fn update_metadata(ctx: Context<UpdateMetadata>, md_bump: u8, program_as_owner_bump: u8) -> ProgramResult
```
this one does not
oh interesting the error goes away when I change some parameters for one of the instructions
Anyone seen this error before?
```
error[E0637]: `&` without an explicit lifetime name cannot be used here
  --> programs/solana-program/src/lib.rs:14:1
   |
14 | #[program]
   | ^ explicit lifetime name needed here
   |
   = note: this error originates in the attribute macro `program` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0106]: missing lifetime specifier
  --> programs/solana-program/src/lib.rs:14:1
   |
14 | #[program]
   | ^ expected named lifetime parameter
   |
   = note: this error originates in the attribute macro `program` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider introducing a named lifetime parameter
   |
14 ~ #<'a>[program]
15 | pub mod solana_program {
16 |     use super::*;
17 |
18 |     pub fn init_staked_counter(ctx: Context<InitStakedCounter>) -> ProgramResult {
19 |         let user = ctx.accounts.user.key();
 ...

Some errors have detailed explanations: E0106, E0637.
```
How can I get a transaction before it's signed via the anchor typescript program API? I want to create multiple transactions then send them all to the wallet at once so there isn't multiple signature requests sent to the user's wallet
How would you use anchor BN to multiply a value by a decimal value. For example if I have a number like 1,000,000,000 and want to multiply it by 1.0006, how would I do that?
Hi guys, how can I restrict transfer function for an SPL token while creating a mint
Thanks, seems like a ton has changed.
https://github.com/project-serum/anchor/blob/master/CHANGELOG.md
Where can I see the breaking changes between different versions of Anchor? I am still on 0.18.2 while it moved to 0.22. Want to see and understand what changed from where I was to now.
Is there a simple way for me to delete and recreate an account within the same instruction? If I wanted to increase size for example?
👀
I guess there should be a CPI-Context right?
Am I calling this cpi wrong?? 

```
 pub fn process_painting_mint(ctx: Context<ProcessPaintingMint>, _artist_license_bump: u8) -> ProgramResult {
        let metadata = &mut mpl_token_metadata::state::Metadata::from_account_info(
            &mut ctx.accounts.nft_metadata_account.to_account_info(),
        )
        .map_err(|_| ProgramError::InvalidAccountData)?;
        
        msg!("uri : {}", metadata.data.uri.to_string());
        msg!("is_mut: {}", metadata.is_mutable);
        msg!("updateAuthority: {}", metadata.update_authority);
        
        
        mpl_token_metadata::instruction::update_metadata_accounts_v2(
            ctx.accounts.token_metadata_program.to_account_info().key(), 
            ctx.accounts.nft_metadata_account.to_account_info().key(), 
            ctx.accounts.payer.to_account_info().key(), 
            Some(ctx.accounts.artist_license.to_account_info().key()), 
            None, 
            None, 
            Some(false)
        )?;
     
        let metadata = &mut mpl_token_metadata::state::Metadata::from_account_info(
            &mut ctx.accounts.nft_metadata_account.to_account_info(),
        )
        .map_err(|_| ProgramError::InvalidAccountData)?;
        

        msg!("uri : {}", metadata.data.uri.to_string());
        msg!("is_mut: {}", metadata.is_mutable);
        msg!("updateAuthority: {}", metadata.update_authority);
        Ok(())
    }
```

My program log shows no hint of a CPI, 

```
> Program log: Instruction: ProcessPaintingMint
> Program log: uri : https://ipfs.io/ipfs/QmPeSgw8kUdg87gwHsUG57PbNuKcSm47yo8m4i6gGUaR2X
> Program log: is_mut: true
> Program log: updateAuthority: JCRbBUd7GvqwhZHbW3AAjgzXhjYmciDJuKkQh8bzpFt1
> Program log: uri : https://ipfs.io/ipfs/QmPeSgw8kUdg87gwHsUG57PbNuKcSm47yo8m4i6gGUaR2X
> Program log: is_mut: true
> Program log: updateAuthority: JCRbBUd7GvqwhZHbW3AAjgzXhjYmciDJuKkQh8bzpFt1
> Program DdKA9HKJeB3YC8XeKsMzqr79SXXxF1DjjBQzAixkrrWd  consumed 51860 of 200000 compute units
> Program returned success
```
for the `fetchMultiple` for anchor accounts, will it preserve the order. ex. `fetchMultiple(1, 2)` where 1 and 2 are addresses, will the returning list be `[account 1, account 2]`?
you 2
thanks
I want to keep my program IDs the same 😦
i gotta hit gym... good luck man
maybe try resetting program ID and deploy on a diff laptop with a diff wallet?
What amount of SOL are you requesting?
ohhh shit. I dont get throttled for 12 hours damn
All my other programs deployed to devnet
Everything works locally, e2e test pass on localnet
it does but after a few tries it throttles me for like 12 hours
is the problem w deploying the program? or with using it
so like u try to interact w devnet as a user and it doesn't work?
I get throttled on devnet airdrops
wym by locked out of airdrops?
I tried it on 3 terminals at once, and that made all of them not work
Thats what they said too but I have kept getting locked out of airdrops when i deploy to devnet
but it should work eventually
for me, it takes ~5 times to get it to work
hmmm
sup man 😛
What's up yeetle lol. Yea was conversing with another person that had this problem also a few days back. I spun up my own devnet rpc on quicknode and it still didn't work so I'm at a loss now. It's a showstopper for our demo because the program not deploying is our accounts program.
I've heard other people are having the same problem
yeahhh i have been experiencing this problem a ton in the last week. It's really slowed down my dev time
My program used to take 500 txns to deploy to devnet, but it takes 1000 txns now that I upgraded anchor to the latest version
Hey all, still stuck on one larger program deploying to devnet with a timeout. Has anyone found a workaround for this issue or have any suggestions? It would really suck to have to refactor this right now, we're announcing an airdrop tomorrow and want to have devnet for people to play on.
Does anyone know the correct way to derive the metaplex metadata account? This is now throwing an expected account to be initialized error and Im pretty sure its the metadata account.
Cool!
thank you so much, it works. anyway it's wired before, I remember I didn't put "amount" into instructions.
ok. let me try to do it. thank you
No, you need to drain the tokens first
It's necessary to match instruction(...) arguments left to right, no matter what (otherwise things will silently or not silently do weird stuff)
(I really don't want to be able to do that)
Can I close a token account if I still have tokens left in it?
In another functions, it worked without need to put amount in instructions
You need to say `#[instruction(amount: u64, pool_seed: String)]`
Issue is that your `#[instruction(...)]` arguments don't match the order of your instruction function's arguments
```
 await program.rpc.depositCollateral(deposit_amount, poolSeed, {
                    accounts: {
                        userAuthority,
                        userCollateral,
                        collateralMint,
                        stateAccount,
                        collateralPool,
                        userAccount,
                        systemProgram: SystemProgram.programId,
                        tokenProgram: TOKEN_PROGRAM_ID,
                        rent: SYSVAR_RENT_PUBKEY
                    }
                })
```
I am gettting this issue. Anyone has idea?
```Program log: Instruction: DepositCollateral
    Program log: AnchorError occurred. Error Code: InstructionDidNotDeserialize. Error Number: 102. Error Message: The program could not deserialize the given instruction.```

```#[derive(Accounts)]
#[instruction(pool_seed: String)]
pub struct DepositCollateral<'info> {
    #[account(mut)]
    pub user_authority: Signer<'info>,
    #[account(
        mut,
        constraint = user_collateral.owner == user_authority.key(),
        constraint = user_collateral.mint == collateral_mint.key()
    )]
    pub user_collateral : Box<Account<'info,TokenAccount>>,
    #[account(mut)]
    pub collateral_mint: Account<'info,Mint>,
    // state account for user's wallet
    #[account(mut,
        seeds = [state_account.protocol_name.as_ref()],
        bump= state_account.bumps.state_account
    )]
    pub state_account: Box<Account<'info, StateAccount>>,
    #[account(
        mut,
        seeds = [state_account.protocol_name.as_ref(), pool_seed.as_ref()],
        bump = state_account.bumps.pool_usdc)]
    pub collateral_pool: Box<Account<'info, TokenAccount>>,
    #[account(
        mut,
        constraint = user_account.owner == user_authority.key()
    )]
    pub user_account: Box<Account<'info, UserAccount>>,
    // Programs and Sysvars
    pub system_program: Program<'info, System>,
    pub token_program: Program<'info, Token>,
    pub rent: Sysvar<'info, Rent>
}```

```
pub fn deposit_collateral(
        ctx: Context<DepositCollateral>,
        amount: u64,
        pool_seed: String
    )-> Result<()> {
```
Oh lol 🤦‍♂️
Isn't that first line making a mint?
```
const nft = await actions.mintNFT({
      connection: program.provider.connection,
      wallet: program.provider.wallet,
      uri: "https://ipfs.io/ipfs/test",
      maxSupply: 1,
    });

    const nftATA = await spl.Token.getAssociatedTokenAddress(
      splATP,
      splTP,
      nft.mint,
      treasuryKey
    );
    const metadataProgram = new anchor.web3.PublicKey(
      "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"
    );

    const [nftMetadata, nftMetadataBump] =
      await anchor.web3.PublicKey.findProgramAddress(
        [
          Buffer.from("metadata"),
          Buffer.from(metadataProgram.toBuffer()),
          Buffer.from(nft.mint.toBuffer()),
        ],
        metadataProgram
      );

    const tx = program.rpc.readMetadata({
      accounts: {
        payer: program.provider.wallet.publicKey,
        nftMint: nft.mint,
        nftTokenAccount: nftATA,
        nftMetadataAccount: nftMetadata,
        tokenMetadataProgram: metadataProgram,
      },
    });
    console.log(tx);
```

```
pub fn read_metadata(ctx: Context<ReadMetadata>) -> ProgramResult {
        let metadata = mpl_token_metadata::state::Metadata::try_from_slice(
            *ctx.accounts.nft_metadata_account.try_borrow_data()?,
        )
        .map_err(|_| ProgramError::InvalidAccountData)?;
        msg!("uri : {}", metadata.data.uri.to_string());
        msg!("is_mut: {}", metadata.is_mutable);
        msg!("updateAuthority: {}", metadata.update_authority);
        Ok(())
    }

pub struct ReadMetadata<'info> {
 pub payer: Signer<'info>,
 pub nft_mint: Account<'info, Mint>,
 pub nft_token_account: Account<'info, TokenAccount>,
 pub nft_metadata_account: AccountInfo<'info>,
 #[account(address = mpl_token_metadata::ID)]
 pub token_metadata_program: AccountInfo<'info>,

}
```

Hey could anyone tell me why this simple program to read the metadata of an NFT isnt working? 
Currently Errors out with `Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 2: custom program error: 0x26`

```
Program 11111111111111111111111111111111 invoke [1]
    Program 11111111111111111111111111111111 success
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [1]
    Program log: Instruction: InitializeMint
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 2457 of 200000 compute units
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success
    Program metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s invoke [1]
    Program log: (Deprecated as of 1.1.0) Instruction: Create Metadata Accounts
    Program log: Transfer 5616720 lamports to the new account
    Program 11111111111111111111111111111111 invoke [2]
    Program 11111111111111111111111111111111 success
    Program log: Allocate space for the account
    Program 11111111111111111111111111111111 invoke [2]
    Program 11111111111111111111111111111111 success
    Program log: Assign the account to the owning program
    Program 11111111111111111111111111111111 invoke [2]
    Program 11111111111111111111111111111111 success
    Program log: If using a creators array, you must be one of the creators listed
    Program metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s consumed 24605 of 200000 compute units
    Program metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s failed: custom program error: 0x26
```

Also the program log is confusing! why am I initializing a mint and creating metadata accounts? does this the metadata account doesn't exists and my seeds are wrong?
Sure, you can do
```.rs
#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub struct Args {
  owner: Pubkey,
  ...
  int2: u8
}
```
Is there any way to just pass in one struct that represents all the params, instead of each one individually? My instruction is getting messy:
```
pub fn init_vault(
        ctx: Context<InitVault>, 
        owner: Pubkey,
        fee_collector: Pubkey,
        maximum: u64,
        num_protocols: u8,
        bump1: u8, 
        bump2: u8,
        bump3: u8,
        int1: u8,
        int2: u8,
    ) -> ProgramResult {
    ...
}
```
was there ever an answer to this question? maybe the update the authority is still the way to go
quick question about this -- for a 10K NFT pfp collection, are tehy calling this 10000 times? e.g. are there 10000 unique mints? I'm trying to understand how are they tied to the same "collection" (or in other words how does MagicEden aggregate these separate NFTs)?
Not sure, seems to work fine for me! Would be easier if you can send me a full github repo
anchor.toml
```
[package]
name = "splendor"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "splendor"

[features]
no-entrypoint = []
no-idl = []
no-log-ix-name = []
cpi = ["no-entrypoint"]
default = []

[dependencies]
anchor-lang = "0.22.0"
anchor-spl = "0.22.0"
```
same issue
tried on anchor-cli 0.22.0
and .19.0
What anchor cli version are you using again?
thread 'main' panicked at 'Code not parseable: Error("invalid type")', lang/syn/src/idl/file.rs:348:58
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
I commented out almost all the logic in the files and I still get the error

```
#[account]
#[derive(Default)]
pub struct VaultInfo {

    pub vault_name: [u8; 20],


    /// Mint address of token A
    pub token_a: Pubkey,

    /// Mint address of token B
    pub token_b: Pubkey,

    // Bumps
    //pub vault_bumps: VaultBumps,
}
```

```
#[program]
pub mod splendor {
    use super::*;

    pub fn initialize_vault(
        _ctx: Context<InitializeVault>,
        _vault_name: String,
    ) -> ProgramResult {
        // let name_bytes = _vault_name.as_bytes();
        // let mut name_data = [b' '; 20];
        // name_data[..name_bytes.len()].copy_from_slice(name_bytes);

        // let vault_info = &mut _ctx.accounts.vault_info;
        // vault_info.token_a = _ctx.accounts.token_a_mint.key();
        // vault_info.token_b = _ctx.accounts.token_b_mint.key();
        // vault_info.vault_name = name_data;

        Ok(())
    }
}

#[derive(Accounts)]
#[instruction(
    // _vault_name: String,
)]
pub struct InitializeVault<'info> {
   
    /// Token Program
    pub token_program: Program<'info, Token>,

    // /// Associated Token Program
    // pub associated_token_program: Program<'info, AssociatedToken>,
}```
It is not, the code is breaking locally, so I haven't pushed that yet, but its a small start of a repo, I can send you any files you would like
I don't know why the [u8; 20] thing would make a difference.
Is your latest code on github?
Is it is it possible I should be storing the vault_name as a `String` type?
Thanks a lot man, learnt a lot…


///////////////////////////////////////////////////////////////////////////////////////////////

I had some enum types at the end of the struct; putting them at the top solved the issue for now. Really weird overall 🤨
I played around a little with the order of elements inside of the struct and interestingly enough it seems to have an impact. Is this possibly related to byte alignment?
or the struct rather
account is using zero_copy btw
When trying to decode a previously initialized account on the client side with `program.coder.accounts.decode`. Size of the byte array being decoded fits the space with which the account was initialized (size in bytes + 8 for discriminator). Any ideas as to what's happening here?
This is programs/<programname> folder cargo.toml
[dependencies]
anchor-lang = "0.19.0"
anchor-spl = "0.19.0"
solana-program = "=1.8.5"
enumflags2 = "0.7.1"
This is main folder cargo.toml
[workspace]
members = [
    "programs/*"
]
Yeah
can enayon explain to me the difference between the cargo.toml in the main folder and the cargo.toml in the programs/<programname> folder?
Invalid blockhash is often due to your connection or the network being slow. Try with a private RPC or/and a better internet connection
Please help me

When I deploy the program to the devnet, I have got this error every time
Hello, everyone
thx legend!
Can check `anchor deploy --help` for more options
oooh
`anchor deploy -p the-program-name`
I have multiple programs in my project, when i use anchor deploy it deploys everything. Is there a way to deploy just one of the programs?
ah nothing like good news to start my day 🥲  ty ty
And not sure actually if there are any docs about fallback functions, but they're in the Changelog at least, so can see linked PRs about them
Yeah :/ The account migration is definitely going to be annoying
ah got it that's very helpful ty. is there any additional documentation/code on this i can reference? 
also for any of the `#[derive(Accounts)]`  i would probably need to handle some type of state migration similar to this? https://solanacookbook.com/guides/data-migration.html#_1-add-account-conversion-logic
Oh, as for migrating accounts... think that's going to be a pain in the butt lol
So can take your existing entrypoint and stick inside your `#[program]`, and then gradually break out instructions into anchor-style functions
Then it'll act like a vanilla solana entrypoint function
Anchor supports "fallback" functions, where if you use the vanilla solana signature
```.rs
fn fallback(program_id: &Pubkey, accounts: &[AccountInfo], data: &[u8]) -> ProgramResult {
  ...
}
```
yes exactly
sorry i shouldve clarified. i understand how to rewrite the program in anchor but i was wondering about a program that's already currently deployed and has some states/accounts
Or do you mean how to do a partial migration?
Have you gone through the anchor tutorials/the anchor book? This is maybe not the answer you're looking for, but porting a vanilla solana program to anchor should be "straightforward" if you're familiar with anchor
is there any documentation/examples of how to migrate an existing vanilla solana program to one written in anchor?
Some recommended fun projects for people starting with anchor development?
`let swap_context = CpiContext::new(ctx.accounts.swap_program.to_account_info(), cpi_accounts);` because fo the ToAccountMetas trait not matching somehow
ok it is solvable
cyclos is 0.22
program trying ot make use of it is 0.20
I am getting
```
the trait bound `cyclos_core::cpi::accounts::ExactInputSingle<'_>: anchor_lang::ToAccountMetas` is not satisfied
perhaps two different versions of crate `anchor_lang` are being used?rustcE0277
context.rs(947, 10): trait impl with same name found
context.rs(45, 8): required by a bound in `anchor_lang::CpiContext`
```
it there a way to import and use cpi bits of a program crate that is forward in version?
Anchor functions must return `Result` type. eg. `pub fn get_value(ctx.....) -> Result<()>`
I think that function needs to return a `ProgramResult` type, not a u64
This is simple program. I am going to build this but has issue. Anyone can help me?
``` pun fn get_value(ctx: <GetValue>) -> u64 {
      return ctx.accounts.state_account.cart_count1 + ctx.accounts.state_account.cart_count2;   
    }
```

here, I am getting error 
```
the `?` operator cannot be applied to type `u64`
```
I am gonna get some value from program in the web frontend using web3.
Hello, I was wondering if I could obtain some information or leads regarding charging Solana for various  activities such as a reroll mechanism for a game. Would this be possible without a smart contract?
Thank u again ser
```.rs
let slice = &the_account_info.try_borrow_data()?[..];
```
Whats the best way to turn a `AccountInfo.data` field into a regular slice in a Rust program?
that's what I thought. thanks, will do! 🙂
No, but you could use a good old-fashioned `constraint` for that
It’s for compatibility with old nft standard
hey
is it possible to validate an address with an expression? to be more precise - can we validate that the checked address is one of the two?
pseudocode below:
```
    #[account(
        mut,
        address = config.load()?.wallet_1 || config.load()?.wallet_2
    )]
    /// CHECK: checked above
    pub wallet: UncheckedAccount<'info>,
```
so a single thing to check, then you can whitelist
is that for a new collection or to be compatible with old stuff? Because new DataV2 NFT have a collection field
Yea, I guess that’s the best option. Thx
You could always just "hard"code it into your program, and then just redeploy later if you want to change it
Ahh ok, I just didn’t want to in case I need to change/add a collection in the future
Not sure how you can get around that
Ah, yeah, I would expect you'd need to hardcode the intended collection
Yes, I’ve done that part, but I need to verify the address that gives against what I want
https://docs.metaplex.com/token-metadata/specification#on-chain-representation-of-a-collection
I think you'd need to pass in the corresponding metaplex metadata account, deserialize it, etc.
Ik I can pass the address from the client, but I think that’s insecure because whoever’s calling the ix can just pass a nft and creator address that match
I’m thinking of using the address of the first creator, but I’m struggling to think of a way to get that creator address to verify against into the program without hard coding the value
Anyone know the best way to verify that an nft is part of a certain collection in a program?
Did you end up figuring out what the issue is?
gotcha 👍  great! Thanks
What do you mean? Like, you can handle those fields differently in your program based on whatever you want, but borsh itself won't support anything like that automagically
Can i deserialize data differently based on a field? E.g.

```
pub struct Protocol {
    pub uuid: [u8; UUID_SIZE],
    pub protocol_extra_data: [u8; 32],
}
```

Can I deserialize protocol_extra_data differently based on the value of `uuid`?
great
Yeah, probably 0.22

im on .20
<@!134416332509675520> i got a 3012 error, but it doesnt say which account its referring to, is this changed in more recent versions of anchor?
ty
https://github.com/project-serum/anchor/blob/master/lang/src/error.rs
cant find the list of anchor error codes :-(
--program-name <PROGRAM-NAME>
Yeah not sure there's a built-in way to do that with anchor, though it's not too bad to recreate from scratch (anchor just makes a little struct with the function arguments in it and then uses borsh)
haha
I'm guessing deserializing the data would also be sorta hacky
Yeah I could do that
But yeah if you know you want to check they invoked some_important_function you can check for it
Ah got it
But the other direction, sighash -> function name I think is more annoying
That direction is doable, the sighash is just sha256("global:ix_function_name")[..8]
Do you know the specific instruction you want to check for?
If i wanted to check another anchor instruction was called yeah
Ah, yeah, hmm
That makes sense, does anchor lang expose a way to map the discriminator into an instruction? Or just use sighash
How do you want to deserialize it? I don't think anchor really deserializes the incoming instruction data into a specific struct—it looks at the sighash, the first 8 bytes, to figure out which instruction to invoke, and then each individual instruction generates its own deserialization code for the rest of the ix data (the args)


///////////////////////////////////////////////////////////////////////////////////////////////

Where are you getting that error? You shouldn't need to use NodeWallet at all
Small problem <@!134416332509675520> , when I use the wallet from solana wallet adapter I get this issue with a types mismatch. any idea?
perfect, thank you 🙏
oh gotcha
Hey guys! How to check in anchor if an account exists with a particular PDA ? This is needed for validation in the program in rust.
Solana provides "wallet adapters" that can get you something that can conform to that interface (depends on how you're doing things, e.g. https://github.com/solana-labs/wallet-adapter)
You don't have a private key, but you can actually get a Wallet—it's just an interface that can sign for stuff, nothing about needing a private key
You need to pass in an actual Provider to that Program constructor call
<@!134416332509675520> , how would you recommend using anchor in the browser. I was doing this:

`const program = new anchor.Program<Solendcpi>(idl, programId);`

but get an error saying `Uncaught Error: Provider local is not available on browser.` but I don't want a provider bc in the browser I don't have the user's keypair (just pubkey)
gotcha. my problem with this is I don't have a "wallet" bc the wallet is just the user (their phantom wallet), which I don't have keypair just pub key
Signature verification failed when i use market.makeSettleFundsTransaction() with wrapped sol, why? any help, thanks
thanks!
Yeah I figured out just a moment ago
it's telling you to remove the target. so just do `bump,`
ok thank you sir for the guidance
in your package.json (and then can read up on npm package.json syntax if you want to use a fancier version string)
I would suggest just keeping it simple and say `"0.2.0"`
I think what my package.json is saying use any SPL-token version as long as its higher than 0.1.8?

And in yarn, frankly i don't understand what i'm seeing in the yarn.lock file
Creating a thread for this to see if its easier ..

In my package.json...

     `   "@solana/web3.js": "^1.30.0",
        "@solana/spl-token": "^0.1.8",`

in my yarn.lock

`"@project-serum/serum@^0.13.60":
  version "0.13.60"
  resolved "https://registry.npmjs.org/@project-serum/serum/-/serum-0.13.60.tgz"
  integrity sha512-fGsp9F0ZAS48YQ2HNy+6CNoifJESFXxVsOLPd9QK1XNV8CTuQoECOnVXxV6s5cKGre8pLNq5hrhi5J6aCGauEQ==
  dependencies:
    "@project-serum/anchor" "^0.11.1"
    "@solana/spl-token" "^0.1.6"
    "@solana/web3.js" "^1.21.0"
    bn.js "^5.1.2"
    buffer-layout "^1.2.0"

"@solana/buffer-layout@^3.0.0":
  version "3.0.0"
  resolved "https://registry.npmjs.org/@solana/buffer-layout/-/buffer-layout-3.0.0.tgz"
  integrity sha512-MVdgAKKL39tEs0l8je0hKaXLQFb7Rdfb0Xg2LjFZd8Lfdazkg6xiS98uAZrEKvaoF3i4M95ei9RydkGIDMeo3w==
  dependencies:
    buffer "~6.0.3"

"@solana/spl-token@^0.1.6", "@solana/spl-token@^0.1.8":
  version "0.1.8"
  resolved "https://registry.npmjs.org/@solana/spl-token/-/spl-token-0.1.8.tgz"
  integrity sha512-LZmYCKcPQDtJgecvWOgT/cnoIQPWjdH+QVyzPcFvyDUiT0DiRjZaam4aqNUyvchLFhzgunv3d9xOoyE34ofdoQ==
  dependencies:
    "@babel/runtime" "^7.10.5"
    "@solana/web3.js" "^1.21.0"
    bn.js "^5.1.0"
    buffer "6.0.3"
    buffer-layout "^1.2.0"
    dotenv "10.0.0"`
nothing works on 22.1
aAaAaAaAaAaAaAa
And unless the docs say otherwise, they'll be for the latest version
Check your package.json file and your yarn.lock
ok. thanks for that. how do i check the version of the api i'm using, and the version that the docs is updated for?

At the top of my code i have 
`import * as anchor from '@project-serum/anchor';
import {
  PublicKey,
  SystemProgram,
  Transaction,
} from '@solana/web3.js';
import { TOKEN_PROGRAM_ID, Token } from '@solana/spl-token';
import { assert } from 'chai';`
There are different apis. mintA.mintTo() is older. The doc is for the newer one
You're not using the latest version of the spl library (the api changed a bunch). The function from the docs is here: https://github.com/solana-labs/solana-program-library/blob/48fbb5b7/token/js/src/actions/mintTo.ts#L29
<@!771049362658426910> can I use the existing deployed anchor-escrow program. If yes what’s the deployed program address? Unable to find a program deployed at `6m7hFFRbDoCAN5bTm592crzaXNV3qkYwt6aaEzd1rkg6 `
Hi basic question here, on this code and the documentation...... mintA is a mint returned by Token.createMint
`
await mintA.mintTo(
      initializerTokenAccountA, 
      mintAuthority.publicKey, 
      [mintAuthority], 
      initializerAmount
    );`

The call above has 4 params. I'm checking the documentation on mintTo https://solana-labs.github.io/solana-program-library/token/js/modules.html#mintTo

but the docs say there are 8 parameters + 1 option, not 4...  am i looking at the wrong thing? How can i better help myself understand this?
Hello how can I get usdc on devnet
Hey guys. Is there minimal example for anchor PDA's ?
i hope you get paid well for your work helping all us newb devs
I guess I need to make some permissioned pass-through instruction on the program then
thanks
Dang
The only possible way to sign for a PDA is via `invoke_signed`
hm
and get that account's signature
Strictly speaking sure, you can sign for the program's program_id address, but that won't let you sign for one of its PDAs
or perhaps use the program's seed to resign the account
so I can't make a web3 js transaction and use the program's key as a signer?
😛
tartar sauce
Nope
however, what if I don't want to upload a new version of the program to mainnet to do an NFT update instruction?
Usually, I would have to go through the program in order to update the NFT metadata then, and in the `signers` field of the CPI I would pass the seeds of the Program-signed account
For example, let's say I have an NFT where the update authority is set to an account which is generated from the Prorgram, so affectively the Program is the update authority
If I have an account signed by my program, is there a way to make a call signed by that account from outside the program (not using a CPI) by using the private key of the program?
```.toml
anchor-lang = { version = "something", features = ["init-if-needed"] }
```
<@134416332509675520>  chek it out
Okay then i'll go with that <@!134416332509675520>. Thanks for the help👍
Why do you think that?
soo you are using anchor `init_if_needed` in first one I don't think it is usable in new versions of anchor
https://github.com/cqfd/anchor-token-studies, https://github.com/cqfd/quidproquo
Hey how do I pay someone, who connected his wallet to the site, spl token from vault wallet how it is possible without using vault's private key any example or repo? <@!134416332509675520>
You'll have to rely on the built-in freeze functionality.
Don't think redeploying the spl token program will work, no, since then the resulting "tokens" won't be treated at tokens by the rest of the solana ecosystem.
Hi <@!894549103579643934>, I'm also looking forward to one and the same solution, I'm trying that in a way like forking the spl-token program from the solana-program-library git and then removing the transfer functionalities and stuffs and then trying to deploy as a separate contract to disable the transfer functionality from the token contract. By this way can i achieve the requirement? <@!134416332509675520> any suggestion on my plan of action?
hey how do I solve it?
Is there a linter or something for anchor in VSCode?
ok cool then, Thanks <@!134416332509675520>
You can "freeze" a token account to prevent it from transferring its tokens. Requires having/adding a freeze authority to the mint.
Guys, 🙂  suggestions and ideas are welcome for the  👆🏻 above scenario
<@!134416332509675520>  how can i remove or disable transfer function to a custom spl-toke.
I just wanted the token to be minted and burned , but cannot be transferred . Looking if you could help me here , in this. or is there any other alternative to achieve this.
Hi guys, are there any protocols that worked on something like recurring payments? Any help like design ideas are appreciated. Thanks.
what's the best way to solve version collisions? I'm trying to compose with a program which uses 
```
anchor-lang = "0.14.0"
anchor-spl = "0.14.0"
solana-program = "1.7.11"
```
And I use
```
anchor-lang = "0.20.1"
anchor-spl = "0.20.1"
solana-program = "1.8.12"

```

And if I revert back to older versions I break some of the other dependencies that I have 😅.
I haven't read how the so called "local" provider works, so how I've been doing is by creating a new Provider, and passing it to the program:

`const provider = new Provider(connection, wallet, preflightCommitment)`
`const program = new Program(idl, programId, provider)`
any idea of how I should go about using anchor client to build the instructions?
in the browser in order to call the instruction helpers to add to a txn. I am getting the error `Uncaught Error: Provider local is not available on browser.`
I am doing `const program = new anchor.Program<Solendcpi>(idl, programId);`
Is there some known way to cut some fat?
After upgrading to 0.22.1 and only adding I think 1 extra dependency, a staging program program buffer is now too big for the program account data len
Hey Guys, what's the best way to copy the metaplex programs into my anchor project?
Does everyone just tunnel through their own backend?
How do folks handle client side RPC requests? For ex if I build something trying to list all NFTs in a wallet, that's an absurd number of calls to on-chain metadata, but if I put an access token client side I've suddenly leaked the token and now it's botspam time.
it's error 42
how do i know what error `0x2a` is
Is anyone by any chance using Anchor on OpenSUSE Tumbleweed? Having some difficulties installing Anchor on it that I haven't had on on other OSs
its building anyway
hm, seems like that might have fixed it
Think the issue might be that `associated_token::authority = offer.offerer`, I think this is maybe a small bug in anchor now where the right hand side needs to be an actual account now (it shouldn't need to be, but it now does)
well actually my cli version isnt the right one -- but since rust analyzer gives this error too im not sure how that would fix. updating regardless
this stuff doesnt fix :- (
Also make sure u update your cli version of anchor as well
okey, thanks
Thats working for me
Only thing I can recommend is try v`0.22.1` rather than `0.22.0`
Sorry, not entirely sure. I had a similar error, but it was fixed by upgrading the anchor-spl crate to the same version as the anchor-lang crate
cargo-features = ["edition2021"]
[package]
description = "Created with Anchor"
edition = "2018"
name = "nft_lending"
version = "0.1.0"

[lib]
crate-type = ["cdylib", "lib"]
name = "nft_lending"

[features]
cpi = ["no-entrypoint"]
default = ["test"]
no-entrypoint = []
no-idl = []
test = []

[dependencies]
anchor-lang = ">=0.22.0"
anchor-spl = ">=0.22.0"
borsh = ">=0.9.1"
dmsort = "1.0.1"
mpl-token-metadata = {version = "1.2.5", features = ["no-entrypoint"]}
spl-token = {version = ">=3.2.0", features = ["no-entrypoint"]}
Can u show ur Cargo.toml?
and we arent sure how to read this error
we just updated to .22 and it caused anchor to get mad at us about a struct that was previously fine
Ok, Ill do that thx
Not sure, I just install from source
Whats the update command?
Ahh thats it, its 0.18.2
What `anchor --version` do you have? You also need an up-to-date CLI
<@!703647911770062878>
I still think the issue is with the `::` operator. I wanna see if u have a dependency that I don't
Can I see ur Anchor and Cargo.toml files?
one other slight difference is that it looks like you are using the default bump which might be confusing the parser because of no '='? weird suggestion but given the error message maybe move bump away from the `seeds::program` line or set it to something like `bump = 1`. but yeah apart from that I'd start source diving the parser from the error message, really weird issue :/
It didn't fix it
Gonna try deleting my `.anchor` and `target` folders and see what happens
I have no idea y its happening
I was using 0.21.0, upgraded to 0.22.1 but same issue :/
based on the error message you're prob right, sounds like a version issue if you're not on 0.22.1
got it, i havent used that feature before my b
0.22.1
What version of `anchor_lang` are u using?
But even replacing that with `mpl_token_metadata::ID` doesn't fix the issue
I defined `token_metadata_program` as an unchecked account. It has the `.key` field
you should invoke `.key` -> `.key()` (not sure if it just pasted wrong but thats the first thing I notice)
`#[account(
    mut,
    seeds = [
      b"metadata".as_ref(),  
      mpl_token_metadata::ID.as_ref(),
      mint.key().as_ref(),
    ],
    bump,
    seeds::program = token_metadata_program.key
  )]
  pub mint_authority: Signer<'info>,`
could you paste the whole `#[account(...)]` line you have?
The .key is fine I think. I think its an issue with the `::` operator
one thing that comes to mind is I don't use `.key` actually, which might be a key difference. I use the `solana_program::pubkey!` macro with a program ID known at compile-time
Error comes when I add that constraint line
How, when I try I get this error: 
`thread 'main' panicked at 'Code not parseable: Error("expected '='")', lang/syn/src/idl/file.rs:338:58
note: run with RUST_BACKTRACE=1' environment variable to display a backtrace`
Yup I'm currently using this
Has anyone been able successfully use the `seeds::program = other_program.key()` constraint?
can you give me a screenshot of your test file?
yeah I tried this but I think anchor is still using the public endpoint
edit: seems like it might not be possible rn https://github.com/project-serum/anchor/issues/673
How do I check this
solana config set --url https://api.devnet.solana.com
may help but not sure
what test framework are you using?
so what should it look like for a ts file?
trying to upgrade a program on mainnet but the public endpoint keeps timing out for me
Is there a way to pass in a mainnet rpc url to the anchor cli? (like a QuickNode url)
yes, that is the command anchor executed when you run anchor test
Noticed that other "Anchor.toml" files have some sort of "yarn mocha" or some sort
I'm trying to change my test file from js to ts -- is there anything I should change this to?
I'm trying to clone some accounts from mainnet to run localnet tests, but the validator seems to be hanging whenever I run `anchor test`. I've tried upping the startup_wait to `100000` but not seeing any change in behavior. Do I need to do anything else to copy from mainnet?

```
[test]
startup_wait = 100000

[test.validator]
url = "m"

[[test.validator.clone]]
address = "<cut>"
```
Hey how do I transfer spl tokens from valut to connected wallet
Thanks
Yeah now that I think about it not sure what I mean lol
Not totally sure what you mean, but I don't think it makes sense to use the discriminator bytes for versioning (you'd need to add a separate field or something to the struct, or use an entirely new struct—not sure)
Well actually, even if that was possible I imagine not a good idea
I this something I can use to identify the struct, for versioning purposes for example in the way that metaplex assigns a "Key"? 

See: https://github.com/metaplex-foundation/metaplex-program-library/blob/d982ce511aef028f71c748c44302393ceae0df26/token-metadata/program/src/state.rs#L27
All `#[account] pub struct Something {... }` accounts in anchor use it
THat's for the "account discriminator" bytes anchor uses to specify what struct to use for deserializing the account
Good sers, can anyone tell me, in the allocated account space here: https://github.com/project-serum/anchor/blob/552789a072e518420b6844b37660bb5d1976c452/tests/escrow/programs/escrow/src/lib.rs#L113

```
 space = 8 + EscrowAccount::LEN)
```
8 is padding for an account key of some sort, or is it just arbitrary padding?
yes the UI makes it easy to use any wallet
Thanks. <@!831450660146642974>
This is very helpful!
And I wonder how to use them.
Maybe they need .so file for tx and I want to know how I can pass whole .so file as tx data.
I've seen these instructions in upgradeable loader program.
`solana_program::bpf_loader_upgradeable::upgrade
solana_program::bpf_loader_upgradeable::write`
Maybe they need built so file?
Thanks. so with that UI, can business men upgrade contract with their goki wallet?
once those 2 steps are done you can use the UI to propose upgrading the program to the new buffer
i personally manually deploy to a buffer then set the buffer authority to the multisig smart wallet. so without the goki-cli wrapper
I changed upgrade authority of my company's program as goki of business team.
https://github.com/GokiProtocol/goki-cli/ this convoluted tool
Hi, guys
Does anyone know how to upgrade deployed solana program with goki multisig wallet?
Yeah, unfortunately anchor's JS side doesn't handle zero_copy accounts very fancily
Sorry, I wasn't clear at all. I meant on the client side. What I'm seeing from `fetch`  is that it deserializes the zero_copy account the same way as it deserializes a normal account.
I honestly have no idea, but I'd assume it does. When using zero_copy you have to pass your accounts to a specific structure `AccountLoader` instead of the usual `Account`. Also zero_copy doesn't implement AnchorSerialize or AnchorDeserialize so it could not use Borsh anyways.
i don't think it's too big.. would love it if you have a look at the source code... can I dm?
Does anchor know to use zero-copy deserialization instead of borsh for zero-copy accounts? I think they can have different padding. That would explain what you saw.
i think if your program is too big then it will just never succeed, maybe there is a workaround. but ive succeeded on like 7th try before
thanks!
okay got you
and you can check on solscan
the CLI will say something to the effect of "it worked"
or rather `commitment` and `preflightCommitment` arent the same
btw how do i know when the program is successfully getting deployed to devnet?
it ignores the opts
thats from provider.send

yeah
that would make sense
maybe the problem is that i am telling `provider.send` to use "finalized" when my connection is "confirmed"
which i see that this provider is set to
Note that this doesnt happen on localnet unless I set the confirmation level to "confirmed", in which case it does also happen on localnet
Blockhash not found when using provider.send
damn.. beta product pains
constant issues when deploying to devnet, all hilariously solved by just trying again over and over
sometimes it takes like 5 tries
i encounter this all the time, and just keep retrying it until it works
i will wait another day lol
Think this is just devnet sucking
is this due to RPC clogging?
Why would `program.provider.send` be causing me "Blockhash not found" errors?
moreover, my devnet sol is depleting, but my program is not getting deployed
Do we have to do anything more than changing the provider in Anchor.toml and the program ids in Anchor.toml and lib.rs, while deploying to devnet?

Everything works properly in localnet but I am facing this error while trying to deploy to devnet
 
```Blockhash expired. 5 retries remaining
Blockhash expired. 4 retries remaining```

It is a chain of errors that's happening
Does anyone know how to get information like price and market cap from an spl token mint address? I've tried querying coingecko using corresponding symbol but some tokens don't have accurate information on th ere


///////////////////////////////////////////////////////////////////////////////////////////////

Are NFTs and tokens transferred the same way?
for spl tokens
your quidproquo dapp is enoguh to create a claimable reward from an vault acc right? <@!134416332509675520>
if someone want to claim his staking reward I need to crate a escrow app right?
embarrassing but I just had some naming collisions😅 ☕
So what do you mean by variable length? Like, using a `Vec`?
Creating batch with minimum size and index access
What have you tried so far?
I think it's more scalable that way, it really depends on what you want.  I would break it up s.t each instruction works on one of the array elements and then try to bundle these in a transaction. But depends on your specific use case
So data is divided into batch in account?
Try to use pdas that are seeded by the index
Is it possible to create an account with array of variable length?
yea I'm not sure what's exactly causing this to break! Running ablation studies now, will let you know in case I find something.
I'm using anchor 0.20.1 if anyone is wondering, newer versions break some dependencies with other programs that i cpi into which I don't want to deal with rn😅
Oh, sorry lol, I guess we have a todo 😛
~~Do you have a question? Looks like you've already got a todo lol~~
😅
I'm getting the following error 
```
thread 'main' panicked at 'called `Option::unwrap()` on a `None` value', ~/.cargo/git/checkouts/anchor-bf03d42499b9267c/a81ff88/lang/syn/src/idl/file.rs:161:73
```
ah i'm good, but thx for the offer!
Will pay you
Are you free for some work?
NFT Staking Platform
Nope, whats that?
Did yoy heard of gemworks?
let YourInstrcution = program.instruction.myEndpoint(…)
With
tx.add(YourInstruction)
Then u do
let tx = new Tramsaction()
Anyone knew how to bind multiple tx in one?
Hey
Seems kinda clunky tho 🤔
I guess I can serialize the tx and then just pull out the bytes that relate to the ix
ah ok, makes sense
I didn’t build the ui. It just expects the data in a certain format. Not sure if there’s a way around it without writing a new client. (Which I’ll prolly end up doing anyway)
you could deserialize the txn and get the ixn from it
I just want the instruction itself. I’m trying to insert it into a proposal using the spl governance ui
you can add the ixn to a transaction and encode them
instruction or the transaction itself? <:thonk1:801847763527925821>
Anyone know how I can serialize a `TransactionIntruction` object into base64?
Answered my own q. The Anchor `Program` object has an `instruction` namespace that u can use to get a `TransactionInstruction` any of the methods on the Anchor program
Or another question is how are Anchor instructions serialized? Is it different then vanilla Solana program instructions? Can I serialize an instruction without actually calling it?
Is there a way to call an instruction on an Anchor program as if it were a vanilla Solana program? i.e. create a `TransationInstruction` and then call it in a `Transaction` object?
oh this looks neater thanks
But yeah clone works
You can probably also do `...to_account_metas(None).remove(0)`
ok this seems working
```
        for remaining_account in ctx.remaining_accounts {
            instruction_accounts.push(remaining_account.to_account_info().to_account_metas(None)[0].clone())
        }

```
it does not seem Im doing right per the error 
```cannot move out of index of `Vec<anchor_lang::prelude::AccountMeta>`
move occurs because value has type `anchor_lang::prelude::AccountMeta`, which does not implement the `Copy` trait```
this `instruction_accounts` will be used here
```
        let ix = Instruction {
            program_id: cpi_program.key(),
            accounts: instruction_accounts,
            data: data.data(),
        };
```
this seems working, but I got a question on this
```

        for remaining_account in ctx.remaining_accounts {
            instruction_accounts.push(remaining_account.to_account_metas(None)[0])
        }
    
```
Thanks sir
Briefly, it tells anchor to expect those accounts to not yet have their "discriminator" bytes set (can read about that in that link)
You can read about it here: https://docs.rs/anchor-lang/latest/anchor_lang/prelude/derive.Accounts.html
what does mean #[account(zero)]?
in this code,
#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(zero)]
    pub dummy_a: Account<'info, DummyA>,
    #[account(zero)]
    pub dummy_b: Account<'info, DummyB>,
}
Hi <@!134416332509675520> 
I hope you're doing well
May I ask one question?
Try writing out the type signature for your instruction more explicitly,
```.rs
pub fn your_instruction<'a, 'b, 'info>(ctx: Context<'a, 'b, 'b, 'info, YourThing<'info>>, ...)
```
therefore when I try to put them into one vec or list it says lifetime mismatch
It's just one great big list of accounts
Im having a hard time cuz the Context struct have diff lifetime for 
```

pub struct Context<'a, 'b, 'c, 'info, T> {
    /// Currently executing program id.
    pub program_id: &'a Pubkey,
    /// Deserialized accounts.
    pub accounts: &'b mut T,
    /// Remaining accounts given but not deserialized or validated.
    /// Be very careful when using this directly.
    pub remaining_accounts: &'c [AccountInfo<'info>],
}
```
`accounts` and `remaining_accounts`
Yeah
so you mean basically after getting  the "instruction" accounts I just need to somehow append it right
You just need to find a way to smoosh them all together
`Instruction`s don't have remaining_accounts because the accounts are all remaining 🙂
Any ideas someone can help? Thanksss
https://github.com/cqfd/anchor-token-studies/blob/main/programs/token-studies/src/lib.rs#L95
Sure
can a token mint be a PDA?
(sorry if this is a duplicate)
you need this block
```
cpi = ["no-entrypoint"]
default = ["cpi"]
```
wait i figured it out
`feature default includes cpi which is neither a dependency nor another feature`
Oh... hmm. I think you'd have to change to `default = ["cpi"]` in your program's Cargo.toml
`crate::cpi` gives me `could not find cpi in the crate root `.. Any ideas?
for now the workaround wd be to --skip-local-validator and run the decativate on my own validator, but cd be cool to add as a flag to anchor test
wondering if anchor supports deactivating solana features when running solana test validator with anchor test, wd be rlly useful esp. with the new tx wide caps
this is super cool. is it documented anywhere?
by cloning you mean dumping and redeploying?
edit: ok i see, super cool
interesting, will investigate
One thing you can do is use cargo features to declare multiple program ids: https://github.com/drift-labs/protocol-v1/blob/master/programs/clearing_house/src/lib.rs#L32
Scroll around that link—it's slightly tricky since you actually have to clone two accounts, not just the metaplex program_id one
You can clone the metaplex program from devnet: https://discord.com/channels/889577356681945098/889577399308656662/948229192775004160
does anchor give an easy way for the program ids of dependency programs to vary by cluster?
alternatively we could just always test on devnet, in which case we'd want one devnet deployment for active program development and another for more stable releases. any advice on how to achieve that? right now it sounds extremely painful to have 2 deploys of the same program with different programs, since the programid is declared in source, cant just env variable it
xpost from metaplex discord which i dont expect to hear back in:
trying to integrate my program with metaplex metadata program, can anyone advise on how to do localnet testing here?

jordan once said that the version in the repo isnt even the same as the one on devnet. thinking maybe i should just dump from devnet to localnet or something?
saved me some hacking hours
ty man!
w00t
But yeah, you could also just CPI to your own program if you want to piggyback on anchor's account stuff
Ah, ok—well, you can still strictly speaking construct the relevent Context thing, but yeah, it's awkward
they would be provided in `remaining_accounts`
If you don't have access to those accounts already then you also can't CPI to it
so its not functional
but that other code is oriented around its accounts
invoke meaning run—you can just call it
I guess what I mean is that if you're already in your program, you can just invoke that other code
imagine if we had some principal like a synchronise function that is otherwise invoked client-side. In this case, if the `remaining_accounts` satisfied some business logic to _synchonise_, then it would be ideal to CPI the sync ix rather than relying on the client to bundle the separate instructions,
Strictly speaking you could CPI to yourself, but I don't know why you would want to—you can just call your own functions directly, no need to CPI (it's all just rust code)
<@!350632015852208140>
im not sure how wise it is in general to be on the bleeding edge, but 0.22 does have some changes that help a lot with debug i think
this is still true in 0.22 but im testing now, and just using the ts output seems to no longer cause errors
i guess i should upgrade, will do so once the program is a bit more stable xD we have a couple packages we integrate with, no need to make it tougher than is haha
im using 0.20. I just tried 0.21, where it also didn't seem to work.
https://github.com/project-serum/anchor/issues/1513#issuecomment-1049082756
the issue was that the generated code was not up to date. unfortunately we have to do some manual steps here due to a problem ive reported on github
closing because it is fixed now
<@!350632015852208140> what version of anchor are you on in JS land? in 0.22 `new Wallet(keypair)` seems to work now
Hey guys. I am with mac m1 chip. I have build the solana dev tools and i can run local validator. 
But i cant build `spl/farms/farm-cli` for some reason it fails with `error: could not compile `vipers` due to 12 previous errors` 
Does someone encountered that?
maybe worth noting that we updated anchor in rust land but not js land
how would I go about intra-cpi - like invoking some instructions in the same program that is calling cpi?
for reference here is my `program.rpc` call
but `ctx.accounts` is what gets passed to validateAccounts
<@!134416332509675520> 

so you can see here that in the debug log, `ctx` is empty, and `ixArgs` has the accounts in it
ok
Is there an Anchor wrapper for the metaplex `Metadata` account? Like there is for `Mint` accounts in `anchor_spl`?
missing accounts in anchor 0.22
beautiful
my solution
yep just did and solved it. thanks! 🙂
all my tests do this after migrating
**[i am suffering]** 
does 0.22 change `program.rpc.x` arguments or something?
Annoying but you could basically just copy the NodeWallet code
i.e. is there for example a way to return a Wallet object, from a Keypair? only the constructor doesn't seem to work
`new Wallet(keypair)` does not work
any idea how I can create a wallet from a keypair?
thanks
problem was passing in remaining accounts incorrectly from client
ahh actually, it also sounds like ur passing a null object as a signer. can you double-check that
did you double check that the uploaded IDL matches your local IDL? you can download the IDL using anchor fetch (i forgot the exact code)
not seeing anything for the intended method in my anchor logs, any ideas?
getting this error right as I invoke my method with program.rpc.[method] 
```
     TypeError: Cannot read properties of undefined (reading 'toBase58')
      at sort (node_modules/@solana/web3.js/src/transaction.ts:263:10)
      at Array.sort (<anonymous>)
      at Transaction.compileMessage (node_modules/@solana/web3.js/src/transaction.ts:261:18)
      at Transaction._compile (node_modules/@solana/web3.js/src/transaction.ts:379:26)
      at Transaction.partialSign (node_modules/@solana/web3.js/src/transaction.ts:504:26)
      at NodeWallet.signTransaction (node_modules/@project-serum/anchor/src/nodewallet.ts:26:8)
      at Provider.send (node_modules/@project-serum/anchor/src/provider.ts:109:23)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at Object.rpc [as mintLpToken] (node_modules/@project-serum/anchor/src/program/namespace/rpc.ts:25:23)
```
yh im here often haha. perhaps less often the last few weeks haha
xD
thanks david (nice to see ur in this discord channel too 😂)
and for wallet adapter you should try the useWallet context maybe? not sure which adapter you use
you need to rewrite a bunch of code to match the frontend, you should probably use Provider.send to send the instructions manually
Is the getProgramAccounts rpc call working for anyone? I keep getting a '410 Gone' error
when I pass in the wallet adapter into the anchor program (need the wallet from the adapter in order to create the anchor provider)
seems like what I need to do is to append the `remaining_accounts` into the 
```
cpi_accounts
                .to_account_metas(None)
                .into_iter()
                .map(|mut meta| {
                    if (meta.pubkey == ctx.accounts.seller.key() && !buy_side)
                        || (meta.pubkey == ctx.accounts.buyer.key() && buy_side)
                        || meta.pubkey == ctx.accounts.authority.key()
                    {
                        meta.is_signer = true;
                    }
                    meta
                })
                .collect(),
```
but `ctx.acccounts` and `ctx.remaining_accounts` have different lifetime, not sure how to put them together.
Also will need to put the `remaining_accounts` into
```
   invoke_signed(
            &ix,
            &[...]))
```
Is my understanding correct?
my code looks something like 
```
        let ix = Instruction {
            program_id: cpi_program.key(),
            accounts: cpi_accounts
                .to_account_metas(None)
                .into_iter()
                .map(|mut meta| {
                    if (meta.pubkey == ctx.accounts.seller.key() && !buy_side)
                        || (meta.pubkey == ctx.accounts.buyer.key() && buy_side)
                        || meta.pubkey == ctx.accounts.authority.key()
                    {
                        meta.is_signer = true;
                    }
                    meta
                })
                .collect(),
            data: execute_sale_data.data(),
        };
```
I checked the `Instruction` object there doesnt seem to be any remainingAccount field I can use
Hi there, got a question, how do I pass the remainingAccounts through the anchor CPI calls?


///////////////////////////////////////////////////////////////////////////////////////////////

Not sure. I think you should instead slow down and work through as many anchor/solana tutorials as you can (I think you're trying to do something that's too complicated for your current skill level, so you should slow down and learn how to do easier stuff first)
What do I search to find resoruce about it, is "escrow concept" related with this functionality <@!134416332509675520>
actually I don't know how to create a dapp like it and I am trying to find a resource which is able to teach me how to do it
I don't know, have you tried?
Hey in your quidproquo github repo I can create payment from vault as an spl token to an user  right? <@!134416332509675520>
Where I want the following pda to be the signer 
```
   #[account(
        mut, 
        seeds = [owner.key().as_ref(), seeds::PORTFOLIO_SEED], bump = _bump_portfolio
    )]
    pub transfer_from: Account<'info, PortfolioAccount>, 
```
This is how I'm building my cpi call: 
```
let data = marinade_finance::instruction::Deposit{ lamports:dep_amt };

    let cpi_accounts = MarinadeDeposit {
        state: ctx.accounts.state.clone(),
        msol_mint: ctx.accounts.msol_mint.clone(),
        liq_pool_sol_leg_pda: ctx.accounts.liq_pool_sol_leg_pda.clone(),
        liq_pool_msol_leg: ctx.accounts.liq_pool_msol_leg.to_account_info(),
        liq_pool_msol_leg_authority: ctx.accounts.liq_pool_msol_leg_authority.clone(),
        reserve_pda: ctx.accounts.reserve_pda.clone(),
        transfer_from: ctx.accounts.transfer_from.to_account_info().clone(),
        mint_to: ctx.accounts.mint_to.to_account_info(),
        msol_mint_authority: ctx.accounts.msol_mint_authority.clone(),
        system_program:ctx.accounts.system_program.to_account_info(),
        token_program: ctx.accounts.token_program.to_account_info(),
    };

    cpi_util::invoke_signed(CpiContext::new_with_signer(
        ctx.accounts.marinade_program.clone(),
         cpi_accounts,
         &[
            [
                ctx.accounts.owner.key().as_ref(),
                seeds::PORTFOLIO_SEED,
                &[_bump_portfolio]
            ].as_ref()
        ]
    )
```
What causes  "ConstraintSigner" error?
```
     Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: custom program error: 0x8e
```.
I'm trying to cpi into a program which has the following context : 
```
#[derive(Accounts)]
pub struct Deposit<'info> {
    #[account(mut)]
    pub state: Box<Account<'info, State>>,

    #[account(mut)]
    pub msol_mint: Account<'info, Mint>,

    #[account(mut)]
    pub liq_pool_sol_leg_pda: AccountInfo<'info>,

    #[account(mut)]
    pub liq_pool_msol_leg: Account<'info, TokenAccount>,
    pub liq_pool_msol_leg_authority: AccountInfo<'info>,

    #[account(mut)]
    pub reserve_pda: AccountInfo<'info>,

    #[account(mut, signer)]
    pub transfer_from: AccountInfo<'info>,

    #[account(mut)]
    pub mint_to: Account<'info, TokenAccount>,

    pub msol_mint_authority: AccountInfo<'info>,

    pub system_program: AccountInfo<'info>,
    pub token_program: AccountInfo<'info>,
}
```
Can you show the error/some code?
hello! what's the preferred way of importing an idl into a client using typescript? i'm getting an incorrect type error when i try to initialize a new Program instance
yep that fixed it big help ty
thanks appreciate it!
E.g. `pk1.toString() == pk2.toString()`
how would i do so?
This is just javascript being annoying about object equality. You need to test those two keys are equivalent, not literally equal to one another
hi everyone! so i'm trying to right tests for my smart contract, but for some reason even though they're expect.to.equal() and console.log shows that the two pubkeys are unequal even though comparing the two public keys they seem equal to me.. does anyone know why javascript thinks that they're unequal? here's the console.log comparing the public key saved in the account to the wallet key it should be, which is correct
Is there already established time for possible reallocate space?
Yeah, at least for now you can't reallocate space for an account (though you will be able to at some point)
Ok, so it's not improvement in my case. I want to use variable space due to SOL cost optimization
Yes, just have to decide on how much space you want to allocate for the account though (Default won't work)

anyone able to deploy to devnet
Is it possible to use a vector in account struct?
We are using the projectserum/swap git repository and noticed that there are a limited amount of trading pairs; is there any way to add additional trading pairs? (we have already asked in Serum and they referred us here)
99 I think
Can upgrading a deployed program to a new, larger binary cause problems? 
What are best practices?
is there a way to branch on whether code is being run in devnet or mainnet?
I see... 0.14.0 builds without any issues. Hmm...
avm just does a clone of whatever is in the github repo at that tag, so I guess something is wrong with the submodule from back then
I would like to use anchor version 0.13.2
`avm use 0.13.2` returns me
>  failed to update submodule `examples/cfo/deps/stake`
Any ideas?
is there a practical limit to how many accounts I can get with fetchMultipleAccounts? public RPC endpoints seem to use MB limits instead of request size limits
thanks for answer
I'm not sure if there's any particularly good solution to this
Ah, ok. As far as I know that doesn't work yet, not with actual arrays rather than Vecs. The issue is that each different length would require a separate account type (the length of the array effects the size of the type—so different array sizes require different account types)
Arrays will have static length after creation but it’s created with variable sizes. I’d like to use variable length due to SOL cost optimization. In the beginning, I used an array with fixed length corresponding to the worst case scenario.

I tried index-based accounts to implement variable length arrays but I am not very satisfied with this solution as it makes code much more complex and I need to pass variable amounts of accounts by remaining accounts (it’s limited by the possible number of passed accounts).

Additionally I think there will be several length tiers like [u8; 1000], [ u8; 5000],  [u8; 10000]. However I would like to use the same account struct.
Thank you!
Oh I see, just curious
Pubkey::create_with_seed
Basically you probably don't want to use create_with_seed (you can, but it's semi-deprecated as far as I know)
What vulnerabilities? For which method?
I see, also may I know if any  other vulnerabilities that we should avoid using this method?
`find_program_address` is also a hash of some stuff, but it's done in such a way that the PDA address is deliberately "off the curve", so there just isn't a corresponding private key at all
So it's possible the resulting 32 bytes are "on the curve", and do in fact have some corresponding private key (but you'd presumably never be able to guess it)
Ah, well, it actually depends—all create_with_seed does is hash some stuff together
Is that mean someone may held the key-pair with the address from `Pubkey::create_with_seed` , but probably I cannot get it?
How to create accounts when the number of accounts is dynamic and I have to pass them as remaining_accounts?
I have to dynamically do the same as Anchor does when [init, seeds, bump, payer, space] is used for statically defined accounts on the Accounts struct
You mean `Pubkey::create_with_seed`? No, that doesn't generate a keypair (it's a totally different kind of address—you probably don't want to use it either, just use PDAs instead, with `Pubkey::find_program_address`)
Hello guys, may I know if we can get keypairs with address generated by the  created_with_seeds?
Does the anchor IDL support usage of enums? I'm getting `"Enum type" is not assignable to type "never"`.
We are using the projectserum/swap git repository and noticed that there are a limited amount of trading pairs; is there any way to add additional trading pairs? (we have already asked in Serum and they referred us here)
yus


///////////////////////////////////////////////////////////////////////////////////////////////

yea youd just cpi the token program. although I wouldnt say adjusting lamports is a problem in general. depends on your use case
Is it possible to upgrade an existing, deployed program with a new binary that is significantly larger?
What are the limitations and best practices around upgrading production programs?
Thank you.
I guess with wrapped Sol this problem wouldn't occur right?
I see, this will require some figuring out to do on my side. Thanks!
if you want to send SOL from an account that is not owned by the system program but by your program, dont use a CPI. edit the lamports of the accounts instead
This is how I had to build the instruction so far: 
```
let ix = Instruction {
        program_id: *cpictx.program.key,
        accounts: cpictx.to_account_metas(None).into_iter()
                                                    .map(|mut meta| {
                                                        if meta.pubkey == ctx.accounts.position_pda.to_account_info().key() {
                                                            meta.is_signer = true;
                                                        }
                                                        meta
                                                    }).collect(),
        data: data.data()

    };

    anchor_lang::solana_program::program::invoke_signed(
        &ix, 
        &cpictx.to_account_infos(),
        &[
            [
                ctx.accounts.owner.key().as_ref(),
                &_index.to_le_bytes(),
                seeds::USER_POSITION_STRING,
                &[_bump_position]
            ].as_ref()
        ]

    )
```
Would doing something like ``` position_pda.to_account_info().assign(ctx.program_id)``` be safe and fix my problem?😅
Follow up: I'm trying to Cpi into a program, and I want to send SOL from a pda to their account. I managed to pass the signer checks, however, the program expects system program to be the owner of the account that sends SOL to it, which breaks my program since my program is the owner of the pda by definition. 
```
Transaction simulation failed: Error processing Instruction 0: invalid program argument 
    Program EUBBaxNut3Z79MxGFTa4DsfUdAkdrwEP7b7Zc1W9Hj2H invoke [1]
    Program log: Instruction: CreatePositionSMT
    Program log: depamt 2000000000
    Program MarBmsSgKXdrN1egZf5sqe1TMai9K1rChYNDJgjq7aD invoke [2]
    Program log: Invalid transfer_from owner_program: expected 11111111111111111111111111111111 got EUBBaxNut3Z79MxGFTa4DsfUdAkdrwEP7b7Zc1W9Hj2H
    Program log: The arguments provided to a program instruction where invalid
    Program MarBmsSgKXdrN1egZf5sqe1TMai9K1rChYNDJgjq7aD consumed 34066 of 170267 compute units
    Program MarBmsSgKXdrN1egZf5sqe1TMai9K1rChYNDJgjq7aD failed: invalid program argument
    Program EUBBaxNut3Z79MxGFTa4DsfUdAkdrwEP7b7Zc1W9Hj2H consumed 63799 of 200000 compute units
    Program EUBBaxNut3Z79MxGFTa4DsfUdAkdrwEP7b7Zc1W9Hj2H failed: invalid program argument
```
ctx.program_id
How can I access the pubkey of the program from within the program?
if an account is changed, it has to be mutable
Hi All - When transferring SOL from a vault (PDA) account to a "to" account, I've read that the "to" account does not need to be mutable. Because we are only transferring SOL to the account. But when implementing this, I get the error "instruction changed the balance of a read-only account" if I don't mark the "to" account as mutable. Any help on why this happens?
and the accounts work fine, just the instruction data it thinks is private <:jpscream:783002398284972073>
this instruction works fine 🤷‍♂️
Anybody else had an issue with some `instruction` structs (the ones generated by the anchor framework itself) being "private" when using them in a Rust client?

There's nothing different about the instructions which have this issue as far as I can see. But I can't use them in the client, I just get the following error:

```
error[E0603]: struct `RandomNum` is private
  --> rust/client/src/utils.rs:75:45
   |
75 |     let random_num_args = hub::instruction::RandomNum {
   |                                             ^^^^^^^^^ private struct
   |
note: the struct `RandomNum` is defined here
  --> programs/hub/src/lib.rs:56:1
   |
56 | #[program]
   | ^^^^^^^^^^
   = note: this error originates in the attribute macro `program` (in Nightly builds, run with -Z macro-backtrace for more info)
```

It's weird because we don't have this issue when using a ts client <:thonk:908303306038837258>
Rust type inference being dumb, do `b"asdfasdf".as_ref()` instead
Why am I getting this error with the second seed? It goes away when both seeds are the same length.
Before I used `u128` for Decimal, so I didn't have any problems, but now I need a bit more precision
And another question, which `Decimal` type can I use with Anchor?
I've been trying to use `uint` crate, however it seems like anchor can't generate correct idl for it at all and swiftly fails when I try to call `anchor test`.
```
construct_uint! {
    #[derive(AnchorSerialize, AnchorDeserialize)]
    pub struct U256(4);
}
```
https://docs.rs/anchor-lang/latest/anchor_lang/attr.interface.html
Is there a slightly more involved example I can look at&
There is an example in docs, however it is very simple and does not deal with contexts at all (by simply passing an empty one)
Good day! What is the correct way of setting up `#[interface]` macro?
would it work differently from how `new_account.exit()` is called? You'd still need to call it on each individual account right
Not sure, maybe that's a bad idea for some reason 🤔
Rather than having it happen after the instruction function returns
For basically just calling exit()
intializing an account or for writing the data?
what would the `drop` impl be for?
I wonder if it would make sense for Account to just have a Drop impl that does that, hmm
great, i'll pass on the info and try it out. Thanks!
Got it, cool
yes, i read you need `.exit` to make sure it's written
To subsequently write in the data + discriminator bytes
But I think you may be to manually handle calling .exit() on the account at the end of the instruction 🤔
ah i see, `unchecked`
that would be cool if that could work
ok
Think you can do
```.rs
        let hmm: Account<Thing> = Account::try_from_unchecked(&the_account_info)?;
```
it seems like anchor already has loading existing anchor accounts sorted, using `try_from` but i haven't found people initializing variable numbers of accounts
Oh, got it
so everything has to be done manually
the problem is that we're trying to initialize accounts from `remaining_accounts`
Can you use `#[account(zero)]`? If the AccountInfo already has the right amount of space I think that should work,
```.rs
#[derive(Accounts)]
pub struct Something<'info> {
  #[account(zero)]
  pub the_pda: Account<'info, TheStructType>
  ...
}
```
what's the proper way to init anchor account data onto a blank account info? Assume that the account has been init as a PDA already and this is just about assigning the data to the account. There's a `new` method for anchor accounts (similar to `try_from`) but it's private. If this was public would that be the right way to init an account?

https://github.com/project-serum/anchor/blob/2a039f2e45eb0c0f0f13111468becf9f51923af9/lang/src/accounts/account.rs#L243
does someone know the difference between these two?
anchor deploy would work right
You can just redeploy it
how to update an existing anchor program on mainnet ?
maybe i missed something u can either try browsing rustdoc or the sourcecode of both crates to see if you can find a function for your usecase, but it does seem feasible in javascript if you're willing to find the token accounts offchain
checked both anchor-spl and spl-token, didn't find anything that might help you do so from rust
from rust
are you asking in relation to a javascript client or from rust?
is it possible to grab a list of the token accounts that an escrow owns from the program side? (i.e. something similar to candy machine, where an escrow holds some NFT's and wants to transfer a random one?)
How can i wrap or unwrap sol in Anchor ?
how would I use this if I want to pass a "CpiContext::new_with_signer()" where a pda signs for the instruction and there is no "#[account(mut,signer)]" in the context?
Can someone explain the "is_signer" argument in the "to_account_metas" function?  What's the difference with something like:
```
let ix = Instruction {
        program_id: *cpi_ctx.program.key,
        accounts: cpi_ctx.accounts.to_account_metas(None),
        data: instruction_data.data(),
    };
```
and 
```
  let ix = Instruction {
        program_id: *cpi_ctx.program.key,
        accounts: cpi_ctx.accounts.to_account_metas(Some(true)),
        data: instruction_data.data(),
    };
```
<@!134416332509675520>
Hi guys, I'm trying to perform freezing and thawing on a custom token account and I can able to freeze the token account but when I try to unfreeze/thaw the token account, then its throwing an error saying ``Error: Invalid account state for operation ``, Which is very new for me and when I checked the community, there is no information regarding this error. can any one help me out in this?
Thanks
Got it -- crates.io is what I was looking for. Perfect
you can go to crates.io and look at all the creates availabe
spl-token = { version = "3.1.1", features = ["no-entrypoint"] }
For example you want to use the SPL token program So to use it you copy its crate name that is registered at creates.io and tell the version that you are going to use in the cargo.toml file
I'm trying to add solend (https://github.com/solendprotocol/solana-program-library/blob/mainnet/token-lending/program/src/instruction.rs#L820) but how do we know what that cargo.toml is supposed to look like?
this is an example I found online
what do you mean by that? I understand that we ned to add to the Cargo.toml now but is there a package manager (or something of the sort)? How do we know the version and what exactly it's called?
but the anchor result is the one that's relevant for most anchor programs. the large majority dont ever use std::Result. and we're designing the defaults for the large majority
that is why you have to import the caller program Create
you are going to need those instructions to call CPI
When trying to cpi into another program, it seems that you have to add lines into your Cargo.toml file as dependencies. Is there a standard practice of doing so?
Maybe removing the type alias as an import from the prelude would be the simplest thing to do? I think it makes sense to have the specialized anchor Result require namespace qualification by default rather than the std Result
we could consider something like `AnchorResult` but we just havent heard many complaints about this. our result is the most common return type so the alias seems like the right thing to do.

also, people are definitely using other results  without the error type as well. in fact, thats a very common thing to do. `anyhow` does it. the standard library itself does it (see std::io::Result)

edit: AnchorResult, not AnchorError
It’s cleaner because Result should specify the Error type, that’s how Result-like types work in other languages and it’s what people are used to in rust. It makes it harder to upgrade because it’s a breaking change. Breaking changes are fine if they make things better, but this is breaking without much of an improvement (and imo a downgrade from ProgramResult or ideally just no type alias at all)
is there convenient location to look for the detail of error?
I got  0x136 = 310 "Invalid param" but cannot know what parameter I am tossing wrong
I dont see why it's cleaner in the case of anchor programs?

why is it more difficult to upgrade?
Understood, but Result is a really common rust type, it seems like it shouldn’t be aliased to a library-specific type. Instead of aliasing, I think Result<(), Error> was just as easy to write, is cleaner (Result should always be generic over two types), and doesn’t break code. From my convos with other protocols I don’t think I’m doing anything crazy here with error handling, and this makes it more difficult to upgrade anchor versions
like you said, you can still `::std::Result` right? Most users dont use their own result type so Id'd be hesitant to revert this
I propagate my custom protocol errors with a Result that is generic over my custom error type (which is then converted into anchor’s error type). I can’t do that anymore because of this aggressive type aliasing. Everything I’m doing is in line with on-chain programming paradigms.
the justification is that youre writing an onchain program that returns onchain results, not std::results. so it makes sense to make the onchain result the default
this just seems like a really aggressive type alias right? what was the justification for doing this? https://github.com/project-serum/anchor/pull/1462/files#diff-c30312f654589dc8120c3ca5d75db6816b7825627c10c7c4b485215991bd54e7R60

```
pub type Result<T> = std::result::Result<T, error::Error>;
```

Users of anchor use `Result` types that aren't the (now deprecated) `ProgramResult` but now can't without specifying a namespace or a custom type alias. Are anchor devs open to reverting this alias? I can make a PR but wanted to check if it's wanted first.
It’s totally my state of mind actually
Fun related post: https://math.stackexchange.com/questions/2086285/did-p%C3%B3lya-say-can-or-cannot
Like when I was a student, I skipped the steps. Good luck it worked at school because the technical referent was there to explain lol to me. But this is not the case. I need to find the source and attack
Yes no, you’re absolutely right. My dumb side is looking for a miracle, but it’s obvious there isn’t one. I think I have to start somewhere, I don’t know where yet but I’m sure I’ll be able to put my ideas in code in Web3 for sure
If that's too hard, then tinker around with implementing something easier, etc. Keep making it easier until you can do it from scratch, then make it a little harder again, etc. There's no magic.
E.g. you could try writing the program from scratch, without looking at my implementation—you have the answer key already, so it's easy to test yourself
Heh, I realize this isn't a super satisfying answer, but you're just going to have to actually sit down and work through what you're not understanding. E.g. you could do all sorts of things to improve your understanding
So like 16 cents
KING
Look I quickly read your source code, it’s pretty clear is understandable. Apart from some subtlety, I understand globally what you are trying to do with your program! But of myself I would have been unable to realize it
2039280 lamports
I'm on my phone 😭
You can just run it yourself!
does anyone know this off the top of their head I have 35K SE Asians screaming at me in my Discord right now
Ok, then there's your task—go figure out how that program works. No way you'll be able to write an NFT staking program if you can't follow that program
This is maaaybe sort of starting to get better now as people write better docs etc., but I maintain that solana is going to be a nightmare unless you're comfy jumping to source
Not at all but I will be unable to understand what you wrote lol
You basically just have to get comfy jumping to source—everything is code, just need to go looking for it 😛
Have you looked at https://github.com/cqfd/quidproquo ? I would suggest making sure you understand absolutely every part of it, then revisit nft staking
True
I think you're going to have to step back and make sure you can work through simpler problems first—you're trying to run before you can walk
But ballpark is that rent-exemption costs about a dollar per kilobyte (bit less now that sol is down), and a token account takes up 165 bytes (that Account::LEN part)—plus a little overhead (jump to source on that method for the exact amount)—so ballpark is around 20 cents per account
Like a staking NFT tool, how I can think about the logic and develop it
Just that, where did you come up with this logic? If I had to find this solution, where would you get it?
You can use `Rent::default().minimum_balance(spl_token::state::Account::LEN)` to get the exact answer in lamports
Well, I’ll figure it out anyway, I’m gonna have to figure it out myself. Many people did well without having to yell for help lmao
OK so I really have to go back a long way in learning so
How much does an ATA cost? For an airdrop mint.
Well, from there it shows that I don’t understand things since I don’t know how to answer your question
Solana as a db also isn't really immutable, or at least not sure what you mean by that (you can definitely mutate stuff)
Interacting with the blockchain doesn't necessarily require sending tokens (not sure what you mean there)
Learning the web2, I did studies so it’s always easier when there is a technical referent to help you think and correct you.
I think it's both. I already understood that in Solana, everything is an account. As soon as you interact with the blockchain, you have to send tokens (so now what kind of token is another thing). Rust from what I saw in the tutorials doesn't seem too complex either. I've already done embedded system with C++ so there are some similarities. I guess I don't understand the elements that Solana brings to Rust either. To put it simply, I’m going to have an idea, but I have no idea how to think it through completely with a smart contract. If I had to simulate this project in Web2, it’s ok. Solana plays in some way the role of DB (except that it is immutable). But I don’t even know how to explain my lmao problem

I don’t know when a Smart Contract should intervene, how to think about it, how to use it. I also think that my problem comes from my habit of thinking in Web2 I don’t know
The basic interactions with Web3 Solana/SPL-Token are more or less mastered in my opinion. Finally I have the terms, the syntax and I know where to get my information for now. And most of all, I'm glad that the Solana community is present and active
Solana programming model, meaning things like how accounts work, signing for addresses, etc.
Do you think the rust problems you're having are from not knowing rust well enough, or from not understanding the solana programming model?
I will take a look !
I think my real difficulty is logic. The problem is "how to think about my program". The Rust structure, how it works. Making tutorials and making it work is ok, but when you don't understand it behind it's useless. I assume that if you can't do the tutorial by yourself, you don't understand.

Already, JSON RPC from Solana, with Web3, I can more or less manage. I've done some small functional projects that I'm happy with. But I would like to go further than creating transactions, I would like to be able to make a complete Web3 project. JS and Rust. In web, I'm independent. I'm able to develop my thinking. In Rust, nothing. Nothingness.

I did the two most used tutorials I think, the decentralized Twitter and the "ultimate" React, Anchor, Rust tutorial.

But in my opinion these tutorials are good, but lack depth. They explain how the program works in relation to the realized project and not in relation to how it was thought.

And now I'm going to do Solana's Twitter thread, I'm going to read all the possible docs + the buildspace.

But I'm apprehensive about it all
Can you say more about what hasn't worked so far? What tutorials have you worked through, which rust books have you tried reading, etc.?
check out soldev.app, it has some good tutorials to walk through
😭
gotcha, ok, that makes sense, thanks for your help! i'll pick a sane default for now
But if you're using zero_copy, you can't use Vec (that requires using the heap, which kind of defeats the purpose of/is at least incompatible with zero_copy, unfortunately)
I feel like I saw an issue about this though, so maybe anchor will make this easier?
One limitation/difference between zero_copy/bytemuck/AccountLoader versus regular borsh/Account is that borsh is totally fine with extra space in the account, whereas AccountLoader isn't
i am ya
A vec would allow that, yeah—are you using zero_copy though?
i've got a PDA that represents a users history in my app, and there is an array value with records. initially i had the size of the array larger, and realized that rent costs would be probably more than the average user was willing to spend, and reduced it. now i'm seeing errors: `Program log: panicked at 'from_bytes_mut>SizeMismatch'` ok -- that's fair. but is there a data structure or way that i could allow users to dictate their preference, and still have accounts of all sizes work? like if one user wanted to put down 100 bucks and another user wanted the smallest size history possible to save on rent? would a `Vec` allow this?
And then invoke it in your own program with `anchor_lang::solana_program::program::invoke`, or invoke_signed if you want to add signatures for any PDAs derived from your program
You would call one of those instruction factory functions, e.g. https://github.com/solendprotocol/solana-program-library/blob/mainnet/token-lending/program/src/instruction.rs#L820 (I don't know which one you'd personally want to invoke, but that's the idea)
If you jump to source, every token program interaction is just doing an `invoke_signed` of an instruction, under the hood
https://github.com/solendprotocol/solana-program-library/blob/mainnet/token-lending/program/src/instruction.rs
Would be ideal if they were examples in defi/lending -- trying to cpi into solend
Anybody have any examples cpi'ing into on-chain programs. Not sure exactly what I should be "importing" or really looking at with respect to the program's context.
According to my short experience, The error message is not that helpful to me.
Because of there are lots of reasons.
Sometimes it was not enough SOL to send a transaction, sometimes it was because of account types. 
I highly recommend checking all possibilities you can try.
Attaching your source code may help to investigate your error.
I would like for example to develop my own NFT staking system (even if there are tools, I prefer to have complete control over everything I do) but I have no idea how to do it.
I envy you a lot guys because I am a developer myself and I am looking to specialize in web3 and start with Solana. My problem is that I am someone who has trouble assimilating new logics. I need to define development cycles and structure my brain to reflect on development with a new syntax. I have never done Rust before and suddenly I would like to know, what advice can you give me to better assimilate the Solana dev?  Let it be a development cycle (where to start, how to think). Finally anything to help me in my learning of Solana! I have a lot of ambitions that I see at the moment being reduced because of this Rust brake. I think that when I can develop my own Smart Contract, my ambition will never have any limit
Hello. How do I pass in an enum type to the client. I don’t think the idl interprets it correctly
nvm, just submitted phantom to sign the txn instead of sign + send, and then sent separately and it surfaced a much clearer error message.
this isn't an anchor problem but phantom wallet doesn't have a discord. I am getting a very vague error message saying RPC error, but not sure how to debug. anyone have advice?
If it's too hard, try to do an easier version, etc.
Lol, I don't know—I'm saying just try to figure out your program yourself 😛
What is the name of this suff lol
Just give it a shot
I doubt there are any pre-made tutorials for this stuff
Then you should try writing the code yourself!
with spl tokens
no I know how to create a dapp or smart contracts but I haven't created a claimable reward from vault


///////////////////////////////////////////////////////////////////////////////////////////////

😩 learning everyday
Nope, can't close mints unfortunately
It's a dead mint we used for testing on mainnet. Could I close it?
I can't write a custom program or anything?
fuck me
Pretty sure that sol is toast unfortunately :/
Hey I got a fun one for ya'll... I accidentally sent 5 SOL to the wrong wallet in my phantom wallet. The wallet is a token mint. I can't send the SOL back. How can I transfer that 5 SOL back from the token mint?
I am on localnet
This usually happens when the RPC doesn't return a blockhash and it times out. Devnet was probably slow or down during that time
I believe that's it. You can deploy your programs to that program ID so long as you have the wallet in your solana config
Hello everyone! Just want to confirm one thing:
1. If we have the upgrade authority private key for a program, that is all we need to be able to update the program's executable code?

Is there anything else we should be cautious about / store besides upgrade authority keys + program ID that we'll need to be able to upgrade / overwrite a specific program
Hey, I have a question: I'm currently getting my accounts through filtering `program.account.MyAccount.all()` which gives me all the accounts I need. However, I need the public key for the account to use it for another RPC call I'm making. How can  I retrieve it given an account?
Why i am getting this error ? "` Error: Unable to obtain a new blockhash after 10140ms
      at Connection._pollNewBlockhash (node_modules/@solana/web3.js/src/connection.ts:3770:13)
      at Connection._recentBlockhash (node_modules/@solana/web3.js/src/connection.ts:3743:12)
      at Connection.sendTransaction (node_modules/@solana/web3.js/src/connection.ts:3886:39)
      at Object.sendAndConfirmTransaction (node_modules/@solana/web3.js/src/util/send-and-confirm-transaction.ts:30:21)
      at Token.mintTo (node_modules/@solana/spl-token/client/token.js:1042:5)`"
Nothing
Just curious from a security point of view, what would be the difference between the two methods? (being owned by a program vs system_progam)
If you want to subsequently `system_instruction::transfer` the lamports somewhere else
Just let it be a system program account (it lives at a PDA so you can sign for it)
I would suggest not init-ing an account at all actually
ok it was throwing an error when I din't use the space parameter. I din't think we could use space=0, but let me give it a try.
If all you're using that account for is as a place to store some sol, you don't need it to be owned by your program at all by the way, it can just happily be a system program account
Since you aren't storing any actual data there
You could just do space = 0 I think
What are you storing at that account? Why are you giving it space?
What you've got there doesn't really quite make sense (the space in particular)
Why are you making it an AccountInfo though?
```#[account(
        init, 
        seeds=[from.to_account_info().key.as_ref()], 
        bump, 
        payer=from,
        space=8 + std::mem::size_of::<AccountInfo>()
    )]
    vault: AccountInfo<'info>,```
This is how I am initializing the account, it is of type AccountInfo and it is owned by the program right when I initialize it this way?
If you want to close it you'll have to just use sytem_instruction::transfer to drain its lamports
And `close` only works on accounts owned by your program, but I'm guessing that PDA is a system_program account for you
Can you use one of those types?
<@!134416332509675520> Hi, I am trying to close a PDA account I created with "close=user" 
but keep running into an error "close must be on an Account, ProgramAccount, or Loader". Any help in what could be wrong?
Thank you, let me check it
can I send by dm?
Can you post more of your instruction function code?
is there something similar to Box that I can do to the structs within the function? I need to make all these CPI calls in the same function and these are causing the memory error
ya this works
And see if the stack usage changes
Like, try commenting out the whole body of the function
Yeah, in the function itself
Probably not if you're over by 2k bytes
but in the function?
so not in the accounts struct
ohhh
Like, big local variables
I think you probably have some big structs inside your instruction function
No, those are the same as AccountInfo
So im guessing its the uncheckedAccounts?
Are you using any large structs on the stack inside your instruction function? AccountLoaders and AccountInfos would be unlikely to blow your stack budget by 2872 bytes all by themselves (basically impossible)
AccountLoader isn't the problem, that keeps all of the data inside the original AccountInfo (so someplace that's *neither* the stack nor the heap)
Could you first explain why you think you need it? What are you trying to accomplish? I tried to explain above that `TokenAccount` already checks that the incoming account is owned by the spl token program
Hi, I have some really large accounts struct and its causing memory errors
```
Stack offset of -6968 exceeded max offset of -4096 by 2872 bytes, please minimize large stack variables
```
I tried putting some stuff in boxes but it only works with things of type accounts<something>, it doesnt work for accountLoaders or unchecked accounts, I get this when I try
```
error: proc-macro derive panicked
   --> programs/squeeth/src/lib.rs:966:10
    |
966 | #[derive(Accounts)]
    |          ^^^^^^^^
    |
    = help: message: Invariant violation: composite constraints can only be raw or literals
```
any fix to this?
I don't know well the anchor
Would you please explain the reason?
(You don't need to do that 😛)
I know, but why do you think you need to do that?
It's =, not ==
That isn't constraint, only owner = *token_program.key
I'm not sure, but why do you think you need that constraint?
Is it a bug?
But in the 0.19.0, it's okay
...
Why?
But I need that constraint
Interesting—at any rate, you should get rid of that constraint
Other constraints are okay
Error is generated in owner = *token_program.key
One quick thing, you don't need that owner constraint, `TokenAccount` already does that for you
There are different between the accounts struct of TokenAccount and AccountInfo in 0.22.1
but in the 0.22.1, this isn't working now
This was worked in 0.19.0
Account struct has info, and AccountInfo has owner: &'a Pubkey

error[E0609]: no field `owner` on type `&_`
But I'm getting this error

SOS...
figured this out, just going to explain what it was for the benefit of anybody else searching for `error[E0603]: struct X is private` when using the rust client. 

so for some of my instructions, they use the same accounts struct, and this is what i was using as the instruction struct in the client. once i dived into the cargo expand output, i realised that the `program::instruction::InstructionName` struct comes from the function name instead. so once i used `hub::instruction::GetRandomNum` instead of just `hub::instruction::RandomNum` (which worked for the accounts part) it worked fine 

||keywords: private struct instruction E0603 #[program] error originates in attribute macro program||
For anyone who ever tries to cpi into marinade and have it be signed by a pda, make sure that the pda is owned by the system program and not your program!
for sure where would we be without anchor
I'm just a messanger. thank the anchor guys for actually building this 🙂
♥️♥️♥️
♥️♥️♥️♥️♥️♥️♥️♥️♥️♥️♥️♥️♥️♥️♥️♥️♥️♥️♥️♥️♥️♥️♥️♥️♥️
thank you for replying
i love you so much that just solved 4 hrs of debugging
yeah.
take a look at the whole discussion here: https://discord.com/channels/889577356681945098/889577399308656662/950487632239001762
On top of which struct? also i'm on Anchor 0.20.0 if important
had the same issue and also thought it's a bug. they switched how it's packed and now you need to add `#[repr(packed)]` or smth like that to make it work
and deseriliazation
I believe this is abug with array packing
really strange problem, decoding array of structs u64 on client side
I set the u64 in the account to 1 but when I read it off the chain it comes back as 4294967296 (MAX u32)
code:
```rust
#[account(zero_copy)]
#[derive(Debug)]
pub struct WeightedTokens {
    /// The index of array
    pub index: u16,
    /// Max capacity of the array
    pub capacity: u16,
    /// [WeightedToken] array
    pub weighted_tokens: [WeightedToken; 10], // TODO find better name
}
#[zero_copy]
#[derive(Debug, Default, AnchorDeserialize, AnchorSerialize)]
pub struct WeightedToken {
    pub mint: Pubkey,
    pub weight: u64,
}
```
the client call:
```js
    const weightedTokens = await program.account.weightedTokens.fetch(key);
```
it show's BN: 0x100000
you hit the stack limit, try to box the account
ordering matter
would you like to share corresponding code, so we can debug it
You can `Box` some of them, e.g. 
```
pub my_account: Box<Account<'info, MyAccount>>
```
```
#[derive(Accounts)]
#[instruction(
    first_bump: u8,
    second_bump: u8,
    third_bump: u8,
    seed_nonce_a: u64,
    seed_nonce_b: u64,
    seed_nonce_c: u64,
)]
```
does the ordering of the values in the macro matter? or is it by name of the variable?
Hey folks, any tips&tricks for this one (when doing `anchor build`)?
```Error: Function _ZN7riptide9__private8__global14crank_campaign17hecaf01e0c1d04878E Stack offset of -4296 exceeded max offset of -4096 by 200 bytes, please minimize large stack variables```
I noticed that if I remove one of the accounts, from the `#[derive(Accounts)]` structure, it gets rid of the error,  but I kind of need them all
Got it..thansk!
Nope, no network access of any kind (that's just how all blockchains work—can't use randomness either, etc.)
Can we make rpc calls from inside the smart contract? If yes then i can just do getprogramAccounts()?
Nope, solana unfortunately just doesn't work that way, you have to pass *all* accounts in from the client (no dynamics lookups of any kind inside the rust part)
Is there any rust equivalent of program.account.my_struct.all() that i can use in the smart contract to get all the accounts of a particular type?
Ok thanks, will give that a go
the way i debug stuff like this is to log all the addresses that i'm passing in to the context and matching that with the error msg, so i guess the program wants whatever you pass in as player from the frontend to be the signer, You have to make sure that you're doing that. Also signer is usually mut if i'm not mistaken
Those are for the called function


Pretty much just trying to  push data from the front end to the account, ill send what I've got for this in the contract
I guess the signer isn't the one that the program was expecting, kinda hard to distill more out of this haha, you need to give more context
Anyone know why I'm getting this error?

I want to cpi into marinade and have a permissionless instruction where a pda signs for the instruction (depositing sol into marinade and getting back msol). The problem is that the account which has the authority in marinade is the same one that sends sol to get back msol, and they also check that this one is owned by the system program and throw an error if not. I was basically trying to have that as a "Account<'info, Whatever>," pda, but that's not possible😅 .
oh I see now, I will have to  just redesign the program a bit and just add a separate AccountInfo type pda owned by the system program which signs the transaction.
You can't write data to the account unless it's owned by your program, so I'm not sure what you're trying to do
But then why do you want it to be owned by the system program?
i see, but I want to init and save some fields as in ```Account<'info, Whatever>,```
And it will magically be there waiting for you as an empty AccountInfo 🪄
If you want it to be owned by the system program, you actually don't need to init anything at all—just pass the address in from the client
Do you need to init an account at all?
is there a way to change this to the systems program?
Ah, if you use `init` on a `Account<'info, Whatever>`, then yeah, that will be owned by your program
actually this might be a version issue, but the pda owner defaults to the program address for me. what's the syntax to set it to the system program?
```solana-cli 1.8.16 (src:23af37fe; feat:1886190546)```
anchor version 0.22
```

[dependencies]
anchor-lang = "0.22.0"
anchor-spl = "0.22.0"
spl-token-lending = { git = "https://github.com/solana-labs/solana-program-library", version = "0.1.0", features = ["no-entrypoint"] }
uint = "=0.9.1"
solana-program = "1.9.9"
bytemuck = "1.7.2"
spl-token = "3.3.0"
```
it seems specific to my machine
any idea why this could be?

my `anchor test` cannot connect to a local validator after the wait is set to a minute
Thank you
I'm getting a seed constraints violation that I can't figure out. I can calculate the right PDA on the client, and am passing in the exact seeds I use to calculate that PDA, but getting a seeds constraint violation (2006) during transaction simulation. Is there a way to log the seeds when it tries to calculate the PDA in the on-chain code?
Specify your `payer` account as mut with `#[account(mut)]`
SOS ...
I'm using the anchor 0.22.1
#[account(init, seeds = [b"statev1".as_ref(), bid_mint.to_account_info().key.as_ref()], bump, payer = payer)]
    pub state: AccountLoader<'info, State>,
error: the payer specified for an init constraint must be mutable.
How to setting the mutable of payer acc with init?
Hello, everyone
Oh, just reading the Anchor book now, looks like they save the bump into the account for further calls
Also, when doing init, you pass an empty one and Anchor will find the cannonical
I think it's 0.20
What version are you using?
I am trying to Mint a NFT
Another Question:
When I add the "seeds" and "bump" constraints for an account, how do I make sure the caller passes the first bump, and not other bumps? 
Is this constraint enough, or do I need to calculate (seed, bump) on-chain in the instruction?
```rust
#[instruction(bump: u8)]
pub struct UpdateMyAccount<'info> {
  #[account(mut, seeds = [b"my_seed"], bump = bump)]
  pub Account<'info, MyAccount>,
```
I am getting this Error
`Transaction simulation failed: Error processing Instruction 0: invalid account data for instruction 
    Program 3aeX9JsMSHueuLGDoigyt935Yom9cQAN3z8E58v7QDB4 invoke [1]
    Program log: Instruction: TxWithCoupon
    Program metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s invoke [2]
    Program log: Instruction: Create Metadata Accounts v2
    Program log: Transfer 5616720 lamports to the new account
    Program 11111111111111111111111111111111 invoke [3]
    Program 11111111111111111111111111111111 success
    Program log: Allocate space for the account
    Program 11111111111111111111111111111111 invoke [3]
    Program 11111111111111111111111111111111 success
    Program log: Assign the account to the owning program
    Program 11111111111111111111111111111111 invoke [3]
    Program 11111111111111111111111111111111 success
    Program metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s consumed 32159 of 1379700 compute units
    Program metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s success
    Program log: CREATED MEta data
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [2]
    Program log: Instruction: MintTo
    Program log: Error: InvalidAccountData
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 1593 of 1343872 compute units
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA failed: invalid account data for instruction
    Program 3aeX9JsMSHueuLGDoigyt935Yom9cQAN3z8E58v7QDB4 consumed 57721 of 1400000 compute units
    Program 3aeX9JsMSHueuLGDoigyt935Yom9cQAN3z8E58v7QDB4 failed: invalid account data for instruction`
When you use init on an AccountInfo type account, how do you close the account and return rent to some user? If I use the close=user argument, it says "close must be on an Account, ProgramAccount, or Loader"
Awesome, thank you 🙌
The lower-tech way to do it would be to just bake some specific admin pubkey into your program and make it sign the tx whenever you want to modify that account
Yep, you there's an anchor test demonstrating one way to do this (it's a little involved): https://github.com/project-serum/anchor/tree/master/tests/bpf-upgradeable-state
Yeah, that's actually the default
Hi, is there an elegant way to enforce: "This account can only be modified by the wallet who deployed the program" ?

Other than "Create the account quickly after deploying the program, and set a field <owner> and check against that field every time you want to modify"
Ok, this gives me some hope, does it make sense to have the system program be the pda owner?
Yea i remember having tried this before, thanks 👍
Hey all, I'm facing an error when testing my program on devnet:
```Error: 429 Too Many Requests:  {"jsonrpc":"2.0","error":{"code": 429, "message":"Too many requests for a specific RPC call, contact your app developer or support@rpcpool.com."}, "id": "c6d2ff37-a65a-4aee-9e96-1f480d007570" } ```
In the tests, I'm creating 2 accounts and trying to airdrop 1 SOL to one of them so it can pay rent and think it may be erring here, as I'm doing this a total of 4 times. Would anyone know how to work around this?
Just to clarify, it's not the case that your program is the owner of the PDA by definition (assuming I'm reading that right). Program-owner is independent of which program the address was derived from.
No, that only works for system program accounts (not token accounts)
yeah that's what i gathered from skimming the source code but only one way to find out really
I'm also sleepy can't remember if I have tried this already
Let me try haha
Oh so if i do it from a wsol account the system_instrution::transfer will work?
might be easier for you to wrap it then, and make your pda a TokenAccount for wrapped sol instead.

i've never wrapped SOL in a program before, so can't help much if that's the route you want to go for. 

source for the cli wrap command: https://github.com/solana-labs/solana-program-library/blob/0df75ab5e8e163e7e887511290740e5bc5181c45/token/cli/src/main.rs#L1044

if i'm reading the source code right (it's late where i am and i'm half asleep so i'm probably not),  it looks like you just need to create a token account with the `native_mint`and send sol to it
That wouldn't work either citing cqfd : "No, you only get to change program ownership once, from system_program --> some other program
Once you've made that assignment once it's fixed forever" 

haha, my program isn't working as I want it to but this is kinda fun
and 
```
invoke(
                &system_instruction::transfer(
                    self.transfer_from.key,
                    self.reserve_pda.key,
                    user_lamports,
                ),
                &[
                    self.transfer_from.clone(),
                    self.reserve_pda.clone(),
                    self.system_program.clone(),
                ],
            )?;
```. One hacky way would be to try to change the owner of the pda but that will cause more issues down the line i think....
yea I'm trying to CPI into marinade. The problem is that if I adjust the lamports on my side, I won't get back the msol in return I think. They do a case distinction then two instructions like 
```
invoke(
                &system_instruction::transfer(
                    self.transfer_from.key,
                    self.liq_pool_sol_leg_pda.key,
                    lamports_for_the_liq_pool,
                ),
                &[
                    self.transfer_from.clone(),
                    self.liq_pool_sol_leg_pda.clone(),
                    self.system_program.clone(),
                ],
            )?;
```
something like this iirc
```rust
// sending 1,000,000 lamports from acc1 to acc2
let amount: u64 = 1_000_000;
let initial_balance_acc1 = acc1.to_account_info().lamports();
let initial_balance_acc2 = acc2.to_account_info().lamports();
**acc2.to_account_info().lamports.borrow_mut() =
    initial_balance_acc2.checked_add(amount).unwrap();
**acc1.to_account_info().lamports.borrow_mut() = 
    initial_balance_acc1.checked_sub(amount).unwrap();
```
if you're doing a CPI with signer seeds to this other program and the account is marked as mutable then you should be able to modify that account's lamports in the CPI program i think
The problem is that I cpi into a program that adjusts the lamports itself and gives me back some token in return, so me just changing the lamports on my side would break that logic i think


///////////////////////////////////////////////////////////////////////////////////////////////

Thank you let me try!
Annoying but I think you need to do
```.rs
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub enum ChangeOperator {
    AddOperator { pubkey: Pubkey },
    RemoveOperator { whatever: Pubkey },
}
```
Hi, anyone can help me with the typescript error `Error: Tuple enum variants not yet implemented.`? I have this Rust enum as an input parameter in handler. Looks like the serd/deserd not supported yet in ts?
```
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub enum ChangeOperator {
    AddOperator(Pubkey),
    RemoveOperator(Pubkey),
}
```
Ah I figured it out, I was passing in the token account address to the spl-token `getTokenAccount` instead of the token's mint
Can you post the full program log then?
Yeah it should be, this is the account address: https://solscan.io/account/ED7aXuT9naUK4tUujhrGTXeFSFN38muScRop94GBuyYq?cluster=devnet
ahh let me check good call out
Token accounts have to have a very specific length (165 bytes)
Are you sure whatever you're trying to do with a token account is using an actual token account?
Is anyone familiar with the `TokenInvalidAccountSizeError` error?
Hi, quick question, is there a tool / method in anchor ts to read an instruction from the chain and make it readable for humans? 
It would show a map of  accounts name / value and a map a argument name / value  following the IDL format?
cli
The rent exemption for 0 storage is 0.00089088 SOL. Obtained by using `solana rent 0`
Many thanks 🙏
Before. One way you can play around with this stuff is by adding a little `#[test]` to your program file:
```.rs
#[test]
fn whatever() {
  eprintln!("{:?}", Some(123).try_to_vec());
  eprintln!("{:?}", Some("abcd".to_string()).try_to_vec());
}
```
As far as that extra byte for the option goes, in the data layout does the option byte get packed before the (optional) value, or after it? Asking for purposes of determining the byte offset when using `getProgramAccounts()` memcmp filters
OK neat, I've been trying to force myself to specify the space anyway just to be explicit, didn't realize that will be strictly required in the near future
2) 1 extra byte, yep
No (and in fact, the latest versions of anchor got rid of that Default space trick)
Quick question(s) regarding having `Option<>` type data fields in a PDA account struct. 

1.) If I use `#[derive(Default)]` on such an account struct, will Anchor properly automagically calculate the full space of the PDA, or do I need to specify with `space = ...` if I want to have an anchor instruction context init the PDA with the proper "filled" size?

2.) If I do specify the space myself, how many extra bytes do I add? Just 1 for the optional boolean? i.e. would the `Option<Pubkey>` be counted as 33 bytes?
Yeah
Skipping the discriminator would require using AccountInfo/UncheckedAccount, rather than Account<'info, Whatever>
Thats what I was gettting at with the UncheckedAccount type referred by <@!347689664855015424>
(Because you can skip the 8 bytes of discriminator costs, if you really want to)
No, it will be a minimum length of zero bytes—but you still have to pay rent 😛
In which case, it will be a minimum 8 bytes in length per account...
Then yeah, gotta init an actual account unfortunately (one owned by your program, etc.)
I need it for a hashmap kind of purpose. It will be a PDA, when seed maps to true, the account will exist, when false, the account shouldn't exist...
unless you only need the account for its key, e.g. for signing <@917752451120119820>
lul, I'll mess around with it then. Thanks!
Otherwise you'd have to do something dumb and try catch etc.
I didn't realize that changed the timeout time, I'll give it a go
But doesn't seem like it comes with any configurability besides that (lol, bit of an oversight)
Looks like you can switch that `processed` to `"finalized"` and have the confirmTransaction thing wait 60 seconds rather than 30
more accurately would be to name it Ix
nftTransferTx is an array of size 10
```const confirmations = nftTransferIx.map(async (tx) => {
        const transferNFTTx = new Transaction({ feePayer: provider.wallet.publicKey });
        transferNFTTx.add(tx)
        const NFTTransferTx = await program.provider.send(transferNFTTx, [], {'commitment': 'processed'});
        return await program.provider.connection.confirmTransaction(NFTTransferTx, 'processed');
      })

await Promise.all(confirmations)```
How are you doing the timeout?
hi have anyone tried solana nameservice on mainnet?
is there a way to extend the timeout for confirming transactions in the anchor test suite? I'm currently waiting on confirmation for like 10 transactions and it times out after 30 seconds
There's an `ACCOUNT_STORAGE_OVERHEAD` of 128 bytes no matter what, so you always need at least a little rent
https://github.com/solana-labs/solana/blob/master/sdk/program/src/rent.rs#L55
I am about to test this out, but would like to know before spending time if possible.
How is rent calculated for it then? Without any data stored in it? Am I missing something ?
no, UncheckedAccount takes it name very seriously
Does an UncheckedAccount store the 8 byte discriminator ?
same as any other account. it's an anchor type, not a solana type
Interesting, didn't come across it. How does rent work for these accounts. Any more details/pointers please?
maybe UncheckedAccount is what you're looking for?
or get it by solana  explorer
I found it my self,
get  program log by
solana logs <Program-Id>
Try jumping to their source code
I want to store just a boolean, in fact not even a boolean, just an active PDA account.
Is it possible to have Anchor not use the 8 byte discriminator ?
what's Difference between
ProgramAccount
TokenAccount
AccountInfo ? 
They're totally in un-understandable form for me.
Any tips on how to get program log in client side, from deployed program??
I'm trying to use it for debugging program.
No this is more of a design decision / discussion
seeing this really late since im passing through the question related to serum-dex to find some example cpi calls to it😅 , but yeah that's the address of the system program, the field owner is set to that by default i think, if you create a pda with init and allocate some data in it for example, then that field will be the address of your program
Hello, `anchor deploy` is working now?
I tried several time and for a few days but not working.
I am getting `Error: Custom: Invalid blockhash`. I tried to find solution from before blogs. There was write about trying solana and anchor version upgrade. 
I am using `1.9.12` solana cli.
I tried `solana program deploy...` but it is same. I am using `https://api.mainnet-beta.solana.com` rpc endpoint. need to use other one? what is best for it? or is there any other solution?
but the main point here is, **you need to pass all the account up-front**
mg, eventually everything is going to interact with the program, in this case `system_program`. Here phantom is just acting like a client, passing all the required account.
Any idea how phantom is passing this account if not through a smart contract?
does anyone know of an easy to use web app that let's you add metadata about your token to metaplex metadata lib (so the token shows up in phantom). I can read the code and use the JS sdk if it comes to it, but wondering if easier way or if anyone has made a tool for uploading that metadata so I can just use a GUI and pay the rent fees
clearly when i use phantom i don't need to sign as a the recipient to receive tokens
or rather, how can it pass in the *writeable* account of the receipt
how can the client pass in the account of a receipt
client need to pass all the account
but this is also passing the account na ser
yeah, it is
isn't the client just calling an instruction on the system_program
in contract you need to pass all the account
but not in smart contract
they are able to push a payment to an address without needing that account
you can do it in client side ser
like wallets do this all the time
how does phantom do it when you're doing a transfer to an address
you need to pass all the account
no
is there a way to pay an address without passing it in as an account?
I think Anchor does very well and reduces many of the deserialization process but you still have to pass necessary accounts from the client...

Maybe take a look at this sample code (Ido pool) and study how those are done in Anchor:
https://github.com/project-serum/anchor/blob/master/tests/ido-pool/programs/ido-pool/src/lib.rs
I would like to know more about this. 
I was under the impression, that Anchor did the heavy lifting of deserializing addresses into accounts, applying constraints and what not to make life easy for us.
The only thing you can do in the program is validate if the account pubkey (or PDA pubkey) is correct.
It's not really the issue with the framework, it's just that in Solana you cannot convert Pubkey to AccoutInfo in the program.
Hmmm, I guess there is no other way. 
It will be extremely useful if we can deserialize accounts in the code ourselves, instead of having the framework do it only during the call from client.
You have to pass the PDA account from the client side.
In a CPI accounts struct I have to pass an AccountInfo and an Account<T>
AccountInfo, I am able to pass ctx.accounts.whatever.to_account_info()
Account<T>, I have no clue. It is a PDA, I have the PubKey via find_program_address, how do I get the Account<T> from the PubKey ?
Quick question in the new updates, init_if_needed has been put behind a feature flag, I have been using it only for token accounts, I can't imagine this is dangerous considering they are the ones paying for the intialization of their own token account, am I algd to continue using it or do I misunderstand the danger?
I never read any decent guide on how space works. is there anything that you could suggest?
that's going to get interesting...
Think so 😬
How can i create ATA for NFT in js ?
hey, just to double-check.
if I'm facing this when upgrading my program:
```
Error: Deploying program failed: Error processing Instruction 0: account data too small for instruction
```
does that mean I'm royally fucked and the 2x initial space just ran out?
and search for my stupid questions - I faced that task about a week ago XD
I was annoying <@!134416332509675520> in the process, so you may want to spare him this time 😄
Ok will do 🙂 Thanks so much for your help
just go through the changelog, there are some upgrading hints there
will give it a shot
Haha oh god
update to 0.22.1. there were improvements to error handling. errors may tell you more if you update (but brace yourself, there were some nasty breaking changes)
0.20.1
Yeah
Is CAnzrM2t12LwM8CvTZNehvGoivNmEJ5nNXenKS6CPaU6 what your declare_id! says?
ps. which anchor version are you on?
there was a way, but I never used it 🙂 
and no, it shouldn't give you more logs
Is there anyway to skip the transaction simulation? would that maybe give more indepth logs?
Thanks for the suggestion, will give it a shot 🙂
sorry, that's way too long for me to parse.
what I was doing in cases like this is trying to recreate the problem in a small program (just do anchor init and copy-paste the important bits)
if you manage to do it - great, paste this here.
if you don't - it means that this time you implemented this correctly and you don't even need to ask here 😉 
more than half of the time it was the latter
```
#[derive(Accounts)]
#[instruction(_artist_license_bump: u8, _artist_account_bump: u8, painting_account_bump: u8)]
pub struct ProcessPaintingMint<'info> {
 pub payer: Signer<'info>,
 #[account(seeds=[b"artist_license".as_ref()], bump=_artist_license_bump, has_one=treasury_key, has_one=developer_key, has_one=art_token_program)]
 pub artist_license: Box<Account<'info, ArtistLicense>>,
 pub treasury_key: AccountInfo<'info>,
 pub developer_key: AccountInfo<'info>,
 
 //artist stuff
 #[account(seeds=[b"artist".as_ref(), artist_mint.key().as_ref()], bump=_artist_account_bump)]
 pub artist_account: Box<Account<'info, Artist>>,
 pub artist_mint: Box<Account<'info, Mint>>,
 #[account(
    constraint = artist_ata.owner == payer.key(),
    constraint = artist_ata.mint == artist_mint.key(),
    constraint = artist_ata.amount == 1
 )]
 pub artist_ata: Box<Account<'info, TokenAccount>>,
 pub artist_metadata_account: AccountInfo<'info>,

 //painting stuff
 #[account(init, seeds=[b"painting".as_ref(), painting_mint.key().as_ref()], bump=painting_account_bump, payer=payer)]
 pub painting_account: Box<Account<'info, Painting>>,
 pub painting_mint: Account<'info, Mint>,
 #[account(mut)]
 pub painting_metadata_account: AccountInfo<'info>,
 #[account(
    constraint = painting_ata.owner == payer.key(),
    constraint = painting_ata.mint == painting_mint.key(),
    constraint = painting_ata.amount == 1
 )]
 pub painting_ata: Box<Account<'info, TokenAccount>>,
 #[account(address = mpl_token_metadata::ID)]
 pub token_metadata_program: AccountInfo<'info>,
 //cpi stuff

 pub mint: AccountInfo<'info>,
 pub payer_ata: Box<Account<'info, TokenAccount>>,
 pub destination_authority: Box<Account<'info, TokenAccount>>, 
 pub destination_ata: Box<Account<'info, TokenAccount>>, 
 pub tx_account: AccountInfo<'info>,
 pub art_token_program: Program<'info, ArtToken>,
 pub token_program: Program<'info, Token>,
 pub system_program: Program<'info, System>,

}
```
```
Transaction simulation failed: Error processing Instruction 0: custom program error: 0xbbf 
    Program CAnzrM2t12LwM8CvTZNehvGoivNmEJ5nNXenKS6CPaU6 invoke [1]
    Program log: Instruction: ProcessPaintingMint
    Program log: Custom program error: 0xbbf
    Program CAnzrM2t12LwM8CvTZNehvGoivNmEJ5nNXenKS6CPaU6 consumed 28793 of 200000 compute units
    Program CAnzrM2t12LwM8CvTZNehvGoivNmEJ5nNXenKS6CPaU6 failed: custom program error: 0xbbf
```


3007: The given account is owned by a different program than expected

Anyone know what could be causing this I have been checking these accounts over and over I believe they are all inferred the right ownership ://
PDA idea
am I wrong or would it be a deep change within the solana ecosystem itself, not really related to anchor?
gday. another day another funky error XD
any idea how something like that happened?
```
Program log: panicked at 'range end index 744 out of range for slice of length 712', /home/wooha/.cargo/registry/src/github.com-1ecc6299db9ec823/anchor-lang0.22.1/src/accounts/account_loader.rs:156:35
```
additional info:
- tests with local validator work well
- the problem occurs when calling this on devnet
Actually the biggest advantage of storing the pubkey is being able to go backwards when you have an orphaned account, you can figure out who the owner is. Orphaned in the sense that you use get program accounts or something and want to clear up old accounts or do something to settle them
So I'm wondering if it's even needed to have it take up extra room in the data of the accounts, since we can just verify that the right account is part of the seeds when validating accounts
For many of our PDAs the user or authority pubkey is already part of the PDA seed
What do others think about the idea of getting rid of this field in all accounts and just storing the pubkey as part of the seed in the program account / PDA
So you know how many program accounts have an extra 32 bytes dedicated to storing the account owner / authority's pubkey
TY, just saw this and it was really helpful
Nope, have to pass it in from the client
Hi, I want to get create a pda, and get the account info of that pda, in a transaction is that possible? need the account info to make a CPI
But I got the same error 😦
As a desperate attempt I tried copying generated `ts` file, adding missing types and importing it instead
```
IdlError: Type not found: {"name":"borrowedAmount","type":{"defined":"Decimal"}}
```
But when I try to build it I get an `idl` error here
```
  const program = anchor.workspace.PROG_NAME as Program<PROG_NAME>;
```
I have `math` module inside one contract with user defined types and I want to reuse it in another contracts
I see there is `no-idl` flag, but it seems to be the opposite from what I need
Good day! How can I use defined types from one anchor project in another? Or can I at all?
<@!134416332509675520> do you know how I can do this?
https://discord.com/channels/739225212658122886/890332692145668126/914933346558173184 here is where someone asked
Yeah you should ask in their discord. They had it in FAQ channel but removed it but still think it’s possible. https://discord.gg/D8Vdjs7D
it is possible?
I’ve seen people have this issue in Serum discord, you could go in there and ask. They had a tutorial to do this there but can ask around for it


///////////////////////////////////////////////////////////////////////////////////////////////

I see I see thanks for the knowledge!
Like, you once had 123 bytes allocated, and now you have 1234
No, no schema change I don't think—just adding extra space onto the end
oh wow this sounds amazing but I assume lots of byte shifting here and there if we wanna do it right ? Cuz its literally changing the schema
Eventually you'll be able to dynamically resize accounts though
Yeah, currently you have to just pick a space you're comfortable with
so no matter what the account size is known before runtime anyways
ahhhh ok I see
It doesn't—that's why you need to specify `space =` yourself, manually
but now I think about it, lets say I have an account struct with `String` field and then I use anchor `init` macro, how will the program know exactly how much space to allocate? Cuz the real `String` value is only assigned after I suppose?
yus
when I do preinstruction, does do the instructions wait to finalize before going to the next one? trying to bundle ixs into a tx but I need each one to finalize before going to the next
I'm unable to get placeOrder to work at all; probably just confused what accounts are supposed to be owner and payer
https://github.com/project-serum/serum-ts/tree/master/packages/serum
does anyone know how to use serum javascript sdk?
But I am able to catch connection.onLogs on the validator
Hello, I am trying out `addEventListener` . It works fine on anchor test but does not catch any event on solana-test-validator.
Update: Tried on devnet and same result.
oh nicee gotcha thanks !!
You can test it out by doing `let hmm = String::default()`
Default does that
Does rust process `String` in that manner with `Default` by default? Or its a Borsh behavior?
first 4 bytes for the length
ah right I kept getting confused haha
It would be an empty string (which serializes as [0,0,0,0])
u8 holding a 0 I suppose?
oh but what does Default do to this `String`? isnt it just 1 byte?
Yeah, that's why using Default doesn't make sense generally
For a super long string it would look like `[255, 255, 255, 255, ................................................]`
ah ok this is cool, then it means account whose structs with String fields will be of dynamic length in terms of space allocation
Because 你好 takes six bytes (given that we're using the unicode encoding scheme utf-8)
So e.g. `eprintln!("{:?}", "你好".to_string().try_to_vec());` will look like [6,0,0,0,228, 189, 160, 229, 165, 189]
So you can have a string of length up to 2^32 - 1
Ah, no—I'm saying it uses 4 bytes to encode how many bytes should follow
if I wanna do more than 4 chars I need to prob do [u8; 64] something like that right?
so implicitly cannot go further than 4 chars, otherwise the struct might explode?
4 bytes correct!
Thank you so much sir.
ah ok
but how does it know where that String stop?
It has to use a dynamic number of bytes. Borsh encodes strings as 4 bytes for the length (in bytes) of the string itself, followed by the bytes of the string
Yeah, think individual nft marketplaces just have to code this themselves
Hi Ive got a question about Borsh. E.g. the code here https://github.com/metaplex-foundation/metaplex-program-library/blob/master/token-metadata/program/src/state.rs#L112 the type is `String`. How does Borsh know how many bytes to give this field?
No, can't change the transaction after signing it (that will invalidate any prior signatures)
Pls someone explain this
does the expiration of the recent blockhash provide sufficient protection? i.e. is it computationally effectively impossible to come up with a different valid transaction in the time it takes for the recent blockhash of the original transaction to become invalid?
I've got a transaction signing flow which does an offline-ish transaction (essentially as described here: https://solanacookbook.com/references/offline-transactions.html#sign-transaction) - I imagine it's very difficult to do but I can't find any hard evidence on: changing the contents of a signed transaction such that the signature(s) are still valid?
Okay okay got it will try that 🙂
Yeah. And it's also maybe `global:create_user` (unless you wrote the rust fn as createUser)
Okay thanks ! 🙂
And the `global:` is always there for every program/ix?
But make sure they're actual bytes, not the hex/string version of them
But yeah, if you're actually snagging 8 bytes etc. then yeah, you're good
Mm, maybe/not quite (one byte is 2 hex digits, so that's just 4 bytes there)
Just to be sure 🙂 
I have my sha256("global:createUser") => `8AB1FAFF1A5C1D41CDE21A73391C6E8BC43C5A721D9DAE8D2AC8C70FE85182E2`
It means the start of the anchor Ix is `8AB1FAFF`?
Hey 🙂 
I want to understand  how to read a raw data instruction and know what it does. For example I read a confirmed transaction data but i have no clue how to interpret that : 
```
let parsedTransaction = await anchor.getProvider().connection.getParsedConfirmedTransaction(signature, 'confirmed')

console.log(parsedTransaction.transaction.message.instructions[0].data)
 -> YKmz3pSoZibBKvLS6uX18Nb
```

Any hint ? 🙂
Okay perfect will try that thanks 😄
Then just borsh-serialize the instruction arguments after that
First 8 bytes for an anchor instruction data are the "sighash": sha256("global:<your_ix_name>")[..8] in pseudo-code
Manual work is okay 🙂
I can have those info I guess
The thing I cant understand/catch is for example in my pure rust program I know that data[0] mean I want to interact with my Ix index 0 etc
But in anchor the only thing I can see are : Initialize / CreateAccount / Etc so here I would be tempted to say that [0] is Init and [1] CreateAccount but it doesnt seems so
(It's simple manual work but, yeah, it's manual)
Ah, ok, there isn't currently a way to convert IDL to rust code (can you not depend on the project's source code? otherwise you'd have to do some manual work)
Okay thanks!
And for the data how can it be done onchain?
Because I only know the idl of the Anchor Program how can I format the data to what anchor is waiting? (The instruction I want to call in the program)
Can take a look here (plus surrounding context a bit higher up): https://discord.com/channels/889577356681945098/889702325231427584/953979675221295114
Hey, is there any examples on how to do a CPI from pure rust to an Anchor Program?
can you guys sort it?
use anchor_spl::token::{
  |     ^^^^^^^^^^ use of undeclared crate or module `anchor_spl`
can anyone explain the event equivalent of solidity in solana/anchor and how are the 2 implementations different, for say i want to port a ethereum contract to solana is it possible to use the same logic which uses events or would i have to find a work around
Hey everyone. I am thinking about metaplex NFT royalties. When I send NFT from my wallet to another wallet i am not paying royalty.But when i sell or buy NFT on marketplace I’m paying royalties to creators. Is NFT royalty is just a concept. Are marketplaces implementing a pay royalty logic to their program ?
When you somehow manage to send an unknown instruction to your anchor program (usually happens if you forget to redeploy or something)
<@!134416332509675520> 👆
```
    /// 101 - Fallback functions are not supported
    #[msg("Fallback functions are not supported")]
    InstructionFallbackNotFound,
```
When this custom error is made?
addEventListener
you can close the account via `close = destination_account`
Hey <@134416332509675520> is there a way to close a PDA account after init
Just in case anyone else searches for how to parse the anchor error into a human readable string, this did it for me:

```
const ERROR_DISCRIMINATOR = "Program log: AnchorError";
const ERROR_MESSAGE_DISCRIMINATOR = "Error Message: ";

export const parseAnchorError = (err: any) => {
  const logs = err?.logs || [];

  const errorLog = logs.find((l: string) => l.includes(ERROR_DISCRIMINATOR));

  if (!errorLog) {
    return null;
  }

  const message = errorLog.split(ERROR_MESSAGE_DISCRIMINATOR)[1];

  return {
    message,
    log: errorLog,
  };
};
```
sweet I'll do that. thanks <@!347689664855015424> , for both that answer and all your awesome online guides 🙂
you can do what the ts client will eventually do. Read the returned logs yourself
gotcha. is there a hacky way I could parse this to get a more readable message?
thats not implemented yet
How do you parse and get the message of an anchor error. I am trying to get the message here which is "DepositVaultMaxError. Error Number: 6033. Error Message: Can't deposit that much. Exceeded vault maximum.", but I am just getting "Custom program error" without an specific info when I read `err.message`
does anyone know if its possible to make the declare_id!(address) use a variable for the address, thats passed in as an env variable?
mango-v3
you can look at the mango code
Could someone point me to an anchor program that does a CPI into Serum? Any examples to look to?
Just wanted to say thanks so much for this tip, has made debbuging so much easier! tells me which account is causing the issue most of the time 🙂
React.js or react.tsx which is better for anchor?
What is the best way for logging/debugging transactions I test?
Getting a `Some(ProgramAccountNotFound)` not found error but the program I'm sending it to definitely has some executable data on it
Hi guys! Someone would know the complete logic, doc or even tutorial allowing :

Create a NFT staking site, allowing to generate $COIN (which are spl-token ?) linked to a liquidity pool. If two types (generation) of NFT are staked from the same wallet, in this case, the reward of $COIN is multiplied (Generation 2, allows to multiply the rewards of staking of generation 1)
https://book.anchor-lang.com/chapter_3/CPIs.html#reloading-an-account
Good day! How can I refresh an account after CPI?
hey everyone, I'm running some rust tests on an anchor program using `solana_program_test`, passing in `entry` attribute of the program to ``add_program`. However, I'm also overriding entry() function to support middleware for serum permissioned markets, I think this is changing expected behavior of `entry`, causing the instruction to fail. Anyone able to offer advice on this? thnx 🙂
Tysm!
I have a question for the experts. I have a escrow program. This program exchanges tokens and SOL. How will royalty be paid if I trade NFT and SOL with this program? <@!134416332509675520>
I've seen an example of puppet/master in Anchor do I just need to create my puppet (in Anchor) inside my pure Rust code and use it to generate the Ix?
I mean I know the args but for a CPI to a pure rust I would just do `let mut data = vec![IX_INDEX];` + after the data I dont know what the Anchor made program is waiting for IX_INDEX
Yeah right now Im on a project in classic rust
And we would like to do a CPI to a program's intruction I know the IDL of this program but I dont know what data I need to pass in the instruction creation to do the invoke/invoke_signed
Can you say more? But yeah, it's possible
Hey guys, I'm new here!
I'd like to know if its possible to do a CPI from a pure rust program to a Anchor Program
Because in pure Rust we mostly have index going from 0 to X to know which instruction is focused but doesnt seems the case with the program made with anchor 🙂
The syntax is like this (might have to search discord for examples): https://discord.com/channels/889577356681945098/889577399308656662/950454811365617705
You'll probably just want to use the solana `clone` feature, since, yeah, it wouldn't be possible to deploy them to the right addresses otherwise
Hi everyone! Looking for some advice on how to test programs that depend on other programs (metaplex programs for example) on localnet? Do I need to deploy all dependency programs on my localnet? If so, is it possible to deploy them with the same program id that they have on devnet/mainnet? Thanks in advance 🙂
Good day! How can I use different keypair for deploying instead of the one in `target/deploy`?
And can I make Anchor use another one automatically
in https://github.com/project-serum/anchor/pull/1259/files was `coder.instruction.decode` removed?  previously i was able to decode instructions like this

```ts
instructionData = anchor.utils.bytes.hex.decode("39eabc535ce92cc7ec9ea51d00000000");
program = new anchor.Program(idl, programId);
decoded = program.coder.instruction.decode(instructionData);
```

however this no longer works, meanwhile the other coders `state`, `events`, and `accounts` kept their `decode` functions
Hello!
I want to allow program upgrade using 'multi-sig' approach. Like, for example, we can upgrade program only if we have 3 of 5 signatures.
Is it possible on solana?
Thanks


///////////////////////////////////////////////////////////////////////////////////////////////

Ah, ok, that makes sense. Thanx again!
But if anchor doesn't know the seeds for an address there's no way to automagically figure out the bump (it's impossible)
Like with `#[account(seeds = [the, seeds], bump)]` over that `staker` account (I think, actually not 100% sure that works) [edit: think it should work]
Is there already a sample program in the repo that can do airdrops? 
User Clicks button => Receives a token
I want to add this to my app so users can get fake USDC on Devnet
How are you telling anchor about that bump? (Anchor can't guess the bumps, you have to tell it how to find them)
Hi! I'm trying to get the bump out an account I'm passing in a context like this: 
` pub fn unstake(ctx: Context<Unstake>,
        amount: u64
    ) -> ProgramResult {
        let staker_bump = *ctx.bumps.get("staker").unwrap();
        ctx.accounts.unstake(staker_bump,amount)
    } `
This is the ctx:
`#[derive(Accounts)]
pub struct Unstake<'info>{
    #[account(mut)]
    pub user:  Signer<'info>,

    #[account(mut)]
    pub stake_master: Box<Account<'info,StakeMaster>>,

    #[account(mut)]
    pub staking_pool: Account<'info, StakingPool>,

    #[account(mut)]
    pub staker: Account<'info,Staker>,

    #[account(
        mut,
        constraint = ata_stake_funds.owner == user.key(),
        constraint = ata_stake_funds.mint == staking_pool.pool_token,
    )]
    pub ata_stake_funds: Box<Account<'info,TokenAccount>>,

    #[account(
        mut,
        constraint = ata_user_stake.owner == user.key(),
        constraint = ata_user_stake.mint == staking_pool.pool_token,
    )]
    pub ata_user_stake: Box<Account<'info,TokenAccount>>,

    #[account(mut,signer)]
    pub user_deposit: Account<'info,Deposit>,

    /// Token program.
    pub token_program: Program<'info, Token>,
}`

But I'm having this error:
` Transaction simulation failed: Error processing Instruction 0: Program failed to complete 
    Program 2y7MviVmnCudJJpxB3P1ZnB2Hh1ykrgXvgp9aoLzJVqi invoke [1]
    Program log: Instruction: Unstake
    Program log: panicked at 'called `Option::unwrap()` on a `None` value', programs/staking_mock/src/lib.rs:83:58
    Program 2y7MviVmnCudJJpxB3P1ZnB2Hh1ykrgXvgp9aoLzJVqi consumed 20679 of 200000 compute units
    Program failed to complete: BPF program panicked
    Program 2y7MviVmnCudJJpxB3P1ZnB2Hh1ykrgXvgp9aoLzJVqi failed: Program failed to complete `

What I'm missing here?
it's probably on someone's todo list in a github issue somewhere
i was also just sanity checking that it hadn't already been removed and somehow i was using an outofdate version
yep
Mm, yeah, I guess anchor could default to using the newer spl instructions? E.g. https://github.com/solana-labs/solana-program-library/blob/master/token/program/src/instruction.rs#L382 (the old ones require an explicit rent account)
surely this requirement has been removed by now?
V22.1 is still telling me that i need to add rent as a sysvar if initing a token account
Thank you Alan !
I was scared about some security issu 😄
Ok perfect ! This is exactly what i'm doing x)
You have to be kind of careful though, if you want to persist any changes you'll have to manually run its exit handler, `hmm.exit(ctx.program_id)?;`
```.rs
let hmm: Account<Thing> =
         Account::try_from(&ctx.accounts.thing_account_info)?;
```
Hey 🙂 
Do we know what is the safest way to deserialize an accountInfo to an Account<'info, SOME_TYPE> from within a program ? 🙂
so we can see the local tx be it via testing or not on the explorer ? that is cool, so something similar to what tenderly offers on ethereum but is quite limited and requires more setup.
If you do that, you need to `anchor test --skip-local-validator` or similar
Glad it helped! `--detach` is invaluable. If yo'ure ever testing outside of anchor, you can run `solana-test-validator` to spin it up and then run your tests in another shell
Yeahhhhhhhhh I had to rewrite some of the backend stuff I was using
Had the same issue. It looks like .toBuffer is only available in NodeJs.
Thanks for this, didnt know about `--detach`, improves debugging :).  Ignore my previous query. My test was set up incorrectly.
Let me try that.
`http://localhost:8899`, I believe
go to explorer.solana.com (or your preferred explorer), at the top right click `mainnet-beta` and it opens a menu, click `custom RPC` and put in the IP address + port that you're given when you run `solana config get`
yep! So without seeing what your ts file looks like, when you're calling the `send()` functoin, it returns a tx id, you can log that or whatever your preferred way of retrieving the id is. Then, if you run `anchor test --detach` it will keep the local validator spinning after the tests complete
Wasnt aware that you can view anchor test related tx via the explorer.
Are you looking at the transaction logs in the explorer?
Will dig a bit more and report back, just wanted to see if anyone else has experienced this.
Yeah not sure, havent gotten that far. I am running this locally, and finding this to be the case when running tests.
Solana won't let you destroy lamports, so it needs to be going somewhere
Where is the rent balance going to?
Ive asked this before but wondering if others facing same issue:

1. Using the  `close` attribute with a `Box<Account<'info, MyAccount>>` with destination set to an `UncheckedAccount`
2. The account is closed but I am finding that the rent balance is not returned to the specified destination.

If no one else has experienced this, I will create a reproducible example and share.
And it happens to start at 1 for whatever reason: https://github.com/solana-labs/solana/blob/master/sdk/program/src/instruction.rs#L735
So the [1] part is the current invocation depth
That happens here: https://github.com/solana-labs/solana/blob/master/program-runtime/src/stable_log.rs#L19
https://discord.com/channels/889577356681945098/889702325231427584/954012922407956500
also what does invoke [1] and invoke [2]  mean?
I gonna to build spl token mint contract.
And in other contract I want to call mint function. so, many contract can use same spl token. 
how to call function of other contract from my contract? Is it possible?
another error..
Transaction simulation failed: Error processing Instruction 0: invalid program argument 
    Program 8BQunCRwyBZ3EaPP4bmCraTWhVvazrajNR3CtTM7P5rT invoke [1]
    Program log: Instruction: Exchange
    Program 11111111111111111111111111111111 invoke [2]
    Transfer: `from` must not carry data
    Program 11111111111111111111111111111111 failed: invalid program argument
    Program 8BQunCRwyBZ3EaPP4bmCraTWhVvazrajNR3CtTM7P5rT consumed 11718 of 1400000 compute units
    Program 8BQunCRwyBZ3EaPP4bmCraTWhVvazrajNR3CtTM7P5rT failed: invalid program argument

does this mean my escrow can't contain data?
Woah! thanks man!!
So note that the original error message, `Cross-program invocation with unauthorized signer or writable account`, has an annoying "or" in it
`9WxZjnCADFatkzeRYdppd2B2uyDkDgVZww9JtA3s7fwH's writable privilege escalated` means that you forgot to mark the destination account as mutable/writable
9WxZjnCADFatkzeRYdppd2B2uyDkDgVZww9JtA3s7fwH seems to the issue. But i don't get it. We are transferring from vault to 9Wx address. Why do we need it to be the signer?
See the issue?
Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account 
    Program 8BQunCRwyBZ3EaPP4bmCraTWhVvazrajNR3CtTM7P5rT invoke [1]
    Program log: Instruction: Exchange
    9WxZjnCADFatkzeRYdppd2B2uyDkDgVZww9JtA3s7fwH's writable privilege escalated
    Program 8BQunCRwyBZ3EaPP4bmCraTWhVvazrajNR3CtTM7P5rT consumed 11403 of 1400000 compute units
    Program 8BQunCRwyBZ3EaPP4bmCraTWhVvazrajNR3CtTM7P5rT failed: Cross-program invocation with unauthorized signer or writable account
Try posting the full program log (lol 😛) and you'll see another line giving you more info
Yea. seems to work. But giving another issue now. I'll go figure out 😄 thanks!

 Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account
Do you have a `pub system_program:: Program<'info, System>` in your derive(Accounts)?
yes. use anchor_lang::solana_program::system_instruction::transfer;
yes. when i comment this chunk out, the error go away
And is that `transfer` the regular `system_instruction::transfer`?
Are you sure that's where the error is coming from? Like, if you comment out that whole chunk does the error go away?
Hi. I'm getting this error when I run this.
```Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: An account required by the instruction is missing```

           ```for i in winning_accounts {
                let ix = transfer(&ctx.accounts.vault.key(),&i.key, share);
                invoke_signed(
                &ix,
                    &[
                        ctx.accounts.vault.to_account_info().clone(),
                        i.clone(),
                    ],&[&[b"pubkey", &[ctx.accounts.vault.bump]]]
                )?;
            };```

Anyone know what's going on?
I think that works, yeah
Suppose my program A has an instruction `#[derive(Accounts)] pub struct InstructionA {}`, I want to CPI this instruction from `InstructionB` of program B. Currently I redeclared all accounts of `InstructionA` inside `InstructionB`. Can I use the entire `InstructionA`  struct as a field inside `InstructionB`? For an example: 
```
#[derive(Accounts)]
pub struct InstructionB<'info> {
    pub ix_a: InstructionA<'info>,
    pub another_account: AccountInfo<'info>,
}
```
Is there a way to make anchor process IDL primitives like errors coming from an external library?   Most of our application logic is in a library and so far I can not find a way to expose ErrorCode enum  (I.e. have anchor include error enum in the IDL)... Other than manually copying the error.rs file from the library  into the program...
nvm
was able to figure out the above
running into a `WalletSignTransactionError` and not sure what it could be
has anyone seen `y.pubkey is undefined` when trying to sign a message with an anchor wallet?
Not sure if Armani or Paul have plans to or not. I'll hopefully have an actual apartment again at some point though lol and can start doing more streams too
Btw any plans to re record the anchor deep dive which got deleted  in the near future ?
Will have to try that one out
Mm, good question, not sure—maybe
Since it calculates this bump will it be available via ctx.bump even if there is no init, since It calculated the canonical bump?
To double check you aren't being a goof and using non-canonical bumps
It recalculates the (canonical! 😛) bump using find_program_address
Care to explain what this does , so instead of doing seeds=[], bump = from instruction just writing bump what does it do ?
If am not wrong big improvements were made on the js side
Rust syntax is just `bump,` instead of `bump =` 🙂
Actually both
You mean rust syntax or js syntax?
Also haven't caught up to the syntax and recent changes in a chor versions, any repo out there which uses the latest version and shows what changed ?
With a canonical bump approach u just need to always call find program address off chain. To get the correct pda address
Yeah
Yeah, or have some implicit agreement to use the second available bump rather than the first, etc.
It requires to store it somewhere
Yeah, the client would need to know "this program is weird, gotta use a non-canonical bump for some weird reason"
If u call find program address it's gonna give u the address with canonical bump but if u had used a non canonical bump
But on the client side
That isn't really very different from storing the canonical bump though
Is this a acceptable explanation ?
For instance if you decide to use non-canonical bumps let say for the same seeds u generated u know the canonical bump is taken so you manually create one with a non-canonical bump but then you need to store this somewhere to use it later on
In my mind , the reason canonical bump is important to use is because then you don't need to store full pubkeys of pdas onchain or off chain, on the client side using a base seed + combination of let say wallet addresses u call find program address and it gives u the pda address to pass for let say Alice to the escrow program, and by going one step more and storing bump in the account struct u can seamlessly sign for it
This is why you can't use the same seeds for two separate accounts (assuming you're using findProgramAddress—if you really want to be weird and use non-canonical bumps then go for it lol)
There's no checking whatsoever about whether the address is already in use etc.
Here's the important part: https://github.com/solana-labs/solana/blob/master/sdk/program/src/pubkey.rs#L439
On it chief.
I think you should really go read the implementation of `findProgramAddress/find_program_address`
No, I think this where you're confused: given a single choice of seed, there's *only one* canonical bump
And then gives the second escrow pda a bump of 254 etc
<@134416332509675520>  one last question, let say I use the same base seed "escrow" the. For multiple accounts the differentiator will be the canonical bump, so everytime I call find program address does it check if the off the curve address it found for say bump of 255 already exists and is taken by someone or not 
?
https://github.com/project-serum/anchor/blob/v0.18.2/ts/src/error.ts#L87
`custom program error: 0xa7`
<@!134416332509675520> , could you let me know this error detail?
Sad the deep dive Armani and paulx did on twitch got deleted I missed out on real gold 😭😭😭
So if you wanted to store it you needed to do it in the init instruction
Yeah
Ctx.bumps should be empty
Yep, that's right
But when u call that account in a non init state
Also could you explain the ctx.bumps recently added to anchor I assume it only stores bumps of all the init accounts, in that call ?
I think eventually anchor itself might just store it for you, automagically, but that doesn't happen yet
Doesn't really matter how you do it, you can stick it wherever you want 😛
The recommended way of handling this case.
That was my original question sorry if I phrased it wrong what is the design pattern arnd it
Yeah, exactly
Storing the bump is purely about doing less computation
But that is compute heavy
Mm, if you use the canonical bump (aka if you use findProgramAddress), you don't strictly speaking *need* to store the bump anywhere (because you an always just re-calculate it using `find_program_address` inside your program
Which I believe u get when u do init, so that is when you also store the bump in a account field for future use cases  I imagine ?
If I ever wanted to use it to sign for the pda
Do I not have to store it somewhere
Let say find program returns 255 as canonical bump
Canonical bump == use findProgramAddress
You should just always always use `findProgramAddress`
No, it should *always* use the canonical bump
But to start off a good pda design should never have a canonical bump, and entirely rely on unique seeds no ?
But it's very unexpected/weird
And it would work fine
Just to be annoying/sneaky
You could write your own function, `findSneakyProgramAddress`, that instead of taking the first bump that works instead takes the *second* bump that works
But that's not the only bump that could produce an off-curve address, an address eligible to act as a PDA
Ok, the canonical bump is the one returned by `findProgramAddress`
Yes
That might involve the user's key, sure
Mm, I would think of it more generally as "pda seeds should be unique, so figure out a way to make them unique"
So essentially a good design will always have pdas that take on the property of the user
Are you comfy with this material? https://discord.com/channels/889577356681945098/889702325231427584/939324164890845265
Ok could you clear the canonical,non-canonical term pls
The basic point of seeds is to have unique seeds per account
The only way to use the same seeds for multiple addresses is, yeah, to use non-canonical bumps, which is super unexpected
Paulx
Which one?
The escrow example
What example are you looking at to get that idea?
Mm, you essentially never have multiple accounts use the same seeds
Also,  what is the design pattern o. Where to store the bump for the pda accounts, for example the seed escrow is stored inside the program state but multiple escrow will have the same seed but different bumps, so where are these bumps stored.
Not sure if there's actually any attack per-se about using non-canonical bumps, they're just a super unexpected thing to do
Was looking at Armani thread on footguns attacks and was confused about the importance of using a canonical bump instead of a user passed bump which might not be canonical
Mm, good question 🤔
Looking at the difference between `transfer` and `transfer_checked`, it looks like after calling `transfer` and then searching the token's mint address on the explorer, the mint transfer history doesn't include that transaction. `transfer_checked` takes the mint as a parameter and after calling it and querying the mint address, you can see the transaction on the mint's history.

Is there a reason that `transfer_checked` is not the default in Anchor?
Any actual account type (not a pubkey, at least currently)
ty! It worked
Omg its worked. You are perfect sir. taker type is `Signer<'info>` . Which type `associated_token::authority` must be ?
Just do `associated_token::authority = taker` maybe?
`181 | #[derive(Accounts)]
    |          ^^^^^^^^ method cannot be called on `&anchor_lang::prelude::Pubkey` due to unsatisfied trait bounds
    |
   ::: /Users/hbb/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-program-1.10.0/src/pubkey.rs:71:1
    |
71  | pub struct Pubkey(pub(crate) [u8; 32]);
    | ---------------------------------------
    | |
    | doesn't satisfy `_: AsRef<anchor_lang::prelude::AccountInfo<'_>>`
    | doesn't satisfy `anchor_lang::prelude::Pubkey: anchor_lang::Key`
    |
    = note: the following trait bounds were not satisfied:
            `anchor_lang::prelude::Pubkey: AsRef<anchor_lang::prelude::AccountInfo<'_>>`
            which is required by `anchor_lang::prelude::Pubkey: anchor_lang::Key`
            `&anchor_lang::prelude::Pubkey: AsRef<anchor_lang::prelude::AccountInfo<'_>>`
            which is required by `&anchor_lang::prelude::Pubkey: anchor_lang::Key`
    = note: this error originates in the derive macro `Accounts` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0599`.``
Why i am giving error in this line ?
`#[account(associated_token::mint = taker_receive_token_account, associated_token::authority = taker.to_account_info().key )]
    pub taker_receive_account: Account<'info, TokenAccount>,`
https://github.com/project-serum/anchor/blob/master/lang/syn/src/codegen/program/common.rs#L17
Do you have any example of the right way? I'm really confused about Anchor sighash 😅
That's unlikely to be the right way to calculate that sighash
Good afternoon. I'm having some issues to call a Anchor program using pure Rust
```rust
/*
"Program 2UTpyWLPHXHJEbtrVKYBCxV4uSVYPLL31n2B7Yiqj2sK invoke [1]",
"Program log: Custom program error: 0x65",
"Program 2UTpyWLPHXHJEbtrVKYBCxV4uSVYPLL31n2B7Yiqj2sK consumed 1307 of 200000 compute units",
"Program 2UTpyWLPHXHJEbtrVKYBCxV4uSVYPLL31n2B7Yiqj2sK failed: custom program error: 0x65"
*/
let hello_ix = Instruction::new_with_bytes(program_id, "95763bdcc47fa1b3".as_bytes(), vec![]);
```
Solana program:
```rust
    pub fn hello(ctx: Context<Hello>) -> ProgramResult {
        msg!("Hello, world");
        Ok(())
    }
```


///////////////////////////////////////////////////////////////////////////////////////////////

so something i havent been able to figure out with the solana programming model is how do you setup admin accounts so only they can call admin only instructions in your program, safely, cant quite get the mental model on it.
Ahh ok, so if I use `token::` variant I am free to use any address for the new token account I am creating, but if I use `associated_token::` then I must use the proper associated token-derived address for the new account
Whereas token:: means you have to specify the address you want to use yourself (either a keypair address of the client's choosing or a PDA derived from your own program)
Yep, associated_token:: says you specifically want it to be an associated token account (a token account that lives at a special associated token program-derived address)
Is there a difference between using `associated_token::mint / associated_token::authority` or `token::mint / token::authority` when having my anchor program init a new TokenAccount?
Thanks for the info!
Hey <@!347689664855015424>. I saw your secure transfer repo couple days ago. Now i cant find. I think you deleted/hide that repo. Can you add that secure transfer example to the anchor/tests ? Or can you share sir. I need that example for my project.
If anchor has an IDL thing for tracking seeds does this also mean there's a new macro for more easily signing transactions with seeds inside a program?
I think Executing BPF instructions
 refer to the op codes of the bpf instruction set add, dst, sub etc i guess i should ask in the solana discord if the solana version has exact info on the number of computation units consumed for each of these opcodes.
But it's not unique to solana (e.g. the linux kernel uses it too)
So, practically speaking, it's playing the same role as EVM bytecode
It's an odd name, but it's a form of "bytecode" that is used in a bunch of places (e.g. you can use it to run stuff inside the linux kernel), and solana piggybacks on a slightly-modified version of it: https://docs.solana.com/developing/on-chain-programs/overview
mb i wanted to ask what is bpf referring to exactly, like what is bpf
Ah, I'm not sure how individual bpf things are metered, good question—haven't dug into that yet
was looking at the doc, which instructions come under bpf instructions ?
Yep, at least somewhat: https://github.com/solana-labs/solana/blob/master/program-runtime/src/compute_budget.rs#L77
Is there any resource which has a list of compute instruction cost for different operations in a instructions like in evm every op code has a gas cost.
You're running out of stack space (can try searching the discord, comes up a lot)
I think this gives the Size of the Account
```Transaction simulation failed: Error processing Instruction 1: Program failed to complete
    Program 11111111111111111111111111111111 invoke [1]
    Program 11111111111111111111111111111111 success
    Program 6bmKfxkaEiySeRzrSpmrNRWMR7F8MT1S77963k6fcyDs invoke [1]
    Program 6bmKfxkaEiySeRzrSpmrNRWMR7F8MT1S77963k6fcyDs consumed 2605 of 200000 compute units
    Program failed to complete: Access violation in stack frame 3 at address 0x200003b90 of size 8 by instruction #12521
    Program 6bmKfxkaEiySeRzrSpmrNRWMR7F8MT1S77963k6fcyDs failed: Program failed to complete
Translating error Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 1: Program failed to complete
```

Anyone familiar with this error?
What does this mean, is it returning the account size?
```program.account.[accountName].size```
Basically I'm looking for the possibility of staking several NFT, each one allows to unlock a quantity of token and this quantity can vary according to which NFT is staked or its attributes
Hello! 

Do you know what documentation I could use to build a staking system of NFT and spl-token? Is there any existing code (other than gem farm)?
Thanks heaps 🙂
https://discord.com/channels/889577356681945098/889577399308656662/954423436296454164
Yeah, can definitely do that
could I just pass it in as accountInfo and then run my own verification logic as to whether it is initialized and then conditionally pay out the royalties?
Oh I see, thank you!
I would like it to just skip paying out that royalty if the token account isn't initialized
Could the receiver of the royalties just constantly close the token account claiming the sol to rent exempt it, leaving whoever pays for the escrow transaction to re-pay the SOL to initialize it again.  If the royalty party were malicious they could repeat this over and over. It would only be trace amounts but not ideal...
What do you want the program to do if the token account doesn't exist?
Abused how?
I guess I could use init_if_needed but that could be abused a little :/
is there anyway I can prevent a program from panicking if a token account isn't initialized that should be? Trying to set up a royalty system with tokens, but I realize that if the address the royalty is directed to closes their token account it prevents the token that they are tied to from being able to be traded as the escrow contract expects the royalty token account to be intialized...
Thanks. I found it.
You just don't need it—those accounts that you pass to `invoke` correspond to the AccountMetas specified inside the `create_account` instruction builder, and there just isn't an AccountMeta for the system program
No, that up there is raw solana
May I know why, it is an anchor stuff or a solana feature?
Yeah, it's not actually necessary there (you do however need to pass the system_program in as an account in your derive(Accounts) struct)
Hello guys, just curious, why we need to pass the  system_program when we call the system instruction with invoke, it seems it is not necessary during the instruction creation, for example, create_account only need `from` account and `to` account
, but it will be failed if I not pass the system_program.
```        
let ix = anchor_lang::solana_program::system_instruction::create_account(
            payer.key,
            new_account.key,
            10000000000,
            100,
            &ID
        );

        invoke(
            &ix,
            &[
                ctx.accounts.payer.clone(),
                ctx.accounts.candidate.clone(),
                ctx.accounts.system_program.clone(), <- this line can be ignored
            ],
        )?;
```
is the compute budget increase feature for solana released on mainnet now?
gotcha gotcha. all good I was already building the txn and submitting it to network with solana/web3 so not actually inconvenient for me 😄
Ah, just meant that it's a little inconvenient/no wrapper yet
thanks tho that looks right gonna give it a try
that looks right?
wait why only sort of 😄
Sort of: https://discord.com/channels/889577356681945098/889577399308656662/950810145959587930
does anyone have an example of how to add a compute budget instruction to a txn in typescript land? https://docs.solana.com/developing/programming-model/runtime#compute-budget
Rust strings use utf-8, so ascii characters take up 1 byte, but more "complicated" characters take up more, e.g. 你好 takes 6 bytes.
There's no real design pattern, you just have to decide how much space you're willing to pay for (more space = more space, but it's more expensive)
How is space calculation done for accounts with dynamic types like strange I understand 8 for discriminator +4 (borsh)+ the dynamic amount, how to estimate this dynamic amount, what is the design pattern around dynamic strings ?
That’s fine. It’s supports that. They can Unstake whenever they like and they will still get their rewards
Ya I guess a few things need to be changed, let say users would have to stake for a period of time, and cannot unstake during that duration let say 30 days.
Where I stake get a token representing staking position which I stake else where,
Aha u mean LP tokens type
it does what standard farms do.  when you stake you see your token is staked but you dont have a SPL token representing your stake that you can trade or something.  That's all
A bit confused what u meant by this
it does _not_ give you a token representing your position. wrapping the one program with the other one could imagine such a thing composed tho
yeah, standard farm style.  claim whenever, get a proportion of vault based on amount and time.
I think the latter is what I was looking for , a staking system that rewards you on the basis of how long u hold.
Chainlink was napping; lost first mover.
Pyth (pyth.network) and Switchboard (switchboard.xyz)
What oracles are generally used In the Solana defi space, I think chainlink recently launched.
I've written 2 types - both open source.  One for a yield bearing token with underlying vault (xSUSHI model): https://github.com/step-finance/step-staking, and another for dual rewards over a fixed amount/time aka standard farming: https://github.com/step-finance/reward-pool

Both on mainnet as part of core Step protocols (xSTEP and Step Farms)
Obv the architecture would be very different on solana
Any open source staking protocols on anchor ? The goal is to port a staking system made on Ethereum to solana
Oh that is much more cleaner...
https://discord.com/channels/889577356681945098/889577399308656662/954423436296454164
U mean manually get the data array and call anchordeserialize on it ?
Ah, you can still use all the anchor goodies, you just have to use them yourself
Ooh alright , kinda enjoyed the serialization stuff and deserialization stuff using array ref, fun for learning, but would much rather let borsh handle it  xD
But it's a bit low-level/tricky to use since the remaining_accounts are all just `AccountInfo`s, so you have to handle serialization/deserialization etc. yourself.
This is handy if you need to pass in a variable number of accounts (the derive(Accounts) part doesn't support this yet)
Bunch of examples if you search the anchor repo. Basic idea is that it gives you access to any other accounts that were passed into your instruction (the client can pass as many as it wants, above and beyond the ones you specify in the derive(Accounts) block)
The context has remaining accounts field what is this used for ? Any examples ?
Probably easiest to stick them at the top of the file:
```.rs
static MY_PUBKEY: Pubkey = pubkey!("asdfadsfadsf");
```
will this work ?
if i store static pubkeys in my anchor program do i store it outside the functions and then use it there or do i need to have it in each of the functions, for example 
```static pubkey = pubkey!("test1421515151") 
pub fn(ctx:context<afaf> {
if(x.key=pubkey)
}```
dont crosspost pls
Hey! I'm facing an IDL issue while running anchor tests -
Search the actual repo itself (bunch of examples)
I didnt find sir. I am looking for this for hours.
Try searching the anchor repo for examples
How can i pass `remaining_accounts` in client side. Can you show me little example sir ?
Can't do it that way in solana, will have to use `remaining_accounts` (you have to pass in every single account you want to use, no dynamic lookups allowed)
Hey everyone. I am passing `Vec<Pubkey>` arg to my program endpoint. I want to send sol to this accounts. When i try to use these accounts program gives me error because `system_instruction::transfer` wants a AccountInfo type. How can i solve this problem ?


///////////////////////////////////////////////////////////////////////////////////////////////

Hi all, I am trying to transfer SOL from a player wallet to a vault account (owned by my program). I am using a system_instruction::transfer to do that in the lib.rs file. This is my test case:
 await program.rpc.createCheck(new anchor.BN(100), "Hello world", 
{ accounts: { 
escrowCheck: anchor.web3.Keypair.generate().publicKey, 
vault: vault, 
from: from.publicKey, 
systemProgram: anchor.web3.SystemProgram.programId, 
rent: anchor.web3.SYSVAR_RENT_PUBKEY, }, 
instructions: [ await program.account.check.createInstruction(check_escrow, 300), ], 
signers: [check_escrow, from], }); 
I keep running into the error: "Invalid arguments: escrowCheck not provided". I am generating a random wallet for escrowCheck, but not sure what I am missing here? I verified the names from the target/types folder too. Pls help!
sup y'all, im trying to see if i can hack metaplex a bit so i can set multiple tokens as whitelist tokens (use nft collection as whitelist tokens, all with unique mint addresses) does anyone have any tips on where to look/what to potentially change?
current set up only allows for fungible tokens as whitelist tokens
You would need to use the system_program's `transfer` instruction
I want to take a sol deposit from the user and forward it within the function to another wallet (treasury address), how can I do that? is there some code samples I can check out?
But basically you can/need to list out arguments from the instruction function left-to-right up to whatever one you care about (so, you can't change the order of the arguments)
Yep https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html#instruction-attribute
is there any documentation on the instruction macro? Can't seem to find anything in https://book.anchor-lang.com/
yess
umm can you clarify what change you made to get it running?
also building on lending protocols?
needed to use solana's library not a fork of it
hey i'm facing the same issue, were you able to resolve this?
if you use `anchor init --javascript` it will use a plain JS project template instead of typescript
i want to write my Test Scripts in JS but anchor by-default allows for TypeScript, where and how i have to change configuration file?
but it seemingly worked before! I was using cargo features to not actually try to do any CPI calls to the token metadata program when testing locally - I guess now's a good time to try out the program cloning thing...
Ok, that sounds more plausible
yep I reverted to the last known good state and I still have the issue 🥲 my instinct is that I'm getting the error because I'm not loading in the mpl token metadata program on my local test validator
That's definitely an unexpected error to get just from adding new instruction arguments 🤔
is there a maximum number of instruction arguments? running into unexpected 'Program account is not executable' after adding a few arguments to an instruction
Yeah I raise this same issue in solana discord and I tag the contributor on it.
If u can comment it on that github issue, that will bring more eyes to it sooner.
Go here and bump it, I researched the issue a bit and reported it. https://github.com/solana-labs/solana/issues/23376 the regression has been introduced in 1.9.6.

<@!418458476348571649> <@!743130416801775687> comment or something
Ya i have tried that it still works slow or maybe that is the speed
try `solana-test-validator --reset` let me if this works for you.
Facing the Same problem
anchor deploy takes ages to deploy on solana-test-validator? solana version 1.9.9
what is Client.js in Anchor?
Hi, I'm having the same problem as <@!410212730641973258>  did.. 
I haven't seen any answers:
```js
const getGifList = async() => {
    try {
      const provider = getProvider();
      const program = new Program(idl, programID, provider);
      const account = await program.account.baseAccount.fetch(baseAccount.publicKey);
      
      console.log("Got the account", account)
      setGifList(account.gifList)
  
    } catch (error) {
      console.log("Error in getGifList: ", error)
      setGifList(null);
    }
  }
```

I've also changed the BaseAccount struct...
i've got some TS code that airdrops myself some sol, works fine on localnet but not on devnet, is that expected?
Thanks a lot for the resources, Ill look into them
Might be tricky to read, but you can also look at how anchor's all() function works: https://github.com/project-serum/anchor/blob/master/ts/src/program/namespace/account.ts#L210
https://solanacookbook.com/guides/get-program-accounts.html#filters
Do u know of an example of using the filter arg?
Not in a program, in a client. Thanks for this.
oh in a program, sorry
https://docs.solana.com/developing/clients/jsonrpc-api#getprogramaccounts
i.e. get all the accounts of a specific type belonging to a program?
Does anyone know how I could simulate a `program.account.<account-type>.all` call in a non-anchor Solana program?
We should just forget 1.9.x ever existed lol.
I guess edge channel.
If that version solves things from 1.8.x and 1.9.x I will have to try this out.
1.10.0 is beta or edge channel?
Oh, interesting
solana-cli 1.10.0 (src:devbuild; feat:3194406647)
🦸‍♀️
What version of solana are you using now?
🦸‍♂️
Lol, would love to know what actually fixed it
you both are super heroes
thank you <@!326107472098099201> <@!134416332509675520> ❤️
Lol, cool!
alright i don't know what exactly did it, but between the anchor version, and the solana version it looks like anchor test can run on its own now and pass
let me check real quick
think i get the same problem on 0.22.0
So use [[test.clone]]
The key changed from [[test.clone]] to [[test.validator.clone]] somewhere around 0.21.0
anchor-cli 0.19.0
Anchor version?
[features]
seeds = false
[programs.localnet]
splendor = "xmtn2vByiRMraod2aVHYXB9mxRJQ3Z3Y7SnvSdAy8qn"

[registry]
url = "https://anchor.projectserum.com"

[[test.validator.clone]]
address = "4bcFeLv4nydFrsZqV5CgwCVrPhkQKsXtzfy2KyMz7ozM"
[[test.validator.clone]]
address = "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"
[[test.validator.clone]]
address = "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB"
[[test.validator.clone]]
address = "Amig8TisuLpzun8XyGfC5HJHHGUQEscjLgoTWsCCKihg"
[[test.validator.clone]]
address = "gLhY2arqFpmVGkpbBbTi3TeWbsWevA8dqrwbKacK3vJ"
[[test.validator.clone]]
address = "8ojYYusVjAKTB7tHjKb9oCBubhhU4vHQDNCcUAdg2ikb"
[[test.validator.clone]]
address = "DpxS9YTv7e7MD9USgniaG4G5n4gVGAk8HJ6p7AXDXcxq"
[[test.validator.clone]]
address = "5KuYEobaCTkQntwdHBZZJpo8HLAb3ruvcWKC1z5RHGJk"    
[test.validator]
url = "m"

[provider]
cluster = "localnet"
wallet = "./devlet2.json"

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"
weird, same problem 🧐  with 1.8.16
<@!430802284742574101> what does your Anchor.toml look like for the clones?
Another version that I know worked really well for me is, 1.8.5, but stick to 1.8.16 if it works.
Recommending 1.9.9 in docs is really bad.
<@!430802284742574101> ^ yeah I'd give that a shot
Honestly, to all people having issues, stick maybe with 1.8.16 (last mainnet release) of solana tools. 1.9.x is full of regression and weird bugs.
think so, and when i run this command to set up a validator, tests pass, BUT if i run anchor test by itself, the tests fails to load the recent blockhash and tests do not run
signer seeds is only about adding additional signatures for PDAs derived from your program
wait also does signer seeds have to be from a pda, when I pass in a Signer from one  program to another does the signer property remain?
``` 

let ix = mpl_token_metadata::instruction::update_metadata_accounts_v2(
           ctx.accounts.token_metadata_program.to_account_info().key(), 
           ctx.accounts.nft_metadata_account.to_account_info().key(), 
           ctx.accounts.payer.to_account_info().key(), 
           Some(ctx.accounts.payer.to_account_info().key()), 
           None, 
           None, 
           Some(false)
        );

        
            
        CpiContext::new_with_signer( 
            ctx.accounts.token_metadata_program.to_account_info(), 
            ix, 
            Some(&ctx.accounts.payer.to_account_info()),


        );
```

This is how I though I might do it, but the whole second block is is underlined red with the error 
with two of these errors `the trait bound Instruction: anchor_lang::ToAccountMetas is not satisfied
the trait anchor_lang::ToAccountMetas is not implemented for Instruction rustcE0277
context.rs(159, 8): required by a bound in anchor_lang::context::CpiContext`
But what you pasted above, the validator logs, had a whole bunch of lines where it was fetching accounts over RPC—those were all clone lines, right?
^
the correct log flags
```
solana-test-validator --ledger .anchor/test-ledger --mint 8ojYYusVjAKTB7tHjKb9oCBubhhU4vHQDNCcUAdg2ikb --bpf-program xmtn2vByiRMraod2aVHYXB9mxRJQ3Z3Y7SnvSdAy8qn repos/solanaRepos/splendorprotocol/target/deploy/splendor.so --bind-address 0.0.0.0 --clone 4bcFeLv4nydFrsZqV5CgwCVrPhkQKsXtzfy2KyMz7ozM --clone EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v --clone Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB --clone Amig8TisuLpzun8XyGfC5HJHHGUQEscjLgoTWsCCKihg --clone gLhY2arqFpmVGkpbBbTi3TeWbsWevA8dqrwbKacK3vJ --clone 8ojYYusVjAKTB7tHjKb9oCBubhhU4vHQDNCcUAdg2ikb --clone DpxS9YTv7e7MD9USgniaG4G5n4gVGAk8HJ6p7AXDXcxq --clone 5KuYEobaCTkQntwdHBZZJpo8HLAb3ruvcWKC1z5RHGJk --rpc-port 8899 --url m```
mpl_token_metadata::instruction::update_metadata_accounts_v2(
            program_id, 
            metadata_account, 
            update_authority, 
            new_update_authority, 
            data, 
            primary_sale_happened, 
            is_mutable
        );
but the format of the import itself doesn't ask for a context
I cant remember exactly I was playing with it yesterday I think at one point it was something about use_metas() not being applied
should have more flags but does not
mine

        inner: [
            "solana-test-validator",
            "--ledger",
            ".anchor/test-ledger",
            "--mint",
            "8ojYYusVjAKTB7tHjKb9oCBubhhU4vHQDNCcUAdg2ikb",
            "--bpf-program",
            "xmtn2vByiRMraod2aVHYXB9mxRJQ3Z3Y7SnvSdAy8qn",
            "repos/solanaRepos/splendorprotocol/target/deploy/splendor.so",
            "--bind-address",
            "0.0.0.0",
            "--rpc-port",
            "8899",
            "--url",
            "m",
        ],
How so? Your validator log had lots of clone log lines, right?
What goes wrong when you try?
had this bug since 1.8
<@!134416332509675520> <@!430802284742574101> See if it’s related, Solana Tools Suite has been buggy since at least 1.9.6, I reported one severe issue here that appeared at 1.9.6. Comment in the issue if related https://github.com/solana-labs/solana/issues/23376
Uhh how would I CPI to it then, haha sorry for being a noob Ive been stumoed on this since yesterday :p 

I cant call mpl_metaplex_program::cpi::update_m.......
were not being applied
the clone flags
Which flags?
No, anchor could use a trait or something, it just leads to a more complicated function signature I guess
does that any sense
<@!134416332509675520> How much SOL is an hour of your time hehe
so i had to copy the commands from his validator log and it works
Ah, ok—that shouldn't ahve anything to do with how you CPI to it
ahhh i see. Why can't anchor convert the types to account_info for us before invoke/invoke_signed? Is it too much overhead or something?
It looks like the flags that should be being used during spinning up a validator are not being spun up test validator
like when I import it I add ["no-entrypoint"]
What do you mean by has no entrypoint?
Hey everyone trying to cpi the mpl_metadata_program, which has no entrypoint can someone wexplain how I might initiate a CPI with an entrypoint? These have been my current attempts lol 
```
 let ix = update_metadata_accounts_v2(
           ctx.accounts.token_metadata_program.to_account_info().key(), 
           ctx.accounts.nft_metadata_account.to_account_info().key(), 
           ctx.accounts.payer.to_account_info().key(), 
           Some(ctx.accounts.payer.to_account_info().key()), 
           None, 
           None, 
           Some(false)
        );

        solana_program::invoke::new_with_signer( &[ix], Some(&ctx.accounts.payer.to_account_info()));
        Transaction::new_with_payer(&[ix], Some(&ctx.accounts.payer.to_account_info()));
```
that's what I'm doing, but I get the error "AnchorError caused by account: token_program. Error Code: InvalidProgramId. Error Number: 3008. Error Message: Program ID was not as expected" The program is part of Gemfarm (staking) but if I call the Tx using rpc.myprogram it works, just not when I pass instructions into the Tx
I'm not sure off the top of my head why you'd be having trouble using the TOKEN_PROGRAM_ID (I've done similar things in tons of programs, yeah)
Yeah, AccountInfo is the native solana type
is account_info type a Solana native thing? not part of anchor?
has anyone passed instructions to a transaction that include the spl-token account using Anchor? `anchor.instruction.myprogram`
I guess you could instead use a trait or something, but at the end of the day CPIs use AccountInfos once you get to `invoke`/`invoke_signed`
weird just updated to 1.9.9, but have the same issue, cannot run anchor test on its own against localnet
Hi, I don't have a bug just a question about an anchor design decision. Let's say I have some accounts struct `SetData` and it has its fields set to different account types such as `Signer<'info>` or `AccountLoader<'info, T>`.  But when I want to make a CPI call using `SetData` I have to use the accounts struct generated in the CPI module `cpi::accounts::SetData` and in there all the fields expect `account_info` type. This means that I have to cast everything using `to_account_info()` . I might be missing something under the hood but why do we have to turn everything to `account_info` before passing to a CPI call.
Ah, yeah, that's a totally different network/doesn't touch your local validator setup at all
Might not be the best place to ask, but If I wanted to make a script to airdrop from my phantom wallet, is there a good way of going about this
Hey y'all! Hoping for an assist here. am using Anchor to add custom program instructions to a transaction (anchor.instruction.mymprogram) and one of the accounts required is the token program. I am getting that as `TOKEN_PROGRAM_ID` from @solana/spl-token, but when I attempt that transaction I get the following error: "AnchorError caused by account: token_program. Error Code: InvalidProgramId. Error Number: 3008. Error Message: Program ID was not as expected". That is a PublicKey with the correct address from what I can tell. My code is:
```
accounts: {
  ... (other accts removed for clarity)
  tokenProgram: TOKEN_PROGRAM_ID,
}
```
so that could explain it
not localnet
the other projects hit devnet
Ah, that's definitely weird
does it matter if other anchor projects can have tests pass but this one cannot? still likely a reinstall should work?
Reinstall should be fine I think
does that invovle deleting the existing copy or should just a reinstall work too?
Mm, not sure, I guess you might as well reinstall solana at this point—I'm not sure what else to try remotely
validator.log

```[2022-03-01T23:00:08.430419000Z WARN  solana_perf] CUDA is disabled
[2022-03-01T23:00:08.437186000Z INFO  solana_faucet::faucet] Faucet started. Listening on: 0.0.0.0:9900
[2022-03-01T23:00:08.437205000Z INFO  solana_faucet::faucet] Faucet account address: 9MktmCMvCZvhkjbDmxQzpp6ekVMu9E1E8LRtrcNemb2U
[2022-03-01T23:00:08.438038000Z INFO  solana_core::test_validator] Fetching 4bcFeLv4nydFrsZqV5CgwCVrPhkQKsXtzfy2KyMz7ozM over RPC...
[2022-03-01T23:00:08.659151000Z INFO  solana_core::test_validator] Fetching Amig8TisuLpzun8XyGfC5HJHHGUQEscjLgoTWsCCKihg over RPC...
[2022-03-01T23:00:08.682807000Z INFO  solana_core::test_validator] Fetching 8ojYYusVjAKTB7tHjKb9oCBubhhU4vHQDNCcUAdg2ikb over RPC...
[2022-03-01T23:00:08.706790000Z INFO  solana_core::test_validator] Fetching 5KuYEobaCTkQntwdHBZZJpo8HLAb3ruvcWKC1z5RHGJk over RPC...
[2022-03-01T23:00:08.728267000Z INFO  solana_core::test_validator] Fetching gLhY2arqFpmVGkpbBbTi3TeWbsWevA8dqrwbKacK3vJ over RPC...
[2022-03-01T23:00:08.750857000Z INFO  solana_core::test_validator] Fetching EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v over RPC...
[2022-03-01T23:00:08.775021000Z INFO  solana_core::test_validator] Fetching DpxS9YTv7e7MD9USgniaG4G5n4gVGAk8HJ6p7AXDXcxq over RPC...
[2022-03-01T23:00:08.797595000Z INFO  solana_core::test_validator] Fetching Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB over RPC...
[2022-03-01T23:00:08.839213000Z INFO  solana_ledger::blockstore] Maximum open file descriptors: 500000
[2022-03-01T23:00:08.839269000Z INFO  solana_ledger::blockstore] Opening database at ".anchor/test-ledger/rocksdb"
[2022-03-01T23:00:09.129451000Z INFO  solana_ledger::blockstore] ".anchor/test-ledger/rocksdb" open took 290ms```
got it, the main issue that i'm facing is still trying to run tests successfully that others can. 

it looks like my `anchor test` gets caught and never finishes
Is the "idl" section of the API working? Whenever I query the api with a verified anchor app, it's always ```idl: null```. Example https://anchor.projectserum.com/api/v0/program/mgr99QFMYByTqGPWmNqunV7vBLmWWXdSrHUfV8Jf3JM/latest?limit=5
Otherwise if you're not doing a deploy, and just doing `anchor test` etc., you can put whatever program_id you want in your Anchor.toml
Do you have the keypair? Then yeah, I guess you could just copy it into target/deploy with the right name
is there anyway to force my anchor program locally to have a certain program id
it really messes up dev time
ahh ok so it was the solana cli. I may do the same then
we’re trying to launch a devnet demo yes
droppoed solana cli to 1.8 and it works now 😩
are u launching today Kane?
i did not :/
Looks like this is an existing, unresolved issue: https://github.com/project-serum/anchor/issues/741
Hi, has anybody tried to use the RecentBlockhashes with anchor?
I am getting an odd error with Anchor, while it works with a bare-metal Solana program.

anchor_program.rs
```
use anchor_lang::prelude::*;
use solana_program::sysvar::recent_blockhashes::RecentBlockhashes;

declare_id!("ESFaQDT5Y5u8w1VReVHoXH8tKSN7xyXSqZNNAiLC45eS");

#[program]
pub mod sysvar {
    use super::*;
    pub fn initialize(ctx: Context<Initialize>) -> ProgramResult {
        let blockhashes_via_account = &ctx.accounts.recent_blockhashes;
        msg!(
            "RecentBlockhashes: len: {:?}",
            blockhashes_via_account.len()
        );
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    pub recent_blockhashes: Sysvar<'info, RecentBlockhashes>,
}
```

error:
```
  sysvar
1. sysvar account: SysvarRecentB1ockHashes11111111111111111111
2. sysvar account: SysvarRecentB1ockHashes11111111111111111111
Transaction simulation failed: Error processing Instruction 0: Program failed to complete
    Program ESFaQDT5Y5u8w1VReVHoXH8tKSN7xyXSqZNNAiLC45eS invoke [1]
    Program log: Instruction: Initialize
    Program ESFaQDT5Y5u8w1VReVHoXH8tKSN7xyXSqZNNAiLC45eS consumed 200000 of 200000 compute units
    Program failed to complete: exceeded maximum number of instructions allowed (200000) at instruction #2902
    Program ESFaQDT5Y5u8w1VReVHoXH8tKSN7xyXSqZNNAiLC45eS failed: Program failed to complete
    1) Is initialized!
```
sweet, thanks. has the authority - thats what I'm after. <a:pepeCheers:848709322086023229>
<@!925167601590616174> did you make any progress on
```
Error: Custom: Invalid blockhash
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.
```
Actually yep, there's now a test demoing this: https://github.com/project-serum/anchor/blob/master/tests/bpf-upgradeable-state/programs/bpf-upgradeable-state/src/lib.rs#L74
any way to reference a program's own upgrade authority easily? Looks like maybe add a `Account<'info, ProgramData?` to the context?  This isn't already exposed elsewhere, is it?
Ah gotcha, yea that makes sense.
The syntax means "let anchor figure out the bump for you"
No, you can still init multiple pdas
Can we not init two pdas with this change now?


///////////////////////////////////////////////////////////////////////////////////////////////

```
      {
        xyType: 
        {
          x: 0,
          y: 0,
        }
      },

      {
        accounts: {
```
What syntax are you using in JS? Pretty sure that should work
Well your example seems to work fine, tho I can't get it to work for struct types containing other custom types: 
`#[derive(Clone, AnchorSerialize, AnchorDeserialize, Default)]`
`pub struct Type {`
`    pub x: u8,`
`    pub y: u8,`
`}`

`#[derive(Clone, AnchorSerialize, AnchorDeserialize, Default)]`
`pub struct InstructionArguments {`
`    xy_type: Type,`
`}`
No, you can pass custom types too, but on the ts side they'll just look like objects. On the rust side you need to do e.g.
```.rs
#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub struct Arg {
  x: u8,
  y: String
}

// in js
{ x: 123, y: "foo" }
```
The types are technically identical on ts- and rust-side. Also, it works when passing in form of arrays, just not as single objects.
Why can I not pass custom struct type objects to instructions as arguments? Always getting errors along the lines of Type '<type>' is not assignable to type 'never'. Are only standardized types allowed to be passed?
is there any plan to support use of anchor to develop program libraries? for example defining an Accounts struct in a library and using it for instructions in multiple programs. there are issues now like `__cpi_client_accounts_*` being private
i can make a one use instruction by running the instruction to initialize an admin account utilizing the upgrade authority and after its done i can remove the upgrade authority leading to this instruction not able to be called by any means then.
<@!134416332509675520>  regarding our discussion on the upgrade authority approach, 
``` as per the docs it says : 
The type has a programdata_address property that will be set if the program is owned by the BPFUpgradeableLoader``` if i deploy an account as immutable, in that approach wdnt my account will then not be owned by bpfupgradeableLoder if so is there a different kind of loader for immutable programs ?
not any usecase just curious in pauls tutorial he said to zero out the data apart from removing lamports, which is basically acc.data = [], another approach could be to zero it out i guess.
yus
Just to check, why do you need to do that? Can you say more about your use-case?
what is the proper way to re-initialize an account, i.e do account.data = [0;data.len()] , trying to achieve zeroing out the data.
pls share client and program code (accounts struct)
hey w.r.t https://github.com/solana-labs/solana/issues/23670 if anyone has worked around this - 

Do you have to close but only reduce lamports to the rent exempt amount for the 128 bytes of overhead?
Mm, yeah, good intuition, but slightly off: the solana stack is only 4kb, so it's still possible to have an overly-big `Account<'info, Whatever>` that lives at a PDA, and hence still need to use zero_copy
The zero copy is only useful for nonpda accounts right ? As a pda can only have a max of 10kb size, but zero copy makes sense if you decide to have accounts that use the max limit (10mb)
its a struct i guess the #program macro makes
nvm the value of myProgram will always be, `crate::program::nameofmyproject`right ?
```    pub program: Program<'info, MyProgram>,
``` ya i get that myProgram is the value for the generic T, but does it have to be name of my anchor program or any arbitary value ?
this https://docs.rs/anchor-lang/latest/anchor_lang/accounts/program/struct.Program.html#example example is simpler than the test
so this `pub program: Program<'info, crate::program::BpfUpgradeableState>` just tests that it's the key of the executing program whicch in this case happens to be called `BpfUpgradeableState`
the test program is called `BpfUpgradeableState`
nvm.
crate is referring to the current crate's root, and there the program module, and that struct from that module
you dont need that though
just the state of a program account
what is crate::program::BpgUpgradeableStake
the only weird syntax i dont understand is this ```    pub program: Program<'info, crate::program::BpfUpgradeableState>,
```
I already saved your git 😅 thx
You can read through https://github.com/cqfd/quidproquo to get a sense for how to use the spl token program
Oh. Okey ! I will need to know how to think about it so 😊 Thx
Doubt there's any documentation that will help with something like this. You're just going to have to start writing small solana programs, work through anchor tutorials + the anchor tests, etc., until you figure out how to do it
? 😊
this example sets the one-time use account I was talking about earlier
example https://docs.rs/anchor-lang/latest/anchor_lang/accounts/program/struct.Program.html
ermm. so the second instruction approach was more concise, but it used a different type namely ```crate::program::BpfUpgradeableState```
and avoided the whole match statement what is the different between the `bpfupgradeable` and `upgradeableloaderstate` in the context of upgrade authority onchain.
is the request compute budget increase live on mainnet / devnet for solana?
yup a bit dense.
There is indeed, even an anchor test about it: https://github.com/project-serum/anchor/blob/master/tests/bpf-upgradeable-state/tests/bpf-upgradable-state.ts (it's a bit involved, but anchor has support for it)
is there a way to get the upgrade authority of the executing program id on chain ?
https://jstarry.notion.site/Program-deploys-29780c48794c47308d5f138074dd9838 is good too
will do. ty
and read the documentation/source code if you want to know more
https://solanacookbook.com
check the cookbook
<@!307429921225965569>  this makes me realize me knowledge on program deployment , authority keys, etc knowledge is fairly non-existent, any good resources you might have which touches these topics.
It's handy for certain situations, but in this case I would also use a pda tbh
You'd store the account at a fixed PDA, e.g. `seeds = ["the-global-admint-account-thing"]`
Ooh, interesting, I had never noticed that one before 👀
<@!347689664855015424> did you see my message sir?
You could also use the config program and change admin keys without calling your program directly right?
what stops someone else to pass another un-initialized account, to this instruction ?
i dont remember you might have an option to set independently. and you can just add a flag to the admin account. if set to true, the one-time ix fails
the upgrade authority is the payer of the deploy tx right ? but how do you limit the instruction to be a one time use only ?
you can either have the upgrade authority be a permanent admin or you can make 2 instructions. A one-time use instruction that sets the admin key and can only be called by the upgrade authority and a 2nd that can adjust admin settings once the admin has been set by the first ix
but that can be solved with the upgrade authority
there's a chicken and egg problem here with the first setting of the admin key
Do you not need some hardcoded key (or use the program upgrade authority, etc.) to guard the first write to that account?
you have a global/singleton admin state account that stores the admin key. Whatever key is in there, thats the admin key
Whoops meant to point at paul
seed
Yeah 👆
the part i cant figure out is what denotes that account as admin?
how does my program know this is an admin acc ?
advantage is that you dont have to touch program code to change settings
another approach is to have a global admin account that stores the admin settings and an instruction that changes those admin settings
Yeah, it's fine
10 megabytes (the regular account max)
like on ethereum the smart contract size limit is at 24kb.
btw how big can my program bytecode can be asking so let say i make a lot of static data , which would in turn increase the bytecode.
is this a good approach ? or is there any more solana idiomatic way to do this ?
Yeah
aha got it so it is stored in the account which stored the bytecode, the program data account ?
By redeploying 🙂
btw can i change this hardcoded static value and re-deploy incase i ever need to change this value ?
No, it's stored in your compiled `.so` (so it eventually lives in an account, like any other, that stores your program's compiled code)
if not then where is a static data stored if we assume the smart contract has no state.
so a pubkey!("adminkey") is stored in the bytecode i guess not exactly sure.
also dsnt a hardcoded key which is just a constant stored in the bytecode i assume and dsnt take any storage slot.
aha ok so i can hardcode it as log as its immutable from the time of deployment, say i shdnt make a instruction that should attempt to change the value at that hardcoded variable ?
But it support global non-mutable state just fine 😛
Solana doesn't support any global mutable state
It's fine to bake a hardcoded key in (that you can't write to)
the jargon is confusing me.
could you translate that a bit xD
That only applies to *writable* static data
or maybe i just misunderstood in a big way
wdnt saving a hardcode address violate what the docs say ^
```Program shared objects do not support writable shared data. Programs are shared between multiple parallel executions using the same shared read-only code and data. This means that developers should not include any static writable or global variables in programs. In the future a copy-on-write mechanism could be added to support writable data.```
Or variations thereof.
So in order to make an instruction that only admins can run, you'd need to check in your contract that some known admin really did sign the transaction, with something like
```.rs
#[account(address = SOME_HARDCODED_ADMIN_KEY)]
pub admin: Signer<'info>
```
In general in solana, the only part of a request to your contract that a client can't fake is a signature from some known keypair.
just trying to think about it mentally.
Hi! I saw a developer who said he created a token and linked it to a $COIN/USDC pool but without using DEX and Raydium. He did it himself with a smart contract. It's interesting but I didn't see any documentation on the subject
What have you tried so far?


///////////////////////////////////////////////////////////////////////////////////////////////

Thanks, looks like I know what I'm doing today 😭
I found this the other day https://github.com/project-serum/anchor/blob/master/CHANGELOG.md#breaking-1
Moving from 18 -> 23 myself today and also wondering this. Do I have to fix all my `` -> Result<u64, ProgramError> {` into `Result<(u64, ProgramError)>` or is `Result<u64>` more idiomatic? Assume I have a function body like `a.checked_mul(b).or_ok(some_error)?`
I have this as the accounts for the instruction:
```rust
#[derive(Accounts, Clone)]
pub struct CreateTokenAccount<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    #[account(mut)]
    pub mint: Account<'info, Mint>,
    #[account(seeds = ["mint_auth".as_bytes()], bump)]
    pub mint_authority: AccountInfo<'info>,
    #[account(init, payer = payer, associated_token::mint = mint, associated_token::authority = payer)]
    pub token_account: Account<'info, TokenAccount>,
    pub token_program: Program<'info, Token>,
    pub associated_token_program: Program<'info, AssociatedToken>,
    pub rent: Sysvar<'info, Rent>,
    pub system_program: Program<'info, System>,
}
```
when I call this on its own from the methods api, it works fine, but if I include it as an instruction with another  - it is saying that `token_account` already exists and can't be initialized
```js
   const tokenAccountInstruction: TransactionInstruction = await program.instruction.createTokenAccount({
      accounts: {
        payer: payer.publicKey,
        mint: mint.publicKey,
        mintAuthority,
        tokenAccount,
        tokenProgram: TOKEN_PROGRAM_ID,
        associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
        rent: SYSVAR_RENT_PUBKEY,
        systemProgram: SystemProgram.programId
      }
    });
```
```
Transaction simulation failed: Error processing Instruction 0: custom program error: 0x0
    Program 3Ee8Sx8cP4b91Sf7nyGWHDpfwxKB6Mv3e1KTAozwHXjF invoke [1]
    Program log: Instruction: CreateTokenAccount
    Program ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL invoke [2]
    Program log: Allocate space for the associated token account
    Program 11111111111111111111111111111111 invoke [3]
    Allocate: account Address { address: 8u8SPD5sgPTcy625ytvVDfT48qcFKV2kG9tGtNJXDG8y, base: None } already in use
```
Hi Guys, any thoughts on Pyth vs Switchboard as an Oracle for Solana / anchor? Am new to this, google doesn't seem to return much of an opinion of why you'd choose one over another. Er.. which one is easier to interact with ? What questions should i be asking myself? I want to get a data feed for my Anchor /solana program (e.g price of oil).
Hello guys, I'm trying to consume another program in my contract.
```rust
use kyc::accounts::InsertApproved;
use kyc::program::Kyc;
use kyc::{self, AccountsApproved};

#[derive(Accounts)]
pub struct Whitelist<'info> {
    authority: Signer<'info>,
    #[account(mut)]
    ido_data: Account<'info, IdoData>,
    kyc: Account<'info, AccountsApproved>,
    system_program: Program<'info, System>,
}

//declared on kyc program
#[account]
pub struct AccountsApproved{
    pub authority: Pubkey,
    pub accounts: Vec<Pubkey>,
}
```
Error:
```
error[E0277]: the trait bound `AccountsApproved: anchor_lang::AccountSerialize` is not satisfied
   --> programs/ido/src/lib.rs:450:10
    |
450 |     kyc: Account<'info, AccountsApproved>,
    |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `anchor_lang::AccountSerialize` is not implemented for `AccountsApproved`
```
Any idea why this is happening?
`program.methods.myInstruction().accounts().instructions()`? Looks like it is in `preInstructions` https://github.com/project-serum/anchor/blob/9afdb17ac2a66725c1e6cd8089999a923d391328/ts/src/program/namespace/methods.ts#L101
is that callable from the methods api or have to use the rpc api? https://github.com/project-serum/anchor/blob/9afdb17ac2a66725c1e6cd8089999a923d391328/tests/misc/tests/misc.ts#L417
Thanks for the response,  Never mind I got it📝
Hello 👋  does somebody know what wallet_limit and lauch_stages_info are in the accounts instruction from magic eden mint?
and maybe how to get them?
`program.instruction.myInstruction`, but yeah
ok thanks
It's not too too bad to build the instruction data manually, just have to be careful about the sighash/first 8 bytes of instruction data: check https://github.com/project-serum/anchor/blob/master/lang/syn/src/codegen/program/common.rs#L17 for inspiration
and `program.transaction.myInstruction({accounts: {...}})` to create the instruction?
then the accounts are just in the same order as shown in the IDL?
Ultimately you "just" need to build an instruction and `invoke`/`invoke_signed` it
Anchor does: `Sysvar<'info, Rent>` checks
If I want to invoke a program with anchor via CPI, and I only have the raw IDL file, how do I write the CPI code. Is my only option to write the lib.rs for the program manually based on the IDL (and use this as a module in the integrating program)?

If yes, is there a way to automatically derive a lib.rs straight from an IDL?
Yeah, using the `instructions: [...]` arg (they'll run before your main rcp call), or `postInstructions: [...]` (they'll run afterwards)
is it possible to combine multiple program instructions in the call to rpc?
Hello guys, should we check sysvar account address(like rent) when we use it? It seems anchor won't  check the given sysvar account is the official one, so I am afraid some similar attack like wormhole
yeah the switch from "x.y.z" to "~x.y.z" was a bit of a surprise. Had to down grade the version in a few places.
Yep, that's what Boxs do, just point at the other struct, which gets moved over to the heap
wait why is that ?  is it because the box would only hold a pointer which is usize.
so i guess for my setup (pretty much default setup i think), it spins up a fresh new blockchain
So anchor is spinning up a fresh validator for each test run (so no persistent state)
Ok, that means you don't have a live validator running (usually good—I never run one basically)

it doesn't output anything,..
What does `lsof -i :8899` say in your terminal?
i think its the latter, i don' tknow, i didn't change any settings to do with persistent validators
Are you running a persistent validator in the background? Or is anchor spinning up a fresh one for you each time?
But usually the stack pressure is coming from bigger things than some AccountInfos (though if you have 20 AccountInfos in your context struct, that's 1k ish, so it's not really negligable necessarily)
Question - why does my PDA account (testing on local) not persist through several anchor test runs?  I thought it might be..  given the generated PDA is always the same? 

Its always seems to be recreated with every anchor test and its lamports reset to the minimal rental amount.
That was a little too strong on my part, it's not strictly speaking useless—an AccountInfo on the stack takes up 48 bytes, while a Box'd version would only take 8
<@!134416332509675520>  while searching discord i found a message where you said, boxing account info is useless, is it because accountinfo need to be manually deserialized and that is where we need to implement a deserialization to the heap instead of the stack ?
oh yes
`Clock::get()?.slot`
can someone pls help me, how can i get current slot number in anchor? like block.number in solidity
Ill update the book today too with some of the new error work in 0.23.0 so watch out for that
thanks <@!134416332509675520>  and thanks <@!347689664855015424> , will look into the tip on AnchorErrors and err! / error! macros
(see err! and error! macros too)
throw AnchorErrors instead of ProgramErrors and they will be
Because the code above only raises that error if the `checked_sub` or the `checked_add` fail
wish the error messages were a little more intuitive!
how could u tell?
I msg!-ed the transfer amount, indeed it looks like more than what the from account has in its lamports
Just add more code in there to see what's going wrong, which part is overflowing, etc.
So maybe transferring too much, etc.
You're overflowing
Oh, sorry, that function raises that error 😛 (I picked the most generic one I could think of when I posted that snippet—didn't mean for it to be production-ready haha)
This is the transfer_from_account_we_own code... its a copy paste from your link

`impl<'info> Exchange<'info> {
    fn transfer_from_account_we_own(
        src: &mut AccountInfo, // we better own this account though
        dst: &mut AccountInfo,
        amount: u64,
        //&self //use this if wanna call using the instances
    ) -> ProgramResult {
        **src.try_borrow_mut_lamports()? = src
            .lamports()
            .checked_sub(amount)
            .ok_or(ProgramError::InvalidArgument)?;
        **dst.try_borrow_mut_lamports()? = dst
            .lamports()
            .checked_add(amount)
            .ok_or(ProgramError::InvalidArgument)?;
        Ok(())
    }
}`
its inside a loop, that only runs once. 
After that, it runs Ok(()) and thats the end
Are you doing anything after that Exchange::transfer... line?
I tried this but getting an error message i don't understand. Here is the error log followed by the code.

Error log:

`Transaction simulation failed: Error processing Instruction 0: invalid program argument 
    Program 8BQunCRwyBZ3EaPP4bmCraTWhVvazrajNR3CtTM7P5rT invoke [1]
    Program log: Instruction: Exchange
    Program log: Transfer from AccountInfo { key: F1wWUbiAoTjQBSakUb9AViJ9YPRnTkEoWvMi732Wyfpa, owner: 8BQunCRwyBZ3EaPP4bmCraTWhVvazrajNR3CtTM7P5rT, is_signer: false, is_writable: true, executable: false, rent_epoch: 0, lamports: 3063530880, data.len: 9000, data: d308e82b0298757700286bee00000000ff0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, .. }
    Program log: Transfer to   AccountInfo { key: pqYoZJks8WSmiUbYpoKusa33n6yu6jAedBuC7xdNmNR, owner: 11111111111111111111111111111111, is_signer: false, is_writable: true, executable: false, rent_epoch: 0, lamports: 9000000000, data.len: 0, .. }
    Program log: The arguments provided to a program instruction where invalid
    Program 8BQunCRwyBZ3EaPP4bmCraTWhVvazrajNR3CtTM7P5rT consumed 79657 of 1400000 compute units
    Program 8BQunCRwyBZ3EaPP4bmCraTWhVvazrajNR3CtTM7P5rT failed: invalid program argument`


Here's the relevant code from the lib.rs RPC. The transfer_from_account_we_own code is a direct copy paste from the link you provided:

`msg!("Transfer from {:?}", &ctx.accounts.vault.to_account_info());
msg!("Transfer to   {:?}", &i);
Exchange::transfer_from_account_we_own(&mut ctx.accounts.vault.to_account_info(), &mut i.clone(), share)?; `
but we'll update to 1.9.12 very soon
/ new releases have a tendency to roll back code in previous ones
solana releases have a tendency to break things even when theyre only minor releases
Ah, sorry, reading the actual PR, ignore
Does stuff break with 1.9?
yes
Hum yeah, will test that ty
You can probably do `...decode(data, "base58")`
Ah, ok, the issue with using the string is the default encoding assumption is set to "hex", not base58
Hope this help someone 🙂
```
        let itx = await program.instruction.createSellOrder(
            programNftVaultDump, sellOrderDump, price, quantity, sellerTokenAccount.address, {
                accounts: {
                    payer: seller.publicKey,
                    sellerNftTokenAccount: sellerNftAssociatedTokenAccount,
                    comptoir: comptoirPDA,
                    collection: collectionPDA,
                    mint: nftMint.publicKey,
                    metadata: metadataPDA,
                    vault: programNftVaultPDA,
                    sellOrder: sellOrderPDA,
                    systemProgram: anchor.web3.SystemProgram.programId,
                    tokenProgram: TOKEN_PROGRAM_ID,
                    rent: anchor.web3.SYSVAR_RENT_PUBKEY,
                },
                signers: [seller]
            }
        );

        let tx = new web3.Transaction()
        tx.add(itx)
        let signature = await anchor.getProvider().send(tx,[seller])
        await provider.connection.confirmTransaction(signature)
        let parsedTransaction = await anchor.getProvider().connection.getParsedConfirmedTransaction(signature, 'confirmed')

        // @ts-ignore
        const coder = new BorshCoder(idl);
        // @ts-ignore
        let data = parsedTransaction.transaction.message.instructions[0].data
        const decoded = bs58.decode(data);
        // @ts-ignore
        let decodedIX = coder.instruction.decode(Buffer.from(decoded))
        console.log(decodedIX)
```
Posting fully working decoding code
Yeah that will work, but hope the latest one works for it.
At any rate, yeah, you're stuck on 0.22 if you want that metaplex dependency
Interesting—weird lol
<@!347689664855015424> is that change intended?
Perhaps surprisingly, "1.8.5" doesn't really mean what it looks like, it actually means "<= 2.0.0" https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#specifying-dependencies-from-cratesio, and "~1.8.14" actually means "<= 1.9, >= 1.8.14"
Ok, I think the issue is that previously anchor-lang depended on solana-program "1.8.5" https://github.com/project-serum/anchor/blob/v0.22.1/lang/Cargo.toml#L41, whereas now it depends on "~1.8.14" https://github.com/project-serum/anchor/blob/master/lang/Cargo.toml#L42
```
        const coder = new BorshCoder(idl);
        // @ts-ignore
        let data = parsedTransaction.transaction.message.instructions[0].data
        const decoded = bs58.decode(data);
        // @ts-ignore
        let decodedIX = coder.instruction.decode(Buffer.from(decoded))
```
I'm getting something when decoding the transation to bs58
Progress, hope this help people later
<@!134416332509675520> Ofc, this error is from `rust-analyzer`, vscode extension output.
This is what i have right now
```
        let itx = await program.instruction.removeBuyOffer(
            escrowDump, {
                accounts: {
                    buyer: buyer.publicKey,
                    buyerPayingAccount: buyerTokenAccount.address,
                    comptoir: comptoirPDA,
                    escrow: escrowPDA,
                    buyOffer: buyOfferPDA,
                    systemProgram: anchor.web3.SystemProgram.programId,
                    tokenProgram: TOKEN_PROGRAM_ID,
                    rent: anchor.web3.SYSVAR_RENT_PUBKEY,
                },
                signers: [buyer]
            }
        );


        let tx = new web3.Transaction()
        tx.add(itx)
        let signature = await anchor.getProvider().send(tx,[buyer])
        await provider.connection.confirmTransaction(signature)
        let parsedTransaction = await anchor.getProvider().connection.getParsedConfirmedTransaction(signature, 'confirmed')

        // @ts-ignore
        const coder = new BorshCoder(idl);
        // @ts-ignore
        let decodedIX = coder.instruction.decode(parsedTransaction.transaction.message.instructions[0].data)
        console.log(decodedIX)
```
Getting null means the idl doesn't recognize the sighash (the first 8 bytes of the instruction)
Will keep you posted when i get it to work 🙂
yeah this is what i'm trying to do but getting "null", playing around with it right now
Haven't actually tried this, but can you do
```.ts
let coder = new anchor.BorshCoder(theIdl);
coder.instruction.decode(instructionBuffer)
```
Above is a part of `cargo.toml`
```[dependencies]
anchor-lang = "0.23.0"
anchor-spl = "0.23.0"
mpl-token-metadata = { version = "1.2.5", features = ["no-entrypoint"]}
```
```[ERROR rust_analyzer::reload] failed to switch workspaces: rust-analyzer failed to load workspace: Failed to read Cargo metadata from Cargo.toml file /Volumes/Work/Projects/Masterbrews/nft-stake/Cargo.toml, cargo 1.58.0 (f01b232bc 2022-01-19): Failed to run `"cargo" "metadata" "--format-version" "1" "--manifest-path" "/Volumes/Work/Projects/Masterbrews/nft-stake/Cargo.toml" "--filter-platform" "x86_64-apple-darwin"`: `cargo metadata` exited with an error:     Updating crates.io index
error: failed to select a version for `solana-program`.
    ... required by package `mpl-token-metadata v1.2.5`
    ... which satisfies dependency `mpl-token-metadata = "^1.2.5"` of package `nft-stake v0.1.0 (/Volumes/Work/Projects/Masterbrews/nft-stake/programs/nft-stake)`
versions that meet the requirements `^1.9.5` are: 1.9.5, 1.10.3, 1.10.2, 1.10.1, 1.10.0, 1.9.13, 1.9.12, 1.9.11, 1.9.10, 1.9.9, 1.9.8, 1.9.7, 1.9.6

all possible versions conflict with previously selected packages.

  previously selected package `solana-program v1.8.14`
    ... which satisfies dependency `solana-program = "~1.8.14"` of package `anchor-lang v0.23.0`
    ... which satisfies dependency `anchor-lang = "^0.23.0"` of package `anchor-spl v0.23.0`
    ... which satisfies dependency `anchor-spl = "^0.23.0"` of package `nft-stake v0.1.0 (/Volumes/Work/Projects/Masterbrews/nft-stake/programs/nft-stake)`

failed to select a version for `solana-program` which could resolve this conflict
```
Can you post the error you get?
<@!134416332509675520> Would you like to help me for it? ☝️
After upgrade to the latest version(0.23.0), I am unable to install `mpl-token-metadata` due to solana-program version conflict
Hey 🙂
Is there an easy way to go decode instruction data using anchor ? 
Here is what i mean by instruction data : 
```
let parsedTransaction = await anchor.getProvider().connection.getParsedConfirmedTransaction(signature, 'confirmed')
console.log(parsedTransaction.transaction.message.instructions[0].data)
 -> YKmz3pSoZibBKvLS6uX18Nb
```
I noticed that in Anchor 0.22.1 the `ProgramResult` type is no longer included in `anchor_lang::prelude`, and functions now return `Result<()>` instead. Is there a reason for this? Should I stop using `ProgramResult` as a return value?
The issues I had were mostly about needing information from name lookup, so I could generate valid code
what about using this codegen crate? https://docs.rs/codegen/0.1.3/codegen/index.html
Hi. guys. I am a newbie in Solana development.
I have got error when run "anchor migrate".
Error messages below like.

Running migration deploy script
Error: No such file or directory (os error 2)

Now I am using ubuntu20.04 on Win11-vmwarePlayer 16 player.

And these are my env.
anchor-cli 0.22.1
solana-cli 1.9.13 (src:3ac7e043; feat:1070292356)
rustup 1.24.3 (ce5817a94 2021-05-31)

Please help.
<@!134416332509675520> I'm going to code for NFT Marketplace using Anchor?RUST, should i code for ERC721 separately and ERC1155 separately? or there should one file  containing both standards. Please help 📢
can remaining accounts be provided in the methods api - this isn't the right way:
```js
const tx1 = await program.methods.sellTokens(quantity).accounts({
      }).remaining_accounts(creators).rpc();
```
edit: `remainingAccounts`
Strictly speaking yeah, since each signature is 64 bytes and the whole tx has to fit in 1232: https://docs.solana.com/developing/programming-model/transactions#transaction-format
is there a limit on how many signers a transaction can have?
At any rate that `Anchor.toml` wallet should probably match your solana config keypair
where do I find that
it doesn't
And check if `solana config get` matches that Anchor.toml wallet path
Can you post the full error log?
That needs to point to the location of the keypair file it's saying it's not seeing?
Check your Anchor.toml for you wallet
Does anyone know why anchor localnet might be failing now when it was working previously? I'm getting an error that says "Unable to read keypair file" in the Target folder, but the keypair file is there. I did leave anchor localnet running for like 2 days because I forgot to turn it off and it was running for like 50 hours lol. Then I deleted the test-ledger folder before terminating the localnet with ctrl+c. Before, I terminated localnet before deleting the test-ledger folder in .anchor....not before. Now, even after restarting my IDE and computer and reinstalling the Solana CLI...anchor localnet still fails
you need to camleCase `systemProgram: anchor.web3.SystemProgram.programId`
Hello would anyone know what "Error: Invalid arguments: systemProgram not provided." would refer to? 
```
await program.rpc.initializePool(
      new anchor.BN(poolNonce),
      new anchor.BN(86401),
      {
        accounts: {
            pool: poolAccount.publicKey,
            user: provider.wallet.publicKey,
            authority: provider.wallet.publicKey,
            redeemableMint: redeemableMint,
            stakingMint: stakingMint,
            stakingVault: poolStakingMint,
            idoMint: idoMint,
            idoVault: poolIDOMint, 
            rewardAMint: stakingMint,
            rewardAVault: poolRewardMint,
            poolSigner: poolSigner,
            system_program: anchor.web3.SystemProgram.programId,
        },
        signers: [poolAccount],
        instructions: [
          await program.account.pool.createInstruction(poolAccount),
        ],
      }
    );
```
As you can see, I have the system_program already defined in here.
Things brings me to another realization apart from using pdas for signing via your programs,
You can use them to create an illusion of your program having a state, like u said I could have a pda which could act as my state, for instance an array of admin pubkeys, where the pubkeys themselves are not pda, but can be retrieved by querying the program pda account whose addresscan be easily calculatedm
Ya I meant it's like a normal keypair then, cause the program_id which is his mont authority is generated from the curve, only way he can sign for those is from the client side using the private key.
Worst case you can just use a PDA to store a little account that then stores the address of some keypair address where you can put the full 10mb etc.
He would need to sign with that program_id keypair from the client (can't do it from within the rust program)
Right <@134416332509675520>  ?^
So he basically made his program Itself  the mint authority so in his transactions he need to hasthe keypair of his program account itself to sign the transaction
What are some design patterns around having deterministic accounts, pdas are great but they have a size limit, what other option do I have, and any example of it being used anywhere ?
Hello I am trying to run some test where I transfer some tokens. 
But when I try: const fromAccount = await getTokenAccount(provider, from);
I get this error: 
```RangeError: Attempt to access memory outside buffer bounds
      at new NodeError (node:internal/errors:371:5)
      at boundsError (node:internal/buffer:84:11)
      at Buffer.readUInt32LE (node:internal/buffer:220:5)
      at Buffer.readUIntLE (node:internal/buffer:178:17)
      at UInt.decode (node_modules/buffer-layout/lib/Layout.js:570:14)
      at Structure.decode (node_modules/buffer-layout/lib/Layout.js:1234:32)
      at parseTokenAccount (node_modules/@project-serum/common/src/index.ts:218:37)
      at Object.getTokenAccount (node_modules/@project-serum/common/src/index.ts:214:10)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
```
any suggestions ?
No, think you can just retry
can't be caused by the address thingy right ?
Yeah, sorry, not sure!
working fine for me
<@!134416332509675520> halp
devnet is out ?
```To resume a deploy, pass the recovered keypair as the
[BUFFER_SIGNER] to `solana program deploy` or `solana write-buffer'.
Or to recover the account's lamports, pass it as the
[BUFFER_ACCOUNT_ADDRESS] argument to `solana program close`.
=====================================================================
Error: error sending request for url (https://api.devnet.solana.com/): operation timed out
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }.```
Yeah, strictly speaking you could mint tokens like that ^, but not in the way you'd probably want to (worth thinking through what you'd have to do)
is it working fine? is it able to mint the token? 
just curious 😆 with this snippet
```
    pub program: Program<'info, crate::program::MyPRogram>,
    #[account(
        init,
        mint::decimals = 0,
        mint::authority = program,
        payer = initializer
    )]
```
Alright, thanks mate
You will 😛
I completely understand what you're saying, I was just hoping I would not have to refactor around this use case
Oh damn, you're right, actually runs like a charm. Too much trust in intellisense right there xD.
You want it to be a PDA
Right, I'm saying that won't work
This is an approximation of how I made the program the authority of the mint:
```#[derive(Accounts)]
#[instruction()]
pub struct RegisterMint<'info> {
    #[account(mut)]
    pub initializer: Signer<'info>,
    pub program: Program<'info, crate::program::MyPRogram>,
    #[account(
        init,
        mint::decimals = 0,
        mint::authority = program,
        payer = initializer
    )]
    pub mint: Account<'info, Mint>,
}```
My point is that the way you do this in solana is by setting the authority to some PDA (any pda of the program), not setting the authority to the program_id itself
https://github.com/cqfd/anchor-token-studies has some examples of doing this
The way you make the program the authority is by making the authority be a program-derived address from the mint
I spent many hours doing this, but I did it.
wasted so much time on this lmao
How did you make the program the mint authority?
damn
So the program is the mint authority, the destination account is the only PDA but the destination account should not need a signer.  I quite literally need my program to sign the for itself. Does this make sense?
Oh, yeah, good eyes 👀 ^^^
you need to bind accounts in account object like

```await program.rpc.initializeGame(gameB, random, { 
accounts: {
      game: gameA,
      payer: program.provider.wallet.publicKey,
      systemProgram: anchor.web3.SystemProgram.programId,
},
    });
    console.log("Your transaction signature", tx); ```
*Only* the program can sign for a PDA, and you'd need to use `CpiContext::new_with_signer` instead
``` pub fn initialize_game(
        ctx: Context<InitializeGame>,
        bump: u8,
        random: Pubkey,
    ) -> ProgramResult {
        let game = &ctx.accounts.game;
        msg!("{:?}", game.board);
        Ok(())
    }```
Can you also show your `pub fn initialize_game` signature
Mm, bummer, seems like anchor's typescript stuff just doesn't work here (the code will actually run fine, it's only the generated typescript stuff that breaks :/)
```#[derive(Accounts)]
#[instruction(bump:u8, random: Pubkey)]
pub struct InitializeGame<'info> {
    #[account(init,payer=payer, seeds=[payer.key().as_ref(), random.as_ref()], bump)]
    pub game: Account<'info, Game>,
    pub payer: Signer<'info>,
    pub system_program: Program<'info, System>,
}```
``` const tx = await program.rpc.initializeGame(gameB, random, {
      game: gameA,
      payer: program.provider.wallet.publicKey,
      systemProgram: anchor.web3.SystemProgram.programId,

    });
    console.log("Your transaction signature", tx);```
not sure what's happening ?
```Argument of type '[number, PublicKey, { game: PublicKey; payer: PublicKey; systemProgram: PublicKey; }]' is not assignable to parameter of type '[...(number | PublicKey)[], Context<Accounts<{ name: "game"; isMut: true; isSigner: false; } | { name: "payer"; isMut: false; isSigner: true; } | { name: "systemProgram"; isMut: false; isSigner: false; }>>]'.
  Type at position 2 in source is not compatible with type at position 1 in target.
    Type '{ game: anchor.web3.PublicKey; payer: anchor.web3.PublicKey; systemProgram: anchor.web3.PublicKey; }' is not assignable to type 'Context<Accounts<{ name: "game"; isMut: true; isSigner: false; } | { name: "payer"; isMut: false; isSigner: true; } | { name: "systemProgram"; isMut: false; isSigner: false; }>>'.
      Object literal may only specify known properties, and 'game' does not exist in type 'Context<Accounts<{ name: "game"; isMut: true; isSigner: false; } | { name: "payer"; isMut: false; isSigner: true; } | { name: "systemProgram"; isMut: false; isSigner: false; }>>'```
Any new idea regarding my type-problem btw?
Yep, SystemAccount is a regular account *owned* by the system program (like your wallet), the latter is the system program itself
any difference between  system_program : SystemAccount<'info> and system_program : Program<'info,System>
Thanks for help.
not out of the box. you will probably have to run a crank (almost like a cron job in this case) in some way. i didn't use it, but I think https://docs.snowflake.so/en/ allows for that. lmk in case u try it out, curious to see how / if it works!
I want to this in my program. ‘After 1 hour, do this transaction.’. Is there any way to achieve this in solana ?
Hello, I have a program that has authority over a mint. I want this program to mint tokens to an account. However, when I try to invoke the CPI for mint_to I am getting an error:

```#[program]
pub mod my_program {
    pub fn mint_my_tokens(ctx: Context<MintMyTokens>, amount: u64) -> ProgramResult {

        anchor_spl::token::mint_to(
            CpiContext::new(
                ctx.accounts.token_program.to_account_info(),
                anchor_spl::token::MintTo {
                    mint: ctx.accounts.my_mint.to_account_info(),
                    to: destination_account.to_account_info(),
                    // The current program should have authority over the mint
                    authority: ctx.accounts.my_program.to_account_info(),
                },
            ),
            amount,
        );
...
```
The following is the error:
```
Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account 
```
I know that PDAs can sign CPI instructions, but can the program itself sign the CPI instruction? Am I doing something wrong or is this simply not possible?
If I implement Account for non anchor accounts , like for example how it's done for token acc mint acc, etc, I can't make use of the discriminator security check anchor accounts benefit from right ?



///////////////////////////////////////////////////////////////////////////////////////////////

i'm making some permissionless functions
ok, that's good, thanks!
No, that's fine (you can even have an empty account context)
Will anchor complain if you create an account context with no signers?
Probably something wrong with the CPI I'm using later on, gonna fix it first
Passing a zero to that u8 gives `Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: invalid instruction data`, swapping out that u8.to_le_bytes() for some other variable removes the error
How was it failing? Like, produce an actual crash etc.?
idk whats causing your issue but you could try the new `program.methods` api and see if that fixes it
Was using it in an account init, and a 0 as input was causing `&some_input.to_le_bytes(),` to fail.
Upgrading from anchor 18 -> 23. Have a function that takes a u8, and passing zero like this  `      await program.rpc.whatever(0, ....` gives me `invalid instruction data`, but passing a 1 , 2, 3, 4 , etc works (different error, but this one is probably me) `Cross-program invocation with unauthorized signer or writable account`
Could use something like https://docs.switchboard.xyz/randomness
Are any of yall working on projects that need a verifiably random number?  How are you doing it?
Thanks for source. I was missing "buffer-accounts".
Can try reading https://jstarry.notion.site/Program-deploys-29780c48794c47308d5f138074dd9838#561f8e76208a46b8963092adabab2256 to learn more
How are you closing the program?
When uploading the Solana program, I am paying 3.5 SOL. When I close the program, 1.78 SOL transfer to my wallet. Where do lost funds go?
Did you allocate enough space for that account? Get rid of the derive(Default) for it, that doesn't make sense to do for accounts with variable size—remove that line and then follow wherever the error messages lead you 🧘‍♂️
Yep, it would change the numbering
how are the errors stored in the program? if I delete one error from the errors struct, would it change the packing of the errors ?
Hi, I am gonna make wallet list like this program but had isuses
```
Program log: Instruction: AddWallet
    Program log: ADD WALLET
    Program log: AnchorError caused by account: state_account. Error Code: AccountDidNotSerialize. Error Number: 3004. Error Message: Failed to serialize the account.
```
This is my code. 
```
#[program]
pub mod test {
    pub fn add_wallet(
        ctx: Context<AddWallet>
    ) -> Result<()> {
        msg!("ADD WALLET");

        let account_list = &mut ctx.accounts.state_account.account_list;
        account_list.push(ctx.accounts.cbs_account.key());
        Ok(())
    }
}
#[account]
#[derive(Default)]
pub struct StateAccount {
    pub program_name: [u8; 10],
    pub bumps: AccountsBumps,
    pub account_list: Vec<Pubkey>
}

#[derive(Accounts)]
pub struct AddWallet<'info> {
    // State Accounts
    #[account(mut,
        seeds = [state_account.program_name.as_ref()],
        bump = state_account.bumps.state_account
    )]
    pub state_account: Box<Account<'info, StateAccount>>,
    pub system_program: Program<'info, System>,
    pub rent: Sysvar<'info, Rent>
}
```
This is resolved. The SOL balance in my Devnet account was insufficient.
Is there a way to make certain accounts in an accounts context optional in anchor, similar to in vanilla rust?
I have a program which is using anchor version 0.18.0 and I'm creating a new anchor program on latest build how do I switch to old version ?
The same program seems to work fine on another computer, but not on my system. Any clue what could be the error? Anchor version: 0.22.1
Error: Deploying program failed: Error processing Instruction 1: custom program error: 0x1

Hey folks, while deploying a program to devnet, I am getting an error as folllows.
Hello,
I have 2 projects, one created with anchor init and the hello-world-example with npm. In both I import "import * as splToken from "@solana/spl-token";" but in hello world I have many more methods to use than in the anchor project. Can anyone tell me what am I doing wrong ?
Thank you
hmm, ok
lol
😢
you can use `ctx.remaining_accounts` though
😦
no
Hey guys is it possible to do something like this for passing in an optional account into an instruction? `    pub pyth_product: Option<Box<AccountInfo<'info>>>,
`
Not exactly an anchor question but with this code snippet. I was wondering why the second create account does not return an error along the lines of `Address already allocated` instead the transaction just hangs and after 10 seconds I get an  `Error: Unable to obtain a new blockhash after 10101ms`
```
describe("debug", () => {
  const provider = anchor.Provider.env();
  const airdrop = 1_000_000_000;

  it("Issues with: Unable to obtain a new blockhash after 10187ms", async () => {
    const wallet = Keypair.generate();
    await provider.connection.confirmTransaction(
      await provider.connection.requestAirdrop(wallet.publicKey, airdrop),
      "confirmed"
    );
    const mintAuthority = Keypair.generate();
    const mint = await createMint(provider.connection, wallet, mintAuthority.publicKey, null, 0);

    await createAccount(provider.connection, wallet, mint, wallet.publicKey);
    await createAccount(provider.connection, wallet, mint, wallet.publicKey);
  });
});
```
💯
Good, I'll check your link and read the damn book again haha 😄
Thanks a lot!
You're close—that address does need to sign, but (interestingly) PDAs *can't* sign from the client, so it's up to your program to do the signing for it
I think I start to get it 🙂
My guess was that as I was initialising a new account for the key value pair the client needed to sign everything but I think I got it wrong haha
Only keypair addresses can sign from the client
But part of the point of a PDA is that only the deriving program can sign for them, using `invoke` or `invoke_signed`. (If you're just trying to init an account at a PDA, anchor's `init` attribute + `seeds = [....], bump,` will do this for you)
https://discord.com/channels/889577356681945098/889702325231427584/939324164890845265 for a bit of PDA background
Why do you need to sign for anything here?
I know the book talks about that but I still cant get my head around how exactly it should be used
Thanks for the answer, I'm trying to implement a hashmap like structure with PDA. You mean that the program should do the "signing" instead of the client ? You might know a piece of doc or example available for me to dig in ?
You're trying to sign for something that apparently doesn't need to sign (at least not from the client—PDAs can't sign from the client, only from within the program itself)
Hi I have some trouble understanding where an error comes from while using PDAs : 
```
Error: unknown signer: CefvkEbCGuQPTb3G3y21o57Guu1a1jEzAGYuU69UWJZ3
      at Transaction._addSignature ...

```
Is that the entire error?
And the line error is just `await program.provider.send(transaction, signers);`
If I'm getting `Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 3: invalid instruction data` while trying to upgrade Anchor versions, what's the best way to see which data is invalid? Got some fat functions with a lot of accounts/params.
Oh, oops, wrong channel.
Ah, this is probably why. But I never used `toArrayLike` myself, and yet the error crops up anyway saying that `ArrayType` is not defined still comes up. Not sure what's going on here.
Can anybody help me with anchor program idl and how to work with it? IDL: https://pastebin.com/SxbDi4Us
How to call account BorrowingModule and what parameters should I pass? When I am trying to call program.account.borrowingModule.fetch() i have an error Error: Account does not exist 
 Thanks for any help.
Is this maybe because the token account can't be created in the same transaction as a transfer to it?
You can also just re-import the `ProgramResult` type if you're feeling lazy—it still exists 😛


///////////////////////////////////////////////////////////////////////////////////////////////

What should I understand from this error

Anchor 0.23 unfortunately doesn't work with mpl-token-metadata, you'll have to stay on anchor 0.22
<@!134416332509675520>  can you check it out I tried really hard and I couldn't solve
Actually seems like a lot of us in the Pyth/Anchor ecosystem are stuck on Pyth 0.2.2 because our testing tools were based on that mock 🤣
Looks like they also used that anchor solution from Pyth 0.2.2 https://github.com/drift-labs/protocol-v1/blob/e58352555d842501284f81b11b737671abc1292e/stress/mockPythUtils.ts
Drift uses some pyth mocking, might be able to check them out: https://github.com/drift-labs/protocol-v1
hah just about to say that
But, yeah, changing the price won't work, so you might actually need the mock :/
Yeah, like <@!168868665456984065> said, it's pretty easy to just clone real pyth oracles and work with them directly
you can use the fancy test validator features to copy over certain accounts into the tests to use as "mocks"
<@!336251947633868801>  the error is for when an instruction expects an account to already be initialized when executed, but is being provided one that doesn't exist yet
They don't offer anything for mocking a Pyth oracle in testing afaik. We create a mock price feed and change the price around in our tests using the anchor solution.
But the code I'm changing is actually just removing Box, so there must be something going wrong in my program logic // program call
Interesting...
damn beat me to it lol
https://github.com/project-serum/anchor/blob/master/lang/src/error.rs#L171
That's something else and shouldn't depend on Box I don't think
```
Error processing Instruction 0: custom program error: 0xbc4
```
whats the error message you get that indicates its crashing
Seems like for me `Account<'info, Mint>`s need `Box`
Hmm
if its crashing because of stack offset/memory issues, then you will likely need to use `Box` for some/all of the larger accounts
But no, in general things might not work without Box—since you might need to save on stack space 😛
What's crashing?
So without Box it should also work right? It's crashing for me
It's purely a trick to try to save stack space
phantom does indeed
When do we need to wrap Accounts with `Box` in context?
ok, thanks - I'll test it out
Not sure but my guess is that the wallet is smart enough to make an associated token account for them (you'll be paying the rent)
does anyone know if you transfer spl-tokens tokens to somebody from the send button in a wallet if they have to have an associated token account already created?
Can you not just use the actual pyth library? https://github.com/pyth-network/pyth-client-js
Anyone have an updated Pyth TS utility? The format of price data struct changed since (https://github.com/project-serum/anchor/blob/713d43668b304fbec5c870f3a1d67c113b6dead9/tests/pyth/tests/oracleUtils.ts) was last updated
will keep investigating and post here with updates. thanks for helping out
looks good.  curious the cause
```
pub fn claim_vote_reward_instruction(
    ctx: Context<ClaimVoteRewardInstruction>,
    // Bumps
    vault_meta_account_bump: u8,
    _fill_record_account_bump: u8,
    _vote_record_account_bump: u8,
    _vote_vault_account_bump: u8,
    _bid_vault_account_bump: u8,
    auction_state_account_bump: u8,
    _auction_epoch_state_bump: u8,
    // Seed Dependencies
    _nonce: u64,
    _fill_nonce: u64,
    auction_id: u64,
    auction_epoch: u64,
) -> Result<()> {
    msg!("btree vault_meta_account bump {}", ctx.bumps.get("vault_meta_account").unwrap());
    msg!("passed in vault_meta_account bump {}", vault_meta_account_bump);
```
can you post your instruction method signature?
I'm going to try this out https://github.com/project-serum/anchor/pull/1572/files#diff-2e08fd9885e5913729aceb3c9e7195829ac9bbad796967b9dfb135198f0be9f2R255

And possibly try adding a log line to the anchor macro where the passed in bump is being used to calculate the PDA, just to make sure it's using the right bump there
this logged value matches what I pass in through the client:

```
'Program log: btree vault_meta_account bump 251', 'Program log: passed in vault_meta_account bump 251'
```
(the bump was 253 earlier, but as mentioned a program-specific nonce is being incremented every time I call an ix, and that nonce is a seed)
Yeah it's a program specific nonce being incremented
If the bump was computed wrong on client side, you'd get that error they were getting.  Because the account would be wrong; failing the owner check.
Looking at this again, why is this including a nonce in the seed array?  bumps and more bumps?  Or perhaps thats just a program specific nonce being incremented.  Ignore me.
I'm thinking wrong value being passed in, or `instruction` attr and method sig dont match and bump isnt first.  That behavior there is weird.
Yeah, word, same 👍
Like, if the bump is somehow wrong you'd just get a seeds constraint error
I agree, but I'm rolling down this path
Fwiw I'm still confused how that would lead to the error you're actually seeing above though 🤔
Trying that now, for the record I agree I expect that logged value to be different for `vault_meta_account_bump`. That was my original complaint
also, if I recall, that `instruction` attr is using the arguments from the instruction method in order with no checks, so that bump **needs** to be the first arg (or _add _the _others _then your_bump). It might even be deserializing directly from instruction data.
so log `vault_meta_account_bump `
Right
To be clear, you're using:
`#[instruction(vault_meta_account_bump: u8)]`
in your derive

Which means your instruction signature should be 
`pub fn something(_ctx: Context<Something>, vault_meta_account_bump : u8) -> Result<()> {`
Okay yeah I see you edited your comment. Logging `vault_meta_account_bump` makes more sense than logging `vault_meta_account`. I can try that
can't you pass the bumps but not use them in the derive account?
To clarify in the case where I don't pass in the bumps to the instruction from the client, and let the BTreeMap get them, things work as expected. In that case the account on the client side and the PDA calculated on-chain are the same correct value.

In the case where I do pass in bumps to the instruction, things start failing, and I get the invalid account owner error. So I can't log the `vault_meta_account` on-chain unless I fork anchor code and modify one of the macros to log it out
can you log `vault_meta_account_bump` onchain?  I'm thinking its not actually being read correctly.
First snippet is python, second is on-chain
are you logging `vault_meta_account ` from within the onchain code?  Or is that a python log?
0.22.1 but I'll test it out with that chunk
Client side:
```
arbiter.py:176|2022-03-23 09:01:28,235|DEBUG| vault_meta_account bump 253
```
Program instruction handler:
```
Instruction handler:
"Program log: btree: vault_meta_account bump: 253"
```
So it's the same value calculated on client side and on-chain
This chunk in particular: https://github.com/project-serum/anchor/pull/1572/files#diff-2e08fd9885e5913729aceb3c9e7195829ac9bbad796967b9dfb135198f0be9f2R255
I'm still not sure how bumps could mess this up though (meaning it would be an interesting bug if they *are* messing things up), since the error you're getting above is actually about the program owner, not the address/seeds etc.
What version of anchor are you using? Looks like the absolute latest code actually logs the expected vs actual owner pubkeys
> I'm very confident bumps are calculated correctly on the client side
are you able to program log the value of the computed bump (using the btreemap) and the value of what is passed in (`vault_meta_account_bump`), just to be 100%?
any other thoughts on this? Currently, in order to save compute I've defaulted to calculating bumps client side and passing those in, but am blocked and will need to use the BTreeMap instead to make progress.
yeah, was painful for me a couple days back
Yep, you're right, feature got removed
Correct me if I'm wrong, but in 0.23 it doesn't even do this anymore.
found what I think is the answer, I will try to copy all the functions used to deserialize the TokenAccount and see if that works for my custom account
<https://github.com/project-serum/anchor/blob/master/spl/src/token.rs#L336-L365>
calculation happens on chain when the account is init and then you can store it on chain, never have to bother with client based PDA stuff anymore
we don't do that any more though
Got it, thank you so much
Yeah, exactly
So the only reason we generate the bump off-chain is because we wanna save compute budget, right?
Yep, worth taking a look at the implementation, it's actually very simple
Because it iterates through the possible bumps in a sequential manner, I suppose?
Yes
I'm talking about PDAs and the `find_program_address` method
For the same seeds, will the bump always be same?
ideally this would be something that doesn't have to be added to anchor lang or anchor spl and just lives in my own codebase (to avoid the pain of custom forks or waiting for merges)
Is there a set procedure yet for adding custom account structs that can be deserialized using `pub this_crate_account: Account<'info, CrateStruct>`?

i have an account data struct `CrateStruct` that lives in a separate crate which I would like for anchor to deserialize an account as. Similar to how Token Program accounts are deserialized even though they don't have an account discriminator
You don't have solana installed (that build-bpf command comes from the cargo-build-bpf executable in your solana bin directory)
The discriminator only depends on the struct name, not which instruction you do it from.
Pretty much the only reason to ever use derive(Default) is to skip specifying space, anchor doesn't use it any other way.
Wow... interesting. That does seem like a bug—or at least I'm pretty unclear why that would lead to the error message you were getting before 🤔
hey i  was reviewing the cashio github repo(recently got hacked) and noticed there use of acces_control macros to do additional checking on the accounts passed, is this a common process to use access_control and add another set of checks to further validate accounts, for instance why cant it be done in the logic of the instruction itself or it can and this is done only to better organize code ?
Wondering if #[derive(Default)] ever cared about the value or not? Only about the size right?
can i have init on the same type of account in two different methods or would the have different discriminators?
anybody seen something like this in relation to `Provider` deployed on web `Uncaught ReferenceError: $f9936ec00aa88bd7$exports is not defined`?
trying to build with github actions and getting `error: no such subcommand: `build-bpf`` has anyone seen that before?
try to search on discord
<:howiecry:693105312294764606>
lol
I got the right one tho
It generally happpens when you have an incorrect declare_id!
lmao
Now Im confused
Ooooo
I just dont know what AccountNotProgramOwned means when the only PDA (for that program) I have is that one
https://explorer.solana.com/tx/2sWH3hYWx76SfFr7SfL25CD9q9gT7EfZhQpeGp4bcqN56LRXNSpCzfbTd2nsJPi63MAk1155K39F3KR63miCjBbA?cluster=devnet
So its not associated with anything?
huh interesting
and look somethn' like this
normal accounts are owned by systemProgram
It's not a normal account
not sure how im getting a account on the curve when im using findProgramAddress
is there a better way to debug this 😭
huh
but it looks like a normal account
https://explorer.solana.com/address/UPFEo4xxaYxmhyNZkgPGKYj1F26zqshksjnTFudrPBk?cluster=devnet
thats what im passing in
```
  return await web3.PublicKey.findProgramAddress(
    [Buffer.from("auction", "utf8"), seller.toBuffer()],
    programId
  );
```
weird
0xa7 = AccountNotProgramOwned
Unless it has offsets
https://explorer.solana.com/tx/4ARFCu8ogjBckz911pC4G5WE9Ydnq7MwJH2PfpG9uv1Cm4qGz892d2pZ3WJnipLHqsVfgDFVkRM6QNt7iPznkd95?cluster=devnet
lol
but I do not have 59 custom errors
I got custom error 167
How do I close accounts programmatically?
<@!134416332509675520> Removing the explicitly passed in bump fixes the issue. New code below:

```
    #[account(
        mut,
        seeds = [
            ra_owner.key.as_ref(),
            b"vault_meta".as_ref(),
            &nonce.to_le_bytes(),
        ],
        bump// = vault_meta_account_bump
    )]
    pub vault_meta_account: Box<Account<'info, VaultMetaAccount>>,
```

I'm very confident bumps are calculated correctly on the client side. I think it's worth investigating whether anchor is correctly handling the case where bumps are passed explicitly and the BTreeMap isn't used.
Hi everyone! I am trying to debug something by putting `msg` in `lib.rs` file and I want to see the message while running `anchor test` but it's not happening. I want to know if it's possible to see `msg` while running the tests, if not then what is the correct way to see them
Is the account owner checked before or after the calculated PDA is checked?
Do you know where in anchor code this check happens? I can fork and add a `msg!` there
We want to sneak in a log *before* the deserialization happens (since the deserialization part is failing)
Ok, hmm, yeah I may be wrong about the order in which things run
I'm actually a little confused why it's private (maybe I'm wrong about that log running early enough)
Ah, ok, could also do `vault_meta_account.to_account_info().owner`
`vault_meta_account.info.owner` is a private field, but i'm trying this now with logging out a different field in the `VaultMetaAccount` struct
Pretty sure that log will get a chance to run before the actual `Account` deserialization stuff runs
One thing you can do, kind of silly but would at least help debug, is add some extra logging
```.rs
bump = {
  msg("wtf {:?}", vault_meta_account.owner); // or whatever else to log
  vault_meta_account_bump
}
```
The seeds are correct because I print out the calculated PDA client side immediately before I pass the exact same public key to the instruction as an account. Also passing in the exact same seeds used to calculate that public key
```
    #[account(
        mut,
        seeds = [
            ra_owner.key.as_ref(),
            b"vault_meta".as_ref(),
            &nonce.to_le_bytes(),
        ],
        bump = vault_meta_account_bump
    )]
    pub vault_meta_account: Box<Account<'info, VaultMetaAccount>>,
```
Can you show the derive(Accounts) that's failing?
that's a good point. the public key being passed in is definitely correct, and the account is owned by the right program according to the explorer. so I'm very confused as well.
Hmm. The on-chain program can't load any accounts that you haven't passed in from the client, so I'm not sure how bump stuff could factor into this 🤔
I have high confidence this isn't an issue of confirmations, I've noticed a number of weird things related to the 0.22.1 update, related to bumps. I have a feeling the on-chain program is calculating the PDA here with the wrong bump (even though the correct bump is passed to the instruction) and is actually loading a different public key (with a different owning program ID) than it should be.
re: confirmations, I'm programmatically calling the instruction which is mysteriously failing after a websocket subscription update, where the update waits until the commitment level is "confirmed":

`"commitment": "confirmed"`
Ok, that looks fine—not sure what it could be beyond confirmation, since 0.22 also double checks that your declare_id! matches the runtime id (so that old bug possibility is gone now)
sure:

```
    #[account(
        init,
        payer = ra_owner,
        space = 816,
        seeds = [
            ra_owner.key.as_ref(),
            b"vault_meta".as_ref(),
            &ra_data_account.nonce.to_le_bytes(),
        ],
        bump
    )]
    pub vault_meta_account: Box<Account<'info, VaultMetaAccount>>,
```
Could maybe happen if you haven't waited for enough confirmation after the first tx
Can you show the `init` part of the code?
I have an account that was `init`'d through an anchor instruction, but later when passed to a different instruction, anchor complains about it not being owned by the right program:

```
Program log: AnchorError caused by account: vault_meta_account. Error Code: AccountOwnedByWrongProgram. Error Number:
3007
```

The `declare_id` is correct, I've verified in the devnet solana explorer that the program in question is owned by the correct program. This is happening after upgrading from anchor 0.19 to 0.22.1
But yeah, if you want to be able to say `Account<'info, SomeThirdPartyThing>`, you need to mimic what TokenAccount does and write a wrapper struct.
Anchor isn't doing anything itself, it's just using the spl-token program's parsing code (try jumping to source to see)
<@!134416332509675520>  what js the most idiomatic way to differentiate between non-anchor accounts, just for the same of example say, mint and token account if there werent anchor types for them, is the idiom to just write the wrapper or any other alternative,
since there is no discriminator check not even for anchor spl accounts this confuses me how is anchor diffrentiating between spl mint and spl token account without the discriminator ?
the naive way to achieve this is to implement your random based on timestamp.
timestamp mod 10 gives you random between 0 and 9
obviously it's not good enough for everything, but it should be good enough for selecting a random element from a list or smth like that
no


///////////////////////////////////////////////////////////////////////////////////////////////

It's actually not possible to have non-zeroed data in a system program account
Is it possible to transfer an accounts' ownership from system program to a program without first zeroing the data?
That cleared it up
I found out what the problem was...I was using jsdom in my Jest test environment instead of node
try `Uint8Array.From(Buffer.from(...))`. Right now you're passing a raw buffer, `fromSecretKey`  expects a `Uint8Array`
After running `anchor deploy`, I am trying to use `solana program close file1.json --url https://mynode.com/ --authority ./keys/signer.txt --verbose` but I keep getting this error:
Error: Close failed: unable to confirm transaction. This can happen in situations such as transaction expiration and insufficient fee-payer funds
I've tried several things. I tried using Uint8Array.from([secretKey]) and that returned the same result
I'm getting this error message that I can't seem to get to the bottom of. What's weird is, it wasn't failing previously...the test was passing. All it's supposed to do is set the variable to the secret test key in a separate file. Has anyone seen this before?
This is one example, but programs can make any such assumptions.
Suppoose you have a program that 

* creates a `User` account (some arbitrary account)
* creates a `TokenAccount` associated with the `User`

And that is

* funded by a PDA with lamports
* funded by a PDA that is owning token accounts

Such that the invoked program checks the funding token accounts is `owned` by the funding lamports account.

If you try the try the trick of temporarily transferring lamports out of the PDA and to the tx fee payer and then inserting the tx fee player as the funder, the invoked program fails due to a constraint check that it owns the token accounts.
need a real world example of this if you could - I'm scratching my head trying to understand the bigger picture.  dm if it requires some specifics you're holding back on dropping
then fund the actual authority of the other accounts and use it as the payer in your cpi.
Because it means the proxy won't work with those programs, if the payer of the account creation isn't actually the authority of the other accounts (or whatever relationship it expects).
not sure why this is a problem.
no, raw tx layout.  if an instruction takes an account input that is 1 byte. each **distinct** account in a tx is 32 bytes.
are you referring to address maps here?
The big problem here is that programs you invoke might make certain assumptions about the relationship of the funded lamports account and the other accounts.

For example, they might assume the lamports accounts *owns* the token accounts.
Good luck - writing proxy gets difficult if you're trying to be under limit - because the proxied tx might be at limit already.  I've mapped this out in my brain a lot.  Had some good discussion about it with Cashmere wallet in SLC too
It'll cost 1 byte (index to existing account), not 33 (new pubkey + ix acct index).
Your program itself just needs to accept **any mut system program account to use for this**.  It'll give it the lamports from some program account it owns (in your setup), but it just needs an account to act as a payer (but won't really be net charged).
actually  i think your suggestion might work for my use case
> Programs can use any of the given accounts to pay for system program account creation.
"can" or "should be able to"?  I'm confused.
🤔
hmmmm
This doesn't work generally. Programs can use any of the given accounts to pay for system program account creation.
BE CAREFUL - these are not checked in any way.  Verify verify and verify.
omg, ty!!!
Agreed, just want to make sure I'm understanding correctly.  You can just use the tx payer account (every tx has one), transferring lamports to it and using it as the payer - but that's a security risk as you're requiring that signed account to be passed in to your instruction as writable (however many programs break this rule already, and phantom doesnt warn).
They don't have to be explicitly named in the struct.  See `remaining_accounts` on `Context`
But given infinite tx size. Yes, this can be done I think.
transaction size is already way too limiting
currently, those two are the same
good question
if you want to work with them, send receive stuff, you must pass them in as account, we are talking about general solana runtime requirements
But your use case boils down to "need to save 32 bytes", not "this can't be done", right?
u mean send them in an array as parameter? not like accounts
Check with frontend how many NFTs owned by the pda, so you know what to send in the request to the contract.
Hey, guys! So I am doing a sort of a staking program. I have instruction to deposit NFTs to PDA (PDA is unique for every user). 
And I need to make a withdraw instruction of all NFTs that are owned by PDA. Thus I need to pass all token accounts owned by PDA. But how can I pass them? Since I can't know fixed number of token accounts (user can deposit up to 20 NFTs )
we need proxy programs
the use case is very real
not happening anywhere
Would love to get back to the actual use case that <@!501570363566587905> has and talk it over - if there's someplace that's happening.  Complaints tg just going in circles.
didnt see the discussion here.  still dont, prob lost in the flood.  good brain fodder for the morning
There might not really be any checks you need to do, so a kind of hacky way out is to use `SystemAccount<'info>` (to say its owned by the system program)
With anchor v0.23.0, what account type should be used for a PDA to perform checks? I was using UncheckedAccount with constraints: seeds and bump.
cc <@!99911938955309056> ^ not sure why the twitter link didn't work
https://solanacookbook.com/references/accounts.html#how-to-sign-with-a-pda
how do I transfer sol from token account who's owner is a PDA
cool, good to know
No, remaining_accounts are totally skipped by the IDL as far as I know—you have to specify their individual signer-ness/mutability on the client
are remaining accounts set as mut by default by the IDL?
ah, i bet that is it. I'll try and get myself in the situation again and change to init_if_needed to see if that helps
Anyone knows what this error means and how to solve it?

You can change `init` to `init_if_needed`
It tells you that one account you try to initialise is already initialized. Look to the account with init constraint, it should be this one
i'm sure it was something with migrating to a PDA. I've brand new so not fully understanding everything 🤦 trying to wrap my head around things haha
I didn't. I had it deployed and working fine. Then I changed my program to use a PDA and re-deployed. But client side I was getting the "account already in use" error when invoking initialize
Did you close the program? When closing a program, you cannot redeploy at the same address.  It works in your test because it runs a new local node every time.
Is devnet down today?
i read that but still confused, can you please explain in you own words? <@!831450660146642974> <@!881229386551033956> <@!892184358000132166>
i had to deploy with a new program id, not too sure how to get around that
https://book.anchor-lang.com/chapter_3/the_accounts_struct.html
Calling initialize from react I'm getting ```Allocate: account Address { address: "", base: None } already in use```
However it works in my tests everytime. Both running on localhost
`#[account(init,seeds = [my_account.key().as_ref(), b"stake"],bump,token::mint = stake_mint,token::authority = authority,payer =staker)]
    pub contract_token_account:Account<'info, TokenAccount>`,       error :-the payer specified for an init constraint must be mutable.    in   pub contract_token_account:Account<'info, TokenAccount>,
`#[derive(Accounts)]` 
What does mean that?
<@!925167601590616174>
I am trying to use `solana program close file1.json --url https://mynode.com/ --authority ./keys/signer.txt --verbose` but I keep getting ```Error: Close failed: unable to confirm transaction. This can happen in situations such as transaction expiration and insufficient fee-payer funds```
I just made it an `UncheckedAccount` and did deserialized it while processing the instruction. You can try wat <@!445019022338031618> said directly under ur question tho (lmk if it works 🙂 ).
gemworks
Apart from step finance staking system , any other staking systems open sourced ?
lmao yeah okay
Mm, at least for me installing the cli isn't that easy
cargo update solana-cli ?
solana-cli 1.9.8 (src:4ebeb336; feat:2191737503)
might have been a balance issue
What's your solana version? `solana --version`
While deploying on mainnet I get ```
Pubsub error: UnexpectedMessageError("{\"error\": Object({\"code\": Number(-32601), \"message\": String(\"Method not found\")}), \"id\": Number(1), \"jsonrpc\": String(\"2.0\")}")
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.```
Hey everyone . How can i get nft metadata in anchor ?
Thanks! (If anyone searches the above for some reason, I was conflating signing and mut. I thought mut was only required for debits not credits :>. The receiver of Sol is also mut, just doesn't require a signature)
And L92 has the account in question
Ah sorry uncomment L69-74, that was me testing
DM'd entire contract
So I'd need to see more of your code
Not immediately obvious why the signer would need to be marked as mut (I can think of some possibilities but it's a bit surprising)
Yeah
Can you print the full program log? (lol)
If I want to see all the checks anchor implement behind the scenes for different account types, will a simple anchor expand  work, If I wanna see the checks being implemented as defined by the constraints I set.
I'm not sure why it needs to be mut
Marking the signer as mut fixes this but
But I'm getting:
```<Sender's wallet> writable privilege escalated
    Program failed: Cross-program invocation with unauthorized signer or writable account```
When I attempt to execute the CPI
I'm signing
For sure
If they're your tokens, you need to sign indicating you really are ok with transferring them to somebody else
It's the "owner" of the tokens that are getting transferred
Sanity check: what is the _authority_ in an SPL token transfer CPI?
So you want the mint's address? You can do `the_mint.key()`
A very stupid question, but how to get the pubkey of the mint account passed in, as it deserializes to a mint account and it does not have any pubkey Field which makes sense , as the mint is they public key of the mint account itself but how do I retrieve that after it gets deserializes
Had a great chat with bfriel over dm and was able to figure out the issue & mostly solve it. Now that I'm implementing a solution, I'm planning on having a creator which is a PDA. If SOL from nft trade royalties accumulate into a PDA, would the program be able to transfer the SOL from the PDA to another address at some point? I'm worried about some edge cases for example if too much SOL is withdrawn from the PDA then the PDA stops existing, etc.
do tell me what are your thoughts and how one should go for this?
Good to know
I'm seeing different behavior than what's shown in that doc
We're actually revamping the way we handle NFTs and it will follow the new metaplex standard
No I haven't seen this until now
Oh interesting
after migrating to the new Metaplex collection standard, two NFTs which previously displayed as separate collections now appear as part of the same collection
Have you looked at this? https://docs.phantom.app/integrating/tokens/non-fungible-tokens#grouping-non-fungible-tokens
Hey! I was wondering what logic in phantom determines whether two NFTs should be displayed as part of the same collection or not
Thanks <@!134416332509675520> . Hey <@!263540159524503562> how can I help?
Mm, <@!363246496210092035> maybe?
my test seems to be passing but at the end i keep getting this error , ```Error: Program address not found.
```
Some of the behavior around displaying NFTs is strange and need a clarification from them on some of the internal details or need to file a bug report
anyone know what's the best way to get in contact with a developer at Phantom?
alright thanks, it worked.
`[Buffer.from("adsfasdfa")]`
?
the first parameter how do i pass in my seed, as a normal string ? findProgramAddress(["mySeed"],program.programID) >
Yep
if i am initing a pda inside my program ,do i need to do findprogramaddress of chain and provide it as an account too in the initialize instruction ?
How about the delegate, it seems the only  way to generate delegate for a token account is using approve, and it will be reset if the owner changed, so if there is no new approve in my program it should not necessary to check the token account delegate right?

Because I saw the comment here https://github.com/project-serum/sealevel-attacks/blob/master/programs/4-initialization/insecure/src/lib.rs#L26 not sure if I understand it.
Closing a token account doesn't depend on whether the authority is a PDA (the authority needs to sign, but you don't need to do anything special)
Is it necessary to do a delegate check or a close_authority if the owner of the account is PDA?
Oh lol
for me it was a capital letter error lol
so true
its always the simple stuff lol
I needed help in some development
I am creating an app where i add user's profile to blockchain, now I am thinking of doing this via api calls.
User may and may not have a solana account/address, so is there a way to just use my address and if yes there where to use this?
use my address to send/update their profile and obv fetch the updated profile i believe fetching can be done easily

user's profile can be considered as a tweet from a me just for simplicity
two files had conflicting names
i'm dumb
Oh GDI
Hmm, trying to think what it could be without seeing more of your code
Hmmm, ok, that should be fine 🤔
the handler is defined as a regular function
Define it as a top-level function
If you just want to delegate to it, don't define it in a program mod
got it, thank you!
In a `#[program]`?
Wait though, where is this defined?
That's where the error happens—I think someone mentioned this before
https://github.com/project-serum/anchor/blob/v0.18.2/lang/syn/src/idl/file.rs#L161
and this is a pretty hairy error, so thought I was mistaken
yeah thats what I thought
That should be fine, anchor doesn't care about how the bodies of the instruction fns are implemented
Ok—I doubt that's the issue with the IDL generation
yea
Oh, I guess you've got multiple instruction functions and are just delegating to one `handler`?
If they're different
Doesn't matter, you still need to pass in different contexts
Ok, if the accounts are actually different you need to pass in separate contexts for each of them
logic is the same in each instruction, but inputs are diff
There's no way for anchor to guess what you mean there
the accounts each program uses is different
The issue is that at the end of the day anchor needs to actually invoke that instruction function, which requires providing concrete arguments
Can you not just make a single context that you reuse in each function?
Tried to get them into one instruction
Previously had 3 diff instructions that essential did the same thing but interacting with different programs
Why are you trying to do that?
Mm, interesting—yeah not sure how anchor could make that work
Guessing that this is related to my trying to use a trait as a function parameter:
`pub fn handler(ctx: Context<impl LendingMarket>, withdraw_option: u64) -> ProgramResult {`

Is this just completely disallowed?
Tho if upgrading will fix, I'll find a workaround on the dependency issue
v0.18.2 (yes I do plan on upgrading but we have a cpi dependency and can't rn)
```
thread 'main' panicked at 'called `Option::unwrap()` on a `None` value', /Users/charlieyou/.cargo/git/checkouts/anchor-bf03d42499b9267c/3afd1a2/lang/syn/src/idl/file.rs:161:73
stack backtrace:
   0:        0x100ef883f - <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt::hf1ee81583766da09
   1:        0x100c20abb - core::fmt::write::h8dc218a6eb2426a8
   2:        0x100ef6eaa - std::io::Write::write_fmt::heef3e26d448f8c80
   3:        0x100ef7ab5 - std::panicking::default_hook::{{closure}}::h4b7de73863cf8582
   4:        0x100ef7287 - std::panicking::default_hook::h778da672ce56a579
   5:        0x100ef6d59 - std::panicking::rust_panic_with_hook::ha5146542f697c8af
   6:        0x100f1a00a - std::panicking::begin_panic_handler::{{closure}}::hd8bf1442c82bf304
   7:        0x100f19fa9 - std::sys_common::backtrace::__rust_end_short_backtrace::h73a3d0f5ab35b08b
   8:        0x100f19f65 - _rust_begin_unwind
   9:        0x101100fff - core::panicking::panic_fmt::h16f19dd104182e80
  10:        0x101101127 - core::panicking::panic::hf2e66822f0b332be
  11:        0x100b313ad - anchor_syn::idl::file::parse::h9a9fada69088852d
  12:        0x100abdfaf - anchor_cli::extract_idl::h4d302ce46afac8d2
  13:        0x100b34fd5 - anchor_cli::build_cwd::h86eef065e3a539eb
  14:        0x100b348ec - anchor_cli::build_all::ha98eb181938ca31e
  15:        0x100abd090 - anchor_cli::build::he06e90fb8b5c5898
  16:        0x100aabf6b - anchor_cli::entry::hf70b8e50ca8445f4
  17:        0x1009b615f - anchor::main::hfe45b7d43d4c078e
  18:        0x1009b3d06 - std::sys_common::backtrace::__rust_begin_short_backtrace::h294d80242592bc1f
  19:        0x1009b6617 - _main
```

Seeing this error when I run `anchor build`
its not that hard to implement it, just need to implement the traits, as outlined in the accounts page docs rs, and you could take a look how the anchor spl is done and try your hand at it.
any luck on this? in a similar situation
oh ok
Doesn't make sense to use it as an on-chain dependency unfortunately
Ah, ok, metaboss can't run on-chain

Can you post your Cargo dependencies?
Mm, that makes me think you have a dependency in your Cargo.toml that doesn't make sense for solana dev
it is kinda poor error output isn't it?
getting tons of
Try running `cargo clean` maybe and try again? (Annoyingly that will delete your keypair in target/deploy though, so maybe move it in case you want to keep it)


///////////////////////////////////////////////////////////////////////////////////////////////

got it, thank you for the responses
You can use whatever packing strategy you want—you just wouldn't be able to use the magic #[account] macro. E.g. how the implementation of TokenAccount or Mint works
Borsh is just easier/automagic
are there benefits of Borsh over something like doing a linear Pack (always same span for each field, zero-initialized/padded)? would Anchor consider supporting multiple serialization schemes?
u dont define the size of the vector so the macro is not aware of which size to make it -- either define the size or manually allocate enough space for it
How can i deserialize metadata account in anchor?
Yep :/ Filters just don't work well with dynamic account layouts
ah tyty, didn't see it under the Macros list so was unsure
Yep https://docs.rs/anchor-lang/latest/anchor_lang/prelude/derive.Accounts.html#instruction-attribute
is there any documentation on the `#[instruction]` macro?
Or in other words, is there any point of emitting multiple Anchor events throughout a single instruction?
Do the logs for failed instructions get emitted from Solana? Or just for the instructions that successfully execute?
Hi everyone
hey guys, could any one help me with this problem
but,it seems like this data not stored on chain, when i check it through another rpc method, its empty
but,it seems like this

and want to add pubkey through a rpc method like this:
i define a account which want to store pubkey
I am working on some client SDK code and it occurred to me that using Borsh with dynamic-length fields makes writing an RPC call with filters almost impossible for fields following any dynamic-length ones right? do I understand correctly/is there a workaround for this?
Oh or just create custom error and verify the max length. How much for define the size for a max size text ? Like idk 200 characters ?
You mean like give content.len() * 2 for example ?
are there resources for learning about different concepts some defi apps are using e.g. serum has a "crank" and you see "vaults" being used (this one in particular is a bit self-explantory)
Extra room ?
Yes totally. I just tried to have a dynamic space calculating
If you don't give yourself some extra room in the account then you won't be able to update the joke to a longer length
Oh, is it failing when you try to update the joke?


And I mean the actual instruction fn, not the derive(Accounts) part
Can you show the definition of those joke len constants you're using?


Wich instruction do you need ?
Mm, at first glance I think that should work—what does your `pub fn` instruction look like?
Store the seed of the current JokeInfoAccount in the UserAccount, so you can lookup everything easily
might need structure like this. 
UserAccount (aka joker) -> JokeInfoAccount -> Joke
UserAccount holds the pointer to the JokeInfoAccount, JokeInfoAccount has the pointers to the Jokes. 
Suppose there are 5 jokes. The JokeInfoAcccount would contain 5 pubkeys to the different Jokes. If the user wanted to add another Joke you would create a new JokeInfoAccount with the size to hold 6 jokes. Then you transfer all the JokeInfoAccount data to the new account, as well as the new joke pubkey. Then update the pointer in the UserAccount to the new JokeInfoAccount
put whatever you want in the joke account.  you also need to think about the data structure if you want to have a joke teller have more than 1 joke. you can have another account which holds all the jokes accounts a joke teller has
Why ? I only need the author and the content
do something like this for the joke account
#[account]
#[derive(Default)]
pub struct Joke {
    pub joke_creator: Pubkey,
    pub joke_told_time: u64,
    pub punchline_acknowledged_time: u64,
    //any other joke data
}
You can only have certain data size in the anchor account section, but you can still have that data in the account. It has to be handled manually. If you look at metaplex candy machine you will notice vec of nfts is not in any of the account structs. The nfts are indexed directly from the account data
Hi guys ! I am learning to develop my first smart contracts slowly and I have a problem :

Error: 3004: Failed to serialize the account

And im sure the problem come from the space. But I don't know how to solve it..

I mean, createJoke work, but the error come from the updateJoke (screen 2)
Any idea ?
how do I deploy my program to a certain address?
Does anybody have an example or two on a goki wallet implementation?
ser alan 🙏
```solana program close recover2.json --url https://mynode.com/ --buffer-authority ./keys/accrue-1.txt --recipient ./keys/accrue-1.txt```

Can someone please explain what is wrong here
I found this tweet from the release of 0.21.0: https://twitter.com/anchorlang/status/1491906358026907648
I would like to get transaction instructions for my program
Is there an example of how to use the new `program.methods` namespace in anchor 0.23.0?
Can anyone tell me about the use of Loader?
can i pass 10mb account?
#[account]
#[derive(Default)]
pub struct Stakers {
    pub stakes: [Pubkey; 100000],
}
this shows erorr, how to fix it?
Thank you for the clarification it also makes sense doing it that way. Yes exactly.
Otherwise you could totally break a lot of security assumptions, e.g. you could init a fake token account and then transfer ownership to the token program, etc.
No, don't think so. The idea is you have this invariant in solana that if account A has some data in it, you know for sure that A's owning program wrote that data
Oh that is interesting. Haven't read that anywhere. The reason why am asking is because when creating big data accounts I wasn't sure if someone could pre-populate it and thereafter assign ownership to my program.
As far as I know


///////////////////////////////////////////////////////////////////////////////////////////////

If he is the update authority then yes, but that would need to be set first
It depends who is the update authority of the NFT metadata
like he would be able to put anything there
but if i make this via JS than user will be able to update metadata on his own
I guess this will point you in the right direction for a CPI in anchor - you need to call the metaplex program
Can someone help
Well, you use the update metadata instruction with JS: https://github.com/metaplex-foundation/metaplex-program-library/blob/2eb95ec5c5d05dd020b8811b0e21f2f16c5841b4/token-metadata/js/src/generated/instructions/UpdateMetadataAccountV2.ts#L65
I am getting this when deploying:
[ERROR] Cannot find module 'typescript'
Require stack:
- /Users/abhinavsharma/.npm/_npx/3c06c7c2e1894b1b/node_modules/ts-node/dist/index.js
- /Users/abhinavsharma/.npm/_npx/3c06c7c2e1894b1b/node_modules/ts-mocha/src/index.js
so like when it is called it updates NFT image + properties
I was thinking about creating instruction in my Rust program
Are you wanting to do this with JS or on chain with Rust?
Thank you for your reply. I understand that i can update metadata w/ Metaplex, my question is how to do it correctly? User calls instruction to update his NFT then what do I do? I can't upload metadata and get link from solana program. So I need to take new metadata link as a parameter?
This is fairly standard - the uri can point anywhere. If its something that updates often AWS will often be used. For PFP collections where data is usually immutable Arweave is more common.
This is a Metaplex related question rather than Anchor, but you can update the uri on an NFT metadata account as long as the account is still mutable
Any light would be appreciated 🙏
what's interesting they store metadata off-chain on the AWS which confuses me even more
Hey guys, I want to know how to update NFT metadata. So user can call program instruction and his NFT will update (image + properties). Of course it is easy to do if you pass a link to the new metadata (on Arweave for example) as a parameter. But lol this is unsafe as anybody would be able to pass some random metadata. 
So how to safely update image and properties?

For example like Taiyo Robotics did: https://www.youtube.com/watch?v=eKbRdI4a3TY
Might be a good idea for a small blog post
I need to write down my workflow as I don't deploy very often and then forget what I done before
I paired with someone doing a deploy the other day and there are just too many ways to get slightly confused, while in the middle of doing something that can definitely be a little stressful/expensive etc.
Like, always fully specify the `--url` option, etc.
I would honestly encourage not even relying on your `solana config get` values being set
I have been using `anchor upgrade ./target/deploy/program.so --program-id` which seems to work just fine
Yeah—I think for those kinds of doubts life is just way simpler if you do a fully explicit, manual solana program deploy
I'm just a bit paranoid with `anchor deploy` that I run it and it deploys to a new address instead of the existing one
Honestly, I think it's way simpler to just do all of the deployment stuff manually, via solana program deploy. It's not like it's hard to use, and it's nice and explicit (I personally don't think there's much point in being concise while deploying—you don't do it very often and you want to be completely clear about what you're actually doing)
Trying to think when you would ever want to go ahead and deploy if you didn't already have a keypair file though—your program will presumably be broken, since its declare_id! won't match that brand-new keypair.
Actually not totally sure what that means—at any rate, `anchor deploy` will generate a program_id for you if you don't already have one https://github.com/project-serum/anchor/blob/master/cli/src/lib.rs#L2303
Something that has never been quite clear to me in the docs:
```
::: tip Note This is different from the solana program deploy command, because everytime it's run it will generate a new program address. :::
```
"it's" refers to anchor here or the solana cli command?
yup it's fine
Im trying to get involved. Any projects looking for interns? Shoot I would love to just be a fly on a wall for a good team  to see how things are made and how teams work. Bonus if you challenge me with a project.
<@!327282414118240257> dealing with the same problem rn! let me know what you find
yea for sure, my accounts have padding
You'd need to have pre-allocated enough space for that Option<Pubkey> though (so, for borsh, 33 bytes)
yea based on borsh deserialization for `Option`, seems like you're right https://docs.rs/borsh/0.8.2/src/borsh/de/mod.rs.html#181
If the data is zeroed it should <:think:340844434377932800>, pretty curious about that, tell me if you get a clear answer ! x)
anchor build from source takes ages, 
avm needs to use prebuilt binaries
one more noob question... if I modify an account struct like this

before

```
// Accounts that use this have extra space to allow for new fields
pub struct Foo {
    bar: u64,
}
```

after
```
pub struct Foo {
    bar: u64,
    wat: Option<Pubkey>,
}
```

for accounts that were created before this change, `wat` would just be deserialized as `None` right?
yea that makes sense, thanks!
it's possible your own program code makes assumptions about the type and wont compile. it's also possible this increases the compute units to a point where the programs starts failing. The serialization is the same though
thanks!

and just to clarify, if I have an already deployed program, and then wrap an account with `Box`, that won't break anything? (want to make sure that change is backwards compat)
youre now using the heap instead of the stack so thats going to be slower and more expensive (although it might not be on solana since it currently still uses a bump heap). As far as functionality goes, everything should work the same
also, is there any major downside to using `Box`?
noob q—is going from `Account<'info, Foo>` to `Box<Account<'info, Foo>>` a backwards compat change?


///////////////////////////////////////////////////////////////////////////////////////////////

Perfect. Thanks!
Building and testing would probably be covered by any anchor tutorial (basically just `anchor build` and `anchor test`, can always use the `--help` option for more info)
In the `examples/` directory as well as the `tests/` directory
There are lots of examples and tests in the anchor repo (I would definitely suggest cloning it locally)
Just want to make sure I can get through the tutorial and complete a beginner project without getting stuck
Gotcha. Is there anywhere else I can find more info on some of the topics covered in section 3? Particularly Events, and Building and Testing?
Yeah, those just haven't been written yet
Hi, I'm new to Anchor and going over the documentation here: https://book.anchor-lang.com/ ... I notice most of section 3, and section 4 are unavailable, and the seem to cover important topics such as Events and Building and Testing. Is this because the documentation is incomplete?
I'm not aware of a way to do that off the top of my head, no
Is there a way to clone devnet from a block and run the clone locally with Solana test validator ?
Has anyone managed to run anchor within docker on an M1 mac? I can't figure out how to do it 🥴 Somewhat surprisingly to me, I can write a Dockerfile that builds a working solana from source, and can install anchor from source... but `anchor build` fails with `qemu-x86_64: Could not open '/lib64/ld-linux-x86-64.so.2'`
Do you know how I can transform the struct I create in the rust unit test into bytes, so I can assign it to the data field in accountInfo?
Yea just trying to pass in account info in rust, which the function then transforms back into the Price struct
Oh, you're testing in rust? Got it
To clarify its not mutating any real account data, its just mocking out stuff out in rust unit tests
Otherwise you'll have to do something super tedious and mock the pyth accounts, like what drift does here: https://github.com/drift-labs/protocol-v1/tree/master/programs/pyth
If you can get away with it I would suggest just cloning the pyth account you care about
You can't directly alter an account's data like that from the client (only programs can write to account data)
I'm trying to run unit tests on a function that takes in AccountInfo and then casts it into the Pyth Price struct

That means I'll have to create a Pyth Price struct in my unit tests and then convert it to bytes and assign it to the accountInfo data field, any idea how I can best do that?
Hi!
oh lollll, thanks bro!👍
Interestingly, no! I was caught off guard by that too, but failed CPIs immediately short-circuit the rest of the program—the `Result` type you get from `invoke`/`invoke_signed` is basically a lie
Hi, is it possible to handle /ignore the error from a CPI  and continue the process rather than to throw the error and exist?
is there like a website of GUI where we could submit our token so that it shows up nicely in the phantom wallet? unrelated to anchor but curious if anyone knows
can anyone point me in the right direction for transfering lamports in a contract?
storing stuff off chain will make it a lot cheaper
Should I use Aerweave and integrate it into the program? haven't learned how to do this yet....but curious if possible
Should I store ticket metadata off chain? For example we have a venue of 40,000 tickets and each has metadata. This is costly to store on-chain i am assuming
I think this is an issue with solana-test-validator...
For devnet, I used datahub node service, it worked fine
I'm having the same error, were you able to solve it?
don't use nightly rust
Hey guys, I am I running this through my github actions (without modifying my workflow.yaml file at all): `cargo install --git https://github.com/project-serum/anchor --tag v0.20.1 anchor-cli --locked --force`

Since today, I am getting some weird errors: 

``` 
Compiling zeroize v1.4.3
error: no rules expected the token `aarch64_apple`
   --> /home/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/ring-0.16.20/src/cpu.rs:257:13
    |
165 |     macro_rules! features {
    |     --------------------- when calling this macro
...
257 |             aarch64_apple: true,
    |             ^^^^^^^^^^^^^ no rules expected this token in macro call

error[E0425]: cannot find value `AES` in module `cpu::arm`
   --> /home/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/ring-0.16.20/src/aead/aes.rs:381:65
    |
381 |         if cpu::intel::AES.available(cpu_features) || cpu::arm::AES.available(cpu_features) {
    |                                                                 ^^^ not found in `cpu::arm`
    |
help: consider importing this constant
    |
15  | use crate::cpu::intel::AES;
    |

error[E0425]: cannot find value `PMULL` in module `cpu::arm`
...
    |
315 |             || cpu::arm::PMULL.available(cpu_features)
    |                          ^^^^^ not found in `cpu::arm`

error[E0425]: cannot find value `ARMCAP_STATIC` in this scope
...
    |
235 |             if self.mask == self.mask & ARMCAP_STATIC {
    |                                         ^^^^^^^^^^^^^ not found in this scope

For more information about this error, try `rustc --explain E0425`.
error: could not compile `ring` due to 4 previous errors
warning: build failed, waiting for other jobs to finish...
error: failed to compile `anchor-cli v0.20.1 (https://github.com/project-serum/anchor?tag=v0.20.1#a81ff88d)`, intermediate artifacts can be found at `/tmp/cargo-installrWr1FB`

Caused by:
  build failed
Error: Process completed with exit code 101.
``` 

any idea why this could be ?
Does anyone know what this means: "SendTransactionError: failed to send transaction: invalid transaction: Transaction failed to sanitize accounts offsets correctly"


///////////////////////////////////////////////////////////////////////////////////////////////

Like right now every time I want to debug an issue with the dependency, the easiest way is to add some msg! to it, cargo clean, rebuild, copy/paste.
Yeah I still figure there's a better way to manage that dependency than to rebuild and copy/paste it every time we update 😆 . It works anyways
Yeah, the test.genesis syntax there isn't doing anything fancy—it just literally expects you to have some .so file there
Anyone running into this: there's no shortcut for it. Open the dependency, `cargo build-bpf`, copy the .so file from the target/bpf/release output, repeat as needed when updating dependency
If I paste the build that came with the dependency I get `ELF error: Incompatible ELF: wrong machine` so I guess to have to build on my machine, then copy/paste it over.
Is that the way to go? Just build in the local folder and copy it in?
Are you copying the built .so file into that test directory or something?
How do I force an external dependency to rebuild and deploy the new one to genesis? Like I have ```[dependencies]  something = {path = "/somelocalpath/, features =["no-entrypoint"] }``` in cargo.toml and ```[[test.genesis]]
address = "theprogramkeyblahblahblahblah"
program = "tests/deps/something.so"``` in anchor.toml
Unfortunately in general you can't (apparently some people have developed reverse-engineering tools to help reconstruct the rust/anchor code behind a compiled program .so file, but I don't have access to them)
Let's say if I wanted to get the source code of the magic eden program or something like that
an anchor program on the blockchain
Of what?
How could I get the source program code/idl? <@!134416332509675520>
Yeah, totally
yeah, considering the only person that can change the code to change the hardcoding is the same person that can change the upgrade authority. ha

However, this feel like it'd be easily forgotten when reassigning the program.  Try to avoid.
okay all this make sense thx

Executable Data ?
just wait the program when is created comes with an account that own his data ?
oh thx
(Which sounds dumb but honestly probably ins't thaaat bad since you probably don't change it very often 🤷‍♂️)
If you don't want to pass in that weird program data account, the only alternative you have is to just hard-code the program's upgrade authority into your program
like his own update_auth_address ahah ?
and his in own world ?
Correct.  The program knows nothing about the external world with very little exception (clock & rent sysvars)
I feel like that the program have some data about himself but currently not
okay just to be clear I talk about the program Im currenlty coding not an extern program but okay
Specifically, the program AND program data.
That's not possible, Solana requires all inputs.
I have to put the program in the Acconts struct ?
You cannot get the address of the program's authority without taking the ProgramData account as an input.
the fact is that I want the upgrade_authority wihtout having to pass any accounts from the extern
mmh helps me but it's not exactly the way I want it
See examples for BPFLoader accounts
https://github.com/project-serum/anchor/blob/master/tests/bpf-upgradeable-state/programs/bpf-upgradeable-state/src/lib.rs
yeah I need it programmatically sir
if you need it programmatically
should be in the data field

of the program
The upgrade authority
What authority?
hey everyone know how we find the upgrade authority  address direcly from the anchor program ?
Thank you! fits the use case perfectly
omg sorry - haha gotcha, so it's the 10th error message in the executing program
If you know the program you want to be able to call it, have that other program send a signed pda account.  Then have your program only allow signed requests from that account.
**This assumes you know the other program in advance, and thats the only caller.**
I wonder if there is some way to check the if an instruction is invoked via cpi & the program id?
My initial guess would be to sign with the program, but I'm not sure if you can do that/how you do that/how you would constrain it on the first program's end
how would you restrict a function on one program to only being called through a cpi, and not independently?
I have an account on one program that stores and integer, and a function that increments it, but I only want the init function on another program to be able to call it
Hey everyone. Can someone figure how my program work and try to send instructions to my program for hacking ?
https://github.com/project-serum/anchor/blob/master/lang/src/error.rs#L165
0xbc2 = 3010, not 188 😛
No worries - was just checking. It's prob an error native to this program CPI

```Transaction simulation failed: Error processing Instruction 0: custom program error: 0xbc2 
Program Drs5b4bKYYpPBiAEbyTgU1SY7G5m5J3kiKRzrmWwT2LW invoke ***1***
 Program 5JmLMGBRHEPkzzd8h7HruWTcjMkv5eLkvn3tZdqvGPMM invoke ***2***
 Program log: Instruction: TokenSwap
  Program log: Custom program error: 0xbc2
  Program 5JmLMGBRHEPkzzd8h7HruWTcjMkv5eLkvn3tZdqvGPMM consumed 5883 of 153053 compute units
  Program 5JmLMGBRHEPkzzd8h7HruWTcjMkv5eLkvn3tZdqvGPMM failed: custom program error: 0xbc2
 Program Drs5b4bKYYpPBiAEbyTgU1SY7G5m5J3kiKRzrmWwT2LW consumed 52830 of 200000 compute units
  Program Drs5b4bKYYpPBiAEbyTgU1SY7G5m5J3kiKRzrmWwT2LW failed: custom program error: 0xbc2```
Don't think that's an anchor error, can you print the full program log?
What does error code 188 mean on Anchor?
Actually having simplified my `getProgramAccounts` queries a bit (removing some filters) seems pretty fast again. Really going to need to think about how to move away from this method though as I'm pretty reliant on it. Anyway, probably a conversation for another place but would be interested to hear from anyone having similar issues.
Not sure, but in general you're really not supposed to over-rely on getProgramAccounts, since, yeah, it can be slow and too much work for validators
It doesn't seem that these requests are working again but some are reallyyy slow now
Is this a potentially major issue that could affect many anchor front-ends? I'm going to need to get slightly creative to figure out how I can switch out the `getProgramAccount` methods in my front-end which I kinda rely on atm.
I would just run `anchor test`, no running validator in the background. Anchor will spin up a fresh one for you, so you won't have to worry about collisions.
Is anyone else having issues with `getProgramAccounts` requests atm? https://twitter.com/GenesysGo/status/1508335636608167938

I'm using anchor `v0.20.1` atm but all the `program.account.[accountName].all(filter)` all make use of `getProgramAccounts`.
anchor_client question:
calling `.to_string()` on a `ClientError` type throws back a message such as `"RPC response error -32002: Transaction simulation failed: Error processing Instruction 0: Program failed to complete [6 log messages]"`. Is there any way to expand the 6 log messages so that I can inspect them?
ping is ok, it seems have no problem in connection
Check your connection with devnet rpc
could any one help me? and anynone faced the same problem
and i before test sucessfully many time, and suddenly throw this error
hey guys ,when i anchor test targeted devnet, i throw a error like that : 
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.
I tried a transparent struct but it complains the underlying cannot
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.
hey guys ,when i anchor test targeted devnet, i throw a error like that :
Hey 🙂
I have a program with a global account, meaning it has a PDA with a static seed (just a string)
What is the best way to write tests for such a program ? Right now, the creation instruction tests can only be executed once because after that the global account already exist so the creation instruction fail. Since no pubkey is part of the seed, I can't just create a new account to init a new global account.
My only 2 ways are to reset my local validator or redeploy my program on a new pubkey. Is there a better solution ?
You can read on orphan instances in Rust to understand why different approaches wouldn't work
Wrap it into a struct with a single field, and implement those traits manually
Good day! How can I set up multiple IDLs in a single test case?
Is there any trick to get a struct to implement AnchorDeserialize, AnchorSerialize while it does not and is from another crate?
<@!202864446903681026> Thanks for your support. I will check at metaplex discode. 👍
im not sure. Maybe the metaplex discord will have some suggestions
<@!202864446903681026> Is any suggestion for this?
nevermind. yeah as of now i dont think its possible to see metaplex details from within a contract :/
i see
how are you limiting to a single metaplex connection?
<@!202864446903681026> Thanks for your fast reply.
Well, I checked this doc.
But I can not find the way what I want to know.
So my rust contract support NFT Transfer.
But only allow specific metaplex collection.
But I can not find a way for this in rust contract.
Please help me, what I have to do.
this is one of the best resources for solana dev info
https://solanacookbook.com/references/nfts.html#how-to-get-nft-metadata
Hello devs,
I am new to solana dev, is there a way to get token details - metadata of a NFT token from inside solana rust contract?
I think im a bit confused with how its working. So I generate an account using `Keypair.generate()` and then pass that new public key into my program. In the program it becomes an `EscrowAccount` type that holds some data. That is the account that I am sending the SOL to. Should I be doing it differently using another method?
im developing a ticket application on solana and unsure for what purposes I use anchor and I use metaplex. The goal is to create tickets on chain, store their metadata on bundlr, and be able to retrieve this data to verify the venue, time, etc.
can someone help with the use cases of anchor vs metaplex
How does it do that? Which account holds the sol here?
I have an escrow program and it takes an account as an argument then generates a PDA of the program Id and assigns that pda as the account owner
Then copying the generated IDL over to where my client code is and reading from that
`anchor build`
`anchor deploy`
It's a weird/unusual error to get, so that's why I was wondering about your validator setup. Hmm.
How are you deploying your program etc.?
And I double checked my program ID for my Anchor program is right
yes it is :/
Mm, your local validator is presumably also 1.10
Also I'm running this on my localnet validator, maybe that's outdated?
`solana-cli 1.10.0 (src:devbuild; feat:3754840877)`
Which program owns the account? (Not the same as which program derived the address of the account)
What version of `solana --version` do you have?
Having the exact same error and going crazy trying to solve it
does anyone know how to send native sol from an account owned by a PDA of the program?
pretty sure closing the account gives you the rent
does anyone know if rent is recoverable after redeployment
does anyone know of any examples of anyone setting up an oracle to feed smartweave contract states into solana programs? after minimal research it seems like switchboard.xyz would be the best way to do this


///////////////////////////////////////////////////////////////////////////////////////////////

Yeah. I missed space in init macro.
thanks a lot for the quick responses. It's much clearer now
When using json rpc on the front end does anything change when front-end becomes https vs http?
Sure
and that address it is associated with could itself be a pda?
Yeah
thanks. So would the associated_token::authority I set be the address I want to essentially serve as the "wallet" that the token account is associated with?
Associated token accounts are just regular token accounts, but they have special addresses: an associated token *address* is a PDA derived from the associated token program
Hi, quick question, what's the difference between a TokenAccount and an AssociatedTokenAccount? When do you need to use the latter?
Did you figure out this error? I'm getting this on localnet
That was pretty useful, i used it to init nft vaults on demand, given that the mint is always different.
Oh did not follow that <:think:340844434377932800>
Could you explain why init_if_needed was deprecated now?
I have a question at recent version.
Hi <@!501570363566587905> 
Thanks for your Anchor framework
```  Program log: HJ1T7SDy3IYEAAAAAAAAAA== ``` Wonderful. Should have just tested x)
Will double check with a quick test
?
yea i think so
Are events from emit!() recorded even on failing transaction ? <:think:340844434377932800>
thanks for confirming, i will check my code more what is wrong,
why the event is not firing
even though in the console, i could see my callback is registered
There isn't anything backend-specific about it, it just communicated with your local validator over the network
I would expect it to work the same, yeah
is `program.addEventListener` supported in the frontend side (reactjs) ?
is the `events` feature from anchor supported in react?
i am able to make it work in nodejs but not in reactjs
Why when we call an instruction to create an account we need a signature, but to update not?
Okey this works. It is indeed more readable
😅 ❤️
I will personally make sure it continues to work for you 😤
Yes but not maintened 😦
You can still cheerfully use the old way (deprecated just means deprecated, not deleted)
It doesn't replace it, it's an entirely new way 🧘‍♂️
But is he the one replacing rpc?
Try searching the anchor repo for `program.methods` to see a bunch of examples of how to use it

Can you show your code?
Idk ! When I replace the rpc deprecated by methods, the function doesn't work anymore and ask me for remove await
Why can't you use async/await?
I always have this error guys :/ What replace rpc now ?
`--verifiable` 💩
Anyone aware of why the docker build image for `0.23.0` isn't pushed?
There was a team at SLC hackerhouse that came up with an incentivized crank mechanism.  Complicated, but if you really need something, thats the direction you'd go
Did u get a solution ?, facing same issue here
Got it Working Thanks <@!717956950737813594>
don't use local here, create a new provider like this 
```
const provider = new Provider(connection, wallet, preflightCommitment)
const program = new Program(idl, programId, provider)
```
try to jump on the source code.
Hey just wanted to know, is it possible to create a mutable mint account struct for rust unit testing purposes?
What does provider Local mean
great it is simple and logic (What a newbie am i 😆 ). Thanks it work if i put some 0 instead. 👍
Hello everyone !
I have a question about instructions deserialising for Anchor based programs
So I'm going to write a parser which has to grab transactions from the Solana chain and deserialise all the instructions
And the thing is that with programs written using only solana_program lib it's simple, we can just import enum with instructions, try to deserialise it and match

The question is how can I implement the same functional to deserialise Anchor instructions ? I know that I can simply hardcode first 8 bytes of the instruction hash and write match, but I'm curious if there is more cool solution for this simple task

Could someone help me with it ?
Depends on how you're bundling your frontend code I think, sorry, not sure
But no, no way to automatically run stuff on-chain—you need to have some off-chain mechanism, like a bot etc.
A rust function in your contract?
Is there a way to run a rust function without a transaction occurring? For instance I have a timer that when it runs out I need to run a function, is there a way to do this automatically?
Can you please help me

I am getting this error <@!134416332509675520>
ERROR Error: Provider local is not available on browser.
Those `111111` things are actually zeros in base58 (lol, funny/surprising detail). So the default Pubkey is just all zero bytes.
Hello
When i init an array of Pubkey, the keys are like a array of bytes 1111111111111111111111111111111111 by default.
Is it possible to create a new Pubkey with exactly the same value ? 
the goal is to be able to "remove" a pubkey by replacing with this value and compare it easily.
ex : 
```
myArrayOfPubkey[0] = &[1;32] ;
msg!("an empty pubkey in my array {}", myArrayOfPubkey[0].to_string());//cool if == "1111111111111111111111111111111111"
```
It throw error like this:
    Gg1UxbDGmvex19StVpLwXB3W3mRpwiKT6DzRRECFyX9F ( my pda token account vauthority)'s signer privilege escalated
    Program consumed 100512 of 200000 compute units
    Program failed: Cross-program invocation with unauthorized signer or writable account

could anyone can help me, every thankfu!

In the new_order_v3,cpi like this:

hey guys, this problem has struggle me for a few days: 

 I want use “anchor_spl::dex”(version 0.17.0) to invoke serum program onchain(devote) with a  my own program’s pda token account and pda token account vauthority. 
I define the ctx  with_signer  below in red frame:
what this error means?
```AccountDiscriminatorMismatch

3002 - 8 byte discriminator did not match what was expected
```
```bash
cargo install --git https://github.com/project-serum/anchor avm --locked --force```
```bash
npm uninstall -g @project-serum/anchor-cli```
thank you sir
You probably have a global anchor npm install
It won't die
Any update on closing accounts conditionally?
help...

Is it possible to view all the accounts (and data that is updated) before signing/approving a transaction?
I mean methods doesn't replace rpc in Web3
Maybe is not methods
Mmh but methods totally broke the instruction.. Mmhh
Did ProgramResult send back the transaction ID ?

I see in the new version, in Web3, program.rpc is depreciate. We need now to use methods instead but we can't use async/await anymore
should I test the validator?
getting this error: Account allocation failed: RPC response error -32005: Node is behind by 212 slots
Ofc yes.. 3am I need to sleep. Its work (with an ugly error variable : e.error.errorMessage. Too much error words 😢 ) 
Thanks !
Update your `anchor` js dependency too (in package.json)
The instruction failed correctly, but I don't have access to the msg
And now I don't have access to this anymore
Btw I need to replace #[error] by #[error_code] now lmao
Okey ! I updated and use error! (and remove into()). I will test for see
More or less, yeah
So we can use Result<()> everytime is not really a problem ?
Try jumping to source, nothing fancy
I replaced it, but I really need to understand the differences between theses two result type
Or `use solana_program::entrypoint::ProgramResult;`
Nope, just replace those with `Result<()>`
Mmh
And more

Lmao the version totally broke my code
Oh okey !
It's just fancier 🪄 give it a shot/read the anchor Changelog
What about this ?
Oh oh yes ofc
programs/your_prog_name
Nope, the one in the programs/ directory
How ? lol
Just change it in your Cargo.toml in the programs/ directory
Can I update the anchor version with a command?
What else does he add? I will try to update myself anyway
Ah, ok, the new error stuff is a little fancier—ignore the `error!` thing I said above
I continue to work on an old tutorial so idk if im up to date
anchor-lang: 0.21.0
Your `anchor-lang` dependency
Ah, what version of anchor are you on?

No is not
I'll test
No, I mean keep your error_code stuff above, but use the `error!` syntax when you actually return the error—does that work?
Got it
It also didn't work because of this macro #[error_code] which doesn't exist (anymore?).

I admit to using ProgramResult instead of Result<()> because I don't know the difference yet and I'm dumb and disciplined
0x1770 is hex for 6000, which is your first custom error from above 😛
Or just use `Result<()>` instead of ProgramError and say `return Err(error!(ErrorCode::ContentTooLong)`
Try using the `error!` macro: `return Err(error!(ErrorCode::ContentTooLong.into())`
Btw any doc for theses errors type? 0x1770
Yeah its work ! Perfect 🙂
Webstorm
Which ide are you using?
No problem ! Actually my IDE allows me to see the macro (it's crazy) and I noticed that it couldn't find #[error_code] ! So I did a search of all the macros and found this one that seems to work. Hopefully I can use it like this
Oh, sorry, I was wrong, guess that does work
Find here
Yea, `#[error_code]` is now the standard
And still ProgramResult
It just worked when you answered me lmao
For real ?
I just switch to this and my custom error work (replace #[error_code] by #[error])
No, you'd want to use the `Result<()>` type instead
Seams not
Hi! Can we use custom error on a function who return a ProgramResult type ?
Hey. I want just to get advice on one thing. I'm doing metadata update for NFTs (image + properties) and I can't figure the best way to do it. 
Metadata updates via update_metadata call, I know it. But how do you generate a new metadata link? Ofc you can't upload to Arweave via Solana Program, so you need to upload metadata to the storage before Solana Program call. That's possible. But you can't just pass new uploaded metadata link to Solana Instruction, because if you have that instruction - some impostor might just call this instruction and provide fake metadata link <:Sad:827196894840619009> 

I hope you understood me, I'm bumping my head rn, so any help would be apprectiated
TypeError: program.rpc.startStuffOff is not a function
Is anyone getting this error when going through the buildspace tutorial?


///////////////////////////////////////////////////////////////////////////////////////////////

Hi there, can anyone help me?? I have a issue like this
have you ever found a `    Program log: Math operation overflow` error when fetching a price oracle?

```
Transaction simulation failed: Error processing Instruction 0: custom program error: 0xe 
    Program xmtn2vByiRMraod2aVHYXB9mxRJQ3Z3Y7SnvSdAy8qn invoke [1]
    Program log: Instruction: Deposit
    Program log: vault_name is USDC-USDT, bump is 255
    Program log: token a ming EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v
    Program 4bcFeLv4nydFrsZqV5CgwCVrPhkQKsXtzfy2KyMz7ozM invoke [2]
    Program log: Math operation overflow
    Program 4bcFeLv4nydFrsZqV5CgwCVrPhkQKsXtzfy2KyMz7ozM consumed 2104 of 114886 compute units
    Program 4bcFeLv4nydFrsZqV5CgwCVrPhkQKsXtzfy2KyMz7ozM failed: custom program error: 0xe
    Program xmtn2vByiRMraod2aVHYXB9mxRJQ3Z3Y7SnvSdAy8qn consumed 87218 of 200000 compute units
    Program xmtn2vByiRMraod2aVHYXB9mxRJQ3Z3Y7SnvSdAy8qn failed: custom program error: 0xe
```
figured it out was passing wrong account
Have you tried looking through the spl_lending source code for that instruction?
checked that the reserve collateral mint is the address I am expecting, which is correct as I am expecting the token mint for usdc
How have you tried debugging so far?
Transaction simulation failed: Error processing Instruction 0: custom program error: 0xd 
    Program xmtn2vByiRMraod2aVHYXB9mxRJQ3Z3Y7SnvSdAy8qn invoke [1]
    Program log: Instruction: Deposit
    Program log: vault_name is USDC-USDT, bump is 255
    Program log: token a ming EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v
    Program 4bcFeLv4nydFrsZqV5CgwCVrPhkQKsXtzfy2KyMz7ozM invoke [2]
    Program log: Instruction: Deposit Reserve Liquidity
    Program log: Reserve collateral mint does not match the reserve collateral mint provided
    Program log: Invalid account input
    Program 4bcFeLv4nydFrsZqV5CgwCVrPhkQKsXtzfy2KyMz7ozM consumed 3952 of 106474 compute units
    Program 4bcFeLv4nydFrsZqV5CgwCVrPhkQKsXtzfy2KyMz7ozM failed: custom program error: 0xd
    Program xmtn2vByiRMraod2aVHYXB9mxRJQ3Z3Y7SnvSdAy8qn consumed 97478 of 200000 compute units
    Program xmtn2vByiRMraod2aVHYXB9mxRJQ3Z3Y7SnvSdAy8qn failed: custom program error: 0xd
Getting the following error trying to use the spl_lending cpi
Many many
It’s got a lot of SPL tokens associated with it
Exactly, so I’m not trying to copy anymore
So what makes you think the account exists on mainnet? Seems like it doesn't
No data to copy
I realized it’s just an address and not an account.
Hmm. So how do we keep an array/vec of traders token accounts that can be minted to when orders match?
Basically an order (option order) will come, sit on order book and will be filled an hour from now when someone takes the other side.
We want to mint token at that point. How do we get token accounts info at that point? Or can we store account info on chain? But even that won't be coming from context.
The issue with using the program itself as the authority is that it's going to be tough to sign for that address (not impossible, but the normal way to do this is with a PDA).
You can see an example here: https://github.com/cqfd/anchor-token-studies
Ah, ok—that's not quite the right way to do that. You'll need the mint authority to be a PDA derived from your program, not your actual program itself.
the program is the mint authority of an spl token and I want to mint that token on demand
But why are you using your own program as an account like this? That doesn't usually make sense
Ah, you can't—you would need to pass that account in from the client (it's never possible to just directly convert a Pubkey into an AccountInfo in solana)
and how can I convert this to an AccountInfo struct? this gives an error

```
authority: ToAccountInfo::to_account_info(&id()),
```

```
the trait bound `anchor_lang::prelude::Pubkey: anchor_lang::ToAccountInfo<'_>` is not satisfied

the trait `anchor_lang::ToAccountInfo<'_>` is not implemented for `anchor_lang::prelude::Pubkey`rustc(E0277)
```
You can just run anchor deploy again
What error?
`ID`
how can I get the program ID within the program? basically how do I do `anchor.program_id.to_account_info()`?
Ledger location: .anchor/test-ledger
Log: .anchor/test-ledger/validator.log
Initializing...
Unable to start test validator. Check .anchor/test-ledger/test-ledger-log.txt for errors.
Think so, haven't been able to find another easy solution
Sorry if I posted this question in the wrong channel. Wasn't sure which it would fall under, so I went with the safest bet.
PLEASE someone help me. I'm on Windows 11 and keep getting this error:
```
Failed to obtain package metadata: `cargo metadata` exited with an error: error: failed to load manifest for workspace member `\\?\C:\Users\blarg\Git\test-program\programs\*`

Caused by:
  failed to read `\\?\C:\Users\blarg\Git\test-program\programs\*\Cargo.toml`

Caused by:
  The filename, directory name, or volume label syntax is incorrect. (os error 123)
```
The solana account docs says `"Through the upgradeable loader, it is possible to upload a totally new program to an existing program address."`
How exactly can we do this using anchor once we have deployed a program using anchor deploy. If i have some code changes, how do i deploy the program to the same program id?
Are there any best practices for mocking project tokens for localnet and devnet vs mainnet?
all other accounts are cloned with no issue
https://explorer.solana.com/address/8gEGZbUfVE1poBq71VHKX9LU7ca4x8wTUyZgcbyQe51s
I'm cloning over some accounts

```
solana_test_validator] Fetching 34bmioDCWJqaig6SN3b28TAAtrbWL35byabBVmagVzR7 over RPC...
[2022-03-03T02:12:35.303608000Z INFO  solana_test_validator] Fetching D1cqtVThyebK9KXKGXrCEuiqaNf5L4UfM1vHgCqiJxym over RPC...
[2022-03-03T02:12:35.403327000Z INFO  solana_test_validator] Fetching 6wQkK76HdRLtVB11V6Tcvp92WmSwSSf6V64kvYbe3xTd over RPC...
[2022-03-03T02:12:35.507854000Z INFO  solana_test_validator] Fetching FTkSmGsJ3ZqDSHdcnY7ejN1pWV3Ej7i88MYpZyyaqgGt over RPC...
[2022-03-03T02:12:35.743448000Z INFO  solana_test_validator] Fetching 8gEGZbUfVE1poBq71VHKX9LU7ca4x8wTUyZgcbyQe51s over RPC...
[2022-03-03T02:12:35.845319000Z ERROR solana_test_validator] Failed to fetch 8gEGZbUfVE1poBq71VHKX9LU7ca4x8wTUyZgcbyQe51s: AccountNotFound: pubkey=8gEGZbUfVE1poBq71VHKX9LU7ca4x8wTUyZgcbyQe51s
```
and am getting this error which is weird because the account most definitely exists on mainnet:
Hey thanks for this. Just want to follow up on this since I am also dealing with the same issue. Is converting u8/u16 -> u64 still the best solution?
Depends on the use case I suppose. For a decentralized option  and transparency arweave may be better. But postgres would be easier and cheaper 🙂
Yeah seems like postgres would be the way. Arweave seems overkill since the data is already on-chain?
We solved that with off chain postgres. But we are thinking about arweave
So as your program gets bigger, how do you keep track of all the PDAs floating around? It becomes slow to loop through all the program accounts checking for account types. Off-chain db?
Thanks. So any pointers to how to maintain a list of accounts for orderbook? Or can we do a CPI  of my function with pubkeys?
Nope, always have to pass any accounts of interest in from the client
basically an orderbook of options to be filled based on orders coming in
the mint_to call takes AccountInfo. Is there a way to use PubKey instead
We are trying to implement a vector of pubkey (token_mint_accounts) in a vec. Is there a way to mint_to these pubkeys in rust
i can try calculating on my function and find out!
It's calculating a PDA and expecting you to provide it as one of the accounts
Is it actually equal to that PDA?
So probably that lending_market_authority_pubkey
perhaps i'm passing in a wrong address? or a wrong account type?
i think i'm providing it all the accounts it expects, here is the source

```
#[allow(clippy::too_many_arguments)]
pub fn deposit_reserve_liquidity(
    program_id: Pubkey,
    liquidity_amount: u64,
    source_liquidity_pubkey: Pubkey,
    destination_collateral_pubkey: Pubkey,
    reserve_pubkey: Pubkey,
    reserve_liquidity_supply_pubkey: Pubkey,
    reserve_collateral_mint_pubkey: Pubkey,
    lending_market_pubkey: Pubkey,
    user_transfer_authority_pubkey: Pubkey,
) -> Instruction {
    let (lending_market_authority_pubkey, _bump_seed) = Pubkey::find_program_address(
        &[&lending_market_pubkey.to_bytes()[..PUBKEY_BYTES]],
        &program_id,
    );
    Instruction {
        program_id,
        accounts: vec![
            AccountMeta::new(source_liquidity_pubkey, false),
            AccountMeta::new(destination_collateral_pubkey, false),
            AccountMeta::new(reserve_pubkey, false),
            AccountMeta::new(reserve_liquidity_supply_pubkey, false),
            AccountMeta::new(reserve_collateral_mint_pubkey, false),
            AccountMeta::new_readonly(lending_market_pubkey, false),
            AccountMeta::new_readonly(lending_market_authority_pubkey, false),
            AccountMeta::new_readonly(user_transfer_authority_pubkey, true),
            AccountMeta::new_readonly(sysvar::clock::id(), false),
            AccountMeta::new_readonly(spl_token::id(), false),
        ],
        data: LendingInstruction::DepositReserveLiquidity { liquidity_amount }.pack(),
    }
}
```
So just need to read the source of whatever CPI instruction you're trying to do, and see what kinds of accounts it expects
Mm, sounds like you're invoking some instruction that under the hood expects you to use that account, but you're not actually using it
i am using some atas
Are you doing associated token stuff?
any ideas?
but i'm printing out all the accounts i'm passing to my cpi, and none of them are the referenced unknown account
getting an error while making a cpi
```
Transaction simulation failed: Error processing Instruction 0: An account required by the instruction is missing 
    Program xmtn2vByiRMraod2aVHYXB9mxRJQ3Z3Y7SnvSdAy8qn invoke [1]
    Program log: Instruction: Deposit
    Program log: vault_name is USDC-USDT, bump is 255
    Program log: hererererererere in deposit program id 4bcFeLv4nydFrsZqV5CgwCVrPhkQKsXtzfy2KyMz7ozM uat 6wQkK76HdRLtVB11V6Tcvp92WmSwSSf6V64kvYbe3xTd dc 2U6kk4iTVqeypBydVPKA8mLTLAQEBfWf4KYfmkcvomPE ra FTkSmGsJ3ZqDSHdcnY7ejN1pWV3Ej7i88MYpZyyaqgGt rls 64QJd6MYXUjCBvCaZKaqxiKmaMkPUdNonE1KuY1YoGGb tam EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v user8ojYYusVjAKTB7tHjKb9oCBubhhU4vHQDNCcUAdg2ikb
    Instruction references an unknown account 8gEGZbUfVE1poBq71VHKX9LU7ca4x8wTUyZgcbyQe51s
    Program xmtn2vByiRMraod2aVHYXB9mxRJQ3Z3Y7SnvSdAy8qn consumed 143587 of 200000 compute units
    Program xmtn2vByiRMraod2aVHYXB9mxRJQ3Z3Y7SnvSdAy8qn failed: An account required by the instruction is missing
```
thank you
Upgradeable programs are actually stored in two separate accounts, the actual program_id account + this other upgradeable PDA account thing
Probably
You need to also clone whatever you get from doing this: https://discord.com/channels/889577356681945098/889577399308656662/948229375810207839
the error definitely comes from one of 4 accounts that I added to context
i am not, i'm not familiar with an upgradeable loader program
When cloning programs, are you also cloning their upgradeable loader program data account?
still getting this error after cloning in a few more programs

Error: failed to send transaction: Transaction simulation failed: Attempt to load a program that does not exist
got it, I wasn't sure what  "initialize" meant.
Yeah
oh I see what you mean now, its about adding a separate ```instructions: [
          await program.account.escrowAccount.createInstruction(escrow_account),
        ],```
Also those docs are for a different attribute, the `init` one
Or the anchor book: https://book.anchor-lang.com/
#[account(zero)] requires that you issue a separate instruction from the client that allocates the account's space
I would suggest working through the actual anchor tutorials, they cover lots of examples of initializing accounts
yes, this is from the anchor documentation,
"Creates the account via a CPI to the system program and initializes it (sets its account discriminator).
Marks the account as mutable and is mutually exclusive with mut.
Makes the account rent exempt unless skipped with rent_exempt = skip.

Use #[account(zero)] for accounts larger than 10 Kibibyte."
I thought thats what it means.
Have you gone through the anchor tutorials?
Ah, no, it doesn't meant that. Where did you get that impression?
sorry but can you please explain what it means to initialize an account here? I thought #[account(zero)] means it would create an account when the CreateCheck function is called?
It would probably be easier to do `#[account(init, payer = someone_not_sure, space = 8 + however_much_space_you_need)]`
The problem you're having is that you need to actually initialize an account there, but you aren't/haven't yet
Ok, why are you using `#[account(zero)]`?
hmm sorry I din't get what you meant by initialize? I generated a random keypair for the check account (escrow_check) in my JS file and passed that into the function
forgot to clone a program
Doing `#[account(zero)]` means you're expecting the escrow_check account to already have been allocated
yea think you’re right
line 100 is the #[derive(Accounts)] line
Ah, did you actually initialize that Check account before this instruction?
But is that the actual literal line 100?
oops sorry, its line 100 of the lib.rs file.
``` #[derive(Accounts)]
pub struct CreateCheck<'info> {
    // Check being created.
    #[account(zero)]
    escrow_check: Account<'info, Check>,
    // Check's token vault.
    #[account(mut)]
    /// CHECK:` doc comment explaining why no checks through types are necessary.
    vault: AccountInfo<'info>,
    #[account(mut, signer)]
    /// CHECK:` doc comment explaining why no checks through types are necessary.
    from: AccountInfo<'info>,
    /// CHECK: This is not dangerous because we don't read or write from this account
    system_program: Program<'info, System>,
    rent: Sysvar<'info, Rent>,
}
```
Thats the account struct for the function
```ts
const x = [1,2,3,4,...,400]
await Promise.all(
    tasksArray.map(async (task) => {
      const mintTxId = await mintCandyMachineV2(
        cmid,
        connection,
        wallet,
        lamports,
        candyMachineCreator,
        creatorBump,
      );
    })
  );
```
I mean, what is happening on line 100 of your rust code?
Ah, sorry, that line is in your rust code, not in JS
How are you calling them?
are there any "cooldowns" on blockchain for transaction per wallet
Are you running them one after the other?
i mean im calling 400 mintonetoken functions at the same time and it takes so long for them to execute despite fact they are async
I'm not sure, but your program is apparently crashing there!
The line 100 that it is referencing is a different it() block. Not sure why that is causing errors in this block? The create check happens first.
Not sure what you mean
then is there any explanation why the more mintonetoken() i want to call asyncly at the same time it takes longer for mintonetoken() to execute?
Ok, so what happens on line 100 of your program?
This is the rust program log I think..
``` Transaction simulation failed: Error processing Instruction 0: Program failed to complete 
    Program <4fZ_id> invoke [1]
    Program log: Instruction: CreateCheck
    Program log: panicked at 'range end index 8 out of range for slice of length 0', programs/cashiers-check/src/lib.rs:100:10
    Program <4fZ_id> consumed 6572 of 1400000 compute units
    Program failed to complete: BPF program panicked
    Program <4fZ_id> failed: Program failed to complete```
I just replaced the key in the error log to <4fZ_id>
Probably not, that just makes an instruction, it doesn't send it
It should probably also print in the console
Sorry, the rust program log, not the stack trace
is ``candyMachine.program.instruction.mintNft`` async function?
This is the error from the JS file:
```  Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Program failed to complete
      at Connection.sendEncodedTransaction (node_modules/@project-serum/anchor/node_modules/@solana/web3.js/src/connection.ts:3963:13)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at Connection.sendRawTransaction (node_modules/@project-serum/anchor/node_modules/@solana/web3.js/src/connection.ts:3920:20)
      at sendAndConfirmRawTransaction (node_modules/@project-serum/anchor/node_modules/@solana/web3.js/src/util/send-and-confirm-raw-transaction.ts:27:21)
      at Provider.send (node_modules/@project-serum/anchor/src/provider.ts:118:18)
      at Object.rpc [as createCheck] (node_modules/@project-serum/anchor/src/program/namespace/rpc.ts:25:23) ```
What does the full program log say when you get rid of that signer?
Yeah, not sure why you need to sign with `check_escrow`
``` pub fn create_check(
        ctx: Context<CreateCheck>,
        amount: u64,
        nonce: u8,
    ) -> Result<()> {
        let check = &mut ctx.accounts.escrow_check;
        check.amount = amount;
        check.from = *ctx.accounts.from.to_account_info().key;
        // check.vault = *ctx.accounts.vault.to_account_info().key;
        check.nonce = nonce;
        check.memo = memo;

        // Transfer funds to the check using system program
        invoke(
            &transfer(
             &ctx.accounts.from.to_account_info().key(),
             &ctx.accounts.vault.to_account_info().key(),
             amount,
            ),
            &[ctx.accounts.from.to_account_info().clone(),              ctx.accounts.vault.to_account_info().clone(),          ctx.accounts.system_program.to_account_info().clone(),
            ],
        )?;
        Ok(())
    } ```
This is my function and below is my test case:
``` await program.rpc.createCheck(new anchor.BN(100),  nonce, {
      accounts: {
        escrowCheck: check_escrow.publicKey,
        vault: vault,
        from: from.publicKey,
        systemProgram: anchor.web3.SystemProgram.programId,
        rent: anchor.web3.SYSVAR_RENT_PUBKEY,
      },
      signers: [from, check_escrow],
    });
```
Is the check_escrow account not needed in the signers list?
If I get rid of that, I get a "Program failed to complete" error.
That means you're signing from the client with an account that doesn't need to sign
Hi, I am trying to use a system_program::transfer function to transfer SOL from a player wallet to a PDA. I keep running into "unknown signer" error. Any pointers in what I should look into?
Yeah. Better now to just skip it
Thanks,  so right now `bump = _bump,` is pretty much pointless as it just ensures what you pass in is equal to what is generated?
Sounds like you're interacting with multiple programs
The syntax `seeds = [...], bump, ....` tells anchor to calculate the bump for you
You can just skip passing in the bump now
Confused by something in the PDA generation, so `#[account(init, seeds... bump]` does a `find_program_address`  in the init codegen which sets the bump, why is the bump passed in as well? Throws a 2006 ConstraintSeeds error if they differ. Anyone know?
Is there any reason some of my tests would pass when I would run `anchor test` but that one test would fail with `     Error: failed to send transaction: Transaction simulation failed: Attempt to load a program that does not exist`?
I've never used this contract before so don't know what could be going wrong
Is there any actual account data at that address though? What happens if you fetch it from the client and inspect its data?
```
public async getAuctionHouseTradeState(
    auctionHouse: anchor.web3.PublicKey,
    wallet: anchor.web3.PublicKey,
    tokenAccount: anchor.web3.PublicKey,
    treasuryMint: anchor.web3.PublicKey,
    tokenMint: anchor.web3.PublicKey,
    tokenSize: anchor.BN,
    buyPrice: anchor.BN,
  ): Promise<[PublicKey, number]> {
    return await anchor.web3.PublicKey.findProgramAddress(
      [
        Buffer.from(auction_house_prefix),
        wallet.toBuffer(),
        auctionHouse.toBuffer(),
        tokenAccount.toBuffer(),
        treasuryMint.toBuffer(),
        tokenMint.toBuffer(),
        buyPrice.toBuffer('le', 8),
        tokenSize.toBuffer('le', 8),
      ],
      AUCTION_HOUSE_MARKETPLACE_PROGRAM_ID,
    );
  };
```
is how I setup the trade state's, double checked that all accounts passed in were correct
Your seller_trade_state probably isn't set up correctly
I think the issue is here (scroll all the way to the right): https://github.com/metaplex-foundation/metaplex-program-library/blob/master/auction-house/program/src/lib.rs#L1096
Please don't at message for general questions
<@!501570363566587905> , <@!134416332509675520> <@!347689664855015424>
failed tx ^
https://solscan.io/tx/3dbbS25Sj7jJn4JzLBsQ1FNnN7e3ueymhrzUGmWizu9T9cH3pRqPcidZDPzBhHecfQs6txbEXKEBEsyJqk2QSDaY
Hey, Im attempting to interact with auctinhouse and I'm getting an error, something relating to the BPF-panicking. I asked around in the metaplex discord and they said it had something to possibly do with anchor & macros. 

`(node:24051) UnhandledPromiseRejectionWarning: Error: Transaction failed: panicked at 'index out of bounds: the len is 0 but the index is 0', auction-house/program/src/lib.rs:1190:255`
I want to decode the delimiter
no the starting 8 bytes of an account are the Anchor delimiter
Probably just want to do `program.account.yourAccountStructName.fetch(theAddress)`
When I try and convert this to utf8 i get gibberish
I have these bytes at the beginning (in hex) `745b7353d8d92508`
How can I transform an anchor account's starting bytes to something readable?


///////////////////////////////////////////////////////////////////////////////////////////////

Hmm that exposed a diff problem though

I have this in my anchor.toml
```
[test.validator]
# Deactivate tx wide compute cap
deactivate_feature = "5ekBxc8itEnPv4NzGJtr8BVVQLNMQuLMNQQj7pHoLNZ9"
```

but that is never passed to the test validator as a flag

From here it looks like arbitrary args should be passed thru? https://github.com/project-serum/anchor/blob/v0.19.0/cli/src/lib.rs#L1775
Wrong Cargo.toml, stick the dependencies in the programs/your-prog/Cargo.toml
nvm found it in `.anchor/test-ledger/validator-xyz.log`
is there a way to print out the flags that are passed to the test validator from Anchor.toml when anchor test is run?
Error - failed to parse manifest. Why am i getting it?
what is stable version of anchor, solana, rust?
thanks buddy;
This is what I assumed but was looking for a confirmation
> that's the default/what happens if the account hasn't been initialized yet
Man, u are awsome, it works thanks a lot 👍.
Try using instead your crate's `::entry` function (generated by the anchor macros) instead of that create_portfolio thing
Maybe mark the player as mut, `#[account(mut)]`
Hello,
Using anchor, my transfer doesn't work : "Cross-program invocation with unauthorized signer or writable account"
```
    pub fn add_player(ctx: Context<Add>) -> Result<()> {

        let ix = anchor_lang::solana_program::system_instruction::transfer(ctx.accounts.player.key, ctx.accounts.authority.key, 10000) ;
        anchor_lang::solana_program::program::invoke(
            &ix,
            &[
                ctx.accounts.player.to_account_info(),
                ctx.accounts.authority.to_account_info()
            ]
        ).unwrap();
}
#[derive(Accounts)]
pub struct Add<'info> {
    pub system_program : Program<'info, System>,
    pub player : Signer<'info>,
    #[account(mut)]
    pub authority : Signer<'info>,
    #[account(mut, has_one = authority)]
    pub game : Account<'info, Game>
}
```
I have made an airdrop on player before sending and put it keypair as signer.
What's wrong with me 😅 ?
The create_portfolio instruction fn isn't your program's solana entrypoint, it's just an individual instruction fn
that worked wonderfully with the initital serialization function I'd written. thank you again
The `!true` thing is leftover from macro stuff. Can look at the actual macro codegen stuff to see more: https://github.com/project-serum/anchor/blob/master/lang/syn/src/codegen/accounts/constraints.rs#L414
That says if the incoming account is owned by the system program (that's the default/what happens if the account hasn't been initialized yet), then go ahead and init it
Have you tried just doing `Box<Account<'info, MetaplexMetadata>>`?
does anyone know the logic behind this?
I'm just trying to understand the logic behind the if condition which essentially decided wether to create the account or not

`if !true || token_vault.as_ref().owner == &anchor_lang::solana_program::system_program::ID`
```
                    if !true
                        || token_vault.as_ref().owner
                            == &anchor_lang::solana_program::system_program::ID
                    {
                        let payer = creator.to_account_info();
                        let cpi_program = associated_token_program.to_account_info();
                        let cpi_accounts = anchor_spl::associated_token::Create {
                            payer: payer.to_account_info(),
                            associated_token: token_vault.to_account_info(),
                            authority: vault_authority.to_account_info(),
                            mint: payment_token.to_account_info(),
                            system_program: system_program.to_account_info(),
                            token_program: token_program.to_account_info(),
                            rent: rent.to_account_info(),
                        };
                        let cpi_ctx =
                            anchor_lang::context::CpiContext::new(cpi_program, cpi_accounts);
                        anchor_spl::associated_token::create(cpi_ctx)?;
                    }
```
this is what I found
I've got this Account

```
  #[account(
    init_if_needed,
    payer = creator,
    associated_token::mint = payment_token,
    associated_token::authority = vault_authority,
  )]
  pub token_vault: Box<Account<'info, TokenAccount>>,
```

and I'm looking into the expanded code to see how does it check if the given TokenAccount exist or not so it doesn't create it again
hi guys
I'm having a bit of trouble understanding this error, seems to be caused by the lifetime parameter of the function context?
Trying to set up the program test
```
let program_id = Pubkey::new_unique();
    let (mut banks_client, payer, recent_blockhash) = ProgramTest::new(
        "solbond",
        program_id,
        processor!(create_portfolio),
    )
    .start()
    .await;
```
I get the following 
```
error[E0308]: mismatched types
  --> programs/solbond/src/tests/instruction_tests.rs:43:20
   |
43 |         processor!(create_portfolio),
   |                    ^^^^^^^^^^^^^^^^ incorrect number of function parameters
   |
   = note: expected fn pointer `for<'r, 's, 't0, 't1> fn(&'r anchor_lang::prelude::Pubkey, &'s [anchor_lang::prelude::AccountInfo<'t0>], &'t1 [u8]) -> std::result::Result<_, _>`
                 found fn item `for<'r, 's, 't0, 't1, 't2> fn(anchor_lang::context::Context<'r, 's, 't0, 't1, approve_portfolio_weights::SavePortfolio<'t2>>, u8, u64, u32, u32) -> std::result::Result<_, _> {solbond::create_portfolio}`
```
how can I pass anchor functions into the processor from solana_program_test? 
In anchor I have a function which calls something in another module like so: 
```
  pub fn create_portfolio(
        ctx: Context<SavePortfolio>,
        _bump: u8,
        _sum_of_weights: u64,
        _num_positions: u32,
        _num_currencies: u32,

    ) -> ProgramResult {
        instructions::approve::approve_portfolio_weights::handler(
            ctx,
            _bump,
            _sum_of_weights,
            _num_positions,
            _num_currencies,

        )
    }
```
Use unchecked account then
would like to do it on chain, and the error occurs at #[derive(Accounts)] if the passed account is not to be inited but utilised
You can just getAccountinfo(ACCOUNT_ADDR)
how do i check if the account is initialised and not closed to avoid ```Error: 3012: The program expected this account to be already initialized``` ?
🙏
anchor will handle it for you
na
Then I don't need to specify a `space`
ho nice thanks !
yeah you can
Hello again,

Can I use `init` for a TokenAccount ?
yeah, check the bpf-loader test folder in anchor repo
have aanother quesion:  is there any method to get program upgrade authority in the anchor rust?
https://docs.rs/anchor-lang/latest/anchor_lang/error/enum.ErrorCode.html
thanks,  it is successful, could you tell me where to lookup the error code meaning?
Or is it better to create a `u64` field and just initialize it with `Clock.unix_timestamp` ?
If I create a field in my data account that is declared as `anchor_lang::prelude::Clock` ?
Does the `unix_timestamp` field is fixed at the moment of the creation ?

if I fetch the data account, let says two days later, is the timestamp updated ?
I am wondering how the Clock work in Anchor
Hello 👋
https://solanacookbook.com/references/anchor.html#calculating-account-space-size
thanks
take a loooook at solanacook book ser
thanks, shoud i add "space=" in rust side ? how to add it,  is there any exemple
here you need to add `space=TotalSpaceYouWantToHave` in while initing the account
this occurred cuz you didn't manually specify space
0xa4 => AccountDidNotDeserialize,
when i add mut, it throws err"custom program error: 0xa4", where shoud i lookup the error code meaning.
thanks. i take a try
like this `#[account(mut)]` executor_wihtelist
you need to add `mut`


show your context struct
but find nothing😅

add key like this:

and initialize like this:

i define like this:
hey guys, i want to define a account to store pubkey list，i define  account contain pubkey vector ，and push key through rpc method, tranctions not failed, but the key is not stored in the account, how should i define data sturcture in anchor to store list?
&id()
hey guys, is there any method go get self-programid in anchor?
When I won't set up solana environment, I think the issue is to get provider. ```anchor.setProvider(provider)```.
In the ethereum web3, it is easy like this new web3(new Web3Provider(RPC_URL)) but I am not sure how to get "provider" in case of solana.
Hi, guys. 
Can I call the program only using private key in the backend without set up solana environment on example aws ubuntu ec2?
we are trying to speed up our front end flow as much as possible, we have switched our commitment levels to "processed", parallelized as much as possible in our program. But now we are wondering if it's worth trying to make our instructions faster. It may be a silly question
What makes you think you need to optimize their speed? Do you mean compute usage?
can anybody point me to resources on optimizing speed of my instructions
🥲  I learned this one the hard way lol but it's all working now, thanks for the help!
So if you mess up the order it will fail in weird ways
Maybe easier to just know that the way the isntruction macro works is way less fancy than you might guess, it just *re-parses* the instruction data from scratch, no fancyness
You have to match the order exactly, yeah (sucks, no easy way to fix it though)
So in my actual code I had ```rs
pub fn initialize(ctx: Context<Initialize>,  amount_guranteed: u64, amount_total: u64, post_buffer:Pubkey) -> Result<()> {
``` ```ts
const tx = await program.rpc.initialize( amount_gurantee, amount_total, buffer.publicKey,  {``` Reversing the order  of the parameters to  ```rs
pub fn initialize(ctx: Context<Initialize>, post_buffer:Pubkey, amount_guranteed: u64, amount_total: u64) -> Result<()> {``` ```ts
const tx = await program.rpc.initialize(buffer.publicKey, amount_gurantee, amount_total,  {``` fixed my unauthorized signer issue. Does this just mean the instruction macro requires your parameter to be the first arg in the inputs?```rs
#[instruction(post_buffer:Pubkey)]```
I must have had something somewhere else that was breaking things
huh okay it just seems to be working all of a sudden, my brain hurts but it's okay
Found a solution `const txArray = provider.connection.getSignaturesForAddress(new Publickey("program publickey or nft mint address or any publickey you want")` then `const txdetails = await provider.connection.getTransaction(txArray[0].signature)`
You can send sol to whatever account you want, no restrictions (so, be careful)
Yes
What you have above looks ok to me at first glance, is your declare_id! Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS?
I tried using  the #[instruction()]  to make an inputted public key accesible in the seed.  Then I generated the PDA using keypair generate to create the pubkey and inputed the pubkey for the parameter in initialize. Why is this not the correct signer? I am doing this to try to generate my seeds dynamically
does anyone have experience with compute budget increase request ix not working on devnet
What do you mean by a deployed program account?
```bash
Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account 
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS invoke [1]
    Program log: Instruction: Initialize
    3CXEWQ7WPUCg1xg3BYQ1HomTufKpKokFBa5UWnZv6GdX's signer privilege escalated
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS consumed 10813 of 1400000 compute units
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS failed: Cross-program invocation with unauthorized signer or writable account
    1) Is initialized!```
Could anyone tell me what I am doing wrong here?```rs
    pub fn initialize(ctx: Context<Initialize>, post_buffer:Pubkey) -> Result<()> {
        let contract = &mut ctx.accounts.contract;
        contract.contractor = ctx.accounts.contractor.key();
        contract.post_buffer = post_buffer;
        contract.bump = *ctx.bumps.get("contract").unwrap();
 
        Ok(())
    }```
 ```rs
#[derive(Accounts)]
#[instruction(post_buffer:Pubkey)]
pub struct Initialize<'info> {
    #[account(
        init,
        payer = contractor,
        space = 8 + Contract::MAXIMUM_SIZE,
        seeds = [b"contract_acc", contractor.key().as_ref(), post_buffer.key().as_ref()],
        bump,
    )]
    pub contract: Account<'info, Contract>,
    #[account(mut)]
    pub contractor: Signer<'info>,
    pub system_program: Program<'info, System>
}``` ```rs
#[account]
pub struct Contract {
    contractor: Pubkey,      //32
    bump: u8,                //1
    post_buffer:Pubkey       //32
}``` ```ts
      const buffer = anchor.web3.Keypair.generate();

      const [contractPDA, _ ] = await PublicKey
      .findProgramAddress(
        [
          anchor.utils.bytes.utf8.encode("contract_acc"),
          contractor.publicKey.toBuffer(),
          buffer.publicKey.toBuffer(),
        ],
        program.programId
      );

    const tx = await program.rpc.initialize( buffer.publicKey, {
      accounts: {
        contract: contractPDA,
        contractor: contractor.publicKey,
        systemProgram: anchor.web3.SystemProgram.programId,
      }
    });```
Is it even possible to directly airdrop sol to a deployed program account? I am running into transaction errors every time I try to airdrop with the CLI or use a faucet
thanks that fixed it. i was following this tutorial where it wasn't required https://www.youtube.com/watch?v=Kv1_fZIqLs0 .
add account mutable just above the signer
are you trying to pass in the wrong account type into a zero copy account? There's multiple reasons you could see this error
How can i get my program transactions and decode them ? I want to get tx and get instruction data and decode them. How can i achieve this. Is there any source or tutorial for this ?
error - the payer specified for an init constraint must be mutable
```rust
#[account]
pub struct ConfigAccount{
    has_init : u8,    
    pub authority : Pubkey,    
}

#[derive(Accounts)]
pub struct Initialize<'info>{

    #[account(init,payer = authority,space=48)]

    pub config_account : Account<'info,ConfigAccount>,
    pub stake_account : Account<'info,StakeAccount>,
    pub authority : Signer<'info>,
    pub system_program : Program<'info,System>
}
```
did you figure this out? im wrangling this rn
thanks a ton
okay I see
The way you pass it in from the client is just via its address (the same way you pass in your other `{ accounts: { ... } }` stuff to the rpc call
and when i pass the TokenAccount struct how do i set the address for the TokenAccount? sorry for the noob questions
Is there a good way to optimize transactions that depend on each other?

For example, if I have two transactions, A & B, and B depends on A happening first. The total time for completing both locally (using 'confirmed' commitment) on takes a couple of seconds. However, when I deploy to mainnet, it takes at least 10sec to confirm a single transaction so doing both takes 20 seconds.

I've experimented with 4 different rpc servers: Gensysgo, Quicknode, Solana public endpoint & Serum public endpoint. 

Does anyone have any advice for lowering the latency for multiple subsequent transactions that depend on each other?
In general there's no way to know that—but if you know the account where they'd be storing those tokens, you could pass it in as a `Account<'info, TokenAccount>` and read its `.amount`
how can i know the amount of a particular token an address has using anchor?
```rs
#[account]
pub struct Contract {
    contractor: Pubkey,      //32
    contractee: Pubkey,      //32
    amount_guranteed:  u64,  //8
    amount_total: u64,       //8
    state: ContractState,    //1 + 1
    bump: u8,                 //1
}```
The contract data struct looks like this
```rs
    pub fn initialize(ctx: Context<Initialize>, amount_guranteed: u64, amount_total: u64) -> Result<()> {
        let contract = &mut ctx.accounts.contract;
        contract.contractor = ctx.accounts.contractor.key();
        contract.amount_guranteed = amount_guranteed;
        contract.amount_total = amount_total;
        contract.bump = *ctx.bumps.get("contract").unwrap();
        contract.state = ContractState::Initialized;

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(
        init,
        payer = contractor,
        space = 8 + Contract::MAXIMUM_SIZE,
        constraint = contract.amount_guranteed <= contract.amount_total,
        seeds = [b"contract_acc", contractor.key().as_ref()],
        bump,
        
    )]
    pub contract: Account<'info, Contract>,
    #[account(mut)]
    pub contractor: Signer<'info>,
    pub system_program: Program<'info, System>
}```
I want to include some input as a ref in the seeds but I'm not completely sure how to do that.
How do I generate dynamic seeds?
Yeah, still fails for me when I try 0.1 SOL
Have you tested smaller amounts too?
Any ideas here?
Is my assumption correct that Anchor does not have a native way to expand your program's structs under the `accounts` and `instructions` modules out with `Serialize` and `Deserialize` traits (as that would be bloat for most use cases and those bytes are going on-chain presumably), and that the workaround to this is simply to create a struct that mirrors the program's ones and just slap some `impl From<T>` on them?
I have a question for you guys ! I play a lot with anchor and i know how to store String integer etc but how can i manipulate real SOL. For example stake sol or juste create a smart contract that do something if we pay etc ? I didn't find doc that talk about transaction in smart contract.


///////////////////////////////////////////////////////////////////////////////////////////////

I was thinking, assuming I want to make a decentralized Twitter (I know there is a tutorial but my question is about something else), is it useful to use a PDA?  I saw for example a blog tutorial, and they use PDAs for the articles. I do not see the interest of the PDA for a blog (in their case the blog is a PDA and each article is a PDA too, linked to the blog account
Nope, no network access of any kind (you can't even get a random number lol)
it is possible to do Http request in program ? For example to call api from the exterior?
Ok thanks ! It helped.👍 
Well i don't really understand yet what is happening, but it is working like that :
```    /// CHECK: This is not dangerous because we don't read or write from this account
    pub winner : UncheckedAccount<'info>,```
(i still pass only the pubkey from client as winner 😆 🤣 🙃 )
did you ever figure out how to do this?
The only way to pay an account is by passing it in from the client—there's no possible way to avoid this in solana, just the way things are
<@!134416332509675520>  Ty.
The goal is to retribute one of the 3 players with a gain provided by the authority account (here used as provider).
The game account is the only signer here.
Idealy i'd like to make what you said (remove Player argument), but it doesn't compile...
By the way, i'd also like to feed a pubkey saved with a determinate byte array. How can we do this if we have to pass by Accounts ?
````
    pub fn end_game(ctx: Context<End>) -> Result<()> {

        let game = &mut ctx.accounts.game ;
        game.winner = ctx.accounts.winner.key() ;

        let reward = game.entry_price * (game.rm as u64) ;

        let ix = anchor_lang::solana_program::system_instruction::transfer(ctx.accounts.authority.key, &ctx.accounts.winner.key(), reward) ;
        anchor_lang::solana_program::program::invoke(
            &ix,
            &[
                ctx.accounts.authority.to_account_info(),
                ctx.accounts.winner.to_account_info()
            ]
            ).unwrap();

        Ok(())
    }

#[derive(Accounts)]
pub struct End<'info> {
    pub system_program : Program<'info, System>,
    #[account(mut)]
    pub winner : Account<'info, Player>,
    #[account(mut)]
    pub authority : Signer<'info>,
    #[account(mut, has_one = authority, signer)]
    pub game : Account<'info, Game>
}
#[account]
pub struct Game {
    pub authority : Pubkey,
    pub rm : u8,
    pub entry_price : u64,
    pub players : [Pubkey;3],
    pub winner : Pubkey
}

#[account]
pub struct Player {}

```
bumping this up -- any ideas here?
Can you show me exactly what you tried?
so we know how to use invoke signed if one of the accounts in the list passed is a pda, how would the syntax look like if the list of accounts had more than 2 pdas, ? 
for example ? 
invoke_signed(&randomIX,[pda1.clone,pda2.cone],&[pda_seed1,pda_seed2]) ? is this correct where the type of the pda seed is : &[&[u8]] ?
When i try compilation fail : ```expected 1 generic argument```
oh thanks
`anchor deploy --help`
only command i can find the website is "anchor deploy" but i have seen tutorial with additional arguments like --provider.cluster and --provider.wallet etc. Where can i find more info?
With
```.rs
/// CHECK: don't worry
pub the_account: AccountInfo<'info>
```
anchor deploy with specific key and network?
👍 Nice, it is logic 😅 .
Well my problem is if i send the pubkey in the derived accounts struct  ```Account<'info, Player>```
I receive an error message ```The given account is owned by a different program than expected```
How can we make transaction to an external pubkey ?
I want to try to do an update by myself on a PDA owned account. So I think, since it is the PDA that has the authority, I have to ask it to update for us. So the one who created the PDA for his account, has to send the same seed/bump as for the creation of the PDA and just send this is modifications right?
Probably the general solana discord
Right before the next epoch 🤔 
I don't even know where I can get some help about test-validator
Ah, interesting, not sure then!
I changed `slotsInEpoch` to be equal to 32: an epoch should be like `0.4s * 32 = 12.8s` (roughly). Whether I wait for 20 seconds or 5 minutes, it's stuck on 31 slots.
Aren't epochs like 2 days each?
Here is what I do in integration tests. I wait for 5 minutes:
```ts
console.log('Before', await connection.getEpochInfo());
await new Promise((resolve) => setTimeout(resolve, 300000));
console.log('After', await connection.getEpochInfo());
```
Then what is displayed:
```
Before {
  absoluteSlot: 9,
  blockHeight: 9,
  epoch: 0,
  slotIndex: 9,
  slotsInEpoch: 32,
  transactionCount: 22
}
After {
  absoluteSlot: 31,
  blockHeight: 31,
  epoch: 0,
  slotIndex: 31,
  slotsInEpoch: 32,
  transactionCount: 44
}
```
Do you have any idea why? It won't go through the 2nd epoch, even after 5 minutes.
Heh
needs to sign* 😄
Only the sender needs to receive [edit: lol, sign]
No, no need to sign for the receiver
cqfd (pls post full program log) 
Well, so it is absolutely necessary to add the keypair as signer for the receiver ?
If i pass the pubkey as simple Account, an error message is displayed: 
```The given account is owned by a different program than expected```
Here is the struct:
```#[derive(Accounts)]
pub struct End<'info> {
    pub system_program : Program<'info, System>,
    #[account(mut)]
    pub winner : Account<'info, Player>,
    #[account(mut)]
    pub authority : Signer<'info>,
    #[account(mut, has_one = authority, signer)]
    pub game : Account<'info, Game>
}```
Excellent, thanks
Nope, need to pass it in as an account
I think it's a flat 1500 https://github.com/solana-labs/solana/blob/master/program-runtime/src/compute_budget.rs#L80
`anchor publish` gives `Error: No such file or directory (os error 2)` issue, how to resolve?

```
    Finished release [optimized] target(s) in 4m 45s
cargo-build-bpf child: /root/.local/share/solana/install/releases/1.8.14/solana-release/bin/sdk/bpf/scripts/strip.sh /workdir/docker-target/bpfel-unknown-unknown/release/cyclos_core.so /workdir/docker-target/deploy/cyclos_core.so
cargo-build-bpf child: /root/.local/share/solana/install/releases/1.8.14/solana-release/bin/sdk/bpf/dependencies/bpf-tools/llvm/bin/llvm-readelf --dyn-symbols /workdir/docker-target/deploy/cyclos_core.so

To deploy this program:
  $ solana program deploy /workdir/docker-target/deploy/cyclos_core.so
The program address will default to this keypair (override with --program-id):
  /workdir/docker-target/deploy/cyclos_core-keypair.json
Copying out the build artifacts
Cleaning up the docker target directory
Removing the docker container
anchor-program
Extracting the IDL
Writing the IDL file
Writing the .ts file
Build success
Error: No such file or directory (os error 2)
```
The build succeeds, something breaks after. On Anchor v0.23.0
my b
easy to find
only 3k lines
thanks!
lol literally had that file open
missed it
i was reading repo :/
the repo is the absolute source of truth
```
    // Copy the binary out of the docker image.
    println!("Copying out the build artifacts");
    let out_file = cfg_parent
        .canonicalize()?
        .join(format!("target/verifiable/{}.so", binary_name))
        .display()
        .to_string();
```
rather than target/deploy
it's in target/verifiable
oh crap i found it
so maybe something to find in target/ ??
by the look of the code
workdir is inside the docker
but it goes away at the end
there is a docker-target temporarily
nothing there :/
maybe even .anchor ?
look in the root of the current project
when you build --verifiable, it says the binary is going to /workdir. but i have no /workdir when i try to go find it? anyone know where it goes
How can I read get an account's owner when I only have the Pubkey?
Hi, I'm trying to do a similar thing to you and wondering how did you set up the project and where is the tests module located relative to lib.rs? I can't access ```projname::instruction``` or ```projname::accounts```  since it tells me that those are private...
https://discord.com/channels/889577356681945098/889889146087301151/959040989794799616
Is this a bad usage of init_if_needed ? <:think:340844434377932800> 

Heard a bunch of times that its not used correctly etc So i wonder what is the correct way 😄
const provider = new anchor.Provider(connection, anchorWallet);
you need to pass the winner account from the client itself, like
```
#[derive(Accounts)]
pub struct End<'info> {
    pub system_program : Program<'info, System>,
    #[account(mut)]
    pub authority : Signer<'info>,
    #[account(mut, has_one = authority, signer)]
    pub game : Account<'info, Game>
    pub winner: AccountInfo<'info>,
}
```
and then do 
`ctx.accounts.winner.to_account_info(),`
hey guys,
is there anyway for creating anchor.provider without Anchor.toml in .ts file?

i see this:

const idl = await anchor.Program.fetchIdl(EVENT_PROGRAM, anchor.Provider.env());

    const program = new anchor.Program(idl, EVENT_PROGRAM, anchor.Provider.env());

but the problem is anchor.Provider.env() that probably include wallet and cluster
Hello, 
Can we make a CPI transfer of sols to a Pubkey passed as argument in a transaction ?
```
    pub fn end_game(ctx: Context<End>, winner : Pubkey) -> Result<()> {

        let game = &mut ctx.accounts.game ;
        game.winner = winner ;

        let ix = anchor_lang::solana_program::system_instruction::transfer(ctx.accounts.authority.key, &winner.clone(), 1000000) ;
        anchor_lang::solana_program::program::invoke(
            &ix,
            &[
                ctx.accounts.authority.to_account_info(),
                //...how can i put account_info from winner Pubkey ?
            ).unwrap();

        Ok(())
    }
#[derive(Accounts)]
pub struct End<'info> {
    pub system_program : Program<'info, System>,
    #[account(mut)]
    pub authority : Signer<'info>,
    #[account(mut, has_one = authority, signer)]
    pub game : Account<'info, Game>
}

```
Mostly you want to check which program owns an account, whether the discriminator is correct / it can be deserialised into the correct account struct and that the pubkey of the account matches with some other check (whether seeds or the pubkey stored on another account)
Hmm, so there's no way around that. Got it. Will recreate the checks and post here to make sure I got them right. Thank you!!
Basically you have to manually recreate all the validation checks
For anchor accounts
`try_from`
You would have to do all the checks manually
I have, the answers were around `remaining_accounts`, but with remaining accounts I can't run the Anchor checks.
Discord search "optional accounts"
Have you tried discord search?
What would be the best way to support passing an optional account in the context?

Which we also wanna potentially have Anchor checks upon in case it was passed (that it’s a MintAccount etc etc.).
Thanks!
Ah ok, that's interesting. I didn't realise the compute usage was seed length dependent
I meant that I had the benchmark for `createProgramAddress(&[pk1, pk2], programPk)` - a longer seed should cost more compute, but don't know how much more
How do I have optional accounts in the context?
Is this for two seeds checks or a seed that has two pubkeys in it? I wouldn't have thought the length of the seeds affected the number of CUs but maybe it does?
What do you mean by "a two pubkey seeds"?
Something like 1700 cu for a two pubkey seeds
<@887234715940175895> I remember you added the pr for reducing the number of findProgramAddress calls. Do you remember how much a single `createProgramAddress` call costs in compute units?
Does anyone know how many compute units it costs to run create program address to validate a seed, once you already have the bump
Implements a standard process method on the accounts struct that then gets called in the instructions in lib.rs
Here's another setup https://github.com/metaplex-foundation/metaplex-program-library/tree/master/fixed-price-sale/program/src
Thanks! This is kind of overly repetitive though. We're repeating the same type definition between the instruction method signature defined in the program and then repeating it again in the file which implements the instruction
https://book.anchor-lang.com/chapter_3/milestone_project_tic-tac-toe.html#program-directory-organization
anyone could help me with this problem?
Ideally I'd be able to implement the program as some struct then have different traits for each set of instructions i want to separate
i agree with you
I saw this happens in the gem farm repo, but noticed that we need to repeat the type information for instructions in both the program and the module which seems unnecessary
What's a good canonical example of separating an anchor program's instructions & state into multiple rust modules (multiple files for better organization)?
ok, this occured on oldish anchor 0.18
yes, this is the way
we added a runtime check some versions ago that returns an error when running the program and the program_id doesnt match the crate::ID for this reason. was that not thrown?
thanks - I built the binaries from source and put them in the folder. If I didn't have the source are the `.so` files the data from the accounts? i.e, could I fetch the accounts from on chain and save the data to disk?
is there any other method derectly get  upgrade authority other than upload a account type(ProgramData)
does the anchor-lang 0.17.0 i usde not have this type?
but my viscode throw error :"cannot find type `ProgramData` in this scope"
#[account(constraint = program_data.upgrade_authority_address == Some(authority.key()))]
    pub program_data: Account<'info, ProgramData>,
the way to get it like this:
hey guys, I tried to  get program upgrade authority in the anchor rust? and see this ducument: https://github.com/project-serum/anchor/blob/master/tests/bpf-upgradeable-state/programs/bpf-upgradeable-state/src/lib.rs
so need to change mint authority to PDA. right?
You don't want the mint authority to literally be a program_id, you want it to be a program-derived address derived from that program_id—that way the program can sign for the PDA
When `mint authority` is a program itself, how should `signer_seeds` look like to call `mint_to` instruction in the program?
https://github.com/solana-labs/solana-program-library/tree/master/token-lending/program/tests look at this folder
+ 
```
    pt.add_program(
        "serum_dex",
        anchor_spl::dex::ID,
        None,
    );
```
example for the serum dex
add the binaries to tests/fixtures then add them to program test
we do
How about switching the default pk of a program to Defau1T11111111111111111111111111111 more obvious this has to change
and having a warning on build? Got yet another beginner fall into the trap
is anybody testing with `solana-program-test`? I'm trying to figure out how to add programs from devnet that my program cpi's to.
```
error: Error: Transaction was not confirmed in 180.00 seconds. It is unknown if it succeeded or failed. Check signature 3oF1W2ox52ubkfNebqrxguBE9WJYYkJfA3FohqU1h1BkNM1ct3SAA262tkotGzfgtVBqhjhX2dCgsMUBSwDMiFug using the Solana Explorer or CLI tools.
```
I am consistently getting timeout errors when sending txns to solana. Not an anchor specific question, but what are people doing to get around this? just setting really long timeouts?
everything working fine now, thanks again
ok I understand better
no it's the account of the rent sysvar. the token account is the one that needs to get rent because it is newly created. inside the framework, anchor will use the `rent` sysvar to calculate how much rent. all you have to do is pass the sysvar into the call on the frontend
Thanks a lot and sorry to bother.

I am slowly increasing my understanding of Solana and that only thanks to amazing people like you.

If I understand well the `SYSVAR_RENT_PUBKEY` points to the account that will receive the rent, is that correct ?
https://solana-labs.github.io/solana-web3.js/modules.html#SYSVAR_RENT_PUBKEY
no. I mean the rent sysvar itself
I am having a hard time finding anything about what you mention in the doc.
I am fairly new to rust and anchor, maybe I just don't know where to look.

I am using `docs.rs`, `typedoc`, the `anchor book`, and the `solana cookbook`

But basically, do you mean that I need to provide the account from which the rent will be paid?
I though that would be the account from `payer =`
oh in the frontend you add the rent account pubkey. look in the web3 docs. or use the anchor program.methods builder api which will infer it for you
So from my exemple earlier, I add `rent` as follow? :
```rust
  #[account(
    init,
    token::mint = mint,
    token::authority = user,
    payer = user,
    seeds = [
      b"vault_ata",
      user.key().as_ref(),
      mint.as_ref(),
    ],
   bump
   )]
   pub account_to_create: Account<'info, TokenAccount>,
   pub rent: Sysvar<'info, Rent>,
   pub system_program: Program<'info, System>,
   pub token_program: Program<'info, Token>,
```
Ok then there is something I miss there.
If I add a `rent` field in the strcut, then I must provide a value in the frontend isn't it ?
no need anchor will handle the accounts creation for you and the `payer = ` will pay for the rent
Thanks 🙏 
On the frontend side then I should use `getMinimumBalanceForRentExemptAccount` ?
add `rent: Sysvar<'info, Rent>` as an account
So I have been trying to make it work since earlier and I have some difficulty.

here the macro I used
```rust
  #[account(
    init,
    token::mint = mint,
    token::authority = user,
    payer = user,
    seeds = [
      b"vault_ata",
      user.key().as_ref(),
      mint.as_ref(),
    ],
   bump
   )]
   pub account_to_create: Account<'info, TokenAccount>,
```

But I am getting the following error
`error[E0425]: cannot find value 'rent' in this scope`

There is no information on the doc about a `rent` field
The account should be rent exempt by default isn't it ?
sometime ago I found the webpage that was listing all the macro available while creating accounts (*init, init_if_needed, seeds)* But I can't find it anymore.
ok, then I will use a seed, I don't have problem with that. thanks 🎉
Look at other examples of anchor programs that create an account, you'll see that you always have to pick the address from the client
This is how all account creation works on solana: you have to pick the address at which the account will live
Or you could use an associated token address, etc., but then you'd need to use `associated_token::mint = the_mint` etc.
Yes I though too, but how can I have the address before creating it ?
You can use whatever kind of address you want (if you use findProgramAddress you'd need to also use the `#[account(..., seeds = [....], bump)]` attributes too though)
The address of the token account that you're about to create
should I use `findProgramAddress` ?
Thank you, which address whould I use then ?
And then just pass it as a normal account (an address) from the frontend
Yes, `#[account(init, token::mint = the_mint_account, token::authority = the_owner, payer = the_payer)]`
If yes, then how do I pass the information from the frontend ?
```rust
#[derive(
    AnchorSerialize,
    AnchorDeserialize,
    FromPrimitive,
    ToPrimitive,
    Copy,
    Clone,
    PartialEq,
    Eq
)]
pub enum Sign {
    FIRST,
    SECOND,
}
```

That should be all you need
Does anyone know if the Metaplex Storefront Auction program (not the AuctionHouse, but just the single Auction) is moving to anchor soon? Alternatively, is there english auction implementation in anchor?
I wanna have an `enum` in an account, but Anchor is telling me I don't have `AnchorSerialize` and `AnchorDeserialize` implemented. Do I have to write it on my own?


///////////////////////////////////////////////////////////////////////////////////////////////

Does this improve CU also?  I'm not worried about program size in my case, but I can always use CU enhancements!
i've used it for several contracts to reduce deployable sizes and havent had any issues but was curious if there was the possibility that i just hadn't run into yet
`lto` is for link-time optimization and `opt-level`  with `z` is size based optimization without loop vectorization so its interesting that it would cause stack issues 🤔
I actually don't know—it does seem to make the code smaller, but I'm guessing on avg it uses more compute etc.? I tried doing that on the drift repo and got a bunch of stack space errors.
<@!134416332509675520>  on the topic of deployable sizes...are they any concerns with using
```toml
[profile.release]
lto = true
opt-level = "z"
```
for size optimization?
Yeah, sounds pretty normal. Larger programs can easily be 1mb+.
What is a "typical" size `.so` to you guys? Seems like I personally end up between 250-350KB, but no clue if that's normal, or way high, or what.
Yeah, seems like it transcends what JSON can do hahahaha
I think it just wouldn't
How even in principle would the IDL handle things like this that show up e.g. in SPL Name Service:
```
    // ... AccountMeta list...
    ///   4. `[signer]` Account class (written into `NameRecordHeader::class`).
    ///                 If `Pubkey::default()` then the `signer` bit is not required
```
So i am messing around with the basic example here, adding more variables id like to mess with:
```rust
#[account]
pub struct MyAccount {
    pub counter: u64,
    pub min: u64,
    pub max: u64,
}
```
But when running any RPC command in the client JS I am getting:
`Error: 3003: Failed to deserialize the account`

----- fixed ------

So here I just forgot to increase the `space` property on the `account` Outer Attribute:
```#[account(init, payer = user, space = 8 + 8 + 8 + 8)]```
Oh you're right, my bad! I instinctively just went up a level instead of reading the actual source code you linked me to! haha! Much appreciated.
Isn't that this? https://github.com/project-serum/anchor/blob/master/ts/src/spl/token.ts#L21
Ah, this looks like Typescript clients, which is useful but not quite what I'm looking for. I'm looking for IDL JSON files for SPL, either hand-rolled or parsed from a replica.
Amazing thank you!
No, but this is: https://github.com/project-serum/anchor/tree/master/ts/src/spl
Is that what this is? https://github.com/project-serum/anchor/tree/master/spl  Edit: No, appears that's just CPI clients, doesn't seem like I can parse an IDL from these.
Would be nice to be able to interact with them that way.
Has anyone encountered something like a set of IDLs for the SPL programs?
We push to prod on Fridays 🚀 #SvelteJS wallet adapter for #Solana.
https://github.com/svelte-on-solana/wallet-adapter

or you could do something clever with ASS stack
Nope, only advantage is stack pressure. The disadvantage is that it uses at least a bit more compute units.
Ohh, Okay <@!134416332509675520>, Thanks
Only by passing that account into your program from the client (this is just how solana works, not possible to dynamically look up an account based just on its Pubkey)
It's owned by your program if you use `#[account]` on top of its struct.
any one
Hi guys, How can I read and parse account from a ``Pubkey`` inside the program code using Anchor?
How to deploy the project to custom cluster?
Hi, I wonder if one should always use Box<Account<XYZ>> instead of Account<XYZ>?
What would be a good practice in this field?
Assuming that we dont have any problems with exceeded stack size - are there any advantages in using boxed accounts?
getting this error when using CpiContext ```mismatched types
expected struct `anchor_lang::context::CpiContext<'_, '_, '_, '_, Initialize<'_>>`
   found struct `anchor_lang::context::Context<'_, '_, '_, '_, Initialize<'_>>`
```
Not seeing that I have any buffers to close though unfortunately
that makes sense. Is there a way to know which accounts are owned by the program? Like is an account is initiated during function call, that would be owned by the program?
That happens here, in `send`: https://github.com/project-serum/anchor/blob/master/ts/src/provider.ts#L109
When developing the client, can someone explain where the signed transaction comes from. How does the front end know to ask for the phantom wallet, for example
Hi Nithsua. Did you ever figure this out?
It depends on whether the account that lives at that PDA is owned by the system_program (just because the *address* is program-derived from your program doesn't mean the *account* there is owned by your program—it could be owned by the system program)
Hi - Can someone please explain how this example works? Given the fact that we cannot use system_instruction::transfer to transfer SOL from a PDA to another wallet because the system program does not own the PDA.
```invoke_signed(
    &system_instruction::transfer(
        &pda_account_info.key,
        &to_account_info.key,
        100_000_000, // 0.1 SOL
    ),
    &[
        pda_account_info.clone(),
        to_account_info.clone(),
        system_program_account_info.clone(),
    ],
    &[&[b"escrow", &[bump_seed]]],
)?;```

This example is from the solana cookbook https://solanacookbook.com/references/accounts.html#program-1
for this specific example
if you go to 0 + some other bytes but that also matches a sighash
how do you get a collision?
<@!501570363566587905> Writing first program in a while for Step; using `0.22.1` and anchor feature `seeds = true`.  **Absolute game changer for front end peeps**, my unit tests are so clean!  Kudos to you dude.
i don't think there is any solution to that except not using both at the same time. Maybe compiling from a local anchor branch which removes the other one
```
    pub fn default<'info>(
        program_id: &Pubkey,
        accounts: &[AccountInfo<'info>],
        data: &[u8],
    ) -> ProgramResult {
        msg!("DEFAULT HANDLER");
        let method = data[0];

        let mut new_data = vec![0; 8]; // DUMMY sighash that doesn't seem to be verified below
        new_data.extend(&data[1..]);
        match method {
            0 => {
                __private::__global::the_other_method(program_id, accounts, &new_data)?
            },
            // ...
            _ => (),
        }

        Ok(())
    }
```
Armani if you are interested, i managed to use the default instruction handler to create shorter ix routing and route back to another existing method.
The problem is that since the routing with sighash occurs before and is longer, you can get a collision and end up routing through the wrong method 😒
ditto..
Ah, whoops, I didn't source-dive quite as far as I needed too 😛 Missed the skip-lint option
bingo. thank you.
or build/test with --skip-lint
sure, but several 100 area's to add this id rather automate if possible. I respect the addition, and definitely want to address them. Didnt realize id be forced to right away.
Or like, `/// CHECK: TODO`
Can you not just add `/// CHECK` in a bunch of places?
after the latest upgrade I will have many of these errors: 
Please add a `/// CHECK:` doc comment

is there something I can do temporarily to disable the error until I can address them all?  global disable/enable?  it will take some time but I dont want it to prevent me from testing as I go..
👋 Why does Phantom sometimes show balance change previews and sometimes do `Transaction may fail to confirm`?
king
Yeah seems to be the usual 10mb: https://github.com/solana-labs/solana/blob/master/programs/bpf_loader/src/lib.rs#L622
Definitely not very much, no
hm so the max account size. Is there any metadata added from BPFLoader?
Ok. I would like to have it all in the program, but I thought there was some restriction on creating accounts
I'm going to guess 10mb, though I'm actually not sure 👀
Yeah, very interesting—compiler bug seems plausible. cc <@!679373976677384204> in case you're interested
What is the maximum size a program can be?
Solana compiler bug seems to fit all the facts I've seen, but I didn't think that was likely
yea he did. It was a similar error. I have no idea where this is coming from. Maybe it's an internal solana bpf compiler bug. There's no code in the code base that sets the line of `Source` but not the filename
<@!448034961652449283> didn't you run into an error like this before?
hello, how would you transfer a custom token from one wallet to a PDA using smart contracts?
Unfortunately the repo is private right now
Relevant code:
```...
 let retval3 = dispatch(program_id, accounts, data);
 msg!("try_entry returning, {:#?}", retval3); 

..
Relevant lines of dispatch

            let retval2 =
                __private::__global::create_stake_account(program_id,
                                                          accounts, ix_data);
            if retval2.is_err() {
                anchor_lang::solana_program::log::sol_log("arm Err");
            }
            return retval2;
...



Last lines of __private::__global::create_stake_account:

            let retval1 = accounts.exit(program_id);
            if retval1.is_err() {
                anchor_lang::solana_program::log::sol_log("A.exit Err");
            } else {
                anchor_lang::solana_program::log::sol_log("A.exit not error!");
            }
            retval1
```
Generates these logs:
```
> Program log: Ix complete
> Program log: Exiting
> Program log: Done Exiting
> Program log: A.exit not error!
> Program log: arm Err
> Program log: try_entry returning, Err( AnchorError( AnchorError { error_name: "", error_code_number: 0, error_msg: "", source: Some( Source { filename: "", line: 528, }, ), account_name: None, }, ), )
> Program log: AnchorError thrown in :528. Error Code: . Error Number: 0. Error Message: .
> Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS consumed 97278 of 200000 compute units
> Program returned error: custom program error: 0x0
> Runtime error: Unknown instruction error
```
Mm... interesting. Is your code on github? I'd be curious to poke around
I started digging into the anchor source to try to narrow down what's going on. I can see that __private::__global::create_stake_account returns the value of accounts.exit(program_id) which is not an error.
However, if I check the line that calls that (in the big match statement with the instruction hashes), it is an error!
Hi,
I'm struggling to debug a very strange error. When I change one field in an account from u64 to Option<u64> (and change the size accordingly), it causes an instruction to fail with error code 0.
    AnchorError thrown in :528. Error Code: . Error Number: 0. Error Message: .
The strange thing is that the instruction ends with:
        msg!("Ix complete");
        Ok(())
And I see "Ix complete" in the logs, so I don't understand how it is failing. The only other instruction in the transaction is a System Program: Create Account (which succeeds).
after changes ?????
cavid@linux:~/Desktop/mylagrangedapp$ anchor test
BPF SDK: /home/cavid/.local/share/solana/install/releases/1.7.12/solana-release/bin/sdk/bpf
Running: rustup toolchain list -v
Running: cargo +bpf build --target bpfel-unknown-unknown --release
    Finished release [optimized] target(s) in 0.41s
Running: /home/cavid/.local/share/solana/install/releases/1.7.12/solana-release/bin/sdk/bpf/dependencies/bpf-tools/llvm/bin/llvm-readelf --dyn-symbols /home/cavid/Desktop/mylagrangedapp/target/deploy/mylagrangedapp.so

To deploy this program:
  $ solana program deploy /home/cavid/Desktop/mylagrangedapp/target/deploy/mylagrangedapp.so
The program address will default to this keypair (override with --program-id):
  /home/cavid/Desktop/mylagrangedapp/target/deploy/mylagrangedapp-keypair.json
Deploying workspace: https://api.testnet.solana.com
Upgrade authority: /home/cavid/.config/solana/id.json
Deploying program "mylagrangedapp"...
Program path: /home/cavid/Desktop/mylagrangedapp/target/deploy/mylagrangedapp.so...
Error: Dynamic program error: No default signer found, run "solana-keygen new -o /home/cavid/.config/solana/id.json" to create a new one
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }.
does someone else is getting problem with Devnet and Testnet? trying to connect wallet?
Pretty sure you can technically do all of those from within your program, I guess, though I'm not very familiar with NFT stuff
<@!134416332509675520> any thoughts on this?
Check that your wallet looks right in your Anchor.toml
Help ????
I'm looking at making a program that mints an NFT, but i understand some items likely need to be done on the client first. I haven't seen an anchor solution to mint an NFT so I have some architectural questions that maybe someone can help me with.

Which steps can be done through my program vs which have to be done on the client?

create token
create token account
mint nft
disable mint
register metadata


///////////////////////////////////////////////////////////////////////////////////////////////

Howdy devs - what are the trade-offs with **boxing** vs **zero copy**? 
I can relieve the stack by putting my accounts in a `Box` - or I can make them "zero copy".  Why should I prefer one over the other?
Where should I look to find the options available in Anchor.toml? I was looking for how to clone accounts and found discord messages about `test.clone` but not sure how to find more of this info in the future
Aha, interesting
borsh = { version = "0.9.1", features = ["const-generics"] } in cargo.toml works
Hi, I have an account
```

#[account]
#[derive(Default)]
pub struct BufferAccount {
    buffer: [u8; SIZE_A * SIZE_B],
    bump: u8,
}
```
and I'm getting the error
```
^^^^^^^^^^ the trait `BorshDeserialize` is not implemented for `[u8; 320]`
```
Are arbitrary array sizes impossible?
is there a simple Anchor way of declaring a constant that is accessible both in Rust and in JavaScript? Say a magic number, e.g. conversion factor, that is used both client-side and on-chain.
solved it!
trying `space = 8 + std::mem::size_of::<MPoolAccount>()` instead now
**Am I initializing an account with wrong space? I keep recalculating it over and over again but get the same number**

Error when calling anchor instruction: `Program log: panicked at 'from_bytes_mut>SizeMismatch'` 

```
    #[account(
        init,
        seeds = [pool_seed.as_bytes()],
        bump = pool_bump,
        payer = authority,
        space = 8 + 4 + 4 + 4 + 8 + 4 + 4 + 8 + 4 + 20 + 20 + 20 + 20 + 40 + 4 + 4 + 4 + 4 + 4 + 4
    )]
    pub mpool_acc: AccountLoader<'info, MPoolAccount>,
```

the account struct (note that I'm using zero_copy if that's somehow broken with anchor v0.20.1):

```
#[account(zero_copy)]
pub struct MPoolAccount {
    // 8 + 4 + 4 + 4 + 8 + 4 + 4 + 8 + 4 + 20 + 20 + 20 + 20 + 40 + 4 + 4 + 4 + 4 + 4 + 4
    pub version: u32,
    pub id: u32,
    pub lp_mint: Pubkey,
    pub lp_balance: u64,
    pub controller: Pubkey,
    pub is_finalized: u32,
    pub created_at: i64,

    pub num_mints: u32,
    pub mints: [Pubkey; 5], // Max tokens in a pool
    pub token_accounts: [Pubkey; 5], // PDA holding pool balance for the mints
    pub weights_num: [u32; 5],
    pub weights_denom: [u32; 5],
    pub balances: [u64; 5],

    pub swap_fee_num: u32, // Fees must be between 0.0001% and 10%
    pub swap_fee_denom: u32,
    pub exit_fee_num: u32,
    pub exit_fee_denom: u32,
    pub owner_fee_num: u32, // Charged as a % of swap fee
    pub owner_fee_denom: u32,
}
```

Anchor v0.20.1
Looking at it. I think you’re passing an array instead of a function somewhere. Try breakpoints to see what values you’re sending
show an example, it's easier that way
Any ideas on how I would do this? I am thinking I initialize a copy in a cross program master for this. Any way to prevent that redundancy
I have an account that looks like this:
#[account]
pub struct ReportAccount {
    pub uri: String,
    pub authority: Pubkey,
    pub reportstatus: u8,
    pub votestatus: u8,
}

I want the program that initializes this to have access to the first 3 line items. The votestatus would be updated via a separate program only, this program would be handed ownership of to our governance.
exceeded max offset
Any other way to get the sol on devnet?
Unable to get airdrop on devnet. Keep getting that it is rate limited although this is the first time in 2 days that I pinged the devnet rpc. Besides, other requests are working. Just airdrop is not working.
`getOrCreateAssociatedAccountInfo` has been replaced by `getOrCreateAssociatedTokenAccount`?
How can one ensure that two instructions (both of them in my own program) can absolutely not be called in one transaction successfully?
the anchor docs specify that InstructionData trait calculates instructionData as `Sha256(<namespace>::<method_name>)[..8] || BorshSerialize(args)`, what is the namespace here?
Hello. I am trying to transfer tokens through token cpi. The authority of the token account is a pda. I keep getting an  insufficient funds error that makes the transaction fail.
Anchor just ru-runs the rust equivalent, `Pubkey::find_program_address` using the provided seeds
How does anchor figure this out for you? I've noticed you calculate out the PDA like so:
```
const [escrowedMakerTokens, escrowedMakerTokensBump] = await anchor.web3.PublicKey.findProgramAddress(
      [offer.publicKey.toBuffer()],
      program.programId
);
```
Then you pass it through to the rpc call
```
await program.rpc.make(
      escrowedMakerTokensBump,
      new anchor.BN(100),
      new anchor.BN(200),
      {
        accounts: {
          offer: offer.publicKey,
          offerMaker: program.provider.wallet.publicKey,
          offerMakersMakerTokens: offerMakersMakerTokens,
          escrowedMakerTokens: escrowedMakerTokens,
          makerMint: makerMint.publicKey,
          takerMint: takerMint.publicKey,
          tokenProgram: spl.TOKEN_PROGRAM_ID,
          rent: anchor.web3.SYSVAR_RENT_PUBKEY,
          systemProgram: anchor.web3.SystemProgram.programId,
      },
      signers: [offer]
});
```
but this latest anchor change removes the first arg, `escrowedMakerTokensBump` and things still work fine?
Is there any reference/example on how to simulate a transaction using rust anchor client ? Something like `program.simulate.<method_name>` in anchor ts
is there a way to pass an unitialized account to a function so that it then calls an instruction to initialize the account later?
thank you as always, you are more helpful than you know
because I was not thinking, it shouldn't have been unchecked
Mm, why are you `init`ing an UncheckedAccount in the first place? Not actually sure that even works
the expected , comple time error is still there though
than you sir
im a moron
over the init
You wrote init twice
```expected `,`rustc````
getting compile time error
You have to somehow say how much space to `init`.
Oh, maybe because you didn't specify how much space to init there
Ah, I mean in an account struct, not a `derive(Accounts)` thing
yes
Are you trying to store a UncheckedAccount inside of a struct or something?
any ideas?
getting a compile time error
```
no function or associated item named `default` found for struct `anchor_lang::prelude::UncheckedAccount<'_>` in the current scope
function or associated item not found in `anchor_lang::prelude::UncheckedAccount<'_>`
```
nvm found this: https://book.anchor-lang.com/chapter_3/the_accounts_struct.html#using-accounta-t-with-non-anchor-program-accounts for anyone else looking
does anyone know of a good resource/example of including accounts created by non-Anchor programs within an Anchor program? specifically wondering about how to handle accounts that don't use Borsh to serialize
Oh, weirdly there was a "no-idl" entry in my Cargo.toml. Removed it and now I'm getting the file generated again. Problem solved.
'anchor build' is no longer generating an json IDL file in target/idl but was earlier. Build completes successfully. Has anyone seen this before? Any way I can force it to generate the IDL file?
Is it possible to easily deserialize a `zero_copy` account in ts using anchor?  Having some problems, assuming because `repr(packed)`


///////////////////////////////////////////////////////////////////////////////////////////////

Has anyone see this issue when making a custom program call on NodeJS?
```TypeError: unexpected type, use Uint8Array
    at checkArrayTypes (/Users/kvishnu/Documents/Crypto/anchorTutorial/frcnt/node_modules/tweetnacl/nacl-fast.js:2165:13)
    at Object.nacl.sign (/Users/kvishnu/Documents/Crypto/anchorTutorial/frcnt/node_modules/tweetnacl/nacl-fast.js:2269:3)
    at Function.nacl.sign.detached (/Users/kvishnu/Documents/Crypto/anchorTutorial/frcnt/node_modules/tweetnacl/nacl-fast.js:2290:24)
    at /Users/kvishnu/Documents/Crypto/anchorTutorial/frcnt/node_modules/@solana/web3.js/lib/index.cjs.js:2749:55
    at Array.forEach (<anonymous>)
    at Transaction._partialSign (/Users/kvishnu/Documents/Crypto/anchorTutorial/frcnt/node_modules/@solana/web3.js/lib/index.cjs.js:2748:13)
    at Transaction.partialSign (/Users/kvishnu/Documents/Crypto/anchorTutorial/frcnt/node_modules/@solana/web3.js/lib/index.cjs.js:2739:10)
    at /Users/kvishnu/Documents/Crypto/anchorTutorial/frcnt/node_modules/@project-serum/anchor/dist/cjs/provider.js:82:16
    at Array.forEach (<anonymous>)
    at Provider.send (/Users/kvishnu/Documents/Crypto/anchorTutorial/frcnt/node_modules/@project-serum/anchor/dist/cjs/provider.js:81:14)```
i could also try and prepend the init instructions in all of the txs, but I'm afraid they'd error out since the accounts will already be initialized after one of the txs goes through
bulk nft stake
sometimes more
200
How many instructions are you talking about?
You can't jam them into one of the other txs?
would be nice if I could just cram everything into 1 tx
and it's a little awkward having 1 tx for those instructions, waiting for that to finish, then sending all the rest
also I have 1 set of instructions (init some accounts) which need to run before all the others
yeah. I can sign multiple transactions in a single request to a wallet, but it seems when i sign multiple then Phantom stops showing balance change previews which is unfortunate
So from the client's perspective you just can't jam all that many distinct instructions into that little space
I see
I don't think there's an actual strict limit there, the real limit is that the entire tx can only take up 1232 bytes
Yeah, that's saying "you had this many compute units remaining, and you used all of them"
Do you happen to know the instruction limit per transaction?
thanks i think it makes sense
so i can have 21769 instructions per instruction 😂
That's actually about compute units
Nope, the use of "instructions" there is a different meaning than than the other one (lol, solana)
Is this true? That I can have 21769 instructions per transaction?
I think someone is eating 🦀
yeah same
Same with testnet
seems like devnet is having issues. Unable to deploy. Keep getting error Invalid blockhash
Thanks
anchor deploy --provider.cluster https://api.devnet.xyz.com
if you worked with anchor a few versions back prior to the avm you most likely have an NPM version installed on your system
<@!831450660146642974>
I formerly had to run the NPM uninstall anchor command(due to conflicts); restart the machine, then default to the avm to update to the latest with "avm install latest" then "avm use latest" then "avm list" which confirmed the version; then upon restarting the terminal didn't encounter more issues. Occasionally yarn will report it is not installed but everything works and builds and deploys fine. Maybe just run a quick 'anchor build' then 'anchor test' to see if it actually generates any errors(I do not know why the yarn error results but it has not been relevant for me"
the version listed in Cargo.toml lines up with the version of anchor i have installed
you mean the lib.rs file created by running init?
where did you get your lib.rs code that created the original error?
Mind the anchor.lang version in the cargo.toml under the programs folder
?
I encountered the same responses but it had no effect.
i have yarn installed
yet gives me that error
like it creates the anchor project folder and adds all the files
ok that worked but now when i run 'anchor init <project name>' it tells me ```Error: yarn install failed: program not found``` but then still sets everything up
I have created my own instance of solana running on a server and set a domain to point to it. How can I direct anchor to deploy to this? How can I edit the provider settings in Anchor.toml to point to this?
oh i see
now it's 556 size account
just in case u want to know the solution, i added repr(packed) to my account

```
#[account(zero_copy)]
#[repr(packed)]
pub struct MyAccount {....}
```

i guess anchor 0.20.1 uses repr(c) which is different and added padding
looks like some random padding is being added somewhere
ok
so 556 includes the 8 byte disc  already
`8 + 4 + 32 + 32 + 8 + 32 + 4 + 8 + 4 + (32*5) + (32*5) + (4*5) + (4*5) + (8*5) + (4*6)` = **556**
4 bytes missed somewhere?
8 bytes for the discriminator of the account
thanks, and based on these:

u32 = 4 bytes
Pubkey = 32 bytes
u64 = 8 bytes
i64 = 8 bytes

now i'm getting 556 instead of 568 total (wonder where the remaining 12 bytes are missing)
if u want to enable it
in one of the latest anchor version i think they hid init_if_needed behind a feature flag, details in their release notes
i just decided to use init_if_needed to make it easier
this makes things tricky
hm
and only if you're aware of the risk
i've read that it is recommended not to use init_if_needed for security reasons
i recall mine failing when using init, but using `init_if_needed` will be idempotent
or would a repeat call fail since the account is already initialized?
Are init contract calls idempotent?
`pub struct Pubkey(pub(crate) [u8; 32]);`
thanks
oh woops
32 bytes per pubkey
Pubkey = 4 bytes right? (32/8)
`space = 8 + std::mem::size_of::<MyAccount>()`

I'm using this to calculate space but it's creating an account with byte size = 568 (checked devnet explorer)

When I look at the struct I count way less than 568 bytes, like < 200 bytes only

What's going on?

```
#[account(zero_copy)]
pub struct MyAccount {
    // 8 + 4 + 4 + 4 + 8 + 4 + 4 + 8 + 4 + 20 + 20 + 20 + 20 + 40 + 4 + 4 + 4 + 4 + 4 + 4
    pub version: u32,
    pub id: Pubkey,
    pub lp_mint: Pubkey,
    pub lp_balance: u64,
    pub controller: Pubkey,
    pub is_finalized: u32,
    pub created_at: i64,

    pub num_mints: u32,
    pub mints: [Pubkey; 5],
    pub token_accounts: [Pubkey; 5],
    pub weights_num: [u32; 5],
    pub weights_denom: [u32; 5],
    pub balances: [u64; 5],

    pub swap_fee_num: u32, 
    pub swap_fee_denom: u32,
    pub exit_fee_num: u32,
    pub exit_fee_denom: u32,
    pub owner_fee_num: u32,
    pub owner_fee_denom: u32,
}
```
E.g the npm one
You may not actually be using the version avm reports though, you may have a conflicting binary elsewhere in your PATH
*use 'avm list' instead*. It will show all of your installed versions and will display "0.XX.X  (installed, current)" next to the last selected version with the AVM with the 'avm use' command, nearly instantly. This was maddening for me. 'anchor --version' or 'anchor -V' are not properly reporting the version after switching using the AVM; even though the AVM is correctly switching the version with "avm use <version>"... 'avm list' will
Is there any reason anchor_spl::token doesn't re export spl_token? It makes it quite annoying to do manipulations that require the inner bits of spl_token
Solana devnet faucet hasn't been working since 3 days. It's out of sol. Is there any alternate way that i can procure some sol on devnet?
im having the same issue 😅
did you ever find a fix for this problem?
is there a way to spin up a validator at slot > 0 initially?
I didnt think of it that way, but I guess that is what Im going for. Thanks <@!134416332509675520>  lol
Just to make sure I'm understanding, how is this different from just running the `solana-test-validator` locally and doing an `anchor deploy`?
when i check avm --version it tells me i have avm 0.22.1
I ran ```cargo install --git https://github.com/project-serum/anchor avm --locked --force
``` and then ```avm use latest``` but for some reason when i go to check my anchor version it tells me to run ```avm use latest``` again
Is there a way to utilize anchor to deploy and run the test-validator locally?

Basically, I want to do `anchor test --detach` without actually running the tests, I just want a running solana test validator with my defined programs and dependancies.
Good chance I'll be there for first few days. Come talk to The Coherence team if you come. You helped us a several times now got to pay our respects
Not yet, will probably go to the NYC one
Have you been to any of the sol hacker houses?
Thank you for the help as always. Building cool stuff on Anchor / Sol and having fun doing it 🙂
ok I see, I was referring to Borsch and Anchor together when I said Anchor, but I guess that would only specifically Borsch deserializing it. Got it
That's what borsh does for you (via Account)
so how does it work if you pass in an account with existing data? how do you load the vector
gotcha
Ah, not really, it'll just start off being an empty vec
pretty cool
awesome, so anchor autopopulates the vec?
And can do things like
```.rs
#[derive(Accounts)]
#[instruction(how_big: u64)]
pub struct Something<'info> {
  #[account(init, payer = someone, space = how_big)]
  pub some_account: Account<'info, SomeAccount>
  ...
}
```
Yeah, you can do it with non zero_copy, since then you can just have `pub tokens: Vec<SomeStruct>`
there is way to do it without smaller non account loaded accounts though? I may have missed that. Won't work for me because of the size of accounts but that is interesting
Interesting
Ah, ok—hmm, hadn't thought about this before, but I guess yeah, I don't think there's a good way to do dynamic sized arrays like that with zero_copy
I know I can have user alloc different sized accounts and pass them into the program, just not sure about how to represent that and have be it serializable
but I would prefer for the array to be dynamic so I can use it like I have now and without knowing how big the account is (also have it generate nice idl still)
Dynamic at allocation. This is. what I have now
```
#[account(zero_copy)]
#[derive(Debug)]
pub struct SomeAccount {
    pub tokens: [SomeStruct; 16384],
}
```
But that will apparently change whenever 1.9 launches (not sure yet)
You currently only have 1 shot to allocate the right amount of space
Dynamic in what way? Like, able to resize the account?
Right now my very large accounts are using a static array that is huge but I would prefer a dynamic solution to save rent costs
I asked this earlier in here but since I have you, anyway to do dynamic sized accounts in Anchor? I saw something about raw pointers on how you can do it
Try searching the anchor repo for `AccountLoader` and then look at the corresponding js tests
Yep
you mean when they alloc they specify the program owner?
Every account in solana has a program owner, and only that program is allowed to mutate the account's data or spend the account's money.
Just make them alloc it as a your program account
sorry just clearing up some misconceptions I have about solana account arch
which programs have right to modify account data ? if user allocs it as system account they must transfer it first to the program right?
The user can't fill the account with any data (only a program can do that)
the data inside the account
What are you validating here?
do you think this flow would work for large accounts that are secure (guessing serum does something similar for queues) 
1. user allocs and passes in account
2. validate accoun
3. transfer account to program
What security concerns are you worried about?
user passing accounts that aren't program created
I know I can do it with account alloc on client side but worried about security concerns
Ok, yeah, unfortunately not possible with PDAs.
it works with accounts under 10Kb. I need more space than that however.
Have you tried?
Yep, PDAs have to be initialized via a CPI (since that's the only way to sign for their address), and CPI initialization is capped at 10kb.
looks like no pdas over about 10Kb are allowed then?
thie is whatI get 
```
    Account data size realloc limited to 10240 in inner instructions
```
pretty srue this will get runtime error though
without stck issues
it builds
this doesn't work right?
```rust
    #[account(init_if_needed, seeds = ["seeds".as_ref()], bump, payer = payer, space=100000)]
    pub some_account: AccountLoader<'info, AcountType>,
```
Can't use init with accoutn loader right?
Does anyone know how to alloc large PDA accounts? like so big they overflow the stack frame
hi i just got a new mac m1, and I'm getting this error when I run `anchor test`:
```TypeError: Module "file:///~/Desktop/accrue/accrue/tsconfig.json" needs an import assertion of type "json"```

Solution: Change Anchor.toml line to: `test = "yarn run ts-mocha -t 1000000 tests/**/*.ts"`. Idk why lol whatever
Whats the best way I can send this draft to you?/ Is there any other article platform that you use that I can temporarily convert my article to?
Mm seems like I can't read that post unless I sign in (don't have a medium account unfortunately)
Hi Alan, not sure if this is the place to post this but for the passed few days I’ve been writing a medium tutorial to integrate with 01 that also doubles as a CPI tutorial:
https://medium.com/@01exchange/01-for-devs-cpi-tutorial-df945f97284c

I know you’re super busy, but if you have some time to spare I would love to hear your thoughts on it. Really Appreciate all he help you've given me with bugs!
ok great, that compiles! thanks again
ah, I confused TokenAccount with Mint
You probably want to use `source: Account<'info, TokenAccount>`
Im just trying to move tokens from one account to a destination account
Its essentially a wrapper around the spl_token transfer function
What are you trying to do there?
Ah, that has_one constraint won't work like that
```
#[derive(Accounts)]
pub struct Transfer<'info> {
    #[account(signer)]
    owner: AccountInfo<'info>,
    #[account(mut, has_one = owner)]
    source: AccountInfo<'info>,
    #[account(mut)]
    destination: AccountInfo<'info>,
    token_program: Account<'info, TokenAccount>,
    network_config: Account<'info, NetworkConfig>,
}
```
Can you show your code? Not quite sure what you're asking
Is using `#[account]` allowed for fields that have the type AccountInfo?
oh yeah this error is coming from my other Account struct
That should all be fine, so I think you must have something else wrong somewhere else
```
#[derive(Accounts)]
pub struct Init<'info> {
    #[account(init, payer = payer)]
    network_config: Account<'info, NetworkConfig>,
    system_program: Program<'info, System>,
    #[account(mut)]
    payer: Signer<'info>,
}

#[account]
#[derive(Default)]
pub struct NetworkConfig {
    pool_account_key: Pubkey,
    fee: u64,
}
```
Can you post your full derive(Accounts) struct?
Nope, that's fine
Does the Pubkey need to be stored as a reference? I was trying to store the actual value:
```
pub struct NetworkConfig {
    pool_account_key: Pubkey,
}
```
I'm not actually even using the field right now. I think the ref comparison is happening within anchor
You're inadvertently comparing a reference to a Pubkey with an actual Pubkey
hmm running into this now:
```
error[E0277]: can't compare `&anchor_lang::prelude::Pubkey` with `anchor_lang::prelude::Pubkey`
  --> programs/test/src/lib.rs:42:10
   |
42 | #[derive(Accounts)]
   |          ^^^^^^^^ no implementation for `&anchor_lang::prelude::Pubkey == anchor_lang::prelude::Pubkey`
   |
   = help: the trait `PartialEq<anchor_lang::prelude::Pubkey>` is not implemented for `&anchor_lang::prelude::Pubkey`
```
thanks 🙏
But the account would need to be sent anyways with the transaction so I'll have it as an AccountInfo
ok that makes sense. I was trying to store the whole account and then use it in my processing logic so was wondering how I would go from Pubkey to AccountInfo.
The AccountInfo is the whole account (try jumping to source on it, I think it will make more sense why you can't store it on-chain)
Just as a `Pubkey`
oh interesting. what's the recommended way to store an account address then?
You actually can't store an AccountInfo into an `#[account]`
I was wondering if there are any tools for mainnet forking from a particular solana block?
^ it looks like a parser error. I'm able to get around it by defining another type set to `Account<'info, NetworkConfig<'info>>`
Running into an error which I don't really know the source of. Here's the Accounts struct and  I have setup
```
#[derive(Accounts)]
pub struct Init<'info> {
    #[account(init, payer = payer)]
    network_config: Account<'info, NetworkConfig<'info>>,
    system_program: Program<'info, System>,
    #[account(mut)]
    payer: Signer<'info>,
}

#[account]
#[derive(Default)]
pub struct NetworkConfig<'info> {
    pool_account: AccountInfo<'info>,
}
```

Running anchor build gives this error:
```
error: expected `while`, `for`, `loop` or `{` after a label
  --> programs/test/src/lib.rs:57:55
   |
57 |     network_config: Account<'info, NetworkConfig<'info>>,
   |                                                       ^^ expected `while`, `for`, `loop` or `{` after a label
```

I'm assuming its coming from the code anchor generates. Any ideas on how to get around this?
Ah, I don't actually, though you could probably benchmark it by using `sol_log_compute_units` before and after to get a sense for it
thanks!  I used zero_copy plenty, and sometimes I wonder whether it's worth the trouble for a 5kb account.  Do you have a sense how compute-hungry boxing is?
One situation where you have no choice but to use zero_copy is if you have a big account. The heap in solana is only 32kb, so Box can't help you if you have an account with 100kb of data, for instance.
zero_copy is harder to use but very efficient (you just leave the account's data right where it started, in a part of the memory map that isn't the stack *or* the heap, both of which are quite limited in solana: https://docs.solana.com/developing/on-chain-programs/overview#memory-map)


///////////////////////////////////////////////////////////////////////////////////////////////

ah yeah, got confused about how the .toml fit in, my CLI was on 0.20.1 still :/  Thanks! Although now I'm getting the right data at the program address with getAccountInfo and getting the failure on the transaction (program doesnt exist) immediately after... are race conditions w/ confirmation options possible or would you think it's probably something else?
What is your anchor cli version? `anchor --version` I think you need to be on at least 0.21 for that syntax to work (otherwise try doing just `[[test.clone]]` instead of `[[test.validator.clone]]`
I am struggling to clone some program accounts from devnet to localnet during testing, my Anchor.toml contains this:
```
[test.validator]
url = "https://api.devnet.solana.com"

[[test.validator.clone]]
address = "GovER5Lthms3bLBqWub97yVrMmEogzX7xNjdXpPPCVZw"

[[test.validator.clone]]
address = "SQDSm7ifFqwmgxY5aL59BtHcBGHEgbg5thh4Y9ytdn3"
```
but if I run `anchor test --detach` and call `getAccountInfo` for these addresses, they are empty (I also get `Transaction simulation failed: Attempt to load a program that does not exist` when trying to use the programs). I am on anchor_lang 0.22.1. Is there anything else I need to do or common mistakes I might be making?
are our docs somewhere still telling you to use the feature?
use `--skip-lint` instead
Is this correct - after using
```
[features]
safety_checks = false
```
I am still getting an error on anchor builds about adding comment?
the msg() statements are literally right there
i just woke up that is my excuse
🤦‍♂️
lol ignore me
which version of anchor-cli are u on
not my `msg!()` statements, no

Does for me
It doesn't just show up in the test output?
hmm because i want my `msg!()` statements to show
I actually don't think they do, just in the console output 🤔
do failed txns show in the .anchor program log?
Any idea why?
I'm running tests, and my most recent transaction that fails isn't showing up in my logs
I don't think that works with the IDL generation, unfortunately. Next best option is to just use a vector of key-value pairs (that's actually what borsh will do anyway when it serializes a BTreeMap, so it's not actually a big loss)

Can BTreeMap be included in state?
In general anytime you want to use the system program to transfer some sol, the source account *always* has to be owned by the system program.
Then in JS it would just be a `[pubkey1, pubkey2]` etc.
`Vec<Pubkey>`
how to pass vector of addresses into an anchor instruction?
Don't see why not.
yeah, I've gone through all obvious update steps.
this is not something that makes any sense ;p
Can we use loop in anchor program in any way? I want to loop and call same CPI multiple times in a single instruction
https://github.com/project-serum/anchor/blob/master/CHANGELOG.md

There's a bunch of breaking changes from 0.18 to 0.22
I see. I think the not so obvious part is that the PDA transfering SOL has to be owned by System Program (although it could be DERIVED from any program ID)
<@!134416332509675520> this is what  was referrring to about dynamic allocated accounts <https://github.com/project-serum/anchor/issues/639>
if you want to perform some operations using the PDA, then you just need to use the invoke_signed function and other than that - you should be fine transferring SOL
hey
so this is a really weird one...
after upgrading from anchor 0.18 to 0.22 my tests stopped working.
I tried to recreate the problem in a separate project, but it works fine, so it's not an anchor issue per se
the problem is that - in blockchain code I save an integer (`i64`) and when I read it from JS in tests the result is... waaaay off.
I started digging and set the integer to `1` (before it was the current unix timestamp) and JS reads it as `4294967296`...
I also tried `u32` and this one is written/read correctly
I tried deleting `target` and `.anchor` folders - didn't help. I even restarted my computer... 😂 
I know it's a longshot, but does anyone have any ideas what can be messed up (the code has been working before the upgrade and is still working in a separate repository with the new library deps). Because of that I'm thinking that maybe it has something to do with configuration, but `Anchor.toml` and `Cargo.toml` don't have any major differences between those two projects... so I'm lost xd
more specifically send
by holding SOL I mean send and receive
assuming that I (PDA) need sig for the tx, does it mean that the PDA must be derived from System Program ID ?
functionally PDAs are no different than any other account, so yes
or do you have to use wsol
noob question: can pda holds sol?
Either run it in the background via `solana-test-validator` + deploy your code their, or just insert a long sleep in your tests/ a `debugger;` line, etc.
is there an easy way to keep the "anchor test" validator running so i can look into stuff on explorer.solana.com ?
Depends on what you're trying to do. Which program? But yeah, you can always pass it as an UncheckedAccount and handle the initialization yourself
yes, i do. how would i init an account but have it owned by a different program? my attempt is to specify the account as an UncheckedAccount.
in my current program:
```
// mainnet, devnet
#[cfg(not(feature = "local-testing"))]
pub mod constants {
    pub const TOKEN_PUBKEY: &str = "F8jaXiBD8K3a7C1PwxV1xqDHs5aV8y8nWRmHebafdkes";
}

// localnet
#[cfg(feature = "local-testing")]
pub mod constants {
    pub const TOKEN_PUBKEY: &str = "a8iphHZxd7ZpTBqaCa1scLWE5C6QyX2z3ovwktD1pfo";

```
Later in the ctx struct:
```
    #[account(
        mut,
        constraint = purchaser_creator_token_account.mint == constants::TOKEN_PUBKEY.parse::<Pubkey>().unwrap() @ErrorCode::IncorrectToken,
    )]
    pub purchaser_token_account: Account<'info, TokenAccount>,
```
Trying to trade two tokens between two token accounts, and want to use the constraint above to ensure that the tokens being traded match the tokens expected
Can you post more of your code? This is working fine for me, so not sure what you're doing differently
error: package `different-program v0.1.0` does not have a dependency named `tests`. doesnt quite make sense since it runs fine without the flags and im not setting anything up called tests specifically for the feature `local-testing`
strange, for some reason it is causing a dependency feature for me if I run with that feature
Yep, seems to work for me
hmm, and in my TOML i would have `local-testing = []` under features?
and in the program itself, `#[cfg(feature = "local-testing")]` macro to do something based on the particular feature?
I think that's what the syntax is supposed to be, yeah, according to `anchor test --help`
is there a way to pass cargo build flags into anchor test? I saw someone mention a PR for it somewhere in here a while ago, but can't seem to find if theres any documentation about it. I've been using `anchor test -- --features local-testing` to no avail


///////////////////////////////////////////////////////////////////////////////////////////////

ah, here:
https://discord.com/channels/428295358100013066/517163444747894795/943505805578219541
or is this not active until the validators update to 1.99
or TS rather
is there an anchor equivalent of this `ComputeBudgetInstruction` request?
https://solanacookbook.com/references/basic-transactions.html#how-to-increase-compute-budget-for-a-transaction
fixed 👌  thanks guys
ah gotcha
only needs added if you aren't configured for devnet as default:
`solana config set -u d`
`-u d` is short for `--url devnet`
```accrue % solana airdr
op 1 9SByAxANo5Gnn3gBb4oqd4rW7L5z3zyQvCJoTECKrE2Z
Requesting airdrop of 1 SOL
sError: airdrop request failed. This can happen when the rate limit is reached.```

Adding `-u d` worked tho, thanks!
yeah have to go 1 at a time
i keep getting rate limited. Really annoying
You can just run `solana airdrop -u d 1 FzffpmKquwkCPtXNcXJ7Y82sLnRRQvQTRPtcGufnkRgd`
can someone please mint me devnet SOL: `FzffpmKquwkCPtXNcXJ7Y82sLnRRQvQTRPtcGufnkRgd`
ahh yeah makes sense. And how do I convert this array into my public key XD
Anchor.toml
I think it's because my payer doesn't have SOL funds. Where can I find my payer address?
Ok so I deleted my `build` folder and it automatically generated a new keypair 👍  but now when I run `anchor test`, I get this: 
```Error: Deploying program failed: Error processing Instruction 1: custom program error: 0x1
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.```
gotcha, so I'll move this file away, generate a new keypair, and replace it in `target/deploy`
Indeed, I have a branch `generic` in there that could technically be deployed and support any/all mints through one program and derived underlyings.  Could be a "standard" yield bearing mint program.  Step (and others) aren't using it because they want a vanity underlying.
You need the keypair in order to transfer that sol somewhere else
No, you'll lose your sol if you lose the keypair—not if you move it
this is the `Fzff` keypair though, so If I move it out of the way, then I'll lose my 12 devnet SOL?
It has 12 devnet sol in it, so maybe you want to keep the keypair
So if you're sure you want to use a new one, I'd move that offending one out of the way
Anchor uses whatever keypairs are in target/deploy
how do i generate a new one?
interesting, yeah it says that one
Do `anchor keys list`
Idk where this `FzffpmKquwkCPtXNcXJ7Y82sLnRRQvQTRPtcGufnkRgd` is even coming from
hmmm
Try looking at that account in the explorer—you're apparently trying to deploy to that address, I guess? On devnet at least that just isn't an executable, but there *is* an account there, so you can't try to deploy to it: https://explorer.solana.com/address/FzffpmKquwkCPtXNcXJ7Y82sLnRRQvQTRPtcGufnkRgd?cluster=devnet
Cheers mate! <@!111373445245214720> reach out to myself or <@!99911938955309056> if you got any questions
( I downloaded solana-cli from 1.9.9 to 1.8.14 because I was getting a ton of problems )
I can't seem to run `anchor test`
```Error: Account FzffpmKquwkCPtXNcXJ7Y82sLnRRQvQTRPtcGufnkRgd is not an upgradeable program or already in use```
Maybe through the tx since only one wallet can interact with each PDA
i'll find another way
Alright thank you for your guidance !
No, not purely from the address
so there is no way to find the wallet that generated those PDAs ?
ha alright yeah that's my issue then 🙂
in anchor, the seed definition is as follow : ```
seeds = [
            b"account".as_ref(),
            staker.key().as_ref()
]
```
If all you have is the PDA address then you can't back-out the seeds that were used to generate it
And I'm trying to figure out what is the wallet that generated each of these "staking" accounts
So I have an account in which the NFTs are stored
What i'm trying to achieve is to make a snapshot of NFT holders wallets who own a certain NFT that is staked inside our program
Sure
Can you repeat your question then? I'm not sure what you're asking
Yeah you're right it's not really the owner of the account, but more the publickey that's used to generate the seed for this account
thanx!
You can do this with the rust test framework, don't think you can via JS though: https://docs.rs/solana-program-test/latest/solana_program_test/struct.ProgramTestContext.html#method.warp_to_slot
hi! did you find a way to forward time during tests?
What do you mean by owner here?
Hey everyone ! What's the best way to find the owner of an account through its seed ? (like if I have an account created with the seed ["account", pubkey])
any good algorithms for exponent on chain? e.g. E^4.123 My performance with E.powf is terrible.
how to not pay rent exempt but pay rent for only 100 epochs for a account in anchor?
😅
Sorry got confused
Heh, no, it's always been derive(Accounts)
The owner of the tokens, not the mint authority
Oh thanks! I'll check that out
<@!447814520224743424> and the team at Step have an excellent protocol based on the sushi bar
Pretty sure it's been upper-case "A" on `#[derive(Accounts)]` for as long as I have been using Anchor. Are you getting it confused with the lower-cased "a" used for the `#[account()]` macro?
I am getting some errors
hey <@!134416332509675520>  did `#[derive(accounts)]` get changed to `#[derive(Accounts)]`
it gives me this error:

```
Globally installed anchor version is not correct. Expected "anchor-cli 0.22.1", found "anchor-cli 0.20.1".
```
can i work with downgraded version of anchor?
Ah I think I found what I needed, at least to use as a jumping off point: https://github.com/project-serum/stake
can anyone help explain this?
Not strictly anchor related, but I was wondering if any of you devs know about any existing open-source programs for creating SPL token staking programs out there? Some context: I'm doing Solana Program dev for a project now, and the product guys want to let users stake their SPL tokens to earn yield. Seems like a widespread mechanic, so hoping I don't have to reinvent the wheel and write a contract for this from scratch if there's an existing implementation out there already 😅
Unable to deploy to solana mainnet.. keep getting timed out with Invalid blockhash error.. Is the network really so congested or am I the only one facing issues?
Has anyone implemented Solrand oracle and crosspile coin flip game?
oops 😐
hell no XD
sometimes you get a variables name. sometimes XD
btw is there any way i get line of code from errors?
rip me 😐 thanks for help though i will check them out
this particular error means - u can no longer use `bump = smth_bump` when using `init`
just use `bump`
meaning = don't provide the bump from JS
now u need to go through the changelog and fix all problems that arise from breaking changes. I just finished that process in my project - took me 2 days. good luck 😄
thanks my solana version was 1.8.0 updated and applied some checks

now getting this error 
```
$ solana program deploy /Users/mp-haidera-pyse-403/Desktop/anchor_gits/auction_house/target/deploy/auctionhouse.so
The program address will default to this keypair (override with --program-id):
  /Users/mp-haidera-pyse-403/Desktop/anchor_gits/auction_house/target/deploy/auctionhouse-keypair.json
thread 'main' panicked at 'Code not parseable: Error("bump targets should not be provided with init. Please use bump without a target.")', lang/syn/src/idl/file.rs:357:58
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```
let me check thanks
have you updated everything to 0.22.1? 
rust project deps
js project deps
rust cli (`cargo install --git https://github.com/project-serum/anchor --tag v0.22.1 anchor-cli --locked`)
js cli (`npm i -g @project-serum/anchor@0.22.1`)
solana (to 1.8.16 - `sh -c "$(curl -sSfL https://release.solana.com/v1.8.16/install)"`)
rustc (to 1.59 -  `rustup update stable`)

also - you may want to delete those folders after updating everything:
- .anchor
- target
- node_modules
did it not worked
run `rustup update stable`
when i run anchor build it throws this error 


```
anchor build
Only x86_64 / Linux distributed in NPM package right now.
Trying globally installed anchor.
BPF SDK: /Users/mp-haidera-pyse-403/.local/share/solana/install/releases/1.8.0/solana-release/bin/sdk/bpf
Running: rustup toolchain list -v
Running: cargo +bpf build --target bpfel-unknown-unknown --release
error: failed to download `solana-frozen-abi v1.9.2`

Caused by:
  unable to get packages from source

Caused by:
  failed to parse manifest at `/Users/mp-haidera-pyse-403/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-frozen-abi-1.9.2/Cargo.toml`

Caused by:
  feature `edition2021` is required

  consider adding `cargo-features = ["edition2021"]` to the manifest
```
just to double-check
when I do this:
```
    #[account(
        mut,
        associated_token::mint = mint,
        associated_token::authority = XXX,
    )]
    /// CHECK: checked above
    pub associated: Box<Account<'info, TokenAccount>>,
```
XXX should be the mint's mint authority or should it be associated token's owner?
and i also don't know what i am doing
interestingly this is undefined, types are totally lying here
generally I'd advise against running tests on devnet. especially if you switch back and forth between running them on local and devnet. mostly because on localnet you need to deploy some things that are already available on devnet
```
Error: Custom: Invalid blockhash
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.
```
anyone know what this error is
(devnet)
When I run `anchor test`, I get:

```Error: Account MY_PUBLIC_KEY is not an upgradeable program or already in use```
cannot use fetch because the account infos come from a cache that isn't anchor aware
With an `AccountInfo<Bufffer>` is this the most direct way to decode its data?
`const poolState = program.account.poolState.coder.state.decode<PoolState>(accountInfo.data);`

this feels odd due to the need to go that deep
How to create account with 10MB space in anchor.
perfect. thank you so much!
```.rs
#[derive(Accounts)]
#[instruction(that_array: Vec<Pubkey>)]
pub struct Something<'info> {
  #[account(init, payer = somebody, space = 8 + 4 + that_array.len() * 32)]
  pub some_account: Account<'info, Whatever>
  ...
}
```
It would come from the front end client. A submitted array of pubkeys.
Where is the array coming from?
but how would I pass in the the expression into the #[derive(Accounts)] struct?
The right hand side of `space =` can be any rust expression
For example if i'm going to declare an account that will contain an array, then is there a way to make space = "size of array"??
is there a way to declare space as a variable based on the size of an array?
when I remove it it seams to do more security checks that the programId are correct for my programs?
I am trying to understand how and why the `[program.localnet]` is needed.
Hey is the details of how the anchor.toml file works documented anywhere?
My friend sent me $SOL. Now, when I run `anchor test`, I get:
```Error: Account MY_PUBLIC_KEY is not an upgradeable program or already in use```
lol wut im tryna run `solana airdrop 2`
```Error: airdrop request failed. This can happen when the rate limit is reached.```
It's handy but super lazy and generally not a great habit to get into/leads tons of beginners astray: https://github.com/project-serum/anchor/issues/1563
Seams like it was a handy feature.
why was this removed?
```.rs
fn default_space<T: Default + AnchorSerialize>() -> Result<usize> {
    Ok(T::default().try_to_vec()?.len())
}

...

#[account(init, ..., space = default_space::<TheStruct>())]
pub something: Account<'info, TheStruct>
```
~~You can always do `space = ThatAccountType::default()` though, lol, to recover the old lazy behavior~~ Sorry more involved than that, 1 sec
Hot off the presses, now you need to specify space, no more auto-relying on Default 🙀
I see, thanks
and all I have done is change the `ProgramResult` to `Result` and drop the extra `.key()` method calls.
I am now getting this error with my `0.22` upgrade: ``````
was reading into the error message too much and not looking at the types.
ha i just realised that. doh lol
Can you just get rid of that `key()` call? Isn't `pool_state.token_mint` already a Pubkey?
works fine with `0.21`
hey guys, I'm updating my `0.21` codebase to `0.22` and am getting this error and cant seam to find a fix: ```error[E0599]: the method `key` exists for struct `anchor_lang::prelude::Pubkey`, but its trait bounds were not satisfied
  --> programs/hydra-staking/src/instructions/unstake.rs:31:60
   |
31 |         constraint = user_to.mint == pool_state.token_mint.key(),
   |                                                            ^^^ method cannot be called on `anchor_lang::prelude::Pubkey` due to unsatisfied trait bounds
   |
  ::: /home/utx0/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-program-1.9.5/src/pubkey.rs:71:1
   |
71 | pub struct Pubkey(pub(crate) [u8; 32]);
   | ---------------------------------------
   | |
   | doesn't satisfy `_: AsRef<anchor_lang::prelude::AccountInfo<'_>>`
   | doesn't satisfy `anchor_lang::prelude::Pubkey: anchor_lang::Key`
   |
   = note: the following trait bounds were not satisfied:
           `anchor_lang::prelude::Pubkey: AsRef<anchor_lang::prelude::AccountInfo<'_>>`
           which is required by `anchor_lang::prelude::Pubkey: anchor_lang::Key`
``` anyone know what the fix is here?
i know in anchor 0.22.0 we don't need to use bumps in context anymore, but what happens when we need to use bumps later on to sign messages? how do we access bumps then?
```
type TypeDefDictionary<T extends IdlTypeDef[], Defined> = {
  [K in T[number]["name"]]: TypeDef<T[number] & { name: K }, Defined>;
};
```
This could be the culprit
this doesn't cause any bug but that makes reading it quite messy
like not matching the IDL
Is this a regression or something i never noticed?
`type PoolState = IdlAccounts<CyclosCore>["poolState"];` this gives a type with the field out of order
two random thoughts:
- reserve space upfront on your accounts
- if this is not enough - you need versioning, you can find some example of that in the metaplex repository
I'm working on an active program and our accounts gradually change between versions. Is there a best practice for how to ensure the program can handle all versions of accounts? And, is there thought to how account upgrades + versioning might be done canonically in anchor?
i was doing something wrong but ill fix
ohhh interesting, this is very helpful
I made myself a small function in my test SDK for that. hopefully it will show you how to use it
```
async function transferTokenToUser(mint: Keypair, walletKeypair: Keypair, owner: PublicKey, transferCoins: number) {
  const token = new Token(connection, mint.publicKey, TOKEN_PROGRAM_ID, walletKeypair);

  const fromAccount = await token.getOrCreateAssociatedAccountInfo(walletKeypair.publicKey);
  const toAccount = await token.getOrCreateAssociatedAccountInfo(owner);

  await token.transfer(
    fromAccount.address,
    toAccount.address,
    walletKeypair.publicKey,
    [walletKeypair],
    transferCoins,
  );
}
```
keep in mind - it's a test SDK, so tehre is a lot of Keypairs flying around. those can all be PubKeys (as you'll see in the usage)
If I was rich I would fund `85frGYyMRhzKEgWWNeZuEyg4LkWWkofBFAQhyo88iUSj`
god bless your soul
`Token.transfer` method, but it's in spl-token (solana)
what's the easiest way to transfer tokens w anchor's ts library?
I would like to interact with some of these instructions in the dex serum contract, but I can't do the instruction correctly in the client, can someone help me? thanks
https://github.com/project-serum/serum-dex/blob/5b43fe1455470de59233e434f979082092ebb28d/dex/src/instruction.rs#L486
hi
https://github.com/project-serum/anchor/issues/1573
issues for better error msgs are very much welcome!
yeah, I figured that in the past the constraint had to deserialize the account on it's own, which might be leading to double-deserialization. so it kinda makes sense now that it uses a deserialized account, but... the error is not really informative. if the underlying error got caught and the returned error message was changed to something like `associated_token constraints can only be placed on "Account<'info, TokenAccount>"` - it would be much more readable.
just an idea 🙂
Those associated_token constraints end up validating more than just the address, in which case, yeah, they kind of expect the underlying account to already have been deserialized
Oh, actually I guess not, maybe it's working as expected
Mm, I probably wouldn't call it a bug, but maybe unexpected
which works as expected or is it a bug?
Cool—and yeah, turns out the associated_token constraints expect the account underneath to be a Account<'info, TokenAccount>
initial testing shows that `Box` did the trick, thanks 🙂
thanks for an answer 🙂 

the referenced fields are accounts.
pasting the declaration below:
```
    #[account(mut)]
    pub owner: Signer<'info>,

    #[account(mut)]
    /// CHECK: doesn't matter, it will fail with metaplex calls if it's not a correct address
    pub parent_1_mint: UncheckedAccount<'info>,
```

I'll try to use `Box` and report back 🙂
Does anyone know how to properly implement errors when they're defined in two different files? I'm facing an issue where one file's errors overwrite the other's in the IDL upon building, and therefore, the wrong error gets returned.
You unfortunately need the right hand sides of those constraints to be actual accounts, not just pubkeys. About the stack issue, you can usually get around that by doing `Box<Account<'info, TokenAccount>>`
try adding `npx` before it in the `anchor.toml` file under `scripts`
Command "ts-mocha" not found.
(for posterity)  the `foo` here:
```rust
#[program]
pub mod foo {
...
}
```
must match the name of the package in the `Cargot.toml` manifest.
yeah, those errors are less than informative at times. good job! 😄
Figured it out!
The name of the main program `mod` in `lib.rs` has to match the name of the package.
Otherwise, the Anchor test client won't look for the program's logs.
curious indeed.
have you updated everything to 0.22.1? 
rust project deps
js project deps
rust cli (`cargo install --git https://github.com/project-serum/anchor --tag v0.22.1 anchor-cli --locked`)
js cli (`npm i -g @project-serum/anchor@0.22.1`)
solana (to 1.8.16 - `sh -c "$(curl -sSfL https://release.solana.com/v1.8.16/install)"`)
rustc (to 1.59 -  `rustup update stable`)

also - you may want to delete those folders after updating everything:
- .anchor
- target
- node_modules
thanks for the help - that would be it, but my tests are all succeeding.  The file `.log` just is not appearing the `program-logs` dir . . . 🤔
your tests may be failing on `transaction simulation`. which means - no data saved to the blockchain and therefore nothing in logs
Any idea why **program-logs** would be empty after running `anchor test` on the localnet?  My version of Anchor is 0.22.1.
Running tests will create the directory `.anchor/program-logs`, and all the tests run, but no log file shows up.   Very curious.
You're probably right, already ran into issues related to size-restrictions earlier trying to pass the actual encrypted data to the instruction. I'll try a different approach then. Regarding the necessity of encryption: The data should not be visible until the process, which it is part of, has concluded. So any of this data passed to a smart contract has to be obfuscated in some way, otherwise it's completely transparent as you pointed out. I'll have to consider doing that off-chain.
I'm no expert, but encryption (especially of large data sets) seems like an operation-intensive action and we have pretty tight limits on solana, so for that reason alone I'd probably try to think of a different solution.
another thing is - everything is public on chain, so... why bother? decrypt it elsewhere and send plain data to blockchain
yet another thing is - do you really need blockchain if you're dealing with encrypted (and I'm guessing secret) data?
Every input to every transaction, every account, and every program is visible to everyone, so encryption doesn't normally make sense. You don't have a way to keep a secret key secret.
So first of all I have very little experience working with Rust, especially in blockchain environment, therefore I might've gotten some stuff backwards xD. In general, I get encrypted data passed as arguments to a smart contract and I need to decrypt them on-chain. Do you have any suggestions for this scenario, or does this sound like a no-go?
solana has a number of libraries and functionalities cut out (random being the most prominent) and this is why it's compiling. the bigger questions is - why would you want openssl on chain in the first place?
oh, btw.
any idea how to make this work again?
```
    #[account(
        associated_token::mint = parent_1_mint,
        associated_token::authority = owner,
    )]
    /// CHECK: checked above
    pub associated_with_parent_1_mint: UncheckedAccount<'info>,
```
currently it returns:
```
   |
18 | #[derive(Accounts)]
   |          ^^^^^^^^ no implementation for `&anchor_lang::prelude::Pubkey == anchor_lang::prelude::Pubkey`
   |
   = help: the trait `PartialEq<anchor_lang::prelude::Pubkey>` is not implemented for `&anchor_lang::prelude::Pubkey`
```
and if I try to correct it like a simpleton with `&owner` I get `Error: 2015: A token owner constraint was violated`

another thing one could do is `pub associated_with_parent_1_mint: Account<'info, TokenAccount>,` but it results in
```
Error: Function _ZN14sloth_combiner9__private8__global5breed17hb1d3e5b1bf22f2f6E Stack offset of 4200 exceeded max offset of 4096 by 104 bytes, please minimize large stack variables
```
because my transaction is pretty big as is... so my question is - how can we bring back checks on UncheckedAccounts?
has anyone here ever tried to use the openssl-crate in an anchor project? I'm trying to do that rn, but compiler's telling me it can't find the  directory of the openssl installation alongside some cross-compilation error. Only happens when building with `anchor build`; `cargo build` works fine.
hey all, at some point i saw a post about setting the localnet compute so that it runs the same way as mainnet (there was some configuration to allow 200k per instructions instead of for the whole batched transaction) -- does that ring a bell for anyone?
ok. thanks again 🙂 
❤️
which is why I said you should tell us here so we can then send a friend request to you and then you can msg us :p
both you and armani have DMs closed, so that may be hard 🙂
I see. 0.20 patch notes. I didn't understand the repercussions of that. sorry for the alarm. adding `[repr(packed)]` helped indeed. I'll close the issue
and if you think youve found a critical bug, please dont post it here for everyone to see. say that youve found one and then msg us privately
if you already have a program on mainnet and need to be compatible with it, you can override the default repr by adding `repr(packed)` to your data structs. you can look through the changelog for the PRs and issue discussions on that
our links to them in our docs seem to be broken though. https://docs.rs/bytemuck/latest/bytemuck/trait.Pod.html#safety
probably not a bug. Youre just not following the zero copy rules
hey.
yesterday I had a problem with my upgrade and after hours and hours of testing - I'm confident it's a critical, production bug that may affect many projects if they upgrade. this may result in very serious problems, especially if those projects don't have proper tests written (like we had)

I'm happy to stay on Anchor 0.18 for now, but I'd urge the devs to take a look into it:
https://github.com/project-serum/anchor/issues/1569

I know I shouldn't tag people, but I honestly believe it's a very important issue, so: <@!501570363566587905> <@!347689664855015424>
Hey all, has anyone managed to get Anchor running on the front end with a web3auth wallet? It seems like it should be possible but I'm having trouble implementing the Anchor wallet interface with the web3auth system. When I use the following code to set up I get the error back: `Translating error TypeError: Cannot read properties of undefined (reading 'request')` 

```//Get web3auth methods to construct wallet
const provider = await web3auth.connect();
const solWeb3 = new SolanaWallet(web3auth.provider);
const signTransaction = solWeb3.signTransaction; 
const signAllTransactions = solWeb3.signAllTransactions;
const pKey = await solWeb3.requestAccounts();
const publicKey = new PublicKey(pKey[0]);
let anchorWallet = {
   signTransaction: signTransaction, 
   signAllTransactions: signAllTransactions, 
   publicKey: publicKey, 
};
// Setup anchor program
const connection = new Connection(network, opts.preflightCommitment); 
const prov = new Provider(connection, anchorWallet, opts.preflightCommitment, ); 
const program = new Program(idl, programID, prov);
// Execute transaction
await program.rpc.createReceipt(....)
Probably more readable to just return an Err?
What's the best way to handle assertions on Solana/Anchor? Do we just let the program panick with this msg?
```
BPF program panicked
```
oh wow, yeah this worked! I swear I read the whole program loader model carefully in the Solana docs lol, don't remember this part 🤔 Will take another look.
You'll need to calculate that PDA and add it to your clone list.
Ah, I think the issue you're running into is that programs deployed via the upgradeable loader (the default) actually consist of *two* accounts, the program_id one but also a PDA derived from the upgradeable loader: https://github.com/project-serum/anchor/blob/master/tests%2Fbpf-upgradeable-state%2Ftests%2Fbpf-upgradable-state.ts#L15


///////////////////////////////////////////////////////////////////////////////////////////////

Given the instruction, is there a nice way to deserialize it into an anchor instruction?
hey <@!134416332509675520> - I saw you tried messing with Sysvar1nstructions1111111111111111111111111 previously
is it because the owner is only assigned when the account is being initialized and when we do AccountLoader<something> it checks for the owner?
Why is this the case by the way. Im not really understanding the root cause of the problem here
Yep, that's what you'd have to do
Hi, is this correct: Lets say there is a CPI caller and callee. If some account is initialized in the callee (maybe with `init`) and you set the account as a `AccountLoader<something>` in the caller it will cause a `Error: 3007: The given account is owned by a different program than expected` . I was stuck on this for awhile and the only fix that I found was setting it to uncheckedAccount in the caller. Not sure if uncheckedAccount is the best thing to do here.
as I tell you, yes you can. Since platforms like step and ray allow it. I'll keep looking and if I find a solution I'll let you know.
Actually not sure, maybe?
Nope, not as far as I know (you have to approve each separate tx)
but that would send a bunch of approvals to the adapter. It is not possible to send it with an approve all?
Basically by sending them in a loop
Ok, so my confusion is, how do I send this array of transactions to the adapter with the .sendtrasaction method?
You would need to keep them separate like that
Not once you smoosh them into a single transaction 😛
but i have 3 separate transactions

You just can't fit very much stuff into one tx
No, that would have to be using multiple *separate* transactions
but I have seen platforms like step, which manage to separate a large transaction into an array of transactions.
No way around that, unfortunately
😢
but that doesn't work for me. The instruction becomes something very large, and fails.
Because that smooshes them together into a single big transaction
hello

I have an array of transaction.

transaction[0] with 10 instructions
transaction[1] with 10 instructions
transaction[2] with 9 instructions

when i want to make a
```javascript
 const transactionArray = new Transaction();
transactionArray.add(transaction);```

This does not store an array of transactions, but instead stores all the instructions together, why?
oops, I re-deployed my code and it works now! You were right, the IDL I had was wrong. Thanks a ton!
Ok, are you sure your IDL is up to date?
This is the JS call:
Cause, yeah, you definitely need to sign for that address, since you're creating an account there
That error doesn't make sense to me
Can you show me the JS call you're making?
No, I'm just generating a random keypair and passing it in.
Does it live at a PDA?
That is the escrow_check account from above (which is the program account). If I include this account in the signers array, it says "unknown signer"
Ok, yeah, you're somehow not signing for whoever Df2HCkY25byn3JR6Ue4AtzM1Z7zzZF7ugyiUzn7cZmJ is
```Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account 
    Program 4fZd9AxAWRFuxtZcVjE5RbpTpR51ecoBMt7KXVHpzBci invoke [1]
    Program log: Instruction: CreateCheck
    Df2HCkY25byn3JR6Ue4AtzM1Z7zzZF7ugyiUzn7cZmJ's signer privilege escalated
    Program 4fZd9AxAWRFuxtZcVjE5RbpTpR51ecoBMt7KXVHpzBci consumed 9822 of 200000 compute units
    Program 4fZd9AxAWRFuxtZcVjE5RbpTpR51ecoBMt7KXVHpzBci failed: Cross-program invocation with unauthorized signer or writable account
/node_modules/@project-serum/anchor/node_modules/@solana/web3.js/lib/index.cjs.js:6820
      throw new SendTransactionError('failed to send transaction: ' + res.error.message, logs);```
Can you post the full program log though?
This is the derive accounts for the createcheck function:
```#[derive(Accounts)]
pub struct CreateCheck<'info> {
    // Check being created.
    #[account(init, 
        payer=from, 
        space=10240
    )]
    escrow_check: Account<'info, Check>,
    // Check's token vault.
    #[account(mut)]
    vault: AccountInfo<'info>,
    #[account(mut, signer)]
    from: AccountInfo<'info>,
    system_program: Program<'info, System>,
    rent: Sysvar<'info, Rent>,
}```
I have the vault account (which is the "to" account) as mut and the from account as mut and signer
We have PR for this https://github.com/project-serum/anchor/pull/1480 If somebody want this to be merged please ping Armani 😆
Actually, can you post the full program log? You might also have just forgotten to mark those accounts as mut
You need to mark is as `from: Signer<'info>` in your derive(Accounts)
Yes I am passing in the "from" wallet as the signer from the nodejs file
same error with `Error: Deploying program failed: Error processing Instruction 1: ` . it works sporadically
also have troubles uploading stuff to devnet..
Also https://book.anchor-lang.com/chapter_3/errors.html
Yep, try searching the anchor repo for `#[error_code]`, tons of examples
Anyway to make custom program errors?
Is reentrancy attack even a thing in Solana?
For now I think I will just have to write my own yarn scripts or something to start up the local chain, run anchor build + anchor deploy, then start the tests x.x
But it seems no action happening on that PR now for a while so I'm losing a bit of hope 😅
I saw a different semi-related PR open in the solana repo that would also solve this headache: https://github.com/solana-labs/solana/pull/22694
No, though it's possible some of the work <@!448034961652449283> did on this might go into anchor? https://github.com/solana-labs/solana-web3.js/pull/1057
Is there any node.js function for deploying a program using the UpgradeableBPF? I see there is a `web3.Loader` and `web3.BpfLoader` class with `load()` function, but those are using the "BPFLoader2111111111111111111111111111111111" program and not the "BPFLoaderUpgradeab1e11111111111111111111111" program.

For context, I'm hoping to deploy my program in a node.js script using the upgradeable loader for automated testing purposes, as my program has an "admin settings" PDA that can only be initialized by the same wallet that originally deployed the program (determined by checking the upgrade authority on the UpgradeableBpfLoader account)
The source account needs to sign
Can I regard block height as current time? I wonder if current time is 100, then 4s later would be 110 exactly
Getting this running `anchor deploy` on devnet
```Error: Custom: Invalid blockhash
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.```  anyone getting this?
Is there any way to mint more than 20B tokens?
https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html
can you use init with AccountInfo?

Please help
<@!134416332509675520>
my version of anchor is 0.22.1
I am trying to do a CPI but i am getting this error
How do I send and confirm signed transactions at once??
Can I make confirm and send transaction at once?
In tutorial it says 
"This essentially means that once you are done with this quest, you will be able to make your crypto-currency using Solana programs and use that to do whatever you can think of, including using it as a fan token, a social token, a governance token, a utility token or a coin."
Hi there i hope you re doing well. I need help about how can i use my token on smart contract as governance token ? Cause i built it on anchor ?
is there a way to deploy only one program in your programs list?
Hello, when I try to deploy the program in metaplex, I get various erros with the same code:
1. Error: Deploying program failed: unable to confirm transaction. This can happen in situations such as transaction expiration and insufficient fee-payer funds
2. Error: Pubsub error: UnexpectedMessageError("{\"error\": Object({\"code\": Number(-32601), \"message\": String(\"Method not found\")}), \"id\": Number(1), \"jsonrpc\": String(\"2.0\")}")
3. Error: Custom: Invalid blockhash

Currently the versions of cli I use are these:
anchor-cli 0.18.0
solana-cli 1.9.10

I have the sufficient sol(30 sols in the wallet) and tried with mainnet rpc / custom quicknode / genesys rpc.

Does anyone know what the errors are about?
Is there full documentation for the Anchor.toml options somewhere?
Oh now that's even more slick, don't even have to bother with building 😮
Undocumented goodness
The clone key in has changed since then, [[test.validator.clone]]
```[[test.clone]]
address = “…”```
https://github.com/project-serum/anchor/pull/834
interesting. any examples of that?
You don’t even need to compile it. You can use a clone directive in the anchor file to clone it from mainnet.
oh nvm i see the source code
```
static async getAssociatedTokenAddress(associatedProgramId, programId, mint, owner, allowOwnerOffCurve = false) {
    if (!allowOwnerOffCurve && !web3_js.PublicKey.isOnCurve(owner.toBuffer())) {
      throw new Error(`Owner cannot sign: ${owner.toString()}`);
    }

    return (await web3_js.PublicKey.findProgramAddress([owner.toBuffer(), programId.toBuffer(), mint.toBuffer()], associatedProgramId))[0];
  }
```
is there an easy way to check if an address if off-curve (i.e. a PDA) need to know which boolean to pass in when deriving ATA

of course i think looking up the account and checking if owner != SystemPRogram we can assume its off-curve? but maybe there is a quick check without doing a fetch
👍
let me know if you do 😉
I am using `mpl-token-metadata` in my program for deserializing the metadata AcountInfo now, yeah. Would be nice to have the Anchor automate the type-enforcement/deserializing/constraint checking in the instruction context though, rather than having to do that stuff in the instruction logic. 

I'll probably get around to writing a wrapper myself then at some point, using Anchor's SPL Token wrapper as an example of how to do so
works well with anchor programs
not anchor, but there is this
```
metaplex-token-metadata = { version = "0.0.1", features = ["no-entrypoint"] }
```
Oh neat I didn't realize Anchor even had a way to specify this stuff in the Anchor.toml file so I can even use the super slick `anchor test` command rather than having to spin up the testchain myself! Thanks a ton! 

Another semi-related question: are there any existing Anchor wrappers for the metaplex programs so that the accounts can be properly type-enforced and deserialized by Anchor? Rather not reinvent the wheel and write my own wrapper if there's already one out there somewhere 😅
Hi - I have a simple program to create a check account that transfers some SOL from a wallet to a vault account, something like below:
```invoke(
            &transfer(   &ctx.accounts.from.to_account_info().key(),        &ctx.accounts.vault.to_account_info().key(),
                amount,
            ),
            &[   ctx.accounts.from.to_account_info().clone(),       ctx.accounts.vault.to_account_info().clone(),   ctx.accounts.system_program.to_account_info().clone(),
            ],
        )?;```
And in my nodejs test file, I am attempting to pass in the createCheck function with signer being the from wallet. I get this error: "Cross-program invocation with unauthorized signer or writable account'"
I  checked the idl and it only has the from wallet as the signer. What am I doing wrong?
(I have the vault account set as mutable too)
step 1 - compile the metaplex token metadata program
step 2 - add this to your `Anchor.toml`
```
[[test.genesis]]
address = "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"
program = "./external/metaplex_token_metadata.so"
```
step 3 - rejoice
Hey, so I'm working on some Anchor Programs that need to  interface with Metaplex NFT metadata accounts and I had a question regarding testing on a localhost chain. Currently to do any real test flow I am using devnet since I need to mint some NFTs as part of my setup for my program to interact with, but this is cumbersome and far from ideal. 

Has anyone had experience or success getting the metaplex programs setup on a localhost chain for testing? Their Solana programs are open source, so I'm assuming it should be possible to get them running on my testnet by building their programs myself and then including the .so files as `--bpf-program` arguments when I spin up my localhost chain. Just curious if anyone has done something like this before or not, or if you have other approaches for locally testing Anchor programs that depend on external programs
how would we read the that_array in the instruction function? Like some_account would be read as ctx.accounts.some_account, how do we read that_array?
can someone please send me devnet sol? I've reached the rate limit:

```solana airdrop -u d 1 FzffpmKquwkCPtXNcXJ7Y82sLnRRQvQTRPtcGufnkRgd```
Has anyone setup a rust testing framework for an anchor program?
Hey did you solve this problem?
with `SysVar` though you should be able to get the data.  might need `to_account_info()` first.
ah, no, anchor didnt have that sysvar back when I wrote this:
```    #[account(
        address = slot_hashes::id(),
    )]
    pub slot_hashes: UncheckedAccount<'info>,```
I have done testing.  The distribution is even across a `mod`, even of low numbers
i.e. is  using that hash as an rng for a range more or less uniform
Have you done any work to see how 'fair' it is to use slot hashes? I was thinking of running tests for that
Appreciate it. I am still struggling to get the sysvar data :/ 
   `pub slot_hashes: Sysvar<'info, SlotHashes>` right?
It's a whole rabbit hole to go down - these 2 sysvars have quite fun behavior.  I'm intimately familiar with their oddities if you have questions
Also don't fall into the trap thinking that RecentBlockhashes sysvar contains only valid block hashes.
don't fall into the trap thinking these are block hashes.
I have JS code that does the same thing, if you need a client to see these as well to act on.  That's how SolanaDino knows which random egg got minted
Yep
Wish I could send the whole repo, but its a closed project currently.  u building something based on randomness?
`let data = ctx.accounts.slot_hashes.try_borrow_data()?;`
ty, how do you get the sysvar data? `let data = recent_slothashes.data.borrow();` doesn't seem to work for me, where recent_slothashes is the account for `SlotHashes`
`data` is the sysvar data
tuples of Slot (u64) and Hash (as byte slice)
that gets you a lazy iterator over them
```use std::convert::TryInto;

pub fn get_slot_iter<'a>(data: &'a [u8]) -> impl Iterator<Item = (u64, &'a [u8])> + 'a {
    let len: usize = u64::from_le_bytes(data[0..8].try_into().unwrap())
        .try_into()
        .unwrap();
    let iter = data[8..]
        .chunks_exact(40)
        .map(|chunk| 
            (
                u64::from_le_bytes(chunk[0..8].try_into().unwrap()),
                &chunk[8..40],
            )
        )
        .enumerate()
        .filter(move |e| e.0 < len)
        .map(|e| e.1);
    iter
}```
thank you, I am trying to pull one (or more) of the hashes
It's very optimized and... functional.  Not sure how readable.  1 min
I do
Does anyone have an example of manually deserializing SlotHashes 👀
thanks for trying tho gumnut!
lmao great 🙃
Tried to but got rate limit reached, think devnet still scrambled
Right 👍
Yeah, just have to use a u8 or whatever and bool-ify it at runtime
ok thanks, kinda sucks xD
can someone please send me devnet sol? Just do this:
```solana airdrop -u d 1 FzffpmKquwkCPtXNcXJ7Y82sLnRRQvQTRPtcGufnkRgd```
Yeah, pretty irritating.
Question: It is noted here (https://docs.rs/anchor-lang/latest/anchor_lang/attr.account.html#zero-copy-deserialization), that all fields in an account using `zero_copy` deserialization must implement [Pod](https://docs.rs/bytemuck/1.7.3/bytemuck/trait.Pod.html). bool for example apparently is not Pod-compatible (*"The type must allow any bit pattern (eg: no bool or char, which have illegal bit patterns).*). So in conclusion, this means I can't use boolean fields in these account structs, right?
anyway, that's one of the reasons why one shall NOT run tests on devnet XD
interesting. 
rate limiting should not span too long based on this: https://docs.solana.com/cluster/rpc-endpoints
but maybe there is more and u simply got blocked as a spammer. 
I know that it happened with some people running candy machine on devnet
i have thousands of lines of devnet tests
oh yeah, i run a ton of tests straight onto devnet lol
maybe you did indeed spam devnet. were you running some devnet tests lately?
nope. still doesnt work.
will change tho
because the options in the first command mint to devnet 😉
well how do you expect to airdrop something on mainnet? XD
it's mainnet
Oh thanks :). I think like you but want to be sure
paste your config.
`solana config get`
can u plz airdrop me SOL
PDA is an account, it's in the name itself 😄
same thing, didnt work
try `solana airdrop 1 FzffpmKquwkCPtXNcXJ7Y82sLnRRQvQTRPtcGufnkRgd`
Can i transfer SOL to pda than transfer that SOL to other account?
:/
``` accrue % solana airdrop -u d 1 FzffpmKquwkCPtXNcXJ7Y82sLnRRQvQTRPtcGufnkRgd
Requesting airdrop of 1 SOL
Error: airdrop request failed. This can happen when the rate limit is reached.```
awesome, that's what I thought, but better to double-check.
in code examples payer and authority are the same (pasted below), so one might wonder... ;p
`anchor\tests\misc\tests\misc.js`
```
      await program.rpc.testInitAssociatedTokenIfNeeded({
        accounts: {
          token: token.publicKey,
          mint: mint.publicKey,
          payer: program.provider.wallet.publicKey,
          rent: anchor.web3.SYSVAR_RENT_PUBKEY,
          systemProgram: anchor.web3.SystemProgram.programId,
          tokenProgram: TOKEN_PROGRAM_ID,
          associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
          authority: program.provider.wallet.publicKey,
        },
      });
```

anyway, thanks!
It's the owner of the tokens, not the mint authority
ping 🙂


///////////////////////////////////////////////////////////////////////////////////////////////

