confirmed
i tried and got a RefCell with private value I cant read, which function to get readable datas ? Edit : it's OK
you just have to be careful when loading up the data
remaining accounts allows you to access the account data
even if I need to get accounts data ?
Your best bet is to use remaining_accounts
hi ! any ideas ?
can someone confirm this?
they take the median or something like that
I have started this thing that I pretentiously labelled `anchor-scaffold`
https://github.com/Arrowana/anchor-scaffold
It is the **escrow** program from the anchor tests a bit revisited, the idea is to provide a program + a react ui, to show how easy it is to go from a program to the user interface.
It will have a simple "Show all opened escrow accounts" component as well as a  "create escrow" component

The UI is not functional yet, nothing has been tested. Just sharing my diabolic plan.
has anyone gotten the following error when running `anchor deploy` on devnet? programs build fine but for some reason  one program doesn't deploy to devnet

```
Error: Deploying program failed: Error processing Instruction 1: custom program error: 0x1
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }.
```
To achieve
https://github.com/project-serum/swap/issues/15
with
https://github.com/project-serum/serum-dex/blob/0c730d678fd5ec0b07b17465e310a7f2a81b6681/dex/src/instruction.rs#L405-L418
NewOrderInstructionV3
I am confused as to how we can share a single OpenOrders account since the `[signer] owner` is used for the token transfer but also  for the ownership check of the OpenOrders account.
Should this owner be the the signer of the program holding the shared OpenOrderAccounts?
I'm getting this issue now, did you resolve?

UPDATE: https://discord.com/channels/428295358100013066/517163444747894795/885666361404178432
<a:aPES_Think:493353113332219924>
ive tried 0.16.1 and 0.16.2 and same problem with both. what confuses me is another type defined in the same folder but in a different file gets picked up
i'm on 0.16.1 fwiw if that helps
<:necc:412930064813129728>
generated the idl fine for me haha
<@!417857235079790592> I just put that code into my file for fun
probably need to look into the validators section of the docs https://docs.solana.com/cluster/overview
```rust

/// Allows defining authorization restriction on a loose set of roles
#[derive(PartialEq, Eq, AnchorSerialize, AnchorDeserialize, Clone, Copy, Debug)]
pub enum Roles {
    /// can access compounding related roles
    COMPOUNDER = 0,
    /// can access fee management related roles
    FEE = 1,
    /// can access admin related roles
    ADMIN = 2,
    /// can access vault management related roles
    VAULT = 3,
    UNKNOWN = 255,
}
impl Default for Roles {
    fn default() -> Self {
        Roles::UNKNOWN
    }
}


impl From<u8> for Roles {
    fn from(val: u8) -> Self {
        match val {
            0 => Roles::COMPOUNDER,
            1 => Roles::FEE,
            2 => Roles::ADMIN,
            3 => Roles::VAULT,
            _ => Roles::UNKNOWN,
        }
    }
}

impl Into<u8> for Roles {
    fn into(self) -> u8 {
        match self {
            Roles::COMPOUNDER => 0,
            Roles::FEE => 1,
            Roles::ADMIN => 2,
            Roles::VAULT => 3,
            Roles::UNKNOWN => 255,
        }
    }
}

#[account(zero_copy)]
pub struct Management {
    /// the protocol management authority can only access admin related
    /// functionality which is largely restricted to editing the whitelist
    pub authority: Pubkey,
    /// indicates addresses which are part of the access list
    pub whitelisted: [Pubkey; 5],
    /// indicates the role granted to the whitelisted address in the same index
    /// as the `whitelisted` array
    pub whitelisted_roles: [Roles; 5],
    pub buffer: [u8; 795],
}
```

this type gets completed missed by the idl
I am running into `Err(TransactionError(InstructionError(2, MissingAccount)))`
But i am building the instruction through program::acounts::<TheAccountStruct>
So how is that possible?
I'd be curious to know which types were failing
Hmm it doesn't really go into much depth about how network time is coalesced from validators into 1 unix timestamp
i've ran into an issue with the anchor idl that gets generated being unable to correctly parse accounts. Using the idl to fetch an account and print its values locally differs from what is emitted when printing the various account fields on chain.


I suspect this might be related to the issue i mentioned earlier where the idl was not catching some account types <a:aPES_Think:493353113332219924>
look for the `Clock` sysvar
are there docs for this?
```rust
let seed = &[<signer seed here>];
let seeds = &[&seed[..];
CpiContext::new_with_signer(..,..,seeds)
```

Or something similar to the above should work
anyone who knows what these would look like as Python type hints gets a cookie:
```
export type Accounts<A extends IdlAccountItem = IdlAccountItem> = {
  [N in A["name"]]: Account<A & { name: N }>;
};

type Account<A extends IdlAccountItem> = A extends IdlAccounts
  ? Accounts<A["accounts"][number]>
  : Address;
```
they have a pretty reliable way to get unix timestamps from all of the validators
timestamp
Which is a better way to measure time slot or timestamp?
thanks!
issue running: anchor test:  backup new install from source on mac (non- m1)
error: Failed to run test: mocha -t 1000000 tests/: No such file or directory (os error 2).

Nfo: + new setup on a backup older mac. had to build Solana from source, and anchor. anchor build and deploy works fine running my own local solana-test-validator. I can run a validator. 1.7.11.  If I spin up my own validator and run mocha test manually ' mocha tests/'  from examples/tutorial/basic-0. the test runs fine.. against the local validator i spin up. running anchor test from the same dir I get the mocha error. It seems like there is an issue with the build setup and linking, that the anchor test may be having an issue starting a local test validator?  hard to say as no other errors are present.  the bpf sdk and toolchain appear to be pointing to the correct location. It would be nice to get this machine working %100 as intended, anyone have an idea on why anchor test fails with mocha?  and I can run the same command locally? linking/path issue?  I dont see anything too useful in .anchor or logs.  

- thanks
hi, what was the procedure to find out the program_id before deployment?
Did that and I get a type issue when I try to use it for a CPI
just gonna send it
I thought mod.rs in subdirectory was deprecated but the compiler isn't complaining sooo
Thank you for this, it worked. People like you are why the world works
Here's all our logs: https://github.com/blockworks-foundation/mango-v3/blob/dd/marketorder/mango-logs/src/lib.rs

Here's an example of them being used in the client: https://github.com/blockworks-foundation/mango-client-v3/blob/dd/marketorder/src/scratch.ts


///////////////////////////////////////////////////////////////////////////////////////////////

here is some code which basically fires a transaction, and the retries with sleep and a success field called done to fast exit the retries https://github.com/blockworks-foundation/mango-client-v3/blob/main/src/client.ts#L215, code is a bit rough but has worked very well in practice
but yeah with everything
looking more for a wrapper thats better than the one i used in my tutorial
Yes, i am actually trying to replicate the code in anchor tests cfo program, but only the swap part. The code and address is used exactly as CFO and deployed also properly using test.genesis
do you mean with retries?
does anyone have a good pattern for try () catching() failed solana calls
sounds like you are trying to use a program that doesnt exist -- are you sure you deployed everything and are pointing to the right address?
I am getting custom error 0x1000685, anyone knows whats up?
Context: trying to CPI into swap code
hmm ok I just deleted it and manually went through to get rid of enum usage
is there a workaround for this error: `Error: Tuple enum variants not yet implemented.` from `@project-serum/anchor/src/coder/idl.ts` 
i'm currently working on integrating an anchor program with raydium and trying to use the instructions.rs file that they have open-sourced directly. I suspect the issue is related to this: ```
#[repr(C)]
#[derive(Clone, Debug, PartialEq)]
pub enum AmmInstruction {
      Initialize(InitializeInstruction),
      ...,
      Deposit(DepositInstruction),
}
```
yes
Can `has_one` be used multiple times on an account?
It was an error on my side with the CPI IDL and cargo dependency versions out of sync.
I think i figured out the reason!
Yes I did
Did you use `declare_id`?
Should work on 0.16.1. Is vault a custom type or a cpi type?
i am running on 0.16.1
hm is this a 0.17.0 feature?
I got a different error: the trait `Id` is not implemented for `Vault` when changing it to Program<'info, Vault>
I have access
Yes
i.e. in the same crate/repo/etc
do you have code access to the struct you need?
`Program` is a struct saying that the public key being provided should be that of a deployed program
Vault in my case is just a struct used in the CPI program.
Doesn't program here refer to the whole anchor program?
https://project-serum.github.io/anchor/tutorials/tutorial-3.html#defining-a-puppet-master-program
try as `vault: Program<'info, Vault>`
I am defining it like `vault: Box<Account<'info, Vault>>,`
how are you defining it in the context struct?
I am trying to pass an account that is  owned by another program  to my handler for CPI. But the handler for my program is failing with `The given account is not owned by the executing program`
thank you
cool
Ah nvm it's correct just scroll to a section Called program derived addresses
Oops wrong link hold on
I think this is what PDAs are mainly used for program derived addresses.  https://docs.solana.com/developing/programming-model/calling-between-programs
Hi guys. I come from Ethereum world. I want to create a program which allows users to transfer tokens from program to another account (user passes in pubKey and amount, program sends x tokens to y address). In Ethereum it is possible for a contract to hold ERC-20 tokens and can transfer them during the contract execution. Is there an option for Solana program to own an account with token X and transfer this tokens during the contract call so anyone can sign this transfer tx?
eth has their own custom wrapper over bn.js
oh after researching it you need the BN library since its the only one that supports this package https://www.npmjs.com/package/elliptic
bignumber.js has everything i need -- but anchor is using BN.js so
https://github.com/indutny/bn.js/issues/79 dont erally want to write my own custom wrapper over bn
currently using bn.js but it doesnt have all the lazy stuff i want
is there room to discuss the BN library in anchor
Yeah that find command but in project root
Knowing which specific file I need to remove would come super handy
Would you know where is the particular .DS_Store that is causing trouble though? Can't see any in my project folder at any level. But it's definitely the cause of the issue as only way for me to be able to build again is to "sudo find / -name ".DS_Store" -depth -exec rm {} \;" (i.e. remove all .DS_Store file) in-bteween each run.
Thank you !
the owner could be PDA not the token account itself (necessarily)
it's just an optimised getProgramAccounts + filter
30 minutes wasted looking everywhere
i was adament i set declare_id, but i did not
omg
https://github.com/Arrowana/anchor-scaffold/blob/master/app/src/pages/EscrowPage.tsx#L128-L161
One of those accounts give `AccountNotProgramOwned`, not easy to find which one lol
The only difference is that those files are in the same folder of `lib.rs` .. so the problem is with the `#path` macro I guess
And I have another modules declared almost the same way:
```
pub mod errors;
pub mod utils;
```
Yes sure ... I have dependencies from another files which I am declaring in the `lib.rs` file as follow:
```
#[path = "clients/base.rs"]
pub mod base;
```
I'm not sure. Can you clarify what you mean by modules?
<@!501570363566587905>  I removed some modules dependencies I had in `lib.rs` and I am not getting the error anymore and the IDL file is being generated ... any suggestion ?
WSL2 for windows .. Ubuntu 20.04
I thought testnet was down, didn't check went back to building.
I'm on mac os
Are you using macOS?
And of course with `anchor build` the file is not generated because of that error
I get the same error when I run `anchor build` .. that's why I tried to run the `anchor idl parse` separated .. at the end anchor build run `anchor idl parse` as the second command
Can you run `anchor build` and does the idl get generated?
Hi .. I am running the IDL parse command to generate the IDL file of the program and I am getting this  `Error: could not find file` ... something weird since the file exists in the path I am putting in the command ... this is the command with the parameters: `anchor idl parse -f programs/app/src/lib.rs -o target/idl/app.json` .. what could be happening ?
üò¶ were you able to deploy to testnet?
Still no for me
I'm getting this error as well. Does anyone know if devnet is having trouble?

UPDATE: Reading above, I'm trying the following but still no luck

```
0) deploy anchor deploy --provider.cluster devnet

1) solana-keygen recover -o recovered-id.json

2) Paste 12-word seed phrase from the intermediate account's ephemeral keypair

3) solana program deploy -v target/deploy/solarwind.so --buffer recovered-id.json
```
https://github.com/project-serum/anchor/pull/862 here is some more
you wan types
Awesome!!
https://github.com/project-serum/anchor/pull/861
otherwise this is unfair hidden knowledge
I am going to PR this on the escrow test
LFG
ok
it 2 lines i can get extract the type to use it wherever
WAT

oh no
on the account namespace
while fetch is totally happy
I don't see any logical reason but fetchNullable refuses to type check properly after a null check
typescript, how to become mad
having types on that thing is pretty good to navigate the fetched objects
Am i right if i say 0.17.1-beta is missing the ability to get an interface for each Accounts ?
https://github.com/saber-hq/saber-common/blob/master/packages/anchor-contrib/src/index.ts#L200-L214
This in anchor-contrib gives access to Accounts, which gives you a thing for each defined account in the idl
I'd try it out on a dummy key.
will it continue to use the final program address? I'm using a grinded one that I want to use
but i guess that's better on 0.17.0?
It is weird to run into stack size issue when there is very little going on
Try doing `const program = anchor.workspace.Tester as Program<Tester>` üòà
Yup
got it! certainly not a full client stub, but will save a bunch of time
so like `solana program deploy target/deploy/prog.so --buffer recovered-id.json` ?
will give it a shot üôÇ
i'm pretty new to this, but that's my take
if you haven't started, you create your project with `anchor init --typescript` and then just `anchor build`
you happen to know what the command is?
Use `solana program deploy`.
so like
```
solana deploy target/deploy/prog.so recovered-keypair.json
```

?
so I just do a solana deploy with the binary that anchor gave me?
Your error might be because you dont have enough SOL.
Use the solana cli for that.,
can anchor resume failed deploys?
anyone seen this before? mainnet deploy 
```
Error: Deploying program failed: Error processing Instruction 1: custom program error: 0x1
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.
```
got it
i think it's very new, you'd have to build from `master` and use the 17.1 ? beta npm
does anchor support automatically generating typescript clients? I've been reading through jet-v1 trying to get a better idea of how this works and can't tell if this is generated or not https://github.com/jet-lab/jet-v1/tree/master/libraries/ts
super helpful, thanks so much!
That createTokenAccount instruction is expected to happen outside of the logic of the escrow example, as the escrow example currently expects those token accounts to exist already, so in order to create a Token Account for a user I think you could:

- As a learning example: modify the program and add the `init` keyword in the program to those token accounts (however the execution will fail if the token account already exists)
- Pass the create token account instruction as a preceding instruction via the `instructions:` attribute in the RPC in your JS code. (Sadly I don't have an example to this at hand, but will try to find one)
- Create the token accounts in a different transaction, similar to how it is done in the escrow js tests. However I guess for a general use case you are not going to own the mint authority so the code is going to be slightly different from what there is in the tests

And a couple of thoughts:

- Currently the escrow example does not use any PDAs (which perhaps a more intricate version should) - so currently you don't really need `Pubkey::find_program_address` or the concept of `seeds`/`bump` - however it is an important concept that you will very likely need in the future
- Also, I would recommend you to look into ATA (Associated Token Accounts) to  use the canonical token account for a given user and mint, in order to avoid creating too many accounts
at the very least learned a lot about the `CpiContext` stuff üôÇ
might have gone too far out of my way solving a problem that doesn't exist, ha
sure thanks, it's just the sample escrow program, i'm trying to make a client for it, and i think in the test i saw this:
https://github.com/project-serum/anchor/blob/master/tests/escrow/tests/escrow.ts#L62
and i'm not sure when that is called if folks would have to approve a transaction or not (which would mean 2 transactions to start), since i don't want it to be too cumbersome
In your example it seems you are using a Program Derived Address (PDA - given that you are providing those `with_signer(&[&seeds...` ) for which its related token account must be created from within the program, but perhaps you don't need a PDA?  -- maybe if you share a bit more of context or the full program we might be able to give you some pointers
No, you'll need to create the account within a transaction‚Äîyou'll pass the desired address in from the client, and then a token account will get created/initialized and live at that address
ha i can work under that assumption and see how far i get, don't want to take too much of y'alls time, thanks
ok i think i just didn't have the concepts laid out correctly -- to create a token account doesn't require a transaction, so you make that off-chain and just pass it in?
I think you've already got the address, since you're passing it in as an account (it will be ctx.accounts.the_token_account.key())
i need to create a token account and then do something with it in the same transaction, is all
no sorry just identifying the address, would it be `Pubkey::find_program_address` ? i'm just starting to really get my hands dirty with this stuff, so apologies if the question doesn't totally make sense
what do you mean by collecting the account? Closing it and claiming the rent?
if i have something like
`token::initialize_account(ctx.accounts.into_initialize_token_account_context().with_signer(&[&seeds[..]]))`
what's the best way to collect the account that is created?
okay - figured
might be possible, likely very complicated
I'd assume no - but I'm not too familiar with localnet internals
is there a way to use the jetbrains rust debugger from anchor test?
`solana program dump`
get Program accounts is not so good but to get all owned token accounts there is a rpc call, it might be behind some optimizations
is it possible to get the ELF for a program given just the program id / how would I do so?
Once you have the ELF you can just run it locally
yup
is there a way to test against a program that is closed source locally by dumping the bytecode?
I filed an issue here https://github.com/project-serum/anchor/issues/857.
going to think more about this idea of creating IDLs for non anchor programs
good rant imo
/end rant
like these were the steps i had to add to the tests to init an ATA and mint to it
<https://github.com/project-serum/anchor/blob/24d07aa41b0b4e368f1467e315ca0357a7e3febb/tests/ido-pool/tests/ido-pool.js#L161-L183>
for sure, having a consistent API for all programs (including the SPL token program) would be a big quality of life improvement
Yes this is something you can do with existing anchor programs.
I misread your message.
but it's like a getProgramAccounts + filter job
i haven't had to do it before
even initing an ATA is a pain
How do you do this with the spl token program?
it would be great to have easier token library stuff
this is something that can already be done with existing anchor programs?
Correct. In theory.
And similar such things.
which would allow you to reuse a lot of the client functionality that anchor already has for basic stuff?
So that I can do `await program.account.tokenAccount.all()` to get all my token accounts.
And then use that + some custom serializer to generate a client.
Just manually create an IDL.
Not even a wrapper.
except somehow with actually needing CPI
so like a full anchor wrapper program for SPL token program that generates an IDL
I find it so frustrating to do the most basic of things.
Use something like `@project-serum/anchor` to create a client from IDL.
it seems like the `Token` class from the spl javascript library is missing a lot of functionality
what does it mean to `generate clients for` something
i didnt understand how you fixed it, can you PM me so i could know about the details
It's pretty silly that I copy around this file everywhere https://github.com/project-serum/swap-ui/blob/master/src/utils/tokens.ts
APIs like, "give me all the token accounts for this wallet" should be easy. But there doesn't seem to be any clean api?
Everytime I use the client I forget the APIs and need to go look at the source.
We really need  to generate clients for the SPL token program don't we?
I found a solution here: https://discord.com/channels/889577356681945098/889577399308656662/896260926787948564
hi did you find a solution for this
Filed https://github.com/project-serum/anchor/issues/855
We need an Anchor.toml setting to specify the out directory of `target/types/<idl>.ts` to make UI development faster.
Starting a war.
WTH is happening here
its really hard to write clean TS
thats just lazy or bad JS, and bad typescript is much worse. I wish I could show you some of the amazon prod code for aws. maybe i will do it in lisbon lol


///////////////////////////////////////////////////////////////////////////////////////////////

thanks, looking into it
thanks for looking into it ‚ù§Ô∏è
so its failing on apply_risk_checks, hmmm
`apply_risk_checks` emits an event, which is probably the long encoded program log in your screenshot
I'm looking at the swap program's `swap` ix handler (the thing you're invoking via cpi) here https://github.com/project-serum/swap/blob/master/programs/swap/src/lib.rs#L96
hmm now it seems the error is coming from Token Program

wait i will show error log, it will make more sense i think
yes but inside swap, it calls DEX
Maybe https://github.com/project-serum/swap/blob/master/programs/swap/src/lib.rs#L720 ?
Isn't that talking to the swap program, not the dex?
<@!134416332509675520>
https://github.com/project-serum/anchor/blob/c004b0f99cc08f79290d9b6d53d6d6cab8f362ab/tests/cfo/programs/cfo/src/lib.rs#L123-L138
almost similar to this call
<@!794602437440569364> ^^^^^^
Which CPI call are you doing?
https://github.com/project-serum/serum-dex/blob/master/dex/src/error.rs
here is the code, but i am not getting anything meaningful, maybe because i am such a noob idk
and there is no proper documentation i could find
Check their code for custom errors
I am CPI into that
but the problem is, the error is coming from Serum Dex Program
Custom errors start from 300
Yeah, that's your custom error.
error is 0x12e, == 302 which means its coming from the program itself
The code you see is hexadecimal, convert it to decimal (base 10) and check the message matching that enum here https://github.com/project-serum/anchor/blob/master/lang/src/error.rs
If you take a look here, we have a "nested" struct https://github.com/StreamFlow-Finance/timelock-crate/blob/a8a1ab8d476a881583e17a261c74825f6283e8f7/src/state.rs#L156
but the parser just flattens it (as it is represented in a memory)
This is parser's output https://gist.github.com/imprfekt/9ab9135fd88f2aa4504cd362e7ee2b03
This is parser's input https://github.com/StreamFlow-Finance/timelock-crate/blob/master/src/state.rs
rust struct to buffer layout parser
ok, do you have any example of nested buffere layout structs?
Anyone knows how to debug custom program errors on Serum Dex code, its difficult because there is no IDL generated

Any help would be greatly appreciated ‚ù§Ô∏è
Just a bit. And then a bit more to support types like ConfigData and Creator
You'd have to tweak it a bit to support other primitive types (bool, u32, str, u16...)
First I would like to learn how to do that manually...
Out of the box, no. It's a custom made simple parser, but easily extendable.
would it work?
```
#[account]
#[derive(Default)]
pub struct Config {
    pub authority: Pubkey,
    pub data: ConfigData,
    // there's a borsh vec u32 denoting how many actual lines of data there are currently (eventually equals max number of lines)
    // There is actually lines and lines of data after this but we explicitly never want them deserialized.
    // here there is a borsh vec u32 indicating number of bytes in bitmask array.
    // here there is a number of bytes equal to ceil(max_number_of_lines/8) and it is a bit mask used to figure out when to increment borsh vec u32
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Default)]
pub struct ConfigData {
    pub uuid: String,
    /// The symbol for the asset
    pub symbol: String,
    /// Royalty basis points that goes to creators in secondary sales (0-10000)
    pub seller_fee_basis_points: u16,
    pub creators: Vec<Creator>,
    pub max_supply: u64,
    pub is_mutable: bool,
    pub retain_authority: bool,
    pub max_number_of_lines: u32,
}
```
We've created this: https://github.com/StreamFlow-Finance/timelock-crate/blob/master/misc/gen_js_api.py
Might be of use
ty <@!134416332509675520> ‚ù§Ô∏è
Any good resource to learn how to construct buffered layout struct from rust structs (also nested)?
Heh, if you're using anchor's ts stuff, it happens here ü™Ñ https://github.com/project-serum/anchor/blob/master/ts/src/provider.ts#L105
https://tenor.com/view/rainbow-spongebob-imagination-gif-8764636
üòÑ
what kind of sorcery is that????
hmm let me try that
If the wallet is already part of the `provider`, then you don't need to (it will already implicitly sign the tx)
Looking to pass the Keypair to the `signers: []` array
(not `NodeWallet`)
Any way to get Keypair from the `Wallet` (from this package https://github.com/project-serum/sol-wallet-adapter)
cool, thanks for the pointer <@!501570363566587905> . saved me some time üôÇ
`@solana/wallet-adapter` supports spl-token-wallet.
awesome
This is correct.
There's a `useAnchor` hook there.
wouldn't `@solana/wallet-adapter`. be a substitute for `sol-wallet-adapter` though? not `spl-token-wallet`? or do they support both use cases
oh that's great to hear üôÇ
https://github.com/solana-labs/wallet-adapter
Though I'd recommend using `@solana/wallet-adapter` instead.
Yes definitely.
hey all, digging into this now but thought I'd ask in advance: is it possible to wire up anchor with `spl-token-wallet` as the signer? we've been using `sol-wallet-adapter` fine for a bit now, and have a new use case that could benefit from being more like a wallet than a dapp
oh that's excellent
which is just not really worth the effort
the only way i knew to technically do it would be to deinitialized/close and reinitialize a new account with duplicate data and a larger space allocation when needed
this is exciting!
Yeah. It sounds like Solana may (soon?) let you resize account allocations: https://github.com/solana-labs/solana/pull/19475
e.g. using a `Vec<T>` but setting a memory cap at 15 elements or something in the `space` constraint
you _can_ have dynamic sized fields in account data but during initialization you need to specify the max size you'll allow it to occupy
can account data be dynamically re-sized? specifically wondering if it's possible to store an array/hashmap in account data and add/pop from those data structures in later instructions
ahhh you've had this discussion earlier.
Is there an (example) implementation of a **web app client** using anchor?

Basically I want to have all the Anchor goodies like IDL, workspaces, program RPC invocation etc, just like in `/tests` JS file, but from the web app.
You sure , you are passing the right address and it matches with the declare id of the program you are trying to CPI
Hi, I have two programs implemented in Anchor and I try to do a CPI but I receive this error: `Transaction simulation failed: This program may not be used for executing instructions`, any idea why?
has anyone seen an error like this before: ```    'Instruction references an unknown account SysvarC1ock11111111111111111111111111111111', ```
I'm still working on a raydium integration and need to construct an instruction using account metas and I am including the clock when constructing the instruction as follows: 
```
let accounts = vec![
... 
          AccountMeta::new_readonly(sysvar::clock::id(), false),
...
]
```
if you type anything with the object you need to do `typeof Side[keyof typeof Side]`
```const Side = {
  Bid: { bid: {} },
  Ask: { ask: {} },
};```
Why are "enum" so abject
Gnoot.
gotta get some sleep for once, gnoot
i don't have the pleasure of using the strong typings yet. gotta have my team's internal fork updated first
just a lot of pubkeys to manage on the client side
or just a bit
cannot go wrong
with the types no stress
i'm sure calling that instruction from the client is fun
i think 27 is about the max you can fit if they are all unique
but still, 27 is quite large lol
well i'm not talking about `Context` account structs, i was talking about the accounts themselves
not sure if that helps
I am using a total nesting of composites though
because i have seen stack size break with much less
I don't exactly know why
you absolute mad lad
how about that
i have a Accounts with 27 accounts and no box
but yeah i tend to wrap (at the very least) all custom `Account<'info, T>` fields in boxes
that'll do it
ahhh i see, i had an absolute chonk of an initialization function that kept giving me stack errors, wrapping in box solved it for me üòÑ
it was because of a memory allocation update to the core solana protocol
yeah thats more or less right. depending on account data sizes, you can get some non-fatal compile errors on your programs about stack offset overflows
not necessary for `Program<'info, System>` or `Program<'info, Token>`
my understanding is it helps to avoid the stack frame size issues, not sure if this is correct though
I always do nowadays, especially with bigger account type sizes
is it recommended to use the Box around all Account and Program types
can't really do many tangible things without the connection object
if connection was moved out of provider so that solana rpc calls can be done without it, then that would be a good use case
i think the issue is that the connection instance is on the provider at the moment
I don't really see a case where node wallet would be a thing in a browser
maybe some behaviors need to be node only or something
yep, just realized that
yes but if you don't provide it it uses the fs wallet and implode
a crap workaround is `{} as Provider`
ah damn, where are we at with Program to be usable without a provider?
https://github.com/project-serum/anchor/blame/master/ts/src/program/index.ts#L253-L258
feel free to discard, but might be nice to also have the names of custom errors accessible through the idl error parsing functions
https://github.com/project-serum/anchor/pull/869
just opened a PR for the TS client
I wonder if we can get args to type properly but typescript doesn't seem to be able to do that
Typescript transpiling is buggy
```(typescript) Error: /home/arowana/projects/professional/mer-monorepo/libs/use-X/src/lib/X.ts(58,7): semantic error TS2554: Expected 2 arguments, but got 4.
Error: /home/arowana/projects/professional/mer-monorepo/libs/use-X/src/lib/X.ts(58,7): semantic error TS2554: Expected 2 arguments, but got 4.```

but this method signature is mercurialExchange: (...args: [...unknown[], Context<Accounts<...
Sloppy PR.
based af
ty arrowana: https://github.com/project-serum/anchor/pull/719
classic trap
It turned out that the issue was  in `anchor-spl/src/dex` there's this block: 
```
#[cfg(not(feature = "devnet"))]
anchor_lang::solana_program::declare_id!("9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin");

#[cfg(feature = "devnet")]
anchor_lang::solana_program::declare_id!("DESVgJVGajEgKGXhb6XmqDHGz3VjdgP7rEVESBgxmroY");
```
I was trying `anchor build -- --features devnet` followed by `anchor test --skip-build` , but needed to have features be passed through to `anchor-spl` which is done as follows: 
```
# Cargo.toml
[features]
...
devnet = [ "anchor-spl/devnet" ] 
```
no point having 2 files if the ts always need them both
ah sweet, I'll try out those options, thank you!
Less invasive, you might be able to change the `Program<'info, ProgramName>` you've got into a `AccountInfo<'info>` to skip the id check, and just log whatever `.key` it ends up having/versus whatever `ProgramName::id()`  says it's *supposed* to be
Kind of hacky, but if you're willing to edit the anchor source you could try sticking an extra log here https://github.com/project-serum/anchor/blob/master/lang/src/program.rs#L25
I'm working on a raydium integration at the moment and trying to test against the program that I deployed to devnet but running into issues with `    'Program log: Custom program error: 0xa8',` which I found to be `InvalidProgramId`  and based on prior discussion it seems like I am passing in the wrong program ID for one of the `Program<'info, ProgramName>` . 

Is there a good way to verify which one of these program ids is off?  I thought it was an issue with the cfg features where I wasn't building with `devnet` feature enabled but still getting the same error afterwards.
thanks, also very helpful
Maybe better than having multiple files, though.
Is that too jank?
https://github.com/project-serum/anchor/pull/860
lol
ah
idl json
That's in the same types file now
Don't you need the json as well?
This would be helpful https://github.com/project-serum/anchor/issues/855
`Before we can interact with a program on the localhost network, we must switch our Phantom wallet to the proper network.

To do so, open your Phantom wallet and click the settings button. Then scroll down to Change Network:`
You don't actually have to, it is just convenient to see what is going on
It is also a bit wrong
The only reason I don't like that tutorial is bcs they have used wrong Anchor logo...
This is making some progress, not there yet:
https://github.com/Arrowana/anchor-scaffold
- run anchor localnet
- copy idl files to react app manually
- yarn start
You get an app which has as typed `Program<Escrow>`, there is a bootstrap button to get aidrop + mint 2 tokens into the connected wallet, you can already created an EscrowAccount.
Next step is to add exchange.
I am not going to spend time on making the UI not horrid, but if someone wants to help that should be easy
wasn't getting the connection between
`anchor.setProvider(provider);`
and 
`wait program.rpc.create`
ok that clears a lot of things up, thanks guys
New accounts being created on solana need to sign the transaction (unless you're using a PDA, which does the "signing" inside the smart contract itself).
oh ok, thanks, i'll look at it again
Ah, ok, I think he's still signing things with the phantom wallet though (it's embedded in the provider, and that's how it auto-pops up to sign things‚Äîno need to explicitly include it in the `signers` array)
This is actually expected. The keypair being created is the new account data.
I haven't read it lol, will take a closer look
Oh, interesting üëÄ
thanks, i saw that but the code in there is a little weird, it shows you how to connect a wallet and then on the side creates a new keypair that it actually uses instead of the wallet
There's also this great big react + solana + anchor tutorial https://dev.to/dabit3/the-complete-guide-to-full-stack-solana-development-with-react-anchor-rust-and-phantom-3291
Awesome man, thanks a lot again üôÇ
yeah i use the `@solana/wallet-adapter-xyz` packages in my own projects and they work fine
I suppose it is
You have tried out the Solana one no ? Is it functional ?
not sure what the functional differences are
hahah yeah a lot of project build custom browser wallet integrations for some reason. the core solana labs team has the `@solana/wallet-adapter-react` component library and then i think the project-serum org has one of their own as well
Thanks for the wallet-adapter-react ! I did not know about it and did this myself u_u
this sample also assumes there is another component somewhere that handles allowing users to do the wallet logins
ok wonderful, thanks so much!
the rest should work normally with the program instance namespaces
i have something similar to that for instantiating the program with a browser wallet
```ts
import { useEffect, useState } from 'react'
import { Idl, Program, Provider, Wallet as AnchorWallet, web3 } from '@project-serum/anchor'
import { useConnection, useWallet as useSolanaWallet } from '@solana/wallet-adapter-react'
import idl from '../../idl.json'

const programId = new web3.PublicKey(SOL_PROGRAM_ADDR)

const X: FunctionComponent = _props => {
  const [program, setProgram] = useState<Program | null>(null)

  const { connection } = useConnection()
  const { wallet: solanaWallet, adapter } = useSolanaWallet()

  useEffect(() => {
    if (solanaWallet && adapter) {
      const provider = new Provider(connection, adapter as unknown as AnchorWallet, {})
      setProgram(new Program(idl as Idl, programId, provider)
    }
  }, [adapter, connection, solanaWallet])

  render() {...}
}
```
ok hang on. mines a private repo so i have to replicate here
yeah
are you using react?
does anyone happen to have a good example of using an anchor program with a browser wallet (like phantom)? it seems most of the tests/examples assume that the private key known
Updating my solana cli to the latest version allowed me to deploy to devnet üòÑ
blockhash is fine too if the id isnt possible
wonder how computed could be estimated, also transactionId is usually a server response no?
RABBIT HOLE üï≥Ô∏è
also i dont know how to get the transactionId pre sending the transaction but if there was a way to display that before it gets sent off that would be cool
a place to handle call backs for each ping/status, error message middleware, estimating fees / compute cost ahead of time, a place that details what the accounts being called are in the idl in human readable format etc.
what are some of the other things you would want?
hahaha
thank you though
lol
this like 5% of the amount of features i want


///////////////////////////////////////////////////////////////////////////////////////////////

thanks
<@!149990576572334080> https://discord.com/channels/428295358100013066/517163444747894795/861125076116045845
I think it's the end of the transaction.
<@!501570363566587905>
Yes! Will keep this channel updated on what I find with setting browser breakpoints and how my issue gets resolved
Didn't end up solving it on the phone, seems like <@!738425008266674277> is doing things as expected/IDL looked normal (only expecting one signer, which is supposed to be the wallet). They're going to set some browser breakpoints and try to see why the signature verification part fails
Hey everyone. To test our protocol on test/devnet, we need a usdc faucet. I know about this one: https://usdcfaucet.com/. The problem is that it only allows 5usdc per IP. Is there a way to issue more usdc at a time? Thx!
If you want lol I'm happy to do a discord call real quick, might be quicker than text and I won't need to look at any code üôà
Maybe I can ask one of them to get in on this conversation
I'm with you on that one üòì
üò¶
Inside your program, yes. At the API/IDL layer, no. You'll need to define a custom type that transaltes back and forth.
I have been told by my higher ups that I'm not aloud to share anything outside of the client code or test file:

attached is the function in the test.js file
According to your error message, the transaction is expecting you to sign the transaction with a key. But it's not signing. Can you share your IDL?
no
And does the smart contract expect bob or charlie to sign?
does anchor support the fixed crate? for fixed point floats?
Here's what I'm working with
hmm ok i got this fixed, but i closed the program account and saying i need a new program id...is this recoverable?
Sharing the code would help a lot. Otherwise i'll speculate that your generated keypair should be signing the transaction.
In my client Alice doesn't exist and I'd assume the wallet of the user would take its place but the shape is different from a generated keypair
In my test js file I have Alice (generated keypair) signing the transaction.
Do you need any other accounts to sign?
still getting this error: https://discord.com/channels/889577356681945098/889577399308656662/897530568043028530
(assuming that is indeed the provider being used with the client)
Right. Just omit it then.
`payer` attribute doesn't exist on that object
Also, you dont need to have a signer like that with the provider. It will implicitly sign all transactions, since it pays for them.
Use `provider.wallet.payer`
Gotcha, now I'm getting `Signature verification failed at Transaction.serialize`
Yep or you can just remove the `signers` arg entirely
Do I just leave it like this: `signers: []` ?
You shouldn't actually need to add the wallet to the signers array (it will automagically sign the tx for you)
Has anyone encountered this issue when attempting to sign a transaction through an rpc call? `unexpected type, use Uint8Array at checkArrayTypes`

currently how I'm signing my rpc call: `signers: [provider.wallet]`
Hi, How can I get the transaction of my NFT collection from other market places?
Sounds like there's still an account that needs to be removed.
i deleted the buffers for the program but still can't get the redeployment working. any ideas?
so i forgot to airdrop my program deploying wallet (for devnet) and when i went to redeploy afterwards, i'm now getting this error
`Error: Account XXXXXXXXXXXXX is not an upgradeable program or already in use`
Probably missing some other signature , yeah i think so too
Sb have experience with closing accounts ? After we close it it stays alive until end of transaction of end of block ?
Signature verification failed can happen with not passing the required signers in the array too, not just provider.wallet
Hmm. Are you missing some other signature? I thought you'd get a different error if you were, so actually not sure what's wrong ü§î
Yes Phantom prompts and asks me to approve
`const wallet = useWallet();` from `@solana/wallet-adapter-react`
`const provider = new Provider(connection, wallet, opts.preflightCommitment);`
Ah, interesting, how are you constructing the provider etc.? Is phantom actually prompting you to sign?
Ok thanks! However, I still get `Error: Signature verification failed` üòÖ
Happens here https://github.com/project-serum/anchor/blob/master/ts/src/provider.ts#L105
No need to add it to the signers array, it will automatically sign the tx üôÇ
Hi folks, I was only using anchor test until now (with the local wallet). I just added Phantom wallet to the provider, how do I sign the rpc call now? `signers = [provider.wallet.payer]` is undefined
You could try defining test.genesis in Anchor.toml. There are some examples in anchor repo, just search
no easy to way to tell anchor to use a specific key for deployment? It's always using the key that has the same name as the `name` in Cargo.toml
Is anyone using jetbrains products for anchor dev? I feel like it can't properly deal with the `#[program]` macro, lots of highlighting acting acting weird, parameter hinting acting up ü§î
How do I send lamports to a SPL account?
Any clues?
For example, one of the errors is that `module 'accounts' is private`
Hey, I''m trying to use Anchor to achieve cpi with this program (https://github.com/metaplex-foundation/metaplex/blob/master/rust/nft-candy-machine/src/lib.rs) from my program, but I'm not managing to do the imports like in the tutorial: https://github.com/project-serum/anchor/blob/master/examples/tutorial/basic-3/programs/puppet-master/src/lib.rs
Testnet doesn't work actually, my bad
Yes it does works
it's just one thing to try. See if it's accessible
Since you said testnet works
You mean pinging api.devnet.solana.com ?
Not that I'm aware of, located in Hong Kong. Checking
can you ping the address it tries to connect to?
firewall, proxy, vpn or something?
Everything working fine on localnet
I'm using latest anchor cli from github, using same version in the program. I'm on mac on a full rosetta install
Resuming the failed deployment fails too (even after 5+ attempts)
Always with 
`ConnectionError(Protocol(HandshakeIncomplete))`
I think I have an issue with devnet deployment but I'm not sure why. Does anyone has a clue? Been unable to deploy there for more than a week now <:pepeThink:844646497911046164>
should we fix and use referral and referrer, or go with
referrer (the account taking the fees)
fee tier account (the account to calculate the fee tier)
but it is using referral everywhere
new order wants the referral (the account holding the tokens to calculate fee tier)
settle funds wants a referrer (the account taking the fees)
<@!501570363566587905> I found a pretty confusing usage of **referral**/referrer in the cpi
Also having another program makes it reusable, if generic enough
extend when it makes sense to be the same thing, try to split to multi program if there are some clear cuts in the feature set
not really
when do you reckon it's a good idea to create a new program vs extending an existing one? 
Guess that's again the microservice vs monolith debate üòÇ
```
Running: cargo +bpf build --target bpfel-unknown-unknown --release
```

oh yeah it does
was a bit confused cause it says you might need a cache, but compiling here on my m1 mac is still just taking a few seconds max
great! thanks
It uses cargo build-bpf's default, so yes if I'm not mistaken.
since `anchor build` doesn't have flags support, is it always using the release profile?
Wonder how feasible it is
off question but did anyone try using accounts without paying the rent exemption upfront, but instead fund them regularly or let them expire in a specific timeframe?
that's a good point, I didn't consider initial account rent cost
try on devnet, you will see your balance remains the same after the first deployment
txs cost about nothing
yes, but the cost is in the account rent, not the txs
what do you mean? A deploy on a existing program always sends the same amount of transactions to upload the entire binary, no?
redeploying cost nothing much, it closes the old buffer and you get back the SOL
oh damn, I didn't think of compiler settings
So the binary is too large? Did you try this https://discord.com/channels/889577356681945098/889606719829835816/896559943610662962
Morning anchor people! 
We got the issue that our program hit a point where it costs around 2.5 SOL to deploy it. A lot of functionality is in PDAs so only the program itself can sign for those, but the 2.5 SOL per deploy to add new things is becoming an issue. 
Anyone a good idea how to manage this? For example I want to add a new method for a feature, but it'll further inflate the program. I can't break it out into a smaller program either though because it needs to access a PDA owned by the main program
Yes it's returned when a `#[account(constraint = <express>)` is violated.
Trying to execute a transaction through devnet multisig but seeing the error 0x8f which maps to `ErrorCode::ConstraintRaw`. Anyone familiar with this error? https://github.com/project-serum/anchor/blob/d774b456bf92c48cc89a29b22d03a54ffa37604e/lang/syn/src/codegen/accounts/constraints.rs#L236
did you end up decoding this yourself haha
oh gotcha yeah that makes sense
Uhm you should just need to specify `space = 96` you would only need to do `+ 8` if the user info account were anchor based, but raydium isn't so theres no account discriminators
yupp
do you mean when you use `#[account(init)]` ?
wait i think i may have misread your question
uhh no idea tbh, i always manually initialize the accounts
I managed to figure out with trial and error...
gotcha, yeah it's dual rewards so 96 bytes -- do you know if I have to specify the space explicitly when initializing the account with `space = 8 + 96` or would it default to that assuming the `Account<'info, UserInfo>` where `UserInfo` is 96 bytes.
if its not 88 bytes
is the pool dual rewards, or single rewards? if its dual rewards you need to allocate an account size of 96 bytes
ah ok we got that error when we deployed our own raydium program to devnet but this was awhile ago so i guess someones setup a devnet raydium deployment. Anyways, that means the issue is likely coming from you having not allocated the correct user info acount size
i don't think that's true there's a text file floating around in the raydium discord with the program ids for a pool on devnet was able to deposit into the pool and get LP tokens looks like there are logs from the staking pool `'Program log: process_deposit amount: 9161511'`
you'll basically need to create your own amms, etc.. on devnet in order to get it to work
this is happening because Raydium isnt currently deployed to devenet, so the various accounts you need to interact with dont exist
I'm constructing the instruction which is a vector of AccountMetas based on the code at 352. For the user info account I'm not certain but it looks like theres information about the structure here: 
https://github.com/raydium-io/raydium-ui/blob/8d398a56e05780029b56265dd004b66a78246a77/src/utils/stake.ts#L539
so I created a `UserInfo` struct based on the layout and created the user info account as `Account<'info, UserInfo>>`
I'm cross-posting this from the raydium discord if someone has encountered anything similar:  

For depositing into staking v4 on raydium via cpi, I'm attempting to test against devnet and running into the following error: 
```
  'Program HQzzwwBbzHUpYrc9u4VKn4XiAne5fsh444Jp9uuTE5A3 invoke [1]',
    'Program log: Finished constructing cpi context',
    'Program EcLzTrNg9V7qhcdyXDe2qjtPkiGzDM2UbdRaeaadU5r2 invoke [2]',
    'Program log: Instruction: Deposit',
    'Program log: process_deposit amount: 9161511',
    'Program log: libstd rust_begin_panic',
    "Program log: panicked at 'from_bytes_mut>SizeMismatch', /home/computer/.cargo/registry/src/github.com-1ecc6299db9ec823/bytemuck-1.5.1/src/lib.rs:106:3",
    'Program EcLzTrNg9V7qhcdyXDe2qjtPkiGzDM2UbdRaeaadU5r2 consumed 165371 of 165371 compute units',
    'Program failed to complete: BPF program panicked',
    'Program EcLzTrNg9V7qhcdyXDe2qjtPkiGzDM2UbdRaeaadU5r2 failed: Program failed to complete',
    'Program HQzzwwBbzHUpYrc9u4VKn4XiAne5fsh444Jp9uuTE5A3 consumed 200000 of 200000 compute units',
    'Program HQzzwwBbzHUpYrc9u4VKn4XiAne5fsh444Jp9uuTE5A3 failed: Program failed to complete'
```
I'm not sure how to approach debugging this. does anyone have ideas on the source of this error?
raydium source code is closed source so I've been referring to the client side code for reference: 
https://github.com/raydium-io/raydium-ui/blob/8d398a56e05780029b56265dd004b66a78246a77/src/utils/stake.ts#L352
Agreed üôÇ
makes sense, thank you ü§ù
Use `features = ["no-entrypoint"]` when importing other smart contracts into your crate.
Hi guys, I'm stuck on this error; any ideas? `error: the #[global_allocator] in this crate conflicts with global allocator in: spl_token_metadata`

I made a local test validator, cloning the metadata program from devnet and ran `anchor test --skip-local-validator`
Also is nice from a security perspective, since the app can only steal whatever teh main wallet transfers to the embedded wallet.
Embedded wallet UX is the best imo.
Hi guys, I've got idl.json (also rs source code), trying to recreate buffer layout manually (js), still got invalid result. What do I need to look for?
hm yeah separate package could be nice. main problem we're trying to solve is we have a lot of nice anchor code, but think we may need embedded wallet ux
maybe as a package, but there is already a lot of things directly into anchor.
Or maybe i am wrong and we can afford 1 more wallet class with a derivation path + indices input
you don't think this is a good thing to provide support for?
well, I think I understand this nesting, but still doesn't serialize correctly..
i do this with test wallet, i have a test mnemonic, and exported a few keypairs to my computer
seems blotted, account can be exported anyway
Supporting bip32/bip39/bip44.
that'd be very nice
Yes. All the signing functionality provided by spl-token-wallet and phantom, but in a new anchor wallet class.
so NodeWallet is just anchor's support for raw keypairs in a nodejs environment, and you'd like support for embedded browser wallets
oh cool
let me take a quick look to make sure i understand
But it owuld be really cool if someone wanted to open a PR to add bip32 derivations and have a proper embedded wallet in there.
There's currently no native wallet functionality other than NodeWallet.
What do you want to do?
coming back to the original question, is there a straightforward way to use anchor on the wallet side of things?
Ignore my suggestion then. üôÇ
so when i was referring to spl-token-wallet, i meant we'd fork that and use it's key storing & signing capabilities
after a bit of digging i realized i may have mis-represented our requirements. we're interested in building a wallet-like app that is storing the keys and signing transactions, as apposed to sending them off to a signing wallet via an adapter interface
‚ù§Ô∏è üòÜ
ok <@!134416332509675520> you are right as always haha, i changed the error order in swap program and re run the test, now it returns error 301, which i changed to, so yeah ZeroSwap error it is. Thanks man
so probably that
302 matches with Zero Code
because if a swap didn't go through well, i think it should be stopped at the dex program itself, idk though
Why do you think it's coming specifically from the dex and not this ix handler?
I haven't looked super carefully yet but if this is the cpi you're calling, then this is the ix handler that's running
Is there any way i could make sure error is coming from swap itself?
yes, agree. But dont you think that, there is a possibility the error could be raised from Dex code?
In general, I think the debugging approach you're stuck with for this kind of cpi thing, is to find the actual ix handler in the cpi program and see if it can raise any errors :/ Pretty manual for now.
Ok yeah pretty sure it's failing here: https://github.com/project-serum/swap/blob/master/programs/swap/src/lib.rs#L211


///////////////////////////////////////////////////////////////////////////////////////////////

i guess that assumes you know all the seeds for every type B at search time
oh interesting...didn't think of that
If everything is a PDA, then calculating the addresses client side and using `getMultipleAccounts` should be faster?
that's my gut feeling too, but that seems horribly unscalable
Mm, not sure, I guess I would expect the two `.all()` fetches + manual zipping to be faster, just since you do way fewer network calls?
<@!134416332509675520> any thoughts on this? (minimal example of what i'm talking about ^)
...or just `Buffer.from("authority")` works as well
`anchor.utils.bytes.utf8.encode("authority")`
and your `"authority"` string needs to be bytes as well
Thank you
`.toBytes()` instead of `.toString()` on the pubkeys
no this is the right approach, should be a byte array not a string
```rs
#[account]
pub struct TypeA {
  // ...
}

#[account]
pub struct TypeB {
  a_key: Pubkey,
  // ...
}
```
```ts
const allAs = await program.account.typeA.all()
const allBs = await program.account.typeB.all()
// do some O(n) mapping ...or...

const allAs = await.program.account.typeA.all()
for (let a of allAs) {
  const bs = await program.account.typeB.all([{
    memcmp: {
      offset: 8,
      bytes: a.pubkey.toBase58()
    }
  }])

  // store with associated TypeA in some capacity
}
```
Is there a way around this or do I need a new approach?


I want publickeys to be the seeds for my PDA, but I get an error that the max seed length has been exceeded...
might make more sense if i write a minimal example (typing is hard today)
both are PDAs, but type B accounts are seeded with A's pubkey
is A a PDA and B randomly generated?
if a program has a bunch of PDAs where type A has a one-to-many relationship to type B, is it more efficient to do two `.all` fetches for them and do a quasi zip/mapping off chain or use `memcmp`  to filter the associated type B accounts for each type A?
Yeah, meant to edit my comment üò¶
But I think this issue should  mostly solve the problem https://github.com/project-serum/anchor/issues/855.
So what's really annoying is that react doesn't allow you to reference files outside the package, e.g., outside the `app/` directory. So you need to copy paste the idl in there when you change it.
In the utils folder you have both a ts and json file for the idls - are they both necessary?
^ This had a ridiculous fix, <@!376016130617114641> and I looked at this together for a bit, couldn't figure it out, then <@!376016130617114641> realized that the repo above is using a hard-coded/checked-in IDL file ü§¶‚Äç‚ôÇÔ∏è
Yeah, I'm very curious how your phantom wallet is signing the tx and yet signature verification is still failing
Ok, right, since base account there is a keypair and needs to explicitly sign
You can reproduce the issue by running the example 1 of the tuto: https://github.com/dabit3/complete-guide-to-full-stack-solana-development
and removing `signers: [baseAccount]` of `createCounter` function in App.js
Correct
The error itself gets raised here https://github.com/solana-labs/solana/blob/master/web3.js/src/transaction.ts#L583
Mm, yeah, that's the code I'd expect to be running. Well, one thing you can do is just stick a breakpoint in that code and poke around :/
Transaction error:  Error: Signature verification failed
    at Transaction.serialize (transaction.ts:583)
    at Provider.send (provider.ts:112)
    at async Object.rpc [as create] (rpc.ts:24)
    at async createCounter (App.js:60)
I just saw that there is also `useAnchorWallet` in `@solana/wallet-adapter-react`
Interesting! Hmm, have you posted a screenshot of the error you get? Not sure how signature verification would fail here if phantom really is signing (in the issue above, I think phantom wasn't actually signing)
yes it prompts to approve
Ok, interesting. When you try to use the phantom wallet, does it prompt you to sign the tx? Like, with the phantom pop-up
and with the local wallet it works
I have checked: only one, the user.
Just to double check: can you look at the generated IDL in ./target/idl/<prog_name>.json and see how many accounts have `isSigner: true` for the rpc call you're trying to make?
yes
And you're getting the same error about signature verification?
based on : https://dev.to/dabit3/the-complete-guide-to-full-stack-solana-development-with-react-anchor-rust-and-phantom-3291
`const wallet = useWallet();` from @solana/wallet-adapter-react
`const provider = new Provider(connection, wallet, opts.preflightCommitment);`
This ended up being something with how they were setting up their provider with the phantom wallet, so it ended up not actually signing the tx. Can you post how you're setting up your provider?
Yes let us know I am also facing the same issue when using Phantom wallet while `anchor test` works with my local wallet
Sure!
üôÇ
thanks!
and you too <@!134416332509675520>
cant wait to have static type checkign!
typescript really isn't bad :p you can set it pretty strict
thanks for your help
Its good now <@!137101040687382528>, just needed to global install TS and ts-mocha
npx ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts
I really need to find some TS wizard to work with so I can just go back to writing pure rust
üôÉ
doesnt help my JS ire!
yep I get that
cool
hmm weird manually re running ```npm install -g typescript``` fixed that one
^ At any rate these complaints are just from npm, not anchor-specific if that makes sense
not sure what its complaining about
Was pretty sure I had TS installed before this
or just run ./node_modules/.bin/ts-mocha
``` [ERROR] Cannot find module 'typescript'
Require stack:
- /usr/local/lib/node_modules/ts-mocha/node_modules/ts-node/dist/index.js
- /usr/local/lib/node_modules/ts-mocha/src/index.js
- /usr/local/lib/node_modules/mocha/lib/esm-utils.js
- /usr/local/lib/node_modules/mocha/lib/mocha.js
- /usr/local/lib/node_modules/mocha/lib/cli/one-and-dones.js
- /usr/local/lib/node_modules/mocha/lib/cli/options.js
- /usr/local/lib/node_modules/mocha/bin/mocha

```
ts-mocha is already installed locally in a new project tho, you can do `npx ts-mocha`
not really I got to this after install
Actually does installing it locally work too? Not sure
i see.
No, anchor just runs that `test` command as is, from your Anchor.toml file.
Why does it need to be global? Shouldnt it be part of anchors build process?
Need to install `ts-mocha` globally with npm
lemme init a new project and check
``` Failed to run test: ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts: No such file or directory (os error 2)```
ever seen this?
yeah im just having a day
you ok? üòÑ
https://giphy.com/gifs/good-burger-i-know-some-of-these-words-zXA5VEmXr7OUg
https://giphy.com/gifs/wat-loop-old-woman-jA8TT03Sj2pXO
if you do scripts, use `ts-node` instead of `node` to execute them directly with ts
https://giphy.com/gifs/steve-harvey-thank-you-jesus-praise-him-dX3dMAyBWYyAV4zhOm
vsc has very good typescript support baked in so you should be good. should find all static errors right away
Whats the cool dev tools I want to add to vsc? is there a type checker for this that catches weird crap like the above?
brb deleting EVERTYHIGN
oh thank god
anchor init --typescript
Im like a javascript peasant please help
is there a way to initialize an anchor project to use ts?
just use typescript and you'll have a more pleasant experience
Seriously tho.. is webasm a thing yet? Can I abandon JS forever yet?
Im going back to Machine learning.. math makes sense to me
lol
üôÉ
(I'm on a roll tonight)
üòê
show us and we'll react to it
you should see the react I've tried to write at work
My brain was just.. not built for js
Yeah, and instruction arguments go all by themselves, 
```.js
rpc.something(x, y, {
  accounts: {
    ...
  },
  signers: [...]
});
```
not only accounts
signers and instructions (optional) are part of that object as well
cool I suppose that makes sense
soo.. `accounts` has to be a full object you pass in surrounded by {}
Hmm rearranged the {} and got it to at least run
https://tenor.com/I6SN.gif
javascript.. seriously makes my eyeballs bleed
No now its complaining abuot commas
oh maybe thats it.
you have an extra pair of {} here
https://gist.github.com/Snarik/b5d1ff2445778ff9c2512ab208917087.js">
thanks
one sec
yeah lemme send a gist
Mm, that's something else, can you post a larger snippet of your code?
https://tenor.com/rY25.gif
doesnt like being called
``` /Users/snarik/Developer/project/tests/project.js:59
      fakeAccount.publicKey,

SyntaxError: Unexpected token '.'

```
So I tried that
yeah, contains both secret and publickey
It's a keypair, not a public key, so you'd have to do `fakeAccount.publicKey` to pass it as an account (but e.g. `signers: [fakeAccount]` to sign with it)
Like is anchor.web3.Keypair.generate() a JS object with like ``` {pubkey: <>, Privkey: <>``` or is it just a pub key I can use at will
What do you mean the object form?
gets used like this ``` 
    await program.rpc.joinTable({ 
      fakeAccount,
      accounts: { 
        table: myPDA,
      },
    });```
trying to generate a account for something
what is the object form of ```    const fakeAccount = anchor.web3.Keypair.generate();
```
could be it
One way I get that kind of error message is by accidentally doing `somePubkey.publicKey` when I thought `somePubkey` as a keypair
perhaps you undefined it afterwards üòÑ
https://tenor.com/WjiC.gif
> what do you mean its undefined??? I defined it RIGHT THERE
I really wish JS gave less garbage error messages
https://github.com/project-serum/anchor/pull/874 Will this be welcomed? Still not building but i want to know
at which point... instead of which instruction... can't **wrap** my head around this... (pun intended)
Okay, so I've successfully wrapped SOL. How to make that associated token account?

where does `Token.createAssociatedTokenAccountInstruction` come into play here:
https://gist.github.com/imprfekt/90d35b599ec1016ac9649ab8ac91815b
Deployment problems were tied to my local solana installation not matching the devnet/localnet versions.
It's a stupid one but that can help üëç
anyways thanks a bunch
yea we update our nodes to 1.7 as per recommendations for api nodes in the solana mainnet discord, perhaps that has something to do with it <a:aPES_Think:493353113332219924>
Maybe your RPC api was updated?
im just so confused why it started breaking now <:confuse:585605260563972109>
Broke a bunch of stuff 2 months ago.
Yea those RPC changes were really annoying.
armani chad af
<:prayge:827318436870488135>
amazing
thanks will try
Give that the `multisig-ui` repo is also on that release, an update to `@project-serum/anchor` v0.4.6 might just fix the problem.
For example, on the `armani/v0.4.4` branch there is this commit fixing the problem for the v0.4.x release https://github.com/project-serum/anchor/commit/df1f23bb7299d9e625c7c63ea6b33c9f869bef4d
Could just be the anchor version then
nothing related to encoding
so theres some connect api invocations directly, however the option available are only related to commitment
I dont recall the exact API though.
Manually as in specifying the filters and using the connection api directly.
by manually do you mean being invoked, and having the encoding config omitted?
Yes. Need to see if any rpcs are being invoked manually though.
This happened on a bunch of apps in the 1.5 -> 1.6 upgrade if I recall correctly.
shouldnt they do that on the newest releases?
Should be a simple fix. Just need to update whatever RPC endpoint is failing to use base64 encoding.
what would the issue be? i curently run the multisig ui locally and havent' made any changes except adding some extra rpcs.

previously switching to the solana rpc node, and our own nodes enough to solve the issue, but now no matter what rpc provider is used it still gives that error
hmm
I dont think it was ever fixed
the current multisig ui is failing wit:
```
rpc.ts:554 
{jsonrpc: '2.0', error: {‚Ä¶}, id: 'd9f3af98-dd0c-477c-b38b-192d67ea5355'}
error: {code: -32600, message: 'Encoded binary (base 58) data should be less than 128 bytes, please use Base64 encoding.'}
id: "d9f3af98-dd0c-477c-b38b-192d67ea5355"
jsonrpc: "2.0"
[[Prototype]]: Object
```

this is happening across serum's node, solana's node, and our own private nodes.

I believe this issue happened before and was fixed, but it just started happening again today <a:aPES_Think:493353113332219924>
Getting a weird error for a anchor program im trying to write: 
```      Error: Invalid arguments: entrant not provided.```

Entrant is an account associated with an instruction. Its included in the instruction, and in the JS test. Not sure why the test frame work thinks its not being included
it was an upgrade on a existing program from non-optimized to optimized though
I think when I just ran it against a fresh local validator, it worked fine. Maybe some state gets ruined because the optimized version expects something.... optimized?
wanted to bring this up again, any idea why using the recommended optimization build settings borked my program? ü§î
‚ù§Ô∏è
https://github.com/project-serum/anchor/pull/877
this will circumvent the annoyance
```export default class TransactionFactory {
  public static build<IDL extends Idl, I extends AllInstructions<IDL>>(
    idlIx: I,
    ixFn: InstructionFn<IDL, I>
  ): TransactionFn<IDL, I> {
    const txFn: TransactionFn<IDL, I> = (...args): Transaction => {
      const [, ctx] = splitArgsAndCtx(idlIx, [...args]);
      const tx = new Transaction();
      ctx.instructions?.forEach(ix => tx.add(ix));
      tx.add(ixFn(...args));
      return tx;
    };```
possibly never to get a reply
I am asking in the solana discord if this check is useful
push
create it
you would have to check if the array exist
this can be annoying when you start to have a lot of conditions
yea, I'm declaring 
``` let instructions = undefined;
if (shouldAddInstructions) {
instructions = [];
...
instructions.push(new Instruction())
...
}
```
Huh, weird, wouldn't expect them to throw there ü§î
i.e. allow []
yea, perhaps Anchor should handle it more logically, though, as those are **additional** instructions
dayum!
some sort of annoying safety
https://github.com/solana-labs/solana/blob/49d3d794590303f135561bee68aff8ff77927e70/web3.js/src/transaction.ts#L181-L200 it is web3js throwing if you call add with an empty array
ah no
it does something unexpected with empty array
some stupidity with the spread operator
I found what causes it i think
yeah, that doesn't make sense
yeah i mean the error when it is a []
checking now...
that was my reaction to `undefined`
Let's fix this so our future is less painful
do you have the error?
https://tenor.com/view/damn-shookt-shocked-gif-5580082
yes
instructions: instructions.length > 0 ? instructions : undefined
so `instructions: undefined` works?
just add some ugly stuff to go into a undefined when empty
use case: sometimes I want additional accounts created, sometimes I don't
yeah that's annoying
What's the best way to handle **optional** additional instructions when doing program rpc calls?
It looks like you can't just pass an empty array for `instructions: []`
not sure how would one get to 10 MB lol
i checked one of my programs, 400kB
maybe, maybe they have an exception
so binaries also have a upper limit of 10mb since that is what a normal accounts max storage is?
interesting
I noticed that, it took 2.5 SOL out of the wallet and once the deploy was done I got most back
Will definitely save me some time and hassle
and @solana-labs/wallet-adapter
far from complete, but it shows how to use types
exactly what I was looking for. Thank you sir
then replace which buffer the program points to and close the other one
because it creates another one
but when you redeploy you need at least as much SOL
the one that holds the data with the program binary
what kind of accounts does it create on first deploy that cost so much?
btw <@!831450660146642974> you were right, I re-deployed our big program and it was a fraction of a fraction of a SOL in cost
Thank you!! will ask around more about it
looking at the codebase it is there, but not turned on somehow
https://github.com/solana-labs/solana/blob/2400e86d136f5c151eb447bd7fbda6fed4068f49/docs/src/developing/runtime-facilities/programs.md#ed25519-program
Will do

Yeh, another way I can imagine is have the message in the instruction, and somehow find the signed version of it in the program.
removing them, re-deploy and all is good again
Especially this one: 
```
    Program failed to complete: Instruction passed to inner instruction is too large (17180290022 > 1280)
```
Over in resources is the guide to use these settings for Cargo.toml
```
#[profile.release]
#lto = "fat"
#codegen-units = 1
#[profile.release.build-override]
#opt-level = 3
#incremental = false
#codegen-units = 1
```

I spent a good while debugging very cryptic errors just to finally figure out these settings is what broke my program
I have heard people trying to do the verify manually and it does not cut it, it hits compute unit limits
check the PRs, there is one adding a program to do that
there is something planned
I see, I would assume Solana would provide some out of the box solutions. 

Let me ask the team too
probably not
unclear if it is live or not
There is a program for that
Anyone tried to verify ed25519 on chain?  I tried using `ed25519_dalek`, but even constructing the PublicKey object gave me Access Violation in stake frame. 

`let publicKey = PublicKey::from_bytes(&ctx.accounts.auth.key.as_ref()).unwrap();` 

The goal is trying to verify signed messages from the signer, any ideas would appreciate <:pepepray:847897348424335430> <:pepepray:834817528412897300>
I see that `connection.commitment` is read-only
How can we override `connection`'s commitment after instantiation?
where are they!
the higher ups were the ones who wrote the code
He needs to fire the higher ups
Thanks!
or you can just instantiate a standalone connection if you want
`new web3.Connection(clusterEndpoint)`
it works, thx you!
`Connection` is a class that should be at `program.provider.connection` on an initialized `Program` instance
`Connection#getBalance` or `Connection#getTokenAccountBalance`
What is the JS code i need to call to get an account's balance?
Get more Sol
You dont have the money for it
Someone knows why I have this error when deploying in mainnet but all works when deploy in devnet:
```
Error: Deploying program failed: Error processing Instruction 1: custom program error: 0x1
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }
```
sir you need to change higher ups
lol


///////////////////////////////////////////////////////////////////////////////////////////////

ok
I will upgrade Anchor to solana-program 1.8.0 to be compatible with the new spl changes.
Ok thanks. In the past this has spooked people when Anchor upgraded early like this.
accordingly to mvines yes ( there is no evidence  that would indicate otherwise)
<@!712412210814779454> I noticed `spl-governance` is using `solana-program` 1.8.0. Is this safe for Anchor to use on mainnet?
Hello everyone. I am wondering how to enforce that a usdt transfer was made as part of a Tx.
I thought (I asked a while ago), that issuing a USDT token transfer in the instructions array would result in this transfer being processed before my function call. And therefore, I could check within my program function that the transfer had been made like so:
```
 /*
         ** Check whether a USDT deposit was made as part of a bundled Tx
         ** Prevents from issuing a fake deposit tx without depositing usdt first
         */
        let lp_usdt_account_balance_after_deposit = lp_usdt_account_balance_before_deposit
            .checked_sub(deposit_amount)
            .unwrap();

        if ctx.accounts.lp_usdt_token_account.amount != lp_usdt_account_balance_after_deposit {        
            return Err(ErrorCode::DepositWithoutUsdt.into());
        }
```
Seems like this is not working. How can I make sure from within my program that the USDT SPL transfer was made ?
Thank you!
`solana-test-validator -r` did the trick. It was caching past memory for older code in the contract that I have running at the moment
Ah, so maybe stale account data that doesn't match the new layout?
that may be it
how do I clear the cache from my solana test validator?
assuming this is the same guy as before
probably not lol
Can you show what the `Invoice` struct looks like?
that's not good
uh oh
Yeah this actually sounds like a bug, taking a look üëÄ
And I am calling this after I've created some accounts on my localnet. They are definitely there. Just having problems querying all of them.

Can you post more of the stack trace?
I'm trying to access all of the accounts that I've created in my client by this line `const Invoices: any = await program.account.invoice.all();`

then I'm getting this error: `Unhandled Rejection (RangeError): Trying to access beyond buffer length`
Only other thoughts: 0xfffffffffffffffb is right up against the limit of a 64bit address space, so it's actually pretty similar to the 0x6 and 0x8 address, considering wraparound
But it would be interesting all the same to log if a seed constraint check is blowing up for some reason
^ here it's just calculating a slice of the existing data, so should be ok/not do any new allocations
so the return value has to go on the heap
it's possibly because we don't know at run time what the array length will be
but now i don't know why `trim_ascii_whitespace` would assign stuff to heap
you're right, i meant heap
sorry
I think the stack is ok (did you get any stack warnings etc?)
only 176 bytes though
11 accounts * 2 trim ascci whitespace calls * 8 bytes or something
and of course failing that could just add more msg!() calls to see where the errors occur. But it seems likely it's the `trim_ascii_whitespace()` variables blowing the stack
and maybe it used to do something different, anyway, armani might know hopefully
like it inits all the accounts with account constraints first and then loads up the non-init accounts
i have a feeling there was a change in how anchor executes constraints
Basically, if it's a constraint check that's failing it's annoying to not know which one
I guess one desperation-move debugging thing you could try is to add a bunch of `msg!` calls to the code anchor generates, just to get more info about where things are failing (so would have to add them to the macro code)
though it would explain why i couldn't replicate it
well, maybe the trim_ascii_whitespace variables are also just symptomatic of using up stack memory
<@!501570363566587905> we figured out what was likely causing the error but don't know the actual root cause is
but regardless the question is why didn't this break in earlier versions of anchor
which blows the stack memory
and they're all getting added to the stack
but i have a feeling that it like inits a new variable or something instead of reusing the memory from the referenced one
ok, so i don't know rust that well yet
I was just messing around with the trim whitespace function locally, seems ok/not sure where I'm expecting it to break anything
Hmmmmm lol
after commenting out like 5 of the constraints
yeh, it passes
oh shit
commented out from wrong function, let me try again
oh wait sorry lol
So you got rid of the trim whitespace part?
looks like the same error as before
i commented out constraints on four of the accounts that weren't being init 
```
    'Program failed to complete: Access violation in unknown section at address 0x6 of size 8 by instruction #243386',
```
hmm didn't change much
i will try removing more constraints to see what happens
maybe you're right
```rust
/// Trait to allow trimming ascii whitespace from a &[u8].
pub trait TrimAsciiWhitespace {
    /// Trim ascii whitespace (based on `is_ascii_whitespace()`) from the
    /// start and end of a slice.
    fn trim_ascii_whitespace(&self) -> &[u8];
}

impl<T: Deref<Target = [u8]>> TrimAsciiWhitespace for T {
    fn trim_ascii_whitespace(&self) -> &[u8] {
        let from = match self.iter().position(|x| !x.is_ascii_whitespace()) {
            Some(i) => i,
            None => return &self[0..0],
        };
        let to = self.iter().rposition(|x| !x.is_ascii_whitespace()).unwrap();
        &self[from..=to]
    }
}
```
it creates a new variable
maybe
ohoh
it has changed since earlier i was running on a different computer
Is it possible something is weird about the `.trim_ascii_whitespace()` calls? ü§î How is that implemented?
yes
Wow, interesting. And those errors are deterministic? You get the same addresses after repeated runs?
and with the `#[account(seeds=...)]` the error goes back to
```
    'Program failed to complete: Access violation in unknown section at address 0xfffffffffffffffb of size 1 by instruction #162
797',
```
without the constraints the error is 
```
    'Program failed to complete: Access violation in unknown section at address 0x6 of size 8 by instruction #247149',
```
ok, now going to try without constraints on serum_market
haven't started running with your suggestion yet, just wanted to make sure the error was still there, now it's giving off
```
    'Program failed to complete: Access violation in unknown section at address 0xfffffffffffffffb of size 1 by instruction #162
797',
```
because it runs just fine on v13
just trying to narrow down what might have changed between v13 and v17
sure, me neither
Tbh I have no idea why that would fix anything, but I'm also pretty confused why a raw `AccountInfo` would break anything either
let me try this
pretty similar to the test account
```rust
#[account]
#[derive(Default)]
pub struct BracketAccount {
    pub market_name: [u8; 20], // max 20 characters in seed, could make this bigger
    pub bracket_name: [u8; 20], // max 20 characters in seed, could make this bigger
    pub bracket_idx: u8,
    pub bumps: BracketBumps,
    pub fake_yes_total: u64,
    pub serum_market: Pubkey,
    pub usdc_vault: Pubkey,
    pub yes_mint: Pubkey,
    pub no_mint: Pubkey,
    pub f_usdc_mint: Pubkey
}
```
Also, what does the BracketAccount struct look like?
Just curious, if you remove just the `#[account(...)]` constraints on the `serum_market` account, does that do anything? Guessing no
and i'm out of ideas
but alas all tests are passing so far
the error happens before it even hits the main function, so everything bad that's going wrong is happening inside the constraints / account struct
here's my attempt to cause the same error
<https://github.com/Henry-E/anchor/blob/memory-issue/tests/memory-issue/programs/memory-issue/src/lib.rs>
i tried really hard to replicate the error but couldn't
That's fascinating lol, taking a look üëÄ
so when i omit `serum_market` it gives the `0x8` error, otherwise it gives the standard `0x3` error
"""
https://gist.github.com/Henry-E/d123d266d6d694fc98366ec1b0bbf4f9
What I've found so far
- running as is gives the `0x3` error
- omitting the serum_market account changes the access violation error to a different access violation error `0x8` error
- omitting open_orders account gets rid of all access violations accounts
- omitting any of the token account inits gets rid of the access violation errors
"""
I get how you could have a heap violation like the one above (32kb just isn't that big, easy to run out), but the 0x8 thing is puzzling to me‚Äînot even sure how to do that without using raw pointers or something ü§î Hmm.
everything i'm doing is standard anchor
lol no
Are you using any really low-level pointer stuff?
it's all very beyond me tbh
Ah, I think the size of the numbers is hard to interpret (it's bytes), since it's a virtual address map I think (not totally sure, not used to doing things this low-level)
The thing I'm confused about is I think 0x8 means, like, address 8, way at the beginning of the address space
```
    'Program failed to complete: Access violation in heap section at address 0x300007cd0 of size 12884932208 by instruction #0',
```
also i wonder if this size is bytes or bits. It seems huge if it's bytes
but i mean it's pretty clearly linked to something about anchor's discriminators
the page you linked didn't mention 0x8 anywhere
Since that isn't even in the heap (the heap is at 0x30000 whatever)‚ÄîI actually don't even know what goes in the 0x000 part)
Yeah! That's super interesting, no idea how you'd get a memory violation in that part of the address space
8 byte violation!
```
    'Program failed to complete: Access violation in unknown section at address 0x8 of size 8 by instruction #225425'
```
but the funny thing is that even once i remove serum_market, it still gives an even weirder heap error
yeh, i was wondering if i should move to a Loader for the serum market
But sounds like you are running up against the 32kb heap limit (0x7cd0 = 31952)‚Äînot sure how you avoid that other than by giving up on Box<Account<'info, T>> and sticking to raw AccountInfo's or Loaders etc.
^ yeah
(Would like to understand why Anchor has that limitation tbh)
but based on what you're saying it shouldn't matter
Ah, sorry, right
or `UncheckedAccount`
on account info
Boxing isn't allowed
Haha üôÇ
Finally seems to time to use a thread
Ok yeah, that's just the low-level solana AccountInfo (basically telling Anchor to do nothing with it), so wouldn't expect boxing to help (though tbh I'm not sure why boxing would hurt either‚Äîall the data would still be behind a pointer, not like relocated to the heap too I don't think?)
oh right, no i mean like `AccountInfo<'info>` we put next to accounts in the account struct
oh this is useful link thanks. So it is definitely a heap issue then
Hmm, interesting that the address is so low! https://docs.solana.com/developing/on-chain-programs/overview#memory-map
Just to make sure I'm understanding, you mean the actual low-level Solana `AccountInfo` type? I wouldn't have guessed that would ever need to be boxed, since all of its `data` is already accessed behind a pointer
What I've found so far
- omitting the `serum_market` account changes the access violation error to a different access violation error
- omitting `open_orders` account gets rid of all access violations accounts
- omitting any of the token account inits gets rid of the access violation errors

Although other similar structs which have less token account inits in them don't run into this error, I still think the error here is linked to `AccountInfo` / `UncheckedAccount` somehow
<https://gist.github.com/Henry-E/d123d266d6d694fc98366ec1b0bbf4f9>
<@!501570363566587905> i've tried all morning to replicate the access violation error in an easier to run repo than my own with no success. Is there something new about how `AccountInfo` works / loads data in new version?
so i removed another `AccountInfo` type and the tests pass
we're exceeding the heap or memory by only 8 bytes this time
```
    'Program failed to complete: Access violation in unknown section at address 0x8 of size 8 by instruction #225425'
```
ok, after removing the `serum_market` account (which stores MarketState for serum), i'm still getting another error but this one is more interesting
so maybe I just need to implement a CPI Account for serum market?
having a hard time replicating the error. Here's the current status
- removing loading serum market account info from the struct gets rid of the error
- Doing something very similar in a reproducible repo isn't causing the same error
nope no boxing allow
using `UncheckedAccount` still results in out of memory heap error but maybe it can be boxed
ok, trying out the new `UncheckedAccount` type to see if that fixes it
but `Box<>` only applies to `Account<>` types
I have an AccountInfo which actually contains a bit of data and it needs to be boxed
ok figured out where the heap issue was coming from
sorry no idea about that
looks like it implements the websocket methods so that's good
I want to subscribe to program events and see if I can parse them into something useful
there is no IDL for raydium so have to port the typescript code from their frontend into go anyways
ah true, it can't do IDLs
used it a while back 
really depends on what u want to do I guess

the main issue is you wont be able to use anchor IDLs like you can with typescript

but I have done stuff like staking and withdrawing from raydium using that sdk
trying it out rn
yup
https://github.com/portto/solana-go-sdk
this one?
i tried earlier this week to make a reproducible example but couldn't get it to break in the same way.

For example, removing some of the token account initialization reduces the memory sufficiently that it doesn't break.

But when I tried to make a reproducible example by initializing a bunch of token accounts it didn't break
hmmm still getting 
```
    'Program failed to complete: Access violation in heap section at address 0x300007cd0 of size 12884932208 by instruction #0',
``` 
when trying to upgrade anchor
I want Go
üôÖ
frontend typescript
backend rust
don't want to use typescript for everything
anyone used the golang sdk for solana before? wondering what shape it's in
resolved. just realized how expensive logging is lol. will leave this here in case it helps anyone else
hey does anyone know any fixes or workarounds to the following:

```    'Program failed to complete: exceeded maximum number of instructions allowed (993) at instruction #1486',```

I'm trying to settle funds on a Serum permissioned market via cpi
o.o
uhhh i think we are using pdas for everything
lol
we must suffer
meanwhile
yes
Yea this is so clearly a problem. Fixed in the next version which uses PDAs.
but i hear the cache
the query breaks everything and is slow
a highly frictional component right now is getting the open orders
createAccountWithSeed open order, with a highly convenient way to get rid of them
or
-_-
ok
nice
correct
which we can't known beforehand
So i would have to crank the whole event queue?
It's probably the case that this needs to be unset during crank time https://github.com/project-serum/serum-dex/blob/master/dex/src/state.rs#L690, which is of course infuriating for your use case.
create account with seed (for open orders)
initOpenOrders
AGG program: CPI to new orders + CPI to settle fund
Close open orders
What are the ixs here? New orders -> Settle -> Close ?
We are doing a AbortTransaction rather than DecrementTake, not sure if that changes anything here
https://solscan.io/tx/XJ6fmZiCmQZ47PQ4JrYoUmaHTyjukzJTahWerFSCjUtWfwrrbgLaxeHPRsLxeMdDAHxTT9EonoCvSnpWAkQLcK6?cluster=devnet
I'm curious which one here you're hitting. Probably the first branch. https://github.com/project-serum/serum-dex/blob/master/dex/src/state.rs#L2253-L2267
Do you have logs for the transaction?
so more accounts
yeah but its adding this crank ix
It's possible. It just need to be cranked.
is that because the fees are cranked to the fee wallets?
So the whole initOpenOrders/close is not possible?
Cancels need to be cranked.
Yes.
This means you're not signing correctly for some PDA (passing the wrong seeds+bump somehow), or could also mean that the CPI wants some account to be mutable but you forgot to mark it as `mut` in some `#[derive(Accounts)]` struct.
is it because we need the thing to be cranked?
oh
the order was a `serum_dex::matching::OrderType::ImmediateOrCancel`, `serum_dex::instruction::SelfTradeBehavior::AbortTransaction`
I am trying to close an open orders and i get `TooManyOpenOrders`
HELP
there is nothing doxing me at all
yeah i am super anon
yh nw. i dislike talking too. that's why we're anons discord
im only here for 5 minutes a day
i dont like tlaking tho
I will get back to you reg this
ah nice, i see! thank you so much! I think i've seen something similar before, will try it after sleep lol
const program = new anchor.Program(
      idl,

      idWhereProgramIsDeployed,
      provider that you created previously,
    );
program takes in a provider when you initiate it
Yes. We are preparing to visit the moon.
and i feel like you guys are speaking in space talk
i am rtying to understand this conbo
When I press the import button and it doesn't work i start to blame
Quiz time?
well done
that is indeed correct
Public is the default.
That is public.
I'll report to the regulators
Unfairly
This seems like a strategy to make SOL deflationary
https://github.com/project-serum/serum-ts/blob/5f7ceafb1e99e542a74e4377cde1ffcf5a999e1c/packages/serum/src/instructions.js#L471
Why closeOpenOrders not public?
but thx man! üôÇ
sadge
Interesting... above my paygrade honestly... sorry man'
is how i import it
and `const program = anchor.workspace.ImoLaunchpad;`
does that one also rely on the same provider, or does it make a different call? i am confused as to how i can debug this, also because this interacts with the IDL
but this line does not
`const account = await program.account.poolAccount.fetch(poolAccount);`
but so basically my provider works
i.e. at least when i print provider i get the devnet url s
Set it manually to devnet like this
it does get it from env

or you mean this `const provider = anchor.getProvider();` ?
devnet. you mean `solana config get` , right?
In your JS is your provider set to env or localnet?
I think so. im not sure which guide to follow honestly
Have you changed your anchor.toml?
Can someone help with this issue here? I'm having a minor issue to push to the devnet, somehow this function `const account = await program.account.poolAccount.fetch(poolAccount);` always calls localhost, instead of the devnet environment https://github.com/project-serum/serum-ts/issues/179
I can't tell you how many programs I've seen that have failed to properly validate program IDs for CPI accounts and programs.
Statically embedding into the program allows us to do these checks generically for all accounts. Not just the accounts owned byh the current program.

It also allows CPI clients to be more safe as well, since the instruction ID is always hardcoded to match declare_id.
Because we still need a program ID check for cpi accounts, e.g. the token program.
It means you are trying to do something your program isn't allowed to do... like transfer sol from an account it doesnt own
So I'm trying to send something from one wallet to another. Has anyone ever gotten this before? `Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account`
Because at runtime the program has access to its own id
even if we plan to make it more dynamic
Why do we use declare_id! rather than the program_id available in the program?
anchor fetch api seems to be erroring when using option inside a zero copy struct
```Error: Invalid option oracle
      at OptionLayout.decode (node_modules/@project-serum/borsh/src/index.ts:138:11)
      at Structure.decode (node_modules/buffer-layout/lib/Layout.js:1234:32)
      at Sequence.decode (node_modules/buffer-layout/lib/Layout.js:1090:34)
      at Structure.decode (node_modules/buffer-layout/lib/Layout.js:1234:32)
      at WrappedLayout.decode (node_modules/@project-serum/borsh/src/index.ts:92:37)
      at Structure.decode (node_modules/buffer-layout/lib/Layout.js:1234:32)
      at AccountsCoder.decode (node_modules/@project-serum/anchor/src/coder/accounts.ts:54:19)
      at AccountClient.fetch (node_modules/@project-serum/anchor/src/program/namespace/account.ts:139:33)
      at processTicksAndRejections (internal/process/task_queues.js:95:5)
```
ok thanks...lemme try with this
I'm not aware of any other public examples for Solana.
https://github.com/project-serum/spl-token-wallet has some code in there for that.
No. There are other libraries for that.
i see....for bip32, i need to use rust then?
But otherwise you can use `web3.Keypair.generate()` to create a privatekey
If you want bip32  mnemonics, no.
is there any simple anchor code sample for paper wallet creation?
Fair enough
good ole' SSR
I guess could be both with Server Side rendering and whatnot
At the same time, most are using typescript + some transpilation.
I just found it odd, because (I guess I presume) most devs will be using the browser, not Nodejs for thier apps?
Also, note that `@solana/web3.js` uses Buffer, which is why Anchor does.
lol
Not a biggie
Makes sense. If it's causing a problem, though, please let me know!
notice the bike üòâ
It can... but best practices would be to use the Web standard. Total low priority, but something to consider for the future
Can this be solved with a rollup/webpack config? I've never had an issue with the browser.
üá∂ any chance Anchor can switch from using Nodejs `Buffer` to using web standard JavaScript `UInt8Array` or `TypedArray`? It's a pain to have to use `Buffer` in the browser unnecessarily... ‚ùì
The instruction is not available on 1.7.11 üò¶
Going to wait for 1.8


///////////////////////////////////////////////////////////////////////////////////////////////

<@!443079510053748743> did you ever find a way around  this `HandshakeIncomplete` error?
Are there any examples of calling Pyth on chain with anchor? The existing example at https://github.com/NorbertBodziony/anchor/tree/841b0a9b15479c2f91d7f54f60e44f72f6509587/examples/pyth doesn't actually get pricing from Pyth, it's more like a simulation of a Pyth connection
If you figure out why the previous thing you tried didn't work, with the commitment config option, I'd be curious to hear about it (I'm fuzzy about confirmation too)
can confirm (pun intended), it works, cheers üôå
Whoops, sorry, use "spl" not "token" in the path
Well, let me try.
Just out of curiosity, could you change that `anchor-spl` dependency to be another path one? Like `anchor-spl = { path = "../../../../../token" }` I think

Huh. What version of anchor/anchor-spl are you using in your Cargo.toml file?

Mm... how are you importing `TokenAccount`? At the top of your file
This one right? `await program.provider.connection.confirmTransaction(tx);`
<@!134416332509675520> , could you explain this issue please?
I'll check it thanks!
I'm actually kind of confused about this too, but you can see some examples in the anchor source if you search for `connection.confirmTransaction`
yeah, I just made a mistake in the message, the  actual code uses what you say
if your instruction in rust is `create_my_account`, the RPC call should be getting created in js/ts as `program.rpc.createMyAccount`
Folks, how do you make sure the transaction is fully propagated to the cluster, so the when trying to read the created account right after the RPC call, it's guaranteed to return data.
I'm using `"finalized"` as the commitment config option but still after `await program.rpc.createMyAccount()` when I try to fetch that account I sometimes see the `Account does not exist` error. So how can I make sure, it's like really-really there? üôÇ 

Worth adding that after a few seconds the account is there, so it's not a bug in the program
I am now getting a `Not able to find command for test`.
Tried running `NODE_PATH=$(npm root -g) anchor test`, installed anchor locally, used different terminals, restarted my laptop, reinstalled all dependencies. To no avail.
I am on a Mac.
removing instructions then upgrading i mean
does anyone know if removing instructions from a program will break a previously deployed program
But you could have the PDA mint authority have static seeds, like `[b"mint-authority"]` or whatever.
You will need seeds (since it's going to be a PDA)
I haven't used the spl-token cli before, maybe with `spl-token authorize`?
without any keypair or seed.
Spl-token has token pubkey, token account , token mint authority.
here token mint authority is my account (with file keypair).
now can I assign the PDA to token mint authority?
You'll basically just have to pass in all of the relevant accounts, including the PDA mint authority you'll use to sign the minting process
I think I misunderstood your question‚Äîwhat's the relationship to the token you made with the spl-token cli?
ah, i am sorry, yeah. I mean Keypair.generate()
Where is it doing that? I only see `secondUserKeypair = anchor.web3.Keypair.generate();`
ah, I remember I checked it but in that example, it pass the Pubkey.generate() to the contract.
but in my case, I already have token which made by spl-token cli.
ah, okay. thank you so much. Let me take a look it.
Mm, I don't know of any myself‚Äîthere's an example in the anchor repo, tests/ido-pool, that uses the `mint::authority` attribute to do something similar, using a PDA to sign for programmatic minting
Can you please recommend any link for this?
I assume so, I haven't tried that yet myself but don't see why it wouldn't work?
can we assign program-derived address to token made spl-token cli?
yes, but I don't know how to do it.
I think you'll need to make sure token A's mint authority is set to a program-derived address derived from your program, so that your program can sign the minting process.
Can you please help me?
Deposite token B works well but mint Token A to user not works
But I am not sure how the contract can ownership of Token A
Hey, I made a spl-token (Token A) using spl-token cli.
I can mint with cli but now I am gonna let contract mint token.
so Idea is like following.
User deposite token B and then our contract will mint (Token A) to user.
Reinstalling all dependencies again. Looks like the migration from 0.7.0 to 0.17.0 messed up some things
Nothing unfortunately.
Just to double check, what does `lsof -i :8899` say?
Not my case unfortunately üò¶
anchor test spins up its own validator
If I remember right it was because I was running a test validator in the background
Hey Hunterws did you end up fixing that issue? Facing exactly the same one after `anchor test`. Fresh Anchor install + fresh Anchor repo clone
It's the address of the `counter` account‚Äîis that what you're asking?
Working with decimals
Will casting it work for you? That will obviously throw away the big bits (so kind of curious why you've got a u128 in the first place): `let smooshed: u64 = 0x11ffffffffffffff11u128 as u64`
What is this parameter?
or maybe just some documentation on u64/u128 operations?
Anyone know how to get a u128 to u64 for transfer amount?
Thank you, so much. It was a lot helpful. üòÜ
Yep, that's the idea. I think anchor also provides a helper attribute for this common case, `#[account(..., token::authority = check_signer)]`
<@!134416332509675520> , Could you check if I find correct thing please?
Thank you. I found that.
Not that I'm aware of
Thanks but is there link that use anchor please?
Take a look at https://blog.neodyme.io/posts/solana_common_pitfalls for more security stuff
But it is difficult for this beginner guy to find it.
I see. I am walking through test projects now.
That's why you'll have to do validation within the program
Yes. But submitting parameters from client could expose security issues.
I see. Thank you.
You'll need to pass that token account from the client, something like
```.js
await program.rpc.myInstructionThing({
  accounts: {
    ...
    theTokenAccount: thatPubkeyYouveGot
  }
});
```
Nope! I get what you mean, seems like it should be possible‚Äîbut nope, not possible in solana üôÖ‚Äç‚ôÇÔ∏è There's simply no way to go from pubkey to account from within the program itself‚Äî*all* accounts that the program will need have to be pre-specified by the client.
I have already got token account pubKey. Can't I create TokenAccount object with pubkey ?
Thanks, it pointed me in the right direction. My imports were messed up, I had to replace them with:
```
use derisk_pool::cpi::accounts::Lock;
use derisk_pool::program::DeriskPool;
```
Mm, I'm not sure, we'll see what the rest of the discord says üëÄ
BTW, is there any on-chain solution for whitelisting?
Thank you.
I see.
No, in the tests/ directory, not in `examples`
there are only 4 basic examples in the anchor repo.
I would suggest going through some of the `tests/` then (there are actually quite extensive examples of more complex anchor programs)
But still doesn't make sense what to do.
The client submit pubkey to the account.
Yes. I have checked the tutorial.
Have you gone through the anchor tutorials? Lots of examples there + in the anchor repo's tests/ directory‚ÄîI'm talking about things like `Account<'info, TokenAccount>` etc.
Using  lots of validation + requiring appropriate signatures should hopefully be enough
How can I validate it with anchor‚ù§Ô∏è ?
Oh, Sounds great.
This is kind of just a funny thing with Solana, you're going to have to get used to passing a lot of accounts üòõ It will be up to your program to validate that they make sense (anchor helps a lot with that).
And the only parameter from client should be its wallet. Because minting bot could send the token account which is not associated with its wallet.
I see. But the problem is that I am going to make a on-chain whitelist.
You'll need to pass those in as accounts from the client (given just a pubkey, there's no way in solana to have your program go fetch account data from within the program itself‚Äîthe client has to specify those accounts as being of interest ahead of time, at program invocation-time)
I have token account as Pubkey. I also have token program id. Now I need to get balance info of the token account. How can I do this with Anchor?
Hi, community. Happy to join Anchor.
This is kind of yucky, but `Provider.local` ends up calling `NodeWallet.local`, which expects you to have an `ANCHOR_WALLET` env var. Are you doing this in the browser? If so I think you'll need to use the Provider's constructor function, not that `.local` factory.
Yeah, though doesn't solana log warnings etc. about the stack? I totally buy that that could be an issue, just thought solana was noisier about it
could you try using `let cpi_accounts = derisk_pool::cpi::accounts::Lock {` instead of `Lock {`?
`cpi_accounts` is this the variable that's giving the error?
I cannot notice any difference from the examples given. Any idea ?
Hello, I am upgrading my programs to 0.17.0 and get a typing error following the "CpiAccount - ProgramAccount" to "Account" change:
```
 let cpi_program = ctx.accounts.pool_program.to_account_info();

        let cpi_accounts = Lock {
            pool_state_account: ctx.accounts.pool_state_account.clone(),
            user_usdt_token_account: ctx.accounts.user_usdt_token_account.clone(),
            pool_usdt_token_account: ctx.accounts.pool_usdt_token_account.clone(),
        };

        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
        derisk_pool::cpi::lock(cpi_ctx, derisk_option.amount.val, derisk_option.premium.val)?;
```
I get a `expected struct derisk_pool::cpi::accounts::Lock, found struct derisk_pool::Lock`
Did anyone have a similar problem?
```
import { Provider } from '@project-serum/anchor'

const provider = Provider.local('https://api.devnet.solana.com', {
  skipPreflight: true
})
```
```
ts-node script.ts
```
get error:
```
TypeError [ERR_INVALID_ARG_TYPE]: The "path" argument must be of type string or an instance of Buffer or URL. Received undefined
```
LEGEND SIR, I've watched your videos, I would really love if you make more.
Thankyou so much
i will try to make one on the IDO pool soon
a lot of new functionality has come in since then
they're probably a bit out of date though
I made some videos on anchor a few months ago too you could check out 
<https://www.youtube.com/channel/UC2p3rgoUYR7azB8eW-8CbTg>
okay
we're here to help along the way but it seems like you want more than i'm able to give
and eventually figure out all the different keywords and functionality
just read code, run it, edit it and see what works and what doesn't until you have a good mental model of how anchor works
this is how i started too
start whichever one you like ü§∑
I am also a beginner in blockchain space üò≠
should I start with ido-pool or tests/misc?
it's too much mental energy compared to just helping to troubleshoot errors
we don't usually deal with design questions here
I want to write a instruction where 

1. user can create token (I want to save some metadata)
 (a single account can initiate only one token, the authority and signer should be the program itself) 
2. other users can request for mint of a token 
3. other users can request to burn a token
I don't know what's my usecase and which code should i use.
there's not much documentation, just a lot of reading code and experimenting and asking questions when stuck ü§∑
just go through `tests` , particularly `misc`, in the anchor repo for examples of functionality
no
can i dm you sir?
How to ?
alright
here's some code of initing a Mint and initing a token account with a provided Mint in the constraints
https://github.com/project-serum/anchor/blob/master/tests/ido-pool/programs/ido-pool/src/lib.rs#L298-L313
why can't you just use the built in constraint tokens?
i don't know what you're trying to do
can you point me to an example where create token is implemented with signer_seeds
`ctx.accounts.signer_seeds`
not working ;c
`accounts.signer_seeds`
```
#[derive(Accounts)]
pub struct CreateToken<'info> {
  visitor: Signer<'info>,
  #[account(mut, seeds = [visitor.key.as_ref()], bump = visitor_state.bump)]
  visitor_state: Account<'info, VisitorState>,

  #[account(signer)]
  pub authority: AccountInfo<'info>,
  #[account(mut)]
  pub mint: AccountInfo<'info>,
  #[account(mut)]
  pub to: AccountInfo<'info>,
  pub token_program: AccountInfo<'info>,
  pub signer_seeds: [u8; 32],
}

impl<'a, 'b, 'c, 'info> From<&mut CreateToken<'info>>
    for CpiContext<'a, 'b, 'c, 'info, CreateToken<'info>>
{
    fn from(accounts: &mut CreateToken<'info>) -> CpiContext<'a, 'b, 'c, 'info, CreateToken<'info>> {
        let cpi_accounts = CreateToken {
            mint: accounts.mint.clone(),
            to: accounts.to.clone(),
            authority: accounts.authority.clone(),
            token_program: accounts.token_program.clone(),
            visitor: accounts.visitor.clone(),
            visitor_state: accounts.visitor_state.clone(),
        };
        let cpi_program = accounts.token_program.clone();
        CpiContext::new_with_signer(cpi_program, cpi_accounts, signer_seeds)
    }
}
```
cannot find value `signer_seeds` in this scope
ah ok, it looks like another dumb vestigial thing in consume events, even the official crank code just sets it to the max u16 value <https://github.com/project-serum/serum-dex/blob/master/dex/crank/src/lib.rs#L884>
Kind of a serum question but peeps in here might know.

What is the purpose of `limit` in consume events?

<https://github.com/project-serum/serum-dex/blob/master/dex/src/state.rs#L2717-L2730>
4kb is quite small
it sort of makes sense
does the type need to be changed or something for typescript? <a:aPES_Think:493353113332219924>
using https://github.com/project-serum/anchor/blob/d9c643c499121108f9c833571fff5b165a9a0a1b/tests/swap/tests/swap.js#L280-L283 in typescript tests is givingv me an error `Error: unable to infer src variant`
You have to change the mtime of a file to get cargo to actually print a fresh time.
You can see an example of this by doing something like `eprintln!("{:?}", std::time::SystemTime::now())` in `declare_id!` or whatever. Rerunning anchor build will keep printing the time... but always the same time, not the actual current time.
I learned a minor macro wtf today. If you print something within a macro, you'll of course see it when you do anything that requires macro expansion (like cargo check); confusingly though, you'll see the print statement even if cargo decides none of your files have changed and doesn't actually rerun your macro! I guess cargo caches the output of previous macro runs?
THANK YOU SER
its midnight but time doesn't wait for gm
It may be night time but good freaking morning to you ser.
anchor gm backend is looking good so far ‚öìÔ∏èüòà
Change it into a named struct.
Not very javascript friendly.
I don't think we're writing tuple structs.
i've got this but not being written for some reason :/
```rs
#[derive(AnchorDeserialize, AnchorSerialize)]
pub struct TagHash([u8; 8]);
```
Non account structs should be parsed into the IDL if they are `pub` and implement `AnchorSerialize` and `AnchorDeserialize`
is there a way to get type aliases or non-account structs into the IDL?
ok
which i never noticed
i opened the makeCreateAccountTransaction, then realized it is one instruction
we did not
If you call init_open_orders then you're ok.
YOLO
Yes.
https://github.com/project-serum/serum-dex/blob/master/dex/src/state.rs#L159-L174
asking because we might have fucked up
so once blank anyone can use it?
Correct. If it's not initialized it will lazily do it.
initOpenOrders isn't used anywhere
the ts package seems to only call the system program create ix
i have some dex confusion, so the DEX init an open orders on the fly?
I don't think so. ü§î
it seems to still be in the repository as of the latest release https://github.com/project-serum/anchor/blob/0a660d26c4ae65a772d2ef76623f6c468adf1d58/ts/src/idl.ts#L132

did it get moved around or temporarily removed
Can just copy paste the implementation. The address calculation hasn't changed.
what would be the equivalent  in 0.14.0
the multisig ui thats currently deployed uses a util function `    const idlAddr = await anchor.utils.idlAddress(programAddr);`, this apparently isn't present in anchor 0.14.0 <a:aPES_Think:493353113332219924>
I think it makes sense.

 Am pretty new to the later versions so kinda unfamiliar with the concept. But seeing declare_id the same across different programs rang the bell
yes plz get back to work on this
Lol, ok, I should get back to work on https://github.com/project-serum/anchor/pull/868 (not 100% sure it's a great approach)
Pulled my hair out for couple hours, nuked the repo like 5 times, finally got it.

It was declare_id doesn't match..
Which code ... the one in the caller program or the program that is being called ? Haven't called it from a JS client yet but I have run tests ... the call is not reaching the first line of code of the program that is being called ..  and the caller program was tested from a JS client and it works well
Are you sure the rest of your code works without the cpi instruction ?
Wait, is this actually a stack issue?
Hi everyone .. I am trying to make a CPI call and I am getting the `exceeded maximum number of instructions allowed` error right after making the call to the other program .. something weird since that's the only call is being done from the caller program and the other program doesn't even do anything ... the exception is thrown before the program that is being called executes the first line of code ... can somebody help me out ?
jstarry championing the people's causes as usual
I see, I renamed one of my program, and now the anchor.workspace have two copies of them in different name. Maybe it thinks I am referring to the old one.. <:facepalm:847915911855603742>

Ohhh nice so all the Errors # on anchor test is actually referring to the Rust error code, that's neat!!
Really need this https://github.com/solana-labs/solana/issues/13391
Interesting. From the CFO example here https://github.com/project-serum/anchor/blob/d9c643c499121108f9c833571fff5b165a9a0a1b/tests/cfo/tests/cfo.js#L381 and https://github.com/project-serum/anchor/blob/d9c643c499121108f9c833571fff5b165a9a0a1b/tests/cfo/programs/cfo/src/lib.rs#L932
It seems like you can only check the instruction count ?
<@!501570363566587905>  Not sure what is the way forward with regards to https://discord.com/channels/889577356681945098/889577399308656662/898268706612846673
Do you also recommend using the SYSVAR ?

Update: Problem seems to be elsewhere. In my test the bundled Tx works fine. A standalone spl transfer in the FE code works fine, but the same code within a bundled Tx does not. Nothing crashes. Weird.

The following does not work:
```
 let tx = new web3.Transaction().add(
          poolProgram.instruction.deposit(
            new BN(depositAmount),
            new BN(lpUsdtAccountBalanceBeforeDeposit),
            new BN(poolUsdtAccountBalanceBeforeDeposit),
            {
              accounts: {
                [...]
              },
              instructions: [
                Token.createTransferInstruction(
                  TOKEN_PROGRAM_ID,
                  lpUsdtTokenAccount.address,
                  poolUsdtAccountBeforeDeposit.address,
                  wallet.publicKey,
                  [],
                  tou64(depositAmount),
                ),
              ],
            },
          ),
        );
```
But replacing my Tx instruction by the following works:
```
 let tx = new web3.Transaction().add(
          Token.createTransferInstruction(
            TOKEN_PROGRAM_ID,
            lpUsdtTokenAccount.address,
            poolUsdtAccountBeforeDeposit.address,
            wallet.publicKey,
            [],
            tou64(depositAmount),
          ),
        );
```
thanks
and i'll try again to make a reproducible example
it would certainly beat having a separate `initOneSingleTokenAccount` function
yeh, i'll give that a shot
oh right, yes this is how the serum accounts structs work
see tests/misc for an example of creating a token with seeds
also how do i use signer_seeds
Doing this will move the constraint code into a new function, which might help stack frame usage.
Example here https://github.com/project-serum/anchor/blob/master/tests/composite/programs/composite/src/lib.rs#L39
just like extending the existing struct somehow using some rust syntax
oh, i haven't seen that done before
At least for the non init accounts.
the tests don't have implementation to create a token
Also, I would try  provide explicit bumps.
And embedding/composing that into the existing struct.
Can you try extracting out some of those init calls into a new `#[derive(Accounts)]` ?
It doesn't make any sense to me why that's the case, but also not surprised.
LLVM is probably generating different code in your repro example, since it's missing all the other surrounding code.
i'm going to try adding the `trim_ascii_whitespace` functions to a bunch of the things to see if it will reproduce
Nothing off the top of my head.
no, i haven't been able to reproduce yet
is there something in how constraints changed over the versions that might have made this happen
Does the `memory-issue` repo reproduce?
You're probably providing the wrong address on the JS side.
Also you could try some compiler optimization flags.
Extracting out some code into functions and using `#[inline(never)]`
Could try solving this by messing with the codegen.
Not sure. Probably just a legitimate stack overflow.
ah right thanks...sounded somewhat like my hackathon project for solana hackathon haha
Ah I kept thinking it was error on JS side. üôèüèª
<@!501570363566587905> any thoughts on what could be causing an issue with the heap here?
DAO program https://github.com/solana-labs/solana-program-library/tree/master/governance
what is spl-governance?
Which means your `Program<T>` type has the wrong address.
This can only be returned in one place https://github.com/project-serum/anchor/blob/b1ef7431eca809dbca41601008fa220e19b8dee7/lang/src/program.rs#L25
Trying to do some CPI  and running into a series questions..

What would cause "Error: 168: Program ID was not as expected" on JS side? I am passing in `program.programId` for the targeted program, and `anchor.web3.SystemProgram.programId` for system program
Thanks, I'll give it a go
Probably the best thing to do is to pass in the token-metadata account as well. You'll need to verify it though.
See tests/token-proxy
if I have an asset mint like ```pub asset_mint: Account<'info, Mint>,``` is there any way to get the name of the underlying currency? I want to match the name to check it against an oracle.
how can i use https://github.com/project-serum/anchor/blob/master/spl/src/token.rs#L317
with cpi
bumping a question here:
 are there any suggested patterns for reducing number of accounts being used? I'm currently making several sequential cpi calls within a function which is resulting in issues with transaction being too large 1269 > 1232 since I need to pass in the accounts for all of the cpi calls
I would have expected that basic idea to work (being able to see the results of previous instructions). Fwiw there's also this interesting sysvar that lets you look at all the instructions in a tx: https://docs.solana.com/developing/runtime-facilities/sysvars#instructions


///////////////////////////////////////////////////////////////////////////////////////////////

I think it's still used because it's like defacto standard for bignumbers with bignumber.js
`bn.js` was created when `BigInt` did not had solid roadmap yet. Not sure about benifits right now. There also a big problem that's it's hard to update `bn.js`. We made v5 release 2 years ago, but if you check downloads page v4 is still have more downloads üò¶ https://www.npmjs.com/package/bn.js?activeTab=versions
Yeah apparently node has had them too since 10.4.0
https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-2.html#bigint
i think we're at 4.4 now
was introduced in TS v3.2
Though other packages like @solana/spl-token use `bn.js` so switching over may cause more problems than solves.
I didn't even know the builtin bigint type existed. <@!448034961652449283> might have some insight.
not sure what the benefits of `bn.js` vs the builtin `bigint` type are
yeah thats been there for quite some time
TIL that JS has a built-in BigInt type now? You can stick an "n" after an integer literal and it will be a BigInt automatically.
yeah git submodules aren't the greatest but that's probably how i'd solve it here as well
Maybe a local validator running in the background but other than that I don't know.
They aren't great. At the same time they get the job done.
now for something completely different:

Anyone got any ideas for how to use the code from the Anchor tests in my AnchorPy repo? My CI needs the Rust code in `anchor/tests`. I've heard of git submodules but the things I've heard have been mostly bad
I don't have a good way of asking this question but:

Is there anything in the `anchor localnet` command that could create zombie processes? I've got this weird case where the localnet command appears to become a zombie instantly when using `pytest-xprocess`, but works normally otherwise (and `pytest-xprocess` works fine with other commands)
<@!134416332509675520> , could you inform me how can I transfer token from one account to another using anchor in client side please?
any idea why this happens ? I followed the events example
<@!248066053161222144> the trait bound `botapi::Initialize: InstructionData` is not satisfied
seems like there is an issue because quarry-merge-mine is converted to quarry_merge_mine (underscore instead of dash)
anyone know how to fix this issue? `Error loading workspace IDL for quarry-merge-mine`
Generate a keypair using the command line cli
When I make my own program, how can I generate that value?
Anchor uses it to verify that program accounts are actually owned by the correct program (the executing program)
Declare id is a macro from the Solana sdk you can check out the deets there
what is declare_id! for? Is it just for test?
Yes
running into this issue when doing anchor build hread 'rustc' panicked at 'Failed to get crate data for crate11', compiler/rustc_metadata/src/creader.rs:136:32
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

error: internal compiler error: unexpected panic

note: the compiler unexpectedly panicked. this is a bug.

note: we would appreciate a bug report: https://github.com/rust-lang/rust/issues/new?labels=C-bug%2C+I-ICE%2C+T-compiler&template=ice.md

note: rustc 1.52.1-dev running on x86_64-apple-darwin

note: compiler flags: -C opt-level=3 -C embed-bitcode=no -C lto=no -C opt-level=2 --crate-type cdylib --crate-type lib
<@!134416332509675520> , Is declare_id! mandatory for the programs?
I've done this before - just give it `{}`.  If it complains about needing something, add it.  I can't remember the specifics of what I've needed to add but it was like pubkey or a dummy method.
There was a thread about this but I can't find it, can you just pass `undefined` for the Wallet?
```
  const connection = new Connection(url);
  const provider = new Provider(connection, wallet, { // <-- I don't want wallet here.
    skipPreflight: false,
    commitment: 'confirmed',
    preflightCommitment: 'confirmed'
  })

  const program = await Program.at(pubkey, provider);
```
I obviously need to specify a url, but I don't want to specify a wallet.
`const program = await Program.at(pubkey);`
Is there a way to construct an anchor program without a wallet (I'm not signing anything, just getting info)?
Awesome! üëÄ
here's the first release of AnchorPy: so far I've only tested it against the Anchor tutorial but those tests pass at least ‚öì üêç  https://github.com/kevinheavey/anchorpy
Anyone know if there currently is a devnet serum program I can add markets too?
I had abandoned searching for this and using uint.. thx
Yes! Reinstall solana to have the right version!
kk
Correct.
`Program failed to complete: Access violation in stack frame 5` is stack overflow and not an oob or something right?
<@!501570363566587905>
sweet, ty!
Kind of funky I know.
`const enum = { myEnumVariant: {} }`
this is the idl type ```          "type": {
            "defined": "Side"
          }```
```   * * If `src` has a property matching the Union discriminator, the
   *   value of the discriminator identifies a registered variant, and
   *   either (a) the variant has no layout, or (b) `src` has the
   *   variant's property, then the variant is returned (because the
   *   source satisfies the constraints of the variant it identifies);
   * * If `src` does not have a property matching the Union
   *   discriminator, but does have a property matching a registered
   *   variant, then the variant is returned (because the source
   *   matches a variant without an explicit conflict);```
ive read the comments around those union functions but the language is impenetrable to me
does anyone happen to know if/how... if you want to use a rust enum as an anchor function parameter, how to form the argument on the js side? ive tried a few reasonable seeming thing but always ```     Error: unable to infer src variant
      at Union.defaultGetSourceVariant (node_modules/buffer-layout/lib/Layout.js:1667:11)
      at Union.getSourceVariant (node_modules/buffer-layout/lib/Layout.js:1579:14)
      at Union.encode (node_modules/buffer-layout/lib/Layout.js:1709:22)```
try ```sudo anchor build```
Hey I'm just getting started with anchor and I'm getting this error when I run `anchor build` can anybody help me here? or point me to a place where I can get some help for this please?
added that in the client part
doesn't work
yeah the previous error, had 2 errors\
Will probably also have to do `use anchor_lang::InstructionData`
So making the versions match fixed things?
```    program
        .request()
        .args(Initialize {})
        .send()?;```
this error didn't change ```the trait bound `botapi::Initialize: InstructionData` is not satisfied
```
it works now
they don't
Just to double check, are the client and the program using the same version of anchor_lang?
in the client part
Sorry, where did you try doing `use anchor_lang::Event`, in the program above or in the client part where you're doing `let handle = ...`?
yes
```use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod botapi {
    use super::*;
    pub fn initialize(ctx: Context<Initialize>) -> ProgramResult {
        emit!(MyEvent{
            data:6,
            label:"hello".to_string(),
        });
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize {}

#[event]
pub struct MyEvent {
    pub data: u64,
    #[index]
    pub label: String,
}```
Did you declare your event type with `#[event]`?
```botapi = { path = "./botapi/programs/botapi",features = ["no-entrypoint"]}```
should I implement that ?
same thing
Try doing `use anchor_lang::Event`?
for running anchor tests against an instance of solana-test-validator, are the programs in the [[test.genesis]] section deployed automatically when the validator is started? i have serum_dex as a dependency also in the test.genesis section and it seems like that address isn't initialized
```    let handle = program.on(move |_ctx: &EventContext, event: MyEvent| {
        sender.send(event).unwrap();```
Trying to listen to events, I always get this error ```the trait `Event` is not implemented for `MyEvent`rustcE0277
```
Thank you. Let me try.
I haven't tried that, but you might be able to do `anchor test --provider.cluster devnet`
<@!134416332509675520> , is there any way to run anchor test on devnet please?
Thank you.
Solved, I was being dumb and looked right past the hardcoded token id.
but honestly i wouldnt hardcode oracle address
well you still need to pass in in context
maybe that's a bad idea though
I guess I don't want to take it as input, if it's hard coded there's less validation required.
Awesome. They are same.
this is just account that holds data
idk how to explain this
then just deserialize the data
well as input of the program
So let's say I know I want BTC price which is HovQMDrbAgAYPCmHVSrezcSmkMtXSSUsLDFANExrZh2J, where would I put that key
yep
it's these test scripts in the package.json right?
+ you can run them in parallel on github CI
check synthetify we have cool way
there is no way to just get all oracles from one net
you need to use it one by one
You mean what is it for? It embeds a static `ID` variable in your program with its intended address (try searching the discord about it, lots of prior discussion)
Thank you. BTW, what is declare_id!?
Ok, try doing `await program.provider.connection.getAccountInfo(counter.publicKey)`, and check who its owner is/compare it what you've got in your `declare_id!`
We should add package.json + yarn test to all those tests to do this.
No unfortunately.
as in the ones that run in the CI
is there any convenient way to run all the Anchor tests locally?
The only codes that I touched.

<@!134416332509675520>
or do you mean like once cluster is set to devnet in anchor.toml it'll pull from Pyth?
Where would you change the address to devnet? In the tests?
you just need to use devnet oracle address and it should work
Anchor test. I think I probably messes lots of things up by:
- constantly renaming the projects
- having multiple programs in one repo
- when I do anchor new xxx, the declare_id is the same as other program, I have to manually update it

I got the right program ID from test log and gonna update the declare_id with it (And of course it works !)
Are you using `anchor test` or deploying manually?
Got it, I suspected. No matters what I do declare_id is never right for me <a:Sadgemusic:888947791991287869>
What have you changed about `basic-2`? Think you'll have to post more of your code. But anchor is telling you that some account's owner isn't what it expects‚Äîthat could either happen because your `declare_id!` doesn't match the program's actual id (annoying, anchor will hopefully automate this since it's easy to make mistakes), or because some account really isn't owned by the program when it's supposed to be
<@!134416332509675520> ?
Account is preferred. Account will check the global ID in the program generated by `declare_id`. Your error was probably because your deploy address didn't match the `declare_id` adddress.
What's the differences between `Account`  and `ProgramAccount`?

I was told they are the Account is the new ProgramAccount, but ran into the issue where `Account` gave my PDA 167 (account not owned by executing program) but `ProgramAccount` was fine.
I am using anchor test
Are you using `anchor test`? Or are you using a local `solana-test-validator`?
I have no idea. I am just overwriting the sample. What is right declare_id!?
Are you using the right `declare_id!`?
ü¶πüèª‚Äç‚ôÇÔ∏è
^ Lol, the fact that I knew how to fix that trait error means I'm in too deep üòÜ
Thanks this seems like what I need
<@!134416332509675520> ?
Thank you. I fixed it by changing "../../../../../spl" But another error.
Very good
But on chain GM streaks can lead to on-chain streak bets
https://github.com/Synthetify/synthetify-protocol/blob/master/programs/exchange/src/lib.rs#L113
`Clock::get()`
On initialization, find_program_address is used to validate the bump seed. For the reasons above.
Indeed. create_program_address is used in that case *except* on initialization.
`anchor::solana_program::clock::Clock`?
nevermind just realized its O(1) if the bump is supplied
You can access the clock without passing the account
v2 will be assembly
isn't that bad practice, to put an unbounded call to `find_program_address` on every method involving a PDA?
https://tenor.com/view/sad-kermit-kermit-the-frog-jump-off-gif-17801028
lol
We need .rs
.ts
No
It can also be used to assert the address of a given account matches the PDA defined by the seeds.
ship it
this `seeds = ...` macro isn't needed unless we're initializing a new PDA?
<@!501570363566587905> how're we feeling about this
https://github.com/callensm/ahoy/blob/master/discord/src/captain.ts#L70
It does. Though it's easy to miss them.
also ``unresolved import crate could not find __client_accounts_initialize`` in the crate root` on the #[program] declaration
basic-01 runs okay tho
I'm getting a ton of proc-macro derive panicked panicked on the example webapp from Nader Dabit: https://dev.to/dabit3/the-complete-guide-to-full-stack-solana-development-with-react-anchor-rust-and-phantom-3291. The same happens with example basic-02 from official anchor repository ü§î
Otherwise, you will have many accounts for the same set of seeds.
Because there are many valid bumps. However, you need to ensure you use *the* canonical bump.
This is only done, purposefully, on intialization (it's also done if you specify `bump` without  a value, but this shouldn't be done in most cases unless you aren't worried about compute).
What's up with the `#[accounts(seeds = ...)]` macro? Don't you pass a specific public key anyway? Does it validate it on chain? Why is this needed? From the docs:
> On initialization, validates the given bump is the bump provided by Pubkey::find_program_address
isn't it bad practice to call find_program_address on chain?
I know <@!812755783405797376> has, not sure if the implementation is secret though... https://www.youtube.com/watch?v=es_f2Nanpj0


///////////////////////////////////////////////////////////////////////////////////////////////

But it shouldn't matter if you're using anchor ..
I actually don't know what I'm talking about üòÖ . I was thinking you want the buffer you get back from `getAccountInfo` to always be a fixed size.
are there better alternative?
afaik, account size can't expand, right?
what kind of error is this likely to be? also how can i better debug such error messages?
```
failed to send transaction: Transaction simulation failed: Error processing Instruction 0: custom program error: 0x12f
```
hmmm do you plan to have fixed sized accounts throughout your program(s)?
not sure if this is a n00b question, but how does this help scalability?
for scalability
`  pub extra_account_1: Pubkey,
  pub extra_account_2: Pubkey,
  pub extra_account_3: Pubkey,
  pub extra_num_1: u8,
  pub extra_num_2: u8,
  pub extra_num_3: u8,
  pub extra_feature_1: bool,
  pub extra_feature_2: bool,
  pub extra_feature_3: bool,`
is it a good idea to leave some extra space in the Account like this?
Yea it goes both ways. Once you have a habit it's hard to break out of it üòõ
hmm I wish solana labs would start using anchor. I hate looking at/interfacing non-anchor program code. üò©
For context, here is the PR that this will work with https://github.com/solana-labs/solana-program-library/pull/2450#issuecomment-944915361
Okay. Will be following closely. üôè
It will write a `VoterWeightRecord` account, which is then read by the governance program.
No. But it's meant to be used with it.
<@!501570363566587905> is <https://github.com/project-serum/governance-registry> intended to proxy the spl-governance program?
Now we just need crab, sparrow, and gopher versions and we can launch an NFT üòõ
This logo is too awesome
Awesome. <:salute:746135852324749443>
congrats!
oh right, yeh that would be a good call too
Oh, right, misunderstood what you meant. Hmm, maybe, would have to think about it some more‚ÄîI think ideally I just figure out how to finish that pr for killing `declare_id!` entirely
cause the regular compile errors when there's no `declare_id` are pretty opaque / seemingly unrelated to the program id
or is there some way to check if `declare_id` isn't used in the program and cause a compile error
I was thinking one thing we could do, at least in debug mode maybe?, would be to panic if the declare_id! doesn't match the actual runtime `program_id` from the generated entrypoint function.
it seems like a source of random / hard to debug errors
i wonder if there's some way to add a more clear error linked to missing declare_id / incorrectly declared id between the `anchor.toml` file and the program code <@!134416332509675520> ?
nvm i am silly - `declare_id` was different since i was playing around with diff deployments
I've checked the failed tx on explorer and all my program accounts are indeed owned by the program üòÜ
Has anyone run into `AccountNotProgramOwned` after upgrading their program? This is on devnet fwiw
all working now, thx everyone üôÇ
declare id is sumofabitch
oh right
i don't think anchor has been upgraded to work with 1.8.0 yet
following up on this, was missing `declare_id!` at the top, so this error was actually probably about execution inside of the macro about not having the program_id. so yes it was more migration stuff to a newer anchor. thanks <@!134416332509675520> for helping resolve üôÇ
lol now seeing
```
| #[program]
| ^^^^^^^^^^ not found in this scope
```
not sure
did a few things, but i think `cargo clean` addressed this
I'm on 1.6.28
downgrading to solana 1.7.11 solved this. anyone running 1.8.0?
^ Would be curious to know what `anchor-lang` says in your Cargo.lock file
Haha, the person who ostensibly fixed it was me üòÖ Seems to work for me though, hmm.
oh, it might be something with solana deps. issue is arising with solana-frozen-abi-1.7.11, which i'd imagine should match 1.8
I'm still seeing this issue in 17.  ran into it yesterday.  I too thought someone fixed
(just updated to 1.55.0, still the same error)
this sounds like a rust issue, and farther down in the logs it says: `note: rustc 1.52.1-dev running on x86_64-apple-darwin`, but if i run `rustc --version` i get `rustc 1.54.0 (a178d0322 2021-07-26)`
Interesting, never seen that one before lol. What version of rust are you compiling things with?
getting this error now:
```
error[E0460]: found possibly newer version of crate `std` which `rustc_version` depends on
```
oh, good catch. that sounds plausible
Ok I think the issue above is that at one point `seeds` didn't accept trailing commas (but now it does)
ah, that was wrong. just updated to `0.17.0`
Just to double check, what is your `anchor-lang` version in Cargo.toml?
mostly-unrelated, not sure if anyone addressed this in the channel, but i saw this same error `thread 'rustc' panicked at 'Failed to get crate data for crate11'` after upgrading solana & anchor as well. strangely, seems to be resolved if i explicitly run the `anchor test` sub-command `cargo +bpf build --target bpfel-unknown-unknown --release`. any idea why that'd be the case?
it's possible i've got more migration work to do for the newer anchor, just wondering if that error above was immediately telling to someone who's been through this already
after
```
#[derive(Accounts)]
#[instruction(element_nonce: u8)]
pub struct AddElementToGroup<'info> {
    #[account(signer)]
    pub sender: AccountInfo<'info>,
    #[account(
        init,
        seeds = [
            group_account.to_account_info().key.as_ref(),
            b"element_account",
            (group_account.element_idx + 1).to_string().as_bytes(),
        ],
        bump = element_nonce,
        payer = sender,
        space = 1024,
    )]
    pub element_account: ProgramAccount<'info, ElementAccount>,
    #[account(mut)]
    pub group_account: ProgramAccount<'info, GroupAccount>,
    pub rent: Sysvar<'info, Rent>,
    pub system_program: AccountInfo<'info>,
}
```
before, with `&[element_nonce]` in the seeds
```
#[derive(Accounts)]
#[instruction(element_nonce: u8)]
pub struct AddElementToGroup<'info> {
    #[account(signer)]
    pub sender: AccountInfo<'info>,
    #[account(
        init,
        seeds = [
            group_account.to_account_info().key.as_ref(),
            b"element_account",
            (group_account.element_idx + 1).to_string().as_bytes(),
            &[element_nonce],
        ],
        payer = sender,
        space = 1024,
    )]
    pub element_account: ProgramAccount<'info, ElementAccount>,
    #[account(mut)]
    pub group_account: ProgramAccount<'info, GroupAccount>,
    pub rent: Sysvar<'info, Rent>,
    pub system_program: AccountInfo<'info>,
}
```
hey guys
lol i hope not, let's see
Can you show the struct/macro?
Are you missing a comma?
if i remove the bump, it no longer complains, but then during tests it throws an error about the missing bump, as i'd expect
hey all, upgraded solana & anchor just now (1.8.0, 0.17.0), and was going through introducing the explicit `bump` argument in various `#[account(...)]` macros. most of them work, but then just one introduces this new issues with `#[derive(Accounts)]` as pictured here. any ideas?
something like msg!("debug {:?}", ctx.accounts)
is there any easy way to debug ctx.accounts ?
can you just give a "dead wallet", i.e. just provide an address you will not use anyways?


///////////////////////////////////////////////////////////////////////////////////////////////

i have ran into this before just dont remember what the cause was <a:Hmmmm:695129200260153375>
not giving `new anchor.BN(xx) ` for a number? <:4971_pepe_thinking:882326900859633775>
ok thanks
unless something has changed recently, it's not possible
is there a way to simulate time passed when testing?
would love a quick pointer if you don't mind
I'm going to try it real quick, I'll let you know though
Happy to screenshare real quick if helpful
You can insert `debugger;` statements etc anywhere in your js code, or run `Cmd-P` (on macs anyway) to set line breakpoints, etc.
When you run your tests, they will actually just open up a websocket or whatever. Go to `chrome://inspect` and there will be a little link to start debugging them
This is a bit hacky but one thing you can do: change your Anchor.toml `test` command to be `mocha --inspect-brk ....`
would love a point in the direction of how to do this
`anchor test`
Are you running this via `anchor test`? Or in the browser etc?
One thing you could do if you're really not sure where the issue is, is to just set a breakpoint in that function (how to do that depends on how you're running the code) and see what `src` happens to be
````
     TypeError: src.toArrayLike is not a function
      at BNLayout.encode (/Users/connorohara/Prog/switchboard-core/node_modules/@project-serum/borsh/src/index.ts:51:11)
      at Structure.encode (/Users/connorohara/Prog/switchboard-core/node_modules/buffer-layout/lib/Layout.js:1263:26)
      at Structure.encode (/Users/connorohara/Prog/switchboard-core/node_modules/buffer-layout/lib/Layout.js:1263:26)
      at InstructionCoder._encode (/Users/connorohara/Prog/switchboard-core/node_modules/@project-serum/anchor/src/coder/instruction.ts:85:24)
      at InstructionCoder.encode (/Users/connorohara/Prog/switchboard-core/node_modules/@project-serum/anchor/src/coder/instruction.ts:68:17)
      at /Users/connorohara/Prog/switchboard-core/node_modules/@project-serum/anchor/src/program/namespace/index.ts:51:56
      at ix (/Users/connorohara/Prog/switchboard-core/node_modules/@project-serum/anchor/src/program/namespace/instruction.ts:43:15)
      at txFn (/Users/connorohara/Prog/switchboard-core/node_modules/@project-serum/anchor/src/program/namespace/transaction.ts:17:14)
      at Object.rpc [as leaseWithdraw] (/Users/connorohara/Prog/switchboard-core/node_modules/@project-serum/anchor/src/program/namespace/rpc.ts:16:18)
      at Context.<anonymous> (tests/new-crank-tests.ts:556:25)
      at runMicrotasks (<anonymous>)
      at processTicksAndRejections (internal/process/task_queues.js:95:5)
````
Do you get a stacktrace?
I assume it has to do with the wrong type inserted somewhere in my RPC call but I do not see where / how
Does anyone know of any ways to diagnose `TypeError: src.toArrayLike is not a function` errors? I've got it multiple times and it's very opaque
Any smart contract API
which API?
Does it ever need to be in the API though?
Seems like a good idea.
Awesome.
I think you could just store whatever extra information you need in that PDA (doesn't need to be zero-copy I don't think). The existence of the PDA implies they're whitelisted, the data in the account at that PDA tells you whatever extra info you need.
The whitelist also indicate the number of NFT that user can claim. Could you let me know if zero-copy PDA also works for it please?  üôÇ
Awesome.
The existance of the account means its whitelisted
And use that as somewhat of an "auth token"
I would just use a PDA per whitelist entry.
Step 1: Learn Anchor
Step 2: Create a zero-copy PDA to hold a list of accounts, with functions to add entries
Step 3: Figure out how to hook your gatekeeper program up to your target program, or vice versa
üòÖ
I am going to develop ***___on-chain whitelist___*** on solana. Does someone know how to do this?
example U192: https://github.com/saber-hq/stable-swap/blob/master/stable-swap-math/src/bn.rs#L96
I think you'd have an anchor U192 crates that contracts can consume and then you'd also add decoding logic to the ts
Has anybody though about adding U192 support?
in your code?
Yea I am trying to see if I can get my tests to run on devnet and then take those program IDs but getitng a bunch of errors about provider. Is there anything I need to do to switch from localnet -> devnet?
https://github.com/project-serum/swap/blob/master/tests/swap.js

maybe these test can help
Hey everyone, is there a guide on how to add markets to the Serum devnet?
based <:Prayge:878114302479958037>
life wud be much easier if we cud realloc accounts though <:Prayge:878114302479958037>
best to just allocate the extra 1byte
we got a 246 bump recently <:sweaty:882326902973530162>
prolly gets worse if it takes a while to find ur bump
like 13k compute from one time I tested it although now that i think about i didnt see the bump then <a:Hmmmm:695129200260153375>
its quite a big hit tbh
`authority` = person who'll get the lamports
`user_obligation_liquidation` = account to drain
try something like this
```rust
  let lamports = ctx.accounts.user_obligation_liquidation.lamports();
  **ctx
       .accounts
       .user_obligation_liquidation
       .try_borrow_mut_lamports()? = 0;
  **ctx.accounts.authority.try_borrow_mut_lamports()? += lamports;
```

<@!595567283028623362>
Does the require more compute?
```    #[account(mut,
        seeds = [distributor_account.key().as_ref(), b"grant_mint".as_ref()],
        bump)]
    pub grant_mint: Box<Account<'info, Mint>>,```
So that writing only this you can still get the bump in the method
any way we can surface it right now?
ah you do need it for signing since it isn't accessible anywhere, so yes storing it will help
Storing the bumps will be done in the account header in the future, which should help some.
```    #[account(
        mut,
        pda_from = distributor
    )]
    pub grant_mint: Box<Account<'info, Mint>>,```
Maybe a PDA of a program account could have additional abstraction? I am not sure if that's easy to do without being too limiting
you don't actually need to store the bumps if you accept the performance hit
Nothing great at the moment. Any ideas for an API change?
Started using PDAs more, now wondering if there's a way to DRY the code, as i keep repeating seed & bump spec, across all my instructions. One example:

```
 #[account(
        seeds = [distributor_account.dist_mint.key().as_ref()],
        bump = distributor_account.bumps.distributor_bump,
    )]
    pub distributor_account: Box<Account<'info, DistributorAccount>>,

    #[account(mut,
        seeds = [distributor_account.key().as_ref(), b"grant_mint".as_ref()],
        bump = distributor_account.bumps.grant_bump)]
    pub grant_mint: Box<Account<'info, Mint>>,

    #[account(mut,
        seeds = [distributor_account.key().as_ref(), b"grant".as_ref(), receiver_authority.key().as_ref()],
        bump = bump)]
    pub grant_account: Box<Account<'info, TokenAccount>>,
```
If lamports will be sent to, or data will be allocated or modified then yes you need to mark it as `mut`
basically init PDA of another account Via CPI
```#[derive(Accounts)]
mod my_program{
  pub struct EntryToMyProgram {
    pub pda_of_another_program_to_create: AccountInfo<'info>, `<--- This is the account to be initialize by another program I am calling, Does this need to be [mut]?`

    pub signer: Signer<'info>,
    pub target_program: Program<'info>
  }
  
  pub fn create_target_pda() -> Result<()>{ 
     let cpi_accounts = CreatePDA {
          pda_of_another_program_to_create: ctx.accounts.pda_of_another_program_to_create
          signer: ctx.accounts.signer.to_account_info(),
      };
           
      let transfer_ctx = CpiContext::new(
         ctx.accounts.target_program.to_account_info(),
         cpi_accounts)
  }
}

mod target_program{
  pub struct CreatePDA{
    [account(init, payer=signer, seed = [b"hello"])]
    pub pda_of_another_program_to_create: Account<'info, SomeStruct>,
    pub signer: Signer<'info>
  }
}```
If I want to call another program to initialize a CPI account, do I need to mark it as mut?
thanks, but it kind of doubled my compute and Program failed to complete: `exceeded maximum number of instructions allowed (16482) at instruction #25571` still persists, damn
This is a free win https://discord.com/channels/889577356681945098/889606719829835816/896559943610662962
What are some tips to reduce compute cost, i am having a hard time doing 2 swaps in one go. üôå
I am biased because of Rust and Python using snakecase
personally I would like if names didn't get camel-cased when written to the IDL, and all that work was deferred to the client
also I think using anchor events is another way, perhaps it's a bit cheaper ...
Logging is actually a lot cheaper if you log in this manner and don't use string interpolation:
https://github.com/solana-labs/solana/blob/2c60c48eb277525795cc0075a061c1c0f9270ce4/sdk/program/src/log.rs#L24

but obviously harder on the eyes üò©
LOL `state of the art`
Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 1: custom program error: 0x0
hey all, what could this error mean?
Here is the code
I am trying to do 2 swaps in 1 function, and i am running to `exceeded maximum number of instructions allowed`, any workaround this issue, how could one tackle this
how did you solve this?
Anyways, yeah, definitely a kind of unfortunate developer ux situation‚Äîthe `Initialize` struct you want comes from the macro-generated module `botapi::instruction`, but rust-analyzer doesn't get that for some reason, so it probably goes out of its way to suggest using `botapi::Initialize` instead, which is a totally different struct (it's the `#[derive(Accounts)]` one, which likely has the same name as the instruction handler function, which is what generates the `botapi::isntruction::Initialize` struct, oof).
I'm a genius lol
I'm not sure what serum does (haven't looked at the code much yet), but yeah, at the moment you can't reallocate more space for an account (though it sounds like you will be able to soon!)
‚ù§Ô∏è
wow
it worked
Can you try running the program anyway? Rustanalyzer gets pretty confused about this macro stuff
there's no instruction
```unresolved importrust-analyzerunresolved-import
```
Oh maybe you need to do `botapi::instruction::Initialize` instead?
yeah fixed that
Just to double check, you're sure that you're using the exact same version of anchor-lang everywhere?
but I searched and it's implemented in the anchor library
I don't think there is anything
Oh, maybe you won't since it's all in macro stuff ü§î
Hmm, if you hop to source on `botapi::Initialize`, do you see anything about the `InstructionData` trait?
still facing this error
<@!134416332509675520> ```the trait bound `botapi::Initialize: InstructionData` is not satisfied
```
Is this how Serum does it? I figure without this, it would be a hassle when updating to v4, v5, etc
I see thanks
Currently the state of the art technique for error inspection lol is to do 0x12f = 303, note that your own custom anchor `#[error]`s start at code 300, and then look at the fourth enum variant (they go 300, 301, 302, 303,...)
You'd just need to allocate extra space, no need to specify ahead of time what rust types you'll fill it with (borsh will happily ignore any extra space left over after serialization)


///////////////////////////////////////////////////////////////////////////////////////////////

Thank you so much.
I don't have an example on-hand, but you would want to get the account info using the pubkey for the wallet, iterate through the available accounts, check that the account for tokens that are NFTS: `TokenAmount.UiAmount` == 1 and `TokenAmount.Decimals` == 0. Then you need to get that tokens Metaplex metdata and check that the creator address matches that of the collection you are interested in
Using web3.js or sth?
Well, is there any way to check how many NFT of certain collection certain wallet have?
hey all, I'm trying to initialize an account which as a property that hols an array of strings and my program is failing with `failed: custom program error: 0xa4'`
```Rust
pub fn create(ctx: Context<Create>) -> ProgramResult {
        msg!("initalizing account");
        let base_names = vec!["Grass", "Stalk", "Lily", "Root", "Lotus", "Vine", "Plant", "Bloom"];
        msg!("{:?}", base_names);

        let flora_account = &mut ctx.accounts.flora_account;

        for name in base_names.into_iter() {
            flora_account.base_names.push(String::from(name));
        }
        msg!("{:?}", flora_account.base_names);
        msg!("done");
        Ok(())
    }
...
#[account]
pub struct FloraAccount {
    pub base_names: Vec<String>,
}
```

If I reduce the base_names `Vec` down to one element, the program runs fine and returns the vector to the client. However, running with 8 elements as is, results in the aforementioned error. This is probably due to some size limitation enforced by the Solana runtime? Is there anyway to know this and is it possible to accomplish what I'm doing?
as in sending many `requestAirdrop`s in one http request
does batching the requests work?
i dont have 1k sol in devnet though, you need someone one like mvines to gift you sol
what is ur pubkey? there is some severe rate limiting that happens when you do this
We are so early üôÇ
Yep haha I will go make some coffee.
devnet is 5, so you'll just have to do it multiple times
yeah different networks have different airdrop amount limits
I just made a bash script to run it 200 times.
Devnet
which network?
Is there any way to airdrop more than 5 sol?
If you're listing 100s of markets then you might
It depends what you're doingn
Yea I have a setup for localnet anchor tests that works fine but when I go to devnet it says I need 1000 sol? Seems kinda high no?
`projectserum/swap` on GitHub
You could look at what Armani does for the swap repo on local host and try to replicate it on devnet
If there was it's since been deleted from serum discord
Not really
Haha sorry late night lol. Is there any documentation or a thread on how to get a devnet market up on serum?
What's the question?
Going to bump my question about getting serum markets on devnet for testing. Thanks
Hi. Looking for a reviewer/auditor for a simple Solana contract (not written with Anchor). We pay well. Thanks!
what's the method in rust to get associated token accounts by owner (maybe with mint filter)
Yeah, it's just a PDA hash fudge factor, to make sure a program-derived address isn't accidentally squatting on some poor public key's home
Thank you! So it is a PDA thing. Solana memory model is FUN
Linking a thread I wrote a few days ago, let me know if I can explain anything further! https://discord.com/channels/889577356681945098/889702325231427584/898235903540080650
Having trouble understanding what these bumps are doing. Are they moving things around in how the memory is realized in the VM, or are they used for calculating addresses for program-derived accounts?
bump
Added some thoughts there
there is only a default at timestamp, no cost to the loan yet
lending for a NFT, the idea is that the collateral can only be agreed between the two parties, since NFT are illiquid. Then you can borrow against a loan agreement the NFT owner created
https://github.com/Arrowana/nft-lending i wrote this possibly totally incorrect program
<@!99911938955309056> not sure that I entirely followed the discussion above but did you see my alternative proposal to the merkle distributor <https://discord.com/channels/889577356681945098/893934976712724551/894142021558763560>
not sure whether keeping the bump separate is necessary
here's what i have which works
```rust

pub trait Seeds {
    fn get(&self) -> ([&[u8]; 4], u8);
}

impl Seeds for TradeYesAccount {
    fn get(&self) -> ([&[u8]; 4], u8) {
        ([self.authority.as_ref(),
                self.market_name.as_ref(),
                self.bracket_name.as_ref(),
                b"trade_yes"],
                self.bumps.trade_yes_account)
    }
}
```
ok will check jet
yeh, i dunno, but it works
i've tried it too and included the bump in it, which i don't think they did
but the thing is a soupy &[&[u8]]
i've seen it done in jet and sebastian bohr's dao program
you can make a impl function on the account struct that returns a referenced u8 array
While not storing the bump, or maybe i should just store it
Is there a good way to abstract creating signer seeds for a program pda?
I can't install anchor master version. Anyone has an idea?
The tutorial on the documentation used a custom external smart contract, but I'd like to use one that already exists on the testnet (like USDC, for example)
can anyone point me in the right direction?
hey all, I'm trying to wrap my head around CPI and the ability to use other smart contracts in development. I'm trying to find any solid tutorial or documentation on how one would go about building a smart contract that one could deposit/withdraw an SPL token like USDC for examplle
is there an easy way to get list of all token holders <a:Hmmmm:695129200260153375>
Shrug emoji
It does not.
Mm, not sure to be honest (I'm pretty fuzzy on how our npm packaging works)‚ÄîI agree it's a little surprising though üòÖ
who knows
maybe I ran something
but... Why would it break like that just over the weekend? Does `Anchor test` automatically update packages or something in the background?
thanks for the catch
It does indeed work
Does it work if you do `import * as anchor from '@project-serum/anchor'`?
heya folks getting a weird bug... Went away from this project for a few days and came back. For some reason TS is not recognizing packages or something? 
```
TypeError: Cannot read property 'web3' of undefined
```
This error refers to the standard imports at the top of the tests file: 
```
import anchor from '@project-serum/anchor';
const { SystemProgram } = anchor.web3;
```
yes indeed - sorry to not respond.  Should be explained on wikipedia at a high level.  Essentially you store levels above the merkle root instead of the root.  This requires more onchain data, but reduces the data size of the proof.  

Since onchain we can hold up to 10MB, but in the tx we can hold a mere 1232 **bytes**, it obviously makes sense to scale that way.

However, I don't think this is needed unless you're scaling into the hundreds of millions, or have other instruction data and accounts that takes you over the limit.  Each level of the tree requires a 32-byte proof, so at 25 levels you're at 33.5 million leaves (2^25) but only using 800 bytes of the tx for proofs (32*25).
I was curios too, looks like this is it https://medium.com/@jgm.orinoco/understanding-merkle-pollards-1547fc7efaa
You can either create the coder yourself via IDL, or use the one on your program client--i.e. `program.coder.instruction.decode`
You can decode the raw instruction data via https://project-serum.github.io/anchor/ts/classes/instructioncoder.html#decode
Yes.
well unrelated to that, i have a new question: is there a convenient API to decode instruction data in javascript and map it into some rich data type via the IDL?
yeah thought about it, but can't think of anything good right now.

in vanilla rust i'd just define a method/macro that i can re-use across the instruction implementations. probably could define a macro for the seed, bump part.

ideally i'd be able to express the semantic once (the distributor_account has a couple of unique pdas)  and have anchor build the seeds and all validations for me every time i used any of the PDAs in any instruction
ser <:KEK:850127013611569223>

Trying to CPI right now and, when using the executable macro with the account that is the program being called, I get the "0x93" error (program not executable). However, when I remove it I get "instruction expected executable account."
On top of this, when I inspect the account itself with "solana account" it tells me the account is in fact executable. Has anyone seen a macro throw errors like this before when it seems like it shouldn't?
whats pollards <:thinker:790343147305697351>
This would have to be overcome with pollards stored onchain
the saber solution has a limit - and its not u64.  It fails at the point that a merkle proof exceeds max solana tx size.  not sure what tree depth this would happen at
correct.  this is custom for my use case.  it would not work for much more.

That said, I think the transaction size to claim would get too big at that point anyhow.  proofs would bo too large.
but the bitmask doesn't scale, what if you have 320 millions people claiming, that doesn't fit in an account anymore üòÑ
I haven't looked in details yet, so people have to pay a PDA to mark they have claimed?
multiple higher than 20
their cost was higher
personally, the merkle tree just seems easier tho.  I don't like saber's impl using PDAs to prevent dupe claim - hence my other question about bitmask.
> ATA vs paying for the tiny pda
yes, it'd cost just under half as much.  But there's another benefit here too - you could have the contract send the rent for the PDA back to the original creator.  Thus costing them nothing.
oh i see, user whitelist without admin ticking them, yes, botfest guaranted
the only difference is paying the ATA vs paying for the tiny pda, if comparing an airdrop to this PDA airdrop box (founded by admin)
On that note, currently implementing a merkle tree solution for something similar....  Came here **wondering if there have been any features added in the last few weeks that I missed regarding variable length fields**.  Specifically, I'm using a bitmask field for indicating nodes in a tree which have redeemed.  I'm throwing it in the `account` struct as a `[u8; 0]` and setting the `space` on the account manually.  However, loading of the account as `zero_copy` fails since its a size mismatch.  And tricks to make this work smooth, or do I hget to go all low level?
Armani was mentioning a solution where a user can add themselves to a whitelist which creates a PDA for them, like a redemption ticket.  Then you could fund a vault and allow everyone with PDAs to claim.  It's a different model - one where you're asking users to go whitelist themselves.  That just seems like it'd be riddled with bots tho.
but requires the distributor to execute tons of transactions.  And why call it a PDA solution - aren't we just talking about creating ATA token accounts for everyone?
but the PDA is still affordable for quite some accounts
one scales the other does not
yes that is what i am saying
What if half of the addresses aren't real, or will never be used?  You've essentially burned that token and spent a lot doing it.  And how about for 250k accounts?
the admin can create the auth/airdrop account for each user, i am comparing to that
These are 2 very different situations.
or maybe saber couldn't afford those 20 SOL
but still feasible
the PDA option you would need to send hundreds
i guess less convoluted since it is 1 transaction to setup
But if the admin has a whitelist based on some outside source, and has computed who gets how many of what, a merkle tree is going to be the optimal solution.
It depends on what is creating this whitelist.  If a user is supposed to add themselves to a whitelist, then sure, PDA works great.
lol
so was the saber thing just a PR stunt?
but this auth would be much smaller
if all accounts are as big as a token account, for 10k that is 20 SOL (10_000 * 0.002)
mmmh
the PDA approach is great if you can swallow the overhead.
user creates, something whitelists...
but then someone else need to tick the whitelist
Makes the implementation a lot easier imo.
Users could just create their own auth account and then close it.
like to create a full 10k mint whitelist for a NFT collection, something like that
depending of the use case, i think a merkle tree, the implementation from saber-hq could be good to avoid insane rent cost if many users in the whitelist
Hi. Looking for a reviewer/auditor for a simple Solana contract (not written with Anchor). Thanks!
I'm imagining you'd have it in one of your account structs which you'd read from on the client side, not that you'd pass it into instructions. E.g. if you had the saber curve in an account struct
If you give `number` where `anchor.BN(...)` is expected you will get this error
yes that's exactly what it was


///////////////////////////////////////////////////////////////////////////////////////////////

That‚Äôs exactly what I was trying to figure out thank you <:bagsLove:500156064507887618>
OMG looks like doing this solved the thing
Thanks a lot !! üôÇ
Or I have to create a box account and put all the accounts inside it ?
Any example where I can find the use of  Box<Account ? Only saw it in the ido-pool initialization function
So I have to change every account declaration that was Account<'info, TokenAccount>, into Box<Account<'info, TokenAccount>> ?
Thanks a lot üôÇ
You are  using too much stack space. You can try `Box<Account` to heap allocate.
#[derive(Accounts)]
pub struct ExchangeFtrVoteToPool<'info> {
    #[account( has_one = pool_usdc)]
    pub pool_account: Account<'info, PoolAccount>,
    #[account(signer)]
    pub user_authority: AccountInfo<'info>,
    #[account(
        seeds = [pool_account.ftr_mint.as_ref()],
        bump = pool_account.nonce,
    )]
    pool_signer: AccountInfo<'info>,
    #[account(
        mut,
        seeds = [user_authority.key().as_ref()],
        bump = user.bump,
        has_one = user_authority,
        
    )]
    pub user: Account<'info, User>,
  
    #[account(mut, constraint = pool_usdc.owner == *pool_signer.key)]
    pub pool_usdc: Account<'info, TokenAccount>,

    #[account(mut, constraint = user_usdc.owner == *user_authority.key)]
    pub user_usdc: Account<'info, TokenAccount>,

    #[account(mut, constraint = user_ftr.owner == *user_authority.key)]
    pub user_ftr: Account<'info, TokenAccount>,

    #[account(mut, constraint = user_fixed_rate.owner == *user_authority.key)]
    pub user_fixed_rate: Account<'info, TokenAccount>,

    #[account(constraint = token_program.key == &token::ID)]
    pub token_program: AccountInfo<'info>,
    pub clock: Sysvar<'info, Clock>,
}
This is my function's accounts
I dont get where the error comes from, it looks like I didnt run the proper verifications before using an account
Access violation in stack frame 3 at address 0x200003de8 of size 8 by instruction #15946
I have this error
Hey guys
You can create the instructions and insert them into the tx.
```typescript
const tx = new Transaction();
tx.add(
 program.instruction.increment(...)
);
await provider.send(tx)
```
Is it possible to chain anchor tx's together into one call?
Aka I have an increment counter function like the tutorials:
```
await program.rpc.increment({
      accounts: {
        counter: counter.publicKey,
        authority: provider.wallet.publicKey,
      },
    })
```
but instead of incrementing once I want to call this function like 5x in one transaction.

I know this seems kinda silly in this example I could just write an increment by 5 function or something but in a more advanced case where I actually just want to chain together the same method 5x in one tx for some reason is it possible?
Also I looked into the typescript support. I have a quick question on there and I could finish it off: https://github.com/project-serum/anchor/pull/795#discussion_r720697063
Heyo, I just wanted to say my pr is ready for review again when anyone gets the chance. I made the rookie mistake of putting on master... :p
https://github.com/project-serum/anchor/pull/782
I'd use a feature flag for this.
there is code everywhere
define code level
e.g. localnet, testnet, devnet, mainnet
is it possible to get this value: `[programs.localnet]` (`Anchor.toml` file) from code level? I need information about the network <@!501570363566587905>
thank you
the first entry is 300 in decimals
0
thank your sir. do the error code enums start at 0 or 1?
yes
hey how can i convert cpe 0x139 to decimal? it is 313 in decimal, so is error enum 13?
My only fix was restarting the project with anchor init
did you ever figure out a fix? only thing i can think of doing is manual decoding of the account types
i've also had some rust files being missed when generating the idl with anchor build
siiick. thanks!
<@!501570363566587905>  That is great! Thank you
You can run `solana-test-validator` separately, passing in the `--clone` argument to copy down programs for mainnet, e.g., the token metadata program. Then you can run tests against it via `anchor test --skip-local-validator`.
The token metadata program probably isn't deployed by default.
You need to make sure all the programs are deployed.
can you cpi into any program while running a localnet via anchor test? trying to call the token metadata program and i'm getting the error "account is not executable." Do i have to like manually deploy the program on localnet or should i be able to use the address from devnet for cpi
I have accumulated it since may so I've got a lot to go around
DM me your address if you need devnet sol
it really sucks, we ran into this as well recently
<https://discord.com/channels/428295358100013066/749059399875690557/890126358011838484>
then they might reset the limits back to 10
you could try to bully the people draining devnet faucet into not doing that
yeah, I should have sufficient funds to deploy it (according to localnet usage). is there a better / faster way to airdrop more sol to my wallet than typing `solana airdrop 1` repeatedly and waiting for rate limits?
have you tried seeing how much sol the localnet deployment uses up
might still need more
https://github.com/project-serum/anchor/blob/master/ts/src/error.ts
Gotcha.... weird. You can look up error codes here'
gotcha. I've tried loading up with 10 SOL and it still fails. I need devnet since I'm testing an integration with another protocol deployed there (and its localnet setup is pretty manual / complex)
devnet kind of sucks now because of the faucet limits... like 1 sol isn't enough for me to do what I want on devnet. Unless you need devnet for something like an oracle, I like localnet
https://support.solanium.io/support/solutions/articles/69000377685-error-processing-instruction-1-custom-program-error-0x1#:~:text=If%20you%20receive%20the%20error,to%20pay%20for%20transaction%20fees.
I think that's what 0x1 means if I remember right
It looks like you don't have the funds to deploy
consistently getting the following error when trying to deploy to devnet (regardless of the program): 

```Error: Deploying program failed: Error processing Instruction 1: custom program error: 0x1
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }```

anyone know how to fix this


///////////////////////////////////////////////////////////////////////////////////////////////

its getting too damn expensive now to launch programs
same <:PES_Cry:493359762432327691>
I agree... I used to want Solana to go up in price, but I like it cheaper now haha
so hopefully there will be an adjustment back down
Hahaha, sorry
duuuuuh
cost per epoch has stayed the same though
Oh, true
and solana price went up
well rent is a function of solana price right
Sorry, was what you said a joke to the meme? It implied rent used to be cheaper
i don't understand the question
Why is it so high now?
back down to 10c
hopefully anatoly will drop rent by 100x soon
Can I fetch all the NFTs a pubkey owns in JS...

Hahaha, I actually have watched that... my wife and I watched it while we were dating... must just not remember it
Very popular Arrested Development quote üòÜ
I am... what is that from?
You might be too young for that reference now that I think about it lol
Immediately popped into my head, "I mean it's 10kb Michael, what could it cost? Ten dollars?"
Yes... helpful when building apps and reserving space... I am always afraid to rent space becasue I am very cost concious, but this is very helpful!
Ok, cool, that's a great number to have in mind, at current prices $1 buys you about 1kb rent-exempted (a bit less)
Yea
Or $12 sorry
That's ~$6 right? I can't do arithmetic
my users can pay that
which lowkey isnt bad
0.07 for 10k bytes
It is 0.007 for 1000 bytes
That is the number in sol
0.000006962
Yes
For rent exemption/2 years? Yeah.
It looks like it is 6962 lamports per byte
That price per sol is unfortunately (or fortunately I guess) way, way off, so I think the current rental price is ~150x worse than originally intended?
I would like to get better at this estimation too: I think the rental rate is currently set here https://github.com/solana-labs/solana/blob/master/sdk/program/src/rent.rs#L23
Does anyone have an idea of how much it costs to resevere 100 bytes of space... I want to reserve a lot more space for a PDA for my users, but I don't want them to pay too much to initiate the PDA
Sounds good
whelp if you find a clean way to do it, ping me. i'd be curious
I want to close all 10k voted PDAs... if that can be done, that would be awesome, if not, each vote will just have a unique seed
oh i see
Not really... we have 10k users (it is for an NFT project)... that's what I wanted to do is close all voted PDAs after the old vote closes so we can do a new vote at the same place and ppl get their rent fees back
instead of deploying to a new program id to start over
my query was about clearing all pda's owned by a program as part of a cleanup/clean slate op
oh, yeah thats a basic/simple implementation to just close a single pda
I realized that... I am trying to implement a voting protocol where each vote creates a PDA at the user's pubkey... I wanted to delete the user's PDA when a new vote is instantiated, but what I think I'm going to do is just have each vote have a uniqe seed so I can reset the votes without deleting PDAs
i ultimately ran into some `fallback function unsupported` type errors when trying to do it for mine
<@!847130012879814668> only issue with this is that you need to create an instruction per account type and call it for each pda
Ok... that is really helpful... thanks
https://discord.com/channels/889577356681945098/889577399308656662/900089740546687028
Any idea for keywords?

Thanks
There was a thread about this a few days ago, might be able to find it by searching
Does anyone here know if a contract can delete all it's child PDAs programatically?????
Yes <@!134416332509675520> <@!103986638320861184> I am trying to use it on the browser. Thanks for the help and resources. Will look into it and get back if I have any questions. Thanks again üôÇ
<@!826339689195241512> ^ this comment above regarding the Signer + phantom is correct, you can't really use that SDK which expects a signer if you are building something on a browser.

On the other hand, good news, I recommend you to check out this repo with lots of token-related goodies by the saber team:

https://github.com/saber-hq/saber-common/blob/master/packages/token-utils/src/instructions/ata.ts#L43-L68 - `@saberhq/token-utils`

Or implement a similar method to "getOrCreateATA"

```
export async function getOrCreateATA(
  provider: Provider,
  mint: PublicKey,
  owner: PublicKey
): Promise<[web3.PublicKey, web3.TransactionInstruction[] | null]> {
  const associatedTokenAccount = await Token.getAssociatedTokenAddress(
    ASSOCIATED_TOKEN_PROGRAM_ID,
    TOKEN_PROGRAM_ID,
    mint,
    owner,
  );

  const associatedTokenAccountInfo = await provider.connection.getAccountInfo(associatedTokenAccount);

  const instructions = associatedTokenAccountInfo === null ?
    [Token.createAssociatedTokenAccountInstruction(
      ASSOCIATED_TOKEN_PROGRAM_ID,
      TOKEN_PROGRAM_ID,
      mint,
      associatedTokenAccount,
      owner,
      owner,
    )] : null;

  return [associatedTokenAccount, instructions]
}
```
But to answer your question, the `payer` is supposed to be whoever is paying for the tx that will mint the NFT (not going to work with your phantom wallet, for the reason above).
If you're in the browser for example, phantom won't give you a `Signer` (your secret key is secret obviously). You can still call the static method `Token.getAssociatedTokenAddress` and build the instructions to mint the NFT yourself I guess?
Ah, sorry, I was thinking in Rust. I'm actually not sure how you're supposed to use that Token class ü§î Are you doing this from the browser or node?
i have that file open right now lol
So let's say I have the mint account publicKey of a degen ape NFT. Now I want to call this function here: https://github.com/solana-labs/solana-program-library/blob/master/token/js/client/token.js#L536 on the "Token" class instance of that degen ape NFT whose mint address I have. My question is more like: When I instantiate the Token class object for that degen ape, what value do I pass  for the "payer" field in the Token constructor as mentioned here: https://github.com/solana-labs/solana-program-library/blob/master/token/js/client/token.js#L320 ?? Sorry if this sounds confusing
You could maybe start looking here https://github.com/project-serum/anchor/blob/master/ts/src/program/namespace/instruction.ts#L58 Bit tricky to read since it's generic over the IDL
really i think i'm looking to see how anchor makes this translation under the hood
yes exactly
Are you using the `TransactionInstruction` class from web3.js? That has a `data` field in it
not a big javascript guy, wish me luck lol
right now when I make instructions I pretty much only get to pass in an array of "keys" which are just the pubkey, isWritable, and isSigner. Does this translate to anchor accounts? I'm looking through the source now
So you have authority over that mint? And which Token constructor are you referring to? Do you mean cross-program invoking the spl-token program to mint an instance of that NFT?
Not sure if this is the right place to ask this, If I have a PublicKey instance of an existing NFT mint account and want to create a Token instance for that key, what do I pass in the signer field of the Token constructor?
You could always source-dive and see how anchor's JS/TS stuff does this if you get stuck.
Cool! Passing accounts I think would work pretty much as expected (I guess you'd have to figure out the correct order to pass them in). You would also need to figure out how to serialize your instruction data, which is a little trickier than just serializing the arguments‚Äîanchor uses an 8 byte "sighash" to indicate which ix handler function to invoke.
hey all, looking into interacting with an anchor program but without the idl so I have to build the transaction myself. whats the idea behind transfering anchor interface to normal solana transaction?
Hi üëã I'm attempting to use the serum multisig UI but getting the error `Error processing Instruction 1: custom program error: 0x63` when creating a multisig. Anyone know how I could learn more about 0x63?
how do u skip preflight check when using the anchor client to make a rpc request?
<@!448034961652449283> <@!831450660146642974> , I am new to Solana . I need some input . I want to create a program where I can swap/exchange the native sol coin for a fixed number of SPL tokens. I am not sure if this is possible by using the solana-program-library/token-swap program. I would like to do it via anchor by deploying a rust contract. Any pointers to previous implementations.

Help will be much appreciated
It looks great, in order to make work properly, I submitted a PR
https://github.com/project-serum/anchor/pull/902
<@134416332509675520> will your proposed change to declare id make it possible to go back to randomly generating the program id every time anchor test is run
It makes accidentally correct stuff like this possible to get through
This is one thing that I don't like about the fixed program id
You're right, good catch
Lol
I'll try it later
I am also a little skeptical, you are amazing ü§©
When I change that to use `bump = ido_account.bumps.pool_watermelon` I can pass the tests against my local validator
<@!399165388753076225> <@!248066053161222144> this line looks kinda suspicious right? https://github.com/project-serum/anchor/blob/master/tests/ido-pool/programs/ido-pool/src/lib.rs#L478
i remove all test-ledger/ & run & deploy again. I can be sure it is clean
... how do you run tests agains the local validator? Do you have to clear its state every time you run the tests?
In fact, I have tried many methods, including deploying to devnet, but errors will also occur
It's funny, I never run tests against a local validator üòÜ Not sure why it would be different.
Mm, ok, yeah, I can get a seeds error too if I run again an actual `solana-test-validator`.
What happens if you run the tests without the `solana-test-validator` running in the background? So letting `anchor test` spin up its own validator.
Yes local validate and anchor test command v0.17.0
How are you running the tests? With a local validator running in the background, or just with `anchor test`, etc.?
When the user wants to burn Redeemable and get SaleToken. This error will occur.

I double-checked the parameters of PDAs and there is no problem

Another issue seems to mention related content.
I am not sure if it is relevant.

https://github.com/project-serum/anchor/issues/882
Weird... hmm.
I did not modify any code
Excuse me, has anyone encountered this problem? I need some help <:cry:886194124724797461> 
https://github.com/project-serum/anchor/issues/897
Oh, huh. Yeah, I can take a look at that tomorrow
We should probably remove load_init and just write the discriminator before entering the instruction handler on init. What do you think <@!134416332509675520>
This helps a lot, thank you!
`load_init` is what you would use, once, to do that initialization plus then give you access to the freshly initialized whatever you're initializing.
`load` assumes that the account's data already has been initialized by anchor (so it has 8 account discriminator bytes at the front)
What is the difference between `load_init` and `load` in the `Loader` struct here:

https://docs.rs/anchor-lang/0.4.5/anchor_lang/struct.Loader.html
or the new version isn't deployed
right, maybe it hits the wrong program address
Mm, interesting, yeah I was going to ask if there could be a version mismatch
yeah, I'm using `@project-serum/swap@0.1.0-alpha.1`
But yeah, that's an odd error to hit because presumably you're using some library code to send the tx
ahhh got it
That means that you (somehow, not sure how yet) managed to send an unknown instruction to the swap program‚Äîanchor programs can have a catch-all fallback handler, and the swap doesn't ahve one
much of this is ungoogleable
what's `InstructionFallbackNotFound`? ü§î
ahh got it
Sorry, in the anchor repo
I don't actually know which instruction ends up failing
this is errors.ts in `web3.js`?
```
const btcSwapTx = await client.swap({
    fromMint: USDC,
    toMint: WBTC,
    amount: new BN('1'),
    minExpectedSwapAmount: new BN('0'),
  });
```
well I'm calling it this way
That's actually kind of an odd error to encounter though‚Äîwhat swap instruction are you invoking?
For anchor custom errors, you'd go 0x65 = 101 --> look in error.ts (lol), find InstructionFallbackNotFound
is there a good way to debug these things?
```
Transaction simulation failed: Error processing Instruction 1: custom program error: 0x65
    Program 11111111111111111111111111111111 invoke [1]
    Program 11111111111111111111111111111111 success
    Program 22Y43yTVxuUkoRKdm9thyRhQ3SdgQS7c7kB6UNCiaczD invoke [1]
    Program log: Custom program error: 0x65
    Program 22Y43yTVxuUkoRKdm9thyRhQ3SdgQS7c7kB6UNCiaczD consumed 5536 of 200000 compute units
    Program 22Y43yTVxuUkoRKdm9thyRhQ3SdgQS7c7kB6UNCiaczD failed: custom program error: 0x65
```
I'm using `@project-serum/swap` and it crashes on mainnet like this:
Ah ok. Removed find_program_address though didn't seem to fix this error. Could it be that the program's anchor using an older version 1.7.10 version of solana ?
No need to use find_program_address. if yhou just use `bump,` it will do that automatically.
I'm generating the bump seed inside the program itself, like this. Could that still be a possible issue in this case?
```
#[account(
        init,
        seeds = [OPEN_ORDERS_SEED.as_ref(), market.key.as_ref()],
        bump = Pubkey::find_program_address(&[OPEN_ORDERS_SEED.as_ref(), market.key.as_ref()], program_id).1,
        payer = authority,
        owner = dex::ID,
        space = size_of::<OpenOrders>() + SERUM_PADDING,
    )]
    pub open_orders: AccountInfo<'info>,
```
that would explain why it sometiems works and sometimes doesnt
probably have a bad bump seed
Yup a bunch of PDAs
are you initializing PDAs?
<@!501570363566587905> Sorry to ping but I'm pretty stumped on this one and think it might be some specific anchor thing. Basically I'm running an ix that inits a bunch of accounts, but it seems to work sometimes and not others seemingly randomly. For example you can see the failed txs to create this account, then eventually it worked (same accounts and data in the tx, besides a temp wrapped sol acc) - https://explorer.solana.com/address/AkkBe1rKt43CRxxZB76YV6VHE8tiNy78gLwZ1K7Qxn3A

I'm trying to run the ix again, and same thing is happening with failures. Giving back the 0xa7 error. Can't figure out how that error would be related to multiple failures but then eventually a success w/o program changes
classic
lol
someone decided to close the referrer wallet our UI uses
thanks, i can now find why
ok
Just the `instruction::` module, which is used by rust clients.
A bit confusing since the breaking change wasn't with the smart contract API.
Semver w.r.t. the crate.
ok
Irrespective of deployment.
No the logic is that v0.4.0 is a semver v0.4.0.
but it is in fact the v0.4.0 tag, is that the logic?
so it is called v3 because 3rd deployment
https://github.com/project-serum/serum-dex/blob/v0.4.0/dex/src/state.rs#L2065
ok now there is some code
At least when looking at the crate on crates.io.
The marketing version is 3
The real version is 4
wu
eh
oh
That is on mainnet
to dex v3
i am on mainnet
https://github.com/project-serum/serum-dex/blob/v0.3.1/dex/src/state.rs#L2065
There's v0.4.0 release
even for 0.3.1 it makes no sense
there is 0.3.1
https://github.com/project-serum/serum-dex/blob/v0.3.0/dex/src/state.rs#L2065
Are you looking at the right git tag?
i took the file in the commit for program v3
I am confused by the serum DEX error, i am getting 0x1000811
https://github.com/project-serum/serum-dex/blob/868c6f1694dd1b414bf4f7de8352fcaccb520619/dex/src/state.rs#L2065
but there is nothing much at line 2065
Sure!
Mm, not sure, going to have to let someone else chime in, I haven't touched the ci stuff
btw, thanks for the help!
okay, that's helpful. is there a ci config you suggest to look at for reference when setting up ci?
Yeah, fwiw the .travis.yml file has an explicit line to install mocha
depends on what they expect to do with it, for CI you'd want it
Well, actually not sure I'd expect the docker file to include mocha
Ah, hmm, good q... I haven't used the docker image, but yeah, that does sound wrong ü§î
why does the docker image have this problem? are you supposed to run `npm install -g mocha` before using the docker image too?
Try installing it with `npm install -g mocha`
Ok, there's your problem üôÇ
nothing
What does `which mocha` say?
This means that (for whatever reason) mocha is no longer in your path, at least not at this point when anchor test runs
I was successfully using Anchor v0.11.0 under Ubuntu 18.04.2 LTS. I recently updated to v0.17.0 and now I always get the error:
`Failed to run test: mocha -t 1000000 tests/: No such file or directory (os error 2)`. I have also tried using the docker image `projectserum/build:v0.17.0` and running anchor test inside of that. It fails in the same spot with the same error.

Here's sample error message from trying to run the `basic-0` test:
```
basic-0: anchor test
BPF SDK: /home/user/.local/share/solana/install/releases/1.7.11/solana-release/bin/sdk/bpf
Running: rustup toolchain list -v
Running: cargo +bpf build --target bpfel-unknown-unknown --release
   Compiling proc-macro2 v1.0.30
   [...]
   Compiling basic-0 v0.1.0 (/home/user/anchor/examples/tutorial/basic-0/programs/basic-0)
    Finished release [optimized] target(s) in 1m 59s
Running: /home/user/.local/share/solana/install/releases/1.7.11/solana-release/bin/sdk/bpf/scripts/strip.sh /home/user/anchor/examples/tutorial/basic-0/target/bpfel-unknown-unknown/release/basic_0.so /home/user/anchor/examples/tutorial/basic-0/target/deploy/basic_0.so
Running: /home/user/.local/share/solana/install/releases/1.7.11/solana-release/bin/sdk/bpf/dependencies/bpf-tools/llvm/bin/llvm-readelf --dyn-symbols /home/user/anchor/examples/tutorial/basic-0/target/deploy/basic_0.so

To deploy this program:
  $ solana program deploy /home/user/anchor/examples/tutorial/basic-0/target/deploy/basic_0.so
The program address will default to this keypair (override with --program-id):
  /home/user/anchor/examples/tutorial/basic-0/target/deploy/basic_0-keypair.json
Failed to run test: mocha -t 1000000 tests/: No such file or directory (os error 2)
```
Right, but that would mean user will have to sign the transaction & pass in bad program ID. (hacked frontend). My concern mainly on whether I need to add:
```
#[account("token_program.key == &"XXXXXXXXX")]
```
on top of 
```
pub program: Program<'info, Program>,
```

Seems it's not needed
Actually, sorry, I should add with the example above that whether the sneaky program could drain an account's money depends on which program owns the account‚ÄîI was thinking specifically of a wallet. If the wallet has signed the tx and you accidentally pass it along via CPI to a rogue program, then that program could piggyback on that signature to do another CPI to `solana_program::system_instruction::transfer` (bad).
Yeh `Program<'info, Praogram>` is the current implementation I have. Phew, almost rugged üòÖ 

Yep, was wondering how this is safe for Token. Thanks Alan! <:pepepray:834817528412897300>
If you look at the implementation of `Token`, as in `Program<'info, Token>`, you can see that it implements the `anchor_lang::Id` trait by returning the result of `pub use spl_token::ID`
One way is as above, where you just bake the intended address right into the program (e.g. taht's what `declare_id!` does for your own program)
Ah, sorry, yeah, you just have to have some way to verify that the account that got passed in really does have the address you expect it to
Let's say I have 

`pub program: Program<'info, Praogram>` defined, does the constraint apply because this Program is imported from crates, and the ID is already known? 

In that case I won't have to store the program ID into the state
But for example, if someone passes in a sneaky program and you happen to CPI to it with some account having signed... game over, they can e.g. drain that account's lamports!
Yep, this is why `Progam<'info, SomeProgram>` asserts that the account's address really is `SomeProgram::id()`
In general do we need to store the CPI target's program ID in the state and do verification?

I can imagine someone creating a mock program and pass it in <:thinkingpepe:746135853386039376>
yeah, that's what i am doing right now.
usdc has 6 decimals
<@!769548185948913684>
and call it usdc
just make a random token
if so, how to faucet?
do we have usdc address for devnet?
https://github.com/project-serum/anchor/issues/898
anyone know where to start w/ this error? It prints 'custom program error: 0xa7' in the logs so I figured it had to do w/ not using declare_id correctly, but that appears to not be the case

The right thin gto do is to probably have an extra param in the callback for the error.
Can this be optional logging?
Seems to be from https://github.com/project-serum/anchor/blob/master/ts/src/program/event.ts#L98
setting `finalized` as commitment history worked.
yeah, it worked fine with `.fetch` when testing on localnet. any way to work around this issue on mainnet?
The `.fetch` api should be sufficient. Could be a problem with devnet.
how to fetch an account immediately after creating it with anchor? I am running test scripts for devnet but seems like setting "recent" for commitment history doesn't work
Has anyone else seen this?
It seems that adding an `eventListener` prints ALL failed transaction logs to stdout, whether an event triggered or not
i can send u the sol if u get rate limited<@!860076534651158529>
is this new ? <a:Hmmmm:695129200260153375>
thank you!
`space` is in bytes. every PDA requires at least 8 for the discriminator, and the rest is for the stored data properties. with `16+16` you're only reserving 24 bytes for the internal data which is looking to be over 35 as a rough estimate with the strings you're storing
so if I change space to be 64 + 64 it works
I probably screwed something up with the space allocation - this is a new concept for me
16 + 16
```Rust
#[derive(Accounts)]
pub struct Create<'info> {
    #[account(init, payer = user, space = 16 + 16)]
    pub flora_account: Account<'info, FloraAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```
Yup.
something as simple as this?
```rs
pub struct Deinitialize<'info> {
  #[account(mut)]
  pub destination: UncheckedAccount<'info>,

  #[account(mut, close = destination)]
  pub pda: UncheckedAccount<'info>
}
```
You need an instruction that closes the account.
instead of just fresh deploying to new program id
any good suggestions for how to clear all PDAs for a program on test/devnet to start from a clean slate?
In the corresponding `#[derive(Accounts)]` struct, `Create`
How much `space =` did you allocate for this account?


///////////////////////////////////////////////////////////////////////////////////////////////

I see you have the  public key there. Not the data.
The coder will decode the account info data from `connection.getAccountInfo`
Is the account data in there? How is it serialized?
but i guess the schema of the getTransaction output is just a bit non-standard and not related to normal anchor operations
i'm trying to find an idiomatic way to express the bottom for loop

figure out that accounts coder was a red herring
The output should simply be the typed account. Are you seeing something different ?
I also found AccountsCoder.decode but still trying to wrap my head around what that output is
following up on this: i'd like to read out account mappings as well from the IDL. so i'd like to resolve instruction account index of an account given it's "label". currently trying to parse the output of web3.Connection.getTransaction and re-assemble semantics üôÇ
Haven‚Äôt tried myself but perhaps you could try to initialize independent accounts in parallel? (Some might have some sequential dependencies and won‚Äôt be parallelizable, but I guess a lot of them could be)
Ah fair, thanks for that.
it might be even easier to produce a snapshot of a test setup that way
technically you can maybe keep the ledger + account db then replay tests on that
but
not yet https://github.com/solana-labs/solana/issues/20279
there is a setting to clone it from another cluster though
would be good if we could shave that all off
Is it possible to embed account state into test genesis? Our integration tests all take like 1-2 mins to initialize since we have like lots of accounts to initialize.
got it. that's very helpful. thank you!
Thank You
no more @s though ok
<https://github.com/project-serum/anchor/tree/master/tests/ido-pool>
we don't talk about design stuff here, it's mostly for issues related to developing with anchor
lol, be careful with that
<@!248066053161222144> <@811471935925780521> <@!831450660146642974> Any inputs much appreciated
I want to do a IDO , ICO on solana blockchain. Can anyone help me with the rust smart contract by giving pointers or references. Thank You
Since accounts don't actually disappear and get garbage collected until the end of the block, so there's this dangerous time between the end of your close instruction and the end of the block itself
But another set of vulnerabilities are connected with initializing and closing accounts. These are definitely harder to understand. For example when retrieving rent from an account to close it, someone else might submit a transaction or instruction that gets run in the same block after yours, which refunds the account and keeps it open
Most of the major vulnerabilities in solana come from account substitution, where you submit a malicious set of accounts to trick the program into thinking it's in the wrong state of the world and do something it wasn't supposed to
Correct, best practice is to init separately to taking action on some account (if it may or may not exist)

`concerns surrounding optional initing that makes it a dangerous practice`

I'm not actually sure either tbh. Perhaps because it is less explicit and there is more room for unforeseen bugs to slip in
Is there a way to avoid calling `.to_account_info()` for `UncheckedAccount` types? Looks like double work in 0.17, migrating to `UncheckedAccount` then converting it back into AccountInfo
understood. in that case, sounds like the smart-contract way to do it would be to have 1 instruction to initialize all the states and get things ready & have the 2nd instruction solely focusing on the operation on those states. Just curious, what are some of the concerns surrounding optional initing that makes it a dangerous practice?
or at least would lead to less optimal practices (going on the presumption that optional initing is something worth avoiding in smart contracts)
<@!501570363566587905> i do think this new `init_if_needed` thing is going to be super confusing for people to understand
and in the current state of the world one of them will fail (incorrectly technically speaking because the init was successful just not by that transaction)
the purpose is supposed to be to handle the case where two transactions in the same block try to init the same account
that's not the purpose of `init_if_needed` though
Meanwhile, you can use the `instructions` option in your RPC call to optionally init an account
There is a new feature coming up in anchor to do something like this, using `init_if_needed` 

https://github.com/project-serum/anchor/pull/906/files
Is there a way to do different macros under different conditions at run time?
For example, if the account passed in already has been initialized, enforce the [mut] conditions. If not, set it up with [init]
Hello All, I need your help, while trying to call the program from UI using TS binding, I am getting this following error. 
```{ InstructionError: [ 5, { BorshIoError: 'Unknown' } ] }```
And the data I am trying upload is 
```
const creators = metadataJSON.properties.creators.map(
    creator =>
      new Creator({
        address: creator.address,
        share: creator.share,
      }),
  );
```
This is of course metaplex json, I was trying to do pre-sale functionality which is missing in metaplex right now. Any idea why we would get this error ?
Ah I didn't know it this existed. Handy
ok thank you, it is readonly so no need
Which can be done by calling `.exit()`
Though you also need to serialize if you want to persist.
Yes.
```let token_ledger: Account<'info, TokenLedger> = Account::try_from(&token_ledger_account).unwrap();```
ok doing what the proc macro does
Can i account deserialize manually for something that is in remaining accounts?
Mm, if your editor is happy with your program file, then you could try upgrading the anchor cli (current version is 0.17.0).
anchor-cli 0.16.1
Are you missing a `bump` constraint? It's also possible your `anchor` cli is out of date; what does `anchor --version` say?
anyone seen this message when anchor building? thread 'main' panicked at 'Code not parseable: Error("bump must be provided with seeds")', lang/syn/src/idl/file.rs:338:58
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
Thanks alan üôÇ
Scale being negative was actually the ultimate issue. In Big.js scale can be set to a negative number on load when the number in question has trailing 0s. Ive written up a fix
Sorry, I mean the exponent itself can be negative, not the sign (like 10^3 vs 10^(-3)).
Possibly actually, let me assert
Sign is held in the mantissa, not scale
Idiosyncrasies with Big.js vs rust_decimal
Maybe my question is why you're restricting the scale to be a u32‚Äîhow come it can't be negative? Floating points can have negative exponents etc.
But yeah, I guess `scale` could end up being -1? `scale = big.c.length - big.e - 1`
Hmm, yeah, lacking any particular insight here, I would just set some breakpoints lol üòõ
Ah, you're right. Hmm.
Im using `rust_decimal` crate for decimals, which uses a u32 scale. The anchor typescript module makes types that are 32 bits or less numbers, not BN
How come the `scale` thing isn't an `anchor.BN` too?
With fields `mantissa: anchor.BN`, `scale: number`
It returns a `SwitchboardDecimal` class, which I then convert to an object
It just converts a class to a raw object
What does SwitchboardDecimal.fromBig end up returning?
How the scale field is set from the `Big` type https://pastebin.com/LMced9GB
What are the `Object.assign`s for? I'm possibly being JS-dumb.
https://pastebin.com/rDN8z7fb
Its a bit large, I will make a paste
Can you post how you're invoking the rpc call that takes those params?
Ill try upping `scale` size to u64
```    #[derive(Default, Eq, PartialEq, Copy, Clone, AnchorSerialize, AnchorDeserialize)]
    pub struct BorshDecimal {
        pub mantissa: i128,
        pub scale: u32,
    }
```
Where BorshDecimal is:
```pub struct SaveResultParams {
    pub error: bool,
    pub value: BorshDecimal,
    pub jobs_checksum: [u8; 32],
    pub min_response: BorshDecimal,
    pub max_response: BorshDecimal,
    pub feed_permission_bump: u8,
    pub oracle_permission_bump: u8,
    pub lease_bump: u8,
    pub state_bump: u8,
}
```
I do
I would personally probably debug this by trying to set some breakpoints/look at the full stack trace (can you post a stacktrace?)
Interesting. Do you have any conspicuous u32s in the tx?
I do have a field called `value` but its an object type, not a number
Currently Im periodically having transactions fail with `RangeError [ERR_OUT_OF_RANGE]: The value of "value" is out of range. It must be >= 0 and <= 4294967295. Received -1`. Is this indicative of a borsh serialization issue with the instruction?
Sweet.
All yours, I'll work on the declare_id one today.
I"ll take it if noone is.
Here's the issue https://github.com/project-serum/anchor/issues/852
All good. If it's blocking I'll yell.
(Also I need to hurry up and finish the declare_id! PR, assuming it still makes sense, and also that error message PR‚Äîmy bad, will try not to volunteer for PRs and then not finish them)
Let me find the isssue.
It's not loader specific.
The `Loader` one? I was going to start on that tonight‚Äîdid you want to take it?
I think the whole security model is around the user explicitly picking a Wallet in the Phantom UI, so I assume that it is not possible to toggle between wallets programatically
Is there a way to switch between Phantom wallets while inside the same app, preferably from within a component and not opening up Phantom each time?
You must use an oracle if you want a random number
No
are you able to generate a random number in a Solana program using the `rand` crate?
<@!134416332509675520> were you working on the `init_if_needed` issue?
oh interesting okay, I'll try that out too
If you just normally reload the page it should autoconnect or prompt for your phantom password
yes, I followed pretty closely along with the React portion of https://dev.to/dabit3/the-complete-guide-to-full-stack-solana-development-with-react-anchor-rust-and-phantom-3291
I think that has to do with your hot code reloader. I guess you are using create-react-app?
it is still there even with my check to insert the multibutton
yeah, I used that and it still wouldn't connect for some reason
There is an autoConnect attribute on the wallet provider
if you have any solutions to autoconnect to Phantom I am all ears!
Same as it was in my successful `anchor test` runs -- I actually did figure this out though. I had to insert a `WalletMultiButton` to ensure that the web page was connected to Phantom before actually trying to run my program. A slight nuisance but will work for early dev
What does your `signers: [...]` array look like, if you've got one?
I'm trying to build a React front end to interface with my Solana app. I've been reading throughs some tutorials and have been having trouble understanding the exact use of the hooks `useWallet` and `useAnchorWallet`. After trying a variety of things, I'm stuck with the error:

Unhandled Rejection (TypeError): Cannot read properties of undefined (reading 'publicKey')

from a Provider.send call (attaching picture below). Does anybody have experience building out these React interfaces to potentially help me through this issue? Or is there a common gotcha that people make when working through similar exercises?
Is it possible to use args from another anchor program in my anchor program? Seems to not output it in the idl which causes the javascript side to explode
are there any recommended patterns for storing an expanding array into accounts on solana? e.g. everyday we want to write a new entry into an array we write into index i on day i and index i+1 on day i+1.  one solution seems to be to set fixed sized arrays within accounts and then index the accounts as PDAs. then, we pass in the account the contains the index i we care about. are there any better solutions?


///////////////////////////////////////////////////////////////////////////////////////////////

has anyone measured the cost of cpi ? <:hmm:877428198625914910>
If that value really does live in an account (as opposed to, say, being a constant embedded in the program), then you can just read the account (anyone can read an account's data if they know its address).
Hi, I have one question.
I am reading the documentation from anchor site and can see "Cross Program Invocations (CPI) example.
It seems change the value from one contract to another contract.
Is there any way to read the value from another program's state account?
Will happy to debug if somebody will got same error too
Yep, returned back to v16 with nvm and everything works correctly
Does the error disappear when you switch node versions?
Did somebody tried to run `anchor test` with `node:17`? Curious is this error only for me or we need to fix something ü§î 
`FetchError: request to http://localhost:8899/ failed, reason: connect ECONNREFUSED ::1:8899`
Has anyone here worked with the connection between Arweave and Solana at a lower level than just the Metaplex api?
nice
I also add the --debug flag for installing the cli, since doesn't really need to be a release build/super fast etc. Builds way way quicker that way.
But I'm always using the local build.
I just use an alias + cargo build the cli locally.
when testing my changes to Anchor, I'm currently doing `cargo install --path cli --locked` which takes a few minutes. Is there a way to make it faster?
If you're deploying to your local validator, you currently (hopefully not forever, working on it) have to change the `declare_id!` call at the top of your program(s) to match the actual deployed addresses. Same change in Anchor.toml.
oh.. that's it! thx üôÇ
If you have access to the other wallet's keypair, you can add it to the `signers: [...]` array in the rpc call.
Oh. Is one of the wallets paying for the tx?
I mean.. I want to sign using two different wallet private keys
Have you tried doing `anchor.setProvider(...)` multiple times?
is it possible to use multiple provider wallets in tests?
Ok
Even tried deploying on devnet and running script on devnet
Already did it
Try restarting localnet and `anchor deploy && anchor test`
i dont know how to proceed if basic examples dont work
I don't know either why that happens üòï
in anchor
this is while trying to run basic-4 example

Stuck on a weird error
But now I feel I'm genuinely rekt
I figured that out
Thanks <@605702048377470997>
Airdrop Sol to your wallet address `solana airdrop 10 GzX7smLjNhBtaWXKNXrWn4CbsjaCkhoGcfFNpJuY8WSs`
<@!886273867293802556> Can you share the github repo for reference . Thank You
How can i build and execute the entire test suite when I clone anchor
I'm trying to run this program on local validator but keep getting this error
When i build the test case using both cargo build-bpf or anchor build the types directory is not getting generated in the target directory. What could I by missing

```import { Escrow } from '../target/types/escrow';```

Thank You
(as a separate instruction in rpc)
in the `instructions: [`
i think you can do it this way yeah, but i haven't done it myself or found a good example
will the wrapping be a part of my program or a separate instruction to the phantom rpc layer
and then take out the SPL token and do my business
does that mean i need to send an instruction first to wrap their SOL
Lets say I need to accept a user's SOL
<@!886273867293802556> this is excellent
haven't gotten that far myself yet though
oh but <@!379899858737168385> it's important to note that everyone encourages wrapped sol almost always, for mine i made it into an NFT/SOL escrow (never any other spl), so i sort of thought it was fine to use regular lamports
```
// put this in your program function
transfer_sol(
    ctx.accounts.into_transfer_sol_context(),
    amount
)?;

// this outside
impl<'info> Exchange<'info> {
    fn into_transfer_sol_context(&self) -> CpiContext<'_, '_, '_, 'info, Transfer<'info>> {
        let cpi_accounts = Transfer {
            from: self.from_account.to_account_info().clone(),
            to: self.to_account.to_account_info().clone(),
            authority: self.from_account.clone(),
        };
        let cpi_program = self.system_program.to_account_info();
        CpiContext::new(cpi_program, cpi_accounts)
    }
}

pub fn transfer_sol<'a, 'b, 'c, 'info>(
    ctx: CpiContext<'a, 'b, 'c, 'info, Transfer<'info>>,
    amount: u64,
) -> ProgramResult {
    let ix = anchor_lang::solana_program::system_instruction::transfer(
        &ctx.accounts.from.key,
        ctx.accounts.to.key,
        amount
    );
    solana_program::program::invoke_signed(
        &ix,
        &[
            ctx.accounts.from.clone(),
            ctx.accounts.to.clone(),
            ctx.accounts.authority.clone(),
            ctx.program.clone(),
        ],
        ctx.signer_seeds,
    )
}
```
you'll need to fudge the variable names here, but this is how i did it when messing with the escrow program exacmple
i got u, one sec
How do I send and receive lamports by doing a CPI . Thank you
holding onto things
because I am
I am getting a BorrowError in the dex, that is an interesting one.
https://github.com/project-serum/serum-dex/blob/06ae280d9cebd93cc5dcbd5dee503cdc38ae1722/dex/src/error.rs#L195-L199
Is that because i am holding something before the CPI? something odd of this kind
The signer seeds that you pass to `CpiContext::new_with_signer` are for invoking another program via CPI. The seeds don't actually get passed along to the other program (not unless you were to pass them as instruction arguments or something); they're just used to add signatures for some program-derived addresses of accounts that you're sending in the CPI.
<@!134416332509675520> anyway thanks for helping me .. I will have to pass it as ix data
Yep .. understand ... but seems a little weird to me that the `CpiContext` can not be put as a parameter of the ix since the `CpiContext` is the one that have the `signer_seeds` prop ...maybe I don't know exactly how it work but that's how I would expect it to do it .. doesn't make any sense to me that the `CpiContext` has the `new_with_signer` or `with_signer` methods if I can not get the seeds from the `CpiContext` inside the program that is being called
If you really wanted to you could of course pass them as instruction data (the arguments after `ctx`); this is a bit unusual to do but definitely possible (usually the seeds are derived from some other data at hand, like some other account's address, a static string, etc.)
Ok, you'll need to just know which seeds to use, they don't get passed in like you're expecting
a derive address that is being sent on the `_ctx.accounts`
Which seeds are you trying to use here? (Which program-derived address do they apply to?)
?
I am trying to get it this way: `_ctx.signer_seeds`
If I put `Context` how do I access to the `signer_seeds` ?
But I need to use `signer_seeds` which I am sending from another program and is not available on `Context`
Use Context<> not CpiContext<>
does anyone knows what am I doing wrong there ?
and I am getting this error:
```
#[program]
   | ^^^^^^^^^^ expected struct `anchor_lang::CpiContext`, found struct `anchor_lang::Context`
```
Hi .. need help ... I am trying to declare a program like this:
```
#[program]
pub mod test {
    use super::*;
    pub fn init(_ctx: CpiContext<Init>) -> ProgramResult {
        Ok(())
    }
}
```
interesting article I found on that https://adeschamps.github.io/enum-size
maybe i won't use it then lol
oh that is bizarre
Other things can be maybe slightly surprising, for example borsh uses 1 extra byte for an Option<Foo> (the extra byte is 0 or 1 to signal None/Some). But std::mem::size_of::<Option<Foo>>() will return 4 extra bytes
One other weirdness is that I'm not actually sure how that size is determined, I think it can depend on weird alignment things?
just tested, works without `Default` but you have to do `std::mem::size_of::<T>() + 8` for the discriminator
I think
So e.g. `std::mem::size_of::<Vec<Whatever>>()` will be 24, regardless of Whatever
ahhh
Which unfortunately isn't the same thing as its serialized size
Not for std::mem::size_of (it calculates the *stack* size of the type)
vec, string, etc.
default would only be necessary if you have dynamic size field types i believe
oh really? good catch
std::mem::size_of::<T>() shoudl work regardless of Default
That was my mistake when I started too haha. Probably should document better
you have to Derive(Default) above #[account] though to be able to use it.
haha, probably not. just wondering if it's possible; or serum and Solana use the same bare metal and I am still limit to 100 RPC per 10 seconds instead of 200
why have i never thought of using `std::mem::size_of` instead of counting bytes...
Is that only for devnet or did I miss something?
Separate question, when I deploy on devnet. I saw that I only paid part of the program space and the other part is paid by some other account. e.g. cost is 16 sol, I paid 8 sol and the other paid 8 sol.
Yes.
via instruction
this would still require a manual migration of every pda that was initialized prior, correct?
I don't think so. I think you have to write migrator yourself. The alternative is to provide some extra space for each account like maybe 500 B when you init. I think syntax is `space=mem::space_of<T>() + 500`
If it's a breaking change, one thing I thought of is to have a global version number for each account. And when an account is deserialized, the version number is checked. If it's old, abort.

Then have a separate migrate instruction for each  version.
If it's additive, you can just add empty bytes at the end.
do you need that many calls?
I figure I can make some connection balancer between solana.com and project-serum rpc right?. That way it's 200 rpc call / 10 second per user?
also unrelated...is there a need for a golang version of anchor?
are there any well established/standard ways of dealing with future account data properties being added post-deploy and being able to migrate existing PDAs without breaking everything?
with careful optimization
depending of what you make, you can survive with the public endpoint
For public rpc, It‚Äôs 100 rpc call / 10 second per user and not per domain right?
Is the public rpc enough for web dapp ? Or do I need to pay triton 1500/month plan?
Was also wondering if there is maybe interest in a PR to anchor with a simple example that checks for ownership of an NFT, as that could be a common use case?
Oh man imagine pressing that thing 1000+ times <:pepedrama:847915911678656562>
ah makes sense, thanks
You need to break it up since you dont want to do the 1000 or so transactions to write the buffer on your ledger.
Use `solana program` command. First write teh buffer than do the deploy/upgrade command with your ledger.
does the anchor deploy script support using a keypair stored on a ledger nano to deploy?/ if so, how wd you specify the path to the ledger?
Unfortunately no. IDL importing/composition isn't implemented yet.
Is there any way to use composition with an accounts struct from another anchor program? I'd like to write one program that wraps another program, adding some optional extra validation to calls from the original program (and signing those calls). But it's seeming like I'm going to need to copy paste all of the original program's account structs, which isn't ideal.


///////////////////////////////////////////////////////////////////////////////////////////////

ok, here was a mistake. It works: `use anchor_lang::__private::ErrorCode;`. Thanks for help cqfd
Can you show your `use` phrase that imports error module
Maybe anchor should just expose the close method‚ÄîI was just trying to say that you're not really blocked or anything
Seems to work fine for me? Also, you don't need to literally copy that close method of course, you could always use some other error there (but I can use it fine, not sure why it's acting private for you)
one problem remains: `ErrorCode::AccountDidNotSerialize`. `error` module is private
Ah, nevermind, it's not actually private, you still have access to `anchor_lang::__private::CLOSED_ACCOUNT_DISCRIMINATOR`
~~Oh, I'm sorry, I missed the private part of the discriminator, hmm.~~
I just mean that if you really wanted to you could just write that same code, but in your function üôÇ
But I see code that is private encapsulated inside close function,. So it's no easy way to transfer this feature to my own function.
Definitely possible (can just do what that code is doing). I'm not totally sure why it's not exposed as an anchor_lang function though.
So is it possible to close account in function handler, not in context?
Rust-wise it's not exposed publicly by `anchor_lang`. Could you use it via a `close = sol_destination` attribute on the account you want to close?
Also, any possibilities of generating IDLs off of these modules that don't have a `program_mod`?
<https://github.com/project-serum/anchor/tree/master/spl/src>
Why I can't import `close` function and use it in my function handler? https://github.com/project-serum/anchor/blob/master/lang/src/common.rs#L6
<@!501570363566587905>
All I'm getting:
```sh
$ anchor idl parse --file stable-swap-anchor/src/lib.rs 
Error: IDL not parsed
```
üò¶
How do we feel about making `parse` spit out more verbose errors instead of just `Option<Idl>`
<https://github.com/project-serum/anchor/blob/f68cc50e5bcb9a01ff958e41b5e15056f18d2fd6/lang/syn/src/idl/file.rs#L17>
Here is another example:
https://github.com/QuarryProtocol/quarry/blob/master/.github/workflows/programs-e2e.yml
Thank you sir!!!
https://github.com/project-serum/serum-ts/tree/master/packages/common, not sure about documentation (doubt it, but maybe!)
How do you setup integration testing in solana + anchor using GitHub actions?
Do I have to install solana-cli and anchor?
Think I'd need to see some snippets of your code to help, can you share any? Passing an array of variable size serializations should be fine (Borsh can do that). The Borsh vs. AnchorSerialize etc. is interesting (AnchorSerialize is just an alias under the hood for BorshSerialize etc., but it's maybe possible there's a version mismatch or something? Hmm)
Did you figure things out? If you know the address of an account, you can either fetch it on the client with e.g. `await provider.connection.getAccountInfo(itsAddress)`, or you could also pass it as an account to your own program (solana will load its AccountInfo stuff for you, you just specify its address/public key)
Thank you for advice.
Yup. I followed that
https://project-serum.github.io/anchor/tutorials/tutorial-3.html
here is cpi example
<@!765293840542203904>
https://github.com/project-serum/anchor/blob/master/examples/tutorial/basic-3/programs/puppet-master/src/lib.rs#L18
thank you for your advice. but I don't understand. can you please give me better explanation?
I think you need to get account info of product state. Because the hello world program doens't store state.
can you please give me advice?
Hey, guys, I am gonna get the price value from another program's state account (helloworld). but I have no idea how to do it.

can someone suggest example code to look at so I can make this work?
and also trying to pass an array of these to a function in my program that's meant to be called via CPI causes lifetime issues in the `program` macro
it looks like spl-governance `InstructionData` implements deserialization, but rust complains it's Borsh, not Anchor
`spl_governance::state::proposal_instruction::InstructionData` is variable size. I'm trying to pass an array of these to a function in my program, but getting all sorts of rust lifetime errors, and serialization errors
I'm trying to interact with spl-governace program using anchor, and it's all good except I can't figure out how to make `add_instruction` work
In solana program, if I know the address of other program's state account data, can I just read the value? how? can you please give me code snap for it?
Where can I find the source code for @project-serum/common?
And is there documentation?
I'll try that, thanks üôÇ
I guess Rust's lifetime elision rules produce more like
```.rs
pub fn fafarafa<'key, 'accounts, 'remaining, 'info, 'bla>(
        ctx: Context<'key, 'accounts, 'remaining, 'info, BlaAccounts<'bla>>,
    ) -> ProgramResult {
```
Mm, interesting, I wish I could give a better explanation for why you need to do this, but this is a situation where Rust's automatic lifetime inference gets confused. Doing this works though I think:
```.rs
pub fn fafarafa<'key, 'accounts, 'remaining, 'info>(
        ctx: Context<'key, 'accounts, 'remaining, 'info, BlaAccounts<'info>>,
    ) -> ProgramResult {
        let bla = &mut ctx.accounts.bla;
        let rem_acc = &ctx.remaining_accounts;

        invoke(
            &transfer(&bla.owner, &bla.boner, LAMPORTS_PER_SOL),
            &[
                rem_acc[0].to_account_info(),
                ctx.accounts.foo.to_account_info(),
                ctx.accounts.bar.to_account_info(),
            ],
        )?;
        Ok(())
    }
```
hey. it's been a while since I last bothered you all XD
anyway, I have a problem with invoking a transfer in anchor

the code is as simple as it gets:
```
#[program]
pub mod bla {
    use anchor_lang::solana_program::native_token::LAMPORTS_PER_SOL;

    use super::*;

    pub fn fafarafa(ctx: Context<BlaAccounts>) -> ProgramResult {
        let bla = &mut ctx.accounts.bla;
        let rem_acc = &ctx.remaining_accounts;

        invoke(
            &transfer(
                &bla.owner,
                &bla.boner,
                LAMPORTS_PER_SOL,
            ),
            &[
                rem_acc[0].to_account_info(),
                ctx.accounts.foo.to_account_info(),
                ctx.accounts.bar.to_account_info(),
            ],
        )?;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct BlaAccounts<'info> {
    pub bla: Account<'info, BlaStruct>,
    #[account(mut)]
    pub foo: AccountInfo<'info>,
    pub bar: AccountInfo<'info>,
}

#[account]
#[derive(Default)]
pub struct BlaStruct {
    pub owner: Pubkey,
    pub boner: Pubkey,
}
```
and the error is
```
error[E0623]: lifetime mismatch
  --> programs/bla/src/lib.rs:24:28
   |
13 |     pub fn fafarafa(ctx: Context<BlaAccounts>) -> ProgramResult {
   |                          --------------------
   |                                  |
   |                                  these two types are declared with different lifetimes...
...
24 |                 rem_acc[0].to_account_info(),
   |                            ^^^^^^^^^^^^^^^ ...but data from `ctx` flows into `ctx` here
```
why does it work for everything but `remaining_accounts`?
Lol, what is going on with my master branch for the cli‚ÄîI had to rename `use clap::Clap` plus all its derives to use `use clap::Parser`. I don't think I changed anything else ü§î
https://discord.com/channels/889577356681945098/889702325231427584/901294271666221117
ahh got it, thank you sir!
or equiv
and maybe add this to your bash profile `export PATH="/Users/${YOUR_HOME}/.local/share/solana/install/active_release/bin:$PATH` if you're on a mac
i accidentally installed from cargo and npm
yeah that happened to me, run a `which anchor` and then see where the pointer is coming from
anyone running into this issue after upgrading? Globally installed anchor version is not correct. Expected "anchor-cli 0.17.0", found "anchor-cli 0.16.1".
Note that this approach with the tombstone is a bit tricky. If a user is attacked by being tricked to close in a tx such that the immediate instruction following refunds the account, it can leave an account subject to being in limbo, and so to remedy that you need a force defund instruction as well.
https://github.com/project-serum/anchor/blob/master/lang/src/common.rs#L6
yes, could you show template how to do this?
We need fix for this...
https://github.com/nodejs/node/issues/40537
You can remove the close attribute and do it manually.,
How to close account same as in example below, but instead of close it in context I want to close the account from function handler?
```
pub struct Context<'info> {
  #[account(mut, close = owner]
  pub state: Loader<'info, State>,
  #[account(mut, signer)]
  pub owner: AccountInfo<'info>,
}
```
<@!501570363566587905>
<:woow:562246713604309019>
This can be interesting for you too: https://github.com/solana-labs/solana-program-library/blob/fca9836a2c8e18fc7e3595287484e9acd60a8f64/token/perf-monitor/tests/assert_instruction_count.rs#L139-L142
but now numbers are lower, at least were 3 month ago https://github.com/solana-labs/solana-program-library/pull/2101/files#diff-c785169c8de105418e0ff600daa787a34bbb51dc121e1bbb2a7ec83bcb4b2a2cR155-R158
was looking for that number 
ty <:woow:562246713604309019>
logs
How do you measure compute units? logs or create rbpf vm?
Some discussion here https://github.com/solana-labs/solana/issues/20311. The flat cost seems to be somewhat of a function of the number of accounts being used.
Ok... if I get ambitious I will tackle
Roughly yes. What are you interested in?
It doesn't handle that atm. A PR would be great!
No, but really curious...
Does anyone know how I could update a token's metadata in Rust using the anchor_spl crate?


///////////////////////////////////////////////////////////////////////////////////////////////

idk this is a function in the serum lib.
thanks for the pointer <@!134416332509675520> , I had given up and stashed the change already...
Alright I was missing something on the top level and the 'info from TakeOrer and handler were colliding (I wasn't specifying it)

I've attempted to split my code in a "jet" style several times... First time it works
And instead of passing the `accountInfo` as parameter I'll just pass an index and access it there. That makes sense
Oh no Ok I see. I need to add my function on Context and not just the accounts. It will fix it
The error means that there are two differents `'info`?
Actually, it's not exactly the same, because I got it working doing that before, but now I splitted the files and this is slightly different it seems

Thank you ‚ù§Ô∏è
YES. And now that I see that i remember I already fixed it before, goddamn
Are you running into this issue? https://discord.com/channels/889577356681945098/889577399308656662/901311610851819570
When doing idiomatic anchor with contextes, how to access remaining account, cause it's from the "context" above accounts. and passing references causes lifetimes issues
This section of code is taken from tests/swap/utils/index.js. Everything worked fine on my localnet.
Is some account there actually not a system_program account for some reason?
I think that means you end up trying to do a system_program transfer of lamports, but the funding account (`from` above) somehow has non-empty `data` (unexpected since it's supposed to be a system_program account, and I'm not sure when they ever have data ü§î).
Works fine on localnet but not devnet
```
    Program 11111111111111111111111111111111 invoke [1]
    Transfer: `from` must not carry data
    Program 11111111111111111111111111111111 failed: invalid program argument
```
Getting this from using:
```
      await MARKET_A_USDC.makePlaceOrderTransaction(provider.connection, {
        owner: marketMaker.account,
        payer: marketMaker.quoteToken,
        side: "buy",
        price: bid[0],
        size: bid[1],
        orderType: "postOnly",
        clientId: undefined,
        openOrdersAddressKey: undefined,
        openOrdersAccount: undefined,
        feeDiscountPubkey: null,
        selfTradeBehavior: "abortTransaction",
      });
    await provider.send(transaction, signers.concat(marketMaker.account));
```

Very stumped on this one.
too tired to workaround now, but it's almost certainly the problem
just learned there is a bug in `spl-governance`
thanks
yep
Shouldn't need to do anything on the client‚Äîyou can double check by looking at target/idl/progrname.json, the account should be marked with "isMut" true.
thanks <@!134416332509675520> for the support
tx was failing to due compute limit being exceeded. move tx instruction to a standalone tx. something like this:

```var initTokenTx = new anchor.web3.Transaction({
  feePayer: owner,
  recentBlockhash: (await provider.connection.getRecentBlockhash()).blockhash
});
const tokenAix = await serumCmn.createTokenAccountInstrs(provider, rewardAVaultKeypair.publicKey, _rewardMintA, stakingPoolImprint);
const tokenBix = await serumCmn.createTokenAccountInstrs(provider, rewardBVaultKeypair.publicKey, _rewardMintB, stakingPoolImprint);
const tokenCix = await serumCmn.createTokenAccountInstrs(provider, rewardCVaultKeypair.publicKey, _rewardMintC, stakingPoolImprint);
initTokenTx.add(...tokenAix);
initTokenTx.add(...tokenBix);
initTokenTx.add(...tokenCix);
const signedTxSig = await provider.send(initTokenTx, [
  rewardAVaultKeypair,
  rewardBVaultKeypair,
  rewardCVaultKeypair,
]);
console.log('signedTxSig for tokenCix:', signedTxSig);```
fixed finally
how can I pass that as a signer to the tx?
id assume not, owner is `stakingPoolImprint`
it's enough to mark an account with `#[account(mut)]` in Anchor for it to be writeable? Nothing to do on the client?
is this the right way to send a manual tx? I get a `Signature verification failed` error

```var initTokenTx = new anchor.web3.Transaction({
  feePayer: rewardCVaultKeypair.publicKey,
  recentBlockhash: (await provider.connection.getRecentBlockhash()).blockhash
});
const tokenCix = await serumCmn.createTokenAccountInstrs(provider, rewardCVaultKeypair.publicKey, _rewardMintC, stakingPoolImprint);
initTokenTx.add(...tokenCix);
const signedTxSig = await anchor.web3.sendAndConfirmTransaction(provider.connection, initTokenTx, [rewardCVaultKeypair])
console.log('signedTxSig:', signedTxSig);```
it looks like after all that, theres a compute limit being hit. by passing the `TransactionInstruction[]` for creating each token account I can trigger it, however if i remove just one set, the tx and test will pass. older versions of anchor dont show this error in a meaningful message (it seems)
<:hmm:739527689622257784>  able to get it working for two reward tokens but not three
<:fuck:827622412253790218>
but i am still left with an undefined error if i pass the ixs as intended
digging into this further. if i remove the instructions completely, I can force a visible error relating to `An account's data contents was invalid`
hmm no that wasn't it
let me retry
it was marked as `#[account(mut)]` on the outer anchor context, but not on one I use to pass to the inner call
ahh I think I figured it out
my interpretation is that the callee needs `88ac91ynChNuxhetD6GWXUGtQ1pWNYR8iNULdiGb5AUn` to be writable but it was passed to caller as readonly
am I misinterpreting the error message?
hmm the error is `88ac91ynChNuxhetD6GWXUGtQ1pWNYR8iNULdiGb5AUn's writable privilege escalated`
here's the transaction. In the log the error is for for the account `88ac91ynChNuxhetD6GWXUGtQ1pWNYR8iNULdiGb5AUn` which the explorer shows is marked as writeable in both outer and inner instruction
https://explorer.solana.com/tx/557ggCEi7yKyn6cW6t5sdGoVg58svRrmT6jTJDMtPwNrKawu2PPDL2kV9HSoc9ZYCV1wnwehuRqQnj6vY7GUnxd5?cluster=devnet
just the wallet
it's the payer actually
no
Is it a pda?
Change rust-toolchain will not produce any difference because bpf toolchain use own rustc version (on your screenshot 1.52.1)
this is strange because when I put `msg!("ACCOUNT {} {} {}", ctx.accounts.payer.key, ctx.accounts.payer.to_account_info().is_writable, ctx.accounts.payer.to_account_info().is_signer);` I get all `true`
what am I doing wrong?
but when I call `solana_program::program::invoke(...)`  I get a writable escalation error on `payer`
here I know `ctx.accounts.payer` is mutable
```
        let ctx_create_proposal = CpiContext::new(ctx.accounts.governance_program.clone(), SplCreateProposal {
            // ...
            payer: ctx.accounts.payer.clone(),
            // ...
        });
```
do I need to redeclare accounts as writable in `CpiContext::new`?
hmm getting writable account privilege escalation error on a CPI call, but the account clearly is writable
Figured it out needed to nuke my target folder
at this rate i will need to just get a new laptop lol
rustup target list doesnt show a bpf target anymore
Could not find specification for target \"bpfel-unknown-unknown\".
and it is due to this
i traced it down though, when i run in verbose one command is blowing up
yeah ive seen this too, i think it _is_ that
similar to this bug maybe https://github.com/rust-lang/rust/issues/56935 ?
This is because you moved on so metaplex rejects you
no idea why
i even upgreaded rustc to 1.56 and its still doign this

Anybody seen this suddenly appear? Same code, nothing changed
currently the instruction in idl.json references the type, but there is no type definition for it so I get a runtime error `Type not found: {"type":{"defined":"ImportedTypeNameHere"}}`
if I import a type in my anchor program that I use as an instruction argument, how can I make the type definition show up in the idl?
Could be worth a try though if you're running out of stack space.
ah right
(since they're all just pointers internally)
No. But probably not necessary since there's not much data being stored for any of those accounts.
Is there anyything blocking implementing `Box<>` support for `Loader` as well as `AccountInfo / UncheckedAccount` types
Oh actually, I see this feature is not released yet https://github.com/project-serum/anchor/blob/master/CHANGELOG.md
I'm looking through the anchor tests, and I see this in `escrow.ts` (the test for the escrow program, https://github.com/project-serum/anchor/blob/master/tests/escrow/tests/escrow.ts#L11)

```
import { Escrow } from '../target/types/escrow';
```

The test is written in TypeScript, and is importing from a generated TypeScript module.

When I run `anchor build` though, it doesn't create `target/types`. How am I supposed to generate that?
Haha, sure, just send me a dm at some point
can do in a few hours, need some sleep üòÜ  20 hrs on the go
^ Want to screenshare for a bit on this? I'm down
would I be able to see the tx on the local validator or given `Promise rejected with no or falsy reason`should I assume the tx failed?
and let's say i change the depositing accounts to owner (sol pub key, obvs not going to work): 

```Transaction simulation failed: Error processing Instruction 6: invalid account data for instruction 
    Program 11111111111111111111111111111111 invoke [1]
    Program 11111111111111111111111111111111 success
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [1]
    Program log: Instruction: InitializeAccount
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 3919 of 200000 compute units
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success
    Program 11111111111111111111111111111111 invoke [1]
    Program 11111111111111111111111111111111 success
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [1]
    Program log: Instruction: InitializeAccount
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 3919 of 200000 compute units
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success
    Program 11111111111111111111111111111111 invoke [1]
    Program 11111111111111111111111111111111 success
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [1]
    Program log: Instruction: InitializeAccount
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 3919 of 200000 compute units
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success
    Program 2DvfGJejDUKCNmjA5JfrT9h1qF2RkqgDZXj7cg9iQS6V invoke [1]
    Program log: Decay rate: 1
    Program log: Pool type: Static
    Program log: Total reward a: 1000000000000000
    Program log: Updating reward a per block to: 81300813
    Program log: Total reward b: 50000000000000
    Program log: Updating reward b per block to: 4065040
    Program log: Total reward c: 5000000000000
    Program log: Updating reward c per block to: 406504
    Program log: Transferring funds to reward vault A...
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [2]
    Program log: Instruction: Transfer
    Program log: Error: InvalidAccountData
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 1379 of 180933 compute units
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA failed: invalid account data for instruction
    Program 2DvfGJejDUKCNmjA5JfrT9h1qF2RkqgDZXj7cg9iQS6V consumed 200000 of 200000 compute units
    Program 2DvfGJejDUKCNmjA5JfrT9h1qF2RkqgDZXj7cg9iQS6V failed: invalid account data for instruction```
which makes sense, the tokenaccountinstr was not included
if I modify `instructions: tokenAix.concat(tokenBix).concat(tokenCix)` to `instructions: tokenAix` I end up with a different error:
```Transaction simulation failed: Error processing Instruction 2: invalid account data for instruction 
    Program 11111111111111111111111111111111 invoke [1]
    Program 11111111111111111111111111111111 success
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [1]
    Program log: Instruction: InitializeAccount
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 3919 of 200000 compute units
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success
    Program 7zXhoRTZicwAByHzNrifNxpByZFAYuvxs261VbgTkANn invoke [1]
    Program log: An account's data contents was invalid
    Program 7zXhoRTZicwAByHzNrifNxpByZFAYuvxs261VbgTkANn consumed 9906 of 200000 compute units
    Program 7zXhoRTZicwAByHzNrifNxpByZFAYuvxs261VbgTkANn failed: invalid account data for instruction```
``` let tx = await program.state.rpc.new(``` line
Hmm, do you know which line ends up being the problem? Like, just be inserting console.logs or using a debugger?
no additional logs before/after
trace posted in logs when running the test is 
``` 1) test staking program
       Initialising staking pool
         Initialise staking pool:
     Error: Promise rejected with no or falsy reason
      at processTicksAndRejections (node:internal/process/task_queues:96:5)```
is there a way to enable more verbose logging?
Can you post the full stack trace?
but if I change tokenAccountInstrs param for mint to the staking mint key and change the depositors to the staking mint vault, the test passes (incorrectly üòÜ )
```it('Initialise staking pool', async () => {     
      // Create mint and vault  
      const [stakingTokenMint, _mintVault] = await serumCmn.createMintAndVault(
        provider, 
        new anchor.BN(1_000_000 * LAMPORTS_PER_SOL),
        owner,
        9
      );

      // Create reward mints and vaults
      const [rewardMintA, rewardMintVaultA] = await serumCmn.createMintAndVault(
        provider, 
        new anchor.BN(1_000_000 * LAMPORTS_PER_SOL),
        owner,
        9
      );
      const [rewardMintB, rewardMintVaultB] = await serumCmn.createMintAndVault(
        provider, 
        new anchor.BN(100_000 * LAMPORTS_PER_SOL),
        owner,
        9
      );
      const [rewardMintC, rewardMintVaultC] = await serumCmn.createMintAndVault(
        provider, 
        new anchor.BN(5_000 * LAMPORTS_PER_SOL),
        owner,
        9
      );

      const rewardAVaultKeypair = new anchor.web3.Keypair();
      const rewardBVaultKeypair = new anchor.web3.Keypair();
      const rewardCVaultKeypair = new anchor.web3.Keypair();

      const stakeRate = new anchor.BN(1);
      const now = new Date().getTime() / 1000;
      const startBlockDate = now + (1 * SECOND_IN_DAY);
      const startBlock = new anchor.BN(startBlockDate);
      const poolType = new anchor.BN(0);
      const periodInMonths = 2;
      const period = new anchor.BN(periodInMonths);
      const initialRewardAmountTokenA = new anchor.BN(500_000 * LAMPORTS_PER_SOL);
      const initialRewardAmountTokenB = new anchor.BN(25_000 * LAMPORTS_PER_SOL);
      const initialRewardAmountTokenC = new anchor.BN(2_500 * LAMPORTS_PER_SOL);
      const decayRate = new anchor.BN(1);

      const statePubKey = await program.state.address();
      const [stakingPoolImprint, stateImprintNonce] = await anchor.web3.PublicKey.findProgramAddress([statePubKey.toBuffer()], program.programId);
      
      const poolMint = await serumCmn.createMint(provider, stakingPoolImprint, 9);
      
      const tokenAix = await serumCmn.createTokenAccountInstrs(provider, rewardAVaultKeypair.publicKey, rewardMintA, stakingPoolImprint);
      const tokenBix = await serumCmn.createTokenAccountInstrs(provider, rewardBVaultKeypair.publicKey, rewardMintB, stakingPoolImprint);
      const tokenCix = await serumCmn.createTokenAccountInstrs(provider, rewardCVaultKeypair.publicKey, rewardMintC, stakingPoolImprint);

      let tx = await program.state.rpc.new(
        stakingTokenMint,
        rewardMintA,
        initialRewardAmountTokenA,
        rewardMintB,
        initialRewardAmountTokenB,
        rewardMintC,
        initialRewardAmountTokenC,
        statePubKey,
        stateImprintNonce,
        stakeRate,
        startBlock,
        poolType,
        decayRate,
        period,
        {
          accounts: {
            authority: owner,
            poolMint,
            rewardAVault: rewardAVaultKeypair.publicKey,
            rewardADepositor: rewardMintVaultA,
            rewardBVault: rewardBVaultKeypair.publicKey,
            rewardBDepositor: rewardMintVaultB,
            rewardCVault: rewardCVaultKeypair.publicKey,
            rewardCDepositor: rewardMintVaultC,
            rewardAuthority: owner,
            tokenProgram: TokenInstructions.TOKEN_PROGRAM_ID,
            rent: anchor.web3.SYSVAR_RENT_PUBKEY
          },
          signers: [
            rewardAVaultKeypair, 
            rewardBVaultKeypair, 
            rewardCVaultKeypair
          ],
          instructions: tokenAix.concat(tokenBix).concat(tokenCix)
        }
      );
        
      const state = await program.state();

      // Assertions
    });```
here's an example test that fails
sure, its been a pain getting past this
Can you post some of your code? What you're doing sounds fine to me at least ü§î
i thought the same. can i have multiple `createTokenAccountInstrs` in a rpc init call?
That sounds like a general JS error, not anything anchor specific, so don't think anchor logs etc. will help. Are you doing any unusual promise/async stuff?
hey i get an error ```     Error: Promise rejected with no or falsy reason
      at processTicksAndRejections (node:internal/process/task_queues:96:5)``` are there any way to enable more verbose logging to debug  this further?


///////////////////////////////////////////////////////////////////////////////////////////////

Was this the discord server were someone mentioned there was a raydium deployment onto devnet that they setup : ü§î
What does the target/idl/<progname>.json look like for that instruction?
Hi all, I am surprised the following does not work:
```
        const ix = poolProgram.instruction.createLpAccount(usdtPoolLpStateBump, PoolCurrency.USDT, {
          accounts: {
            [...]
          },
        });
```
I get an `Error: provided too many arguments ${args}`
When I pass the args as an array it produces a 0x66 instruction error.
Another part of my code uses this code fine:
```
await poolProgram.rpc.init(usdtPoolPoolStateAddressBump, nonce, PoolCurrency.USDT, {
    accounts: {
```
Seems strange to me that the former would not work. There is nothing special in the rust code either:
```
#[derive(Accounts)]
#[instruction(bump: u8, currency: u8)]
pub struct CreateLpAccount<'info> {
```
And the fn: `pub fn create_lp_account(ctx: Context<CreateLpAccount>, bump: u8, currency: u8) -> ProgramResult {`

I am sure I made a stupid mistake somewhere. If anyone has an idea ?
It's possible but not simple. You need to fetch accounts, create instruction (you need new_order and settle_funds) and then process it with `serum_dex::State::process`. Rate will depend from order size.
How to get rate of a serum market from the rust side, is it even doable?
This will be cool if you test it https://github.com/project-serum/anchor/pull/928
thanks! i updated to 16.4 and it works great now üôÇ
ohhhh, I tested on node > 16.4 üò†  will submit fix shortly
ran in this error after upgrading to v.0.18 (running on node v16), running anchor tests

```
node: --dns-result-order= is not allowed in NODE_OPTIONS
```

Seems related to this change here - https://github.com/project-serum/anchor/pull/915/files
"--dns-result-order" is added in Node 16.4, so anything before that won't work. Which node version is anchor officially supporting?
Has anyone else had interest in optional named accounts? Also named account arrays (if you want to streamline typechecking and grouping rather than passing all of these in remaining_accounts)
btw Here, can I use u8 array from the keypair in my local since I created the spl-token in my local? if so, how? and to put the seed directly is safe from security ?
Is it possible to see the contract code like what I can see from Etherscan and bscscan ?
```TypeError: programId.toBuffer is not a function
    at Function.createProgramAddress (../node_modules/@solana/web3.js/lib/index.cjs.js:228:58)```
hey any ideas why id get this?
how to send a custom rpc transaction using phantom wallet
Is serum dex on devnet still DESVgJVGajEgKGXhb6XmqDHGz3VjdgP7rEVESBgxmroY???
if i am not wrong
i think a single instruction would take something like 27 accounts at least
Usually it happens when composing with other programs, like you need CPI so accounts for program #1 + program #2....
What kind of madness hits the transaction limit though?
lol
facepalm
ahhh I completely misunderstood where the eight bytes are
I just switched from using normal context infrastructure to remaining accounts to get around transaction size issues, but that didn't change the size of the transaction at all
Anchor prepends each account with 8 bytes for safety checks. Does it do that with `remaining_accounts`?
You could also provide the values of side to the instruction as a u8, and then add a from trait for u8 to cast it to a Side type
`#[repr(u8)]` on the enum should reduce the space needed for side
That doesn't look like too much but with the transaction size limit this can cause problem quickly
20 bytes for side + in_amount
Side is a rust enum
This
```
        side: Side,
        in_amount: Option<u64>,
        minimum_out_amount: u64,
```
consumes 28 bytes serialized
3/4 mint instructions working!
ok needed to give more lamports
and than later checking for the rent account
let new_account_info = next_account_info(account_info_iter)?;
        let mint_info = next_account_info(account_info_iter)?;
but this instruction is grabbing two accounts right away
hmm when people are using this instruction, they are generally using two accounts for keys, the first being the mint, the second being the sysvarrent
oh awesome, wasn't sure where to find the source for these
https://github.com/solana-labs/solana-program-library/blob/master/token/program/src/processor.rs#L40
https://github.com/solana-labs/solana/blob/master/sdk/program/src/program_pack.rs#L44
In general, yeah, it depends on what the program expects. In this case it checks against an exact length
so you can give something too much space?
^ ah, from source-diving it sounds like you're supposed to give mints 82 bytes of space
In general you kinda just need to source-dive. In this case you can see which instruction you're trying to do, TokenInstruction::InitializeMint, and go find where it gets handled inside the spl token program's processor.rs file
165
How much space are you giving it?
yes
Are you creating the mint with the first createAccount instruction?
the init mint function is from the TokenProgram
on iOS
from a client app
no rust code actually, i'm calling into the SystemProgram and TokenProgram respectively here
It looks like it‚Äôs an error with your rust code. Mind posting the initmint function so we can see?
anywhere you recommend for triaging or debugging this?
createAccount alone is succeeding
there are two instructions in my transaction, createAccount and initializeMint
request(method:overridingEndpoint:path:bcMethod:parameters:onMethodNotFoundReplaceWith:log:) -> {"jsonrpc":"2.0","result":{"context":{"slot":89648922},"value":{"accounts":null,"err":{"InstructionError":[1,"InvalidAccountData"]},"logs":["Program 11111111111111111111111111111111 invoke [1]","Program 11111111111111111111111111111111 success","Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [1]","Program log: Instruction: InitializeMint","Program log: Error: InvalidAccountData","Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 1705 of 200000 compute units","Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA failed: invalid account data for instruction"]}},"id":"681D52D3-74BE-4537-AF3A-DB8F8E926A78"}
hey all, hitting this error from an instruction i'm calling:
‚öì
We have one
this is unacceptable
why don't we have anchor emojis
now i cannot pretext some obscure error is blocking me
thanks
noobed
ok
of course it is wrong
OFF BY ONE
That's your error.
wat
`WrongOrdersAccount`
0x2d
https://solscan.io/tx/5vSN1ARsYeChuJbY5KLoLcvexDcmH2aF9khHqFANX985ND8KPtKQBgS1wQySjDE5Hcfzpboj9BsCZQ8v7HosAdb4?cluster=devnet
not yet
did you try throwing the computer out the door?
that is a correct observation
that doesn't make sense
hmmm
but that is not even CPI, that is 2 sequential instructions in the transaction
If you ever borrow the account data you should drop it before CPI
Yes.
is it possible an instruction holds something for the next? and i should drop something in particular
I am having a bizarre BorrowError when i chain new order instructions hitting serum twice, but weirdly no error when i do another operation then a serum new order
The alternative I guess would be to 

* copy `program_id`
* `RC<T>` for accounts (or instead pass in a mutable reference in the instruction api)

And then leave the remaining accounts, so that we have two lifetimes instead of four.
because he didn't chose?
```/// Provides non-argument inputs to the program.
pub struct Context<'a, 'b, 'c, 'info, T> {
    /// Currently executing program id.
    pub program_id: &'a Pubkey,
    /// Deserialized accounts.
    pub accounts: &'b mut T,
    /// Remaining accounts given but not deserialized or validated.
    /// Be very careful when using this directly.
    pub remaining_accounts: &'c [AccountInfo<'info>],
}```
4 references with different lifetimes
I second this!
Armani, what's the reasoning for why `Context` has four lifetime paramaters? It seems excessively granular on the face of it, I'd like to understand better why you chose to do it this way.
Yup.
yes maybe the usual path through but don't we already pass those to `cargo build`?
but it works
i don't know what is best but redefining all the arguments seems odd
because that is a lot of wrapping, while this is fully documented on solana test validator
Similar to the slop?
Via cli args?
is there any way we can just forward stuff?
that is quite limiting to the implemented feature set
hahaha, this is great.  this is exactly how I was imagining implementing
See the description there.
Yes this is doable on the master branch https://github.com/project-serum/anchor/pull/834
Is there a way for tests to start `solana-test-validator` with arguments (when doing `anchor test`)?  Just start it myself and use `--skip-local-validator` would work, but would like to be able to use `-c` to clone some mints as part of my tests, and not have to start a local one every time


///////////////////////////////////////////////////////////////////////////////////////////////

Had to run brew install openssl@1.1
Nevermind I got it
dyld: Library not loaded: /usr/local/opt/openssl@1.1/lib/libssl.1.1.dylib
  Referenced from: /Users/solanadev/.local/share/solana/install/active_release/bin/solana-test-validator
  Reason: image not found
I'm having an issue running anchor test after I run anchor init. I'm currently on localhost in my config file...but for the past couple of days...for some reason my machine doesn't want to run solana-test-validator...which runs through anchor test. Cargo test works fine...and I'm in my root directory. I also don't have an M1 chip...I'm on a new iMac 2020 which should've been the last without the M1
Zero copy is basically a byte for byte type cast, so dynamic structures aren't supported.
no unfortunately
Amazing! Thanks!
Very curious now
Good question...
is there any vector-like data structure implementation for zero-copy array?
You can probably do `ctx.accounts.my_account.reload()`
Is there a good way to resync an account from context after executing a cpi call? For example, you execute a cpi call that drains some amount from a TokenAccount, and you want to know how much it drained. The ctx.accounts.token_account still shows the original amount. 

I tried to re-deserialize the data, but get `instruction tries to borrow reference for an account which is already borrowed`
You are welcome.
yo thanks.. the program_id after the deploy was different using devnet
If so, try to rebuild, redeploy and rerun migrations.
Did you specify `declare_id!("PROGRAM_ID");`  in your program ? Does it match ```
[programs.localnet]
your_program_name = "PROGRAM_ID"
``` in your anchor.toml ?
my tests passes in localnet, but when I change `Anchor.toml` to devnet it fails with error - `Error: 167: The given account is not owned by the executing program`.
Sry for the late reply, just got back to my laptop. The idl looks fine imo:
```
 {
      "name": "createLpAccount",
      "accounts": [
        {
          "name": "lpAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "authority",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "payer",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "rent",

          "isMut": false,
          "isSigner": false
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "bump",
          "type": "u8"
        },
        {
          "name": "currency",
          "type": "u8"
        }
      ]
    },
```
UPDATE: Turns out Anchor v0.17.0 was the culprit. Works fine under 0.18.0.
wow, thank you so much. Let me try to do it.  üëç
I don‚Äôt really use the cli but I think you did it correct (if the new mint authority is pointing to pda account)

how to convert token authority to program?
"spl-token authorize" can be worked?
why turn it off? It is an essential feature
In side of the programs, I can get token account infos and it was minted successfully but only problem is that I couldnot import token in my wallet.
In this case, the spl-token was not imported into my wallet, it was so wired.
yes, right, To sign the mint, can I use my keypair.json in my program directly?
I think it's easier to create spl-token in js. 
But anyway, you will need to set up PDA because of the mint authority. You only want the program to mint right? But how can the program mint without signing? This is where PDA comes in.
(and is there a way to turn it off)
if I declare `#[account(init, ...)]`  on `AccountInfo`, will anchor still prepend an eight byte descriminator?
so when user deposite USDT, I am gonna mint above token in my program
and I am gonna use this token in my program
I just created spl-token

PDA from my spl-token?
You will need to setup pda
I think this is an example of mint
https://github.com/project-serum/anchor/blob/master/tests/ido-pool/programs/ido-pool/src/lib.rs#L94
thank you for your advice. But it is javascript code. I wanna it in my rust program.
Yes, very easily. Example code:
https://github.com/project-serum/anchor/blob/master/tests/escrow/tests/escrow.ts#L42
hey, guys, can I mint the spl-token, which was made in spl-token cli, in my program?
ah I have to rebuild anchor
does it need to be in root folder maybe?
when I do it on the level of an individual program and deploy it, it doesn't seem to work
```
[features]
devnet = []
default = ["devnet"]
```
if I wanted to enable devnet is the following entry in Cargo.toml correct
ty
etc.
then you search in the codebase for that
error 2 is `InvalidMint`
https://github.com/solana-labs/solana-program-library/blob/master/token/program/src/error.rs
I'd look under spl token on github for error codes
anyone know what this means when calling createMint?  Transaction simulation failed: Error processing Instruction 1: custom program error: 0x2
ah thank you
https://github.com/project-serum/anchor/blob/master/spl/src/dex/cpi.rs#L11-L15
or hardcode it in Cargo.toml
when building
-- --features devnet
Armani-- in your dex porcelain layer context structs (like `NewOrderV3`) don't take a program id, and `new_order_v3` passes a constant dex program id when creating the instruction. Which doesn't work on devnet for serum because it has a different devnet address
and armani and others of course!
it made the experience way way easier
thanks for your help <@!134416332509675520>
Yep
do I have to pass the PDA in the context for the program to be able to sign with it?
err, this would be so easy if I weren't bump up against transaction size limits
I feel very stupid
thanks
lol
no üôÇ
Hmm, are you definitely using the right programId on the client?
if I don't pass it, the account gets created
but if I pass the bump explicitly I get `Provided seeds do not result in a valid address`
ok, did some debugging. When I use your bump printing trick, it's the same bump on the client and server
Haha, I was like "... wait ü§î"
hah nice that's great
Can then compare with what console.log says for the bump on the client lol
It's funny, this made me realize you can do `bump = { msg!("bump = {}", the_bump); the_bump }` as a quick/hacky debugging thing
will quadruple check everything
üëç
Cool, so that means that that bump above is wrong somehow‚Äîeither you're passing the wrong one from the client, or you've got something off with `#[instruction(...)]` (unfortunately have to be pretty careful about the ordering there‚Äîyou're aware but easy to make mistakes)
no idea why that would be the case, I just take the bump returned by `findProgramAddress` and pass it on
<@!134416332509675520> -- looks like you were right, thank you
let me try
thanks
I guess you can double check that by just doing `bump`, rather than `bump = the_bump` (it will recalculate it for you)
Hmm. I think this means something is wrong with the bump you end up using.
it's just the signature of the instruction
`#[instruction(side: u8, limit_price: u64, size: u64, open_orders_authority_bump: u8)]`
What does your `#[instruction(...)]` look like?
Ah, you can also do `pub my_account: Account<'info, Something>`
`Program failed to complete: Could not create program address with signer seeds: Provided seeds do not result in a valid address`
that gives me the following error msg on exectuion
Yep üëç

so smtg like this should work
Yep, just need to also add seeds and bump annotations (well, `bump` can be just `bump`, no equals sign if you really want)
does adding an account init annotation work for PDAs?
anyway it would implode if it isn't
Assuming the owner is indeed the current program id
Yea that works.
I don't really want to pass down the program id, adds bloat to that one function
```            token_ledger.token_account = Pubkey::default(); // Wipe token ledger
            token_ledger.exit(&TokenLedger::owner())?;```
Is this the best shot at writing back an Account i deserialized on-demand with try_from? Given that I know I am the program?

Well at least we've got issues.
ah! There's not docs, I just search/read github issues
If there's docs, those are very stale docs. üò¶
The associated attribute was removed.
(in other words is there a way to express "create one if missing, otherwise noop")
for the `associated` attribute, what happens if the account already exists?
at some point I need to write down all this stuff and publish it
thanks
No. It's just a way to access method arguments in the derive macro. The order and types of the args must match the instruction handler method exactly.
and pass the mantissa and scale yourself
You could always use a combination of Big.js/rust_decimal
are there any docs anywhere for the `#[instruction]` attribute?
üëç
And it will fail.
Correct.
if the bump is implicit they can't provide a different bump because you'll assert against the first working bump, correct?
This is to prevent attacks where someone provides a PDA with a different bump.
Although on `init`, we still run `find_program_address` *and* add an assertion that the bump provided is equal to the one found.
üëç
Correct.
is this to avoid paying compute for `find_program_address`?
Thank you for that clarification
ahh got it
Generally, best practice is to explicitly provide the bump and store it on the account.
That is an expensive computation.
It's just an explicit annotation to remind the developer that `PublicKey::find_program_address` will be run.
what would specifying it without the value do?
it's required, though you can specify `bump` without the value, e.g., `bump,`
Good question!
should the docs be updated? (or maybe I'm doing smtg wrong)
anchor docs say that when the `seed` constraint is declared on an account the bump is optional, but it seems to be required
Ok, thanks!
Oh one thing you could try is adding a `[profile.release]` in your Cargo.toml that has things like `opt-level = 0`. It didn‚Äôt make a difference for me but maybe it makes a difference if it‚Äôs taking 10 minutes
Thanks
True...
Just multiply by the decimals you need.
Can you do that with u128?
I am trying to pass lat and long into my function
Happy to add it if there is one.
Not atm. I haven't seen a reason to use f64 instead of u64 or u128.
To get around it... are there talks to add support for f64s?
Ok... I have an idea
Generally i'd recommend avoiding it if posible
https://tenor.com/view/noooo-star-wars-darth-vader-gif-8348766
f64 isn't usable in the idl atm
Anchor is angry at me... I want to pass an f64 into my fucntion, but the rpc doesn't like it...
Oh well... thanks for the help!
I‚Äôm not doing anything special ü§∑‚Äç‚ôÇÔ∏è
That is odd
Ok same as me
I am running version 2

https://askubuntu.com/questions/1177729/wsl-am-i-running-version-1-or-version-2
I think v1
WSL v1 or v2
Not sure what that is
You WSL2?
Interesting....
Yeah mine‚Äôs not nearly as bad ü§î think most if not all the tests are less than five minutes to build for me
And I have a relatively new machine
for me
It averages about 10 mins
https://github.com/mozilla/sccache
Interesting, it doesn‚Äôt take that long for me
Like the cargo-build bpf
Ah
In my WSL
Sorry, when I run anchor build it takes forever
Are you working on Anchor itself or just using it? If the latter, installing via NPM is much faster and works for me on WSL2
I hate how long it takes for Anchor to build for the first time on my WSL... does anyone have any hacks for a humble Windows user such as myself?


///////////////////////////////////////////////////////////////////////////////////////////////

Yeh, the SPL token program is very convenient but also lack of room for ponzi creativities. Let me dig that proposal up

Wow searching for `rebase` in a git repo is bad idea..
Found it, this is good read, thanks! 

https://github.com/solana-labs/solana/blob/1ca6543a3f4dc4214f680faa9dd5e4351d2fc551/docs/src/proposals/interest-bearing-tokens.md
Basically, solana needs an interface for SPL tokens so that we can have other token programs, instead of a single one.
There's an outstanding proposal in the solana repo for this
Any one thought about how rebasing will work for SPL tokens? Asking for my <:3_:825108400060629073> bag 

https://discord.com/channels/889577356681945098/889601099735126077/902658841878102108
thanks mate!
ok so no need to have a check neither that's great
I see, it's a whole new way of thinking on sol I love it
That's enough to prevent double-voting (trying to initialize an account at the PDA will fail the second time)
One thing you could do is to still have a single poll account which aggregates the votes. The individual PDAs just witness the fact that someone has voted (if an account has been created at that pda, then they've voted‚Äîotherwise they haven't yet); you'd still increment the appropriate vote count in the top-level poll acount.
And if I store each vote in it's own PDA, how are these accounts all grouped so I can get the total amount of votes?
Yeah I've heard of those two possible ways, creating a PDA for each account would be more expensive though right?
Damn that's it thanks üíØ
Another approach is to not store a vec of pubkeys at all, but rather create a separate account for each vote, which lives at a program-derived address whose seeds are based on the voter's public key + the poll's own address
You're almost certainly not allocating enough space to the poll (you're only doing 16 + 16, but you'll have to store at least 32 bytes for every pubkey you track)
Has any one found a solution for this?
I added a vector to the poll/counter but any time I wish to vote with an address I get a Failed to serialize account error (164)
Hey guys! I followed Brian's guide on creating a vote counter, but am trying to add a limit to have only one vote / address
Ok, just need to replace BorshDeserialize and BorshSerialize with AnchorDeserialize and AnchorSerialize, respectively. Thanks
This is `ClosedOffer` struct
I have this account, but there is no definition for `ClosedOffer` in the IDL file
I have an account with a field that's an enum, and Anchor defines that enum type in the IDL section 'types', which is OK. But I have another account with a field that's a struct but Anchor does not define that struct type in the IDL 'types' section. Why?
some initialization tests that don't interact w/ anchor program pass, but the first call to my program results in  `Transaction not confirmed`

EDIT: hrrrm lol - seem to have fixed it by restarting computer
im seeing this now - wasnt happening when i last spun up tests a couple weeks ago - do you just see it intermittently?
I'm trying to find a public smart contract that I can deploy that serves as a middleman in a transaction that automatically checks the input of lamports into an account, divides it and sends it to previously specified wallets without needing any manual inputs. Just wondering if anyone is aware of anything like this?
I'm following a video on Youtube and have the same things...his goes through though
Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 1: custom program error: 0x0
Why might I get this error? Isn't this related to not having enough funds in an account? I've tried on both localhost and testnet
i have two function here  (which does nothing great) the create pda function has to create a PDA if the condition in intitiate function passes...currently how i am doing this is by setting the pair_available boolean as true..and getting the pair available value in client using fetch(account)...and making the rpc request to create_pda fn if the boolean is true...is this correct the way to do this and is there any other efficient way to do this
but the programs actually build
unresolved imports everywhere
rust analyzer in vs code just fails completely for anchor cpi
ah I see
(I want to pass it to a governance proposal)
for Anchor cpi (looking at example 3), is there a way to create the instruction rather than actually call the program?
How to write a function in anchor that can only be invoked by owner/deployer of the program? i.e if it is called by some other keypair it should give an error. Something like ```owner only``` in the ERC20 world
but It is happening in devnet as well.
`anchor test` shutdown local validator after test. If you want to use created accounts you need to run local validator by yourself and add `--skip-local-validator` to `anchor test`.
anchor test
yes
How you received output on screenshot? `anchor test`?
why I couldnot import this token into wallet?
Hi
Output with `ido-pool` on screenshot received with `anchor test`?
there is some reference to lots, but I can't figure out what's going on
in the serum protocol, what units are max token quantity, max coin quantity, and limit price expressed in?
U wizzard
but it is actually there
i found that the js lib does not expose sync native in the type
Alright thanks a lot man
it was added not too long ago
Holy fuck thanks for this exactly what I wanted to do. I mean that‚Äôs the intuitive solution
https://github.com/solana-labs/solana-program-library/blob/master/token/program/src/processor.rs#L702-L727
I did not know, what‚Äôs that <:pepenani:871538839821373501> <:pepenani:871538839821373501>
the beauty is that nobody knows about sync native
creating another wSOL account to transfer and close is the old way, very annoying and terrible for transaction size
send lamports to wSOL ATA, call token program sync native
no
It‚Äôs a bit convoluted, but if all inside the assoc txs of an anchor call it should be atomic and safe right?
Yep same, so to do so you would create new wrappped sol on a non ATA WSOL account and transfer them to the ATA WSOL?
I will do that soon
I would prefer though that the wSOL ATA be used as is and we push more SOL to it, thus combining SOL and wSOL
Thanks Mr, that‚Äôs a ui/ux choice indeed
on https://jup.ag we politely invite the user to unwrap all by clicking 1 button
No, just the canonical assoc token account for WSOL
all as in all potential token accounts?
More of a sol question, but is it accepted to unwrap all user WSOL before a tx if you want to use the WSOL canonical address? WSOL being the convenience SPL representation of SOL I would say yes, but...
Haha thank you!
No worries! I don't think anchor supports this yet, think you'll have to write out all 8 of them üò¨
or if anyone has seen this before, please post resolution here. While also help future searches!
<@!305170331214282762> in case you're still around, did you ever resolve this?
gotcha! thank you. I have one more silly question  sorryhaha

Is there a way to  for the #[derive(Accounts)] to expect an array ? 

E.g. 
‚Äú`
#[derive(Accounts)]
pub struct Example<'info> {
    #[account(mut, signer)]
    pub authority: AccountInfo<'info>,
    pub array_of_accounts: [Account<'info, ExampleAccount>;  8] 
}
` ‚Äú

Or should i manually type out all the accounts it expects?
Ok, yeah, you unfortunately have to pass those accounts in from the client somehow (and probably mark them as mutable, `#[account(mut)]` in the instruction's `#[derive(Accounts)]` struct)
I just wanted to pull out the account data from the pubkeys stored in the PDA parent account and just update an attribute for them
when testing i'm grabbing anchor's workspace
wait nm, not sure how i could be passing the wrong programId
Ohh okay, I see. If you were to make it a cross program would it then be possible?
And what do you mean to make them mutable?
This unfortunately doesn't really work in solana, if I'm understanding you right‚Äîyou have to pass all accounts your program wants to read or write in from the client, no dynamic lookups allowed (going from Pubkey --> AccountInfo within the program).
Hello, could someone point me in the correct direction for this?

I have a program derived account set up which has an array of Pubkeys referencing other previously created PDAs. 

I was wondering if I could create an iter to loop through those sub Pubkeys and read the data from them? Preferably to make the mutable. 

Would someone happen to have an example for how this could be accomplished?
ty ser lolol
i'm dumb or more like blind
omfg
You're probably doing `Program<'info, SomeProgram>` but passing the wrong address for that program
0xa8 = 168 = InvalidProgramId
logs: [
    'Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS invoke [1]',
    'Program log: Custom program error: 0xa8',
    'Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS consumed 2804 of 200000 compute units',
    'Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS failed: custom program error: 0xa8'
  ] this means invalid number of signatures correct?
but only the token made from ido-pool has this issue.
okay, but regarding to the spl-token (from cli), it is added even though I have no that token.
but at least with the mint and amount
of course without the nice name
yes
you mean when I receive that token, it would be showed automatically?
tokens automatically show up in your wallet
you can use it without
you don't actually need to add metadata to use it
interesting i didn't know phantom does this
why cannot I add the redeemable token into my wallet?
Here, I have one doubt.
Hey, guys, I run the ido-pool project in my local

I got it. I think I deleted the meme.json in the idl folder by accident. I pasted it back in there
Yeah, this one
You mean when I set it...anchor.workspace.<myName>? If so then yes...I'm following a tutorial and I have it set to anchor.workspace.MemeNum
Sorry, I'm not explaining myself very well‚Äîthere ought to be a different "accounts" section, at the same level of nesting as "instructions" (so not that one, look further down in the IDL). It will have information about what the accounts look like, their member data types, etc.
Do you need more?
Almost‚Äîthe "accounts" section
this one?
Do I have to run anchor deploy first?
I'm getting an 'error loading workspace idl' when I run anchor test. However, I do see the IDL JSON file in the target folder. Anyone know the source of this? It say 'Error: No such file or directory (os error 2)'
Ah, no, in the the `target/idl/<your_program_name>.json` file


sure.
Can you post what your target/idl "accounts" section looks like for the program?
<@!134416332509675520> , could you check my issue please? ü•∫
So I guess you're trying to upgrade a deploy but are running out of space in that account (not sure how it got sized originally)
Ok, not 100% sure why this happens, but https://explorer.solana.com/address/GVnuruV5aNMVbVuQyQGbQwW3ERi5VSiTrif6dU5jztiz?cluster=devnet only has 300kb allocated for it
my understanding is that's not even close to the limit
nah it's only about 300kb. this is one example of a failed deploy: https://solscan.io/tx/2MMskynBopNsmnocFUKsVe42nfBo71r5sfiyaCvCwhM51KoVqZgoM8mZ64Yuj3DBj3Kvys99RuXyW6RfkuaxwCZy?cluster=devnet
^^^ Thanks a lot folks! üëè
I defined the stakeAccount here.
I am running this code. But dataProgram.account.stakeAccount is undefined.
.clone()
Never mind... I just needed to do .clone(
Do I need a zero copy here?
this example is great
Just in case anyone references my question in the future, heres what I changed: 

‚Äú`
....
    #[account(init, seeds = [user.key.as_ref()], bump=_bump, payer = user, space = 5000)]
...
` ‚Äú

Front end: 

"` 
const [pdaAddress, nonce] =
await anchor.web3.PublicKey.findProgramAddress(
  [user.publicKey.toBuffer()],
  program.programId
);
`"
Omg it worked! Thank you so much üòä
The part you're missing here is that in order to `init` an account at a program-derived address, you need to specify its seeds + bump (this is so the program can sign for the address when asking the system_program to allocate an account there): `#[account(init, payer = user, space = 16 + 16, seeds = [the, seeds], bump = the_bump)]`
Ouu thank you. let me try this üôÇ
Here's a related example in case helpful https://github.com/cqfd/anchor-visitors/blob/master/programs/visitors/src/lib.rs
You can use a public key as part of your seeds as `seeds = [their_account.key().as_ref()]`
PublicKey.findProgramAddress + PublicKey.createWithSeed (maybe)
Thank you! yep, i'll let you know if i find a solution too. I tried using the user public key but was getting nasty errors
I need to head out now but I will nail this down later and ping you. I think we need to be using bumps/nonces + the user public key
this works for me but the seed is static then üò¶ and i want to be able to generate the PDA without a statically typed seed
I am stuck on this exact same thing right now 

so far I got this working to generate 

`
#[derive(Accounts)]
#[instruction(_bump: u8)]
pub struct Init<'info> {
    #[account(mut, signer)]
    pub user: AccountInfo<'info>,
    #[account(init, seeds = [b"your_seed".as_ref()], bump=_bump, payer = user, space = 5000)]
    pub pda: ProgramAccount<'info, PdaState>,
    pub system_program: AccountInfo<'info>,
    pub rent: Sysvar<'info, Rent>,
}
` 

And then on the client side i have this: 

`
const [pdaAddress, nonce] =
await anchor.web3.PublicKey.findProgramAddress(
  [Buffer.from("your_seed")],
  program.programId
);

await program.rpc.createUserPda(nonce, {
    accounts: {
      pda: pdaAddress,
      systemProgram: SystemProgram.programId,
      user: user.publicKey,
      rent: anchor.web3.SYSVAR_RENT_PUBKEY,
      systemProgram: SystemProgram.programId,
      clock: SystemProgram.SYSVAR_CLOCK_PUBKEY,
    },
    signers: [user],
  });
`
This is helping!
?
```
#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 16 + 16)]
    pub pda: Account<'info, UserData>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```
If I wanted to generate a PDA from a users address, how would I go about that? Would I start with:
```
anchor.web3.PublicKey.createProgramAddress(
  [user.publicKey.toBuffer()],
  programId
);
```
Hmm, interesting. Is your target/deploy/progname.so file huge or something?
i'm trying to deploy a program via anchor, and it's failing with the error "account data too small for instruction." when i take logic away from the program (comment out different sections), it deploys fine. does this mean i'm at the size limit for a single executable account? or is the account space i need not getting calculated correctly
thanks. checking this
There's some in tests/misc. Also see https://discord.com/channels/889577356681945098/889606719829835816/901126428848975903
is there any tutorial / examples for using PDA's in Anchor?


///////////////////////////////////////////////////////////////////////////////////////////////

Ah, ok, what does `err` look like?
i can see it hitting the error line in `rpc.ts`
starting setting breakpoints, stepping into function calls
How did you trace it down to that line above?
just that console log

no nothing at all
If you open up the chrome console etc., do you not see any program logs?
everything works fine from cli
from a UI
i am hitting this with a candy machine and tracing through dev tools this is where the error is happening
Right, I mean from the program itself, not just in JS
no its hitting the line where it just returns an `err` https://github.com/project-serum/anchor/blob/0a660d26c4ae65a772d2ef76623f6c468adf1d58/ts/src/program/namespace/rpc.ts#L29-L30
Do you get any program logs? Anything about a custom error etc.?
i am failing here https://github.com/project-serum/anchor/blob/0a660d26c4ae65a772d2ef76623f6c468adf1d58/ts/src/program/namespace/rpc.ts#L24-L25 but able to mint from CLI . it is hitting the catch line that does not have a `translatedError`  so i am essentially failing silently does anyone know what the error could be ?
Anyone got some resources on listing all tokens in a collection? Or can tell me what this person referring to by "creator index": https://gist.github.com/creativedrewy/9bce794ff278aae23b64e6dc8f10e906#gistcomment-3924913
Dope PFP btw
Ok.... Thanks!
Measure it and find out!
Probably ~5k compute if I had to guess.
Thanks!
Do people know how much more expensive CPI calls are than just building like a million fuctions in one contract?
Check this out https://github.com/cqfd/anchor-token-studies
I have a program that I'm building where the `Initialize()` function constructor would ideally also initialize a new Wallet for a particular mint (also known as token)
Hi guys does anyone have experience with initializing a new `Token` account in Anchor?
hi guys, how can i define a vector of structs in account data?
Guys, can I somehow apply multiple `memcmp` filters on getProgramAccounts() as `OR` instead of `AND`. 

Looking for the same address in two different spots in memory, would love to fit in one  `getProgramAccounts` call?
let me try run https://github.com/chronologic/deep-waifu-payment-contract/blob/71ad0da3b1741fcb748ff064d897a41a0ce21056/programs/deep-waifu-payment-contract/src/lib.rs#L119-L122 with anchor 0.17 and see if it raises the same issue. it's super similar to this..
guys can someone refer some projects which store data? it will help me for my project.
am sure am correctly passing the bump in the js client..
```#[derive(Accounts)]
#[instruction(bump: u8)]
pub struct InitializePool<'info> {
  #[account(init, payer = admin, space = 8 + 225, seeds = [b"poolaccountv1".as_ref()], bump = bump)]
  pub pool_account: Account<'info, PoolAccount>,```
maybe it's on the curve for user wallets, pdas need to be bumped off it.
I was wondering if you might have forgotten the bump seed
i think it's an issue with a pda that is being initialized...
is that a program address or a generated pubkey?
hmm, we'll its via `anchor test`
Looks like you're trying to deploy a program that's already deployed. Localnet?
anchor 0.17
please help:
```   'Allocate: account Address { address: 4APtKxnJ9cSgzceRCNL4Cd29NT6J1Ts7qUTVkNfiJhdm, base: None } already in use',
    'Program 11111111111111111111111111111111 failed: custom program error: 0x0',
    'Program DifxjdFwqvcqL6nnGkq6ihnvoBWDViSGYHn73MqAvLGd consumed 200000 of 200000 compute units',
    'Program DifxjdFwqvcqL6nnGkq6ihnvoBWDViSGYHn73MqAvLGd failed: custom program error: 0x0'```
The way you open/load the file might be wrong I suppose
Or you can also upload it onchain and fetch in the front
Right, that's the file I copied over into the aforementioned idl.json file
It is outputed in the target/idl folder
Is this not automatically generated upon an `anchor build`?
Probably the idl.metadata that is not loaded (metadata being 'undefined' here)
Is this coming from the IDL side of things or my reading of the IDL? Has anyone encountered this before?
I'm trying to build a React-based front end for my Solana program. Much like in Nader's full-stack Solana guide, I import my idl from the `idl.json` file copied over to the `app/src` directory, but I'm getting the following error:

`const programID = new anchor.web3.PublicKey(idl.metadata.address);` throws
`Unhandled Rejection (TypeError): Cannot read properties of undefined (reading 'address')`
had anyone setup github workflow to deploy and test on devnet? Like create a keypair and sed the adress in `anchor.toml`/`declare_id()`. Is that dumb, any less convoluted way? (I cannot test on localnet, I've tried I swear https://mirror.xyz/0x9fEcc73Da3f8bd2aC436547a72f8Dd32326D90dc/u05KU4oE4tnlI4Z5Yj-TAQSq8bgZuu4Mv2s3wblpkTs )
Ok
Hmm, interesting. 0xaa = 170 = AccountNotSigner, which gets raised by the `Signer<'info>` type saying "uh, this account didn't actually sign the tx".
hello sirs! ive been trying to use of those big accounts without the 10kb pda limit for my program however am not really having any luck so im wondering if anyone here could lend a helping hand 

Im trying to create an account and run the create method in the same RPC call similar to the way its done with the Config file for the candy machine here however i just get a  unknown signer error.. this is probably since the create method no longer requires the generated keypair to sign, however it still needs to sign the create account instruction no?https://github.com/metaplex-foundation/metaplex/blob/6209ced0572754d6ee66c194f3e47e0670a484e7/js/packages/cli/src/helpers/accounts.ts#L49
üëç
<@!430438036761870356> Can I dm
not sure then, could you share your initialization function
I am not able to find what 0xaa means <@!430438036761870356>
Yes. It has. It is failing with a custom program error 0xaa
does the account sending the transaction have enough SOL on devnet?
<@!430438036761870356>
It is basically a initialization of a contract. In that initialization I create a new mint
why I am getting this issue after upgrade solana version from 1.7.11 to 1.8.0?

What is the transaction supposed to do?
Where can I look for the custom program errors. What does custom program error OxAA mean
Hi guys,
I am trying to run a program on devnet. I works fine in localnet while using anchor test
For some reason, the same program when deployed to devnet stops working while submitting transactions.

Any clue why that would be??


Phantom says txn may fail to confirm
which it does
Can that be done on chain or should it be fetched through js first?
Yo guys, how can I go about getting an AccountInfo struct (I need to know the owner) for a public key in rust?
or find out from solana docs what the default "state" of an account is. It's possible that if the account is not init then there won't be any data / space to borrow. But I don't know that for sure
send in an uninit account and see what happens
you should just try it
you want to know when it won't be able to borrow
the second clause of your sentence is hard to parse
`under which conditions would the data of an account be borrowed mutably causing the functions about to error/panic`
I'm just trying to understand, like when someone calls my program's instruction, under which conditions would the data of an account be borrowed mutably causing the functions about to error/panic
yes
these all seems like wrappers around more low level rust commands, like <https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.try_borrow_mut>
and error if you can't
so really you should just try to borrow the data mutably ü§∑
yes
just looking at the source all they do is try to borrow the data and fail if they can't
they just return bools
neither of those functions mutably borrow the data from looking at the source
like, in which cases the error/panic would occur
right, I'm trying to understand when the data would be mutably borrowed
and you just put a `?` at the end of the call
`data_is_empty` would panic inside the function like you said
well if `try` fails it returns a program error
right, just want to understand what this does
`Result<T, ProgramError>` is really more standard in anchor

`Panics if the value is currently mutably borrowed.`
i would use `try`
I know one panics the other errors
probably something about their return values, i haven't done a lot with zero copy stuff either yet
I don't know rust well enough yet to understand these conventions
one calls borrow, the other try_borrow
do you know the difference between normal functions and `try_`?
(assuming that's not what `data_is_empty` already does)
you could find out what the default value is for uninitialised accounts and check against that
those sound like reasonable thing to try
there is `data_is_empty` and `try_data_is_empty`
this is for `remaining_accounts` for various reasons
it's kind of dangerous to just YOLO in an account and load up its data, so it's not done all that much
mostly the "checking if an account has been created" happens during the account deserialization step
depends on the context
is there a canonical way to check from rust/anchor if an account has already been created?
Anyway, discovering Javascript B)
Yes I did add a "skipDependencies" and it works. Also I had a very old version of tsc
you shouldnt be importing from the dist file
Seems quite weird, which version should I use for target and module in Tsconfig?
Trying to add anchor to a Typescript project, I get some weird issues with syntax errors in the fetched node_module<:pepeThink:844646497911046164>
yarn tsc --version 3.9.10
The value of "offset" is out of range.aaccess_control
thanks!
ok got it
Need to crank the entire queue, so unlikely to do in a single tx.
or it's not something one would do in the same tx?
is there a crank instruction I can CPI?
got it
For the reasons you stated above
Since you probably can't close it in the same tx.
It's safe but not a great idea.
is it safe for me to create a new open orders account for each order?
In the existing orderbook, we'd have to issue a new instruction for that probably.
I haven't looked into it but it might be more easily done in the new "AOB" version of the dex bonfida has been working on.
I mean "init -> place order -> settle -> close" flow
Not cranking, no. That will always be necessary, since you can't know apriori which accounts to give when issuing a taker order. I.e. you won't know who you will get filled against because it's data dependent.
you said this part is fixed in the next serum release?
ah got it
Processing the event queue.
what's the tldr of what cranking is?
Order cancels need to be cranked, for example.
Cranking is usually the solution.
what I'm gathering is roughly that some longer-term operation has to happen first so open order accounts can't be closed immediately?
ping <@!831450660146642974> in case you figured it out
but I don't understand the solution (crank?)
there is some discussion about it here https://discord.com/channels/889577356681945098/889577399308656662/898027579313913907 (I seem to be hitting exact same problem)
it seems to be `open_orders.free_slot_bits != std::u128::MAX` codepath
I settle right before it, settlement succeeds, and then I get this error when I try to close
has anyone seen error 0x2a (TooManyOpenOrders) on closing the openorders account?
Does the `#[account(init)]` macro create a System account owned by the program or an actual PDA?
```rust
[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 8 + 32 + 8 + 4 + 32 * 1000)]
    pub whitelist: Account<'info, Whitelist>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```
ah yeah, solana test validator was runnign in background
it's unable to deploy your program to local validator before commencing tests?
anyone know why tests would timeout as soon as i declare it() Error: Transaction was not confirmed in 30.01 seconds.
https://github.com/project-serum/permissioned-markets-quickstart/blob/master/tests/utils/market-lister.js#L46

I see this, though this is a market created with keys generated on the frontend. If I use PDAs for the base/quote vaults, I think I need to invoke this from Rust in the contract right?
Yes - that worked, thank you!
there is a boostrap repo thing
check the permissioned market example or repo
<@!501570363566587905> Any suggestion here? I'm just using `solana_program::program::invoke_signed` for now
THANK YOU
Does this work? https://discord.com/channels/889577356681945098/899315988087054397/901127804245123142
Here's some more context on my question -

```
    pub enum MyEnum {
        Value1,
        Value2,
        Value3,
    }
    pub fn create(ctx: Context<Create>, authority: Pubkey, val: MyEnum) -> ProgramResult {
        ...
        Ok(())
    }
```

Is there a way to directly use `MyEnum` that's generated from the IDL in TypeScript?
Hey Alan - pardon the direct reply but I think may have a related question üòÖ. I have an argument to an instruction that is an enum type in rust. I can see that the type exists in the IDL under the `types` array, but I can't seem to figure out how to use this enum from the TypeScript client. Any chance you or someone else could point me in the right direction for using this type?
Finally started using the generated typescript types, this stuff is so fun üôÇ
Heh thank you ser!

I chatted with more guys seems like they aren't bringing the rebase mechanic but Olympus DAO. Equally exciting
I think thats set at `[programs.localnet]` in Anchor.toml
Has anyone used this function before: `update_metadata_accounts`???
When running anchor test
Error: failed to send transaction: invalid transaction: index out of bounds
This is the error I get on localnet
Is there an example of initializing a market in Serum from rust in anchor? I'm looking for an anchor equivalent of this: 
https://github.com/project-serum/serum-dex/blob/master/dex/crank/src/lib.rs#L1245
I ran solana-keygen new...well that was on localnet that I ran that I think
Any idea what might be causing this?
Error: Account ... is not an upgradeable program or already in use
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }.
I was having an issue running anchor test on localnet, so I switched my config over to the testnet and ran anchor test and got this error response when it tried to deploy...
i'd be similarly interested in a token that represents reputation and has a decay (negative interest)
(redirects to https://solana.com/)
lol i just clicked on wagmi.finance in your twitter, so good
so I've set `declare_id` to the on chain address of my program, but my test suite now fails because the program is deployed to a different address on the local test chain, how do I set the address of a program on the local test chain


///////////////////////////////////////////////////////////////////////////////////////////////

is there any other way to remove account or not depending on some checks?
I tried using close method from anchor, but when I load the account before using it
```
        let lower_tick = ctx.accounts.lower_tick.load()?;

        close(
            ctx.accounts.lower_tick.to_account_info(),
            ctx.accounts.owner.to_account_info(),
        )
        .unwrap();
```
I'm getting:
`'Err' value: AccountBorrowFailed'`
is there some common convention?
basically we recognize that there really isn't a need for 18 decimal precision
I see, that makes sense!
In spl-token decimal usually 6 / 8 / 9 (it's actually can be any number which can be stored in u8)
```
>>> 2 ** 64
18446744073709551616
>>> _ / 1e18
18.446744073709553
```
Maybe I'm not getting something right, but with 18 decimals token representation, you can only have a max market cap of 18 tokens?
are decimals presented the same way as in ETH? big unsigned integer with a decimal definition?
interesting
In spl-token u64 is used as storage for amount
u64
in Solana, are are token balances represented? is it still u256?
u128?
what data structure should I be using?
In Anchor, what is the best way to pass in as parameters an unsigned integer > 64 bit?
Hmm... not sure then. If `anchor --version` is up to date and your editor isn't complaining about your source, not sure why idl generation would fail.
yeah, did that as well
okay, let me check
Have you upgraded your anchor cli too? It can get confused during idl generation if you're using new anchor_lang features etc.
You ordinarily wouldn't be calling `try_accounts` yourself‚Äîwhat are you trying to do?
upgraded to anchor 18, now `thread 'main' panicked at 'Code not parseable: Error("expected `,`")', lang/syn/src/idl/file.rs:338:58` after the build and deploy.

anyone seen this before I dive in?
so, what value need to delivery to 3nd parameter? I used `&[]` now
It's the raw instruction data (part of what solana itself passes your program).
What is latest parameter of try_accounts function?
old version had 2 arguments. but now, it is require 3 arguments.
okay, thank you
Should maybe move this to the Rust channel, since it's not anchor related.
oh
Oh, sorry, I'm unable to read today‚Äîno, you'd manually implement Default for `RewardVendorKind`, not RewardVendor itself

It is requiring other fields.
Yep (forgot you can't derive Default for enums‚Äîlike you said, have to do it manually)
so, need to implement manually. right?
`impl Default for RewardVendor {
    fn default() -> RewardVendor  {
        RewardVendor {}
    }
}`

It would work?
Need to also tell rust how to derive Default for your enum (if rust is going to make a default instance of the struct, it will of course have to pick something for that enum member).
The issue is just that you're deriving Default on a struct that has a member that doesn't derive Default too‚Äîthat doesn't work.
Ah, sorry, I just reread your example more carefully‚Äîforget the `space` / `init` part, sorry
No, the `space` and `init` part would go in the `#[derive(Accounts)]` struct.
`#[derive(AnchorSerialize, AnchorDeserialize, Clone, PartialEq)]
#[account(init, space = 8 + 8)]
pub enum RewardVendorKind {
    Unlocked,
    Locked {
        start_ts: i64,
        end_ts: i64,
        period_count: u64,
    },
}`

Like this?
One way to fix it is to specify `space` yourself, but you could also just follow the rust compile error, and add `..., PartialEq, Default)]` to that derive block you posted, above `RewardVendorKind`.
That means you aren't manually specifying `space = ` in some `#[account(init, ...)]` somewhere.

I am going to use below code
`
#[account]
#[derive(Default)]
pub struct RewardVendor {
    pub registrar: Pubkey,
    pub vault: Pubkey,
    pub mint: Pubkey,
    pub nonce: u8,
    pub pool_token_supply: u64,
    pub reward_event_q_cursor: u32,
    pub start_ts: i64,
    pub expiry_ts: i64,
    pub expiry_receiver: Pubkey,
    pub from: Pubkey,
    pub total: u64,
    pub expired: bool,
    pub kind: RewardVendorKind,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, PartialEq)]
pub enum RewardVendorKind {
    Unlocked,
    Locked {
        start_ts: i64,
        end_ts: i64,
        period_count: u64,
    },
}
`

But this is getting an error.
If you don't specify space yourself, anchor will use the `Default` impl for the type‚Äîwhich doesn't work well for variable sized types like Option or vec, since the default is None/an empty vec, which won't have enough space.
it works when I set the space! does anchor try to guess the space if I don't specify it manually?
That shouldn't have any effect (PDAness is about the address, not the account‚Äîit more or less only affects how you sign)
I'm using PDA for this
Not sure what's not working for you, but it's fine to serialize an `Option<T>` into an account. Just need to make sure you have enough space for it (borsh will require however many bytes a T needs, plus one for the optionality)
People underestimating the space they have to deal with is better than overestimating
Nope, it doesn't include it (maybe it should though?)
Does the `space` annotation include or disclude the 8 bytes for the discriptor?
https://docs.rs/anchor-lang/0.18.0/anchor_lang/derive.Accounts.html
after some debugging.. I can't interchange between `None` and `Some()` but setting just one of it works
Or maybe the wrong issue, the point is, enums aren't working right now, sadly
https://github.com/project-serum/anchor/issues/806
when I `impl Default` manually and set it to `Some(0)` it works but `None` doesn't work
is it not possible to deserialize `Option<T>` type?

getting this error when using it `Error: 164: Failed to serialize the account`
Thank you!
some real world resources.  similar yet different than what you're discussing.
https://github.com/step-finance/reward-pool/blob/main/programs/reward-pool/src/lib.rs
https://github.com/step-finance/step-staking/blob/generic/programs/step-staking/src/lib.rs
Yes, indeed!
Let's call them ... I don't know .. synthetic tokens. A user can stake their tokens and will receive synthetic tokens as a proof for their stake. These tokens are also owned by a pool, but they can be withdrawn at any time without any unstaking period. But if users do withdraw them, rewards are stopped from being given to them, and after these tokens are traded the other user will put them into a pool again and will start getting rewards again
I can point you to Step Finance's single token staking (ala xSUSHI) and farming contracts if you want examples of very similar things.  But if I'm understanding what you're attempting to get at - tradable tokens that represent farms including pending rewards of OTHER mints, that becomes a difficult problem to solve for.
Well, staked tokens are still there in the pool, I'm talking about the tokens they receive for staking them
then why have the "pool" at all
the first user won't get rewards as they took this token from a pool
yes
Is that what you're trying to solve for?
what if a user trades away some token to another user, and another user stakes it also
Yeah, off chain programs are no go
But then they wouldn't be able to trade and reap the rewards at the same time, which is unfortunate
It is possible to write a program that pays rewards to users based on their activity on the chain - but again, it would require a offchain program to periodically find eligibility and issue rewards via direct distribution or merkle.
Then after users trade (however they want), the user with tokens will put them into a pool, and the rewards will continue trickling to their specific accounts
It's not solvable with fungible tokens by nature. All tokens of a given mint are equal.
So far I came up with a solutions to either let users transfer stakes directly on my pool or to store this staking token as being owned by my program and and allow them to retrieve those tokens at any time, but it would also stop giving them rewards for those
ah yes, this is a complex problem that I've gone down the path of.  a transferrable farm token essentially.
Yeah, but the rewards are given in a different token, so there is also a pool of rewards based on how long people hold those staking tokens
thus, a token represents a share of a pool.  so transferring it transfers the "stake" effectively.
"swap stakes based on how people transfer those tokens"
perhaps instead look at users all staking into the same vault, and issuing a token representing share of ownership over that vault.
there is no way to do that onchain.  you'd need a program querying the chain for that.
Also a bit of an unrelated question, is there a way to add a callback or somehow to subscribe to all `transfer`s of my particular `mint` in a `spl-token` program? I want to issue tokens for staking and then swap stakes based on how people transfer those tokens. So far I don't see a simple way of doing it, as I used to do it in Solidity before. There are workarounds I came up with, but they all feel ... wrong
Thank you!
you're exactly correct with the drawbacks.  you could use this derivation path to instead store a user proof registry account with vector of up to 10 proof accounts for that user. (as an example of a solution)
Yeah, I mean it is fine so far, just wanted to be aware of possible drawbacks
like how many would you expect to have? 1, 2 maybe, 50k often?
yep! it's one of the design challenges on solana.  several solutions but depends on some factors of your program
for a given account of course
The only thing, I'm not sure how much of a problem it will be, but I can't get more than a single address this way, so just a single proof will be possible
bingo
So users don't need to store anything and any other dapp will be able to easily find it (thought it would need to know seeds)
against a particular program, yes
I see. To reiterate, pdas here are used as a derivable address of a specific account, right?
Typically, thats where derivation comes in - although other mechanisms are possible including registry accounts at known addresses and such.
Look at it another way - if Step Finance wanted to add these Proofs to our "Dashboard of Solana", how would we find the accounts for a wallet?
And they will have an address to it
They can create an account, pass it to an instruction, which will initialize it and set ownership to my program
how does the user know it?
And `user` and `pda` inside it (at least in my case) will be used for verification
The user will provide it
How does the dapp get the addresses of the Proof accounts?
Store it where?
But I see how PDA's are superior (though it would mean I can't have more than a single `Proof` it seems)
Or it could store it at initialization, this is how I've been doing things before
correct.  otherwise a dapp would have to query ALL program accounts looking for one for their wallet
And with pdas I won't need to store user's pubkey and will be able to find this account solely based on their pubkey
for a user to know if they are staked in my imaginary staking program, they find the program address associated with that wallet and look on the chain for an acocunt
So far I've been doing things like that
```
#[account]
#[derive(Default)]
pub struct Proof {
    /// An address of a user who unstaked their funds
    user: Pubkey,
    /// An address of a staking pool funds are unstaked from
    pda: Pubkey,

    /// When funds can be unlocked
    applicable_at: i64,
    /// An address of a blocked account
    user_unstaking_wallet: Pubkey,
}
```
That's what I said!
The user is a wallet.   A single address.
Thank you!
Ah, I see. So the user doesn't need to store lots of accounts, right?
To allow a user to find it! In addition, if the program is creating the account - it has to be a pda.
What would be the point of storing the details specifically at an address, derived from their wallet? I thought all I needed to do was to set my program as an owner of the account?
this is in fact how associated token program creates token accounts for wallets.
For instance, if I have a staking program, an account storing the details about a users stake could be held at a pda derived from their wallet's address as a seed.
<@!788122420765917184> you can use pdas in many ways. you dont have to bother storing their addresses because they are derived and you can use them for arbitrary program accounts, or token accounts for things like vaults, or even mints, etc, etc.  As you're seeing they can also not be accounts at all but just signers, or *authorities* as we call them by convention in that case.
I'm mostly using it in exactly the same way escrow does here.
https://github.com/project-serum/anchor/blob/master/tests/escrow/programs/escrow/src/lib.rs
In no way did I mean to infer that.
Am I missing or misunderstanding something?
```
**    #[account(
        seeds=[b"instance".as_ref(), user.key.as_ref()],
        bump = instance_bump,
    )]**
    instance: AccountInfo<'info>,
```
But it seems like people use it for some different reasons as well, say here
Also can somebody explain how PDA's work exactly? And even more importantly what is the agreed upon way of using them? What `seeds` attribute is used for? When adding `init` attribute who is the owner of created account otherwise? 
Right now I find `pda` on initialization, store it in my `account` and use it when I need to take userspace ownership of user's `spl-token` accounts and such
I see, thank you!
https://github.com/project-serum/anchor/pull/905/files#diff-007f92356afd74981ae6c71437fabf5e344967031ce67f10e026e450ef71b546R70
just because you didn't identify any issues it doesn't mean it's inherently safer
yes, there's a custom constraint error, check the anchor change logs for deets
Is it currently possible to write an additional error message with `has_one` and `constraint` attributes?
maybe try anchor deploy instead of trying to run solana program deploy
I run `anchor build` and I got `solana program deploy /my.so` command.
when I run this command, I am getting an error.

Error: ELF error: ELF error: Multiple text sections, consider removing llc option: -function-sections

what is solution?
I‚Äôm aware of how PDAs would have been another choice, but if using has_one in all places those accounts are referenced, help me understand what would be the flaw. 

Usually I‚Äôd just use has_one and a reference when the account is too large to be a PDA, but in this case I inherited it already written as is and I identified no flaw.
sorry, i guess i just don't understand the particular problem you're having
ok, thank you for getting me back. I have checked the ido pools and others over 2 weeks. but I found it is not fit for my demand.
if you need some variant of that then you should probably play around with the code to understand it and get something that works for you
but ido pool initializes a token mint and then mints tokens to users
sorry i don't know anything about token lists
I am sorry I think no. 
I mean, for example, I did like the following.
I created one token with spl-token cli and upload this token info and symbols to github solana token list (https://github.com/solana-labs/token-list/tree/main/src/tokens). After 12 hour, I could see that token name/symbol etc from solana explorer devnet. also when I import that token address into my Phantom wallet, I can confirm that token from my wallet.
#1 But I am not sure if it is possible with "redeemable_mint" from ido pool. when I import it "redeemable_mint" into my wallet, It was not imported. it's wired.
#2 If I get "redeemable_mint" address, can I upload this token info to github  (https://github.com/solana-labs/token-list/tree/main/src/tokens) so that we can show our token to customers like USDC or another coins?
ido pool does this with the redeemable mint
Hey, everyone. Thank you for your support. I have had some advantage from my work.
I have one suggestion. If  you could make this one, I am so appreciate and i think it would be helpful for the beginners.
For now, ido-pools and another samples, it create pda and init it with token info, then mint/burn/transfer it.
It works great but I wanna mint our custom token in the program. (for example, if I am owner of USDC coin, I wanna let the program the ownership of USDC mint and mint the USDC to users). Maybe I am wrong :).
I hope to get this example soon. thank you again for support.
i didn't define it, but i rectified it.
`0.18.0` is latest version available, https://crates.io/crates/anchor-lang/versions
hi guys, how to tackle this problem?`failed to select a version for the requirement anchor-lang = "^0.18.2"`
(henrye from twitter here)
<@!99911938955309056> it's worth spending the couple of days to upgrade the step finance thing to use PDAs everywhere and some of the more recent features of anchor. The IDO pool exploit could have been avoided if it had been upgraded to use PDAs everywhere
https://github.com/metaplex-foundation/metaplex/blob/master/rust/auction-house/src/lib.rs#L1151-L1212 wow that is some complicated pda seed
The npm cli version is ahead of the rest of the packages. You can cargo install 18.0 instead

I installed anchor 0.18.2 and tried to "anchor init projectName", but I can see this issue. Waht is wrong?
I literally saw that file like 10 times hahahah. Still it aint maaking sense tho üò¶
hello everyone! is there a good way to mock the Context object on the rust side to do unit testing? If not, seems like the way to do so in many examples is to write integration tests on the typescript side. Is there a general structure we should follow to get accounts into a certain state for a particular unit tests? If an instruction depends on a bunch of other instructions to initialize states, it can get a bit cumbersome
I'm not familiar with the program either/also a finance noob, but there are a bunch of different fees that get charged whenever you do anything: https://github.com/solana-labs/solana-program-library/blob/master/token-swap/program/src/curve/fees.rs#L13
Hey hey. Trying to learn the TokenSwap Program. I kind of understand the nuances behind, but just confused on the following fee variables/use cases, due to me being a noob in finance as well

```
const TRADING_FEE_NUMERATOR = 25;
const TRADING_FEE_DENOMINATOR = 10000;
const OWNER_TRADING_FEE_NUMERATOR = 5;
const OWNER_TRADING_FEE_DENOMINATOR = 10000;
const OWNER_WITHDRAW_FEE_NUMERATOR = SWAP_PROGRAM_OWNER_FEE_ADDRESS ? 0 : 1;
const OWNER_WITHDRAW_FEE_DENOMINATOR = SWAP_PROGRAM_OWNER_FEE_ADDRESS ? 0 : 6;
const HOST_FEE_NUMERATOR = 20;
const HOST_FEE_DENOMINATOR = 100;
```

Could someone explain me when would trading fee/owner_trading_fee/host_fee be used for?
`has_one` does not work on Loaders, correct? It seems no error is propogated when using on Loaders
According to https://docs.rs/anchor-lang/0.18.0/anchor_lang/derive.Accounts.html
No worries! You're kind of lucky tbh you tasted that gotcha early, it can be pretty tricky to debug lol (can search the discord, many examples of it).
YAS works!
apologies for that slip, I thought it would do pattern matching
okay sorry
ugh O_O
You've flipped the order of your bumps in the `#[instruction(...)]` bit (they have to match exactly, unfortunately)
Technically yes but that would be incomprehensibly unlucky (each bump has about a 50/50 chance)
Is there ever a chance that PDA fails to be generated, beause no bump is available (all 255 slots are on secp curve)?
of course! thanks Alan

```
#[derive(Accounts)]
#[instruction(wallet_bump: u8, instance_bump: u8)]
pub struct Initialize<'info> {
**    #[account(
        seeds=[b"instance".as_ref(), user.key.as_ref()],
        bump = instance_bump,
    )]**
    instance: AccountInfo<'info>,
    #[account(
        init,
        payer = user,
**        seeds=[b"wallet".as_ref(), user.key.as_ref(), mint.key().as_ref()],
        bump = wallet_bump,**
        token::mint = mint,
        token::authority = instance,
    )]
    wallet: Account<'info, TokenAccount>,
    mint: Account<'info, Mint>,
    user: Signer<'info>,
    system_program: Program<'info, System>,
    token_program: Program<'info, Token>,
    rent: Sysvar<'info, Rent>,
}
```

```
pub fn initialize(ctx: Context<Initialize>, instance_bump: u8, wallet_bump: u8) -> ProgramResult { ... }
```

This is how I'm calling it in the JS

```
 let [ instancePubkey, instanceBump ] = await anchor.web3.PublicKey.findProgramAddress(
      [Buffer.from("instance"), provider.wallet.publicKey.toBuffer()], program.programId,
    );
    
    // Find PDA that should correspond to the wallet for the program
    let [ walletPubkey, walletBump ] = await anchor.web3.PublicKey.findProgramAddress(
      [Buffer.from("wallet"), provider.wallet.publicKey.toBuffer(), tokenMint.publicKey.toBuffer()], program.programId,
    );
    const tx1 = await program.rpc.initialize(instanceBump, walletBump, {
      accounts: {
        mint: tokenMint.publicKey,
        instance: instancePubkey,
        wallet: walletPubkey,
        systemProgram: anchor.web3.SystemProgram.programId,
        user: provider.wallet.publicKey,
        rent: anchor.web3.SYSVAR_RENT_PUBKEY,
        tokenProgram: spl.TOKEN_PROGRAM_ID,
      },
    }); // THIS fails
```
This means you're somehow not always providing the right bump for those seeds. This could happen in a variety of ways though, so may need to post more about how you're setting the bump in your Accounts struct, etc.
Is there any reason why I periodically get
```
Could not create program address with signer seeds: Provided seeds do not result in a valid address
```
source code doesn't change
Thank you ser
Not docs, but the ido-pool test has a bunch of examples https://github.com/project-serum/anchor/blob/master/tests/ido-pool/programs/ido-pool/src/lib.rs#L308
<@!501570363566587905> is there any documentation that would allow me to understand how I can create a `Token` account within an Anchor program execution? I don't really want to use `associated_token`
Indeed. See `tests/misc` for an example.
I see, so you can read events as part of event simulattion? cool
You can approximate this by emitting an event and simulating the transaction on the client, reading the event as the returend data.
<@!501570363566587905> in Solana can we use programs as "read only" essentially as getter functions to read data and return some output without manipulating state? (like `eth_call` does)
Ah
Not the end of the world--especially when we get 1mm compute in 1.9--but worth keeping in mind.
The bummer about `associated_token` is that you need to run find_program_address each time.
You can actually now do some kinda slick stuff in anchor for associated token accounts: https://github.com/cqfd/anchor-token-studies/blob/main/programs/token-studies/src/lib.rs#L115
ya, it does. I think the paulx escrow tutorial does it manually, but I'm sure some of the other tests have examples.
actually, nevermind, I think that requires the associated accounts to be created upfront
would check tests/escrow for examples on how to init spl token accounts
I see! thanks
It will (the extra args change the behavior of `init`‚Äîmaybe a little confusing)
won't that just write some properties in the buffer? it won't change the ownership of the account right?
Just need to also specify the seeds + bump.
Yep (for example, using those token::mint + token::authority attributes will work fine to make a token account that lives at a PDA)
can we use Anchor to allocate a PDA that is owned by another program rather than it's own?
aaaah i see...
I think `init` all by itself will initialize an account that's owned by the current program, which is wrong for a token account (it needs to be owned by the spl token program)
it would just write zeros, and then `token::spl_token::instruction::initialize_account` would be responsible for allocating the various properties in the buffer?
Wouldn't `init` just behave like `SystemProgram.createAccount()`?
Try searching through the anchor codebase for examples
Ah, ok, you're not using `init` correctly I don't think, you can use the `token::mint` and `token::authority` attributes to do the initialization for you
I tried that, unfortunately it still was not the problem üò¶
Token accounts are owned by the spl token program, so they don't have any anchor-y discriminator bytes‚Äîyou want to allocate just 82 bytes, not 8 + 82
<@!134416332509675520> I'm getting the following errors while initializing my `Token` account

Here is my instruction
```
#[derive(Accounts)]
#[instruction(wallet_bump: u8, instance_bump: u8)]
pub struct Initialize<'info> {
    #[account(
        seeds=[b"instance".as_ref(), user.key.as_ref()],
        bump = instance_bump,
    )]
    instance: AccountInfo<'info>,
    #[account(
        init,
        payer = user,
        space = 82 + 8,
        seeds=[b"wallet".as_ref(), user.key.as_ref(), mint.key().as_ref()],
        bump = wallet_bump,
    )]
    wallet: AccountInfo<'info>,
    mint: Account<'info, Mint>,
    user: Signer<'info>,
    system_program: Program<'info, System>,
    token_program: Program<'info, Token>,
    rent: Sysvar<'info, Rent>,
}
```

Here is my initialization function

```
    pub fn initialize(ctx: Context<Initialize>, instance_bump: u8, wallet_bump: u8) -> ProgramResult {
        let cpi_ctx = CpiContext::new(
            ctx.accounts.token_program.to_account_info(),
            InitializeAccount{
                account: ctx.accounts.wallet.clone(),
                mint: ctx.accounts.mint.to_account_info(),
                authority: ctx.accounts.instance.clone(),
                rent: ctx.accounts.rent.to_account_info(),
            }
        );
        anchor_spl::token::initialize_account(cpi_ctx)?;
}
```

When run, simulation fails with the following error:

`Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA failed: invalid account data for instruction`

oh my days, what could it be? am I `malloc`ing the `wallet` correctly?
```
-> project root:$ git submodule update --init
cd tests/cfo/deps/serum-dex/dex/ 
anchor build
cd ../../stake
anchor build
cd ../swap
anchor build
cd ..
anchor test
```
I'm trying to update the docs for some of the anchor tests. The cfo program has several dependencies that are not included in the workspace. Is there a way to target these additional programs through `anchor build`, right now it looks like I need to change directories and run it each time.
nice!
You can do `ctx.accounts.rent.to_account_info()`
In my case, `rent` is `rent: Sysvar<'info, Rent>,` - and when I use `InitializeAccount` instruction, I cannot convert the `sysvar` to a `AccountInfo`
Yep, interestingly it's not possible in solana to go from pubkey --> AccountInfo dynamically, within the program‚Äîyou have to pass *all* accounts your program needs in from the client
which function are you referring to?
my understanding is that you have to pass in the public key to your handler/program function to get the AccountInfo
<@!134416332509675520> do you know how I can convert a `PublicKey` instance into an `AccountInfo`? is there some helper function or should I go ahead and re-create a struct?
Or a cent actually
not a problem then igüòÑ
(8 bytes rent-exempted is like a tenth of a cent, fwiw)
Right, each account instance would have 8 bytes dedicated to its discriminator
i would be making an account for every new instance of the struct, which would incur extra 8 bytes on each one of them right?
If you're fine paying for those 8 extra bytes, then I guess that's your answer
Not sure, depends on how much other stuff you'd be storing per account üôÇ E.g. if you were comparing storing a vec of bools vs an account per bool, the discriminator bytes would be the majority of your storage, but if each account is like 1kb, then sure, maybe it's negligible
can i consider the rent of extra 8 bytes to be negligible?
<@!134416332509675520> what a smart guy!!!
Try doing `.key()` instead
How do I get the public key from `Account<'info, Mint>,`? If the key was `AccountInfo<'info>` then it would be just `.key`, but it looks like I can't do that?
What do you mean?
and is this 8 byte negligible?
Mm, I guess each individual account (in anchor anyway) comes with its own 8 byte account discriminator, but otherwise I think you're storing similar amounts of stuff‚ÄîI'm not sure if there's any per-account cost besides just the bytes themselves
what would cost more rent? storing every struct type in different PDAs or storing vector of these structs in a single account.
I see, thanks for explaining!
gonna do some more research now, ty
im using a custom candy machine with treasury splitting between multiple wallets. so this works on the cli not sure what the disconnect is on the UI
<@!134416332509675520> aha ! found something finally. when it gets to that line above, i added `error` to watch variables alongside the existing `err` and now i have something to go off of.
#[derive(AnchorSerialize, AnchorDeserialize)] on top of it I think
hi guys, i want to store a vector of struct of type:
```
struct NFTcollection {
name: string,
total_supply: u128,
total_minted: u128,
}
```
how can i store a vector of structs of type that is defined above, in an account data?
Hmm, I wonder why you don't get any program logs in the console ü§î
So you could have a separate PDA, say with seeds = [b"the-program".as_ref()], and use that to sign for the token account.
The authority will have to be a program-derived address derived from your program (the programId itself can't sign anything, which is what the authority is for‚Äîsigning)
eventually i get here, with the only thing to go off of is "minting failed"
`authority = <<self>>,` of course will not work, I basically need `authority = programId`
```

#[derive(Accounts)]
#[instruction(wallet_bump: u8)]
pub struct Initialize<'info> {
    #[account(
        init,
        payer = user,
        mint = mint,
        authority = <<self>>,
        seeds=[b"wallet".as_ref(), user.key.as_ref()],
        bump = wallet_bump,
    )]
    wallet: Account<'info, TokenAccount>,
    mint: Account<'info, Mint>,
    user: Signer<'info>,
    system_program: Program<'info, System>,
}
```

Hey guys one QQ, I have a `wallet` account that is an uninitialized PDA. I'd like to initialize this new account as a `Token` instance, owned by my program. How would you do this using Anchor?
Mm... weird
thats the problem, i put it in the watch variables, it won't show up. i hover over it and it won't show a value. so im trying to find other ways around
If you break in there, that is


///////////////////////////////////////////////////////////////////////////////////////////////

Just double checking but looks like to mint with decimals (mint_to_checked) I'd need to call `spl_token` directly vs `anchor_spl::token` ?
https://discord.com/channels/889577356681945098/889577399308656662/890891595367473192 looks like this is the issue
console.logged the `workspace` obj and it's empty
anyone run in to this issue: https://github.com/project-serum/anchor/issues/805#issuecomment-932969992
Linking this here since someone asked a similar question earlier https://discord.com/channels/889577356681945098/889702325231427584/893942166932553739
So when we use `Option<T>` in a `zero_copy` account - the anchor deserialization uses borsh which I believe requires an extra byte of memory for Option. So in this scenario the anchor API to fetch will error - 
```
     Error: Invalid option data
      at OptionLayout.decode (node_modules/@project-serum/borsh/dist/lib/index.js:96:15)
      at Structure.decode (node_modules/buffer-layout/lib/Layout.js:1234:32)
      at Sequence.decode (node_modules/buffer-layout/lib/Layout.js:1090:34)
      at Structure.decode (node_modules/buffer-layout/lib/Layout.js:1234:32)
      at WrappedLayout.decode (node_modules/@project-serum/borsh/dist/lib/index.js:62:41)
      at Structure.decode (node_modules/buffer-layout/lib/Layout.js:1234:32)
      at AccountsCoder.decode (node_modules/@project-serum/anchor/dist/cjs/coder/accounts.js:42:23)
      at AccountClient.fetchNullable (node_modules/@project-serum/anchor/dist/cjs/program/namespace/account.js:96:37)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at async AccountClient.fetch (node_modules/@project-serum/anchor/dist/cjs/program/namespace/account.js:104:22)
      at async Context.<anonymous> (tests/test-padding.js:25:15)
```
Does anyone know a solution for this or do I need to write my own decoding for the data?
you need to specify `space = <amount>` to make sure you create it with enough space
A nob question - was wondering if someone might be able to explain how Borsh deserializes struct with non-fixed size fields, like below:

#[account]
pub struct Pool {
    pub name : String,
    pub condition: String
}

How does Borsh know which is the ending byte of the 'name' field ? Edit: looks like it encodes string as (len(string), [u8]). I suppose this means we need to add a few extra bytes for each string field when calculating the account space ?
how does the serum fee rebate work? is it possible to allow usage of an address that holds a large amount of SRM as a signer on an order/settle instruction, while not requiring the SRM holding address to be the owner of the funds being traded?
what you can do is in `src` folder for the program you want to CPI to, run `cargo expand --features cpi` and copy the generated CPI code yourself, or alternatively  write a function that returns an instruction yourself.

To do this you'll need the sighash of the program you want, and the required accounts. You insert this into your unit tests as a handy method of calculating the sighash:

```rust
#[cfg(test)]
mod test {
    use super::*;
    use anchor_lang::solana_program::pubkey::Pubkey;
    use ring::digest::{Context, SHA256};
    #[test]
    fn test_sighashes() {// claimFarmRewards
        {
            let mut context = Context::new(&SHA256);
            context.update(b"global:stake_tokens"); // replace `claim_farm_rewards` with your relevant information as needed
            let digest = context.finish();
            println!("pub const STAKE_TOKENS_SIGHASH: [u8; 8] = {:?};", &digest.as_ref()[0..8]);
        }
    }
}
```

you would then take this sighash and use it to create a helper function that returns the instruction like this https://gist.github.com/bonedaddy/0a51ad0191856c4330f2fd8adff10990
no if you need the project as a dependency you will have to use the same version
I'm working on a program that uses another anchor program as a dependency for CPI. The other program uses an older version of anchor. Is there any way my program can use the newer version of anchor and still have it as a dependency? Screen shot attached:
Better to just remove the token owner check and give delegate access.
Agreed multi instruction sucks.
this adds to the spaghettiness a fair bit
The problem is that this is for multi protocol transitive swaps
Which I dont think you will for a single swap. Potentially for a transitive swap.
(assuming you actually run into compute limits)
Anyway I think the token transfer approach is totally legitimate. Just need to either break it up into 3 instructions or wait until solana 1.8.
Also better to over check then under check üòõ
üòÑ
it is not like the DEX can steal tokens
True.
or no check at all, the CPI would fail
A delegate access check would be sufficient though.
It does a token transfer.
thanks again ser!
Correct. That will move things to the heap.
is that also where 'boxing' helps ? or what is the primary use of boxing added?
If you need to use accounts larger than the stack size limit.
ok thanks. interesting. If that is the case, what is the general use case for really needing to use it?
I prefer to not use it unless absolutely necessary. It uses some unsafe code under the hood.
when not to use zero_copy ? or should we always use it?
But if the dex doesn't write to it in an IOC, why does it check?
the token transfer seems highly painful
If you try that let me know how it goes. <@!688968670059429948> is currently investigating the former approach.
Yes the CLI needs to be 0.16.2. But that CLI might work with 0.15.0.
init/close seems the best approach
more like compute units
The alternative would be to just immediately close any open orders account that is created for the transaction, but I'm not sure about tx size limits.
So instead there would have to be an SPL token account owned by the PDA. Then the instruction

* transfers from wallet to pda token account
* swap with pda open orders and pda token account
* transfers from pda token account back to wallet
I dont thihk that would work, because the dex will check the token account is owned by the open orders owner.
Is it possible only from version 0.16.2?
This question for the great guru <@!501570363566587905> 
Does that mean the user need to approve/revoke the PDA owning the open orders?
Try `anchor build -- -h`
In v0.16.2 you can run `anchor build -- <cargo build-bpf flags here>`
how to use feature flag with `anchor build` CLI?
Nvm, solved this by using different anchor versions in the same program, but under different names in Cargo - `anchor_lang_16 = ...`
Is there a way to make the CpiContext of programs with different anchor versions compatible? Doing `anchor_lang::CpiContext::new_with_signer` gives this error ```expected struct `anchor_lang::context::CpiContext`, found struct `anchor_lang::CpiContext``` which seems like it's because the programs are using different anchor versions
airdrops are taking forever
is there soul here that can spare some devnet sol?
Solana programs can only operate on Accounts they take in as params
how do I create an AccountInfo in rust from and existing Wallet address? To transfer some Sols to it.
And it happens on both: localhost and my server. Does anyone experience the same issue?
ah, yeah, not directly the issue in the ticket - but same solution.
TLDR: all cpi account structs should just take AccountInfos rather than the validated types.
Correct. We need to address that with this issue https://github.com/project-serum/anchor/issues/390
Every request my app (react) makes, is blocked by CORS. I have tried on devnet and mainnet-beta, but neither seems to work
Hey. Does anyone know who to solve CORS issues?
Anchor to Anchor CPI doesn't compose well when the callee takes a `Signer`, or am I missing something? (in the accounts struct)


///////////////////////////////////////////////////////////////////////////////////////////////

I am getting this error üò¶

Yes, currently we need to create a new (bigger) account and copy the content from the old to the new (I think that's how it should be done). Was just hopping that Anchor (as an amazing framework it is) would make that job for me ü§£  Thanks!
It's currently not possible to reallocate an account in solana as far as I know (though it sounds like this will be available soon-ish?). So, no, if you run out of space in anchor you're just out of space in that account.
Imagine an account which is simply a Vec. Does Anchor handles account "reallocation" in case the Vec is full (i.e., the values do not fit anymore in the current account)?
seems like its waiting for full confs?
anyone else experiencing contract calls taking ~20 seconds to return a promise from a react app but like 2 seconds when just using a simple ts script?
Found it. Sorry, just found out that Discord has search box
```js
    const tx = await program.rpc.addOutcomePriceOffers("HOW DO I SPECIFY THE ENUM HERE?", {
      accounts: {
        outcomePriceOffersAccount: outcomePriceOffersKeypair.publicKey,
        gameAccount: gameKeypair.publicKey,
        oracle: client.publicKey,
        systemProgram: anchor.web3.SystemProgram.programId
      },
      signers: [outcomePriceOffersKeypair, client]
    });
```
How to call (on JS side) an instruction that receives an Enum as instruction data/argument?
About actually managing to write the seeds: I personally just always inline them into the call to `CpiContext::new_with_signers` ü§∑‚Äç‚ôÇÔ∏è It helps rust with the type inference; you can just write `&[ &[seed1, seed2, &[some_bump]], &[other_seed, &[other_bump]] ]`
I see, thanks
But either way you'll need a temporary variable (I think)
You could maybe store it on heap memory
And no I don't believe you can get away with not storing a variable on the stack
I would get rid of the vectors there and just use slices directly
I'm curious why `CpiContext::new_with_signer()` accepts `signer_seeds` as `&'a [&'b [&'c [u8]]]`. Is there a reason for all the many lifetimes? also, what is the best practical way to write code to fill in the seeds? I have some pretty ugly code to implement it:
```
       let bump_vector = state_bump.to_le_bytes();
        let mint_of_token_being_sent_pk = ctx.accounts.mint_of_token_being_sent.key().clone();
        let application_idx_bytes = application_idx.to_le_bytes();
        let inner = vec![
            b"state".as_ref(),
            ctx.accounts.user_sending.key.as_ref(),
            ctx.accounts.user_receiving.key.as_ref(),
            mint_of_token_being_sent_pk.as_ref(), 
            application_idx_bytes.as_ref(),
            bump_vector.as_ref(),
        ];
        let signer_seeds = vec![inner.as_slice()];
```
How do we pass in slices to `CpiContext::new_with_signer` without storing a temporary variable on the stack?
but I think it's an easy fix actually. But also I'm heading out so gn
but it also won't work as-is if we change it to `assert.equal`
I think this assertion in `tests/misc` is meant to be `assert.equal` instead of `assert.ok`?
```assert.ok(JSON.stringify(expectedRaw), resp.raw);```
Right now it's just testing that `expectedRaw` is not null, which of course it isn't
You should probably describe more though and what youd be willing to offer. Also probably want to do <#889601099735126077>

<@!448034961652449283> sorry about that. Any help btw?
<@!464320185327943681> please don't spam the channels.
I am trying to catch event I am sending with emit!, with a program.addEventListener. But my tests just hang forever. Am I missing something?
any help would be greatly appreciated!
But not sure what actually changed here, hmm.
Hmm, weird, it looks like anchor's js error parsing expects to have "custom program error:", not "Custom program error:", and solana itself has a mix of both cases ü§¶‚Äç‚ôÇÔ∏è
I think you're right, it used to be a programerror
i used to get a `{code: 340, message: "[my_custom_error_message]"}`
it's `Transaction simulation failed: Error processing Instruction 0: custom program error: 0x154 
    Program DwwLDw7BmNBV2Z7yv5tMyZEunewvkGVi12LXaDtNPoD2 invoke [1]
    Program log: Custom program error: 0x154
    Program DwwLDw7BmNBV2Z7yv5tMyZEunewvkGVi12LXaDtNPoD2 consumed 22207 of 200000 compute units
    Program DwwLDw7BmNBV2Z7yv5tMyZEunewvkGVi12LXaDtNPoD2 failed: custom program error: 0x154
SendTransactionError: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: custom program error: 0x154`
sure
Can you post it here? Will help me see what changed
not sure if any of u are free, it should be easy
Hi, a solana discord mod refered me here for posting a job (?)
yeah i can, but now the code is at the end of a string
I think you should still see whatever information was contained in that `SendTransactionError` though, anchor isn't deliberately swallowing it or anything.
Maybe anchor is failing to parse it into the anchor ProgramError type?
Hmm, not super familiar with anchor's side here, but SendTransactionError is from solana/web3.js.
yes typescript
I'm getting a `SendTransactionError` which doesn't have the `code` property, allowing me to see what custom error my transaction is throwing
Do you mean in JS? What's the new structure?
now it's a pretty useless structure
it used to be a dict like `{code: XXX, message: "..."}`
Looks like the new version has different error types
Yeah, I realized that it should not really be an attack vector
Signing is purely about the address (its the address that signs, not the account really)
Can you say more about the attack there? Creating an account requires signing, so you can't really just snag somebody's public key and squat an account there
if an account is now `malloc`ed and associated with a program, can it still be used as a signer?
interesting, isn't this a very scary attack vector? essentially, you could "brick" EOA accounts by simply calling `SystemProgram.createAccount()` on them
cool!
My understanding is no, because in solana only the program that owns an account can change its data/spend its lamports‚Äîand now that token account is owned by the token program, not the system program anymore.
that's my interpretation too. My only concern is if that private key of a potential wallet could still call `SystemProgram` and manipulate or re-allocate the storage of an account
That's my understanding‚ÄîI don't think token accounts themselves are ever expected to sign anything (in which case you'd need that private key). Only their owner/authority/delegate needs to sign stuff.
One question about `Token` wallet accounts in Solana (ignoring PDAs). My understanding is that, in order to create a Token wallet for a particular user and mint, you need to fo the following:
- create a new random in-memory keypair
- Send an instruction to  `SystemProgram.createAccount()` to allocate space for the address that corresponds to the keypair, and specify that the owner should be the Token program
- Send an instruction to `Token.InitAccount()` to initialize the wallet for that particular address, which will "format" that account that was previously created, and it will add an "authority" to that wallet. The authority is, essentially, who "owns" and can spend the tokens.

If the above is correct, then my question to you is: once a public key is used to create a new token account, does the private key that corresponds to that public key have any value? can it still be used in any way?
works, ty so much!
```rust
        {let lower_tick = ctx.accounts.lower_tick.load()?;}

        close(
            ctx.accounts.lower_tick.to_account_info(),
            ctx.accounts.owner.to_account_info(),
        )
        .unwrap();
```

this would be fine
no the code fragment you linked still has a borrow to the account when close is invoked
good call. --version pointed out a different version in the path I had compiled previously trumping my npm install. thanks!
I shared just the minimal fragment of code. I use loaded one only before closing not after so it should be dropped (right?)
Sorry not sure I understand, if you want to close the account you shouldn't load it before invoking close. If you must then you should scope the variable so the reference is dropped before close gets invoked
seems the Metaplex accounts have not implemented Anchor traits afaik
has anyone had any luck interacting with Metaplex package using Anchor
and not removing is still a valid call, not an error
it works then, but the point is to remove it or don't depending what's inside
The account is borrowed into `lower_tick`. Remove the statement just before the close and it should work


///////////////////////////////////////////////////////////////////////////////////////////////

anyone else has experienced application hanging on `program.addEventListener("MyEvent"` one the client when trying to trigger even on solana program with `emit!`
To answer the question, you can use ctx.remaining_accounts. If possible, create an other endpoint.
Please don't ping unnecessarily.
What is best way to pass account via context as optional (load only if account provided and change logic in function handler based on it)? <@!501570363566587905>
thank you sir, that works!
use that rather than useWallet
there is an anchorWallet, in the same package
Hello
I'm trying to configure provider but I'm getting type issues. 
I'm following this article:
https://dev.to/dabit3/the-complete-guide-to-full-stack-solana-development-with-react-anchor-rust-and-phantom-3291#:~:text=useWallet()%3B%0A%0A%20%20async%20function-,getProvider(),-%7B%0A%20%20%20%20/*%20create%20the%20provider
Thanks for helping man
Yes, as you can see a `txn` is created from solana's web3 package
Can I also execute functions from different contracts, one written in achor and another not written using anchor in single txn?
<@!477913575726383125>
```
const txn = new anchor.web3.Transaction();
const ix = program.instruction.NAME(..);
const ix2 = program.instruction.NAME(..);
txn.add(ix);
txn.add(ix2);
 await provider.send(txn, signers);
```
hi guys, how can i configure a txn to call two functions from my program in single txn?
hmmm actually i'm dumb ...
hmmm i probably should look at one of the oracle programs ..
Or other patterns of sharing account data between caller and callee within a CPI .. ?
Has anyone used the spl shared-memory program?
https://github.com/solana-labs/solana-program-library/blob/master/shared-memory/program/src/lib.rs
ah i see fetchMultiple
is it possible to bulk fetch accounts?
`target/types` contains only 1 type now (program)
instead it should contain all the types defined in the program
yup
got it so you are just suggesting that those types should be built into anchor fetch and derived from the IDL since it should know the types from there? which I think would be a good improvement as well
and apart from the fact that prettier and eslint hate those, it's fine ;p
The ergonomics are definitely bad, yeah.
I can and that's what I'm doing üôÇ
you can still define the type separately and just cast "thing" as your type, and if its an object and the fields match it should work
Ah, I see. Hmm.
```
  const fafa = (dada: any => {//do smth})
  
  const thing = await program.account.that.fetch(thing.publicKey);
  fafa(thing.dada)
```
so the thing is that the IDE can see those types, but those types are not formalized, so lets say that you want to pass the result of fetch as an argument. what do you use. `any`?
To be more specific here: if `dada` was a simple type (number, pubkey, etc) - it works.
but it doesn't for lists for example or more complex types. or lists of more complex types

Well, sort of nice types anyway, looks like they don't know what to do with strings lol. But it's trying.
It's true that the type doesn't print very well in my editor.
(Meaning typescript knows what the resulting account should look like, its fields, etc.)
Hmm, this seems to work fine for me. I get appropriately typed values out of `await program.account.someAccount.fetch`.
the fetch itself works properly. I had a program that have been working fine with my hand-crafted typescript interfaces/classes. The only thing I updated now is `as Program<MyProgram>`, which added types to the program itself, but those types are not compatible with my pre-defined types (which is fine), but `target/types` provides only one definition (the program itself), so I cannot import (nor use) other types.
I was hoping that `target/types` can have more exports (export per account/struct) with actual typescript definitions

does that make any sense?
make sure you're passing the pubkey of the account to the fetch
fetches with anchor accounts give u ts-compatible objects with account data if they exist. only thing u might have to do is a little handiwork to convert bw ambiguous types, eg the fetch might return a number[] when u want a uint8arr
are there any plans on extending the `types` generation?
as far as I can see the Program gets nicely typed, but when you want to interact with it (for example `program.account.accName.fetch()`) the result is just being weird (as in - it's a JSON object describing the IDL type) and not really typescript compatible (which would be really useful)
or am I doing something wrong? 
<@!501570363566587905> ? üôÇ
Is there any way to monitor the timing of every transaction happended? IN ehtereum, it is way easy because nft is implemented on custom smart contracts. But in soalna, nfts are implemented on system token progrma. what is the solution for this?


///////////////////////////////////////////////////////////////////////////////////////////////

Cool package though.
Still need the bulid step to generate the interface there.
I use this lib all the time for my json to ts types generation.
https://www.npmjs.com/package/maketypes
padding might be issue ?
üòï
and it works until i overwrite it with buffer
I set it explicitly on both of them
just idea
<@!889636611736891412> maybe verify is using different network than deploy
no ran out of ideas
Did you resolve your devnet issue?
Add me and dm me your email.
Great. I'll whitelist you when I get home.
yes
Are you trying to publish on anchor.projectserum.com?
<@!501570363566587905> any way I publish source using anchor already?
yeah i think thats fine
And UIs can copy and paste out.
Then the tests directory can just import from there.
What do you think about `target/types/` ?
Build step it is then.
üò¶
you need to generate it there is no way to import it
<@!501570363566587905> i dont think so
Otherwise, we can just add an additional  build step in `anchor build` to do the conversion.
Would be nice for https://github.com/project-serum/anchor/pull/795.
I wonder if there's a way to `import MyJson form './file.json';`  as a TypeScript type (rather than a value).
Hmmm I'm not sure.
yes, https://explorer.solana.com/address/u9km7ajtP6FF9sujWDauBULbt9WVRhVKeXrJxtx2pzv?cluster=devnet
What is the address?
Is the program upgradeable?
tried to redeploy, got `Error: Binaries don't match` expected as I didn't use docker. Created buffer and verified it, worked just fine. Used `solana program deploy --program-id <PROGRAM_ADDRESS> --buffer` and getting `Error: Account not found`. I can see it fine on explorer. Any ideas?
yeh, i will have to do that, just been procrastinating
yes
It shouldn't.
yes, it's devnet if it matters
Is your cluster set?
Both should work.
Can anchor verify only be used with programs or just buffers? Getting `Error: Account not found` when trying to verify a program
were you `Box<T>`ing the token accounts? That would likely be needed.
Can you file an issue with a reproducible example so we can investigate?
darn
I don't think so. This change will only affect those using the `<my-crate>::cpi::<my-method>` API when calling other anchor programs.
It would be interesting to see what the ix data bytes end up being, just to see if they're wrong in some kind of interesting way. I often set a breakpoint here https://github.com/project-serum/anchor/blob/master/ts/src/program/namespace/rpc.ts#L17 and poke around the raw tx object
I get this message on my terminal `The program address will default to this keypair (override with --program-id):`
Hi! Trying to deploy a the program following the Nader's article, after deployment I don't get any address in the IDL json file. Is that normal?
Thank you sir - are there any pros/cons to this method vs using something like git modules and adding the programs in a deps folder (like how cfo test program does it) - then using them in genesis in the anchor.toml?
Potentially. In the meantime Im going with
```
pub struct Params {
    pub id: Vec<u8>,
    pub metadata: Vec<u8>,
}
```
And then ensuring strict sizing on chain. Id prefer just to avoid the problematic type
solana program dump <ADDRESS> filename.so
then when starting
solana-test-validator --bpf-program <ADDRESS> filename.so
i bet if you call the same method from rust it would just work
someone need to fix this js thing
Exactly my concern. Ive upgraded all my components to anchor .17 (cli + ts lib + rust lib) and it still seems to persist.
Yeah my issue is compute, in that this is a wrapper around the dex consume_events function so the less compute I use the more events I can potentially crank.

Edit: Fwiw got it working via storing the loaded accounts into a Vec<RefMut<T>> by manually deserializing the account info rather than using the loader.
Classic mistake haha definitely done that before.
I don't actually use those accounts for the CPI, so don't need to drop them. If that's the case it's actually possible? I suppose I just need the correct syntax for storing the loaded `&mut RefMut<T>` from the loader.
sending 1 million USDC to HELL
on a peculiar case
what if it goes off in production
that is pretty scary actually
seems like the lib is rotten
some other people had other peculiar bugs
e.g. I want to test something against a program that has been deployed by someone else - I saw the above comment to run the local validator w/ --clone, but I'm curious if anyone has a method of doing it programmatically in a script so that I can just have contributors run anchor test and they don't know the difference
Does anyone have examples of automatically pulling programs deployed on mainnet for testing?
Still failed when I tried a u8 between the fields
I think thats the case. I tried adding an i64 between the arrays

```
#[derive(Clone, AnchorSerialize, AnchorDeserialize)]
pub struct Params {
    pub id: [u8; 32],
    pub x: i64,
    pub metadata: [u8; 64],
}
```

And all tests now pass. Hmm
https://project-serum.github.io/anchor/getting-started/verification.html
coundn't find it can you safe me with a link?
you read the doc, lol
how can I use your service to verify smart contract <@!501570363566587905> ?
anyone know how to setup proxy for solana RPC node ? with WS
all of the accounts are "Boxed" so it's a different error than the standard one that crops up with upgrades
`    'Program failed to complete: Access violation in unknown section at address 0x43 of size 1 by instruction #157101',`
https://pastebin.com/2pEEtKzB
out of memory as in stack size issue?
(I also gave up on upgrading to v16 after two tries hoping that a future release would fix whatever the issue was so maybe i will try an upgrade to v17 soon)
<@!501570363566587905>  Also with regards to v17, 
```
. This will be much more efficient all around and will fix problems in the v0.16.x release related to using Signer types in CPI invocations.
```
will this potentially fix the issue I was having with running out of memory while initialising a lot of TokenAccounts in the account struct? I never ran an explicit check as to what might be causing it but the biggest difference between that struct and the others which didn't fail was that the failing one was initializing like 5 token accounts and the others only ever inited 3
still doesn't fix it for CPI accounts (of which there might be a lot of people building on top of serum)
you also have to reload the accounts post cpi, i dont believe theres anyway around that
if your issue is compute units usage, you can do a check at the start of the instruction that validates the remaining accounts are as expected, and then on subsequent loads, do unchecked loading of the account (ie, dont validate program id as youve already done so, dont validate account discriminator as youve already done so) so you'll save some compute units on subsequent usage of said accounts.
you'll get an error during tx execution about account data already being borrowed
this wouldnt work. if you want to do cpi with those accounts the references need to be dropped before  cpi
ok he found it, it is actually such a cryptic error, the IX was providing the dex ID, but in my test the program was on another id. So this resulted in an account being in account info but not in account meta. A smart colleague found that terrible mistake
<@!501570363566587905> any ideas? Is this even feasible - I've tried some permutations but I think I'm lacking in rust borrow understanding :/
Fwiw I tried doing this locally (I think, hopefully I understood your example right), and it seems to work fine?
I have a rusty ~ question:

Does anyone know how to do something like this?

```
        let mut loader_margin_accounts: Vec<Loader<'_, MarginAccount>> =
            Vec::with_capacity(ctx.remaining_accounts.len() / 2);

        let mut loaded_margin_accounts: Vec<RefMut<MarginAccount>> =
            Vec::with_capacity(ctx.remaining_accounts.len() / 2);

        for i in 0..ctx.remaining_accounts.len() / 2 {
            let margin_account_index = i * 2 + 1;
            loader_margin_accounts[i] = Loader::try_from(
                &ctx.program_id,
                &ctx.remaining_accounts[margin_account_index],
            )?;
            loaded_margin_accounts[i] = &mut loader_margin_accounts[i].load_mut()?;
        }
```

Pretty much I load a bunch of zero_copy remaining_accounts, do some checks, do a CPI, then reuse these loaded accounts. I don't want to have to reload them post CPI so want to store them in a vector.
moving over to <#889702325231427584> - hope to come back here soon üôÇ
ah ha thank you!
You have to pass in the payer when initializing an account see https://github.com/project-serum/anchor/blob/master/examples/tutorial/basic-1/programs/basic-1/src/lib.rs#L24
```error: payer must be provided when initializing an account
  --> programs/meme-num/src/lib.rs:17:15
   |
17 |     #[account(init)]
   |               ^^^^
```

could anyone explain what this is?
thank you - im an idiot
through its buggy code
likely borshjs failing you
i believe borsh itself is fine
i have to say i never tried 2 arrays consecutively
ok
```
    'Program 11111111111111111111111111111111 invoke [1]',
    'Program 11111111111111111111111111111111 success',
    'Program JVMJJD4TagDBUahzcVwS367fSGAvwSBgK9tazCT52h2 invoke [1]',
    'Program log: Custom program error: 0x66',
    'Program JVMJJD4TagDBUahzcVwS367fSGAvwSBgK9tazCT52h2 consumed 2605 of 200000 compute units',
    'Program JVMJJD4TagDBUahzcVwS367fSGAvwSBgK9tazCT52h2 failed: custom program error: 0x66'
```
```
      {
        id: new Array(32).fill(0),
        metadata: new Array(64).fill(0),
      },
```
32 then 64?
with the right size being provided?
Same error it seems
Tests have been passing using buffers but if thats the case Ill try the switch
aren't arrays of u8 supposed to be `number[]`?
Removing the `metadata` field on the typescript side resolves the error
Possible bug:

When using an rpc parameter formatted as such:

```
#[derive(Clone, AnchorSerialize, AnchorDeserialize)]
pub struct Params {
    pub id: [u8; 32],
    pub metadata: [u8; 64],
}
```

There seems to be some issue calling this rpc including both of these parameters on the typescript side.

Passing the parameters as such:

```
{
  id: (params.id ?? Buffer.from("")).slice(0, 32),
  metadata: (params.metadata ?? Buffer.from("")).slice(0, 64),
},
```

Produces `InstructionDidNotDeserialize` errors
the only thing the soupy brain can do
so time to give up for me and go buy some JPEGs
Looking at the source code, it hasn't changed in like 7 months so..
to be sure i didn't use some random binary
i even redownloaded the mainnet serum v3 dex program
yes, exactly that
```
impl<'info> PlaceOrder<'info> {
    pub fn into_place_order_context(
        &self,
    ) -> CpiContext<'_, '_, '_, 'info, dex::NewOrderV3<'info>> {
        let cpi_accounts = dex::NewOrderV3 {
            market: self.market_accounts.market.clone(),
            open_orders: self.open_orders.clone(),
            request_queue: self.market_accounts.request_queue.clone(),
            event_queue: self.market_accounts.event_queue.clone(),
            market_bids: self.market_accounts.bids.clone(),
            market_asks: self.market_accounts.asks.clone(),
            order_payer_token_account: self.market_accounts.order_payer_token_account.clone(),
            open_orders_authority: self.serum_authority.clone(),
            coin_vault: self.market_accounts.coin_vault.clone(),
            pc_vault: self.market_accounts.pc_vault.clone(),
            token_program: self.token_program.to_account_info().clone(),
            rent: self.rent.to_account_info().clone(),
        };
        CpiContext::new(self.dex_program.to_account_info().clone(), cpi_accounts)
    }
}
```
My instruction for dex_v3 works with 12 accounts and looks like this
but my pea sized brain refuses effort
that is what i thought
Might be mismatch between the CPI wrapper and the actual dex binary you're testing against?
anchor spl dex::new_order_v3
Which CPI?
Makes sense
I am seeing something pretty weird, i have 12 accounts (in the program) i do a CPI and the CPI fails with `failed: An account required by the instruction is missing`
But the code of the program does show 12 accounts are required
need to install yarn?
``` $anchor init hello-world
Error: yarn install failed: No such file or directory (os error 2)```

any reason why this could be happening?
About the memcmp filter (neat, hadn't seen that before), yeah, I guess that won't work super well with variable account data layouts.
Mm, I'm not sure‚ÄîI see that the tests/chat example seems to use both Strings as well as fixed-size byte arrays.
so in the general case we just copy to evolve in a safe environment
because one is safe the other isn't
Am still unsure why we need to serialize it for normal `Accounts`
Ok so tried it out - the account you get from loading directly writes to the zero_copy account. üòÑ
Does `try_from` for an `Account` from a passed in remaining_account just load the data onto the stack/heap, which is why we need to explicitly write back into the `AccountInfo` like so: 
```
    let mut data = account_info.try_borrow_mut_data()?;
    let dst: &mut [u8] = &mut data;
    let mut cursor = std::io::Cursor::new(dst);
    program_account.try_serialize(&mut cursor)?;
    Ok(())
```
^ This is how we do it currently .

So my follow up question is when I use `try_from` for a `Loader`, when I load the object i.e.
```
let loader: : Loader<_, Foo> = Loader::try_from(&ctx.program_id, &account_info);
let foo = &mut loader.load_mut()?;
```

Do modifications to my foo object write directly to the remaining account data?

I see the `try_from` method uses acc_info.clone() -> meaning it is just a Loader with a clone of account info?
Wasn‚Äôt it like this at some point? With a ‚Äúbumpable‚Äù trait or something? Back in 0.6 or something?
super helpful, thanks <@!134416332509675520> just a follow up question, is it a an anti-pattern to use dynamic size string ? should one use a fixed-size byte array to store string instead ? if using string is acceptable, how would one approach account query using memmcp filter while the account layout is unpredictable ?
Some sort of abstraction of "static" accounts
another one, for all those "hardcoded" accounts like `Program<'info, X>`, anything with `#[account(address = `...
Would it make sense to have the address in the idl and have the program client feed them automatically to `accounts`?
Would really clean up the programming model to just never use bump seeds explicitly.
yes doesn't seem essential for survival and a lot of other things need to be done first
I dunno
What do you think?
Or even v2.0.0.
So probably best to do it for v1.0.0.
This is a big breaking change though.
Agreed. And it's only a byte so we can just put it there for all accounts.
it is a bit like the is_initialized flag, seems essential enough to be in the header
But no more passing in the bump via args.
The macro would still run it.
i see, so no more find_program_address
Then the macro just inserts the bump.
So the layout is: `discriminator || bump || other-metadata || borsh(struct)`.
I.e. have an extra byte in all accounts specificially for a bump seed.
So I think the way to do that is with the account header.
Yea that would be nice. Currently you need to use instruction args.
This would really put `Accounts` in charge
I think a nice improvement would be to have access to bump in the method body after using
#[account(
    seeds = [blabla]
    bump,
)]
when doing init or later on, to avoid the need to redo find_program_address or having to store the bump
neat
This is useful for things like using bump seeds.
Allows one to access instruction arguments inside the `#[derive(Accounts)]` macro.
what does `#[instruction(...)]` do <a:aPES_Think:493353113332219924>
ty ser!
See https://github.com/project-serum/permissioned-markets-quickstart
does anyone have any links or resources on documentation for serum permissioned markets
Do all the versions line up?
Did anyone have similar problem on CI after updating the anchor to 0.16.2.
CI after running tests:
`TypeError [ERR_INVALID_ARG_TYPE]: The "path" argument must be of type string or an instance of Buffer or URL. Received undefined`
<@!501570363566587905>


///////////////////////////////////////////////////////////////////////////////////////////////

Just send me your email and I"ll whitelist y ou.
whats the process to be able to publish builds?
<@!501570363566587905>  we  open sourced our protocol written in anchor when we did our soft launch last week - would love to be able to publish it as an anchor verified build - https://github.com/nina-market/nina
The idea is to use borsh.
so for a program rpc call that requires it, the idea is to use the `borsh` package to create the raw layout as the argument or can some combination of `Buffer` or `Uint8Array` be used as the RpcFnc argument
It's possible that's not tested, but I dont know off the top of my head.
https://github.com/project-serum/anchor/blob/master/ts/src/coder/idl.ts#L48-L50
thats the rust type, but what about the typescript/js one
It's vec<u8>.
as well as `borsh.vecU8`
what is the typescript mapping to the `bytes` IDL type? i've tried multiple different types of buffer and uint8array instantiations but getting type errors because of `Blob`
he will mostly likely make a youtube video if it won't be streamed
Will it be streamed for those of us too broke to go to Lisbon for a few days?
Congrats <@!867369388608061470>! Looking forward to it.
also big news <@!867369388608061470> is going to be giving a talk at solana breakpoint about our anchor UX stuff
Need to show proof of work.
But how else do we get paid?
including the docs of course
minimalism above all else!
Going to need more roles.
Please! Make him head of developer relations or something haha
https://tenor.com/view/brienne-knighted-first-woman-knight-knight-of-seven-kingdoms-dream-come-true-knighted-gif-14061043
<@!134416332509675520>
<@!134416332509675520> fast becoming a core dev!
Yea these types of features are being added on demand. Thanks for the PR <@!134416332509675520>.
yeh, if SPL supports it then it's just a minor change to the anchor API
That's my impression too, I made a little pr last night that hopefully adds `mint::freeze_authhority` capability
No üõå for me
On it boss man.
This CENTRALIZATION needs to stop üòÜ
<@!501570363566587905> open gates of verifying smartcontracts
but I guess we can just overwrite the bytes
yeah! if it ever becomes necessary 
for deserializing in a non anchor program I'm already doing that in javascript with `buffer.slice(8)`
Not just deserialise the data in a non anchor program
When you say migrate you mean permanently change the account and delete the discriminator right
right
Except increasing space
Anything is possible
is it doable to migrate already created accounts (through anchor) into normal non-anchor accounts? Can I just chop off the first 8 bytes that anchor uses and treat the rest of the data as usual? ü§î
so you at least know instantly what the pubkey should be
it helps to use PDAs for all the accounts as well
<@!867369388608061470> convinced me that it's a very quick getAccountInfo call to just get that one piece of info
but it's one getAccInfo that could be saved :p
I'm doing it here as well, yeah!
just check if an account exists and if it doesn't, then add the init instruction to the transaction ü§∑
we do it on our site all the time
the second thing you said is not that hard to do
I might take a look to see if this can be added easily
hmm it's either asking the user to click a dialog (that he probably doesn't understand) twice, or to have some logic that checks if account exists, and if it doesn't add an extra instruction to the tx
not 100% sure why but probably to make the code and contracts clearer
it's just encouraged to make separate functions for initing
It's just not an anchor feature
is that a limitation of the current anchor way of doing things, or solana?
I see
Unfortunately not
Hmm do you always need to have a separate `init` method that initializes an account before it can be written? 
Can't be initialized (if doesn't exist) + mutated at once?
hi, how can we "name" a transaction in the rpc call such that in the Phantom wallet it doesn't say "Unknown"?
previously i would manually check the owner value but have been several anchor versions behind
https://github.com/project-serum/anchor/blob/master/lang/src/loader.rs#L46-L48
right <a:aPES_Think:493353113332219924>
sorry i meant anchor codegen makes sure that the `vault` account is owned by the calling program
The `try_from` for Loader checks the account is owned by the program - load only checks the anchor discrim
in the following:

```rust
#[derive(Accounts)]
pub struct Foo<'info> {
  pub vault: Loader<'info, VaultAccount>,
}
```

and you call:

```rust
let vault = ctx.accounts.vault.load()?;
```

this will validate that `VaultAccount` is owned by the current program right?
hey is there a way to preserve rpc call function structure when using a wallet to sign? in other words, not having to construct a transaction and call wallet.signAllTransactions. Running into this conflict since there's no direct access to the keypair through frontend, only signing capability.
It lets you refer to arguments to the instruction handler in your `#[account(...)]` stuff, so here `bump` would be the first non-ctx argument to whatever instruction handler is using `InitializeCandyMachine`
Yep
and what is the meaning of the macro instruction?
can i have dynamic sized array in an anchor serializable struct like this?
am i correct in thinking that anchor currently doesnt support something like creating a new mint with a freeze_authority like `mint::freeze_authority` because its not passed through here and instead is always None
https://github.com/project-serum/anchor/blob/2c827bc839f7e67c25597c055c373833314583c0/lang/syn/src/codegen/accounts/constraints.rs#L458
These lil branches you write are super helpful, thanks!
Ah so you need to wrap them in what anchor expects huh 
I think I‚Äôll just stick with invoke_signed for now
```rust
let cpi_accounts = Transfer {
   from: ctx.accounts.from_account.to_account_info(),
   to: ctx.accounts.to_account.to_account_info(),
   authority: ctx.accounts.authority.clone(),
};
```
I'm doing something similar to this except with a bunch more accounts. And all I can tell is that it doesn't like one of them. But I have no clue beyond that
Is there a better way to get error messages when creating the cpi_accounts? I am current just getting a InvalidAccountData but it doesn't point me in any useful direction.
That was what I was missing.
Looks like you can. But it seems slightly different with those. 
https://github.com/project-serum/anchor/blob/master/spl/src/token.rs
You would invoke these for the spl_token_program. I am sure there is something similar for the system_program
slightly related, but can you do CPIs with things like spl_token_program or system_program? the examples are all about puppet programs that got created with anchor
I think you need to explicitly use the "cpi" feature, e.g. `puppet = { path = "../puppet", features = ["cpi"] }`
I got a question for you fellas. I am trying to do a CPI call following the example from tutorial three. The problem I am running into is that there is no cpi module in the crate I am trying to call. Should all anchor projects have a cpi module?
I'm still a bit confused why it didn't work with just 'info though, even if it's restrictive 
I thought rust would keep track of it's internal lifetime and pin those to the same lifetime (in this case 'info), but I guess that's not how it works right? More the other way around that the fx says "I want a X with lifetime 'a, give it to me", and we have to pass the appropriate thing in?
I see
Yeah in this case the compiler will fill in some appropriate 'a at the callsite (and it will be shorter than 'info)
so 'a is shorter than 'info
hmm I see
Basically, a function with an arg like `&'info AccountInfo<'info>` is actually quite restrictive, you're saying you need a borrowed AccountInfo that can live as long as the AccountInfo's data itself‚Äîbut like, you probably don't need it to actually live that long, your function just needs it for a quick sec or whatever
ah sweet, I didn't know that. I guess the missing piece was the `'a` annotation in the fx signature then
yeah, I thought I could just pin them to the same lifetime
About the 'a, I think you can probably get rid of it entirely and just do `&AccountInfo<'info>` btw, "lifetime elision" will insert it for you
Hmm I'm worried I'm too fuzzy to actually answer this lol, should think about it some more.
Yeah definitely realizing I'm fuzzy here‚Äîa value of type `&'info AccountInfo<'info>` says this borrow has the same lifetime/scope as the AccountInfo's underlying data (I think, right?)
but why can't those 2 be the same ü§î
The reason why I made that suggestion is that `&'info AccountInfo<'info>` has two distinct lifetime slots, that you made equal to each other, which is a deliberate choice‚Äîthe default would for them to both float somewhat freely and have the compiler fill them in with two different values
My understanding was, that when I annotate my function with `'a` or '`info`, rust would put all the arguments that are annotated with it on the same lifetime, but I guess that's not how it works üòÖ
Mm, honestly I'm a little fuzzy on this aspect of rust (I can usually work my way out of lifetime jams but I'm not really simulating the compiler well‚Äîthat's part of why I was curious about your example)
wouldn't setting everything to `'info` put it all on the same lifetime
My issue was that the other arguments of the fx also needed the same `&'a AccountInfo<'info>` annotation, even though it only complained about the first argument `user_account`

<@!134416332509675520> do you mind explaining again what the `'a` here is, and why we need 2 lifetime annotations? Why can't it all be `'info` (or 'a)
I reproduced it
literally nothing is different with those parameters/accounts though besides that code afterwards changed. 
could it be that usage of the user account in other functions did something to the lifecycle (I don't know lifecycle stuff fully yet)
I'm so confused, when I strip it down to a minimal example it works
Fwiw this was a previous discussion https://discord.com/channels/889577356681945098/889584618372734977/892805497940492338
I'll see if I can copy a small snippet together 
Lifetime stuff in rust is giving me a hard time
Could you maybe post a full gist of your code? This lifetime issue has come up on the discord before but I can't really work through it in my head yet lol
Basically there are two distinct lifetime parameters for a borrowed AccountInfo, the lifetime of the borrow (the `&'a` above), and the lifetime of the data that the AccountInfo itself borrows (the 'info)
hmm no, same
let me try
What happens if you have `do_something<'a, 'info>(user_account: &'a AccountInfo<'info>)`?
what am I doing wrong here
also 
> but data from `ctx` flows into `ctx` here

I mean... yeah lol
it's strangely also the only account that I can't pass
tried spam-annotating everything with `'info` just to see if it would do anything but I can't manage to pass the account because of the different lifetimes
hey guys! I'm having a bit of a struggle with lifetime parameters
I moved a lot of stuff into own functions and just try a simple 
```
        do_something(user_account) 
```

where the fx is:
```
    do_something<'info>(user_account: &'info AccountInfo<'info>) {}
```

and struct is
```
pub struct Do<'info> {
    #[account(signer, mut)]
    pub user_wallet: AccountInfo<'info>,
```

but getting 
```
error[E0623]: lifetime mismatch
   --> programs/hoge/src/lib.rs:200:13
    |
124 |     pub fn Do(ctx: Context<Do>, data: u64) -> ProgramResult {
    |                      ------------- these two types are declared with different lifetimes...
...
200 |             user_account,
    |             ^^^^^^^^^^^^ ...but data from `ctx` flows into `ctx` here
```
ah no refferal is correct, that is the usage of **referral** in anchor_spl settle funds that isn't
then referral (referrer?) is given when settling funds
https://github.com/project-serum/anchor/blob/master/spl/src/dex/cpi.rs#L29
weird, isn't this the fee discount token account rather than the referral?
https://github.com/project-serum/serum-dex/blob/master/dex/src/state.rs#L1814-L1818
yeap, thanks
Does `pyth::ID` work?
One more question. How can i check the owner in another module having `delacre_id`?
```
mod pyth {
    use anchor_lang::declare_id;

    #[cfg(feature = "mainnet")]
    declare_id!("...");
    ... etc
}
```
```
#[derive(Accounts)]
pub struct Context<'info> {
  #[account(owner = [**here**])]
  pub asset_feed: AccountInfo<'info>
}
```
awesome - thank you - looks to be exactly what im looking for
https://doc.rust-lang.org/reference/conditional-compilation.html

This is worth a read, there's a few different methods you can use for conditional compilation
This could be `targer_arch` if you want to specify conditional compilation based on target architecture you are building for.
Yes I believe that only activates the `test` feature which is disabled during non test builds. 

Basically the way it works is it allows you to define some logic based on attributes/features
I have a mint that i want to ensure is a particular value in production, but during testing w/ my team i dont want to have that restriction
How does `cfg_attr` work? does this make is pass the following account check if running during tests? https://github.com/project-serum/anchor/blob/db193d824887f12881c93853f3c4821cca5d09b1/tests/cfo/programs/cfo/src/lib.rs#L366
Be the change you want to see in the world! üôÇ
wen anchor sol wrapper
Daaaayum, was hoping some of this happens magically behind the scenes
Yea sounds like it.
https://github.com/solana-labs/solana-program-library/blob/master/token/js/client/token.js#L596
there are some helper functions in the program library for wrapped native accounts
Here's an example https://github.com/project-serum/swap-ui/blob/master/src/components/Swap.tsx#L456
Is there an easy way to wrap native SOL and use it as an SPL token? Ideally do some of this magic on the client side.

We want to have an unified interface in our program, to treat everything as SPL tokens...
when u get an error w/  "[account pubkey] writable privilege escalated," does that mean a read-only account is being passed as writable?
```rust
mod pyth {
  #[cfg(feature = "devnet")]
  declare_id!("...");
  #[cfg(feature = "localnet")]
   ... etc
}
```
I have problem with compute units. This function (`get_oracle_pubkey`) is called frequently. I'm looking for way to create publickey once during compilation, instead of doing it every time function is called:
```
pub fn get_oracle_pubkey() -> Result<Pubkey, ErrorCode> {
    let address = if cfg!(feature = "mainnet") {
       PYTH_MAINNET
   } else if  cfg!(feature = "testnet") {
       PYTH_TESTNET
   } else if  cfg!(feature = "devnet") {
       PYTH_DEVNET
   } else {
       PYTH_LOCAL
   };

   match Pubkey::from_str(address) {
       Ok(pubkey) => Ok(pubkey),
       Err(_) => Err(ErrorCode::InvalidOracleProgram),
   }
}
```
<@!501570363566587905>
my pleasure ü§ù
I'd love to writ some smart contracts so that DAOs can govern the builds. But we'll add that to the infinite list of things todo.
https://tenor.com/view/that70s-show-ashton-kutcher-michael-kelso-burn-gif-4891812
S3 is great.
I don't apologize.
It is.
Omg it is CENTRALIZED
Thank you <@!739966689776631932>
üôè üôè
Thanks to whoever added this `Unable to start test validator. Check .anchor/test-ledger-log.txt for errors.`
was in target, wasn't on chain so deployed
you mean idl wasn't created or deployed ?
thought it would be created automatically or at least show clearer error
figured it out, idl wasn't created.


///////////////////////////////////////////////////////////////////////////////////////////////

This is not released. Build the cli on master to use this.
That was me I think, and I think (?) I fixed it by using solana's /scripts/cargo-install-all.sh to install release builds (I was using a debug build before). At any rate I haven't seen 30s timeout since.
Yeah my tests are still in js
Oh nvm, it's a sneak peak for the next version:
https://github.com/project-serum/anchor/blob/master/CHANGELOG.md#:~:text=%5BUnreleased%5D,derive(Accounts)%5D%20(%23835).
I'm using the latest: v0.17.0
split into two separate
If you look at this test program, it's importing the type
https://github.com/project-serum/anchor/blob/master/tests/escrow/tests/escrow.ts#L11
I don't have any folder `target/types` when building a anchor project
Hello
I did `anchor build` in the escrow program but `../target/types/` is not generating. Is there different command?
Ok thx, what is the workaround when reaching the max transaction size?
Hi. I am trying to make a swap with my custom swap program. I made the js script to make swap according to test example from the anchor repo.
So, tests pass nicely (with local market generation), but in devnet I have some issues with making the swap. I get 2 market the accounts of serum dex and use them as markets to swap, but I recieve this kind of error: 
```
Transaction simulation failed: Error processing Instruction 2: custom program error: 0xa1 
    Program 11111111111111111111111111111111 invoke [1]
    Program 11111111111111111111111111111111 success
    Program 11111111111111111111111111111111 invoke [1]
    Program 11111111111111111111111111111111 success
    Program 2d2wEgqzGP57pzxJHgXywYK7psrBg3LL5xAzqxPnhcUn invoke [1]
    Program log: Custom program error: 0xa1
    Program 2d2wEgqzGP57pzxJHgXywYK7psrBg3LL5xAzqxPnhcUn consumed 10293 of 200000 compute units
    Program 2d2wEgqzGP57pzxJHgXywYK7psrBg3LL5xAzqxPnhcUn failed: custom program error: 0xa1
```
It is the 161 error with message: "No 8 byte discriminator was found on the account"
How to find out what is wrong with passing accounts? Maybe I do something wrong
Thank you wery much in advance
yes but it mostly limited by transation size
Hi,
I am getting this error: `Function _ZN4sdfi4sdfi4swap17hb5f9a96f6444d36dE Stack offset of -4168 exceeded max offset of -4096 by 72 bytes, please minimize large stack variables` for a CPI. Is there a limit for the accounts' number we can provide to a CPI? (My inputs are some AccountInfo, some Mint and TokenAccount Accounts put in a Box and two u64)
Hey, I recall someone saying that M1s had issues with unconfirmed tx's in 30 seconds - Is that still the case / has anyone found a fix for it?
oh you're right, i totally misread the question
I think you'll still be constrained by the limitation you need to pass in the PDA itself to create it, in which case it would be better to use anchor `init` in your instruction.
perfect thanks `UncheckedAccount<'info>` is exactly what i was looking for

>Out of curiosity, what's the reason you don't want to create it without init?

basically the way my program is designed it stores a list of pending votes and then there is a crank that looks for any votes that have finished and then creates an account with some data for them for the votes that passed. I need to first look at which votes have finished to create the account. This is another reason the client doesnt really know which PDAs it needs to pass it so im thinking I may want to redesign the program in some way but thats how it is currently
Out of curiosity, what's the reason you don't want to create it without `init`?
`pub account_to_create: UncheckedAccount<'info>`
Since the account hasn't been created yet, it doesn't have an owner, but anchor will check that it is when you use the anchor AccountInfo wrappers - use `UncheckedAccount`
for this example, how do you specify the account in the instruction? it seems when i try and specify it without (init) it fails with account not owned by program
```rust
#[derive(Accounts)]
pub struct Crank<'info> {
    #[account(mut)]      <---------- this is an account i want to create manually - not using (init)
    pub account_to_create: Account<'info, TokenInfoAccount>,
    pub payer: Signer<'info>,
    pub system_program: Program<'info, System>,
}```
It Worked !! Thanks a lot <@!134416332509675520> !
this gist gives the relevant code: https://gist.github.com/maddyonline/951951e524ea8e3fc03fc69ef0ce49a9
Hi everyone, I got redirected to this from Solana discord. I am trying to use Phantom wallet to sign a txn for basic-1 example. It is failing for me. So I deployed the following program https://github.com/maddyonline/anchor-basic-1-example using 
```
anchor deploy  --provider.cluster devnet
```
Above example is a clone of https://github.com/project-serum/anchor/tree/master/examples/tutorial/basic-1


Then I am trying to run a react app which uses Phantom wallet to sign the ‚Äúinitialize‚Äù transaction.
https://github.com/maddyonline/anchor-react-starter

But it fails with the following error:
```
The given account is not owned by the executing program
```
<@!866934864917037106> I don't think nested `#[account]` use like that works‚Äîwhat happens if you change the `#[account]` line above Tasks to be `#[derive(AnchorSerialize, AnchorDeserialize, Clone)]`?
`$ solana --version
solana-cli 1.7.8 (src:7aced9e7; feat:2045430982)`

`$ anchor --version
anchor-cli 0.16.0`

`$ npm --version
6.14.14`

`$ cargo --version
cargo 1.54.0 (5ae8d74b3 2021-06-22)`

`$ rustc --version
rustc 1.54.0 (a178d0322 2021-07-26)`

`$ node --version
v14.17.5`
Generated IDL file
Cargo.toml:
`[package]
name = "taskdapp"
version = "0.1.0"
description = "Created with Anchor"
edition = "2018"

[lib]
crate-type = ["cdylib", "lib"]
name = "taskdapp"

[features]
no-entrypoint = []
no-idl = []
cpi = ["no-entrypoint"]
default = []

[dependencies]
anchor-lang = "0.16.0"`

Xargo.toml:
`[target.bpfel-unknown-unknown.dependencies.std]
features = []`
Hey guys, so we are developing a task management app on top of solana using anchor. I getting an error when using a custom struct 'Task' and a vector of type 'Task'.

Error: `Unhandled Rejection (IdlError): Type not found: {"type":{"defined":"Task"}}`

Lib.rs:
`use anchor_lang::prelude::*;

declare_id!("3tXcACn8fgUn6sVtd4D7EjcoK1zNYrjP2eTMK2Zp2DPb");

#[program]
pub mod taskdapp {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>,
        authority: Pubkey,
        taskname: String,
        description: String,
        startdate: String,
        deadline: String,
        tokens: String,
        participants: Vec<String>,
        status: String
    ) -> ProgramResult {
        let base_account = &mut ctx.accounts.base_account;
        let task = Task {
            authority,
            taskname,
            description,
            startdate,
            deadline,
            tokens,
            participants,
            status
        };
        base_account.tasks_list.push(task);
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 1024)]
    pub base_account: Account<'info, BaseAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct Update<'info> {
    #[account(mut)]
    pub base_account: Account<'info, BaseAccount>,
}

#[account]
pub struct BaseAccount {
    pub tasks_list: Vec<Task>,
}

#[account]
pub struct Task {
    pub authority: Pubkey,
    pub taskname: String,
    pub description: String,
    pub startdate: String,
    pub deadline: String,
    pub tokens: String,
    pub participants: Vec<String>,
    pub status: String,
}`
i am clearly missing something i think

this is how i am importing my accounts
this is the error
I am trying to CPI into swap program to perform a swap
i have to continuously delete /deploy/
why does it seem like that anchor build does not override previously built .so file?
You should be able to airdrop via sollet or cli
anyone care to spare some devnet SOL por favor ü•∫
got it. ya it is PDA but i wanted it to be be based on data in another account and be dynamic so like client wouldnt know which accounts are being created. I guess thats not possible so client will have to know somehow which accounts
Oh apologies, misunderstood your question - you have to pass in the account from the client - but if it's a PDA your client can generate that.
hmm so greeks account (one being created) is still passed in though. in my case I want to dynamically pick the account to create so the client wouldnt know which account to pass in there
But if you're doing a normal pda you can use the anchor init and that works fine (this uses zero_copy)
```
pub fn create_greeks_account(ctx: Context<CreateGreeksAccount>, nonce: u8) -> ProgramResult {
    msg!("Create greeks account.");
    let rent = Rent::get()?;
    let ix = create_account(
        ctx.accounts.admin.key,
        ctx.accounts.greeks.key,
        rent.minimum_balance(size_of::<Greeks>() + DISCRIMINATOR_SIZE),
        (size_of::<Greeks>() + DISCRIMINATOR_SIZE) as u64,
        &ID,
    );

    let seeds = greeks_seeds!(zeta_group = &ctx.accounts.zeta_group.key, bump = nonce);

    invoke_signed(
        &ix,
        &[
            ctx.accounts.admin.to_account_info().clone(),
            ctx.accounts.greeks.to_account_info().clone(),
            ctx.accounts.zeta_program.to_account_info().clone(),
        ],
        &[&seeds[..]],
    )?;

    let account_info = &ctx.accounts.greeks.to_account_info();
    write_account_discriminator::<Greeks>(&account_info)?;
    Ok(())
}

pub fn write_account_discriminator<T: Discriminator>(account_info: &AccountInfo) -> ProgramResult {
    let mut data = &mut account_info.try_borrow_mut_data()?;
    let mut disc_bytes = [0u8; 8];
    disc_bytes.copy_from_slice(&data[..8]);
    let discriminator = u64::from_le_bytes(disc_bytes);
    if discriminator != 0 {
        return Err(ErrorCode::LoadAccountDiscriminatorAlreadySet.into());
    }
    let dst: &mut [u8] = &mut data;
    let mut cursor = std::io::Cursor::new(dst);
    cursor.write_all(&T::discriminator()).unwrap();
    Ok(())
}

```
thank you! yes what i was trying to look at what the anchor macro code generates and do something similar but if the account isnt passed in it seems I have to make my own AccountInfo struct but not sure that is correct - snippet would be great
It's not that bad i'll send a snippet
Our large PDAs are created in a separate instruction that doesn't use `init` and writes the 8 byte discriminator. (this is due to stack size issues)
You can do this, it's just a bit more manual
are you talking about from client side? using anchor program account fetch? it seems to just return the account data. but dont you already know the public key since u passed it in as an arg to fetch?
since when you initialize a new pda, you have to pass in that account into the accounts in the create account instruction, does this mean that there is no possible way to have a program method that creates an account that the client doesnt know about (and doesnt pass in as an argument)
You can't close an account, and reinitialize it in the same instruction though
I routinely initialize accounts via pdas and use them in the same instruction
I'm pretty sure you can
has anyone ever had difficulty getting a `Pubkey` from the result of a call to `AccountClient.fetch`? It's correctly returning all of the other fields of my account datatype, but the public key is coming back as a `0`


///////////////////////////////////////////////////////////////////////////////////////////////

CPI is a good idea, since that's the main reason to introduce this type.
its enough if i change Loader -> AccountLoader or should i also add CPI to this test ?
ohhh oke
```
[programs.localnet]
zero_copy = "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"
```
Need to add the pid to the Anchor.toml
and i am trying to debug this
yeah i got problem that declare_id != deployed program address
We can just remove that `owner` line.
```#[derive(Accounts)]
pub struct CreateBar<'info> {
    #[account(
        init,
        seeds = [authority.key().as_ref(), foo.key().as_ref()],
        bump,
        payer = authority, owner = *program_id
    )]
    bar: AccountLoader<'info, Bar>,
    #[account(signer)]
    authority: AccountInfo<'info>,
    foo: Loader<'info, Foo>,
    system_program: AccountInfo<'info>,
}```
Will post in 15
Huh kinda traveling now
Link?
In context
Depends. Where is this?
<@!501570363566587905> this `owner = *program_id` should overwrite declare_id value ?
Or was at least
npmjs is down
Ok for some reason the tenth time worked. Probs a server issue of some sort. Ty üôÇ
I have not.
Hi all, moving back to yarn. The anchor dependency won't install. Typing : `yarn add @project-serum/anchor`
Will produce:
```
‚û§ YN0000: ‚îå Resolution step
‚û§ YN0032: ‚îÇ secp256k1@npm:4.0.2: Implicit dependencies on node-gyp are discouraged
‚û§ YN0032: ‚îÇ utf-8-validate@npm:5.0.6: Implicit dependencies on node-gyp are discouraged
‚û§ YN0061: ‚îÇ circular-json@npm:0.5.9 is deprecated: CircularJSON is in maintenance only, flatted is its successor.
‚û§ YN0061: ‚îÇ uuid@npm:3.4.0 is deprecated: Please upgrade  to version 7 or higher.  Older versions may use Math.random() in certain circumstances, which is known to be problematic.  See https://v8.dev/blog/math-random for details.
‚û§ YN0032: ‚îÇ bufferutil@npm:4.0.4: Implicit dependencies on node-gyp are discouraged
‚û§ YN0032: ‚îÇ node-addon-api@npm:2.0.2: Implicit dependencies on node-gyp are discouraged
‚û§ YN0035: ‚îÇ @npmcli/fs@npm:^1.0.0: The remote server failed to provide the requested resource
‚û§ YN0035: ‚îÇ   Response Code: 404 (Not Found)
‚û§ YN0035: ‚îÇ   Request Method: GET
‚û§ YN0035: ‚îÇ   Request URL: https://registry.yarnpkg.com/@npmcli%2ffs
‚û§ YN0000: ‚îî Completed in 13s 912ms
‚û§ YN0000: Failed with errors in 13s 914ms
```
Anyone encountered this pb before ?
fixed now tests crashes on `AccountNotProgramOwned` seems like it does not resolve owner auto like token
huh back to debuging
Looks correct.
```impl<'info, T: ZeroCopy + Owner> Accounts<'info> for AccountLoader<'info, T> {
    #[inline(never)]
    fn try_accounts(
        _program_id: &Pubkey,
        accounts: &mut &[AccountInfo<'info>],
        _ix_data: &[u8],
    ) -> Result<Self, ProgramError> {
        if accounts.is_empty() {
            return Err(ErrorCode::AccountNotEnoughKeys.into());
        }
        let account = &accounts[0];
        *accounts = &accounts[1..];
        let l = AccountLoader::try_from(account)?;
        Ok(l)
    }
}```
Loader had it implemented to i also added it to AccountLoader
i think so
Are you using `Accounts::try_accounts` anywhere?
what do you mean ?
Are you using the symbol?
fixed now hit `Could not resolve Accounts symbol`
We're probably being lazy somewhere in the code. I.e. not using a trait when we should.
Though we can change the method signature if needed.
ohhh yeah
No because `AccountLoader` doesn't need the `program_id`.
but arguments should be same ?
ok will check it
Sounds like it's using the `AccountLoader` method signature with the `Loader` arguments.
in zero_copy
i am creating separate test and just wanted to swap Loader for AccountLoader
nope
I see the tests pass. Is this resolved?

trying to implement AccountLoader and got this error when changed Loader to AccountLoader
oh gotcha, that PR is super helpful! I'll try to do like <@!831450660146642974> said and just put each in their own ix (thanks pikachoo!)
just wondering if this is a general restriction of sorts. Since I'm just passing the account in as `new web3.Pubkey(xxx)`
nope not that I know of
Any constraints on the account?
I want to push my other question again (the reason why I even needed this pubkey stuff to begin with)
I want to pass in a pubkey from the client and transfer some SOL from the user to that address (instead of a PDA). Is that doable?
thanks a ton üôÇ
ayy it actually worked and builds now
let me try
that's clever
btw, you also can use:
```rust
mod my_key {
anchor_lang::solana_program::declare_id!("xxx")
}
```
and
```rust
#[account(mut, address = my_key::ID)]
```
IIRC `declare_id` transform base58 to u8 array on compilation stage
it should be possible, all the programs declare their own ID or even the `declare_id` macro, which are all pubkeys ü§î
Yep, you need to use https://crates.io/crates/lazy_static but not sure that this will works in bpf
still not happy about that pubkey 
```
error[E0015]: calls in statics are limited to constant functions, tuple structs and tuple variants
  --> programs/xxx/src/lib.rs:20:33
   |
20 |   static MY_KEY: Pubkey = "xxxx"
   |  _________________________________^
21 | |     .parse()
22 | |     .unwrap();
   | |_____________^
```
Yeah, just checked, missed this in updates. Try `#[account(mut, address = MY_KEY)]`.
for these 
```
    #[account(address = spl_token::ID)]
    pub spl_token_program: AccountInfo<'info>,

    #[account(address = system_program::ID)]
    pub system_program: AccountInfo<'info>,

    #[account(address = spl_token_metadata::ID)]
    pub metadata_program: AccountInfo<'info>,
```
yes üòÑ
Do we have `address` constraint? ü§î
```
    #[account(mut, address = MY_KEY.as_ref())]
    pub foo: AccountInfo<'info>,
```
still doesn't let me use it for the `address = MY_KEY.as_ref()` annotation though üò¶ 
`    |          ^^^^^^^^ no implementation for anchor_lang::prelude::Pubkey == &[u8]`
But better would be use `Pubkey::new_from_array` (https://docs.rs/solana-sdk/1.7.1/solana_sdk/pubkey/struct.Pubkey.html#method.new_from_array) because it's `const` method.
thanks
ohhhhh!
`static MY_KEY: Pubkey = "xxx".parse().unwrap();`
just sol, the instruction is correct because I used that with PDAs before, but when I change it from PDA to just mutable account and pass the publickey in I'm getting that 0x92 error
Do you want to send Sol or a specific token?
no, I want to send to a wallet that I don't own the pkey for, so just publickey
you need to do a KeyPair: `anchor.web3.Keypair.generate()`
lots of questions from me today, but I'm trying to do a transfer() from user to a wallet (not PDA) of my choosing specified by Publickey. The account is marked `mut`, but when I pass in a `new web3.Publickey(xxx)` I'm getting "custom program error: 0x92" which is based on source code `ConstraintSeeds`

Is this doable in solana, or do I have to go through a PDA first? (User -> PDA -> Other wallet)
hmm it expects a tokenstream though, not a &str
-----------------------------------------------------------
How to retrieve a PDA PubKey when knowing the seed and bump nonce?
1- create a pubKey 
2- Define your Account structure containing the array
3- pass the pubKey to the program + in your function context add `#[account(init)]` for this ProgramAccount
4- Fill the Account attributes in the function body
What is the best way to create an account with an array, pass it to the program and update it?
You need to use ".parse", not "from_str".
background is, I want to use the `address = ` attribute to check a account address passed is what I expect it to be
what's the right way to declare a static pubkey in a program to use with the `address = ` annotation? 

trying to do a simple `static MY_KEY: Pubkey = Pubkey::from_str("xxxx").unwrap();` but getting function or associated item not found in anchor_lang::prelude::Pubkey (complaining about the `from_str`)

why's the function not found? Pubkey implements the FromStr trait
(I just love how I figure out the solution 10 seconds after asking the question, after struggling for few hours beforehand)
I'll answer this! You're passing your program's ID instead of Token Program ID. yw
I want to create an array of strings or intergers and pass it on to my program. Can someone help me or point me to some docs or examples?
```
//(uses @solana/spl-token)
const recipientTokens = await Token.getAssociatedTokenAddress(ASSOCIATED_TOKEN_PROGRAM_ID, program.programId, mint, recipient.publicKey)` 

//(uses @project-serum/anchor)
const recipientTokens2  = await utils.token.associatedAddress({mint, owner: recipient.publicKey})
```
return different public keys. What da fuq am I missing?
Hah good find
https://github.com/project-serum/anchor/issues/481
just removed all .DS_Store files from my project and now it builds fine again
I found the culprit! omg! it's `.DS_Store`! 
If programs/ contains `.DS_Store`, anchor cli isn't able to handle it. The reason why after copying it had this error was because I opened the folder in finder, which created a .DS_Store
both same encoding, same permissions ü§î
ok get this - if I *copy* my lib.rs over to the new project it results in the `not a directory` error, but if I copy only the filecontents to a new lib.rs, no error
it normally lives at the project root but it gets created by test validator runs and so on
oh I replicated it
I also think that somehow some file got created that shouldn't be there that's causing this
no .anchor file. Where would that usually be?
if you somehow ended up with `.anchor` as a file not a directory it might cause that
maybe check hidden dirs, e.g. `.anchor`? that might be something copy missed
I tried initing a new project and copied my files 1by1 over - no issues
I'll just go with that and leave why it doesn't work a open mystery
man they are identical lol
I'm now comparing the 2 projects to see if I'm missing anything but this is very odd
and like I said, it works in a new project with `anchor init`. The only difference is the toolchain version, so I pinned it to be the same with `rustup override set` but no good
I even deployed today
yes same, m1. but it was working until like... a few hours ago
Same problem. I'm using a mac M1
Does somebody who use anchor was updated fields in PDA? Do we have an issue for this?
(by update I mean something like MarketState in serum-dex: https://github.com/project-serum/serum-dex/blob/0c730d678fd5ec0b07b17465e310a7f2a81b6681/dex/src/state.rs#L197)
If you on linux, you do not need to build anchor-cli from source, npm package exists for this: https://www.npmjs.com/package/@project-serum/anchor-cli
maybe I'll try downgrading
tried that already to no luck
Random idea to try, what if you delete the target/ directory (so you can rebuild from scratch)?
you didn't build the cli from source at all?
I'm looking at my git diff and nothing besides the solana program changed, and stashing that also doesn't do anything
a new installation with anchor init builds. did something recently change?
Lol, well, I can reproduce your error by deliberately trying to confuse anchor, like deleting the target/ directory and then replacing it with a regular file, e.g. `touch target`.
```
‚ùØ cargo install --git https://github.com/project-serum/anchor --tag v0.17.0 anchor-cli --locked
‚ùØ anchor --version
anchor-cli 0.17.0
```
Ah, ok, hmm
I'm using the cargo one
```
‚ùØ which anchor
/Users/david/.cargo/bin/anchor
```
@project-serum/anchor-cli doesn't work on macs, so you'll need to uninstall it
so yes I think
I did upgrade the npm package for a repository I am working on
I keep getting lucky with this‚Äîare you on a mac and did you accidentally install the npm anchor-cli package?
hmm all anchor commands give me that error. did my installation get borked somehow
huh getting this all of a sudden
```
‚ùØ anchor build
Error: Not a directory (os error 20)
```
Also using the anchor `try_from` to convert `AccountInfo` will let you deserialize it / check that it is program owned and have anchor discriminator - just a bit more manual.
But also üôÄ
It is very useful for flexibility in accounts passed in i.e. say you wanted to crank the serum dex via CPI - you have a variable amount of `open_orders` to pass to the instruction and that lets you do so without needing to have different instructions for variable account numbers.
But yeah, you're totally right that it's risky/inconvenient to use `remaining_accounts`‚Äîyou're basically back in non-anchor land, since they're just raw solana `AccountInfo`s üò±
ah interesting, thank you
Not totally sure about this but at the moment I don't think you can specify a `#[derive(Accounts)]` struct with a variable number of accounts in it (there's a pr up to support `Vec`s of accounts but it hasn't been merged in yet). So one use for `remaining_accounts` is as an escape hatch if you really do need to pass a variable number of them
(I'm specifically looking at serum/multisig project fwiw, if I hear from them I'll post the answer here)
right right, but why would you want this? I.e. they're not serialized presumably, so what do you do with them?
just a random guess: accounts that aren't managed by anchor through KV could be in the remainingAccounts part?
(running into it in some code I'm reading, but wondering the purpose in general)
what is the purpose of `remainingAccounts` argument when passing context? I can't quite understand what this is for
that's a good explanation
ah I see
like for everything
only the program can mutate the lamports balance
so you cannot sign and create a system program transfer anymore
once you create a bpf-loader account, bpf-loader owns it
hmm so if I can use a pkey for the program, what stops me from using the pkey as my private wallet as well ü§î that's not doable right
Will do once this finally gives me one lol 
```
Searched 238000000 keypairs in 1245s. 0 matches found.
```
Should be able to. Try it out!
could I just put that keypair into the deploy/ folder and have anchor use it?
hey guys, quick q: how can you grind a vanity address for a deployed program?  Still just solana-keygen grind?
if updates are valid on their own for 1 account it might be better to just make one ix per account, the overhead is quite minimal
Mm, I think `#[derive(Accounts)]` doesn't support vectors of accounts yet (https://github.com/project-serum/anchor/pull/782), but I guess you could use the `remaining_accounts` field on `ctx` (they're just unvalidated AccountInfos, so have to be careful/do things manually)
Ah I see. Hrmmm ü§î Would the solution be to break each one into its own instruction? e.g. something like this
```
    pub fn update_pda_acct(ctx: Context<UpdatePda>, new_data: u64) -> Result<()> {
        let mut pda_acct = ctx.accounts.pda_acct.load_mut()?;
        pda_acct.data = new_data;
        
        Ok(())
    }
```
This is interestingly not possible in solana‚Äîyou have to pass all accounts that you want to use as actual accounts, no within-program lookups allowed
yessir
So you wan to pass the array of pubkeys as an instruction argument? Like `pub fn some_ix(ctx: Context<Something>, the_pdas: &[Pubkey])`?
So I think I'm missing something super obvious, any help would be amazing. Is there a way to update the data of a program-derived address given just the pubkey or seed/bump?

I'm generating the program addresses client side (accounts already created in a prior transaction) and then wanting to pass an array of the PDA pub key's to a program that'll update all their data fields. In my head I'm trying to figure out something like
`for each PDA account pubkey in an array get the actual PDA account and update its data`, but I feel like there's an inbetween step/problem that I just can't quite put my finger on?
Haha the reason for this was to keep only business logic inside the main function and strip out the boilerplate.
Yep! I tend to just inline everything personally
ahh i think I get it now!  The use of from/into in the escrow example was confusing to me.  Is there a reason for doing that beyond style? Can I keep all of the CPI building within my function?
The program uses a single PDA with seeds = [b"escrow"] (just some static value) and makes it the authority for each individual spl token account holding escrowed tokens
Your program could use a program-derived address for this. You can see a similar use in the tests/escrow example: https://github.com/project-serum/anchor/blob/master/tests/escrow/programs/escrow/src/lib.rs#L76
can I make an executive contract account that is the authority of spl tokens?  And it has proxy calls to the SPL token program?  How do I use "self/this" or similar to sign the spl token CPIs as a contract, without needing a user to sign as the executive contract
This is what I was missing
I think you can pass seeds with `CpiContext::new_with_signer` https://project-serum.github.io/anchor/tutorials/tutorial-3.html#signer-seeds
Is it possible to use a PDA as a signer for an anchor CPI call? I don't know where to supply the signer seeds.
What's the most idiomatic <:pepeThink:844646497911046164>
Or maybe the right thing is to use "access_control()" which allow pre business logic check with custom error. Altough it's not access_control here but more like parameters_checks
Related to https://discord.com/channels/889577356681945098/889889146087301151/895466502520709130
Not sure there is already a way to do this and I'm not aware, feels weird to move checks in there, but only half of them, cause I keep some in the IX block for specialized errors.
Or maybe I should not move checks that are business logic there? Seeking guidance
^^ exactly how I fixed <a:9843pepenarutorun:880176525784281129>
Nvm, fixed it by adding more SOL.
Can you elaborate a bit!
ah! there is a final amount of sol required to deploy the program which may not be checked above the amount shown when running the deploy command
Thank you üôÇ
Good luck!!
let me look elsewhere
I am working on the solana ignition hackathon
What are you working on?
Good think is it usually is a simple fix
Weird... When I get that error, that usually is the problem
Checked the wallet in Anchor.toml has more than 3 SOL
I get this eventually on mainnet even with a funded account
oohhh let me check
No worries... IT might be that the wallet in the anchor.toml isnt the wallet with the 3 sol
let me load more..
sorry
I loaded 3 sol or so in that
No need to post in both chats... ppl read both
It means you dont have enough money to deploy it
<@!501570363566587905>
Can anyone help
Program deploys on localnet but getting this on deploying to devnet
```
Error: Deploying program failed: Error processing Instruction 1: custom program error: 0x1
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }.
```
I believe you set this using the solana cli
i can't find anything about how i can deploy with my own keypair.  or about anchor keys ...
or is deployment broken on older versions of anchor?
only occurs on mainnet also, private rpc or public
is there any way to reduce or speed up the number of transactions when deploying? i seem to be getting an recurring loop when trying to deploy
Aha ! Okay, i will read about it in document ( if it's exists ), Thank you
You can see what's already in your workspace with `anchor keys list`. Or you can make your own.
You can deploy with your own keypair file.
i should deploy it at least one time
so for first time i don't know what is the address
The address just needs to match whatever contract you're interacting with.
and this is correct way ? i mean i should change this after first deploy and then redeploy ?
yes your are right
10 days i spend to find this
i want to cry, now i can go to next tutorial ( Tutorial-2 ) üòÜ
Although the declare_id requirement is there for good reason! Many people forget to check owners in their programs.
Sorry you had to deal with that! We need better documentation.
Correct!
we should change this with program_id and then rebuild and redeploy !
i search into document and i can not find any thing about "declare_id!" ( just in tutorial 2, there is a little details )
after 10 days, finally i solved the problem ! and it's so weird !
when deploying i am stuck in a loop, does this mean some txs are failing?
==> Tutorial-1 Problem :
how i can fix this error ?
https://github.com/project-serum/anchor/issues/826


///////////////////////////////////////////////////////////////////////////////////////////////

I'm also having issues with running the test validator locally then `anchor deploy` so maybe that's the issue
I was letting tests spin one up also tried running a local validator with `solana-test-validator` followed by `anchor test --skip-deploy` getting the same error in both cases
That's a pretty low-level solana error as far as I can tell.
How are you running the tests? Against a local validator vs letting the tests spin one up for you, etc.?
I tried removing all of the accounts from the context object and all input arguments and I'm still getting the same error for some reason -- so currently the function looks like `initialize(ctx: Context<Initialize>)` where Initialize has just a single field `rent` and i'm calling `program.rpc.initialize({accounts: { rent: SYSVAR_RENT_PUBKEY }})` and it's failing with the `index out of bounds error`
Jet's code is all public
not sure who else
Saber and Jet are both using anchor
I was planning to write a good example and helper code within solana explorer for anchor based projects. I did a fairly large integration for mango markets a while back but it was very custom, with anchors decoder class it should be fairly easy. This could serve as a good example for future. If anybody of you out there has a settled project on mainnet I would love access to your idl, so I could use your project as the example, feel free to DM me
it just needs the trait to be implemented. It's implemented for program accounts but not CPI accounts
I want to use the Rust code from the anchor repo in my anchorpy repo so I can run all the same tests using anchorpy. How best to do this? Git submodules maybe?
Would be interested if you figure this out
but it's probably best to just keep it in a separate function
i need to drain the account first
even with zero rent
account should stay alive until transaction ends
i think so
hmm, ok probably just have to make it a separate instruction
but i think that it would probably reclaim rent immediately
nope i think close is used to reclaim rent
has anyone done this before? There's a `close` keyword but that is a different thing I think
hmmm, i want to close a PDA token account and reclaim the rent
idk honestly i would try to google that `Failed to get crate data for crate11`
why stopped compiling after I upgraded?
huh
rustup --version         
rustup 1.24.3 (ce5817a94 2021-05-31)
getting something like this...
```
thread 'rustc' panicked at 'Failed to get crate data for crate11', compiler/rustc_metadata/src/creader.rs:136:32
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

error: internal compiler error: unexpected panic

note: the compiler unexpectedly panicked. this is a bug.

note: we would appreciate a bug report: https://github.com/rust-lang/rust/issues/new?labels=C-bug%2C+I-ICE%2C+T-compiler&template=ice.md

note: rustc 1.52.1-dev running on x86_64-apple-darwin

note: compiler flags: -C opt-level=3 -C embed-bitcode=no -C lto=no -C opt-level=2 --crate-type cdylib --crate-type lib

note: some of the compiler flags provided by cargo are hidden

query stack during panic:
end of query stack
error: could not compile `
```
but now I cant recompile
I got it deployed, after I upgraded anchor and solana
try using solana directly
guys, trying to deploy to mainnet and none of my transactions are getting confirmed and just keep retrying.
My solana version is 1.7.11 and anchor-cli 0.15.0
any help would be much appreciated
devnet is always quick üòÑ
on devnet same deploy was super quick
Sanity check <@!501570363566587905> ?
I think program by default inserts its program_id thats why seeds validation fail
some other people complained about that too in the solana discord. I think might just be slow
Can we use seeds in CPI ? ```
pub struct CheckCpi<'info> {
    #[account(
        mut,
        has_one = authority,
        seeds = [authority.key().as_ref(), foo.key().as_ref()],
        bump,
    )]
    bar: AccountLoader<'info, Bar>,
    authority: AccountInfo<'info>,
    foo: AccountLoader<'info, Foo>,
}``` Bar is owned by other program ?
maybe your transactions are not confirming
give it some time if it owrks
not failing, but just repeating
been going over and over this part
```
[584/1771] Transactions sent
```
+ for deploy on mainnet i would use solana directly
nope
anchor deploy on mainnet taking forever, is this normal?
anyone good with borsh? I'm trying to figure out how to properly serialize `[u64; 4]` in javascript
tried to use something like `new BigUint64Array(4)` with schema `["my_field", [4]],` but it ain't liking that. Do I need to write my own serializer for BN?
it should already update the idl
when I deploy a program to the mainnet, do I also need to run `anchor idl init` after? I had to in the devnet
ah so it's just calling the other things 
```
        pub fn reject_migration(ctx: Context<RejectMigration>) -> ProgramResult {
        ctx.accounts.validate()?;
        instructions::approver::reject_migration(ctx)
    }
```
Hopefully this is useful üôÇ 
https://github.com/DeployDAO/migrator/blob/master/programs/migrator/src/lib.rs
any examples on how to split methods into different files? since it all has to be under the `program` macro
https://discord.com/channels/428295358100013066/517163444747894795/894361752576360468
has anyone seen errors like this before when writing js tests? I'm not sure how to go about debugging this ```SendTransactionError: failed to send transaction: invalid transaction: index out of bounds```
The error occurred in the context of a program.rpc call
Hi, I've created a program which has an account to save some event data. Now I would like to allow users to subscribe to the event and also allow them to add some extra information individually. What's the best way to save this information? Should I create a PDA for each user and associate an account to the PDA to save its data?
would it be possible to use `Box` for zero copy accounts? i tried just now and it seems like it only works for `Account` for not `Loader` which is used byzero copy
yes, or https://github.com/mercurial-finance/create-ata-if-missing-program/blob/master/src/lib.rs
I wrote this to be a lazy ATA creator, because we have a backend that does stuff concurrently and it is error prone to rely on a query. But that's only if you do intense crap.
Thanks I'll try that out!
thanks a ton to <@!134416332509675520> for the almost hour long debugging session! my program is running fine now üôÇ
So to recap it seems the best approach for now is to handle token creation outside of the program, via the `instructions:` attribute in the rpc call, which are executed before your program instruction. You could check in the client if the token account has been initialized or not, and would conditionally add that instruction to the list.
agreed
but the token account is more like a client thing
for others, it is done inside for convenience
for pdas you cannot do it outside
the `init` attribute could be entirely replaced with `instructions: [..]` right? or is there any other big reason why acc initialization lies inside the program?
i agree, however I also find the `init` attribute quite useful too, and perhaps it would be handy to support that use case, and wouldn't be that big of a change, i guess?
yes
for example, using the `instructions: [intialize_acc]` in the RPC interface?
you can add instructions with the instructions argument of program.rpc.<method>
keep the program simple
creating the token account should be done as another instruction
oh i misunderstood the use case
ah, yeah actually that doesn't work safely
If that is a good idea for an improvement, I'd be down to tackle it
So you mean any account given with `init` should be able to be passed as already initialized?

And that wrapper you are talking about would just check if acc hasn't been initialized and initialized, otherwise just let it pass?
to be able to say if exists { blabla } else { init_pda....}
i think when it is less canonical we just need a nice wrapper in the method body
interesting question. I am also curious to hear more experienced folks answer, it perhaps would be cool to have a `get_or_init` attribute on accounts
I have a program that can mint tokens. What's the best way to support initializing new token accounts? Should I have an initialize() instruction that just initializes the token accounts? Or should I have a initializeAndMintTo() for minting to uninitialized accounts and a mintTo() for minting to initialized token accounts?
one day a hero will fix the CLI lol
It's funny that the error is so opaque. You try to deploy and solana is like üôÑ
yup, it requires a lot more SOL than I had initially expected
oh that would be super helpful
Sure! Just sent you a dm in case you want to try screensharing for a bit
thanks for always helping me debug my cryptic errors üòÖ
I commented my entire method so it's just an empty thing that does `Ok(())` 
so it really looks like this is coming from something in anchor
Hmm, are you getting this error from a cpi to another anchor program?
I can mark accounts I don't own as `mut`, right?
so if I replace this account with a pda it works 

```
    const [acc, bump] =
      await this.deriveAddressFromProgram("foo");
```
with 
```
    const acc = new web3.PublicKey(
       "xxxx"
    );
```
Heh, I think you must be getting this error from somewhere else in the program then (someplace with a seeds constraint‚Äîthough sounds like you're aware of that, so possibly a non-obvious place). Can you post more of your code?
yeah still the same error tried that already üòÖ
If you remove the `address` constraint entirely, do you get the same 0x92 error?
it's not a program or PDA, just a wallet
yeah I saw that too, but no. I just want to pass it in to make it a target for a transfer() instruction 
```
    #[account(mut, address = hogehoge::ID)]
    pub acc: AccountInfo<'info>,
```

Is it even allowed to pass wallets in like this?
0x92 = 146 = ConstraintSeeds ü§î Do you have a `seeds = [...]` constraint on that account in your anchor program?
Hey guys! I'm having problems passing a user wallet with `new web3.PublicKey("xxx")` into a program that expects a `mut` AccountInfo
Getting     `Program log: Custom program error: 0x92`
I accept the witchcraft and will proceed to 0.17.1 everywhere
interestingly, composites seems to work better with 0.17.1 types than the @saber-hq/anchor-contrib ones
It doesn't seem to typecheck the ix/rpc arguments as well as the saber-hq thing
without going through workspace
i forgot that none of the example actually consume the idl
i saw it just now, i was searching for the wrong thing
This is what the tests do. https://github.com/project-serum/anchor/blob/master/tests/escrow/tests/escrow.ts#L17
this is happy
We should probably leave at least one test around as pure javascript.
`const program = new Program<JupiterIdl>(JupiterJSON as JupiterIdl, JUPITER_PROGRAM_ID);`
Feel free to.
Seems hacky but does it work?
Yea it's probably unhappy using the type as a value.
`const program = new Program(JupiterJSON as Idl, JUPITER_PROGRAM_ID) as Program<JupiterIdl>;` ?
Do i need to make the typescript test use the types? (I need this oktoberfest tshirt, not that i want to help)
so i believe i also need the json?
it would take the json value before as Idl
I don't see a single example
I have ts types
Yeah, sorry, should have picked better names‚Äîit's the first byte of lower-case `something` (the u64)
acutally it's not `Something`, it's the arguments you pass after the context
:/
The only thing to do is to move the derive macro inside the `#[program]` mod and process everything in one macro.
Ooooh
exactly! i actually encountered this before lol, and forgot
But there's no other good way to get the instruction data inside the derive macro.
ahh yes
Yea it's a bit of a hack.
`bump` must be the first arugment
For example, if you have `pub fn some_ix(ctx: Context<Something>, something: u64, bump: u8)`, then doing `#[instruction(bump: u8)]` will grab the first byte of `something` ü•¥
if I use `#[instruction(bump)] `
i know what it is
ohhh yes
Of the `#[instruction(...)]`  attribute? Yeah, tbh I think this is kind of a big gotcha‚Äîthe instruction attribute deserialization is totally independent of the instruction handler args!
The cleaner fix is to wrap your args in a struct which works perfectly - I haven't looked into it deeper but its to do with the serialization from client or deserialization from rust
yes
I ran into this issue too, seems like ordering of the arguments matter ...
noob question but once i have master cli i need to remove the npm one, is that right?
was it actually a problem with SOL balance?
<@!752231111232585881> -- did you ever solve the `custom program error: 0x1` issue on devnet? I'm getting the same thing
well i am in the middle of implementing something, it is then PERFECT TIME for me to try that
ok
(need the CLI on master to generate that).
There's no scaffolding. Just need the `target/types/<program>.ts` file which defines the ts type.
or does it work with no effort?
The saber one had some scaffolding
Where do i learn how to use that thing?
https://www.npmjs.com/package/@project-serum/anchor/v/0.17.1-beta.1
I am still using the saber-hq anchor contrib stuff
wat
I never used a anchor program as a dependency with `ProgramTest`, so the entrypoint wasn't gone
Well, no way except writing something that actually generates client code
Mypy kinda sucks
I don‚Äôt think there‚Äôs any way to achieve the same thing in Python üò¢
Damn that‚Äôs sweet
yes yes, exactly
Oh so for example it catches if you say  `program.rpc.initialise` when it should have been `program.rpc.initialize`?
so it just makes programming much safer and easier
also you get intellisense autosuggest and things like that
if you misspell an rpc call, or pass the wrong argument you'll get an error right away, as opposed to having to actually run the code, hitting that specific line (if you're lucky) and getting an error at runtime
it means your calls to onchain programs are now typesafe, so many more mistakes will be caught at compile time
What does this do for us? I don‚Äôt really have enough JS/TS knowledge to understand
this just levels everything up an order of magnitude
Thanks to <@!124564013970358272> <@!840683071496912916> <@!812755783405797376>
<@!501570363566587905> -- the typesafe Program<idl> in 0.17.1 beta is amazing üî• üî• üíØ
issue was I was trying to use AuthorityType::AccountOwner and to change the auth of mint I need to use AuthorityType::MintTokens.
so im creating a mint/spl token in my admin front end, and then trying to pass the authority to a contract by using set authority with  AuthorityType::AccountOwner and a pda.  I'm getting "Error: Account does not support specified authority type'".   I tried to follow the escrow example where it sets a token account's authority in a similar way.  Does this fail for mint accounts, or do I have some other issue?
RefCell is inherently unsafe, allowing you to use the "interior mutability" pattern in Rust, which means you can have an immutable object, but still have the ability to get a mutable reference out of it.
Which, of course, is a runtime check as per the RefCell API.
And when you CPI,  it checks that you don't have any outstanding mutable borrows.
Because `load_mut` takes a mutable borrow to the `AccountInfo`'s `RefCell` on the data field.
dropping worked for the first one but not for the second.
let mut some_account = ctx.accounts.some_account.load_mut()?;
let some_account = &mut ctx.accounts.some_account.load_mut()?;
<@!501570363566587905> dropping did helped. thanks. may I ask what happened here? why runtime is throwing this error instead of compiler doing this?
<@!831450660146642974> I know you have experience using program test. Any thoughts on the above? I suspect the fix I suggest above is the way to go.
If I import the dependency without the feature flag I get a double entrypoint error
Yeah, that would make my life way easier. I am having to import my own project with no-entrypoint so I can have access to the anchor entry.
What happens if you don't use that feature flag?
We should remove the second feature gate, perhaps.
Ah you are right.
https://github.com/project-serum/anchor/blob/master/lang/syn/src/codegen/program/entry.rs#L54
The entry function isn't there when the dependency has the feature no-entrypoint
Just not *the* entrypoint used by the solana runtime.
There is still an `entry` function.
I've got a question about testing. Say I've got a project built with anchor that I am importing as a dependency with the feature "no-entrypoint". Now I want to add that program to my ProgramTest context but I need a processor entrypoint point. How would I add the anchor project to my ProgramTest?
when creating a token account owned by the program, is it better to do that client-side and pass in the account or do it like this in the anchor program itself:

#[account(init, seeds = [b"my_seeds".as_ref()], bump = token_bump)]
pub program_owned_token_account: Account<'info, TokenAccount>,
that didn't help
If you have loaded an account, and you pass that same account to CPI, you need to drop the account prior to cpi.
using load_mut
yes
Are you using zero copy?
Sounds like a double refcell borrow.
This happened when I tried to mutate an account data which is previously sent to spl mint instruction as mint authority.
Anyone familiar with this error? `Failed to borrow a reference to account data, already borrowed`


///////////////////////////////////////////////////////////////////////////////////////////////

If i wasn't so busy with the smart contract stuff I might actually be able to understand how anchor is built finally and contribute a little
Things make a lot more sense
i started watching Doug Milford's rust videos again. Actually went through generics, ownership and borrowing
<https://www.youtube.com/playlist?list=PLLqEtX6ql2EyPAZ1M2_C0GgVd4A-_L4_5>
just debugging client code is so intimidating
i have mostly successfully avoided reading <@!867369388608061470> 's foresight API / client code
Especially if you have to work with another developer
For anchor tests it's totally fine. But for a complex GUI it's a nightmare.
this is my understanding of what all client side coding is like
javascript for writing anchor tests work fine for now
thankfully this is something i mostly don't have to deal with
lol
Yes. It's called tyepscript üòõ
doesn't javascript support types now?
Look at sollet. Everytime you change one thing, something stupid breaks because a variable is undefined.
Nightmare.
nope
Have you ever tried to refactor someone else's javascript?
i respect this youtuber and he ranks javascript way higher than typescript in this `The Official Programming Language Tier List 2021` video
 <https://youtu.be/AzLqTgC0E0s>
Fair.
üòõ
i would use types if javascript was reasonml
Say it to me.
You love types.
Redux is trash.
you dont understand the pain of typescript
You love types.
you never used redux
i hate types
You and me.
Tom. We will have a talk in lisbon.
:.:
in the world
i am the msot anti types person
Can we make this typescript?
lol
Excuse me. Found it https://github.com/tomland123/react-anchor-tutorial.
I'm lazy and want to steal your code.
<@!867369388608061470> where is your anchor UI repo?
For the general case that anchor would need, I doubt thats suitable though
Essentially we expect logs every block, if multiple pass with no logs we perform a reconnect
Ive built some functionality around this noticing the same thing
Though it's possible that has changed.
For reasons I dont appreciate, they have not been reliable on the solana RPCs.
Still output unfortunately, must be through a different file descriptor than stderr
My experience has been to avoid websockets.
Can you elaborate on this? Switchboard is highly incentivized to use this in prod
Not currently. Can you get them with a try catch?
Is there a way to disable/redirect the transaction error logs emitted from the typescript module on tx failures?
Nice. `addEventListener` then is just a function of susbcribing to `onLogs` and calling the decode `logs[]` function.
that part's done üéà
I.e. being able to parse logs and decode events.
Though the mechanics are high priority.
Websockets are a bit busted so probably low priority.
emoji reacts will be interpreted as yes
are people using `.addEventListener` in prod? Trying to gauge how much demand there might be for it in anchorpy
GL
YEP
just to check my calc is correct here,  one pubkey is of type [u8; 32], so 32 x 1 byte * total amount of pubkeys
got it working! it created the account for measly 2.2 SOL on my local test validator üòÇ 
I'll be reconsidering if I really need this data onchain, but thanks for the help <@!149990576572334080>
ahh Isee
keyword `zero`
find how i did it in synthetify
you need to init it first i think
<@!149990576572334080> you sure it doesn't need a discriminator? I created an empty account on js and tried to pass it along into my init instruction
```
    #[account(mut, constraint = acc.to_account_info().owner == &id())]
    pub acc: Loader<'info, Acc>,
```

But getting AccountDiscriminatorMismatch
Hmmm... Checking...
yep
you just create it ahead of time with the program set as owner, then pass the pubkey into the program for storing right
seems like you might be mutating a copy
We‚Äôre having this problem where Anchor `init` seemingly overwrites our data with zeros.

So we‚Äôre importing struct and then use it as 
`#account(init, payer = sender, signer)
pub metadata: Account<‚Äòinfo, ImportedMetadataStruct>` and then pass it to the crate where it gets filled with data and then after returning to the Anchor code it‚Äôs zeroed out.
just not pda
nope its still anchor account
or does it still need the first 8 bytes
for this you created the account without anchor, so without 8 byte descriptor?
that's a nice idea
oh wait yeah that could work
Does your program own the account? (Can't remember your use case) If so you can just write to it, no need for it to sign anything
thats no problem
you can also write
ah for reading
assets_list list is zero_copy but not pda
https://github.com/Synthetify/synthetify-protocol/blob/de5a26bae7bae5e4fec0c526ac86b9429d0c54a1/programs/exchange/src/context.rs#L17
how can the program write into it with just pubkey? Or you mean for reading
but u can pass pubkey in invocation
yep
dumb question, but how would you be able to use a normal account from within a program for writing? thought if it's not a pda you'd need it's pkey to write to it
and in pda hold reference to big account
if you need pda just use 2 accounts
my stuff would be more than 10kb
ah damn okay
regular can be up to 10mb pda 10kb
use AccountLoader Loader will be deprecated
it's a pda
Ah, yeah‚Äîis this account behind a pda or a regular address?
maybe it's just not really feasible to store this amount of data onchain üòÖ
getting closer 
```
    SystemProgram::CreateAccount data size limited to 10240 in inner instructions
```
Yeah just needed to call `exit` explicitly and the state persisted. thanks <@!134416332509675520>
okay I see
There might also be a way to do what you want to do (not blow the stack) with careful use of `Box` but not totally sure
The basic idea of Loader is to take the account's underlying, low-level solana `AccountInfo<'info>` and kind of just squint at the `.data` field and pretend it's a `&mut MyAccount` rather than what it really is, a `&mut [u8]`
> Note that using accounts in this way is distinctly different from using, for example, the ProgramAccount. Namely, one must call load, load_mut, or load_init, before reading or writing to the account. For more details on zero-copy-deserialization, see the account attribute.

ah I see
Yeah, you'll have to use `Loader<'info, MyAccount>` instead
like if I just add the zero_copy attribute to my account, I'm getting "the trait bound `MyAccount: anchor_lang::AccountSerialize` is not satisfied" when I try to use it from within a instruction struct
I read through that already but it's still not really clear how to use it. I also haven't used Loader before
Actually I guess the zero_copy docs are pretty good here https://docs.rs/anchor-lang/0.17.0/anchor_lang/attr.account.html#usage
haha appreciate the help
will try manually calling exit
Oh, right, good point
Ok I was looking at that `exit` function and was thinking that the `Accounts` in `Context` must have it called for them whereas the `Account` I create from `remaining_accounts` doesn't
`greeting_account.serialize(&mut &mut account.data.borrow_mut()[..])?;` sheeeesh
More generally this is what anchor ends up doing under the hood: https://github.com/project-serum/anchor/blob/master/lang/src/account.rs#L83
Using that Writer interface is surprisingly hard lol, a lot going on in that one line
Are you doing something like this? https://github.com/solana-labs/example-helloworld/blob/master/src/program-rust/src/lib.rs#L44
Heh, I'm not sure / realizing I don't totally know how you're supposed to use this stuff either, so doing some source reading ü§ø
More generally I want to pass an optional account into an instruction, so if there is a better pattern I'm also open to that
I'm trying to take an account in the `remaining_accounts`, deserialize it into an anchor Account and mutate it's state and have the mutation persist. I haven't managed to get it to work yet. I can deserialize the account, but the change doesn't persists. Has anybody done this before and can point me to an example?
if there are better ways to store public keys I'm open to recommendations üòÑ I just want to keep a track of all minted tokens this program produces
any links to docs by chance? Been through the examples in the tests/ folder already
So you'll need the zerocopy + Loader strategy
so how does that zero_copy stuff work?
5000 * 32 > solana's 4096 stack size
That won't solve your whole problem though because an account that big w/out doing the zerocopy stuff will almost certainly blow the stack
oh issit
<@!137101040687382528> well, seems like adding `borsh = { version = "0.9", features = ["const-generics"] }` to your program's dependencies is enough to wake borsh up to the possibilities of arbitrary N
But now I'm curious if there's a nicer way obviously
To unblock you I guess you could just implement BorshDeserialize/BorshSerialize yourself (you'd basically just copy-paste what that silly macro thing is doing)
uhh so anything I can do to get it serialize [Pubkey; 5000]? ü§î
But yeah, if it's not working for you, maybe not ü§î
I think that's only if your rust compiler doesn't support const generics yet (hence the need to do the silly impl macro-pasting for likely values of n, lol)
not having much luck with that zero_copy stuff
`anchor_lang::AccountSerialize is not satisfied` with zero_copy as well ü§∑‚Äç‚ôÇÔ∏è
```
//! This example demonstrates the use of zero-copy deserialization for accounts.
//! Zero-copy is a deserialization technique that creates data structures by borrowing
//! (not copying!) from the array holding the input, avoiding the expensive memory
//! allocation and processing of traditional deserialization.
//! With zero-copy, we can create accounts larger than the size of the stack or heap,
//! as is demonstrated by the event queue in this example.
```

hmm
Yeah I can't help you with details as to whats going on under the hood, but my understanding is that you're right there's a limitation on array size and zero_copy helps you get around that somehow ü§∑‚Äç‚ôÇÔ∏è the comments in tests/zero_copy explain it a bit i think
this? 
```
    #[account(zero_copy)]
pub struct ChatRoom {
    head: u64,
    tail: u64,
    name: [u8; 280],            // Human readable name (char bytes).
    messages: [Message; 33607], // Leaves the account at 10,485,680 bytes.
}
```
i'm looking through the code but don't full understand how it's helping here
I think you need to use `zero_copy`, look at the zero_copy or chat examples in the `/tests` folder in the anchor repo
ah looks like it's only supported up to 2048 length arrays in borsh - https://docs.rs/borsh/0.9.1/src/borsh/de/mod.rs.html#514
is that a strict limitation of what's doable, or can I just implement the trait for my length array myself
I want to store a larger array of Pubkeys as state in one of my programs but the current serializer doesn't support that yet. Anyone got a example how to extend it to add support?
hey guys! what's a good way to calculate how much storage an account needs? 
Was using .byteSize in javascript but there are some fields that can't be serialized with borsh properly (like u64 array), so the size is off. Currently just using paper lol
Hmm, interesting! I wonder if you ended up using a different version?
hmm yeah it turned out to be an issue with the way i was including the dependency, but I still don't really understand why this works. The solution was to follow the dependency structure in the cfo example such that `serum-dex` and `swap` are both included as top level dependencies rather than referring to `serum-dex` directly through `swap`. Again not entirely sure if this was the issue but now it's working
thanks for the reference! I can probably track down the error from there. 

I'm doing the cpi pretty much exactly the same as in cfo so it looks something this in the cpi context construction: 
```
fn from(accs: &CreateOpenOrders<'info>) -> Self {  
            let program = accs.dex_program.to_account_info(); 
            let accounts = dex::InitOpenOrders {
                open_orders: accs.open_orders.to_account_info(),
                authority: accs.program_authority.to_account_info(),
                market: accs.market.to_account_info(),
                rent: accs.rent.to_account_info(),
            };
            CpiContext::new(program, accounts)
```
Then I sign it with a signer from seeds for the program_authority account 
```
use anchor_spl::dex
....
dex::init_open_orders(cpi_ctx.with_signer(&[&seeds]))?;
```
I wonder if it's an issue with the way I include serum_dex as a dependency. Currently, I'm using the one that's a dependency of `swap` which I'm also using.
How are you doing the cpi? If that ^ is the error then I'm a bit surprised, since I would expect code like the anchor cfo example to at least send a valid instruction (maybe the accounts could be messed up, but the instruction would at least parse)
I would personally probably go source-diving in the dex code. I guess this is where that ProgramError::InvalidArgument gets raised? https://github.com/project-serum/serum-dex/blob/master/dex/src/state.rs#L2403 (I found the ProgramError variant by searching the solana source code for "invalid program argument")
has anyone made SPL token faucets work on localnet? https://www.spl-token-ui.com/#/token-faucets
Is there any way to suppress stderr for tests that expect an exception to be thrown? e.g. the test in anchor/tests/interface/tests/interface.js which has an `assert.rejects`.
how would people recommending debugging an error with cpi? I'm trying to create an open orders account on serum dex through a cpi -- similar to how its done in the anchor/tests/cfo directory, but getting this ```    'Program 9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin failed: invalid program argument',``` error
We've got a large client library wrapping each of our commands manually doing this haha
Probably very hard to do, but would be cool to eventually automate the JS client commands where use of `has_one` are happening. If that account isn't provided, automatically fetch the root account to get the `has_one`. Or automatically generate accounts with `init` and `seeds`.
sadly I don't have one in mind, but I saw these guys were posting something related to pseudorandom generation, perhaps you could reach out or dig deeper: https://twitter.com/draffleluckclub
Yeah that is also another valid approach! I believe you could also improve that by wrapping all the common stuff into `CommonAccounts` and embedding them into another `YourInstructionA` and `YourInstructionB`

such as:
common definition:
https://github.com/DeployDAO/migrator/blob/master/programs/migrator/src/account_contexts.rs#L154-L164

reusability:
- https://github.com/DeployDAO/migrator/blob/master/programs/migrator/src/account_contexts.rs#L44
- https://github.com/DeployDAO/migrator/blob/master/programs/migrator/src/account_contexts.rs#L62
btw, how to I know the estimated cost of deploying a program on the solana mainnet?
my use case is a small raffle so I imagine it should be okay
pseudo random means that miners could tamper right
for pseudo random?
do you have some sample github repo in mind I could take a look at?
My rust is pretty awful lol
Cool, everyday you learn something new... I worked around it by having two instructions one with and one without, that sucked ass
so checks the owner, and then tries to deserialize the data, which might perform a discriminator check if it is an Anchor account
yeah it seems it does. This is the implementaiton of `Account::try_from`

```rust
    pub fn try_from(info: &AccountInfo<'a>) -> Result<Account<'a, T>, ProgramError> {
        if info.owner != &T::owner() {
            return Err(ErrorCode::AccountNotProgramOwned.into());
        }
        let mut data: &[u8] = &info.try_borrow_data()?;
        Ok(Account::new(info.clone(), T::try_deserialize(&mut data)?))
    }
```
That would be great to know, I figure if that's what's used underneath, its possible it checks that too
What I am not sure is if this thing checks for ownership or not, I'll dig a bit more later
Gotcha, thanks a lot man you rock üî•
both, I believe, if its an Anchor defined struct. If it is a barebones struct with no discriminator (such as Token) then it wouldn't be able to check it and just try to deserialize it
yeah, in this example `map` is used because `.get(0)` returns an `Option<AccountInfo>` as there might or might not be a remaining account with the given index `0`. So the `map` is saying something like "if there is an AccountInfo, try to call `Account::try_from` on it)
`Account::try_from` receives an `AccountInfo` and tries to deserialize it's data into the expected Account type (in this case `Account<TokenAccount>`) 

It uses the trait `anchor_lang::AccountDeserialize` for a given Account, so for `TokenAccount` it uses the following:
https://github.com/project-serum/anchor/blob/e763b721c37d7b36fa283d2f973bc8c76ca96abc/spl/src/token.rs#L267-L282
that checks the discriminator too? or just the info structure?
the map takes the try_from function and applies it to the get(0) response
Ohh.. forget it, my rust is so bad lol
I suppose try_from would receive the struct I want to verify
you would have to check them yourself, however here is what I am doing myself to deserialize and perform some basic assertions:

```rust
let maybeToken: Option<Result<Account<TokenAccount>, ProgramError>> = ctx.remaining_accounts.get(0).map(Account::try_from)
```
I see, thanks bro <@!103986638320861184>... those remaining_accounts can have macro-based validation? or will I have to check that imperatively?
There is no random oracle yet that I know of, hopefully chainlink adds something soon. For now you would have to implement some kind of pseudo-random using like the current timestamp + current blockhash or something like that
curious if there is a better way to represent these "Optional Accounts"
I had a similar question and had to end up handling those optional accounts via the `remaining_accounts` and accessing them with something like: `ctx.remaining_accounts.get(0)`
(looking at solidity we cant do that without using oracles.... but in Solana, how does this work?)
what is the best way to do this?
how someone go to pick a random index from an array in a Solana program?
hey guys
I have something like this 

```rust
#[derive(Accounts)]
pub struct CreateAccount<'info> {
    #[account(
        init,
        payer = authority,
        space = 8 + 32 + 32,
    )]
    pub new_account: Box<Account<'info, NewAccountStruct>>,
    pub optional_account: Box<Account<'info, OptionalAccountStruct>>, // <----- I want this to be optional
    #[account(mut)]
    pub authority: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```

If I don't provide the "optional_account" when doing program.rpc.createAccount I get an error saying that optional_account wasn't found
Is it possible to have an optional account when using `#[derive(Accounts)]`?
ah i think i fixed it for some reason didn't have sol in my account so airdropped in order to fix the `anchor deploy` issue also seemed to fix `anchor test` issue. does the account need to have sol on localnet in order to run `anchor test`?


///////////////////////////////////////////////////////////////////////////////////////////////

