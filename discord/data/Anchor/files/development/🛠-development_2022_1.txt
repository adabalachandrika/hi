He/she's my hero from now on bro
<@!134416332509675520> setting üî• to this discord from day 1 of 2022
it is, but private right now, but I'll make it public right now then
Does this live in a github repo? Would be easier to debug that way
Program A <- handles data, owns data accounts which is made by `createWithSeed`
Program B <- handles logic, get data accounts (owned by Program A) by client and handles logic in Program B, and gives data and account to Program A

That's my whole scheme
So any subsequent instructions that use that account won't use `#[account(zero)]` anymore
That instruction will end up automatically writing the 8 byte discriminator
Sorry, I'm being sloppy with my language: you can create the account in a separate instruction, that's fine. You then use `#[account(zero)]` in your own program to "initialize"/set up that account
So, What I want to do is that I want to use data account which is already initialized...
What do you mean? Not quite sure what you're asking
Basically just have to read the source unfortunately
Where can I find the docs about that decorators?
omg... How can I make it possible with initializing / existing account all along?
I don't think that would lead to the ConstraintZero error ü§î
I put GREETING_SIZE + 16
Ah, sorry, you can only use the `#[account(zero)]` constraint once, when initializing the account
What the problem was -> space was GREETING_SIZE + 8
So What I'm currently struggling on is if I try on existing data account, it throws ConstraintsZero error. I'm thinking of space problem
```
const SEED = '11111111112222222222333333333320' // spl token
        newDataAccount = await anchor.web3.PublicKey.createWithSeed(clientWalletAccount.publicKey, SEED, dao.programId)
        const dataAccount = await dao.provider.connection.getAccountInfo(newDataAccount)

        if (dataAccount === null) {
            console.log('Creating account', newDataAccount.toBase58(), 'to say hello to')

            const lamports = await dao.provider.connection.getMinimumBalanceForRentExemption(GREETING_SIZE + 8)

            let createNewAccDao = new anchor.web3.Transaction().add(
                // create account
                anchor.web3.SystemProgram.createAccountWithSeed({
                    fromPubkey: clientWalletAccount.publicKey,
                    basePubkey: clientWalletAccount.publicKey,
                    seed: SEED,
                    newAccountPubkey: newDataAccount,
                    lamports,
                    space: GREETING_SIZE + 8,
                    programId: dao.programId,
                }),
            )

            await dao.provider.send(createNewAccDao, [clientWalletAccount])
        } else {
            console.log('success')
            console.log(dataAccount)
        }
```
Here I make data account with createWithSeed
you mean my ts code?
I'm actually not sure why you'd get that error just because of doing different space stuff, can you post your code?
Yes exactly 8 bytes
https://docs.rs/anchor-lang/latest/anchor_lang/attr.account.html
if I add 10 or 16 or other byte then it throws 'ConstraintsZero' Error
So, when I test it, it has to be exact '8' bytes
lol I spent a day figuring out that exact same thing. Forgot to add the bytes for the discriminator
You saved so much times for me
although I have another errors haha
So thankful
Because anchor uses the first 8 bytes of account storage (at least for accounts you interact with via the `Account<'info, Whatever>` type) for the "account discriminator": anchor marks the account with its intended struct type, so you don't accidentally deserialize it as some *other* struct
One last question, Why I have to add 8?
cqfd, you are the besty
GREETING_SIZE + 8
Oh I see
I mean for the account allocation part, you aren't giving that new account enough lamports
Hmm but I have 3.5SOL in my wallet...
You're not paying enough for rent anymore
0x7d5 = 2005 = https://github.com/project-serum/anchor/blob/master/ts/src/error.ts#L70
```
  console.error
    Transaction simulation failed: Error processing Instruction 0: custom program error: 0x7d5 
        Program GdySSAQ5BGoa11mUHoHDeJZdmyZQbreguyBJLu8XMvS9 invoke [1]
        Program log: Instruction: Initialize
        Program log: Custom program error: 0x7d5
        Program GdySSAQ5BGoa11mUHoHDeJZdmyZQbreguyBJLu8XMvS9 consumed 4684 of 200000 compute units
        Program GdySSAQ5BGoa11mUHoHDeJZdmyZQbreguyBJLu8XMvS9 failed: custom program error: 0x7d5
```
Okay, now new error
You can debug by just randomly allocating 9000 or whatever
Ah really
You need however much for the account data plus 8 for the discriminator bytes
Yep
Are you allocating enough space?
Where I make data account with `createWithSeed`:
```
const SEED = '11111111112222222222333333333346' // spl token
        // ÌÅ¥Îùº ÌçºÎ∏îÎ¶≠ÌÇ§, SPL token ID, DAO ÌîÑÎ°úÍ∑∏Îû® IDÎ°ú ÏÉà Îç∞Ïù¥ÌÑ∞ Ïñ¥Ïπ¥Ïö¥Ìä∏ ÏÉùÏÑ± (ÌòπÏùÄ Ïù¥ÎØ∏ ÏûàÎäî Ïñ¥Ïπ¥Ïö¥Ìä∏ Í∞ÄÏ†∏Ïò§Í∏∞)
        newDataAccount = await anchor.web3.PublicKey.createWithSeed(clientWalletAccount.publicKey, SEED, dao.programId)
        // newDataAccountÍ∞Ä Í∞ÄÏßÄÍ≥†ÏûàÎäî DAO ÏÜåÏÜç data account
        const dataAccount = await dao.provider.connection.getAccountInfo(newDataAccount)
        // data accountÍ∞Ä nullÏù¥Î©¥ DAOÍ∞Ä ÌôÄÎî©ÌïòÎäî data accountÎ•º ÎßåÎì§Ïñ¥Ï§ÄÎã§.
        // nullÏù¥ ÏïÑÎãàÎ©¥ Í∑∏ÎÉ• Ìï¥Îãπ Îç∞Ïù¥ÌÑ∞ Ïñ¥Ïπ¥Ïö¥Ìä∏Î•º ÏÇ¨Ïö©ÌïúÎã§.
        if (dataAccount === null) {
            console.log('Creating account', newDataAccount.toBase58(), 'to say hello to')

            // Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïù¥Ï¶àÏóê ÎßûÎäî ÏµúÏÜå rentÎπÑ Î¨¥Ïãú Ï†ÅÏû¨Îüâ Í≥ÑÏÇ∞
            const lamports = await dao.provider.connection.getMinimumBalanceForRentExemption(GREETING_SIZE)

            // Ìä∏ÎûúÏû≠ÏÖò
            let createNewAccDao = new anchor.web3.Transaction().add(
                // create account
                anchor.web3.SystemProgram.createAccountWithSeed({
                    fromPubkey: clientWalletAccount.publicKey,
                    basePubkey: clientWalletAccount.publicKey,
                    seed: SEED,
                    newAccountPubkey: newDataAccount,
                    lamports,
                    space: GREETING_SIZE,
                    programId: dao.programId,
                }),
            )

            // Ìä∏ÎûúÏû≠ÏÖò Ïã§Ï†ú Î∞úÏÉù
            await dao.provider.send(createNewAccDao, [clientWalletAccount])
        } else {
            console.log('success')
            console.log(dataAccount)
        }
```
Ok, 0xbbb = 3003 = AccountDidNotDeserialize
```
  console.log
    Translating error SendTransactionError: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: custom program error: 0xbbb
        at Connection.sendEncodedTransaction (/Users/bakjuna/dev/cyber-wave-anchor/node_modules/@solana/web3.js/src/connection.ts:3689:13)
        at processTicksAndRejections (internal/process/task_queues.js:95:5)
        at Connection.sendRawTransaction (/Users/bakjuna/dev/cyber-wave-anchor/node_modules/@solana/web3.js/src/connection.ts:3649:20)
        at sendAndConfirmRawTransaction (/Users/bakjuna/dev/cyber-wave-anchor/node_modules/@solana/web3.js/src/util/send-and-confirm-raw-transaction.ts:27:21)
        at Provider.send (/Users/bakjuna/dev/cyber-wave-anchor/node_modules/@project-serum/anchor/src/provider.ts:114:18)
        at Object.rpc [as initialize] (/Users/bakjuna/dev/cyber-wave-anchor/node_modules/@project-serum/anchor/src/program/namespace/rpc.ts:24:23) {
      logs: [
        'Program GdySSAQ5BGoa11mUHoHDeJZdmyZQbreguyBJLu8XMvS9 invoke [1]',
        'Program log: Instruction: Initialize',
        'Program log: Custom program error: 0xbbb',
        'Program GdySSAQ5BGoa11mUHoHDeJZdmyZQbreguyBJLu8XMvS9 consumed 3962 of 200000 compute units',
        'Program GdySSAQ5BGoa11mUHoHDeJZdmyZQbreguyBJLu8XMvS9 failed: custom program error: 0xbbb'
      ]
    }
```
That's my full error log
I'm really thankful for your help
Sorry, you're going to have to provide way way more information if we're going to help you debug! Can you post code + the full program log?
will try a fresh deployment
it's still not working and could probably be this https://discord.com/channels/889577356681945098/889577399308656662/926867597620813876
I made sure that the `declare_id` is same everywhere. It was not initially. I used the local net id but was testing with devnet
I'm not sure, so I'm just constantly changing signers, or newDataAccount's properties
What have you tried so far?
this is me
Hmm can I get your advice a little bit more plz i'm stuck up in that state...
People constantly skip that step lol, it's very easy to accidentally forget
You have to edit the declare_id! and then *remember to re-run anchor build* before you re-run `anchor deploy`
It's extremely easy to goof up changing your declare_id when you deploy
Can you show your program log?
nope did not help
the id is the same everywhere
I will try to redeploy
For Alex + Shivek
Is your comment for me? or Alex?
E.g. if you look at your program log, the id it prints had better match your declare_id
I mean all accounts which should provided to the program should be owned by the program
Check that your declare_id matches the actual runtime program id
what do you mean?
I think that's not a problem, rather it's a config
just came here to check. is this is a known problem?
damn, I got the same error right now
Transaction error:  Error: 3007: The given account is owned by a different program than expected

Here we go again
Anyway my account did not deserialized, then it means createWithSeed account is not deserialized....
Yeah, you have to convert to decimal (annoying)
16th error
Oh okay like 0x10 is 16 right
(Kind of a goofy way to find them, but they're there)
You can find all of them in anchor's `error.ts` file
how could you find that error message?
I was always wondering how could I get proper error message also
0xbbb = 3003 = AccountDidNotDeserialize
Yeah it was always confusing to me also lol
in a different example it was myAccount üôÑ
fuck youre right
Right, it's `counter`, not `myAccount`
Maybe you named the account args incorrectly?
```#[program]
mod counter {
    use super::*;

    pub fn create(ctx: Context<Create>, authority: Pubkey) -> ProgramResult {
        let counter = &mut ctx.accounts.counter;
        counter.authority = authority;
        counter.count = 0;
        Ok(())
    }

    pub fn increment(ctx: Context<Increment>) -> ProgramResult {
        let counter = &mut ctx.accounts.counter;
        counter.count += 1;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Create<'info> {
    #[account(init, payer = user, space = 8 + 40)]
    pub counter: Account<'info, Counter>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct Increment<'info> {
    #[account(mut, has_one = authority)]
    pub counter: Account<'info, Counter>,
    pub authority: Signer<'info>,
}

#[account]
pub struct Counter {
    pub authority: Pubkey,
    pub count: u64,
}```
Well, your code is still wrong lol üòõ Can you post the rust side?
I literally copy and pasted the code from the example
```
#[program]
pub mod dao {
    use super::*;
    pub fn initialize(_ctx: Context<Initialize>) -> ProgramResult {
        Ok(())
    }

    pub fn set_data(ctx: Context<SetData>, data: ProgramAccountInfo) -> ProgramResult {
        let account_data = &mut ctx.accounts.account;
        account_data.level = data.level;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(zero)]
    pub my_account: Account<'info, ProgramAccountInfo>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[account]
pub struct ProgramAccountInfo {
    pub level: u32,
}

#[derive(Accounts)]
pub struct SetData<'info> {
    #[account(mut)]
    pub account: Account<'info, ProgramAccountInfo>,
}
```
```
#[program]
pub mod register {
    use super::*;

    pub fn register(ctx: Context<Register>, is_deposit: u64) -> ProgramResult {
        let cpi_program = ctx.accounts.dao_program.to_account_info();
        let mut account_data = ProgramAccountInfo {
            level: ctx.accounts.my_account.level,
        };
        account_data.level += is_deposit as u32;
        
        let cpi_accounts = SetData {
            account: ctx.accounts.my_account.to_account_info(),
        };
        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
        dao::cpi::set_data(cpi_ctx, account_data)?;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Register<'info> {
    #[account(mut)]
    pub my_account: Account<'info, ProgramAccountInfo>,
    pub dao_program: Program<'info, Dao>,
}
```
Can you show the rust side again?
Can you post your rust instruction function? I think you've messed up the arguments
I made a transaction like this:
```
const tx = await dao.rpc.initialize({
    accounts: {
        myAccount: newDataAccount, // made with createWithSeed
        user: provider.wallet.publicKey, // wallet
        systemProgram: anchor.web3.SystemProgram.programId,
     },
     signers: [],
})
```
Error: Invalid arguments: counter not provided
```
logs: [
   'Program GdySSAQ5BGoa11mUHoHDeJZdmyZQbreguyBJLu8XMvS9 invoke [1]',
   'Program log: Instruction: Initialize',
   'Program log: Custom program error: 0xbbb',
   'Program GdySSAQ5BGoa11mUHoHDeJZdmyZQbreguyBJLu8XMvS9 consumed 3962 of 200000 compute units',
   'Program GdySSAQ5BGoa11mUHoHDeJZdmyZQbreguyBJLu8XMvS9 failed: custom program error: 0xbbb'
]
```
So it actually failed......TT
What goes wrong?
hope this works
So thanks for the help, I'll try with it!
How can i call this in my react code?
Doing it like this:
```     const authority = wallet.publicKey;
      await program.rpc.create(authority, {
        accounts: {
          myAccount: myAccount.publicKey,
          user: provider.wallet.publicKey,
          systemProgram: SystemProgram.programId,
        },
        signers: [myAccount],
      });```
But already tried some varations
I think that would work, assuming program B owns the account üëç
well?
You can do nice formatting with three backticks "`"
Am I understood whell?
So to sum it up,
I initialized my account with `createAccountWithSeed` in first instruction in ts,
And I wanna store data in that account.
Then I pass it and data into Program-A,
and Program-A pass that account and data to Program-B with CPI,
so actual data store instruction is done by Program-B.
(because you allocated its account in a separate instruction)
`#[account(zero)]` says "this thing doesn't have any discriminator bytes yet"
Oh I'll try
So I successfully made my newDataAccount. So What I want to acheive is that I wanna pass that account to register program so that use it
You can then use that address in your anchor program by using the `#[account(zero)]` attribute
All good üôÇ
Where you just create the account on the client by executing the createAccountWithSeed instruction
sorry for my country's comment though
Right, that will work üëç
It's a totally separate, weird third kind of address (keypair addresses, PDAs, and then createWithSeed addresses)
```
    newDataAccount = await anchor.web3.PublicKey.createWithSeed(clientWalletAccount.publicKey, SEED, dao.programId)
        // newDataAccountÍ∞Ä Í∞ÄÏßÄÍ≥†ÏûàÎäî DAO ÏÜåÏÜç data account
        const dataAccount = await dao.provider.connection.getAccountInfo(newDataAccount)
        // data accountÍ∞Ä nullÏù¥Î©¥ DAOÍ∞Ä ÌôÄÎî©ÌïòÎäî data accountÎ•º ÎßåÎì§Ïñ¥Ï§ÄÎã§.
        // nullÏù¥ ÏïÑÎãàÎ©¥ Í∑∏ÎÉ• Ìï¥Îãπ Îç∞Ïù¥ÌÑ∞ Ïñ¥Ïπ¥Ïö¥Ìä∏Î•º ÏÇ¨Ïö©ÌïúÎã§.
        if (dataAccount === null) {
            console.log('Creating account', newDataAccount.toBase58(), 'to say hello to')

            // Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïù¥Ï¶àÏóê ÎßûÎäî ÏµúÏÜå rentÎπÑ Î¨¥Ïãú Ï†ÅÏû¨Îüâ Í≥ÑÏÇ∞
            const lamports = await dao.provider.connection.getMinimumBalanceForRentExemption(GREETING_SIZE)

            // Ìä∏ÎûúÏû≠ÏÖò
            let createNewAccDao = new anchor.web3.Transaction().add(
                // create account
                anchor.web3.SystemProgram.createAccountWithSeed({
                    fromPubkey: clientWalletAccount.publicKey,
                    basePubkey: clientWalletAccount.publicKey,
                    seed: SEED,
                    newAccountPubkey: newDataAccount,
                    lamports,
                    space: GREETING_SIZE,
                    programId: dao.programId,
                }),
            )

            // Ìä∏ÎûúÏû≠ÏÖò Ïã§Ï†ú Î∞úÏÉù
            await dao.provider.send(createNewAccDao, [clientWalletAccount])
        } else {
            console.log('success')
            console.log(dataAccount)
        }
```
That was what I did for initializing new data account, and it says success
`createWithSeed` actually doesn't create PDAs at all
Actually that's what I did.
You can find the PDA on the client and save the bump on the account. Is this an okay pattern? <@!134416332509675520>
At any rate anchor has no built-in support for init-ing accounts with createWithSeed, you'll have to do it all yourself
Then how can I use accounts with createWithSeed?
I think you're going to have to do the account creation part from the client
`init` doesn't use it (it's actually pretty rare to use `createWithSeed`)
Ok, right, that code won't work with createWithSeed unfortunately
and the other code is here:
```
#[program]
pub mod dao {
    use super::*;
    pub fn initialize(_ctx: Context<Initialize>) -> ProgramResult {
        Ok(())
    }

    pub fn set_data(ctx: Context<SetData>, data: ProgramAccountInfo) -> ProgramResult {
        let account_data = &mut ctx.accounts.account;
        account_data.level = data.level;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user , space = 64)]
    pub my_account: Account<'info, ProgramAccountInfo>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[account]
pub struct ProgramAccountInfo {
    pub level: u32,
}

#[derive(Accounts)]
pub struct SetData<'info> {
    #[account(mut)]
    pub account: Account<'info, ProgramAccountInfo>,
}
```
It's my rust code (simplified)
```

#[program]
pub mod register {
    use super::*;

    pub fn register(ctx: Context<Register>, is_deposit: u64) -> ProgramResult {
        let cpi_program = ctx.accounts.dao_program.to_account_info();
        let mut account_data = ProgramAccountInfo {
            level: ctx.accounts.my_account.level
        };
        account_data.level += is_deposit as u32;
        
        let cpi_accounts = SetData {
            account: ctx.accounts.my_account.to_account_info(),
        };
        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
        dao::cpi::set_data(cpi_ctx, account_data)?;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Register<'info> {
    #[account(mut)]
    pub my_account: Account<'info, ProgramAccountInfo>,
    pub dao_program: Program<'info, Dao>,
}
```
So I'm curious how you're making it work on the rust side
But I bet your rust side is the problem (createWithSeed is hardly ever used tbh)
No, the wallet signs automatically when you do the rpc part
So wallet keypair is not needed?
Can you show the rust side of your code?
Ah, no, you don't need to use the wallet keypair like that (the wallet signs the tx automatically!)
the signer should be a keypair, or if the wallet is signing you don't need to provide it as a signer, the wallet will automatically sign
SO when I make transaction like this:
```
            const tx = await dao.rpc.initialize({
                accounts: {
                    myAccount: newDataAccount,
                    user: provider.wallet.publicKey,
                    systemProgram: anchor.web3.SystemProgram.programId,
                },
                signers: [(provider.wallet as NodeWallet).payer],
            })
```
It fails with signature verification failed
That sounds fine so far!
So I wanted to make that data address with `createWithSeed`, which is made by someone's public key, and NFT ID as seed, and program ID
Umm... What I need is that someone holds NFT needs to be accessible to specific data address.
You can use the `createWithSeed` stuff without needing an actual keypair though (you just need to sign the tx appropriately, which doesn't require a keypair)
I'm not sure you get it
I want to make custom data addresses within specific NFT, so I wanna store data in specific program which holds NFT's ID to address's seed.
(I mean the wallet automatically signs)
In anchor when you send the transaction it automatically signs the tx correct?
Why isn't just having the wallet sign the tx enough?
Not sure why you need the actual keypair though for that
Oh Thanks
What I want to acheive is - 
I want to make a CPI communication and store data in account IN 'createWithSeed' address, not with generate method
It's slightly annoying, `(program.provider.wallet as NodeWallet).payer`
yep
Do you mean in your anchor tests?
How do I get my wallet's keypair using anchor?
Oh damn 
perfect, thanks!
This is actually covered in the tutorial: https://project-serum.github.io/anchor/tutorials/tutorial-2.html#clone-the-repo
How do I fix this?
Hey folks, I'm encountering problem with versioning up @project-serum/anchor to 0.19.0 fro 0.16.1, and It says 'workspace' has no exported member.
`use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
mod mysolanaapp {
    use super::*;

    pub fn create(ctx: Context<Create>) -> ProgramResult {
        let base_account = &mut ctx.accounts.base_account;
        base_account.count = 0;
        Ok(())
    }

    pub fn increment(ctx: Context<Increment>) -> ProgramResult {
        let base_account = &mut ctx.accounts.base_account;
        base_account.count += 1;
        Ok(())
    }
}

// Transaction instructions
#[derive(Accounts)]
pub struct Create<'info> {
    #[account(init, payer = user, space = 16 + 16)]
    pub base_account: Account<'info, BaseAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program <'info, System>,
}

// Transaction instructions
#[derive(Accounts)]
pub struct Increment<'info> {
    #[account(mut)]
    pub base_account: Account<'info, BaseAccount>,
}

// An account that goes inside a transaction instruction
#[account]
pub struct BaseAccount {
    pub count: u64,
}`

So i have this simple counter program. How do i do that only a specific wallet is able to increment the counter?
resolved issue, It was a version problem. When I updated anchor to 0.19.0, problem solved.
Hello, did you solve this issue?
hello,
I'm currently testing CPI program, and when I run 'build', it says SetData is private.

Here I got this error:

```
use puppet_master::cpi::accounts::SetData;
  |                     ^^^^^^^^ private module
  |
note: the module `accounts` is defined here
```
How can I solve this error? Plz help
On windows you should try using wsl, everything works great with Ubuntu
Please guys I‚Äôve been trying to install anchor on my windows machine for weeks now. I‚Äôm stuck here -

The following warnings were emitted during compilation:

warning: zstd\lib\compress\fse_compress.c:21:10: fatal error: hist.h: No such file or directory
warning:    21 | #include "hist.h"       /* HIST_count_wksp */
warning:       |          ^~~~~~~~
warning: compilation terminated.
warning: zstd\lib\compress\hist.c:20:10: fatal error: hist.h: No such file or directory
warning:    20 | #include "hist.h"
warning:       |          ^~~~~~~~
warning: compilation terminated.

error: failed to run custom build command for `zstd-sys v1.4.18+zstd.1.4.7`

Caused by:
  process didn't exit successfully: `C:\Users\HP\AppData\Local\Temp\cargo-installZ5pUrb\release\build\zstd-sys-f7e5dc0bb30787a0\build-script-build` (exit code: 1)

  --- stderr
  error occurred: Command "gcc.exe" "-O3" "-ffunction-sections" "-fdata-sections" "-m64" "-I" "zstd/lib/" "-I" "zstd/lib/common" "-I" "zstd/lib/legacy" "-fvisibility=hidden" "-DZSTD_LIB_DEPRECATED=0" "-DZSTDLIB_VISIBILITY=" "-DZDICTLIB_VISIBILITY=" "-DZSTDERRORLIB_VISIBILITY=" "-DZSTD_LEGACY_SUPPORT=1" "-o" "C:\\Users\\HP\\AppData\\Local\\Temp\\cargo-installZ5pUrb\\release\\build\\zstd-sys-302cf417acc75ab8\\out\\zstd\\lib\\compress\\fse_compress.o" "-c" "zstd\\lib\\compress\\fse_compress.c" with args "gcc.exe" did not execute successfully (status code exit code: 1).


warning: build failed, waiting for other jobs to finish...
error: failed to compile `anchor-cli v0.19.0 (https://github.com/project-serum/anchor?tag=v0.19.0#3afd1a22)`, intermediate artifacts can be found at `C:\Users\HP\AppData\Local\Temp\cargo-installZ5pUrb`

Caused by:
  build failed
given a transaction buffer and IDL, how do I deserialize it back to the RPC call?
It doesn't contain the scheme to build each account
Mmmh, no
when trying to interact with an onchain program, will the IDL contain the information i need about seeds for PDA's?
Especially with all the accounts that some RPCs need to be passed in
Thought that it would be nice to publish a WebAssembly package for all JS contract interactions, would be better separation of concerns
Was hoping to integrate with a React application like this tutorial suggests: https://codeburst.io/getting-started-with-react-and-webassembly-using-hooks-441818c91608
Any examples of someone creating NPM packages written in web assembly (de-compiled from Rust) for interacting with Solana programs?
A small Serum question for who knows Serum üòÄ üëá

In Serum I notice the variable orderClientId and clientId. Are these two the same thing? also, what's an expected input value? Thanks!


///////////////////////////////////////////////////////////////////////////////////////////////

what's the correct way to set up the addEventListener call so that it'll trigger a new transaction on every event?

something like

```
this.program.addEventListener("TestEvent", (event, slot) => {
      console.log(`Observed t event: ${event} at slot: ${slot}`);
      this.program.rpc.doSomething(...);   
});
```
Hi guys, I've been learning and experimenting with anchor for a couple of weeks, now i want to create a browser-based client but noticed that in most examples i've seen on github, a random keypair is generated to act as the wallet signer

```javascript
const post = web3.Keypair.generate()
await program.rpc.newPost(topic, content, {
    accounts: {
        author: wallet.value.publicKey,
        post: post.publicKey,
        systemProgram: web3.SystemProgram.programId,
    },
    signers: [post]
})
```

I'm curious, is this the best approach? In cases of PDAs, can this pattern serve as suitable replacement? Is there a browser based example with more details  that i read the code and try to learn from it? Thanks
i can create repro
deserialization is incorrect
yeah i know
but would still be interested why yours doesnt work. What exactly is the error?
you can upgrade to 0.20.1 and use packed again btw
if i add `#[repr(packed)]` alignment is fixed
I want to use 0.20.0 but cant wrap my head around why this stuff does not work ```#[zero_copy]
#[derive(Debug, Default, PartialEq, Eq, PartialOrd, Ord, AnchorDeserialize, AnchorSerialize)]

pub struct Decimal {
    pub v: u128,
}```
Hey Guys,

Just had a quick question about using Vecs of tuples in a struct. For example, I wanted to have the following:
```
pub struct ExampleStruct {
    pub a: Vec<(u8, u8)>,
}
```
This is able to build and deploy but running `anchor test` gives me a `User defined types not provided` error. I'm assuming that this means that Vecs of tuples aren't currently supported in the IDL.

Is my understanding here correct? If so, is there a workaround so that I could do something similar to this? Thanks!
anyone know where i could find an example of correct short-term rent calculations?
<@!134416332509675520> The hero ‚ù§Ô∏è
This is exactly what I needed! cheers
I want to have the code with the devnet and mainnet program ID included but be able to decide when to pick the devnet or mainnet ones depending of CI or test env etc. Due to auditing I want to change this externally
Is it possible to influence `    #[cfg(feature = "devnet")]` in the rust code from the `anchor test <specific option>` ?
I was to use pass a CandyMachine account into context. Is the CandyMachine struct published in a crate? If so whats it called?
ok, i made a pull request to make common public in case anyone else wants to close program accounts in the future
it looks like `common` is private unfortunately, maybe worth adding `close` to prelude
`crate::common::close()` this is how it's accessed normally inside the crate itself
dumb question but does anyone know how to access this method inside a regular lib.rs file?
lemme check this out!! THanks a lot
it's just 20
https://borsh.io/
maybe I should check out Borch related stuff
may I know how are `[u8; 20]` translated into `space` term?
exactly and they use `33` once because of the option
ah ok I found they actually specify the `space`
reason why Im asking is that, Im just following the metaplex code here https://github.com/metaplex-foundation/metaplex/blob/master/rust/nft-candy-machine/src/lib.rs#L457. Wonder why they dont have that error
thanks <@!347689664855015424>  any examples you can point me to? Big thanks
yea, rust's null pointer optimization probably. specify space manually in `init` according to the borsh specification
Hi there, Im hitting this error
```
Error: 164: Failed to serialize the account
```
I suspect the issue comes from my usage of `Option` in the definition of `#[account]`
```
#[account]
#[derive(Default)]
pub struct VaultAccount {
    pub campaign_name: [u8; 20],
    pub time: Option<i64>,
    pub mint: Option<Pubkey>,
}
```
Does anyone have some ideas? Thanks
Better to just add a frontend check and instruction
when using `#[account(init_if_needed)]` is there a way to tell within the instruction whether it's a new account or not?
I want to simply increment a counter within the account each time instruction it's called.
cause Program no longer requires T to implement AccountDeserializd
are you using an old anchor-lang with a newer anchor-spl?
yes this was intentional. what is your use case for deserializing `Token`?
Hi all 
i have code below but i don't know how to get  NodeWallet(keypair) 
anyone have ideal?
const mintNFTResponse = await actions.mintNFT({
    connection,
    wallet: new NodeWallet(keypair),
    uri: 'https://34c7ef24f4v2aejh75xhxy5z6ars4xv47gpsdrei6fiowptk2nqq.arweave.net/3wXyF1wvK6ARJ_9ue-O58CMuXrz5nyHEiPFQ6z5q02E',
    maxSupply: 1
  });
how can I use commitment with program.account.all() ? I see it's available with fetch() but no all()
If I have a user1 account key and airdrop some sol, the owner becomes the system program. I can transfer sol to other accounts and sign with user1 no problem.

But then I use that user1 public key to init a new account of a different type from my program. For example:
```
#[account(init, payer = authority, space = 64)
vault: Account<'info, Vault>,
```

Then I check the owner and the owner is now my program id instead of the system program. My program is able to take ownership from the system program?

Then I try to send sol from user1 to user2, except now I get the error that the user1 account may not be used to pay transaction fees. I assume this is because the user1 account is now owned by my program and not by the actual system program account anymore.

I've tried to transfer ownership back to the system program but I get the error illegally modified the program id of an account.

Does this mean the user1 account is now broken? What happens to the sol that was in there?

If I call web3.SystemProgram.createAccount with the user1 public key. I get the error account address already in use.

So does the anchors init attribute not check if the account address is already in use?
Looks like ```impl anchor_lang::AccountDeserialize for Token {
    fn try_deserialize(buf: &mut &[u8]) -> Result<Self, ProgramError> {
        Token::try_deserialize_unchecked(buf)
    }

    fn try_deserialize_unchecked(_buf: &mut &[u8]) -> Result<Self, ProgramError> {
        Ok(Token)
    }
}
``` was this removed from `Token` was this intentional?
Hey in the latest version of anchor I am now getting a bunch of api change type errors: ```error[E0277]: the trait bound `Token: anchor_lang::AccountDeserialize` is not satisfied
  --> programs/hydra-staking/src/lib.rs:49:24
   |
49 |     pub token_program: Program<'info, Token>,
   |                        ^^^^^^^^^^^^^^^^^^^^^ the trait `anchor_lang::AccountDeserialize` is not implemented for `Token`
   |
note: required by a bound in `anchor_lang::Program`
  --> /home/utx0/.cargo/git/checkouts/anchor-cdfdd1da98090750/bb67efa/lang/src/program.rs:13:35
   |
13 | pub struct Program<'info, T: Id + AccountDeserialize + Clone> {
   |                                   ^^^^^^^^^^^^^^^^^^ required by this bound in `anchor_lang::Program`

```
issue was lot of addresses in arguments ^ using remaining_accounts helped
Less signers especially
yes, use less accounts
Search for Box<>
are there any tips on reducing transaction size? the 1232 limit
hey people just wanted to ask what github repositories do you clone to start building your new dapps?
Looking for extra pair of hands

https://jobs.lever.co/Expopulus/a30ab3f9-bf2d-4e43-b3f3-07d11025a5f1


///////////////////////////////////////////////////////////////////////////////////////////////

Bumping this one more time if anyone has experienced similar issues
sorry üò¶
i am not aware of the problem any more because we stripped out the anchor types in our codebase
No, and you wouldn't wan to do that anyway. SOL should be stored in accounts, not programs
And <@!867369388608061470> - you had some ideas on the original post of this problem a few months ago.
No worries. It's this on build.  Maybe I just forget about Typescript for now!
No memory of this question sorry man! Still as bad in JS üòÅ
I'm having this same build problem and at the very periphery of my knowledge here.  Is "skipDependencies" a tsconfig option? Not sure what "importing from the dist file" is or if I'm doing that or not.
everything on solana is CLI this CLI that
is that what that line is doing? creating tokenization
https://github.com/jet-lab/jet-v1/blob/67b84d436011f983b598546aa7be677ed356d695/programs/jet/src/instructions/init_reserve.rs#L163
is there examples on how to deploy a spl token program from a rust contract
no but you can do that in a `constraint == my_account.is_signer || def`
is it possible to have signer constraint that is an or? `signer == abc || def`
hey üëãüèΩ I've deployed program to devnet and ve used it to create few accounts (user profiles). And now I've changed struct for such profile in the program and redeployed the program. and now I've struggled to fetch all accounts probably client can't parse old accounts (`Trying to access beyond buffer length`). 
Wondering what is best way to handle such issue? Should I deploy program with new program ID or rewrite all these old account somehow... ?
What do you mean by system program ser ?
Hey folks! Can we send and store sol in a system program?
yep, thats all i needed, muchas gracias amigo
getsignatureforaddress with limit?
anyone know what client calls are needed to get recent transactions for a given account?
It looks like these are definitely in the Anchor.toml https://github.com/search?q=org%3Aproject-serum+%22%5Bprograms.mainnet%5D%22&type=code
I would like to supplement your answer with the fact that there is no need to update (for this particular reason). This bug belongs to Anchor.
https://github.com/project-serum/anchor/blob/229e335da8402fd98fec1e972ca59070453d3be0/lang/src/error.rs#L68
if you cant upgrade, the only way to find what the error means is by printing our the message with `err.msg`  locally or by reading the `ts/error.ts` file in the anchor repo
If you can upgrade, pls upgrade to the latest anchor version. You can find the error codes for that version here https://docs.rs/anchor-lang/latest/anchor_lang/__private/enum.ErrorCode.html. It's possible it's not an anchor error though
dont cross post in multiple channels
Most likely you have transferred an account that does not belong to the program and are trying to do operations with it that imply this.
0.18.0
As I undestood , did U use anchor >0.20.0 version ?
i got error 0xa7, can someone point me to fix it
Resolved my issue by reverting to earlier versions of solana-cli and anchor cli

```
solana-cli 1.8.0 (src:4a8ff62a; feat:1813598585)
anchor-cli 0.18.2
rustc 1.57.0 (f1edd0429 2021-11-29)\
```

https://github.com/project-serum/anchor/issues/1157
Be careful though, I think you can only go upto 32 accounts
You can use remaining_accounts
Is there any way to pass an array of accounts and transfer sol to them in a function? without naming each in the struct
Any idea whats happening here? Any help would be helpful :))
I tried deploying to devnet today and I keep getting this error - `Invalid Blockhash` 
I used the following command for deploying 
```
solana program deploy path/to/program.so --program-id program_keypair.json --upgrade-authority authority_keypair.json --url http://api.devnet.solana.com
```
`solana-test-validator`
How do I setup a custom rpc node on anchor tests?
another similar issue

https://giters.com/project-serum/anchor/issues/1157
```
Error: Custom: Invalid blockhash
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.
```
dont think so - it's basically this issue

https://stackoverflow.com/questions/70437644/error-custom-invalid-blockhash-when-solana-program-deploy
Out of funds?
Been getting `Error: Custom: Invalid blockhash` errors recently when deploying via `anchor deploy` hmmm.
Any ideas on how to resolve this issue? I can't run "anchor test" for escrow program successfully
Please update the Cargo.toml for the local-testing
bump
Thanks
See: Dependency features
https://doc.rust-lang.org/cargo/reference/features.html
üëç awesome it's working
spl-math = { version = "0.1.0", features = ["no-entrypoint"] }
spl-math = "0.1.0" becomes:
```
[dependencies]
spl-math = "0.1.0"
anchor-lang = "0.19.0"
anchor-spl = "0.19.0"
```
<@!501570363566587905> <@!844070629484527646>
But not resolved yet
```
[features]
no-entrypoint = []
no-idl = []
no-log-ix-name = []
cpi = ["no-entrypoint"]
features = ["no-entrypoint"]
local-testing = []
```
on the Cargo.toml
in "programs/<your program>/Cargo.toml"
Where should I update it?
on Xargo.toml?
`features = ["no-entrypoint"]`
<@!501570363566587905> 
Could you let me know how I can fix it?
error: the #[global_allocator] in this crate conflicts with global allocator in: spl_math
have you tried `anchor_client`?
anybody know a good example of a rust anchor client? Feel like most projects make a js clients
Hi guys .. I am trying to implement an event with nested objects and the build is not generating IDL types correctly and tests are failing .. please can anyone tell me if there is a way of doing that
broke on other machine
might try another machine lol
nuke computer
still getting the error
cargo clean ?
im still getting the error after removing `target`
yeah
how do i nuke the cargo cache
that warning will become an error
although i cant find reason to use C other than compiler warrning
you can reference the inner fields
is it faster or something?
yeah i know but for future i imagine `repr(C)` should be used
You can use `#[repr(packed)]` still if you want to avoid changing your code.
what's the advantage of Anchor switching to Reprc?
https://tenor.com/view/nino-gotoubun-nakano-crying-gif-21756021
u8 u8 u16 will work
u8 u16 u8 will not work
+ aligned correctly
zero-copy has been here for a while
your fields must all be fixed-size
man now ordering of fields affect size üòÜ  padding gonna rekt me
What changes need to made to a program take advantage of Zero-Copy?
yes
right?
That's assuming you're using Anchor's new Zero-Copy based on reprc tho
or you will endup with padding
problem is that now all fields need to me align to highest-byte field
https://discord.com/channels/889577356681945098/889577399308656662/928418937622913084
i'll nuke it
cargo might be using cache
problem with alignment
heard it was caused by the new anchor version's breaking changes to ZeroCopy, but even after downgrading, i get the same bugs
getting 0xbbf, `AccountOwnedByWrongProgram` on tests that used to pass
yeah so i just hit that
https://github.com/Synthetify/synthetify-protocol
would you mind linking me please?
synthetify repo has one
can anyone link me to sample implementation for passing remainingAccounts in a rpc call from client?
<@!595567283028623362> <@!324185078160949248>
imo u8 adds some weird padding and we do nor parse it correctly
Bar is PDA Foo is not
on Foo it hits size missmatch
btw on bar it builds but order is not correct
idk if there is something wrong but now sometimes even if i revert change program does not rebuilt correctly
tested on Bar and it fails
let me
havent try
/ if you use `mem::size_of` for the `space` constraint?
does it work if during init you set the space manually and add the amount required by padding too?
1.18.12 has native implementation on m1
works perfectly
overall weird stuff happens when you add u8 i am not sure why  also checked size with `mem::size_of` and there is a lot of padding added
fixes
adding ` #[repr(packed)]`
u128 works üëÄ
i just added u8 to struct and program flips `'from_bytes_mut>SizeMismatch'`
https://github.com/NorbertBodziony/bug-zero-copy master
Is anyone doing development on an M1 mac? Any gotchas I should be aware of?
I don't have an example, but as for use cases of PDAs that could be interesting to you: https://discord.com/channels/889577356681945098/889577399308656662/926109666222694481


///////////////////////////////////////////////////////////////////////////////////////////////

this should be documented somewhere. Is there any system for submitting this as a documentation proposal?
I just want to prevent someone from passing the ownership of account A and then passing an account C instead of the appropriate account B
I was wondering if anyone wanted to double check my logic here. If I own account A, and account B uses account A as a seed, then I only need to check ownership of account A because someone cant pass in a different account B
just as a simple example. passing the account back and forth between a custom and the system program.
this Code generated this result :
https://github.com/Kriptikz/anchor-transfer-ownership
Oh ok cool!
(i.e. resize account data to zero and then reassign to the system program)
because this is how we're going to implement closing once the realloc api comes out
oh actually i think you can
can see the system program for details
i'm not sure if a program can reassign
Or this is atleast how i've understood it :S
Yes, but I was mainly concerned with the satement "Once you've made an assignment once it's fixed forever" which has been said by alan multiple times, but does not seem to be completely correct since if you do not set the data of an account you can pass it back and forth between programs.
there's two different steps to initialization

1. creating the account (which assigns an owner)
2. setting the data

Here we are concerned with 2
Thanks! Also there have been multiple times in this discord in which alan has said that once an account has been assigned a programId as a new owner from the SystemProgram's initial set, the account can not be transferred to another programAccount. this is true only for initialized accounts right? Because I've seen examples in which an uninitialized account has been passed from the SystemProgram to a Custom one and then back again to the SystemProgram.
in the context of anchor, setting the discriminator
yes
<@!501570363566587905> tweeted about the foot gun of not initializing a n created Account here: https://twitter.com/armaniferrante/status/1481023111168417797.  Does anyone know what is the minimum requirement/s for an account to be considered initialized?  Is it assigning the account data?
<@!130415586080587777> I am not very familiar with Borsh but what is the simplest way to pull the `items_redeemed` field out of the data blob for the CandyMachine account?
So i assume that means the Owner trait gets set to my program_id.
No because I declared the CandyMachine struct in my program since i don't think metaplex published a crate that exports it:
```
#[account]
#[derive(Default)]
pub struct CandyMachine {
    pub authority: Pubkey,
    pub wallet: Pubkey,
    pub token_mint: Option<Pubkey>,
    pub items_redeemed: u64,
    pub data: CandyMachineData,
    // there's a borsh vec u32 denoting how many actual lines of data there are currently (eventually equals items available)
    // There is actually lines and lines of data after this but we explicitly never want them deserialized.
    // here there is a borsh vec u32 indicating number of bytes in bitmask array.
    // here there is a number of bytes equal to ceil(max_number_of_lines/8) and it is a bit mask used to figure out when to increment borsh vec u32
}```
Ownership check should be against that other program's address automatically, is it not working?
is that the reason for why the createUserAccount works but not the UpdateUserAccount? Really appreciate the answers
Since you are creating a new account, you need to pay rent and the rent sysvar is what tells the program how much the current rent is
Is there a way to override the ownership check in `Account<'info, MyStruct>` that way i can deserialize an account belonging to another program?
could you explain why technically?
I see, thx!
You need to include the rent sysvar in `CreateUserAccount`
and I am calling the function on the client side like this 
```
const [userAccount, bump] =
      await anchor.web3.PublicKey.findProgramAddress(
        [Buffer.from("epoch"), provider.wallet.publicKey.toBuffer()],
        program.programId
      );

    await program.rpc.createUserAccount(bump, {
      accounts: {
        userAccount: userAccount,
        authority: provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      },
    })

await program.rpc.updateUserAccount({
      accounts: {
        userAccount: userAccount,
        authority: provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      }
    })
```
could someone please explain to me like I was 5 why I am receiving 
```
Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Failed to reallocate account data
```
when I have the handlers 
```
pub fn create_user_account(ctx: Context<CreateUserAccount>,bump:u8) -> ProgramResult{
        Ok(())
    }

    pub fn update_user_account(ctx: Context<UpdateUserAccount>) -> ProgramResult{
        
        Ok(())
    }
```
and the accounts:
 ```
#[derive(Accounts)]
#[instruction(bump: u8)]
pub struct CreateUserAccount<'info> {
    #[account(
        init, 
        payer = authority, 
        seeds = [
            b"epoch",
            authority.key.as_ref(),
            ],
        bump = bump,
        space=10000,
    )]
    pub user_account: Account<'info, User>,
    #[account(mut)]
    pub authority: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct UpdateUserAccount<'info>{
    #[account(mut,has_one=authority)]
    pub user_account: Account<'info,User>,
    pub authority: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```
Id imagine you would need to do it like any other 3P CPI, I've been trying to find an example of that myself with no luck.
How do you make CPIs to a program that's deployed via anchor on an "unofficial" program ID? My understanding is that when you use, for example, the `spl_token` anchor client on-chain, you can't just use an unofficial deployment of SPL token by switching the `token_program` account to that new deployment. The reason being that the `spl_token` client code is hard coded to the official SPL token program ID.

So if I fork `spl_token` and deploy on a different Program ID, how would I go about sending CPIs to the unofficial deployment? Would the only way be to set up a new crate for the "unofficial" spl_token with an updated program ID?
(ie given the ctx.accounts.candy_machine.data, how do i deserialize?)
How do I do this in Rust: 
```
  const state: any = await program.account.candyMachine.fetch(candyMachineId);
  const itemsAvailable = state.data.itemsAvailable.toNumber();
```
assuming i've passed in the candymachine account as: `candy_machine: AccountInfo<'info>`
they updated custom errors from 300 to 6000
You can create a wallet with a key pair and use that for provider.  See the "helpers.ts" file in this tutorial (very good tutorial by the way). https://dev.to/findiglay/building-a-blog-on-solana-2pg8
I'm getting custom errors with very high numbers (`0x1778`), translates as 6000+ - and when I glance at https://github.com/project-serum/anchor/blob/master/lang/src/error.rs errors stop at 5000, yikes

what might be happening?

context - using goki's program - https://github.com/GokiProtocol/goki
```
pub struct Order {
    account_type: Header,
    mint: Pubkey,
    user: Pubkey,
    token_mint: Option<Pubkey>,
    price: u64,
}
```
anyone know how to use borsh to Deserialize byte array to this struct in golang?
```
type OrderResp struct {
    AccountType uint8
    Mint        common.PublicKey
    User        common.PublicKey
    TokenMint   *common.PublicKey
    Price       uint64
}
this is my struct in golang
borsh.Deserialize(&order, orderByte) is not work
i use this tool:https://github.com/near/borsh-go
```
Hi, what account type to use when loading an account owned by another program as read-only?
I'm loading a CandyMachine account into another program to read its state.
Is there any way I can read NFT's metadata in a program?
Hello,
I now just created my own wallet with `const wallet: any = null;`.
This works because when getting the account info i don't use any of the stuff provided by the wallet. 
But this kinda feels illegal. 
Is there a proper way to do this?
Like is there another way to achieve this:
```    
const idl = await anchor.Program.fetchIdl(CANDY_MACHINE_PROGRAM, new   
      anchor.Provider(connection, wallet, {}));
const program = new anchor.Program(idl!, CANDY_MACHINE_PROGRAM, new. 
      anchor.Provider(connection, wallet, {}));
const state: any = await 
      program.account.candyMachine.fetch(candyMachine1.candyMachineId);
```
if i don't have the `wallet`
How do i get the `anchor.Provider` if i don't have a `wallet`. I am using this in my backend where i have no access to the wallet.
I am trying to do     `const idl = await anchor.Program.fetchIdl(PROGRAM_ADDRESS);`
Without the second option `provider` i get the error `Provider local is not available on browser`
Hi <@!925882190842195988> i clone this code and when i run test it error 
can you help me 
i try test on devnet 
and this is the error:
Transaction simulation failed: Error processing Instruction 0: custom program error: 0xa7 
    Program HmWPG9bFwTvAkFdZsANpQwJWASgwjuXFWWRmjD19nVep invoke [1]
    Program 11111111111111111111111111111111 invoke [2]
    Program 11111111111111111111111111111111 success
    Program log: Custom program error: 0xa7
    Program HmWPG9bFwTvAkFdZsANpQwJWASgwjuXFWWRmjD19nVep consumed 13107 of 200000 compute units
    Program HmWPG9bFwTvAkFdZsANpQwJWASgwjuXFWWRmjD19nVep failed: custom program error: 0xa7
anyone know why this error

HI all,
which is required by invoke transaction
but .to_account_info doesn't exist on the pda
hey folks! i am trying to create a pda and transfer sol to it

```let bank_pda = Pubkey::create_program_address(
            &[msg_sender.to_account_info().key.as_ref(), &[nonce]],
            ctx.program_id,
        );
let bank_res = bank_pda.unwrap_or_default();```
hi all 
is there have resource marketplace with anchor ?
thanks
All - trying to find some documentation but not having as much luck and perhaps I am misunderstanding some of the existing ones. 

On the web3.js `solana-wallet-adapter`, I can see that you can create a `transaction` if you want to send SOLS from, let's say a phantom wallet, to the solana runtime.  ex:

```js
const transaction = new Transaction().add(
            SystemProgram.transfer({
                fromPubkey: publicKey,
                toPubkey: Keypair.generate().publicKey,
                lamports: 1,
            })
        );

        const signature = await sendTransaction(transaction, connection);
```

Following the Anchor documentation of making the Rust smart contract etc,  what is the procedure of taking SOLS from the wallet but adding it to a smart contract?

How to set up the contract to get this data etc?
I've got the proper import `use anchor_lang::prelude::*;`
```18 | #[derive(Accounts)]
   |          ^^^^^^^^ use of undeclared crate or module `__client_accounts_account```
Hey all, I'm probably doing something stupid, but I'm going through some tutorials and am not sure what's causing this compilation error:

```20 |     pub mint: Account<'info, MyData>,
   |               ^^^^^^^ help: a trait with a similar name exists: `Accounts````

Any ideas? Thanks in advance!
on a local test validator?
so anchor test starts up a test validator and then resets the world fresh. r u trying to run anchor test on your pre-deployed contract ?
On running ```anchor test``` I have none of these problems
I'm trying to run ```anchor test --skip-deploy``` but keep running into this error that ```const program = anchor.workspace.Example1;``` this program is undefined. Does anyone know how to correctly skip this deploy step and run tests?
https://github.com/project-serum/anchor/issues/695
the other thing we need to do is this issue, but that shouldn't be required for the localnet usecase (but is required for the devnet use case)
ooo no, ok i was doing it the hard way by deploying to the local validator, thank you!
Then you dont need to shrae a keypair
To have deterministic addressing as configured by the Anchor.toml
can you use `anchor localnet`?
yeah
do you have a ui / e2e app youre developing on a localnet with?
when working with a team on an anchor program, how should folks set up their wallets? running into the issue where one person is deploying locally and it isn't matching up with the `declare_id!(`
should folks be sharing a dev keypair?? correct me if i'm wrong but there is no way to specify the program address before a program is deployed, is that right?
it was some error with multiple solana installs. i was able to get everything working after i wiped my mac
I have a program that is making CPI calls to 2 other programs which provide anchor bindings. However they are using different anchor versions and I am getting `trait bound is not satisfied` errors. What's the best way to handle this?
is there a way to implement a token account owner that could represent either a single owner as well as a multisig without having to wrap it all in the multisig program? the main issue i'm running into right now is that when i have a single owner i need it to be a signer but not when its a multisig
BTW- 20.1 seems to compile and work on an M1 mac for me üôÇ 
<@!161709591220977664>
haha np
Figured this out for anyone who ever comes across the same issue and searches this channel like I did. Not an Anchor problem at all (isn't that often the case???).  A simple "yarn add typescript" and I'm good to go.
Thank you! I didnt realize that they remove all the `_` and capitalize everything üòÖ
use a feature flag


///////////////////////////////////////////////////////////////////////////////////////////////

<@!175770682599276544>can you help me?
thank you!
thanks for any help!
In the instruction you are just passing in public keys and parameters for creating the instruction.
In the invoke_signed CPI call you are passing in the instruction as well as the actual account info data that is needed to for the program to do what it needs. AccountInfo has much more data than a simple public key.
Error: 163: Failed to deserialize the account
i get this error
```json
      await this.program.rpc.initializePool(
        poolNonce,
        reward_per_token,
        {
            accounts: {
                authority: provider.wallet.publicKey,
                stakingMint: stakingMintObject.publicKey,
                stakingVault: stakingMintVault,
                poolSigner: poolSigner,
                pool: poolPubkey,
                tokenProgram: TOKEN_PROGRAM_ID,
            },
            signers: [poolKeypair],
            instructions: [
              await this.program.account.pool.createInstruction(poolKeypair, ),
          ],
        }
      );
```
when i tried initialize a pool
```json
#[derive(Accounts)]
#[instruction(pool_nonce: u8)]
pub struct InitializePool<'info> {
    authority: UncheckedAccount<'info>,

    staking_mint: Box<Account<'info, Mint>>,
    #[account(
        constraint = staking_vault.mint == staking_mint.key(),
        constraint = staking_vault.owner == pool_signer.key(),
        //strangely, spl maintains this on owner reassignment for non-native accounts
        //we don't want to be given an account that someone else could close when empty
        //because in our "pool close" operation we want to assert it is still open
        constraint = staking_vault.close_authority == COption::None,
    )]
    staking_vault: Box<Account<'info, TokenAccount>>,

    #[account(
        seeds = [
            pool.to_account_info().key.as_ref()
        ],
        bump = pool_nonce,
    )]
    pool_signer: UncheckedAccount<'info>,

    #[account(
        zero,
    )]
    pool: Box<Account<'info, Pool>>,
    
    token_program: Program<'info, Token>,
}
```
Hello. I have a problem
like why are we passing those accounts in again if we already did for `initialize_mint`
What's the difference between `initialize_mint`'s parameters and `invoke_signed`'s account_infos?

Solend uses U192
i've been using the uint crate for U256 but arithmetic operations on it is a bit too high. ~4-5k compute units / multipliation & division. Did anyone else happen to find a cheaper replacement by any chance?
yea it's a bad idea
I don't want to just check in keypairs for development, seems like a security risk. Maybe not though.
whatsup og! I guess the keypair files. We're not checking target into the repo; each dev has their own keypair in .config/solana so it rebuilds with new ids and keypairs. Makes working on the same repo kinf of a pita for newer devs
what are you trying to share? keypair files?
How are other teams sharing code with /target folder? We have to keep doing find and replace and it seems sub optimal
https://giphy.com/gifs/rollin-they-see-me-hatin-tfzI6qrcyaTK4AGI8a
https://github.com/gemworks/core/blob/a7e253f1ee7d31ffcfd03ffc16fa3e65a53a75a0/programs/gem_farm/src/instructions/record_multiple_rarities.rs#L67
it works
dude dude dude I got it
awesome!
Done and working: https://github.com/olistic/solana-twitter/commit/c8bbd4cbe03b90d7a620e779b61a4e47f1d6ce2d

Thanks so much <@!194280119710253068> !
Too hard to debug without see logs üòÖ
Yes !
did you redeploy after making changes?
I use solana-test-validator and my smart contract is deployed and call from nodeJS, the smart contract is called but logs does not work
Hi guys is someone can help me with a logs problem ? üòÖ

Problem is the following -> I try to print logs from my smart contract but it seems that it does not work, or I don‚Äôt know where logs are displayed, I read that I should use msg!() and messages should go on solana logs but it‚Äôs not working :/
not the name of the struct it appears
what is anchor's discriminator *actually* hashing, someone?
this is giving me `Invalid account discriminator`:
```rs
        let disc = hash(b"Rarity".as_ref());

        let mut gem_rarity_raw = gem_rarity.data.borrow_mut();
        gem_rarity_raw[..8].clone_from_slice(&disc.0[..8]);
```
now need to hash and add the disc
ok some progress - I managed to create a PDA with allocated space, see this https://github.com/gemworks/core/blob/rarity/programs/gem_farm/src/instructions/record_multiple_rarities.rs#L86
Problem is the following -> I try to print logs from my smart contract but it seems that it does not work, or I don‚Äôt know where logs are displayed
Hi guys is someone can help me with a logs problem ? üòÖ
correct
yes
it should be same for all cuz its just type specific right? not instance specific.
I was wondering that too... they say the discriminator guarantees the type so does is the rust "identifier" unique to the type? Maybe we can find an explicit hashing example somewhere in these damn macros.

In the meantime i just dumped the first 8 bytes of a candymachine account lol:
```
    Program log: Instruction: TestLoadCandyMachine
    Program log: items redeeemed: 1
    Program log: got byte 0: 51
    Program log: got byte 1: 173
    Program log: got byte 2: 177
    Program log: got byte 3: 113
    Program log: got byte 4: 25
    Program log: got byte 5: 241
    Program log: got byte 6: 109
    Program log: got byte 7: 189
    Program 8Jj7CZ7gu87Jd3VKBqZg4ahD6diyK2V7a4LHVBgyAjru consumed 10109 of 200000 compute units
    Program 8Jj7CZ7gu87Jd3VKBqZg4ahD6diyK2V7a4LHVBgyAjru success
```
now next question - what are we hashing? just the name of the struct?
`use anchor_lang::solana_program::hash::hash;`
yes sha256 found in source
its sha256 i think... hopefully <@!831450660146642974> or someone can chime in here.
do you know the exact hashing function / how to use it?
yeah you can, but PITA
That's the approach I'm taking now.
well ya this: `let mut new_data = CandyMachine::discriminator().try_to_vec().unwrap();` doesnt work presumably because the CandyMachine struct is declared in external crate...
But since we have the struct can't we just hash it and gen the 8 byte discriminator ourselves?
worst case case will have to CPI self invoke another instruction, also PITA
I'm digging through source code hoping I can right click copy paste some stuff
= PITA
if you want the account to be anchor de/ser, you need to manually prepend it
exactly
the problem tho you're gonna have is the discriminator
they use a zero, unchecked account, then populate the data array manually in the instruction.
```
#[derive(Accounts)]
#[instruction(data: CandyMachineData)]
pub struct InitializeCandyMachine<'info> {
    #[account(zero, constraint= candy_machine.to_account_info().owner == program_id && candy_machine.to_account_info().data_len() >= get_space_for_candy(data)?)]
    candy_machine: UncheckedAccount<'info>,
```
https://github.com/metaplex-foundation/metaplex-program-library/blob/master/nft-candy-machine/program/src/lib.rs
I'm looking at how metaplex initializes the CandyMachine account manually, it's not a pda but i think same principles will apply
haha i'm working on the same stuff as u bro
thx for this

is there a similar command but to do an init? Ie if I want to manually create a PDA without using `#[account(init)` but I still want it to be anchor serialized?
```pub fn create_profile(ctx: Context<CreateProfile>, _bump: u8, name: String)```
you need to pass the bump as an argument to create_profile too
something like that should work
```rust
#[derive(Accounts)]
#[instruction(bump: u8)]
pub struct CreateProfile<'info> {
    #[account(init,
      seeds = [owner.key().as_ref(), b"profile"],
      bump = bump,
      space=...,
      payer=owner
    )]
    pub profile: Account<'info, Profile>
    #[account(mut)]
    pub owner: Signer<'info>,
    #[account(address = system_program::ID)]
    pub system_program: AccountInfo<'info>,
}

```
Where should I store the `bump`, which will be different for each user?
Yeah like public key + b"profile"
I would use the user's public key as the seed, no? I will give it a try, thanks!
If someone tries to create another account, it'll automatically fail
So you can use a PDA with seeds here
Hi! I have a `create_profile` instruction for creating a `Profile` account with an `owner` field that gets assigned the public key of the wallet creating the profile. I want to ensure that a given public key can only create one profile. How can I do that? Is this a use case for `#[account(constraint = <expression>)]`?

Here is the code I have so far: https://github.com/olistic/solana-twitter/blob/a27bda3bc65fe6267f9d2d287ab03743b04500b8/programs/solana-twitter/src/lib.rs#L10-L24
https://discord.com/channels/889577356681945098/889577399308656662/931097077138747452
in the code üòÑ
how do I deserialize an anchor state account which has been passed in as `AccountInfo`, not `Account`? I can't pass in as Account because it's optional, and thus sits in `remaining_accounts`
<@!831450660146642974> , thank you. then What is #[access_control(ctx.accounts.validate())] ?
where can i find document about access_control?
Hey! Has anyone ever tried to clone this solana crowdfunding tut? (from using Rust to using Anchor) https://learn.figment.io/tutorials/build-a-crowdfunding-platform-on-solana#introduction
Yeah i think that should work. For me, I just switched to using a Docker image that had the versions that I shared üôÇ

I've encountered many people with this issue üòÜ
as example
```Rust
token::initialize_mint(accounts.into(), 0, authority_key, Some(authority_key))?;```
Hey! Does Anchor implement wrappers for CPI system program ? I would like to replace this code with something more concise: ```Rust
let create_acc_ix = system_instruction::create_account(
            ctx.accounts.user.key,
            ctx.accounts.mint.key,
            lamports,
            Mint::LEN as u64,
            &spl_token::id(),
        );
        
        msg!("instruction created");
        
        anchor_lang::solana_program::program::invoke(
            &create_acc_ix,
            &[
                ctx.accounts.user.to_account_info(),
                ctx.accounts.mint.to_account_info(),
                ctx.accounts.system_program.clone(),
            ],
        )?;
```
see it as adding some more accounts to the top level accounts struct, nothing more
This is a composite, just another set of accounts, nothing to directly deserialize here
if I pass an account into a function, and it is not yet initialized, using AccountLoader, how do I tell?  if its not initialized i want to load_init() then set parms, if it is initialized already, i want to load_mut(), if I just try 1 or the other, I can get error if it already exists, or not.  what should I do to handle both cases inside the same function for passed account?
<@!831450660146642974> , please help me with this question. https://discord.com/channels/889577356681945098/889577399308656662/931059305581535242
badass, thanks a bunch dude ‚ù§Ô∏è
https://github.com/project-serum/anchor/blob/master/lang/src/accounts/account.rs#L238-L254
This is what i used to reply
is there a particular source file i can look to for inspiration?
might be a bit off
less yolo:
This will check ownership + discriminator
`let cm = Account<'info, CandyMachine>::try_from(&accountInfo)?` something like that, just check how anchor does it
epic ü§ù  - i might have to use this instead and check ownership manually with a switch because i want to have my test suite run locally w/o depending on actual candy_machine program
`let cm: CandyMachine = CandyMachine::try_from(data[8..]);` something like that
if you want to do it yolo you can remove the first 8 bytes
yes that works. but i want to know how to do it "manually"
then in the function `ctx.accounts.candy_machine.items_remain....` or any other field
problem solved
it will deser for you
Why don't you just do: `candy_machine: Account<'info, CandyMachine>` in the account struct?
sorry
oh
~~try_from should work, that is how anchor does it in the codegen~~ on Account not CandyMachine
keeping in mind that the blob was originally serialized with `#[account]` by a different program.
Ok, so given an AccountInfo data accessed like `ctx.accounts.candy_machine.data` and a struct with borsh serialization traits implemented like so:
```
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Default)]
pub struct CandyMachine {
    pub authority: Pubkey,
    pub wallet: Pubkey,
    pub token_mint: Option<Pubkey>,
    pub items_redeemed: u64,
    pub data: CandyMachineData,
}```
How do I deserialize the blob into a new instance of the struct?
yes, 8 bytes discriminator
If I understand correctly, decorating a struct with `#[account]` appends an 8 byte "dicriminator" to beginning of its data blob array, is this right?
If so, then the problem is that my locally defined version of CandyMachine does not include this... so how do I skip to the... 9th byte and start from there?
also tried similar variations but using `use solana_program::borsh::try_from_slice_unchecked;` which is implemented for CandyMachine due to `#[derive(AnchorSerialize, AnchorDeserialize, Clone, Default)]`...
<@!831450660146642974> Many variations of the following:
```
let mut data = &ctx.accounts.candy_machine.data.borrow();
let cm: CandyMachine = CandyMachine::try_from(data);
```
I'm paraphrasing here... but am I far off?
what did you try?
(i tried many methods and kept getting "first byte must be zero or one"... is this the discriminator messing me up?)
Thanks you so much ‚ù§Ô∏è  - this is exactly what i needed.

For fun, could you point me in the direction of how i would deserialize the data blob if I had instead paseed the CandyMachine account in as `AccountInfo<'info>`?
Thanks again!
using anchor-lang / spl 0.2.0 in anchor.toml
running into the same issue.. weird i have to downgrade... do you mean downgrade the npm package in my anchor workspace and the cli in my zsh profile?
Hi.
I am working to integrate quarry protocol and I found some strange accounts here.
https://github.com/QuarryProtocol/quarry/blob/150915d38e3f74939e9105869907b5d533a86f21/programs/quarry-mine/src/lib.rs#L770

UserClaim is Accounts struct, then can we use it in such way?  I think  #[access_control(ctx.accounts.validate())] makes it possible. right?
Thank you!
Your message did not pop up somehow üò¶ Was waiting all day for an answer until i just now checked if i maybe missed something
looks like its 8 bytes of null!
Otherwise you'll need to access and deserialize individual byte ranges from data
You can have cargo use git even if metaplex didn't publish a crate: https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#specifying-dependencies-from-git-repositories
is anyone familiar how the client handles optionals when decoding fetched account data?
I tried to add Sysvar<'info,Rent> but it didn't solve the problem. If I remove  ```
pub authority: Signer<'info>,
    pub system_program: Program<'info, System>,
```

so that the UpdateUserAccount becomes ```
#[derive(Accounts)]
pub struct UpdateUserAccount<'info>{
    #[account(mut)]
    pub user_account: Account<'info,User>,
}
```
it works but this results in not being able to set a has_one=authority plus that it's not possible to update an account more than once. Do you know why?

SOLVED: this retard (me) allocated too little space in UserAccount.


///////////////////////////////////////////////////////////////////////////////////////////////

then do ser
because i didnt receive new one
no
?
Have you updated declare_id with new one
yep
Are you using anchor ‚öì?
Suppose that if i want to know that, if this account is owned by an program or not
im trying to deploy my first program
anyone knows whats the problem

<@134416332509675520> is there any way to know that, whether a token account is pda or not
I was creating an non-PDA account via `program.rpc...` syntax and now trying to make it an transaction like so: 
```
    const transaction = new Transaction()
      .add(await this.program.account.tickmap.createInstruction(bitmapKeypair))
      .add(createIx)

```
but getting `Signature verification failed` with the same signers as before
idk i'll play with this some more and come back with more clalrity
hmm, it was last failing because we were creating an account saving some data about the interaction and then calling it from inside that program
If not, then you're all good!
Are you specifically checking that someone has the authority to increment the account?
Does this actually fail when you try to do it? Like, is the owning program here actually demanding that someone sign?
What we are trying to accomplish is allow an end user to pay a small fee to increment the state on the program.
https://github.com/cqfd/quidproquo
can you share the repo, where you did this ser ?
This naming confusing in solana is such a bummer, nice example of how even small naming mistakes can lead to endless suffering lol
I think you're maybe confused about what I mean by "owner" here. Every account has a program that owns it (not the same thing as a user-level "owner"/authority)
Having write contention on a small number of accounts though does sound like a tough idea
the user doesn't own the account so can't call those state mutations through cpi
Can you say more? I'm not really following‚Äîwhat goes wrong doing things the vanilla way?
We have four different increments that need to be mutated often from many users. Any thoughts on how this could be accomplished? Maybe by creating another program called like Metadata from inside the original program that exposes those functions for cpi?
<@!501570363566587905> can you review this https://github.com/project-serum/anchor/pull/1309 PR?
Would be pretty odd to do if the token address isn't a PDA, unless I'm missing something
"Having the program own the tokens" means the token owner/authority needs to be *some* PDA, and if it already happens to live at a PDA might as well just use its own address
Sometimes I do that when the address is program-derived, as a way for the deriving program to own the tokens
?
when we wanna do like this <@!134416332509675520> any idaea
Yep
*Only* an account's owning program can mutate it
is this picture saying that the owner of the token account is token_account itself
yes it needs to mutate it's state but it doesn't own it
<@!164924128065748993> üòÆ
(Whether the program you're calling can mutate the account depends on whether it own is, not necessarily on whether the account's address has signed)
What's going wrong? Your program itself won't be able to sign for that address, but that doesn't mean you can't use the account in a CPI
using CPI
I'm trying to call an incrmement function on a non PDA account
Yeah, not quite sure what you're asking here‚Äîthe PDAness of an address pretty much only affects how it can be signed for.
Are you asking if its possible to create a non-pda account from your program? Or use a non-pda account for a CPI?
Is there a way to use cpi on an account that's not a pda? Or would I just have to seed the account with something?
`tail -F .anchor/program-logs/<address>.<program-name>.log`
is there a way to see `msg!("")` program logs when i run `anchor test`?
For anyone that runs into this later on, this is the fix that worked for my **'Error: Not a directory (os error 20)'** problem

https://github.com/project-serum/anchor/issues/481
Hi, the issue I had was a simple mismatch between my javascript test and the rust struct. Maybe double check this part ?
i managed a work around but still would like to understand why `pub struct Context<'a, 'b, 'c, 'info, T> ` not compatible with `pub struct CreateMetadataAccountsLogicArgs<'a>` created in a separate crate.
Any tips on where to look? I already scanned google but maybe not efficiently
vrf is not on solana at all
yes
But it can be done off chain and then called on chain?
Or i haven't understood? They talk about vrf
But chain link is only on devnet solana
Ok I will scan the channel, i thought they were just talking about random stuff ^^
Thanks Tom for your time <3
they dont do the randomness on chain
you can check <#889596381235392522>
Actually if I can prove i can do it i can be selected for a project, so I'm eager to have a try
I've read i can call oracles to do.
And also found this website:
https://degencoinflip.com/

Which makes me believe it's doable unless I don't get how they do?
wouldnt bother trying to do randomness on solana -- its much harder than you think
GM everyone :)
I'm looking to do a small game to practice and I love flipping coins but I realize I don't know how to add a random number. When I was looking online i saw no solutions.
Can someone help me to find a way to create a random number in my program?
Thanks much <3
can someone please explain what i'm missing about rust lifetimes here?
but i get this:
```
error[E0597]: `metadata_info` does not live long enough
   --> programs/climax_controller/src/lib.rs:132:36
    |
122 |         ctx: Context<SimulateCreateMetadata>,
    |         --- has type `anchor_lang::Context<'_, '_, '_, '_, SimulateCreateMetadata<'1>>`
...
125 |         let metadata_info = ctx.accounts.metadata.to_account_info();
    |                             --------------------------------------- argument requires that `metadata_info` is borrowed for `'1`
...
132 |             metadata_account_info: &metadata_info,
    |                                    ^^^^^^^^^^^^^^ borrowed value does not live long enough
...
156 |     }
    |     - `metadata_info` dropped here while still borrowed
```
hello frens, i have this:
```
    pub fn simulate_create_metadata(
        ctx: Context<SimulateCreateMetadata>,
    ) -> ProgramResult {

        let metadata_info = ctx.accounts.metadata.to_account_info();
        let mint_info = ctx.accounts.nft_mint.to_account_info();
        let signer_info = ctx.accounts.signer.to_account_info();
        let system_info = ctx.accounts.system_program.to_account_info();
        let rent_info = ctx.accounts.rent.to_account_info();

        let args = spl_token_metadata::utils::CreateMetadataAccountsLogicArgs {
            metadata_account_info: &metadata_info,
            mint_info: &mint_info,
            mint_authority_info: &signer_info,
            payer_account_info: &signer_info,
            update_authority_info: &signer_info,
            system_account_info: &system_info,
            rent_info: &rent_info,
        };
```
remaining_accounts?
gotcha, yeah does sounds quite complicated.

Would be great if there existed something like an `AccountInfos` type that is essentially a vector of `AccountInfo` , which allows an instruction to process a dynamic number of accounts of the same type
but yes it is possible
and expensive
you can get around this limitation by creating a very large string / vec and putting in null bytes and then cpi'ing to a related program defined by PDAs but its very complicated
I don't mean resizing the account. I mean for a specific instruction, is it possible for it to take a dynamic number of accounts - e.g. for a "create_vault" instruction where you allow users to specify the number of assets (token mints) they want to have in the vault that they create.

E.g. Single asset vault creation for `create_vault`

```
create_vault(
   authority,
   token1_mint,
   token1_account,
   1, // Specified number of assets
)
```

2 asset vault creation

```
create_vault(
   authority,
   token1_mint,
   token1_account,
   token2_mint,
   token2_account,
   2, // Specified number of assets
)
```

In the instruction invocations above, there is support for a dynamic number of accounts depending on the specified number of assets (`n_assets`) for the same instruction.

Is this dynamic number of account inputs for an instruction possible for Anchor?
worked, thanks again
ah ok, i'll give a go updating anchor cli and trying again, thanks üôÇ
this usually happens because your cli is out of date
Hey! What's the best way to debug root cause for this issue when building an idl?

`thread 'main' panicked at 'Code not parseable: Error("expected `=`")', lang/syn/src/idl/file.rs:337:58`

The code is relatively simple and unfortunately the error doesn't really offer a location to look at. Also, The rust compiles just fine. Thanks!
i would recommend using the search function üòõ
if you mean resizing the account -- i do not think that is possible right now. If you mean filling up data with null bytes and then adding them later and decoding based off that, you can do that
what do you mean by "dynamic number of assets" ? Do you mean resizing the account, or do you mean you want to pre-generate a vec with a thousand items and fill them up with bytes as you go
the only exception is if you are running a CPI and didnt declare the correct ids in ur contract but afaik that isnt the case here
sorry i am not used to using skip local validator, but why would it matter if you declare your programs in [programs.localnet] if you already deployed the programs and know the accounts. If you aren't seeing data when you fetch account info for those two publickeys that is your problem
just dont call init if the data exists with an if statement
Hey everyone, is there a way to define a context that can accept a dynamic number of accounts. E.g. if you want to setup a vault with N number of assets.

Hence the number of accounts will be N x (accounts per asset).

I recall being able to implement this  flow in a fairly straightforward way from just raw Solana code, but I notice that Anchor contexts have to have strict lengths (with all account names specified).

Is there a workaround to this?

Below is an example of how you can support a vault with a dynamic number of assets via the `next_account_infos` function

https://github.com/project-serum/serum-dex/blob/eb50404ebcc06a27cca98f9e991e40abe8b6cc1c/pool/src/lib.rs#L170
I've also got the right program IDs in my anchor.toml file.

[provider]
cluster = "localnet"
wallet = "~/.config/solana/devnet.json"

[programs.localnet]
jet = "Dp4cZAQMAyXmMPXtxdhjvLdbmE1ezj31XYMDmTDBEffL"
test_writer = "J5qZsS9h4fXSAhjQdyqfJdVgTmXXQ3izC7MRYwsimvcA"
Hey all, wondering about an error I'm getting with anchor test. here's what's happening. 

first, I set up a local validator and switch my solana config to point to the localhost.

Then I run `anchor test --skip-local-validator` to build, deploy and test my programs on the localhost I have running. But I get this error: `Error: failed to send transaction: Transaction simulation failed: Attempt to load a program that does not exist`

I've checked the deployed programs on my localnet on Solana explorer, and they definitely exist. What could be going on here?
hey thanks. in my case if someone calls init again, i dont want to init or throw an error, just load the account. and if another function requires the init, i just want to init it then and load it, instead of requiring additional steps.  maybe its not possible?
am a noob and don't know the answer, but I have an 'initialize' function and that is the only place I ever `load_init`. That instruction must be run before any of the other instructions may be used.

Food for thought might be if you could separate out your initialization step from your other logic in a similar way, so you know whether you need to call `load_init` or `load_mut`. Someone with more experience may be able to provide more help
Thank you! ‚ù§
Error: failed to send transaction: invalid transaction: index out of bounds any idea?
if i pass in an account with AccountLoader is there way to determine when executing if the account has been initialised? so I can load_init or load_mut ? from the executing function?
setAuthority changes who owns the account (without changing what's in the account). To transfer a token/NFT from one account to another, use transfer.
Was looking at an old repo that uses SetAuthority from anchor_spl::token, I am assuming this isnt a thing anymore haha And if I want to transfer NFTs, I should just use transfer?
if it's to the same destination wallet, putting it in the "to" should be enough. Otherwise you have to leave it in two different transactions.
awesome, thanks. I have something like this, but it is creating 2 separate transactions. Is there a way to wrap both of those events in a single transaction?
```// transfer action
let cpi_accounts = Transfer {
    from: ctx.accounts.user_usdc.to_account_info(),
    to: ctx.accounts.fee_pool_usdc.to_account_info(),
    authority: ctx.accounts.user_authority.to_account_info().clone(),
};
let cpi_program = ctx.accounts.token_program.to_account_info();
let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
token::transfer(cpi_ctx, usdc_fee)?;

// mint action
let cpi_accounts = MintTo {
    mint: ctx.accounts.team_token.to_account_info(),
    to: ctx.accounts.user_team_token_account.to_account_info(),
    authority: ctx.accounts.pool_signer.clone(),
};
let cpi_program = ctx.accounts.token_program.clone();
let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer);

token::mint_to(cpi_ctx, n_token)?;
```
use mintTo and specific the dest, authority for mint and the amount
in my rust code (using Anchor) I have a `token::transfer` and `token::mint_to` that I would like to have as 1 single transaction. Is there a way to do that?
any idea?
```json
  logs: [
    'Program 2Twfm9Ypbpax6drffqar4iVj5LSiXsv1UYT8UsDDbW8Z invoke [1]',
    "Program log: panicked at 'called `Option::unwrap()` on a `None` value', programs/moonlana_stake/src/lib.rs:91:105",
    'Program 2Twfm9Ypbpax6drffqar4iVj5LSiXsv1UYT8UsDDbW8Z consumed 13590 of 200000 compute units',
    'Program failed to complete: BPF program panicked',
    'Program 2Twfm9Ypbpax6drffqar4iVj5LSiXsv1UYT8UsDDbW8Z failed: Program failed to complete'
  ]
}
``` i get this error on this line, 
```json
ctx.accounts.user.balance_staked = ctx.accounts.user.balance_staked.checked_sub(amount as u128).unwrap();```
<@!925882190842195988> Any further insight on this? I am experiencing a similar problem with `invoke_signed` randomly failing for certain address with `Provided seeds do not result in a valid address`.

My first inclination was the the bump was being passed incorrectly, and the successes just happened to work with 255 (as <@!117243115676499972>) suggested -- however, after adding logging and experimenting this seems to not be the case.

I can in fact hardcode the bump and address:
```rust
let metadata_bump = 251;
let mint_key = Pubkey::new(&[57, 167, 35, 136, 47, 94, 28, 99, 198, 22, 246, 189, 131, 226, 108, 128, 214, 122, 31, 103, 124, 208, 32, 236, 86, 49, 125, 71, 189, 153, 35, 176]);
// == 4t44KKrYSa57quRjt7N7WfyzBSjzNeRL7td6euPnPTM1
```
 and the following will pass:

```rust
let metadata_signer_seeds = [
            METADATA_PREFIX.as_bytes(),
           metadata_program_id.as_ref(),
            mint_key.as_ref(),
            &[metadata_bump],
        ];

let generated_address = Pubkey::create_program_address(&metadata_signer_seeds, &metadata_program_id)?;
 assert_eq!(metadata_account.key(), generated_address);
```

but, calling `invoke_signed` will raise the error:

```rust
      invoke_signed(
            &instruction,
            &[ 
                // ... accounts ...
            ],
            &[&metadata_signer_seeds]
        )?;
// => Provided seeds do not result in a valid address
```
... and further more, changing the bump to `250` (not the bump used to generate the account address) will result in the exact opposite, with `create_program_address` raising the error, and `invoke_signed` passing?!

Any thoughts on what I'm missing?
cdnt find anything could you provide a link if psbl.
<@!501570363566587905>  so am new to rust and finding the zero copy concept a bit hard to grasp any resources you could refer which could help in understanding how it works also the #repr things used in conjunction with it normally.
check their v1
were u referring to this repo :? https://github.com/step-finance/reward-pool/blob/main/programs/reward-pool/src/lib.rs, could not find any zero copy usage in there
gotcha. (added)

thanks <@!501570363566587905> <@!445019022338031618>
the cpi client doesnt deal with the validated types
an account info
cant u pass in Signer::new(AccountInfo) as long as its is_signer is true, it will work just fine
smol question: if im doing a cpi to a program and the program is asking for a signer. what should i pass?
or zero copy should only be used in cases where i would be capping the stack or the heap.
quick question abt zero copy, if my struct is using fixed datatypes is zero_copy better over using anchor deserialization and serialization
How to make auto compounding farm on solana with anchor?
I know solFarm is first auto compounding on Solana. But they didn't share their contract.
Who has any example repo or any solution? please teach me.
I am using this contract. But I initialize the pool and when I want to get the information in web3, the information is different.
when I already define my contract. And I want to obtain the information of the layouts from the web3. Why the information that comes is different from the struct?
step-finance's reward-pool
jet, synthetify, blockworks's voting-registry
any repo i could take a look at to see the way zero copy is utilized ?
ohhhh. found
hint: read the error message
<:happy_thonk:844153022409998366>
I'll leave this as an exercise for the reader üòâ

new error ^^ üòÖ
thanks <a:4297pepehacker:898240339939328061> worked
Also make sure to use `features = ["cpi"]` in your Cargo.toml for the arrow_sunny crate
Need to use the `cpi` module. For example, `arrow_sunny::cpi::new_arrow`
new error:

`function 'new_arrow' is private`
Thanks ser! This worked üòÑ
So you need to clone an AccountInfo and give it over.
The struct takes ownership over those types.
call `to_account_info()` on all those structs.
hi, i was trying to do a CPI between my program and arrow protocol but im getting the below error

`cannot move out of 'ctx.accounts.pool' which is behind a mutable reference`

any solution?
So that I can decode an instruction with it
I'm trying to expose the Instructions struct somehow
When an anchor program receives an instruction, how does it deserialized it?
I up this interesting question if someone encounter the same problem
I think it has to do with what accounts data the program you are sending the instruction to will need to process that instruction. Basically any account that program needs to read from or write to needs to be passed in.
any idea how to determine whether load_mut or load_init is required in a function?  do not see way to determine which is necessary based on account. i prefer not to have a separate client call for init alone.
how do u know which accounts u need to pass into invoke_signed's account infos
There's quite a bit there to wrap my head around.
I don't understand why you're using UncheckedAccount. I don't understand why you have Accounts wrapped with Box. I also don't know what that 
```Typescript
await this.program.account.pool.createInstruction(poolKeypair, ), 
```
is doing.


///////////////////////////////////////////////////////////////////////////////////////////////

Okay, thanks üôÇ
You can do that or store it onchain with anchor idl init
should I include idl file in my react app or not? Or it doesn't matter?
anyone knows what is the problem here?
im trying to npm start my react app

I have a program that distributes tokens by staking... from time to time I want to modify the reward per token, but as I understand it, the only way to modify this is by interacting with the program, now, those who were with the first reward when modifying this variable , your reward will be affected. How is the best way to do it without affecting the previous reward? Do I have to handle everything outside the program? I understand that to modify the rewards per account, I must call my pb fn and for this invoke an instruction, but I don't know if it is the best way?
Hi!

I'm trying to manually generate an Instruction from an Anchor program in Rust as I don't know how to generate a Rust client. Based on the IDL i serialized the parameters for the contract call but still the transaction fails. Compared the JS transaction I can make online for the same program my transaction data is shorter even I serialised the parameters from the IDL
Can someone help on what all to do?
My smart contract works fine with anchor test and i want to deploy it to mainnet now..
This is the error i get Error: `Deploying program failed: Error processing Instruction 1: custom program error: 0x1
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.`
Hey <@!831450660146642974> Can you help me for 2 mins in deploying a smart contract to the mainnet?
how did you get this?
yes
Hi <@!831450660146642974> Did you solved this problem?
I believe only system owned programs can pay transaction fees. Check the owner of the account your trying to use to pay the fees and see what program id it gives you.
Only the program that owns the account can modify the data. So yea you need to call the function.
from scratch to complete
Is there anyone who can give me best solana tutorial url?
https://github.com/project-serum/anchor/tree/master/tests/spl/token-proxy
does anyone have an example of a contract sending spl tokens?
is there any change on phantom wallet or anchor , my app was working right but now give me this error: Transaction simulation failed: This account may not be used to pay transaction fees
IF i want to deploy a new spl program: is this right:

```
spl_token::instruction::initialize_account( .. )
```
For a variable to be updated in my program, it must be updated by calling a function within the contract? or can I do it in another way? I mean, I have a variable that is modified as time passes, but I see that it does not update if I do not call the function again.
sorry, how use the fetch on web3? o i need install the anchor on front-end for this consult?
thanks!
üôè
a better solution is hopefully ready in the next day or so
and use it to start your project
rip out the /packages/starter/nextjs package
didnt really understand what to do there
<@!501570363566587905> If you could help me with this one id really appreciate
Does anyone know what ``` TypeError: unexpected type, use Uint8Array``` means when trying to send a bbump value to my contract?
but it uses nextjs
the starter appears to work, yes
did it work for you?
thanks!
Looks like the suggested solution right now is to use the nextjs starter project in the repo
See https://github.com/solana-labs/wallet-adapter/issues/241
yes i just ran into this mess
is it possible to sell @ market price? <:happy_thonk:844153022409998366>
i get some errors
but
im on the last step
maybe you are smart enough to help me please ü•∫
its just really easy to copy and paste exploits that already exist
no im dumb
i guess you are a great programmer?
except transferring money
pretending to be on chain but nothing is actually done on chain
hahaha
now they are fake on chain
daamn
when they were on chain all their money got stolen
degen coin flips isnt on chain
<@!867369388608061470> but why dont you just take every cent from degen coinflipz
eh my friend is pretty smart im sure he will figure it out
you are playing some mind games
its easy
but since its on chain
oh
i wouldnt be able to
if it was offchain
not sure tho
its on chain so i dont think you will be able to
ive followed a tutorial and i think I have done no mistakes
anyone knows whats the problem?

thanks
it is the "interface" for your program (https://en.wikipedia.org/wiki/Interface_description_language#:~:text=An%20interface%20description%20language%20or,written%20in%20an%20unknown%20language.)
Yes. This is the file that allows the JS anchor library to create the Program object and the helpers inside
into the idl.json?
do i copy all of the code from there?
yep
in the target folder there should be a `mysolanaapp.json` file
and now what do i copy
i created a new file idl.json in the src directory in my app
can you explain me this part

yes
and i wont feel bad about it at all
i will steal every single cent you have
hey <@!915682383905316864> you still here? I need like a little small advice is no error
when your friend launches on main
if its on chain just warning you
it is working without any issues on devnet
My system on MacM1:
```
Anchor: v0.20.1
Solana: 1.8.0
Rust: 1.57.0
```

Idk why this error is being shown on my code.
Here is the full program file lib.rs
https://pastebin.com/VNq2p0Yb

Anyone please?
It was working sometime back
in this method on program, I am creating a PDA for the user and depositing SOLs there.
See you soon üôÇ
haha might give a look yeah
if you wanna try on devnet fair3d.me
nope, havent launched yet improving but almost done
Hey, I am getting this error while calling an smart contract method which was working previously, any idea

```
     Error: failed to send transaction: Transaction simulation failed: Attempt to debit an account but found no record of a prior credit.
      at Connection.sendEncodedTransaction (node_modules/@solana/web3.js/lib/index.cjs.js:6591:13)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at async Connection.sendRawTransaction (node_modules/@solana/web3.js/lib/index.cjs.js:6550:20)
      at async sendAndConfirmRawTransaction (node_modules/@solana/web3.js/lib/index.cjs.js:8513:21)
      at async Provider.send (node_modules/@project-serum/anchor/dist/cjs/provider.js:90:22)
      at async Object.rpc [as userDepositSol] (node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:31:31)
      at async Context.<anonymous> (test/integrationTestMainnet.js:87:14)
```
lol degencoinflip?
onchain
you too ü§ù
my friend programmer has created a coinflip betting app
Sounds great. I'm not that far into Solana myself, so I understand where you're at
Hope you are going to have a fantastic weekend
my first steps
for now im trying to just make an app where a person connects his wallet and can send a tx
And thank you very much!!!!
if you want you can add me as friends so i can consult with you üôÇ
hahahha we could make a project when i learn how to use program on solana
<a:5554pepenoted:898239915769335898>
A few, but nothing too serious **yet**. Just enough to have hit these kind of issues enough times to know be clear about it now lol
that does CPI to the orderbook program
or apps
have you created any projects
üöÄ
But you're all set I believe
classic
there it was probably some turn it off and on again missing
definitely, but at some point you already had the correct file content and it still failed
i was using it i mean
Probably the thing that i was doing stuff with program wallet
Maybe we were just missing a fresh terminal spin up
Something not completely in sync
does `dex.rs` (anchor_spl) work for bonfida swaps?
No clue what was wrong
Hell yeah
shit's working
Program Id: 9XYzBqrqR4H3mg8WDRixssWqyhzT3m2pzjY5pRsvpnCy
woohoo
doesn't matter
`solana-test-validator` can be run from anywhere
then `solana program deploy /Users/nikitatelnovas/Desktop/ddd/mysolanaapp/target/deploy/mysolanaapp.so --program-id /Users/nikitatelnovas/Desktop/ddd/mysolanaapp/target/deploy/mysolanaapp-keypair.json`
same directory tho
yep im running on another terminal
`solana-test-validator --reset`
very COOL
Now next step
COOL
cool
ok
do make sure your `solana-test-validator` is not running
works

alright good to go for `anchor test`
done
yep
```
[programs.localnet]
mysolanaapp = "9XYzBqrqR4H3mg8WDRixssWqyhzT3m2pzjY5pRsvpnCy"
```
that's all
ok so you can update the 2nd line yes
key
it has the old
`[programs.localnet]
mysolanaapp = "2o9t2jKS81VhdHJPQ1Qg61hy3hfYkPtvojX8MBksZ8LN"

[registry]
url = "https://anchor.projectserum.com"

[provider]
cluster = "localnet"
wallet = "/Users/nikitatelnovas/.config/solana/id.json"

[scripts]
test = "yarn run mocha -t 1000000 tests/"
lib.rs yes. Anchor.toml it depends. Paste your Anchor.toml here?
so i update declare id in both lib.rs and anchor.toml
did you update `declare_id!` to `9XYzBqrqR4H3mg8WDRixssWqyhzT3m2pzjY5pRsvpnCy`?
`TEST`
it's easy to remember if you realize that you will end up with as many `target/deploy/SOME_NAME-keypair.json` as you have programs on your machine, but only 1 `~/.config/solana/id.json`
9XYzBqrqR4H3mg8WDRixssWqyhzT3m2pzjY5pRsvpnCy
yep
we are interested in specifying the **program** private key in `declare_id!`
and that one is program
yep
remember that `~/.config/solana/id.json` is your **wallet** private key
not the /id.json?
`solana address -k /Users/nikitatelnovas/Desktop/ddd/mysolanaapp/target/deploy/mysolanaapp-keypair.json`
i mean
program id
i didnt get my key
cargo-build-bpf child: /Users/nikitatelnovas/.local/share/solana/install/releases/1.9.4/solana-release/bin/sdk/bpf/scripts/strip.sh /Users/nikitatelnovas/Desktop/ddd/mysolanaapp/target/bpfel-unknown-unknown/release/mysolanaapp.so /Users/nikitatelnovas/Desktop/ddd/mysolanaapp/target/deploy/mysolanaapp.so
cargo-build-bpf child: /Users/nikitatelnovas/.local/share/solana/install/releases/1.9.4/solana-release/bin/sdk/bpf/dependencies/bpf-tools/llvm/bin/llvm-readelf --dyn-symbols /Users/nikitatelnovas/Desktop/ddd/mysolanaapp/target/deploy/mysolanaapp.so

To deploy this program:
  $ solana program deploy /Users/nikitatelnovas/Desktop/ddd/mysolanaapp/target/deploy/mysolanaapp.so
The program address will default to this keypair (override with --program-id):
haha yes sorry
by nuke you mean just delete
for now just:
1. nuke `target/` completely
2. `anchor build`
3. update `declare_id!`
4. `anchor test`
let's not do anything with a test validator just yet
i turn it off
and then when i test
wait so i run test validator first
alright
Just do that, it doesn't hurt, and to be honest I'm a bit out of ideas
or will you try to fix it
should i do it now?
I don't think that would matter actually, but you can always nuke the `target/` folder and rebuild. Just remember to run `solana address -k /Users/nikitatelnovas/Desktop/ddd/mysolanaapp/target/deploy/mysolanaapp-keypair.json` again after and update `declare_id!` with the result
i probably shouldve anchor built with the /id.json wallet right
json_rpc_url: "http://localhost:8899"
websocket_url: ""
keypair_path: /Users/nikitatelnovas/.config/solana/id.json
address_labels:
  "11111111111111111111111111111111": System Program
commitment: confirmed
no problem i thank you very much üôÇ
sorry to be on a loop but now the output of `cat ~/.config/solana/cli/config.yml`?
2o9t2jKS81VhdHJPQ1Qg61hy3hfYkPtvojX8MBksZ8LN
now the output of `solana address -k /Users/nikitatelnovas/Desktop/ddd/mysolanaapp/target/deploy/mysolanaapp-keypair.json`
Cf2UAtJAwYjDipRP1j7kcRLTUJKXvtYXSRjdcbF8tG6w
what is the output of `solana address -k ~/.config/solana/id.json` right now?
yeah... not so great
Goodness
Error: Account 2o9t2jKS81VhdHJPQ1Qg61hy3hfYkPtvojX8MBksZ8LN is not an upgradeable program or already in use
`createInstruction` used a provider, needed to do somethink like this: 
```
.add(
        SystemProgram.createAccount({
          fromPubkey: admin,
          newAccountPubkey: stateKeypair.publicKey,
          space: this.program.account.state.size,
          lamports: await this.connection.getMinimumBalanceForRentExemption(
            this.program.account.state.size
          ),
          programId: this.program.programId
        })
      )
```
you have to fetch them `state` is the name of you the struct you declare in rust
ok so try to run the deploy command again, and hopefully now you'll hit an `Insufficient sol` error
`await this.program.account.state.fetch(address)`
(tip: prefer to copy/paste outputs and code snippets using the \```<language ticker>   your code\``` rather than screenshot. It's easier to copy paste back haha)

then run `solana balance` and paste the output here
open this file, and change:
`keypair_path: /Users/nikitatelnovas/Desktop/ddd/mysolanaapp/target/deploy/mysolanaapp-keypair.json`
to
`keypair_path: /Users/nikitatelnovas/.config/solana/id.json`
ok so
Lol I'm not mad at all, don't trust feelings through texts üòÑ
i know im noob and im sorry if i make you mad üòÑ
---
json_rpc_url: "http://localhost:8899"
websocket_url: ""
keypair_path: /Users/nikitatelnovas/Desktop/ddd/mysolanaapp/target/deploy/mysolanaapp-keypair.json
address_labels:
  "11111111111111111111111111111111": System Program
commitment: confirmed
Thank you, I will start looking into how in the world to even do this.
Ok let's make this very clear. Go ahead and copy the output of `cat ~/.config/solana/cli/config.yml`  here please
so do i set my keypair to this one?
I see. Your general solana CLI config is messed up though, if you have your associated wallet keypair file pointing to a program keypair file, so why leave it that way?
file
but its already in my anchor.toml

vim/gedit/vscode, whatever text editor?
it's a file
how can i do that
after that run `solana config get` again
and specify `~/.config/solana/id.json`  in `keypair_path: XXX`
modify `~/.config/solana/cli/config.yml`
Yep no problem
That wallet also has a keypair file associated to it, located by default in `~/.config/solana/id.json`
i can change the wallet mid process right
okay
to pay for deployment fees
now in order to deploy that program on-chain, you need a wallet
so it determines the address at which your program will be available on-chain
that is the keypair file **for the program**
yes
it generated this one
yes but when i ran anchor build
by default it is in `~/.config/solana/id.json` I believe
Did you change it at some point?
How would I do then to obtain the variables of my program?
Here you have specified the same key for the program address and for the funding wallet
wdym
also, bump
then <@!867369388608061470> was correct I think. That path should be the path to your funding wallet keypair file
it's just a rust visibility thing, encapsulation and all that
yep
sound like u just want to fetch it, and pub doesn't matter here
is that what is given to you by `solana config get`?
for example, this 
```json
#[account]
#[derive(Default)]
pub struct User {
    /// Pool the this user belongs to.
    pub pool: Pubkey,
    /// The owner of this account.
    pub owner: Pubkey,
    /// The amount of points redeemed.
    pub points_redeemed: u128,
    /// Points Balance.
    pub points_debt: u128,
    /// The amount staked.
    pub balance_staked: u128,
    /// last update time.
    pub last_update_time: u128,
    /// Signer nonce.
    pub nonce: u8,
}
```
ok, i have a stake method. But I would like to consult from my front-end how to access the variables of my contract.
/Users/nikitatelnovas/Desktop/ddd/mysolanaapp/target/deploy/mysolanaapp-keypair.json
You can also just ask anchor what your programs key that it generated for you is:
```
anchor keys list
```

Also isn't the key in target/deploy/
what is your Keypair Path?
can u elaborate?
<@!889636611736891412>
to the layout I use in my front-end
the 3rd step for deployment didnt work as well
it's just the rust think with visibilisty outside a module
what do you mean consult?
hi i have a noob question. The pub struct is the structure that I can consult from web3 to my contract?
anchor deploy
what command are u using
https://book.anchor-lang.com/chapter_4/cli.html#test
keep in mind that you have 2 choices:
1. have not local test-validator, and run `anchor test` (which will automatically start one)
2. have a local test-validator running, and run `anchor test --skip-local-validator` so that anchor test makes use of the one you started

with anchor deploy
mm now im stuck with the last problem
you can always console.log your pubkey
‚ù§Ô∏è
Oh it worked
idk how to check
yeah i think so
yes
test validator?
make sure your local validator is stopped before running `anchor test`
and on the same cluster
and you sign with your wallet?
i figured i dont need deployment this second, ill first figure out the anchor test
but when i check solana balance i have unlimited
did you solve your previous issue?
bump
no sol on your signer account
?
have any ideas when i run anchor test why this could be happening
<@!915682383905316864>
Anchor is a framework that reduces boilerplate/simplifies setup/eases account validation/prevents some basic mistakes etc. You will very likely benefit from using it compared to vanilla, and I don't think your use case has any dealbreaker.

and check in that same output your wallet `Keypair Path`, to make sure you're not weirdly using the same private key file for both program deployment and funding wallet, as stated above
<@!498506679474847774> also make sure you're actually deploying to localnet. For instance run `solana config get` and make sure it points to localhost/127.0.0.1
I want to do staking with my token. So they will stake 1 NFT + Token A, and they will get Token B as a reward with the amount scaling based on NFT rarity. Is this something I can do using Anchor?
ok but his error message is regarding there being something in solana on the same pubkey where he is trying to deploy another program
That should be fine if he followed this: https://discord.com/channels/889577356681945098/889577399308656662/931616745813336105
you need to declare the Id on something that you arent using to sign
you cant deploy a program on a wallet
<@!498506679474847774> If you are trying to deploy your program to localnet to be able to inspect it through the explorer for instance, maybe you wanna take it from the top?
1. stop your local validator
2. re-run the `solana address ...` command to make sure that the pubkey in your `declare_id!` is correct
3. start a fresh validator: `solana-test-validator --reset`
3. try deploying again and be axplicit about the program ID just to root this out: `solana program deploy <path to target's  .so> --program-id <path to the private key json file>`
Aah then, no idea ser
yes
Is your solana test validator up and running
i can try starting from new project
if you have any presets i can use
local
Are you on devnet ??
but still same error
shows different account

Let's see if it works or not
Delete target folder, and repeat the process ser
but its the same
from deploy
but
but not /target/release
Aah then no idea mate
i got the id from this
Ok
yes
Are you sure you updated the declare-id

Share lib.rs
Mm ok
i updated my declare id
this

same error
Run this one
bruh
oh
Ser you are trying to deploy .json
any idea ser
<@!717956950737813594>
Any idea ser
Yup
the root?
in which one should i run
Yeah I guess
what directory
does it matter where i run achor build?
Cool
ill try
thanks!
Do anchor build
And then solana address -k target/release/your-program-name-keypair.json

Copy the output key, and replace the adress in declare-id with it
here ser i dont get the id

and where do i put it
i tried redoing the project multiple times and it shows the same
or i missed it and now i will definitely not have one
You will have the program id
Once you do anchor build


///////////////////////////////////////////////////////////////////////////////////////////////

I would probably also switch to devnet if I wanted a more realistic experience when testing the frontend for instance
amazing will read through it! Thanks a lot
I would say what is best depends on what you are testing. If you are purely looking at whether your integration is working, I'd say if you can do it in localnet it's best since you have full control.
Where I'd switch to devnet is if you cannot easily replicate the mainnet setup locally, for instance if many underlying accounts are involved and you're not an expert in that particular protocol.
If you have doubts on how to setup accounts/programs locally I wrote that thing yesterday: https://solana-cookbook-git-fork-losman0s-using-mainnet-6e845e-cookbook.vercel.app/references/local-development.html#using-mainnet-accounts-and-programs
It has not been accepted yet but the PR preview should be enough.
``` let user_context: SwapUserContext = SwapUserContext {
        token_program: ctx.accounts.token_program.to_account_info(),
        swap_authority: ctx.accounts.swap_authority.to_account_info(),
        user_authority: ctx.accounts.user_authority.to_account_info(),
        swap: ctx.accounts.swap.to_account_info(),
        clock: ctx.accounts.clock.to_account_info(),
    };

    let input_a: SwapToken = SwapToken {
        user: ctx.accounts.user_a.to_account_info(),
        reserve: ctx.accounts.reserve_a.to_account_info(),
    };

    let input_b: SwapToken = SwapToken {
        user: ctx.accounts.user_b.to_account_info(),
        reserve: ctx.accounts.reserve_b.to_account_info(),
    };

    let deposit_context: Deposit = Deposit {
       user: user_context,
       input_a: input_a,
       input_b: input_b,
       pool_mint: ctx.accounts.pool_mint.to_account_info(),
       output_lp: ctx.accounts.output_lp.to_account_info(),
    };
    let saber_swap_program = ctx.accounts.saber_swap_program.to_account_info();


    stable_swap_anchor::deposit(
        CpiContext::new(
            saber_swap_program,
            deposit_context,
        ),
        token_a_amount,
        token_b_amount,
        min_mint_amount,
    )?; ```  I'm doing a cpi call as follows. Now to test this functionality in my front-end, do I need to deploy a version of the saber program on my localnet or use devnet? how is this done best?
I have a general question about composing with other programs. Let's say that I'm integrating my program to compose with the saber-swap program https://github.com/saber-hq/stable-swap.
How can I make this work? obviously im doing something wrong but idk too much about rust
can some1 help:

My goal is to take a token, and then launch a wrapped version....
```
use anchor_lang::prelude::*;
use anchor_spl::token::InitializeAccount::{self};
declare_id!("5CJLYpV8p73QUHNALLDChxSUfHZWut3yk9g78nZ5Hgg6");
//
#[program]
pub mod stable_up {
    use super::*;

    pub fn initialize(
        _ctx: Context<Initialize>
    ) -> ProgramResult {
        Ok(())
    }

    pub fn initialize_pool_asset(
        _ctx: Context<PoolAsset>,
        data: InitializeAccount
    ) -> ProgramResult {
        // let wrapped_token_program_id_ = token_instruction::initialize_account(
        //     i_a
        // )?;
        // // ctx.token_program_id = token_program_id;
        // ctx.wrapped_token_program_id = wrapped_token_program_id_;


        Ok(())
    }
}

#[derive(Accounts)]
// Pool
pub struct Initialize<'info> {
    pub owner: Signer<'info>,
    pub system_program: Program<'info, System>, // <--- Anchor boilerplate
}

#[derive(Accounts)]
// #[account]
pub struct PoolAsset<'info> {
    pub token_program_id: AccountInfo<'info>, // asset
    pub wrapped_token_program_id: AccountInfo<'info>, // asset
}
```
I get : `error[E0412]: cannot find type InitializeAccount in this scope`

Then also: " use anchor_spl_token::token::InitializeAccount;" but when i use this....

I get: error[E0106]: missing lifetime specifier
Does anyone know if there's a way to codegen Typescript interfaces from the IDL json?
* Mainnet - https://api.mainnet-beta.solana.com
should just be mainnet
Yo guys, when editing Anchor.toml for mainnet, should I use mainnet-beta or mainnet?
Or if its just an preset account not a pda, whats the address?
Im trying to mint an edition from a master through metaplex. Anyone know what seed an `edition_mark` pda (seperate from an `edition` pda) is supposed to have?
I'm probably missing something though, I'll find time to read the Anchor source code more thoroughly to express the approach more concretely
ah cause if the  `Accounts`  structs can take a `Vec<AccountInfo>` (in addition to singular `AccountInfo`), then at account validation, Anchor should be able to validate through the vector, and then store the vector in the context's  `self` to be used during instruction handling.
sorry im not sure how that would solve that problem
even using `next_account_infos` ?
yeah i dont think this feature is likely to happen in anchor -- its a solana limitation
I setup a related issue on github, in case it makes sense to implement the feature, or others have thoughts on workarounds üôÇ 


https://github.com/project-serum/anchor/issues/1325
Thats what I thought, I just didn't know if there was a more nuanced answer lol
Yeah right, I think it's just a two way of achieving same result
They both essentially call for a signer account right?
I had a random question lol 
What‚Äôs the difference between the following account declarations. 

#[account(mut)]
Pub user: Signer<‚Äôinfo>

And 

#[account(mut,signer)]
Pub user: AccountInfo<info>
kinda like an LP
MY goal is to launch a token on initialization
I did 
```
        let token = token_instruction::initialize_account(
            _ctx.accounts.token_program_id,
            _ctx.accounts.owner,
            _ctx.accounts.owner,
            _ctx.accounts.owner
        )?;

```

I got this function takes 1 argument but 4 arguments were supplied
Using

```
pub struct InitializeAccount<'info> {
    pub account: AccountInfo<'info>,
    pub mint: AccountInfo<'info>,
    pub authority: AccountInfo<'info>,
    pub rent: AccountInfo<'info>,
}
``` 

for `use anchor_spl_token::token as token_instruction;`

How?
Does anyone know why this fix actually works? It helped me solve the exact same error I was getting when calling a function an Anchor program. The error itself was TypeError: unexpected type, use Uint8Array. The context is in a spl-token transfer.

https://giters.com/project-serum/anchor/issues/1109
I would think this would work, where I don't need to sign with the tileTokenAccount after that account has already been initialized
```javascript
        await program.rpc.completeTask({
            accounts: {
                gameAccount: gameAccountKey,
                tileTokenAccount: tileTokenAccount ? tileTokenAccount.publicKey : tileTokenAccountKeyPair.publicKey,
                workerAccount: worker.publicKey,
                workerTokenAccount,
                tileAccount: tile.publicKey,
                authority: wallet.publicKey,
                systemProgram: web3.SystemProgram.programId,
                associatedTokenProgram: spl.ASSOCIATED_TOKEN_PROGRAM_ID,
                rent: web3.SYSVAR_RENT_PUBKEY
            },
            signers: tileTokenAccount ? [] : [tileTokenAccountKeyPair]
        });
```
However, I am getting an error in javascript saying that the signature verification failed
Okay, I need a sanity check. I have the following
```rust
pub struct CompleteTask<'info> {
    #[account(
        init_if_needed,
        payer = authority,
        space = 8 + 1 + 32 + 32 + 8
    )]
    pub tile_token_account: Account<'info, TileTokenAccount>,
```
Where the first time Complete Task is called the tile token account will need to be created and after that it will not for a given user.

The problem I am running into, is once I have created the TileTokenAccount, I assume when I do a transaction I do not need to sign for that tile token account since it is already been created.
halp pls

broooooooo wth
I need a concept clarification. Is it possible for a variable to be updated in the contract through a consult to the program? I say this because if I have a counter 1 that increases depending on how many spl-tokens a person has... how do I know how far the current counter goes without having to send the variable to be updated through an instruction?
any idea , anyone else with that problem?
and is not only with my app y try with https://learn.figment.io/  tutorials and it give the same problem on their apps
if run it with the test in anchor,  I not have not problem if i try  with phantom with the front end give that error
connection.ts:3665 Transaction simulation failed: This account may not be used to pay transaction fees 
    
(anonymous) @ connection.ts:3665
rpc.ts:22 Translating error Error: failed to send transaction: Transaction simulation failed: This account may not be used to pay transaction fees
    at e.<anonymous> (2.3ae2eaeb.chunk.js:2)
    at f (2.3ae2eaeb.chunk.js:2)
    at Generator._invoke (2.3ae2eaeb.chunk.js:2)
    at Generator.next (2.3ae2eaeb.chunk.js:2)
    at n (2.3ae2eaeb.chunk.js:2)
    at s (2.3ae2eaeb.chunk.js:2)
somebody else has problem with phantom wallet , i have a app was  working good, but now is not working with phantom wallet and i did not change anything.
yeah for sure haha. but I guess for pure testing purposes it's fine (as long as it's not used anywhere else)
yeah this probably sounds like the easiest solution. thanks a lot! üôÇ
Just make sure no one uses this keypair ever üòµ‚Äçüí´
I mean if the objective is simply to end up with the same pubkey every time, while not having to track an additional file, you can always do that: https://solanacookbook.com/references/keypairs-and-wallets.html#getting-keypair-from-a-secret
I guess because the seed needs to be a certain length
and when I try something like this:
``` 
const liquidityProvider = Keypair.fromSeed(Buffer.from(anchor.utils.bytes.utf8.encode("liquidityProvider")).slice(0, 32));
``` 
I get `bad seed size`
in a previous message, I see this snippet
``` 
var seedFromSolanaCli = "design forward flee wage vast host cigar fly able wool element upset near leopard attitude initial basic scene raccoon route glue crucial hunt diagram";
let seedBuffer = bip39.mnemonicToSeedSync(seedFromSolanaCli, "");
let fromSolanaCliTool = Keypair.fromSeed(seedBuffer.slice(0, 32));
````
hmm as I understand the createFromSeed uses a mnemonic seed phrase to generate the keypair from?
I think there is something called createFromSeed
is it possible to provide seeds to `Keypair.generate()` ? 
I am writing tests on devnet, and instead of airdropping each time to a new address, I figured that it might be beasier to just re-use an address (without going through the hassle of saving the keypair locally each time)
try wiping your lock file and target dir

I am trying to run "anchor build" for escrow contract and getting this error message


///////////////////////////////////////////////////////////////////////////////////////////////

yeah, program.account.name.all()
Is it possible to get all the accounts associated with my program?
I get an error when I try to pass to signers array phantom's wallet, what's the problem?
```
Transaction executed in slot 1146:
  Signature: 2bMwkUyeJfm8SBNnhCCZxA45N3AxwfwkyrW2mSHj8ySijKS2onHckigWv6BYRpj1SMZuQ5SAE4nYfP6s3KgS7eih
  Status: Ok
  Log Messages:
    Program 3cdx2BHuSCyyvLJt2ZhdcoPpSrMqzZHb2UPQD6f8tTUK invoke [1]
    Program log: Instruction: FetchVrf
    Program log: VRF rand for this run: 18298853097607163984
    Program 3cdx2BHuSCyyvLJt2ZhdcoPpSrMqzZHb2UPQD6f8tTUK consumed 144458 of 200000 compute units
    Program 3cdx2BHuSCyyvLJt2ZhdcoPpSrMqzZHb2UPQD6f8tTUK success
Transaction executed in slot 1147:
  Signature: 2bMwkUyeJfm8SBNnhCCZxA45N3AxwfwkyrW2mSHj8ySijKS2onHckigWv6BYRpj1SMZuQ5SAE4nYfP6s3KgS7eih
  Status: Ok
  Log Messages:
    Program 3cdx2BHuSCyyvLJt2ZhdcoPpSrMqzZHb2UPQD6f8tTUK invoke [1]
    Program log: Instruction: FetchVrf
    Program log: VRF rand for this run: 18298853097607163984
    Program 3cdx2BHuSCyyvLJt2ZhdcoPpSrMqzZHb2UPQD6f8tTUK consumed 144458 of 200000 compute units
    Program 3cdx2BHuSCyyvLJt2ZhdcoPpSrMqzZHb2UPQD6f8tTUK success```
I'm getting two log entries for a transaction I'm making - seems the only difference between the two is the `slot` they are in. I'm only expecting one log though (one transaction) and want to confirm this is just log duplication and not a case of the logic being run twice. 

Considering the signatures are identical, that means it's only being run once, correct?
iiiiiiiiinteresting. Thanks for the resources. I guess worst case, forcing into 1ix per transaction for these couple instructions could do the job!
https://discord.com/channels/889577356681945098/889702325231427584/927595439308546138
I broke it down for some guy a while back, let me find it
from there onwards: https://github.com/metaplex-foundation/metaplex-program-library/blob/master/nft-candy-machine/program/src/lib.rs#L381
At the price of composability, you can definitely do that. This is what is being done for the new version of the candy machine. Making sure that people don't pick and choose based on the NFT they got. It's basically accessing and parsing the instruction sysvar and whitelisting the programs, counting number of ixs, whatever
But short of somehow forcing ix1 to be the only instruction in it's transaction (probably not possible?) I can't think of any way to disallow this
Is there a best-practice way to ensure that if two instructions need to run in sequence, a user can't insert an instruction in between that fails if the result of ix 1 isn't to their liking?

I've essentially got logic that computes data in ix1 and uses the computed data in ix2. I've got bool locks that make sure these only run one after the other, but I need to make sure that once ix1 is run, there is no ability to roll back. But it seems any user could throw a separate instruction on the transaction _after_ ix1 that will fail the whole thing if they don't like the result
There's this: https://github.com/project-serum/multisig
if you want to code-up your own wallet.

Else you can have a look at Goki
Is there any solution
Has anyone ever set up a multisig wallet
Is there a way?
no
Hey guys, I'm trying to read some account data when a user has not connected their wallet yet (to show some statistics). Any idea how I can achieve this?

Right now I am doing 
```
this.program.account.bondPoolAccount.fetch(this.poolAccount)
``` 

but intantiating `program` requires to have a provider with a payer (in the browser!)
Exactly what I was looking for. Will that also generate an IDL that is usable in Typescript?
then it can just be called like any other anchor cpi function
you can do it like this https://github.com/project-serum/anchor/blob/e48f84c6bd7122a7d7744be2a9b25b7e8d2efc11/spl/src/token.rs#L12
Again, I want to confirm this. There is no good way to wrap a non-anchor program in an Anchor compatible API so I can use it for CPI with Anchor programs yet right?
Thanks <@!347689664855015424> 
Also, your blog is an absolute gem.
`await program.account.<name>.fetch()`
what's the way for deserializing an account state from the Typescript client?
There is an example in the repo
Got the answer in chat history ü§©
anyone here has interacted with there program using a solana rust client or anchor rust client, just wanted to know what packages are available and some starter code on how to write a anchor rust client to interact wiht solana programs.
Cross posting for visibility: https://discord.com/channels/889577356681945098/899315988087054397/932594701788393502
specifically any idea what is Custom Error 0x8f?
Hey guys, 

I am facing an issue. I am getting this error of Transaction simulation failing. But when I am retrying it several time, it is working good. 

I think, my RPC settings are bit wrong. Any ideas, why I am getting this error? 

I am using anchor 0.18.0 and I have not created the Custom Error 0x8f myself

```
Transaction simulation failed: Error processing Instruction 0: custom program error: 0x8f 
    Program 3f4J87oqwMxi7LqF5HTxSL8aFhnj9XX6o2WatXXrRGcP invoke [1]
    Program log: Custom program error: 0x8f
    Program 3f4J87oqwMxi7LqF5HTxSL8aFhnj9XX6o2WatXXrRGcP consumed 18871 of 200000 compute units
    Program 3f4J87oqwMxi7LqF5HTxSL8aFhnj9XX6o2WatXXrRGcP failed: custom program error: 0x8f
```

The issue doesn't come when testing on localnet, mostly coming on the mainnet
targer/types/<program>.ts those are types that allow making a Program<"ProgramName"> to do it all
any open source repos for a anchor rust client code i could refer to , inorder to make my client on rust to interact with my solana program ?
I‚Äôdneed to do some more digging in, cant seem to find it.. i think it was in a repo with mschneider or so gopartypareot, but maybe my mind is playing tricks on me
I am fairly certain ive seen some actual ts generation at some point tho..
Hmm maybe i misunderstood the docs, maybe all they meant was to generate the rpc subclass.   https://project-serum.github.io/anchor/tutorials/tutorial-0.html#workspaces
Googling rn‚Ä¶ https://project-serum.github.io/anchor/getting-started/introduction.html they do mention it on the first page of the docs
but that puts all the logic at the top
the only way is to crank them out conditionally at the top
best option is to use remaining accounts or pass in dummy accounts
yea optional accounts aren't great
remaining accounts no?
I have 1 context with 3 optional accounts, all optional for different reasons, i can't think about a good way to pick them up without passing a magic argument
in solana / anchor context.
when would one not put `pub` in front of a variable in the account structs?
Hi all,
anyone have resource for staking on solana with anchor ?
thanks
hey man i need a tutorial to build a swap pool and farms on my dapp 
Atrix  or Raydium which one i should use ?
In Eth I would do 
```
new IERC20Wrapped(data);
```
How in rust with anchor
I want to initiate a wrapped asset so my goal is something like
```
         let wrapped_token_program_id_ = token_instruction::initialize_account(
             data
         )?;
         ctx.token_program_id = token_program_id;
         ctx.wrapped_token_program_id = wrapped_token_program_id_;

```
help por avor?

```
    pub fn initialize_pool_asset(
        _ctx: Context<PoolAsset>,
        data: anchor_spl_token::token::InitializeAccount
    ) -> ProgramResult {
        Ok(())
    }



 | #[program]
  | ^^^^^^^^^^ expected named lifetime parameter

```
Ok! Thanks
If all you want to do is read some on-chain state, you'd do that by just fetching the relevant accounts (no instruction necessary)
If you want to mutate any on-chain state you'll have to do so via an instruction
Sorry, I'm not able to follow your question well enough to really answer it‚ÄîI think you're going to have to write some code so we can be more concrete
<@134416332509675520>
Yes. But I put a counter of 10 seconds and the information remains at 0 and when I call the function again, the counter increases
If you know the address the account lives at you can just fetch it, e.g. `await program.provider.connection.getAccountInfo(theAccountAddress)`
Sounds like you just want to read some account data. Do you mean from the client?
<@134416332509675520>
I have a function that increments a number over time, but in order to know how long my increment is going, I must recalculate using an instruction. I thought I could know the current incremental, without having to call an instruction. You see it?
Or if you want to interact with some other program, you have to send it an instruction (or do a cross-program invocation to it from your own program, etc.)
Not totally sure what that means‚Äîif you want to interact with your program then yeah, you have to send it an instruction
but from what I understand, we can't call a function without an anchor instruction
not much. I was wondering if they updated this by invoking a function, to get the current farm per user
I understand. So if you were right, a lot of things are done outside of the contract and updated by an instruction, maybe with a cron
But yeah, any time-driven stuff needs to be driven externally
Ah, sorry, is this a different question from your previous one? Not sure I follow
<@134416332509675520> I would like to understand a little. For example, orca farming, how do they have a weekly mint controlled in a program or daily by user? If the concept that is handled in the program is an execution of an instruction to be able to modify the variables, do they carry this control externally?
Like its so simple but i cant get it working
anyone able to help me on this post?
oh really? Got any links? I'd love to read up
What do you mean?
Is possible call a function without params and context?
I think the latest anchor release was doing this automatically, but I'd need to check... I did hear about it though
restarted the IDE and problem still persists
its slow to update
or your entire ide
close then reopen the file
Hi, I'm having trouble importing the cpi module of another crate when i do ```use ___::cpi::accounts``` it keeps saying unresolved import (im using rust-analyzer on vscode). I've added ```[features]
no-entrypoint = []
no-idl = []
no-log-ix-name = []
cpi = []``` in the cargo.toml of the callee and ```callee = {path = "../callee/", features = ["no-entrypoint","cpi"] }``` in the cargo.toml of the caller. It compiles though so is it an IDE error?
yeah that's what I thought ü§î, for instance if i change a `msg!` log it only reflects with a manual deploy
yea it should build + deploy + run tests
hey! isn't `anchor test` intended to also deploy in one go? i'm not seeing the updates in localnet without manually deploying


///////////////////////////////////////////////////////////////////////////////////////////////

tried to just send an array of json-rpc requests w/ method "sendTransaction" for a single POST, but for some reason only 1 tx gets through every time
if i created a blockhash with something like 
```
const { blockhash } = await connection.getRecentBlockhash('confirmed');
```
and then made say 10 different `new Transaction().add()` transactions, how can i send them all at once so that they're in the same slot?
hey this is more of a client question but still related to an anchor program, does anyone know how to send multiple of the same transaction in a single blockhash?
Standard practice is n accounts (PDAs) since you can only store 10mb max in one account and it would be very expensive.
Does anyone have some information or know where to find regarding the status of the approved Transactions v2 proposal? I've asked on Solana discord but didn't get an answer, here is the real Solona discord B)
In order to associate metadata to a collection of accounts, is it better practice to make `n` accounts / one per each account in the collection or have a single account with a HashMap?
<@!831450660146642974> figured it out... had to create a new account, transfer sol to wrap to it, initialize it as wrapped sol account, then transfer balance to the ata (since candy machine checks the token account is the ata)
the extra step is not necessary if the user does not already have a wrapped sol ata, but if they do then you have to add the intermediate account because only way to "wrap" sol 
is to initialize a token account and the native sol balance then is wrapped upon initialization.
Is anyone building on Bonfida's dex-v4 + aob? We need a functioning ui with this kind of logic
its less than 1mb.
are you deploying a large program file, like is your `.so` over 1mb?
yea but it seems to be running forever haha. I changed the solana version back to 1.8.12 since that's the version that some of my dependencies were running on and it solved the issue
this isn't an error, it looks like the program is just being deployed
because the treasury wallet for the cm is a program owned token account (multisig smart wallet). 
that part works fine as long as i wrap the sol in advance via the spl-token cli, but i need to do it in the cm mint page client code.
so... ive got it mostly solved but still missing this:

given an initialized wrapped sol ATA, how do I send native sol to the ata? What is the client code for "wrapping"? 

I tried using the `Token.createWrappedNativeAccount` interface but was unsuccessful since it requries a `Signer` argument and i only have
`program.provider.wallet` exposed since it uses phantom react api...
here a pic of the situation
when trying to run some tests on devnet I sometimes get this weird behaviour where the program just prints out a random address over and over again. I can't figure out where the problem lies, I have changed the config to devnet and also the anchor.toml is set to test on devnet. Anyone knows where this behaviour stems from?
Hi, everyone. I am following this tutorial to create a ticket system (https://www.fmendez.com/building-a-simple-on-chain-point-of-sale-with-solana-anchor-and-react). I would like to modify the smart contract so that each ticket is NFT. Can someone help me?
The solution is to use the exit method on the account after the update. Havent digged yet into why this is the case. Thanks <@!712332112128376885>
Solution
doesn't it?
it handles native sol
mmmh why wrapped sol
Has anybody here used wrapped sol for their candy machine mint? After adding the wrapping instructions to the cm_v2 ui client the transaction is too large... ideally i'd rather not force user to approve and additional transaction...
Hi all, i want to create a custom token for an user and the token should not be able to transfer from the user account by the user, only the mint authority can. like wise am looking out, do guys have any idea?, can you share me any resource you know that be much useful, regarding the custom token creation.
But might have to investigate what is going on
I hit the binary of the old version and it works
same here
How do I deploy more programs into the genesis block when doing `anchor test`?
haha, same. i did write react for like 5 years after it came out, but vue is now my happy place
ok, I'll have to look into it more. Svelte has been a great experience so far - I dread the idea of moving to React.
u probably have to do the same thing or switch to react. Not enough reasons for me to use react
yeah, that's entirely possible. What i did, was extract the wallet adapters i needed into my own codebase and created a wrapper around them. Thankfully, I only needed phantom.

Created new composables, state watcher for the libs, etc etc
OK thanks that makes sense, I'm using the Svelte adapter which probably has similar problems
In my case, i did https://discord.com/channels/889577356681945098/889577399308656662/932896455528706089
the solana wallet adapter has changed a bit between the time of release of that article and now. So has some internals of phantom.

I'm guessing u're using the vue adapter which TBF, sucks. And it's not properly maintained when compared to the react version. That could be the entire reason you're having an issue with this transaction
sure, this is the JS implementation copied from lorisleiva/solana-twitter hacked into Svelte
probably cause the blockhash isn't set. can you show how u're sending the transaction to phantom, faster for debugging
Any reason I could be getting this "Transaction simulation failed: Blockhash not found" on a localhost network? (solana test-validator running locally) Phantom wallet just spins waiting to approve then eventually indicates 'transaction may fail'. If I approve the transaction it still goes through though.
I think in your case, its been run twice for some reason. Also, curious how are u getting the VRF? Is this by chance from an oracle?
phantom already has the signer. but in your case you're passing a plain array instead of a Uint8Array. You'll most likely need to convert your array to Uint8Array using 

```js
Uint8Array.from(plainArray)
```

And pass that
maybe checkout marinade finance and their mSol token. something like that could be what u're referring to
why so many lifetimes?
```js
const int = new anchor.BN(10000); 
```

That's typically how u want to send large numbers to anchor as JavaScript is only 58bits and Rust and go well up to 128
yes. there's currently no way to schedule something on the blockchain, so you have to setup a crank for it
Generate an instruction using anchor 

```js
const tx = program.transaction.initialize({
    accounts: {
        authority: publicKey,
        systemProgram: anchor.web3.SystemProgram.programId,
    },
})
```
So, instead of using anchor's rpc proxy, u can just generate an instruction and sign it however u want.

Now that you've constructed your instruction, you can have phantom sign it

```js
const blockhashObj = await connection.getRecentBlockhash()
tx.recentBlockhash = await blockhashObj.blockhash
tx.feePayer = publicKey

const signedTransaction = await window.solana.signTransaction(tx)
const txId = await connection.sendRawTransaction(signedTransaction.serialize())
console.log('transactionId:', txId)
```
What is the correct way to pass an integer from javascript to an i32/i64 anchor transaction input? I got a type error previously and have now tried sending in Strings and converting in the program before submitting the transaction
general question: i'm implementing a system that involves daily recurring transactions. is a crank the intended way implement faux-scheduling? and then call it 1x day with an external client?
Hi all,
i have a idl file and programId build by anchor .
so how can i using TransactionInstruction phantom call  function rpc ?
many thank
Hi üôÇ 
I'm trying to update a field from a remaining account but sadly this one does not update and keeps it old value. I'm unsure why, but probably because somewhere the memory is copied but unsure where.


```
    pub fn lala<'a, 'b, 'c, 'info>(ctx: Context<'a, 'b, 'c, 'info, Lala<'info>>) -> ProgramResult {
        let lol =   &mut ctx.remaining_accounts.iter();
        let acc =  next_account_info(lol)?;
        let mut item: Account<'info, Item> = Account::<'info, Item>::try_from(acc)?;

        item.quantity = 3;

        Ok(())
    }
```

Within the JS file the isWritable is put to true : 
```
 remainingAccounts: [{isSigner: false, isWritable: true, pubkey: a.publicKey}],
```
when it ccomes to making a lending pool like aave. in solana is launching a wrapped, similar to aToken or cToken to be done from rust or is it done from the client?
1.9.4 solana program deploy doesn't work for me, it stays forever without outputting anything.
still have to use 1.8.5 for deployment somehow
Hey all, looking to build an API that interfaces with a program I'm writing. Anyone have any suggestions for frameworks or libraries for building APIs that work well with Solana?
are tests written using anchor's template and `anchor test` actually independent between suites? seems like they would not be unless the validator restarts between suites, which, idk how that would happen
that is, i want to use dependencies, which seems pretty basic
the reason i ask is because I want `anchor localnet` to deploy more programs than just the one im building in my workspace
is there anywhere i can read the schema used by anchor.toml?
Ok added `features = ["no-entrypoint"]` to `Cargo.toml` fixed the issue
Using serum as a dependency I get an error
```
error: the `#[global_allocator]` in this crate conflicts with global allocator in: serum_dex
```
How do I disable the `global_allocator` in `serum_dex`?
or do you know of a method to create a TokenAccount without needing the signature from the frontend
does the seed + bump combo work your program to get the correct ATA address?
I saw your follow up at https://github.com/project-serum/anchor/pull/790#issuecomment-939206306
<@!443079510053748743>
oh cool, I think I'll look into doing it on the rust side, hadn't thought of that. Thanks!
Can also use an extra variable in your account to use as a time oracle for testing
You can mock the clock in rust tests
Hi all! just curious if anyone knows a good approach for testing time-related programs (e.g. programs whose output changes on a schedule). For instance: "mocking" the clock sysvar just for testing purposes.
i know how to do this with `solana program deploy`, but wondering if anchor.toml supports dependencies in this manner
OK so now I understand that SPL token program is always loaded.

How do I load others? for example metaplex token metadata program?
Can I add more fields to an account once it‚Äôs created?
Why does token rs used invoked_signed even though the passed in CpIcontext has seeds as empty, is it so incase. A pda is used it would be compatible for it ?
OK so my program uses CPIs (specifically, with solana token program)
and as I understand it, this is fine during anchor test
does that mean that anchor test is also deploying the programs i'm CPI-ing to localnet?
Nice. Thanks!


///////////////////////////////////////////////////////////////////////////////////////////////

maybe its more rust related question, but could somebody help me to declare an array in struct derived from accounts? Because my solution doesn't work :\
So the question is: Should the data structures in the Anchor program (contract) be split into a completely separate crate? Or put into a separate internal module within the existing one? Are there any gotchas I'm likely to hit with this, and any advice starting out?
Hey folks, I'm about to embark on a probably-not-very-epic-but-feels-quite-epic quest. We already have a Solana Program (contract) in Anchor, and I want to write a Rust contract-interface client library/crate, that embeds the Rust/Anchor structs from the contract, and this Rust library will also be embedded in a Swift package (called from an iOS app). I've already got the rust/swift wrapping working, and I can duplicate the instruction structs from the contract in this library, but I want to split them out and share them. I want to ask about the approach for this aspect of it....
Yo need to actually create the account on the blockchain, generating a keypair is only the first step
Having some trouble passing in an enum as an instruction parameter from typescript:
```
#[derive(AnchorDeserialize, AnchorSerialize, Clone, Copy, Debug)]
pub enum StrategyType {
    MaxYield,
    EqualAllocation,
}

pub fn handler(
    ctx: Context<Initialize>,
    bumps: InitBumpSeeds,
    strategy_type: StrategyType,
) -> ProgramResult
```

Have seen others report success with `{EqualAllocation:{}}`, `{equalallocation:{}}`, and other case combos, but I keep getting `Error: unable to infer src variant`

What am I doing wrong here?

EDIT: `equalAllocation` was the correct answer
the first i getOrCreateAssociatedAccountInfo from spl-token it oke 
but the second i getOrCreateAssociatedAccountInfo from spl-token it error
offerTaker a ready on the solana blockchaine, it is keypair
have any of you been using github actions to automate PR reviews in anchor programs such as deploying and testing the programs? would be cool to check it out
i think the problem is the \\?\ but i don't know hot to remove it
Failed to obtain package metadata: `cargo metadata` exited with an error: error: failed to load manifest for workspace member `\\?\C:\Users\hixh1\Desktop\solana project\complete-guide-to-full-stack-solana-development\example2\programs\*`

Caused by:
  failed to read `\\?\C:\Users\hixh1\Desktop\solana project\complete-guide-to-full-stack-solana-development\example2\programs\*\Cargo.toml`
hello guys anyone knows how i can fix that
it cant find offerTaker on the solana blockchain. You need to create offerTaker
Thanks!
Hi all,
i have a problem when i using spl.Token 
the first call function below it oke but the second it error 
Error: Failed to find account
    at Token.getAccountInfo (/Users/nguyenthingoan/Desktop/SOLANA/solana-web3-demo/node_modules/@solana/spl-token/client/token.js:768:13)
 var tokenNFT = new spl.Token(
      program.provider.connection,
      paramMakeOffer.addressNFT,
      spl.TOKEN_PROGRAM_ID,
      Offer
    );
offerTakersMakerTokens = await tokenNFT.getOrCreateAssociatedAccountInfo(
    offerTaker.publicKey
  );
it error when getOrCreateAssociatedAccountInfo 
anyone ideal 
thanks
Let me know if you found the solution
I did 
```#[account(
    init,
    seeds = [b"seed".as_ref()],
    bump = nonce,
    payer = admin,
    space = 8 + size_of::<structname>()
  )]``` 
and so since its init I think it should be mut too
I think in general you cannot. I've seen some examples on borrow mut lamports, but I think that was separate. also, if it's a writable privilege, it means that you probably forgot to add a `#[account(mut)]`  somewhere
Hi, I updated to 0.20.1 and am getting the following error
```Type 'NodeWallet' has no construct signatures```
while trying to construct a wallet from a keypair
Solution: You can apparently pass `[AccountInfo]`  to an anchor `Context` via `remaining_accounts`

https://docs.rs/anchor-lang/latest/anchor_lang/context/struct.Context.html#structfield.remaining_accounts
Hi, is it possible to have a PDA as a payer in a CPI call? I tried this and kept getting an error about ```writable privilege escalated``` on the PDA account. Really stuck here
<@!347689664855015424> can i have a multisig wallet with native sol? i need to send nft royalties to a dao wallet but have only been able to do this with wrapped sol so far...
https://docs.rs/anchor-lang/latest/anchor_lang/accounts/program/struct.Program.html#example
gotcha. on another note, is it possible to have a program controlled escrow account with native sol? 
last I checked an account with data could not transfer out sol... so i resorted to using a wrapped sol token account with pda as authority?
is there any way to do this with native sol?
it used to be
What‚Äôs ‚Äúsafe sending?‚Äù
Are there any examples of safe sending custom amount of sol?
I did think it was a bit strange if only way to wrap was to initialize...thanks for the tip.
Ok, I‚Äôll check out sync native.
a transaction size can be 1232 bytes, you can fit in those many accounts irrespective of instructions
no expert here, but i suppose if you want to lock down your program to a single authority you can just hardcode the pubkey and do an assertion vs creating a pda just to store the same key
Is Solana‚Äôs 35 account limit for an entire transsction? Or just individual instructions
This is extremely helpful, thank you. What prevents someone else (malicious) out there in the world calling the `new` instruction and making themselves the authority before you do? It seems to me that there is some race condition to configuration, no?  Also, what prevents from someone else calling `new` at any point in time and resetting the state with them as the authority? I see it is deprecated and the new strategy is to use a PDA with `seeds = [b"the-state".as_ref()]` , but I guess my same question applies
this example comes to mind https://github.com/project-serum/anchor/blob/master/examples/tutorial/basic-4/programs/basic-4/src/lib.rs#L10-L14 - maybe helpful?
checking up on this issue here https://github.com/project-serum/anchor/issues/1120 has anyone found a workaround?
Hey all, I've searched discord up and down, asked a few days ago but got a cold response.

Is there a way to programatically reference the program owner/deployer/upgrade-authority from WITHIN that program? something like 
```
#[program]
pub mod my_program {
...
    my_program::owner();
```
?
Hey there, I'm having an issue getting started. Would love some help in the <#889702325231427584> channel
Big bump on this!!!

Does anyone have some information or know where to find regarding the status of the approved Transactions v2 proposal? I've asked on Solana discord but didn't get an answer, here is the real Solona discord B)
I had the same. my programs just wouldnt upload. I thought it was because there were not enough devnet validators or so?
Hi guys, please what's the real purpose of anchor migrations? Are they similar to migrations we'll get in an ORM
Don't do that you can send to the ata directly and call sync native, much simpler


///////////////////////////////////////////////////////////////////////////////////////////////

They're all raw AccountInfos, so their data actually doesn't live on the stack *or* the heap (it's in the 0x4 part of the solana memory map https://docs.solana.com/developing/on-chain-programs/overview#memory-map)
Are the docs updated yet?
are the remaining accounts received in context always found in stack? or could they be sent through the heap?
I got it to work. I needed to use `{program name}::accounts:InstructionName`  instead of `{program name}::InstructionName` to define the CPI accounts.  

Thank you for taking a look at this <@!347689664855015424> <@!915682383905316864>  üôè
could u share your code
Maybe you are using to_account_info on the ctx.accounts.some_account in question before passing it on to the cpi call?
hey everyone, happy new year.

I am trying to invoke my other program instruction which has one of its accounts as a Program account.  When trying to create the cpi_accounts I am getting 

```
expected struct `anchor_lang::ProgramAccount`, found struct `anchor_lang::prelude::AccountInfo`
```

Anyone know how to construct the expected program account from accountInfo?  Thanks
How do would i call this custom program call instruction increment from the counter example with restrictions that only a specific wallet can increment

```#[derive(Accounts)]
pub struct Increment<'info> {
    #[account(mut, has_one = authority)]
    pub counter: Account<'info, Counter>,
    pub authority: Signer<'info>,
}```

I would use this:
```
allocateTransaction.add(new web3.TransactionInstruction({
  keys,
  programId: web3.SystemProgram.programId,
  data,
}));```

But what are the Keys and the data.
I would say that the keys are:
```
let keys = [
  {pubkey: counter.publicKey, isSigner: false, isWritable:       true},
  {pubkey: authority.publickey, isSigner: true, isWritable:      false}
];
```
Is this correct?

For data i did:
```
let increment = {
  index: 2,
  layout: struct([
    u32('instruction'),
  ])
};

let data = Buffer.alloc(increment.layout.span);
let layoutFields = Object.assign({ 
  instruction: increment.index 
});
increment.layout.encode(layoutFields, data);
```

Did i get this right?
I'm building a cpi context and using the `anchor_spl::token::initialize_mint` to invoke this CPI:
```
        // initialize the ownership nft mint
        let creator_account_key = ctx.accounts.creator.key;
        let init_owner_mint_cpi = ctx.accounts.into_initialize_mint_context(ctx.accounts.owner_token_mint.to_account_info().clone());
        initialize_mint(init_owner_mint_cpi, 0, &creator_account_key, Some(&creator_account_key))?;
```
, and `into_initialize_mint_context` looks like this ( `mint` is signed):
```
    pub fn into_initialize_mint_context(&self, mint: AccountInfo<'info>) -> CpiContext<'_, '_, '_, 'info, InitializeMint<'info>> {
        let initialize_mint_cpi_accounts = InitializeMint {
            mint: mint.clone(),
            rent: self.rent.to_account_info()
        };
        CpiContext::new(self.token_program.clone(), initialize_mint_cpi_accounts)
    }
```
I'm stuck here getting a `Signature Verified Failed` error. Any help on where I'm screwing up?
how do i call programs if i know the program id?
Don't want to use the idl everytime
Is there any working examples of testing anchor rs file?
It would be amazing if rust macros allowed one to access the ast of the entire file but alas.
If you provide the wrong bump, you'll calculate an invalid PDA at some point.
I'm not worried about it being a footgun since tests should (almost always?) catch this.
And so the api is the way it is as a quick and dirty workaround. Not ideal but it does allow us to get instruction data into the derive macro.
The easiest way to do this with validation + avoid a duplicate deserialization would be to move the derive macro into the program mod. But that's a bit of a heavy lift.
The derive macro is in an entire different ast subtree so it doesn't have context of the program module instruction handlers.
Borsh serializes a vector of Ts as 4 bytes for the length + each T one after the other.
You just need to make sure you allocate enough space to handle whatever max size you're comfortable with
anyone have an idea how anchor/solana accounts handle vector sizes? do i have to specify the capactity of a vector in an account before
woa thank you so much! Do you guys have any experience interfacing with Mango Markets contracts?
Idk why the api looks like it does but <@501570363566587905> will
is it done like this because the full struct is only deserialized later on?
would be good to have some kind of validation yes, I think it might be possible to check that the endpoint ix list begins with the instruction attribute ix list
Isn't borsh fine with too long a slice but not with too short a slice (indeed)?
it creates a new struct from the given fields in the attribute and tries to deserialize that. thats why different names are ok but different order is not
potential giga footgun
or try to grab only the bump that was actually not passed in as first argument
I have seen people waste hours because they changed the order
Also this is raw decoding i think, so it doesn't care about naming
prob not the clearest example but we do it here: https://github.com/drift-labs/protocol-v1/blob/master/programs/clearing_house/src/controller/token.rs#L24
thank you!!
got it
E.g. take a look at the anchor_spl token module. All it does is build some spl token instructions and invoke them (so, there isn't really anything anchor specific about it)
Basically the "usual" way, by building an instruction and then invoking it with `invoke`/`invoke_signed`
does anyone know how I can make CPI calls to non-Anchor projects? The tutorial only covers the case to other Anchor projects
ha, all right. nice thanks
Ah, yeah, this came up on a different forum‚Äîtry_from_slice panics but `::deserialize` (what anchor uses) doesn't! That was a TIL for me too
Ok interesting you can omit everything after the arg youre interested in. Borsh's `try_from_slice` panics when there's bytes left over to read so I wonder how anchor doesnt
(It just re-parses the arguments from scratch)
You need to use them in order up to the last one you care about, lol
just to confirm, when using the `#[instruction(..)]` attribute on the accounts struct, I need to use all the arguments from the endpoint, not just a subset e.g. the first argument ?
Filed https://github.com/project-serum/anchor/issues/1219
yea we should add that to the parser
Might be nice to throw an Err if a dev tries to use `payer` with an account that isnt mutable
Closed the issue based on this feedback, thanks yall!
so there is no issue with cpi, i just need to mark `authority` as mutable?
ok so the anchor client is just marking the provider wallet as writable. I was wondering how the payer ended up writable. I thought anchor might be doing it on smart contract side when it sees `authority` specified as `payer`
Yeah. Definitely a gotcha that you can end up passing in your provider wallet as a payer and not notice that it gets automatically marked as mut since it pays the tx fees.
I guess what I mean is that I don't understand the "cpi module turns the `Signer` into a read only account" part. Seems more like it was never marked writable
According to this, `authority` is also a payer: https://github.com/drift-labs/protocol-v1/blob/master/programs/clearing_house/src/context.rs#L94
so isn't it just that you need to specify authority as mutable?
```rust
#[account(mut)]
pub authority: Signer<'info>,
```
Spent an hour or two trying to debug an issue with a cpi call. The errors I was getting was `{}'s writable privilege escalated`. The issue was i specified an `AccountInfo` as `Signer` and was using it as a `payer`. The cpi module, when it generates `ToAccountMetas` turns the `Signer` into a read only account. The workaround is to make `Signer` a `#[account(mut, signer)]`.

Filed an issue in case it's a bug: https://github.com/project-serum/anchor/issues/1218

Just putting it here in case somebody searches `writable privilege escalated` and has the same issue üòÖ
I want to create a language where you procedural describe a "workflow" involving multiple users which have to act in sequence (or in parallel). Then this workflow is compiled down into separate transactions which must be executed in a particular order. Before I get started, is there already something like this?


///////////////////////////////////////////////////////////////////////////////////////////////

thank you
`import { getPhantomWallet } from '@solana/wallet-adapter-wallets';` or `import { useAnchorWallet } from "@solana/wallet-adapter-react";`
see here for example react implementation: https://github.com/exiled-apes/candy-machine-mint/blob/main/src/Home.tsx
Hi  i am trying to build a swap like this 
https://swap.symmetry.fi/
can i do it with this tutorial
https://www.youtube.com/watch?v=ARG0FkY_5Dc&t=1134s
and how i can integrate phantom wallet ?
Something like this https://github.com/paulmillr/noble-ed25519 where the public and  private key is just the solana keypair should work for signing and verification
Maybe I‚Äôm missing something, but since solana accounts are just ed25519 keypairs you should be able to use generic library to sign stuff right?
When you create your anchor Provider - just use a Connection with the url you want. ```const clusterUrl = ‚Äúyour url‚Äù
const commitment = "processed";
const connection = new Connection(clusterUrl, commitment);
const provider = new Provider(connection, wallet.value, Provider.defaultOptions());```
There's also https://solanacookbook.com/references/basic-transactions.html#adding-a-memo
Sorry, not sure!
Everything other than a Ledger should work right?
It will depend on which type of wallet the user has (not all of them will expose this functionality as far as I know)
<@!134416332509675520>
How would I sign a message with wallets other than phantom?
You'd probably have to drop down to `useWallet` instead.
You can't, basically (signMessage is specific to phantom as far as I know, right? so can't work as a general `useAnchorWallet`)
How would I use signMessage() with useAnchorWallet()?
It seems only these functions are available
so basically just do a a try-catch? xD
Basically just try fetching it and see if there's an account there
i.e. if the token account has been initialized?
is there any good way to check if an associated token account has been generated already?
TokenAccount to hold the token and mint is the minter address
TokenAccount vs Mint? whats the ddif
https://youtu.be/FmdPAwsqJC4?t=3150

I think ANCHOR_PROVIDER_URL env variable
it‚Äôs devnet rpc url seems hardcoded
anchor doesn‚Äôt honor that
solana config set --url devnet??
any way to change the cluster rpc for devnet?


i‚Äôd like to set it to my own
i just added a separate instruction lol
https://github.com/project-serum/anchor/pull/1343 <@!134416332509675520>
It does not count
<@!134416332509675520> after a couple hours of debugging, i realized that the parsing is getting bonked because i have two files with the name name (one in `./state/bet.rs` and one in `./instructions/bet.rs`)

the second `bet` was just getting bonked it looks like
Thanks. That's what I was looking for.
it won't work on windows iirc, but wsl2 should work
my anchor test is not running on any of the available wsl, so trying it on powershell but it seems that anchor doesn't work on windows, :yikes:
not even powersheel
anchor doesn't work on windows?
ü•≥ ü•≥ ü•≥
welcome back!
alan!!! you're back! üòÆ
how can i create the account by web3js 
you have example ?
many thanks
I've been assuming that but just want to double-check
`load_init` means my program is initializing the account - meaning my program is the defacto-owner, correct?
yea that's a good debug step, will check it out
I'll do that getAccountInfo bit later in my next round of testing

Edit for posterity: I realized by doing this that the account I was passing in was incorrect. A simple problem of not passing the right publickey
hm, I haven't had this problem with any of the other zero_copy accounts I'm using. These first transactions are definitely finishing before the later one
But basically you want to find a way to log what the actual runtime owner is and see if it makes sense
And just verify manually that its owner looks right
You can always try refetching the raw account with `await program.provider.connection.getAccountInfo(theAddress)`
It sounds like you might need to wait for the previous tx to confirm maybe?
but the initial call with `load_init` succeeds - so seems my program should definitely be the owner of the account.
that instruction (the `createInstruction`) is run in the `instructions` array oof my initialize instructions - which calls `load_init`. That all succeeds. Later, I call a different instruction which just calls `load_mut` and that's where it fails on owner
Are you running that instruction in the same transaction as the rest of your code?
I would be very surprised if alignment affected that.
You can grep the anchor codebase and see everywhere that error is raised, and it always happens by checking the accountinfo's `.owner` property, nothing to do with its data.
Hmm, I'm not sure how that could be the case, but might have to think about it more
thanks
https://github.com/project-serum/anchor/blob/master/lang/syn/src/idl/file.rs#L381
But I'll go through everything again and see if I can find anything that seems wrong
https://discord.com/channels/889577356681945098/889577399308656662/930211309771956224
NB says here it could be FWIW
cqfd; can you point me toward the source?  i was trying to start with entry point for "anchor build"
Yeah, that wouldn't have anything to do with alignment (it's purely about the account's owner, which doesn't live in the .data field)
to be clear: this is run on the account prior to the `load_init` call: ```            await program.account.fudged_account.createInstruction(
              fudgedAccountKeypair,
              FUDGED_ACCOUNT_SIZE
            ),```
The idl generation is kind of janky to be honest, and involves parsing the program file. I'm not super familiar with it to be honest, so you may have to go source diving to learn more.
the `load_init` works fine, it's a follow up call with the account and `load_mut` that dies on me
don't think it works like that?
pass an _un_initialized?
(That way being: Pass an initialized `account(zero)`, call `load_init()?` to initialize it under my program's control)
yea fair thought but I've triple checked that I'm instantiating it the exact way as my other zero_copy accounts. May need to go for a quadruple check, but the message I reply to mentions that this error can surface due to bad alignment in `zero_copy` in the newest version of anchor
AccountOwnedByWrongProgram seems like.. an error that's unrelated to alignment?
Yo the anchor 8-bit discriminator doesn't count towards the struct right? I've got this `AccountOwnedByWrongProgram` error on a struct that's `alignment: 2` and only consists of an even number of `u16`s in an array. There's no way my padding should be off, yet I'm getting the error. this is with newest version of anchor using `repr(C)`
code here does work:  https://github.com/gdoteof/solana-gamba/blob/cqfd/programs/gamba/src/lib.rs#L18-L36

why does it need to be in the file?
Anyone have experience with metaplex token vaults?
<@!134416332509675520> i take it back.  if i have it in the same file (like you said) not within the #[program] macro (like you didn't say), then indeed moving it into the same file works
<@!134416332509675520> assuming this is what you mean: https://github.com/gdoteof/solana-gamba/blob/cqfd/programs/gamba/src/lib.rs#L21-L39
looks to be exact same error
Anyone successfully using Ed25519SigVerify111111111111111111111111111 on testnet? Both the JS and rust instructions fail for me on testnet, but they work against my local validator
https://docs.rs/solana-sdk/1.9.4/solana_sdk/ed25519_instruction/fn.new_ed25519_instruction.html
https://solana-labs.github.io/solana-web3.js/classes/Ed25519Program.html#createInstructionWithPublicKey

> Err(ClientError { request: Some(SendTransaction), kind: RpcError(RpcResponseError { code: -32002, message: "Transaction simulation failed: Error processing Instruction 0: invalid instruction data", data: SendTransactionPreflightFailure(RpcSimulateTransactionResult { err: Some(InstructionError(0, InvalidInstructionData)), logs: Some(["Program Ed25519SigVerify111111111111111111111111111 invoke [1]", "Program Ed25519SigVerify111111111111111111111111111 failed: invalid instruction data"]), accounts: None, units_consumed: Some(0) }) }) })
Mm, just to try something real quick, what happens if you move that code into the same file as your `#[program]`?
could anyone point me in the general direction of where IDL generation is implemented?  i am many hours into fighting with this trivial thing and kinda out of ideas so it hink i might as well start trying to see how it works
The other thing I'd try locally if I were you is to just use a modified/log-ier version of the anchor source
done change the idl.json to idl.ts
```json
import { Idl } from '@project-serum/anchor';
 export const idl: Idl = {
...
idl.json generate on anchor
...
}
```
thanks!
can you help me with that?

code is here: https://github.com/gdoteof/solana-gamba/blob/master/programs/gamba/src/state/bet.rs#L13
I get `
IdlError: Type not found: {"name":"betType","type":{"defined":"BetType"}}
`

I have `BetType` defined:

```rust
#[derive(Debug, Clone, Copy, Eq, PartialEq, AnchorDeserialize, AnchorSerialize)]
pub enum BetType {
    TwoFold,
    TenFold,
}
```
it seems that anchor is not adding types to the IDL that are e.g. enums that are defined.  I see some minor talk of it but wondering if someone can point me in the right direction
ok it can be one or the other, just that the function arg is obfuscating that
`fn fetch_idl(cfg_override: &ConfigOverride, idl_addr: Pubkey) -> Result<Idl> {`
any idea?

is there any reason for that? Feels unecessary since the idl is in a pda
idl fetch wants the idl address, not terribly ergonomic
i puked
i just tried getting rid of another account and adding my new account, and that worked. so seems like something fishy going on ( <@!501570363566587905> maybe you've seen this?)
although the provider code shouldn't mess with this
ix data is 

```
Buffer 25 4a d9 9d 4f 31 23 06 fb ff ff 00 e4 0b 54 02 00 00 00 00 e4 0b 54 02 00 00 00 01 00 00 00 00 00 00 00
```

right after creating the ix. which is right, i see two `1e9` in there. can try seeing what it is right before sending though..
If you set a breakpoint when you do the `program.rpc` stuff you can step into here-ish, https://github.com/project-serum/anchor/blob/master/ts/src/provider.ts#L104, and poke around with the raw tx, just to see exactly what it's data is before you send it
haven't tried, do you recommend just printing `ix.data` or something? i'm not changing anything on the client‚Äîif I remove the account and keep the client the same, it works
I'm not aware of any "good" reason why this should happen though, so definitely interesting
Like it would be nice to check if this is a js side issue or a deserializing stuff rust issue
Just to double check stuff, have you tried breaking in the js side to see what the resulting ix data looks like? I can't imagine it looks wrong (so I'm guessing the issue is somehow happening on the rust side) but am curious
i.e. just pass `buyer_price` twice and let one version get changed for some weird reason
I *could* hack around it by making the 5th arg a dummy arg, but seems quite brittle
I actually ran into this a while ago trying to modify this instruction, and then gave up and did something else lol. But now I'm running into it for a different feature üò¨
Neat lol
I'm not doing anything with `new_account` in the instruction. removing it fixes the issue
Interesting!
when I add `new_account`, then `buyer_price` becomes `1`, even though I pass in `1e9`. it takes its value from `token_size` (if you change `token_size`, `buyer_price` will reflect that)
it's a fork of metaplex's auction house contract

```
#[derive(Accounts)]
#[instruction(escrow_payment_bump: u8, free_trade_state_bump: u8, program_as_signer_bump: u8, buyer_price: u64, seller_price: u64,token_size: u64)]
pub struct ExecuteSale<'info> {
    #[account(mut)]
    buyer: UncheckedAccount<'info>,
    #[account(mut)]
    seller: UncheckedAccount<'info>,
    // cannot mark these as real Accounts or else we blow stack size limit
    #[account(mut)]
    token_account: UncheckedAccount<'info>,
    // 4th account
    token_mint: UncheckedAccount<'info>,
    metadata: UncheckedAccount<'info>,
    // cannot mark these as real Accounts or else we blow stack size limit
    treasury_mint: UncheckedAccount<'info>,
    #[account(mut, seeds=[PREFIX.as_bytes(), auction_house.key().as_ref(), buyer.key().as_ref(), token_mint.key().as_ref()], bump=escrow_payment_bump)]
    escrow_payment_account: UncheckedAccount<'info>,
    #[account(mut)]
    seller_payment_receipt_account: UncheckedAccount<'info>,
    #[account(mut)]
    buyer_receipt_token_account: UncheckedAccount<'info>,
    authority: UncheckedAccount<'info>,
    #[account(seeds=[PREFIX.as_bytes(), auction_house.creator.as_ref(), auction_house.treasury_mint.as_ref()], bump=auction_house.bump, has_one=authority, has_one=treasury_mint, has_one=auction_house_treasury, has_one=auction_house_fee_account)]
    auction_house: Account<'info, AuctionHouse>,
    #[account(mut, seeds=[PREFIX.as_bytes(), auction_house.key().as_ref(), FEE_PAYER.as_bytes()], bump=auction_house.fee_payer_bump)]
    auction_house_fee_account: UncheckedAccount<'info>,
    #[account(mut, seeds=[PREFIX.as_bytes(), auction_house.key().as_ref(), TREASURY.as_bytes()], bump=auction_house.treasury_bump)]
    auction_house_treasury: UncheckedAccount<'info>,
    #[account(mut, seeds=[PREFIX.as_bytes(), buyer.key().as_ref(), auction_house.key().as_ref(), token_account.key().as_ref(), auction_house.treasury_mint.as_ref(), token_mint.key().as_ref(), &buyer_price.to_le_bytes(), &token_size.to_le_bytes()], bump=buyer_trade_state.to_account_info().data.borrow()[0])]
    buyer_trade_state: UncheckedAccount<'info>,
    #[account(mut, seeds=[PREFIX.as_bytes(), seller.key().as_ref(), auction_house.key().as_ref(), token_account.key().as_ref(), auction_house.treasury_mint.as_ref(), token_mint.key().as_ref(), &seller_price.to_le_bytes(), &token_size.to_le_bytes()], bump=seller_trade_state.to_account_info().data.borrow()[0])]
    seller_trade_state: UncheckedAccount<'info>,
    #[account(mut, seeds=[PREFIX.as_bytes(), seller.key().as_ref(), auction_house.key().as_ref(), token_account.key().as_ref(), auction_house.treasury_mint.as_ref(), token_mint.key().as_ref(), &0u64.to_le_bytes(), &token_size.to_le_bytes()], bump=free_trade_state_bump)]
    free_trade_state: UncheckedAccount<'info>,
    token_program: Program<'info, Token>,
    system_program: Program<'info, System>,
    ata_program: Program<'info, AssociatedToken>,
    #[account(seeds=[PREFIX.as_bytes(), SIGNER.as_bytes()], bump=program_as_signer_bump)]
    program_as_signer: UncheckedAccount<'info>,
    rent: Sysvar<'info, Rent>,

    #[account(mut)]
    new_account: UncheckedAccount<'info>,
}
```

```
pub fn execute_sale<'info>(
  ctx: Context<'_, '_, '_, 'info, ExecuteSale<'info>>,
  escrow_payment_bump: u8,
  _free_trade_state_bump: u8,
  program_as_signer_bump: u8,
  buyer_price: u64,
  seller_price: u64,
  token_size: u64,
) -> ProgramResult {
```
Nah, not in my mind (I usually just do it within the program since the `init` stuff is so ergonomic)
I was just wondering if there was something like " always create a account that can be created outside of the program outside of the program"
Yeah, you can definitely also just do it in your program (basically I don't think there are any like "hidden" advantages one way or the other‚Äîyou kind of can just do it either way)
I mean either works, But somehow I prefere to have as much of the logic as possible in the program
Interesting... not sure why that would happen ü§î Can you post any code?
So u think that it does not really matter then right? unless you are exhausting your compute budget?
If all you need to do is create the ATA, then I don't see anything wrong with just doing it from the client (it doesn't require any intervention from your program).
I added another account to an instruction, and now the instruction data is getting messed up. That is, the value of one of the instruction's arguments is wrong. All I'm doing is passing in another account‚Äîit works if I omit the account. Has anyone run into an issue like this?
WalletSignTransactionError: x.pubkey.equals is not a function
    at PhantomWalletAdapter.<anonymous> (adapter.ts:171:1)
    at Generator.throw (<anonymous>)
    at rejected
And most importantly, why?
Assume that I'm making an app that requires the user to create a Token account or ATA, in which to store a token related to the programs functionality, where is it customary to make this? Create CPI's from my program or invoke the system_program/token_program directly from the client?
https://github.com/project-serum/anchor/tree/master/client/example
Hey guys, I'm running this ann getting the following error:
`    await cpamm.rpc.swap(amount, amount, {
      accounts: {
        user: {
          tokenProgram: TOKEN_PROGRAM_ID,
          swap: swapAccount,
          userAuthority: wallet.publicKey,
        },
        input: {
          user: new PublicKey(token1.mint),
          reserve: new PublicKey(token1.reserve),
          fees: new PublicKey(token1.fees),
        },
        output: {
          user: new PublicKey(token2.mint),
          reserve: new PublicKey(token2.reserve),
          fees: new PublicKey(token2.fees),
        },
      },
    }); `

error:
`Translating error Error: Signature verification failed
    at Transaction.serialize (transaction.ts:583:1)
    at SolanaProvider.<anonymous> (provider.ts:77:1)
    at Generator.next (<anonymous>)
    at fulfilled (tslib.es6.js:73:1)
SwapContainerComponent.jsx:85 Uncaught (in promise) Error: Signature verification failed
    at Transaction.serialize (transaction.ts:583:1)
    at SolanaProvider.<anonymous> (provider.ts:77:1)
    at Generator.next (<anonymous>)
    at fulfilled (tslib.es6.js:73:1)`

Any idea on what could it be causing it? Thanks
This sounds similar to my query above - are you writing an off-chain client in Rust/Anchor to communicate with the on-chain program?
silly me, can just use a native token account and sync_native.
How to issue a transaction using Anchor using a Rust crate? Any way to consume Anchor program from a Rust code that is not another program i.e CPI?
oh, yeah, I was thinking that its impossible
thanks for reply
not possible rn. use `remaining_accounts` if you have variable amount of accounts


///////////////////////////////////////////////////////////////////////////////////////////////

Account ownership is totally independent of the address at which the account lives.
In this case if you send money to a "fresh" PDA, the account that holds the sol is still owned by the system program, despite the *address* being derived from your program.
Ah, I think you're confused about account ownership: just because an account lives at a program-derived address doesn't mean that the account itself is owned by the deriving program!
But you can only transfer SOL from account which is owned by system program . Here in our case  if I use PDA as a vault then PDA belongs to my program. Is that my understanding wrong?
Because the address is a PDA derived from your program, your program can then subsequently sign for that address when it wants to send the sol somewhere else (by invoking the system program with `invoke_signed`)
For a pure wallet (no account data, just sol), you can just send sol to an address and the sol will sit there.
oh ok. I am little confuse here. I read different post and they have mentioned that if we want to create vault account for SOL then we need to have pda address that authorize one of the system wallet. So here if I do not create / initialize system account how my address would bind to that wallet.
You can definitely transfer to the address from within your program though.
I tried doing that locally (generated a PDA and pasted it into the phantom send dialog), and yeah, phantom doesn't like the address.
Oh, interesting, maybe phantom won't let you send to an off-curve address? Weird.
Can you post the full error message?
I need to further use that pda to withdraw sol from same. I created PDA address without initiating account but when I go to phantom and try to transfer SOL for same it says invalid account.
If all you want to do is store some sol there, you actually don't even need to init the account at all. You can just send sol to that address.
okay thank you
try `anchor init blablabla`
Hi ! i'm trying to create a new program with anchor but every time I type "anchor new blablabla" I have this error : "Not in anchor workspace."
I need to create SOL vault account with PDA address so program can transfer SOL to other wallet.
but that is not working
Can I initialize empty data account with PDA? I was thinking something like #[account(init, seeds=[(*rand.key).as_ref()], bump=_bump, payer=owner,space=164)]
    site_wallet : SystemAccount<'info>,
you need the "money" to be an spl-token in a TokenAccount with a PDA as its authority. Then you can just transfer it with `anchor_spl::token::transfer()`.
If you want to use native SOL, then you can use a TokenAccount with NATIVE_SOL as its mint, and use `spl-token sync-native` to convert the native sol to the spl token.
i am working on something similar. Lets connect and exchange notes
solana having issues
I'm really stuck on this Invalid blockhash error, anyone has idea how to fix it?
Maybe ill try again ty
Oh that was actualyl the one I was trying. I just got an error
on linux
alternatively you can use `npm i -g @project-serum/anchor-cli@0.20.1`
the way i did it was `cargo install --git https://github.com/project-serum/anchor --tag v0.20.1 anchor-cli --locked` just specify the desired version tag, then just change the lookup path that `anchor` command uses to point to desired binary.
Hello guys how do you downgrade anchor version, say from 20 to 18?
also remeber to change the Anchor.toml file as well
check the keypair in your ./target/deploy folder using `solana address -k ./target/deploy/your_proj_name-keypair.json`  for what it should be - rebuild and redeploy
usually this happens to me because `declare_id!()` macro is set to the wrong address.
I Guys üôÇ is someone know how we can send money own by the smart contract to an user account ? Thanks by advance ü§ü
<@!501570363566587905> 
Can you tell how to generate the account and instruction modules for anchor_client usages in Rust as pointed out and used here in the example? 
https://github.com/project-serum/anchor/blob/master/client/example/src/main.rs#L15
`anchor idl init`
Oh I think I figured it out, I need to have this running on on the command line
hey all, I'm trying to analyze the instructions for a transaction (https://explorer.solana.com/tx/4FFzc6spegby7yDVkgL4dBbGtMnBQSfABdJqygaTrMz5zhaikhpBBmyV5HYs2VrPbMUFMrZ82d1qBQBNYXSGdkSc) as follows:

`async function getIDL(): Promise<void> {
  const connection = new web3.Connection(web3.clusterApiUrl('mainnet-beta'), 'confirmed');
  const signature = '4FFzc6spegby7yDVkgL4dBbGtMnBQSfABdJqygaTrMz5zhaikhpBBmyV5HYs2VrPbMUFMrZ82d1qBQBNYXSGdkSc';
  const transaction = (await connection.getParsedConfirmedTransaction(signature));
  const ix = transaction?.transaction.message.instructions[0];
  console.log('hi');
  const idl = await anchor.Program.fetchIdl("MEisE1HzehtrDpAAT8PnLHjpSSkRYakotTuJRPjTpo8");
  console.log('bye');
  if (idl) {
    const ixCoder = new anchor.InstructionCoder(idl);
    const decoded = ixCoder.decode(
      (ix as web3.PartiallyDecodedInstruction).data ?? "",
      "base58"
    );
    console.log(decoded);
  }
  console.log('null idl');
}`

However, `  const idl = await anchor.Program.fetchIdl("MEisE1HzehtrDpAAT8PnLHjpSSkRYakotTuJRPjTpo8");` is throwing an error. Screenshot attached. Any idea on what's happening here? Is it since I didn't provide a wallet to the API call?
hey everyone i want to know that is it possible to make a token contract using anchor framework where i can have some customization like of deducting a certain amount of fee on every transaction that happens on that token contract and send that fee to a liquidity pool and to the owner of that contract is this thing possible using the anchor framework ?
How do I use an rpc for deploys?
The networks is really congested lately and:

Doing --provider.cluster <quicknode rpc here>
Always errors out with json 2.0 not returned etc

It just takes all my sol causing me to have to manually run solana program close
any course or tutorial help me a lot.
hi all, I need to be fork example solana nft staking app.
Thank you very much for your help.
Yeah, you can just do it all in the one anchor function
Sorry one last question. when buyer submit tx then I need to do 2 operations (instruction) one is transferring nft and second is transferring SOL to wallet. I have 2 different instructions. I assume I need to add both in single tx due to dependency.
Yeah, but the signing happens via `invoke_signed`. No need to say anything about signing from the client.
Got it.
Sorry if I misunderstood. I was in impression that signer seeds from pda work as signer
It will sign from within the program, via invoke_signed like you have above
The site_wallet can't be a signer, since it's a pda
Who would the other signer be? Which account?
pub fn pay_return_buyer(ctx: Context<PayReturnBuyer>, lamports: u64) -> ProgramResult {
        
        msg!("Return to Buyer");

        let pool = &mut ctx.accounts.pool;
        let site_seeds = &[
            pool.site_rand.as_ref(),
            &[pool.site_bump],
        ]; 
        invoke_signed(
            &system_instruction::transfer(
                &ctx.accounts.site_wallet.key,
                ctx.accounts.buyer.key,
                lamports,
            ),
            &[
                ctx.accounts.site_wallet.clone(),
                ctx.accounts.buyer.clone(),
                ctx.accounts.system_program.to_account_info().clone(),
            ],
            &[site_seeds],
        )?;
        
       
        Ok(())
    } // <@!134416332509675520>  so here if I make buyer who is submitting tx should be the signer then do I need to pass 2 signers? one is seed and another is buyer?
Yes Program Driven Address.
Or do you mean something else?
Just to double check, by pda you mean program-derived address, right?
You'll have to instead know its seeds + bump and do the transfer with `invoke_signed` (assuming the account that lives at that pda is a system program account)
So don't use `signer` fo the site_wallet
And the pda *can't* be a signer from the client actually (not possible since only the program itself can sign for it)
pub struct PayReturnBuyer<'info> {
    #[account(mut, signer)]
    pub site_wallet: AccountInfo<'info>,

    #[account(mut)]
    pub buyer: AccountInfo<'info>,

    #[account(mut)]
    pool : Account<'info, Pool>,

    system_program : Program<'info, System>,
} // here needs to transfer from site_wallet to buyer where site_wallet is pda
So the user will submit the tx, and the tx will then have the program do the transfer
You'll have to do that transfer from the pda to the user's wallet within your own program
User1 is submitting tx. But I need to transfer SOL from PDA to user1's wallet so PDA is signer. Can I have signer and payer different?
Who is submitting the tx? Why don't they just pay?
Do you in my usecase how can I pay transaction fees?
The pda can't pay for the transaction actually, since it can't sign from the client (only the program itself can sign for it‚Äîafter someone managed to submit a tx/pay the tx fees)
I have written rust program using Anchor where when user1 offer price, I add those SOL in pda account. When user1 cancel that offer I need to transfer from pda to user wallet. May I know how can I make payer and signer different? I want to sign this transaction through PDA but do not want PDA to pay for transaction. That transaction fee from user's wallet.
Where is the version number actually listed?
Hmm, I'm having trouble finding the error then‚Äîthat code is meant to mean look in the state.rs file (the leading 0x1 part), line (0x761 = 1889), but I don't see one of the assertion macros there.
V3
Do you happen to know what version of the serum dex is deployed at the moment?
hello guys , i'm trying to place an order using the serum-ts library , but getting error 0x1000761
When I try to deploy to devnet using anchor deploy to an existing address (i.e. update to contract) I get the following:
```Error: Custom: Invalid blockhash
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.``` 

Any ideas?
Hi, I am trying to mint via anchorpy and solanapy but I just get this error along the program one:
``anchorpy.error.ProgramError: 2006: A seeds constraint was violated``
```solana.rpc.core.RPCException: {'code': -32002, 'message': 'Transaction simulation failed: Error processing Instruction 5: custom program error: 0x7d6', 'data': {'accounts': None, 'err': {'InstructionError': [5, {'Custom': 2006}]}, 'logs': ['Program 11111111111111111111111111111111 invoke [1]', 'Program 11111111111111111111111111111111 success', 'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [1]', 'Program log: Instruction: InitializeMint', 'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 2343 of 200000 compute units', 'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success', 'Program ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL invoke [1]', 'Program log: Transfer 2039280 lamports to the associated token account', 'Program 11111111111111111111111111111111 invoke [2]', 'Program 11111111111111111111111111111111 success', 'Program log: Allocate space for the associated token account', 'Program 11111111111111111111111111111111 invoke [2]', 'Program 11111111111111111111111111111111 success', 'Program log: Assign the associated token account to the SPL Token program', 'Program 11111111111111111111111111111111 invoke [2]', 'Program 11111111111111111111111111111111 success', 'Program log: Initialize the associated token account', 'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [2]', 'Program log: Instruction: InitializeAccount', 'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 3272 of 179576 compute units', 'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success', 'Program ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL consumed 24345 of 200000 compute units', 'Program ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL success', 'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [1]', 'Program log: Instruction: MintTo', 'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 2515 of 200000 compute units', 'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success', 'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [1]', 'Program log: Instruction: Approve', 'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 2025 of 200000 compute units', 'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success', 'Program cndy3Z4yapfJBmL3ShUp5exZKqR3z33thTzeNMm2gRZ invoke [1]', 'Program log: Instruction: MintNft', 'Program log: Custom program error: 0x7d6', 'Program cndy3Z4yapfJBmL3ShUp5exZKqR3z33thTzeNMm2gRZ consumed 14103 of 200000 compute units', 'Program cndy3Z4yapfJBmL3ShUp5exZKqR3z33thTzeNMm2gRZ failed: custom program error: 0x7d6']}}```
Any explanation for that error? I dont really understand it but it could be because I am not setting the ``creator_bump`` value right in the mint_nft instruction but I am not sure what structure it has to have, I am just doing integer right now
So any time you say `Program<'info, SomeProgram>`, anchor will verify that the passed-in account really does have the right address
The `Something` there specifies what its address is supposed to be (e.g. try jumping to source on Token if you have a `Program<'info, Token>` lying around)
And wrong program@in terms of the ‚ÄòSomething‚Äô? Ie does anchor cross compare the idl of the deployed program, and the IDL defined in the program?
You're apparently doing some `Program<'info, Something>` and passing in the wrong program from teh client
oh.. that makes sense
The issue is that in the browser you won't have access to the user's actual secret key (the wallet will never ever give it to you‚Äîat best they'll expose some api for using it behind the scenes)
I'm getting it for this programId, but solana explorer shows that this address does exist on devnet: https://explorer.solana.com/address/5W8cgQkGhjniKuVikNyVq6Nh5mWVzHawRnXkWhL7risj?cluster=devnet
Hey guys, I'm getting a 
``` 
  Error: 3008: Program ID was not as expected
``` 

what are the best ways to debug this? I already checked out all accounts on solscan, and they all seem to be owned by their rightful programs..


///////////////////////////////////////////////////////////////////////////////////////////////

Hi, there. I am trying to make nft staking contract.
So, when stake nft, need to transfer nft to pool vault.
When transfer nft, it is require nft token account of pool vault.
How to create nft token account in rust?
I am now bending my mind with statelessness yet needing to know the state of affairs to do something fairly (see above) if you have any ideas, tips pointers
Yeah, that one has taught me a lot though
Yeh I forgot it was a contract owned token account so it needed a signer. It was actually a diff contract that made me realize but I can‚Äôt remember which one. Most of the burn examples don‚Äôt use the signer cpi
the `ido-pool` example in the achor tests shows this beautifully
I have a Solana/anchor puzzle I am thinking about a lot mentally, maybe someone enjoys thinking with me

I am building a staking protocol where a fixed amount of rewards are distributed pro-rata over the stakers over the duration that they have staked.

Can't loop over accounts and check when they started staking to calculate rewards when a person withdraws ofc. I am trying to see if there is a way to fairly distribute rewards upon redemption or "harvest" moment. I am trying not to think in terms of when everyone stakes and how to calculate rewards fairly. I am trying to design a mechanism which doesn't require an external crank. 

Has anyone done something similar or know of a fair rewards distribution mechanism which doesn't require a crank?
Thank you! I‚Äôll try this
Basically what `simulate` does, but tweak it for your use case: https://github.com/project-serum/anchor/blob/master/ts/src/provider.ts#L207
Ok, I guess you could also just use `program.transaction.updateConfig` to build a tx object and then submit it yourself with `simulateTransaction`
Ah, ok, did some source-diving, I guess it does request a signature from the wallet
Hmm. As far as I know phantom is just using the same transaction simulation machinery that `.simulate` would use
I guess what I really want to do is jack into the info phantom has when it simulates a tx
I guess I can just query program state and manually "simulate" price change before running the actually await program.rpc call
It requires me to sign the tx via phantom.

Basically I'm playing around with making a swap
I want to check for slippage before a user submits a tx
If price is moving fast I want to let them know

It's pretty bad ux to have to click approve twice for the "same" tx to make it go through.

Is there a better way to do this?
`program.simulate.updateConfig` üôÇ
kind of like phantom wallet before I click approve
Is there a way to simulate a function call in anchor?
ex:
```
await program.rpc.simulate.updateConfig()
```
ahh i switched to a new keypair so i had to
1) remove the keypairs in `./target/deploy`
2) deploy the contract
3) update the new program ids
4) deploy the contract again
Thank you for your answer.
```Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [1]
    Program log: Instruction: InitializeAccount
    Program log: Error: IncorrectProgramId```

any ideas why id be getting an `IncorrectProgramId` error when creating a new token account for a user?
I was just stuck on the error where i cant move NFTs to stake so I'm considering all the options even if I think it is actually not the solution
idk what gemworks involves or what you mean by "can't make the project work" but as far as Anchor itself is concerned you don't need docker
This is gemworks btw that I'm trying to do
I ran anchor build on windows and it said SOlana BPF is not available on windows. So i just tried WSL but i cant make the project work so I'm guessing maybe because I have no docker?
(Maybe you need it for whatever that course is)
You don‚Äôt need Docker
Does it mean I need to install both or either one?
anyone know how to use TOKEN_PROGRAM_ID local?
I want to create a guess game where user will submit Sol to the program and will guess the random number generated by program between some range. If guessed double money will be transferred and not then will lose his stake. So here how to make the program pay the fees for transfer of token from program to user and how to generate random number?
I tried doing random number generation 
https://docs.switchboard.xyz/randomness
```
#[allow(unaligned_references)]
use anchor_lang::prelude::*;
use std::convert::TryInto;
pub use switchboard_program::VrfAccount;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod dice_game {
    use super::*;

    pub fn get_random(ctx: Context<GetRandom>, params: Value) -> ProgramResult {
        let luck = &ctx.accounts.values;

        let v = VrfAccount::new(luck)?;
        params.dice1 = String::from_utf8(v.get_verified_randomness().clone().unwrap()).unwrap();
        // params.dice2 = v.get_verified_randomness().unwrap();
        // luck.dice2 = VrfAccount::new(luck)?.try_into()?;

        // let v1 = format!("{:?}", String::from_utf8(params.dice1.clone()).unwrap());
        // let v2 = format!("{:?}", &params.dice2);
        msg!("Values are: {:?}", params.dice1);
        
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 8 + 64 + 64)]
    pub values: AccountInfo<'info>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}


#[derive(Accounts)]
#[instruction(params: Value)]
pub struct GetRandom<'info> {
    #[account(mut)]
    pub values: AccountInfo<'info>,
}

// #[account]
#[derive(Clone, AnchorSerialize, AnchorDeserialize)]
pub struct Value {
    dice1: String,
    // dice2: u64,
}
```

but getting  ```ctx flows into ctx here``` error saying there is an lifetime mismatch
Any anchor nft minting repos that aren't candymachine floating around to look at?
What kind of work has been done to support the anchor_client and async rust
Any examples of token burning?
I can't seem to get the signers right.
Hi is there any anchor examples for transferring SOL from invoking wallet to another wallet and vice versa?
we are adding sth like this
i'll just add some logic for that in my program
why can't `declare_id` just go with the one for the corresponding network in the Anchor.toml
but nah lol
i thought it would be enough to differentiate the keys in the Anchor.toml
It's surprisingly easy to mess this is up.
YES! thank you
My guess is that your `declare_id!` doesn't match the actual runtime/deployed id
looks like <@!765147529725476864> had the same bug. Did you solve it?
anyone know why it works on localnet but not devnet?
Of course it isn't owned by the executing program, it doesn't exist! I'm trying to initialize it!
i run `solana account [pubkey-of-pda]` and i get that the account doesn't exist
works fine on localnet, devnet gives me `The given account is not owned by the executing program`
trying to initialize a PDA to a zero-copy account
actually i guess it is doing that.  creates a token with provider as all of the parameters
because theres no way that makes sense
or am i looking at this wrong
in solana, you make the token first and then apply an account to it?
In this test file. you guys set up a usdc token to test with but im confused
https://github.com/project-serum/anchor/blob/e48f84c6bd7122a7d7744be2a9b25b7e8d2efc11/tests/ido-pool/tests/ido-pool.js
<:whut:920405009223524372>
facepalm, missing `anchor.setProvider(provider);` from the migration script
is there any reason why `program.rpc` would use a different rpc than the provider?
seems to be trying to use localhost rpc
<:thonk:895614589562150913>
adding `skipPreflight: true` still throws a simulation failure
weirdly
running into this on devnet
Any oracle examples from anchor?
Or examples of someone getting NFT attributes from a rust program on Solana?
How do I use an RPC Node when running anchor deploy from the cli
Are you talking about https://docs.solana.com/developing/runtime-facilities/programs#system-program?
hey guys anyone knows whats a SystemProgram?
actually nvm this is still an issue, i realized my mental model of how this idl works was off. basically i'm to see if magic eden uploaded their program here and analyze some instructions, but it looks like they might have just not uploaded their program via anchor? not sure, any other insight would be greatly appreciated!
appreciate the help
never to mint again
Since the address itself is used once, stored and thrown away
I think keypair would be simpler in this case
Makes sense
But here they sort of aren't, because of the nonce
Whereas pdas are usually guessable/"memorable"
Keypairs are usually kind of annoying because you have to, like, remember them‚Äîthey're random
I'm just trying to understand what you gain by using pdas here‚Äîthey aren't really better or worse than keypairs, just different tradeoffs
suggest keypair instead?
I dont, just thought it would be the route
Why do you need to use pdas at all though?
wouldnt you need to check the seeds match up
but how would random pdas work?
yes random would work and I store the mint generated already
So would storing the mints at random keypair addresses work? I guess you'd have to have some way to remember the addresses later though
keypair + init a mint -> pass that in could work
yeah to avoid collisions
Is the nonce just to avoid collisions?
Could you store the mints at keypair addresses then? (Maybe that doesn't work any better than at pdas, not sure)
basically I need to create new mints on the fly, I dont really care what the pda is
yes
Think I'm not following‚Äîis the nonce like an incrementing id?
same one
Another txn
Who would be changing the nonce?
Usually you want PDA addresses to be guessable/non-random, but yeah, you can totally do the above
Well it seems I would need to grab the account where the nonce is stored, get the pda and then pass in that account (js). I was wondering if somehow the nonce could change from passing it in to execution or something
What do you mean by ok? Are you worried about something breaking etc.?
Is it ok to use a nonce to create a pda? I.e. ["vault", 1], ["vault", 2] And if so, where/how should I be storing that nonce?
So, no need to keep anything alive when the account doesn't have any sol.
But if the account has zero sol in it, then there isn't anything to delete‚Äîit's already in an empty state.
That's the thing, with a pure wallet account there isn't really any account to delete (well, sort of‚Äîeven empty accounts take a little bit of rent, so if you send the account a very tiny amount of sol it'll be under the empty account rent exemption amount, and the rent collector will actually take some of your money üòõ)
<@!134416332509675520> ,If my PDA account balance is zero then won't get deleted in next epoch right because we do not have data. Or do I need to keep minimum balance all the time to keep my account alive.
ah got it. Thanks for the information. Yes I verified account still own by System Program.


///////////////////////////////////////////////////////////////////////////////////////////////

like integration tests or something for that function?
do you have a client that works outside of the front end client stuff?
yes, I've seen this but still can't figure it out üòÖ
did you see this? https://discord.com/channels/889577356681945098/889702325231427584/925962127326470235
I posted this is beginner-questions but I'm starting to think it's more of an advanced question.. anyone able to help me figure out what could be my problem? https://discord.com/channels/889577356681945098/889702325231427584/934844396883558451
It‚Äôs not exported in a typescript friendly way. You can @ts-ignore and it will run. Not elegant, but it works
What version of Anchor are you currently using? and what's you tsconfig (ES6, etc)? thanks
NodeWallet
Hello, all üôÇ Have a good time this weekend?
I want to transfer spl my own token.. but it's an issue
```
            await consumeToken.approve(
                fromTokenAccount.address,
                new web3.PublicKey(transferAddress),
                ownerAddress,
                [signer1Keypair, signer2Keypair],
                transferAmount * 1
            );
```
Please let me know is it correct and how can I fix the issue
I downgraded versions, I think it's something to do with ECMAScript version inconsistency
Same question. Have you gotten an answer to this? In general, how does one interface w/ a real-world wallet, not just some arbitrary keypair generated by anchor, if none of the wallet types returned by the standard @solana/wallet-adapter-xxxx useWallet(), useAnchorWallet() exports are compatible? ps. never seen type NodeWallet before this, either
Any idea what's causing this? The program creates a PDA off of a program address, a bump seed, and two public keys. When the token program tries to initialize, it gets this issue
hey guys, I just posted a design question on stackoverflow, would highly appreciate any upvotes! üôÇ https://stackoverflow.com/questions/70823213/how-do-i-calculate-tvl-on-chain
someone meet this problem ?
D:\Worksapce>anchor init myepicproject2 --javascript
Error: yarn install failed: program not found
what can i do for this ?
Nice! Thanks for the guidance üôÇ
Ah, if you want to distribute different types of tokens as rewards and not just a single type you will need something more complex.
Maybe this can offer some insights:
https://github.com/project-serum/stake
Right, for sushi type staking awards that makes sense. This would be a Geist-type fee distribution for all users into each individual vaults
What do you mean by, in a single transaction? Do you want to update every individual account that is staking every time rewards are to be distributed?
In this example I completely avoided making any individual user accounts that need to be updated. To distribute tokens to individual accounts requires a more complex system, that isn't necessary if you just want to distribute rewards to every staker based on their portion of the total staked amount.  
The reward tokens are automatically distributed when they are deposited into the vault based on a simple calculation using the total tokens in the vault and the total amount of xTokens minted. A user can then claim their share of rewards, if they were staked when the rewards were deposited, based on how many xTokens they got when they staked.
Seems like you are distributing the tokens for each user per single instruction. I guess there isn't really a clean way to do this in single transaction Solana due to the programming model and the compute limit
Thanks, I'll have a look!
A pretty simple way I've found of distributing tokens to stakers is similar to how xStep and xSushi do it. I 've got a simple implementation on my github:
https://github.com/Kriptikz/anchor-xtoken-staking
The bump is just a u8 from 0-255, used to kick the key off the curve. So they can have the same bump, it doesn't actually matter. 
Being able to uniquely identify tokens you init from your own program seems tricky, since those token accounts are owned by the Token Program, which means you can't just add some identification data to it.
Off the top of my head you can have an authority PDA that will be the owner of these Token Accounts. Then any account owned by that PDA will be owned by your program. Doesn't guarantee it was initialized by your program - but it will ensure that your programs PDA is the owner and can sign CPI's for it; like transferring, burning, etc.
Another way could be creating some account data in your program that tracks Token Accounts you init.
the bumps can be different.
I'm trying to make a revenue sharing system where when someone buys and NFT the proceedings will get distributed to all token stakers. What would be the best architecture to achieve this? Only way I can think of for now is to periodically spam the network with multiple transfer instructions for each staker. Is there a way to implement this in an event driven manner?
i want to be able to uniquely identify spl tokens that i init within the contracts
```
1 usdcReceiptMintAccount PublicKey {
  _bn: <BN: cbbb1ff4223875bf197b284b549f757d0fa2c491b03425efdd782444d6d6465a>
}
1 usdcReceiptAccountBump 255
2 usdcReceiptTokenAccount PublicKey {
  _bn: <BN: c575e3cdae9cd923adae53d26a8357228fce002a84d6861aa139a79570248a33>
}
2 usdcReceiptTokenBump 255
```
print..
are programs supposed ot have ompletely unique bumps because this prints the same bump:

```
    const [usdcReceiptMintAccount, usdcReceiptAccountBump] = await anchor.web3.PublicKey.findProgramAddress(
      [usdcMintPublicKey.toBuffer(), Buffer.from("receipt_mint")],
      program.programId
    );
    console.log("1 usdcReceiptMintAccount", usdcReceiptMintAccount);
    console.log("1 usdcReceiptAccountBump", usdcReceiptAccountBump);
    this.usdcReceiptAccountBump = usdcReceiptAccountBump;

    const [usdcReceiptTokenAccount, usdcReceiptTokenBump] = await anchor.web3.PublicKey.findProgramAddress(
      [usdcMintPublicKey.toBuffer(), Buffer.from("receipt_account")],
      program.programId
    );
    console.log("2 usdcReceiptTokenAccount", usdcReceiptTokenAccount);
    console.log("2 usdcReceiptTokenBump", usdcReceiptTokenBump);
    this.usdcReceiptTokenBump = usdcReceiptTokenBump;

```
you can use AWS
Very true
the BPF program can be downloaded and reversed too
nothing is hidden
I mean it's the blockchain
<@!134416332509675520> If we use Anchor framework then do we know what is the best practice to keep IDL file which is used by client. If it is at client side anyone can download and understand our contract design.

anyone else getting then when trying to deploy on mainnet right now?
Are RPC requests to devnet not working? I tried to get faucet but not happening anything. 
```
solana balance, solana airdrop
```
 command too does not work on devnet giving me same error. I tried on two operating systems same thing
`line is highlighted`
I can do that in rust right? i feel like doing this beforehand seems like its a bad idea
so this ^
https://github.com/project-serum/anchor/blob/e48f84c6bd7122a7d7744be2a9b25b7e8d2efc11/tests/ido-pool/tests/ido-pool.js#L73
ok, thanks!
I'm not quite sure how to answer your question‚Äîit isn't any more magical than how regular instruction arguments work in your `pub fun do_something(ctx: ...)` handler
Think you should try using `cargo expand` on a simple anchor program, think it will make things clear
I still don't understand... Could you help me more üôÇ
It actually just re-parses those arguments from the instruction data
maybe looking at `anchor expand` output can be helpful
Can anyone tell us how the "instruction" work? How is the information in "initializer_amount" passed along for example, seems like magic tbh...
```#[derive(Accounts)]
#[instruction(vault_account_bump: u8, initializer_amount: u64)]
pub struct Initialize<'info> {```
Gotcha. Thanks!
Which id do I have to replace and where??
You're using the wrong program id (check the one in Anchor.toml matches however you're deploying the code)
Everytime I run anchor build on the anchor boilerplate code for tests, I get this error.
I have also tried running anchor test --skip-local-validator, but I get the same error.

I'd love a solution. Been stuck on this for 2 days.

PS: I am running a ubuntu machine.
What I mean is - if your declare_id! is wrong you have a bigger problem anyways
Wait I didn't know this. Will this even matter since the Owner trait works through this anyways (meaning the Account<'info, ...> owner check as well)?
just a quick one; will the authority here be a pda?
so you wouldn't actually know which loader the program is loaded with during comptime
yea and another thing is that in the future the default bpf loader could change
if we did, that would be a better alternative
i think we currently dont enforce that the declaredid == actualid
hmm thats true that could work
I mean both inputs are known
I'm new to rust, but wouldn't there be a way to derive it at comptime using macros or something?
you could but whether it's better depends on your use case. `find_program_address` takes unknown compute units so I prefer to use the account. it's not an account that ppl try to write to constantly so locks aren't a concern
<@!347689664855015424> question about doing admin checks with ProgramData -- instead of verifying that the passed ProgramData account matches the program by passing the actual Program account and then getting the programdata_address from there (https://github.com/paul-schaaf/anchor/blob/master/tests/bpf-upgradeable-state/programs/bpf-upgradeable-state/src/lib.rs#L71), since the programdata_address is a PDA derived from program id and bpf loader id, wouldn't it be better to just derive the programdata_address using find_program_address instead of passing the whole Program account just to get that address?
the direction is MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr
does anybody knows how Memo program v2 of solana works ?
makes sense! yeah i guess the other thing should work as well if you need to test on localnet
I think i found the answer : 

You can actually just do `anchor deploy` to devnet and then `anchor test` and it works üòÆ
haven't tried it, but looks like `solana-test-validator` includes a `clone` param ```Clone accounts from a public cluster, including programs (--clone ...)
``` that may accomplish what you're looking for
Also - can I somehow run `anchor test` in devnet?
How do I write tests on localnet/testnet if most protocols only have their programs up on mainnet/devnet ?

in the latest version of anchor how do I do this:
you can use `invoke_signed` and `spl_associated_token_account::create_associated_token_account` i think


///////////////////////////////////////////////////////////////////////////////////////////////

test validator not running in parallel
getting `Error: airdrop to 6QDgdEEMahKZGr2CEAfVhGJfK3EgxxphXww3eyWLGSpb failed: Internal error` when running `anchor test` which is using `localnet` - any advice?
Looks like this was added here https://github.com/solana-labs/solana/pull/22292
This is new on solana v.1.9.5 `Transaction leaves an account with data with a lower balance than rent-exempt minimum` ü§î
is it possible to obtain a minting contract Transaction Instructions and keys from any CMID by using IDL fetch ?
thanks i will try it
You can fetch the account that lives there with `await program.provider.connection.getAccountInfo(theAddress)`
yess
So what do you mean by fetch it fro the block chain?
no i don't storing it
Are you storing that public key in an account?
I'm not sure what you mean
i want to get offer.publicKey from solana blockchane 
it oke right ?
The seeds are hashed to produce the derived address (can't reverse that).
Given only `escrowedMakerTokens`, you can't figure out what seeds were used to derive the address.
Not sure I understand what you mean‚Äîcan you say more?
Hi All,
i have code below so how can i find again offer.publicKey from escrowedMakerTokens
const offer = anchor.web3.Keypair.generate();
  console.log("offer : ", offer.publicKey.toBase58());
  const [escrowedMakerTokens, escrowedMakerTokensBump] = await anchor.web3.PublicKey.findProgramAddress(
    [offer.publicKey.toBuffer()],
    program.programId
  );
  console.log("escrowedMakerTokens", escrowedMakerTokens.toBase58())
Please ignore as I am not able to reproduce now.
Although it happened only once. I am trying to find signature hash if I can
#[account]
pub struct ItemData {
    pub unlisted : bool,
    pub owner : Pubkey,
    pub pool : Pubkey,
    pub account : Pubkey,
    pub created_time : i64,
    pub item_type : u8,
    pub item_amount : u64
}
pub fn unlist_offer(ctx : Context<UnlistOffer>) -> ProgramResult {

        msg!("Unlist Offer");

        //let pool = &ctx.accounts.pool;
        let item_data = &mut ctx.accounts.item_data;
       // let clock = Clock::from_account_info(&ctx.accounts.clock)?;

        if item_data.unlisted {
            return Err(PoolError::AlreadyUnlisted.into());
        }
        item_data.unlisted = true;

        //Check if balance is enough in vault account
        if item_data.item_amount > **ctx.accounts.vault_wallet.lamports.borrow_mut() {
            return Err(PoolError::InsufficientFunds.into());
        }

        //Transfer sol from vault to buyer account
        **ctx.accounts.vault_wallet.lamports.borrow_mut() -= item_data.item_amount;
        **ctx.accounts.owner.lamports.borrow_mut() += item_data.item_amount;

        //Close item_data object as not needed
        ctx.accounts.item_data.close(ctx.accounts.owner.to_account_info())?;
 
        
        Ok(())
    }    // Here I am closing item_data which is not Token account but Account initiated by Anchor.
I'm not sure what they mean when they say the close failed (were they using `close`? or closing a token account, etc.?)
Oh, sorry, misread their post
closing an account with `close` does not use cpi though
It is 100% the case that if a cpi fails midway through your tx, then the whole tx will fail.
That seems very unlikely to me ü§î Can you post the actual code?
Hi there, I dont know why there is not ./target/idl/program.json after running anchor build? Please help me
Anyone has any idea? What should be the best practice? Should we create separate instruction for each operation or put all in one anchor function?
I have instruction in my rust class using Anchor, where I have added 2 operation in same instruction. First operation is to transfer sol and second to close account. I was expecting that I would achieve all or none but surprisingly my first operation was successful and second operation was failed. Still I got my tx successful. Is it expected? Do I need to create 2 different instruction and put in one transaction to achieve all or none behavior of tx.
I wanna find solution to pay account create fee on program side.

In here signer is user. so user will pay fee. How to pay fee on program side when create new account?
```
signer: Signer<'info>,
#[account(
        init,
        payer = signer,
        seeds = [
            data.to_account_info().key.as_ref(),
            "data".as_bytes()
        ],
        bump = nonce,
    )]
    data: Box<Account<'info, Data>>,
```
I am still running into the same error üò¶ even after I updated the idl json file after deploying it
i've had this happen when my idl json file wasn't updated after deploying a new version of the protocol
Does anyone know what "Uncaught (in promise) RangeError: Trying to access beyond buffer length" is caused from? I am having a hard time trying to pinpoint the reason behind it
I occasionally see: `The program was compiled without idl instructions` when I try to use one of the generated client rpc calls (anchorpy in this case). Anyone know why?
actually.. reading the comment in the deprecation notice answered my question, thanks again for the help üôÇ
is there any way to accomplish this without having to pass in the base account pda for every method?
ok thanks, good to know! so something like this and forgive the quick pseudocode

```
init
    base_account = pda('base_account') (+ constraint to match seeds)
    base_account.authority = ctx.accounts.authority.key()

some_method
    if accounts.base_account.authority != accounts.authority.key()
        return err```
Also note: `#[state]` is deprecated. https://docs.rs/anchor-attribute-state/0.20.1/src/anchor_attribute_state/lib.rs.html#26
Yeah, you'd want to save the `authority`'s `PublicKey` in some program account and verify it later on when doing the restricted action.
What's the best way to hold onto a programs authority key when initialized so it can be checked against? I see this example with `#[state]`, but is this still the intended approach? https://github.com/project-serum/anchor/blob/master/examples/tutorial/basic-4/programs/basic-4/src/lib.rs#L10-L14
Sure!
May I dm you to ask some anchor related questions?
You somehow aren't passing enough accounts into a CPI I think (would have to see more code to see how though)
Running anchor test, does anyone know what insufficient account keys for instruction means?
https://spl.solana.com/token#finding-all-token-accounts-for-a-specific-mint
ahhh I see. I'm new to Rust. Thank you!
`features = ["dex"]`
need to use the feature flag
seems the module hasn't been included since v 0.18.0
am I missing something? Thanks for the help
and can't install the dex module
I have anchor_spl 0.20 installed
no why do you think that?
we just shouldn't use that anymore?
so is anchor_dex deprecated?
Yes..
are both of those screencaps connected to devnet?
This worked. LOL. added // @ts-expect-error to my two lines where I set the provider and then the idl (another typescript issue), and the whole thing bloody works! Thank you so much!

both üòÑ
I am making spl token staking auto-compound. I met risk. need to fetch all staked users for auto compound.
how to get all users list who have my spl token? or is there any other good idea?
when you said you "redeployed" before, did you mean netlify or the devnet on-chain program?
what is inside 'view advanced transaction details'
the wallet already says it's going to fail on the live one
this is a difference I see for one, but the requests don't make me a lot wiser
can you look at the developer console to see the difference in the http requests that are made between your local build and the bundled one?
the local build gives me the same error, so it's the code itself for sure..
Thank you, I'll also look into that
ahh I understand, nope haven't tried that but I will now
i was wondering if you have tested that "bundled" version of the app running on a local server and see if that works; to see if it the code itself or somehow netlify
i mean when you are testing locally you are probably running like a dev environment with live reload and non-minified javascript.  but what gets sent to netlify is (probably) like bundled/compiled/minified javascript
I can view the website, just not send a "goal"
ehm what do you mean exactly?
is it broken then or does it work?
and what if you look at the bundled version that gets sent to netlify; but view that one locally
yes!
oh i am just seeing that.  so everything works fine on your local machine.  its the netlify version that is borked only
if I test both of them locally it works fine too
both of them on devnet
when you run the tests locally they are probably on your local cluster; are you also testing your client against the local cluster?  or are you testing against devnet or prod?
I just redeployed again, doesn't change anything..
then it seems pretty likely you haven't re-deployed to wherever you are testing?
yes! they pass
i see you do.  https://github.com/carlijnweijer/buildspace-solana-web3/blob/main/tests/myepicproject.js#L27  do these pass or no?


///////////////////////////////////////////////////////////////////////////////////////////////

Is there a list of the arguments u can pass to the anchor account macro (`#[account(<args>)]`) anywhere? I can't really find anything in the docs for the anchor_lang crate.
Added this to keep track: https://github.com/project-serum/anchor/issues/1360  üôÇ (if anyone could check my repro steps are accurate I'd appreciate, thanks)
https://discord.com/channels/889577356681945098/889577399308656662/935477171080818688 this sol'n worked for me <@!620612278768762880>
Passing the system program from the client worked thx a lot!
Gah - we just decided to drop trying to use anchor to talk to our contract from iOS.. anyone got any tips on getting started with talking to our contract directly? Will have to re-produce what anchor does I guess, but without sharing the instruction structs.
How did you install solana? Sorry, I can't help much more from here‚ÄîI would suggest uninstalling it and starting over
Oh, same contents as in that issue?
I don't understand lol
Good to know, thank you!
https://github.com/project-serum/anchor/issues/876 this is the file
yeap
^ and yeah, this is just a random rust thing, the From trait https://doc.rust-lang.org/std/convert/trait.From.html
Do you mean `ctx.accounts.into()`?
Hey <@!134416332509675520> hope you are well. I have a question for you! Does implementing a `from` method on an account struct change the output of `ctx.accounts.into()`? I'm thinking specifically of: https://github.com/project-serum/anchor/blob/d8d720067dd6e2a3bec50207b84008276c914732/tests/spl/token-proxy/programs/token-proxy/src/lib.rs#L130
Go look at that file
The error message says, at the bottom, `Check ./anchor....`
kinda confused now, wdym
What does that log file say? (It gives you a location to look at)
nope ryzen 5 so i don't think so
Interesting. Is your computer maybe super underpowered?
ubuntu
Are you on an M1 mac?
I am just confused bro I have been stuck in this for like 2 days now
it's version 1.9.2
Your solana install is messed up something, but I can't really help you with that
Does it look healthy?
When you run `solana-test-validator` , what does it do?
It's possible something is wrong with your solana install unfortunately

Yep
so for now let me kill validator and run achor test again?
Make sure you turn off the `solana-test-validator` process though
Just do `anchor test`, no more `anchor deploy` etc.
Ah, yikes. I would suggest that you kill your running solana-test-validator and just skip using it (not sure what's going wrong, that's a completely different error)
this is the error now
Whatever comes back from `anchor keys list`
You need to replace it in Anchor.toml and your declare_id
Right, that's the default program id, not the one you would have gotten when you ran anchor deploy

That's what we're trying to debug above! And my bad, do `console.log(program.programId.toString())`
this is the error I am getting
Delete it lol
That's not part of the default
What is that `solana-test-validator` line doing there?
default file with no changes made
this is the file
`[programs.localnet]
solana_dapp = "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"

[registry]
url = "https://anchor.projectserum.com"

[provider]
cluster = "localnet"
wallet = "/home/sohom/.config/solana/id.json"

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"
solana-test-validator`
``
You have like a syntax error
That means your Anchor.toml is probably broken now
yup
That's' the same error you were getting before?
with no console log
this is the error

We need to know what program id your test is trying to use (it's wrong lol)
But what did that console.log print?
I just did anchor test and same error
I have never run any test honestly except anchor test, this was just a default repo with default files after `anchor init` & `anchor build`
I want to know what it prints/how it compares to the id you think it should have
Ah, no‚Äîjust rerun your tests (make that console log run)
ok wht cmd should i run now ? `anchor keys list`?
Anywhere after you define the `program` variable
actually where exactly to add it?
u mean over here in this file?
Basically you're using the wrong program id, just need to figure out why
oh sorry give me a sec
Sorry‚ÄîI'm asking you to add that and then tell me what it says üòõ
I didn't do anything as such like this, I was just following this https://openquest.xyz/quest/solana-calculator
In your js test, what does `console.log(program.programId)` end up printing?
Don't many people use `anchor-client` for Rust? It needs some love :/
getting same error
Do `anchor keys list`
Ok, you'll need to fix both the Anchor.toml as well as the `declare_id!` call to match the actual deployed program id
i did  anchor deploy first
I am getting this error now
Do you have a running solana-test-validator open in the background?
How are you running the tests? Did you do an actual `anchor deploy` or did you purely run `anchor test`?
they both are the sameee!
Yep!
nope it isn't like should I change it manually or something?


That's saying your using the wrong program id in your test code
Does your Anchor.toml program id match the actual program id?
<@!134416332509675520>
heyy everyone , I am stuck with `anchor test` for the past 2 days now, not able to move forward at all, I would like your help , any idea or input or suggestions at all
apologies and disregard, it looks like #[state] is deprecated.
In the examples, it shows #[state] being used for setting an authority whitelisting.  Wouldn't it be possible for someone to race ahead of you call your initialize before you do without further checks?
Yeah sometimes I‚Äôll be watching the build and think why tf am I pulling in a string-searching algorithm
I think it's more the `solana*` crates that are unnecessarily bloated, rather than anchor. Anchor just suffers from having to pull them in :/
Also the anchor-client depends on `termios` - is this actually needed for `-client`? or only in the `-cli` package?
I'm not familiar with exactly how dependencies work in cargo (well I read about it, and used it a bit... but can't figure out advanced things); it'd be really nice if I could depend on `anchor-client` but tell it to use a certain `feature` when it depends on `solana-client` - is that possible?
I'm trying to build it for iOS - looking at its `solana-client` dependency, is there a good way in Rust to change this dependency so it uses the recently-merged fix in `solana-client`?
Does `anchor-client` in rust have a feature to not depend on `hidapi`?
Thanks
lol
The instruction data is 8 bytes of sighash at the front, followed by the borsh serialization of the instruction arguments: https://github.com/project-serum/anchor/blob/master/lang/syn/src/codegen/program/common.rs#L17
I think you'd need a "price_update_authority" and you do it offline and submit it, but it checks that the authority has signed.
You could look through the anchor source for how this is done: https://github.com/project-serum/anchor/blob/master/lang/syn/src/codegen/program/instruction.rs#L137
Of course this should be done in the smart contract - otherwise how do you know they have paid for the specific action? Even if you could check a transaction id or something (which I don't think you can from within the contract itself) then you wouldn't know if they were obtaining the reward multiple times from a single payment transaction, unless you stored huge data structures for every tx inside a PDA of teh contract.
i.e. How do I trigger specific entrypoints/functions?
Hey, how can I find out what an Anchor program is expecting as an instruction when I'm making a raw instruction from bytes with solana tooling?
This didn't work for me. 

In the end downgrading anchor-spl + anchor-lang to 0.18.2 (upgraded anchor-cli to 0.20.1 as well) seems to have worked
Anyone experiencing issues with devnet atm? Seems the node I'm using is lagging
Also (need to sticky this or something): way easier to help debug if you post the *entire* program log, not just a snippet
Hi <@499605357719453736> I have the same problem !
We would need to see more of your code to tell (transfering just takes the source + destination accounts, but you do *also* need to pass in the system program account from the client)
As long as they're simple `account_info`s it should be fine
Hi ! I encounter the same problem ! Is it working ? üôÇ I think my problem is in the structures in the context, is it possible that you send me the structure definition when you define the account user and the account fee_wallet ?
Could anyone help me with "Uncaught (in promise) RangeError: Trying to access beyond buffer length"? I have been trying to figure it out but have never came to a conclusion on this
Rn I'm passing both the to and from accounts but i'm getting this error
Can anyone tell wat accounts I need to pass when invoking the `solana_program::transfer` function?
It would introduce error into the TWAP calculation. Any thoughts?
The other issue I see with just using a crank for something like this is that it's not necessarily precise. Like if you want something to be called at an exact time.
Question: What is the best design pattern when you need a function of your program to be called at a specific time (i.e. like a cron job). For example let's say you want to calculate the TWAP of Pyth price at 00:00 UTC every day. 

The only thing I can think of is make that function permissionless so that anyone can call it to calculate the TWAP, but the calculation only goes through after the right timestamp. This seems like its not too robust. And 

Not sure if there is a better way to do this.
hey can anyone tell me that how to make a token contract through anchor framework? is there any doc or help ?
when play a game, if need to create new account, player need to pay the fee. I want to pay from admin.
how to set program as payer when create new account?
ohh i see. will have to do that also. at least i know in advance üòÑ
np üëç
e.g. a withdrawal function
you don't need to sign when you're receiving lamports, only when sending them, so if you were doing something similar but sending the lamports from your PDA you'd have to use invoke_signed
if i understand correctly
nah because the payer is signing it rather than your program
shouldn't i use invoke_signed?
thanks a lot mate!
you can do it in the program (smart contract):

```rust
anchor_lang::solana_program::program::invoke(
            &ix,
            &[
                ctx.accounts.user.to_account_info(),
                ctx.accounts.fee_wallet.clone(),
            ],
        )?;
        ix = anchor_lang::solana_program::system_instruction::transfer(
            &ctx.accounts.user.key(),
            &ctx.accounts.authorisation.key(),
            FEE_LAMPORTS, // your amount goes here, the amount is in lamports
        );
```
THANK YOU üôè
<@!202864446903681026> this is how I did it. the BigAccount struct just has the array field and the count field. the BigAccountEntry struct just has two fields, each one is a different pubkey and one of those pubkeys is what's used to "find" the entry in the account and remove it. 

would make more sense if i rename `pop()` to `remove()` and add a `pop()` fn that removes + returns the item at a specified index (or the end of the array by default) but yeah it's a WIP. 

probably much better ways to go about doing this but it works, you just need to make sure the array is bigger than you'll ever need it to be. 

```rust
impl BigAccount {
    // This is inefficient, depending on your use case you could add an idx field
    // to the struct you're storing in the array, unfortunately not viable for 
    // my use case though
    pub(crate) fn push(&mut self, entry: BigAccountEntry, n: &u8) {
        // If you don't need to add a varible number of duplicated entries like I do, 
        // then you can remove all the stuff related to n
        let mut idx: usize = 0;
        while n > 0 && idx < self.big_array.len() {
            if self.big_array[idx].is_empty() {
                self.big_array[idx] = entry.clone();
                self.count += 1;
                n -= 1;
            }
            idx += 1;
        }
    }

    pub(crate) fn pop(&mut self, entry_id: Pubkey) {
        let mut idx: usize = 0;
        while idx < self.big_array.len() {
            if self.big_array[idx].entry_id == entry_id {
                self.big_array[idx] = BigAccountEntry::default();
                self.count -= 1;
                self.squash(idx);
            } else {
                idx += 1;
            }
        }
    }

    fn squash(&mut self, idx: usize) {
        // I use this to make sure there are no gaps, so idx = count-1 will always be
        // the last non-empty index in the array
        let mut i: usize = idx + 1;
        let mut k: usize = idx;
        while i < self.big_array.len() {
            self.big_array[k] = self.big_array[i].clone();
            i += 1;
            k += 1;
        }
    }
}
```
hey there, i m working on a program that requires the user to transfer some SOL to a pda derived from program key before doing a specific action. 

would be better to charge the user for lamports from frontend side via a tx OR do the transfer via the smart contract?
best off using an array. 

my solution was to create a struct with an array field and a count field. then to implement pop() and push() methods for the struct which iterate over it and make sure there are no 'gaps'
`sol_log_compute_units();` is your friend
haha, guess i'll write a bash script to retry until it goes through then, thanks
or really anyway to pass a variable number to publickeys into a program
Hello, i am trying to save a list of publickeys and am having difficulty saving a Vec<Pubkey> in an account due to deserialization errors. Is ther a better way than using a Vec?
I'm trying to build a rust library that depends on `anchor-client`, with the `--target aarch64-apple-ios` target specified... issue is that it fails to build `hidapi` crate for this target (it uses `libudev` for USB hardware wallet support). The underlying issue is now fixed in solana (<https://github.com/solana-labs/solana/pull/21449/files>) but I don't know how to pass the feature along from the `anchor-client` dependency in my library's Cargo.toml file. Is this possible? Or do we need to push changes into anchor to specify the features when it depends on `solana-client` ?
Hey all, having trouble seeing Program Logs in my local validators logs. 

Followed the instructions here:
```
When running a local cluster the logs are written to stdout as long as they are enabled via the RUST_LOG log mask.

export RUST_LOG=solana_runtime::system_instruction_processor=trace,solana_runtime::message_processor=info,solana_bpf_loader=debug,solana_rbpf=debug
```

but when I look at the logs I'm not able to see a simple msg!("Hello World")
done
```json
return Keypair.fromSecretKey(
    Buffer.from(
      JSON.parse(
        fs.readFileSync(process.env.ANCHOR_WALLET, {
          encoding: "utf-8",
        })
      )
    )
  );
```
Property 'payer' does not exist on type 'Wallet'.ts(2339)

any help? thanks!
this message doesn't belong here, but curious does anyone know of any smart contract insurance companies? wondering if there is a way we can buy insurance on our contract after we also get the contract audited. just to provide extra safety for funds
nvm seems to work on devnet, I guess log filtering isn't supported with local validators?
Seems to also not work on devnet...
Awesome, thanks for clarifying!
Any time you use `init` in anchor you'll end up rent-exempting it by default
It will usually happen automatically (at any rate, whenever you create an account in solana you have to specify how much sol to start it with)
Maybe! Haven't tried this, was just thinking about something I want to develop so this may be my answer
Isn't that already happening automatically unless you flag it as rent exempt?
If you're using a PDA to store data on behalf of a user, and you want to persist the PDA indefinitely, is it possible to calculate the rent required to persist the PDA in real time and add this to the cost of the transaction?
FWIW `solana logs <program-id>` doesn't seem to work either...
Okay, I did some tests and found that amount of remaining_accounts doesn't lead to that - I sent 12 accounts again, but burned only 2 nfts
So, the problem is related only with invoked instructions inside my program
I'm trying to use https://docs.rs/anchor-client/latest/anchor_client/struct.Program.html#method.on to subscribe to events from a program, but it looks like all the logs are getting filtered out somehow. From experimenting: https://gist.github.com/shosti/bd14836aaf1d1ddfc030137aacf1fb92 works but https://gist.github.com/shosti/a7edbfe73d448b90fa03427dde3213a3 doesn't (with a local validator). Has anyone else run across this issue?
and I need to pass some arguments to that instruction: nft pubkey, nft token account and nft metadata account
3 account * 4 nfts = 12 account
I use burn instruction inside my contract, and I use it in order to burn nfts
I'm not sure why extra `remaining_accounts` would lead to that, hmm
> Program 4oFF7dcUaeMNiDrhX8s9QfaeF2NXcuD3m9HHmuKfiphN consumed 200000 of 200000 compute units> Program returned error: exceeded maximum number of instructions allowed (200000) at instruction #13049> Runtime error: Program failed to complete
Much easier to debug than with a snippet
Can you post the full error log?
I receive "exceeded maximum number of instructions allowed (200000)" error
When I reduce amount of sent accounts everything works fine
Too much in what way? What goes wrong?
I need to send around ~12 accounts to my program with remaning_accounts, but I've found that its too much - how can I do this in other way?
Not really honestly. Just spam deploy for hours until it goes through <:bagsFeels:449275062625894400>
Have to run solana close --buffers a lot though
Anyone else run into this regression when initializing an associated token account ? https://github.com/solana-labs/solana-program-library/issues/2791
i‚Äôve been having this issue on devnet starting from around the 23rd, did you ever figure out a way round it? i‚Äôm wondering if i‚Äôll need to use a durable nonce account to presign all deployment txs before trying to deploy or something


///////////////////////////////////////////////////////////////////////////////////////////////

got it, thanks a lot
I think in general for doing multiplications (which seem fine to me, dimensionally-speaking) you would want to give yourself some extra space by treating your amounts (all u64s) as u128s‚Äîthat way you can multiply them together etc. and not lose precision.
perhaps the addition example was a dumb one haha. I sorta imagined a conversion happening there, so i would for example convert the 10 cents to euros and then add them together to get the total in euros. The main issue I'm concerned with here is avoiding numerical errors
good question actually üòÖ
The physics major in me doesn't understand the dimensional analysis happening there.
Possibly dumb question, but what does it mean to add numbers of different tokens? Like, what does it mean to add 1 euro to 10 cents?
For example when adding two numbers one with 9 and another with 5 decimals, is it wise to bring the 5 decimal number to base 9, i.e by dividing by 10^4 and then simply adding and converting back? Or will this cause problems due to floating point/ numerical issues?
What is the best approach when doing arithmetic on tokens with different decimal points?  For example calculating conversion rates between two tokens or more complex (i.e pegging) calculations. Is it a good idea to convert all the numbers to the same basis and then back again or can you lose precision like that?
update: this seemingly has more to do with the fact that i'm starting `anchor localnet` via a python subprocess. (dunno if this is the direct cause, but certainly relevant.)
when initializing an ATA for the *second* time:

```
#[account(
        init_if_needed,
        payer = payer,
        associated_token::mint = foo_coin_mint,
        associated_token::authority = maker
    )]
    pub maker_foo_coin_assoc_token_acct: Account<'info, TokenAccount>,
```

i'm getting this error:

```
solana.rpc.core.RPCException: {'code': -32002, 'message': 'Transaction simulation failed: This transaction has already been processed', 'data': {'accounts': None, 'err': 'AlreadyProcessed', 'logs': []}}
```

any idea why? since i have `init_if_needed`?
Does anyone here know how the new escrowless auctions work? Is it a matter of transfering authority and then freezing so the NFT can stay in the user's wallet but still be transferred when sold?
I've a related question around program ids.

We see `Error: 3007: The given account is owned by a different program than expected` show up in Discord quite a bit, which can be caused by `my_program/lib.rs` containing a `declare_id(<some address>)` statement where `some address`  doesn't match the address of the account that the program is deployed to. 

My question is how are you meant to deal `declare_id` if your program is deployed to different addresses in different clusters.

e.g., in Anchor.toml we might have something like
```
[programs.localnet]
my_program = "aaaaaaaaaaa"

[programs.devnet]
my_program = "bbbbbbbbbbb"

[programs.mainnet]
my_program = "ccccccccccc"
```
How should we best deal with deploying and calling the program in different clusters when there's a program id hardcoded in the `declare_id` statement in `my_program/lib.rs`?
I guess the address is where the program is deployed to, whereas when it's built, before it's deployed, we don't really know what address it will be at. 

Though there are addresses in Anchor.toml, so, not sure.
thanks!

do we know what this reason is? was this done on purpose?
or anchor test. for some reason, building generates an idl without metadata and test/deploy will bring it back in
anchor deploy will add it
what's the word on `anchor build` generating an IDL with/without the `metadata.address` section?

if this is not standard, why is it not standard?

if i want this section in my `idl.json`, how do i put it there?

thanks!
hello!
let's say I have a puppet program and a puppet_master program.

puppet -> vanilla solana program
puppet-master -> anchor program

if I want to use "anchor test" to test  puppet-master, is it possible?

I think it is not possible, because puppet_master is calling puppet contract inside of instruction. (CPI)
ok time to get hackin. Y'all both getting noses if you want them xD
OOOOOOOOOH
There is  a bit of CPI stuff but that's just for transferring and burning of SPL tokens. As <@!848333406849073202> said, you can probably do this exchange in just one instruction. The only other instruction you would need is for initializing the vault that the new NFT's will come from. Once you've initialized that vault, just send them there from your wallet. When someone wants to exchange, just make sure they have 3 NFT's and then burn them. After burning them send them the new one from the vault. ezpz
i'll keep the convo here üôÇ thanks
HEY i love that
but i'll make my attempts first yup
sure. might be better to keep in here so people get to observe design decisions around the use case but idm
can i slide into your DMs and maybe pay you in one (or multiples) of my NFTs? HEHE. i promise to pay it forward. my project is all about sharing everything i learn with the ecosystem üòÑ üòÑ
i'm getting super mindblown here
you can do them all in one program, possibly just one instruction too
<a:noted:807130457326092289>
just so i dont get lost, are you saying i can do them all in one program? or do i have to write multiple and do CPI stuff? sorry super new here maybe i shouldve used <#889702325231427584>
ok i'll take a look at the examples and dig around and learn a bit more üôÇ thanks for pointers
yup just burning is what i'm thinking
Yea, pretty simple. Unless you're trying to make specific NFT's as a combination of those 3 - then you would need metadata and stuff. If you're just saying hey burn 3 of these NFT's and you get this new NFT then that's pretty simple.
I also use token burning in this example:
https://github.com/Kriptikz/anchor-xtoken-staking
you'd typically need the tokens in an account to transfer them out. instead, you could mint SPL tokens using the mint CPI if the token authority is a program-owned PDA
thanks for this, do you think what i described is doable?
This is a basic spl token vault, should be helpful:
https://github.com/Kriptikz/anchor-token-vault
where the program can send it to the user who is depositing/burning 3 of their NFTs from the specified collection
that's be very useful yup, but i think the tricky (?) part is that the SPL tokens have to be sitting around in an account somewhere
so are you just looking for an example of sending SPL tokens?
the minting part is easy, just need CMv2
the goal is to "merge" or "breed" their existing NFTs from one collection, and mint a different collection with the token they get
1) transfer 3 selected NFTs from user wallet
2) transfer back an SPL token to the user from an account holding the SPL tokens
what are you trying to do?
not sure if anybody has reference
damn, how do yall find repos, i'm trying to do something super trivial
thanks bro ü§ù will look into it
https://github.com/Kriptikz/anchor-pda-transfer-sol
we can get back with a solution after figuring it out
sure. might be better to keep in here so people get to observe design decisions around the use case but idm
interesting take. can we get to DM's? the actual usecase is simpler in the end if explained, because i dont need all the tracking part which might make this more complicated
off the top of my head, theres a few ways to approach this: 
1. you can isolate each users deposits using a user specific, program owned PDA
2. you can commingle users funds with a single shared vault pool, again program owned PDA

i.e when you initialise your program, you could store the vault pool address in a state account. you can then use this stored account for any user's tokens. you will need to keep track of how much a user has deposited, in this case you will also need to create an account to store this data for each user

flow would be roughly something like:
1. init program, pass in vault address as a program owned PDA sol account, store vault address in state, create `GlobalStakingData` in state and set staked to 0 (i.e. `GlobalStakingData.totalStaked = 0`)
2. create user `StakingData` account with 0'd data
3. when user deposits, use transfer CPI to move tokens from user to vault and update user's `StakingData` data to track how many tokens they deposited (i.e. `StakingData.staked += deposit amount` and `GlobalStakingData.totalStaked += deposit amount`)
4. when user withdraws, use the transfer CPI to move tokens from the vault to the user and update user's `StakingData` data to track how many tokens they withdraw (i.e. `StakingData.staked -= withdraw amount` and `GlobalStakingData.totalStaked -= withdraw amount`)
okay but how do i use the same account for each user? from my understanding you mean creating a new account for each user to store the tokens in the program independently

also, i need this for SOL and not for an spl token. i've specified spl-token in the question above but since then looks like it's gonna be easier for now to start with a SOL transfer, at least for practice. modified the question also above ^
create a PDA authority account, set it as your vault pool and use the transfer CPI to transfer tokens from the invoker to the pool
https://project-serum.github.io/anchor/getting-started/projects.html
you can use the transfer CPI
yes

have you found a solution for this?
what are some existing platforms on mainnet who are using anchor
https://github.com/gemworks/core/blob/a7e253f1ee7d31ffcfd03ffc16fa3e65a53a75a0/programs/gem_farm/src/instructions/record_multiple_rarities.rs#L67
fist 8 bytes of that
its hash("account:StructName")
Where can I find the code for generating the discriminator?
hi there, been searching for a bit but not much success. is there a template or something to transfer SOL from an user to a kind of vault in the program?

seems something very trivial and don't wanna re-invent the wheel üòÑ appreciate in advance!
Hey there, i'm looking for a way to build the @project-serum/anchor ts package locally such that I can include in index.html as a <script/>. 

Why ? I'm motivated to use [elm](https://github.com/bigtimetapin/somos-solana/tree/develop/elm/src/Sub) to communicate with @solana/web3.js , phantom, and anchor. I'll do anything not to use react Lol.

Any advice? I've been looking for webpack configs but not having luck & not sure if that's the right path anyways . . 

CDN distribution is the dream but I understand that's not our reality right now https://github.com/bigtimetapin/somos-solana/blob/develop/assets/index.html#L8-L9
Paulx, sorry for the late response. This is amazing, words can not describe how much this helps. Thank you and I feel honored. I started with your blog post üòÑ
am i missing something ?
hey guys can i get help ? 
how to convert the native number to the actual token amount for wrapped token ? ! 
for example 9996453 (for soLink) when i i devide by 10**6  it doesn't give me the correct amount
the client just needs to be updated there's good no reason for this
I can make a "how to add your contract interface in Swift to use from iOS" once that is done... not sure if a binding within the anchor project would be appropriate though - since you're gonna have to write your own client-functions anyway, specific to your contract.
I'm _slowly_ learning how cargo and cargo dependencies work. Felt really daunting at first.
<@!501570363566587905> thanks for the tags on that GH issue... I'm actually not sure of the implications when `solana-client` version needs to be updated - it's actually on quite an old version atm. Not sure if that's for a reason or just hasn't been updated for a while.
thx
https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html


///////////////////////////////////////////////////////////////////////////////////////////////

it was `declare_id!`. This is like the third time i've come in here for this same bug üòµ
Or, another possibility is that your `declare_id!` doesn't match the actual runtime program id‚Äîthen any `Account<'info, OneOfYourAccounts>` will fail with that error
E.g. maybe you're passing in an uninitialized account when you meant to have a real TokenAccount
Mm, basically just have to think carefully lol‚Äîit could be any `Account<'info, Whatever>`
Thank you! Helpful!
anyone know tips on how to debug this? is there a way to tell which account is causing the issue?
`The given account is not owned by the executing program`
I will add this to the constraint docs
anchor's creates accounts via a CPI but you can only create accounts with 10 kibibyte space max via CPI. You can work around this by creating the account in a previous instruction with a direct call to the system program and then use `#[account(zero)]`
Anyone? üôÇ
They're zeroed
I'm gonna guess #[derive(Default)] makes it so it is defined
dunno if i missed it in the docs
Hey when we use [init] or [init_if_needed] constraints are the bytes default initialized to anything or are they in an undefined state?
I am also facing this problem, can you give me the documentation or demo source create the account on the blockchain?
thanks!
`solana-keygen grind`
This leads to an odd situation where if you transfer a tiny tiny amount of sol to a fresh/uninitialized account, the rent collector will just take that sol lol ü•≤
Even empty accounts require a little bit of rent!
Getting the same issue here, if I use the Provider.env() method and feed in ANCHOR_WALLET and ANCHOR_PROVIDER_URL in the command line, it returns "Cannot read properties of undefined (reading 'env')". Would I have to run a script like this from within my anchor programs folder? Or should I be able to run a vanilla JS script like this from anywhere
Hey! I have a strange error when MAX_SPACE_DATA is more than roughly 10K Bytes:
```#[derive(Accounts)]
pub struct SaveData<'info> {
    #[account(init, payer = sender, space = MAX_SPACE_DATA)]
    pub data: Account<'info, Data>,```
```Account data size realloc limited to 10240 in inner instructions
Program consumed 7916 of 200000 compute units
Program failed: Failed to reallocate account data```
What should I do?
Hi Guys... I am trying to create a Solana account in which I want to use a struct inside a struct. For example, there is an employee struct with name & age details and now I want to use an array of employees in #[account] of the company that will have other fields also.  I am facing a few problems like the default is not implemented. Any idea how I can do it.
anybody knows how to create a custom program name and validate it?
like if want my program name to start with `myName......`
hi, how to add new optional field to anchor instruction without breaking the clients
which instruction are you trying to construct?
If I need to use the solana sdk to send a single txn I need to pass in 3 fields. How do I go about constructing the data? I know what arguments it needs to take and the instruction name, but not sure how it all gets serialized into this data argument
getParsedAccountInfo?
Is there a method to deserialize token account data on the front end?
Has anyone sent a TransactionInstruction object from an express server to a frontend? it seems as soon as it gets parsed as json the publicKeys in instruction.keys becomes undefined
Thanks a lot
It‚Äôs now working I was not deployed the right way
Does anyone have a serum-dex-ui in Anchor that works?
Is the game address you're passing in from a keypair or a PDA?
why do you have this line:
```Rust
#[account(address = system_program::ID)]
```
You can delete it, anchor verifies it's the System Program already when you use Program<'info, System> 
```Rust
system_program: Program<'info, System>,
```
keypair.generate() doesn't create a new account. It creates an public key and a private key. Nothing exists at that public key yet. When you send some sol it creates a System Account at that public key, which then has some account metadata ( address, owner, lamports, etc). The smallest an account can be for rent calculations is 128 bytes because they will always have that metadata. 
Use the cli command
```
solana rent 0
```
to see how much rent it is for a basic System Account. Currently it's 890880 Lamports.
If you send any amount less than this to an account, it will instantly deduct rent, and continue deducting rent every epoch. If the account doesn't have enough rent it will be purged.
A basic System Account takes 2439 Lamports currently for rent every epoch.
Have you ever been through this error ?
but I receive an error like this Error: 2012: An address constraint was violated
I try to call my rpc route which as this struct 


pub struct PlayAParty<'info> {
    #[account(init, payer = author, space = Game::LEN)]
    pub game: Account<'info, Game>,
    #[account(mut)]
    pub jar: Signer<'info>,
    #[account(mut)]
    pub author: Signer<'info>,
    #[account(address = system_program::ID)]
    pub system_program: Program<'info, System>,
}
thanks <@!221877670290522112> ! I encounter a problem maybe there is a link !
the seed is kind of a key from which you derive a new address from an existing one - for example deriving a new key using "second_derived_account" key

the bump is just another seed resulted when you compute the PDA - `anchor.web3.PublicKey.findProgramAddress()`
Hi what is a seed and a bump please ? thaks üôÇ
so the solution to our problem:

transfer SOL from an user to a PDA account and back to the user all inside the program (without first transferring SOL from frontend as many examples did)

you got your `house_pda` in your struct (which is provided from frontend using the same seed as you did on your program together with the bump)
inside the program, you check it's the same pda created from your program
`
    #[account(mut)]
    pub author: Signer<'info>,

    #[account(
    mut,
    seeds = [HOUSE_PDA_SEED],
    bump = house_pda_bump
    )]
    pub house_pda: SystemAccount<'info>
`

and from here on, you simply do a system_instruction::transfer with signer seeds from HOUSE_PDA_SEED and it's specific bump

it works back and forth - from `author` to `PDA` and from `PDA` to `author`
hope i'm not missing anything üòÑ
so if I wanted to store information about a user. Like when he last added a stake to this smart contract. Would it make sense to store that info as a PDA that the contract owns? Or like a token account where it's attached to a user's account but only the smart contract can change it?
Hey, I'm got a verifiable build that I'm trying to deploy to devnet and I'm trying to upgrade the IDL. But `anchor set-buffer` seems to be consistently failing with `Error: Error processing Instruction 0: custom program error: 0xbbf` . I tried pretty much every thing I could think of and can't seem to figure out what I'm doing wrong. Here's the related transaction if it helps : https://explorer.solana.com/tx/57xNy2oXJBPxCsu1m2EuE2HDCWFQruoaA2iowLdFfwXmSoRtfcJcmbsLR4chrK733oUsszuN3RyKrjGmLDuVNxFR?cluster=devnet
`Error: Simulate error: AlreadyProcessed`
Submitting the same tx for simulation back to back in a test on devnet and getting this error

Where can i learn about the limits that seem to be here?
get the same if I use this too: ` anchor migrate --provider.cluster devnet`
Am getting this on a vanilla project: ```‚ùØ anchor migrate 
Running migration deploy script

/home/utx0/Code/hydra/hydra-protocol/node_modules/ts-node/src/index.ts:261
    return new TSError(diagnosticText, diagnosticCodes)
           ^
TSError: ‚®Ø Unable to compile TypeScript:
deploy.ts(10,34): error TS2576: Property 'local' does not exist on type 'NodeWallet'. Did you mean to access the static member 'NodeWallet.local' instead?

    at createTSError (/home/utx0/Code/hydra/hydra-protocol/node_modules/ts-node/src/index.ts:261:12)
    at getOutput (/home/utx0/Code/hydra/hydra-protocol/node_modules/ts-node/src/index.ts:367:40)
    at Object.compile (/home/utx0/Code/hydra/hydra-protocol/node_modules/ts-node/src/index.ts:558:11)
    at Module.m._compile (/home/utx0/Code/hydra/hydra-protocol/node_modules/ts-node/src/index.ts:439:43)
    at Module._extensions..js (node:internal/modules/cjs/loader:1149:10)
    at Object.require.extensions.<computed> [as .ts] (/home/utx0/Code/hydra/hydra-protocol/node_modules/ts-node/src/index.ts:442:12)
    at Module.load (node:internal/modules/cjs/loader:975:32)
    at Function.Module._load (node:internal/modules/cjs/loader:822:12)
    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)
    at Object.<anonymous> (/home/utx0/Code/hydra/hydra-protocol/node_modules/ts-node/src/bin.ts:157:12)
Deploy failed.
```
Hey guys, is `anchor migrate` broken in the latest version of anchor 0.20.1?
It seems this is just what happens when u transfer amounts smaller than 1000000 lamports. The amount dedudted is negligible (46 lamports), so I guess its not really a problem
Like, if u create a new account with keypair.generate() then send sol to that account it doesn't make a new account to store that sol
The sol balance is built directly into every account. Even token accounts for other mints still have a sol balance. I'm pretty sure theres no need to create any other accounts
I mean, that record has to be stored on the chain somewhere.  So an account has to be created then right?
Sol doesn't require a token account. The balance is stored directly at the address
Yea, I'm 99% sure that's the case: https://spl.solana.com/token#example-transferring-tokens-to-another-user-with-sender-funding
I appreciate the help anyway
Yeah, I'm guessing that's it.  The token account has to be paid for by someone. That's why there's the 'sender pays' optoin
Something like that is prolly the case. I'll have to dig through the tx logs to see where its going
Search me... my only other guess is that there is maybe an allocation fee for the account on the first transfer.
`pub fn transfer(
    ctx: Context<TransferCtx>, 
    bump: u8, lamports: u64
) -> ProgramResult {
    let account_list = vec![
      ctx.accounts.user.to_account_info(),
      ctx.accounts.jar.to_account_info(),
    ];

    let transfer_instruction = solana_program::system_instruction::transfer(
      ctx.accounts.user.key,
      ctx.accounts.jar.key,
      lamports,
    );

    solana_program::program::invoke(
      &transfer_instruction,
      account_list.as_slice(),
    )?;

    Ok(())
  }
`
can you post the instruction body where you're doing the transfer
No, only dealing with sol/lamports. No spl tokens.
Are you using anchor_spl::token or spl::token directly? When you actually call transfer
The jar account is the relevant one
`#[derive(Accounts)]
#[instruction(bump: u8)]
pub struct TransferCtx<'info> {
  #[account(mut)]
  pub user: Signer<'info>,
  #[account(
    mut,
    seeds = [b"jar".as_ref(), user.key.as_ref()], 
    bump = bump
  )]
  pub jar: UncheckedAccount<'info>,
  pub system_program: Program<'info, System>,
}`
What's your struct look like?
I'm never calling init on the account
Well, if you're doing the transfer in your actual instruction code, Anchor has already ran it's init code, and if you marked the PDA account as init, I'm guessing Anchor has no way of knowing that you're about to transfer.  So if you're 100% sure you will be transferring enough to that PDA, you can mark it as rent_exempt?
this is to prevent double spend
Wait a minute, the balance looked at for rent exemption _is_ the sol balance for the account no? So it wouldn't make sense for rent to be deducted from the account balance. If anything it would add on to it
no, if the tx content is identical, the blockchains drops it
not quite. rust should handle the idempotency.

concretely, because of this line, nothing should break.

https://github.com/cavaunpeu/anchor-escrow-program/blob/0ad20392000a680808a08dda5cdca37e2f752590/programs/anchor-escrow-program/src/lib.rs#L212

indeed, when i run `solana-test-validator` manually, nothing breaks.

when run in a python subprocess, it (curiously) does.
If you're transfering lamports to it, I think it will need the rent exemption?
The pda did not exist before no. But it has no data, so need for rent exemption right?
Did the PDA already exist?  If not, is that amount explained by rent exemption being deposited?
Any thoughts on what is happening here?
My first thought about what was happening was that the network fee is being deducted, but thats not the case since any subsequent transfer increments the balance by the correct amount.
I'm encountering a strange issue. I wrote a program that transfers lamports from the user to a pda account. That works fine, but the first time I make the transfer and look at the post balance in the pda it is lower than expected by a constant amount.
you cannot send 2 times an identical tx
You already sent this transaction
can you close an account from any program? what stopping me from calling close() on another programs anchor accounts
https://gist.github.com/akutruff/35a0d1aebe50d0efc5d48af8c23c14c7
I think I found a bug where I get an transaction error only if I change the ordering of the fields in my struct....  Am I doing something wrong or should I file an issue?
https://discord.com/channels/889577356681945098/889702325231427584/899740156423176235
Interestingly, they don't work out of the box, because they sneakily use some global mutable state under the hood. It *is* possible to use them though, you just have to do some non-default stuff (finding the thread)
You can do
```.rs
use anchor_lang::AccountsClose;
your_account.close(who_to_send_the_lamports_to)?;
```
If I need to conditionally close an account, I cant use anchor's close constraint, so what would I use instead inside the function? Its an account I defined (not token)
Basic question, but just making sure: are Rust HashMaps safe to use inside an on-chain program? I read a dev who said they had issues...\


///////////////////////////////////////////////////////////////////////////////////////////////

Cool. I'll start looking around over the weekend after I get something working on the verified badge
can probably finish this by end of next week
exactly
yes true, otherwise you can only ever decode wrt latest which will often be wrong
so that you can always decode old transactions
and then that idl lives on chain at a PDA
i.e., all instructions and account data should have a corresponding version number that refers to an idl veresion
just so that we don't overlap
idl
versioning within the IDL? Or the solana account decoding
i think i'll prioritize this
we need to introduce versioning though to do that in a robust way
along with more instruction decoding
would be so excited to see that
yea that would be amazing
Actually what I was thinking about is if an IDL being available could let us see an account's data in a readable form right in there
woot!
there is a bunch of decoding utils for sure there
so there should already be utils for this!
which the explorer already has now that i think about it
want to see the current upgrade authority and last updated slot
probably same use case as  you
what's the use case? I'm working on some stuff for solana-explorer that might need something like that and I don't want to waste efforts
and putting it all together for a `Program<T>` client here https://github.com/project-serum/anchor/blob/master/ts/src/spl/token.ts#L11
The shame channel, my padding issues not more glorious <:peepodetective:904036528970424370>
ok let's get this fixed
that's what i'm here for
embarrassing
example implementation for the spl token here https://github.com/project-serum/anchor/blob/master/ts/src/coder/spl-token/index.ts
oof
just need to implement this interface https://github.com/project-serum/anchor/blob/master/ts/src/coder/index.ts
we do this for the spl token now
yea you can do that now
Might be possible to generate an IDL with just the types for a non anchor project? Then could use `AccountsCoder` as for Anchor accounts
`target/verifiable/mango.so` is what you want
that's your local machine build (built outside the docker image)
isn't the verified build
`target/deploy/mango.so`
there is your problem
oh no I'm doing
```
anchor build -p mango --verifiable
BUFFER="$(solana program write-buffer target/deploy/mango.so -k $KEYPAIR --buffer-authority 3fpD42WxHsZSi5yjKcNei8H6gzndRtDLGg4otQbKNW5K --output json-compact | jq .buffer -r)"
solana program set-buffer-authority $BUFFER -k $KEYPAIR --new-buffer-authority 3fpD42WxHsZSi5yjKcNei8H6gzndRtDLGg4otQbKNW5K

anchor publish mango
```
i.e.

- publish
- download mango.so
- deploy mango.so
- click verify
i'm curious, are you deploying with the build artifact from the registry?
doing that now. Just thought I'd fire off this message while I wait for that to complete
can you verify locally?
Hello Anchor fam, I'd just like to report that Anchor build registry has been saying there's a mismatch between for Mango the last two times we did a program upgrade. I'm looking into it now but just thought I'd mention here in case there is something obvious: https://anchor.projectserum.com/build/240
yay
guessing i'll need to fiddle with this myself
basically just need a bincode decoder
yup
A tool that would find layouts from the repo and fetch/map data to TS objects?
for example https://github.com/solana-labs/solana/blob/b8837c04ec3976c9c16d028fbee86f87823fb97f/sdk/program/src/bpf_loader_upgradeable.rs#L24
are there any existing utilities for decoding solana Program accounts
The one I use for MangoMarketv3 for instance
```rust
#[derive(Clone)]
pub struct Mango;

pub mod anchor_mango {
    #[cfg(feature = "development")]
    solana_program::declare_id!("4skJ85cdxQAFVKbcGgfun8iZPL7BadVYXG3kGEGkufqA");
    #[cfg(feature = "production")]
    solana_program::declare_id!("mv3ekLzLbnVPNxjSKvqBpU3ZeZXPQdEC3bp5MDEBG68");
}

impl anchor_lang::AccountDeserialize for Mango {
    fn try_deserialize(buf: &mut &[u8]) -> Result<Self, ProgramError> {
        Mango::try_deserialize_unchecked(buf)
    }

    fn try_deserialize_unchecked(_buf: &mut &[u8]) -> Result<Self, ProgramError> {
        Ok(Mango)
    }
}

impl anchor_lang::Id for Mango {
    fn id() -> Pubkey {
        anchor_mango::ID
    }
}

/// Checks that the supplied program ID is the correct one, better use that before doing CPI also, as you don't get the anchor auto protection
pub fn check_program_account(mango_program_id: &Pubkey) -> ProgramResult {
    check_eq!(mango_program_id, &anchor_mango::ID, ErrorCode::MangoMarketProgramId)?;
    Ok(())
}
```
Yes!
Yes üòÅ  That's the only way I got it to work so far, so I manually cleanup the generated IDL each time I move it to my Client that act as the source of truth. I can script it too, but might have some alternatives
`impl Id` might be needed for non-anchor programs?
Nope, turns out i just had to get them on the same anchor version and its fixed
ah or does that lead to borsh issues which is why youve done it that way?
I dont have time to look at it now but you can also just use the array directly instead of defining a struct for it
right, I cant read mb
Not really padding, more like reserved space
For later additions to the content of the struct
You can see an example of how this works by jumping to source on `Token` in `Program<'info, Token>`.
It needs to implement an actual anchor trait, Id.
Where does the Sbaddin type come from?
made sure `declare_id!(...)` is correct, it's still happening
Using
`Program<'info, Sbaddin>`
and getting `the trait Id is not implemented for Sbaddin`
<@!443079510053748743> why do u need padding for a non-zero-copy struct?
Was this one specifically üòÅ
Code for reference 
```rust
#[account]
#[derive(Default)]
pub struct MyStruct {
  ...
    pub _reserved: StructPadding, // this complication was a way around padding in anchor offered by Alan iirc
  ...
}


// The padding struct, it's being exported in the IDL as a type, cause it's defined above as the type of "_reserved", although this one is not exported so it create errors.
#[derive(Clone)]
pub struct StructPadding([u8; 255]);

impl AnchorSerialize for StructPadding {
    fn serialize<W: std::io::Write>(&self, writer: &mut W) -> std::io::Result<()> {
        writer.write_all(&self.0)
    }
}

impl AnchorDeserialize for StructPadding {
    fn deserialize(_: &mut &[u8]) -> Result<Self, std::io::Error> {
        Ok(Self([0u8; 255]))
    }
}

impl Default for StructPadding {
    fn default() -> Self {
        StructPadding { 0: [0u8; 255] }
    }
}
```
Or to type it back to something more primitive
I have a struct that I used as Padding (deriving AnchorSer/de, and clone), and it's being added to the IDL type definition cause it's added to some struct with the #[account] derive, although that type is not itself exported in the IDL.

Any way to have a property of an #[account] not being exported or ignored in the IDL?
Ok. Mystery is solved: one need to bump anchor-cli version to v0.20.1
Yeah, in v0.20.1 something is broken with error codes
+1 
Is it possible to have Option<> param?
Hello!
```
myerr = 0x358
...
return Err(myerr.into());
```
When I execute the program: custom program error 0x484
Somehow anchor v0.18.0 changed error code. How to fix it?
What do you mean "Between different accounts"
is anyone aware of solana name service? what does that do exactly ?  in docs it is mentioned that helps to manage ownership of pubkeys,domain names etc
hi all, is there any way to get around the whole 'you have to anchor deploy to get the program ID, and then put it back into your program and then do a build and deploy again' issue? Between different accounts, I can't get a program successfully getting used, because the generated program ID is always changing, and I'm forced to update the declare_id, and then re-build.& deploy
I don't think Solana programs like floats very much tho
Repeated division?
Hello, I am running the anchor upgrade command, but I am running into the error: Error: ELF error: ELF error: Failed to parse ELF file: bad magic: 0x3131312c3936315b
Any pointers to implementing logarithms in a program?
Heh, funny, hadn't thought to try that üòõ
rough, but definitely works. Thank you
i havent personally tested this but i found it in the drift code iirc
how can i suppress this logging for a given test?
however, even though I catch the error to pass the test, i am getting console logs that show a transaction simulation failure
i have unit tests where i intentionally "attack" my program and i want the program to fail
speaking of testing, i have a question on how to suppress transaction simulation failure logs during testing
this is why we test
yes indeed
Honestly I would try to get your seed choices looking good ahead of time lol, migrating accounts will be somewhat painful üòõ
Yeah, if you want to get rid of that account you'd have to close it once you're done with it/have copied it over to the new address
that address would still be marked as 'vault' or w.e. account structure its been given
ah that makes sense
You can't really "change" the seeds for an existing account (it lives at a certain address determined by those seeds‚Äîyou would need to basically copy the account over to the new address)
Or the old ones are no longer fetchable using the fetch js fn
Makes sense. How does changing the PDA seeds of an account affect things? I did that on devnet and it seems to lose all the old ones
or you dont migrate the accounts at all and just view them as separate entities that are handled differently
changing a program does only that. All accounts are left unchanged. If you edit an account structure in the program, you have to add custom migration logic to your program so it can handle both the old and the new types of accounts
How does updating a contract affect accounts owned by the program? For example:

- You change how a PDA is derived
- You modify what is stored in an account

Any blogs or docs on understanding this better?
Oof, that'd be a very unfortunate situation. Thx for the info
Ahh, good to know. Thx the a lot for the info. That'd be a nasty problem to have to have down the line


///////////////////////////////////////////////////////////////////////////////////////////////

Now that there's something, what's the process for migration?
Added it as the last property
`#[account]
pub struct Profile {
    pub pfp_token_account: Pubkey,
    pub pfp_url: String,
    pub first_name: String,
    pub owner: Pubkey,
    pub bump: u8,
    pub expired: bool
}`
That's weird that there's a 34 there of course.
How did you change the struct definition when you added the bool? Before/after?
`Transaction simulation failed: Error processing Instruction 0: custom program error: 0xbbb
    Program 3K8NudgEtky3S31T7g5cYmmXB2JTKN9NVqyS44P1VdYd invoke [1]
    Program log: Instruction: Create
    Program log: Custom program error: 0xbbb
    Program 3K8NudgEtky3S31T7g5cYmmXB2JTKN9NVqyS44P1VdYd consumed 5662 of 200000 compute units
    Program 3K8NudgEtky3S31T7g5cYmmXB2JTKN9NVqyS44P1VdYd failed: custom program error: 0xbbb
    1) Is initialized!


  0 passing (455ms)
  1 failing

  1) profile
       Is initialized!:
     Error: 3003: Failed to deserialize the account
      at Function.parse (node_modules/@project-serum/anchor/dist/cjs/error.js:40:20)
      at Object.rpc [as create] (node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:38:61)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at async Context.<anonymous> (tests/profile.js:32:14)`
 This is the error for the update or create (with init_if_needed). 
 If I try to fetch it says:

 `    Error: Invalid bool: 34
      at WrappedLayout.decodeBool [as decoder] (node_modules/@project-serum/borsh/dist/lib/index.js:124:11)
      at WrappedLayout.decode (node_modules/@project-serum/borsh/dist/lib/index.js:62:21)
      at Structure.decode (node_modules/buffer-layout/lib/Layout.jsüî¢32)
      at AccountsCoder.decode (node_modules/@project-serum/anchor/dist/cjs/coder/accounts.js:47:23)
      at AccountClient.fetchNullable (node_modules/@project-serum/anchor/dist/cjs/program/namespace/account.js:97:37)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at async AccountClient.fetch (node_modules/@project-serum/anchor/dist/cjs/program/namespace/account.js:105:22)
      at async Context.<anonymous> (tests/profile.js:42:19)`
Can you show the full error log? Not just a snippet
So maybe you do have enough space
Ah, no, no preallocation happens
The account has a couple of short Strings and two pubKeys, and 5000 bytes allocated space. Could it be that it preallocates to Strings, because they're unknown?
Does that mean you confirmed it has enough space? Yeah, that sounds like you don't have enough
I was hoping for that but it failed to deserialize. (just retried now to confirm:  Error: 3003: Failed to deserialize the account)
If the accounts all have enough space (you would have had to have allocated some extra when you first created them) then you can just add a new field to the end of the rust struct; it'll get interpreted as `false` (because the extra bytes are all zero).
Hi, How do we migrate accounts when we want to change the structure of data? For example I want to add a boolean to an account struct and the accounts have enough space to allow that.
anybody that can help me with that?

**TLDR:** Phantom shows the output of the tx which depends on a pseudo random (either win/lose -> get/lose SOL in tx)
anybody know of client code to quickly filter NFTs belonging to particular collection in a user's wallet?
I need some help to use the anchor library in my browser. Ive been unsuccessful bundling the npm package with browserify and multiple other bundling tools. Any help is appreciateds
So you could not link a repo, have a provably audited code deployed, and still give people some guarantee I guess.
Point is: it‚Äôs flexible
Also auditing has to be tied to an identifier for the build artifact/code. You‚Äôre just thinking of Commit hash but a company could still be asked to audit a code and publish that they did along with the verified build hash
Well any side info in a complex code base is obviously good. The point here is that a GitHub URL could be added as an optional  data to the verified build. And if it is not added and integrators/users require it, then it‚Äôs their choice to still use it or not.
Fully open projects can link everything, and the others can not do so, and have their verified build appear moot to most.
not really, if nobody can know what changed in an obvious way what is the point in even making it public and add "verified" to it.
For instance serum DEX has a new verifiable build, who is going to inspect the whole blob, how do we actually know it is what it says it is? vs building it in a way i can verify they did in fact build commit X which is a delta from commit Y, Y has been audited/already inspected by me/you/someone/a group of auditors
All that matters is that what‚Äôs published and explorable matches what is on chain
The time or person who verified is irrelevant
Is there a huge difference though. If you make the code explorable on the verified build app, you have something agnostic to your code tracking. You might not even track progress publicly, and still publish the code snapshot at verification time.
Looking forward to see their anchor fork
https://github.com/DeployDAO/verified-programs-builder/blob/master/.github/workflows/verify-CrateProtocol__crate-v0.4.0.yml#L40 this is building with anchor build --verifiable
It is actually interesting because you get a public repo then a commit to verifiable build mapping.
Rather than a wild blob of files, built at X by a random guy
For the anchor verified build I‚Äôm guessing that the idea is to just follow the link to the verified build UI? Is there not a reference to the commit or something like that there?
I think etherscan‚Äôs code blob feature is more geared towards people who want to have look right then and there, not for verification purposes
actually don't create NFTs because they are NFts
Or is the expectation that i should reread it all everytime
Also i don't know how people feel in general with etherscan but having the blob of code, does it actually link back to a github commit somehow? Like how do people compare it against the last audit/review/time they looked at it
don't create NFTs because it uses metaplex
but ok
that's like saying don't create nfts because it uses metaplex
but you need an Anchor.toml
all it does is build inside a docker image
yes
Isn‚Äôt the verification also available for non-anchor programs?
It is time to give up
Also i am not sure we need to improve open source tooling Saber is rewriting them all and closed source so what is the point to advance what we have right now?
Seems quite off
The problem of this verified badge is that it is embedded into anchor so why should a general explorer page "enforce" usage of one framework/tool to verify?
question - if my contract method depends on random, the preview on Phantom will show negative/positive SOL balance changes i think depending on what that method will do in that specific moment. But its not exact - it shows like the SOL preview updates each 5-10 seconds or so. So, sometimes the output is the opposite of what balance change is showing

Why is that? Or how can i prevent this from happening?
Maybe as a first PR I should just make the whole page background blood red, with maybe a skull, if unverified
haha it will become a lot more common once this is in the explorer
tsk tsk tsk
candy machine not verified
Not knowledgeable about trees much, but I'll check the bundle size
sweet i'll probably cut a new anchor release early next week
Cool cool cool. Definitely gonna be in a PR this weekend.
tree shaking should hopefully make it small?
or just add the dep
ok yes slot matching
yea you can totally just copy and paste that code
ok I need to read a  bit come on
oh no it uses it
Alright yes I'll probably just use that. The dependency is probably already there. Worst case I'll copy it for clarity, since you have a bit of doc in it. The authority decoding bit in that PR is unrelated right?
otherwise returns null
returning the verified build only if it matches the on chain slot number
just an async function
it's not a hook
it does the process I described way above
You're making it, I'd rather go for it. You're talking hook or something right? Cause design-wise I'll re-use some badge already in the explorer
Here's the utility https://github.com/project-serum/anchor/pull/1371/files#diff-de331e82234ec0fa09063a78de0bb2985fccd7ab84c5fa1652453ea8aebd2547R11
oh ok, I'll just leave it at that for now then, cause next is to make it code-pretty anyway
feel free to use it or not
i've got a utility api for you soon
ready to merge
looking excellent ser
that's design ser
üî•
amateur
This will show up *only* if the verified build matches the upgrade slot from the program currently on chain
https://anchor.projectserum.com/program/mv3ekLzLbnVPNxjSKvqBpU3ZeZXPQdEC3bp5MDEBG68
Allright we've now got a *real* verified badge
might need to bring back sollet tbh
and then wallets at some point ü§∑
creating a utility client api right now for web clients
hopefully we'lll be integrated into explorers soon
np thanks a lot. Also kind of sad we had a mismatched build out for a week and nobody cared
looks pretty buggy
there's a transparent cache layer on the rpc nodes
yea sorry about that
must be nice to be admin
i just reran the verifier
no need
already did
alright will publish again
verified success
got it
yup
let me try to change the RPC node
that's the only explanation
i wonder if the RPC node is giving stale data
```
anchor-program
Extracting the IDL
Build success
mv3ekLzLbnVPNxjSKvqBpU3ZeZXPQdEC3bp5MDEBG68 is verified.
```
i'll try again
not looking good for me then
hmmm
but when I run verify on my machine it succeeds
but that's my guess
i'm running verify
we'll see
Did I deploy the wrong thing again?
not looking good for you daffy
ok i got the same `d4d61c68e5d99f64619388b6a15a47f9ba3847a6fc0acb35920cfaf0d0fd9e3f` hash
i will then run anchor verify after confirming the hash matches
ok i downloaded from the registry and am running `anchor build -p mango --verifiable`
will run on my machine
`anchor-cli 0.20.1`
hmm
that is what is on the registry
all the server does is run that command
d4d61c68e5d99f64619388b6a15a47f9ba3847a6fc0acb35920cfaf0d0fd9e3f
what's the checksum on your local machine?
https://anchor.projectserum.com/build/242 says mismatch. But `anchor verify -p mango mv3ekLzLbnVPNxjSKvqBpU3ZeZXPQdEC3bp5MDEBG68` says verified
I usually don't deploy by downloading from registry. I usually haven't had to. Do you think there could be a difference between how registry is building it and how I'm building it using anchor on my machine?
not ofifically but you can compile one with rolllup or some other bundler
Is there a browser bundle for the anchor web3 js?
interesting that bincode uses a u32 to encode the rust enum discriminant
thanks, still helps
ha, ok
I mean I'm not into semantics, maybe you are right and then it is technically an escrow haha
yeah possible as well
in case the coniditoin isn't met, we want to fully refund the donors (less txn fees)
for instance if the beneficiary has not withdrawn funds
Yes that would be critical
it can be made more complex as well by maintaining the depositor state (~ who deposited what/how much), if you want the ability to return funds to depositors after some deadline has passed
Ok
"only Joe can withdraw **and** only after Feb 1 **and** only if there is at least 1000"
Yes so definitely possible with a simple vault contract. Think of all these potential time/amount checks as additional conditions to the withdrawer check
Would the vault model still work in that case?
Yes, it would be either a date, an amount, or even an external oracle
In a multi-depositor escrow case, the event you mention would be that all depositors have deposited I'm guessing (which would be awkward in a kickstarter use case). What event would be required here? It could be a rather simple contract allowing withdrawal only if the amount has reached a certain threshold, or only after a certain date, or a mix
Thanks, but then would the beneficiary have access no matter what? We'd want it restricted until some external event occurs.
Would that require an escrow? For a kickstarter kind of thing you would simply need a vault only the beneficiary has authority over, and anyone can transfer to.
on your latest build
i see your sha256 checksum is the same
<@!748249199606497502> did you screw up again lol
Does anybody have an example of multi-party escrow? Basically like a kickstarter app where multiple givers put into escrow that is triggered to transfer value to a single receiver.


///////////////////////////////////////////////////////////////////////////////////////////////

How much space are you planning on using? It's actually true that for a really big account you kind of can't use a vec (solana's heap is only 32kb, plus it uses a bump allocator so it never actually actually reclaims heap memory that you might have expected to get freed, etc.)
Ah, no, you still have to specify the space to take up‚Äîjust in the separate instruction that creates the account
but yea so the question essentially boils down to: It _seems_ initializing a large account in this unique way comes with an additional requirement that the size of all data must be known at compile time, which means a Vec cannot be used (but an array could). Does that sound correct?
referencing https://github.com/project-serum/anchor/blob/3958533750c83c3e90709448c4f30ed9cce0b9b8/tests/tictactoe/tests/tictactoe.js#L34 btw
I'm getting the same thing now. How did you fix it?
So it seems that when accounts are initialized with  `#[account(zero)]` and in it's own instruction a la ```      instructions: [
        await program.account.huntState.createInstruction(stateAccount),
      ],```
You never actually specify the exact space the account should take up. Seems like it instead uses a generated instruction to create the account, presumably using the idl data to calculate _for you_ the amount of space the account needs.

If I have that part right, that seems problematic if your account is storing a `Vec`, since the idl has no idea how much space the Vec will require now - and I think I'm running into a problem because of that. 
I just played around with converting my Vec to an array to see if I could resolve that way, and then went a ways down a rabbit hole of trying to implement custom `AnchorSerialize/AnchorDeserialize` for my array (`[CustomStruct, 5000]`) before stopping because it was getting too hairy (implementing deserialize for a custom struct is over my head right now).

Does that vec stuff sound right? I'd prefer to keep the implementation as a vec which I choose the capacity of, but if I have to go down this serialization rabbit hole, I guess I will
Interesting‚ÄîI actually discovered it yesterday since this video popped up on my twitter feed üòÜ https://www.youtube.com/watch?v=1HBappnahHw
fun trivia about this track, it was recorded on custom build synths and the "shakers" are actually scissor sounds
üôÇ Actually discovered it yesterday
Also <@!134416332509675520> good jam!
ty
I moved the init for that object into another fn and it worked
I always forget about that lol
you can also call `drop` to get rid of the `Ref` which is more conspicuous than wrapping in `{ ... }`
no worries, thank you
But yeah, you basically just need to listen to the borrow checker üßò‚Äç‚ôÇÔ∏è
Yeah, sorry, not sure I'll give very accurate advice without being able to run/see the error myself
I mean its a correct syntax, will try a couple of things.
I'd have to see your actual code, kind of hard to debug in my head like this
Oh, sorry, maybe that would work actually
will try that ty
aha ok
or do you mean I cannot reuse `mango_account` for both uses?
Mm, probably not‚Äîalready all usages of it
as in
```
let mango_account = {
  MangoAccount::load_checked(
        &ctx.accounts.mango_account_ai,
        ctx.accounts.mango_program.key,
        ctx.accounts.mango_group_ai.key,
  )?
};
```
?
That will drop the Ref at the end of the curly brackets
Simplest thing you can try is to just wrap the previous usage inside `{ ... }`
`    'Program log: Failed to borrow a reference to account data, already borrowed',`
Where it fails
Then I use it in a CPI call
I deserialize it manually first
However the `mango_account_ai` is the problem
These are parts of it
```rust
...
let mango_account = MangoAccount::load_checked(
        &ctx.accounts.mango_account_ai,
        ctx.accounts.mango_program.key,
        ctx.accounts.mango_group_ai.key,
)?;
...
 let mut account_infos = vec![
        ctx.accounts.mango_group_ai.to_account_info(),
     -> ctx.accounts.mango_account_ai.clone().to_account_info(),
        ctx.accounts.mango_authority.to_account_info(),
        ctx.accounts.mango_cache_ai.to_account_info(),
        ctx.accounts.root_bank_ai.to_account_info(),
        ctx.accounts.vault_ai.to_account_info(),
        ctx.accounts.token_account_ai.to_account_info(),
        ctx.accounts.signer_ai.to_account_info(),
        ctx.accounts.token_prog_ai.to_account_info(),
        ctx.accounts.clock_ai.to_account_info(),
];
...
invoke_signed(
        &withdraw_ix,
        &account_infos,
        &[&[
            MANGO_AUTHORITY_SEED,
            &ctx.accounts.trading_pool_account.key().to_bytes(),
            &[ mango_authority_bump_seed.clone() ],
        ]],
    )?;
```
its a lot of code üòÑ
If you post some code that's not working I can probably suggest how to fix it
Have you figured out how to solve this?
Try searching the anchor codebase for `#[account(zero)]` for some examles
So you'll need to create that big account in an entirely separate instruction that runs before your program does (no more `init`)
Any time you use `init` you're initializing an account via CPI, and the 10kb restriction applies to CPIs, not specifically PDAs (it just happens to be the case the *all* PDAs have to be initialized via a CPI, since the only way to sign for their address is to get their deriving program to do it)
Hey all - follow up on the max account data size problem I encountered last night. I've converted the account from PDA to an on-curve account, but I'm still getting that same error for some reason. I can't see a difference between this new implementation and the escrow program I'm referencing (though TBF, the escrow program isn't initializing a >10240 account, so maybe this still doesn't work). Here are the relevant pieces of code:
```

#[account(
    init, 
    payer = owner, 
    space = 8 + 540004 + 1 + 1 + 32,
)]
pub state_account: Account<'info, HuntState>,

pub fn handler(
    ctx: Context<InitializeProgram>, 
    program_ust_account_bump: u8,
    mint_auth_account_bump: u8,
) -> ProgramResult {
    let state_account = &mut ctx.accounts.state_account;
    state_account.mint_auth_account_bump = mint_auth_account_bump;
    state_account.program_ust_account_bump = program_ust_account_bump;

    state_account.owner = ctx.accounts.owner.key();
    state_account.hunt_state_vec = Vec::with_capacity(5000);
    Ok(())
}

// test
const stateAccount = anchor.web3.Keypair.generate();
await program.rpc.initializeProgram(programUstAccountBump, mintAuthBump, {
  accounts: {
    owner: provider.wallet.publicKey,
    stateAccount: stateAccount.publicKey,
    ...otherAccounts
  },
  signers: [stateAccount],
});
```

and then error: ```Transaction simulation failed: Error processing Instruction 0: Failed to reallocate account data
    Program 69v7eiACV758WzGopNQN8s5WRG5TcTSF4nexNP8F5p7d invoke [1]
    Program log: Instruction: InitializeProgram
    Program 11111111111111111111111111111111 invoke [2]
    Program 11111111111111111111111111111111 success
    SystemProgram::CreateAccount data size limited to 10240 in inner instructions```
When I reduced the allocated size of this account to below `10240` it does succeed.
only pass integers.. u64, u128
yes
Hello, I have a question about program struct.
Is it impossible to use float (f32 or f64) for data account struct? When I try it, it emits error.
Curious if I can get some input here https://discord.com/channels/889577356681945098/889702325231427584/927342842106495047
is there any endpoint I can call to get all the custom anchor errors? looks like I don't receive the msg and code fields from the rpc error calls
Gotcha, all right. Thank you üôÇ
`require!(<condition>, MyError::MyErrorCodeIfConditionNotTrue)`
we have the `require` macro which makes validation a bit easier but nothing like you described
no
For example, I'd like to conditionally accept multiples of 2 token accounts in `remaining_accounts`.

If I receive two accounts in `remaining_accounts`, is there a way I can convert them and/or use the `ValidateMe` struct below so that I can use Anchor for validation still? In this case it would do the checking of the `mint` field on the token accounts.

```
#[derive(Accounts)]
pub struct ValidateMe<'info> {
    #[account(mut, constraint = account_a.mint == some_mint)]
    pub account_a: Account<'info, TokenAccount>,
    #[account(mut, constraint = account_b.mint == some_mint)]
    pub account_b: Account<'info, TokenAccount>,
}
```
Got it yup, that makes sense for deserialization! Is there a way to manually trigger the account constraint validations so that we don't have to manually do constraint checking on the `remaining_accounts`?
yes. this is what anchor does for your normal accounts after all! There are different ways to do it. Anchor uses borsh.io to deserialize accounts which you can do yourself with the remaining accounts. Or you could go even more manual and do what e.g. the token program does, byte by byte manual deserialization
Hey all - is there a way to manually run serialization / validation on `remaining_accounts`?

I noticed this in some example code, but it is using some deprecated features: https://github.com/project-serum/anchor/blob/5fa263ff176a6f3f1e8fb1e6667da0ec5999b6e9/tests/lockup/programs/registry/src/lib.rs#L507
thank you for looking into this
So seems like you need to think through who is supposed to have authority over what, how signing for a program-derived address works, etc.
You have mint::authority = authority, which then fails when you try to mint the tokens (because the program doesn't have authority over them)
About the mint authority, should be:
```.rs
    #[account(
        init,
        payer = authority,
        seeds = [],
        bump = mint_bump,
        mint::decimals = 0,
        mint::authority = mint,
    )]
    pub mint: Account<'info, Mint>,
```
No, it apparently should be `owner`, based on what you say in the rust code
it should be `program.provider.wallet.publicKey`?
```.js
    let ourAssociatedTokens = await spl.Token.getAssociatedTokenAddress(
      spl.ASSOCIATED_TOKEN_PROGRAM_ID,
      spl.TOKEN_PROGRAM_ID,
      mint,
      owner.publicKey
      // program.provider.wallet.publicKey
    );
```
And then you've also mismatched the authority over the mint
oh my, where did I do that?
You calculated the associated token address by specifying that its owner is the program wallet, not the `owner`
Because you've mismatched the owner of the tokens vs the signing authority
I know it has something to do with this declaration
```rs
#[account(init_if_needed, payer = authority, associated_token::mint = mint, associated_token::authority = authority)]
pub destination: Account<'info, TokenAccount>,
```
<@!134416332509675520> that solves that, but really this is the biggest mystery:
https://discord.com/channels/889577356681945098/889577399308656662/927414400556601384
How does one solve what account was missing from the instruction?
BIG thank you, seriously. I get it now and am relieved
but all other accounts suffer from this anyway
yea, I was using the same in my client
lol
which can be a death trap
yes, once ownership is given it is useless. until closed
gotcha. and now piecing together with something I realize I read like 3 weeks ago - that means that once the program initializes this account, the secretKey from the original keypair is useless going forward, unless the account is uninitialized in the future?
Were you also using empty seeds from the client? They need to match
`init` does it for you, it calls the system program to create the account, since the account has signed the transaction it is possible.
https://github.com/project-serum/anchor/blob/master/tests/escrow/tests/escrow.ts#L90-L102 see how the test calls it
```
[dependencies]
anchor-lang = "0.18.2"
anchor-spl = "0.18.2"
spl-token = "3.2.0"
```
basically this error is what I'm contending with: https://discord.com/channels/889577356681945098/889577399308656662/927414400556601384

but if I remove the new token stuff causing the above error and I just leave an empty array for the seeds I get this error:
```
    'Program failed to complete: Could not create program address with signer seeds: Provided seeds do not result in a valid address',
```
Sorry, one more question because I'm still missing a piece. I'm trying to follow the ownership of the newly created `escrow_account`, specifically trying to understand at what point the program is gaining ownership over it. Does the program have ownership of `escrow_account` at initialization or does it gain ownership after? 

I didn't think the program had ownership purely because it initialized it, but that's the only solution that makes sense to me
What goes wrong? What version of anchor are you using?
which I found elsewhere
I've had to use this 
```
seeds = [b"mint".as_ref()],
```
<@!134416332509675520> what does the `seeds` mean?
When I try to copy your mint account init, I'm unable to leave the seeds as an empty array like so:
```rs
seeds = [],
```
https://discord.com/channels/889577356681945098/889702325231427584/918277114279637022
This bit is helping to connect dots - didn't realize the `impl<'info> From...` below was being utilized
https://docs.rs/anchor-spl/latest/anchor_spl/token/fn.set_authority.html
https://github.com/project-serum/anchor/blob/master/tests/escrow/programs/escrow/src/lib.rs#L179
ah
it is another one that ends up calling that one
oh I've actually read this link through in full twice now lol. I get the difference between user space owner and actual owner
it isn't this function
not least because it doesn't seem to line up with the args here https://docs.rs/spl-token/2.0.3/spl_token/instruction/fn.set_authority.html
https://paulx.dev/blog/2021/01/14/programming-on-solana-an-introduction/
This is the best link to get the account owner != user space account "owner" brainfuck resolved
I'm trying to narrow my error.
I added this
```rs
    #[account(init_if_needed, payer = authority, associated_token::mint = mint, associated_token::authority = authority)]
    pub token_destination: Account<'info, TokenAccount>,
    pub associated_token_program: Program<'info, AssociatedToken>,
``` 
to my initialize handler

But I'm not sure how to debug this error
```
'Instruction references an unknown account D7LtSe6YRSER41Qr9xXS1uHcLdx9mkH6jXiseGjHKzY',
```
I've tried switching/adding/moving the accounts around, but I'm not able to find what this unknown account is

Basically the error is still:
```
Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: An account required by the instruction is missing
```
Ok, I wish I could say I was following this lol. I'm still hung up on the magic line `token::set_authority(ctx.accounts.into(), AuthorityType::AccountOwner, Some(pda))?;`
if you look at the token program, it uses a PDA based on the state account that isn't a pda. So another variation.
but you don't have to
so yes if you have a state on a pda you can use that as a program signer
and authority != account owner
yes this program has a different signer, so you have the escrow account, the token accounts and the pda to sign
not the escrow_account
set_authority is the authority of the token account
if it had said `ctx.accounts.escrow_account` it would have made sense to me - it's creating a new PDA, and that PDA owns the escrow_account, right?
`ctx.accounts.into()` is throwing me
```let (pda, _bump_seed) = Pubkey::find_program_address(&[ESCROW_PDA_SEED], ctx.program_id);
        token::set_authority(ctx.accounts.into(), AuthorityType::AccountOwner, Some(pda))?;```
So this appears to be the logic that is assigning the program as the owner of the newly created `escrow_account`, though I'm not really following the `token::set_authority` call
An example, the escrow program.
https://github.com/project-serum/anchor/blob/master/tests/escrow/programs/escrow/src/lib.rs#L113-L114
The escrow account is just a regular on curve account
oh shit, you're right
if you own it is is writable at any time
you don't need to sign to modify it
but you're giving me hope, so that's nice
I don't think I've ever seen an example of that, I actually was under the impression that programs can't sign for anything that isn't a PDA. Like, all examples of code I've seen that use escrow accounts always create them under a pda.
PDA is only the location
an account that is program owned but not a PDA
yes
My program needs to be able to update the data stored on the account though
don't use a PDA then
legit think my entire project will be ended if I can't store more than 10kb per PDA account...really hope someone can give me good news here at some point. 10kb is a heavy restriction
<@!134416332509675520> related to what we were talking about earlier, I'm attempting to mint 100 tokens here, basically using your repo as an example
https://github.com/AJTJ/auction/blob/master/tests/auction.ts#L54
getting this error.  I feel like I might be messing up account ownership.
```
Transaction simulation failed: Error processing Instruction 0: An account required by the instruction is missing 
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS invoke [1]
...
```
```
  logs: [
    'Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS invoke [1]',
    'Program 11111111111111111111111111111111 invoke [2]',
    'Program 11111111111111111111111111111111 success',
    'Program 11111111111111111111111111111111 invoke [2]',
    'Program 11111111111111111111111111111111 success',
    'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [2]',
    'Program log: Instruction: InitializeMint',
    'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 2280 of 180583 compute units',
    'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success',
    'Instruction references an unknown account FqZBuNDwPMMpLsrgMCpKjKuPtFpCPNxfvFQrrXjRDvAA',
    'Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS consumed 200000 of 200000 compute units',
    'Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS failed: An account required by the instruction is missing'
  ]
```
Below is how I'm trying to initialize my PDA state account. The above said the limit is 10mb for accounts created in instructions, which sounds like what this is, but I'm being limited so perhaps it is not equivalent. I guess it must be doing invoke_signed behind the scenes or something..?
 ```    #[account(
        init_if_needed, 
        payer = owner, 
        space = 540004 + 1 + 32,
        seeds = [b"state"],
        bump = state_account_bump, 
    )]
    pub state_account: Account<'info, HuntState>,
```
...
```
pub fn handler(
    ctx: Context<InitializeProgram>, 
    state_account_bump: u8, 
    program_ust_account_bump: u8,
) -> ProgramResult 
    let state_account = &mut ctx.accounts.state_account;

    state_account.hunt_state_account_bump = state_account_bump;
    state_account.program_ust_account_bump = program_ust_account_bump;
    state_account.owner = ctx.accounts.owner.key();
    state_account.hunt_state_vec = Vec::with_capacity(540000);
    
    Ok(())
}
```
> If you want to create an account with the full 10MB, you need to do it as a standalone instruction, and not as an inner instruction using invoke_signed or invoke from within your program.
> 
> In your situation, that means you won't be able to use a PDA for your GameState if you need it to be bigger than 10240 bytes.
> 
I'm not following this explanation fully but it doesn't sound good. The last line of the stackoverflow answer seems to imply that *no pda* can have state larger than 10240 bytes. Really, really hope that's not true
https://stackoverflow.com/questions/70150946/systemprogramcreateaccount-data-size-limited-to-10240-in-inner-instructions
Just found another comment saying:
> It's 10mb for accounts created in instructions, it's 10kb for accounts created via CPI
really swore it was 10mb
please tell me this isn't true - 10kb? I thought it was 10mb for max account data size
appreciate all your insight
I'm enjoying anchor, but I feel like myself and most people, are just kind of winging it
break it down in a granular sense
I suppose I'm also just looking for tutorials on how solana (and by extension, blockchain) works.
Not totally sure, but this is a good one to just go source-diving for, the implementation is actually really simple‚Äîit's just a sha256 hash
(Since if you're off-curve, then you simply don't have a private key at all‚Äîso not possible to sign in the usual way, since you just straight up don't have a private key)
PDAs are supposed to only be signable by their deriving program, so the bump is just a way to be extra super sure this is the case (tbh I'm not sure it's really all that necessary in practice, but I guess it's nice)
I'd really like to be able to understand what is happening a bit more.
Also, are there any ground-up tutorials on this?
that's bloody fascinating. So, is the goal is to avoid some sort of address collision where a PDA is mistakenly used as a public key?
Program-derived addresses are supposed to *not* be actual ed25519 public keys, so the way solana makes sure of this is with this "bump" thing; it's just a fudge factor to chuck into the hash mix until you get something that doesn't land on the curve (and hence isn't a valid ed25519 public key‚Äîwhich is the goal)
sha256 as a hash function outputs 32 byte values. These values are just random-ish, and have nothing to do with elliptic curve points, but because both live in this space of 32 bytes, about half of all sha256 outputs will just happen to randomly land "on the curve", meaning their 32 bytes correspond to the byte representation of a point on the ed25519 curve.
ed25519 public keys mathematically are points on a (sort of) geometrical thing called an elliptic curve. They get encoded as 32 bytes; out of all such possible 32 byte values (2^8^32 = 2^256 possible values) about half turn out to be valid points on this curve.
https://discord.com/channels/428295358100013066/517163444747894795/927383761346261113
Can you clarify what "off the curve" means? Moved the conversation here, for clarify.
I'm actually honestly not sure why its necessary to record the decimals in the mint itself tbh
Oh, sorry, I misinterpreted what you said‚Äîyeah, to send "1 sol" you send 10^9 lamports
(I'll try and keep my questions related to you <@!134416332509675520> here) üôÇ
huh, can you clarify that? I built a simple program that requires a transfer of lamports, but nowhere along the line did I record the decimals. Since nowhere in the program do you ever deal with sol.

Do you record decimals just so you can output information to the users so they can understand the cost of things in sol?
Or rather how many zeros to get rid of (e.g. 10^9 lamports --> 1 sol)
so that it equals to lamports
right, ok, so all it is is "this is how many zeroes to add onto the actual number"
Under the hood you're always dealing in the smallest denomination (e.g. 1 sol is actually a billion lamports)
I guess it's just for ease of human readability
I'm actually not sure now that I think about it lol
perhaps this is rather nooby of me, but I'm trying to understand
hm, I've heard about this process of saving "decimals" separately, but I don't think I fully parse what it is intended for. If you want 100 tokens to be worth 1 USD, can't you just set the price in lamports or whatever?
Decimals is to handle things like having 1 USD = 100 tokens (although, actually, seems like the actual USDC mint has six decimals ü§î https://explorer.solana.com/address/EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v)
is it permanent?
i.e. to pause minting?
that makes a lot of sense regarding the stateless nature of programs on the chain. Two more questions. What are the decimals on the mint used for? And is freeze authority the authority to *stop* minting tokens?
It's up to the spl token program to actually do the minting itself though
It records information about the minting process: who needs to sign in order to mint new tokens (the authority), how many decimals the mint has, whether it has a freeze authority, etc.
huh, so what purpose does the mint serve? For some reason I associate a `mint` with being like a mint that prints dollar bills
Or a human might have authority over a mint, etc.
A mint isn't a program (it's just an account). A program might have authority over a mint though (that's what my example shows)
will do, is it fair to say that a `mint` is a program that generates tokens, even?
Can maybe check out https://github.com/cqfd/anchor-token-studies
looking for a simple example of how to mint and transfer token ownership
is there a way to enforce anchor to generate the "metadata" field in the idl on build? it seems to only do it on deploy or test.
Yeah this fucked me up, I wasn't aware it was positional.

Some lessons you just have to learn the hard way
awesome. thank you!
Yep, you can close the token account (spl token program has a close instruction)
when a token account is created, it looks like it takes 0.002 $SOL (for rent?). is there a way to get that $SOL back if you are done using that token account?
I was not aware of that, thanks!
Yeah, new anchor remapped the error codes (custom ones now start at 6000)
my error codes are mapped from 300 to 364. does the new anchor error encoding print out differently?
Always easiest to debub if you print the whole program log
(Or it could be coming from a CPI etc.)
That would ostensibly be one of your own custom errors (a pretty high one, the 39th in your list).
I don't get the error when I'm using 0.18.0
I'm getting an 0x1796 (6038) error when updating from anchor 0.18.0 to 0.19.0. Trying to map it out, but can't really find the culprit. Any ideas?
thanks!


///////////////////////////////////////////////////////////////////////////////////////////////

correct
ok
the push will not be rejected because of missing program on-chain
correct
so just so that I'm clear: when running `anchor publish` what happens is that the build is pushed, and verification is attempted.
but yes
or you can trigger it from the ui
ok so verification of builds is a scheduled job on your server basically?
yup this will automatically happen now
and if they aren't verified, then does nothing, to support the build, deploy, verify workflow as you mentioned
there's now a process that will scan through the latest non verified builds and tries to verify them
this was the case until yesterday
You can have Aleph.in index data for you and have a graphql interface to do queries, that's how I process errors
yes - that was the initial query. seems to be answered, as the only apparent way to do that, appears to be via logMessages. but when it comes to accessing past events efficiently, there doesn't seem to be a prebuilt solution
Ok but then you'r back to just storing data on chain and accessing it later? (I though the initial statement was that you wanted to "return" data that was not stored onchain)
hm, probably just best to designate a pda to each event, if it should be done onchain
Yep indeed
I think you need a service that collect and store them for you. mango does have a db for it (not anchor event, but similar)
i'm not too worried about the time. Once I copy once I can just save the ledger for later use.
It's surprisingly not that slow
oh I see, seems to be indexed via the respective trx in logMessages
<@!443079510053748743>
just perused the docs - emitting events, instead of messages works nicely as well. but is there an efficient way of getting events by name for a programId? There appears to be nothing in the event.ts
I guess I'll need to write a script to generate my command (will need to clone hundreds of accounts)
damn this guy literally just cloned a huge amount of accounts!
is a solution, yes. but not in this case
Maybe try to clone what you need. I'm now just using devnet btw
You can use --clone https://mirror.xyz/0x9fEcc73Da3f8bd2aC436547a72f8Dd32326D90dc/u05KU4oE4tnlI4Z5Yj-TAQSq8bgZuu4Mv2s3wblpkTs
AnchorEvents, not really a return either
Hmmm no there should be a deploy step in between otherwise there's nothing to verify. Different question then: what should the ideal setup look like?
1. latest release build
2. automatically push this build to anchor verify server
3. deploy that build on-chain
4. automatically trigger verification process after deployment
?
<@!501570363566587905> why do many builds in the anchor verified app show as `built` only, and not `verified`/`unverified`? I thought the build/verify was a single-step process
some hacky solution would/could be to log it via logMessages, but doesn't seem to be efficient
this might be an odd question, but is it impossible return a value directly from a program's function to a client (without storing it on an account)?

example:
`
    pub fn gm(ctx: Context<SayGm>) -> Result<String, ProgramError> {
        let x = String::from("GM!");
        Ok(x)
        
    }`
Is there any way to clone all accounts on mainnet-beta to a localnet ledger?
Doing a 34 accounts instruction with mango/serum CPI, I'm still blowing the stack by 500, but I'm already using all `AccountInfo`, `Box<...>` and `Program<...>`, not sure what's left for me in that case, removing parameter (only two, a u64 and u32)?
is `anchor verify` only working for build published on anchor registry? tried with a mainnet program and it gives me `Error: Account not found`
Hi guys, rust newbie here.. is there any way to deserialize a struct (annotated with `#[account]`) from vec<u8> or [u8]?
just this just mean the next working bump seed?
random question can someone explain what "canonical bump" means here https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html under PDA validator constraint
wait... why even do this in the first place
Pass it in as a token account
e.g. `#[account(payer = program_pda)]`
is there a way to set `payer` to a PDA?
tomorrow's problem
the annoying bit will actually be how to display the fields the correct way depending on their type it seems
üëç
Will there be any updates on the examples?
Nevermind that, got something working by simply instantiating a Coder, works just fine
when I say "re-implementing a chunk of the decoding logic", I really just mean piecing together bits of the Program
<@!501570363566587905> brain picking time: I'm fiddling with using the IDL on the explorer to decode Anchor-based accounts on the fly in the explorer, and I might be on the verge of re-implementing a chunk of the decoding logic. The reason is that instantiating a Program client comes together with Provider/Wallet which are not a required here. Do you see a way to re-use the Program (ultimately for the coder namespace only), or should I just go ahead I setup a Coder directly?
ok, interesting. yeah not sure why there was something there.
And that space is all zeros at first
So if you explicitly said `space = 5000`, then you'll have that much space
No, you have to (one way or another) be explicit about how much space to allocate
Could it be that init only resets as much of the allocated space as the struct needs?
So I'm not sure what went wrong for you above.
Assuming you have space
You ought to be able to just add new fields, as far as I can tell from thinking about it
Yeah I don't think I can help much more without seeing the account‚ÄîI don't know why there was a 34 in there
Thanks much <@!134416332509675520> for your help. Managed to migrate it in two steps, first to u64 to reset to 0, and the to bool. Not sure if it's practical in production though, so I still would like to know how would a generic account migration function from one struct to another look like.


///////////////////////////////////////////////////////////////////////////////////////////////

0x1 = insufficient funds
not enough sol
whats the difference between `safe_add` and `checked_add`?
Your space allocation is wrong. Remove `space` constraint in your context Initialize or `space = 32 + 8 + 8 `
can someone point out the mistake im making here?
i've enough sol balance
probably you have insufficient Sol balance
You can make accounts optional, so there must be a way to make an optional account with a signer constraint, not sure if that would fix your issue
Anyone know if there is a way to have a signer be optional?  If I try and sign for an UncheckedAccount using the javascript client it complains that it didn't expect a signer for that key.
i was trying to deploy my program on the mainnet but this error shows up:

`Error: Deploying program failed: Error processing Instruction 1: custom program error: 0x1`

any fix?
If I pass in an inited token account I get a signature verification error, if I pass in a new keypair and add it to the signers, its fine
Right ok that makes more sense. If you pass in an initialized token account into it, does that account need to be a signer?
no. it initializes the account if it's not already initialized
init if needed only initializes the account if we use it in the function, correct?
ok nvm after couple min it started running ¬Ø\_(„ÉÑ)_/¬Ø
my deployment command (`anchor deploy --provider.cluster devnet`) is stuck at this:
```
Deploying program "gem_bank"...
Program path: /Users/ilmoi/Dropbox/crypto_bc/gemworks/core/target/deploy/gem_bank.so...
```

just sitting there doing nothing üò¶

any ideas?
Why when using `anchor build --verifiable`, the .so is not added to `target/deploy`? I have to manually move it before doing `anchor deploy` so that it can be verified later.
In general you could use e.g. cargo features to do conditional compilation around `declare_id!`, e.g.
```.rs
#[cfg(feature = "mainnet")]
declare_id!("adsfasdfasdf");
#[cfg(feature = "localnet")]
declare_id!("lkjlklkjlkj");
```
And please don't at message people for general questions
`pk == Pubkey::default()`
Hi <@!501570363566587905> 
How can we check if the pubkey is zero_address?
Can someone explain me why having `programs.localnet` and `programs.mainnet` in `Anchor.toml` if both should have the same programs ID due to the macro `declare_id!`?
https://docs.rs/anchor-safe-math/latest/anchor_safe_math/
a small crate for those who want a seamless error handling with numeric operations
Thank you so much üôÇ
--program-id flag lets you specify the keypair you wish to use on a deployment
just checkout the cli command `solana program deploy`
anchor deploy is just a wrapper on solana deploy
When you've run anchor build it outputs the message The program address will default to this keypair (override with --program-id) but then if I run e.g. anchor deploy --program-id ~/.config/solana/AUDVPRGmDgT4R23Tdd1REnKf5PB53prSX1gLxSf13xRm.json I just get error: Found argument '--program-id' which wasn't expected, or isn't valid in this context.

Is there an easy way to override the keypair at deploy time?
That slack is what you think avg fees will be <@221877670290522112>
This is easy use some sort of slack and check if the amount is expected-slack to expected + slack
any ideas how to deal with fees?
I am getting error because of `_calculator = calculator;`
I double checked the errors
heyy guys I am facing this error while running `anchor test` ?

thanks, ill try this out
yeah that's what I thought. I'm checking the handler and CPI'ing to that program, so i can just check the seeds on the other side. should be equivalent
thanks xD
Yeah, this should go in the next anchor release I think
you can still check in your handler though
docs say:
> Will be adjusted in the future to allow PDA to be derived from other programs.
> 
> https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html
but just curious üôÇ
it's not a huge deal since I'm CPI'ing and I can check it on the other program
is there a `#[account(seeds = [...])]` for PDAs owned by other programs? üëÄ
I really wish I could get someone to engage with me on the type checking inside typescript against rust types.  I keep asking questions and posting code over last couple weeks and 100% of the time i get no response.  Does no one care about having sane typing?  Am I doing it completely wrong?  Am I in the wrong channel?  Is someone else frustrated by this?
Also, how come is it trying to create an account at an address that is already in use when running a test?
By the way, `solana logs --url localhost | grep "Program log"` doesn't work . Only `solana logs --url localhost ` works
Awesome! That worked! I had found something similar where

one terminal runs the `solana-test-validator`
On the other `solana logs --url localhost`
But I didn't have the flag `--skip-local-validator` when running `anchor test`, which I think that was the issue
<@!907959093262712882> I found a solution on my side to see log when in run `anchor test`

1.  On a separate terminal run `solana-test-validator -r`
2. On a separate terminal run `solana logs --url localhost | grep "Program log"`
3. To do the test run: `anchor test --skip-local-validator`
I've been trying to see the logs of the programs and I added `msg!()` . However, whenever I run the tests, the logs don't show in the terminal


I also try to enable debugging after checking this article  https://docs.solana.com/developing/on-chain-programs/debugging

and I set the env variable,

export RUST_LOG=solana_runtime::system_instruction_processor=trace,solana_runtime::message_processor=info,solana_bpf_loader=debug,solana_rbpf=debug

However, if I run the tests, the logs don't show either


I apologize in advance if this seems to be a dumb question, but I've been struggling to make a simple program to work
That program log is trying to give you some info: looks like you're trying to create an account at an address that is already in use
```js
await connection.getParsedProgramAccounts(
    TOKEN_PROGRAM_ID,
    {
      filters: [
        {
          dataSize: 165, // number of bytes
        },
        {
          memcmp: {
            offset: 32, // number of bytes
            bytes: MY_WALLET_ADDRESS, // base58 encoded string
          },
        },
      ],
    }
  );
```
you could use `getProgramAccounts`  for token program ID and filter by wallet address
Hi, I'm really struggling with this one.

Whenever I run a test, I get the following error

Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: custom program error: 0x0

These are the logs

Transaction simulation failed: Error processing Instruction 0: custom program error: 0x0 
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS invoke [1]
    Program log: Instruction: WriteTweet
    Program 11111111111111111111111111111111 invoke [2]
    Allocate: account Address { address: 8cMiYohr7b7brodHuLD29iaHHCcDZJXj4se8UaaXEM28, base: None } already in use
    Program 11111111111111111111111111111111 failed: custom program error: 0x0
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS consumed 4125 of 200000 compute units
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS failed: custom program error: 0x0

Could anyone help me?
gurus - what is the most efficient way to get a user's token accounts? im using getParsedTokenAccountsbyOwner and is very slow
This lets me do things like
```typescript
let bet_choice : BetChoice = "low";
let anchorized_bet_choice = new Anchorable<BetChoice>(bet_choice).to_anchor();
// anchorized_bet_choice = {low:{}}
assert.equal(bet_choice, from_anchor<BetChoice>(anchorized_bet_choice));
```
```typescript
interface IAnchorable {
    to_anchor: object,
}

class Anchorable<T> implements IAnchorable {
    public inner: T;
    anchor_root: string;

    constructor(inner: T) {
        this.anchor_root = inner.toString();
    }

    to_anchor(){
        let obj = {};
        obj[this.anchor_root] = {};
        return obj;
    }

    get_root() {
        return this.anchor_root;
    }

    equals(other: Anchorable<T>): boolean {
        return other.get_root() == this.anchor_root;
    }
}

export function from_anchor<T>(obj: object) : T {
    let ourKey =  (Object.keys(obj) as Array<keyof typeof obj>)[0];
    let ret : T = ourKey;
    return ret;
}

export type BetChoice = "low" | "high"
export type BetType = "twoFold" | "tenFold"
```
https://github.com/gdoteof/solana-gamba/blob/master/tests/utils/gamba_utils.ts#L11-L45
It was really bugging me the way that the typescript side of things can't really see the types exported by rust.

I am using something like this:  I wonder if there is a more general solution or any undergoing effort to bring something like this direclty into Anchor?
how do you guys handle fees in tests?

for example i m testing a deposit from account A to B
A = 10 sol, B = 1 SOL

deposit 1 sol from A to B, A = 9 SOL B = 2 SOL

but there are fees paid by A, so balance is 8,99999...

how do i deal with this in testing?
Yeah, ugh
uhm, i just realised now that you said it
Uh, wait, why does solana's web3 lib return lamport account balances as `number`s, not bignums?
added you on discord, let's talk there
Yea i can give you access
Hmm, is your code on github? Probably easier for me to just run it myself
But i m using static seeds there
Other tests using pda s worked
Yep
And just to double check, your program id in Anchor.toml matches `declare_id!`?
let [flipAccountPDA, flipAccountPdaBump] = await anchor.web3.PublicKey.findProgramAddress(
        [program.provider.wallet.publicKey.toBytes()],
        program.programId
    );

const tx = await program.rpc.userDepositInFlipAccount(
            flipAccountPdaBump,
            new anchor.BN(lamportsToDeposit),
            {
                accounts: {
                    signer: program.provider.wallet.publicKey,
                    signerFlipPda: flipAccountPDA
                }
            }
        );
yes it is
Also, is your `declare_id!` correct?
Can you show me how you're calling it from JS? What you have their looks fine to me
i think it bails out somewhere else. my access_control method that checks PDA received with PDA computed on program works, but now i get `Provided seeds do not result in a valid address` - think it's from constraint checks

maybe my struct is mistakenly written?

#[derive(Accounts)]
#[instruction(flip_account_bump: u8)]
pub struct UserFlipAccountInteraction<'info> {
    #[account(mut)]
    pub signer: Signer<'info>,
    #[account(
    mut,
    seeds = [signer.key.as_ref()],
    bump = flip_account_bump
    )]
    pub signer_flip_pda: SystemAccount<'info>,
}

method: 

**pub fn user_deposit_in_flip_account(ctx: Context<UserFlipAccountInteraction>,
                                        _flip_account_bump: u8,
                                        lamports_to_deposit: u64) -> ProgramResult {...}**
The same sort of thing will work in rust too (just make sure no `to_string`)
That looks good üëç
its interesting cuz on tests, using `await anchor.web3.PublicKey.findProgramAddress(
        [program.provider.wallet.publicKey.toBytes()],
        program.programId
    );` it does generate an address
yep, i tried using that, but seems like having the same issue ü§î
Whoops sounds like you already got there
You almost certainly want to do `signer.key.as_ref()`, no `to_string`
how can i get a PDA to be used as an intermediary account inside my program then?

something like having a PDA derived with user's pubkey as seed (which from what i see is not possible due to lenght issue)

my current code: `**Pubkey::find_program_address(&[signer.key().as_ref()], program_id);**`
well i think i found the problem.

i'm trying to get a PDA using signer's full key, but i found the error: `Length of the seed is too long for address generation`

so from my understanding, i cannot get a PDA using a full pubkey as seed
Hey guys!
Just wanted to ask how do i hide my solana wallet private key from users
so that they cant inspect it
the args in the instruction macro must match names and order exactly with the arguments in the instruction but that seems good here, I wasted a bunch of time last week trying to figure out a similar error
don't think so, cuz in other places it works
missing the underbar?
you should be using _flip_account_bump in the _instruction macro I think
i've followed the same pattern used in other places in my app. but in that places i'vebeen using a static seed from my app
#[instruction(flip_account_bump: u8)]

ctx: Context<UserFlipAccountInteraction>,
_flip_account_bump: u8,
lamports_to_deposit: u64
Can you show me what you have for `#[instructions( ...` and what you are taking in as parameters of your instruction?
i'm trying to check a PDA derived from program address together with signer's wallet key as seed, but i keep getting Seed constraint violated error

am i doing it wrong?

#[account(mut)]
    pub signer: Signer<'info>,
#[account(
    mut,
    `seeds = [signer.key.to_string().as_bytes()]`,
    bump = flip_account_bump
    )]
    pub signer_flip_pda: SystemAccount<'info>


///////////////////////////////////////////////////////////////////////////////////////////////

trying to use docker to run tests in parallel an getting `sh: 1: anchor: Permission denied` any ideas?
theres also `Program<'info, crate::program::MyProgram>` which doesnt rely on internal macro code
`#[account(address = *program_id)]`
nvm this actually works lol
obvs  this isn't right ^^
something like that
`#[account(address = program_id)]`
Hey how would I check if an account is the program itself?
ah yeah. Forgot. anchor.workplace ?
i couldn't get it using that
https://discord.com/channels/889577356681945098/889702325231427584/927910333115416596 did this not answer that question?
hmm, actually yeah you're right, the second is not the case. thanks so much!! üôÇ
<@!347689664855015424> is it possible to get the current slot inside of a smart contract?
Are you sure `MOCK.SOL` is a valid mint? or that `qPoolContext.userAccount.publicKey` is a _token account_ and not a user's system account?
any idea why this might be happening?
but for some reason I get an `Error processing Instruction 0: invalid account data for instruction` error
Hey guys, I'm trying to airdrop some tokens on the frontend using a keypair:

``` 
let transaction = new Transaction();
        let mintToInstruction = Token.createMintToInstruction(
            TOKEN_PROGRAM_ID,
            MOCK.SOL,
            qPoolContext.userAccount.publicKey,
            airdropAdmin.publicKey,
            [],
            sendAmount.toNumber()
        )
        transaction.add(mintToInstruction);
        const blockhash = await qPoolContext.connection.getRecentBlockhash();
        transaction.recentBlockhash = blockhash.blockhash;
        let connection: Connection = qPoolContext.connection;
        const tx1 = await connection.sendTransaction(
            transaction,
            [airdropAdmin]
        );
```
have you ever renamed that program and didnt update the idl maybe? also, in case you didnt know, anchor provides a testing scaffolding out of the box so you dont have to write stuff like `main` or `new anchor.Program(idl, programId);` yourself
although this wouldnt make sense if this `    console.log(counterAccount.count.toNumber());
` returns the correct result
Quick question -- I have a program running on mainnet (fully functional), and deployed it on testnet (+ verified all accounts are correct). Yet something must have gone wrong since I'm getting an odd error: `0x233`. I've checked the `error.rs` file on anchor and cannot find it --> 0x233 = 563. 

Anyone run into this error code before / can point me in the right direction?
is your error coming from the 1st or 2nd tx? If it's the 2nd, try adding a short sleep between the two. maybe the tx just hasnt been confirmed on devnet yet. im not super familiar with the ts client tho
unrelated but you can implement `Default` for counter so you dont have to specify `space` explicitly
<a:coding:850830817629437992>
`use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod increment_decrement_program {
    use super::*;
    pub fn initialize(ctx: Context<Initialize>, authority: Pubkey) -> ProgramResult {
        let counter = &mut ctx.accounts.counter;
        counter.authority = authority;
        counter.count = 0;

        Ok(())
    }

    pub fn increment(ctx: Context<Increment>) -> ProgramResult {
        let counter = &mut ctx.accounts.counter;
        counter.count += 1;
        Ok(())
    }

    pub fn decrement(ctx: Context<Increment>) -> ProgramResult {
        let counter = &mut ctx.accounts.counter;
        counter.count -= 1;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 40 + 8)]
    pub counter: Account<'info, Counter>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>
}

#[derive(Accounts)]
pub struct Increment<'info> {
    #[account(mut, has_one = authority)]
    pub counter: Account<'info, Counter>,
    pub authority: Signer<'info>
}

#[account]
pub struct Counter {
    pub authority: Pubkey,
    pub count: u64,
} 

`
could u share your program code
yup. checked that. confused where is the issue
(0xbbf == 3007)
looks like you're passing in an account not owned by the program
https://github.com/project-serum/anchor/blob/master/ts/src/error.ts#L94
hi, i was just trying to write a test for increment & decrement program and i get the error 3007

code:
`const anchor = require("@project-serum/anchor");
const { SystemProgram } = anchor.web3;
 
const provider = anchor.Provider.local("https://api.devnet.solana.com");
anchor.setProvider(provider);

async function main() {
    const idl = JSON.parse(
        require("fs").readFileSync("./target/idl/increment_decrement_program.json", "utf8")
    );

    const counter = anchor.web3.Keypair.generate();

    const programId = new anchor.web3.PublicKey("C32nN2JfAfrH35gngEMmGNedRiqT1vxZPCdPxt7294En");

    const program = new anchor.Program(idl, programId);

    await program.rpc.initialize(provider.wallet.publicKey, {
        accounts: {
            counter: counter.publicKey, 
            user: provider.wallet.publicKey,
            systemProgram: SystemProgram.programId,
        },
        signers: [counter],
    });

    let counterAccount = await program.rpc.getAccount(counter.publicKey);
    console.log(counterAccount.count.toNumber());

    await program.rpc.increment({
        accounts: {
            counter: counter.publicKey,
            authority: provider.wallet.publicKey,
        },
    });
    console.log(counterAccount.count.toNumber());
}

console.log("Starting...");
main().then(() => {
    console.log("Done.");
});`

err:
`Transaction simulation failed: Error processing Instruction 0: custom program error: 0xbbf `

ps: i hate writing tests <:cringe:885396558588313620>
hey everyone. qq how would I go about generating an anchor idl and client for serum-dex? I see there is an anchor branch, should I use that?
hi, is `#[borsh_skip]` sufficient for `AnchorDeserialize/AnchorSerialize` to ignore a field?
If I want to use solana json RPC in rust program, then what should I install? only installing solana-program won't work...
Hi guys, i'm facing issue with creating an two mints using anchor_spl inside program, while initialization there is no issue but i check with the mint address was created by the program was same, it
should not be same pubkey because those are tow different mints

here the sample code i have been used!
```
#[derive(Accounts)]
pub struct aTokenMintInt<'info> {
    #[account(
        init_if_needed,
        payer = owner,
        seeds=[],
        bump =bump_seed,
        mint::decimals = 6,
        mint::authority = token_mint_a
    )]
    pub token_mint_a: Account<'info, Mint>,
    #[account(
        init,
        payer = owner,
        associated_token::mint = token_mint_a,
        associated_token::authority = owner
     )]
    pub reserve_a_token_account: Account<'info, TokenAccount>,
}

#[derive(Accounts)]
pub struct bTokenMintInt<'info> {
    #[account(
        init_if_needed,
        payer = owner,
        seeds=[],
        bump =bump_seed,
        mint::decimals = 6,
        mint::authority = token_mint_b
    )]
    pub token_mint_b: Account<'info, Mint>,
    #[account(
        init,
        payer = owner,
        associated_token::mint = token_mint_b,
        associated_token::authority = owner
     )]
    pub reserve_a_token_account: Account<'info, TokenAccount>,
}
```


and i try to initialize the token mints from test using 

```
let [authority, bump_seed] = await anchor.web3.PublicKey.findProgramAddress([], program.programId);
```
``authority`` for the ``token_mint_a and token_mint_b``

and check with the mint address was initialized by the program and those are same keys
why its same? it should not be same right, those are two different mints, but both having the same mint public Key
whats i'm missing and doing wrong here!, can any one help me to figure this out, thanks
Hey, When running solana-test-validator, are there certain instructions or transactions where the fees = 0 ? The transaction is properly signed as well so it seems logical that there would be at the very least LAMPORTS_PER_SIGNATURE charged as fees.
pyth network has good docs as well
https://docs.chain.link/docs/solana/using-data-feeds-solana/
Hi. Does anyone know of any examples for reading oracle data from inside a rust program?
Hi ! I try to do an anchoring smart contract, actually I have already done it, but I also would like it to be impossible for the same wallet to put the same data twice, so my question is the following: is it possible to list the smart contract accounts of a wallet within this smart contract?
If I could list the previous interactions of a wallet with my smart contract I could prevent this wallet to anchor twice the same data...
Is there a way to debug which account failed to satisfy the signature requirement for `Error: Signature verification failed` errors?
Anyone have any experience listing tokens in the solana token-list
is these any project written by anchor a bit mode complex?
maybe anchor can make provider.wallet.payer great again
always v helpful üôÇ
ok, just wanted to make sure that was the best way and I wasnt missing something, appreciate it
https://github.com/cqfd/quidproquo/blob/main/tests/quidproquo.ts#L31
Yeah, that's how I do this in my own mint tests
this was all to avoid having to write two lines of airdrop code
(Won't work in the browser)
yes it is
If this is in a test
You can do `(provider.wallet as NodeWallet).payer`
makes sense
Ok, I guess what's happening is that the underlying mintTo machinery doesn't actually auto-sign with the provider wallet (sorry, I was being dumb‚Äîit's not anchor code)
i saw wallet.payer used to exist
In fact it would be awesome if you could do this:
it works if i use a keypair for everything

Can you post the full stack trace?
Ah ok
I can rename that t anything
Ok, why is mintAuthority the payer then?
3rd arg is for the actual mint authority = the wallet
mintAuthority is just the payer in this example
1 sec
Or maybe I'm misreading üëÄ
Shouldnt it be
mintTo requires a signature from the mint authority, which in this case isn't actually the wallet, right?
Ah, ok‚Äîyeah, *that's* the thing that needs to sign, not the wallet then
var names are kinda confusing sorry (I undid some things to show error). its just a keypair with some solana in it
What is `mintAuthority` here?
Yeah this should work I guess i was trying to use multiple wallets and came across a seed limit error Ill have to try again
The error is on the mintTo() function "Error: Signature verification failed"
I guarantee you that the provider.wallet is signing the tx, unless you're going out of your way to skip it
Gotta give me more info than that‚Äîwhat specifically fails? Can you post the full error?
If you ceate a new mint with provider.wallet.pubkey as the mint authority, and then try to mint to a new account using the below signing fails
`mintTo` would need the authority of the mint itself to sign
In what sense? Need more info than that
Doesn't seem to work for mintTo() function though
Thanks so much üôÇ
You can just use the wallet's own address as the seeds
Probably just `seeds = [wallet_account.key.as_ref()]`
is there a go to way of generating a unique and valid pda seed from a wallet address?
Little bit tricky, `(program.provider.wallet as NodeWallet).payer` would works
but as cqfd mentioned it signs automatically so you don't have to put it manually
It signs automatically!
How does one use provider.wallet as a signer? Or are we stuck generating a keypair for such cases? I saw provider.wallet.payer in some examples, but seems to be deprecated now
I ran an older binary:
They are in
`$HOME/.local/share/solana/install/releases/...`
It's a shame I can't use Vecs though because my array will generally be pretty empty, and vecs would make managing that (with remove/push) a lot easier than keeping track of individual populated indices all of the time. but it can be made to work
I'll take it üôÇ
hah
You actually don't have to worry any more about borsh, since zero_copy doesn't use any deserialization/serialization at all üòõ
```    pub hunt_state_arr: [Option<EnteredExplorer>; 2048], // Vec<EnteredExplorer>,```
This is my new (WIP) object. I'm using 2048 just for now, because arrays of size 2048 are apparently supported, but my real number will be 5000 - that's unsupported
Why do you need to implement customs deserialization? Do you have exotic types not covered by Borsch?
seems like you mark the account `zero_copy` and then just load with either `load_init()` or `load_mut()`...will try to implement, but seems hopefully straightforward.
I'm going to struggle later with trying to write the serialize/deserialize for my `Something` struct, but one step at a time
Sounds good. Thanks
Try searching the anchor codebase for `load_init()`, the api is slightly confusing at first but not too bad to use
```.rs
#[account(zero_copy)]
pub struct MyHugeAccount {
  things: [Something; 5000]
  ...
}
```
Ah, ok, then yeah you're gonna need to use `zero_copy` and use an array (zero_copy doesn't work with heap allocations)
Oh I wasn't aware of those restrictions. The vec is looking to be about 500kb right now.


///////////////////////////////////////////////////////////////////////////////////////////////

i don't think you're supposed to pass bump again to call the account, the address should be enough
(the only hidden piece is that _bump is an arg passed to the rpc call, exact same way I did the init. I am not doing anything in the body of the method in the contract for this test)
ok so last piece of the puzzle: 
- when i want to retrieve my created PDA account, do i do:
```

#[derive(Accounts)]
#[instruction(_bump:u8)]
pub struct incrementValue<'info> {
    #[account(mut, seeds = [b"seed".as_ref()], 
    bump = _bump )]
    pub base_account: Account<'info, BaseAccount>,
    #[account(address = system_program::ID)]
    pub system_program: AccountInfo<'info>,
}
```

and then
```
  const [baseAccountPDA, baseAccountPDABump] = await anchor.web3.PublicKey.findProgramAddress(
      [Buffer.from("seed")],
      program.programId
    );

    await program.rpc.incrementValue(baseAccountPDABump, {
      accounts: {
        baseAccount: baseAccountPDA,
        systemProgram: anchor.web3.SystemProgram.programId,
      }
    });
```
? everytime I try to do this I get:
```
Transaction simulation failed: Error processing Instruction 0: instruction modified the program id of an account 
    Program EespR7XYaCcPqNAZfuAdBFTsNGBoBgUJ65H5qH9Q8Ds1 invoke [1]
    Program log: Instruction: NameFloppydingdong
    Program EespR7XYaCcPqNAZfuAdBFTsNGBoBgUJ65H5qH9Q8Ds1 consumed 4212 of 200000 compute units
    Program EespR7XYaCcPqNAZfuAdBFTsNGBoBgUJ65H5qH9Q8Ds1 success
    failed to verify account 11111111111111111111111111111111: instruction modified the program id of an account
```
yeah
like if i use i128 it'll still work?
lol, i just mean it'll cast any uX or iX to it's appropriate type if i use non i64 in the future?
big number
what type is BN?
or import BN explicitly
new anchor.BN(num).toBuffer()
any helper functions in web3 js that might be able to help me get a buffer to pass in to find_pda?
speaking of PDAs....i'm trying to figure out how to pass in i64 as seeds through typescript, but it being typescript, they don't have those types
Most of the docs say that the client does this work to avoid your contract doing it so I assumed it was never done, but it is done once in init.
ya init does find_pda under the hood
Anchor codegens this
Yes
following along.... how does init know what is the right canonical bump? does it use compute units to find it during run time?
Thank you üôÇ
It clicked
Sick
And you are validated cuz nothing but ur program can create that account
Then u don‚Äôt incur the cost in mut
Ok that makes sense
Oh amazing! Init does the check
The client still passes in the bump in the args -> you can just use that in your bump seed
if that makes sense
As it guarantees the PDA uses canonical bump
Haha it's not possible to spam the other bumps if you use the `init` macro
Should I just not care about this spamming?
My brain itches
Anchor transparently adds the validation to confirm that you are using the first bump? But the point of offloading the bump to the client was to avoid that calculation
Ok but what if someone wants to spam my contract by using all the other bumps?
blah is just the bump you passed in from the client haha
Is blah a constant here? Or given by the client from the rpc call argument?
<@!342134856060502016> thanks for your help and have a nice flight, <@!117243115676499972> thanks for your help and have a nice evening !
anchor checks canonical bump in that macro i believe
i.e. if the only tx that is able to create said account uses `init... bump = blah` - then that tx can only be called with the canonical bump - then you can guarantee that all accounts of that type are infact the canonical one.
You can just enforce the canonical in your smart contract.
There can theoretically be 255 copies of this account? But we only respect the first one?
For example I want an account with a bool in it in an initializer that has a property initialized I set to yes
How would I avoid people creating new accounts with other valid bump seeds? Or should I just not care because we all decided the first seed that works is the correct one?
Different bumps will result in different addresses.
So you can have multiple bump seeds 255-> 0 that bump it off the curve - the first one that successfully does so is the canonical.
So I guess I'm back at solving my issue
"PDAs are a great way to store this kind of mapping‚Äîyou just need a new PDA account for each user." üòÑ
In this thead : "We can define the PDA's seeds, making it so that anyone can derive the PDA." So I assume that seeds must be reliable. So, using a seed combining a user address and a mint address should do the trick and be safe.  In the thread, he shows an example where he use a user's address.
Thanks a lot for sharing
this thread helped alot:
https://twitter.com/pencilflip/status/1455948263853600768
<@!117243115676499972> im kind of stuck on my understanding of bump seeds though- tell me if I'm wrong:
- These bump my address off the valid generated keypair curve
- I calculate them on the client side so they just need to be verified in my tx, not generated which would be more costly
- this is what I'm shaky on: the first valid bump seed is the canonically "correct" answer? or can there be multiple valid bump seeds? Does a base seed guarantee uniqueness?
agreed, I need something analogous to program state and PDAs offer me state lol
Haha fair - I can't think of many cases where PDAs shouldn't be used tbh.
Well, it looks risky now that you said it, I'll try to find more about it
üòÑ
it was that twitter thread that was being passed around! I should not make claims like that I'm def not qualified
Ok thanks, I will go with the getProgramAccounts solution for now, I think that it will serve me well too, and might be nicer if it is more reliable
would love to hear the cons against PDAs
I read somewhere recently about the downfalls of using PDAs as a mapping
I want to use the NFT's address to make it easier to find my escrow later. Is it really the right way to this or should I just use getProgramAccounts and filter with memcmp ?
Now
So this is working.
And in my initialize struct :

```
    // 3. PDA account,
    #[account(
        init,
        seeds = ["n4a_list".as_bytes(),listing_data.key().as_ref()],
        bump = listing_account_bump,
        payer = seller,
        token::mint = nft,
        // We want the program itself to have authority over the escrow token
        // account, so we need to use some program-derived address here. Well,
        // the escrow token account itself already lives at a program-derived
        // address, so we can set its authority to be its own address.
        token::authority = listing_account
    )]
    pub listing_account: Account<'info, TokenAccount>,
```
```
    it("Seller can list his NFT", async () => {
        const dataAccount = anchor.web3.Keypair.generate();

        [listingAccount, listingAccountBump] =
            await anchor.web3.PublicKey.findProgramAddress(
                ["n4a_list", dataAccount.publicKey.toBuffer()],
                program.programId
            );

        console.log(
            `    Listing Data :\n    https://explorer.solana.com/address/${dataAccount.publicKey.toBase58()}?cluster=custom\n`
        );
        console.log(
            `    Listing Account :\n    https://explorer.solana.com/address/${listingAccount.toBase58()}?cluster=custom\n`
        );
        await program.rpc.initialize(new anchor.BN(listingAccountBump), {
            accounts: {
                // 1. Account that will contain data,
                listingData: dataAccount.publicKey,
                // 2. the person who wants to list the NFT,
                seller: seller.publicKey,
                // 3. PDA account,
                listingAccount: listingAccount,
                // 4. the NFT to list,
                nft: token.publicKey,
                // 5. the token account belonging to the seller
                nftTokenAccount: mintAssociatedAccount,
                // 6. the Token Program,
                tokenProgram: spl.TOKEN_PROGRAM_ID,
                // 7. the System Program,
                systemProgram: anchor.web3.SystemProgram.programId,
                // 8 the Rent Sysvar,
                rent: anchor.web3.SYSVAR_RENT_PUBKEY,
            },
            signers: [dataAccount],
        });
    });
```
or put it on stackoverflow  and post the link!
can you edit that to have better markdown tags üôÇ
``^
    it("Seller can list his NFT", async () => {
        const dataAccount = anchor.web3.Keypair.generate();

        [listingAccount, listingAccountBump] =
            await anchor.web3.PublicKey.findProgramAddress(
                ["n4a_list", dataAccount.publicKey.toBuffer()],
                program.programId
            );

        console.log(
            `    Listing Data :\n    https://explorer.solana.com/address/${dataAccount.publicKey.toBase58()}?cluster=custom\n`
        );
        console.log(
            `    Listing Account :\n    https://explorer.solana.com/address/${listingAccount.toBase58()}?cluster=custom\n`
        );
        await program.rpc.initialize(new anchor.BN(listingAccountBump), {
            accounts: {
                // 1. Account that will contain data,
                listingData: dataAccount.publicKey,
                // 2. the person who wants to list the NFT,
                seller: seller.publicKey,
                // 3. PDA account,
                listingAccount: listingAccount,
                // 4. the NFT to list,
                nft: token.publicKey,
                // 5. the token account belonging to the seller
                nftTokenAccount: mintAssociatedAccount,
                // 6. the Token Program,
                tokenProgram: spl.TOKEN_PROGRAM_ID,
                // 7. the System Program,
                systemProgram: anchor.web3.SystemProgram.programId,
                // 8 the Rent Sysvar,
                rent: anchor.web3.SYSVAR_RENT_PUBKEY,
            },
            signers: [dataAccount],
        });
    });
```

And in my initialize struct :

```
here is my code that is working
Have a nice flight then üòâ
im on an airplane right now üôÇ
is there a screen sharing option on discord ?
that would be nice
Want me to help look at code?
<@!342134856060502016> I am still not sure how to get the part 1 working ^^ I got it to work, but I don't know why
I'll make a PR once I get the second part working üôÇ
This seems to be a pain point lots of people are experiencing, maybe there should be an  example in the anchor docs that is just -> rpc 1: store value in a PDA, rpc 2: retrieve the PDA ?
https://github.com/metaplex-foundation/metaplex/tree/master/rust/auction-house
Ok, thanks for your kind help, I'll go re-read some informations on deriving PDA's then
The reason it's working with the other key is probably sheer luck that the bump is 255 im guessing
So likely the issue you're seeing is because the bump you've provided isn't the correct one for the PDA you've passed in so when it tries to sign on the create account call, you don't have the correct seeds.
I'll double check the bump though
I pass a bump yes. That would be nice to be able to use the mint address because that will help me find my escrow pda, this way, I can later know if the current mint is listed for sale or not.
Ha
Because using a mint address in seed is fine fwiw
Are you passing in the bump correctly?
I'm, not sure if this is possible, it's just the keypair that signs the tx from the client side - This public key does not necessary need to be an account in the tx.
Regarding the seed issue I was experiencing, I found that the issue occured because I was using a mint address in the seed : `["n4a_list", mint.publicKey.toBuffer()]`. I replaced it with an unexisting key and both errors are now gone (signer privilege escalation error and "Provided seeds do not result in a valid address"). <@!892560437047078922> you might have the same issue.
how to get the fee payer in anchor program rust code
like I can know if a account is a signer using is_signer(),
but I want to know if someone is fee payer
I am also building an NFT's listing program. The closest open source project I found is this one : https://github.com/cqfd/quidproquo It really helps me building my program, altough it is a little bit different.
thanks paul, makes sense. I see TokenAccounts already have this built in.
this is how the token program does it (although not using anchor). each token account has a `close_authority` that can close the accounthttps://github.com/solana-labs/solana-program-library/blob/eedcbd860270e43fe56900c29bbdb176ea61e3a3/token/program/src/state.rs#L105
e.g. you give the account an `authority` field. Then when someone calls the instruction that can close the account, that instruction checks that the authority account has signed the transaction.
is there a repo or example on how to sell NFT in anchor?
thanks
I see, so how does one prevent closing? And what stops me from closing every account I see to myself
it's up to your program to prevent that
yes, you can close other people's accounts
Understood, what authority is used to close accounts?
thanks
Hello! I noticed that Anchor gives nice messages on failure when using `program.rpc.myInstruction()`. Is there a way we can surface error strings when constructing a single instruction and then sending a transaction manually?
https://discord.com/channels/889577356681945098/889577356681945101/928293715758432326
so lets say i want to check how many token received after swap cpi, in this case i need re-read the token account info somehow after the cpi
Is is possible to re-read the account after cpi?
im afraid not
<@!347689664855015424> Do you have an idea of what usually cause this kind of issues ?
OK thanks for that explanation.
`close = <target_account>` closes an account and all lamports in it are sent to `<target_account>`. accounts are owned by programs, not signers or pdas
the code tries automatically, this is not what is causing your error
`#[account(
        mut,
        close = ... )]` will close the account if the owner is the signer (or pda)?
However, I dont know how we are supposed to retry.
I have the exact same issue. However, I think I know why there is this inconsistent error with the seed validity : finding a valid key for a PDA has 50% chances to succeed. See https://docs.solana.com/developing/programming-model/calling-between-programs#hash-based-generated-program-addresses
updated idl. still same err üò¶
do you have any example regarding this token creation , it might be useful for me. <@!117243115676499972>
yeah mate, i tried with that
```
#[derive(Accounts)]
#[instruction(bump_seed:u8)]
pub struct Borrow<'info> {
    #[account(mut)]
    pub user: Signer<'info>,
    #[account(
        init_if_needed,
        payer = payer,
        seeds=[user.to_account_info().key.as_ref()],
        bump =bump_seed,
        mint::decimals = 6,
        mint::authority = token_mint
    )]
    pub token_mint: Account<'info, Mint>,
}
```
and its throws an error saying:
``
log: Custom program error: 0x7d6
9sU2PC2JXWzK8kVQVkg48HDFRPwDqhoAAVdNdn3XXdf3 consumed 49137 of 200000 compute units
9sU2PC2JXWzK8kVQVkg48HDFRPwDqhoAAVdNdn3XXdf3 failed: custom program error: 0x7d6
``
can you help me with this,
this is how I define the wallet
```
   this.wallet = provider.wallet.payer as Keypair
```
any idea why this is happening?
Hey guys, I keep getting an `owner cannot sign error`  when I run the following lines:

```
this.QPTokenMint = await Token.createMint(
            this.connection,
            this.wallet,
            this.qPoolAccount,
            this.qPoolAccount,
            9,
            TOKEN_PROGRAM_ID,
        );
this.qPoolQPAccount = (await this.QPTokenMint.getOrCreateAssociatedAccountInfo(this.qPoolAccount)).address;
``` 
where this.qPoolAccount is a PDA
`"A".as_ref().as_bytes()` etc.. or `some_key.as_ref()`
It just expects a slice of u8 so you can use strings or other pubkeys
i don't know what fits into the seeds, can you throw some examples <@!117243115676499972>
it can be whatever you want, as long as it doesn‚Äôt overlap
If you‚Äôre using the same seed, the pda it will produce is the same
```#[account(
        init_if_needed,
        payer = owner,
        seeds=[],
        bump =bump_seed,
        mint::decimals = 6,
        mint::authority = a_token_mint
    )]
    pub token_mint: Account<'info, Mint>,```

yeah , I initialized it with seed = [] for both the token. so what values should be given here
You probably have the same seeds for those mints?
How can I create two mint with same authority(pda), when i try to init the mints  then the second mint initialization throws an error 
``Allocate: account Address { address: 7Y6FfnyXPrJdEUzivcmZmD5vjAHc9TMpxBNb9rCVdeiZ, base: None } already in use``, any ideas?
in rust i have something that looks like this:
```
#[account(seeds = [account_a.to_account_info().key.min(account_b.to_account_info().key).as_ref(), account_a.to_account_info().key.max(account_b.to_account_info().key).as_ref(), b"str"],...)]
```
Running into a weird issue, wonder if anyone has encountered it...

I'm adding an account to an instruction

```
#[derive(Accounts)]
#[instruction(escrow_payment_bump: u8, free_trade_state_bump: u8, program_as_signer_bump: u8, buyer_price: u64, seller_price: u64,token_size: u64)]
pub struct ExecuteSale<'info> {
    #[account(mut)]
    buyer: UncheckedAccount<'info>,

    ...

    // ADDED 
    #[account(address = metaplex_token_metadata::id())]
    token_metadata_program: UncheckedAccount<'info>,
}
```


The instruction looks like this (metaplex auction house contract)

```
pub fn execute_sale<'info>(
    ctx: Context<'_, '_, '_, 'info, ExecuteSale<'info>>,
    escrow_payment_bump: u8,
    _free_trade_state_bump: u8,
    program_as_signer_bump: u8,
    buyer_price: u64,
    seller_price: u64,
    token_size: u64,
) -> ProgramResult {
```


when I add the account, somehow `buyer_price` is always the same as `token_size`, instead of whatever I originally passed in....
like somehow adding the additional account is messing with the instruction data
from what i can see in the rust docs `Ord` is implemented for Pubkey
what's the correct way to "order" pubkeys on the frontend side?
actually, when running the test the error is inconsistent w/o any code changes (it's either a signer privilege or a provided seeds do not result in valid address error)
i'm running into a signer privilege escalated error when initializing a PDA in an instruction...any thoughts as to why this could be?
hey guys, can any one please take a look!. i'm stucküôÅ
I gotta get some sleep but I'll probably bump this in the morning. I can't think of a good way out of it atm
and not sure why it was working when the struct only had a single u8 field, but not now with 5 u8s and 7 bools
but without really understanding how this node is set and used I'm at a loss for now on how it could be fixed
Yea so it seems like it has less to do with the contents and more to do with the fact that the array itself is of an Option<struct>. I'm not familiar with this borsh decoding stuff, but it's failing on this node: ```OptionLayout {
  span: -1,
  property: undefined,
  layout: Structure {
    span: 12,
    property: undefined,
    fields: [
      [UInt],          [UInt],
      [UInt],          [WrappedLayout],
      [WrappedLayout], [WrappedLayout],
      [WrappedLayout], [WrappedLayout],
      [WrappedLayout], [WrappedLayout],
      [UInt],          [UInt]
    ],
    decodePrefixes: false
  },
  discriminator: UInt { span: 1, property: undefined }
}
```
Which seems to me to be the decoding of the actual Option<Struct> - you can see every individual field lines up (5 ints, 7 bools)
https://discordapp.com/channels/889577356681945098/889702325231427584/927737082657509446
actually, zero_copy stuff requires an exact size. You can't increase over the exact amount - found that out a couple days ago with alan
but you got rid of option....
would it still implode?
what if on your init you put a generous size = X
i think there was some business about zero copy, Option and size
I've updated the gist with this new info at the bottom
unfortunately as I said, I removed all Option types from my nested struct and something in it is still tripping up the decoding. My nested struct is currently 7 `bool`, 5 `u8`, and a `u64` yet it's still failing which is quite strange, since it wasn't failing when it was _only_ a `u8` in my example code
it seems to be writing and reading properly from the program itself. I did ```msg!("{}", state_account.state_arr[open_index].unwrap().example_boolean);
``` after writing to this index and got the expected value
I can try to throw some logs in the program itself to spit out some state to confirm
Well, I was testing to find out if it's working as expected but can't actually inspect the state yet to confirm üòÖ . It _seems_ like it's working properly, my transactions are succeeding
interesting, how about program side? All good to write/read it?
default mode is derived from owner, mint, and token program id, but it can be overwritten if you specify it both on the backend via seeds = and the frontend right?
~~FWIW I think I can modify my object structure to remove the need for "nested" optionals in the meantime, luckily, but this definitely seems worthy of a filed issue. But don't want to be presumptious, perhaps there is a known workaround~~
rip, nope, it actually continues to happen in my specific case even without a nested `Option` type field. Seems this happens with more than just nested options.
Hi all, I've found a bug with `anchor.Program.account.<account>.fetch()` that is causing me some big headaches. In short, fetch fails if one of the data fields of the account is of the type `[Option<CustomStruct>; num]`, where `CustomStruct` also contains any field that is an `Option<anything>`.

Next-day-edit: It seems it's not _just_ about Option types. It may involve many variants of `[CustomStruct; n]` arrays where `CustomStruct` contains multiple fields.

I've written up a gist here, and I'd really appreciate if someone could take a look and offer guidance (or help me potentially file a bug report to the anchor team):
https://gist.github.com/Danlowe95/8ae5767a95e8321c255e2b1345f351fb
thank you. In my case, I used 5.3 SOL
could you possibly link to an example of this, and tysm for your help paul!
locally you can call reference to it via your file system
how would one register the crate as a dependency? This is the part that's confusing me
7 SOL/mb is the figure i've heard
Hi, How much is the gas fee for deploy the contract to mainnet? My .so file size is 383kb.
Thanks!
<@!804207881511370762>
What is the best way to init a pda account that doesn't have any data? Just used for sol? Should it be done via anchor init or something else? Init seems to require creating an Account struct  even if its empty so was curious
if it's not an achor program, you have to use raw solana syscalls but you can write wrapper functions around those. e.g. anchor provides those for the token program
exactly the same way if the other program is an anchor program. register the crate as a dependency, import it with `use <crate>;` and use it with `<crate>::cpi::<ix_name>()`
Hey all! 

I'm looking at the anchor tutorial 3 and https://project-serum.github.io/anchor/tutorials/tutorial-3.html#return-values which shows how to add and link a local (puppet) program I would want make a CPI on.

Is there a tutorial on how I would import and use a program that isn't local? For example, how should I go about making a CPI to an orca or serum program that I haven't written locally? cc: <@!501570363566587905>
eyyyyyyy that works
yes! sorry, i meant to imply that I have that check. Cool thank you for your time
can u try `anchor_lang::solana_program::pubkey!("xyz")`
well that shouldnt cause your account to roll back but in your ix code you should have a check that makes sure that fun_token.number < 40
Is there a way to hardcode an address into the `address = ... ` constraint? `address = Pubkey::new(b"xyz")` doesn't work for me
Bleh ok i gotta figure out whats wrong with my tests then üôÇ
yes, the answer is yes lol
haha I'm creating it by:
```
#[derive(Accounts)]
pub struct NameFunToken<'info> {
    #[account(init, payer = creator, space = FunToken::LEN)]
    pub fun_token: Account<'info, FunToken>,
```
this should roll back?
if you create an account inside a tx, the tx fails, and the account is still created anyway, you just broke the blockchain. lets hope its an error in your code üòÖ
triple checking now
oh really! weird, my tests are saying that there are extra accounts being comitted to the blockchain
wdym "it creates the account even when there is an error"? If there's an error in a tx it gets reverted and nothing changes
you can put any program in there, even your own
unrelated but we have the `Program` type now. Use it like `pub system_program: Program<'info, System>`
for anyone installing fresh on a mac M1, just ran through the instructions here and seem to have had success. Can run solana-test-validator as well as anchor test of my current program successfully: https://gist.github.com/billyjacoby/84a839d97949fa2445c1c77c84534336
I figured fetching based on base_account and making my base account a PDA is a pretty good / kinda secure solution, but it feels like I'm making bad assumptions.
One more question that I could use clearing up on- I'm trying to implement a simple base_account.counter that decides whether or not a fun_token account can be created (I want to limit it to 40). however when the name_fun_token method is called, it creates the fun token even if there is an error. (I fetch all of them and see extra ones created). How do I prevent the creation?

The docs have lots of best-case scenarios, but no negative scenario like this.

Should I just,,, not care that these are created and only fetch the fun_tokens that match my base account? (the base account is only assigned after all the checks in the method)

Can also move this to stack overflow, but im def writing a blog post üôÇ 

```
#[derive(Accounts)]
pub struct NameFunToken<'info> {
    #[account(init, payer = creator, space = FunToken::LEN)]
    pub fun_token: Account<'info, FunToken>,
    #[account(mut)]
    pub base_account: Account<'info, BaseAccount>,
    #[account(mut)]
    pub creator: Signer<'info>,
    #[account(address = system_program::ID)]
    pub system_program: AccountInfo<'info>,
}

#[account]
pub struct FunToken {
    pub creator: Pubkey,
    pub timestamp: i64,
    pub name: String,
    pub number: i32,
    pub base_account: Pubkey,
}
```
awesome, thank you <@!347689664855015424> !
exactly
the `Account` type checks that the ID of the crate where #[account] is used is the owner of the variable with the `Account` type
I found `Using this type within an Accounts struct will ensure the account is owned by the address defined by declare_id! where the inner account was defined.`
Account<'info, BaseAccount>, so im assuming yes that's built in üôÇ, thank you!
what makes Anchor decide whether to include a struct as a type in the idl? I have a struct that is used as the type for a field in an account but the struct isn't defined as a type in the idl even though the idl references it as `"defined": "structname"`
another struct of mine works just fine but this one doesn't
the only difference is that I implement `AnchorSerialize` and `AnchorDeserialize` myself instead of deriving it
that depends on which type you use for `base_account` in your account validation struct
(I already know I should be using a PDA as an epoch to limit program created accounts, but I wanna make sure I don't need to do this in the future for accounts that base_account decides are ok for my program to create)
My question is basically -- Do I need to be doing this or does #derive(Accounts) do this for me?
```
 if ctx.accounts.base_account.to_account_info().owner != ctx.program_id {
            return Err(ErrorCode::FraudulentBaseAccount.into());
        }
```
Hey! is there a stack overflow for anchor that is checked regularly? I have some questions but IDK if the chat is the best place!
is it possible to hardcode an address = constraint? something like address = Pubkey::new(..) doesn't work
nah, more like:

I'm using version 1, and I get an error. But I go look at the FAQ, and anchor is now on version 2, and so the answer for my version 1 error has disappeared.
so in other words, your worry is that if we have our own FAQ, if we stop maintaining it, the FAQ will become outdated or worse, be shut down?
gotcha, thanks!
no. not currently. you can ofc encrypt locally and store the encrypted data onchain
True, but Stack Overflow lets you have multiple answers to a question, which lets the answer change over time. 

So if you're working on a project that's out of date, the answer doesn't like "disappear from the internet"
Stack Overflow
is it possible to prevent the data stored in a PDA from being read?
How would you leave off the local wallet in testing?  I've got a series of tests I'm running. One is an update to account data that is to be signed by a 3rd party who should also pay for those transaction fees (a local pair I've created & funded in testing).  When I run that test, the local wallet gets passed in as a signer by default (as expected) along with the 3rd party keypair, but the local wallet is paying the fee.  The transaction & test are successful - but it's a false result as the 3rd party isn't paying the fees.
Plz can anyone help me how to solve this error?
i am getting this error
When i run **anchor test**
this is great. we should consider creating a FAQ page somewhere instead of stackoverflow though. Better to keep an overview of all the questions because they will need to be updated regularly because solana/anchor moves so fast. e.g. https://stackoverflow.com/questions/70484086/what-is-custom-program-error-0xa2-in-anchor the error code for that error is different now
and it's actually on mainnet, chainlink isn't (or wasn't, maybe it is now i haven't checked)
um hi friends, I'm going to start putting folks questions here on Stackoverflow, as "answer your own question style", so people can find answers when googling. If someone answered your question, consider moving it over for others ‚ù§Ô∏è 

Here's some examples:
- https://stackoverflow.com/questions/70583441/my-token-createminttoinstruction-is-throwing-error-processing-instruction-0-in
- https://stackoverflow.com/questions/70406575/what-is-signature-verification-failed-in-solana/70406576?noredirect=1#comment124464208_70406576
- https://stackoverflow.com/questions/70484086/what-is-custom-program-error-0xa2-in-anchor
build works just fine, solana's validator as well (everything as root btw)


///////////////////////////////////////////////////////////////////////////////////////////////

There's a decent list here: https://project-serum.github.io/anchor/getting-started/projects.html
jet, saber, zeta, drift
Do you know any DeFi projects that use anchor and have developer docs for calling their programs or at least have their repos opensource so I can see the functions that are available to be called?
Out of curiosity, does anyone know if lets say a program owned account's SOL balance goes to 0, what will happen to the mint accounts and token accounts it owns? Will the whole mint just disappear?
is there a (relatively) straightforward way to get the signature of the transaction for the current instruction, within the program? if not, where should i start looking?

in other words, if an account is the signer for an instruction, how can i get the signature itself within the program/instruction?
Ho sorry, then it is this one: `import { MetadataProgram } from "@metaplex-foundation/mpl-token-metadata";` and `MetadataProgram.PUBKEY.toBase58()` which is `metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s`
idk how to find it either but thats not the token metadata program. thats the normal token program
`import * as spl from "@solana/spl-token";` and `spl.TOKEN_PROGRAM_ID`
how to get TokenMetadataProgram (metaplex token medata program)id in js?
cool, what's the problem then?
Yes yes
After they connect their wallets, you can read their accounts to get all the NFTs, a filter on the array can check to see if the token has a mint authority which you have provided.

Is this what you mean?
<@!722185506674311258> That's fun üôÇ
ooooh! i ran out for a quick lunch, i'll be back to give this a go
Hello ,
Im dev from subway skaters 
we are making a solana skate park and subway city on unity ! 
So we want a feature like when they access our game so they have to connect their sol wallet like phantom and other wallets , so those people who have our 3D nfts in their wallet only they can access and rome in our subway city ! 
So through which coding and sources do we need !
actually I dont think you need the `&&`, you can just do it like this `fn1(1) fn2(2)` without `&&`. With `&&` you get `&&fn1(1)?;&&fn2(2)?;` in your expanded code. Surprisingly, this compiles just fine but it's not as nice
gotcha, thanks!
i havent looked into it myself yet but probably macro magic.
but access_control are supposed to return a `ProgramResult` so how does && work on it? little bit confused
you can use `&&`
```rust
#[access_control(guard_after_time(ctx.accounts.crash_account.starts_at))]
```

How can i use multiple `access_control`s? do i have to create a factory around existing access controls? because adding a comma separated access controls throws an error
maybe that the main metaplex program is included in this version, do you have an older one ?
running `solana-test-validator --version` returns `solana-test-validator 1.9.2 (src:f58b87be; feat:4100269022)` for me
otherwise, no, I dont have any reference to the new program in anchor, it isn't aware of it
you need to use `anchor test --skip-local-validator`
Then do you need to add something in anchor.toml to expose these programs? For an unkown reason the metaplex program_id is not found when launching anchor test ü§î
There might be a better way, but I did not found it and I needed to go further with my work so... I went the easy way üôÇ
ok thanks
(you'll need to install inotify-tools if you want to use  `watchtests`)
here is the Makefile I wrote to make it easier: 
```
PHONY: test dev watchtests

test:
    anchor test --skip-local-validator

watchtests: 
    @while inotifywait -r ./tests ./programs -e modify,close_write; \
        do clear && make test ;\
        done

metadata.so:
    solana program dump -u m metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s metadata.so

dev: metadata.so
    solana-test-validator --bpf-program metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s metadata.so --reset
    @echo "Launched the validator"
```
and then `anchor test --skip-local-validator`
<@!170833501111713793> Yes but I think you cant do this directly using Anchor. I did exactly what you said in your two steps
Anchor automatically launches a solana-test-validator, but is it possible to inject some programs from their .so files?
For example with a solana-test-validator you can:
- dump a program in a .so using solana program dump
- inject the program in solana-test-validator using the flag --bpf-program program_address path_to_so
weird, the mints seem to be correct according to solana explorer
got it... super weird, but will double check!
I suspect that `this.qPoolQPAccount` is not the right account
I have done a similar thing, but it works for me : `(await token.getAccountInfo(mintAssociatedAccount)).amount.toNumber()`
Ok great, thanks for your help !
not an expert with NFTs tho
I think common practice is to have a separate account for that. TokenAccount by definition contains data, data that contains Information about the toke account (like decimals, amount, etc.)
Hi everyone ! I have quick question : can a TokenAccount that will hold an NFT also contain data or do I need a seperate account for that ?
I am getting a `Error: Invalid account owner` when running the following line.
``` 
        let beforeQptFromAmount = (await this.QPTokenMint.getAccountInfo(this.qPoolQPAccount)).amount;
``` 

Is there anything that changed from solana 1.8.11 to 1.9.0 that affects this? this line works fine in my tests, but not when i deploy stuff on testnet
The idl is also a ts file, so it is perfectly fine to have generic types and thread what is in the idl through it
the idl isn't dynamic at runtime, defined at build time, typescript is only present at "build" time when transpiling
witchcraft
<@!620612278768762880> don't cross post please xD üôÇ
Hey guys ! Is someone know how to use random in a smart contract with Anchor ? üòÄ
i'm trying to get some understanding of what program/namespaces/type.ts is used for. I'm new to typescript and i dont understand how a dynamic IDL can be static typed checked? Anyone got some pointers on what this advanced typescript is doing?
is devnet down for anyone?
However, the Accounts module seems to be computing public keys completely incorrectly
I am trying to avoid moving the whole codebase to Keypair
has anyone else here had problems using the deprecated Accounts system in solana/web3.js?
bumping this- still having this issue all day :/
actually, unless youre importing the anchor master branch, youre still using repr(packed) though (we're changing it to repr(c) next release) so there's actually no padding at all in 0.19.0 zero_copy
> struct has the same alignment as its most-aligned field
Ah, didn't know this part. Will need to read more about `repr` myself then. Thank you.
I think `u16,u8,u8` would be ok. `u16,u8,u8,u8` would not be because there's padding at the end (struct has the same alignment as its most-aligned field -> u16 -> 2 bytes). but this is just from reading repr(c) docs, havent tested this myself
My current implementation of my state_account works (though is poor design due to inability to get it working with `Option`), but it uses bools which makes me concerned it could corrupt in the future if any underlying tech changes. but my tests are working, so..hm
I mean, is this really saying you can't store a struct with a `u16, u8` because it would have padding? Am I understanding correctly that the padding is because these take up 3 bytes total, and 1 byte padding? so if the struct was `u16, u8, u8` that would be kosher?
> (eg: no #[repr(C)] struct Foo(u8, u16), which has padding in the middle, and also no #[repr(C)] struct Foo(u16, u8), which has padding on the end).
yea this part AND the bool thing is probably causing my problems, though I'm having trouble understanding how I can store....any, data, with all these restrictions
yea some of our own tests and programs on mainnet solana today do not follow the guidelines either and still work. So it seems to be possible to ignore some of those rules. But we havent done extensive research on which rules solana programs do need to follow which is why zero_copy is still very much experimental
> The type must not contain any padding bytes, either in the middle or on the end (eg: no #[repr(C)] struct Foo(u8, u16), which has padding in the middle, and also no #[repr(C)] struct Foo(u16, u8), which has padding on the end).
This sounds like it's probably relevant to my problem, though how my specific Struct fails these safety params is a bit hard to parse. will have to give it more thought
> The type must allow any bit pattern (eg: no bool or char, which have illegal bit patterns).
Ok so this is really interesting, because it's _currently_ working with bools, but the existence of bool could be throwing it. I was also seeing problems with `Option` types and I mention in the gist problems with u16/u32/u64 (but all when `bools` were present, so who knows now)
some links not working in that section. go here too https://docs.rs/bytemuck/1.7.3/bytemuck/trait.Pod.html#safety
rules can be found here -> https://docs.rs/anchor-lang/latest/anchor_lang/attr.account.html#zero-copy-deserialization
No bool?
Ill look into this tomorrow or sometime this week. this may be a bug with anchor but it may also be because youre not following the zero_copy rules e.g. no bool, no padding etc.
I have updated the gist with a second file that goes into far more detail with more concise examples. I will be posting it as an issue to anchor project. Seen here https://gist.github.com/Danlowe95/8ae5767a95e8321c255e2b1345f351fb#file-gistfile2-md
bump on this if any anchor devs are watching, I think it's a serious problem in anchor deserialization and I can't find a way around it to actually access my state account data. I've tried re-architecting the state data in a number of not-ideal ways and even then, still errors
How do I pass struct data to the program? 

I'm doing this way:
```
const data = borsh.serialize(
    ProgramAccountInfoSchema,
    new ProgramAccountInfo({
    key: 0,
        key2: 100,
        key3: "key3"
    }),
 )
await program.rpc.setData(new anchor.BN(data),{
    accounts: {
    account: newDataAccount
    }
})
```
But it says I have encountered deserializedError.
Any Ideas?
restarting my laptop lmfao
nope. 
`     Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: instruction modified the program id of an account`
sick
yup
ignore the bump because it's no longer needed?
yup
gotcha. the address "findProgramAddress" gives me
you can just generate it again if you didn't store it
you pass it from the front end
is there another method in the client
but how do I get the correct public key for the PDA?
you only need it if it's going to be mutated, and even then you just need #[account(mut)] i think
yea like you don't need the account macro for taking in accounts


///////////////////////////////////////////////////////////////////////////////////////////////

Would my users have to sign twice? (1) creating the associated token account, (2) calling my instruction with that associated tokenaccount
gotcha, thanks for sharing your experience!
honestly, your frontend store doesn't matter. it's up to u to make sense of client state. My friends and I are using vue.js for our frontend and pinia for state management and everything works as expected
Yep! 2 is always better
Not explicitly anchor-related, but assuming we got some React devs in here as well, what store pattern do y'all use? I see lots of `Context` use in solana repos, but that's not technically designed for statement management (e.g. redux or https://zustand.surge.sh/)
gotcha, I see. That makes sense. Thanks Paul üëå
Unless there are big benefits, better to just split logic into two instructions. One for init, one for using the account
keep using it if you know how to protect yourself against re-initialization attacks
just feature flagged - not removed
`init_if_needed` has some good use cases, but I heard it will be removed in the future. What should I use instead?
k thanks
o.O
all passing
works fine for me
maybe i have old version of rustc or something if that going to work for you
did you try repo i send in issue ?
still curious our tests are not failing
it's possible that it's failing because you actually have to follow `zero_copy` guidelines now for it work which you partly didnt have to do before
just anchor version
nope i did not change anything
have you changed anything? our tests were passing after all
```#[account(zero_copy)]
#[derive(PartialEq, Default, Debug)]
pub struct Pool {
    pub token_x: Pubkey,
    pub token_y: Pubkey,
    pub token_x_reserve: Pubkey,
    pub token_y_reserve: Pubkey,
    pub position_iterator: u64,
    pub tick_spacing: u16,
    pub fee: Decimal,
    pub liquidity: Decimal,
    pub sqrt_price: Decimal,
    pub current_tick_index: i32, // nearest tick below the current price
    pub tickmap: Pubkey,
    pub fee_growth_global_x: Decimal,
    pub fee_growth_global_y: Decimal,
    pub fee_protocol_token_x: Decimal,
    pub fee_protocol_token_y: Decimal,
    pub seconds_per_liquidity_global: Decimal,
    pub start_timestamp: u64,
    pub last_timestamp: u64,
    pub oracle_address: Pubkey,
    pub oracle_initialized: bool,
    pub bump: u8,
}```
also https://github.com/project-serum/anchor/issues/1255 <@!347689664855015424>
sek
how does your struct look like?
ah ok!
yeah i am trying clean repo <@!812755783405797376>
https://github.com/project-serum/anchor/pull/1199
v.0.20.0 isn't backwards compatible
it seem like there is problem with deserialization
Anyone tried v0.20.0 zero_copy ?
How do I make `declare_id!` conditional on devnet or mainnet? Ive tried setting them specifically in Anchor.toml but perhaps I missed some step
what do you mean?
What is instructions param in program?
How can one use anchor init to initialize a TokenAccount at a PDA? 

Edit: you need to use init + seed + token:: constraints
correction: the one case where you do need it is when initializing accounts owned by the token program
Nice! Thanks
by using the `associated_token` constraints https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html#spl-constraints
How do I assert that a given account for the instruction context is an Associated Token account?
however when I try to build, I get many such errors...? Any help would be much appreciated! What's the right way to do this? üôÇ
this is my cargo.toml file for my program.
Hi there! I'm trying to integrate with serum-dex and the serum-swap program. More specifically, I want to perform a swap from inside my rust program on the serum-dex. For this I'm trying to do cpi calls to the swap program, but have some trouble importing the dependencies. For that I have cloned https://github.com/project-serum/swap inside a deps folder in my project and done all the steps in its readme.
Hi, still learning the ropes on anchor.   I would like to define struct in external crate because it would be used in instructions of different programs. Is it possible ? Thanks
you can init without passing in rent
it's not
Gotcha, that makes sense!
except for rent which is needed for creation
I think so, since they released that feature i never pass in sysvars
Lmao, so it sounds like 2 is ... better in every sense?
2. means you save an account üòÑ
Also another question - 

What's the difference between the following two ways of retrieving the system time?

1. Passing in a system clock account
```
#[derive(Accounts)]
pub struct Test<'info> {
    clock: Sysvar<'info, Clock>,
    ...
}
```

2. Directly using `Clock` in the instruction handler
```
    let clock = Clock::get()?;
    if time_x <= clock.unix_timestamp {
        ...
    }
```
Have you checked out the documentation for the token program? https://spl.solana.com/token#example-creating-your-own-fungible-token
is there any resource for custom token creation?, Anyone.
Hi <@!561794511005548545> , i'm also searching for the similar case here, i want to create a custom token for an user and the token should not be able to transfer from the user account by the user, only the mint authority can. like wise am looking out, do you have any idea?, can you share me any resource you know that be much useful, regarding the custom token creation. thanks in advance.
Hi All - Got a question about some account constraints like the following example:

```
#[derive(Accounts)]
#[instruction(index: u8)]
pub struct FooBar {
  #[account(constraint = myAccount.data[index as usize]).authority == authority.key()]
  pub myAccount: Account<'info, MyAccount>,
  pub authority: UncheckedAccount<'info>,
  ...
}

#[account]
pub struct MyAccount {
  data: [SomeStruct::default(); 5],
  ...
}

pub struct SomeStruct {
  authority: Pubkey,
  ...
}
```

**Questions**
1. If the instruction is called with an `index` that is out of bounds of `MyAccount.data[]`, is it kosher to have the constraint fail with the code as-is?

2. Any preferred / better ways to handle the error?
Ok
this is for account validation, if you leave out bump and seeds it will not check that this is a PDA with this seeds and bump
https://discord.com/channels/428295358100013066/689412830075551748/928812009737302047
what is this replay that anatoly mentions here
what happen if I do not provider `bump` value? like following
You can PR to web3.js and add it on the underlying @solana/web3.js
Shouldn't there be a `SYSVAR` in `anchor.web3` for `SLOT_HASHES`? There isn't one: https://project-serum.github.io/anchor/ts/modules/web3.html#SYSVAR_CLOCK_PUBKEY
I would use `SYSVAR_RECENT_BLOCKHASHES_PUBKEY` but that is apparently deprecated: https://docs.rs/solana-program/1.9.3/solana_program/sysvar/recent_blockhashes/struct.RecentBlockhashes.html
How much can we trust `simulateTransaction` ü§î
The only two things I can think of:
1) call getTransaction after tx is executed and parse compute units from logs
2) call simulateTransaction as it has `unitsConsumed` response value
literally about to ask the same!
How do people profile consumption of compute units when optimizing your solana instructions?

I'm parsing it from the tx logs but I'm curious if there is a better approach.
Much appreciated!
Thank you!
Is there a js wallet to use ?
like a web3 js wallet to send nfts
send tokens etc


///////////////////////////////////////////////////////////////////////////////////////////////

im not sure anchor checks this
it works in lib.rs but not in my utils.rs file. I just found the error. ID is available when the program macro is called. i'll stick to context `ctx.program_id`. thanks again
Interesting. Not sure about the details honestly, but if ctx.program_id works you're good
it's included, just not working
probably part of `use anchor_lang::prelude::*;`
haha üòÜ thanks guys. I was using `ctx.program_id`. but I was trying to use `ID` but I couldn't find the import location
actually can you confirm that ctx.program_id == ID?
but now kayandra is fully convinced
ah was already answered
`ctx.program_id`
I think this is the address of the program, similar to `ctx.program_id`
Perfect thanks! Is it also possible to get the number of instructions remaining after the current one?
it is available in the context passed to endpoints: `ctx.program_id`
https://github.com/metaplex-foundation/metaplex/blob/master/rust/nft-candy-machine-v2/src/lib.rs#L694
https://github.com/metaplex-foundation/metaplex/blob/master/rust/nft-candy-machine-v2/src/lib.rs#L363
Is there any way to count the number of instructions in the txn? I've heard it's possible using SysvarInstructions but not sure how to
Thanks
Hi, Could you help me?
require!(
            *claim_status.to_account_info().owner == ID,
            OwnerMismatch
        );
What is ID in this code? (this code is part of merkle distributor)
is there an easy way to change feePayer in the test program calls?
what is the idiomatic way to get the id of the current program
can you bring accounts and mints from mainnet for testing with anchor? in test.genesis?
Is there any function like "mapping" in ether?
cargo.toml
where does this go
will repr(packed) continue to be supported in the future?
right!
So I'll have to check if the associated account is allocated on the client and if its not already there I'll have to add a additional instruction to do so correct?
no, you'll have to do that
What happens when the SPL token program transfers tokens to another owner if there is no allocated associated token account with that owner? Does the program automatically initialize the account?
Nice! Thank you üôÇ
This is great, thank you! For anyone else looking, there is also a devnet version https://api-devnet.solscan.io/token/holders?token=YOUR_TOKEN
or you can use the createAssociatedTokenAccountInstruction
there's a `getOrCreateAssociatedTokenAccount` method
you can use the solscan API https://public-api.solscan.io/docs/#/Token/get_token_holders
Could you do something like this?
```import { Keypair } from 
'@solana/web3.js';
const kp = Keypair.generate();```
How do I create an associated token account keypair on the client?
is there a way to get the token balance for all holders (for a given token)?
Wrote this to parse compute from logs https://github.com/drift-labs/protocol-v1/blob/master/sdk/src/util/computeUnits.ts#L3
might give you some info. I'm in a position right now where my state account works, even though it contains bools which apparently aren't supported, but if I add e.g. a u64 it will not work. It's precarious
https://discord.com/channels/889577356681945098/889577399308656662/928405042434818128
Check out the messages starting here
<@!111233596173373440> think Im having the same issue that you have here(https://github.com/project-serum/anchor/issues/1241) re: msgs above
bumping this, it's a good question
This is on a zero-copy acc with a fixed length array
but when I am fetching accoutn from localnet, it shows that account's data didnt get updated
account gets updated on rust side and txs work everywhere
*error
after upgrading to anchor 20.0, having a very weird errr
Can you explain this one a bit? Why does it have to be inline?

i upgraded to the latest version .20 where the anchor.Wallet was supposed to be fixed from this PR (https://github.com/project-serum/anchor/pull/1137) but i still getting the error
anyone know of an easy way to use the `dataSlice` parameter of the `getAccountInfo` RPC call over the js web3 library.  It looks like it isnt exposed, nor is there an obvious way to hack it in.
`program.rpc`, `program.transaction`, `program.instruction` all behave similarly, but return different things - each a bit more fine grained than the previous.  `rpc` handles the siogn and send - but you want to handle this yourself instead.
use `program.transaction.sometMethod` to create the transaction, then sign it using your wallet adapter.
as we only have a public key
solana wallet adapter uses `sendTransaction(transaction, connection)` method to automatically sign transaction with adapter.
i have this piece of code for execution of rpc method `  let tx = await program.rpc.sometMethod(
    new anchor.BN(amountInLamports),
    userAccountBump,
    {
      accounts: {
        user: anchorWallet.publicKey,
        userProgramAccount,
        systemProgram: anchor.web3.SystemProgram.programId,
        serviceAcc1p: serviceAccount1p,
        serviceAcc25p: serviceAccount25p,
      },
      signers: [xxxxxxxxxxxxxxxxxxx],
    }
  );`

but how do i sign this with solana wallet adapter as this is not transaction object, it's method rpc.
how does someone use solana wallet adapter with anchor lang?
yes
oh on the client side? 
So calling two separate instructions in the same transaction
you can do both in the same tx


///////////////////////////////////////////////////////////////////////////////////////////////

I try ubuntu and windows
when i run anchor deploy
i can't pass error `Recover the intermediate account's ephemeral keypair file with
`solana-keygen recover` and the following 12-word seed phrase:`
Does the serum-dex crate only work with solana program = 1.7.8 and will this be updated to support later versions?
but was present on 1.9.1
it disappeared for me with 1.9.4
was an issue with 1.9.4 ^
not sure  what's up with that
anyone seeing a bunch of `msg <hash>` when using `solana program deploy` ?
getMultipleAccount, then decode the mint account
Is best practice to just try to add as many logs as possible in the devnet deployment?
Sooo, what are some good debugging practices you guys use? I'm deployed on devnet right now because testing my current project would be difficult locally
rn using a loop, which doesn't seem super efficient ```mint.getSupply()```
is there an efficient way to get the supply for a list of 30+ tokens in typescript?
i rarely use anchor test
it was set to cluster = "devnet"
lol
you'll need to add test genesis for other binaries tho
at least for your native program
doesn't it already do so <@!831450660146642974>
rather than embedding at genesis
Why is `anchor test` deploying the program? That sounds quite an inefficient thing to do
Consuming more compute units?
Whats the drawback of having to box some accounts?
Thank you so much
bump on this problem, im not using any option nor bool, and also tried aligning everything to 8 bytes, seems like anchor's decoding results are not aligning well with the new repr C, everything deserializes fine on solana since I'm able to println inside the ix the right data, so it's only on anchor's side; that's why I was asking about reprC <@!347689664855015424>
So if you‚Äôre already using packed you‚Äôd just use an older version of rust once its removed?ü§î
so use it at your own risk
but packed will be removed from rust
we are adding a feature so you can use whatever alignment you like on zero_copy
someone can help me to add a external signature to a tx? I was doing that all today but nothing works.. keep getting me error signature.. I'll share my code with whoever can help me to resolve this (the tool i'm making is very helpful)
thought to bump thiis question
hey is there anyway to copy mints from mainnet for testing on testneT?
so you need double an additional `--` before your args. e.g. `anchor build -- --my_feature`
`<CARGO_ARGS>...    Arguments to pass to the underlying cargo build-bpf command`
`anchor build --help` is your friend!
One more tiny little disturbance üòÖ . How do i pass rust features to `anchor build`? or is `cargo-bpf` the way to go?
happens to the best of us üôÇ
<@!347689664855015424> <@!915682383905316864> thank you for helping out. I figured the error.

I'm actually running a test suite and another instruction gets called at the end of the tests. Its context also needed `mut`. It's really a dumb oversight on my part as I had been using the provider wallet all along for testing. Thank you!
yes
transfer is just the system program transfer?
gotcha! thanks
this saves compute
instead of using `to_account_info()`
unrelated but you can just use `key()` on hash_account
gotcha, I've made the signer `mut`, but get a new error
I created a PDA for the `hash_account` to hold data I've omitted for the sake of brevity
there's a feature coming that informs you that you need `mut` on the `payer` when using `init`
so this happens because `init` requires `mut`. But if you pass in the provider wallet, it will be mut because it pays for the tx and is therefore mut even if your program doesnt check it. But a random signer will not be mut
adding `mut` on `authority` changed the error to 

```bash
Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: instruction changed the balance of a read-only account
      at Connection.sendEncodedTransaction (/home/hugs/batcave/bett/node_modules/@solana/web3.js/src/connection.ts:3689:13)
      at processTicksAndRejections (internal/process/task_queues.js:95:5)
      at Connection.sendRawTransaction (/home/hugs/batcave/bett/node_modules/@solana/web3.js/src/connection.ts:3649:20)
      at sendAndConfirmRawTransaction (/home/hugs/batcave/bett/node_modules/@solana/web3.js/src/util/send-and-confirm-raw-transaction.ts:27:21)
      at Provider.send (/home/hugs/batcave/bett/node_modules/@project-serum/anchor/src/provider.ts:118:18)
      at Object.rpc [as closeHash] (/home/hugs/batcave/bett/node_modules/@project-serum/anchor/src/program/namespace/rpc.ts:25:23)
```
lol
no *my* bad lol!
right üòÑ my bad
not like this is the feature I'm working on...
yes
`init` requires `mut` on the `payer`
even if he wasnt making a transfer. It should be `mut`
here it is a signer, but you are also making a transfer from it, so it gets mutated
that might not be it though. I think you are missing the `mut` attribute to your `authority` account
any reason to pass `hash_account` as CPI signer?
```bash
Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account 
    Program DEVqgUD6yMqWGwdaER6PvXpr5Sqhb6m2MD15i61S1jq2 invoke [1]
    Program log: Instruction: Launch
    FjTdPmko591oqc3CWpgcPK3ocPLj5HjwpEZHttHmFMvi's writable privilege escalated
    Program DEVqgUD6yMqWGwdaER6PvXpr5Sqhb6m2MD15i61S1jq2 consumed 8657 of 200000 compute units
    Program DEVqgUD6yMqWGwdaER6PvXpr5Sqhb6m2MD15i61S1jq2 failed: Cross-program invocation with unauthorized signer or writable account
```
a second
can you show the log output?
<@!915682383905316864> could you possibly help?
This does the fetching in 1 call
Notably I am fetching only ATAs, and not **all** token accounts. But if you want all then you could simply remove the filtering.
I did something similar back then. This is mostly pumped from somewhere and I forgot where (maybe serum?), but it should be a good start for you to tweak as you need: https://gist.github.com/losman0s/1465cda3807b2c79eb2967b439393d43
glad to be of help
ok thank you. i will try that!
For this, since you have to individually check each account controlled by the wallet to know the account balance, I believe you can send the wallet address to the backend instead and have that do the aggregation for you?
but it fails if i pass in a random signer. `can_sign` right now just returns true for all cases. But once i pass in the provider wallet as the signer, the function call succeeds. I'm curious why this happens
I have this seemingly na√Øve endpoint

```rust
pub fn launch(ctx: Context<Launch>, bump: u8) -> ProgramResult {
    let authority = &ctx.accounts.authority;
    let hash_account = &mut ctx.accounts.hash_account;

    invoke(
        &transfer(
            authority.key,
            hash_account.to_account_info().key,
            1e9 as u64,
        ),
        &[authority.to_account_info(), hash_account.to_account_info()],
    )?; 

    Ok(())
}
```

With this context

```rust
pub struct Launch<'info> {
    #[account(
        init,
        payer = authority,
        space = HashAccount::space(),
        seeds = [b"hash", authority.to_account_info().key.as_ref()],
        bump  = bump
    )]
    pub hash_account: Account<'info, HashAccount>,

    #[account(
        constraint = can_sign(authority.to_account_info().key) @ HashError::InvalidSigner
    )]
    pub authority: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```

which is triggered like this:

```javascript
await program.rpc.launch(verificationSeed, bump, {
  accounts: {
    hashAccount, // generated PDA
    authority: signer.publicKey,
    systemProgram: anchor.web3.SystemProgram.programId,
  },
  signers: [signer],
});
```
is it possible to get the user's balance for all tokens (or a list of tokens) on the frontend? right now I'm looping using this for about 32 different mints (using easy-spl module)
```mint.getBalance(userAddress)```
but it feels like there should be a more efficient way
thanks again!
https://github.com/metaplex-foundation/metaplex/blob/d6fd7f1075ea3d875bc57668f020cd1933c450e8/rust/nft-candy-machine-v2/src/lib.rs#L344


///////////////////////////////////////////////////////////////////////////////////////////////

