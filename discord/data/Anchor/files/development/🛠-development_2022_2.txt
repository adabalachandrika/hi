Hi, I want init anchor project, but return a yarn error, but yarn is installed from npm install --global yarn, know about this?
Hey guys, I am getting this error while deploying the program to devnet. using this command

anchor deploy --provider.cluster devnet


but deployment on localnet is working good. The .so file is of 550 KB and the devnet account has around 38 SOLs
i'm running into a weird issue where my tests seem to pass wether or not i pass signers to the rpc calls

e.g. i have `pub authority: Signer<'info>,` set properly but passing `signers: []` on the client is succeeding. any thoughts around how to enforce this if i'm doing something wrong?
this is the repo
https://github.com/sohomx/messengerapp
shall I deploy it in github and can u look into it give me a sec
That error means you're somehow trying to talk to the wrong program id. Maybe your Anchor.toml is wrong, or maybe you forgot to deploy it, etc.
Heyy <@!134416332509675520> I am facing this error again since yesterday
Sorry, I don't think I have enough info here to spot the error, you'll need to just explore that stack trace above
<@!134416332509675520>
from console.log on javascript
```json
{
  type: 'createUser',
  userNonce: 254,
  user: {
    _bn: 'ffcdfe9d12509695e528073036a6eee8a259ff08de238d4669c761f9e40ef19c'
  },
  pool: {
    _bn: 'ac635bfd693d6251fb2083c06f1ffcacfe6a0c2e57221cadb10c7868e1e88e1b'
  },
  owner: {
    _bn: 'e8a696776bc353c08da1c579bcbb906bbafd320f9b1d0b7dd8cc058179c326e6'
  },
  systemProgram: { _bn: '00' },
  walletAdapter: {
    publicKey: {
      _bn: 'e8a696776bc353c08da1c579bcbb906bbafd320f9b1d0b7dd8cc058179c326e6'
    }
  }
}
```
Are they instances of `PublicKey` etc.?
No, I mean what do they look like as javascript values?
from program .rs
```json
#[derive(Accounts)]
#[instruction(nonce: u8)]
pub struct CreateUser<'info> {
    // Stake instance.
    #[account(
        mut
    )]
    pool: Box<Account<'info, Pool>>,
    // Member.
    #[account(
        init,
        payer = owner,
        seeds = [
            owner.key.as_ref(), 
            pool.to_account_info().key.as_ref()
        ],
        bump = nonce,
    )]
    user: Box<Account<'info, User>>,
    owner: Signer<'info>,
    // Misc.
    system_program: Program<'info, System>,
}
```
That STAKE_PROGRAM key looks fine to me
And are all of those `instruction.whatever`s public keys?
``` 
export const  STAKE_PROGRAM = '5ThNAAvbN1gy3yVfT1KyYRppi1NeicixbgA4BvW8WDbH';
```
What is the value of `STAKE_PROGRAM` here?
Probably that `new PublicKey` line
```json
export const createProgramInstruction = async( instruction: any ): Promise<any> => {
    const programID = new PublicKey(STAKE_PROGRAM);
    const connection = new Connection(SOLANA_NETWORK_URL);
    console.log(instruction, SystemProgram.programId);
    console.log(instruction.walletAdapter);
    const instructionWalletProvider = instruction.walletAdapter;
    const provider = new Provider(connection, instructionWalletProvider, {commitment: 'recent'});
    const program = new Program(idl, programID, provider);
    // createUserStake
    if( instruction.type === 'createUser' ) {
        return await program.instruction.createUser(instruction.userNonce, {
            accounts: {
                pool: instruction.pool,
                user: instruction.user,
                owner: instruction.owner,
                systemProgram: SystemProgram.programId,
            },
        });
    }// end createUser
}
```
You'll need to show more code, I can't see enough in that screenshot
but i apply the signature and obtain the error
```json
Error: Non-base58 character
    at Object.decode (index.js:115:1)
    at new PublicKey (index.browser.esm.js:95:25)
    at index.browser.esm.js:754:1
    at Array.forEach (<anonymous>)
    at Transaction.compileMessage (index.browser.esm.js:752:1)
    at Transaction._compile (index.browser.esm.js:872:1)
    at Transaction.serializeMessage (index.browser.esm.js:894:1)
    at Wallet.<anonymous> (index.js:188:37)
    at Generator.next (<anonymous>)
    at index.js:7:1
```
<@!134416332509675520> i use the program.instruction and return that
`init_if_needed`, though you have to be a bit careful when you use it (people often suggest not using it and just writing two separate handler functions)
Hey!
Is it possible to define an account as "init new if it doesn't already exist" ?
```
    #[account(
        initOrOpen,
        seeds = [seme_seeds],
        bump = some_bump,
        payer = authority,
        space = ...
    )]
```
Now I have to implement two instructions, like  "InitNewAccount" and "UpdateNewAccount"...
Thank you!
is possible use anchor library on angular component?
<@!134416332509675520>  ^
^ this is me

I have a handler function and InitVault context in the same fine. I can do `vault::init::handler`, but I can't do `vault::init::InitVault`?

```rust
#[program] 
mod accrue {
    use super::*;

    /*  VAULT INSTRUCTIONS  */

    pub fn init_vault(
        ctx: Context<vault::init::InitVault>, 
    ) -> ProgramResult {
        vault::init::handler(
            ctx, 
        )
    }
```
Yeah exactly, Init is a declare(Accounts) within the vault crate
What's the error ü¶Ä
Guessing since not 100% sure what you want to do, but does it not work to just do `vault::Init`?
That's not the expected type (are you saying `Init` is a declare(Accounts) inside the vault crate?)
ReferenceError: Cannot access 'StakeModule' before initialization
i try to import anchor on my angular project, but i have a error
morning
I tried your suggestion, but this time it gives another errorü§¶üèª‚Äç‚ôÇÔ∏è
I've been stuck on this problem for a very long time:

```rust
use vault::*;

mod accrue {
    use super::*;

    /*  VAULT INSTRUCTIONS  */

    pub fn init(
        ctx: Context<Init>, 
    ) -> ProgramResult {
        crate::vault::instructions::init::handler(
            ctx, 
        )
    }
```

The code above works, but if I replace `Init` with `crate::vault::instructions::init::Init`, it doesn't work. It gives me this error:
```unresolved import `crate`

could not find `__client_accounts_vault` in the crate rootrustc(E0432)

lib.rs(13, 1): could not find `__client_accounts_vault` in the crate root```
umm intresting :)))))))))))))
`anchor test` will spin one up for you if you don't already have one running (I never start my own)
why is my compute units getting consumed
logs: [
    'Program DwRPVvFn8a2AqXv8skZxJRp2PRrUqEq9mDzJ7CBaBqKo invoke [1]',
    "3p3u6FuXu2xWD7dYcTdr75pMxvk3E2j2Zztqk5a52cVP's writable privilege escalated",
    'Program DwRPVvFn8a2AqXv8skZxJRp2PRrUqEq9mDzJ7CBaBqKo consumed 200000 of 200000 compute units',
    'Program DwRPVvFn8a2AqXv8skZxJRp2PRrUqEq9mDzJ7CBaBqKo failed: Cross-program invocation with unauthorized signer or writable account'
  ]
Please help. Error that i get is following
await program.rpc.sendTokens(
            amountToSend,
            vault_account_bump,
            {
                accounts: {
                    user: userMainAccount.publicKey,
                    mint: tokenKey,
                    userAccount: ata,
                    vaultAccount: vaultTokenAccountA,
                    vaultAuthority: vault_account_pda,
                    payer:payer.publicKey,
                    systemProgram: anchor.web3.SystemProgram.programId,
                    rent: anchor.web3.SYSVAR_RENT_PUBKEY,
                    tokenProgram: TOKEN_PROGRAM_ID,
                    associatedTokenProgram : ASSOCIATED_TOKEN_PROGRAM_ID
                },
                signers: [payer],
            }
        );
JS test :
pub fn send_tokens(ctx:Context<SendTokens>, token_amt : u64, vault_authority_bump : u8) -> ProgramResult {

        anchor_spl::token::transfer(CpiContext::new(
            ctx.accounts.token_program.to_account_info(),
            anchor_spl::token::Transfer {
                from: ctx.accounts.vault_account.to_account_info(), // program's pool containing y-token
                to: ctx.accounts.user_account.to_account_info(), // user's y-token account
                authority: ctx.accounts.vault_authority.to_account_info(), // this program
            },
        ), token_amt)?;

        Ok(())
    }
#[derive(Accounts)]
#[instruction(user_token_amt: u64)]
pub struct SendTokens<'info> {

    #[account(mut)]
    pub user: AccountInfo<'info>,
    pub mint: Account<'info, Mint>,
    #[account(
        init, 
        payer = payer,
        associated_token::mint = mint,
        associated_token::authority = user,
    )]
    pub user_account: Account<'info, TokenAccount>,

    #[account(mut, constraint = vault_account.amount >= user_token_amt)]
    pub vault_account: Account<'info, TokenAccount>,
    pub vault_authority: AccountInfo<'info>,
    pub payer: Signer<'info>,
    pub system_program: AccountInfo<'info>,
    pub rent: Sysvar<'info, Rent>,
    pub token_program: AccountInfo<'info>,
    pub associated_token_program: AccountInfo<'info>,
}
Guys facing issue trying to send SPL token from vault (owned by PDA) to user's associated token account.
if yes, then you need to start solana test validator üôÇ
are you on localnet?
Hello, when I run "$anchor test" it says "Unable to start test validator" and doesn't give me the signature. Even there isn't any solana-test-validator commands running anywhere.

Who can help me. I am in the buildplace platform for learning Solana but I have stopped learning because of this problem üò¢üò¢
ummm, isn't `init_if_needed` mean `init` an account if it's not, else `mut` it.
lol
init_if_needed might cover up the root cause here. Unless you know that you've already created the account and specifically want it to fail gracefully anyway on a second init, i'd be careful. <@!248066053161222144> beat me with a stick for trying to use it.
`Allocate: account Address { address: BpWibez93uM4hdcTPJ8iCicBBgSUMjRgZa7u8mSeiunq, base: None } already in use`
<@!515604356226220043> you are trying to create an already existing account, try `init_if_needed`
OK, i'll let someone that known what they're talking about respond üôÇ . Just thought i recognized that error.
no. `node client.js`
Is this happening when you're running anchor test?
if i were you, i'd reboot just to make sure üôÇ . I might be misremembering what the fix was though.
no solana program is running üòÖ
For some reason, the m1 occasionaly hangs a build/test from what i can tell.
At least I think thats what I remember.
I ran into this issue, and the fix was to 'ps ax' and look for a still running solana program, kill it.
yes
are you on m1?
hi, i was trying to `Initialize` but there is a error

`Transaction simulation failed: Error processing Instruction 1: custom program error: 0x0 
    Program 11111111111111111111111111111111 invoke [1]
    Program 11111111111111111111111111111111 success
    Program hck8BPUoo8mYFQYppnjePstEricv2v2uZp9LAXKz invoke [1]
    Program log: Instruction: Initialize
    Program 11111111111111111111111111111111 invoke [2]
    Allocate: account Address { address: BpWibez93uM4hdcTPJ8iCicBBgSUMjRgZa7u8mSeiunq, base: None } already in use
    Program 11111111111111111111111111111111 failed: custom program error: 0x0
    Program hck8BPUoo8mYFQYppnjePstEricv2v2uZp9LAXKz consumed 10835 of 200000 compute units
    Program hck8BPUoo8mYFQYppnjePstEricv2v2uZp9LAXKz failed: custom program error: 0x0`

any fix?
is there any lifehacks of how can I reduce size of .so file? 
Because I had one .rs script (his weight was around 29 KB), I changed him and decrease his size to ~20 KBs, but size of my .so file hasn't changed, but even increased. what the hell? üòê
cant find it anywhere in the anchor library
does anyone know what this #[index] macro does in an #[event] struct?
ty ty
https://support.solanium.io/support/solutions/articles/69000377685-error-processing-instruction-1-custom-program-error-0x1
maybe i can double check but ty for the help, pretty sure it has something to do with that but the compute budget being maxed out is what's throwing me off
yep
And deploying on solana cost 1-2 sol
yep made sure to airdrop the wallet keypair automatically generated at the start of the test.js file that i have
I believe that anchor test redeploys the program
and have you enough sol in your wallet ?
yes okay
type "solana config get"
which uses a local-test-validator
using the anchor test command
hmm I'm a very beginner but are you trying to do your test on your local network ? Or testnet ?
no, unfortunately not getting anything like that. i'm getting a 0x01 error and a compute budget maxout error, and have a very poor idea why it's happening. think it has something to do with the anchor-test-validator that gets started but i could be completely wrong about that
I'm interested by the answer too, have you "unknown signer" error like me ?
hi everyone, having problems because after running anchor test a few times all of a sudden the compute budget was maxed out. is it because the program is being upgraded everytime i run anchor test? how would i go about fixing this?
actually it was an edgecase where i did a division by 0.. but managed to find it fast
I fixed it, actually, the problem is with space, need to provide more space üôÇ
hey @here, i hope you doing great can you tell me is there any guide available for making a two faced token like it should be a utility also a governance one? is there any material available for this ?
Hi guys, suggest me which way is best for doing looping an array of counts in js/rs?
    1. to have a loop on js and call the contract function multiple times (or)
    2. send the entire array to the contract from js and have a loop inside the contract
    which one is efficient and less gas fee?ü§î
i see we can update version but coming from eth, i usually separate contracts so i can update logic by deploying a new one if needed.  should i be doing this with cosmwasm
how simple is upddating contracts
though you can make a script, a bash one I guess üôÇ
I don't think so
I'm getting this error `AccountDidNotSerialize`, how I can resolve this?
any insights <@!134416332509675520>
hi team, what's the best way to get around the whole declare_id issue where you need to build to get the id, then you need to put it in the rust file and then build again? Surely there's a better solution that having to build twice?
Hey so the issue is I believe there are bundlers that do funny things to the sha256 library - we just tested the difference in the outputs on a development server and production build (For vite) - and it just produces a different instruction header in the ts client for the same instruction name.

Webpack seems to work ok though.

https://github.com/project-serum/anchor/blob/master/ts/src/coder/borsh/instruction.ts#L390

This is where the magic happens: Probably related to this but not going to investigate further

https://stackoverflow.com/questions/55700453/sha256-different-values-for-same-string
If you have an account with a vector field, ex. `some_field: Vec<string>`, it seems to be allowed. But accounts have to allocate a certain amount of memory when they are instantiated, but vectors are unbounded. why can you use `Vec` given that it is unbounded, how does that work given accounts size limitations (have to declare size upfront)?
what's in the log?
Can't anyone help me? üò¢
HI! I'm getting the following error when trying to deploy to devnet 

Error: Program's authority Some(7SqDpz1jU4prvk44F9BSgMPqjFTnKZFTua6qsaBz88Zb) does not match authority provided FJhdob1QFRnFhcCNnn17spFY1nqV4cXmVeGivBQtTrfT

How can I make it match the authority?
I've been stuck on this problem for a very long time:

```rust
use vault::*;

mod accrue {
    use super::*;

    /*  VAULT INSTRUCTIONS  */

    pub fn init(
        ctx: Context<Init>, 
    ) -> ProgramResult {
        crate::vault::instructions::init::handler(
            ctx, 
        )
    }
```

The code above works, but if I replace `Init` with `crate::vault::instructions::init::Init`, it doesn't work. It gives me this error:
```unresolved import `crate`

could not find `__client_accounts_vault` in the crate rootrustc(E0432)

lib.rs(13, 1): could not find `__client_accounts_vault` in the crate root```
Unable to start test validator

Hello, I have a problem with the : anchor tes
Interesting, anything else in the log?
Not sure, never used angular before
question, my program is working well on devnet but on mainnet i get `Program failed to complete: BPF program panicked`, what could be?
<@!134416332509675520> thanks
is happening every time I initialize something from the @project-serum/anchor library... should I add something to the angular module?
core.js:6456 
        
       ERROR Error: Uncaught (in promise): ReferenceError: Cannot access 'StakeModule' before initialization
ReferenceError: Cannot access 'StakeModule' before initialization
```json
import { Program } from '@project-serum/anchor';
import { idl } from '../commons/stake-idl';
@Component({
  selector: 'app-stake',
  templateUrl: './stake.component.html',
  styleUrls: ['./stake.component.scss'],
  providers: [CurrencyPipe]
})
export class StakeComponent implements OnInit {
ngOnInit(): Promise<void> {
  const programId = this.programId;
  const program = new Program( idl, programId.toString() );
}
}
```
anchor have a example for use the anchor on angular component?
any ideas on if this kind of upgrade is safe? üëÄ
nice, i will try, thanks bro!
But with the right sighash etc.
ok! i will try
It returns an instruction
This returns me some value to be able to make a signature?
and then try to sign that with the wallet adapter
Just do `program.instruction.createUser`
But again I really don't think you should be manually building the instruction like that
<:harri:534077395020283915>
for noob
Why are you using instruction: 1?
You're still missing the 8 byte sighash
No, not the same
is the same that:
I thought we were trying to debug it lol

But I need to know more about what you've tried/what errors you're getting in order to be able to help
but is work
They will work, you're just doing something wrong
No‚Äîyou should really try to get it working with the built-in anchor helpers üòõ
same that? 
```json
const dataLayout = struct([u8('instruction'),u8('nonce')]);
```
Can you give me more info? Error messages, etc.
i use this but on my back-end and it works fine. My problem starts when any wallet wants to sign a transaction... In my anchor test it works correctly, but in my front-end it doesn't
At any rate, the reason why your manual instruction stuff isn't working is because you haven't included the 8 byte sighash at the beginning of the instruction data (the anchor stuff does this for you, but you're doing it manually)
Or `program.rpc.doSomething`, etc.
`program.instruction.doSomething`
Then yeah, why can't you use the built-in anchor support for invoking your contract?
WalletAdapter, solflare, sollet, phamton, etc
I'm not sure what an adapter is
yes!
But is the contract an anchor program?
this instruction can call my adapter to sign? I do it this way, because it is a stake contract, where different users must interact with the contract
Not building the instruction manually yourself
If it's your own anchor program, you should presumably be doing something like `program.rpc.doSomething`

<@!134416332509675520>
I want to interact with my contract, from the wallet adapter, to sign the transaction from my front-end
Why are you building the instruction manually like that?
0x64 = 100 (so you're using a slightly old version of anchor) = you aren't building your instruction correctly
Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: custom program error: 0x64
    at Connection.sendEncodedTransaction (index.browser.esm.js:4814:1)
    at async Connection.sendRawTransaction (index.browser.esm.js:4773:1)
Have you actually posted the error?
i need sign the transaction with my Adapter, and i obtain a instruction error. But on javascript test, work fine
```json
  async signature (wallet: WalletAdapter,
    transaction: Transaction,
    signers) {
    // console.log('transaction', transaction);
    const hash = await this.connection.getRecentBlockhash('max');
    // console.log('blockhash', hash);
    transaction.recentBlockhash = hash.blockhash;

    transaction.setSigners(
      // fee payed by the wallet owner
      wallet.publicKey,
      ...signers.map((s) => s.publicKey),
    );

    if (signers.length > 0) {
      transaction.partialSign(...signers);
    }

    const signedTrans = await wallet.signTransaction(transaction);
    // console.log('sign transaction', signedTrans);
    const signature = await this.connection.sendRawTransaction(signedTrans.serialize());
    // console.log('send raw transaction', signature);
    return signature;
  }
```
```json
  async createStakeAccountInstruction( pool: Pools ) {
    const programId = this.programIdMola;
    const dataLayout = struct([u8('nonce')]);
    const [
      _userPubkey, _userNonce,
    ] = await PublicKey.findProgramAddress(
        [this.walletAdapter.publicKey.toBuffer(), new PublicKey(pool.pool_address).toBuffer()],
        programId
    );
    const userPubkey = _userPubkey;
    const userNonce = _userNonce;
    console.log( userPubkey.toString() );
    console.log( userNonce );
    const keys = [
      { pubkey: new PublicKey(pool.pool_address), isSigner: false, isWritable: true },
      { pubkey: userPubkey, isSigner: false, isWritable: true },
      { pubkey: this.walletAdapter.publicKey, isSigner: true, isWritable: false },
      { pubkey: SystemProgram.programId, isSigner: false, isWritable: false }
    ];
  
    const data = Buffer.alloc(dataLayout.span);
    dataLayout.encode({ nonce: userNonce }, data);
  
    return new TransactionInstruction({ keys, programId, data });
  }
```
I have a problem, when calling an instruction from my web3. Can anybody help me?

```json
async disMissFunction(reason: any, pool?: Pools){
const transaction = new Transaction();
const createUserInstruction = await this.createStakeAccountInstruction(pool);
transaction.add(createUserInstruction);
const signers = [];
          const signature = await this.signature(this.walletAdapter, transaction, signers);
          this.toastService.show(`Transaction`, { tx: signature, classname: 'bg-success text-light', delay: 10000 });
          await SolanaUtils.confirmTransaction(this.connection, signature);
          this.toastService.show(`Confirm`, { tx: signature, classname: 'bg-success text-light', delay: 10000 });
          let result = await SolanaUtils.getTransacionStatusUntilFinish(this.connection, signature);
          if (result === 'success'){
            this.toastService.show(`Complete`, { tx: signature, classname: 'bg-success text-light', delay: 10000 });
          }
          console.log(this.myForm.value.amount);
}
```
hi
thanks
I figure out that my declare ID is not a good one
Hey! Trying to use Ledger hardware wallet with Anchor. Can it be done without React? Any example or tuto?
isMut the same to isWritable? on a instruction
Mm, what kind of PDA stuff are you doing? Are you sure your declare_id! is correct?
Hello everyone, I'm trying to build a program with anchor. I've wrote it and manage to make it work on localhost. Now I'm trying to launch it on devnet and I'm stuck on this error:
Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account 
    Program 7W5Tbkhvqpu7MdYd6KSwa8BQdFqthfivMuMaxqZCEJjg invoke [1]
    7rjJvtUsd6ngmxTF2LNibrurbDy41F9q9ZXrGwbYMBEx's signer privilege escalated
    Program 7W5Tbkhvqpu7MdYd6KSwa8BQdFqthfivMuMaxqZCEJjg consumed 8049 of 200000 compute units
    Program 7W5Tbkhvqpu7MdYd6KSwa8BQdFqthfivMuMaxqZCEJjg failed: Cross-program invocation with unauthorized signer or writable account.
I got this error only on devnet. Is that something i'm missing?
Please help me ..
i.e. 

```
pub struct FooList {
    pub account_padding: [u8; 512],
    pub foos: [Foo; 8]
}

pub struct Foo {
    pub bar: u128
}
```

upgraded to:

```
pub struct FooList {
    pub account_padding: [u8; 384],
    pub foos: [Foo; 8]
}

pub struct Foo {
    pub bar: u128,
    pub buzz: u128
}
```
yes except u can use `.lamports()` on the AccountInfo instead of `lamports.borrow()`
something like this? `if ctx.accounts.signer_flip_pda.lamports.borrow() < lamports {}`
In your rust progran? The lamport balance lives on the AccountInfo
what's the best way to check lamports of a PDA before doing a transfer?
not sure if this is the right place, have a question around program upgrades:

if i create an account with a property of an array of objects (i.e. `foos: [Foo : 8]`) where Foo has simply a property of `bar: u128`, and i want to add another u128 to the Foo object (i.e. `buzz: u128`), must i have padding on the account to accomodate for this upgrade? 

if i do have padding, can i just reduce it by `size::u128 * 8` and add the additional `buzz: u128` to the Foo object? (i.e. will anchor be able to deserialise the account after upgrade) and is the data 0'd?


///////////////////////////////////////////////////////////////////////////////////////////////

is there any incentive to store bumps vs look up and pass in?
I'm having the same error that gALEXy reported.  Error: Program's authority Some(9EnXez8TkP6afj8n4dfvUxQDZrsdfNUHedXtExvTxKomMNv) does not match authority provided 6RHBJDmqu1vaGPcasdfdfs7fvwLBq1jGaQQJs5b7FAz9dAL
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.
quick q - is wallet.payer an implicit signer when using achor.getProvider()? i noticed that i don't need to include in the signers array
Mm, not aware of any reading‚Äîthe basic idea is simple though, you just have to be mindful that if you use `init_if_needed`, by the time you start running your instruction function there's no indication of whether or not an `init` was indeed needed. So if your instruction function sets some initial values on the account, you need to make sure that's what you actually want to do! E.g. you presumably don't want to overwrite values from an account where `init` wasn't needed.
I've been banging my head looking at the expanded code trying to understand how it could happen. Should've taken a walk
One way that could happen is if you accidentally deployed with the wrong `declare_id!`. (This is actually very easy to do, so one quick thing you can try is to just re-run `anchor build` and then redeploy.)
Am I missing something obvious?
https://github.com/BurntFinance/Collections/blob/9ff62d2116a50c29c9a2e2ad92c055188bbc7a30/programs/collections/src/lib.rs#L63 This seems to be the relevant portion
https://github.com/BurntFinance/Collections/tree/ash/redux
My code is here
Hi all. I have a fairly simple anchor contract, based closely on the tutorial. It initializes a PDA based on seeds from the provided accounts. In local tests, it works fine. However, when deployed, we are seeing this error: https://explorer.solana.com/tx/2trK9fz4EEkVBndiGKWeAMReh8YNCpF6ti5gQRUAoyC5Y5yb4dEfS3gzeBFni1suvTR2zoFybi8DgfQJFECm2e4P?cluster=devnet
my use cases are for token accounts and atas though. No structs with init_if_needed
do you have any info to read up on re-initializing? i've been using init_if_needed for similar  use cases and want to make sure i know what to look out for. thanks üôÇ
Got it..thanks!
The only way to do that is to have some way of looking at the `UserInfo` struct and recognizing if it has been initialized (e.g. one way is to have a `is_initialized: bool` flag on it).
Anchor has an `init_if_needed` attribute, but it's a bit tricky to use‚Äîyou'll have to make sure your instruction function correctly recognizes the two code paths, since otherwise you might accidentally *re*-initialize the account (bad).
Hey guys I have a struct in my smart contract which creates a account for the particular user in the program.
Something like this: 
#[derive(Accounts)]
pub struct Create<'info> {
    #[account(init, payer = user, space = 10240)]
    pub userInfo: Account<'info, UserInfo>
 #[account(mut)]
    pub user: Signer<'info>,
}

so the problem i am facing here is, if the account is already created this will throw an error. Is there any way i can add the check for (if account already exist then do not do this, otherwise create a account) in the smart contract itself?
One solution is to have 2 different structs, one which initialises and one which is used if already initialised but i do not want to do that..
Since I started using `avm` I get a weird error when running `anchor test`: `Unable to start test validator. Check .anchor/test-ledger/test-ledger-log.txt for errors.`
Anybody knows where this comes from?
I'm not 100% sure why this happened (was just working) -- my guess is that I ran out of SOL on devnet?
I think I just screwed up my anchor pretty badly. For some reason, it outputted text suggesting to input a given seed phrase and I did that, but now my program authority doesn't match the solana address that was newly created?
Like closing a token account now sometimes returns the `Transaction leaves an account with data with a lower balance than rent-exempt minimum` error hmm.
Did this just break a bunch of stuff
Can anyone please guide me regarding what to do please?
Guys I am using Mac M1 and i am using solana version 1.9.5 and anchor version 0.20.1 and i am getting this error `BPF SDK path does not exist: /Users/name/.cargo/bin/sdk/bpf: No such file or directory (os error 2)`                                                                                     UPDATE Solved it by making a symlink to sdk at ./cargo/bin/sdk
See e.g https://project-serum.github.io/anchor/tutorials/tutorial-1.html
In the snippet you posted
I assume this would be in the rust file but that doesn't seem right?
I'm confused as to what that would like look like
Yea
huh? Is that how I pass in an int value?
new anchor.BN(5)
I've tried "5" and 5

Trying to pass in a value into the deposit function
I'm getting this error and can't seem to find any information on it
nope
<@!707604162673639504>  did u manage to successfully cpi into the candymachine program yet ?
```
Transaction simulation failed: Error processing Instruction 0: invalid account data for instruction 
    Program Hmdjij19WXWCt9ztYHYB7eryGXD3gv8PNQYFGYiF4v2W invoke [1]
    Program log: Instruction: CreateNft
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [2]
    Program log: Instruction: InitializeMint
    Program log: Error: InvalidAccountData
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 1662 of 194834 compute units
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA failed: invalid account data for instruction
    Program Hmdjij19WXWCt9ztYHYB7eryGXD3gv8PNQYFGYiF4v2W consumed 6828 of 200000 compute units
    Program Hmdjij19WXWCt9ztYHYB7eryGXD3gv8PNQYFGYiF4v2W failed: invalid account data for instruction
```
```
#[derive(Accounts)]
pub struct CreateNFT<'info> {
    #[account(mut)]
    mint: AccountInfo<'info>,
    #[account(mut)]
    to: AccountInfo<'info>,
    #[account(signer)]
    authority: AccountInfo<'info>,
    token_program: AccountInfo<'info>,
    rent: Sysvar<'info, Rent>,
}

impl<'info> CreateNFT<'info> {
    fn initialize_token(&self, authority: Pubkey) -> ProgramResult {
        let token_accounts = InitializeMint {
            mint: self.mint.clone(),
            rent: self.rent.to_account_info(),
        };

        let result = token::initialize_mint(
            CpiContext::new(self.token_program.clone(), token_accounts),
            0,
            &authority,
            None,
        );
        result
    }

    fn create_token_account(&self) -> ProgramResult {
        let token_accounts = InitializeAccount {
            account: self.to.clone(),
            mint: self.mint.clone(),
            authority: self.authority.clone(),
            rent: self.rent.to_account_info(),
        };

        let result =
            token::initialize_account(CpiContext::new(self.token_program.clone(), token_accounts));
        result
    }

    fn mint_token(&self) -> ProgramResult {
        let token_accounts = MintTo {
            authority: self.authority.clone(),
            mint: self.mint.clone(),
            to: self.to.clone(),
        };

        let result = token::mint_to(
            CpiContext::new(self.token_program.clone(), token_accounts),
            1,
        );
        result
    }

    fn set_token_authority(&self) -> ProgramResult {
        let token_accounts = SetAuthority {
            current_authority: self.authority.clone(),
            account_or_mint: self.mint.clone(),
        };

        let result = token::set_authority(
            CpiContext::new(self.token_program.clone(), token_accounts),
            spl_token::instruction::AuthorityType::MintTokens,
            None,
        );
        result
    }
}
```
Hi,
I'm trying to write a program to create token account and mint a token but i'm getting invalid account data error while testing, I'm new to anchor so if i made any dumb mistake please bare with meüòÖ 

```
pub mod ticksol {
    use super::*;

    pub fn create_nft(ctx: Context<CreateNFT>, authority: Pubkey) -> ProgramResult {
        ctx.accounts.initialize_token(authority);
        ctx.accounts.create_token_account();
        ctx.accounts.mint_token();
        ctx.accounts.set_token_authority();
        Ok(())
    }
}
```
LIFESAVER THANKS BRO!
`ANCHOR_WALLET=~/.config/solana/<wallet>.json <script>`
The error I am getting btw is `The "path" argument must be of type string or an instance of Buffer or URL. Received undefined` when the `ANCHOR_PROVIDER_URL` is defined as my localnet
hey guys, im wondering why `anchor.Provider.env()` and `anchor.Provider.local()` both dont work in any files but do work when running `anchor test` and running the test script?
Looking in my code it was because I didn't capitalize the text correctly üòÖ
That would mean that you haven't set up your `program` variable correctly
Hey there, I keep getting this error when running `anchor test`: ```js
 Starting test...
TypeError: Cannot read property 'rpc' of undefined
```
thought so, thanks for the clarification
if you want to read/write from/to any account on solana you need to explicitly pass it in
is there any way to lookup an ata token account in a program given a mint and user or does the ata need to be explicitly passed in?
hey! did anyone try to use anchor programs with octane or other relayer mechanisms, that are paying the transaction fee? maybe there is some oss code? stuck with "writable privilege escalated". everything seems fine if the fee payer = authority, but once authority is just a signer and 3rd party is the fee payer - error comes up.


///////////////////////////////////////////////////////////////////////////////////////////////

Can you show me the js code where you're calling the function?
I have this in my idl
```
      {
          "name": "farmer",
          "type": {
            "option": "publicKey"
          }
        }
```
I'll do something in mango, and then we'll see it it makes sense to carry over
yes
Did you rebuild your code too?
Don't `match Some(farmer)`, do `match farmer`
```
pub fn add_veterinary(ctx: Context<AddVeterinary>, vet_account_bump: u8, firstname: String, lastname: String, location: String, city:String, farmer: Option<Pubkey>) -> ProgramResult {
        ctx.accounts.veterinary_account.bump = vet_account_bump;
        ctx.accounts.veterinary_account.firstname = firstname;
        ctx.accounts.veterinary_account.lastname = lastname;
        ctx.accounts.veterinary_account.location = location;
        ctx.accounts.veterinary_account.city = city;
        ctx.accounts.veterinary_account.authority = *ctx.accounts.authority.to_account_info().key;
        match Some(farmer) {
            Some(farmer) => ctx.accounts.veterinary_account.farmers = vec![farmer],
            None => ctx.accounts.veterinary_account.farmers = vec![]
        }
        Ok(())
    }
```
yes
Did you type the argument as `farmer: Option<Pubkey>`?
So apply your solution but when i try to pass null in the js test file i got this error:
```
TypeError: Cannot read property 'toBase58' of null
```
`event.try_to_vec()` is the main offender, usually allocates around 2x data size on the heap
if you can do it without growing an intermediate Vec<u8> on the heap, then it solves the problem
i don tthink we can assume the stack is empty
if we just did borsh serialize -> log (skipping the string step) would that be sufficient?
does this imply the problem is in borsh?
And here are some measurements about how often I could `emit!()` a mango fill log before hitting heap limits:
```
mango_emit: 17x, then out of memory; 3794 compute per emit
mango_emit_writers: 85x, then out of memory; 3711 compute per emit
mango_emit_zero_copy: 83x; 3799 compute (weird, would have expected to reduce compute since it doesn't hit borsh)
mango_emit_stack: inf; 3141 compute per
```
I'd propose this. If we're sure the stack is pretty empty, like in the root function of an instruction:
```Ôªø
mango_emit_stack::<FillLog, 512>(event); // needs 1k on the stack, FillLog must fit 512 bytes
Ôªø```
and otherwise we can manually pre-allocate larger buffers on the heap and use
```Ôªø
mango_emit_buffers(event, &mut buffer1, &mut buffer2);
Ôªø```
neither of these will hit the heap at all and seem to potentially have slightly (20%?) lower compute than the default emit!() function.
This is my latest state on that:
but that may be too complex to give to normal users
thanks! I will try it!!
I've been looking at serializing the events in stack buffers, or in reusable heap buffers instead
and may actually increase compute needs for some cases
these changes are mostly about memory
Note that we actually had trouble recently because emit!() consumes a lot of heap memory
Nice, this could probably go in with some polish, but the stack_buffer dependency is unfortunate. And I've since tested more and a larger buffer on the stack is quite helpful.
Then you would do
```.rs
match farmer { // note, *not* match Some(farmer)
  Some(famer) => ...,
  None => ...
}
```
That will show up in your instruction function as `None` (the "nothing" version of an Option type)
You have to at least pass `null` for the farmer
no difference between null and none. Just want to be able to populate the account without pass in the farmer
happy to bring that change in as part of a temporary solution
nice so this maintains the existing format
Then you can pass it as either `null` or as a real pubkey
here's christian's commit: https://github.com/ckamm/anchor/commit/154f6eb1170d4df1e572e3f3c3c4b5083d22044d
At any rate, you would want to pass an *optional* farmer from the client, so have your instruction function take a `farmer: Option<Pubkey>` (I guess)
What's the difference between farmers being None versus an empty list?
<@!887234715940175895> would love to know more about your changes. Happy to add them but I suspect the above is part of the preferred solution.
First thing to consider is that `Option<Vec<Pubkey>>` is a bit of an odd type, potentially. Do you want to both have `None` as well as `[]` (an empty vec) be valid?
And the binary logging api i was referring to https://github.com/solana-labs/solana/pull/19764
existing thread on this https://github.com/project-serum/anchor/issues/863
<@!887234715940175895> <@!501570363566587905> is curios about your changes. He mentioned anchor logging should actually move to the binary format for even more efficiency
logging efficiency
thanks but I'm still struggling with the same issue
To be more clear, here is my problem:
I want to optionally pass pubkey in a vec when i call my fn.
Here is my account struct def:
```
#[account]
#[derive(Default)]
pub struct Veterinary {
    pub firstname: String,
    pub lastname: String,
    pub location: String,
    pub city: String,
    pub farmers: Option<Vec<Pubkey>>,
    pub authority: Pubkey,
    pub bump: u8
}
```
And here is a function that try to populate the account:
```
 pub fn add_veterinary(ctx: Context<AddVeterinary>, vet_account_bump: u8, firstname: String, lastname: String, location: String, city:String, farmer: Pubkey) -> ProgramResult {
        ctx.accounts.veterinary_account.bump = vet_account_bump;
        ctx.accounts.veterinary_account.firstname = firstname;
        ctx.accounts.veterinary_account.lastname = lastname;
        ctx.accounts.veterinary_account.location = location;
        ctx.accounts.veterinary_account.city = city;
        ctx.accounts.veterinary_account.authority = *ctx.accounts.authority.to_account_info().key;

        match Some(farmer) {
            Some(farmer) => ctx.accounts.veterinary_account.farmers = Some(vec![farmer]),
            None => ctx.accounts.veterinary_account.farmers = None
        }
        Ok(())
    }
```
I dont know how to deal with the option here, Also in my  frontend test file, I dont know what to pass to the account in order to simulate null value
Has there been any updates or solutions to the invalid blockhash error on deployment?
Any tips for making the transactions go through?

I seem to be able to deploy on devnet just fine but mainnet is giving me a lot of issues.
Yep, you can do this:
```.rs
pub fn init_config(ctx: Context<InitConfig>, global_config : Config) -> ProgramResult {
    *ctx.accounts.config_account = global_config;
    Ok(())
}
```
Basically I want to avoid populating the fields 1 by 1. I'd rather build the whole struct on ts and avoid useless lines of code in rust
I am trying to create an account and assign it the struct.
```struct Config{
    a : u64,
    b : u64
}
```
 Typically I do : 
```    pub fn init_config(ctx: Context<InitConfig>, a : u64, b: u64) -> ProgramResult {
        let config_account = &mut ctx.accounts.config_account;
        config_account.a = a;
        config_account.b = b;
        Ok(())
    }``` 
However it seems cleaner to do something like :
   ```pub fn init_config(ctx: Context<InitConfig>, global_config : Config) -> ProgramResult {
        let config_account = &mut ctx.accounts.config_account;
        config_account = global_config;
        Ok(())
    }```
This doesn't seem to work. Is there a right way to do this?
Thanks for the clarification. Optimizing stack and compute is important but I appreciate the focus on correctness and account security. The framework you guys are building makes writing secure solana so much more accessible and I think it brings a lot of validation to the projects built on it
It's something we really need to benchmark and measure. But not something we've been actively considering, since it's caught at compile time (and with very basic tests). The primary priority has always been correctness and account security. So if there's a change that uses more stack space or compute, but allows one to reason about the framework in some meaningful way, we'll make that change. Adding ctx.bumps in the last release is a good example of this. Though I definitely think we should start optimizing everything relatively soon.
That's what I figured, I just wasn't sure if I missed something in the changelog. Do you have any estimation of how anchor stack usage has changed across versions? With the stack being so limited on solana, I'm sure mitigating stack usage is something that you guys take into account
unfortunately every anchor release is technically breaking because of solana runtime constraints. It's always possible we make internal undocumented changes that are by themselves not breaking but cause programs to overflow because they use stack space that wouldve been used elsewhere downstream
It said I overflowed the stack by 0 bytes, which I thought was odd
Has anyone else run into stack overflow issues since 0.21? An instruction of mine which was working in 0.20 suddenly started giving stack overflow when I upgraded. I fixed the issue by boxing an account but looking through tgeh changelog, nothing jumped out at me which would have caused the stack issue
oh so I've seen this
<@!891024357026041907> https://github.com/project-serum/multisig/blob/master/programs/multisig/src/lib.rs
Am I correct in this?
yeah that's what i'm thinking too, i'll stick with constraint for now, i don't really have access to the staker when calling the rpc method otherwise i'd pass it in to get the account info. is there any way to do a to_account_info at the constraint level?
why does the rust client pass in the payer as the first account for RequestNamespace::State { new: true }?
Mm, I think you maybe need to have an actual account on the rhs of `associated_token::authority`, not just a pubkey ü§î
oh, got it. ok. this makes sense.
still running into an issue with 0.21.0 if anyone has any insight

```#[derive(Accounts)]
pub struct Crank<'info> {
    #[account(
        associated_token::mint = mint,
        associated_token::authority = config.staker.unwrap()
    )]```

`config.staker` is an `Option<Pubkey>` and i'm getting 

```
^^^^^^^ method cannot be called on `anchor_lang::prelude::Pubkey` due to unsatisfied trait bounds
...
1 | pub struct Pubkey(pub(crate) [u8; 32]);
   | ---------------------------------------
   | |
   | doesn't satisfy `_: AsRef<anchor_lang::prelude::AccountInfo<'_>>`
   | doesn't satisfy `anchor_lang::prelude::Pubkey: anchor_lang::Key`
   |
   = note: the following trait bounds were not satisfied:
           `anchor_lang::prelude::Pubkey: AsRef<anchor_lang::prelude::AccountInfo<'_>>`
           which is required by `anchor_lang::prelude::Pubkey: anchor_lang::Key`
```

changing to this works just fine (rather use associated token though):

```
#[account(
    constraint = token.owner == config.staker.unwrap(),
    constraint = token.mint == mint.key())
]
```

i'm probably making an obvious mistake, just not seeing it. thanks in advance!
You can I guess get around it with what you suggested above, with the client asking the program for what seeds to use, but yeah, not totally sure how much better that is than the alternative of just using a knowledgeable client
In solana there isn't really much of a separation between on-chain program and client, because of this address stuff
I guess you could do that‚Äîit's a little awkward in solana since you can't exactly return anything from an instruction function. You'd have to pass in a separate "return value" account for where the program should write its answer to.
What do you mean by a program function?
but, there's only "1 canonical way" to compose a PDA via the client.

(namely, via `anchor.web3.PublicKey.findProgramAddress`.)

- take the seed (verbatim).
- take the program id.
- call the function.

...but what if i don't want the verbatim seed? instead i want `seed + "FOO"`?

should this logic live on client? if so, wouldn't *all* clients (anyone can implement their own, right?) need to know this logic?

in this vein, why not keep it on the program itself?
Along these lines - I keep backing myself into thinking that pretty much any associated token account I'll be depositing into should be set to `init_if_needed`

```
    #[account(
        init_if_needed,        
        payer = user,
        associated_token::mint = mint,
        associated_token::authority = user,        
    )]
    pub token_account: Account<'info, TokenAccount>,
```
Otherwise, unless I'm mistaken, someone could send you a small amount of a token which would trigger the creation of an associated token account that they paid for on your behalf.  Then, when you go to use an instruction for that ATA that's only marked with `init` and not `init_if_needed` then the instruction would fail.
this is my question; can't it call a "program function" to get this address? then, once it has it, stuff it into a subsequent instruction call?
So if you're planning on writing any data to an account, at the end of the day the client has to pass it in (which means they need to know the seeds if the address is a PDA).
No, the client will have to do it too if you're planning on storing anything in an account there, since the client always has to pass any accounts needed by the instruction.
just some rust logic that computes a PDA pubkey given seeds.

shouldn't this live on the program itself?

if the logic is at all non-standard?

for instance, imagine my seed is the token `FOO`.

*but i want my true seed to be `FOO<>SOL`. (the name of the pool).*

shouldn't my program do this? not the client?
What would the instruction do? Not totally sure what you mean by "doesn't deal with accounts"
And yeah, if you use `init` then it'll fail if the account has already been allocated.
You'd either have to check on the client (just try fetching the account), or do the `init` logic yourself, without anchor macros.
sanity check question: my solana program should be responsible for defining the mapping from "some token name" to "address of token-sol pool," right?

and this would just be a simple instruction that doesn't deal with accounts (other than the system program)?
what's the alternative?

concretely, if you don't use `init_if_needed`, what's the right pattern to check if the account exists before initializing it?

similarly, if you try to initialize an account that's already been initialized, solana should error, right?
"instruction data" are just the machine instructions for each `pub fn` in your program?
That's how you can have big 10mb accounts despite only having 32kb of heap
So it's interesting, insturction data and account `.data` live at 0x40000.... addresses, different from stack (0x2...) and heap (0x3....)
https://docs.solana.com/developing/on-chain-programs/overview#memory-map
`this other part of the memory map` -> what does this mean?
But that's not the raw account data itself (the stuff in an AccountInfo's .data property), that's the result of explicit deserialization of that data into a nice rust struct.
interesting!
The raw account data itself lives in this other part of the memory map, neither stack nor heap. But once you deserialize with `Account<'info, Whatever>`, the resulting deserialized Whatever struct will indeed use the heap to store its Vecs.
isn't a vec stored on the heap? if so, where does solana store vec account data?
How you store a mapping like this depends a bit on how you want to read from it. For example, the simplest way is to just use PDAs. The seeds would be the token name, so then you can look up via the token name an account that stores the corresponding mint (PDAs kind of work like maps, seeds ==> account data)
Solana accounts themselves don't store their data in the heap, but borsh is happy to work with Vecs etc. Hashmaps interestingly don't quite work out of the box for annoying solana reasons (they sneakily use mutable global state under the hood, which doesn't work on solana).
i'm building an AMM. what's a good pattern for storing a registry of token mints?

for instance, a hashmap that maps a token name to its corresponding mint (pubkey)?

can solana accounts store data on the heap? seemingly, solana cannot deserialize hashmap data.

**crucially, i don't know how many mints i have a priori.**
The system program is passed in most of the anchor tutorial examples, e.g. here: https://project-serum.github.io/anchor/tutorials/tutorial-1.html#defining-a-program
Hi,
I'm trying to write a anchor program to create and mint token but I'm getting invalid account data in test. 

I'm not sure what's the issue can someone help me out with it 

https://gist.github.com/Nithsua/28dfaf2a5e9618b34e96c4e5be92690e
<@!583559610334576652> pass this one as the account
https://project-serum.github.io/anchor/ts/classes/web3.SystemProgram.html#programId
also to understand better about systemProgram and accounts do we have specific lecture/docs
I couldnt find more about it.
I guess you can search the anchor web3 doc. I'm not familiar with the web3 sdk.
You must have 
```
#[derive(Account)]
pub struct GiftSol {
    ...
    system_account: ...
}
```
somewhere in the code
how do we pass systemprogram as an argument
Nah I mean the struct you attached #[derive(Account)]
here it is
Can you show your Account definition? It seems like you require a systemprogram to be passed with the ix
maybe also implement anchor_lang::Discriminator  for the Instructions like what it currently does for the Accounts?
yea Ive been thinking that as well recently. We could add it to the idl or we could have a cli command that outputs all the discriminators. or both
BTW it would be nice if anchor can expose the discriminator of the instruction as well.
error
I'm using the Instructions sysvar to ensure several ixs are run in a same tx like this:
```rust
        let ix = get_instruction_relative(-1, instructions)?;
        let sighash = crate::instruction::ExpectedPreviousIX { }.data();
        require!(ix.data[..8] == sighash[..8], IXNotInOrder);
```
May I ask if you see any security issue here?
test

hey guys .... i have a problem in sending some solana using anchor
It would be nice but currently not possible since it's not a sysvar. have to use the `address` constraint
How can I use it in #[derive(Account)]? Currently I'm using AccountInfo but ideally it should be Sysvar<Instructions>
thats the right one. instructions is a sysvar doesnt implement the sysvar trait.
I only find this one https://docs.rs/anchor-lang/0.21.0/anchor_lang/prelude/struct.Instructions.html. which does not implement the Sysvar trait.
Anyone knows if there's the Instructions Sysvar in Anchor?
https://crates.io/crates/mpl-token-metadata
Does the `metaplex-token-metadata-test-client` in the `MPL Token Metadata` still work? When I try to run it from a clean master branch I get:

```
Running `target/debug/metaplex-token-metadata-test-client`
thread 'main' panicked at 'called `Option::unwrap()` on a `None` value', cli/src/main.rs:853:67
```
No not exactly, I mean will it find keys in the same order each time given the same input
anyone aware of any good code examples of doing automated escrow payments with anchor?
You mean random? Yes.
anyone know if solana-keygen grind is non-deterministic?
<@!791742567146323978> so you might have to get crafty
<@!791742567146323978> Hey not sure how to simulate what a null value would be, but I believe Rust does not support null
Bumping this. Not sure it's convenient to mix the rust and js E2E test for this. Anyone had a jab at it before?
You'll have to post that js test code (not sure why you'd be using an empty string ü§î)
I have a struct  that have this 
```
pub farmers: Option<Vec<Pubkey>>
```
I want to be able to update my account without adding anything in that Vec.
My first approch is to do something like this :
```
 match Some(farmer) {
            Some(farmer) => ctx.accounts.veterinary_account.farmers = Some(vec![farmer]),
            None => ctx.accounts.veterinary_account.farmers = None
        }
```
But it's not seems to work as in my test file, when i pass empty string the test fail
Can you say more? What have you tried so far? Rust doesn't strictly speaking have null, just `None`
Hello, say i have an vec of pubkey like this:
```
Option<Vec<Pubkey>>
```
How can i handle it in fn to accept null value ?
yeah i've got ```[dependencies]
anchor-lang = "0.21.0"
anchor-spl = "0.21.0" ```
Hmm, just to check, are your Cargo.toml anchor dependencies all using the same version? Are you also using 0.21.0 for anchor_spl?
hey! i just updated to 0.21.0 and i'm running into an issue with a constraint i had set up

`associated_token::authority = config.staker.unwrap()`

and getting: `method cannot be called on anchor_lang::prelude::Pubkey due to unsatisfied trait bounds`

should i be referencing this pubkey from the struct differently?
though subject to messy implementation details ü§î
yea sgtm
instead of importing a crate to do it, we could also do sth dumb and simple. We know how many autogenerated bumps each instruction will have at compile time. So we could just generate a macro that creates an empty array (initially with all 0 or whatever, doesnt matter). That array will be filled with the bumps. Then we also generate a match statement that matches the given `&str` to the account index which is then used to index into the bump array. <@!501570363566587905>
You also reminded me of this - statement about inspiring other sol devs still true!
thanks Alan you're the man
No, here it should be `&[OFFER_PDA_SEED.as_ref(), ctx.accounts.offeror.key.as_ref(), &[offer_vault_authority_bump]]`
Hey hopefully a quick question on PDAs - I'm having some trouble with the syntax of the authority seeds - the authority seeds should be a [&[u8]; 2], where the first &[u8] is the seed of the PDA (here, a constant and the user pubkey) and the second is the bump, right? What is the right syntax/structure here? Thank you!
That library would need to be adapted. But perfect hashing should result in static, compile-time keys mapping to a simple array index, I think.
which is fine i suppose
i guess this map has to be static?
great that's all we need
The data can be mutable but not the keys
Unfortunately we need runtime mutation since the bump seed is often data dependent.
I don't think so, because the hashcode itself is computed ahead of time.
probably can do that
e.g., via the `phf_map!` macro?
can the map be created at compile time with dummy values that are changed at runtime?
interesting
https://github.com/rust-phf/rust-phf
Something like this:
I see a BTreeMap has been added to each anchor instruction to keep track of bumb seeds. With only 32K of heap available is there a more efficient way to do this, like maybe compile-time perfect hashing?
I see now, so you take the slothash vector, take a slice, as uint and that uint is your random number? 

Did i get that right
Having a hard time grasping how you would handle pseudorandomness with slothashes
How would you go on about this btw
Hopefully I'll get to see some of you on Riptide!
Thanks mate
Lmk if you get a better one working
I'm just gonna use slothashes at least to start üòâ
but chainlink probably works too
I think he was referring to this one
https://switchboard.xyz/
Or would it be better to create our own implementation of VRF per program
he said that he wasn't really familiar with the solana vrf because it just came out
By VRF you mean use Chainlink's program?
there's an example of the easy way in candymachine
easy way (minable) -- slothashes
better way (harder) -- solana vrf
How'd it go
Aren't you still at the mercy of potentially malicious validators?
Was talking to a solana dev about this yesterday
Would it be pseudorandom with Clock?
Does anyone have any idea how to handle randomness in Solana?
I just created an entirely new anchor env from scratch using "anchor init" and it's still giving me the same error
oh nvm i see the changelog now
just not in subsequent calls?
don't you need to for the initializations though?
ok, got some refactoring to do, but thanks for the info!
as of the latest version,  it's recommended to never pass in the bump from the client
Don't know the official answer but the latest changelog seems to imply they recommend storing
Is this anchor env just screwed? Only fix I can think of is copying the relevant files and anchor init in a new folder


///////////////////////////////////////////////////////////////////////////////////////////////

in this case yeah, like ```    #[account(mut, seeds = [b"config".as_ref(), mint.key().as_ref()], bump)]
    pub config: Account<'info, MintConfig>,```
If I understand correctly you‚Äôre trying to assert that the correct config account has been passed for the mint?
Again not fully clear on your use case but you dont need to pass it through the client, just load it from the account to do the check
and then just pass it back through the client? i could do that
Why not store the bump seed in each config account?
gotcha, that's good to know. yeah in my case i've got a config per mint in a collection so there are a couple thousand. perhaps not the best approach?
Yes it will always be the first one. Not sure about your exact use case but in general you always want to store it. Computing the bump seed every time can be wasteful in terms of cumpute budget.
ideally a vault or something that is dispersed automatically
I've seen a few but just trying to view as many as possible
anyone know good examples for using PDAs for CPIs on anchor?
only ever use the first one as in, `findProgramAddress` will always return the first right as it goes down from 255 - is that correct? if i specify `#[account(mut, seeds = [b"config".as_ref(), mint.key().as_ref()], bump)]` will that bump in `ctx.bumps` always be the first one? when would i want to store it in an account? in my case i have a ton of configs so i don't necessarily want to store all the bumps
do I have to put the wallet program in the `signers` part of the CPI call somehow?
Hi I'm making a CPI call and passing in the wallet program address as a payer. It's causing me to have a writable privilege escalated error. I checked the wallet program address account info and its 
```    is_signer: true,
    is_writable: true,```
On the side of the devnet program that I'm making a CPI call to its only supposed to only check signer
Yes it is deterministic. Multiple different bumps can be valid but it's recommended to only ever use the first one.
No
Anyone has any good examples of how to put an nft or a token ¬´up for sale¬ª? Trying to make like an buying mechanism with a fixed price for fun. 
Trying to find some documentation but might be looking in the wrong peace
when I use command `anchor test`
Caused by:
  this version of Cargo is older than the `2021` edition, and only supports `2015` and `2018` editions.
How does this happen?
Hello guys, may I know if PDA is deterministic? if I have one fixed seeds, it will only one bump valid for PDA?
I think so, I'm thinking along the lines of another cron job initializing the account as well, or any other way to automate that on a schedule. Is that possible?

Essentially I'd like to automatically create bets with a cron job, but I know that rent has to be paid for each account, etc, so i was wondering if I could have my wallet on autopilot paying for automatically created accounts with a cron job.
What do you mean by automate here? You can initialize that account with a programmatic call from the client, does that count as automated?
I've got probably a weird question idk, but as I understand, I can use a PDA along with a cron job to automatically release some funds on a schedule, take other actions etc. But for the initialization of that account, is there any way that I can automate that initialization of an account as well? Or is that something that always has to be a manual action?
so lately anyone else getting a "Transcation may fail" simulation error for a few seconds, before phantom refreshes and shows the correct info?
awesome!
I was the one in the twitch asking about optional human-readable descriptions in the IDL spec for instructions and accounts. I plan on taking a look at the code this weekend for IDL gen.
yes
docs.rs doesnt seem to have a place for me to see optional feature addons
is this also true for `0.21.0`?
i see that `anchor-spl 0.19.0` has a `features = [dex]` option that allows me to import serum stuff
Nevermind got confused
This will compile but doesn't seem to serialize into the account
Ohhh. Jeez, I didn't think about the `mut` + discriminator part.
Thanks
Still can‚Äôt figure out how to achieve this
forgive me if this has been answered elsewhere already but is there a way to add pre-instructions with the new ts builder?
oh! thanks!!!
just pass them individually
youre passing instructions args as an object
You're probably running into a variation of this bug https://github.com/project-serum/anchor/issues/1103
can token accounts not be created through `init`?
don't think so
i.e. for initPool
are you missing an argument for the function call?
after inserting some debug statements in the cjs files, it appears the `accts` object going into the `validateAccounts(...)` function in `common.ts` is `undefined`
getting `Error: Invalid arguments: pool not provided`, even though I do provide `pool`
this is actually not safe (and we shouldve documented this. it's only meant for internal use). if an account is marked with `mut`, its discriminator will be set at the end of the instruction, overwriting the closed account discriminator. So if you use `.close` manually you are vulnerable to account revival attacks. We will make a change soon that will make discriminators be written at the beginning of an instruction instead of the end
Don‚Äôt know to. I will dig a lil more
Mm, that actually looks fine to me, so not sure what the problem is
```
const tx = await program.rpc.addVeterinary(
      new anchor.BN(veterinaryAccountBump),
      firstname,
      laststname,
      location,
      city,
      null,
    {
     accounts: {
        veterinaryAccount: veterinaryAccount,
        authority: provider.wallet.publicKey,
        systemProgram: anchor.web3.SystemProgram.programId,
      },
    }
    );
```


///////////////////////////////////////////////////////////////////////////////////////////////

Ohhh I see. thank you
Nothing happens if you leave it as an AccountInfo (meaning, anchor does absolutely nothing)
what happens if i leave it raw?
Use `pub config: Account<'info, Config>`, don't leave it as a raw AccountInfo
Hi, I hve a config account hta keeps the record of the authority keys (which are pubkey type). SO when i need to use constraints for for example
```rust

// this is code inside my context struct
#[account(mut, constraint = authority.key == &config.admin_account_authority.key())] 
// =====> how do i match the authority ket with the config authority pubkey???
pub authority: Signer<'info>,
pub config: AccountInfo<'info>

#[account]
#[derive(Default, Debug)]
pub struct Config {
    pub bump: u8,
    pub is_initialized: bool,
    pub authority: Pubkey,
}```
No, totally different
Out of curiosity, do the solana version and anchor version have to be the same to work?
Oh sweet. its set up like that. Ty.
You can validate that the PDA is derived from a different program with the `seeds:program` attribute
Then yeah, anchor will validate that the PDA has the right seeds + bump, and is derived from your program.
If you do
```.rs
#[account(seeds = [...], bump = its_bump, ...)]
pub the_account: ...
```
üßê
Does it check on its own ?
Hi, how can I check if the pda is generated by the program that im calling ?
I removed build and tried the whole thing again, seems same issue... Let me check further
Yep.
hmm indeed this is quite hairy, ideally what I need to do is to just clone the solana repo , checkout the version, and run `scripts/cargo-install-all.sh` right?
For what it's worth, I'm running 1.10 locally and everything is fine
Ok, I'm pretty sure you're solana install is still messed up unfortunately
if it were v1.9 and onwards having issues with the `anchor deploy` hang, I would have just gone ahead with v1.9 haha, cuz downgrade obviously is a lot of hassle
this behavior is only found in local validator, My deployment to devnet seems alright
it hangs at 
```
‚†í [0/1] Finalizing transaction 5haDibgxHFFEAj47prAqRP5xZZwd9GUqM6PsTS1YeAWoe6GwYPJSZnwNpCoHj4bcJeg7k8v98niBiBXvo2Deeyrw
```
with `anchor deploy`
Mm, does anchor test work if you *do* start the validator in the background?
```
To deploy this program:
  $ solana program deploy /Users/username/program/target/deploy/program.so
The program address will default to this keypair (override with --program-id):
  /Users/username/program/target/deploy/program.json


  some error checks
    1) Cannot commit 

Translating error FetchError: request to http://localhost:8899/ failed, reason: socket hang up
    at ClientRequest.<anonymous> (/Users/username/program/node_modules/node-fetch/lib/index.js:1461:11)
    at ClientRequest.emit (events.js:400:28)
    at Socket.socketOnEnd (_http_client.js:499:9)
    at Socket.emit (events.js:412:35)
    at endReadableNT (internal/streams/readable.js:1334:12)
    at processTicksAndRejections (internal/process/task_queues.js:82:21) {
  type: 'system',
  errno: 'ECONNRESET',
  code: 'ECONNRESET'
}

```
Can you print the full log you get when you try to run anchor test?
v14.18.3
Mm, vague memory of this being a node version issue‚Äîwhat does `node --version` say?
cuz if I run a standalone `solana-test-validator` I guess the state will persist in my local validator, which I dont want as its just for testing
yup it loaded up just fine, but I thought `anchor test` will auto spin up one
Are you able to spin it up manually? `solana-test-validator`
build works and I got all the binaries!! but when I run `anchor test` seems like the test validator is probably not spun up correctly?
```
Translating error FetchError: request to http://localhost:8899/ failed, reason: socket hang up
    at ClientRequest.<anonymous> (/Users/username/liqnft/serialized-vault-program/node_modules/node-fetch/lib/index.js:1461:11)
    at ClientRequest.emit (events.js:400:28)
    at Socket.socketOnEnd (_http_client.js:499:9)
    at Socket.emit (events.js:412:35)
    at endReadableNT (internal/streams/readable.js:1334:12)
    at processTicksAndRejections (internal/process/task_queues.js:82:21) {
  type: 'system',
  errno: 'ECONNRESET',
  code: 'ECONNRESET'
}
```
let me have a try on this one
I build locally with `scripts/cargo-install-all.sh`
I think my built binary was in target folder
but it seems ive only got empty folder `/Users/username/solana/bin/deps` after build
oh I see
ohh hmm so I clone the solana source, checked out 1.8.2 (seems 1.9 onwards there is issue with `anchor deploy` hanging), and then I run `cargo build --release`
So not in target/release at all
For me at least, my BPF SDK path is in my solana directory, then bin/sdk/bpf/
That makes me think you haven't quite installed solana correctly.
Hi Guys, I just tried to build solana from source (cuz im on M1 mac), so Ive got the `solana` binary through `cargo build`, but when I run `anchor test`, it complains 
```
BPF SDK path does not exist: /Users/username/solana/target/release/sdk/bpf: No such file or directory (os error 2)
```
Does anyhow know how I can build this `bpf` binary?
Yep
<@209141563324891136>
Did u try solana-install update command
Rip
üßê
Well, It doesn't work either üò¢ IDK
üò∂
0.18.0
Solana and
1.8.14
Which version of anchor-client do you use?
Hmm I had the same issue. But it worked  after i used that version
Doesn't work with 1.8.14 either.
I the docs says 1.9.1, but also links the solana docs, which installs the 1.9.6
<@209141563324891136>
üßê
Wasn't it specified in the docs
Use 1.8.14
üò∂
Ok, I just updated it and I have the same error
```
 ‚ùØ solana --version
solana-cli 1.9.6 (src:781609b2; feat:2191737503)
```
<@209141563324891136>
Update ur solana version
When I add `anchor-client = "0.21.0"` to my dependencies

I got this error on `anchor build`
```
error[E0425]: cannot find function `is` in this scope
  --> /home/odck/.cargo/registry/src/github.com-1ecc6299db9ec823/atty-0.2.14/src/lib.rs:98:6
   |
98 |     !is(stream)
   |      ^^ not found in this scope
```
Anyone has an idea about how to resolve this?
For the instruction struct in anchor?
Y is my stack size over limit?
Hi!! Does anyone how why from solana 1.9 and onwards when I run `anchor deploy` ,which I know underlying is `solana deploy` the cli just hangs forever?
Im trying to downgrade to 0.18.2 on my new M1 laptop, but seems to be having lots of issues there
update your anchor versions to 0.21.0
<@!347689664855015424>
But When I try this on react it through error.

`action.ts`
```
    return await props.program.rpc.stakeNft({
      accounts: {
        owner: owner.publicKey!,
        rewarder: props.rewarder.address,
        rewardAuthority: props.rewarder.rewardAuthority,
        stakeAccount: props.stakeAccount.address,
        rewardMint: props.rewarder.data.rewardMint,
        rewardTokenAccount: tokenAccountAddress,
        nftMint: nftMint,
        nftTokenAccount: nftTokenAccountAddress,
        tokenProgram: SplToken.TOKEN_PROGRAM_ID,
        systemProgram: web3.SystemProgram.programId,
        rent: web3.SYSVAR_RENT_PUBKEY,
        clock: web3.SYSVAR_CLOCK_PUBKEY,
      },
      remainingAccounts: [
        { pubkey: nftMetadata, isSigner: false, isWritable: false },
      ],
    });
```

error 
```Transaction simulation failed: Error processing Instruction 0: custom program error: 0x13c 
    Program 3e7TuwkTTMeRJhne9Z1oRSGuJfF22ErcDVyPmNFHJ8sq invoke [1]
    Program log: Custom program error: 0x13c
    Program 3e7TuwkTTMeRJhne9Z1oRSGuJfF22ErcDVyPmNFHJ8sq consumed 25161 of 200000 compute units
    Program 3e7TuwkTTMeRJhne9Z1oRSGuJfF22ErcDVyPmNFHJ8sq failed: custom program error: 0x13c
```

This is my program address `3e7TuwkTTMeRJhne9Z1oRSGuJfF22ErcDVyPmNFHJ8sq`
This is working fine with anchor test

`test.ts` ```
    it("stakes an NFT", async () => {
      const nftMetadata = await Metadata.getPDA(nftMint.publicKey);
      await solNftStakingProgram.rpc.stakeNft({
        accounts: {
          owner: owner.publicKey,
          rewarder,
          rewardAuthority,
          stakeAccount,
          rewardMint: rewardMint.publicKey,
          rewardTokenAccount,
          nftMint: nftMint.publicKey,
          nftTokenAccount,
          tokenProgram: splToken.TOKEN_PROGRAM_ID,
          systemProgram,
          rent: rentSysvar,
          clock: clockSysvar,
        },
        remainingAccounts: [
          { pubkey: nftMetadata, isSigner: false, isWritable: false },
        ],
        signers: [owner],
      });

      let nftAccount = await nftMint.getAccountInfo(nftTokenAccount);
      expect(nftAccount.owner.toBase58()).to.equal(stakeAccount.toBase58());
    });
```
I just created an pda account using anchor  and the instruction stack size  is more than 4kb ??
For a instruction
Hi, what are some variables that would effect my stack size?
There is no custom error in my program and my dependencies looks like this
```
anchor-lang = "0.18.2"
anchor-spl = "0.18.2"
metaplex-token-metadata = {version = "0.0.1", features = ["no-entrypoint"]}
spl-token = "3.2.0"
```
you need to find out which error corresponds to error code `316` in the program starting with `3e7`. If thats an anchor program and its under your control, it seems like youre using an old anchor version. We dont currently have an error code `316`
<@!347689664855015424>, any idea? Trying to figure it out since morning, but nothing seems to work.
wrap your  `amount` instruction argument (the `20000000`) in a `new Anchor.BN(200000000)`
can somebody please guide me
Hmm
That command only added in program folder...
But sure will do it that way ty.
Oh I only added to the workspace.
yes but youll need to remember to adjust config code in some places which `new` will do for you
Thank you
Oh wow didn‚Äôt know that thanks
Copy pasting the program should work too isn't it ?
and `anchor new <program-name>` to create another program in a workspace <@!940768249501610034> <@!242234529396424704>
üöÄ
I already did
Not sure how you‚Äôd structure your folders..
Oh ty.
`anchor build -p <program-name> and anchor test <test-file-name>`
Can I create multiple program in anchor?
<@!501570363566587905> This is what I settled on doing for mango-v3: https://github.com/blockworks-foundation/mango-v3/pull/134
üßê
For rent ?
can someone please explain sending sol to the program account
thank you!!!!
don't know why it wasn't working before
nevermind me stupid
Code?
passed them as raw bytes to the program?
üßê
how did you pass the seeds?
having trouble with pda addresses. trying to create a multiple unique account assigned to each user (publickey), but am having trouble getting around the seed limit of 32 bytes, since each publickey fills up the seed completely. anyone have a workaround?
please helpin resolving the error
error
lib.rs
test.js
Im fairly new in anchor. So, the question might sound stupid.
Also, I was just wondering,  if I need to modify a pda account later, do I need to pass the seed and bump to it ? Like I did it while creating an pda account in anchor or I can just use account mut attribute and continue to change it ?
Is see thank you.
<@!134416332509675520> for this code: https://github.com/ironaddicteddog/anchor-escrow/blob/master/tests/anchor-escrow.ts#L143

is it generally preferred to create the escrow account separately and pass it in like this or can I just create the esrow account inside my main handler?
asserts account discriminator is zero
Deserialise with zero copy?
What does #[account(zero)] do?
<@134416332509675520> any thoughts on it ser?
thank you!! what a weird error honestly
Guess you can do this? Ew
```.rs
            let market_bump = vec![market_bump];
            let inner_seeds = vec![
                b"market".as_ref(),
                ugh.as_ref(),
                wtf.as_ref(),
                market_bump.as_ref(),
            ];
            let signer_seeds = vec![&inner_seeds[..]];
```
the error is in `src/instructions/swap.rs`
https://github.com/RohanKapurDEV/anchor-cpamm
So it's this line where I need to ask the system program to take money out of the account that's getting debited?
This is where I store it then right?
Like this but in rust: https://solanacookbook.com/references/basic-transactions.html
In this case, the user is a system program account, not a your program account, so you can't just take its money like that. You need to ask its owning program, the system program, to do it for you
Key point: in solana, every account is owned by a program, and *only* that owning program can mutate the account's data or spend the account's money.
To do this lamport transfer from the user, you'll need to use the system_program's transfer instruction
That shows *where* you store it, but not the line where you actually write it
That's a different error: your program can yank lamports from an account it doesn't own
so the bump gets correctly saved here?
so this? still getting an error
Ok, think I'll need a github repo to tinker with to help more
same issue
So you're not actually sending it in from the client, since you already wrote it on some account (I think)
The bump is getting passed through because it lives on some other account (pool_account_ticket.bump)
?
Write the bump as `&[the_bump][..]`
Ok now it works but only if i remove the bump
Get rid of the `borrow_mut`s on the rhs of those equalities, just do `lamports().checked_add(...)` etc.
I don't understand how/if the bump is getting passed down
Do `inner_seeds = vec![b"market".as_ref(), ...]`?
```let inner_seeds = vec![b"market", ugh.as_ref(), wtf.as_ref(), &[market_bump]];
            let signer_seeds = vec![&inner_seeds[..]];```
Lol
I would need to see that part of your rust code
doing this throws ``` mismatched types
expected struct `Box<[&[u8; 6]], _>`
   found struct `Box<[&[u8]; 4], std::alloc::Global>` ``` at `inner_seeds`
That's an actual rust error
Ok, but now getting this error? Is this a mut issue?
You only need to sign when creating an account (you might need to sign for other random reasons, depending on what your instruction requires)
So can remove the `signers` array
You don't need to sign again for that poolAccount once you've already created it
but I want the FULL keypair and poolaccounticket is already the publickey?
I should think through how dropped temporaries work at some point but even my minutia brain just goes ü•±, oof
should the signer be the poolaccountticket?

sorry for so many questions, but looks like there's a different issue with deposits?
yeah seriously lmao
Lol, it's funny how occasionally rust is like "nah fuck you"
```.rs
let inner_seeds = vec![b"...", ....];
let signer_seeds = vec![&inner_seeds[..]];
```
lolol will try
i can remove the & and [..] before and after `godpls` and he still wont answer my calls
Oof, can you just add even more local variables?
Oh, I guess you do
Do you need the `[..]` here? Jeez, I can't do this part of rust in my head at all apparently
pain
Then do `&[&hmm]]` in the seeds argument?
```.rs
let hmm = vec![b"market", ....];
```
okay, that makes sense
Ok, give the whole inner &[...] a local variable
no combination of omitting any of the seeds results in error free code
So what's the recommended "workflow":

1) anchor test on "localnet"
2) anchor deploy to "devnet"
3) anchor deploy to "mainnet"?
Urgh lol
So yeah, it's always the same
That's not creating an address, it's just fetching it from your local solana config
nope üò¶
So this doesn't give me a new wallet address every time in devnet, but on localnet it also doesn't give me a new one, but it's "fresh", i.e. hasn't run before
I can't do this part of the rust compiler in my head yet, urgh
Does that type error go away if you get rid of the bump? (Temporarily, just to debug)
why must god forsake me like this?
You're only running into this problem because you were running your tests against devnet (doesn't totally make sense to me)
`init_if_needed` is probably not the right solution here‚Äîordinarily you just wouldn't keep trying to initialize the same account
This is why e.g. when you run your regular old web2 tests locally, you have some way to reset your local db in between test runs
So yeah, it's weird to run your tests directly against devnet, since you run into issues like this constantly
No way to initialize an account there again
So if you initialize an account at addres XYZ then there's an account there
Devnet has persistent account state

Looks like doing something like this works:
tbh I'm pretty confused. If I want to work on this in devnet then I have to check if it exists already?
And then use those `.as_ref()` in the seeds block
Like try doing
```.rs
let ugh = ctx.accounts.token_a_mint.key();
let wtf = ctx.accounts.token_b_mint.key();
```
not sure i fully understand what you mean.
Why would it effect you going to mainnet?
It's just being devnet all the time
No, devnet is actual devnet‚Äîit never gets reset üôÇ
and when I'm on devnet, I don't get a new validator? Isn't this an issue if I want to eventually go on mainnet
Urgh, you basically are going to have to stick in some annoying local variables üòî
Because when you run your tests locally, *without* a running validator in the background, then anchor test spins up a totally fresh validator each time
also localnet is so much faster haha
wait so how is this changed on localnet?
The wallet stays the same every time
Right, those are fixed (the user key is the provider.wallet)
and user key is regenerated every time right?
but the PDA takes in the seeds + user key
The collision was for the PDA, since its seeds were always the same
and how does that mean that there's collisions? do I not get a new address every tiem?
so I was running against devnet?
Which indirectly uses your Anchor.toml file
changed to localnet and ran twice -- and it worked both times
No, anchor test uses whatever your js code does
trying that ^^^
I thought I was told by someone here that that shouldn't matter because anchor test is only local?
So yeah, address collisions
Not localnet
Ah, ok‚ÄîI think what's happening is that you're actually running your tests against devnet
You can try changing `programs.devnet` to `programs.localnet` real quick
I'm definitely not doing anchor deploy, but I think I have previously as I went through the buildspace tutorial
Are you sure you're not using `anchor deploy`?
I think ü§î
Yeah, you're using devnet, not localnet I don't think
i think it might have something to do with the fact that im calling the cpi inside a match statement
not sure if this matters:
this is my entire file that I run
tried it, more or less the same error
I'm confused how you're running your tests, since if you're using anchor test without a live validator running, then you should get a fresh validator state each time you do `anchor test` (so no possibility of an address collision)
No, in your tests
Try inlining that `destination_signer` variable (just get rid of it and do that expression in the callsite)
in the rust file?
I have no idea, just restarted my terminal and just ran anchor test and got the same issue
not sure what this is even saying
Are you initializing that account multiple times?
Usually if you let anchor spin up the validator, then it spins up a fresh instance each time
Ok, how is that address already in use then?
I do only run that commdand
Yeah, to actually deploy you'd do that
and you should be doing anchor deploy (either on devnet or mainnet)
I would actually suggest only doing `anchor test`, no local validator running
I was told that anchor test just does local stuff
I'm not but I heard I should
Are you doing an `anchor deploy` step?
What network are you testing this on?
Ah, ok

Just type that command in your terminal, it will check if anything is listening on that port
I can quit my terminal and restart
what does that do?
`lsof -i :8899`
Are you running a solana-test-validator in the background?
I save the js file and run anchor test
that's how I running it, not sure what you mean by that
And just let `anchor test` spin one up from scratch for you
I would suggest that you not run a persistent validator in the background
Yep, seems like it worked, but you can't run it again because, yeah, you've already initialized an account at that address
--------------------------------
wait, I think I know what's going on. Looks like it's trying to initialize every time I run it, but the second time with the same seed means that there's a collision because it's already been initialized.

It looks like the pubkey of the user is the same every time -- but shouldn't
const provider = anchor.Provider.env();
anchor.setProvider(provider);

create a new pubkey every time?
Isn't that what's I'm doing with provider.wallet.publicKey.toBuffer()?
It makes sense that the seeds have to match and I should be passing in the user key as the seed
I may have run the wrong thing, but it looks like it did work the first time, but now it's throwing the same error?
I changed it to this:

Oh, sorry, misread what you meant
But above the second rust seed is user.key.as_ref(), so different
So if you use `poolAccount` there in JS as the second seed, it needs to be the second seed in rust too
I'm saying you need to match the seeds exactly between rust and JS
I thought I tried that, but trying that again
This should work?

so if I were to use that commented out portion
You've got PREFIX + user.key(), whereas the js side uses "escrow" (guess that's PREFIX), but then the poolAccount's key, not the user
yeah, you're using different seeds on the rust side
That's probably saying your seeds aren't quite right on the rust side, taking a closer look
Ok, that's different üëÄ
am I passing in the wrong things?
And get this error ^^

Just changed it to what you have above (I think I had this previously):
So do
```.js
const poolAccount = anchor.web3.Keypair.generate();
...
accounts: {
  poolAccount: poolAccount.publicKey,
  ...
},
signers: [poolAccount]
}
```
Above you're adding the public key part (or at least that's what's implied by when you also use it in the accounts part)
You need to add the full key*pair* to the signers array
haha I'm at the solana hacker house in seattle, definitely accelerating my learning curve
Get this error when I do that:
I thought I might need to do that, i.e. it should look like:
The `user` here signs automatically since it's the provider wallet, but you need to add the poolAccount's keypair to the `signers` array.
Whenever you create an account in solana, the address needs to sign. For a keypair address that means signing from the client, with the `signers: [...]` array, while for a PDA that means having the program sign (as you're doing above with the `init` + `seeds` etc. attributes)
Ah, sorry, you're more on track than I thought‚Äîthe issue is that you need to sign with the poolAccount keypair

On the front-end we're simplying "finding' the associated pda using the seed and poolaccount address
Isn't the signer the user?


What's likely happening is that your rust side expects the poolAccountTicket address to sign the tx from the client, but it can't because it's a program-derived address (only your program can sign for it)
Can you post the rust side?
Not sure if I have to include "signers: [xxxx]" in the initialize, but I tried that and that didn't work either
Everything looks like it should work to me.
Very stuck on trying to call initialize from my front end.
d'oh, yeah my mistake, but sweet thank you!
But yeah, you could have a script invoke your contract.
It signs the entire transaction (you don't really sign individual instructions).
does the program.provider.wallet.signTransaction function automatically sign instructions passed into them? I could presumably run a cron job that runs a script to create objects on a schedule with the program's provider wallet, correct?
I saw the "Add compute_budget_program" feature was enabled at slot 117072004. Does this mean we can increase our compute budgets now?
I'm happy to take a look locally if you can get me a github repo
Nope, wouldn't be any anchor-related changes there
looked closer and it turns out that the PDA is not a signer when being passed in the CPI. (even though in the program logs it says that the wallet account has privilege escalated). Strange cause I already use this `CpiContext::new_with_signer(...)` for the PDA. The whole thing was working when I tested everything on localnet in anchor 0.19.0. Is there something that I need to change with CPI calls between anchor versions (I'm using 0.20.1 now) or something I need to change between devnet/localnet?
understood, definitely helpful though
but keep in mind I can't really comment on your smart contract design, there's multiple ways to do it and there's trade-offs...
it should be ok
ah ok, that makes sense then, didn't know if it was acceptable to have self referenced storage for bumps
persist it in the root config
i have a good idea of where to persist most of the bumps, except for the root config
what about in the case where i need to use base bump in signer seeds for a cpi?
Or even better if you have a github repo etc.
Can you post your program log?
I think you should try the solana discord for this one
Hmm good question, I don't know the answer to this. I would assume that since the payer is already a signer for the program call you could just pass it in?
ya I've faced this problem many times before, but I think this is slightly different. The CPI needs to be signed by a PDA but there also needs to be payer. Since PDAs cant be payers, the CPI needs to be signed by both the wallet program and the PDA. I'm getting writable escalation errors for the wallet account not the PDA. I already use `CpiContext::new_with_signer(...)` for the PDA acc. Do I need to use `CpiContext::new_with_signer(...)` for the wallet account to somehow?
Your question is a bit vague, but I'm assuming you're trying to do a CPI that needs to be signed with a PDA? You need to use `CpiContext::new_with_signer(...)` and pass the seeds used to generate the PDA to do that.
This question has been asked before so try searching the `beginner-question` channel, you should be able to find some examples.
np
thanks again üòÉ
oh nice, that's really helpful info
because this checks that the account passed is the `Base` account, and if you know the there is only one, you know that it is the correct one.
doing just `pub base: Account<'info, Base>` will be enough
if you can make sure that only one Base account can ever be initialized in the "initilize" instruction
hmm I don't even think you need to have the constraints at all
i realize there are more constraints i can add
yup
you only have one base account for the whole program?
lastly what about a base account? nowhere to store it unless self references for constraint purposes are kosher? e.g. is this valid? ```    #[account(seeds = [b"base".as_ref()], bump = base.base_bump.unwrap())]
    pub base: Account<'info, Base>,```
any idea, why it is happing?
hello just wanted to bump
cool, good stuff and then the others are one off accounts that i can store the bumps. gracias
Yup
oh yeah! i didn't even think about that, so i don't have to do the checks on the seeds / bump at all - in this case i could do ```#[account(mut, constraint = config.metadata.mint == mint.key())]```
Yea you could also store the mint address in the config and do the check that way


///////////////////////////////////////////////////////////////////////////////////////////////

Ah, cool, what was the fix?
all good I finally managed to fix it. Thanks for the help!
Ah, hmm. I feel like I asked this already, but can I see the code for this?
E.g. if you say `Account<'info, TokenAccount>` but pass in an uninitialized account, you'll get that same error.
This can happen with any `Account<'info, Whatever>` in your Create instruction
but the program id is properly set ü§î
```
error Error: 3008: Program ID was not as expected
    at Function.parse (error.js?ab71:40:1)
    at Object.rpc [as create] (rpc.js?696e:38:1)
```
I'm getting an error 3008:
```
index.esm.js?1b5d:6781 Transaction simulation failed: Error processing Instruction 0: custom program error: 0xbc0 
    Program BKYHC1UxAAvaeZagebJdQYumzVYuDfNhd6Apm3bhb6TA invoke [1]
    Program log: Instruction: Create
    Program log: Custom program error: 0xbc0
    Program BKYHC1UxAAvaeZagebJdQYumzVYuDfNhd6Apm3bhb6TA consumed 4241 of 200000 compute units
    Program BKYHC1UxAAvaeZagebJdQYumzVYuDfNhd6Apm3bhb6TA failed: custom program error: 0xbc0
```
hi all
specifically the account being mentioned, its both a signer and marked as mut
This is probably because the anchor idl account was too small, need to init a new one
everything that I'm passing in on the CPI caller side is marked as mut. Could it be because its not marked as mut on the callee side?
This passes on localnet actually, so not sure why it is failing on devnet
I realise it is this error, but not sure how that relates to upgrading the idl as it is just the one generated by anchor, no weird custom logic
```    /// 3004 - Failed to serialize the account
    #[msg("Failed to serialize the account")]
```
hey there, I am running into this error when using `anchor idl upgrade` does anyone know why this might happen?
```
> Program log: Instruction: IdlSetBuffer
> Program log: Custom program error: 0xbbc
> Program 9Kz3PrNuXGogG97NA6GcPKYkDHC3uJtDszZvBY6QeUyn consumed 7273 of 200000 compute units
> Program returned error: custom program error: 0xbbc
> Runtime error: custom program error: 3004
```
specifically, can we use 0.21.0 js version with 0.18.2 rust?
Pretty sure answer is no but want to confirm--js versions are not backwards compatible with different rust versions right?
If anyone has ever done this before or knows how to do this, I'd really appreciate your help. Also willing to pay for consulting üôÇ
Also <@!134416332509675520> if you're interested in a tech review for some tokens let me know üòâ
This is perfect. thanks guys
no but bought tokens recently after finding it makes sense
Are you affiliated with them <@!653519450397474846> ?
perfect.
Haha
aiiight, let me plug my bags <cracks knuckles>
https://akash.network/
There has to be someone doing something like a decentralized lambda?
fair enough
then run a copy on Azure and Google Cloud
I don't consider a single company having the ability to shut us down being decentralized
Is that bad?
lambda is owned by amazon
I haven't actually used any but there are a million (eg. aws lambda)
Would hate to have a single point of failure for a dApp. Is there any services for hosting a decentralized API?
Hi, how can I interact with magic Eden programs to buy or sell with solana web3 because I believe it's made with anchor
Okay so basically don't index on chain and just cache everything on an API.
I think a centralized api for caching solves this forsure but we're a startup so are trying to avoid tech debt; talked to two companies doing indexing but they both ghosted us.
If you want to run your own decentralized client or whatever then good luck (possible but you'll have to keep up with the head of the list somehow)
Just do all your writes from a central place, which keeps track of the latest head of the list
Yeah ^
But I feel like you're definitely in the "maybe a blockchain just sucks for this usecase" territory
how about having a centralised backend that keeps the index?
Yeah, hmm, I'm not sure to be honest
Ideally you don't index at all and just fetch and order by a timestamp but that's not possible. Or is it?
How would you think about solving a high tps linked list?
That's the worst case scenario for solana's performance model
Also, by the way, I would have guessed that doing a 100 txs/second writing to a single account (that X thing with the count) would be problemmatic in and of itself ü§î
I guess this would be a case of premature optimization for us but it would be rad to have this data structure nailed down for the long run because it's core to our app
That works both ways for new messages and loading old messages.
By saving each message as a pda it helps with fetching and indexing on the client side because you can know exactly how many new messages there are in the chat and the pda of those next messages
But yeah, I'm not sure there's any easy way to get around this issue
I guess it makes storage costs more annoying, hmm.
Why not put batches of messages into a single account?
Hmm, not having thought about it much, that feels a bit odd to me (for basically this exact reason)
Yes
Do you mean that each message in the chat goes into its own account?
This is exactly how Bonfidas Jabber solves sequential messages.
Imagine we need a sequential list of Y accounts. We are solving this by having an indexing account X which increments `count` with each initialization of a Y account to the sequential list and having the Y Account be a pda of X's `count` that it fetches from X. If the pda index is already taken then it is an account collision. This works great for low TPS, but on high TPS when the Y account fetches the count it can already be stale before generating it's pda and calling initialize which would cause an account collision.
Great thanks <@!134416332509675520> ü§ù
Solana has this offline signing mechanism though https://docs.solana.com/offline-signing. I'm not familiar with it yet.
I think that by default it does, because part of the transaction that you sign is a recent blockhash. So if you sign a tx, then wait a week, you'll have to update the recent blockhash (invalidating the previous signature).
Mm, not sure I have a good mental picture of what you're trying to do. You're saying that the latest PDA's address would be changing a hundred times/second?
This part doesn't make sense to me, since you're trying to transfer funds from the PoolAccount (an account owned by *your* program) back to the user, but you're trying to do it via the system program. That doesn't make sense in solana (think we talked about this yesterday). At any rate, you're also trying to sign with a different account's seeds, since those seeds apply to the pool_account_ticket, not the pool_account.
Looking at Bonfidas Jabber as a reference. If there is very active group chat this issue will pop up.
Our pda is based on the index of the current count on a linked list. How can we handle this is we have something like 100 account creation per second? Would we just have to keep retrying? Everytime a slow connection attempts to fetch the current count it will be stale and their pda will already be taken.
For 2, the AccountInfo's lamports are pointers (try jumping to source), so they actually do reflect the right sol.
The `?` operator in rust short-circuits your code (early returns) if there's an error. Oddly, this actually isn't strictly necessary with CPI calls in solana, since if they actually aren't recoverable if they error (not obvious)‚Äîif they error your whole program just stops.
If you look at that log carefully it says that `  > 2QqWUAdCfvbwVnkwSaVePnD5E5xpevZWo734JMqpY1eB's writable privilege escalated
` so something hasn't been marked as mut.
E.g. that's what you do every time you use `init`.
You can create an account within your anchor program, but you have to specify its address from the client.
I can't create an account with System Program inside of a program?
There's no way to create an account inside of an anchor program?
AFAIK you need to declare all accounts you're gonna touch ahead of time
Maybe for this use case we can just create the pda inside the transaction?
Can I borrow a giga brains thoughts on storing *very long lists sequentially on chain that need high tps? We are currently using an index on an account that tracks the list and a pda made from that index. Just like Bonfidas Jabber. It works great but the only downside we see with this is once our tps goes up, slower connections will keep fetching stale indexes and will have to continuously regenerate their account pda
always around 10%, only since today
anyone knows why?
been stuck here

Since you need to make sure the byte array on the JS side has the same length.
That should work fine, though it is indeed a bit tricky to do the same exact thing from JS.
You're going to need to post way more code, not enough info here to help much!
Yeah, you'll have to pass in more accounts etc. and have a more complicated constraint in order to do the NFT collection thing (I haven't tried doing that myself though so not 100% sure what it will look like).
If yes, then this part of the task seems simple. But how does my constraint look like, if I don't want a USDC token account, but I want an NFT account that contains an NFT from a specific NFT collection? The problem is that each individual NFT has its own "mint". The only common denominator is the update_authority of the NFT program and the "creators" field in the metaplex metadata.
Is that correct?
My approach to ensure a token account with the mint being the USDC token program would have been to write following constraint: #[account(constraint = token_account_address.mint == usdc_token_program_address)]
Hi, Anchor noob here. I'm trying to rewrite the escrow example program so that it only accepts tokens from a specific mint. I want the initializer deposit token account to be an NFT account from a specific NFT collection and the receive token account to be USDC tokens. How would I ensure that via constraints?
nvm it was mismatch between function signature and `#[instruction(...)]`
Help please!
awesome thanks
anyone having trouble using a byte array in account seeds? Like `seeds=[others, num.to_le_bytes()]` where `num: u32`? Everything works fine if I remove that array. Or even replace it with `[0, 0, 0, 0]`
yes tx have an expiry. check out https://docs.solana.com/offline-signing/durable-nonce
Thank you, fixed it!
check your `Anchor.toml` if the `provider.wallet` is pointing to the file containing the key you use to deploy the program
can `anchor idl init` be ran after a program has been deployed or does it need to be run before?
What can I do to fix this?
Stating: Program authority does not match authority provided
But when in run anchor deploy I got an error
I want to deploy my solana program
Gm everyone
Quick question. Could person A partial sign a transaction, then wait 1 week, then let person B sign and broadcast the transaction? Essentially, does a partially signed transaction have an expiry ?
Hey folks! I am new with Anchor and trying as an experiment to write an escrow program replication yawww.io  for NFTs. I know that Solana runtime requires to pass all accounts at execution time, so I would to specify all the tokens accounts to do a transfer from a vault to another user. 
In the case of yawww they allow the client to put an arbitrary number of NFTs into their escrow vault.
How would one create such a context struct in Anchor whose length might vary depending on how many tokens the user decides to add?
anyone know how to find a bump given the public key and the program address? (reverse the find_program_address)
Hey @here, can some one tell me like if i am making an SPL token how can i define the percentage shares of different thing from my total supply like if i have a total supply of 100 and i said that 10% of this is for burning so is there any way that we can pass that in an spl token or do the token owner have to do the manual burning by himself of the 10% amount of total supply timely ?
And for the "withdraw", I thought it should be the exact inverse + the signer seeds. But looks like something is wrong with the signer seeds?
the yellow numbers are the before and after depositing 6 lamports total (and part of the lamports are going towards fees I'm presuming)
<@!134416332509675520> Trying to make a CPI call on devnet. getting privilege escalated error even though all the accounts that need to be signer are signer. Here is the program log when I make the CPI call: https://explorer.solana.com/tx/2HXAsSuDGcAeU3PZMY1miRomuk3xZ5wkxr7TJAaDi83uWgVJdZrxNvCY6NQUC3Fr8hqzRBBR2df8eonGpihzaJrM?cluster=devnet
when I call directly from client (without CPI) on mainnet it works fine: https://explorer.solana.com/tx/2s34Es4Hf2aGQUeeXHHVn9FcyMwPxZxyMGEazmAf91ai5q3dz7mn1zs2GFzs2qZxP35qrzejKqNFbd8rVgpvp4uK
The accounts being checked for signer are 2 and 3 but they are both signer
By just the counters/variables in the structs it looks like it's checking out, but these are obviously just counters and not tracking the actual sol moving
It looks like it's working? Have 2 quick questions:
1) I found other examples online and it needed the "?" at the end and I don't think I fully understand why it needs that.
2) I'm trying to test the amounts before and after to see if the numbers check out.
i am having the same problem, does anyone have a solution for this error? . Thanks everyone!
Getting the following error. I wrote a function to send sol to the other account in Rust. Tested it in the anchor framework. While i was integrating it in the frontend, it gives me the following error in the browser console:

Error sending SOL TypeError: Cannot read properties of undefined (reading 'toString')
    at Transaction.partialSign (transaction.ts:495:1)
    at provider.ts:109:1
    at Array.forEach (<anonymous>)
    at Provider.send (provider.ts:106:1)
    at async Object.rpc [as giftSol] (rpc.ts:24:1)
    at async sendSol (Modal.js:46:1)
getting this interesting error when attempting to cpi to the serum_swap program, which i have locally through git submodules
my program uses anchor `0.21.0`, and serum_swap uses `0.19.0`
when i manually edit the swap program's `anchor-lang` and `anchor-spl` versions to be `0.21.0` instead of `0.19.0`, the error goes away but then it blows my stack for some reason
is there a way to solve this without changing the serum_swap version? do i have to downgrade my own program to `0.19.0`?
fixed: i had the wrong program. thought it needed my program, actually needs TokenProgram
has anyone got error code 0x64 InstructionMissing from `token.createAccount`?
so if you were to go the opposite way (i.e. pda back to user account, you would need invoke_signed)
It's the destination account, not the source account.
Yes.
because the pda in this case is being credited?
So in other words, `invoke` is fine, no need to use `invoke_signed`.
So you need the user to sign from the client, no need for any PDA signature.
Here you're transferring from the user (presumably a system account?) to your PDA.
Yeah, for a system program transfer, only the source account needs to sign.
Meaning that the only entity that needs to sign is the one that is being debited? I think I understand that conceptually but not really how that manifests.
Ok I think that makes sense
(I'm being obnoxiously pedantic lol, hopefully helpful) the issue is that the *account* that lives at an address may or may not exist yet
Addresses are just big numbers lol, they all already exist (it's like saying, does 123123123123123 exist? Yeah)
Basically. I would suggest not thinking that the seed etc. already existed‚Äîthe point is that there was already an *account* that lived at that program-derived address.
which is completely separate from the program_id
and what was happening yesterday is that I was trying to communicate with devnet and the second time I tried to "initialize", the seed+pubkey already existed?
Got it, so if I anchor deploy once and do it a second time, all that is correctly dealt with
So if you redeploy, the old version is gone
Yeah, there's only ever one version of your code at a particular program_id
Okay, I think that makes sense. I guess my question is more like what happens when you "update" your code to devnet? The program points to a newer version of your program and is the old one correctly discarded?
The program variable is just a little helper abstraction to try to talk to a given program, based on its program_id + a particular cluster (devnet, localnet, mainnet, etc.)
This JS stuff assumes you've already deployed your code; it just says "given this program id and this cluster, try to talk to it"
But this is a matter of the cluster you're talking to, not like the `program` variable
Not unless you change them
If you create an account at some address on the devnet cluster, then it will stick around (unless you close the account)
Yeah, like the program and programId wouldn't change?
That depends on the solana cluster you're talking to
Ah, meaning re-using an existing address?
I guess I'm asking how/if it relates to the issue I was having yesterday where the seeds were already created given the address
But I'm not sure what that has to do with freshness etc.
The `program` abstraction here is set up to talk to a specific solana cluster, so if you tried doing this on devnet it would have to be configured to talk to devnet.
Sorry, I think I'm still confused about what you're asking‚Äîwhy does it matter if the instance is fresh or not?
like every time I run this locally, I will have a new fresh instance? But if I were to run this on devnet, the program and programID would be the same
You're transferring from the user right? Only the source account for the lamport transfer needs to sign
Mm... not totally sure what you mean by static. It's based on your program, so I guess if you keep using the same program_id for it, then yeah?
would I actually need "invoke_signed" here because we are signing for a pda?
and this is static (is the same every time)?
`program.account.someAccountType.fetch(someAddress)` says go fetch the account that lives at someAddress, and try to parse its data assuming it's a `SomeAccountType` struct in rust
Yep. That `program` is the anchor abstraction for talking to your Panceres program.
tbh, I'm not sure what the first program is exactly doing, but we need that programID to find the pda, in this case the pool account?
What I'm doing in the code above is fetching the account that lives at that address. (There are multiple ways to do it; the first is the low-level solana way, the latter is the fancier anchor way.)
The call to system_program::instruction::transfer just builds an instruction (a little data structure that describes what you want to do). And yeah, to actually execute that instruction, you need to do a CPI, by calling invoke
Mm... not sure what you're talking about here, can you say more?
program account of the main pool account?
so I need to wrap in "invoke(xxx)" because this is a cross-program invocation? (I'm asking system program to perform an action)?
poolAccountTicket is just an address; the account itself is a separate thing
What do you mean by PROGRAM ACCOUNT?
So you use the poolAccountTicket (unique to each user, derived from seed + user pubkey) to ask the PROGRAM ACCOUNT to fetch the given account given the poolAccountTicket information>?
Or something like
```.js
const theActualAccount = await program.account.poolAccountTicket.fetch(poolAccountTicket);
```
You would need to fetch the actual account that lives at that address,
```.js
const theActualAccount = await program.provider.connection.getAccountInfo(poolAccountTicket);
```
Or am I misunderstanding your snippet?
It's just an address, you can't dot into it to get the amount etc.
Ok, definitely won't work to do `poolAccountTicket.bump` etc.
poolAccountTicket is the pubkey derived from the "findProgramAddress" from the seed + userkey?
In that snippet it looks like `poolAccountTicket` is the address, not the account, or do you redefine that variable at some point
I think I'm having trouble actually initializing:

Everything is undefined on client side
That's how you build the instruction, but then you need to execute it with `invoke`
Something like this? (No error checking yet)
Thank your ser üëåüèΩ, it worked
Mm, what if you do `cargo clean` and then re-try building
Yes i have anchor-lang = 0.21.0 in dependencies
Dumb question, but do you have anchor_lang as a dependency in your program directory's Cargo.toml?
Here it is
Can you show your rust code
Anyone have any tips on reducing rent exemption? My program doesn't seem that big but is already costing my 5 SOL to deploy on devnet.
I am having this error when a try to run anchor build, anyone can help me?
Hello
ü•¥
hmm guess, its just not available in the version that Im using ...
y isnt it supporting set_inner??
no method named `set_inner` found for struct `anchor_lang::Account<'_, Config>` in the current scope
Hi, idk y im getting this error


///////////////////////////////////////////////////////////////////////////////////////////////

didn't get your point here?
right, but actually finding the program address, is there an easy way to look that up? i only have an interface to make  a cpi, not the cpi address itself
Either pass from client-side or define statically
right, so how do I find the address of the program I want to cpi into?
ok, It is confusing now. `let cpi_program = ....` is supposed to be the program address of the program you are trying to CPI into
so i need to find the program address of the program im trying to CPI to
which is the `vault` im creating
that program  im passing in from the client is the same program thats making this call though
`let cpi_program = ......`
I think you are doing this, right?
do you know how I can find the program address of the program i want to call? all i have is the interface for CPIs
got it, i'm probably not doing that
yeah
is it the address of the program being called?
what program should be passed into cpi context in general?
aah no idea, but if you want you can share the github repo, I'll then take a look and hopefully able to debug this
right now, i'm passing in the program id of the program making the cpi for the `obligationProgram`
to your point <@!717956950737813594>,the problem is probably the obligation program, as I should be passing in the program ID of the program I want to call
there you go!


can you share your frontend code for `initializeVault`. Let's see if you are passing all accounts or not
it looks like i'm providing all the needed accounts, right? there are 6
aah sorry, yeah you are doing
I think i'm doing that right? when I construct the CPI accounts i include a token_program

aren't I doing that on line 74?
you've to pass token_program as well
CPI'd program: https://github.com/jet-lab/jet-v1/blob/master/programs/jet/src/instructions/init_obligation.rs#L25


share the code if possible
I'm proving 6 accounts and the program i'm making a cpi to is also expecting 6 accounts though so that is strange

cool getting a different error now with the cpi, so that probably solved it?
probably you forgot to add `#[account(mut)]` on account

trying to call a cpi and getting this error
is the way to get them back
solana program close buffer_address
<@!134416332509675520> solana program show --buffers
space
<:Hangpepe:458800322127855627>
Sorry, not sure, I don't actually deploy stuff I just answer questions on discord üòõ
<@!134416332509675520>
how can i recover my lamports?
solana-cli 1.9.2 (src:f58b87be; feat:4100269022)
What version of solana are you using? `solana --version`
```Recover the intermediate account's ephemeral keypair file with
`solana-keygen recover` and the following 12-word seed phrase:
=====================================================================
horse when bird damp thumb cover sniff rough deliver sand receive pet
=====================================================================
To resume a deploy, pass the recovered keypair as the
[BUFFER_SIGNER] to `solana program deploy` or `solana write-buffer'.
Or to recover the account's lamports, pass it as the
[BUFFER_ACCOUNT_ADDRESS] argument to `solana program close`.
=====================================================================
Error: Pubsub error: UnexpectedMessageError("{\"error\": Object({\"code\": Number(-32601), \"message\": String(\"Method not found\")}), \"id\": Number(1), \"jsonrpc\": String(\"2.0\")}")```

hi, i tried deploy a program on mainnet and
Hi guys, I have issue with passing an object of struct ``TestObjectParam`` from the js.
this was the contract code :-
```
#[program]
pub mod Test {
  pub fn test_fn(
      ctx: Context<Initialize>, 
      test_object_param: TestObjectParam,
      ) -> ProgramResult {
          ....
          ...
          ......
      Ok(())
  }
}

#[derive(Accounts)]
pub struct Initialize {}

#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub struct TestObjectParam {
    ..
    ....
    data: u8
}
```

i'm trying to call the ``testFn`` from the js like as below
```let testObjectParam = {
    data : 100
    ..
    ....
};
const tx1 = await program.rpc.testFn(
    testObjectParam,
    {}
);```

It throws error saying that Invalid arguments
``Error: Invalid arguments: testObjectParam not provided``

can anyone, please help me out to pass the TestObjectParam Object as a parameter to rpc testFn function, thanks
got it. So sounds like the best use case is for an ATA then.
If you need to differentiate, then make 2 instructions, don't use init_if_needed.
correct.
What's the best way to check whether an account was init through init_if_needed or not?
so the following is not possible ? create a wrapper anchor program which makes a mint and pda token accounts  and then call the candy machine with those accounts ? and is it because in this tx i do there would be an instruction calling my wrapper program which is not the token program or the system program ?
haha, the concept sounds so simple, oh well, will see how I go...
welcome to chomping on glass! bloody gums be damned.
Thanks for that, probably just saved me a whole lot of time. Ye I think maybe cloning and manipulating the mintnft function might be the best way. I need to confirm that the minter owns nfts from two different collections before allowing them to mint. I wasn't expecting it to be so difficult but it's proving to be quite a challenge
You are probably passing wrong program id or seeds to `utils.publicKey.findProgramAddressSync`.  It uses the AssociatedTokenProgram program ID:

```      await PublicKey.findProgramAddress(
        [owner.toBuffer(), programId.toBuffer(), mint.toBuffer()],
        associatedProgramId,
      )```
In fact, `createAssociatedTokenAccount` calls `getAssociatedTokenAddress` internally

https://github.com/solana-labs/solana-program-library/blob/master/token/js/client/token.js#L494
It shouldn't.
Im generating a mint from `Token.createMint()` . Why is deriving an ATA from the mint.createAssociatedTokenAccount(...) result in a different account than `SplToken.getAssociatedTokenAddress(...)`  or doing it 'by hand' via  `utils.publicKey.findProgramAddressSync(...)`?
Maybe the whitelisting features would give you the functionality you want
You can certainly clone the candy machine program itself, change how it works, and deploy your version.  Nothing wrong with that.
Correct.  You will not be able to mint from a candy machine via cpi.  It's a security issue to protect the integrity of the mint.  Too much gaming.  Too many bots.  The random + cpi prevention + other ix prevention + captcha are purposefully there to stop any type of gaming.
Awesome!
I'm trying to follow what you guys are saying above... Does this mean that a program cannot call Candy Machine mintNft function via CPI? This is one of the reasons I'm trying to clone candy machine, I wanted to add in some custom logic before allowing someone to mint an nft by interfacing with candy machine via a custom program?
I assume done that way as opposed to a pure pda in case the account is too large for cpi creation
it's a derived pubkey with base as a PDA with no seeds , seed as "anchor:idl", and program id of your program.
Thanks üôÇ
The idl address can be found like this:
https://github.com/project-serum/anchor/blob/master/ts/src/idl.ts#L156
(line 731)
And yes they check the address of the sysvar, so you can't game it like the hacker did with wormhole üòÜ
specifically line 415
https://github.com/metaplex-foundation/metaplex-program-library/blob/master/candy-machine/program/src/lib.rs#L395

lines 395 to 423
ooooooooooooh alright, would love to see this in the source code it self any pointers or link
It's to ensure no one is gaming the mint.  Otherwise you could check what was minted and fail the tx if you didnt like it
not possible because they explicitly check the Instructions sysvar to make sure the instruction to mint is called standalone and nothing else is in the tx except token_program or system_program
read something along that the signer does not sign the cpi call
Rip, i dont understand why though
I've been told it's not possible on metaplex discord, so I stopped trying
has anyone managed to cpi into the candy machine v2 and create an nft yet ? <@!707604162673639504>  <@!917687988266352640>
Thanks, I'm trying to find the idl address now for the program. I‚Äôve assumed that I can switch config url over to main net and run `anchor idl fetch cndy3Z4yapfJBmL3ShUp5exZKqR3z33thTzeNMm2gRZ` but it returns with Error: Account not found.

How would I go about finding the idl account?
yeah its somewhat counter-intuitive - you have to pass in the account when it isn't even created yet.  You're passing the address tho - not data.
got it üëå
clone the IDL account also
Hey there, I'm trying to clone meta plex on a local test validator by using `solana-test-validator -um -c cndy3Z4yapfJBmL3ShUp5exZKqR3z33thTzeNMm2gRZ`

Seems to work ok but when I try to access the idl using `anchor.Program.fetchIdl` it returns null.

Can anyone help me to find out what I‚Äôm doing wrong here
you can't convert a pubkey to an account_info on chain.  The account pubkey must be passed to a program to have the account_info

The typescript client needs to do findProgramAddress and pass it in.

*Programs cannot access accounts that were not provided*
Is there an easy way to convert the anchor pubkey found with `find_program_address` to account info easily? it dosen't seem to have a `to_account_info` method
ü§Ø
note: this is the part that anchor 0.21 does for you with the anchor.toml feature flag enabled!
`const [ mykey, myBump] = await anchor.web3.PublicKey.findProgramAddress([ Buffer.from("obligation"), marketPubkey.toBuffer(), borrowerPubkey.toBuffer() ], program.programId);`

reference: https://project-serum.github.io/anchor/ts/classes/web3.PublicKey.html#findProgramAddress
yeah
and I need to provide the same seeds when its finding the program address as are used in the init method, right?
got it
if there is seed and bump
so anything initialized in context is usually a pda?
Hence It's PDA
It is initialising using bump and seed, and PDA is basically an off-cure account
how can you tell its supposed to be a pda?
It's a PDA I guess, so use umm maybe `findProgramAddress`
I'm not sure if I should generate a new keypair locally for that or what actually
or rather an account that is created during the InitializeObligation instruction
thats also a good point, the obligation should be a newly created account
I didn't think, they are expecting same account

`borrower` and `obligation` have the same account, intentional or?
thanks, getting the same error, but probably a step in the right direction
It is
yeah
not the mint account
thats a good point, maybe its looking for THE token program
are you sure you passed the correct token_program account?
for sure
https://github.com/jet-lab/jet-v1/blob/master/programs/jet/src/instructions/init_obligation.rs#L25

share code bruh?
I'm getting an error while making a CPI that i'm missing a needed account from the cpi, but it looks like i'm passing in all required arguments. Any idea what the problem is?

```
logs: [
    'Program 8KFe29BGwPevewGY147ytq2mSGuNVRtM4JaikvF6D26G invoke [1]',
    'Program log: Instruction: InitializeVault',
    'Program 11111111111111111111111111111111 invoke [2]',
    'Program 11111111111111111111111111111111 success',
    'Program 11111111111111111111111111111111 invoke [2]',
    'Program 11111111111111111111111111111111 success',
    'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [2]',
    'Program log: Instruction: InitializeMint',
    'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 2344 of 170221 compute units',
    'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success',
    'Program 11111111111111111111111111111111 invoke [2]',
    'Program 11111111111111111111111111111111 success',
    'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [2]',
    'Program log: Instruction: InitializeAccount',
    'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 3297 of 155190 compute units',
    'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success',
    'Program log: true',
    'Program log: Initialize vault',
    'Program log: Transferring 100000000 lamports from `vault_admin` to `vault_authority`',
    'Program 11111111111111111111111111111111 invoke [2]',
    'Program 11111111111111111111111111111111 success',
    'Unknown program JPv1rCqrhagNNmJVM5J1he7msQ5ybtvE1nNuHpDHMNU',
    'Program 8KFe29BGwPevewGY147ytq2mSGuNVRtM4JaikvF6D26G consumed 62096 of 200000 compute units',
    'Program 8KFe29BGwPevewGY147ytq2mSGuNVRtM4JaikvF6D26G failed: An account required by the instruction is missing'
  ]
}
```
quick question about `anchor_client`. is this fails, does it throw an error in my face or fail silently?
extra info here 
https://docs.google.com/document/d/1isGJES4jzQutI0GtQGuqtrBUqeHxl_xJNXdtOv4SdII/edit?usp=sharing
Awesome, will check it out thank you
since solana program itself is stateless, I dont think there is a built in `emit` mechanism (at least not that I know of )
if you look at serum dex, I think they implement it with a requestQueue, but you need an external tool to crank the events out. Check out crank in serum-dex repo
bump
some updates on this (again big thanks <@!134416332509675520>  as always passionately helping people out). For those people struggling using Apple M1 with solana dev tools, I managed to get through using the below 2 resources
https://github.com/project-serum/anchor/issues/876
https://dev.to/nickgarfield/how-to-install-solana-dev-tools-on-an-m1-mac-kfn
if you are running earlier versions like 1.8ish (cuz anchor deploy using 1.9 hangs forever), you need to build from source with Rosetta enabled. Hope this will help
true, true, I was confused with the serialize_data method of the accountInfo
Borsh gives you a ::serialize method that takes any Writer (and that weird double &mut thing is a Writer)
That's just using pure borsh
my question with this solution is: are you serializing a serialized object? greeting struct use borsh but the serialize method use bincode behind
Can see an example of low-level data-writing here: https://github.com/solana-labs/example-helloworld/blob/master/src/program-rust/src/lib.rs#L44
I am trying to create a pda but I want to pay for one epoch only. My solution to this problem is to check if the account data is empty, if yes I create the account, but I need to fill the account with the data, someone know how to do this? I am using an UncheckedAccount
Probably way quicker for me to debug that way
Can you add me to a github repo or something?
Assuming it's working and my logic is sound
Because the user wallet should be depositing into the escrow pool account and withdrawing back into the user wallet?
the user public key wallet
Which balance is the same? I probably need to be able to run your code to really see what's going on
Also, still unsure about this when deploying to devnet.
Like this? The balance at the end is still the same.
It's possible that you submit the tx but then refetch the balance too quickly for it to have gotten completely confirmed
You (might) need to do more than just await the rpc call, you may need to do what I wrote above
I can try a breakpoint
I‚Äôm pretty sure I‚Äôm awaiting at each deposit/withdraw step
Can also just try sleeping for a bit, setting a breakpoint and chilling, etc.
Did you make sure to wait for the tx to confirm?
```.js
await program.provider.connection.getConfirmedTransaction(
  await program.provider.rpc.doSomething(...),
  "confirmed"
);
```
This would be the user account balance
Different withdrawal amounts all output the same balance
This is how I‚Äôm checking balance, once before and after
Looks pretty plausible to me
How did you check?
Just running the code above didn‚Äôt look like it was correctly withdrawing though, according to before and after balance checks
No need to wrap this in an invoke or anything‚Äîthe pool_account is owned by your program so your program can just do the work itself. `invoke` is only for when cross-program invoking a separate program.
and a fresh instance is spun up every time you run anchor test
or at least that's my understanding
not sure what the [features] are but setting url to local and changing anchor.toml to localnet run it locally
also, any pointers on how the `[features]` and `[programs.localnet]` fields of `Anchor.toml` work
is it possible to load a program and its accounts from devnet for testing locally?
Separately, I'm running into the same issue I had when deploying to devnet -- not sure I totally understand what's going on but basically the pda already exists (created via seed + user key).
Not sure what the "let s = src.key().to_string() is doing here, but this is what I thought should work but doesn't look like it is.

I think I want to be wrapping this in an "invoke" but I'm not sure how to structure it given that these are two different transactions it looks like?
fyi `cargo build` and `cargo check` work fine...
Anyone know why I might be getting this error? ```‚ùØ anchor build
BPF SDK: /home/utx0/.local/share/solana/install/releases/1.9.6/solana-release/bin/sdk/bpf
cargo-build-bpf child: rustup toolchain list -v
cargo-build-bpf child: cargo +bpf build --target bpfel-unknown-unknown --release
Unable to get file metadata for /home/utx0/Code/hydra/hydra-protocol/target/bpfel-unknown-unknown/release/hydra_staking.so: No such file or directory (os error 2)
```
lmk if I can add any more context <@!134416332509675520> üôè
Yea, it figures it out from the instruction params... I thgink there is info on that instruction struct
It contains metadata about an nft such as update_authority, creator, mint authority etc.
A metaplex metadata account is a pda that is generated with the token program id and the metaplex program id as seed
thats an interesting interface, guess it figures out which instruction is being called from those accounts and ix param structs
so just to reconfirm, all i need to pass in are the accounts struct and the instruction params? i dont need to use any other functions to target the instruction specifically from the client?
Specifically, I would like to access the data of a metaplex metadata account (pda) and write a constraint that the token program that was passed has a metadata account which contains data that fulfils certain criteria
Thanks, that gives a lot of insight actually!
^ That program will be kind of incomprehensible if you haven't gone through all of the anchor tutorials though
If you want to access a specific token account's data (like, how many tokens it contains), you need to use `Account<'info, TokenAccount>` and pass in its address from the client
Try looking at this example program: https://github.com/cqfd/quidproquo
I came across a "data" field that is in Program<'info, Token> but it's datatype is "Rc<RefCell<&'a mut [u8]>>" and I don't know how to parse/deserialize it or use it in a constraint.
No problem... like I said, the red squiglys are SUPER annoying... especially in Rust code, but at least it works
thank you, Hunter!!
wow it actually compiles lmao
What have you tried so far?
The data that's stored on the blockchain
Thanks. How do I get the data?
`Account<'info, TokenAccount>` + add `anchor-spl` crate to your Cargo.toml
And how can I use this parsed data in a constraint?
How do I parse the data that is stored in a token program in rust?
Yeah, rust-analyzer can struggle with valid macro stuff.
Did it compile?
no, just call the instruction from an offchain client
ok ser i will give this a shot
It will compile and work for you. Promise
Rust_analyzer needs to be fixed. I have tried a lot to get it not to yell at me and I have no good solution
That code was generated by a macro
If you look at the source code for rust_analyzer it says it gets false positives for code generated by a macro

Yea, I told you it will. Ignore it.
rust analyzer yells at me
but change out baseic_2 for the contract name you are using
use basic_2::accounts as basic_2_accounts;
use basic_2::instruction as basic_2_instruction;
No, trying to use the rust_client
r u trying to make a cpi?
what does the import statement look like in my case then?
It will work for you. I promise
It does... it's created by a macro
i am trying to use the `execute_sale` instruction from this contract: https://github.com/metaplex-foundation/metaplex-program-library/tree/master/auction-house

`ExecuteSale` is the accounts struct but the program doesnt seem to expose an instructions struct for me to use. all i can get is `auction_house::execute_sale` which is the function of the instruction from the contract (its a function, not a struct)
What do you mean? like rust_analyzer yells at you or there really is an issue
yep! https://github.com/mark-antony1/jet-vault
i cant seem to import the instruction structs from the anchor program im using for some reason. accounts struct can be imported just fine though
It is anoying as hell because rust_analyzer can't recognize code pulled in from macro generated code, so it creates a false positive for me... hate red squiglys in my rust code... anyway, you just use those instead of an idl
see `use basic_2::accounts as basic_2_accounts;
use basic_2::instruction as basic_2_instruction;`
So Anchor creates accounts and instructions structs automatically
ok so for this function: https://github.com/project-serum/anchor/blob/master/client/example/src/main.rs#L141

how is it working really? i can see that it passes in the `Create` accounts via `program.accounts()`  and the `Create` params via the `program.args()` but is that really all that's needed? the call the create instruction in the program?

<@!847130012879814668> would appreciate input on this
I have done a lot here... happy to help
trying to fetch idl
Guys what's the solana equivalent to `emit` in solidity?!
or any suggested best practice to handling events
Anyone know the reason this is happening?
Are there any docs or open source projects out there where I could learn how to interface with solana from an iOS client ?
Mm, can you send me a github repo?
yep!


```
Transaction simulation failed: Error processing Instruction 0: custom program error: 0xa8 
    Program Cw4xY7rsYrsY15WxHi8wy7ZD2G7cp3TKxGZiwD28zMAe invoke [1]
    Program log: Custom program error: 0xa8
    Program Cw4xY7rsYrsY15WxHi8wy7ZD2G7cp3TKxGZiwD28zMAe consumed 6618 of 200000 compute units
    Program Cw4xY7rsYrsY15WxHi8wy7ZD2G7cp3TKxGZiwD28zMAe failed: custom program error: 0xa8
Translating error SendTransactionError: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: custom program error: 0xa8
    at Connection.sendEncodedTransaction (/Users/jchri/repos/solanaRepos/fuze/vault/node_modules/@solana/web3.js/src/connection.ts:3689:13)
    at processTicksAndRejections (node:internal/process/task_queues:96:5)
    at Connection.sendRawTransaction (/Users/jchri/repos/solanaRepos/fuze/vault/node_modules/@solana/web3.js/src/connection.ts:3649:20)
    at sendAndConfirmRawTransaction (/Users/jchri/repos/solanaRepos/fuze/vault/node_modules/@solana/web3.js/src/util/send-and-confirm-raw-transaction.ts:27:21)
    at Provider.send (/Users/jchri/repos/solanaRepos/fuze/vault/node_modules/@project-serum/anchor/src/provider.ts:114:18)
    at Object.rpc [as initializeVault] (/Users/jchri/repos/solanaRepos/fuze/vault/node_modules/@project-serum/anchor/src/program/namespace/rpc.ts:24:23) {
  logs: [
    'Program Cw4xY7rsYrsY15WxHi8wy7ZD2G7cp3TKxGZiwD28zMAe invoke [1]',
    'Program log: Custom program error: 0xa8',
    'Program Cw4xY7rsYrsY15WxHi8wy7ZD2G7cp3TKxGZiwD28zMAe consumed 6618 of 200000 compute units',
    'Program Cw4xY7rsYrsY15WxHi8wy7ZD2G7cp3TKxGZiwD28zMAe failed: custom program error: 0xa8'
  ]
}
```
Can you post the full program log?
`     Error: 168: Program ID was not as expected`
I had it as this before in ts, but was getting the same error

```
    await program.rpc.initializeVault(
      vaultName,
      vaultLamports,
      bumps,
      epochTimes,
      {
        accounts: {
          vaultAdmin: vaultAdmin.publicKey,
          vault,
          vaultAuthority,
          usdcMint,
          market,
          marketAuthority,
          redeemableMint,
          vaultUsdc,
          // obligationProgram: vault,
          systemProgram: anchor.web3.SystemProgram.programId,
          tokenProgram: TOKEN_PROGRAM_ID,
          rent: anchor.web3.SYSVAR_RENT_PUBKEY,
        },
        signers: [vaultAdmin],
      }
    );
```
If you want to specify a mint account, then you'll have to do
```.rs
pub some_mint: Account<'info, Mint>
```
Not a specific mint, etc.
tokenProgram, as you have above in your derive(Accounts), needs to be the actual spl token program
Yeah, that's wrong: `tokenProgram: usdcMint`
```
    await program.rpc.initializeVault(
      vaultName,
      vaultLamports,
      bumps,
      epochTimes,
      {
        accounts: {
          vaultAdmin: vaultAdmin.publicKey,
          vault,
          vaultAuthority,
          usdcMint,
          market,
          marketAuthority,
          redeemableMint,
          vaultUsdc,
          // obligationProgram: vault,
          systemProgram: anchor.web3.SystemProgram.programId,
          tokenProgram: usdcMint,
          rent: anchor.web3.SYSVAR_RENT_PUBKEY,
        },
        signers: [vaultAdmin],
      }
    );
```
Can you post that chunk of your JS code?
What are you passing from JS?
You're only using two `Program`s in that section, so it's either the token one or the system one üòõ
Well I don't know which program ID i'm passing in is wrong, or how to identify the right one to pass in, so I was asking if the information above would help me identify the right program ID

does that clarify anything üòÖ?
Mm, not totally sure what you mean, it's just another account:
```.js
await program.rpc.doSomething(arg1, arg2, {
  accounts: {
    ...,
    tokenProgram: spl.TOKEN_PROGRAM_ID
  }
});
```
```

#[derive(Accounts)]
#[instruction(vault_name: String, vault_lamports: u64, bumps: VaultBumps)]
pub struct InitializeVault<'info> {
    // vault Authority accounts
    #[account(mut)]
    pub vault_admin: Signer<'info>,
    // vault Accounts
    #[account(
        init,
        seeds = [vault_name.as_bytes()],
        bump,
        payer = vault_admin
    )]
    pub vault: Box<Account<'info, Vault>>,
    // This is the PDA that holds SOL to pay for the margin account
    #[account(
        mut,
        seeds = [VAULT_AUTHORITY_SEED.as_bytes(), vault_name.as_bytes()],
        bump = bumps.vault_authority
    )]
    pub vault_authority: UncheckedAccount<'info>,
    #[account()]
    pub usdc_mint: Box<Account<'info, Mint>>,
    #[account()]
    pub market: UncheckedAccount<'info>,
    #[account()]
    pub market_authority: UncheckedAccount<'info>,
    #[account(
        init,
        mint::decimals = 8 as u8,
        mint::authority = vault_authority,
        seeds = [REDEEMABLE_MINT_SEED.as_bytes(), vault_name.as_bytes()],
        bump,
        payer = vault_admin
    )]
    pub redeemable_mint: Box<Account<'info, Mint>>,
    #[account(
        init,
        token::mint = usdc_mint,
        token::authority = vault_authority,
        seeds = [VAULT_USDC_SEED.as_bytes(), vault_name.as_bytes()],
        bump,
        payer = vault_admin
    )]
    pub vault_usdc: Box<Account<'info, TokenAccount>>,
    // Programs and Sysvars
    pub system_program: Program<'info, System>,
    pub token_program: Program<'info, Token>,
    // pub obligation_program: UncheckedAccount<'info>,
    pub rent: Sysvar<'info, Rent>,
}
```
for context
so for     `pub token_program: Program<'info, Token>,` the Token should live as another param passed into the context struct?
So ideally it should be clear from your derive(Accounts) struct.
When you say Program<'info, SomeProgram>, the SomeProgram struct specifies which program id it expects
Like this:
```.rs
fn transfer_from_account_we_own(
    src: &mut AccountInfo, // we better own this account though
    dst: &mut AccountInfo,
    amount: u64,
) -> ProgramResult {
    let s = src.key().to_string();

    **src.try_borrow_mut_lamports()? = src
        .lamports()
        .checked_sub(amount)
        .ok_or(ProgramError::InvalidArgument)?;
    **dst.try_borrow_mut_lamports()? = dst
        .lamports()
        .checked_add(amount)
        .ok_or(ProgramError::InvalidArgument)?;
    Ok(())
}
```
Got it, thanks

is there any way to find out which program id is expected?
This makes sense but I'm not totally sure how to transfer SOL without asking the system program
Yeah so this is the before and after of the account getting debited (I'm sending a total of 6 lamports). But obviously there's lamports missing and want to make sure that actually 6 are getting. It looks like it given the last few digits.
Yeah‚Äîfrom the client's perspective all accounts are passed as addresses
meaning i'm passing in the wrong public key value, not the wrong type?
Just do that as well for wherever you shipped the sol to
Ah, ok that works too
This is what I was doing to get the balance (did it once before, once after). But don't know how much is getting lost to fees, etc.
That means that pubkey needs to be the spl token program's program id
So how do I change the  PublicKey i'm passing in via typescript so it matches the correct type of Program<'info, Token>
Testing in JS? You would need to refetch the raw account data,
```.js
await program.provider.connection.getAccountInfo(theAddress)
```
I guess what I'm trying to ask is the best way to test to make sure the correct amount is being debited/credited on both sides
Right, you need to just directly yank those lamports yourself
Wouldn't this mean that I don't actually need "invoke_signed" because I'm debiting from PoolAccount
Mm, maybe I misunderstood your question
What do you mean by "jumping to source" here? Like right now I'm reading the values from the pointers to the lamport values?
will go through that, thanks
Does the example repo work? https://github.com/project-serum/anchor/tree/master/client/example
People forget that the client payer is automatically marked as mut, so they forget to mark it as mut themselves
are there any example repos for building an instruction for an anchor program via the `anchor_client` lib?
Ah, yeah, this is unfortunately a very common bug :/
so I was using a library to make the CPI call. This library had function definitions and struct definitions that are supposed to help me make the CPI call. I used one of these structs to make a CPI call but in that struct the account that was supposed to be payer, was not mut. So you were right, something wasn't mut, it was just not super obvious hahaha


///////////////////////////////////////////////////////////////////////////////////////////////

Hi <@!202864446903681026>, i am also stuck with this same error. can you able to resolve that? problem. could you please help me with this situation. how can i fix this Error?
Hi there .. I am trying to execute some Tx of a specific program using the multisig program. The problem I have is the Tx I am trying to call  creates a new account and the signature (keypair passed in the original Tx as signer) is required by the multisig program when executing the Tx .. any suggestion of how can I solved that problem ?
Just use a `?` afterwards: `so_something()?;`
I think it would be cool to be able to generate typescript interfaces from IDL and package them into a client lib automatically.

Interested to hear if this is under development or of any 3rd party tools to do it?
what should be done then? it yells at me if i don't do something with the result of the cpi call?
There is no # instruction limit.  Only a CU limit.  Removing the `msg!` in a large program after a dev cycle typically cuts this down enough to duck under.

The word "instruction" in that error is misleading.  It's referring to CU - compute units. It the context of BPF execution though, its referring to "instructions" as in processor level instructions.
If it's for your own custom type then yeah, I would just use Option
Yeah there isn't really any advantage one way or the other
I meant that.
Ah, sorry, do you mean impl AccountDeserialize for the whole account? Yeah that could work
do you prefer to use Option standard?
So at that point there's kind of no point using COption I feel like, unless I'm missing something
What are you trying to do/why do you need to use COption? I think you actually can't impl those traits for it without introducing a wrapper type (rust impl rules)
so do I need to impl `anchor_lang::AccountDeserialize` customized for the account including `COption`?
Nope, don't think so
does Anchor not support serialize/deserialize `COption` yet?
Unless I'm being misled ü§î
(I have to admit, solana is kind of amazing at coming up with plausible but misleading names lol, it's pretty funny)
The `instruction` term is misleading, it actually means compute units
You can't use the result of CPIs actually (they either fail + short circuit your program completely, or they return nothing)
weird that the number of instructions remained, but removing logs fixed the error message of `failed to complete: exceeded maximum number of instructions allowed (21769) at instruction #79884`
removing program logs seemed to help and it now passes again
1) some of my program logs are for logging the result from a cpi that, as the result from the cpi needs to be used, should I do something else with that result instead?

2) is there not an explicit message saying that i'm running out of compute units?
Could also see if you can sneak in under the cap by removing extra stuff, like any of your own program logs etc. (I don't have much intuition for how much that will help though)
Mm, yeah, maybe‚Äîyou're running out of compute units
looks like i'm exceeding the maximum # of instructions allowed

do i need to move my existing CPI calls into other functions that get called from the client?
thanks for the response! Do you have an example on how i would sign, then sending to a service for admin signing?
TIL üî•
Is this in that github repo? I can take a look
You're probably running out of stack space in your instruction function
Yeah, you actually can't Box UncheckeAccount/AccountInfos (wouldn't help)
it looks putting variables in {} for context worked though
it must not be implementing whatever a box requires cc: <@!99911938955309056>
happy to debug & brainstorm
why? If you are getting it, share the log here
I don't think i can, getting errors everywhere if I do
If you can‚Äôt use a pda, yes signing, then sending to a service for admin sign would work. Most likely though, your design can leverage a pda. Very much depends on what you‚Äôre doing.
Hey guys, anyone have any idea how to send SOL tokens while calling JSON RPC anchor functions?
Hello there! hoping to get some clarification around signing instructions

I have a react application. I have an instructions that requires being signed by the users wallet as well as the admins wallet, but i don't want to expose my admin wallet in the frontend. A possible way around this is having a user "presign" the instructions sends it to the backend where the admin then finish signing the instructions, and send it off to an rpc endpoint. 

Is a presign mechanism possible? if not, how should i be getting around this problem of needing a signature from user as well as admin, without exposing admin wallet and their private keys to the frontend? Thank you so much.
There are some issues. Not sure specifics, but I hear rumblings here and there
Think everything works normally now (I'm on an M1 but have been too lazy to stop using rosetta, so not 100% sure)
more of a general solana question but im ordering a new macbook and was wondering if there were anyone has ran into issues with developing on the m1 macbooks (whtether for solana, anchor, docker or any related tooling etc). i remember you used to have to use rosetta but that part of the readme was removed from the github last month
Hi, can anyone explain me where is problem? I set dex program id to serum devnet, call my program on devnet but transaction fails because serum mainet address was not found. Anchor v 0.21.0 and v0.20.1
I am following this swap example https://github.com/project-serum/swap
```
pub fn initialize_open_orders(ctx: Context<InitializeOpenOrders>) -> ProgramResult {
        let ctx = CpiContext::new(ctx.accounts.dex_program.clone(), ctx.accounts.into());
        dex::init_open_orders(ctx)?;

        Ok(())
    }
```
Is it possible to use the solana explorer to inspect our anchor transactions? Anywhere we can upload an IDL or something?
Try this out : 
```
const VAULT_AUTHORITY_PDA_SEED:&str = "vault-authority";


#[account(
      seeds = [VAULT_AUTHORITY_PDA_SEED.as_ref()],
      bump)]
    pub vault_authority: AccountInfo<'info>,```
```
const VAULT_AUTHORITY_PDA_SEED: &[u8] = b"vault-authority";
...
#[account(
      seeds = [VAULT_AUTHORITY_PDA_SEED],
      bump)]
    pub vault_authority: AccountInfo<'info>,
```

The IDL PDA generator hates this for some reason: ```WARNING: unexpected seed: Path(ExprPath { attrs: [], qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(VAULT_AUTHORITY_PDA_SEED), arguments: None }] } })```

I tried `seeds = [VAULT_AUTHORITY_PDA_SEED.as_ref()],` but that doesn't build.
I see this error, maybe the program is wrong somewhere, bro, is there a way to fix this?
Drop more
I have 4 sols in my account
not enough sol
When I run the command anchor deploy, I get an error like this, does anyone know how to fix this?
Can someone help?
What I want is to record the result of the instruction of a custom on-chain program in a transaction.

Exactly this.
Hi <@!371810607403630603>. Here is example what is told.
https://explorer.solana.com/tx/5mW1gGtBFNJs7uEKDj82nyN4GYJVj9gkrwSze4BcuihQ33xrzCmQRFbrNNzeUV9xKoPUt82EC5PED5Df1Y7FcqGD
hmm is this like a security check?
https://spl.solana.com/memo
it seems like they define these functions on rust docs but don't really spell things out clearly?
hmm what does spl_memo do exactly?
Is it possible to use spl_memo in an on-chain program? If possible, can i find such an example?
how can i initialize an associate account by my publicKey?
are there any in depth writeups of token using contracts with anchor?
I would guess that there are some mismatching keys somewhere. I haven't used candymachine in a while though
you should ask on the candymachine discord probably
yes
this is for candymachine?
I get an error when I deploy auction, can someone tell me how to fix this?
anyone?
thanks
I see
yeah, or you can bundle in one single transaction
one generates the account for them, and the other doesn't? if I try to initialize a token account that exists does it return an error?
hmm I see. so then would the user do a different transaction depending on whether or not they have the token account yet?
yeah, you can check it on client-side itself
try to box unchecked account
this is during the user trying to transact with the smart contract this would happen
hey, I was wondering... Let's say I want to return a token back to a user. They may or may not have the token account. Is there a good way to check for the token account and initialize it only if it doesn't exist?

I think I already am
Thanks for the response <@!161709591220977664> ,I tried with that, but it expecting an struct type data as input as param  and it show an exception as ``TypeDef<{ name: "TestObjectParam"; type: { kind: "struct";`` how can i form a struct type data field inside the js? and in plain solana code they use the ``BufferLayout`` how can i do this in anchor here?
use `Box<Account<'info, someOfYouAccount>>`
all the fields within the object need to be properly BN and camelCase
when passing in the data: 100, you want it to be anchor.BN(100)
anyone?
Hi <@!134416332509675520>, can you please take a look.
Any ideas how I can fix that?
I'm getting an error of `Error: Function _ZN5vault5vault16initialize_vault17hc99fc37b28e650d1E Stack offset of -4136 exceeded max offset of -4096 by 40 bytes, please minimize large stack variables`
nvm i solved this, was providing a wrong address
Is there any extension on Visual Studio Code that helps with developing in Anchor?
Error: 141: A has_one constraint was violated
Now i'm working on making a new cpi which is giving an error regarding has one. Any ideas?
I had many many issues in my CPI, but fought through them all and it is working now üôè
Have you verified that that account has the right `.owner`?
Not sure, but jet is complaining at you. You'll need to check jet's source code to see what `Account<'info, Whatever>`s it's using
do you think its the Obligation being passed in improperly out of all the other accounts?
could a core maintainer take a look at my pr? https://github.com/project-serum/anchor/pull/1362
The error is saying that, somehow, you're not actually passing in a jet Obligation account
That's fine
so if i pass an account in as an `UncheckedAccount` but then in the context of the program i'm making a cpi to it wants  `Loader<'info, Obligation>,` thats okay?
No, it's purely a question about the low-level solana account, anchor stuff doesn't matter
must the type that I pass in as context in my program match the type in the jet program's context?
Ok, yeah, sounds like you're trying to invoke the jet program but you're passing it an account with the wrong program owner
context for the cpi: https://github.com/jet-lab/jet-v1/blob/master/programs/jet/src/instructions/init_obligation.rs#L25
context  for my function


of course haha
Mm, can you post the full program log haha
for example, the CPI is expecting a type in context of `    pub obligation: Loader<'info, Obligation>,`
but value I provide to the CPI as the obligation, which is the jetProgram has the type of `    pub jet_program: UncheckedAccount<'info>,` as it is called in my program
When i make a call to a CPI does the type of the variable i'm supply to the CPI have to be the same type as on my program?
where `Wherever` is the supposed owner?
has to be the wrong owner specified then on the Account, right?
that seems to be right, the log after it deploys and prints matches what I have at the top of my lib.rs file
It needs to match whatever your runtime program_id is (the thing that shows up in your logs)
would it be the wrong declare_id when i define my program in lib.rs?
Ohh you are right, my b
Yeah, you're using it then
.21
You have to use it
Doubt it haha, what version of anchor are you on?
I don't think i make use of declare_id anywhere in my codebase, so likely the former then?
*Or*, annoyingly, you just have an incorrect declare_id
Yeah, so two possible sources for that error: you really did pass in an account with the wrong program owner (like, you passed in a token account, which definitely isn't owned by your program)
which is likely causing this error `     Error: 167: The given account is not owned by the executing program`
Ahh right, and I could incorrectly say that any Program owns a given account when I define my context even though it doesn't
Almost‚Äîthe Whatever struct declares (in possible a sneaky, anchor-macro-y way) which program is supposed to own it
Got it, so in your example, `Account<'info, Whatever>` there should be a `Whaterver` program that exists and which has ownership over the listed account
Yes, or spend the account's money
and ownership essentially means one that has exclusive access to mutate?
PDAness is purely an address thing, not an account thing.
Yes, a great example is an ATA. Its address is derived from the associated token program, while the account that lives at that address is a token account, so owned by the spl token program (totally different program).
so is it possible for accounts to be PDAs, but not owned by the program they are derived from, then?
This is totally separate from whether a program derived an address
Typing out my spiel: every account in solana is owned by a program, and only that program is allowed to mutate the account's data or spend the account's money.
Actually no!
program 'owned' here meaning program derived, right?
You can unfortunately also get it if your declare_id! is wrong.
So e.g. if you have `Account<'info, TokenAccount>` but pass in some random other program's account, you'll get this error
The `Whatever` struct encodes who its intended program owner is (e.g. anything you define with `#[accounts]` is supposed to be owned by whatever you said in declare_id!)
This can happen with any `Account<'info, Whatever>` in your derive(Accounts) block
You passed in an account owned by some program, but anchor thought it was supposed to be owned by a different program
meaning an incorrect owner of an account was passed in?
Nope, nothing to do with seeds. It means that the account's program owner doesn't seem to match what anchor expected.
is an error of `     Error: 167: The given account is not owned by the executing program` usually indicative of seeds not being passed in properly somewhere?
Cool, thanks!
For finding PDAs and also for signing for them
when are seeds required to be used in solana development? just for creating or finding pdas, right?
Can anyone publish in anchor? I keep getting ` expected '!'`
The current set up should work fine.
For accounts, we simply have the "account" namespace.
Excuse the above. That was all in reference to instructions. not accounts.
The discriminator check is needed to serialize/deserialize. The owner check can be done separately.
I have a certain data structure that could be provided by different programs.
Got it. Thanks!
alternatively, we could use the program mod name, but the downside of that is that we don't get compile time checking for interfaces like we do with traits
in the future, the idea is to have different traits for different namespaces
so handlers from different programs could have the same disc
currently it's all put under the "global" namespace
When Anchor generates the "discriminator" field for accounts, does the "namespace" data ever get used? Or, is the final value entirely based on the name of the struct? Would two structs from different programs that have the same name end up having the same discriminator? (In the case of my system, this would be beneficial.)
you can check this repo https://github.com/0xdeepmehta/anchor-cpi/blob/master/tests/cpi_hack.ts
I generally know the address for my custom CPI program.
yea, i'm saying how do you normally get the value on the client, docs usually have it or something else?
system_program, token_progam are such examples, which we are using in daily anchor life
form client-side
when you make CPI calls, how do you get the string value of program id of the program you want to call usually?
don't know ser
hey, is there any example/guide of a project that works on Anchor with spl tokens? Balance check, transfer e.t.c
is that normally provided in documentation?
I don't know how you find something, which you don't know.
i don't know what the value to pass is though, how do you go about finding the string value of the program address you want to make a cpi call to
aah, you need to pass all the account in Solana upfront.
No, I don't think so
but i have no idea what the actual string is
i thought perhaps the cpi package includes that or something
the address and public key for the program exists somewhere in the world, but i have no idea what it is


///////////////////////////////////////////////////////////////////////////////////////////////

Ah, interesting! Ok, good to know
ok just figured out that the issue has been already created https://github.com/project-serum/anchor/issues/1416
ah nice, this is exactly what i needed thanks
You can use the `test.genesis` feature for this, e.g. in Anchor.toml
```.toml
[[test.genesis]]
address = "9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin"
program = "./deps/serum-dex/dex/target/deploy/serum_dex.so"
```
Oh, sorry, misread
Would cloning work? https://discord.com/channels/889577356681945098/889702325231427584/943483106852212766
Is it possible to run `anchor test` against a local validator that has been pre-seeded with other programs? You can load in a program into the genesis block by doing
```
solana-test-validator --bpf-program PROGRAM_ID PATH_TO_BINARY
```
for as many programs as you want.

I need to make modifications to some existing programs in order for the test to work properly, so this would be the easiest way to do so.
In case anybody was wondering, this seems to be the solution:
```
    #[account(
        mut,
        owner = METAPLEX_PROGRAM_ID.parse::<Pubkey>().expect("Failed to parse Metaplex Program Id"),
        seeds = [
            "metadata".as_bytes(),
            METAPLEX_PROGRAM_ID
                .parse::<Pubkey>()
                .expect("Failed to parse Metaplex Program Id")
                .as_ref(),
            maker_mint.key().as_ref(),
        ],
        bump = find_metadata_account(&maker_mint.key()).1,
        seeds::program = METAPLEX_PROGRAM_ID.parse::<Pubkey>().expect("Failed to parse Metaplex Program Id"),
        constraint = Metadata::from_account_info(&metadata)?.data.creators.as_ref().expect("Failed to access creators in metadata")[0].address == CREATOR_ADDRESS
            .parse::<Pubkey>()
            .expect("Failed to parse Creator Program Id")
    )]
    pub metadata: AccountInfo<'info>,
```

Relies on mpl-token-metadata crate:
```
use mpl_token_metadata::pda::find_metadata_account;
use mpl_token_metadata::state::Metadata;
```
Also, is there a way for the client to pull an IDL from the registry? Or does it have to be provided as a file?
What is the generated `app/` directory for in new projects?
I think you can also just update your solana install, pretty sure they eventually deleted that stowaway log line
yes. other msgs appeared. üôÇ thx
You can just ignore those msgs
so do I need to wait sometimes? how much? seems it won't be finished.
It's fine, the version of solana you're using just includes an errant log message
Hello!
Anyone haven't seen this kind of issue during deployment?
https://prnt.sc/26xw53a
cool cool, thanks
So and so's writable privilege escalated ==> you forgot to mark something as mut
Yeah, look at the third line from the bottom of that log
Perhaps i missed the more important error message then. Are you saying that it is generally specified that an account needs to be marked mutable or another signer needs to be added, but another log made it a dead giveaway that the problem was that an account needed to be marked as mutable?
yup that was the issue. good timing haha. thanks!
thanks buddy üôÇ
<@!134416332509675520> you know what mate; I'm so stupid. I remember I had the same issue in the previous version of anchor when I wanted to use a bump_seed and I did realize back then that bump seed needs to the the first param in the instruction function
I might've added a bump key that's unnecessary in the macro
oh ok, let me try it out
ah...
yes
It might be the issue we're talking about just above‚Äîare you using the `#[instruction(...)]` macro?
qq: What's the common reason for error code "0x66/102 - The program could not deserialize the given instruction"? Is it because the wrong account type was sent for an account parameter? Or an account address was provided that doesn't exist?
^
You need to add that to the `#[instruction(...)]` thing too‚Äîthe args need to exactly match (in terms of types anyway) up to the last argument you care about using in the derive(Accounts) part
But you have that extra `  metadata_program: Pubkey,` part in there
The issue is that your `#[instruction(...)]` needs to match the order of the args to the instruction fn
Oh, ugh‚Äîmy brain's not working today lol, I tried looking for this above and was going too fast
let me try use a primitive value
It's very weird that an intruction with a string causes that issue
no worries buddy üôÇ
Sorry, I'm totally wrong, my bad ü§¶‚Äç‚ôÇÔ∏è
I've used this approach before and there was no issue at all; which makes believe that there is no issue with the `sighash`
1 sec
Ah, sorry ü§¶‚Äç‚ôÇÔ∏è
I need to get the Solana `Instruction` somehow
the `solana_program_test` has this function to send the transaction

```
  pub async fn process_transaction(
    &mut self,
    instructions: &[Instruction],
    signers: Option<&[&Keypair]>,
  ) -> Result<(), ProgramError> {
```
~~But then you throw away part of it by calling `.data()` on it (just don't do that)~~
~~Right, I'm saying you don't need to manually build an Instruction yourself‚Äîyou're already doing that the fancy anchor way on the previous line üòõ~~
```
  let ix = Instruction {
    program_id: soliquid::id(),
    accounts,
    data,
  };
```
this part here though requires the resilized data
hmm ok
You're accidentally throwing away the sighash part
Just use `let ix = soliquid::instruction::Initialize` etc., you've already got the code to make the instruction
It's missing the first 8 bytes that anchor uses for the "sighash". Why are you doing the `.data()` part?
Ah, that's unfortunately not quite the right way to build an anchor instruction
and this is the snippet from the tests 

```
let (index_token, index_token_bump) = Pubkey::find_program_address(
    &[b"soliquid:index_token", name.as_bytes(), symbol.as_bytes()],
    &soliquid::id()
  );
  let (index_token_authority, index_token_authority_bump) = Pubkey::find_program_address(
    &[b"soliquid:index_authority", name.as_bytes(), symbol.as_bytes()],
    &soliquid::id()
  );
  let (metadata_account, metadata_account_bump) = Pubkey::find_program_address(
    &[b"soliquid:metadata", name.as_bytes(), symbol.as_bytes()],
    &soliquid::id()
  );

  let accounts = soliquid::accounts::Initialize {
    state: state.pubkey(),
    index_token: index_token,
    index_token_authority,
    metadata_account,
    deployer: deployer.pubkey(),
    token_program: Token::id(),
    system_program: system_program::ID,
    rent: Rent::id(),
  }.to_account_metas(None);

  let data = soliquid::instruction::Initialize {
    metadata_program,
    name,
    symbol,
    uri,
    rate,
    fee_basis,
    merkle_root,
  }.data();

  let ix = Instruction {
    program_id: soliquid::id(),
    accounts,
    data,
  };

  assert!(pt.process_transaction(&[ix], Some(&[&deployer, &state])).await.is_ok());
```
```
pub fn initialize(
  ctx: Context<Initialize>,
  metadata_program: Pubkey,
  name: String,
  symbol: String,
  uri: String,
  rate: u64,
  fee_basis: u16,
  merkle_root: [u8; 32],
) -> ProgramResult {
}

```
```
#[derive(Accounts)]
#[instruction(name: String, symbol: String)]
pub struct Initialize<'info> {
  #[account(
    init,
    payer = deployer,
    space = 8 + size_of::<State>()
  )]
  pub state: Box<Account<'info, State>>,

  #[account(
    init_if_needed,
    payer = deployer,
    mint::decimals = 9,
    mint::authority = index_token_authority,
    space = 8 + size_of::<Mint>(),
    seeds = [b"soliquid:index_token", name.as_bytes(), symbol.as_bytes()],
    bump,
  )]
  pub index_token: Box<Account<'info, Mint>>,
  #[account(
    init,
    payer = deployer,
    space = 8,
    seeds = [b"soliquid:index_authority", name.as_bytes(), symbol.as_bytes()],
    bump,
  )]
  pub index_token_authority: AccountInfo<'info>,
  #[account(
    init,
    payer = deployer,
    space = 8 + size_of::<DataV2>(),
    seeds = [b"soliquid:metadata", name.as_bytes(), symbol.as_bytes()],
    bump,
  )]
  pub metadata_account: AccountInfo<'info>,

  #[account(mut)]
  pub deployer: Signer<'info>,
  token_program: Program<'info, Token>,
  system_program: Program<'info, System>,
  rent: Sysvar<'info, Rent>,
}
```
Also the instruction function itself
yes sure
Can you post that code though?
I'm running tests in Rust via the `solana_program_test`
How are you calling the code in JS?
has anyone experience anything similar to this?
I'm experiencing a weird runtime error; I've got an Initialize Account

```
#[instruction(symbol: String)]
pub struct Initialize<'info> {
}
```

where I get some params from the fn and use part of the seeds for a few pdas. I receive the following error

```
DEBUG solana_runtime::message_processor::stable_log] Program log: Instruction: Initialize
DEBUG solana_runtime::message_processor::stable_log] Program log: Custom program error: 0x66
DEBUG solana_rbpf::vm] BPF instructions executed (interp): 5514
DEBUG solana_rbpf::vm] Max frame depth reached: 16
```

However, if I remove this macro `#[instruction(symbol: String)]` it looks to run with no errors
But the log specifically says you forgot to mark something as mut "writable privilege" etc.
Note that the error message has an "or" in it üòõ
Not yet. Is that what that means? That I need to label an account as mutable?

I thought it meant I wasn't signing with the right account or something
Really appreciate your help, <@!134416332509675520> !
Gotcha
Not fundamentally no (just a question or organization)
I appreciate it, thanks!
Is there any disadvantage of doing constraint checks in the instruction code as opposed to using the account constraint macros?
I'll see if I can get an example working today at some point
Think you can do it in constraints, yeah, although I'm not super familiar with metaplex
Is that possible using constraints or do I need to do these checks in the instruction code?
Ah, ok, you can't do that via `#[account]`, you're going to have to either write some anchor metaplex wrapper machinery stuff, or just pass the account in as a `AccountInfo` and deserialize its data yourself
I need to ensure that the mint that is passed to my program has a specific creator (which is defined in the metadata account of the mint)
It‚Äôs a metadata account of an nft minted via metaplex
The account (a pda) already exists (its owned by the metaplex program) and I just want to parse its data and use it as a constraint.
Do you want that account to be owned by some other program?
You can't üòõ Your own accounts can only be owned by your own program (this is just part of how solana works)
That makes a lot of sense now, thank you! How do I change the expected owner of an account I made with the account macro?
(Using the value you specified in `declare_id!`, so that's why you can get this error if your declare_id doesn't match the *actual* runtime program id)
Because any account you make with `#[account]` is implicitly owned by your own program
```    #[account(
        mut,
        // owner = METAPLEX_PROGRAM_ID.parse::<Pubkey>().expect("Failed to parse Metaplex Program Id"),
        seeds = [
            "metadata".as_bytes(),
            METAPLEX_PROGRAM_ID
                .parse::<Pubkey>()
                .expect("Failed to parse Metaplex Program Id")
                .as_ref(),
            maker_mint.key().as_ref(),
        ],
        bump = find_metadata_account(&maker_mint.key()).1,
        seeds::program = METAPLEX_PROGRAM_ID.parse::<Pubkey>().expect("Failed to parse Metaplex Program Id"),
        constraint = metadata.data.creators.as_ref().expect("Failed to access creators in metadata")[0].address == CREATOR_ADDRESS
            .parse::<Pubkey>()
            .expect("Failed to parse Creator Program Id")
    )]
    pub metadata: Box<Account<'info, MetadataAccount>>,```
For reference, here is my metadata account field including the constraint:
In fact, I cannot even specify an owner in my constraint for that account. I get "no field `owner` on type `&anchor_lang::prelude::Account<'_, MetadataAccount>`" as a result.
So I created my own account struct "MetadataAccount" which seems to be the culprit. However, I did not specify an owner in my constraint. How is it possible that I get the aforementioned error message for this account? (The given account is owned by a different program than expected)
Ohh ok gotcha thanks
This error happens before any of your instruction code runs
If my program tries to transfer tokens from an account where it doesn't have the allowance to do so.
Not totally sure what you mean
Is it possible this message appears due to an unauthorized transfer?
Thanks <@!134416332509675520>!
One thing to double check is if your declare_id! matches your actual runtime program_id (the one that prints in the logs)
E.g. if you say `Account<'info, TokenAccount>`, you had better pass in an accoutn owned by the spl token program
Basically by just carefully thinking about it üò¨ This could happen with any Account<'info, Whatever> you're using
I got an error message "The given account is owned by a different program than expected". How do I find out which account this refers to?
Hi, does anyone have experience with running the soteria tool on a mac? Also will this be added to anchor at some point?
It makes no sense in our case if it's only a Mint allowed, cause we would need to pass another account. We are saving the Pubkey of the mint in our main account and verifying from there.
correct
Did you get this figured out? The program log says some account hasn't been marked as mut
Just to double check, are you using `0.21.0` for *both* anchor-lang as well as anchor-spl?
That means you have some `seeds = [...]` constraint on an account, and it's wrong somehow üòõ
Hello Everyone!
can I apply the latest version of `anchor-syn` for retrieving the cpi interface from the program built with old version? thx
How can we resolve this?
Hello everyone.
does anyone know about custom error 2006
/// 2006 - A seeds constraint was violated
    #[msg("A seeds constraint was violated")]
    ConstraintSeeds,
what to do
Anchor.toml has devnet mentioned but anchor test still asking for localnet. It just magically switched to localnet
Hi, why in anchor 21 version `associated_token::mint = xxx ` xxx can't be a Pubkey. It was working in previous version 0.20.1 but not anymore giving the error `method cannot be called on anchor_lang::prelude::Pubkey due to unsatisfied trait bounds`
sure, I will definitely share my use cases
<@595567283028623362> mind sharing your use case for conditionally closing?
I get it, thanks üôÇ
you can close an account conditionally now but you have to use UncheckedAccount
closing an `Account<'info, T>` conditionally is currently not possible safely. we're considering making some changes to make it safe and at that point make it public. but still gathering the use cases for conditional close
Is it possible to make close account function public? I am closing account based on the condition. It will be much easier to just import close function instead of copy-pasting close source code after every changes. Btw what is purpose of making close function private? <@!347689664855015424>
yea just referring to a pubkey
yea the accounts struct deserializes a completely independent struct so only the types and order need to match
like they can be named differently but they have to be in the expected order?
is it just a matter of order then?
not an error this is fine to do. actually the instruction args in the accounts struct can be named completely differently than the function args
not sure what you mean by "native" pubkey but if you dont care about anything else except the account being a pda, then you can do it like this
is this an error in the auction house contract?
one of the instruction handler parameters for the `execute_sale` instruction is `_free_trade_state_bump` but in the accounts context struct for `ExecuteSale`, the instruction param is defined as `free_trade_state_bump` (it is missing the `_` prefix here)

https://github.com/metaplex-foundation/metaplex-program-library/blob/master/auction-house/program/src/lib.rs#L564
is that because any native pubkey doesn't have to be initialized unless for storing account data?
since the PDA has not been initialized, why is it typed as `AccountInfo`?
why does anchor allow me to pass in an uninitialized PDA as an `AccountInfo` like:  
```
    #[account(
        seeds = [b"Authority"],
        bump,
    )]
    pub authority: AccountInfo<'info>,
```
you probably need to add `#[account(mut)]`
Hey I'm getting an anauthorized signer or  writable account error, any ideas?
Can anyone share the git repo / code to write a program to transfer sol to an account and emit event?
Else can anyone share the solution to sync db after the sol has transfered?
Can I somehow use Serde instead of Borsh?
it seems you need an iterable data structure of all your depositing users so you can push the correct amounts when cycle 6 starts
what's the suggested way to do this?
anyone have suggestions on how to distribute rewards to a group of people at some point in the future?

say i run rewards distributions on a weekly cycle; if people deposit in cycle 5 they will be eligible for rewards in cycle 6, and will receive a proportional alloc of the cycle 6 rewards based on `their deposits / total deposits for cycle 6`
Hey I've noticed that on different machines I hit the compute limit on certain instructions that I otherwise wouldn't. Is this expected or should compute be machine agnostic when running localnet testing scripts?
Hi ,can anyone help me, how can I Create an associate account token ?
Sorry for the dumb question, I'm new to Solana, and I am trying to build my helloworld solana app using Anchor. I am on aarch64 (docker container on M1 Mac). When I do `anchor build`, it appears that it tries to download the BPF SDK into `/root/.local/share/solana/install/active_release/bin/sdk/bpf`. However, I _think_ it installs the bpf tools in x86_64, which causes the command to error out with `qemu-x86_64: Could not open '/lib64/ld-linux-x86-64.so.2': No such file or directory`. Is  aarch supported for Anchor?
I should have remember to convert to decimal
thank you
`0xbbf == 3007 == AccountOwnedByWrongProgram`
attempting to use account loader
anybody know what error code `0xbbf` is ? Cant locate anything for it
I'm fighting with this exact thing right now
Is there a way to send multiple instructions as one transaction using project-serum/anchor in JS? I have a process with several steps, but the user currently has to sign each step in Phantom. If not anchor, is there an alternative way to do this? I haven't been able to find any examples.
Doubt there's anything local-specific about it
ah ok cool
I think that just means that you need to be able to talk to an actual validator etc.
i only ask because some of the tests seem to have the following line commented above them: `// Make sure to run a localnet with the program deploy to run this example.
`
would this client work when testing against devnet?
work. Thanks!
maybe not the best place to ask this but trying to user anchor_spl::dex. Anyone know how devnet works for serum? Can't find any info on devnet markets or addresses
It's annoying, but the is what happens when you try to use JS for finance-y stuff.
You'll instead have to use the BN constructor with a string: `new BN("10000000000000000")`
JS numbers are doubles under the hood, and can only represent all integers up to 2^53. Your number is just slightly bigger than that, so the BN constructor throws an error telling you that it doesn't really make sense to use JS numbers for safe integer stuff when they're all the way up there (in this case that number is still representable as a JS number, but, for example, try adding 1 to it in a node repl)
what is the error?
i have a number 10000000000000000 but 
when I transform it to new BN() it throws me an error, why can this happen?
This number is derived from 10,000,000 tokens to 9 decimal places.
Thank you that worked
That's the first thing I thoght but I was trying to figure another way out because I would have to change some things in the program A
There's no avoiding needing that keypair‚Äîultimately you need to be able to sign for any address of a new account
Yep that's my problem
You're unfortunately going to need that keypair
That error is happening on the client‚Äîyou're going to have to sign *that* request with that keypair
<@!134416332509675520>  I have program A with a specific Tx let's say TxA that creates a new account .... the TxA receive the new generated Keypair from the client as a signer for the new account.. What I am trying to do is packing that TxA and save it in a Transaction account of the multisig program to execute it later after all approvals .. When I call the multisig program executeTransaction from the client I get `signature verification error` .. becaused the multisig program is trying to execute the TxA which has a signer for the new account that is going to create and I don't have the Keypair at the moment of the exxecution to pass it from the client as a signer .. hope is more understandable now .. thanks
probablyshould have added that as context
was trying to figure out how to send a tx to the network
figured it out, just needed `provider.send(transaction)`
let me try to explain better my problem .. the error I am getting is in the client and this is the scenario
What kind of error do you get?
Better question‚Äîwhat have you tried so far/what hasn't worked?
If I'm understanding your question right, you just need to pass the address of the account you're going to create?
```.js
    const tx = new anchor.web3.Transaction();
    tx.add(yourInstruction);
    tx.recentBlockhash = (
      await program.provider.connection.getLatestBlockhash()
    ).blockhash;

    program.provider.wallet.signTransaction(tx);
    program.provider.connection.sendTransaction(tx, []);
```
Can anyone help me out here please ? .. I have been stock some hours trying to figure a solution out with no luck.
I'm trying this right now, but this seems to be an example for sending a tx in a web browser
where is the documentation for  anchor.web3.TransactionInstruction ? i want to call arbitrary instructions for testing purposes in ts files
perfect, thanks!


///////////////////////////////////////////////////////////////////////////////////////////////

Suggestion from my discussion in beginner's chat - Currently the TypeScript typing does not result in well formed or correct types for accounts when you call things like `fetch()`  Having gone down this type of road before, I recommending fully generating the TypeScript types at build time, rather than using the current approach where the `Program<T>` uses TypeScript's inference to result in a type.  Big recursive type hierarchies in TypeScript get finicky, and at the end of the day we're looking for a 1:1 mapping of the types we define in Rust with TypeScript types.
I'm getting an error right as my function gets entered, any ideas?

```
  logs: [
    'Program 8KFe29BGwPevewGY147ytq2mSGuNVRtM4JaikvF6D26G invoke [1]',
    'Program log: Instruction: InitializeUserRedeemableTokenAccount',
    'Program 11111111111111111111111111111111 invoke [2]',
    'Program 11111111111111111111111111111111 success',
    'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [2]',
    'Program log: Instruction: InitializeAccount',
    'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 3272 of 182107 compute units',
    'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success',
    'Program log: 1645208134',
    'Program log: 1645208128',
    'Program log: Initialize user redeemable token account',
    'Program 8KFe29BGwPevewGY147ytq2mSGuNVRtM4JaikvF6D26G consumed 30978 of 200000 compute units',
    'Program 8KFe29BGwPevewGY147ytq2mSGuNVRtM4JaikvF6D26G success',
    'Program 8KFe29BGwPevewGY147ytq2mSGuNVRtM4JaikvF6D26G invoke [1]',
    'Program log: Instruction: DepositVault',
    'Program log: Custom program error: 0xbc0',
    'Program 8KFe29BGwPevewGY147ytq2mSGuNVRtM4JaikvF6D26G consumed 13755 of 200000 compute units',
    'Program 8KFe29BGwPevewGY147ytq2mSGuNVRtM4JaikvF6D26G failed: custom program error: 0xbc0'
  ]
```
I mean, the seeds and bump cannot be listed on the context account?
you need to use the `bump` keyword as well
Hi <@!501570363566587905> 
The seeds cannot be specified on the context struct?
Like this
```
#[account(
  mut,
// seeds = [ signer.key().as_ref() ],
)]
pub user_account: Account<'info, UserAccount>>,
```
Hi all, anyone having issues deploying the idl to devnet/testnet? 

```anchor idl init -f target/idl/<my_idl>.json <PROGRAM_ID> --provider.cluster devnet
Error: unable to confirm transaction. This can happen in situations such as transaction expiration and insufficient fee-payer funds```

My wallet is full and I have the latest version of anchor (cargo cli). Deploying the program worked fine.
nvm solved this, it was a namespace error
Okay yay I got past that first error!
Yeh is there anything else I should be aware of?
following up here üôÇ
okay thank you so much!
Try fixing those and see if you get more errors.
3. You can't do #[derive(AnchorSerialize, AnchorDeserialize, Clone)] over a derive(Accounts) struct, so just delete that.
Ok, bunch of stuff not quite right in there üòõ
1. You can't use the `#[account(constraint = InitProfile.user != Like.fan()]` in that position, it only works on top of one of the fields inside a derive(Accounts) struct (you've got it on top of the struct as a whole, not over one of its fields)
2. Your `#[instruction(...)]` args need to exactly match the order the args are declared in the corresponding instruction functions (yours don't)
By size do you mean the 10kb limit?
here is my code
Only within the derive(Accounts) struct
You can't use the `Account` type within a #[account] struct
GM, I have been dealing with this error for the past day and I was wondering if I can get some second eyes on this: 
`IdlError: Type not found: {"name":"profile","type":{"defined":"Account<'info,Profile>"}}`
What are the main downsides of pdas?
Is it just size?

Is there a list of pda limitations somewhere?
any idea?
even though it builds fine
keep getting this
"TypeError: f.Wallet is not a constructor"
all my code for initialising a new Wallet is dead
just got @project-serum/anchor@0.21.0 in typescript
hey guys
any way to override the cluster endpoint used by the anchor cli? Not sure if it is just me but `anchor idl init` is timing out for me on devnet
Hi, guys. I am suffering from this error. Please help me.
```error: the `#[global_allocator]` in this crate conflicts with global allocator in: pyth_client```
I imported pyth by writing ```pyth-client = "0.3.0"``` in cargo.toml
we changed error mappings a while ago. maybe its that?
Hey Guys I am getting this error. It seems that anchor 0.20.1 does not works with solana-program v1.7.12. Which anchor version should i downgrade to make it work ?
I just upgraded to anchor 21 and it seems like some errors are no longer mapped properly

Has_one
 AssertionError: expected 'Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: custom program error: 0x7d1' to include 'A has_one constraint was violated'

Raw Constraint
AssertionError: expected 'Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: custom program error: 0x7d3' to include 'A raw constraint was violated

Seed Constraint
AssertionError: expected 'Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: custom program error: 0x7d6' to include 'A seeds constraint was violated
The errors should be imported from the lib.rs file in the same directory, but they are searching for jet for some reason
This is a recent error that just popped up, didnt have this before and had those error codes defined in context previously

Im getting many errors like ``` variant or associated item not found in `jet_proto_v1_cpi::ErrorCode```

Any ideas?

In that case you can just do a close_account cpi in your business logic function instead. 
For example if I wanted to close an spl_token account it would like like so:
like i want to check if it's empty
what if i want to do some validation before closing the account?
To any address, and you can use the `close = who_to_send_the_lamports_to` attribute in anchor to automate this
(also how do i close an account?)
When closing an account, can you send the funds to *any* address or does it have to be a signer on the transaction?
feature request üëÄ thanks, ill use a keypair then
Yeah, can't use big PDA accounts unfortunately üò¶
this was my fear. given the account size constraints with `init` I wanted to find a better way to initialize a large PDA account. Doesn't seem like there is really a way around it besides not using a PDA
does anyone have some spare time to hop on a quick call with me to debug something when using the `anchor_client` library?
No, because creating an account requires that the account's address signs, but you can't sign for a PDA from the client (only the deriving program can)
can `program.account.[account_name].createInstruction()` be used for a PDA?
Though I haven't actually looked at this stuff much yet
What do you mean by always? I think the automatic bump stuff only happens for `init` (and anchor was already re-finding that bump before)
Hey there, I‚Äôm hoping someone can help me out here. I‚Äôm running Metaplex candy machine on test validator which all seems to be working well until I get up to the add configLinesFunction on an upload.

I‚Äôm getting the error `AccountOwnedByWrongProgram` and I can‚Äôt work out why.

I can confirm that the authority for the created candyMachine, the signer and authority that is passed into the addConfigLines function are all the same‚Ä¶

Any ideas????
is there a way to disable the automatic bump feature? it seems unnecessary to compute bump always (was it already doing this?) and also u basically alwayss have to run find_program_address client side anyways
ConstraintSeeds: A seeds constraint was violated
https://rustrepo.com/repo/samuelvanderwaal-wtf-is
You might like the crate wtf-is
I am still looking for help frens, I feel like anchor should have a function to parse the error and return the error message from the macro
yep, appreciate it. turns out it had nothing to do with the prop with init üòÇ
0x7d6
you gotta turn this from hex to normal
https://docs.rs/anchor-lang/latest/anchor_lang/error/enum.ErrorCode.html
is there somewhere i could lookup / find what custom program errors from anchor actually are..?
for e.g. 
```rs
#[error]
pub enum ErrorCode {
    #[msg("Account does not have correct owner!")]
    IncorrectOwner,
}
```
in the handler
```rs
    pub fn initialize(ctx: Context<Initialize>) -> ProgramResult {
        msg!("some error");
        Err(ErrorCode::IncorrectOwner.into())
    }
```
```#[error]
pub enum ErrorCode {
    #[msg("Insufficient balance to take on a new position")]
    InsufficientBalanceCreatePosition,
}``` Rust code btw
you need to return an error or log it using `msg!()`, in both cases this will log the error in the program logs & won't return a string to javascript afaik
Hi Anchor friends, I'm looking for some code that will allow me to print the error messages from anchor. This is my code :
```    try {
      await program.methods
        .createPosition(zero_pubkey, zero_pubkey, new BN(8))
        .accounts({
          stakeAccountPositions: stake_account_positions_secret.publicKey,
        })
        .rpc({
          skipPreflight: true,
        });
    } catch (err ) {
      console.log("err",err.toString());
    }
```

I get : 
```err Error: Raw transaction 28wZTFT94spWLfyYbYZtUmP62RjuTjsqVQKgrnDfmWuNDHkqYo2VAQuAHzmeQzWANKUK9eYJ8QX2W3rShbj8bjey failed ({"err":{"InstructionError":[0,{"Custom":6000}]}})```

How do i get from error 6000 to the actual error message, that's in the IDL.
```rs
#[instruction(game_creator_bump: u8)]
pub struct Initialize<'info> {
    #[account(mut)]
    game_creator_auth: Signer<'info>,
    #[account(mut, seeds = [PREFIX, &game_creator_auth.key().to_bytes()[..], &game_creator_auth.key().to_bytes()[..]], bump = game_creator_bump)]
    game_creator_pda: AccountInfo<'info>,
    #[account(mut)]
    static_pda_key: Signer<'info>,
    #[account(init, seeds = [PREFIX, &game_creator_auth.key().to_bytes()[..], &static_pda_key.key().to_bytes()[..]], bump, payer = game_creator_auth)]
    static_pda: Account<'info, StaticPda>,
    token_program: Program<'info, Token>,
    system_program: Program<'info, System>,
    rent: Sysvar<'info, Rent>,
    associated_token_program: Program<'info, AssociatedToken>,
}
```
with anchor 0.21.0, it's my understanding that we're supposed to not pass a bump from the arguments when initializing pda accounts anymore, however doing this in the above gives me the error `Transaction simulation failed: Error processing Instruction 0: custom program error: 0x7d6` in the decorator resolution (prior to the handler executing) and i'm struggling to figure out what it wants me to do / what this error is
I guess this is a bug with jet, those fields really ought to be public (they're part of their contract's API, so, yeah, they're effectively public)
okay, is this a problem with anchor then? a mistake in the Jet code?
Hmm, funny, maybe anchor doesn't realize that those fields need to be public in order to create an instance of that type
https://github.com/jet-lab/jet-v1/blob/master/programs/jet/src/instructions/deposit_collateral.rs
updated lines
all good!
Where is deposit_collateral coming from?
Sorry, jeez, I can't read at al today for some reason
so anchor does find_program_address for u (which is expensive right?) - but i can see how it prevents attacks
No, but I think that's deliberate, since anchor wants to verify that the bump is correct ("canonical")
what about for init, does it get passed transparently from the client? and if so how does that work for CPI
You can access the stored bumps with ctx.bumps now
what line are you referring to with `instruction::` I'm using the same cpi modules for all my other successful cpi calls
how does this work with CPI? does the program just compute find_program_address under the hood? seems expensive
Seems like you're trying to use the wrong struct (is this a jet thing? That `instruction::` module isn't the right one)
does this storage of the bump mean its irrelevent now to store it ourselves in the account? its stored as a single byte in the anchor header?
I couldn't get them fast enough üòÖ

Can you show the code?
I am trying to construct context for a CPI, but one of the structs in context has private fields I cannot manipulate
where does this exist
i see it does store it in the account header automatically - which is pretty cool üòÆ 
https://github.com/project-serum/anchor/pull/1367/files
but still trying to understand if it will be a ton of compute for CPIs since it wont be passed in from client
https://github.com/project-serum/anchor/pull/1367/files#diff-1773434fcc58d74d77cfb9c10645cc88eeec52f21d891af23b3f783272b7011fR319-R324
so for anchor 0.21.0 how is it calculating the bumps? does it compute client side in the JS and just secretly pass them in? what about for CPI how does it know which bumps the CPI will need?


///////////////////////////////////////////////////////////////////////////////////////////////

gm
nice thanks
And apparently constants work fine, you can do `ESCROW_SEED.as_ref()`
You now need to do `b"escrow".as_ref()`
Ah, ok... I think if you read through tests/pda-derivation, it will be more clear
In Anchor.toml. Not sure why I added that tbh think I copied it from one of the test projects.
Ahhh, seems I get this error when I enable:
```
[features]
seeds = true
```
everything seems to work fine otherwise
Hmm still get it in this case: `WARNING: unexpected seed: Lit(ExprLit { attrs: [], lit: ByteStr(LitByteStr { token: b"escrow" }) })`
Mm, I bet the IDL doesn't work with named seeds like that üò¨ Try replacing it with `b"escrow"`
Seed is defined `const ESCROW_SEED: &[u8] = b"escrow";`
Sure, here's an example:

```
    #[account(
        init_if_needed,
        payer = borrower,
        seeds = [ESCROW_SEED, mint.key().as_ref()],
        bump,
        token::mint = mint,
        token::authority = escrow_account,
    )]
    pub escrow_account: Box<Account<'info, TokenAccount>>,
```
Ah, ok, can you now show more of how your using that seeds constraint?
```
WARNING: unexpected seed: Path(ExprPath { attrs: [], qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(LISTING_SEED), arguments: None }] } })
```
Its coming from https://github.com/project-serum/anchor/blob/093eaf0c3ffa6da53b59571fbf7903d8dd2a6a35/lang/syn/src/idl/pda.rs#L123
Never seen that before, can you print the full message?
Is "WARNING: unexpected seed" something to be concerned about? I'm trying to use a PDA like:
```
seeds = [b", mint.key().as_ref()],
```
No, deploys use solana conventions, not anchor, so it looks in target/
Unless that keypair is actually ignored altogether after initial deploy and anchor just defers to their keypair defined in Anchor.toml and program?
`target` directory comes in generated .gitignore (I think), but might it make sense to commit that after initial deploy since the keypairs pubkey might be needed?
Ok, thanks. Main scenario I'm thinking about here is accidentally deploying a new program instead of updating this existing one.
It would be stupendously, impossibly unlucky if you managed to generate a fresh keypair that matches someone else's already-deployed program_id. But at any rate, even if you did, re-deploys rely on the program's upgrade authority (by default, the wallet that did the program's first deploy).
1. I'm actually not sure what people do to manage developing on multiple machines‚Äîat any rate, you only need that keypair when deploying, so I guess it depends on how many machines you plan on deploying from. And when you deploy you also only need the full key*pair* for the first deploy; subsequent re-deploys no longer care about the secret part of the key.
2. anchor deploy doesn't always generate a new program address, it only does so if there isn't already an appropriately-named keypair in the target directory.
Hi <@!134416332509675520> I was wondering if you could help me with a few questions I have around the anchor workflow:

1. When I run anchor build on different machines, I get a new keypair generated under `target/deploy`. Does it matter if I ignore this keypair once I've set the initial keypair via `declare_id`?
2. Docs say that `anchor deploy` always generates a new program address - does this refer to the program address declared with `declare_id`? Will deploy fail if a program exists at that address already?
gotcha, I wanted to use it right after confirmed status
But this depends on details of how you're talking to the validators that I'm fuzzy on
You might need to wait for the first transaction to be "finalized"
yeah, seems like I need to wait for finalization
do I need to specify finality anywhere?
Yeah, should be able to‚Äîare you finding that you can't?
if I receive a token from somewhere, can I use it again immediately after confirmation of the first transaction ?
Yes. In general it's super super weird to change an ATA's authority.
You need to pass that ATA into your program from the client, and then use `pub that_token_account: Account<'info, TokenAccount>`. Then you can just do `that_token_account.amount`
is there any way i can parse sendtransaction from browser to be able to reproduce same function in web3js?
Cheers mate. Solved it for me
HI all, 
Ive got a question regarding setting the token account with a new authority. Let's say a user X owns a mint A's  ATA, and set the ATA's authority to user Y. If user Z tries to send tokens of mint A to user X, will the tokens end up in user Y's wallet (as user X's mint A ATA is now owned by user Y)?
I was playing around with <@!134416332509675520> 's anchor-token-studies repo, wanted to implement by own balance function to retrieve a specific wallet's balance of the new token. I think I got as far as getting the ATA address, but how do I get the balance information from that? I looked at Solana's SPL docs and there is a JSON RPC method called getTokenAccountBalance (https://spl.solana.com/token#json-rpc-methods), but is there an anchor implementation of this? If not, how would I go about retrieving a specific wallet's SPL token balance in my rust program? My code is as follows:
```
//get token balance of specific address
pub fn get_balance(ctx: Context<GetBalance>, &wallet: &Pubkey) -> ProgramResult {
    //retrieve ATA address of desired wallet
    let address = anchor_spl::associated_token::get_associated_token_address(
        &wallet, ctx.accounts.mint.to_account_info().key
    );
    //is there a getTokenAccountBalance method in anchor_spl?
    Ok(())
}
...
#[derive(Accounts)]
pub struct GetBalance<'info> {
    #[account()]
    pub mint: Account<'info, Mint>,
    pub system_program: Program<'info, System>,
    pub token_program: Program<'info, Token>,
    pub associated_token_program: Program<'info, AssociatedToken>,
    pub rent: Sysvar<'info, Rent>,
}
``` any help appreciated üôè tysm
For those in the future. This was because the RPC node returned an error when requesting the account data. Retriggering verification fixed the problem. Currently there's no way to do that from the UI.
or where is the code for the UI for verified-registry so i can take a look at what that means
anyone know what "Aborted" means in anchor verified builds
Thank you ser
Don't think so, no
Is it possible to use aliases in rust like ```type EpochNum = u64 ```. It seems like the idl parser doesn't like this and my typescript client crashes.
I am looking for references on how to create constraits around accounts like if you want only the creator address to edit the data in an account and how to disallow the creator address to edit data in an account
the first test ran
no not anymore
Are you still getting an error?

smh
` const account = await program.account.profile.fetch(profileAccount);` here I had it still connecting to baseAccount
`
import { Program } from "@project-serum/anchor";
import { Keypair } from "@solana/web3.js";
import { Walletprofile } from "../target/types/walletprofile";
import { findProgramAddressSync } from "@project-serum/anchor/dist/cjs/utils/pubkey";
export {}
const assert = require("assert");
const anchor = require("@project-serum/anchor");
const { SystemProgram } = anchor.web3;

const PROFILE_SEED = "PROFILE";

describe("Testing our Profile functionality: ", function() {
  const provider = anchor.Provider.env();
  anchor.setProvider(provider);
  const program = anchor.workspace.Walletprofile as Program<Walletprofile>;let baseAccount = Keypair.fromSecretKey((provider.wallet as any).payer.secretKey);

  it("A profile account is initialized", async function() {
  const [profileAccount, profileBump]= await findProgramAddressSync(
      [Buffer.from(PROFILE_SEED), baseAccount.publicKey.toBuffer()],
      program.programId
    );
    await program.rpc.init(profileBump,"Noah", "Miami", {
      accounts:{
        user: provider.wallet.publicKey,
        profile: profileAccount,
        systemProgram: anchor.web3.SystemProgram.programId,
      },
    })
    const account = await program.account.profile.fetch(profileAccount);
    console.log("Name", account.name);
    console.log("location", account.location);
    baseAccount = baseAccount;
  });

  it("Update the profile account previously created: ", async function() {

  });

  it("Like the profile account: ", async function() {

  });
});
`
i got it
omg
Can you post that code?
Ok, so you aren't even getting to your program I don't think, at least not in that test
yes
Are you doing an account fetch in your test?
` Testing our Profile functionality: 
    1) A profile account is initialized
    ‚úî Update the profile account previously created: 
    ‚úî Like the profile account: 


  2 passing (269ms)
  1 failing

  1) Testing our Profile functionality: 
       A profile account is initialized:
     Error: Invalid account discriminator
      at AccountClient.fetchNullable (node_modules/@project-serum/anchor/src/program/namespace/account.ts:153:13)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at AccountClient.fetch (node_modules/@project-serum/anchor/src/program/namespace/account.ts:168:18)



error Command failed with exit code 1.`
So I wonder if you, like, haven't deployed correctly or something
Can you post the full program log? That error actually doesn't make much sense based on what you're doing
however the error persists
cool yeah i came to that conclusion as well by looking at https://github.com/project-serum/anchor/blob/5ff9947ba2c3ad11fbb58041e63b502d042ea96e/tests/misc/tests/misc.js
Also, don't pass the system_program as an AccountInfo, use `Program<'info, System>` and get rid of that address constraint (don't need it)
One thing, get rid of that `signers` array (you aren't using the baseAccount anymore, so you can't sign for it like that)
okay I added the address that I got from the JS , but I am back to getting that `Invalid account discriminator` 
`
await program.rpc.init(profileBump,"Noah", "Miami", {
      accounts:{
        user: provider.wallet.publicKey,
        profile: profileAccount,
        systemProgram: SystemProgram.programId,
      },
      signers: [baseAccount]
    })
`
I think i found the issue, my keypair changed in my target
oh
You're still using `profile: baseAccount.publicKey`
You find the address in JS, but then you never actually use it for anything
Yeah
#[derive(Accounts)]
#[instruction(profile_bump: u8)]
pub struct InitProfile<'info> {
    #[account(mut)]
    pub user: Signer<'info>,
    #[account(
        init,
        seeds = [
            PROFILE_SEED,
            user.key().as_ref()
        ],
        bump,
        payer = user,
        space = 16 + 16,
    )]
    pub profile: Account<'info, Profile>,
    #[account(address = solana_program::system_program::ID)]
    pub system_program: AccountInfo<'info>,
}
`
profileAccount?
You don't seem to be using that `profileAccount` PDA at all in the test ü§î
This is my test: 
`const PROFILE_SEED = "PROFILE";

describe("Testing our Profile functionality: ", function() {
  const provider = anchor.Provider.env();
  anchor.setProvider(provider);
  const program = anchor.workspace.Walletprofile as Program<Walletprofile>;let baseAccount = Keypair.fromSecretKey((provider.wallet as any).payer.secretKey);

  it("A profile account is initialized", async function() {
  const [profileAccount, profileBump]= await findProgramAddressSync(
      [Buffer.from(PROFILE_SEED), baseAccount.publicKey.toBuffer()],
      program.programId
    );
    await program.rpc.init(profileBump,"Noah", "Miami", {
      accounts:{
        user: provider.wallet.publicKey,
        profile: baseAccount.publicKey,
        systemProgram: SystemProgram.programId,
      },
      signers: [baseAccount]
    })
    const account = await program.account.profile.fetch(baseAccount.publicKey);
    console.log("Name", account.name);
    console.log("location", account.location);
    baseAccount = baseAccount;
  }); 
`
Okay I know this means there is an issue with the seed key. So I first made sure the test was reading in the right seed key.  
 `Error: 2006: A seeds constraint was violated`
That error means you're incorrectly passing in some `Program<'info, Whatever>`
I've tried checking all the accounts and input in context matching what i'm passing in w/ typescript
and it returns this error before any logic is run, any ideas?
thanks! it says ```/// 3008 - Program ID was not as expected
    #[msg("Program ID was not as expected")]```
https://github.com/project-serum/anchor/blob/master/lang/src/error.rs
I don't how can I do so?
got it so it was always re-finding the bump...isnt that expensive and the whole point of passing it in to avoid the compute for find_program_address?

im trying to understand if i should remove the bump argument from the client interface, or leave it there and just not use it in case in future versions of anchor we think it will make sense to use the client passed in one or have the option to etc
haha
onto the next error
Got it. For anyone interested this is what I got wrong
your speed at responding is beautiful and another reason i love this community . thank you and let me look into this
That means on the client that you're passing in a `Account<'info, Foo>` where your actual rust program expects you to pass a `Account<'info, Bar>`
Hey again, 
so I made all those edits suggested by <@!134416332509675520> . I am not running into this error:
` Error: Invalid account discriminator`
I upgraded my anchor cli to latest version and solana cli to the most recent stable version
What have you tried so far?
Do you know how to look up those error codes?
Dropped context here: https://github.com/project-serum/anchor/issues/1465


///////////////////////////////////////////////////////////////////////////////////////////////

Is this where you are hiding?
ty
so fkn badass
amazing
Yep
Those are additional instructions to tack into the tx, which run *before* your rpc call
does this mean that `TransactionInstructions` that you include in the `instructions` array are executed before your program?
there is an `instructions` param being passed here
```js
return await program.rpc.mintNft({
    accounts: {
      config,
      candyMachine: candyMachine.id,
      payer: payer,
      wallet: treasury,
      mint: mint.publicKey,
      metadata,
      masterEdition,
      mintAuthority: payer,
      updateAuthority: payer,
      tokenMetadataProgram: TOKEN_METADATA_PROGRAM_ID,
      tokenProgram: TOKEN_PROGRAM_ID,
      systemProgram: anchor.web3.SystemProgram.programId,
      rent: anchor.web3.SYSVAR_RENT_PUBKEY,
      clock: anchor.web3.SYSVAR_CLOCK_PUBKEY,
    },
    signers: [mint],
    instructions: [
      anchor.web3.SystemProgram.createAccount({
        fromPubkey: payer,
        newAccountPubkey: mint.publicKey,
        space: MintLayout.span,
        lamports: rent,
        programId: TOKEN_PROGRAM_ID,
      }),
      Token.createInitMintInstruction(
        TOKEN_PROGRAM_ID,
        mint.publicKey,
        0,
        payer,
        payer
      ),
      createAssociatedTokenAccountInstruction(
        token,
        payer,
        payer,
        mint.publicKey
      ),
      Token.createMintToInstruction(
        TOKEN_PROGRAM_ID,
        mint.publicKey,
        token,
        payer,
        [],
        1
      ),
    ],
  });
```
I see this in the candy machine client repo
gm
anyway - it worked... many thanks üôÇ
Which is basically the opposite of good practices in writing nice clean code, where we de-couple things as much as possible
I guess you just have to be aware that everything is extremely fragile, so you must make the right decision first time and never change it.
(just seems like it encourages/forces messy huge code files, and breaks if you try to make your code tidy)
Does this mean the struct and instruction macro must be defined in the same file as the instruction function?
So inside the macro you have access to raw source code (well, sort of‚Äîslightly more cooked than raw but same idea)
Ah, yeah, that happens here: https://github.com/project-serum/anchor/blob/master/lang/syn/src/codegen/program/dispatch.rs#L102
I don't really understand rust macros, how does it know the method name, when the `#[instruction]` macro is applied on the struct, rather than the actual method?
Oh, whoops, typed too fast üòõ
"global:my_instruction", just one colon
Oh.. no it looks like just `"global:my_instruction"` - one colon.
Ahh perfect, so `"global::my_instruction"` is what I'm hashing?
For normal instruction functions, the namespace is just "global"
You can see how anchor does it here: https://github.com/project-serum/anchor/blob/master/lang/syn/src/codegen/program/common.rs#L17
How do I calculate the first 8 bytes of instruction data for an Anchor program? The instruction macro says `sha256(<namespace>::<method_name>)` - does this mean the sha256 of a UTF8-encoded string of those? and what is the namespace?
do you guys know a way to move `Account` definition to a separate module within the same crate? I added mine into `program_acccounts/initialize.rs` but when importing it into the program lib I get the following error

```
116 | #[program]
    | ^^^^^^^^^^
    | |
    | unresolved import
    | help: a similar path exists: `crate::program_accounts::initialize::__client_accounts_initialize`
```
Hi! One can create an account via a direct call from the client with ```createInstruction``` as in ```await program.account.data.createInstruction(dataAccount)``` But how can i close that account and get back the rent fees?
I guess that's one way
you could fetch accountInfo for target accounts and check state-changes?
I'm using that rn, but I wanna check if the txn is actually successful
not sure. üò¶
because the txn is validated
will that help negate stuff like this?
depending on use-case, you could do something like this :   await provider.connection.confirmTransaction(
            await provider.connection.requestAirdrop(userMainAccount.publicKey, 1000000000),
            "processed"
        );
I used to get this error when I passed ie. Keypair object instead of Pulickey object to an instruction
no, from the frontend
are you not checking status of accounts on explorer?
hello, how do I confirm if a txn was a success on chain?
like without the fail status
Have anyone deployed a websocket for crypto trading pairs API using this git repo: https://github.com/blockworks-foundation/serum-history
Error
```js
Error: Non-base58 character
    at Object.decode (index.js:115:1)
    at new PublicKey (index.browser.esm.js:95:25)
    at index.browser.esm.js:754:1
    at Array.forEach (<anonymous>)
    at Transaction.compileMessage (index.browser.esm.js:752:1)
    at Transaction._compile (index.browser.esm.js:872:1)
    at Transaction.serializeMessage (index.browser.esm.js:894:1)
    at Wallet.<anonymous> (index.js:188:37)
    at Generator.next (<anonymous>)
    at index.js:7:1
```
Morning guys i create a transaction intruction with program.instruction.name but when i try to sign a trasaction with wallet.signTransaction with web3, the method receive a "[object Object] and obtain a error with the signature.
```js
const createUserInstruction: TransactionInstruction = new TransactionInstruction(await this.stakeService.createInstruction(instruction).toPromise());
            transaction.add(createUserInstruction);
            console.log(transaction);
          }
          const signers = [];
          const signature = await this.signature(this.walletAdapter, transaction, signers);


async signature (wallet: WalletAdapter,
    transaction: Transaction,
    signers) {
      try {
        // console.log('transaction', transaction);
        const hash = await this.connection.getRecentBlockhash('max');
        // console.log('blockhash', hash);
        transaction.recentBlockhash = hash.blockhash;
    
        transaction.setSigners(
          // fee payed by the wallet owner
          wallet.publicKey,
          ...signers.map((s) => s.publicKey),
        );
    
        if (signers.length > 0) {
          transaction.partialSign(...signers);
        }
    
        const signedTrans = await wallet.signTransaction(transaction);
        // console.log('sign transaction', signedTrans);
        const signature = await this.connection.sendRawTransaction(signedTrans.serialize());
        // console.log('send raw transaction', signature);
        return signature;
      } catch (error) {
        console.log( error );
      }
  }
```
Hi, seniors. We are going to implement compound feature in farming.
Compound feature is:
```Lock A/B LP -> Reward A -> Swap half of A to B -> Add liqudity(half of A, and swapped B) -> Deposit new LP```
So we should call harvest, swap, addLiqudity, DepositLP instructions.
We tried to execute these instructions in one transaction but stopped because of the compute unit limitation.
Is there any way to sign once for 2 transactions?
I don't think, there is any concept of `gas on computation` in Solana rather then Solana works on  `Lamports per signature`.
any suggestion, any one
Thank you man‚Ä¶
ser, compute units
but i hear it isn't super good
I have no idea how much the base 58 conversion costs
https://github.com/project-serum/anchor/pull/1367/files why isn't it BTreeMap<Pubkey, u8> to avoid the base 58 conversion?
to send a tx instead
I'll just rework this
```js
  static async createMint(connection, payer, mintAuthority, freezeAuthority, decimals, programId) {
    const mintAccount = web3_js.Keypair.generate();
    const token = new Token(connection, mintAccount.publicKey, programId, payer); // Allocate memory for the account

    const balanceNeeded = await Token.getMinBalanceRentForExemptMint(connection);
    const transaction = new web3_js.Transaction();
    transaction.add(web3_js.SystemProgram.createAccount({
      fromPubkey: payer.publicKey,
      newAccountPubkey: mintAccount.publicKey,
      lamports: balanceNeeded,
      space: MintLayout.span,
      programId
    }));
    transaction.add(Token.createInitMintInstruction(programId, mintAccount.publicKey, decimals, mintAuthority, freezeAuthority)); // Send the two instructions

    await sendAndConfirmTransaction('createAccount and InitializeMint', connection, transaction, payer, mintAccount);
    return token;
  }
```
I'm looking at the method now
figured
yep
this can't be used
```js
        const tokenMintA = await Token.createMint(
            this.provider.connection,
            this.provider.wallet.payer,
            this.wallet.publicKey,
            null,
            9,
            TOKEN_PROGRAM_ID
        );
```
yeah I'm trying to use it as a keypair
good practice is to create it in the same transaction that the action requiring it
are you trying to use a utility on the provider somehow?
make a transaction and sign it with the adapter
obviously, since the keypair isn't exposed
because none of the UI wallets have a `payer` attr
is there a way to create an ATA on the client-side using a UI wallet?
okay here's a better question
adapting it is
üòÜ
that's it?
```js
import { PublicKey, Transaction } from '@solana/web3.js';
import { useMemo } from 'react';
import { useWallet } from './useWallet';

export interface AnchorWallet {
    publicKey: PublicKey;
    signTransaction(transaction: Transaction): Promise<Transaction>;
    signAllTransactions(transactions: Transaction[]): Promise<Transaction[]>;
}

export function useAnchorWallet(): AnchorWallet | undefined {
    const { publicKey, signTransaction, signAllTransactions } = useWallet();
    return useMemo(
        () =>
            publicKey && signTransaction && signAllTransactions
                ? { publicKey, signTransaction, signAllTransactions }
                : undefined,
        [publicKey, signTransaction, signAllTransactions]
    );
}
```
`useAnchorWallet.ts`
lol
but I think I can hack the window var and just use sollet/solflare/phantom
yeah the nice thing with the adapter is being able to use a buttload of wallets (don't care about the selector since I designed my own)
if you want let's say phantom only then you can hack it through window yes
the reason people use the adapter is to have access to plenty of wallets but also the dialog wallet selector
instead of messy adaptation
I am talking about the case where PDA is program owned. While talking about the possible workaround to make it confusing
well at that point i'd rather just use the `window` variable
but can't you adapt copy/pasta for your framework?
it seems that there's no way atm to use the `wallet-adapter-wallets` *without* the exclusive `useAnchorWallet()` because someone didn't have the foresight to be able to use outside of React üòÜ
well
Okay
I can't remember exactly, I think it was like the fresh account could then be its own payer or something ü§î
There's some thread in discord of hackily getting around this, sort of, where you transfer out of the program-owned account directly into the un-initialized account, lol
yeah, having a non-system payer (regardless of if it lives at a pda) doesn't really work
Oh, sorry, the pda here isn't owned by the system program?
and then alter the lamports of the pda? I think it is kind of the same problem as handling SOL from a pda, you need a pda still owned by the system program that the program controls
that's for react, I'm not using react üòõ
It could in principle be smart enough to realize the payer has `seeds` + `bump` specified for it
Ah, right, if the payer is a pda then `init` doesn't really work since it doesn't notice it needs to sign
there is a useAnchorWallet thing in that package
because this involves a sys program transfer
yes
Actually, mm‚Äîgetting sleepy, immediately forgot where I was going with that question :/
Meaning if you want the pda to pay for the init-ing?
and pay
I think this is my problem , because connect but it does not let me sign the transaction.
https://tenor.com/view/charlie-day-gif-18564553
this "works" but it also doesn't because the `payer` on `provider` is `null` because the wallet adapter doesn't have a payer attr....
```
        // Get the selected wallet adapter and connect.
        this.wallet = new PhantomWalletAdapter({ network });
        this.wallet.connect();

        // Generate the provider and program for Anchor.
        this.provider = new Provider(this.connection, this.wallet);
        this.program = new Program(idl, this.programId, this.provider);
```
has anyone been able to use `wallet-adapter-wallets` with anchor?
the app was working before
do someone has this error with phantom wallet Translating error Error: failed to send transaction: Transaction simulation failed: This account may not be used to pay transaction fees
isn't `init` kind of problematic if the caller is a pda? Essentially whenver the signer is a pda
<:facepalm:721741693233135676>
looks like it something in my rollup config
ty
https://dev.to/0xmuse/accelerated-guide-to-fullstack-web3-with-ass-anchor-solana-and-svelte-1mg might be of use
having issues with my setup
Has anyone been able to import `anchor` using Svelte?
ah thanks!
When you call `Pubkey::find_program_address`, it gives you back a deterministic bump value (a u8) based on the seeds. That's the canonical bump. The issue is that there could be many other u8s for those seeds that result in an off-curve address (the canonical one is the first bump that works, starting at 255 and going down to zero)
Hey for the account seed contraints what is meant by the "canonical bump"
does anyone of you has experience on that?
I would like to setup a github action for testing programs developed using Anchor framework
<@!490581421778534400>
```js
  it("Prepares for initialization", async () => {

    // Initialize the mints.
    TOKEN_A_MINT = await Token.createMint(
      provider.connection,
      provider.wallet.payer,
      provider.wallet.publicKey,
      null,
      9,
      TOKEN_PROGRAM_ID
    );
    TOKEN_B_MINT = await Token.createMint(
      provider.connection,
      provider.wallet.payer,
      provider.wallet.publicKey,
      null,
      9,
      TOKEN_PROGRAM_ID
    );

    // Create associated token account of token A for user.
    userAssociatedTokenAccount = await TOKEN_A_MINT.getOrCreateAssociatedAccountInfo(
      provider.wallet.publicKey
    );

    // Create 100 tokens for the user.
    TOKEN_A_MINT.mintTo(
      userAssociatedTokenAccount.address,
      provider.wallet.publicKey,
      [provider.wallet],
      TOKEN_AMT
    );

  })
```
yeah this is what I'm doing
ah this is totally what i'm running into üëÜ üí™
hi guys, has anyone managed to get https://github.com/metaspan/solana-docker-mac-m1 working with anchor? sorry for the vague question, ive been pulling my hair out trying to get a working dev setup going on my m1 mac... üòñ  thanks!
you can do a `before` block in your test suite and do a `SPLToken.Token.createMint(...)` and then mint it to use for testing
possible for me to create a SPL token on the localnet when i am testing with the `anchor test` command? i need to create some dummy token for my program to interact with


///////////////////////////////////////////////////////////////////////////////////////////////

What have you tried so far?
Oh I think I meant PDA, so the data or in that case the wallet is saved in a standalone account of the user
What do you mean by save here? Link how?
hey I would have another question,

How can I make it so that when the user calls the function, a new wallet account gets created and is linked to his public key (in the program).
Next time the programm is called it checks if there is already one. 

Question in short: Save a newly created wallet in the blockchain and link it to the user calling the program
oh wait idl isn't pushed by default? awesome thanks!
You have to go out of your way to push the idl, so‚Äînothing
If I'm writing a program in anchor and want to push it to chain but not the idl to make reverse engineering harder. how would I go about it?
All good lol
because you guys saved me some
are we able to donate a coffee to you ?
üòÑ
Yeah, you ended up accidentally using `undefined`
undefined
ok now I know what NOT PROVIDED means
oh wait
Do `fromTokenAccount.whateverNeedsToGoHereToWork`
nvm
oh...
dot into it?
Ok, then dot into it however you need to to get its address
AccountInfo
At runtime, what is the type of fromTokenAccount? Like, what is that variable?
```Error: Wrong input type for account "tokenFrom" in the instruction accounts object for instruction "create". Expected PublicKey or string```
i can test it again though
then it complains that it expected string or publickey
It doesn't have a `.publicKey` field
Just do `tokenFrom: fromTokenAccount`
It's messy so I don't wana paste it all
```
var myToken = new Token(
    provider.connection,
    mintPublicKey,
    TOKEN_PROGRAM_ID,
    provider.wallet.publicKey
  );

it('create token account', async () => {
    fromTokenAccount = await myToken.getOrCreateAssociatedAccountInfo(
      provider.wallet.publicKey
    );
  });

await program.rpc.create(
      new anchor.BN(5_000_000_000),
      {
        accounts: {
          tokenFrom: fromTokenAccount.publicKey,
          tokenFromAuthority:  provider.wallet.publicKey,
          tokenVault: test,
          tokenProgram: TOKEN_PROGRAM_ID,
        },
      });

```
Post the full JS syntax you're using
```
Error: Invalid arguments: tokenFrom not provided.
```
this error
Can you say more? Not sure what you mean
and what does it mean when it says not provided even though you provided something?
For example this:
```#[account(mut)]
  //the token account to withdraw from
  pub token_from: Box<Account<'info, TokenAccount>>,
```
damn one line ...

it worked thank you.
ohh i see, thanks I will look into  it
Yes, there needs to be an actual token account at that address
i mean if not initialized it maens doesn't exist for that token*
initialize means that the token account dosn't exist?
So here, you're probably forgetting to initialize one of those token accounts
That error means your program is expecting you to pass it a Foo account, but you're actually passing it an uninitialized account
```
    Program EzymRPQRG3Bb163HPjybqZ8xTNkYA4cnH7ad6n9awMgU invoke [1]
    Program log: Instruction: Create
    Program log: Custom program error: 0xbc4
    Program EzymRPQRG3Bb163HPjybqZ8xTNkYA4cnH7ad6n9awMgU consumed 2740 of 200000 compute units
    Program EzymRPQRG3Bb163HPjybqZ8xTNkYA4cnH7ad6n9awMgU failed: custom program error: 0xbc4
```
```#[derive(Accounts)]
pub struct Stake<'info> {
    #[account(mut)]
    //the token account to withdraw from
    pub token_from: Box<Account<'info, TokenAccount>>,

    //the authority allowed to transfer from token_from
    pub token_from_authority: Signer<'info>,

    pub token_vault: Box<Account<'info, TokenAccount>>,

    pub token_program: Program<'info, Token>,
}


await program.rpc.create(
      new anchor.BN(5_000_000_000),
      {
        accounts: {
          tokenFrom: tokenFromAccount,
          tokenFromAuthority:  provider.wallet.publicKey,
          tokenVault: test,
          tokenProgram: TOKEN_PROGRAM_ID,
        },
      });
```
I changed it up a bit. The only thing I want to do is to send the token he has into the token_vault.

The program expected this account to be already initialized <--- Do you know what this error means? Where should I look when I get that
hmmmm leme check that one too
Youre setting `tokenVault` to `toTokenAddress` instead of `vaultPubkey`
Ok I found out why
ok i admit i don't know what to do...
can you please look over it again 
```
[vaultPubkey, vaultBump] =
    await anchor.web3.PublicKey.findProgramAddress(
      [mintPublicKey.toBuffer()],
      program.programId
    );

    await program.rpc.create(
      vaultBump,
      new anchor.BN(5_000_000_000),
      {
        accounts: {
          tokenMint: myToken.publicKey,
          tokenFrom: test,
          tokenFromAuthority: provider.wallet.publicKey,
          tokenVault: toTokenAddress.publicKey,
          tokenProgram: TOKEN_PROGRAM_ID,
        },
      });
```

Error: 2006: A seeds constraint was violated

This is what I get at the moment. Thanks in advance!
Hi Team. I am looking for an example of how to create a durable nonce account using the anchor. Any link to guide/tutorial would be really helpful.
oh wait I might have an idea
```
    Program FL6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS invoke [1]
    Program log: Instruction: Create
    Program log: Custom program error: 0xbc4
    Program FL6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS consumed 2889 of 200000 compute units
    Program FL6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS failed: custom program error: 0xbc4

Error: 3012: The program expected this account to be already initialized

await program.rpc.create(
      vaultBump,
      new anchor.BN(5_000_000_000),
      {
        accounts: {
          tokenMint: myToken.publicKey,
          tokenFrom: provider.wallet.publicKey,
          tokenFromAuthority:  provider.wallet.publicKey,
          tokenVault: toTokenAddress.publicKey,
          tokenProgram: TOKEN_PROGRAM_ID,
        },
      });
```

This is what I get now, seems like this whole Rust Solana dev thing doesn't like me. Never took this long to understand something
leme check, thank you alot <@!347689664855015424>
should be `await program.rpc.create(nonce, new anchor.BN(amount),{{accounts...`
youre missing the function arguments, nonce and amount
Error: Invalid arguments: tokenMint not provided.
Now I get this
```
  const mintPublicKey = new anchor.web3.PublicKey("CixLGX3WkYxhGK4k1p5VUCBX7LaL4aJFnaukxkf9WkPv");

await program.rpc.create({
      accounts: {
        tokenMint: mintPublicKey,
        tokenFrom: provider.wallet.publicKey,
        tokenFromAuthority:  provider.wallet.publicKey,
        tokenVault: toTokenAddress.publicKey,
        tokenProgram: TOKEN_PROGRAM_ID,
      },
```
i renamed the function
you sent the ix structure for Stake but the function youre calling is `create`
To be honest I copied it from somewhere and tried to adapt it. I didn't get why they used Box for or what it is used for at all. So i removed it
ctx: Context<Stake>, nonce: u8, amount: u64
can u send your ix function signature too?
Hey guys

I get the following Error:
```
Transaction simulation failed: Error processing Instruction 0: custom program error: 0x66 
    Program FL6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS invoke [1]
    Program log: Instruction: Create
    Program log: Custom program error: 0x66
    Program FL6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS consumed 2977 of 200000 compute units
    Program FL6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS failed: custom program error: 0x66

     Error: 102: The program could not deserialize the given instruction
      at Function.parse (node_modules/@project-serum/anchor/dist/cjs/error.js:40:20)
      at Object.rpc [as create] (node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:38:61)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at async Context.<anonymous> (tests/basic-2.js:46:5)

```

```
#[derive(Accounts)]
#[instruction(nonce: u8)]
pub struct Stake<'info> {
    #[account(
        address = constants::STEP_TOKEN_MINT_PUBKEY.parse::<Pubkey>().unwrap(),
    )]
    pub token_mint: Account<'info, Mint>,

    #[account(mut)]
    //the token account to withdraw from
    pub token_from: Account<'info, TokenAccount>,

    //the authority allowed to transfer from token_from
    pub token_from_authority: Signer<'info>,

    #[account(
        mut,
        seeds = [ token_mint.key().as_ref() ],
        bump = nonce,
    )]
    pub token_vault: Account<'info, TokenAccount>,
    
    pub token_program: Program<'info, Token>,
}

await program.rpc.create({
      accounts: {
        tokenMint: mintPublicKey,
        tokenFrom: provider.wallet.publicKey,
        tokenFromAuthority:  provider.wallet.publicKey,
        tokenVault: toTokenAddress.publicKey,
        tokenProgram: TOKEN_PROGRAM_ID,
      },
```

Does somebody have any idea why I get this. I've literally been trying to fix this for hours... Any help is appreciated
A question about the anchor_spl library:
If i have a token account (let's call this token account `X`) with a delegate that's allowed to spend an amount `dx`, and the delegate spends an amount `y`  (assume `y` is smaller than `dx`), does the `.delegated_amount` field of the token account actually get updated to the value `dx - y` when the delegate decides to spend? or is that something i need to manually handle myself?
U can check the working repo https://github.com/AJTJ/auction
hey did you ever fix this? im getting the same result from a very similar situation
thanks ü§†
it's odd because if i call setCurrentProfile, only the first time it is called does it also affect loadedProfile.
The problem is that when i change the state of current profile, it also impacts loadedProfile sometimes as well, usually in odd ways. loadedProfile is supposed to be a stored snapshot that can be reverted back to, whereas currentProfile will change. Any ideas why this is happening?
hey my friends. i am using REACT and i set the state for two items with the same object. ```
   const [loadedProfile, setLoadedProfile] = useState();
   const [currentProfile, setCurrentProfile] = useState();```
Got it, okay I think I have a much better understanding now. I do have access to it in this case since it'll be a wallet I control. 

I really appreciate all of your help.
But in order to have that be the right thing you'll need access to that creator keypair (no avoiding that‚Äîyou can't sign without it)
No, because the `provider.wallet` automatically signs
But nothing has to explicitly sign that transaction?
But it's just an account
Do you have access to its keypair? You would create a Provider from it, and then pass it as an account:
```.js
await program.provider.createTweet({
  accounts: {
    tweet: tweetAddress,
    author: program.provider.wallet.publicKey, // aka the creator
    systemProgram: ...
  }
}
```
I think so too, because what you're saying makes sense. So in an example like this:
```
#[derive(Accounts)]
pub struct CreateTweet<'info> {
    #[account(init, payer = author, space = Tweet::LEN)]
    pub tweet: Account<'info, Tweet>,
    #[account(mut)]
    pub author: Signer<'info>,
    #[account(address = system_program::ID)]
    pub system_program: AccountInfo<'info>,
}
```
How would I be able to send in the provider wallet (the wallet that created the program) as the author?
The wallet isn't really "automatically" signing for anything‚Äîit's just submitting a transaction, the same way it works in your tests (so it's just "programmatic", not really automatic or anything)
But when you run your tests, they also need access to a keypair (it's configured via your Anchor.toml in this case of running tests)
You'd do the same thing in your chron job, except you'd actually talk to the real deployed version of the program
They get configured with a wallet, and run requests against your code
It would be very similar to how you run your tests
I think you might be making this more complicated than it needs to be (or I'm misunderstanding)
Can you say more about what you've tried so far/what has gone wrong?
That make sense, I'm still a bit confused on how a wallet would automatically sign for the initialization of an account though.
But that shouldn't have anything to do with the #[account(zero)] stuff
Ah, yeah, you'd need some way to initialize your provider etc. with the right keypair
That's the idea, I just think there's a gap in misunderstanding about how I can initialize programs that way. I'm assuming to do that I'd have to store the keypair somewhere where the cron job can grab it and initialize those accounts right?
Can you not just have like a chron job etc. that talks to your program every 12 hours?
I think I'm still confused about what goes wrong if you just do that though, haha
Ideally I'd like to keep the initialization of those betStates to the wallet that initially created/launched the program.
Like, why can't you just initialize the account with a request to your program‚Äîwhy does it matter who's paying for it?
Not sure why that would change anything in your anchor program though ü§î
Ok, cool
Yup!
Sorry, what do you mean by initialize with your wallet? Just meaning have your wallet pay the tx fees/rent etc.?
Yes, and that makes sense as to why that error is popping up. I'm trying to figure out how to initialize an account automatically with my wallet so account initialization can happen on a timely basis without my manual intervention.
Just to double check we're on the same page, #[account(zero)] means that you allocated the storage for that account in a separate createAccount instruction, so the storage space is there already but Anchor hasn't had a chance to set the account's discriminator bytes yet
What do you mean by initialize an account with the provider's wallet? Not sure what that means
This seemed like the most straightforward way to initialize an account with the provider's wallet. Didn't know how else for the provider's wallet to auto-sign the creation of an account. The goal here is to automatically create a betState account from my(provider's) every 12 hours.
Ah‚Äîwhy are you using `#[account(zero)]` there, just to make sure I'm following?
Hope that made sense lol
Interesting, all of my types match up, the only thing that might look fishy is the way Im creating this account here below
```
#[derive(Accounts)]
pub struct InitializeBetState<'info> {

    #[account(zero)]
    bet_state: Account<'info, BetState>,

    bet_creator: AccountInfo<'info>,

    rent: Sysvar<'info, Rent>
}
```
This "betState" account is getting passed into another rpc call that initializes a bet that needs this betState account to be passed in and is throwing the error. All my other accounts' types make sense, but this betState is being initialized differently, with the provider wallet instead of a third party user.
Now you're passing in the wrong kind of account‚Äîyour rust program is expecting an Account<'info, Foo> but you're actually passing it a Bar
Ah, that fixed that, but now I'm receiving  ``` Error: Invalid account discriminator ```
Look in your target/idl file and see which accounts are expected to sign that instruction‚Äîyou're not signing for one of them
Im receiving ```Error: Signature verification failed``` when trying to initialize a new account by a test user and passing in an account that was created by the provider wallet. Does this mean that the account created by the provider wallet can't be passed in? Not sure how to move forward.
<@!501570363566587905>  do you have any idea how the .sol TLD was made ?
and is there any open source program ?
could be cool though
nope that was never a feature
"my-seed".as_bytes() should work?
yeah, I only wanted to make super anchor program. lol üòÜ
The old-fashioned way, lol
But why do you need this? Can't you, like, just hardcode things?
So I don't know, it's probably just not very developed yet
Yeah tbh I had never even heard of that feature
why anchor doesn't have this function? Is it difficult to implement?
I need **"my-seed"**, not **b"my-seed"**
Maybe I couldn't use it for producing pda
Thanks. but if I get value of my_seeds, it is ```b"my-seed"```
Can see an example in the tests: https://github.com/project-serum/anchor/blob/master/tests/misc/tests/misc.js#L916
Is there any example of parsing IDL json to get constant?
You might have to just walk through the IDL json.
I don't see any examples of doing that in the tests
Did `program.constant` ever work?
Hi, alan, How can I use constant from IDL in typescript client?
i.e.
in rust part:
```
#[constant]
let my_seeds: &[u8] = b"my-seed";
```
in idl, I can see
```
"constants" :[
  {
    "name": "my_seeds",
    "type": {
      "defined": "&[u8]"
    },
    "value": "b\"my-seed\""
  }
]```
I tried to use my_seeds as like program.constant.mySeed, but not working now.
No, all you can do with a signature is verify it (using the public key)‚Äîpart of its magic is that it doesn't leak any info about the secret key
If i sign a transaction with nacl.sign i.e.
```
let feePayerSignature = nacl.sign.detached(serializedTx, userAccount.secretKey);
```
is feePayerSignature sensitive data? If an attacker somehow got a hold of the feePayerSignature, are they able to do nefarious things with it?


///////////////////////////////////////////////////////////////////////////////////////////////

Hi, how to define IDL (instructions) with no fixed number of accounts.
I want to do something like this for all the NFTs in a marketplace
how to track events on token accounts using anchor?
https://cdn.discordapp.com/attachments/915593529194070068/945200253253062696/unknown.png
^ turned out that i was trying to send too many instructions in a single tx and the tx was too large. sending 10 at a time avoided that error fyi
what's the best way to debug one of these errors: `RangeError [ERR_OUT_OF_RANGE]: The value of "value" is out of range. It must be >= 0 and <= 255. Received 11359` - i've been successful 100 times in devnet but hitting this in mainnet now. this is occurring during account config initialization. thanks!
hi, ProgramAccount is unavailable in >0.20.0, what is the substitute?
super interesting / cool. thanks a ton of your insight
Yep
understood. so `invoke` does not create a transaction . . . but instructions the run-time to invoke
You would run that code *within* a broader transaction context
No, that creates multiple instructions, not transactions
right. so this is sequential & creates multiple transactions. correct ?
Just like doing a regular system_program transfer, except in a loop
And then loop through them/execute them with invoke/invoke_signed, as normal (anchor basically has no effect on this)
You would just use that right in your rust program, no need to do any anchor stuff
with this method: https://docs.rs/solana-program/latest/solana_program/system_instruction/fn.transfer_many.html
But I feel like that's not what you mean‚Äîcan you say more?
There are some situations where you might send in an instruction from the client as a data structure: https://github.com/project-serum/multisig
Where would you get that Vec<Instruction> from if not the client?
Mm, not sure what you mean. You can just do multiple things in your rust code
<@!134416332509675520> are you aware of a method that does not involve passing instructions from the client? this ideally is handled entirely by the rust solana program I think
Or building a transaction and manually adding instructions, etc.
You would do this by sending those instructions in a single transaction from the client:
```.js
await program.rpc.doSomething({
  accounts: {
    ...
  },
  instruction: [
    ... // add pre-instructions here
  ]
});
```
yes
but digging thru the `src` both native `solana-program` and `anchor-lang` it's not obvious how
the solana docs claim to support this https://docs.solana.com/developing/programming-model/transactions#multiple-instructions-in-a-single-transaction
does anchor support sending multiple instructions `Vec<Instruction>` in exactly one transaction?
your pubkey isn't the object you believe it is
does anyone know this error

(would also eek me out some storage space savings in a many to many linkage which is always great)
Hey! I have some API efficiency questions: Is there some well understood point where using `fetchMultiple` to grab every single possible PDA associated with a specific object Type X is more/less efficient than a `all(filter with a reverse pubkey to original object)` I'm in a situation where I have a many to many relationship but Type X is likely to be some orders of magnitude larger than the other many.
Hello Guys
Nice to meet you
I'm new to Anchor framework
And have a project to do. It's a Token staking program with token locking time
I tried to create stake_account for every deposit and vault account to deposit to. But I can't implement with the anchor code
Who can help me with this?
Hi there! Did someone have tips about the dev cycle for create a project with Anchor ? Where to start, how to build your logic, which docs etc..


///////////////////////////////////////////////////////////////////////////////////////////////

Thank you! That seems likely üôÇ
This is a change in anchor 0.22.0, replace those ProgramResults with Result<()>
My guess is that your init_if_needed is trying to init the associated token account, and that then calculates the *correct* address based on the mint + update_authority, but that doesn't actually match the address you're passing in from the client.
You're probably not passing in the correct associated token address from the client.
And here's the error I'm getting when I try to run it:
```
logs: [
    'Program BRruaeiRT6Z54nKSXffCsZDSEfAgFHH5XfNCCNEWBYHG invoke [1]',
    'Instruction references an unknown account ArrkjakQzzmLredzSoTBMnKX1cfH9YyygmmDs1NVmS3e',
    'Program BRruaeiRT6Z54nKSXffCsZDSEfAgFHH5XfNCCNEWBYHG consumed 200000 of 200000 compute units',
    'Program BRruaeiRT6Z54nKSXffCsZDSEfAgFHH5XfNCCNEWBYHG failed: An account required by the instruction is missing'
  ]
```

I have no idea why is there an account missing, and I don't know what is the 'ArrkjakQzzmLredzSoTBMnKX1cfH9YyygmmDs1NVmS3e'  account... I know it's not one of the accounts that I provide
Hi! I have a problem when I try to mint a coin to an account, and I cannot figure out what this error means... Anyone care to help? üôÇ
Here's the program code:
```
 use anchor_lang::prelude::*;
 use anchor_spl::token::Token;
 
 declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");
 
 pub const UPDATE_AUTHORITY_SEED: &str = "update-authority";
 
 #[derive(AnchorSerialize, AnchorDeserialize)]
 pub struct Bump {
     pub update_authority_bump: u8,
 }
 
 #[program]
 pub mod souls_test {
     use super::*;
     pub fn initialize(ctx: Context<Initialize>) -> ProgramResult {
         let cpi_accounts = MintTo {
             mint: ctx.mint.to_account_info(),
             to: ctx.associated_with_mint.to_account_info(),
             authority: ctx.owner.to_account_info(),
         };
         let cpi_program = ctx.token_program.to_account_info();
         let cpi_xtx = CpiContext::new(cpi_program, cpi_accounts);
         token::mint_to(cpi_ctx, 2)
     }
 }
 
 #[derive(Accounts)]
 #[instruction(bump: Bump)]
 pub struct Initialize {
     pub owner: Signer<'info>,
 
     #[account(
         seeds = [UPDATE_AUTHORITY_SEED.as_bytes()],
         bump = bump.update_authority_bump,
     )]
     pub update_authority: UncheckedAccount<'info>,
 
     #[account(mut)]
     pub mint: UncheckedAccount<'info>,
 
     #[account(
         init_if_needed,
         payer = owner,
         associated_token::mint = mint,
         associated_token::authority = update_authority,
     )]
     pub associated_with_mint: UncheckedAccount<'info>,
 
     pub token_program: Program<'info, Token>,
 
     pub system_program: Program<'info, System>,
 }
```
Hi I'm getting a fundamenal compile error. Here's what 'im using, its only a newly setup macbook just an hour ago:
rustc 1.58.1 (db9d1b20b 2022-01-20)
solana-cli 1.9.8 (src:4ebeb336; feat:2191737503)
anchor-cli 0.22.0

Getting error say **cannot find type `ProgramResult` in this scope**

Someone in Solanatech pointed out that it might an Anchor version issue. I know this was working with solana-cli 1.9.7 and ancohr-cli 0.21.0
Actually when I'm supposed to receive 1 I received 2^40 and when I'm supposed to receive 2 I receive 4^41. Don't think this helps though because it depends on the layout ... Any solution to deserialize it correctly in ts?
```    #[account(
        constraint = token.mint == mint.key(),
        constraint = token.owner == user.key() 
    )]``` rather
`#[account(constraint = a, constraint = b)]` or does it need to be one expression
does account macro support n constraints?
i updated the client code so it fetched the active token account vs derive it. not ideal, but it's a requirement
ok easy enough then, i can update. thanks
You can always just do `constraint = the_token_account.mint = some_mint` etc.
hi! what's the best way to check mint / owner for a token account (not necessarily ata) that is guaranteed to already be initialized? i released a contract and it turned out that many folks holding mints had token accounts that weren't ATAs so i've removed some constraints, but i'd like to get some constraints back in place. i can add a code block to check mint / owner, but wondering if there's a easy constraint that i'm missing that is aside from an init constraint. thanks!
Not actually sure what you're supposed to do for this use case‚Äîanyone?
I may be being dumb, but I think in general you can't expect zero_copy accounts to deserialize correctly in ts, because the ts stuff expects them to be borsh-serializable, but zero_copy doesn't use borsh (it doesn't use anything, just the raw rust layout).
Anyone might have a hunch why, when using a zero_copy account with AccountLoader, the loaded data is always correct onchain. But when I try to fetch the account in ts (using `await program.account.accountName.fetch(accountPubkey);`) the fields contain wildly different values? They make sense in the way that 0 = 0, 1 = 2^20, 2=2^40 and so on ... Also I'd like to mention that it was working before, but after I changed the migrated the account to zero_copy it doesn't work anymore
Perfect! Thanks for that
Yep https://docs.solana.com/cli/deploy-a-program#set-a-programs-upgrade-authority
Ok thanks for that breakdown!
I do similar with SlotHash, in a 2 phase tx. First tx says which upcoming SlotHash to use. Second (after it passes) grabs it. If you use the metaplex method, **be sure to also implement their instruction sysvar check** to be sure no trailing ix gates the tx.
Interested in this as well. Metaplex has a method using recent_slothashes that I am implementing
Random follow up question off the back off this. Is there a way to change the anchor program's update authority? Or would I need to deploy the program again separately with another keypair
ya any guidance would be appreciated üôè
I‚Äôm drawn to discussions on randomness like a moth to a light.
hi <@!99911938955309056>
SolanaDino uses a commit/reveal method that works well. I can walk you through the concept later if you like
That is a horrible, horrible hack.
their example repo is mostly setting up not using the vrf :))
anyone got switchboard vrf working in anchor ? would love to see an example
I'm not sure how that helps, from what I understand you can't do `==` comparison so using `assert!` I'm not sure what condition I need there
what is meaning of serializing and desalinizing of accounts using anchor?
I also tried this code and it gives me `Error: No signers`
```tx.recentBlockhash = (await connection.getRecentBlockhash()).blockhash;
        tx.feePayer = anchorWallet.publicKey;
        tx.partialSign();
        console.log(tx);
        tx = await anchorWallet.signTransaction(tx);
        let res = await provider.connection.sendRawTransaction(tx.serialize());
```
How do i sign a transaction with the anchorWallet interface.
Using phantom wallet and getting this issue
`WalletSignTransactionError: Transaction recentBlockhash required
    at PhantomWalletAdapter`
<@!341595318283927552>, not `assert_eq!`, do `assert!`
Hi there.
Did anyone come across such error? 
```
error: package `uint v0.9.3` cannot be built because it requires rustc 1.56.1 or newer, while the currently active rustc version is 1.56.0-dev
```
thanks a lot, will do that. I ran cargo build-bpf from a parent directory and it ended up solving the initial compilation issue, very weird haha
Do people have a workaround for asserting on errors in unit tests on `0.22.0`? E.g. before I would do this;
```
assert_eq!(result, Err(MyError::SomeError.into()));
```
But I can't find a way around this without running into;
```
 binary operation `==` cannot be applied to type std::result::Result<(), anchor_lang::error::Error>
```
I think the issue is this file https://github.com/saber-hq/stable-swap/blob/master/stable-swap-anchor/Cargo.toml. they specified `anchor-lang >= "0.17"`. That causes it to import any new version above 0.17 regardless of whether it breaks existing code. You can fork the repo and use your fork inside which you change it to `anchor-lang = "0.17.0"`
Hi, I'm trying to run the soteria docker image to do a few security checks on the prorgam. When I run 
```cargo build-bpf```
 I get the following errors: 

 ```error[E0107]: this type alias takes 1 generic argument but 2 generic arguments were supplied
  --> /root/.cargo/registry/src/github.com-1ecc6299db9ec823/stable-swap-anchor-1.6.8/src/state.rs:49:54
   |
49 |     fn try_deserialize_unchecked(buf: &mut &[u8]) -> Result<Self, ProgramError> {
   |                                                      ^^^^^^       ------------ help: remove this generic argument
   |                                                      |

```
I assume that these are due to some version mismatch, outside of the image the program compiles fine, for some reason it can't compare 
``` stable-swap-anchor = "1.6.7"```
 

Here're the dependencies in  the cargo.toml: 

 ```
[dependencies]
anchor-lang = "0.20.1"
anchor-spl = "0.20.1"
solana-program = "1.8.12"
spl-token = { version = "3.1.4", features = ["no-entrypoint"] }
stable-swap-anchor = "1.6.7"
```


Any help would be much appreciated,
looks like hashing current timestamp + btc price from chainlink oracle is one hack - but no official support?
is there a go-to solution for random number generation?
type annotations neededthis method call resolves to `&T`note: type must be known at this pointrustc(E0282)list_for_sale.rs(5, 10): this method call resolves to `&T`no field `owner` on type `&_`rustc(E0609)pub trait Accounts<'info>: ToAccountMetas + ToAccountInfos<'info> + SizedA data structure of validated accounts that can be deserialized from the input to a Solana program. Implementations of this trait should perform any and all requisite constraint checks on accounts to ensure the accounts maintain any invariants required for the program to run securely. In most cases, it's recommended to use the Accounts derive macro to implement this trait.
error[E0282]: type annotations needed
 --> programs/sol_transaction/src/instructions/list_for_sale.rs:5:10
  |
5 | #[derive(Accounts)]
  |          ^^^^^^^^ this method call resolves to `&T`
  |
  = note: type must be known at this point
  = note: this error originates in the derive macro `Accounts` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0609]: no field `owner` on type `&_`
 --> programs/sol_transaction/src/instructions/list_for_sale.rs:5:10
  |
5 | #[derive(Accounts)]
  |          ^^^^^^^^
  |
hi guys the program was working fine on anchor v0.18.0 but when i upgrade to v0.21.0 it not building
I've installed all the dependencies and got this error when running the anchor test on Ubuntu
Hi Team. I am using anchor for development. I have taken an Vectot of u8. Now while init I need to provide the size of it. Any idea how I can implement the size of a vector for saving it in an account.
It will happen automatically if you publish
It‚Äôs open
I have a  `Box<Account<'info, MyAccount>>`, which I am trying to close via the `close` attribute but seems to be failing to close as expected. This particular instruction is called by another instruction. When I close the account "manually" from within the instruction I am successful. Is this a known issue?
So init uses `invoke()` under the hood afaik, is the a way to make it use `invoke_signed`?

Something like this?
Hey is it possible to use a PDA as an address of an account you are just initiating?
Seems back on track, was 1.8.12 to 1.8.14 transition it seems
edit: I was using the wrong devnet url <:pepefacepalm:834817528294277130>
Anyone running into `error trying to connect: The certificate was not trusted.` the last hour? <:pepethink:904036530069328012>
I wanted to do a token transfer and init if it hasnt been already so this works for me.
And for the tokenaccount address being passed in from client, I can just call getAssociatedTokenAddress from the @solana/spl-token library correct?
Yep (you can also use the regular `init` attribute instead of `init_if_needed` if you want)
```
    #[account(
        init_if_needed,
        payer = payer,
        associated_token::mint = the_mint,
        associated_token::authority = the_authority,
    )]
    pub something: Account<'info, TokenAccount>,
```
Found this code from using the search, is this how I would go about creating an associated token account for someone in my anchor program?
https://docs.phantom.app/integrating/tokens/tokens
docs say yes but i can't get it to show in wallet. ik the metadata was successfully created
can anyone confirm/deny that phantom will show on-chain metadata for regular tokens?
Could I get publishing access to the Anchor Program Registry to verify a build?
nvm found it here https://project-serum.github.io/anchor/getting-started/verification.html#building
Is there a documented process somewhere to get the Anchor-verified build status in the Solana explorer?
Given I have a CPI interface
How can I manually deserialize ix_data and find the instruction arguments?
nvm theres some functions in the str library that I think will solve the problem
just by using the str library?
removing whitespace is easy but how can I remove symbols etc without defining all of them ahead of time?
Mmm sounds likely
`rand` is a dev dependency of the `regex` crate. maybe thats causing a runtime issue?
Yeah can always do simple stuff by hand
Hm I'll try looking. I'm just trying to apply `\W+`.
Maybe you can find a different/simpler regex crate?
Ok, that's a definite blocker with using that library
ELF error: Found writable section (.data._ZN5regex4pool7COUNTER17h2edeb26d5be246f8E) in ELF, read-write data not supported
I get that too lol
Actually I do get a different error though lol, about ELF stuff
you can throw some accounts in the heap to free stack space by `Box`ing them in the `Accounts` struct for the instruction
And that's the only thing in your program that leads to that stack error? I just tried some similar code locally and I don't seem to get a stack error ü§î
No idea how to accomplish this without changing our product specs.
Is anyone using Regex in their programs? The constructor is too large for a stack variable. Trying to check a string passed is alphanumeric

`Error: Function _ZN5regex4exec11ExecBuilder5build17h6409425ee0b47b20E Stack offset of 11208 exceeded max offset of 4096 by 7112 bytes, please minimize large stack variables`
yeah sort of an odd problem. got a 1-to-1 user and account that has a vector for child account public key storage/association and would like to offer the users an option to increase the vector storage limit
Oh, interesting‚Äîgot it
otherwise i'd need to add some sort of dynamic seed so there's no pubkey overlap
that's how i have it implemented now, but was curious about methods to reuse pdas because of seeding
Can you not just have one transaction where you pass in both the old account + the fresh new one, copy over the data, then close the old one?
it is in multiple transactions, you would just zero out the data and assign the account back to the system program and it would be "reset" and then could be reinitialized in a subsequent transaction, but this is annoying for the user to have to sign two transactions for an account migration process
Hmm, I don't think it is possible to reinitialize with other size.
anyone know why `anchor.BN.toBuffer()` is throwing `toBuffer` is not a function? 


obvs its a function - https://project-serum.github.io/anchor/ts/classes/BN.html#toBuffer

im calling it like this 

https://github.com/metaplex-foundation/metaplex/blob/master/js/packages/cli/src/helpers/accounts.ts#L521
yes i know, was curious if there were any patterns for creatively closing / reinitializing accounts so that the space could _appear_ scalable for UX
Account size is static during its lifetime on solana blockchain.
You may need to make some reserve spaces on account for further update.
```
{ ... ...
  pub reserve1: u128;
  pub reserve2: u128;
  pub reserve3: u128;
.. ...
}
```
anyone come across any good patterns for resizing accounts? (reinitializing with more space)
Not any time soon as far as I know‚ÄîI think it will at some point though.
is this limit changing at any point pls ?
appreciated, thanks
Yep :/
gaaaah.... may I also ask for my understanding... even if I split this into multiple instructions it wont work because the transaction will end up too big ?
Nope, unfortunately no way around it :/
Hi, I'm running up against the max number of accounts that can be passed to an instruction.
Is there a way around this ? For example I'm thinking of storing the accounts I need in a state object at initialization, and then just passing the state object publicKey etc.... but will this work please ? 

I see this question has been asked in various forms, but I cant see explicitly using a "state" account as a layer of indirection.

My instinct is that it wont work because the accounts themselves are not passed in and it would likely break security models.... but I'm not sure

any help appreciated !


///////////////////////////////////////////////////////////////////////////////////////////////

when deploy program to devnet, I am getting this error.

`dump targets should not be provided with init. please use dump without a target`

How can I fix it?
Put out my anchor viz tool for anyone interested. Just `cargo install anchor-viz` and run `anchor-viz` from within an anchor project directory. Would love feedback or would love to see it in action.
Cool thanks
Yes you can still use it explicitly
Did anchor use `repr(packed)` earlier? I have a production smart contract so do not want existing accounts to break.

It appears so, from this issue title. https://github.com/project-serum/anchor/pull/1356#issuecomment-1045114489
Hi! Is there any example on my last comment in this question: https://github.com/project-serum/anchor/pull/1380 ? Shortly I am looking for example of escrow program with PDA that store some data and store tokens in the vault. On request of other account he can withdraw this locked tokens.
any other public devnet rpc nodes?
down
anyone having issues with devnet rpc?
^bump
Why after updating an IDL with `set-buffer`, the IDL buffer is not closed to retrieve rent?
thx for clarifying
ok understood
wait you dont have to do this though. `Account` already checks the owner. The additional `owner` constraint is pointless
Looks like devnet is down?
can u file an issue for that
oof
still gives me the same error: `no field owner on type &anchor_lang::prelude::Account<'_, execution_receipt::ExecutionReceipt>`
am I the only one having trouble deploying to devnet?
```
Error: Account allocation failed: RPC response error -32005: Node is behind by 54932 slots
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.
```

tried multiple times using different RPC providers - with same result
I want to create a list like structure, like I want to keep adding addresses to the list, by incrementing some nonce or counter value each time. How do I achieve this using PDA for each list address in anchor?
Yep. I am using v0.20, but the problem is as follows: the zero copy accounts use repr(C) by default. You could force them to use repr(packed) which would solve the issue, but it's gonna be a hard error in the future because of unalignement. The solution is to not have unaligned bytes, which in my case was solved by converting u8 -> u64 and u16-> u64. Not sure if this is a hack or not, but will see.
`owner = crate::ID`
Did you get an answer? Getting the same issue after v0.22 upgrade
not sure if the best way tho
ok this solved it 
```rs
    #[account(mut, 
        constraint = execution_receipt.to_account_info().owner == program_id,
        has_one = taker, has_one = mutation)]
    pub execution_receipt: Box<Account<'info, ExecutionReceipt>>,
```
same if I try `constraint = execution_receipt.owner == *program_id`
trying to do an owner check on one of the accounts: `owner = *program_id`

after upgrading from 0.19 to 0.22 and getting `no field owner on type Box<anchor_lang::prelude::Account<'_, execution_receipt::ExecutionReceipt>>`

any advice?
Also what's a good resource for reading up on these details?
I have a general n00b question about rent in Solana/Anchor. Does passing in ``` Sysvar<'info, Rent>, ``` handle rent being paid to store the account on chain, and rent being retrieved once the account is closed or is some further logic to be implemented to handle such things?
Thank you!!
^
plz in rust plsssss
Hello! Would we be able to decode the base64 event logs using the anchor_client for rust? If not, would I be able to decode the base64 logs simply using borsh to deserialise it?
solana program close --buffer buffer.json
something like that
but you need to have saved the keypair
what command would getting the sol from the account?
would be better to see the context and constraints you call this instruction
Full program log ```Transaction simulation failed: Error processing Instruction 0: custom program error: 0xaa 
    Program 4UyPxtrzuFNQHQWmY9Gqb3LspExhYVUAecY9vxuDgtTe invoke [1]
    Program log: Custom program error: 0xaa
    Program 4UyPxtrzuFNQHQWmY9Gqb3LspExhYVUAecY9vxuDgtTe consumed 2990 of 200000 compute units
    Program 4UyPxtrzuFNQHQWmY9Gqb3LspExhYVUAecY9vxuDgtTe failed: custom program error: 0xaa``` It works when the provider is a filesystem wallet in the tests. But it seems like when I test it with the front end using phantom it fails
<@!379899858737168385> did you ever figure this problem out? Facing the same error Transaction simulation failed: Error processing Instruction 0: custom program error: 0xaa - but I don't think I have any signers that I'm not supplying
Check this out: https://project-serum.github.io/anchor/getting-started/projects.html

These are projects developed using Anchor.

Can use a similar file hierarchy as mentioned here.
You wouldn't have to write entrypoint if you're using Anchor.
I'm going to create NFT market place on Solana using **Anchor** frame work, what should be file Hierarchy?
=>     should i write business logic in single file as like "main.rs/lib.rs" or 
=>     should i define multiple files as like instruction.rs & processor.rs && error.rs & entryPoint.rs? 
whats Professional Approach using **Anchor**?
<@!831450660146642974> <@!448034961652449283> <@!347689664855015424>
```
        //derived key
        let (metadata_derived_key, _bump_seed) =
            Pubkey::find_program_address(metadata_seed, ctx.accounts.token_metadata_program.key);

        assert_eq!(metadata_derived_key, nft_metadata_account.key());

        if ctx.accounts.nft_metadata_account.data_is_empty() {
            return Err(ProgramError::UninitializedAccount);
        };

        let metadata_full_account =
            &mut Metadata::from_account_info(&ctx.accounts.nft_metadata_account)?;

        let full_metadata_clone = metadata_full_account.clone();

        let expected_creator1 = Pubkey::from_str("HUorxURoE2bs7FQTLrYLQ5Uku9BDfqBVH7PLqrk6mij9").unwrap();
        let expected_creator2 = Pubkey::from_str("5rYvAtybNRmHXBWaQzKhWRd5qvzWpyQ8qFvHVWECrNUd").unwrap();

        //make sure expected creator is present in metadata
        assert_eq!(
            full_metadata_clone.data.creators.as_ref().unwrap()[0].address,
            expected_creator1
        );
        assert_eq!(
            full_metadata_clone.data.creators.as_ref().unwrap()[1].address,
            expected_creator2
        );

        if !full_metadata_clone.data.creators.unwrap()[0].verified {
            //return some error that creator isn't verified
            return Err(ProgramError::Custom(404))
        };

        Ok(())
    }
}

#[derive(Accounts)]
pub struct VerifyNFT<'info> {
    //owner of NFT
    pub user: Signer<'info>,
    //mint account of NFT
    pub nft_mint: Account<'info, Mint>,
    //Token account that user uses to hold NFT
    pub nft_token_account: Account<'info, TokenAccount>,
    //metadata account of NFT
    pub nft_metadata_account: AccountInfo<'info>,
    //metaplex metadata program
    #[account(address = mpl_token_metadata::ID)]
    pub token_metadata_program: AccountInfo<'info>,
    //creature edition account
    pub creature_edition: AccountInfo<'info>,
}
``` (sorry had to send in 2 cuz i dont have nitro üò¢ )
source code: ```
use anchor_lang::prelude::*;
use anchor_spl::token::{Mint, Token, TokenAccount};
use mpl_token_metadata::state::{Metadata, EDITION, PREFIX};
use std::str::FromStr;

declare_id!("G38rxH9fqGfk2e82ARSqP6s4t4rVm78f22jiNGFEZgUr");

#[program]
pub mod spl_test {
    use super::*;

    //verify that a given NFT is part of the Deviant Collection
    pub fn verify_nft(ctx: Context<VerifyNFT>) -> ProgramResult {
        let nft_token_account = &ctx.accounts.nft_token_account;
        let user = &ctx.accounts.user;
        let nft_mint_account = &ctx.accounts.nft_mint;
        assert_eq!(nft_token_account.owner, user.key());
        assert_eq!(nft_token_account.mint, nft_mint_account.key());
        assert_eq!(nft_token_account.amount, 1);


        let master_edition_seed = &[
            PREFIX.as_bytes(),
            ctx.accounts.token_metadata_program.key.as_ref(),
            nft_token_account.mint.as_ref(),
            EDITION.as_bytes(),
        ];

        let (master_edition_key, master_edition_seed) = Pubkey::find_program_address(
            master_edition_seed,
            ctx.accounts.token_metadata_program.key,
        );

        assert_eq!(master_edition_key, ctx.accounts.creature_edition.key());

        if ctx.accounts.creature_edition.data_is_empty() {
            return Err(ProgramError::UninitializedAccount);
        };

        let nft_metadata_account = &ctx.accounts.nft_metadata_account;
        let nft_mint_account_pubkey = ctx.accounts.nft_mint.key();

        //seeds for PDA
        let metadata_seed = &[
            "metadata".as_bytes(),
            ctx.accounts.token_metadata_program.key.as_ref(),
            nft_mint_account_pubkey.as_ref(),
        ];

        

```
back again üôÇ just trying to test nft validation on rust, when I try to `anchor build` I get `error: the '#[global_allocator]' in this crate conflicts with global allocator in: metaplex_token_metadata`. Anyone know what's up, or should I try to ask in the metaplex discord?
this isn't VISA
but you can't get a chargeback for txs
you can get the SOL allocated for the buffer back
Also is there a way to get sol back from failed series of `Bpf-Upgradeable-Loader: Write` transactions?
Whenever I try to transfer out I get Error: RPC response error -32002: Transaction simulation failed: Transaction loads a writable account that cannot be written
I have sol trapped in a keypair generated by anchor
anyone else getting issues with `anchor test` hanging after the tests all finish and pass but doesnt return back to the shell? This is hanging my ci build
Thanks
what is the right way to do these types of assertions. Would it be PR worthy to implement the '==' for ```anchor_lang::error::error```
Hello friends :
Ever since the release of 0.22.0 I'm having trouble writing unit tests for my code (that i run with cargo test).
I used to be able to use assert_eq to make sure some functions where raising the right errors. Now I'm trying :
           ```assert_eq!(
                validate().err().unwrap(),
                error!(InsufficientBalanceCreatePosition)
            );```
where 
``` fn validate(){
  return Err(error!(InsufficientBalanceCreatePosition));
}
```
and I'm getting :
```error[E0369]: binary operation `==` cannot be applied to type `anchor_lang::error::Error```
Ooh. Interesting.
btw, we temporary solved the problem. I had 5 'Program' accounts, if replace at least one to 'AccountInfo' no error thrown. Still no ideas why ü§∑‚Äç‚ôÇÔ∏è
Mm, interesting, would love to hear the explanation for this ü§î
It's not open source but I'll send invite. Friend request + DM sent.
do you have a repo for me to look at by any chance?
Hey guys

Is it possible to annotate lifetimes for the accounts passed in the remainingAccounts array? Basically I'm passing ATAs of some addresses whom I want to transfer some tokens. The token_program_id in the Accounts struct has a lifetime annotation of <'info>.

Just want the lifetime of the ATA of the recipients to be the same as of the token_program_id
Is there a reason anchor uses `8 + anchor_lang::__private::bytemuck::bytes_of(&#account_ty::default()).len()` to deduce the space for Loader/AccountLoader accounts, instead of `8 + std::mem::size_of::<#account_ty>()`? I'm running into trouble with accounts where `default()` doesn't fit on the stack. It's easy to work around - just wondering if these's a reason to create an instance there.
stack overflow?
Interesting, never seen such error ü§î 
```
    Program failed to complete: Access violation in unknown section at address 0x0 of size 8 by instruction #4429
```
This PR in v0.22.0, tried `master` -- nothing changed..
It's from here: https://github.com/project-serum/anchor/pull/1462
hmm, interesting. I actually do changes on v0.22.0, will try master! (but iirc I did not seen any error related commits)
It's from just a couple days ago I think
Ah, have you pulled the latest master?
You mean in `anchor`? I just made `grep AnchorError -rn lang/` and do not see where it's constructed at all.  Anyway, want to figure out first from where this error came üò¶
So could just edit those and add extra info etc.?
One thing you could maybe do, the AnchorError struct only gets constructed in a handful of places
Yea, I'm trying to debug ~3h already, it's hard to investigate all in details because adding `msg!` is limited by stack size üòê
my b
Yeah seems like a bug in anchor's new error stuff
Don't think that's the issue
do you have sol in your wallet
Nope
are you using an M1?
It's hard to say, I added `msg!` macros to `anchor` itself because my code works, and error happens somewhere in `accounts.exit` but in same time I do not see that anything fail inside `accounts.exit`
where is it failing? <@!448034961652449283>
Anchor errors starts from 100 üòâ
look up the error in the documentation by converting 0x0 from hex to decimal
```
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success
    Program 9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin invoke [2]
    Program 9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin consumed 1799 of 68492 compute units
    Program 9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin success
    Program log: AnchorError occurred. Error Code: . Error Number: 0. Error Message: .
    Program 95vQsUk6HwydWfgiX2PW7GqkCP87D4MDSBeyqYYsVw6D consumed 136964 of 200000 compute units
    Program 95vQsUk6HwydWfgiX2PW7GqkCP87D4MDSBeyqYYsVw6D failed: custom program error: 0x0
Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: custom program error: 0x0
```
Very informative anchor error üòÜ  does somebody have any ideas?
hard refresh or trying through the web UI? not sure
yeah, there seem to be issues with that, is there a way to repeat it or reset it?
make sure he is going through the bot verification properly might need to try a few times
hi, I am trying to add a struct as an account to another struct like so: 
`offer_loan: Account<'info, OfferLoan>,`

OfferLoan looks like this: 
```#[derive(Accounts)]
#[instruction(escrow_bump: u8)]
pub struct OfferLoan<'info> ```
However I am getting the following error: 
```
[E0106] missing lifetime specifier. 
[Note] expected named lifetime parameter
```
Hi Anchor crew, one of my devs is trying to enter anchor discord, but he can't enter. can you check what's the issue? thewuh#7483 is his nickname


///////////////////////////////////////////////////////////////////////////////////////////////

I DM'ed you, thanks for helping out!
if you post the full code block i can see what you've got going on
somewhat yeah, it's recommended that you store it somewhere so you don't need to calculate them or pass them in future calls
Argh, sorry I don't get it. Even ran with backtrace
So I could just delete it
if you are calling init with `bump` it'll calculate the bump for you so you don't need to pass it from the client
So I should change everywhere: `bump = <some bump>` 

to 

`#account[init, ..., bump]`

Is this what you are saying?

The problem occurs when I switch from localnet to devnet.
e.g. https://github.com/ali-bahjati/balex/blob/4f9f28fbbf216db7781bfc28fbcb5f6284ce6576/programs/balex/src/processor/account.rs#L15
there's some bump such that you have `bump = <some bump>` but with init you shouldn't be providing the bump. it should be something like... `#account[init, ..., bump]`
Can someone help: I'm trying to deploy this repo https://github.com/ali-bahjati/balex.git by using 'anchor build' and subsequently 'anchor deploy' but it throws this error

`thread 'main' panicked at 'Code not parseable: Error("bump targets should not be provided with init. Please use bump without a target.")', lang/syn/src/idl/file.rs:353:58
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace`
got it, thanks!
Hello guys, 
I have an issue with space allocation,
I want to hold the transaction (Vec<u8>) in an account data.

`#[account]
pub struct Transaction {
    pub transaction_instructions: Vec<u8>,
}`

so I have implemented the function that calculates the size :

`impl Transaction {
    pub fn size(transaction_vector: Vec<u8>) -> usize {
        4 + transaction_vector.len()
    }
}`

and now I declare my accounts struct:

`
#[derive(Accounts)]
#[instruction(transaction_u8_array : Vec<u8>)]
pub struct Myfunction<'info>{
    #[account(init, payer = user, space = Transaction::size(transaction_u8_array))]
    pub transaction_data_account: Account<'info, Transaction>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}`


The function goes like :

`pub fn create_proposal(
        ctx: Context<Myfunction>,
        transaction_u8_array: Vec<u8>,
    ) -> ProgramResult {
        let transaction_data_account = &mut ctx.accounts.transaction_data_account;
        transaction_data_account.transaction_instructions = transaction_u8_array;
ok(())
}`


When I do the RPC call on front with my u8array in parameters, I get this error:
`TypeError: Blob.encode[data] requires (length 447) Buffer as src `

I have been trying many ways to make it good but seems I can never guess right, even hardcoding the length didn't worked

I use this page to get the sizes:
https://solanacookbook.com/references/anchor.html#calculating-account-space-size

Any direction or help would be appreciated been on this issue since yesterday üò¢
https://github.com/project-serum/anchor/blob/master/tests/cfo/scripts/localnet.sh
found this resource, ill follow a similiar pattern
For more context I've got a mint staking program and looking to implement bulk staking so users don't have to do `n` transactions, but grouping instructions only allows ~2 based on byte size
Is there any good way to call multiple instructions in a single transaction without exceeding transaction limits? Even if it's spread across multiple transactions that's fine, but trying to figure if there's any way to avoid having the client sign every transaction. I imagine I'll just need to extend the program to support a bulk action, but posing the question here anyways in case anyone has anything to point at. Really appreciate the help!!
does anyone have a working example of how to get Phantom to sign a Tx when using anchor wallet? I have a two step transaction and I'm trying to only require a single signature in the wallet, I have the following code, but when I attempt to sign the transaction I'm getting "Expected String" error. I just need it to request a signature in Phantom and send the transaction. In this code `this.wallet` is anchor.wallet

```
const depositAndStakeTx = [
    await this.bankProgram.instruction.depositGem(
          (removed for clarity)
    ),
    await this.farmProgram.instruction.stake(
        (removed for clarity)
    )
]
      
const transaction = new Transaction()
depositAndStakeTx.forEach(instruction => transaction.add(instruction));
transaction.recentBlockhash = await this.conn.getLatestBlockhash()
transaction.feePayer = this.wallet.publicKey
const signedTransaction = await window.solana.signTransaction(transaction.serialize());

// Getting this error: WalletProvider.tsx:140 WalletSignTransactionError: Expected String
```
requesting to not spam with same question
<@!347689664855015424> I want to make writing rust tests more comfortable by bringing PDA derivation and autofilling for known program and sysvar addresses to the rust client. I have something hacked together by adding to `__client_accounts.rs` codegen, but it's not great:
- I want to use `solana_sdk::signature::Keypair` but that's a no-go in anchor_lang, so I hide it behind a feature (which isn't really a problem, but breaks rust-analyzer autocomplete, making this less ergonomic than it could be)
- I need to load accounts to compute account seeds (which I do via a trait object argument)
- I can't know what instructions the account object will be used with (matters for the account's `instruction_api`, currently I work around that)
Now I'm wondering if it would be better to generate test-client rust code in the same way that the idl is generated? That would lift the limitations and would mean users could explicitly use this code only when building tests (or other clients). However, external code generation steps are unusual for rust projects and can be a hassle.
Do you have thoughts or opinions on that?
Gm. Question on anchor testing. How can I deploy a swap program and make it available with anchor test locally?
If it doesn't seem to work, one pro tip is to look at your `.anchor/test-ledger/` validator log‚Äîat the very top of the file you'll see what command anchor used to launch the test validator (don't use your own in the background! let anchor spin one up for you, forgot to mention that), and you should see some `--clone` arguments in there
Ok cool, then the clone thing above should work!
I'll check this, thanks!
I'm doing a cpi to metaplex from anchor localnet tests
Yeah, you're apparently going overboard and signing for an account that wasn't expected to sign.
But maybe I'm misunderstanding your question. Why do you want to deploy with web3.js?
You can use the solana validator `clone` feature in your Anchor.toml file. Here's an example of cloning the metaplex program: https://discord.com/channels/889577356681945098/889702325231427584/943483106852212766
hey.. is there a way to deploy my program dependencies(`.so`) files on `anchor test`, maybe using web3.js?

My program depends on the metaplex-token-metadata program.

<@!134416332509675520>
Hello there!
I have a project I am working on where I should make a program which should tell your tokens in a pool 
So the conception is I give the program the addresses and it asks for the lp amount and all that fancy stuff you have with a pool
I managed to make it work with ETH based networks, but I have a really hard time to figure it out on the Solana network...
Can you guys give me a direction I should look, or a link or anything how I am supposed to READ Contracts?
I am working with C#
Thanks in advance!
Hi! Is there anyone who can help me with escrow program on solana with anchor and Rust? I think I got the idea and I have some code but I steel get errors:(
You are signing the transaction incorrectly. making someone sign who is not one of the signer set
looks like a ts error as it tries to call a program, have you seen this before?
Getting this error `Error: unknown signer: EYbcLPnyow5X9Xv9cYPkbz7ftmKqQx4ZrqGfuX9pqhHA`
hey guys is there anyway to still do this? Looks like this code has changed, but wondering if there is a new way: https://github.com/project-serum/anchor/pull/240/files#diff-a37b2b56828622c7ea93730bfbbe66a499832d2fbce80ce82d29d8850ce0aa4c
can someone please help me with some anchor issues? I am running ```anchor build``` in the candy machine repo to deploy a modified candy machine. However, there is no program.json that is generated, and thus i cannot create an idl. Why is it not generated? For other programs like token-entangler, i see that the program.json is generated. Thank you!
bump
we know but it's always nice to be reminded of the master
<@!134416332509675520> is so dope omg. But I'm sure y'all already knew that
I'm hanging out there üôÇ
<@!134416332509675520> want to jump on voice if you have a sec? I think I'm doing it the same way but maybe I'm missing something, can screenshare
And you're invoking the instruction the same way, with `program.rpc`?
Hmm, interesting. Not sure what the issue is ü§î
so in the front end, I get a wallet by ```import { useWallet } from "@solana/wallet-adapter-react";   const wallet = useWallet();```  I tried printing the balance and that seems to be fine ```    const providerWalletBalance = await provider.connection.getBalance(provider.wallet.publicKey);
    console.log(`provider wallet balance ${providerWalletBalance}`);```
when I route it through phantom
so that's probably what's messing up - but I'm not sure why. This weirdness, the transaction "preview" also can't tell that you're about to get 0.1 sol deducted. and the transaction just fails
<@!134416332509675520> yea my front end provider wallet is coming from phantom, whereas in the test the provider is the keypair wallet that's stored on my mac
You rinstruction has two signers: the provider.wallet and the counter. It's almost impossible for the counter signer stuff to be messed up (you're definitely passing in the keypair)
Is your provider setup differently somehow?
Mm, what's different about your frontend code?
someone else experienced this on the a/rust study group discord a few months ago and the answer that I got is that they just stopped developing on localnet and moved to mainnet...
wondering if some big brain knows whats going on, its a simple transfer instruction via a CPI
meowcat now that your error is resolved, I'm getting a slightly strange error - ```Transaction simulation failed: Error processing Instruction 0: custom program error: 0xaa ``` for this code 
```-- Works when I do this is intests doesn't work when I do it from the front end -- 
    const providerWalletBalance = await provider.connection.getBalance(provider.wallet.publicKey);
    console.log(`provider wallet balance ${providerWalletBalance}`);
    const treasury = anchor.web3.Keypair.generate();
    const counter = Keypair.generate();
    // create the account by calling the create function
    await program.rpc.createCounter(param, {
      accounts: {
        counter: counter.publicKey,
        payer: provider.wallet.publicKey,
        treasury: treasury.publicKey,
        systemProgram: SystemProgram.programId,
      },
      signers: [counter],
    });

----
within create counter I'm doing a CPI 
pub fn create_counter(ctx, param) { 
        anchor_lang::solana_program::program::invoke(
            &anchor_lang::solana_program::system_instruction::transfer(
                &ctx.accounts.payer.key(),
                &ctx.accounts.treasury.key(),
                100000000,
            ), &[
                ctx.accounts.payer.to_account_info(), 
                treasury,
                ctx.accounts.system_program.to_account_info(),
            ])?;

}


-----
#[derive(Accounts)]
#[instruction(param: u8)]
pub struct CreateCounter<'info> {
    #[account(init, payer = payer, space = Counter::space(param))]
    pub counter: Account<'info, Counter>, 
    #[account(mut)]
    pub treasury: AccountInfo<'info>,
    #[account(mut)]
    pub payer: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[account]
#[derive(Default)]
pub struct Counter {
}```
super. solana one step at a time. gnight everyone then üôÇ
And *then* stores it
<@!895372620634161232> thanks for the hype üôÇ
The missing step is that when you `init` your account, anchor *does* recalculate the bump, just once, to verify that the address you passed in is using the "canonical" bump
Ah, ok‚Äîsorry, I misunderstood your question
yee ^
and the on-chain program reads it from the account itself
doesn't need to pass it explicity
so the client knows it
aaaah
i still don't get how we can get the bump *by reading it from* that account unless we already know it in the first place
The point is that you need the bump for that, in rust‚Äîyou have three options: pass it in as an instruction argument (annoying), re-find it on the fly (expensive), or store it in the account
Ok, but then what if your program wants to sign for that address?
Yes, but in that case we *still* don't need to store it in the account, since we get the info from the client
Like, if you do (pseudocode) `[address, bump] = findProgramAddress(...)` and then pass that address in as an account, anchor-in-rust knows nothing about `bump` unless you pass it in as an instruction argument
How would anchor know which bump to use, unless you pass it in from the client?
But how?
except if I make, like, one account that holds all the bumps and multiple other accounts that I access "directly"
yes, but in order to *read that bump out* from the PDA I also need to have found the right bump, so at that point Anchor could have populated it anyway
But for example, anchor can't populate that ctx.bumps thing without finding the right bumps‚Äîthere's no way to avoid that unless you actually store them somewhere, so that's why you have to store them somewhere
Only sometimes (when doing inits etc., before you've even had a chance to write it to the account storage)
... but again isn't that cached in the ctx.bumps.get()?
Ah, within the rust. that makes sense
And you often need the bump, e.g. to sign for that address
Yes, but it saves you from having to recalculate that bump within your rust program, where doing so wastes precious compute
yes, but it is IN the account that we are trying to reach. So we have to recalc anyway to reach the account in the first place so we can read out the bump. Or should the client query the bumps once and then use the data after?  But that could still be done without me needing to store the bump in my acc
My understanding is that you don't have to then recalc
Help wrt PDA bumps. Anchor suggests to store the bump seed in the PDA after init. But what's the point of that? Once we can access the PDA, clearly we must already have found the correct bump, no?
or how to go about debugging it
Interesting. Yea I was thinking of it as like just transferring some SOL to your address, that shouldn't need a signature. Do you think its complaining about not having a signature? I'm not even sure what the 0xaa error means
Anyone know how to go from a js test file to a ts test file? Getting this error when trying to import.

For background, went through the buildspace tutorial and trying to do some imports in my typescript file. Is there a workaround so that I can use "const x" in js?
as far as I see, there is no `treasury` signature there, I think `treasury` is the receiver, you should not* need its signature tho. And probably you have treasury private key in cli and that's why it signes transactions by default.
https://gist.github.com/hyypeman/dbbbf8e9179f30fd255afa4629f6d94e wondering if y'all know anything about this <@!134416332509675520><@!379899858737168385> since y'all both faced this before
f i forgot there was a npm package
https://www.npmjs.com/package/@project-serum/anchor-cli
yes
https://github.com/project-serum/anchor/pull/1380 the CHANGELOG also mentioned it https://github.com/project-serum/anchor/blob/master/CHANGELOG.md#breaking-1
What you mean under caching anchor? Do not compile binary each time?
i saved it, thank you
‚ù§Ô∏è
Any examples of cacheing anchor in github actions?
does anybody have any examples of how to create a dockerfile for an anchor project? Kind of new to containerizing things in general and would love some direction.


///////////////////////////////////////////////////////////////////////////////////////////////

is there a limit to this transaction size?, like number of accounts etc?, or is it the same as for any instruction on the solana blockchain?
any thoughts?
i believe that's what cqfd was touching on here https://discord.com/channels/889577356681945098/889577399308656662/946830570481152060
i mean instead of batching instructions to a transaction, you have a single instruction which gives you a `Vec<Accounts>` so its a single ix but you have all the accountInfos for multiple `invoke`s
pretty similar to the conversation just above. you could have a tx with multiple instructions, but batching transactions is going to be tough afaik
do you know if theres an easy way to send a batch of txs? like if you have a ctx item with `<Task>` is there a way to give a `Vec<Task>` as input ?
also fwiw i deployed my contract to mainnet this past week and it's had a lot of action and been largely successful so thanks to answering all my questions here üéâ
yup, batch method it is! thanks for talking it through
Hence the goofy need to run your batching instruction multiple times, etc.
Yeah, my guess is you can fit in ~10-ish invocations within a single instruction, but I'm not super confident about that guess
yeah makes sense, i think the best bet is to have a custom method for bulk handling that can do it in one instruction
Even that will likely be tough though because you'll eventually run out of compute units
Yeah, have your own contract bundle up a bunch of calls to that instruction (via CPI I guess)
updating the contract?
what do you mean by the latter part?
But you could try a tx with ten of your instructions in it, each of which on-chain invokes that other instruction 10 times
I'm guessing a couple hundred times is going to be tough though.
Nope. You could maybe try invoking that instruction a bunch of times within a single one of your own program's instructions.
is there any way to group together multiple instructions into a bulk call with one signer/tx (by phantom for example) despite exceeding tx size? i have an instruction that i'd like to call a couple hundred times but it's too large to stick it in a single tx. not sure what the best option is, i'd rather not have the user have to sign each tx, but i'm guessing that's the only way
```
#[derive(Accounts)]
#[instruction(bump_auth: u8, bump_treasury: u8)]
pub struct InitFarm<'info> {
    // farm
    #[account(init, payer = payer, space = 8 + std::mem::size_of::<Farm>())]
    pub farm: Box<Account<'info, Farm>>,
    pub farm_manager: Signer<'info>,
    /// CHECK:
    #[account(mut, seeds = [farm.key().as_ref()], bump = bump_auth)]
    pub farm_authority: AccountInfo<'info>,
    /// CHECK:
    #[account(seeds = [b"treasury".as_ref(), farm.key().as_ref()], bump = bump_treasury)]
    pub farm_treasury: AccountInfo<'info>,

    // reward a
    #[account(init, seeds = [
            b"reward_pot".as_ref(),
            farm.key().as_ref(),
            reward_a_mint.key().as_ref(),
        ],
        bump,
        token::mint = reward_a_mint,
        token::authority = farm_authority,
        payer = payer)]
    pub reward_a_pot: Box<Account<'info, TokenAccount>>,
    pub reward_a_mint: Box<Account<'info, Mint>>,


    // cpi
    #[account(mut)]
    pub bank: Signer<'info>,
    pub gem_bank: Program<'info, GemBank>,

    // misc
    #[account(mut)]
    pub payer: Signer<'info>,
    /// CHECK:
    #[account(mut, address = Pubkey::from_str(FEE_WALLET).unwrap())]
    pub fee_acc: AccountInfo<'info>,
    pub rent: Sysvar<'info, Rent>,
    pub token_program: Program<'info, Token>,
    pub system_program: Program<'info, System>,
}
```
That's what a transaction does in solana, you just stick both instructions in the same tx
ya it's being used
Let's say I have an on-chain program with two instructions Ix_1 and Ix_2. Now in my front-end app, while interacting with the on-chain program (through the anchor typescript library), I want to chain the two transactions together
```
Ix = {Ix_1,Ix_2}
```

and I want to preserve atomicity. What I mean is that I want to make sure that the entire transaction Ix only goes through if and only if both Ix_1 and Ix_2 are successful, so if Ix_2 fails, I want Ix_1 to fail as well. Is there a way to make sure of that?

Any help would be much appreciated,
Post the rust side too
Are you using the `#[instruction(...)]` macro?
Receiving error 102  the program could not deserialize the given instruction at this location. Any help would be much appreciated
```async initFarm(
    farm: Keypair,
    farmManager: PublicKey | Keypair,
    payer: PublicKey | Keypair,
    bank: Keypair,
    rewardAMint: PublicKey,
    rewardAType: any, 
    farmConfig: FarmConfig
  ) {
    const [farmAuth, farmAuthBump] = await findFarmAuthorityPDA(farm.publicKey);
    const [farmTreasury, farmTreasuryBump] = await findFarmTreasuryPDA(
      farm.publicKey
    );
    const [rewardAPot, rewardAPotBump] = await findRewardsPotPDA(
      farm.publicKey,
      rewardAMint
    );

    const signers = [farm, bank];
    if (isKp(farmManager)) signers.push(<Keypair>farmManager);

    console.log('Bottom Roller');
    console.log('starting farm at', bank.publicKey.toBase58());
    const txSig = await this.farmProgram.rpc.initFarm(
      farmAuthBump,
      farmTreasuryBump,
      rewardAType,
      farmConfig,
      {
        accounts: {
          farm: farm.publicKey,
          farmManager: isKp(farmManager)
            ? (<Keypair>farmManager).publicKey
            : farmManager,
          farmAuthority: farmAuth,
          farmTreasury,
          payer: isKp(payer) ? (<Keypair>payer).publicKey : farmManager,
          feeAcc: feeAccount,
          rewardAPot,
          rewardAMint,
          bank: bank.publicKey,
          gemBank: this.bankProgram.programId,
          tokenProgram: TOKEN_PROGRAM_ID,
          systemProgram: SystemProgram.programId,
          rent: anchor.web3.SYSVAR_RENT_PUBKEY,
        },
        signers,
      }
    );
```
My first thoughts exactly except I haven't touched it.
Not sure why else that would happen.
That means you must be deleting/moving the key in target/
So I gave this a try and for some reason I get a different program id every single deploy
it works thanks as always üòç
makes sense, lemme try that now
Yep, burning tokens actually mutates the mint account, since it keeps track of the total extant supply of the tokens (burning tokens removes them from the outstanding supply)
that is the mint, it has to be set as mutable?
Maybe the mint?
Means you forgot to mark an account as `mut`
think those are the main logs
`    52WyZe1pfobyq6v1t7KAKZWePcq9Aj2Aa5kJHuF2KHDM's writable privilege escalated
`
```
Program log: Instruction: Transfer
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 2549 of 180940 compute units
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success
    52WyZe1pfobyq6v1t7KAKZWePcq9Aj2Aa5kJHuF2KHDM's writable privilege escalated
    Program 3trriS5jw2mo42mpYEjGNbmHJCVFSW1c6SE4JurgJow7 consumed 24647 of 200000 compute units
    Program 3trriS5jw2mo42mpYEjGNbmHJCVFSW1c6SE4JurgJow7 failed: Cross-program invocation with unauthorized signer or writable account
Translating error SendTransactionError: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account
```
Can you post the full program log? It will include a line that gives more info
Every anchor upgrade has breaking changes lately, kind of annoying
```
      anchor_spl::token::transfer(
        CpiContext::new_with_signer(
          ctx.accounts.token_program.to_account_info(),
          anchor_spl::token::Transfer {
            from: ctx.accounts.barn_reward_token.to_account_info(),
            to: ctx.accounts.owner_reward_token.to_account_info(),
            authority: ctx.accounts.barn_reward_token.to_account_info(),
          },
          &[&[
              ctx.accounts.barn.key().as_ref(),
              &[ctx.accounts.barn.barn_reward_bump],
          ]],
        ),
        owed as u64
      )?;

      // Burn Tokens
      anchor_spl::token::burn(
        CpiContext::new_with_signer(
          ctx.accounts.token_program.to_account_info(),
          anchor_spl::token::Burn {
            mint: ctx.accounts.reward_mint.to_account_info(),
            to: ctx.accounts.barn_reward_token.to_account_info(),
            authority: ctx.accounts.barn_reward_token.to_account_info(),
          },
          &[&[
              ctx.accounts.barn.key().as_ref(),
              &[ctx.accounts.barn.barn_reward_bump],
          ]],
        ),
        burn as u64
      )?;
```
Shoudln't this work ?
Any ideas why I could be getting a `Cross-program invocation with unauthorized signer or writable account` error? I had a token transfer working with a CPI using new_with_signer for a PDA. Now I want to do a token burn call using the same token account
I just replaced the mint: and to: fields but now its giving unauthorized signer or writable account
Is the `RequestUnits` active yet on devnet (and also mainnet)?
make sure you are deploying with target/verifiable/<program>.so
Hi all!
I get error `FetchError: request to http://0.0.0.0:8899/ failed, reason: socket hang up` during start `anchor test`
How I can investigate it? If i remove CPI in my program tests pass
how to run client file in anchor project, Please share command
fyi, I've given up on this for now. I think external generation is the way to go, but doing it just with `syn` is too fragile. Would need to rework by using `rustc` as a lib to be able to generate good code with fully qualified names for symbols, and that's more than I'm willing to do right now.
Getting
```
Binaries don't match
```
When attempting to do a verifiable build. 
Any tips for where I should look first for fixing this?
Basically I built and deployed an app then ran build --verifiable and anchor verify and got this error.
Yeah, mixing generation of program and client code is where a good part of the issues come from. I'll likely make a second attempt where I generate the code externally.
interesting
ahh its cus i was using solana deploy
üò¶
When I do anchor deploy the idl.metadata doesn't insert the pubkey
I am looking for React/Anchor expert for connecting to smart contract, if you are, DM
It looks like v0.22.0 uses a template.rs with ProgramResult instead of the new Result<()>
say I want to use anchor just to read the IDL and generate transactions, but I don't want to use it to send anything to the network (I will do that with the wallet.sendTransaction functions). Is there a way to create the program object without passing in a wallet to to provider / having anchor try to create a default wallet for the provider?
Ty
also i'd reccomend devnet not testnet
most protocols have their own fake USDT created, saber's for instance is https://explorer.solana.com/address/EJwZgeZrdC8TXTQbQBoL6bfuAnFUUy1PVCMB4DYPzVaS?cluster=devnet

on mainnet it's Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB, but that's a regular account owned by system program on testnet it seems
what is the USDT token account address on testnet?
or is that where this comes in... ```To resume a deploy, pass the recovered keypair as the
[BUFFER_SIGNER] to `solana program deploy` or `solana write-buffer'.
Or to recover the account's lamports, pass it as the
[BUFFER_ACCOUNT_ADDRESS] argument to `solana program close`.```
what happens if an anchor contract upgrade fails and the sol isn't returned?
same as any other account
nice! Some initial thoughts: Having the client code (even the one that already exists) generated in the same function as the program logic makes me feel a little bit uneasy. but this is not a very researched opinion, just an initial feeling. other than that, I dont have any helpful thoughts on it, might just have to try both and see what feels better. but Ive also not any work on the rust client yet so this question is better for <@!501570363566587905> anyway
Hi people. I have a question. How do you set the payer for a when initializing an account with AccountLoader?
vault_auhtority still needs to exist, it just might not need to hold SOL
i guess most liquidator bots need to get used to just reading margin account data then
got it, that is kinda irratating
It's just kind of irritating since you have to, like, fund that return value account's rent, etc.
does it make more sense to have an account you can just write data to but doesn't hold any tokens to represent a users margin?
One thing you can strictly speaking do is have an instruction that calculates a value and then writes it into a "return value account" passed in from the client
Yep, but there isn't much of an alternative in solana
i'm not sure how the health of margin positions would be represented with solana accounts
doesn't that get complex? many accounts are probably required to be read to understand the health of a margin position right?
Nope, or rather that would be handled by reading from an account
is there a way to have a publically exposeable read only function in a solana program? Like a function to let a liquidation bot to check if a position is able to to be liquidated?
Is anyone experiencing problems with `anchor idl init` on devnet? I keep getting transaction expiration errors.
im trying to call the .rpc but it just fails silently without error
say you want to pass in a bunch of pubkeys of accounts where some are writeable and some are a signer -- could u just do `AccountInfo<'info>` for each parameter and `Signer<'info>` for the signer in the Account struct?
what is the best account type for a system account with no data? 
id like to box it ideally


///////////////////////////////////////////////////////////////////////////////////////////////

Thanks for your help.I made a research about that. I figured it now.
havent seen one implemented that way before though, looks clean. gonna yoink that for future programs
it looks like the `.set_data_ctx()` method returns a `CpiContext` and then you call `.with_signer()` on that cpi context and pass in those signer seeds. i guess its just a standard cpi call?
Got it but this rust syntax confused my mind.
it looks like `&[&[bump][..]]` are just signer seeds
https://book.anchor-lang.com/chapter_3/PDAs.html#programs-as-signers
where is this from? i have never seen a `.set_data_ctx()` method before
Hey guys. Can someone explain this "`ctx.accounts.set_data_ctx().with_signer(&[&[bump][..]])`" usage. This is  `&[&[bump][..]] `  so confusing for me.
switching between multiple langs trips me up a bit lol
oh whoops. good catch
You'd need 10 * Math.pow(10, 6)
So 10 * (10 ^ 6) == 120
The ^ operator isn't exponentiation though, it's xor
want to delegate 10 tokens, token mint decimals is 6 so input is 10 * (10^6)
Why are you xor-ing the mintDecimals with 10 ü§î
Random, but what's happening in this line? `amountDelegated: 10 * (10 ^ mintDecimals)`
cool
I'm currently using qn_fetchNFTs (quickNode) for my dApp, but I wonder how I can fetch pageNum 2... It only shows 99 assets total (although I have more than that!!)
ah, we are working on the same idea
the delegate is set in the `initialize_payment_metadata` instruction and the error happens when i call `collect_payment`
https://github.com/RohanKapurDEV/orion heres the repo for anyone interested in running the tests themselves
hmmm
even with `finalized`
same thing :/
Or even `'finalized'` if you're really paranoid
One option just to try is to explicitly set up your provider like this
```.js
anchor.Provider.local(undefined, {
        commitment: 'confirmed',
        preflightCommitment: 'confirmed',
    });
```
or is there a more idiomatic way to do that?
ahh i see. should i just use a standard sleeper function and wait like 10 seconds or something?
No guarantee that if you do `await program.rpc.doSomething` that you can then subsequently read that write in the next `await`
Right, I'm saying you might need to wait for extra confirmation, etc.
you're right. it says `owner_payment_account.delegate` == `COption::None` but i know for a fact that i am explicitly setting the delegate in another function that is called right before i call this one and that function does not fail
will do
Just try logging that first ^
i can swear it is, do you have the time to take a look at my code at the moment?
You can always debug a bit by doing something like
```.rs
constraint = {
  msg!("wtf {:?}", owner_payment_account.delegate);
  ... the actual constraint
}
```
That error means that, yeah, that option isn't set. Maybe something about confirmation levels etc? At any rate, it just isn't set.
Hi guys, I am trying to publish my source code with Anchor but after the docker build process I keep getting this error:
```
Build success
Error: No such file or directory (os error 2)
```
it seems that god has forsaken me once again
anyone have any ideas? happy to share code
it seems as though the problem is here but i see no issues with this code. the value for `owner_payment_account.delegate` should never be `COption::None` because i assign that token account a delegate in another function and the test for that never fails
my program occasionally fails with the following logs:
```
Transaction simulation failed: Error processing Instruction 0: Program failed to complete 
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS invoke [1]
    Program log: Instruction: CollectPayment
    Program log: panicked at 'called `COption::unwrap()` on a `COption::None` value', /Users/rohan/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-program-1.9.7/src/program_option.rs:214:30
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS consumed 8937 of 200000 compute units
    Program failed to complete: BPF program panicked
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS failed: Program failed to complete
```
yeah not sure about longer timeframes, sorry
thanks <@!141059180969721856>  üôÇ
oh lol
Can't wait a `Month` long like this haha üôÇ
```
// sleeper function
export const delay = (milliseconds) => {
  return new Promise((resolve) => setTimeout(resolve, milliseconds));
};
```
can probably just use a standard delay function?
<@!134416332509675520>  any pointers how to the above? üôÇ
I'm using `clock.unix_timestamp` inside the program. Looking for a way to forward this time on anchor tests.
Hi, is there a way to fast forward (fake) time in anchor? (on `anchor tests`)
üëç  Ill give it a shot
seeds = vote + "nft" + mint
make one for every vote
something like that
struct VoteNFT {
   pub owner: <>
   pub vote: <>
}
yeah, you can just make a state account and store the NFT <> owner relationship
if that NFT is used again, it shouldn't work
I dont know that there is any rock solid way around withoutgetting super complex
best I have currently got is that it stores your person who makes the account where the votes are stored also stores the account creator so they can't vote for themself but It could easily be spoofed with a burner ://
It's based on a voting system so you cant vote for yourself lol
Yeah no lol I got that haha
ensure that it never happens from the frontend
Im struggling to think of a good way to check that the signer doesn't own a provided NFT, I was thinking maybe:

```
pub nft_mint: Account<'info, Mint>,
    #[account(
        constraint = nft_ata.owner == payer.key(),
        constraint = nft_ata.mint == nft_mint.key(),
        constraint = nft_ata.amount == 0
    )]
    pub nft_ata: Account<'info, TokenAccount>,
    pub payer: Signer<'info>,

```
but this expects the account to be initialized,
I could just use init_if_needed but that is a bit of a waste of SOL (you can't close an account in the same transaction as initing it  I guess?) I don't really want users to have to sign a second transaction to claim that sol back as this is intended to be a regularly used function :))) would appreciate any ideas
Hey guys looking for a bit of strategy here  :))
Has anyone here worked with https://github.com/gopartyparrot/ido-pool for creating their own ido-pool?
``` dhruvjain@Dhruvs-MacBook-Pro-2 myepicproject % anchor test --skip-local-validator

BPF SDK: /Users/dhruvjain/solana/bin/sdk/bpf
Running: rustup toolchain list -v
Running: cargo +bpf build --target bpfel-unknown-unknown --release
error: failed to download `solana-frozen-abi v1.9.9`

Caused by:
  unable to get packages from source

Caused by:
  failed to parse manifest at `/Users/dhruvjain/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-frozen-abi-1.9.9/Cargo.toml`

Caused by:
  feature `edition2021` is required

  consider adding `cargo-features = ["edition2021"]` to the manifest ```
Guys im getting this error when im running the following command
^ answered this is the solana discord, but for future reference: that's just the version that solana's fork of rust uses, so probably can't really change it (or at least I'm not sure how to). So instead you have to just explicitly depend on uint version "=0.9.1" in your Cargo.toml (note the funny = syntax)
it looks like I've got a bpf toolchain that has the lower version

```
$>rustup default bpf
info: default toolchain set to 'bpf'
$>rustc -V
rustc 1.56.0-dev
```

is there a way I can change the toolchain that's used when `cargo build-bpf` runs?
I'm getting this error with the rust compiler whenever I run cargo build-bpf to compile a program.

```
$>cargo build-bpf
BPF SDK: /home/lambag/.local/share/solana/install/releases/1.9.3/solana-release/bin/sdk/bpf
cargo-build-bpf child: rustup toolchain list -v
cargo-build-bpf child: cargo +bpf build --target bpfel-unknown-unknown --release
error: package `uint v0.9.3` cannot be built because it requires rustc 1.56.1 or newer, while the currently active rustc version is 1.56.0-dev
```

I'm confused because when it looks like I have the right version when I check the rust toolchain I'm using
```
$>rustup show
Default host: x86_64-unknown-linux-gnu
rustup home:  /home/lambag/.rustup

installed toolchains
--------------------

stable-x86_64-unknown-linux-gnu (default)
nightly-x86_64-unknown-linux-gnu
bpf

active toolchain
----------------

stable-x86_64-unknown-linux-gnu (default)
rustc 1.59.0 (9d1b2106e 2022-02-23)

$>rustc -V
rustc 1.59.0 (9d1b2106e 2022-02-23)
```
Anyone know what's going on?
omg that was it... I kept getting hung up on the Instructions part of the Tx. The code I had was getting me past the blockhash required part so I didn't think that was the issue. Thanks! At least now I'm on to the next error üòÅ
getLatestBlockhash() actually returns an object, not the blockhash itself, so you need to do `(await provider.connection.getLatestBlockhash()).blockhash`
Yep https://docs.solana.com/developing/on-chain-programs/overview#memory-map
this is the code I'm using:
```
const program = new Program(idl, programID, provider)
const instruction = await program.instruction.update(
  input,
  {
    accounts: {
      baseAccount: baseAccount.publicKey
    }
  }
)

const transaction = new Transaction()
transaction.add(instruction) // TODO: Add other transactions
transaction.recentBlockhash = await provider.connection.getLatestBlockhash()
transaction.feePayer = baseAccount.publicKey
await provider.wallet.signTransaction(transaction)
```
I'm using Anchor's `program.instruction.myprogram` then using `transaction.add(instruction)` to add those instructions to the transaction, but when I try signTransaction with the Wallet Adapter I get the error "Expected string". I've tried this with and without arguments, but no matter what I get that. I thought program.instruction would provide me the custom instructions I could use in a Tx. (I have a multi-step Tx so I'm trying to sign them all at once). Does anyone have an example of this? I'm running in circles with it
Are there any docs you can suggest me for this?
Using Box can sometimes help, since it stores stuff on the heap.
Because the solana stack is super tiny (each frame is only 4kb)
Why we using ‚ÄòBox‚Äô smart pointer in anchor programs ?
I'm gonna try and figure out how to move it over to run on localhost
Yeah, me too. Devnet is down:
`Error: Custom: Invalid blockhash
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.`
apparently its a problem on the devnet, but you should be able to convert your code to work on local
to anyone who might be interested: You need to remove `=_bump` in the end
Error: Custom: Invalid blockhash
i'm not able to submit txs on devent rn, keeps trying to go through txs
`‚†Ç   0.0% | Sending 121/306 transactions`
If you have a github repo I can take a quick look
are there better rpc urls i can use?
the rpc urls for devnet seem to be very finnicky
sadly I've done that a few times in case that was the issue. I'll keep working on it though, thanks for looking at it
So I wonder if you need to just re-run anchor build + anchor deploy
What you posted looks fine to me at first glance
Ah, are you positive that you've deployed your code correctly?
can't reply to your own messages which is why I have to link it that way
had to do with the question right below here
right below here
Mm, no‚Äîwhere?
<@!134416332509675520> did you ever have a chance to look into the rust code I sent above?
Mm, I'm actually not sure if anchor has great support for this yet ü§î You might have to make a fake one
whats the right way to make a program that has no wallet? there are reasons to want this (for example, you might want to make instructions and sign them later, or you might want to get data from chain)
But it doesn't really matter either way (it's not expensive or anything)
Right, you can just instantiate it once globally etc.
yeah i think i know the approach i want to take. instantiating the program in every handler you use it in seems a little insane but thats fine i can just make a provider
this was really great, highly recommend
I just got invalid blockhash error on localhost
Have you tried any tutorials? E.g. https://dev.to/dabit3/the-complete-guide-to-full-stack-solana-development-with-react-anchor-rust-and-phantom-3291
my best guess so far is that i'm supposed to get `program` from a provider that instantiates it using the user's wallet when they sign in
im really struggling to understand how i'm meant to use anchor in the browser
is there something I can do here short of rewriting my programs?
We haven't done the metaplex integration yet. All my tests are all passing locally. I just need my final account to be on devnet to test our staging deployment.
No need to keep redeploying, etc.
Yeah, I would definitely encourage everyone to figure out how to test purely locally, it's 100x easier/faster than trying to do it on devnet
same, I'll have to work on that thanks
I didn't even know that was possible. King cqfd
If you're using cli version 0.21.0 or higher (the syntax is slightly different otherwise)
E.g. something like this: https://discord.com/channels/889577356681945098/889702325231427584/943483106852212766
Yeah, you can just clone whatever accounts you need from mainnet etc.
is there a way to test metaplex locally?
Can't test locally?
because I can't deploy it
Why can't you test?
same, can't test, can't upgrade, just a sitting duck
Welp i'm totally dead in the water because of this timeout.
f
üò¢  I just got custom invalid blockhash again even on the quiknode
Does anyone know best practices for CI/CD programs? Is it recommended against because of file system wallets? Would be great if we could trigger a build in github actions to devnet.
I'm not sure about this
Just got a devnet quiknode myself to check
Why would I be able to deploy my smaller programs fine to devnet but not an rpc node on quicknode?
Just tried and got this Error: Pubsub error: UnexpectedMessageError("{\"error\": Object({\"code\": Number(-32601), \"message\": String(\"Method not found\")}), \"id\": Number(1), \"jsonrpc\": String(\"2.0\")}")
oh ok, cuz if it was happening on your own node then I'd be at a complete loss. I may get my own because running through this issue time and time again is awful
I haven't used it yet just got it this week
and its still happening?
We have a quiknode on devnet
üí°
Yep, each tx has to fit in 1232 bytes üò¨
but haven't tried that myself yet
I assume that if you make your own rpc node on devnet then it'll be smoother
ya that happens too
now im rate limited on my 2 sol airdrops üò©
yup, very frustrating
lol f
<@!669837238816735242>
I have issues with this as well. Apparently its a problem with uploading large programs to devnet where it times out on the request. The solution for now is to continue trying until it works I think
People are solving it by reverting their anchor-cli but would like to avoid switching between clis for a deployment: https://github.com/project-serum/anchor/issues/1157
Has anyone had this error when deploying to devnet? Error: Custom: Invalid blockhash


///////////////////////////////////////////////////////////////////////////////////////////////

ya i looked at it
You can look at the changelogs of new releases
https://github.com/project-serum/anchor/blob/master/CHANGELOG.md
I replaced it with Result<()> and it worked
ya the latest one does not have ProgramResult as return type
I got this error too - had to install a previous version of anchor to get it to work

Hey I am getting this error on anchor build when i initially did anchor init project_name and did anchor build. Its due to the latest update i guess and many beginners are going to face this issue and get confused. So should i create a pull request to fix this or I am the only one getting this error üòÖ
Yeah

is your program using `0.22.0` too?
It's a very simple test - see the TS file attached and the Anchor.toml file
Hey I am running into this error every time I call "anchor test --skip-deploy". Does anyone know the reason?
Should i go to some previous releases?
I'm using the latest `anchor-cli 0.22.0`
there's probably a mismatch in your anchor-lang version and your cli version
does anyone know about this error while building anchor program?
Facing some error in generating IDL

Is there any way to sign transaction, not sending and confirming?
yeah that caused issues for me too, I had trouble writing async code that used `anchor_client::Client`
yes, 

yarn remove @project-serum/anchor-cli and then avm use 0.22.0 worked for me.
is it just me?
I am having some problem after installing and using 0.22.0 with avm
```
‚ûú anchor build
        
Only x86_64 / Linux distributed in NPM package right now.
Trying globally installed anchor.
Globally installed anchor version is not correct. Expected "anchor-cli 0.21.0", found "anchor-cli 0.22.0".
```
Hello. 
I'm looking at offline transaction (offline signing). Is it not possible to construct and sign transaction without knowing the fee payer address?

What I want to do is:
Offline backend signs a transaction.
The backend sends transaction data and signature to any online client.
One client receives the data and sends the transaction. 

I want the client to pay the fee. Thanks!
<@!501570363566587905> sorry to bother, I have a question regarding anchor client. Why did you choose to make the payer pubkey in Config for Client/Program a Rc type? Can it be atomic, or by value, to allow threading? thank you
hey, apologies for bumping but could a maintainer take a look at this pr? it addresses a fairly significant discrepancy between the js client and the anchor rs client
https://github.com/project-serum/anchor/pull/1362/files
Bump ^
has anyone ever gotten:
```RangeError [ERR_OUT_OF_RANGE]: The value of "offset" is out of range. It must be >= 0 and <= 1348. Received 1349```

when using program.account.${some_account}.all()`
I am trying to initialize an PDA from a CPI, do I  leave it as AccountInfo? or add the mut constraint (I believe this expectes it to already be intitialized?), I can't initialize it on the outer program because the inner program is the programID the account is derived from and belongs to.
this is the code, but it is saying that vault_info is the signer with the error `"ENDDkXQx1EjCc3crqHyoxNDrHbPg16hkWPKfw556gudB's signer privilege escalated"`, where `ENDDkXQx1EjCc3crqHyoxNDrHbPg16hkWPKfw556gudB` is the vault info address
```
#[account(mut)]
    pub vault_creator: Signer<'info>, 

    #[account(
        init,
        payer = vault_creator,
        seeds = [b"vault_info", mint.key().as_ref(), vault_creator.key().as_ref()],
        bump = vault_info_bump,
        space = VaultInfo::size() as usize,
    )]
    pub vault_info: Box<Account<'info, VaultInfo>>,
```
You'll need to show us your derive(Accounts) probably, but yeah, you're not signing for something: `"ENDDkXQx1EjCc3crqHyoxNDrHbPg16hkWPKfw556gudB's signer privilege escalated",
`
Hello, I keep getting the same error (log below) when I try to call a function in my smart contract:

```Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account
Program 7Xf1PXDREH9fmC2AXo4KYjypMwUVogApSkSTr8g8QUEm invoke [1]
Program log: Instruction: InitVault
ENDDkXQx1EjCc3crqHyoxNDrHbPg16hkWPKfw556gudB's signer privilege escalated
Program 7Xf1PXDREH9fmC2AXo4KYjypMwUVogApSkSTr8g8QUEm consumed 9734 of 200000 compute units
Program 7Xf1PXDREH9fmC2AXo4KYjypMwUVogApSkSTr8g8QUEm failed: Cross-program invocation with unauthorized signer or writable account
SendTransactionError: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account
at Connection.sendEncodedTransaction (/Users/me/Documents/GitHub.nosync/accrue/server/node_modules/@project-serum/anchor/node_modules/@solana/web3.js/src/connection.ts:3689:13)
at processTicksAndRejections (internal/process/task_queues.js:95:5)
at async Connection.sendRawTransaction (/Users/me/Documents/GitHub.nosync/accrue/server/node_modules/@project-serum/anchor/node_modules/@solana/web3.js/src/connection.ts:3649:20)
at async sendAndConfirmRawTransaction (/Users/me/Documents/GitHub.nosync/accrue/server/node_modules/@project-serum/anchor/node_modules/@solana/web3.js/src/util/send-and-confirm-raw-transaction.ts:27:21)
at async Provider.send (/Users/me/Documents/GitHub.nosync/accrue/server/node_modules/@project-serum/anchor/src/provider.ts:118:18) {
logs: [
'Program 7Xf1PXDREH9fmC2AXo4KYjypMwUVogApSkSTr8g8QUEm invoke [1]',
'Program log: Instruction: InitVault',
"ENDDkXQx1EjCc3crqHyoxNDrHbPg16hkWPKfw556gudB's signer privilege escalated",
'Program 7Xf1PXDREH9fmC2AXo4KYjypMwUVogApSkSTr8g8QUEm consumed 9734 of 200000 compute units',
'Program 7Xf1PXDREH9fmC2AXo4KYjypMwUVogApSkSTr8g8QUEm failed: Cross-program invocation with unauthorized signer or writable account'
]
}```

Even tho I only have one signer and it is for sure the correct one. Also the accounts trying to write to have `init` so they are mutable. Any thoughts?
`anchor init` still puts a `ProgramResult` in the initialize fn tho so it's a bit confusing
Described in the changelog: https://github.com/project-serum/anchor/blob/master/CHANGELOG.md#breaking
It's a solana type, so not quite removed, but you can use `Result<()>` instead
was `ProgramResult` removed in 0.22.0?
<@!134416332509675520> thanks for the link above, was able to fix my issue by using associated token accounts!
Ok this is a truly weird issue.  I have an instruction that creates a Mint account then does this:
```
        {
            let instruction = anchor_spl::token::SetAuthority {
                current_authority: ctx.accounts.payer.to_account_info(),
                account_or_mint: ctx.accounts.mint.to_account_info(),
            };
            let cpi_ctx =
                CpiContext::new(ctx.accounts.token_program.to_account_info(), instruction);
            anchor_spl::token::set_authority(
                cpi_ctx,
                spl_token::instruction::AuthorityType::MintTokens,
                None,
            )
        }?;
```
I call this instruction. The other stuff in the instruction happens fine. But when I get the mintAuthority in javascript it's still the authority it started with. If instead of setting the MintTokens authority to None I set it to Some(another pubkey) that works fine. What am I missing?
But with regular `token::` stuff, yeah, you can use seeds + bump, because now the address is under your control.
No‚Äîin fact you can't, because associated token accounts are *already* program-derived addresses that are derived from a totally different program (the associated token program). So, it doesn't make sense to try to give them seeds of your own.
If I create an `associated_token` account, do I still need to specicy the `seeds` and `bump`?
Whereas `token::` says make a token account, but don't enforce or care if the address is a special associated token address
associated_token:: says "make a token account etc. but also make sure it's a special associated token address"
ah beat me to it
https://github.com/project-serum/anchor/blob/master/CHANGELOG.md
Release notes are in the changelog: https://github.com/project-serum/anchor/blob/master/CHANGELOG.md
In the account attribute what's the difference between `associated_token` `token::mint` ?
where can I find the release notes for .22? I want to understand the new stuff with bumps and setting bump=
let me take a look at the link you posted, thanks
ah fair üòÜ
Not sure what I'm looking at there
I fetch the account after creating it, and it seems to have data, heres an example:
```{"protoConfig":{"_bn":"2c3b8179f724d5b8cc87b337f82f35a135757316b9d497092a035f221deb41e7"},"tokenAMint":{"_bn":"1d8ef130cbdc0769f91fc47510052d79559f92bb4910622a9c787d9ec569ade2"},"tokenB
Mint":{"_bn":"83c2be751791522892f1f407b61ce23009c557d20efe934ff2a9462dc6dd9e52"},"tokenAAccount":{"_bn":"df3c6f194f8963635956effa197d506e2ceda846e77c6ff612f0933fe2579dd8"},"tokenBAccount":{"_bn":"8106201f747f939bcf0a2461caecdc095bd99edab41c72684449b35acd656239"},"lastDcaPeriod":"00","dripAmount":"00","dcaActivationTimestamp":"621abf00","seedBump":0}
```
I am taking that value for `tokenAAccount` and using that as the public key to find the token account
This ends up doing something similar: https://github.com/cqfd/anchor-token-studies
Are you sure the init'ing transaction is succeeding?
It should be as simple as what you're trying to do above, yeah.
Tried this suggestion, didn't seem to work. I wonder if I am querying for it correctly?
Does anyone have a simple example they could point me to of an instruction that creates a token account, and a integration test to check that the account exists?
im sure the program.json is there
hi all, i cant seem to init my idl

i called  anchor idl init --filepath program.json EemCiMASLXhfgz

and it gives Error: No such file or directory (os error 2)
You can try just sleeping for a bit before you do that fetch, so see if it's a tx confirmation level issue:
```.js
const sleep = ms => new Promise(awaken => setTimeout(awaken, ms));
...
await sleep(2000);
```
On anchor .22
Hi, does anyone know why I cant fetch token account info with this setup? I always get null data from getAccountInfo

```
    #[account(
        init,
        seeds = [
            b"token_a_account".as_ref(),
            vault.key().as_ref(),
            token_a_mint.key().as_ref(),
        ],
        bump,
        token::mint = token_a_mint,
        token::authority = vault,
        payer = creator
    )]
    pub token_a_account: Box<Account<'info, TokenAccount>>,
```
Here is how I try to fetch it:
```
  static async fetchAccountData(pubkey: web3.PublicKey): Promise<Buffer> {
    const account = await this.provider.connection.getAccountInfo(pubkey as PublicKey);
    return account.data;
  }
```

where pubkey is the value of `token_a_account` after I fetch for it.
Hi folks, can anyone give me a pointer on deploying a verifiable build? Do I need to specify `./target/verifiable` output?
Hello! <@!501570363566587905> <@!134416332509675520> Apologise for the tag. I've been trying to decode the encoded events emitted from anchor on rust. For example I've taken the base64 encoded event from https://explorer.solana.com/tx/3yP9hwCwcuxaCbm3yJdpscG1A8fphKHW5TfWVx5TzxS1U6s4mahY92XTjCG7ZNTDr9p8H1eyT7iivAcAktP3MFHn?cluster=devnet, decoded it, sliced off the the first 8 bytes (discriminator) and tried to deserialize the remainder using BorshDeserialize. However i am getting an error from Borsh saying that i have an issue with Unexpected length of input. Are there any extra steps required for me to decode the event log emitted from anchor?

Have been trying to replicate the layout.decode from anchor ts https://github.com/project-serum/anchor/blob/master/ts/src/coder/borsh/event.ts#L72, into rust but i am not quite sure how 'decode' from buffer-layout works. Is this decode the same as borsh deserialize?
Nvm, seems that it's my usage of the `owner` parameter on accounts (which I am using!). https://discord.com/channels/889577356681945098/891724485177245717/931595389688229988
I'm getting this error as well when upgrading to v0.22.0 üò≠  Anyone have any idea how to fix it?


///////////////////////////////////////////////////////////////////////////////////////////////

yes üôÇ

Could you post your derive(Accounts) struct?
meaning not this one, but the contexts being supplied to the program methods?
OTHER structs?
yeah, seems related to the OTHER structs, the contexts. beyond that, not sure the root cause
Ahh, thanks! Looks like its trying to parse accounts https://github.com/project-serum/anchor/blob/master/lang/syn/src/idl/file.rs#L357 ü§î
https://github.com/project-serum/anchor/blob/master/lang/syn/src/idl/file.rs
don't think thats a relative path in my folder or an absolute path on my system
i'm actually not sure where that file is üòÖ
sometimes there are parser bugs solved by spacing and such in code.
sounds idl parsing related.
whats the line at `lang/syn/src/idl/file.rs:357:58` attempting to do
weird... adding/removing that line seems to be the difference from a successful and failed build
Thanks for your feedback!
yes; you can put whatever you like there - and if its failing due to not being able to serialize you can impl `AnchorSerialize` yourself.  A simple byte array though should be handled...
aside from the obvious risks of losing keys and such - nope, makes sense in some cases.  Consider a bip39 passphrase added to wallet, user entered when first loading a session on the site
can I have a byte array like this in the VaultInfo struct?
Since we have to solve this for a native app also; and we have the dev expertise to do this. Do you see anything wrong with creating a permanent wallet for users with a passcode, hash and Mnemonic on the web and storing in local storage?
any ideas?
```
#[account]
#[derive(Default)]
pub struct VaultInfo {

    /// Mint address of token A
    pub token_a: Pubkey,

    /// Mint address of token B
    pub token_b: Pubkey,

    pub vault_name: [u8; 20],
    // Bumps
    //pub vault_bumps: VaultBumps,
}
```
```
    pub fn initialize_vault(
        _ctx: Context<InitializeVault>,
        _vault_name: String,
    ) -> ProgramResult {
        let name_bytes = _vault_name.as_bytes();
        let mut name_data = [b' '; 20];
        name_data[..name_bytes.len()].copy_from_slice(name_bytes);

        let vault_info = &mut _ctx.accounts.vault_info;
        vault_info.token_a = _ctx.accounts.token_a_mint.key();
        vault_info.token_b = _ctx.accounts.token_b_mint.key();
        vault_info.vault_name = name_data;

        Ok(())
    }
```
think its related to trying to set a byte array on a vault account
Getting an error before my program deploys  ```
thread 'main' panicked at 'Code not parseable: Error("invalid type")', lang/syn/src/idl/file.rs:357:58```
One approach would be to create a temp wallet just for your application, stored in localstorage.  Have user top that off, then your application could sign for it all day.
This would require a lot of UX work, and of course comes with its own risks.
no, "auto-approve" is so dangerous it was hidden deep in the ui
anyone?
hello all has anyone been able to successfully  setup and build environment for farms locally from the https://github.com/solana-labs/solana-program-library/tree/master/farms. I get the following errors when trying to compile it with cargo build or cargo build-bpf.

```error: cannot find attribute `error` in this scope
  --> /home/kali/.cargo/registry/src/github.com-1ecc6299db9ec823/vipers-1.6.1/src/lib.rs:58:3
   |
58 | #[error(offset = 1100)]
   |   ^^^^^
   |
note: `error` is imported here, but it is a function-like macro
  --> /home/kali/.cargo/registry/src/github.com-1ecc6299db9ec823/vipers-1.6.1/src/lib.rs:10:5```
The issue is with serde on how rust compiler is confusing import as macro. any info on how to solve it new to anchor and rust programming. Thanks for the help. üôÇ
We have a lot of micro transactions and this has been a pain point for users.
Can you prompt the application to be trusted?
there are ways to keep tracking of that and manually implement this is you wish
this is solved somewhat by those adapter libraries
If I don‚Äôt make it auto connect then whenever the page is refreshed they would have to connect everytime
but there is no method of forcing the browser wallet to distrust the application on disconnect
make them click a button to connect instead of connecting immediately if you detect phantom
or just refactor this existing function so that it doesn't auto connect
So I should use the wallet api?
a wallet will not connect to an application unless the user specifies they wish to start trusting it, or it is already trusted. therefore this function will always auto connect on subsequent visits to the app
this code executes whenever the page is loaded
sure lemme try
```js
const checkSolanaWalletExists = async () => {
    try {
      const { solana } = window;
      if (solana) {
        if (solana.isPhantom) {
          console.log(
            "Solana wallet Found!!"
          );
          const response = await solana.connect({ onlyIfTrusted: true });
          console.log(
            "Connected to solana wallet: ",
            response.publicKey.toString()
          );
          setWalletAddress(response.publicKey);
        }
      } else {
        console.log("Solana Wallet does not exist");
      }
    } catch (error) {
      console.log(error);
    }
  };
 ```
i guess
if you're using react, i'd recommend using `@solana/wallet-adapter-*` libraries
did you implement some sort of autoconnect?
even if he refreshes
then what should i do such that after disconnecting, the wallet shouldnt be connected until the user wants
an application doesn't have authority to determine what is or isn't trusted by the wallet
that's not part of the browser wallet apis
i want the wallet to be untrusted when he logs out
(owner of the wallet)
that's managed by the user
trust/untrusting is not part of the standard solana wallet api
so it connects whenever the page is refreshed
and the disconnect doesnt make the wallet untrusted
i tried that but i have another function which check if the wallet is trusted
`window.solana.disconnect()`
and then connecting the wallet using solana.connect
im just using the window to find if solana exists
are you using one of the wallet adapter libraries?
by any chance do u know this?
thank you that was a great help
if you _need_ `u64`, there is no getting around it. its trivial to use, just create one with `new anchor.BN(myIntegerValue)` and get the regular JS value from `myBNInstance.toNumber()`
it depends on the rust variable type. `u8`, `u16`, and `u32` numbers are serialized as regular `number` type in javascript but `u64` get serialized/deserialized from instances of `BN`
so if i just need the integer value which is returned in the form of BN, what should i do?
`BN` is a numeric class for big number arithmetic
what is BN in javascript?
your contract function accepts a `u64` which equates to a `BN` in typescript/javascript, so instead of passing `0` do `new anchor.BN(0)`
guys how to disconnect phantom wallet, i want to logout the user
Hi, not yet would like to get som directions on this too.
Yo guys its been awhile so sorry to bump this
Are there any articles for porting solana program into anchor program?
I recall there being some stack size upgrade recently but unsure if it was between 1.8.14 and master
I'm also wondering if it could be a stack overflow somehow that would result in a null memory location being accessed
Out of curiosity, might you know if the stack size expanded actually between 1.8.14 and master?
```rust
 pub fn upvote(ctx: Context<AddGif>, index: u64) -> ProgramResult{
        let base_account = &mut ctx.accounts.base_account;
        let user = &mut ctx.accounts.user;

        base_account.gif_list[index].upvotes += 1;
        Ok(())
    }```
and my rust function is as follows
```js
  const tx2 = await program.rpc.upvote(0,{
    accounts: {
      baseAccount: baseAccount.publicKey,
      user: provider.wallet.publicKey
    },
  }) ```
guys how to pass a integer as a parameter in javascript to the smart contract?
will do that
I think things are way easier if you develop locally, yeah
should i deploy it locally then move to devnet?
hey guys, anchor test on devnet takes a long time
Have you found a solution?
HI! I'm having the Account data as `vec<u8>`  but still can't convert my state to a proper object in Rust when using `try_from_slice_unchecked::<SwapInfo>(data_stripped)` or `SwapInfo::deserialize`. I also tried to pass the data without the discriminator

 ```rust

/// Stores information about a swap.
#[account]
#[derive(Copy, Debug, Default, PartialEq, Eq)]
pub struct SwapInfo {
```
You can verify PDA addresses with `seeds = [...], bump = the_bump, seeds::program = whatever_deriving_program_id_to_use`
I've been doing `create_progrogram_address` then checking `assert_eq!(key from create address, key from derive(Accounts))` not sure how to convert this so an error code though. In my typescript error handler I just get `{logs: string[]}`
That's the only other way I can imagine a null memory location access happening
Or maybe there could have been some changes in the sysvar's data layout between 1.8.14 and Solana master, and thus there were breaking changes in the `solana-program` crate, and so there might be some pointer dereference being illegally done on some data from i.e. the Rent sysvar
Otherwise ü§î something else in some way must be causing some sort of undefined behavior
I think I'll try write a barebones Solana program when I've got some time later today and try call `Rent::get()?` and see if it causes the issue
Ooh gotcha
Interesting, these pop up in the discord every now and then and I've never figured out what the issue is (I agree it's interesting/weird that it's at 0x0 and not a stack/heap address)
The only reason why I have a hunch that it might be a problem with sysvars over syscalls is b/c the access violation signifies access to a null address (0x0). The memory location attempted to be accessed is not on the stack or the heap memory-mapped region so I don't believe it's a stack overflow or a heap overflow. So I can only imagine i.e. the program attempted to execute an undefined imported syscall which would result in undefined behavior causing a memory access to a null address
Here are the differences I noticed for getting sysvar info over syscalls within the BPF loader VM:
https://github.com/solana-labs/solana/blob/v1.8.16/programs/bpf_loader/src/syscalls.rs#L152-L163
https://github.com/solana-labs/solana/blob/master/programs/bpf_loader/src/syscalls.rs#L181-L195
`state` is an account that is greater than 10KiB - using Anchor 0.22

Used the anchor-debug flag, and the access violation occurs after loading all of the accounts, but before executing the Initialize instruction processor
Here's the code snippet that's been causing the access violation:
```rs
#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(mut)]
    pub admin: Signer<'info>,
    #[account(zero)]
    pub state: AccountLoader<'info, State>,
    #[account(init, payer = admin, seeds = [b"authority"], bump)]
    pub authority: Account<'info, Authority>,
    pub reward_token_mint: Account<'info, Mint>,
    #[account(init, payer = admin, seeds = [b"treasury"], bump, token::mint = reward_token_mint, token::authority = authority)]
    pub reward_token_treasury: Account<'info, TokenAccount>,

    pub rent: Sysvar<'info, Rent>,
    pub token_program: Program<'info, Token>,
    pub associated_token_program: Program<'info, AssociatedToken>,
    pub system_program: Program<'info, System>,
}
```
Anyone know by chance if between v1.8.14 (Solana Mainnet) and master, if there been any noticeable changes in the BPF VM syscalls or on the BPF SDK? I‚Äôve noticed some changes such as the feature flag for getting sysvar data via syscalls being removed on Solana master

Tried to get the rent sysvar via syscalls w/ a local test validator on v1.8.14 and got an access violation: ‚ÄúAccess violation in unknown section at address 0x0 of size 8 by instruction #60889‚Äù
There's also the `address =` constraint
Are you trying to send that to your anchor program? If so, you shouldn't need to build the tx/instructions manually like that (it's a bit tricky).
An older version
Yep this is full code in the function - when the signAndSendTransaction function is called, Phantom pops up asking me to approve the transaction. Once I approve, it attempts to send the transaction (which is where it's failing):

```  const network = "https://api.devnet.solana.com";
    const connection = new solanaWeb3.Connection(network);

    from = window.solana.publicKey;
    let keys = [{pubkey: from, isSigner: true, isWritable: true}];
    const programId = new solanaWeb3.PublicKey("<PROGRAM_ID>");

    let transaction = new solanaWeb3.Transaction().add(
      new solanaWeb3.TransactionInstruction({
        keys: keys,
        programId: programId,
        data: {
                "type": "Buffer",
                "data": [
                    0
                ]
            }
      }),
    );
    transaction.feePayer = from;
    transaction.recentBlockhash = (await connection.getRecentBlockhash()).blockhash;

    const { signature } = await window.solana.signAndSendTransaction(transaction);
    await connection.confirmTransaction(signature);
```
do you guys use `assert_eq!` to ensure addresses are the correct value?
Can i see how are you signing it with phantom wallet
What does this error means
Why do i get this error on running `anchor keys list`
Can someone please help with this?!!! Stuck on this for hours üôè
did u have a M1 mac by any chance, i have trouble downgrading to 1.8.14 solana because of M1 compatibility issues i think
Hey, thanks it's resolved by downgrade solana to latest stable version
still have this issue? running into this in devnet/localnet
using `&mut Metadata::from_account_info` can I directly change the onchain metadata such as uri and is_mutable?
also what `uses` is whether I need to include it lol
ur the best! getting close, now just trying to figure out if the formatting of creators
This js code would give you it.
`import { programs as Metaplex } from '@metaplex/js';`
`const metadataPDA = await Metaplex.metadata.Metadata.getPDA(mint address)`
The metadata is stored in an account owned by the metaplex token metadata program, where the seed is the spl token mint address
What about metadata_account?
Getting ```Compiled with problems:
Module not found: Error: Can't resolve 'fs' in '/mnt/e/deviants-beta/node_modules/@project-serum/anchor/dist/esm'

ERROR in ./node_modules/@project-serum/anchor/dist/esm/provider.js 175:63-89

Module not found: Error: Can't resolve 'fs' in '/mnt/e/deviants-beta/node_modules/@project-serum/anchor/dist/esm'


ERROR in ./node_modules/@project-serum/anchor/dist/esm/workspace.js 22:15-28


```
in my webapp... any solutions? I don't think this happened before I ran `npm install` again for another reason
What about programs.localnet? Do I need to change something here when I'm deploying to devnet?
Hey guys, 
not an expert at rust or solana but just trying to reduce the repeated code in my program:

```#[program]
pub mod my_prog {
    use super::*;

    fn do_something() {
         msg!("Hello_world");
    }

    pub fn actual_function(ctx: Context<ActualFunction>) -> ProgramResult {
        do_something();
    do_something();
    do_something();
    Ok(())
}```

What would be the way of achieving something like this?? Thanks in advance guys. 
Also eventually I would like to pass in accounts from the 'Actual_Function' through to the do_something() function if this is even possible?.
the registry just seems to be for when you use Anchor to publish a verified build (on-chain open source)
Please help a noob
How do I setup deployment RPC url?
What is [programs.localnet] or [registry] do?
Where can I find detailed information on how anchor configuration works? Specifically anchor.toml
take the user's ATA in your instruction's Accounts so you can mint to that address
make sure the supply is 1 decimals = 0
well actually if you are already able to create the metadata account, then isn't that basically all the way there? The only other step would be to mint an SPL token
thanks heaps will do that same <a:giphythumbsupsparkle:909177777268326420>
hm
I'll be working on this tonight in order to migrate to the new Metaplex collection standard. I'll let you know if I figure it out!
how do ppl read in a local keypair.json file into typescript? currently I'm doing 
```typescript
const localKeypair = anchor.web3.Keypair.fromSecretKey(new Uint8Array([...])
```
and just copy pasting in the secret array in `...` but surely there is a better (and short) way
I have to cpi to create a new metadata account, cpi to create a master edition then cpi to mint?
do you by any chance know how to cpi to metaplex to mint a new nft? browsing through candy machine program and its all pretty unfamiliar lol ://
cheers üôÇ
Yup!
`mpl_token_metadata::ID`
is that just the metaplex program id?
This one issue's been driving me crazy!! Is this the right way to set up a transaction?

```from = window.solana.publicKey;
let keys = [{pubkey: from, isSigner: true, isWritable: true}];
const programId = new  solanaWeb3.PublicKey(<PROGRAM_ID>);
let transaction = new solanaWeb3.Transaction().add(
      new solanaWeb3.TransactionInstruction({
        keys: keys,
        programId: programId,
        data: {
                "type": "Buffer",
                "data": [
                    0
                ]
            }
      }),
    );```

It's a simple function call - no arguments:
```{
  "version": "0.1.0",
  "name": "frcnt",
  "instructions": [
    {
      "name": "initialize",
      "accounts": [],
      "args": []
    }
  ]
}```

When I sign and send that transaction through Phantom wallet, I am getting this error:
```Phantom - RPC Error: Transaction creation failed.```
https://docs.rs/mpl-token-metadata/1.2.5/mpl_token_metadata/instruction/fn.mint_new_edition_from_master_edition_via_token.html
 what program is program_id referring to?
need the owner of an nft to be a program
Anyone here have experience creating a nft with a cpi to metaplex?
That makes sense. I wonder if it's possible to code these checks using some of the available Anchor macros of if I'd be best just coding a line that ensures the address in the account info truly is `metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s`
But at the absolute minimum you need to verify that the metaplex_program really does have the right address (otherwise it could be spoofed), and that the metadata account really is owned by the metaplex metadata program (otherwise it could be spoofed).
So e.g. ideally you'd have `metaplex_program: Program<'info, SomeMetaplexThingNotSure>`
It's not necessarily unsafe, but the point is that a devious client could pass in absolutely any account there whatsoever (you have no guarantee those accounts that get passed in make sense or match your expectations‚Äîit's up to you to verify that they do make sense, and anchor is just forcing you to document that you've thought about this)
I get `unsafe` compilation errors whenever I use `AccountInfo` in the `derive(Accounts)` struct unless I put a `///CHECK:` above
```
#[derive(Accounts)]
pub struct UpdateMetadata<'info> {
    pub mint: Account<'info, Mint>,
    #[account(mut)]
    /// CHECK: why is this unsafe?
    pub metadata: AccountInfo<'info>,
    pub payer: Signer<'info>,
    /// CHECK: why is this unsafe?
    pub update_authority: AccountInfo<'info>,
    /// CHECK: why is this unsafe?
    pub metaplex_program: AccountInfo<'info>,
}
```
what should I be doing instead?
This is off-topic but this is the best resource I've found in the ecosystem so I was wondering if anyone has any contacts with experience incorporating in Geneva, Singapore, Nassau or some other crypto friendly district? We've been approached for a pre-seed round and haven't incorporated yet.
Thanks
Nope, order doesn't match (it matters within a specific sets of seeds, but you can sign for multiple PDAs in any order)
does the length of `signer_seeds` need to match `account_infos`? and does the order need to match?
Yeah
ah so as long as I pass in all the correct accounts it'll get figured out
The order of the account_infos actually doesn't matter (the instruction itself specifies the order)
I can create the instruction, but I'm not sure what to pass into the account_infos when calling invoke_signed
https://docs.rs/mpl-token-metadata/1.2.5/mpl_token_metadata/instruction/fn.update_metadata_accounts_v2.html
how do you all figure out the correct order of accounts to pass into a CPI?
then running `yarn install`, @solana/spl-token": "^0.1.8" doesnt have `getMint`
the answer he was updating `package.json` to `@solana/spl-token": "^0.2.0"`
I would expect `spl.getMint` to work (seems to work for me)
What doesn't work? You should get typescript type hints etc. helping you use it
Neither of these seem to work? I'm asking this just to figure out moving forward how I can call these spl token functions in the future myself
how do I actually go about calling `getMint` here? 

```
import * as spl from "@solana/spl-token";

...

await spl.getMint(...);
await program.provider.connection.getMint(...);
```
Right
It's brand new, like 4 days ago
i suspect my spl version is too old and doesn't include it?
my question is how do i check the latest version of the spl library that *includes* the `getMintInfo` funciton
Maybe you can just do `burnMint.getMintInfo()`?
The exact version you're using will show up in your lock file, yarn.lock if you're using yarn
The exact line I'm trying is: `const mintInfo = await spl.getMint(connection, burnMint.publicKey, undefined, spl.TOKEN_PROGRAM_ID);`
I'm running `"@solana/spl-token": "^0.1.8",` right now
how can I check the latest version number? I have `import * as spl from "@solana/spl-token";` but `await spl.getMint` still shows up as `undefined`
oh okay, so I will have to do it in like a backend server or client side and call the program with the holder address
Ah, no, can't do that within your program, not dynamically
just the holder own greatest amount, like the functions in web3js
What do you mean by token holder of a given mint? A given mint could have lots of token holders
At any rate, with the old spl library above, `burnMint.getAccountInfo` only works when you pass it a burnMint token account, not the burnMint itself.
The latest version of the spl library makes this a bit easier: https://github.com/solana-labs/solana-program-library/blob/master/token/js/src/state/mint.ts#L73
how can we check the exact changes on the mint account? for example if i have:

```
const burnMint = await spl.Token.createMint(
  program.provider.connection,
  payer,
  payer.publicKey,
  payer.publicKey,
  0,
  spl.TOKEN_PROGRAM_ID
);

const burnTokenAccount = await burnMint.createAccount(arbitraryOwner.publicKey)

await burnMint.mintTo(burnTokenAccount, payer.publicKey, [], 1);

const tx = await program.rpc.burnToken(amountToBurn, {
  accounts: {
    burnTokenAcct: burnTokenAccount,
    burnMint: burnMint.publicKey,
    burnTokenAcctAuthority: arbitraryOwner.publicKey,
    tokenProgram: spl.TOKEN_PROGRAM_ID
  },
  signers: [arbitraryOwner]
});

let postBurnATA = await burnMint.getAccountInfo(burnTokenAccount)
```

The `burnMint` has type `Token` which doesn't give any info on the supply. If I add a `let preBurnMint = await burnMint.getAccountInfo(burnMint.publicKey)`, I get `Error: Invalid account size`.
Just wondering is it possible for a anchor program to get the token holder of a giving mint ?
probably wrong config or pass in wrong parameter for setting up provider?
It ends up not needing Rc or Arc.
Hey so I ended up forking the client and adding a pseudo copy effect for the dyn Signer parts (Keypair::from_byte(self.to_bytes)). Ill let you know how it goes and send a copy of the client if it works
this one throws 30s timeout
`transactionSignature = await program.rpc.someFunctionality(`
is there a way to get tx signature before it timeouts when we do this

"**provider.send is not a function**" - has anyone seen this issue before?

Here's the command I am trying to execute:
ANCHOR_WALLET=/Users/kvishnu/Documents/Crypto/anchorTutorial/frcnt/FRAhcueDBpuUqqKekpx2Frgu8L7WQwyqf41Z674EMbY4.json node frcnt.js
I'm hoping the client fixes this though cuz it's quite annoying for async code
it's a shitty workaround, but in my case I was using a shared `State` struct, I defined a getter `client()` on it that would rebuild a new client, also since `Keypair` doesn't implement `Clone` I also store the bytes of the keypair instead, and then do `Keypair::from_bytes`
How‚Äôd y fix it
The workaround I am using atm:
```
! anchor test | grep "failing"
```
```
anchor test
echo $?
```

always returns exit code 0 for me even if the tests are failing on 0.22.0
I am trying to integrate this into my CI, but it always returns 0, even with failing tests
does `anchor test` always return `0` exit code ?
Anyone noticed that deploying on solana-test-validator in versions >= 1.9.x is super slow compared to 1.8.x.? Is it a bug introduced somewhere? I have tried both our manual deployment and also solana deploy and solana program deploy and everything is super slow, the test validator denies to accept more than one transaction per slot, or it seems so via solana logs.

Referring to CLI tools from: https://docs.solana.com/cli/install-solana-cli-tools, but even when deploying manually with our own code using solana_client RPC, it's the same, super slow, buggy. Once we downgrade to 1.8.x it's super fast again. 

It seems to be related to the new CLI option to control ticks per slot of the `solana-test-validator`, but it looks like it broke the validator somehow and the true reason is probably somewhere very deep in the validator code.


///////////////////////////////////////////////////////////////////////////////////////////////

but this is a bit of a contentious topic
i think one should either create two different versions or only use spl tokens (and wrap the native sol)
Given this https://github.com/project-serum/anchor/issues/1387
Right now i have a program that uses uncheckedAccount because someone can pay with a sol account or a token account and i do the check within the program.
But also often felt as if i should just create two different methods and thus avoid a bunch of verification by directly using the anchor account types.

Anyone has a comment on that ?
Is there some example to check, maybe, because I want to have exact same instruction with same signature and accounts for different contracts. The implementation of this instruction will be different for different contracts, so this will give me possibility to do CPI, but with different program_id and accounts, but for exact same instruction. Its kind of `virtual` instruction. üòÖ Or maybe my direction of thinking is wrong?
Yeah, it's definitely possible, but a bit annoying since you have to get the Instruction data just right (it's tricky because of the "sighash" plus encoding the instruction arguments, etc.)
Return an `Err`
Hey guys, is it possibleto do CPI call like in pure solana, but for anchor contract?

```
    solana_program::program::invoke_signed(
        Instruction {
            program_id,
            accounts,
            data: CustomContractInstruction::Foo { amount }.pack(),
        },
        account_infos,
        signer_seeds,
    )
```

But instead of CustomContractInstruction::Foo  enum I will have some anchor program instruction?
No, you can have a field afterwards, that's fine (assuming you allocated sufficient space)
Can I have a field after a Vec in my account? Or does the Vec have to be the last field in my account, since its length can increase?
I am building a program that interacts with NFT, when i run `anchor test`, is it possible to preload that localnet with NFT (metaplex program, nft mint account etc.) that i can clone from the dev net?
Thanks! Just looked it up.
32 bytes
Hey guys! 

I‚Äôm storing a vector of pubkeys in a programAccount. How much space does one single pubkey occupy?

Help much appreciated üôÇ
when i run `anchor test`, does it spin up a completely new localnet each time, can i preload the network with certain account and program?
in Solidity, we use require() to perform validation, wt is the best practice to perform validation in Anchor (expecting the txn to be reverted if validation failed)?
can anyone share an example of how to use parseLogs properly? I have an event called 'NewTransmission' being emitted by my program that I want to look for, but not exactly how to get it using Anchor. Here's what i have so far from a previous example, but it doesn't like the 'logs' param as it's not defined

`
//  const idl = {...}; // your idl here
  const coder = new anchor.Coder(storeIdl);
  const parser = new anchor.EventParser('EdWr4ww1Dq82vPe8GFjjcVPo2Qno3Nhn6baCgM3dCy28', coder);

  // Parse a string[] of logs from a transaction.
  parser.parseLogs(logs, (event) => console.log(event));

  // Parse a single log.
  coder.events.decode(log);`
any way to skip the init check?
tried `#[account(zero)]` but got an error, I assumed it's because `zero` implies zero_copy?
how do I pass an unitialized account, to be initialized on a CPI to another program?
another question:
(you can use the `pubkey!` macro for this)
nvm
is there a way to use the `#[account(address = XXX)]` with a `&[u8]` instead of a Pubkey?
Can I have a field after a Vec in my account? Or does the Vec have to be the last field in my account, since its length can increase?
Yeah, I think you're going to have to just carefully step into the rcp call
Hmm, didn't think that would *add* a layer of promising
oh that's my mistake in the logging, i accidentally put an await in front of the transactions in the `console.log`
Actually, wait, why are there any promises in that log? Am I reading it wrong?
rather than @solana
all classes and whatnot
i'll try using everything from anchor
<:wtf:900073910400335902>
```js
            const instructions = []
            const createAtaIx = createAssociatedTokenAccountInstruction(
                userIncomingTokenAccount,
                this.wallet.publicKey,
                this.wallet.publicKey,
                new web3.PublicKey(PHASE_TOKEN_MINT)
            )
            instructions.push(createAtaIx)
            console.dir(instructions, {depth:null})
            console.log((await instructions[0]).programId.toBase58())
            await this.program.rpc.swap({
                accounts: {
                    state: new web3.PublicKey(PHASE_STATE_ACCOUNT),
                    signer: this.wallet.publicKey,
                    tokenProgram: TOKEN_PROGRAM_ID,
                    xTokenAccount: userOutgoingTokenAccount,
                    yTokenAccount: userIncomingTokenAccount,
                    xTokenMint: new web3.PublicKey(ROPE_TOKEN_MINT),
                    yTokenMint: new web3.PublicKey(PHASE_TOKEN_MINT),
                    yPool: new web3.PublicKey(PHASE_POOL_ACCOUNT),
                    cpiAuthority: new web3.PublicKey(PHASE_AUTHORITY_ACCOUNT),
                },
                instructions: instructions
            });
```
aghhh i know where the whole issue lie

the library I am calling has a mainnet flag that I need to turn on, otherwise it will keep referring to devnet program ID
that's what im doing now, will let you know
Does it somehow not have a programId?
Can also just store that instruction in a variable and poke around with it
yeah
Think you should probably set some breakpoints etc. and start stepping through code
```js
        if (!hasAssociatedAccount) {
            tx = await this.program.rpc.swap({
                accounts: {
                    state: new web3.PublicKey(PHASE_STATE_ACCOUNT),
                    signer: this.wallet.publicKey,
                    tokenProgram: TOKEN_PROGRAM_ID,
                    xTokenAccount: userOutgoingTokenAccount,
                    yTokenAccount: userIncomingTokenAccount,
                    xTokenMint: new web3.PublicKey(ROPE_TOKEN_MINT),
                    yTokenMint: new web3.PublicKey(PHASE_TOKEN_MINT),
                    yPool: new web3.PublicKey(PHASE_POOL_ACCOUNT),
                    cpiAuthority: new web3.PublicKey(PHASE_AUTHORITY_ACCOUNT),
                },
                instructions: [
                    createAssociatedTokenAccountInstruction(
                        userIncomingTokenAccount,
                        USER_PUBKEY,
                        USER_PUBKEY,
                        new web3.PublicKey(PHASE_TOKEN_MINT)
                    )
                ]
            });
        } 
```
I don't see anything wrong with it but I could also be blind
hmm I think it has something to do with the way anchor is passing the instruction, the error states `Uncaught (in promise) Error: Transaction instruction index 0 has undefined program id`
TIL, thanks Alan!
Right, since the struct itself has the declareID
So a `Account<'info, Mint>` checks spl token program owns the account, whereas a `Account<'info, OneOfYourAccounts>` checks that your own program owns it
Yeah, it checks that it's owned by whatever program the `Whatever` struct declares should own it
yep, that's why I was confused. So it's owned by a Program but any Program
(It's for checking *program* ownership, not authority stuff)
E.g. `Account<'info, Mint>` is owned by the spl token program
Ah, no
aghhh. I see. I always thought Account is only for things that owned by current program
So probably that account isn't initialized on mainnet
Account<'info, Whatever> will require it to be an actual Whatever
If you change it to `AccountInfo` then that will work even if the account isn't initialized
then why it would be OK in devnet <:thinkingpepe:746135853386039376>
aghh there's a another Account that refers to struct from different program, changed that to AccountInfo and it seems OK
yep, I can still use Account<'info, Mint> even if the program doesn't own the Mint authority right?
Hmm, are you sure you're passing in the right mint address from the client then?
no, different mint
Yeah, does the mint use the same address on devnet vs mainnet?
Most suspicious seems to be `Account<'info, Mint>`, as the program don't own the Mint, but neither it owned the Mint in devnet?
Anyone know how I would airdrop USDC to a localhost wallet?
Let me double check all the Account first, thing shouldn't change too much coming from devnet and mainnet
Happy to try pair-debugging it if you want?
This should definitely be fixable without nuking the program id
like almost 10 sol each deployment
yep already reran those, maybe gonna try nuking the program id as well. Just super expensive to do so T-T
One thing you can try is to rerun `anchor build` and just deploy again
So depends a bit on what kind of `Account<'info, Whatever>`s you have, but when deploying like this it's often because of a mixed up declare_id
This error means some `Account<'info, Whatever>` doesn't like the owner of that account
Oh, haha, no idea what that means
was referring to: https://discord.com/channels/889577356681945098/889577399308656662/930211309771956224
Mm, not quite sure if this would apply here, but a very common mistake is to run anchor build to generate a program id, change your declare_id!, and then run `anchor deploy` without remembering to *rerun* anchor build
yep same program ID, just nuked everything, and copy pasting the keypair in
Ok, that looks ok I guess (what's up with that error?)
Are you using the same program id on devnet vs mainnet?
Usually when this pops up after a deploy to a new network it's because of an incorrect declare_id (it's surprisingly easy to goof this up if you change your program id)
What do you mean by alignment issues?
aghhhh aghhh getting `0xbbf` 3007 for after deploying the same code from devnet to mainnet. could it be due to alignment issues?
```
  const keys = [
    { pubkey: payer, isSigner: true, isWritable: true },
    { pubkey: associatedTokenAddress, isSigner: false, isWritable: true },
    { pubkey: walletAddress, isSigner: false, isWritable: false },
    { pubkey: splTokenMintAddress, isSigner: false, isWritable: false },
    { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },
  ];
  console.dir(keys.map(i => i.pubkey.toBase58()), {depth:null})
  const cnx = new Connection(clusterApiUrl(`mainnet-beta`))
  console.dir(await cnx.getAccountInfo(splTokenMintAddress))
```

Did you try fetching the mint account?
Well, the only place I see in that function where it can raise that error is when making sure the mint is owned by the spl token program, so without being able to run your code I'm not sure what else could be the issue
Yeah totally, been doing that, this one just has been stumping me
https://github.com/solana-labs/solana-program-library/blob/master/token/program/src/processor.rs#L80
But in general the way you need to debug stuff like this is by reading the relevant token program source code
`await program.provider.connection.getAccountInfo(theMintAddress)`
Can you quadruple check by fetching the account itself?
yeah
Is the code above using that same network?
this is FZx

`console.dir(keys.map(i => i.pubkey.toBase58()), {depth:null})`:
```
Array(7)
0: "ph4s8QRWjyiXH2R1FxnumUDYvhE3ikEA8VjW3sJYu8c"
1: "4HbUgs45oomZgF5AgWSLffXgeqFUk9oQTRk5TAJkuZnY"
2: "ph4s8QRWjyiXH2R1FxnumUDYvhE3ikEA8VjW3sJYu8c"
3: "FZxUbyQ9oeFiSDaabw8KfAWACsDMQhbuxR9vm2Rh7Ewm"
4: "11111111111111111111111111111111"
5: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
6: "SysvarRent111111111111111111111111111111111"
length: 7
[[Prototype]]: Array(0)
```
did a quick log
Mm, are you positive that mint really is a mint?
that's what i meant
yeah sorry
Got it
Oh, you defined that yourself?
mine:
```js
export const createAssociatedTokenAccountInstruction = (
  associatedTokenAddress,
  payer,
  walletAddress,
  splTokenMintAddress
) => {
  const keys = [
    { pubkey: payer, isSigner: true, isWritable: true },
    { pubkey: associatedTokenAddress, isSigner: false, isWritable: true },
    { pubkey: walletAddress, isSigner: false, isWritable: false },
    { pubkey: splTokenMintAddress, isSigner: false, isWritable: false },
    { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },
  ];
  return new TransactionInstruction({
    keys,
    programId: ASSOCIATED_TOKEN_PROGRAM_ID,
    data: Buffer.from([]),
  });
}
```
```js
export function createAssociatedTokenAccountInstruction(
    payer: PublicKey,
    associatedToken: PublicKey,
    owner: PublicKey,
    mint: PublicKey,
    programId = TOKEN_PROGRAM_ID,
    associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID
): TransactionInstruction {
    const keys = [
        { pubkey: payer, isSigner: true, isWritable: true },
        { pubkey: associatedToken, isSigner: false, isWritable: true },
        { pubkey: owner, isSigner: false, isWritable: false },
        { pubkey: mint, isSigner: false, isWritable: false },
        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
        { pubkey: programId, isSigner: false, isWritable: false },
        { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },
    ];

    return new TransactionInstruction({
        keys,
        programId: associatedTokenProgramId,
        data: Buffer.alloc(0),
    });
}
```
https://github.com/solana-labs/solana-program-library/blob/eb048559eb71bd9218729978c9020926b4b4fd10/token/ts/src/instructions/associatedTokenAccount.ts#L16
I'm following the same instruction pattern as here
it's my own function haha
At any rate, I think you have your arguments wrong‚ÄîI would jump to source to double check you're doing them in the right order
Where are you importing that function from?
in this func? I have 4 arguments there
So the token program is saying that the mint you're passing isn't actually a mint
They're supposed to be
```.ts
    static createAssociatedTokenAccountInstruction(
      associatedProgramId: PublicKey,
      programId: PublicKey,
      mint: PublicKey,
      associatedAccount: PublicKey,
      owner: PublicKey,
      payer: PublicKey,
    ): TransactionInstruction;
```
Ok, the args you're passing to `createAssociatedTokenAccountInstruction` don't make sense to me
```
Connected wallet: ph4s8QRWjyiXH2R1FxnumUDYvhE3ikEA8VjW3sJYu8c
4HbUgs45oomZgF5AgWSLffXgeqFUk9oQTRk5TAJkuZnY
null
```
first is the owner account, second is the fetched associated token account, third is the result from `getAccountInfo`, since it's null, I'm assuming it hasn't been initialized

Whoops, nope, I was wrong, 1 sec
hmm, I'm checking to see if the user has an associated token account before running the instructions
Let me double check
Ok, that I think means (confusingly) that the associated token account might already be initialized
```
bundle.js:37502 Transaction simulation failed: Error processing Instruction 0: incorrect program id for instruction 
    Program ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL invoke [1]
    Program log: Transfer 2039280 lamports to the associated token account
    Program 11111111111111111111111111111111 invoke [2]
    Program 11111111111111111111111111111111 success
    Program log: Allocate space for the associated token account
    Program 11111111111111111111111111111111 invoke [2]
    Program 11111111111111111111111111111111 success
    Program log: Assign the associated token account to the SPL Token program
    Program 11111111111111111111111111111111 invoke [2]
    Program 11111111111111111111111111111111 success
    Program log: Initialize the associated token account
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [2]
    Program log: Instruction: InitializeAccount
    Program log: Error: IncorrectProgramId
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 2796 of 179577 compute units
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA failed: incorrect program id for instruction
    Program ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL consumed 23219 of 200000 compute units
    Program ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL failed: incorrect program id for instruction

bundle.js:35014 Uncaught (in promise) Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: incorrect program id for instruction
    at Connection.sendEncodedTransaction (bundle.js:37506)
    at async Connection.sendRawTransaction (bundle.js:37465)
    at async sendAndConfirmRawTransaction (bundle.js:39461)
    at async v.send (bundle.js:57188)
    at async Object.swap (bundle.js:57216)
    at async SwapClient.swap (bundle.js:57522)
    at async HTMLDivElement.swap (bundle.js:57992)
```
haha yeah was just about to run it again and post that
Can you print the full program log? Way easier to debug that way
checked both `ASSOCIATED_TOKEN_PROGRAM_ID` and `TOKEN_PROGRAM_ID` to ensure theyre right
error tells me incorrect program id for instruction
```js
                instructions: [
                    createAssociatedTokenAccountInstruction(
                        userIncomingTokenAccount,
                        this.wallet.publicKey,
                        this.wallet.publicKey,
                        new web3.PublicKey(PHASE_TOKEN_MINT)
                    )
                ]
```
```js
export const createAssociatedTokenAccountInstruction = (
  associatedTokenAddress,
  payer,
  walletAddress,
  splTokenMintAddress
) => {
  const keys = [
    { pubkey: payer, isSigner: true, isWritable: true },
    { pubkey: associatedTokenAddress, isSigner: false, isWritable: true },
    { pubkey: walletAddress, isSigner: false, isWritable: false },
    { pubkey: splTokenMintAddress, isSigner: false, isWritable: false },
    { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },
  ];
  return new TransactionInstruction({
    keys,
    programId: ASSOCIATED_TOKEN_PROGRAM_ID,
    data: Buffer.from([]),
  });
}
```
hmm seem to have issues create associated token account when using the `instructions` on anchor rpc calls. this function works outside of anchor
I meant github actions to install anchor and solana for use in our own actions
`pool_signer` owns `reward_vault` yep?
the anchor repo uses github actions
has anyone made github actions for solana/anchor? I'm planning on making some in case there isn't, just making sure I'm not duplicating effort
`from` and `to` both need to be mut, could that be the issue?
im running anchor test
does anyone know what this error mean?
hey guys
yes
`reward_vault` correctly specified as `mut`?
got this error while transferring tokens (in a program)

    `<TOKEN_ACCOUNT_ADDRESS>'s writable privilege escalated
failed: Cross-program invocation with unauthorized signer or writable account`

side note: signer is a PDA

code: 
`
if user.balance_staked > 0 {
                let pending = muldiv(user.balance_staked as u128, pool.acc_per_share as u128, 1000000000000);
                if pending > 0 {
                    {
                        let seeds = &[pool.to_account_info().key.as_ref(), &[pool.nonce]];
                        let pool_signer = &[&seeds[..]];
                        let cpi_ctx = CpiContext::new_with_signer(
                            ctx.accounts.token_program.to_account_info(),
                            token::Transfer {
                                from: ctx.accounts.reward_vault.to_account_info(),
                                to: ctx.accounts.reward_receiving_vault.to_account_info(),
                                authority: ctx.accounts.pool_signer.to_account_info(), //todo use user account as signer
                            },
                            pool_signer
                        );
                        token::transfer(cpi_ctx, pending)?;
                    }
                }
            }`

help is highly appreciate. thanks üòÑ
<@!501570363566587905> I'll go ahead and add the git URL as a program field in Anchor.toml. I'm not too familiar with toml syntax though, is that what we'd be looking for?
```rust
[programs.mainnet.test_program]
address = "GRIEOJGIOER4390903F2FJO2EP0f9324jf93feijf239"
git_url = "https://github.com/xyz/123.git"
```
as a replacement for
```rust
[programs.mainnet]
test_program = "GRIEOJGIOER4390903F2FJO2EP0f9324jf93feijf239"
```
I'm getting the famous "feature `edition2021` is required" when trying to run `anchor build` . I see a lot of people mentioning it here in Discord, but not a lot of people saying they solved it. My versions are Anchor -> 0.20.1, solana -> 1.9.4, and rustc -> 1.60.0-nightly. Any ideas how to solve this?
spicy


///////////////////////////////////////////////////////////////////////////////////////////////

Hi! Not sure if this is the right place for this, but I'm trying to use https://github.com/project-serum/multisig to authorize a transaction that requires multiple signers (specifically https://github.com/StreamFlow-Finance/stream) and I haven't figured out a way to get multiple signers working with multisig. Does anyone know if it's possible?
I want to develop an application. For example, I will send x tokens to several accounts. Then I will find out how many y tokens are in accounts with x tokens. Does anyone know a roadmap for this? Where should I start?
how do you think solana transfers work when you want to send solana to a friend
to send money
no you just need his public key
if I want interact with the wallet player on my server and send money to him I need his private key no ? so it's a problem
they are also known as cranks
https://docs.chain.link/docs/chainlink-keepers/introduction/
what is a keeper ?
but if your doing gambling on the blockchain its better to do everything on the server if possible because any exposure to the chain is a vulnerability
you can run a keeper to play the game later and then update it after a give namount of time for the user
question is: how to sign a transaction securely with one of my account in the frontend ?
I have my houseWallet and feeWallet public to everybody because it's in my frontend code, it's dangerous and people can steal money inside these accounts no ? what is the solution to make this secure ? üòÖ
but if I do a call like this in my frontend call

    let tx5 = await program.rpc.playGame(betType, amount, {
      accounts: {
        game: game.publicKey,
        houseWallet: houseWallet.publicKey,
        feeWallet: feeWallet.publicKey,
        author: provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      },
      signers: [game, houseWallet, feeWallet],
    });
    await provider.connection.confirmTransaction(tx5);
Not the goal i am learning haha
why would you want to do that besides stealing all of his money
But if I want sign my smartcontract call in my backend with a user who is using phantom Wallet on my frontend, is it possible to send provider.Wallet to my API and sign with his Wallet infos from my back ? üòÖ
Okk thanks I will use an API and make my smart contract calls from my backend
afaik protocols already do that, they just make a patch that disables the program while they find a fix, then patch again with the exploit fix
If you build in a "disable button" you make that exploit unusable, and instead of upgrading you deploy a new version
no because the program thats deployed could already have an exploit and it wouldnt be patchable
Let me rephrase: how about the program immutability by default that I mentioned, do you think it does not solve the issue?
Are you saying that making the program immutable does not solve this issue?
Actually have no idea besides forking the code and deploying your own version -- maybe there would be a way to license tech in solana in the future
One thing I can think of is that programs not being upgradeable might lead to some tricky situations if a bug is found, and the program in question cannot be patched. Would the inclusion of a "disable" feature/endpoint mitigate that, and can you think of any other issues?
What would be the ideal situation, for this upgrade/validate for CPI topic? Basically if I say "programs should never be upgradeable, so that you **don't** have to duplicate CPI accounts checks because you'll always know what you point to" what's the flip side and can it be mitigated?
don is cool yeah
yeah we want to be able to validate all the accounts in anchor within our contract without relying on the cpi program -- I think there are some resource constraints for the bigger ones but don is smart
next major version, to be specific
yeah anchor does solve some headaches yes
next version would be anchor
well its not just trust, I 100% trust the mango team, but they are human and make mistakes and dont use anchor yet :l
you have to have trust in them
but yeah you kind of rely on the council
technically mango also version tags
good point, you suggest more seldom updates
which means one day mango might be safe and the next day unsafe
upgrade constantly
serum luckily versions deploys and doesnt upgrade, but most projects, and I think Mango is super guilty of this
and compare against them
yeah you can hardcode basically well known pub keys
well its reponsibility of the client code
you need to validate on your side. Its the only way to know
when you CPI
yeah so you cant tell that its safe
I meant anyway that, if you cpiing into another progrma, and building some kind of relay program, then you rely on final program to check the accounts
sorry i mean into another program
what do you mean by cpiing into account?
how do you know if its safe if the account your CPIing into is upgradeable and not owned by you
if someone has the secret key, they own the account. You should keep the secret keys on a private server and access it through an API. Alternatively, handle everything through a smart contract.
Yeah, that is typical.
ah so when using PDA, the bump (one for each) must an input to the instruction
It's really more like a salt. Basically <@653519450397474846> there is a 50% chance that a derived address will be on the curve. PDAs must not be on the curve, so you derive it not from the seed alone, but from the seed with an extra byte added, to 'bump' it off the curve. You calculate the bump by keep trying different values until you find one where the derived address is of curve, then pass that number in so that the on-chain program doesn't have to calculate it.
I don't understand why some implementations name this variable `nonce` since it really isn't.
It is a nonce that is used for move the public key out of the curve
what is 'bump' in context of PDA accounts?
Thanks by advance the commu üôÇ
And to sign I need the secret key, so, i need to have access to secret keys from the front end and secret keys become public no ?
Because if I want to make √† transaction from account A to B from the frontend, I need to sign the grpc call with signers=[A,B]
Hi guys ! Is it dangerous if someone have the secret key of my account ?
Rather than the explicit uncheckedaccount
I also found that people tend to use account info all over the place because it is just a warning
yeah with cpi you end up with a bunch of uncheckedaccounts, but yeah a comment like SAFETY: or something doesnt sound bad
Let's say someone wants to call serums dex new order, only the market and program need to be the right thing since the cpi will check all the rest.
Isn't an unchecked account with an address constraint lighter that needing the accountloader?
https://twitter.com/armaniferrante/status/1489259867172794378?t=zXwk9o1tAEIFnQCSS7VtUQ&s=19
I think deploying fixtures is a one time thing, could be daunting at first, but really pays of in long term
I using Metaplex CPI and deploying them to localnet each time is a pain.

rn I'm thinking to clean up all the accounts after tests. Maybe anchor should do this automatically for tests not on localnet.
i think tests are intended for localnet, one of the core devs would be able to confirm though
yeah, had similar issues in the past, hence I ditched devnet testing completely, either you continue the test from where it was successful last time (reuse the already init pda) or setup anew the state (which is used as a seed in the pda, so e.g. if the pda requires some key, then create a new one per test)
the code checks for a valid PDA so I cant use any generated account
well, instead of changing the seed each time you can generate a keypair each time and use that since itll be unique
keypair? You mean account keypair? But I need to use a PDA for my code
create a keypair and use that
what is the best way to write tests for accounts using PDAs on devnet?

need to change the PDA seeds every time I run the test since the same account cant be created again.
@ solana/wallet-adapter + useAnchorWallet
hey guys, im looking to make the backend of my website interact with my program. im having trouble getting the provider because of the wallet parameter. Anyone know how to get a wallet for the provider in typescript?
Anyone interested in iOS? I've just created a PR to Solana.swift that adds basic support for creating and sending Anchor instruction transactions - asking for comments from iOS devs who want this: <https://github.com/ajamaica/Solana.Swift/pull/150>
Anyone know a tool for getting the top N~300 token holders given a mint?
I found `let largest = await connection.getTokenLargestAccounts(mint);`, but seems to only support top 20...
the usual "do this only if" is done though business logic, like this can happen only if this other condition is fulfilled
for something to happen you need someone/something to send a transaction
"some event" what is this?
Ahhh I see, okay. Is there any way to prevent someone from doing that at any time, would I need to attach an external account that ‚Äúowns‚Äù that action to prevent just anyone from calling a function that mutates some state? 

Like for instance I‚Äôd like some event to automatically create some state (an account owned by the program), but I don‚Äôt want just anyone able to mutate the account by calling a function that‚Äôs only automatically signed by the program that owns it, or am I misunderstanding something and that‚Äôs not possible?
look at this lean example for instance
close/mutate has nothing to do with signing, the program owning the account can do that at any time.
https://github.com/solana-labs/solana-program-library/blob/master/token/program/src/processor.rs#L652-L688
Am I understanding correctly that in order for only a program to be able to change an account it owns, I need to create a signer key from that account to be able to close itself, mutate itself, etc? 

I‚Äôm trying to build a system where the program can create a certain account that holds data, and when certain events happen, the account data is mutated in certain ways programmatically, by no outside manual influence. In other words I don‚Äôt have to close the account manually, when a timer goes off or something, data gets mutated in some way.
maybe it is the wrong approach though and the program should have one method for each rather of having 1 method do them all
What is the best mechanism to crank out remaining accounts with some sort of naming to it? The goal is to build at runtime the right cpi call

The problem is that a few accounts are required, then only the method knows what cpi needs to be performed, requiring a completely different set of accounts downstream.
So i thought maybe the best approach is to ::try_accounts on an Accounts struct that has all the right accounts
being explicit is 1 reason. idk whether its a good enough reason. i havent checked how much compute borsh takes for each byte
got it, thanks
If you decreased the padding, yeah (c needs to maintain its offset)
would putting `d` before `c` work also?
very clear
understood, thank you ser
Dumb question, why do we need padding at all again? Versus just pre-allocating extra space for new fields at the end?
so if you put the `d` directly before the padding. it would be ok
no. think about offsets of your fields. those have to stay the same. `c` used to be at 4+4+512= 520. now its at 4 + 4 + 508 = 516.
can i do something like 

```pub struct Foo {
    pub a: u32,
    pub b: u32,
    pub account_padding: [u8; 512],
    pub c: u32,
}```
upgraded to
```pub struct Foo {
    pub a: u32,
    pub b: u32,
    pub account_padding: [u8; 508],
    pub c: u32,
    pub d: u32,
}```
it doesnt have to be as long as you manage it correctly
does it matter where my padding is placed in a struct? i.e. does it have to be at the bottom in terms of order?
Thanks Paul!
if by hex string you mean base58 encoded pubkey, you can do `new Pubkey(myString)`
any help? üôÇ
thanks guys!
understood, much easier if I add padding to the `Foo` struct itself
if you wanted upgradability of a struct in an array you would need the padding to be in the struct and after.
you can swap out padding for other types yes. re your specific example, you put the padding at the start of the struct and now youre reducing it so the Foo array will start at a different, earlier point in memory which may corrupt old accounts. you also didnt add padding in the Foo struct so you cant just add a new field there because that would also mess up offsets inside the Foo array
This can't work, it will read the wrong data, think about borsh as a dump take memory and dump into objects, if there are now new the old bytes under the new field this will just implode.
Also the padding is before rather than after, kind of odd
Question for a test: how can we transform a hex string of a pubkey to a real PublicKey object on the client side?
<:pepewoah:866983237141397514>
while the ogs are online, any idea regarding upgrades?
a light example https://github.com/saber-hq/merkle-distributor/blob/master/programs/merkle-distributor/src/lib.rs#L177-L241
```    #[account(mut)]
    pub distributor: Account<'info, MerkleDistributor>,```
I see a lot of programs use the seeds on init, then for subsequent calls just rely on the seeds and bump that has been crafted and saved on init
0x7d4 == 2004 = ConstraintOwner, so some `owner = ...` constraint is failing
the problem of that convenient bump is that you need to specify the pda seeds on Accounts wherever you want it, is that right?
rather than canonical bump
oh if the fool specifies the bump
"multiple pdas with the same seeds" mmh how, like same seeds then the next bump?

this is hurting my brain
though theoretically you could have something asinine like multiple pdas with the same seeds
yea this is true
the bump is unique for the pda, which can be recognized by the pk, isn't it right?
not pubkey
by address i mean bpf memory address
would need to be based on the wrapper type address or something idk
eh you're right i dont think that works
like check pk only?
or is there a way to macroize it? So still just a string but from account.
the partial eq what would it be based on?
oh
instead of `ctx.bumps.get("my_account")`
so that we can do something like `ctx.bumps.get(ctx.accounts.my_account)`
which is probably better
vs doing something like implement the PartialEq trait for all the major account types
well if it is the account name ok
and the reason is because it took me 1 second to implement
`Custom program error: 0x7d4` fighting this guy right now. any way to tell what account is causing it?
it's the string of the account_name
i see
it's not a pubkey
<@!501570363566587905> ping why?
awesome thansk
literally just a pubkey with zero data
UncheckedAccount
I want to pass an uninitialized account to a program which will be initialized on a CPI to another program
any way to make anchor skip all checks
though measure and find out
probably just more compute
any downsides to wrapping all accounts in `Box`? I know it can save stack space, but any downsides to doing it if the original account wasn't throwing any errors to begin with?
yep Ive run into that one too but the error was much clearer in my previous case
Whereas the separate instruction approach can do 10mb
But also worth pointing out that with `init`, the biggest you can go is 10kb
I'm actually not sure though off the top of my head why you'd get a stack issue there though
got it, thanks üôÇ
(Ah, usually to have a big account you need to init the account in a separate instruction, and then use zero etc.)
Yep, switiching `init` to `zero` resolves the issue
Maybe its because Im also using the `init` macro?
`pub vrf: AccountLoader<'info, VrfAccountData>,`
That sounds like you aren't using `AccountLoader`
So seems that there is some contention point with the account and stack size
When I try to build my code, I receive `Error: Function _ZN91_$LT$switchboard_v2..actions..vrf_init_action..VrfInit$u20$as$u20$anchor_lang..Accounts$GT$12try_accounts17hfbca78718b9369b3E Stack offset of 4784 exceeded max offset of 4096 by 688 bytes, please minimize large stack variables`
AccountLoader leaves the underlying AccountInfo's data in place, so it can be all the way up to 10mb (it never touches the stack *or* the heap, unless you goof something up)
Are you using `AccountLoader`?
https://github.com/Synthetify/synthetify-protocol/blob/master/programs/exchange/src/account.rs#L206
https://github.com/Synthetify/synthetify-protocol/blob/2fb9a4958cca0ecb8f356867fbfc4ef0c9af17fe/programs/exchange/src/context.rs#L38
This seems to be larger than 4096, zero-copy, and without Box, maybe there is something there you can use?
Is there a way to manage zero-copy accounts larger than 4096 bytes? Im getting access violations on init and seems I cant wrap in `Box`


///////////////////////////////////////////////////////////////////////////////////////////////

Is any team in here rolling their own indexing/cacheing? We need it badly for our UX and have been ghosted by the projects in the ecosystem that are doing this as a service.
I‚Äôm still stuck with an instruction taking 32 accounts and blowing the stack by 350bytes‚Ä¶ all accounts are boxed/program/signers. I take 2 u32 as parameters also. 
Kinda stuck as where to look at next as to reduce the stack usage, any leads or pointers?
Hey everyone! How can I make a rust program with anchor that does automatically send and sign the transaction and then use the endpoints in my ts program?
sounds good. Thanks for all the help. Hopefully, we'll make some more headway into the stack issues and update you onthem
Ok, I need to go to bed, but happy to look tomorrow at some failing tests if you push them (probably quicker for me to debug that way)
Okay got it. We were thinking the same as well
they should succeed
I just tried running your tests locally, should they fail?
Mm, you actually have to go back to a fixed array with AccountLoader, but it would definitely allow you to use a bigger account
Or would just allocating enough space for the account so that it can house thousands of assets be a better approach
Do you think an `AccountLoader` approach with `zero_copy` would help us achieve dynamic array length?
Got it, yeah
It certainly isn't for now. We want the asset array to be able to house a dynamic number of `assets`.
Oh, sorry, I see
Then 1000 bytes for the account storage is almost certainly not enough
Ah, so the assets array has 250 things in it?
Array allocation is now handled on the heap
The stackoverflow issue occurred before we implemented the account size override. The stack limit is like 2kb or something and we were initializing a fixed array of 250~ entries, which easily went over that limit
Yeah, why did you need to do that? 1000 isn't very big
One thing we were considering is using `AccountLoader` with `zero_copy` to essentially remove the account size override hack we implemented
It's pretty simple
https://github.com/Split-Coin/prism/blob/convert/programs/splitcoin-prism/src/lib.rs#L33
Can you post more of the rust instruction function code?
I would guess that 1000 bytes would be enough storage for whatever you're doing, so maybe it's not a space issue.
Mm, don't think I have enough info to guess anything else‚Äîbasically, you'll have to just stick in some logs etc. and see which account is complaining
I will try your logging suggestion in a sec
Our code is a bit hacky at the moment. We were dealing with stack overflow issues by allocating our initial array on the stack. We've since moved to dynamic array with overriden account size that will allow us more than enough room for plenty of assets
I wonder if you haven't given some account enough `space =` to handle a vec of stuff
And it'll show up in the log
You can do stuff like
```.rs
msg!("hmm {:?}", that_arg);
```
I have not. Can you attach a snippet of how I would do so?
Have you tried logging the assets from within your rust code?
So you actually managed to invoke your contract fine
0xbbc = 3004 = AccountDidNotSerialize
Instruction that is called that produces the error
```const tx = await sdk.registerToken({
      mintKP,
      assets: [
        {
          dataFeed: {
            constant: new BN(0),
            expo: 9,
          } as ConstantValueFeed,
          weight: new BN(0),
        } as AssetData,
      ],
      authority,
    });```
Error is pretty vague. It doesn't seem to be able to properly parse the struct

To pass a vec of custom struct things you probably have to use a regular array, `[...]` no Buffer stuff.
Could you post the full error? It's way easier to help debug if I see the stack trace
That's weird. Just tried again and it does work. Good to know `Vec<u8>` can be passed as a parameter. However, still can't properly pass in an array(`Vec<AssetData>`) of a custom struct like `AssetData` without the instruction erroring out. Are we not extending a trait that should be for it to properly do so?
What went wrong? I just tried using Buffer locally and it seemed to work
Doesn't seem like anchor instruction properly parses dynamic array inputs
Tried buffer as well. Didn't do the job. Best solution I've come up with now is basically splitting adding an array of assets into adding them one by one through chained instructions
Hmm, looks like you have to do just `Buffer.from`, not quite sure yet why Uint8Array doesn't work
I'm trying to pass in a variable length vector as a parameter to the instruction handler. However, even when properly passing in a uint8array to the instruction, I an encoding error. Is what I want to achieve possible through instruction parameters or would I have to utilize the `remaining_accounts` property to do so
Have you tried doing that? `msg!` (with an exclamation mark) is indeed the right thing
How would I log something from within a function, when running tests?
You can see my psuedocode attempt in screenshot (incidentally I don't think that works, but even if its just "code is here", I'd like to know how to print this)
In solana individual accounts sign transactions. Why don't you want to sign it with a wallet? What are you going to do with the signature etc.?
Can you say more? Don't think we have enough info to answer your question
How do i sign a transaction with a private key so I dont have to sign it with a solana wallet?
<:pepewoah:866983237141397514>  so id need to handle wrapping/unwrapping before depositing as collateral for example
Wrapped sol is what you use when you wish sol were an spl token
Probably by using wrapped sol?
interesting, i wonder how platforms handle sol as collateral in that case
No (the wrapped token is the token-ized version of regular sol, which isn't a token at all)
stupid question, is there a mint address for the native solana token? not wrapped sol
Is it possible for variable array idl generation
ive been getting the same errors
and it exsits. idk whats wrong

but its passing a string üò¢
`TypeError [ERR_INVALID_ARG_TYPE]: The "path" argument must be of type string or an instance of Buffer or URL. Received undefined`
but i kept getting errors with reading the idl
i did
have you looked at this https://project-serum.github.io/anchor/tutorials/tutorial-0.html#generating-a-client ?
i want to use the `await program.account.escrowAccount.fetch(pubkey)` but i cant becuase i dont have a wallet object
i have the idl and everything, just unsure how to decode the data
its anchor. i built it
what do you know about the program? does it use anchor? is it open source?
can anyone point me into the direction of some help for decoding account data for a custom programs account?
so the account is here: <https://github.com/Split-Coin/prism/blob/convert/programs/splitcoin-prism/src/state.rs>
and custom type here: <https://github.com/Split-Coin/prism/blob/convert/programs/splitcoin-prism/src/asset_data.rs>
https://github.com/Split-Coin/prism/tree/convert here's the repo
Can you post some code? I wouldn't necessarily expect this to work tbh, the IDL generation isn't super sophisticated
Awesome thank you so much.
Also one other question while I have you. I'm using an array of a custom type with generic in one of my defined Account structs. I derive AnchorSerialize and Deserialize on it but the IDL doesn't know how to serialize the `CustomType<T>` which I get because the IDL serializer really can't deduce which types fufill "T" easily. But my question do you ahve recommended method for mapping these types as possibilities for generic on the Typescript side of things?
As in:
```
# IDL generated
type: {
  defined: "T"
}
# types A, B are defined in types section and can be used for T
```
How do I tell the IDL decoder that A and B can be used for T , like `T: A | B` in ts terms
on the github issue
Yeah I was little confused. Seem's like my failure to read that the suggestion was wrapping the whole account with Box
So you would say `pub my_account: Box<Account<'info, TheStruct>>` in your `#[derive(Accounts)]` block
If you think about what it would mean to Box a single field in the `#[account]` struct you'll see why it'd be an odd thing to do: you're saying that, on-chain, you want to store a pointer... to somewhere (doesn't really make sense)
Ah, ok. No, that's not quite the right way‚Äîin order to use a very large account struct, you need to either Box the entire account (not just one of its fields), or use `AccountLoader` for really really large accounts
I have an account type that is very large and causing me stack overflow issues . I found this issue https://github.com/project-serum/anchor/issues/708 , seemed like using Box type was one of the three possibilities
Can you say more about what you're doing?
That won't work
So you've got a `Box` in one of your `#[account]` structs?
Im using type like : `pub bigData: Box<[CustomType; 256]>` And the IDL it generates is `defined: "Box<[CustomType; 256]>"` not sure how to get the typing and everything working
Does anyone know how to get IDL working with Box type on Anchor
Don‚Äôt understand their code :/
https://github.com/project-serum/anchor/tree/master/tests/escrow im pretty sure this escrow logic shows a way to xfer money
wait inside the smart contract?

I am searching but I can‚Äôt find solution :/ do you have a code example of sol transfer using publicKeys Inside a smart contract ? üòÖ


///////////////////////////////////////////////////////////////////////////////////////////////

how do I backtrace macros lol
do you know how Can I use anchor.workspace.Mysolanaapp; in other files than the test file ?
hey guys üôÇ
I guess only way is to check the account owner after fetching?
What can you do to make sure the accounts you are fetching are accounts actually created by your program?
indexing caching of what exactly?
i need to deserialize account data given IDL in Python, can someone point me in right direction?
if you want to suppress error logs when running a test, im using a small helper function

```export const runWithNoLogsAndExpectError = async (
    task: () => Promise<string>
) => {
    const oldConsoleLog = console.log;
    const oldConsoleError = console.error;
    console.log = function () {
        const _noop = '';
    };
    console.error = function () {
        const _noop = '';
    };
    try {
        await task();
    } catch (e) {
        throw e;
    } finally {
        console.log = oldConsoleLog;
        console.error = oldConsoleError;
    }
};
```
You can always link your account to another account buffer that acts as your array. Make the first 8 bits a static discriminator, the next 4 bytes the current length, then bytemuck the rest to the type you need


///////////////////////////////////////////////////////////////////////////////////////////////

do you mean like this: `const program = anchor.workspace.Bridge as Program<Bridge>;`
what is the best way to control what SPL tokens are supported in a program? debating using a PDA to store each mint's tokens (which only an authority can init), but wondering what else has been thought up
i may be missing something, but is there a way to type a workspace client?
I mean it's a fair question, and something a lot of people ask about, but it's an easy no üòÑ
Thank you, I figured as much, but I wanted to make sure haha I am not going to risk my entire project on obfuscation haha
Hey there. Obfuscation is all that is possible (i.e. people not knowing the account layout so not able to decode the content), but that's just playing with fire. All data in an account is public and should be considered readable, it's just a matter of how bad someone really wants to know.
Hey! If I wanted to hide some information on chain for my program to interreact with, would that be possible? Or will people be able to see what accounts my program interreacts with and then decode the information from there?
https://github.com/project-serum/anchor/pull/1402
Sorry for asking, its very easy. I will just set a bool in a static PDA and check the value in each function
anchor
how to do contract functions pausing using
gotcha! thanks :))
The program can sign for a PDA derived from it. So what you would do is setup an authority account with a seed, you can use that to be the authority and then the program can sign that PDA.
Hi! I had a followup question, can the program itself be the authority somehow, especially if the account being created is a PDA account?
note to myself: you can do whatever anchor is doing with the accounts and use the `try_from` implementation
Any good examples on how I can deserialize accounts from remaining accounts?
üò© not sure what i need tio. do
Failed to obtain package metadata: `cargo metadata` exited with an error: error: failed to parse manifest at `/Users/carlosdelrio/myepicproject/programs/myepicproject/Cargo.toml`

Caused by:
  can't find library `myepicproject`, rename file to `src/lib.rs` or specify lib.path
Carloss-MBP:myepicproject carlosdelrio$
can some one help me..im trying to run anchor test
does anyone know how to rate limit a cranked function (e.g. max once per day)? anything supported out of the box or should i store the last call timestamp and compare?
Can someone help me get my script running? I get ```Error: ANCHOR_PROVIDER_URL is not defined```when running my script through ts-node, but not when using anchor test. Any fix for this?
Transaction simulation failed: Error processing Instruction 0: incorrect program id for instruction 
    Program Stake11111111111111111111111111111111111111 invoke [1]
    Program Stake11111111111111111111111111111111111111 failed: incorrect program id for instruction
cross posting from the Solana dev support channel. this is the error i get when trying to call `StakeProgram.delegate()`
im banging my head against the wall trying to figure out why I cant get this last transaction to process properly
is anyone here familiar at all with delegating stake?
awesome that's what I thought. thank you <@!474851811422109701>
It checks the authority of the token account not the mint
for this account contrstraint:
`#[account(associated_token::mint = <target_account>, associated_token::authority = <target_account>)]`
Does anchor check if the mint authority for the token = passed authority or if the ata maps to the account passed as authority
pretty sure it's latter but chekcing
Thanks, this helped me too
I‚Äôll let you guys know when I figure it out. The governance module might be obsolete or need changing
Not sure the macro is even necessary anymore
I was using the voter_weight! macro but the API has changed
What do you want to do? One thing you can do that's pretty fun/educational is to use your own local checkout of the anchor repo as your `anchor-lang` Cargo dependency. Then you can just edit the anchor macros, stick in print statements, etc.


///////////////////////////////////////////////////////////////////////////////////////////////

it's weird that the error is `writable privilege escalated` though, it makes it look like it's a mutability problem and not a signature problem
noted - thanks a lot!
I believe no. The program can only sign for PDAs
oh that makes a lot of sense. is there no way to get the user to directly sign the CPI then?
the user is signing for the tx being sent to your program but not for the CPI. I think the way you have to implement this is: 1. mint the NFT to a PDA 2. then trasnfer the NFT from your PDA to the signer
Hello everyone, I have run into a unique problem. I am working with an account that holds an array of structs in the following form.

```#[account(zero_copy)]
pub struct Account {
    pub structs: [Struct; 255], 
}

#[zero_copy]
#[derive(Default)]
pub struct Struct {
    pub some_pubkey: Pubkey, 
    pub some_other_pubkey: Pubkey,
}```


When I run the following instruction on my client to set some_pubkey at index 0‚Ä¶

```await program.rpc.setPubkey({
      accounts: {
        someAccount: Account.publicKey,
      },
});```

I then print out both Account.structs[0].some_pubkey and Account.structs[0].some_other_pubkey and get the following‚Ä¶

some_pubkey
PublicKey {
  _bn: <BN: 54588872aa701a7c5c673831a1db1629879c6f8742256339ba5a>
}
some_other_pubkey
PublicKey {
  _bn: <BN: 90cad83349090000000000000000000000000000000000000000000000000000>
}

The initial Account.publicKey was‚Ä¶
 
PublicKey {
  _bn: <BN: 54588872aa701a7c5c673831a1db1629879c6f8742256339ba5a90cad8334909>
}

Any idea why this overflow is occurring?
thanks <@!474851811422109701>!
```

#[derive(Accounts)]
#[instruction(creator_bump: u8)]
pub struct Mint<'info> {
  // With the following accounts we aren't using anchor macros because they are CPI'd
  // through to candy-machine which will do all the validations we need on them.
  #[account(mut)]
  candy_machine: AccountInfo<'info>,
  #[account(mut)]
  candy_machine_creator: AccountInfo<'info>,
  #[account(mut)]
  user: Signer<'info>,
  #[account(mut)]
  wallet: AccountInfo<'info>,
  #[account(mut)]
  metadata: AccountInfo<'info>,
  #[account(mut)]
  mint: AccountInfo<'info>,
  #[account(mut)]
  master_edition: AccountInfo<'info>,
  #[account(address = mpl_candy_machine::id())]
  candy_machine_program: Program<'info, mpl_candy_machine::program::NftCandyMachineV2>,
  #[account(address = mpl_token_metadata::id())]
  token_metadata_program: AccountInfo<'info>,
  token_program: Program<'info, token::Token>,
  system_program: Program<'info, System>,
  rent: Sysvar<'info, Rent>,
  clock: Sysvar<'info, Clock>,
  // #[account(address = sysvar::recent_blockhashes::id())]
  recent_blockhashes: AccountInfo<'info>,
  #[account(address = sysvar::instructions::id())]
  instruction_sysvar_account: AccountInfo<'info>,
}
```
```
use anchor_lang::{prelude::*, solana_program::sysvar};
use anchor_spl::token;
use mpl_token_metadata;
use mpl_candy_machine;
use mpl_candy_machine::cpi::accounts::MintNFT;

#[program]
pub mod my_program {
    use super::*;

    pub fn my_mint(ctx: Context<Mint>, creator_bump: u8) -> ProgramResult {

      let user = ctx.accounts.user.to_account_info();
      msg!("pubkey: {:?}, writable: {:?}, signer: {:?}", user.key(), user.is_writable, user.is_signer);

      let cpi_program = ctx.accounts.candy_machine_program.to_account_info();
      let cpi_accounts = MintNFT {
        candy_machine: ctx.accounts.candy_machine.to_account_info(),
        candy_machine_creator: ctx.accounts.candy_machine_creator.to_account_info(),
        payer: user.clone(),
        wallet: ctx.accounts.wallet.to_account_info(),
        metadata: ctx.accounts.metadata.to_account_info(),
        mint: ctx.accounts.mint.to_account_info(),
        mint_authority: user.clone(),
        update_authority: user.clone(),
        master_edition: ctx.accounts.master_edition.to_account_info(),
        token_metadata_program: ctx.accounts.token_metadata_program.to_account_info(),
        token_program: ctx.accounts.token_program.to_account_info(),
        system_program: ctx.accounts.system_program.to_account_info(),
        rent: ctx.accounts.rent.to_account_info(),
        clock: ctx.accounts.clock.to_account_info(),
        recent_blockhashes: ctx.accounts.recent_blockhashes.to_account_info(),
        instruction_sysvar_account: ctx.accounts.instruction_sysvar_account.to_account_info(),
      };

      let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
      mpl_candy_machine::cpi::mint_nft(cpi_ctx, creator_bump)?;
      Ok(())
    }
}
```
can you show us the code where you are making the cpi?
Hi everyone! I've been hitting my head against the wall for the past 24 hours, trying to fix this issue. If anyone has encountered the same problem, please let me know üôè

I'm trying to call the `mint_nft()` instruction from Metaplex's `mpl_candy_machine` program (see https://docs.rs/mpl-candy-machine/2.0.1/src/mpl_candy_machine/lib.rs.html#39) through an Anchor CPI call. It works perfectly if I call `mint_nft()` directly from the js client. But when I do it through my custom program (even though all the accounts are really just passed through), it fails with a `writable privilege escalated` error.

I don't understand why this error occurs, given that the account in question is clearly mutable (see the log just before the call to `cndy3Z4yapfJBmL3ShUp5exZKqR3z33thTzeNMm2gRZ` in the screenshot). 

(It might very well be a problem on Metaplex' side)

Any help would be greatly appreciated!!
seeing a bunch of build errors recently, I suspect from a new anchor version
Getting the error

failed to resolve: could not find `ProgramState` in `anchor_lang`
anyone ever seen `method 'exit' not found for this`?
what the previous api did is: provide a bump, we check that the given bump matches the found one and then you can use your given bump in your ix if u want. this was confusing because in instruction that dont use init, you could actually provide the bump and the check would use the provided bump
we didnt deprecate it but we put it behind a feature flag now cause of its dangers
check out th constraints reference for that
<@689817175900291093> <@832140329301311488> the new release also comes with some more init_if_needed docs!
yeah okay, thanks
oh well youd have to import anchor-lang. if for some reason you dont wanna do that(?), you can use the underlying invoke syscalls
how if im not even importing anchor? üòÑ
yes! you can use those in a non-anchor program too
you were never allowed to provide a bump. it just looked like you were. this is why we changed the api so now its clear you cant do it. you cam get the found bump with ctx.bumps.get()
yeah well here we are using codegen cpi methods, and cpi context
same as from an anchor program. https://project-serum.github.io/anchor/tutorials/tutorial-3.html#cross-program-invocations-cpi
ctx.program_id
There's a comment on a GitHub issue which says the following:
`init_if_needed is dangerous because it requires additional verification code to protect against reinitialization attacks and should therefore be used with care.`
https://github.com/project-serum/anchor/issues/1191
wow, 3 `init_if_needed`  questions in a row. this must be a new record!
it works in the case where it's a PDA account though
or is it not possible to use SPL constraints with `init_if_needed`
Hi folks! I'm trying to use the `init_if_needed` constraint on a TokenAccount; however in the case where the token account exists, and I pass in the token account's public key, the signature verification fails (I'm only using the token account authority as the signer). What can I do in this case?
Was also wondering the same thing. I have heard here its good to create two seperate handler than using init_if_needed. But looking for anyone to chime in and can give appropriate reason what's the problem with that.
hey there, what are the fees on deploying on mainnet? especially for updating a program?

my initial deploy was around 5-6 SOL and now when i want to do a very small update (add a better error), it wants to charge me ~2,8 SOL

is anywhere an overview on deploy/update fees?
Is init_if_needed safe to use? I remember reading something about it being deprecated
the problem is that when I re-run the same function, I get an error saying something like ``` Allocate: account Address { address: 5YRmcepTnePenofZJX9uRGCCRWZVmhMrMu3si4XBjVPr, base: None } already in use ```
how to get the program id of current program?
Is there any reference for a minting NFT contract written in Anchor?
which can be invoked from native solana program
something like program::cpi::instruction constructor
is there a codegen for instructions based on anchor accounts
Hi, how can i invoke anchor program from within native solana program?
Why is providing the bump target with init not allowed anymore?
Thank you üòÑ
Nope, only the program from which the PDA is derived can sign for it. So program A can sign for addresses derived from program A, but not PDAs derived from program B even if you know the seeds+bump.
Can I use PDA as signer of invoke_signed in other programs, if seeds and bump are known?
the answer is yes. it won't compile if they are in the same module because the macro expands to the same enum name. if you namespace them separately, the numbers will collide, so you should specify different numbers for each enum. the idl will only get errors from one of the enums
what happens if you declare multiple enums with #[error]. will the error numbers collide?
Anchor always assumes accounts are initialized, unless you are initing from the program.
Could be wrong but I think specifying `init` in the account constraints is the canonical (and therefore safest?) way?
Hi! What's the safest way to check if an account (pda) is already initialized and only allow it if it isn't yet?
worked üéâ
let me try updating, i'm pretty behind!
also, thanks üëç appreciate the help
what version of anchor are you on?
before this line I also have the following:
```
import { Program } from '@project-serum/anchor';
import { Bridge } from '../target/types/bridge';
```
which, looking at it now, feels like a bit of a bodge, but hey it works
anchor.Program isn't a generic, no? casting to program gets me the basics, but wondering if i can lock down to my idl
also slightly tricky thing I'm grappling with: if I want to pass an account to Program 1, which will invoke Program 2 via CPI which is responsible for init-ing the account, do I use UncheckedAccount in Program 1, or Signer? As far as I can tell, I'd ordinarily need the account to sign the instruction to Program 2 if I was invoking it directly, but I can't seem to get it to work via CPI


///////////////////////////////////////////////////////////////////////////////////////////////

I kept getting a `writable privilege escalated` error on the `payer` account passed in (https://discord.com/channels/889577356681945098/889577399308656662/940661032328761484)

did you manage to mint an nft this way?
this worked btw, thanks man ü§ú ü§õ
oh interesting, why was it failing?
btw let me know if you manage to CPI a `MintNFT` instruction, I tried yesterday and couldn't get it to work
I see. The problem is that the program is called `NftCandyMachineV2` and not `CandyMachine`. So just do:
```use mpl_candy_machine::program::NftCandyMachineV2```
(see here https://docs.rs/mpl-candy-machine/latest/mpl_candy_machine/program/index.html)
I'm trying to CPI it - the same way eg I'd CPI my own program (this throws no error):
 ```rs
use gem_bank::{self, cpi::accounts::SetVaultLock, program::GemBank};
```
why are you trying to access the `CandyMachine` struct? as shown on your screenshot, it's private
any thoughts on this anyone? üôè
it did work, thanks!
oh actually that probably won't work if you're using 0.19.0
Try deserializing  the token account directly instead
```pub token_a_destination: Account<'info, TokenAccount>```
as shown in the last example in the documentation https://docs.rs/anchor-lang/0.21.0/anchor_lang/derive.Accounts.html#spl-constraints
and another question - I'm trying to CPI the candy machine and am running into this error:
```rs
use mpl_candy_machine::{self, cpi::accounts::MintNFT, program::CandyMachine};
   |                                                                ^^^^^^^^^^^^ private struct
```

I don't get this type of errors when I CPI the programs I wrote. How do I get around this?
which i think comes in 1.9
we need to wait until we can resize accounts before doing this
running into this after I upgraded from 0.18.2 to 0.19.0
not yet
why might this macro:
```rs
    #[account(init_if_needed,
        associated_token::mint = token_a_mint,
        associated_token::authority = receiver,
        payer = receiver)]
    pub token_a_destination: AccountInfo<'info>,
```

be throwing this error?
```rs
error[E0277]: can't compare `&anchor_lang::prelude::Pubkey` with `anchor_lang::prelude::Pubkey`
 --> programs/transmuter/src/instructions/execute_mutation.rs:6:10
  |
6 | #[derive(Accounts)]
  |          ^^^^^^^^ no implementation for `&anchor_lang::prelude::Pubkey == anchor_lang::prelude::Pubkey`
  |
  = help: the trait `PartialEq<anchor_lang::prelude::Pubkey>` is not implemented for `&anchor_lang::prelude::Pubkey`
  = note: this error originates in the derive macro `Accounts` (in Nightly builds, run with -Z macro-backtrace for more info)
```

I don't see where I'm referencing a &Pubkey...
ya using `close =` and then another instruction with `init = ` in the same transaction says account address still in use
Yes so I think I found the issue. The account is on mainnet but the connect im running my tests on is local net. Do you know how to force the program ID of the trasaction.
Do you have a piece of code we could look at? I assume you‚Äôre taking about initialising / closing PDAs?
does anchor not allow for closing and then init in 2 subsequent instructions in the same transaction?
Yes, you can use the `getSignaturesForAddress` RPC call (https://docs.solana.com/developing/clients/jsonrpc-api#getsignaturesforaddress or https://solana-labs.github.io/solana-web3.js/classes/Connection.html#getSignaturesForAddress)
list of last interaction between an account and the blockchain
and do you know if there is a way to see list of transactions of an account ?
Not that i'm aware of unfortunately, you can't query the blockchain from inside a program. Basically, all you have access to within the smart contract is the accounts you passed as inputs
I wanted to use anchor_client to ask the blockchain in the smart_contract
really ? üòÖ  is there a way to recup a transaction informations on the blockchain by passing the tx ?
This is the address of the System Program. Are you sure you're passing the correct accounts? Showing your code would make it easier for other people to help
I'm not sure what you're trying to do exactly, but this is a *client* crate. That means you can use it to communicate with the solana blockchain (e.g., check if a transaction completed successfully), but you can't use it to run anything on the blockchain itself (ie you can't use it inside smart programs)
Hi. Is it posdible to retreive partial data from the account? For example, I request bytes from the 5th to 15th
Should not be address map program but instead Serum Dex Program as owner.
Trying to use remaining accounts to load Serum Market Accounts. For some reason the owner id is incorrectly shown as 11111111111111111111111111111111 in my program. Is this a bug?

Hi guys ! Is this working in a Anchor smart contract ? Rpc calls to solana node
I'm trying to close the mint itself! (account type 'Mint')
Are you closing the mint itself or the token account with that mint?
Is the above at least roughly the correct to close a token MINTING account?
Hey! I‚Äôm trying to close a minting account. However, I‚Äôm getting an ‚Äúinvalid account data for instruction‚Äù error. Is there anything wrong with the code below, or is the problem hidden somewhere else? (The program ‚Äúworks‚Äù when that section is commented out.)
```
      let signer: &[&[u8]] = &[&my_key, &[bump]];
        anchor_spl::token::close_account(
            CpiContext::new_with_signer(
                ctx.accounts.token_program.to_account_info(),
                anchor_spl::token::CloseAccount{
                    account: ctx.accounts.my_mint_account.to_account_info(),
                    destination: ctx.accounts.owner.to_account_info(),
                    authority: ctx.accounts.my_mint_account.to_account_info(),
                },
                &[&signer[..]]
        ))?;
```
Hmm so does this mean without the bug in the candy machine, this CPI should go through? Does the signature from the user gets included in the CPI then? So as soon as the user signs its account, we get the write lock on the `user` for the tx and other programs called from the program that the user interacted with are free to write to that as well? I guess my understanding of accounts isn't good enough!
Surprisingly easy to forget this + then it leads to very confusing behavior lol
Ah, no! This is actually a pretty common gotcha‚Äîyou need to be pretty careful to make sure you've re-run `anchor build` before `anchor deploy` if you make any changes
oh, thx, I thought that 'deploy' automatically rebuilds the code if there're any changes
Hmm, the code you posted actually looks fine, so I wonder if you somehow deployed a different version etc.?
Thanks for the explanation! For this one I suggest to put it in the doc. I was reading the doc and didn't quite understand what is the re-initialization attack then I searched the Discord to get the answer.

Hello everyone, I was trying to run some basic examples and stumbled upon the following error:
Thanks <@!134416332509675520>
Yeah that's what I suspected. Good job I just updated deps and got this warning, otherwise would have been open to this.
Just to explain the re-initialization issue: what you definitely don't want to do is use `init_if_needed` and then inside your instruction function do `ctx.accounts.whatever.important_value = INITIAL_VALUE;`. If you pass in an account that has already been initialized then you just overwrote whatever its `important_value` was.
Yep
This should be safe?
e.g.
```
/// This is where we'll store the borrower's token
#[account(
    init_if_needed,
    payer = borrower,
    seeds = [b"escrow", mint.key().as_ref()],
    bump,
    token::mint = mint,
    // We want the program itself to have authority over the escrow token
    // account, so we need to use some program-derived address here.
    // The escrow token account itself already lives at a program-derived
    // address, so we can set its authority to be its own address.
    token::authority = escrow_account,
)]
pub escrow_account: Box<Account<'info, TokenAccount>>,
```
You mean like `token::mint` ? You'll have to actually, since anchor will need them in case the init *is* needed
Ok, will go with this suggestion then! With token accounts is it advisable to add constraints?
Yup. I renamed it `user` here https://discord.com/channels/889577356681945098/889577399308656662/940662685861818390, but it's essentially the wallet signing the tx and being passed as `payer` in the CPI call
Ah, ok‚Äîare you positive you're looking at the right account then?
I thought so too - but then how come the CPI is failing? The `payer` is still the account signing the tx, and it's also been marked as `mut`
I only ever use `init_if_needed` for third-party accounts, e.g. a token account, since there's no way I was initializing it in my own code
The protection just consists in not re-initializing something üòõ
Lots of `init_if_needed` questions today. Are there any docs covering how to protect from reinitialization attacks?
This is an annoying gotcha, so I understand how they might have forgotten to mark it as mut
I think the issue is that the `payer` is usually the wallet sending the tx, which is automatically mut since it pays the tx fees
What's blowing my mind is that this instruction doesn't fail https://github.com/metaplex-foundation/metaplex/blob/master/js/packages/candy-machine-ui/src/candy-machine.ts#L424
Ok, thanks!
If you want to use multiple PDAs you'll need to have multiple distinct seeds.
Just to keep the terminology straight, an ATA is an associated token account/address. What you have there is a regular old PDA, a program-derived address.
Yeah that's what i was thinking too
But that's annoying, definitely a bug in candymachine‚Äîthey should be marking the payer as mut
Ah, interesting, I think I actually ran into this too at one point ü§î
Hey! The typical way of making an ATA is to do: ```let [atAccount, bumpAta] = await anchor.web3.PublicKey.findProgramAddress([pdAccount.publicKey.toBuffer()], program.programId);``` But what if I need a second ‚ÄòatAccount‚Äô? Is there an increment somewhere?
I've noticed something else that might be at the source of the problem. In the `mpl_candy_machine` program that my program is calling, the `payer` account is *not* marked as `mut` (https://docs.rs/mpl-candy-machine/2.0.1/src/mpl_candy_machine/lib.rs.html#702). So you'd think it doesn't require to be mutable. Yet the CPI call fails with a `writable privilage escalated` error about that account.
Ok so this is what I'm confused about - it *is* marked as `mut`
That error does indeed mean that you forgot to mark some account as `mut`
Even more bizzare, it seems my on chain data is not overflowing, and is actually accurate. Any guidance as to why the data is off when I am testing would be massively appreciated


///////////////////////////////////////////////////////////////////////////////////////////////

