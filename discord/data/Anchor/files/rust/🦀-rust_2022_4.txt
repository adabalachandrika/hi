i want to know those versions
solana-cli, anchor-cli, rust?
<@!134416332509675520> which version are you using?
thanks
and i can use 1.57
<@!134416332509675520> i have installed 1.57
`rustup toolchain install 1.57` or something like that
https://rust-lang.github.io/rustup/concepts/toolchains.html
i want to install 1.57.0
i have tried several times
<@!134416332509675520> but this script install 1.59.0
Got it, thanks. I'll use 2 different fields, each one being under a mutually exclusive feature. It does work afaik.
https://rustup.rs/
So to restate that, the IDL isn't generated by the macro‚Äîit's generated by a whole separate program, the anchor cli
i want to install 1.57.0
how to install specific rust version?
Hence the brittleness
Right, I'm saying that IDL generation happens at a totally different time, by the anchor cli‚Äîit literally just tries to parse your code
<@!134416332509675520>  I think that the `cfg_attr` resolution happens before the proc-macro one. Your IDL generation seems to work well, because if I add some faulty code (ie 2 `mut`), your macro returns an error as expected.
Is there some debug feature that I can use to see what your macro takes as an input? I may discover why it behaves like that.
cfg_attr
You're flying too close to the rust sun there unfortunately‚Äîthe IDL generation is not super sophisticated, so I doubt it's able to understand that cfg_attr stuff üòî
I tried to add 2 `mut`, but it says ‚Äúerror: mut already provided‚Äù. So it's correctly parsed.
But when I don't use `cfg_attr`, it is `"isMut": true`.
The IDL indeed says:
```json
        {
          "name": "userPoolTokens",
          "isMut": false,
          "isSigner": false
        }
```
I have a weird error. This
```rust
#[cfg_attr(feature = "liquid",
    account(
        mut,
        associated_token::mint = pool_mint,
        associated_token::authority = user,
    )
)]
#[cfg_attr(feature = "plain",
    account(
        mut,
        seeds = [pool.key().as_ref(), user.key().as_ref(), USER_SPL_TOKEN_SEED],
        bump = params.user_spl_tokens_bump,
    )
)]
pub user_pool_tokens: Box<Account<'info, anchor_spl::token::TokenAccount>>,
```
throws `Error: 2000: A mut constraint was violated` when I run with the `liquid` feature active;
But if I only write:
```rust
#[account(
    mut,
    associated_token::mint = pool_mint,
    associated_token::authority = user,
)]
```
It works fine. Do you have any idea why? It should be semantically equivalent.
anchor lang v0.22 dependency error
Honestly I think in general you'd have to just manually write the frontend deserialization code (üôÄ, lol). Or figure out if you could re-align your fields in the struct so that they end up matching what borsh would do (I'm super fuzzy on alignment issues, I'll do some reading)
Any tips on workarounds?
but that 20% is kind of a deal breaker
It's like 80% correct. lol


///////////////////////////////////////////////////////////////////////////////////////////////

30
anybody know the rough max number of accounts you can update in one transaction?
This looks good: https://crates.io/crates/chronoutil
Can anyone recommend a crate for datetime parsing? I want to take a `unix_timestamp` and calculate timestamps for the 5th of each month for the next three months.
i guess the term is byte casting not actually sure , since isnt casting is used in the context of changing the type of data for instance type cast (int) 5.0, so what is byte casting then ?
btw have you found any proper resources yet on the topic of zero copy, want to know bytemuck actually does this and what prequisites it requires from that data.
Bytemuck literally just goes "I hope this data you've pointed me at looks like a T..."
https://github.com/project-serum/anchor/blob/master/lang/src/accounts/account_loader.rs#L165
Since that's just how zero_copy/bytemuck works‚Äîyou point it at some data location/pointer (in this case, in that weird part of solana that's neither stack nor heap) and hope it looks like the struct in question ü§û
ya i get that but ,  why is this ```Because you need those bytes to look exactly like the struct would look like if it were on the stack``` why is it important it should look like as if it was on the stack ? its just a memory region how does it changes the way byte casting would occur ?
Yeah, the actual data in a vec lives in the heap
so basically the vec part would only be a pointer in the stack to a somewhere in the heap ? not the actual data
Because you need those bytes to look exactly like the struct would look like if it were on the stack or whatever‚Äîso if there's a Vec in there, it the part on the stack is (handwaving, amongst other things) a pointer... to where?
interesting , i dont understand though, using bytemuck u get a view over certain length of bytes and cast them to the struct u want hoping the bytes completely align if so why is there a heap restriction ?
i meant i can likke say a[i] = new value right , that is all i require
For a fixed length array you can't exactly remove things, but you could, say, "remove" a key by setting it to `Pubkey::default()` (assuming that the zero pubkey otherwise isn't a valid key for your use case‚Äîit's the system_program's id)
Can't use Vec in a zero_copy account (vecs store their data on the heap)
reason am asking between fixed array and vector is also becasue i want it to be zero copy compatible i remember reading somewhere vectors are not zero copy compatible can you also explain is this is the case and why ?
can any one explain the difference between let mut x =5 and let x = &mut 5 ?
if not would i need to use a vector ?
if i want to store an array of addresses in an account imagine them as sort of validators, and in future i want to remove or add more validators let say i always keep a fixed amount of validators i.e 3 so a fixed sized array can add remove ?


///////////////////////////////////////////////////////////////////////////////////////////////

Yeah, think that's how you'd have to do it (and that's just how rust decided to do modules, I agree it looks a little weird)
xD its weird why do i have to write mod error and then import it from it, is this how its normally done ?
declare errors in a file named errors.rs then in my lib do ```mod error;
use error::my_errors;``` ?
i wanna achieve the following, declare my errors in a file named error.rs and use those error in my lib.rs files, not sure what is the idiomatic way to do this ?
Can read the rather gory details here: https://docs.rs/uint/latest/src/uint/uint.rs.html#478
You just have to re-implement all the math stuff you care about for your new struct
yes they are , i will prolly have to do the same thing so a u192 is a safe choice, also kinda curious if the language only has builtin support for 128 bits how do you make a type which takes 192 bits .
So they're doing some math and don't want to overflow (so they give themselves a bunch more space)
Probably because they're later multiplying that timestamp by some other numbers: https://github.com/step-finance/reward-pool/blob/071f67e5e82a5a5b10eebf8e7ebdfc9706025475/programs/reward-pool/src/calculator/pool_v2.rs#L29
was tryin to implement my version of staking which also uses timestamps and was refrencing this for best-practices.
https://github.com/step-finance/reward-pool/blob/071f67e5e82a5a5b10eebf8e7ebdfc9706025475/programs/reward-pool/src/calculator/pool_v2.rs#L22
You might want to use a u128 or u192 for some other usecase though
An i64 is plenty for a timestamp, yes
so conclusion is a i64 is more than enough ? weird i saw ppl use spl math u192 so still curious in what case would that be a better choice.
i meant the range for instance  a u8 is from 0-256. a i8 is -127-128
The number is how many bits are used, so u64 and i64 both use 64 bits = 8 bytes
No, it's the same size as a u64
Timestamps on solana are in seconds, and 64 bits worth of seconds is a *lot* of time: a year is very close to 2^25 seconds, so 64 bits of seconds is about 2^39 years = half a trillion (the entire universe has only been around for about 15 billion, lol)
so a i64 is basically the same size as a u128
Unix timestamps on solana are i64s (64 bits, but signed since timestamps can be negative), so even smaller than a i128
It's just an even bigger type (192 bits versus 128)
if i am playing around with unix timestamps, do i need u192 or a u128 is fine ?
seen ppl use u192 which comes from the spl_math library, what is it ? and in what cases would you need to use U192 ?
you could try `init_if_needed` https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html in new version of Anchor it is behind a feaure flag, just check ehre


///////////////////////////////////////////////////////////////////////////////////////////////

I think you're right, you won't be able to use the lifetime at all in your signatures if you use `'_` (I actually didn't even know that that worked haha)
it works like `Account`. so not the executing program but the program its payload was defined in
I assume that's what this line of code is doing? https://docs.rs/anchor-lang/latest/src/anchor_lang/accounts/account_loader.rs.html#122
Does Anchor `AccountLoader` check to verify the account being passed is is owned by the executing program?
any rust ninja could help out with this ^
if i do something like 
```impl<'a> TypeA<'a> {}``` this way i can use the life time in my function signatures right ? but if i do ```impl TypeA<'_>``` compiler would infer the life time but i wont be able to use the lifetime defined by my struct in my function signatures ? Or am i  wrong and i can just use `'_` in my function signatures too and it would link to the anonymous life time i used in my struct `impl TypeA<'_>`
error is coming from pebkac <:PES_Facepalm:838743826784845874>
is this error coming from anchor or solana itself <:thonk:551296478295883777>  never seen it before  `Program log: ProgramError occurred. Error Code: InvalidArgument. Error Number: 8589934592. Error Message: The arguments provided to a program instruction where invalid.`
thanks, for the explanation.
but you shouldnt use `ok_or` in the first place and should just use `unwrap` instead because a `bumps.get` call should never fail
`ok_or` wraps `Err` around its argument so you shouldnt use `Err` yourself
ya am confused  because ```let bump = *ctx.bumps.get("xyz").ok_or(xyz::Test_error)?;
``` 
this works but ```let bump = *ctx.bumps.get("xyz").ok_or(Err(error!(xyz::Test_error)))?;``` does not.
Just try it and see if the compiler complains
You can do whatever you want üßò‚Äç‚ôÇÔ∏è
no just curious, because the changelog says u have to use Err(then an error macro(then your error))
How is that related to the syntax question you were asking above though?
```        let bump = *ctx.bumps.get("xyz").ok_or(xyz::Test_error)?;
```
Can you show me the syntax you used?
that is why am confused üòõ
i just did and it works...
No üòõ
?
there is this weird syntax in the change log i dont understand , `Err(MyError::SomeError.into()) to Err(error!(MyError::SomeError))` can i not just do `Err("my_custom_error)`
`ctx.bumps.get` should never fail in a correct program
Unwrapping is probably fine though because if the bump isn't there then that means *you* made a mistake in your program, not the client, since you must have misspelled the name of the account etc.
https://discord.com/channels/889577356681945098/889584618372734977/963173004089622609
not sure but i want to unwrap but if that fails pass in a custom error i made using #[error_code]
Yes
this makes sense if my function was expecting a option only then would it have had been fine.
It works on multiple different types
the link i sent is using ? on options , which is why am confused.
Which of course won't work if the surrounding function expects a Result
It also short-circuits, but in this case it will early return None
Rust can't do that automagically for you since it won't know what to provide for the Result's error value
i know it does that for results, not sure what it does for Option i heard it returns None if the value is None
The point is that if you short-circuit on an Option, you *still have to return a Result*
The ? short-circuits and early-returns
Not if the ? happens!
but am already returning a `Ok(())`
https://doc.rust-lang.org/rust-by-example/error/option_unwrap/question_mark.html
For the return type, yes (though that won't work for other reasons lol, since the function is supposed to return a Result)
aha if i had the type as Option `?` would have had worked ?
The ? short-circuits on the unhappy path.
`let maybe_bump = ctx.bumps.get("hmm");`
Then you would just not use the ?.
am just curious that if am storing the value in a variable ? should evaluate to None if its Option::None
What do you mean? What kind of issue are you worried about?
Think of it this way: if you  ? on a None, you still need to return a Result from the surrounding function. But what error value will you use?
`pub fn initialize(ctx: Context<Initialize_xyz>) -> Result<()> {
        let account = &mut ctx.accounts.xyz;
        // let bump = ctx.bumps.get("xyz").unwrap_or(&1u8);
        Ok(())  }`
 what is the issue
Or just unwrap it.
You would have to do something like `ctx.bumps.get("xyz").ok_or(SomeError)?;`
The ? short-circuits, so doesn't matter
not returning it
yes but am storing that in a variable
Because your instruction functions return `Result` types, not `Option`s like what `ctx.bumps.get` returns.
This is weird , `let bump = ctx.bumps.get("xyz")?;` 
 gives me the error that you cant use the question mark operator why is that as per the rust doc , one can use the `?` and if the value is Some(test) it returns test if not it evaluates to None, if so why is it not working in my anchor program ?
any down side to setting rust edition to 2021 ? will it break stuff in anchor ?
in my account validation struct the visibility specifier should be public or not ? what would be the repercussions if i did not use the pub keyword, would i then not be able to use anchor cpi abstraction ? for example ```pub struct Initialize<'info> {
pub account : Account<'info,test>
}```
VS
```pub struct Initialize<'info> {
 account : Account<'info,test>
}```
any reason to not use "seed".as_bytes() over b"seed".as_ref()  ?


///////////////////////////////////////////////////////////////////////////////////////////////

So using size of will make it Incompatie with borsh generally  if there is padding involved ? Since borsh ignores padding
size_of returns the size of the type in rust (like, how big it would be on the stack), which is not necessarily the same thing as how much data borsh would use for it (it is however how much space zero_copy needs, since zero_copy doesn't use borsh)
What is the downside of using size_of::<my_struct>() to calculate the space required for the account ? Because generally ppl just calculate each individual cost of each field In a struct and add 8 to the individual accumulation of all the field size and set that as space , ignoring the padding where as size of will include padding so what is the reason size if is not used, because realistically do you not need to calculate the total space your account will require including the padding ?
By doing basically what I suggested above (try it and see!)
in a case where there is concern that A and B might drop to 0. decimals how do i handle it do i come up with a certain number of decimals to multiply A and B by to ensure they never drop to 0 but then in my calculation how do i offset this multiplication to save it from going to 0. decimals to ensure result is correct ?
But basically do `(3 * A + 7 * B) / 10` (pseudocode)
Do you mean 30% and 70% there?
hey without using floats how do i achieve the following logic, i have two uints each of which contribute some % to the final amount
let say final amount is 0.3% of current price of asset A + 0.7% of current price of asset B, but obv we cant use floats so how is this percentage stuff handled in solana/anchor is what the main question is.


///////////////////////////////////////////////////////////////////////////////////////////////

Here is an example
```
    #[account(
        init,
        seeds = [meBoxSeed.key.as_ref()],
        bump,
        payer = authority,
        space = BoxBox::LEN + 8
    )]
    boxbox: Box<Account<'info, BoxBox>>,
```
yus, you can use `Box<>`
<@!134416332509675520> can I not use Box for accounts that are being init'd
Do this or some bullshit is gonna happen ^
https://stackoverflow.com/questions/51336147/how-to-remove-the-win10s-path-from-wsl/63195953#63195953
Thank you!
I'll try WSL method
So it really is broken.. üò¶
ubuntu
would recommend WSL
Windows is really broke
https://github.com/solana-labs/example-helloworld/issues/164
Hi everyone, does anyone know how to deal with the solana-test-validator not installing with Solana exe for windows?
Is the reason no one has done C# or other languages is the overhead?
So anything can compile into BPF?
https://docs.solana.com/developing/on-chain-programs/overview#stack
Each frame is 4kb
Whats the call stack size limit?
got to liquidate some jpegs to pay for bpf loader lmao
alright üôÇ
Sure
Like the token accounts, mint accounts, auction account?
Box moves stuff to the heap (relieving stack pressure, which is the issue you have above)
And it will fix the error, usually
No, just a few
Does this fix the issue or just do better error reporting?
I'm sure you've answered this a hundred times
Box around every account?
Just try doing `Box<Account<'info, Whatever>>` a few times (can search the discord, this comes up a lot)
```
#[derive(Accounts)]
pub struct CreateAuction<'info> {  
    #[account(init, seeds = [b"auction-5".as_ref(), seller.key().as_ref(), token_mint.key().as_ref()], bump, payer = seller, space = 512)]
    pub auction: Account<'info, Auction>,
    #[account(mut)]
    pub seller: Signer<'info>,
    #[account(
        init,
        seeds = [b"token-seed-5".as_ref(), seller.key().as_ref(), token_mint.key().as_ref()],
        bump,
        payer = seller,
        token::mint = token_mint,
        token::authority = escrow_auth,
    )]
    pub escrow: Account<'info, TokenAccount>,
    #[account(constraint = escrow_auth.key() == Pubkey::find_program_address(&[&seller.key.to_bytes()], &program_id).0)]
    pub escrow_auth: AccountInfo<'info>,
    #[account(
        constraint = item_token_account.owner == seller.key() @ErrorCode::NotAuthorized, 
        constraint = item_token_account.amount == 1u64 @ErrorCode::AmountZero,
        constraint = item_token_account.mint == item_mint.key() @ErrorCode::ItemMintMismatch,
    )]
    pub item_token_account: Account<'info, TokenAccount>,
    pub token_mint: Account<'info, Mint>,
    pub item_mint: Account<'info, Mint>,
    pub system_program: Program<'info, System>,
    pub token_program: Program<'info, Token>,
    pub rent: Sysvar<'info, Rent>,
}
``` 
Anyone see anything crazy?
oh pls no
```
> Program returned error: Access violation in stack frame 5 at address 0x200005ff8 of size 8 by instruction #1255
```
is there a way to decode solana instruction data to an anchor instruction? sort of like how I would use mpl_token_metadata::instruction::MetadataInstruction::try_from_slice() to decode a token metadata instruction


///////////////////////////////////////////////////////////////////////////////////////////////

No, not yet‚Äîbut soon lol, it hasn't been rolled out yet
is there any way to do that ? it will be help full :/. Is it enaugh to jus add sol to account?
Not quite yet, but soon ‚Ñ¢Ô∏è
is it posibe tu set on init lower space and later add the space?
Yes, but you'll need to manually set aside enough `space = ` for it in the `init`
is it possible to store a vector (without specific size) in
# [account]
# [derive (Default)]?


///////////////////////////////////////////////////////////////////////////////////////////////

solved
hi how to pass array to our contract ([data1, data2]) and then use it us vector
Thanks a lot! Please do share if you find it
Not sure where I put it, but you could definitely just hardcode this stuff if you wanted
Yeah, good question‚ÄîI wrote a little `find_program_address!` macro for this usecase, where you know the seeds at compile-time and want to find the address at compile-time too
This PDA does not store anything, its only use is to sign outbound token transfers. Deriving the address each time with `Pubkey::find_program_address(&[], &cyclos_core::ID)` would be inefficient
Is there a precedent on hardcoding PDA addresses and bumps? I have a global PDA with `seeds = []`. Since we already hardcode the smart contract address, how about pre-compute and storing the PDA too?
Thanks, it was that simple üôè
Nope, you'd have to pass in the desired destination account from the client
what i'm trying to implement is to transfer lamports from program's owned account to one of the pubkeys(randomly) saved in program's pda, without that user of pubkey to initiate the rpc call, is that possible?
No, can't store AccountInfo's on chain (doesn't really make sense, the best you can do is just store their addresses)
Hi guys is it possible to store a vector of AccountInfos in PDA's data field?
At any rate, you can fix the error above by being explicit about the lifetime parameters, usually something like
```.rs
pub fn your_instruction<'info>(ctx: Context<'_, '_, '_, 'info, YourContextThing<'info>>)
```
Mm, yeah, I'm actually not sure what would happen if you made those the same lifetimes. It would be more restrictive (the current version is more general), but maybe that would be fine
I'm pretty sure I'm not the first one to hit that error.
For information, the code looks like that:
```rust
invoke_signed(
    &merge,
    &[
        ctx.remaining_accounts[0].clone(),
        ctx.remaining_accounts[1].clone(),
        ctx.accounts.pool_authority.to_account_info(),
        ctx.accounts.clock.to_account_info(),
        ctx.accounts.stake_history.to_account_info(),
        ctx.accounts.stake_program.to_account_info(),
    ],
    &[&seeds_authority[..]],
)?;
```
And the error message:
```
error[E0623]: lifetime mismatch
  --> programs/solana-pool-plain-staking/src/instructions/x_update_validators.rs:72:17
   |
41 |     ctx: Context<UpdateValidators>,
   |          -------------------------
   |                  |
   |                  these two types are declared with different lifetimes...
...
72 |                 ctx.remaining_accounts[0].clone(),
   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ...but data from `ctx` flows into `ctx` here
```
I have a function that gets several `AccountInfo<'info>`, some coming from the accounts, some from the remaining accounts. That means that the `'info` lifetime is sometimes constrained by `'b`, sometimes by `'c`. Then, the compiler cannot infer what this lifetime is.
Is there any reason why those 2 lifetimes are different in the `Context` structure?
```rust
    /// Deserialized accounts.
    pub accounts: &'b mut T,
    /// Remaining accounts given but not deserialized or validated.
    /// Be very careful when using this directly.
    pub remaining_accounts: &'c [AccountInfo<'info>],
```
it's causing borrow checker errors when I try to pass account info around.
The data source of those references is the same, IIUC, so the lifetime should be the same
Hello all, I have a question regarding `cpi` , Are there any examples of passing `remaining_accounts` from one anchor program to another anchor program ? Any examples or leads would be really helpful


///////////////////////////////////////////////////////////////////////////////////////////////

Bummer, think you kind of just need to carefully read this: https://docs.rs/bytemuck/1.1.0/bytemuck/trait.Pod.html
Mm, actually maybe you don't always get a compile error, shoot
Do you not just get a compiler error if you try to use something that doesn't work?
any one could help with this ?
Then sounds like you're all good!
Ah, ok
Just having its Pubkey on-chain isn't enough unfortunately, you need the full AccountInfo for it, and that's only possible if you specify it from the client
they will be the ones claiming
If you want to withdraw to some account, you're gonna have to find a way to pass in that specific account
so meaby thats the way
and that one be the one allowed to withdraw
no, i need to store a **winner***
You can store as much as you want in an account (well, up to 10mb), but if you want to actually interact with an account, you have to pass it in from the client
i think i saw some code using u32 for this?
i can store multiples users keys in an account?
No, unfortunately in solana every single account you want to use has to get passed in from the client
ü§î mmm
meaby create a token an give it to each user, representing their value, but again, i need then to see all the holders of a token from the contract side
so there is no way for the contract to find all the pdas in a given contract? i guess i will need to find a workaround to what i was trying to do, cuz i need to calculate probability for a given user, i stored the user id and value in a PDA, i was hoping to read all the PDAS, their users and value, and give a % to each, then run a randomizer (key) to choose one of them
This is unfortunately hard/maybe impossible to do in your smart contract, since in solana you always have to pass in any accounts of interest *from the client*, and you can only fit about 30 accounts max into a single transaction
https://docs.rs/bytemuck/latest/bytemuck/trait.Pod.html
I'm new to rust and cant figure out how, already done this on the front, but need to program to read all the accounts and calculate from that data
Hi, I have a bunch of pdas and I want to iterate and filter the ones that have X values, like the javascript method:   program.account.bank.all(filter), any example code I can go through to do this?
also is there a list of all types that are pod ?
hey guys ppl who have extensively usex zero copy, what is the most intuitive way to tell if the struct am making is compatible with zero copy or not i.e has no padding that is the only restriction right  if not do let me know all the restrictions to keep in mind


///////////////////////////////////////////////////////////////////////////////////////////////

how do you do this with multiple price feeds with different expo, for example 
sol/usdc has exponent of -5
btc/usd has exponent of -8
if price of sol/usdc  is `1500000` this
it basically means its `[1500000,5] = 15.0000
and btc/usd is  = [2000000000,8 ]= 20.00000000
how can i compare both could you explain normalization using this example.
It's funny, I think I'm just weird‚ÄîI find solana to be quite a lot easier than web/mobile/backend dev etc.
when are you getting called on the solana glass eater podcast, out of anyone you have chewed the most glass xD
Honestly I learned how to use them by reading the anchor source code!
btw i have noticed proc macros is very extensively used in rust, any good resources for it, as i find declarative macros hard enough, proc macros are a different ball game,
anchor is like 100% rust proc macros if am not wrong right ?
The drift example was saying that they want to internally use N digits of precision. For sake of example, suppose they always want 6 digits. Then { 123, 2} = 1.23 = 1.230000 = {1230000} with an implied number of digits = 6
99.123 would be 99123 and 3, etc.
So 1.23 is represented as a pair, 123, and 2 for the number of digits
Pyth is sending you a structure that keeps track of a decimal number
i think normalization is the correct approach but i dont understand how drift did it, any elaboration on that would be appreciated üò¶
I was just answering your q about how to divide i64s üòõ
surely that would be very wrong to do with a oracle price xD dont u think
That's what that drift example was doing
No, you can just divide i64s (it will lose the remainder though)
one thing i dont understand is i asked in the pyth discord they said it is possible 2 different oracle account can give different exponents if so , i will need to normalize to a certain standard so i can compare the prices regardless of th exponent, can you explain how this normalization thing works and how can i achieve in a simple intuitive way üò¶
yes but what is the idomatic way to do this to avoid underflow, and wndt doing this way i will have to use floats.
Can you just divide it by 100_000_000?
i cant figure out how to do simple math, 
i want to multiply a i64 with 10 to the power -8  how do i achieve this üò¶
I'm currently having trouble building an anchor crate (including instructions and account structs) that will eventually be included in an anchor program. The ```#[account]``` attribute on the account struct throws an error because there isn't a crate::ID to find since it isn't a program. What's the best way to handle this error? Is there a way to inherit the ID from the including program?


///////////////////////////////////////////////////////////////////////////////////////////////

is it posible to check in "#[derive(Accounts)]" did pda account is already inicialized and do something if not.

For example:
```
#[account(
        init,
        seeds = [b"seed".as_ref()],
        bump,
        payer = sender,
        space = 8
    )]

//if already inicialized try: 

    #[account(
        mut,
        seeds = [b"seed".as_ref()],
        bump
    )]
```
Did anchor support something like this or i have to use 2 separate function for that?
hmm
You can upcast to u128 to make sure you don't overflow
Multiply by 25 and then divide by 100
also how is the percentage stuff done in rust ? let say i wanna charge a fee of 25 % how do i do this without floats ?
Fixed point is just regular old integer arithmetic. It's like when you represent dollars in terms of cents (1 dollar aaactually = 100 cents)
hey , need a bit of help trying to make the mental model of how fixedpoint arithimethic work, am using this library called fixed which is also used by mango, I80F48 means a fixed point with 80 bits for integer and 48 bits for a floating point, can any one explain intuitively how does fixed point arithimethic actually work ? like if i want to process it sort of in my brain i honestly cannot rn.
Yeah, think they just standardized on using 128s for prices/amounts
is it to just be able to handle bigger numbers ?
what abt this
Sure, what I meant was `[the_digits, num_decimals]`
Floating point has some funny properties, as numbers get bigger the *gap* between one floating point number and the next can get bigger too. For example, in JS, numbers are all doubles (floating point) under the hood, and eventually the gap between one double and the next gets pretty big‚Äîbigger than 1 in fact!
```.ts
Math.pow(2, 53) === 1 + Math.pow(2, 53)
```
123/10^2 = 1.23
btw yesterday when we were talking about normalization, wdnt [123,-2] would be more accurate compared to [123,2] the `-` would tell you , u need to divide and `+` would tell you u need to multiply
any particular reason why drift converts the pyth price which is a i64 to a i128 ? 
```
        let oracle_price = cast_to_i128(price_data.agg.price)?;
        let oracle_conf = cast_to_u128(price_data.agg.conf)?;

        let oracle_precision = 10_u128.pow(price_data.expo.unsigned_abs());```
This is actually a pretty good answer: https://stackoverflow.com/questions/7524838/fixed-point-vs-floating-point-number
Lmao üòÜ
any resources on fixed point numbers what they are and why might they be used over floating point ?
Gosh this man keeps pumping his bags
Here's a token escrow that's safe, as far as I know: https://github.com/cqfd/quidproquo
so how to safely store sol in Escrow?
I'm following this page for space allocation https://book.anchor-lang.com/chapter_5/space.html?highlight=space#space-reference
I believe I put enough space for the account data but it still says space constraint violated
And this
Still confused on this
Instruction sysvar allows this if am not wrong
You need to write your program in such a way that guessability isn't an issue
Guessability of seeds isn't a security thing (and yes, they're guessable)
my next question is: is it safe to pass seeds in this way? whether our account will not be hijacked if you can protect yourself against it
is there any way to check from rust did sender already used some function from our contract oj just interact with it before? if no is there any way to track it or write it down?
what is the down size to using aligned am convinced zero copy does not care about alignment as long as there is no padding it works fine i guess ? but then what is the downside of straight up using repr(packed) is there a performance downside for not making ur struct aligned ? for a long time i thought ur struct needed to be aligned and have 0 padding for bytemuck/zerocopy to work
i mean is it necessary, can a normal struct not be a subfield ?
#[zero_copy] defines a type that can be a subfield of a zero_copy account (#[account(zero_copy)])
#[zero_copy]  used repr packed, which strips of the padding but still this would be still unaligned dsnt zero copy require a struct to be aligned ?
also what is the difference between #[zero_copy] and #[account(zero_copy)] ?
saw this in the synthethify repo, 
```#[zero_copy]
#[derive(PartialEq, Default, Debug, AnchorDeserialize, AnchorSerialize)]
pub struct Decimal {
    // 17
    pub val: u128, // 16
    pub scale: u8, // 1
}```
isnt this zero copy wrong ? as zero copy requires there to be no padding, the alignment of the struct is the alignment of the highest type/value which is 16, if so it would only be aligned at addresses multiple of 16, i.e , 16,32,48, since the total size is 17,(16+1), 15 bytes of padding would be added no ? if not where did i go wrong ? what am i missing out on
keep running out of retries
anyone deployed any contracts today, can't seem to get one out üò¶
also this by synthetify is awesome , https://github.com/Synthetify/synthetify-protocol/blob/b7dff93204f5ac63a90222f011ab73fdf15b220e/programs/exchange/src/decimal.rs
, unfortunate its not a crate in it self.
10^9
for example how many lamports make one sol ?
I don't think there's a standard in general (heh, it's like asking "what's the standard number of decimals of a real number?")
for example 1x 10^18 wei = 1 ether
in my values like accurate up to how many decimal places, what is the general idiom regarding this ? also like in ethereum the standard decimal places of token is 18 what is the equivalent in solana ? that way i can set the precison to what ever the standard of decimals is of spl tokens ?
so i need to decide what precison i want
aha so i can choose let say 6 decimal places and if pyth gives me [1000,3] i can make it,  [1000000,6] and if another oracle gives [10000000,7] i can make it [1000000,6] by losing one precison.
With your example here, you could do note that `[1500000,5]` == [15000000, 6] == [150000000, 7] == [1500000000, 8], and now you can directly compare it to [2000000000,8 ]
If they come along and give them 5 decimals, they add a 0
So if pyth comes along hands them a value with 7 decimals, they just chop one off
Drift is just saying "we want to use 6 decimal places, period" (or whatever)
basically trying to do what drift did but also want to understand how did that work out in relation to my example above.
hahaha man am trying to understand how normalization works i dont even know if am making any sense,
In short the goal is to normalize a value such that even if the pyth oracle gives me different exponents am able to normalize them so i can compare those different values.
What have you tried? Looks like you've basically worked out the normalization yourself


///////////////////////////////////////////////////////////////////////////////////////////////

xD
yeah, `Pubkey([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])`
Yeah, default pubkey is all zeros (which confusingly actually looks like all 1s in base58, lol)
show me your client-side code
32 0 ig
just checked and nothing was created due to the error, this really confuses me, and btw for those u8 and i64 types it will give them 0 by default right? what about pubKey types?
umm ok, it generally happens when an account is already init'd  but it has the wrong amount of space
I forgot taking a screenshot of it
You forget to add, extra 8 bytes for anchor discriminator
let me know if I can provide more relevant information. This is new to me so bear with me lol
but yeah, something about `'sys'`
I got it running, but then I added some dependencies to `cargo.toml` and I'm trying to import them in `lib.rs`
I'm using this guide: https://dev.to/edge-and-node/the-complete-guide-to-full-stack-solana-development-with-react-anchor-rust-and-phantom-3291
but I keep getting this error: `file not found for module 'sys'`
I'm trying to build a Solana app with Anchor
yooooooo
why is it saying space violation while I allocate the space correctly?
It just gives you a way to only update the specific things you provide: https://github.com/metaplex-foundation/metaplex-program-library/blob/master/token-metadata/program/src/processor.rs#L248
hey, can u explain, why are this fields tagged as Options not just types they have?


///////////////////////////////////////////////////////////////////////////////////////////////

