ohk will do
Basically yes, but I really think you should re-do the full tutorial, it'll be way more efficient
so i just do? ```
accounts:{
from:fromaddress,
to: toaddress
}```
<@!691933164909756466>
```await program.rpc.voteGif(giflink, {
        accounts: {
          baseAccount: baseAccount.publicKey,
        },
      });``` right now this is how i did it
Any time you pass *any* account you do so by passing its address in from the client, e.g.
```.js
await program.rpc.yourInstructionName({
  accounts: {
    someAccount: itsAddress // <-- these are all addresses
    ...
  }
});
```
I think you should work through the full anchor tutorial if you haven't already, it will help you understand this confusion
and how do you pass an address as an account
You need to pass in both addresses as accounts, from the client
```.rs
#[derive(Accounts)]
pub struct YourInstruction<'info> {
  pub their_account: AccountInfo<'info>,
  ...
}```
i only hv account of the person sending the sol not receiving
You pass it in from the client
but thats the problem how do you get their "account" by their public address
Definitely don't need remaining accounts for this, not sure where you got that from 🤔 You can just pass in their one single account
Still completely unsure what it means or how to move forward testing front end :/
Re: compiling errors caused by imports

I keep trying to specify exactly what file to find exports in, I keep getting that error for a few items, but I am now also getting this project serum error

Compiled with problems:

ERROR in ./node_modules/@project-serum/anchor/dist/browser/index.js 12:0-28

Module not found: Error: Can't resolve 'assert' in '/home/sal/mysolanaapp/app/node_modules/@project-serum/anchor/dist/browser'

BREAKING CHANGE: webpack < 5 used to include polyfills for node.js core modules by default.
This is no longer the case. Verify if you need this module and configure a polyfill for it.

If you want to include a polyfill, you need to:
    - add a fallback 'resolve.fallback: { "assert": require.resolve("assert/") }'
    - install 'assert'
If you don't want to include a polyfill, you can use an empty module like this:
    resolve.fallback: { "assert": false }


ERROR in ./node_modules/@solana/wallet-adapter-react-ui/lib/WalletConnectButton.js 29:6-15

export 'useWallet' (imported as 'useWallet') was not found in '@solana/wallet-adapter-react' (module has no exports)
but didnt get anything useful
i went thru the docs and tutorials
u said something abt reamining accounts
i want to send sol to another person using their public address
What's going wrong so far?
What part? What are you trying to do?
<@!134416332509675520> hey cn u explain how to get remaining accounts
nobody seems to have the same error as me for something as simple as importing wallet adapters
noob question since I keep getting this node module export  not found error... should I delete the node modules from my ./app directory, or is it using that one and not the node modules in the root?
ok - checked with the metaplex people - just to tie this up -- they generate a new keypair for the new mint -- so I guess then they use that "temp" keypair to transfer everything
Whats the best way to go about transferring lamports with a program? I looked into the example on the solana program library, but can't seem to interact with it from a client without errors.
Ok thanks for the reply. I will change the design,
You can't transfer account ownership unfortunately (it can only happen once, from the system program to some other program)
Hello, 
I have a question about program address. I have a program address which was created by program A. But it is really modified in program B. As it is created in program A, program B cannot really modify it as it is not owner of this address. How can i transfer ownership to program B. I tried it with SetAuthority but it seems it needs a signature of programA even if i am in program A while setting ownership. Am i missing something?
or use some kind of "program key" in the client - which would obviously be a bad idea
ok -- so an alternative I guess could have a program mint them via cpi -- that seems fine since yeah - the client doesn't really need the mint - just the token that comes out it
Yeah, I'm not sure (not v familiar with nft stuff), but I would be surprised if your client could just directly mint an nft
i could be doing it wrong - i'm trying to kind of copy the approach of "editions" that metaplex uses -- where each "edition" of an NFT is another mint and another token -- so I assumed that new mint would be owned by the holder of the "master" edition of the NFT
Mm, who has authority over the mint? It would be odd to be able to directly mint new tokens straight from the client, since that mean the client would have to have authority over the mint
ok that makes sense -- is what i'm trying to do impossible?  i.e. i want to let people mint new NFTs off an NFT they have -- or you are saying i need to call the underlying token program directly via lower level signing of a transaction with the wallet?
like one contract deploying many subcontracts
How do i implement factory contract in anchor
No, nothing is off with the way you're using the wallet, the issue is just that you can't get access to a wallet keypair in general (eg in the browser phantom will *never* give you the keypair)
the createMint code again :
`  let mintAccount = await spltoken.Token.createMint(
    provider.connection,
    userKeypair,
    userKeypair.publicKey,
    null,
    0,
    spltoken.TOKEN_PROGRAM_ID
  );`
and ended up with a mint on devnet - https://explorer.solana.com/address/H3QaBncWUqweyS4gja5LYMtSKvWzKPSjRU8FrV6xiKBr?cluster=devnet
i..e rather than use the wallet I did this:
`  //let userKeypair = wallet;
  let userKeypair = web3.Keypair.generate();
  let fromAirdropSignature = await provider.connection.requestAirdrop(
    userKeypair.publicKey,
    web3.LAMPORTS_PER_SOL,
  );
  // Wait for airdrop confirmation
  await provider.connection.confirmTransaction(fromAirdropSignature);`
actually the code seems to work if I generate a new keypair right before calling it -- so I guess something is off with the way I'm trying to use the wallet I think.
I guess I am a bit lost on the logic behind which account is the one the program sees as "Given" in my code, and how I can verify it is owned by the executing program (which I assume is just the pubkey I put in declare_id)
aand it seems to succeed
i will do that now that test passes
Ok, so you have an explicit `anchor deploy` step?
i just started spamming anchor test and build until test passed, but I truly don't understand why.

To answer your question <@!134416332509675520> I am runnign my tests against a local validator
Makes sense. That's what I thought
E.g. what does `lsof -i :8899` say?
Or are you letting `anchor test` spin one up for you?
Are you running your tests against a running solana validator?
anchor test after build
at what point are you getting this error?
something about a caller and callee, what I am wondering though is if the pubkey I put for declare_id is the same one I Have in program-logs, why am I getting this error?
So I am getting an error when I test saying "The given account is not owned by the executing program", I went through discord but others came to solutions that I didn't understand
With my understanding, no
is there any way to get account info with pub key in the program itself
gotchu
It's actually a bit annoying, for a variable number you'll have to use `remaining_accounts` (try searching the anchor repo for examples)
prolly a dumb question but how do i accept an array of accounts in a func?
v0.19, and there are just more of them as far as I know
And my real question is why? (Not why, I’m pissed I have to learn new error codes, but why, strictly a curiosity)
Hey, dumb question, but when did the error codes change from ~300 to ~3000
yep, gotcha
You will have to pass those accounts in from the client
how do i make it so that i can capture accounts which i can later transfer tokens to
so the array im accepting while deploying, it was a list of addresses
gotchu
Having just a pubkey isn't enough
Ah, no, in solana you always have to pass in any accounts you want to use
how do use just the pub key of someone to transfer them sol
```pub fn send_sol(ctx: Context<SendSol>, amount: u64) -> ProgramResult {
        // Get a reference to the account and increment total_gifs.
        let ix = anchor_lang::solana_program::system_instruction::transfer(
            &ctx.accounts.from.key(),
            &ctx.accounts.to.key(),
            amount,
        );
        anchor_lang::solana_program::program::invoke(
            &ix,
            &[
                ctx.accounts.from.to_account_info(),
                ctx.accounts.to.to_account_info(),
            ],
        )
    }```

here, when invoking, i don't have access to `account_info()`
What do you mean?
No, they're just regular rust static vars, right in the program itself
+1
like, the anchor_lang transfer thing asks for account info
How are static variables stored? Are they baked into the program itself? or anchor automatically creates an account for that?
or is it even possible?
also, how do i transfer sol with just the public key?
awesome!
Yeah then by far the simplest thing is to just bake them in
lol no, for now i don't want to change the vars i guess
But if you want to change those variables you can always just redeploy the whole program 😛
It can have *immutable* static variables (no global mutability though)
i see, does the static vars work though?
i'm really new to solana so was confused if the program can maintain state
Easiest way would be to just bake them into your program as static variables
You can initialize an account with the data you want to store, and pass this account pubkey from the frontend to you functions later on
I get the same error
did you find a solution ?
later, access them in rest of the functions. how do i go about it?
hey folks! i want to accept some params & store them while deploying the rust program, like admin pub key and an array with some info.
Awesome. Thanks for helping
The provider is an abstraction over both the connection as well as the wallet—so I wouldn't expect you to almost ever use the connection directly
On a related topic can I ask some more noob questions? In which context would one use the methods in connection and when in provider?
Ohh okay I see.
The connection itself won't know about the provider wallet
Think you actually want to use `provider.send` rather than just using the connection
```  const provider = anchor.Provider.env();
  const connection = provider.connection;
``` to be precise
```const connection = provider.connection;```. Anything unusual here?
Hmm, how have you defined `connection` here?
Stuck on something real noobish. Why would this testing code fail with `Signature verification failed`? `MyAccount` is a super simple account struct containing a single pubkey member
```
    const myAccount = anchor.web3.Keypair.generate();
    const initTokenAccountIx =
      await program.account.myAccount.createInstruction(myAccount);
    const tx = new Transaction();
    tx.add(initTokenAccountIx);
    await provider.connection.confirmTransaction(
      await connection.sendTransaction(tx, [myAccount]),
      "confirmed"
    );
```
oh ok - good luck 🙂
windows subsystem linux. currently trying to reinstall it and start all over
yeah 🙂 you can try it - i don't know if it will help but may give you more clues -- "bongo" is just whatever you called the import - i used bongo to try and be funny, but i realize it might be confusing - sorry
what is wsl?  and what error do you get?
I guess look at the first error and try and resolve that - -and then keep doing that -- i.e. 
`warning: zstd\lib\compress\fse_compress.c:21:10: fatal error: hist.h: No such file or directory` you might have luck googling that -- or looking into "zstd" -- looks like something weird with your rust install -- but im a complete rust newbie and also i run on mac - sorry!  if you are really struggle with windows it might be worth seeing if you can run a virtual linux machine maybe ?  if you are spending weeks might be worth looking into.  Sorry though!
(There's about a 50/50 chance that any such sha256 hash lands on the ed25519 curve)
I think this is easiest to understand by reading the source code for findProgramAddress. A program-derived address is just a sha256 hash under the hood, of the seeds + bump + program_id (plus a fixed string, not important). The purpose of the bump is just to make sure the resulting 32 bytes returned by the hash function *aren't* a valid ed25519 public key.
whenever i try to run `anchor test` it brings me to an error when trying to build  `solana-program` so it fails
hi! im trying to setup anchor and solana on wsl
<@!912046857000194158> <@!134416332509675520> can you suggest me some more advance codes to become more advance in anchor and solana
these are some awsome tutorials for beginers
<@!912046857000194158> <@!134416332509675520> thanks these were awsome tutorials for beginers just finished testing those
Why I even need it?
What is bump in findProgramAddress? Is there any docs about it?
a"type":{"defined":"Hash"}
Would the following code be valid??
```
    // the token account of owner
    #[account(
        init,
        payer = owner,
        associated_token::mint = mint,
        associated_token::authority = owner,
    )]
    owner_token_account: Account<'info, token::TokenAccount>,
```

I'm trying to do this later in the instruction, 
```
let seeds = &[&AUTH_PDA_SEED[..], &[_auth_pda_bump]];
// cpi call to mint 1 token to owner
        let cpi_accounts = token::MintTo {
            mint: ctx.accounts.mint.to_account_info(),
            to: ctx.accounts.owner_token_account.to_account_info(),
            authority: ctx.accounts.auth_pda.to_account_info()
        };
        let cpi_program = ctx.accounts.token_program.to_account_info();
        token::mint_to(CpiContext::new_with_signer(cpi_program, cpi_accounts, &[&seeds[..]]), 1)?;
```

But I am getting this error, 
`'Program 2HHQPmSdaRfhb5vVragacdGhcXFbT3e6cS4ei56J3ZLa failed: Cross-program invocation with unauthorized signer or writable account'`
Please guys I’ve been trying to install anchor on my windows machine for weeks now. I’m stuck here -

The following warnings were emitted during compilation:

warning: zstd\lib\compress\fse_compress.c:21:10: fatal error: hist.h: No such file or directory
warning:    21 | #include "hist.h"       /* HIST_count_wksp */
warning:       |          ^~~~~~~~
warning: compilation terminated.
warning: zstd\lib\compress\hist.c:20:10: fatal error: hist.h: No such file or directory
warning:    20 | #include "hist.h"
warning:       |          ^~~~~~~~
warning: compilation terminated.

error: failed to run custom build command for `zstd-sys v1.4.18+zstd.1.4.7`

Caused by:
  process didn't exit successfully: `C:\Users\HP\AppData\Local\Temp\cargo-installZ5pUrb\release\build\zstd-sys-f7e5dc0bb30787a0\build-script-build` (exit code: 1)

  --- stderr
  error occurred: Command "gcc.exe" "-O3" "-ffunction-sections" "-fdata-sections" "-m64" "-I" "zstd/lib/" "-I" "zstd/lib/common" "-I" "zstd/lib/legacy" "-fvisibility=hidden" "-DZSTD_LIB_DEPRECATED=0" "-DZSTDLIB_VISIBILITY=" "-DZDICTLIB_VISIBILITY=" "-DZSTDERRORLIB_VISIBILITY=" "-DZSTD_LEGACY_SUPPORT=1" "-o" "C:\\Users\\HP\\AppData\\Local\\Temp\\cargo-installZ5pUrb\\release\\build\\zstd-sys-302cf417acc75ab8\\out\\zstd\\lib\\compress\\fse_compress.o" "-c" "zstd\\lib\\compress\\fse_compress.c" with args "gcc.exe" did not execute successfully (status code exit code: 1).


warning: build failed, waiting for other jobs to finish...
error: failed to compile `anchor-cli v0.19.0 (https://github.com/project-serum/anchor?tag=v0.19.0#3afd1a22)`, intermediate artifacts can be found at `C:\Users\HP\AppData\Local\Temp\cargo-installZ5pUrb`

Caused by:
  build failed
yeah -- i mean - i don't know if it will help -- but then you can see what wallet-adapter-react has for methods
Hello, can I have an idea about 'Custom program error: 0xa8' 
When I make this transaction?

```
await program1.rpc.register(new anchor.BN(0), {
  accounts: {
    myAccount: dataAccount,
    program: program2.programId,
    authority: clientWalletAccount.publicKey,
  },
})
```
works now
alan ur a G
omfg
You forgot to mark that account as mut
`foraz9cGYqhwYVHmTo68GU4ED1zLFUD25ZWPTj9S4BX's writable privilege escalated`
```
Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account 
    Program 6qCDFG94uAzBniiAn2HqzbekKq7gozR2tMKzEBEHJTTz invoke [1]
    Program 11111111111111111111111111111111 invoke [2]
    Program 11111111111111111111111111111111 success
    foraz9cGYqhwYVHmTo68GU4ED1zLFUD25ZWPTj9S4BX's writable privilege escalated
    Program 6qCDFG94uAzBniiAn2HqzbekKq7gozR2tMKzEBEHJTTz consumed 16635 of 200000 compute units
    Program 6qCDFG94uAzBniiAn2HqzbekKq7gozR2tMKzEBEHJTTz failed: Cross-program invocation with unauthorized signer or writable account
```
Can you print the full program log?
Im working on building a simple contract with a deposit and withdraw function for an spl token.  I am planning on using the spl anchor approve instruction in order to delegate tokens when the deposit function is called. I am now attempting to figure out how to create a withdraw function.  What would be an appropriate instruction to use to “withdraw” or revoke access to a specific quantity of tokens?
I've tried using like every form of invocation to invoke the instruction I can find but im at a loss
& `Cross-program invocation with unauthorized signer or writable account`
Getting `Error: Account does not exist`
I have no idea why I can't send SOL here.

```
        let instruction = solana_program::system_instruction::transfer(
            &ctx.accounts.authority.key,
            &ctx.accounts.fora_community.key,
            CREATE_ACCOUNT_FEE
        );

        // Invoke the system program to transfer funds
        let transfer_result = solana_program::transaction::invoke(
            &instruction,
            &[
                ctx.accounts.system_program.to_account_info().clone(),
                ctx.accounts.authority.to_account_info().clone(),
                ctx.accounts.fora_community.to_account_info().clone(),
            ],
        );
```
If I airdrop a wallet, does it get created or do I have to use SystemProgram.createAccount?
any idea what can cause this? started popping after i did some refactoring
```27 | #[program]
   | ^^^^^^^^^^ could not find `__client_accounts_crate` in the crate root
```
<@!134416332509675520> I just wanted to say thank you! I finally figured it all out
i just put this in app.js?
hey folks, just wanted to bump this: can you only provide single instructions to the anchor multisig? seems like transaction only holds the info for a single Instruction
(i.e. when you execute a multisig transaction, can that only execute a single instruction)
and see what is in there -- or at least what your program can see
and then 
console.log(Object.keys(bongo);
ok -- try maybe importing to just 
`import * as bongo from '@solana/wallet-adapter-react';`
same here
can you look inside the 'wallet-adapter-react' folder? 
for example mine has an index.ts file with:
`export * from './ConnectionProvider';
export * from './errors';
export * from './useAnchorWallet';
export * from './useConnection';
export * from './useLocalStorage';
export * from './useWallet';
export * from './WalletProvider';`
oh ok 🙂 thanks
Ah, ok, yeah, you won't be able to use that API unfortunately (it's just not written quite right, you'll have to jump to source and re-do what it's doing under the hood—irritating)
where i pass in the wallet from useWallet -- i guess it kind of makes sense that the wallet's key isn't just available
trying this 
`  let userKeypair = wallet;
  let mintAccount = await spltoken.Token.createMint(
    provider.connection,
    userKeypair,
    userKeypair.publicKey,
    null,
    0,
    spltoken.TOKEN_PROGRAM_ID
  );`
oh - i get this error: 
`TypeError: unexpected type, use Uint8Array`
What do you mean? What goes wrong?
Ordinarily you would use anchor's `init` attribute to handle this
module has no exports
Compiled with problems:

ERROR in ./src/App.js 24:0-16

export 'getPhantomWallet' (imported as 'getPhantomWallet') was not found in '@solana/wallet-adapter-wallets' (module has no exports)


ERROR in ./src/App.js 41:17-26

export 'useWallet' (imported as 'useWallet') was not found in '@solana/wallet-adapter-react' (module has no exports)
not sure why the error requires something to export from
yeah I think I just tried importing more random things to fix it
and see if its truly not there or something else is bungling it?
maybe try and remove things you may not need - i.e. make a small page with only that import
eek
sorry - it does look fine
Im not sure how to go about making sure the versions are all correct and compatible
which one did you use?
copy pasting a configuration from another github repo did the job for me
you need to be careful which version to use. versions are super fragile on this package
i.e. show where you are importing it?
can you show the code?
been trying to test an app and I keep getting this error 

ERROR in ./src/App.js 41:17-26

export 'useWallet' (imported as 'useWallet') was not found in '@solana/wallet-adapter-react' (module has no exports)

any clue why this is? I have been banging my head against a wall over this all day, I should have the dependencies correct
is it not possible to call the spl.Token program in javascript with a wallet?
Anyone knows how I could pass a uninitialized account info to something like Account<'info, T>?

The SC will create the account if needed and I would like to just use the method `reload(&mut self)` after that to get data on the Account struct
<@!134416332509675520> sir, I just got back home and sent an nft directly from Phantom. The associated token account I derived is correct. It seems something is wrong with the way I use `createAssociatedTokenAccountInstruction()`

This is how I use it

```
Token.createAssociatedTokenAccountInstruction(
          ASSOCIATED_TOKEN_PROGRAM_ID,
          TOKEN_PROGRAM_ID,
          mintAddress,
          toTokenAccount,
          provider.wallet.publicKey,
          provider.wallet.publicKey
        )
```
I don't get where it can go wrong
Thank you, I will look into this
I think there is a chainlink oracle to do so, at least by november this was not possible in pure solana i remember. would have to dig in though, but you should be able to find stuff when you google `solana chainlink randomness´ or so. maybe someone else knows more
is there a way to add guaranteed randomness?
thanks man
gotcha, perfect
Nope (hence the existence of wrapped sol, to bring native sol into the spl token ecosystem)
nvm
I thought SOL itself was an SPL token as well
ooooh
Yes, *all* spl tokens go in token accounts (sol isn't an spl token)
but other SPL tokens have token accounts?
It's an account all by itself, owned by the system program
You should try taking your phantom wallet address and sticking it in explorer.solana.com
You might be thinking of "wrapped sol", which is indeed a tokenized version of sol
That store lamports but no data
Wallets are accounts all by themselves
wut
Nope
don't wallets have an associalted SOL token account?
Why are there any token accounts at all here?
But what token accounts are you referring to?
yes, so I have to pass in or derive their token accounts then?
Assuming you're transferring sol
Those don't sound like token accounts, just regular system program accounts
the signers and the apps wallet
Wouldn't expect anything to be derived for you 😛
Which token accounts?
last q, do i pass in their token accounts or does it derive that under the hood?
you're a king alan
If you're transferring sol from an account owned by the system program, yeah, you have to use the system program to do it
Yes, they're all CPIs (they have to talk to the spl token program)
in this case I could just use solana_program::system_instruction::transfer?
Are all anchor spl_token transfer CPIs? I will need escrows in the long run so I just went with what examples I could find to get the tokens transferring.
Yeah, that sounds like a regular transfer, not sure why you'd need to break in into two hops via an escrow
Here's where anchor does error parsing: https://github.com/project-serum/anchor/blob/master/ts/src/program/namespace/rpc.ts#L32
from : signer
to: appPubkey
What do you mean by a 1:1 transfer?
I have an escrow working fine but if I just want to send a 1:1 transfer in the contract; basically pay our apps token account a fee; do I even need an escrow?


//////////////////////////////////////////////////////////////////////////////////////////

lemme try increasing the size
isn't it supposed to show another error then ?
could you be running out of space on the account?
oh sorry
hmmm - maybe the objects get changed by the first call somehow?
it worked before i've no idea what i messed up
adding an item to a list
ya
and calling from js?
no they are the same calls
your error - I mean just guessing - maybe you added something to it the 2nd time that prevented serialization?  what changes between invocations?
^^ oh its definitely better -- but direct solana rust dev is always available to us as a reminder 🤓
it abstracts many stuff so i kinda feel very hard to debug 
don't take my word i'm just a beginner `:P`
I heard the term the other day on the solana podcast -- I think anchor in general has reduced the amount of glass chewing so I'm not complaining - just nice to know others feel it too 🙂
chewing glass ? i never saw it xD
is there a chewing glass emoji?  :chewing-glass:  🙂
Ok weird - changing the seed seemed to fix it
i mean it worked on the first one but keep getting error this `0xbbc` error after that
No one had this error ?
https://github.com/project-serum/anchor/blob/4422902e86fbfe2118d0e9fe8ec26596fc312e94/lang/src/error.rs#L115
I'm getting this error when i do the rpc call two times
you dont have to do anything to set that up
every account not declared in the validation struct but passed into the tx will magically appear in `ctx.remaining_accounts`
you dont add remaining accounts, they appear automatically on ctx
I have another program working fine - almost same -- in the same workspace etc.  -- could it be that the PDA is off?  probably something stupid - i'll try and make a new seed and see if it matters
hovering over it, it says: `invalid type`
but idk why there exists this error on `&`
Hey folks! I am trying to add remaining accounts to my struct to be consumed from the context. The params are being passed correctly as per https://docs.rs/anchor-lang/0.4.5/anchor_lang/struct.Context.html
for "The given account is owned by a different program than expected" is this an error in anchor validation or was it rejected by the program?  is there a way to find out which account -- ?  I assume it is the PDA account b/c its the only one passed in that is mutable - or marked as such
checkout the tests/events folder in the anchor repo
and this is what my event looks like on the program ```emit!(TestEvent {
            data: 6,
            label: "bye".to_string(),
        });```
hi everyone, I'm just getting started trying to use Event Emitters in Anchor. Does anyone have an example about how to listen for events on the frontend? This is what I tried on my front end ```createEventManager()
  .then(listener => {
    listener.addEventListener("TestEvent", (event) => console.log(event))
  })
  .catch(err => console.log(err))
``` but ran into this error ```throw new Error(`Could not find program invocation log line`)```
Hey everyone,

Just had a quick question about using Vecs of tuples in a struct. For example, I wanted to have the following:
```
pub struct ExampleStruct {
    pub a: Vec<(u8, u8)>,
}
```
This is able to build and deploy but running anchor test gives me a `User defined types not provided error`. I'm assuming that this means that Vecs of tuples aren't currently supported in the IDL.

Is my understanding here correct? If so, is there a workaround so that I could do something similar to this? I was thinking maybe `enum`s but that might be expensive. Thanks!
is there any way to re-run tests every time a file is saved? like a `anchor test --watch` flag or something similar?
is my seed maybe colliding with an existing program?  seems unlikely
The size matters, 1232 bytes is max
anyone have a code example on how to close an account?
`The given account is owned by a different program than expected` --- did I maybe generate the PDA incorrectly?
but that also means from the clientside on a dapp, the user will have to approve 3 transactions correct? hmmm
what are the limits around number of instructions in a transaction?
hmm no but mb someone else does
interesting, do you have any resources I can learn more to implement this?
and you also might have to use 3 tx and use delayed randommness cause otherwise your randomness can be gamed
you can add checks to your program that prevent that
I'm not sure, I'm still learning solana programs tbh
transaction 1 returns account to sent token to, transaction 2 sends it to that address
Isnt it possible for somebody else to just call my transaction 2 knowing my program_id
im not following
right, but how do I prevent anybody from sending the second type of transaction which specifies the account
yea I meant that you choose it onchain from the list of addresses in the first tx
its why I want to determine the recipient account onchain to prevent malicious intent from clientside
was thinking about that before but could it be a security issue if someone directly calls the second tx
but you could do it in two transactions. first, you send a tx that randomly chooses address key from the list you have stored in an account somewhere. you save that address in the tx. then in a second tx, you send tokens to that address
if your list is small, you can do this but if it's large it's not possible in a single transaction because all accounts have to be passed into the transaction and the tx has a size limit
Like I have a program account that stores an array of addresses and I randomly select which to transfer to when the program runs
and the reason for there being two options is that sometimes, you want an account to sign that is not a Signer type. then you can use the signer contraint. we might deprecate this constraint completely and add types like `AccountSignerMut`
Type Signer is the more up-to-date way (although they do the same thing)
so if my instruction takes an account and i wanna check if its a signer what is the preferred way to do it ? define its type as Signer or use #account(signer) ?
Can someone pls tell? 
I have the account as a parameter in the form of 
#[account(mut)]
 pub service_account: AccountInfo<'info>

And I want to first see how much balance of a mint this service_account has
And then debit the particular token
yes. really struggling with architecture here
<@!915682383905316864> <@!161709591220977664> <@!831450660146642974> <@!248066053161222144> can you guys pls help?
How do I read the amount of another token knowing its mint, (say SRM) in rust inside the smart contract?
Hey guys, I just tried `anchor test` but, there's some error. So I tried `sudo anchor test` and I got an error too. I'm practicing on Ubuntu 20.0.4 LTS and each version is below. I want to learn how to develop with anchor and solana. Please somebody help me 😫 

nodejs - 16.13.1
npm - 8.1.2
rustup - 1.24.3
rustc - 1.57.0
cargo - 1.57.0
solana-cli - 1.9.1
anchor-cli - 0.20.0

```
newmynixx@LAPTOP-JSMKVSS3:~/myepicproject$ anchor test
BPF SDK: /home/newmynixx/.local/share/solana/install/releases/1.9.4/solana-release/bin/sdk/bpf
cargo-build-bpf child: rustup toolchain list -v
cargo-build-bpf child: rustup toolchain link bpf /home/newmynixx/.local/share/solana/install/releases/1.9.4/solana-release/bin/sdk/bpf/dependencies/bpf-tools/rust
cargo-build-bpf child: cargo +bpf build --target bpfel-unknown-unknown --release
error: failed to create directory `/home/newmynixx/myepicproject/target/release`

Caused by:
  Permission denied (os error 13)
newmynixx@LAPTOP-JSMKVSS3:~/myepicproject$ sudo anchor test
Error: No such file or directory (os error 2)
```
8 is the minimum, max for CPI initiated calls (accounts created with init) is 10kb (10,400 bytes to be exact)
I need it to be really big. My account contains 4 fields, each being a vector of size 100
What is the maximum value of space= that I can use?
phantom wallet always shows the TokenAccount as long as it has a balance and the owner is the wallet address?
eg: if its not the ATA PDA, any custom PDA, as long as the owner is the wallet address and it has some balance, it will show right?
who are you transferring to then? its like wanting to pay someone money. only not knowing who someone is.
if its a seed constraint error, it will throw seeds violated. its likely your signer priviledges arent correct when invoking cpi. check that if you're calling cpi, all accounts that need to be signers are signers
is it possible to have different migration files kick off for different networks? when running `anchor migrate` ?
Hit a roadblock on a CPI calls to a contract pre-deployed locally. 
I have another contract using a PDA for `invoke_signed`, with correctly matching seeds. 
But, I keep on getting the `signer privilege escalated`
I also have the `#[account(mut)]` constraint set on the PDA

Are there other reasons for getting this error besides mis-matching seeds? 
Appreciate your help in advance 🙏
Is it possible to do a token transfer in my program without passing in the recipient? I want to randomly token transfer to an account and it's not feasible to pass in all possible accounts from the client side
is the owner the same as the authority?
for a TokenAccount
**What am I doing wrong here? There is no error here when i call the create instruction but the arrays seam to be empty id: [].
how should I fill them?**
**I have a struct **
`#[account]
pub struct Ledger {
    pub id: Vec<String>,
    pub amount: Vec<u64>,
    pub time: Vec<String>
}`
**And I want to initialize them to an empty vector in the create method. **
`#[derive(Accounts)]
pub struct Create<'info> {
    #[account(init, payer = user, space = 8 + 64 + 64 + 64 + 64)]
    pub ledger: Account<'info, Ledger>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
   
}`
`**In this create function i am doing the following**
    pub fn create(ctx:Context<Create>) -> ProgramResult {
        let ledger = &mut ctx.accounts.ledger;
        bets.id = get_id();
        bets.amount = get_amount();
        bets.time = get_time();
        Ok(())
    }`

**All these get_ functions return an array of size 20 which are empty
for eg: -**
`pub fn get_id() -> Vec<String> {
    let mut id_vec: Vec<String> = Vec::new();
    for _ in 0..10 {
        id_vec.push(DUMMY_TX_ID.to_string())
    }
    return id_vec;
}`
<@!134416332509675520> 
Would you like to share the code that is using the spl_math library's U256?
youre welcome 🙂 theres more on its way
the test repo is a super useful way of understanding the ts side of anchor (the 0.20 docs.rs stuff has been super great for the rust side) so thanks for putting them all together
iirc I created the public key there manually instead of importing it from solana/web3 cause they actually hadnt added it by then
correct!
🤦‍♀️ thank you that makes so much more sense
OH but not of bpf-upgradeable-state (the program from the anchor test); it's an actual *solana* internal
it has nothing to do with the program except for generating the programdata address in the tests
thats the key of the upgradeable bpf loader
unless it was used to gen `bpf_upgradeable_state-keypair.json` and that's why it's not in the repo?
`BPFLoaderUpgradeab1e11111111111111111111111` is used only in the findprogramaddresssync call and nowhere else in the repo
the anchor.toml file and the declare_id have a different key than the one used in the test in the code I shared above
yes the way to get the `programdata_address` is the same for all upgradeable programs
> the BPFLoader key isnt the one actually used

wdym?
odd internals question:
``` const programDataAddress = findProgramAddressSync(
    [program.programId.toBytes()],
    new anchor.web3.PublicKey("BPFLoaderUpgradeab1e11111111111111111111111")
  )[0];
```
This is from the anchor `bpf-upgradable-state` test. The `BPFLoader` key isn't the one actually used to deploy the program, but I'm assuming the test passes (since this is from the github). Is the seed used to find the program data address always the program id? And why is that different from the second input (which the api lists as `programId` but here is a public key that isn't used anywhere else).
and could this be used for a vault program?
what does the anchor_spl::token::Approve function do?
Anyone know why my transaction is failing to confirm on devnet? Using custom rpc as well. Keeps timing out after 30s
for sure
One sec let's dm 😆  I want to get the source and try running on my end and play with it a bit
sorry this is missing where some of the vars are initialized lemme send that too
```
 it('It lets you deposit', async () => {

    const offer = anchor.web3.Keypair.generate();
    const [escrowedTokensOfOfferMaker, escrowedTokensOfOfferMakerBump] = await anchor.web3.PublicKey.findProgramAddress(
      [offer.publicKey.toBuffer()],
      program.programId
    )
    let offerMakerCurrentCowAmounts = (await cowMint.getAccountInfo(offerMakerCowTokenAccount)).amount.toNumber();
    console.log(offerMakerCurrentCowAmounts)

    await program.rpc.deposit(
      escrowedTokensOfOfferMakerBump,
      new anchor.BN(2),
      {
        accounts: {
          offer: offer.publicKey,
          whoMadeTheOffer: program.provider.wallet.publicKey,
          tokenAccountFromWhoMadeTheOffer: offerMakerCowTokenAccount,
          escrowedTokensOfOfferMaker: escrowedTokensOfOfferMaker,
          kindOfTokenOffered: cowMint.publicKey,
          tokenProgram: spl.TOKEN_PROGRAM_ID,
          systemProgram: anchor.web3.SystemProgram.programId,
          rent: anchor.web3.SYSVAR_RENT_PUBKEY
        },
        signers: [offer]
      }
    );
    console.log("Starting Withdraw")
    await program.rpc.withdraw(
      {
        accounts: {
          offer: offer.publicKey,
          whoMadeTheOffer: program.provider.wallet.publicKey,
          whereTheEscrowedAccountWasFundedFrom: offerMakerCowTokenAccount,
          escrowedTokensOfOfferMaker: escrowedTokensOfOfferMaker,
          tokenProgram: spl.TOKEN_PROGRAM_ID,
        },
      }
    );
    
    //assert.equal(2, (await cowMint.getAccountInfo(escrowedTokensOfOfferMaker)).amount.toNumber());
    //offerMakerCurrentCowAmounts = (await cowMint.getAccountInfo(offerMakerCowTokenAccount)).amount.toNumber();
    //console.log(offerMakerCurrentCowAmounts)
    //let cook = (await cowMint.getAccountInfo(escrowedTokensOfOfferMaker)).amount.toNumber();
    //console.log(cook)



  });
```
Can I see the client side test as well
let me know if you need anything else!
Here is the source code for the instruction:
```
use anchor_lang::prelude::*;

use crate::state::*;
use anchor_spl::token::{Mint, Token, TokenAccount};

#[derive(Accounts)]
pub struct Withdraw<'info> {
    #[account(
        mut,
        constraint = offer.who_made_the_offer == who_made_the_offer.key(),
        close = who_made_the_offer
    )]
    pub offer: Account<'info, Bank>,

    #[account(mut)]
    pub who_made_the_offer: Signer<'info>,

    #[account(mut)]
    pub where_the_escrowed_account_was_funded_from: Account<'info, TokenAccount>,

    #[account(
        mut,
        seeds =[offer.key().as_ref()],
        bump = offer.escrowed_tokens_of_offer_maker_bump
    )]
    pub escrowed_tokens_of_offer_maker: Account<'info, TokenAccount>,

    pub token_program: Program<'info, Token>,
}

pub fn handler(ctx: Context<Withdraw>) -> ProgramResult {
    anchor_spl::token::transfer(
        CpiContext::new_with_signer(
            ctx.accounts.token_program.to_account_info(),
            anchor_spl::token::Transfer {
                from: ctx
                    .accounts
                    .escrowed_tokens_of_offer_maker
                    .to_account_info(),
                to: ctx
                    .accounts
                    .where_the_escrowed_account_was_funded_from
                    .to_account_info(),
                authority: ctx
                    .accounts
                    .escrowed_tokens_of_offer_maker
                    .to_account_info(),
            },
            &[&[
                ctx.accounts.offer.key().as_ref(),
                &[ctx.accounts.offer.escrowed_tokens_of_offer_maker_bump],
            ]],
        ),
        ctx.accounts.escrowed_tokens_of_offer_maker.amount,
    )
}
```
thank you for your willingness to help!
sounds good, here is the error message:
```Transaction simulation failed: Error processing Instruction 0: custom program error: 0x65 
    Program FZUqSDoE9P4PUEmiwgDSUKfE4cLp3KxfA8Z5ocbRrFS4 invoke [1]
    Program log: Custom program error: 0x65
    Program FZUqSDoE9P4PUEmiwgDSUKfE4cLp3KxfA8Z5ocbRrFS4 consumed 2567 of 200000 compute units
    Program FZUqSDoE9P4PUEmiwgDSUKfE4cLp3KxfA8Z5ocbRrFS4 failed: custom program error: 0x65
Translating error SendTransactionError: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: custom program error: 0x65
    at Connection.sendEncodedTransaction (/Users/michaelgiardino/Desktop/animal-trading-farm-public/node_modules/@solana/web3.js/src/connection.ts:3689:13)
    at processTicksAndRejections (node:internal/process/task_queues:96:5)
    at Connection.sendRawTransaction (/Users/michaelgiardino/Desktop/animal-trading-farm-public/node_modules/@solana/web3.js/src/connection.ts:3649:20)
    at sendAndConfirmRawTransaction (/Users/michaelgiardino/Desktop/animal-trading-farm-public/node_modules/@solana/web3.js/src/util/send-and-confirm-raw-transaction.ts:27:21)
    at Provider.send (/Users/michaelgiardino/Desktop/animal-trading-farm-public/node_modules/@project-serum/anchor/src/provider.ts:114:18)
    at Object.rpc [as withdraw] (/Users/michaelgiardino/Desktop/animal-trading-farm-public/node_modules/@project-serum/anchor/src/program/namespace/rpc.ts:24:23) {
  logs: [
    'Program FZUqSDoE9P4PUEmiwgDSUKfE4cLp3KxfA8Z5ocbRrFS4 invoke [1]',
    'Program log: Custom program error: 0x65',
    'Program FZUqSDoE9P4PUEmiwgDSUKfE4cLp3KxfA8Z5ocbRrFS4 consumed 2567 of 200000 compute units',
    'Program FZUqSDoE9P4PUEmiwgDSUKfE4cLp3KxfA8Z5ocbRrFS4 failed: custom program error: 0x65'
  ]
}
```
Lets keep it on here I think in case anyone else runs into this issue. If it gets to be a lot though we can maybe dm.
for sure, can I send you a dm or should i send it here?
Ah, custom program errors are fun 😆  are there any logs above that error? Gnna need to see some code to help out though.
Can anyone help me with debugging a `Program log: Custom program error: 0x65` issue. I am attempting to call the spl transfer instruction and im having a hard time figuring out where to look for the issue.
I'm also curious if you would even want multiple different PDA's for different accounts. I don't really see an obvious reason for needing many different PDA's. But I'm new to this stuff too.
I'm currently playing around with making vaults owned by a PDA that users can deposit sol to and then withdraw from. Basically create a PDA, then you create the vault which is a SystemAccount for that PDA so the program will have authority over the vault account. You will also need your own transfer_sol function in your program that does a CPI using invoke_signed. You create the the transfer instruction using the system_instruction::transfer function. You will then need also include the signers_seeds, the ones you used when creating the PDA, with the invoke_signed call so the runtime can verify the program calling this invoke_signed with the transfer instruction is the proper authority for transfering sol.
What do you mean by close PDA? Do you mean close the PDA Account? I haven't got to closing accounts yet, but anchor has a functions and attributes for closing accounts. The PDA (Program Derived Address) will always exist as far as I know, as it's just the program_id with some seeds hashed with it for allowing programs to sign transactions. If you know the seeds you can always generate the same PDA, you can't close an address. But you can close accounts associated with addresses.
What are the negative implications of only using one seed/bump for a PDA for different users accounts and just hardcoding it in, rather than saving the seed/bump in an account just taking up extra space?
I'm trying to create a basic "vault" program that keeps a record of balances owed to different people in SOL, and they can deposit and withdraw. Struggling on architecture , PDA, CPI and account types / ownership....

How can I make a vault account that holds sol and is owned by the program that changes its balance?

What additional accounts types would I have to have for add / withdraw?

Trying to make sense of Neodyme's examples: https://github.com/neodyme-labs/neodyme-breakpoint-workshop/blob/main/level0/src/processor.rs


//////////////////////////////////////////////////////////////////////////////////////////

Should i just create a new program and copy source code over
I want to deploy my program with a different program ID but i'm not sure the best way to go about it?
I'm getting this `Transaction simulation failed: Error processing Instruction 1: instruction modified the program id of an account` I've searched everywhere for that error without much success. There are some examples in this channel but none of the solutions worked. Can someone point me in the right direction?

My program is just minting some coins, transfering them and burning them. Here's the link to the detailed output I get when running `anchor test`: https://app.warp.dev/block/FWYGAhgRrEo1HhgbWvG1Kw

And this is the link to the gh repo: https://github.com/Francososa/francoin
<:thankyou:753524665930088508>
https://github.com/ironaddicteddog/anchor-escrow/blob/103578b363b414565a74adb935d2bfa9671e7d51/programs/anchor-escrow/src/lib.rs#L233
which are the best examples of wrapper to do cpi between anchor program and solana program? (except anchor_spl) <:scaredcat:848238059610439720>
I Can't figure out try Different system Ubuntu and Windows
how would someone handle this situation? if you need to change the structure of an account
Thank you. Do  you mean declaring my PDA in the context struct as a `#[account(mut, signer)]` ?
<@479752955655094272> I just kept redeploying 😂 and it worked
how do I close an account? and what are the requirements?
how did you fix it ?
I dont think so, I did it manually 💔 the other day
is there a way for anchor to rename my project from top to bottom? something from `test_project` to actual `project_name`?
Hi <@!501570363566587905> 
Can I implement the deserialize the accounts to get accounts array on the instruction?
<@!501570363566587905> <@!915682383905316864>
Does anyone have a suggestion about writing tests for such a program?
super thanks
You can use `metaplex-token-metadata` crate, require the metadata account in your Context struct as `Account<'info, Metadata>`, and you can read the fields inside with `ctx.accounts.metadata` inside your handler. The metadata PDA can be found by 
`const [metadataPubkey, metadataPubkeyBump] = await PublicKey.findProgramAddress([METADATA, METADATA_PUBKEY.toBuffer(), nftMint.toBuffer()], METADATA_PUBKEY)` where the constants are "metadata" and metadata programId
I think it can't be done. since them stored on separate blockchain Arweave or ipfs
Is there any way to get it if it is metaplex nft?
yes, but it can be changed
Are they metaplex nfts?
Is there any way I can get nft attributes in solana program?
i have a send sol function in which im sending sol from a user to my vault account but then in withdraw function which i made i cant withdraw sol from vault account to the users account because of ```Cross-program invocation with unauthorized signer or writable account ``` <@!915682383905316864>
actaully fixed that error but im getting another one
Hi everyone 🙂

I'm trying to write local tests for a program that needs to read some Metaplex Metadata accounts for given NFTs.

I see that I need to have the `https://crates.io/crates/metaplex-token-metadata` already deployed for me to refer some PDAs and call some instructions on it.

How can I deploy this contract before my tests for local development? Is this the right approach?
Also, you are transferring to the system_program? Is that really what you want to do?
You are transferring from msg_sender (mutating) but the account is not marked mut
afaik u cant
How can I add the accounts array on the context?
Pls reply guys really no other way for me to find this out ⬆️
Can someone pls tell? 
I have the account as a parameter in the form of 
#[account(mut)]
 pub service_account: AccountInfo<'info>

And I want to first see how much balance of a mint this service_account has
And then debit the particular token
```rust

        let ix = anchor_lang::solana_program::system_instruction::transfer(
            &msg_sender.key(),
            &ctx.accounts.system_program.key(),
            amount,
        );

        anchor_lang::solana_program::program::invoke(
            &ix,
            &[
                msg_sender.to_account_info(),
                ctx.accounts.system_program.to_account_info(),
            ],
        );```
```rust
#[derive(Accounts)]
pub struct SenderContext<'info> {
    #[account(mut)]
    pub base_account: Account<'info, BaseAccount>,
    pub msg_sender: Signer<'info>,
    pub system_program: Program<'info, System>,
}```
i got this error while doing that
code: 2000,
  msg: 'A mut constraint was violated'
}
Is it possible to transfer sol in pgorgram to system program
max size is 32. Probably you will have to maintain this mapping of different wallets off-chain
How do I setup a custom rpc node on anchor tests?
```rust
pub fn dynamically_allocate_buffer(ctx: Context<Dynamic>, size: u64) -> ProgramResult {
...
```
these are the main lines of importance
```rust
#[instruction(buffer_seed: u64, buffer_size: u64)]
pub struct Dynamic<'info> {
    #[account(init, payer = authority, space = 8 + 4 + buffer_size,
```
example:
```
error[E0308]: mismatched types
  --> programs/anchor-echo/src/lib.rs:44:10
   |
44 | #[derive(Accounts)]
   |          ^^^^^^^^ expected `u64`, found `usize`
```

```rust
#[derive(Accounts)]
#[instruction(buffer_seed: u64, buffer_size: u64)]
pub struct Dynamic<'info> {
    #[account(init, payer = authority, space = 8 + 4 + buffer_size,
    seeds = [b"dynamic", authority.key.as_ref()],
    bump)]
    pub buffer: Account<'info, Buffer>,
    #[account(mut)]
    pub authority: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[account]
pub struct Buffer {
    pub data: Vec<u8>,
}
```
is it currently possible to dynamically size account space via the `#instruction` macro? context here is I have a struct with a `Vec` that i don't know how large it'll be upfront (and want to allocate _just enough_ space at runtime)

the thing i'm running into is the `derive` macro seems to expect a `usize`, which is strange because vanilla solana expects `u64` --
Can someone pls tell? 
I have the account as a parameter in the form of 
#[account(mut)]
 pub service_account: AccountInfo<'info>

And I want to first see how much balance of a mint this service_account has
And then debit the particular token
Hi <@!501570363566587905> 
Would you please share the code that is using the spl_math U256?
I think you probably omitted parameters of instruction.
Is it possible to search through past events with web3.js, or only to subscribe to future events?
Solved this, was sending an incorrect address for the ATA
I'm not sure what account might be missing?
Hi -- I have the following struct:

```
#[derive(Accounts)]
pub struct ATA<'info> {
    #[account(
        init,
        payer = payer,
    associated_token::mint = mint,
        associated_token::authority = payer,
    )]
    pub token: Account<'info, TokenAccount>,
    pub mint: Account<'info, Mint>,
    pub escrow_account: Box<Account<'info, EscrowAccount>>,
    #[account(mut)]
    pub payer: Signer<'info>,
    pub rent: Sysvar<'info, Rent>,
    pub system_program: Program<'info, System>,
    pub token_program: Program<'info, Token>,
    pub associated_token_program: Program<'info, AssociatedToken>,
}
```

When i try to send a transaction like this:

```
let exchangeTx = program.transaction.ata(
            {
                accounts: {
                    token: toTokenAccountAddress,
                    mint: nft.mint,
                    escrowAccount: currentEscrow.pubkey,
                    payer: publicKey,
                    rent: anchor.web3.SYSVAR_RENT_PUBKEY,
                    systemProgram: anchor.web3.SystemProgram.programId,
                    tokenProgram: TOKEN_PROGRAM_ID,
                    associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID
                },
            }
        );
```

I'm getting the following error: 

Program returned error: An account required by the instruction is missing
Ty for clearing that up, much appreciated!
Whats the max seed length to generatea pda? im trying to generate based on multiple wallets would a hash of the wallets work?
which checks he account data length
it uses pack/unpack
AnchorPy is a client, like anchor-ts. You use it to interact with smart contracts written in Rust using anchor_lang. Anchor itself is an umbrella term
How does anchor differentiate between Account<'info,TokenAccount> and Account<'info,Mint> ? Since for these accounts there is no descriminator and they are deserialized using the u checked version where discriminator is not checked ?
Thank you
Hi all, I’m looking to try out Anchor this week and was wondering if there is any recommendation or functional difference between Anchor, anchor_lang, and AnchorPy?
` rent: anchor.web3.SYSVAR_RENT_PUBKEY,`
Anyone know what account pubkey I should pass as rent (`Sysvar<'info, Rent>` type)
guess it's snake_case rust against camelCase js. So in my case, in order to call down_vote I do 

```
 await program.rpc.downVote({
      accounts: {
        account: newUpVoteAccount.publicKey,
        voter: provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      }
    })
```
on the client. But how it's technically mapped I am not sure. Not that deep into the anchor framework
For constructing transactions myself against a program I'm a bit confused on how the program maps the instructions received to the right function...
oh sorry forgot to include the sizes 

```
 const DISCRIMINATOR_LENGTH: usize = 8;
const PUBLIC_KEY_LENGTH: usize = 32;
const EPOCH_TYPE_LENGTH: usize = 50 * 4;
const TIMESTAMP_LENGTH: usize = 8;
const STRING_LENGTH_PREFIX: usize = 4; // Stores the size of the string.
const MAX_TOPIC_LENGTH: usize = 50 * 4; // 50 chars max.
const MAX_CONTENT_LENGTH: usize = 280 * 4; // 280 chars max.
const DESCRIPTION_LENGTH: usize = 100 * 4; // 100 chars max
const URL_LENGTH: usize = 30 * 4; // 30 chars max url
const NAME_LENGTH: usize = 20 * 4; // 20 chars max name

impl VoteAccount {
    const LEN: usize = DISCRIMINATOR_LENGTH
        + PUBLIC_KEY_LENGTH
        + PUBLIC_KEY_LENGTH
        + STRING_LENGTH_PREFIX
        + EPOCH_TYPE_LENGTH;
}
```

so I guess it is 8 + 32 + 32 + 4 + 200

~~up_vote works flawlessly but the error is thrown for the down_vote call and I don't really get it~~

I think the solution was to change DownVote to: 
```
#[derive(Accounts)]
pub struct DownVote<'info> {
    #[account(mut)]
    pub account: Account<'info, VoteAccount>,
}

```

thus not include signer or program. I don't get it. Maybe because there isn't a signer for update account?
Might be the space you allocate for the VoteAccount. Try 8+VoteAccount::LEN, if VoteAccount::LEN is the size of the struct
on the blockchain
is there a way to get all token accounts of particular mint
hi, I am receiving this error ``` Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Failed to reallocate account data```

when I call the downVote after upVote:

```
 // up_vote allows users to vote on a message
    pub fn up_vote(ctx: Context<UpVote>, message_account: Pubkey) -> ProgramResult {
        let vote_account = &mut ctx.accounts.account;
        vote_account.epoch_type = String::from("upVote");
        vote_account.voter = *ctx.accounts.voter.key;
        vote_account.message_account = message_account;
        Ok(())
    }

    // close account when user downvotes
    pub fn down_vote(ctx: Context<DownVote>) -> ProgramResult {
        //let vote_account = &mut ctx.accounts.account;
        //let voter = &ctx.accounts.voter;
        //vote_account.epoch_type = String::from("");
        //vote_account.close(voter.to_account_info())?;
        Ok(())
    }
```

with voteAccount on these corresponding structs  
```#[derive(Accounts)]
pub struct UpVote<'info> {
    #[account(init,payer=voter,space=VoteAccount::LEN)]
    pub account: Account<'info, VoteAccount>,
    pub voter: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct DownVote<'info> {
    #[account(mut)]
    pub account: Account<'info, VoteAccount>,
    pub voter: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[account]
pub struct VoteAccount {
    pub message_account: Pubkey,
    pub voter: Pubkey,
    pub epoch_type: String,
} ```
 do anyone know what I'm missing?
<a:coding:850830817629437992>
(feel free to create one and open a pr)
no you'd have to make your own wrapper
is it possible to access `token-lending` with `anchor_spl` ? (as per anchor github, i think it's a no)
But the macro approach greatly simplifies the programming model particularly in the context of an e2e app in my opinion.
All the traits and types can be used as a library if you want to use the regular solana entrypoint.
You can do both.
Random Q:  Why did anchor decide to go the macro route instead of being an ordinary library? What specific problems were hard to solve with functions but easy with codegen/macros?
so smth flawed with the way im passing them. i logged all the accounts to verify, everything is well.
im certain it is because of the remaining accounts as passing remaining accounts on other fns breaks as well
it throws this error
Gotcha! I did the same but when I pass the remaining account like below

```
let send_sol_tx = await program.rpc.sendSol(
      new anchor.BN(0),
      new anchor.BN(2),
      {
        accounts: {
          baseAccount: baseAccount.publicKey,
          msgSender: provider.wallet.publicKey,
          user: provider.wallet.publicKey,
          systemProgram: SystemProgram.programId
        },
        remainingAccounts: [aone.publicKey, atwo.publicKey]
      }
    );
```
8 for `count: u64` and 40 for storing `authority: Pubkey` <@!569289717582135296> 
and i think i kinda have to calculate the space by myself
https://solanacookbook.com/references/anchor.html#calculating-account-space-size
i think its for field in the Account struct...
i should've tried `anchor expand` : P
Referring to this, I looked at the anchor examples for this and can't find any problem with my code. Does anyone know what would cause this error ``` Could not find program invocation log line``` from the Event listener on triggering the event?
oh good question - idk sorry
the left and right side of `+`
what is it trying to represent ?
https://github.com/project-serum/anchor/blob/4422902e86fbfe2118d0e9fe8ec26596fc312e94/examples/tutorial/basic-2/programs/basic-2/src/lib.rs#L25
https://github.com/project-serum/anchor/blob/4422902e86fbfe2118d0e9fe8ec26596fc312e94/examples/tutorial/basic-1/programs/basic-1/src/lib.rs#L24
no i mean why not `space = 128` ?
i guess it depends on what you are trying to put in it
`space = 64 + 64` what is this supposed to mean ? isn't giving 128 enough ?
i really am a beginner as well - so I am just guessing


//////////////////////////////////////////////////////////////////////////////////////////

Anchor.toml is probably a different version than your CLI
hey guys i am getting this error can someone help me with it.
How would one serialize instruction data for a program that is not mine? What information do I need to make a CPI to a 3p program somewhere on mainnet?
New to solana/anchor etc and going through some tutorials. The one thing I am trying to do is send SOL from a wallet to the smart contract but I only keep seeing Javascript implementations of this (creating a transaction). Is there an example of how to do this in the Rust code, triggered by a button press in the UI?
Unable to find the account
is there any reason why programs would be uploaded to localnet with different program ids than specified in code? I also have a block of `[programs.localnet]` in Anchor.toml but my programId when deployed still seem to be different
Thanks a lot for your reply.
This is a very good tutorial which demonstrates (among other things) using a PDA to sign/transfer funds.  Well, more specifically it's transferring spl-tokens, but you could do the same with SOL.  https://hackmd.io/@ironaddicteddog/solana-anchor-escrow
Hi <@!134416332509675520> <@!855419683515400223>
Could you let me know if there's any solution to add accounts array on the context?
If not, is there any way to deserialize the accounts on the instruction without context?
what are best practices for composing my on-chain program with other on-chain programs?

e.g. when users use my dapp, I want a bunch of stuff to happen and then a limit order to be submitted to a serum order book. would I do this by:

1. separating these two things into two separate instructions in the same transaction? i.e. a bunch of stuff happening on my dapp is instruction 1, and then submitting a new limit order to serum is instruction 2

2. do a cross-program invocation from my dapp that submits a limit order to serum? i.e. there's only one instruction sent to my dapp, and as part of the instruction's execution, a new limit order is sent to serum
I'm not sure what you need exactly, but there is `anchor verify` to check that local and onchain bytecodes match
hmm, so it seems to be a solana error but I am not sure how to interact with anchor to solve the problem. My struct looks like this ```
#[derive(Accounts)]
#[instruction(content: String,bump: u8)]
pub struct SendMessage<'info> {
    #[account(mut,has_one=authority)]
    pub user_account: Account<'info,User>,
    #[account(
        init,
        payer=authority,
        seeds = [
            b"epoch",
            user_account.key().as_ref(),
            &[user_account.message_count as u8].as_ref(),
        ],
        bump = bump,
        space = 10000  
    )]
    pub message_account: Account<'info, Message>,
    pub authority: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```
where user_account is an already existing account
It seems that this is related to adding dependency to rust smart contract. I have already added this into my cargo file. I am having issues when i am launching mocha tests. I want to know if my serum_dex.so is correctly deployed when i launch anchor test.
I don't know, you can grep sources to find out where this error occurs or ask on solana discord server
Thanks a lot
thanks! In my case I pass two accounts, how do I know where the error occurs?
https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#specifying-dependencies-from-git-repositories
How to correctly add an external library to my anchor project. 
Currently i am adding serum_dex.so to my anchor project and test it.
This is solana program error message and is not specific to Anchor
https://docs.rs/solana-program/1.4.6/src/solana_program/instruction.rs.html#164
how do people debug anchor error messages? this one confuses me  ```
Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Failed to reallocate account data
```
yes
You can take inspiration from here
https://docs.rs/anchor-spl/0.17.0/src/anchor_spl/token.rs.html#261
That's what I'm trying to figure out at the moment.
how are you receiving funds in the PDA? i have been trying, new to anchor, can i dm for a few quick questions haha
How can we manually deserialize an account from its address in rust with anchor?
Thank you. So all I would need to do is fund the PDA?
Hello,
I am writing a smart contract and testing using typescript. I have added dependency with serum_dex. 
My tests are failing while i am trying to create a market.
I want to check weather i have deployed correctly my serum_dex.so on the local validator before launching my tests.
How can i find it out?
Thx
if you can sign with it, then yes
as well as many others
There is one written in `./tests`
Good day! How can I pass additional accounts into `idl`, which I then could access with a `remaining_accounts()` function?
Hi, I have been looking for anchor dev for the past few weeks, and couldn't find one, might as well start to learn how to do it myself.

Any examples on simple escrow program?
Hi guys, just wanted to double check. Is it possible to have PDAs that are payers? (PDA payer).
I'm working on CPI calls to and existing protocol, and one of their instructions expects a particular address parameter to be a payer for the initialization of another account. But, I'm using a PDA (inside my program), since I don't want to rely on a client as a payer.
Hi all, I'm trying to test my program which uses metaplex metadata accounts. Is there any way for me to deploy the metaplex metadata contract in anchor JS tests to create metadata accounts?
vault account is an account created in context struct and is of type accountinfo, how do i get the seed for it
anyone saw this error before ? 0x7e0 working with spl-token faucet
for metaplex js you can do something like :
`const metadata = await Metadata.load(connection, pda`
I am getting this error after i rum anchor test i have installed mocha also still getting anchor command not found please help
it can be changed
Is there any way to get it if it is metaplex nft?
^^ for metaplex specifically?
is there any way to get metadata structure?
i want to use metadata via `Account<'info, Metadata>`, `ctx.accounts.metadata` inside my handler
but i don't know about metadata's structure
and these methods allow you filter --
<@!849284643999842304> -- one way to do it -- and I don't know if this is the best way -- if you look at the spl-token documentation -- https://spl.solana.com/token -- near the bottom it shows some RPC methods
😂  until i get my current program out the door i can't even think about what's next
i haven't even started on that one..
i need some anchor contracts
i will pay you to work on my project if you want 😛
I'm in pain 😩
every single person learning solana is probably saying that
lol <@!616045157925650453>
If anyone is offering any kind of tutoring service i will literally pay to help get my unstuck with a program i'm working on
looking for an example..
ok yeah -- if you know the token is in your local wallet - then you can find the token address from that I think
now i want to use sendToken but input there is this.. i am trying to figure out how to get the token account address .. 
```
interface ISendTokenParams {
  connection: Connection;
  wallet: Wallet;
  // token account address
  source: PublicKey;
  // destination wallet address
  destination: PublicKey;
  mint: PublicKey;
  amount: number | u64;
}
```
this is what i am using.. and it returns
```
  return {
    txId,
    mint: mint.publicKey,
    metadata: metadataPDA,
    edition: editionPDA,
  };
````
<@!569289717582135296> https://github.com/metaplex-foundation/js/blob/main/src/actions/mintNFT.ts#L110
Am in mobile now I will link the repo for more context
Lol no I am saying I can do that now
But I need to know how to do it programatically
yes 🙂
I can even transfer from phantom to another wallet
Yes !
ok -- so when you mint it it had to go to an account -- probably your local wallet
Mint address is returned by the mintNFT function so I can use that, but can’t seem to figure out how to get the token address
In sollet.io it shows those 2 values
Yes I think that is automatically done .. I need the from address.. I don’t think it can be the account holding the SOL .. it needs that underlying account
ok - the mint is the address - and then the wallet recieving it would need an account to send to
How do I get the address for that underlying token
oh ok - I _think_ you only need to transfer the underlying token
But having trouble figuring out exactly the values I need to give to transfer it  to another account
Yes I guess, I am learning / new to all this .. I am using the Metaplex / JS lib at the moment to mint NFT, now I want to transfer that NFT with sendToken function
https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html
Hey so what does this macro do: #[account(zero)]
are you looking for the Metaplex Metadata account for a particular mint?
this seems to be different form metadata account ?
but i am looking at metaplex/js lib and i can't seem to find, how to derive this Associated Token Metadata account
i see you need Mint address and Associated token to transfer a spl-token
hi anyone here know how i can derive associated token account ?
```
Mint Address: 5umaykH2cgRRTqe97xbVmhoNpeo2kWbtARboKqtXjMM3
Associated Token Metadata: CGHDeQahCktxW5yaMK2yNPWxSZiJnLkCnPLxESwMTAFv
```
Hi, where can I find the full list of Anchor.toml configurations?
libcrypto-1_1-x64.dll
is this a common error upon launchign solana-test-validator ?
Are you signing with the vault account owner? If the owner is a PDA you will need to use invoke_signed and pass in the seed and bump you used when generating the PDA.
Anyone have a resource I can use to learn how PDA seeds work?
thanks 😄
is there a front end repo that lets you transfer a selected nft to another wallet?
^ Really good to read through the commits of how he implemented this
https://github.com/project-serum/anchor/pull/790
There is one from Armani calling the associated token program. One sec
I feel like an idiot. Been trying that but forgot about Anchor.toml since i was in the program dir 😂
are there more examples? <:mortydumb:908904337361743882>
I believe you can just rebuild it:
```
anchor build

// Get the new program id.
solana address -k target/deploy/myepicproject-keypair.json

// Update Anchor.toml and lib.rs w/ new program id.
```


//////////////////////////////////////////////////////////////////////////////////////////

can anyone help me pls i got this one a run the command: cargo install --git https://github.com/project-serum/anchor --tag v0.20.1 anchor-cli --locked
Hey guys, i want to get a particular token balance on my react front end. I'm using the wallet kit provider and a phantom wallet. Does anyone has an example to use? Thanks
So if I want to change `program_id` , how can I get a valid one to deploy with?
I think it's due to me and my friend who work on same repo deploying with different wallets
While trying to deploy im getting: `Recover the intermediate account's ephemeral keypair file with`
Can you send example of front end call?
spl_token::instruction::transfer
you can use this instruction 

or you can look here:
https://github.com/solana-labs/solana-program-library/tree/master/examples/rust/transfer-lamports

in your front website call you need to specify how many lamports
Hello peeps,
I need to add a **random number generation** in my smart contract. I'm searching using oracle but chainlink only available on devnet.
Any tips on how to do / where to look?
Can anyone help ⏫
Basically on init I want to transfer x number of sol from user to the created account in the program
Hey <@!111233596173373440> <@!152089247254315008> 
How can I transfer a variable amount of sol (say x SOL) from a user wallet to the account that is being created by them in my smart Contract?
Currently when is pecify init and payer, the amount of sol is autoamtically calculated based on size i think, how can I transfer more sol than that if needed?
cc <@!347689664855015424>
You can't deserialize SlotHashes because it would be too big. Which is why it throws an error on execution like "unsupported sysvar". 
If you want to get the slot you can do : 

```rust
let data = slot_account.data.borrow();
let slot: u64 = u64::from_le_bytes(data[data.len() - 8..].try_into().unwrap());
```

(that's without using anchor)
this is what the docs say, if any one can simplify this "A data structure that can be used as an internal field for a zero copy deserialized account, i.e., a struct marked with #[account(zero_copy)].

" would appreciate it.
not sure where the non-account variant comes into play.
I know my usage uses `#[account(zero_copy)]` because...well, it's an account 🙂
was looking at the zero copy example in the anchor examples
no clue personally
any idea abt this ?
that was the issue fixed it everything works now https://github.com/xedk/solana-splits
aha understood
if your program is creating the account, it's a cross program invocation from your program -> system program to create the account, so limit of 10kb.

but if you create it directly from the client, it's client->system program, not a CPI, and not stuck under this technical limitation
An account created via CPI is limited to 10kb in size. That's the problem here. Why that is I do not know, but it's likely fairly technical
is there any explanation for this ?
by initializing the account on my own separately, then passing the already initialized account in, I bypass the quirky restriction that program init'd accounts must be max 10kb
what is the difference between #[zero_copy] and #[account(zero_copy)]
Yea https://discord.com/channels/889577356681945098/889702325231427584/923722638361231370
So I am no expert on this, but I think using `init` is essentially telling your program "hey, initialize this account for me". Which means your program is the one initializing the account - which means it is limited to 10kb instead of 10mb
cdnt init have created a normal account whose max size could have had been 10mb unless u pass seeds and bump , that is what init does if am not wrong.
genuinely curious about the last point if using init and #derive(default) would have had worked. still not clear on what #[account(zero_copy)] exactly does i think it marks the account so it is not deserialized at runtime
> if so is it wrong to use init here ? with zero_copy with #derive(default) , wouldnt that have calculated the space for you, or am i missing on something(most probably).
Honestly, no idea. I was banging my head against the wall for like two days before getting this working - this is what eventually worked
```await program.rpc.initializeProgram({
        accounts: {
          stateAccount: stateAccountKeypair.publicKey,
... other accounts,
          systemProgram: anchor.web3.SystemProgram.programId,
        },
        signers: [stateAccountKeypair],
        instructions: [
          await program.account.huntState.createInstruction(
            stateAccountKeypair,
            225043 <--- the number I was calc'ing
          ),
        ],
      });```
Here's a snippet of how that account is being created. The `createInstruction` instruction gets run first which initializes the `stateAccount` with the proper size before it gets passed into my program's `initializeProgram` instruction, where `&mut ctx.accounts.state_account.load_init()?;` gets called. I _think_ `load_init` gives ownership of the state_account over to the program, it appears to, but I actually should go confirm that no one else can modify the data of `state_account`.

>  is that why you needed to know the exact space your struct type will take
I needed to know the exact space because accounts that use `zero_copy` will currently fail if you give too little _or_ too much space.

Worth noting that this was extra stuff needed to be done because my state account is greater than some number (I think 1024KB or something?) and could not be a PDA for that reason (PDAs are limited to that number and under). By creating the account _not_ as a PDA and then giving ownership of the account over to my program,  I can make stateAccount as large as 10MB
<@!111233596173373440>  were u creating the account off chain on the client side in a different instruction and sending it to your program to get it initialized, if so is that why you needed to know the exact space your struct type will take to pass it when you create an account via systemProgram passing in the space parameter, if so is it wrong to use init here ? with zero_copy with #derive(default) , wouldnt that have calculated the space for you, or am i missing on something(most probably).
i get errors all the time 😩
https://github.com/evanmarshall/cross-pile hello anyone can help me with this pls
Hi! How can I use Anchor with such a Rust crate? https://docs.rs/stable-swap-client/1.6.7/stable_swap_client/index.html Do I need to spin up https://docs.rs/anchor-client/latest/anchor_client/ and which struct is the entry point in there?
Hey guys I am doing this in my smart contract 
`**program_account.try_borrow_mut_lamports()? -= (fees + remaining_amount);
**commission_account.try_borrow_mut_lamports()? += fees;
**service_account.try_borrow_mut_lamports()? += remaining_amount;`

And I get the error sum of account balances before and after instruction do not match
What am i getting wrong here?
When I  log the amounts fees, remaining_amount, they perfectly add up to the total amount of parameter
np
ah. gotcha. thanks a lot 😄
^
In your Context struct
```Rust
associated_account: Account<'info, TokenAccount>,
```
Then in your function you can get the amount
```Rust
let amount = ctx.accounts.associated_account.amount;
```
⚓
in anchor (rust)
In typescript?
```Typescript
 let _initializerTokenAccountA = await mintA.getAccountInfo(initializerTokenAccountA);   assert.ok(_initializerTokenAccountA.amount.toNumber() == initializerAmount);
```
Is this what you're looking for?
is it possible to check balance of an token account.?

before swap & after swap
are the accounts marked with the mut attribute?
yea i used the same one on client side which was 251 but it then gave me this error ```logs: [
    'Program 4tzDAD5KLntPhT8t3gjqs85vsT5aguZTNCoeRvKkt5zr invoke [1]',
    'Program log: Instruction: Withdraw',
    "82mC2udFeQk4QqGzY7YuLMX7ivL3D6kb6ygiquCq1nYJ's writable privilege escalated",
    'Program 4tzDAD5KLntPhT8t3gjqs85vsT5aguZTNCoeRvKkt5zr consumed 7926 of 200000 compute units',
    'Program 4tzDAD5KLntPhT8t3gjqs85vsT5aguZTNCoeRvKkt5zr failed: Cross-program invocation with unauthorized signer or writable account'
  ]```
I hard-coded the bump in that exercise, make sure that's correct, what bump is the test logging in the console?
When I  log the amounts fees, remaining_amount, they perfectly add up to the total amount of parameter
What am i getting wrong here?
Hey guys I am doing this in my smart contract 
`**program_account.try_borrow_mut_lamports()? -= (fees + remaining_amount);
**commission_account.try_borrow_mut_lamports()? += fees;
**service_account.try_borrow_mut_lamports()? += remaining_amount;`

And I get the error `sum of account balances before and after instruction do not match`
why do we use "#[account(zero)]" in conjunction with account loader ?
so it cannot be used for types like token account or mint etc ? (or is it possible if not then why exactly ? )
for what kind of accounts can we use the AccountLoader type, i assume its for all those accounts made using #[accountzero_copy)] ?
<@!347689664855015424> any hints
i followed this tut
https://github.com/Kriptikz/anchor-pda-transfer-sol/blob/master/programs/pda/src/lib.rs
```anchor_lang::solana_program::program::invoke_signed(
                        &ix,
                        &[
                            ctx.accounts.pda_account.to_account_info(),
                            ctx.accounts.receiver.to_account_info(),
                            ctx.accounts.system_program.to_account_info()
                        ],
                        &[&[b"test", &[254]]]
                    )?;```
```Program failed to complete: Could not create program address with signer seeds: Provided seeds do not result in a valid address``` im getting this error while doing invoke signed with pda and sender pubkey
Hey! Has anyone ever tried to go through this solana crowdfunding tutorial? (from using Rust to using Anchor) https://learn.figment.io/tutorials/build-a-crowdfunding-platform-on-solana#introduction
figured it out. i needed to send those accounts sol. not sure why that prohibits me from cloning.
Hey! Quick questions. How come Solana Test Validator can't fetch a few accounts from mainnet? Like this one:

[2022-01-13T10:02:14.352309000Z ERROR solana_test_validator] Failed to fetch HggGrUeg4ReGvpPMLJMFKV69NTXL1r4wQ9Pk9Ljutwyv: AccountNotFound: pubkey=HggGrUeg4ReGvpPMLJMFKV69NTXL1r4wQ9Pk9Ljutwyv
In this code, what is Account type?
If I put #[account] above the struct, it's type also can be Account ?
Here you go:
https://github.com/Kriptikz/anchor-pda-transfer-sol
I thought I saw a note in twitter a month or so ago about deploying a program such that the owner was not a keypair but rather a multisig / dao of some type. Anyone have a good article / page on how to deploy a program safely so that it's not just a keypair file protecting it
void that I worked it out.
Hey guys, how can I debug why I am getting this on one of my tests? ```  Error: Signature verification failed
      at Transaction.serialize (node_modules/@project-serum/anchor/node_modules/@solana/web3.js/src/transaction.ts:583:13)
      at Provider.send (node_modules/@project-serum/anchor/src/provider.ts:116:22)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at Object.rpc [as stake] (node_modules/@project-serum/anchor/src/program/namespace/rpc.ts:25:23)

```
I don't think so -- to use the wallet I think you need to create a separate transaction that is somehow signed by the wallet instead
then find it inside of the program and transfer to it and sign transactions from it
So, I assume I need to generate the PDA address on client, pass it to program and create it with system_instructions
Hey folks! I want to be able to create a PDA, store & then transfer sol from it. How can this be done?
Hello guys, a stupid question, I am not familiar with js, do you use any extensions for anchor js code? For some cases, like `program.rpc.someFunction` I cannot jump to the source code.
Hey guys, can I use `program.provider.wallet` as a Signer for say this call: ``` Token.createMint(
            program.provider.connection,
            program.provider.wallet,
            program.provider.wallet.publicKey,
            program.provider.wallet.publicKey,
            9,
            TOKEN_PROGRAM_ID,
        )```
<@!347689664855015424>  thanks for answering my mundane questions, even more motivated to increase my knowledge depth and help around in this community like you do.
What "Account" is this referring to? And what is "T"?
```#[account]
#[derive(Default)]
pub struct MyAccount {
    data: u64
}

#[derive(Accounts)]
pub struct SetData<'info> {
    #[account(mut)]
    pub my_account: Account<'info, MyAccount>```

```Account is generic over T. This T is a type you can create yourself to store data. In this example, we have created a struct MyAccount with a single data field to store a u64. Account requires T to implement certain functions (e.g. functions that (de)serialize T). Most of the time, you can use the #[account] attribute to add these functions to your data, as is done in the example.```
ah yes correct
ya that is what i meant with no way to deallocate a allocated space once you run out of 32kb of space u cannot deallocate something already assigned space right ? its a limitation of the bump allocator
yup, 32kb. but whether you can or cannot deallocate has nothing to so with the size of the heap but the way its memory allocator is implemented
in a program context if i allocate something on the heap in an instruction , after using it i cannot deallocate it and use that heap space in that same instruction for something else , since heap is also limited to the instruction which is around 32kb i think.
an allocator that keeps growing by adding new space but does not manage memory in any other way. clearly very fast but also inefficient cause you dont get to reuse freed memory cause there is no free
feel bad having to ask some terminology every now and then, no idea what a bump allocator is etc, could you refer some reading material so i could grasp some of this jargon ?
although this might not necessarily be true on solana rn cause they use a bump allocator which only provides simple functionality but is fast
heap is slower
it strongly suggest not inlining the function. inlining would result in it not getting its own stack space
Note that in the future stack frames will be removed so this won't be an issue.
so by default its stack allocated and we can force it to get allocated on the heap, is there any downside to doing this ? i assume it is generally preferred you allocate on the stack if possible (assumption even if its true idk the reason)
tldr on what the inline macro does ?
use functions and mark them with [inline(never)] if boxing doesnt help
in your accounts struct, that is
wrap accounts in box
any idioms or patterns to solve the large stack variables error ? or in general 9 is the max number of accounts a program instruction can take and the logic should be designed around that ? also how is this limit calculated , if each stack frame is of 4 kb how is this stack frame allocated in context to how many accounts and instruction data arguments my program is expecting ?
if i do `cd client ; blah blah` then blah blah never gets run
so whatever is parsing these scripts, its not just going straight to bash
complains that `client;` is not a directory
good to know
lol
nope!
`test = "cd client; yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"` doesn't work?
whatever i just made my own intermediary script lol
but the uh syntax here seems to be different than normal bash lol
i want to simply add `cd client` in front of `mocha blah blah`
modifying the test script in anchor.toml
im getting stuck on
thanks for the help
ty ty
glad it works now
i think it was just this inconsistent casing
super. I found this little blurb helpful... bottom of this page https://book.anchor-lang.com/chapter_3/milestone_project_tic-tac-toe.html
works now lol
trying again now
yeah i did. but then i noticed there was still a hyphen in another toml
did you run `anchor build` after you changed everything?
yeah i changed this in the toml, but did not affect outcome
I think the Rust programs are supposed to be snake-cased, so `solana_twitter` or in your case `nft_lending`
appears not to
i wonder if it matters that the output in target is called `nft_lending.so`
if it does not affect `anchor build` or `anchor deploy`
appears to be being ignored? like what does this do

yeah so
lol
oh no thats a solana cli feature
but this is undocumented in --help
i just notice with anchor test you can pass a --program-id
nice
when i manually copy her keypair.json to my `target/deploy`, it deploys properly
I think that keypair gets autogenerated at the first `anchor build`. Presumably you could have the keypair created elsewhere and use whatever you want
yeah
ill copy hers..
but the one in `target/deploy` seems downstream of other steps
yes that seems right
Ok, no guarantees, since I'm just an idiot in the chat here, but probably all three should match
no we dont
i doubt it, finding out now
okay, but you have the identical keypair file in the `target/deploy/` folder?
it doesnt have this id
when i use anchor deploy
yes its the same
Sorry, no, your wallet is just the payer when you go to deploy your program. You were saying you want the program ID to be the same, right?  You set that here (see highlighting):
1) and 2) are the same
thanks for the help btw
does that seem right <@!814176793400836128> ?
which leads to 3) being different
i think we dont hve the same thing here

from anchor.toml
i think the issue is that
You will need to check three things, I think: 1) declare ID is the same, 2) the public key in Anchor.toml on the line under `[programs.localnet]` matches, and 3) that the same keypair exists in your `target/deploy/` folder
yeah it looks like `anchor build` is just making some new rando keypair for my program, and i want to supply one
how can we do that? is it a mistake to try to expect it to be constant? seems like not given the `declare_id!` function
when i deploy an anchor program, the program id is different than what it is on my friend's machine. right now this id is hard coded in lib.rs, so we obviously want it to be constant across machines.
Yea they are
got it, nice share anyway. jet is on mainnet?
Probably just not updated yet.
I expect yes, if your program will use the SPL token program, you would initialize it in your accounts struct. An example from the solana-twitter program that uses the system_program:
nice! Why is there a heavy use of AccountInfo rather than Account?
Jet has some good anchor examples

https://github.com/jet-lab/jet-v1/tree/master/programs/jet/src/instructions
or can i get account from this pub key in anchor?
can i store token account instead of only pubkey
#[account]
pub struct Account {
    pub token_program: Pubkey,
}
fabulous!
thanks username was not correct.
ok let me check
Have you checked the path to the keypair file? Look in your Anchor.toml file and double check maybe?
i already created solana account
when i run **anchor test** givinig this error
Error: Unable to read keypair file
anyone can help?
hi, how can I program a contract so that using a method requires sending funds to/from a baseaccount?
Is there a better way to search or inspect the data inside accounts that were created by an anchor program? Assuming the program hasn't created many other accounts, it's not a problem, but after it's created 100's, or 1000's, the RPC servers will get hammered every time my client tries to do this: `structOfAccounts = await program.account.ashpools.all()`
`cargo install --git https://github.com/project-serum/anchor --tag v0.20.1 anchor-cli --locked`

is this a global install? im not too familiar w/ cargo
yeah i found the docs on this
need to use `cargo install` for macos
this package is linux only
(i was able to install 0.18, but get same error)
even after installing via npm, `where anchor` still goes to cargo bin
whats the recommendation for macos users
<:raise_eyebrow:405037568930086912>

actually i may not have upgraded anchor
i updated rust, anchor, and solana cli to most recent
i've cloned a project, and all anchor commands -- `test` `build` `deploy` error out with the same error:
Thank you. Looking into it.


//////////////////////////////////////////////////////////////////////////////////////////

and why do i get this error
im trying to deploy one program

ahh - much better 🙂
anyway to generate TS typing .d.ts for program client ?
Is there a way to use cpi on an account that's not a pda?
This is about the kind of thing I was looking for
https://docs.rs/anchor-lang/latest/anchor_lang/prelude/struct.Pubkey.html#impl-FromStr
Hey everybody, anybody knows of a good example of using CPI and returning data using an intermediary account?
Ok - yeah - I don't see a method for it - but I guess just thinking it through - the string is base58 encoded -- so .. maybe this stackoverflow question is similar :
https://stackoverflow.com/questions/48996294/how-do-i-convert-base58-encoded-data-to-a-vecu8-and-then-into-a-string
Thanks !
The problem is that I need to do this in Rust. 
In Rust I have a string that I got with solana adress , and now I need to turn it into a Pubkey that gives &[u8]
correct -- all programs are owned by the system I think
that program is system token program
and is program not owned by wallet?
ok - so then who owns PDAs?  the program 'owns' them
thats right
ok in terms of what kind of account- its actually a PDA from the system token program - right?
yes!
consider a mint is just an account, right?
I think its this under the covers: https://github.com/indutny/bn.js
i am noob in solana, i make a lot of  confusion with solana
so mint is owned by 'wallet' not token program..? am i right?
Big number objetct
sorry - I don't even know what BN is  🙂 - what is it?
the mint authority is 'owned' by a wallet yes
I don't think that's right -- the mint is owned by the token program -- a system program -- so there is no wallet involved
oh you are in js land - sorry I was assuming you meant in rust
yes mint is owned by program and program is owned by wallet
i just check that token is owned by my wallet at typescript oh..
btw -- a token mint's owner isn't a wallet - -its actually the token program
like - assume it is an input into your program -- an account that is input right?  -- 
`token_account: AccountInfo<'info>,`
then you should be able to do something like:
`ctx.accounts.token_account.to_account_info().owner`
right?
I am a noob - but not 100% sure this would work - or is even what you are asking for -- but if you know the public key - you can use js to 
`let mykey = new anchor.web3.PublicKey("8YPaZ9FhHTh6FHq2pf632BWgjKw7BpuJuyCR58NOTAREALKEY");`
then
`console.log("look at the bytes mom!", mykey.toBytes());`
like `mint.getAccountInfo()` ..?
^^ if you can get that as "AccountInfo" then you can get the owner
i want to get owner wallet public key from mint token
is there no way to get owner's information?
I don't think so -- the programId is the public key of the program
Hey guys, where i can get the anchor.BN documentation?
Hey guys can i get wallet account public key from programID?
Guys, hi!
Can you please tell me how can I get an array &[u8] from a key pair?

The situation is: I generated a key with solana-keygen new, and now I want to use that key in Rust code, but https://docs.rs/anchor-lang/0.17.0/anchor_lang/prelude/struct.Pubkey.html#method.new requires an array, and I can only get the public key as a string. 

Or am I confusing something and it needs a private key?
Good morning, one question what i need to put here? the path of the json wallet? or the key wallet?
When I implement `AnchorDeserialize` and `AnchorSerialize` by hand, I get `IdlError: Type not found`: do you know why?
The size is stored just before the data AFAIK
how would add a vector as data to an account? moreover, would rust be able to intuitively see the size of the vector and/or how would that be done in anchor?
```rust
#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 16 + 16 )]
    pub vote_account: Account<'info, VoteAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,

#[account]
pub struct VoteAccount {
    pub crunchy: u64,
    pub smooth: u64,
}
```
Why is it 16 + 16 after space? 
```rust
#[account(init, payer = user, space = 16 + 16 )]
```
Shouldn't it be 24 ? 
```rust
[ 8(discriminator) + 8(u64) + 8(u64) ] 
```
Noob here
how do i accept usdc in my program instead of sol
This was really good, thanks again. I figured I'd share--Brian Friel's example anchor program (https://www.brianfriel.xyz/learning-how-to-build-on-solana/) has the most no-BS client implementation I've seen so far (3/4 through, near the bottom). Quick + dirty, but mostly easy!
I want to do staking with my token. So they will stake 1 NFT + Token A, and they will get Token B as a reward with the amount scaling based on NFT rarity. Is this something I can do using Anchor?
Thanks so much!
When we're doing any sort of arithmetic in rust, for example transferring lamports, is it best to use `check_sub` and `check_add` over `+-`?? any reason why we wouldn't want to use the safer operations in `check_sub and check_add`?
Hello, I am trying to compile a smart contract but an getting an error when trying to use the anchor_spl crate
``` use of undeclared crate or module anchor_spl```
Is it possible for a "token mint account" to run out of rent and be deleted? And if so, what happens to all the "token accounts" that belong to the "token mint account" ? Or am I understanding this incorrectly
ah ok - I think anchor test conflicts with localnet - not sure how output gets sent with anchor test
This is a good one. The helpers.ts file is super helpful (as it's name implies!).  See how he initializes the objects before his test code - then you've got easy access to the program.rpc through your idl.  https://dev.to/findiglay/building-a-blog-on-solana-2pg8
i am using msg! but when I run an anchor test, what I wrote does not appear.
I think I just realized that a mint is a PDA of the token program -- so the mint isn't owned by whoever has the auth -- it's owned by the token program itself
like debug how its running?  you can use log statements and run it against localnet then you should be able to see what's happening
I don't think you'd need to do that - you would import the rust program as a program - i.e.  something like
`use synthnew::program::Synthprog;`
sorry, how can debug the rust contract?
I'm looking for the equivalent of the following JS code in Rust. Anchor noob here.

```js
    const program = new Program(
      idl as Idl,
      id,
      new Provider(bn.conn, null, {
        preflightCommitment: 'recent',
        commitment: 'recent',
      }),
    );
```
hi! whats the easiest/best way to look up an ATA of a mint and fetch it within a program method?
Any good tutorials on writing typescript clients for deployed anchor programs? That's actually the most opaque part of this process, for me
see .anchor/program-logs
I've noticed that "anchor test" command sometimes doesn't log messages from tests, whats the problem?
Another question, when I close a program, will it handle closing the IDL account created when i called anchor idl init?
sorry for the essay lol
hello, i was reading over this escrow program (https://github.com/ironaddicteddog/anchor-escrow/blob/master/programs/anchor-escrow/src/lib.rs) and i had some quick questions regarding token transfers with anchor if anyone had a second to answer. i see there is a `set_authority` call made in `initialize`, but in `cancel` the tokens are transfered back to the initializer but I don't see any explicit instructions set the authority back to the initializer (or rather remove the vault account's authority). is the logic just that the vault will still always have the authority on the initializer's token account but since the program calls `close_account` it's not a security concern? or does `close_account` explicitly remove authority?
so figured id just start fresh and close the program
cool, seeming to run into this issue when initializing my program  Error: 3007: The given account is not owned by the executing program, definitely the owner
that works
should be an easy one, whats the best way to safely generate a new programid if I want to close the program and deploy a new one? `solana-keygen new`? use PK?


//////////////////////////////////////////////////////////////////////////////////////////

thanks - yes - but in the case of a wallet -turns out its going to be owned by the system program - so address is fine for what i'm doing
I believe this does not check anything about ownership, but just that the account address equals your hardcoded value
and doing an init_if_needed. How much space do I need to specify?
Im specifying a Account<'info, TokenAccount> for one of my instructions
it seems like "TokenAccount"s aren't owned by wallets either - they are owned by the Token program - so i guess they are PDAs too
ok yes that worked 🙂  - using "address" instead of owner
`#[account(address = Pubkey::from_str("MYHARDCODEDKEY").unwrap())]
user: Signer<'info>,`
oh wait ... its a wallet address thats why its not working b/c its owned by the system, nvm
is there an easy way to use a constraint that a specific key owns an account ?  i.e. a hardcoded one?  
I'm trying this, but it doesn't appear to work - 
`#[account(owner = Pubkey::from_str("MYHARDCODEDKEY").unwrap())]
user: Signer<'info>,`
Why not Pyth?
Does it mean there are no programs for Chainlink deployed at mainnet but only for devenet? https://docs.chain.link/docs/solana/data-feeds-solana/#Solana%20Devnet
but maybe yeah if you only want the program to be an owner of something -- you don't need to actually create that address first?
I think the init approach is if you need to store data at the PDA address
i mean - I could be wrong 🙂 -i 'm looking through the anchor examples -- there is this :
`        let (pda, _bump_seed) = Pubkey::find_program_address(&[ESCROW_PDA_SEED], ctx.program_id);
        token::set_authority(ctx.accounts.into(), AuthorityType::AccountOwner, Some(pda))?;
`
Aha, i see. so in the famous escrow one i use pda as a stateless address (just to be owner of something and later signs it). So.. I assume it's not doable anchor way. 
Thanks.
i.e. you pass the key for PDA you generated into the function and then the program will make the PDA account that way via init
if you want to use anchor for it -- yeah -- you just do 
`#[account(init, seeds = [etc etc )]
famous_escrow_pda_account: Account<'info, FamousEscrowState>,`
Any otherway to create pda?
aha, my pda is simply a pubkey. created using Pubkey::find_program_address...
ok - you can pass a PDA as AccountInfo - it should work fine
(trying to do famous escrow myself, i want to assign pda as owner of a token account, I could do it manually myself however using anchor-spl requires accountInfo)
^^ what context are you trying to use it in?
(i know we can create pda account using macro but i want empty account for just handling ownership)
Hi,

Is there anyway to convert pda pubkey to account info? (I used pubkey::find...) Or is there any anchor way to create it?
Thank you
welcome <@!908560543990837298> ser
Hello, im just new
How to generate rust clienet?
I tried to manually serialize the parameters and adding necessary accounts to build a transaction but I guess I am missing something
Hi!

How can I generate the Instructions that I can use for builind transactions from an Anchor project?
``` Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: custom program error: 0x0``` 
with this error for 2nd attempt to create
this is what I tried to test with
```describe('these words will appear before tests', () => {
  const SolanaNetworkLocalConnection = anchor.Provider.local();
  anchor.setProvider(SolanaNetworkLocalConnection);

  const SignerTestID = anchor.web3.Keypair.generate();
  const ProgramID = anchor.workspace.Thisistheprogramname; //first letter of program name has to be CAPITAL for some reason

  it('create - this is the name of test', async () => {
    await ProgramID.rpc.createfunctionname("pass this text into function to test", {
      accounts: {
        nameofaccount: SignerTestID.publicKey,
        user: SolanaNetworkLocalConnection.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      },
      signers: [SignerTestID]
    });

    const DataStructAccount = await ProgramID.account.nameofDataStruct.fetch(SignerTestID.publicKey);  //nameofDataStruct is Data struct account, first letter has to be lowercase for some reason

    assert.ok(DataStructAccount.words === "pass this text into function to test");
    _variable = SignerTestID;
  });

  it('create again - this is the name of test', async () => {
    await ProgramID.rpc.createfunctionname("pass this text into function to test", {
      accounts: {
        nameofaccount: SignerTestID.publicKey,
        user: SolanaNetworkLocalConnection.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      },
      signers: [SignerTestID]
    });

    const DataStructAccount = await ProgramID.account.nameofDataStruct.fetch(SignerTestID.publicKey);  //nameofDataStruct is Data struct account, first letter has to be lowercase for some reason

    assert.ok(DataStructAccount.words === "pass this text into function to test");
    _variable = SignerTestID;
  });

});```
Or maybe I'm not testing it correctly
It seems like I can only call it once right now
What would I need to change if I want to call the "createfunctionname" multiple times to create different Data Accounts?
```use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]  
pub mod thisistheprogramname {
    use super::*;

    pub fn createfunctionname(ctx:Context<NameOfCreateStruct>, init_message: String) -> ProgramResult {
        let test = &mut ctx.accounts.nameofaccount;
        test.words = init_message;
        Ok(())

    }
}

#[derive(Accounts)]
pub struct NameOfCreateStruct<'info> {
    #[account(init, payer = user, space = 8 + 64 + 64 + 64 + 64)]
    pub nameofaccount: Account<'info, NameofDataStruct>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}

}

#[account]
pub struct NameofDataStruct {
    pub words: String,
    pub result: i64,
}

```
~~Why isn't my `memcmp` filter not working? Printing out everything without a filter I can see that the account I'm looking for is definitely there:
```
        const states = await program.account.contentState.all([
            {
                memcmp: {
                    offset: 8 + 2 + 8 + 32,
                    bytes: ownerMint.toBase58()
                }
            }
        ]);
```
My account struct looks like this:
```
#[account]
pub struct ContentState {
    pub bump: u8,
    pub price: u64,
    pub currency_mint: Pubkey,
    pub ownership_mint: Pubkey,
    pub viewership_mint: Pubkey,
}
```~~
Okay that was dumb wrong offset
How can I transfer some custom tokens from one wallet to another in my ts tests? This seams like it should be easy, but I cant seam to work this out.
Hey, I am sketching out a solana program based on an ETH smart contract. One thing I've been wondering about:
How do programs in solana generally keep track of global values, say the list of all players that participated in a specific raffle (dumb example). I don't really want a "raffle player list" account since it would have to be passed every time someone participates in a raffle, limiting concurrency. Do programs generally track this stuff offchain?
nvm, Clients can't sign for PDAs (only your program can)
how do i sign for a pda?
to_account_owner is defined as simply wallet.publicKey in the client
Hey guys, I want to transfer some sol from my program_account to a user wallet inside a smart contract. 
`
        let program_account = &mut ctx.accounts.program_account;
        let to_account = &mut ctx.accounts.to_account_owner;
        **program_account.try_borrow_mut_lamports()? -= final_amount;
        **to_account.try_borrow_mut_lamports()? += final_amount;`

Is this correct or am i missing something?
program_account is owned by the executing program and to_account_owner is a user wallet owned by the system program
Upon running this I get the error:
`Error: 168: Program ID was not as expected`
What am I doing wrong?
So we wrote some tests for this fn - https://github.com/Triptych-Labs/goki/blob/9e61dcb171382a2ba0433761aeffd92147d05a85/programs/smart-wallet/src/lib.rs#L575

Test - https://github.com/whymidnight/steakhouse/blob/f93f4a0a1bdcac0506bac4b8350c0b65100f6490/src/staking/tests/unwidthdraw/unwithdraw.go#L156

But when we ported the process to our React app, `@solana/web3.js` would either complain about wrong seeds or CPI escalation. Anyone mind helping my team out? A SOL is on the table 🙂
Very basic question - how do I log in an anchor program? I see solana uses the `msg!` macro but going through the examples (https://github.com/project-serum/anchor/tree/master/examples/tutorial) I see no mention of logging on the rust side of things
If a transactions is signed by a sender sending lamports, can the instructions of the transaction call a program owned by the receiver (who has authority over program to be called) but who has not signed the transaction because they are only receiving lamports? Or will the receiver also have the sign the transaction if the receiver wants the transaction instruction to call a program owned by the receiver?
if anyone got "Error: 3007: The given account is owned by a different program than expected 0000"   then make sure in program lib.rs declare_id!(xxxx)  is same as "solana program deploy path/to/app.so"  return
sounds out of my scope rn :/
Sort of—you'd have to encode them into the cpi instruction's own data.
Can you pass instructions into a cpi?
now getting "Error: 3007: The given account is owned by a different program than expected 0000"
the pub struct is the structure that I can consult from web3 to my contract?
hi i have a noob question
I want to do staking with my token. So they will stake 1 NFT + Token A, and they will get Token B as a reward with the amount scaling based on NFT rarity. Is this something I can do using Anchor?
<@!134416332509675520> fyi got it working, wasn't passing in mut on the containing context
thanks a lot
thanks i just found it from there
Maybe I'm not understanding the question, but do you not get what you need from /target/types?


//////////////////////////////////////////////////////////////////////////////////////////

ah, nice
as I understand, using Box<> stores the account info on the heap
so that frees up stack space
Thanks! Could you explain how that makes it possible under the hood?
and would prob have to be linear
(you'd need to match up the client calcs with whatever is done in the program)
i've been handling time issues by just saving a timestamp whenever the value changes, as well as the value, so that the next time you need it you just calculate whatever it is based on the: time diff and old value. won't work for all use-cases, but is one approach
^^ can you have another program that runs on a timer and calls the recover function ?
Well, I am developing game nfts. It has attribute hp. hp is reduced when it get damage. And it must be recovered over the time. How can I handle HP-recover? program hasn't got timer I think.
Hi I am getting this error after upgrading anchor to 20.1
```
error[E0609]: no field `mint` on type `anchor_lang::prelude::AccountInfo<'_>`
 --> programs/src/instructions/init_collateral_account.rs:6:10
  |
6 | #[derive(Accounts)]
  |          ^^^^^^^^ unknown field
  |
  = note: available fields are: `key`, `is_signer`, `is_writable`, `lamports`, `data` ... and 3 others
  = note: this error originates in the derive macro `Accounts` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: can't compare `&anchor_lang::prelude::Pubkey` with `anchor_lang::prelude::Pubkey`
 --> programs/src/instructions/init_collateral_account.rs:6:10
  |
6 | #[derive(Accounts)]
  |          ^^^^^^^^ no implementation for `&anchor_lang::prelude::Pubkey == anchor_lang::prelude::Pubkey`
  |
  = help: the trait `PartialEq<anchor_lang::prelude::Pubkey>` is not implemented for `&anchor_lang::prelude::Pubkey`
  = note: this error originates in the derive macro `Accounts` (in Nightly builds, run with -Z macro-backtrace for more info)
```
```
use anchor_lang::prelude::*;
use anchor_lang::Key;

use crate::state::*;

#[derive(Accounts)]
#[instruction(bump: u8)]
pub struct InitializeDepositAccount<'info> {

    #[account(has_one = market_authority)]
    pub market: AccountLoader<'info, Market>,

    pub market_authority: AccountInfo<'info>,

    #[account(has_one = market,
              has_one = deposit_note_mint)]
    pub reserve: AccountLoader<'info, Reserve>,

    pub deposit_note_mint: AccountInfo<'info>,

    #[account(mut, signer)]
    pub depositor: AccountInfo<'info>,

    #[account(init,
              seeds = [
                  b"deposits".as_ref(),
                  reserve.key().as_ref(),
                  depositor.key.as_ref()
              ],
              bump = bump,
              token::mint = deposit_note_mint,
              token::authority = market_authority,
              payer = depositor)]
    pub deposit_account: AccountInfo<'info>,

    #[account(address = anchor_spl::token::ID)]
    pub token_program: AccountInfo<'info>,
    pub system_program: AccountInfo<'info>,
    pub rent: Sysvar<'info, Rent>,
}

pub fn handler(_ctx: Context<InitializeDepositAccount>, _bump: u8) -> ProgramResult {

    msg!("initialized deposit account");
    Ok(())
}
```
select rust, and expand the snippet
https://solana-cookbook-git-fork-losman0s-using-mainnet-6e845e-cookbook.vercel.app/references/accounts.html#get-sol-balance
Hey guys! Is there a function in anchor to get the sol/lamports balance of a pubkey? in rust?
this makes sure that the discriminator data in the account passed is empty/zero: https://docs.rs/anchor-lang/latest/anchor_lang/__private/enum.ErrorCode.html#variant.ConstraintZero
how did you that?
>  rebuilt it with another program
I cant figure out how did you fix it. I am try it many times 🙂
hey guys,  can someone help me understand what this means :  #[account(zero)]
Yes thanks a lot for reply. Problem was solved by Box.
use Box accounts `Box<Account<'info, something>>`
Hello,

How to get rid of the following error : 
Error: Function _ZN11test__private8__global10buy17hba2d086706def913E Stack offset of -5280 exceeded max offset of -4096 by 1184 bytes, please minimize large stack variables

regards
Haven't tried it yet but I don't see why not. Technically it would be two CPI calls in the same function, init does the first one that creates the account and then you do a second one to transfer to that initialized account.
awesome, so it is possible to do a cpi token transfer from an existing tokenaccount to the one I just init in the same instruction?
I do that in this example project I'm working on:
https://github.com/Kriptikz/anchor-token-vault
```Error: Error loading workspace IDL```

what does this mean when running anchor test
This might be kind of a dumb question but I'm assuming there's no way to easily call an anchor function from another function (bc it needs all the info required in context)

Like lets say I have a redeem function people can call.
But I also have a close account function

I want my close account function to call the redeem function before it runs.
In solidity you just add that function to the declaration or whatever

In solana I need access to all those accounts so I can't do that.

I guess I just create a mod with that shared functionality and import it / call it or?

Just wondering if anyone has any good rust examples of doing this in a clean way

-Thanks
I'm having troubles installing Anchor on my MacOS. This is the command I'm using 
`cargo install --git https://github.com/project-serum/anchor --tag v0.20.1 anchor-cli --locked` and this is the error I'm getting . Any help would be much appreciated!
Can anyone explain the relationship or provide addition resources to help me better understand the relationship between 
#[derive(Accounts)] and #[account] 

do #[derive(Accounts)]  have their own address?

https://project-serum.github.io/anchor/tutorials/tutorial-1.html#defining-a-program
```#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 8 + 8)]
    pub my_account: Account<'info, MyAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[account]
pub struct MyAccount {
    pub data: u64,
}```
How do I init a TokenAccount thats owned by my program? If I'm doing an account init I believe I need to pass in the keypair as one of the signers which I'm not sure how to do
```anchor init name``` is giving me 
```Error: String is the wrong size```
oh yeah, that's how I caught the issue in the first place. It did place it as a warning at first though
My guess is to comply with popular linters
https://giphy.com/gifs/z1GQ9t8FxipnG
Hi, I just ran into a this error while running an `Anchor test` :

```Transaction simulation failed: Error processing Instruction 0: custom program error: 0x65```

Took me a while to figure out that writing my rust `fn` name in snake case while calling it as snake case in the  `program.rpc` object was the reason for the error. 

My question is why though?
i guess you could write the lottery part somewhere else if you wanted to and then use command line tools to transfer winnings ?
no 🙂 thats great
do you still want to know given that i solved the issue by updating solana cli?
what does your Cargo.toml file look like?
Hello, incoming noob question: Do you think it will be possible to build simple lottery just using SPL token program from Solana? or you think it will require developing own programs ?
Let say its a  simplest lottery : users buy tickets with the coin and play, if they win they receive tokens.
no issues if i just use cargo build instead of anchor build
it could be that anchor is using the wrong version of rust?
and i cant edit this package's
my manifest already has cargo-features line on it
any knowers know how to address this error?

edit: solved, i had to update solana cli


//////////////////////////////////////////////////////////////////////////////////////////

hey guys, any idea how to build vaults with Anchor and get an LP token?
Oh that's nice! Thank you.
I ended up wrapping code that needed the wallet in a 
`useEffect` loop like this:

`  useEffect(() =>{
    if(!props.wallet || !props.wallet.publicKey){
      console.log("wallet empty - returning");
      setListItems(<li>Scanning Wallet....</li>);
      return;
    }
    //this code here happily using the wallet
  }, [props.wallet]);
`
so when the wallet changed it would re-run
sure -- I don't understand it all either - sometimes helps just to try and explain it or have someone to talk with 🙂 - it is weird that WalletContextState isn't a wallet -- sometimes it takes a while for the wallet to initialize maybe -- so it could also be that its being used before its ready
Yes using react. And I have created a Wallet.tsx react component that wraps all the other pages, which contains the <ConnectionProvider> tags, but it's all in some convoluted way that works and yet I barely understand. Thinking maybe I should simplify and understand it a bit better, first. Thanks for the suggestion!
i see that `spl_associated_token_account::create_associated_token_account` requires me to provide ""[writeable] Associated token account address to be created" as an AccountInfo in the `invoke_signed` used to call the instruction

does this mean i need to initialize an empty Account and then just pass that in? if so how is that done in rust? so far ive only created new accounts in js
if you are running on devnet you can check in solscan
its just a guess!  hope it helps 🙂
If my program instruction throws an Err, are all the new init accounts not created? Sorry I'm learning more about anchor
I know mine is on mainnet since a long time 😄
let me try that
Good goblin! You are too good
maybe try by just setting your solana config to devnet?  could it be a key mismatch?
Hey Guys, I tried to "anchor deploy --provider.cluster devnet" and got this error: 
`Error: Deploying program failed: Error processing Instruction 1: custom program error: 0x1
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }`
are you using react or no ?
not sure if this is why --- but running in react I found I needed to wrap any components that referenced useWallet inside <ConnectionProvider></ConnectionProvider>
thanks a lot for sharing
huh, and here i was thinking the `owner` attribute was only a check
gm. Sort of puzzled here on using a connected wallet with an anchor client... A few examples use the `wallet-adapter-react` adapter with an anchor Provider, but, when I do the same w/ useWallet or useAnchorWallet, I am getting a mismatch of types: "WalletContextState not assignable to parameter of type Wallet." I understand *why* this is a problem, but not really how to resolve it. Any suggestions appreciated. Example:
`import { useWallet } from "@solana/wallet-adapter-react";
// ...
const wallet = useWallet();
const connection = new Connection(selectedNetwork, "confirmed");
const provider = new anchor.Provider(connection, wallet, "confirmed"); // <-- mismatched type occurs here 
`
Thanks for any help!
and then it worked!
so I had to mark it with this:
`    #[account(owner = Pubkey::from_str("MYPROGRAMID").unwrap())]`
the other thing I was doing was passing in 
`AccountInfo<'info>,` for a PDA from another program - and that was also failing
so that should fail b/c the account isn't a mint
ok -- so one thing that was wrong that I was doing was using 
`Account<'info, Mint>,` for an account that wasn't a mint
hahaha, I just wanted to try to understand why changing that solved that issue. Not checking the discriminator would explain it
sure -- its still not working 🙂 but i can dm it to you when it is
We manage to do it as:

```
...

let mut account_info_data = to_account.try_borrow_mut_data()?;
let buff: &mut [u8] = &mut account_info_data;
let mut cursor = std::io::Cursor::new(buff);
my_decoded_account.try_serialize(&mut cursor)?;

msg!("My logs {} {} {}", my_decoded_account.amount, shares[counter], counter);
```

Do not know, if it is the way, but it is working now! Thanks for help and showing direction!
<@!569289717582135296> could I see the entire context's definition? I'm still learning anchor and still don't understand when to use AccountInfo. I understand it's an account that is not deserialized, therefore anchor doesn't check its discriminator?? When would it be usefull then?
thanks 🙂 -  turns out i copy/pasted `Account<'info, Mint>,` instead should have been  `AccountInfo<'info>,`
the blockhash part of the new candy machine is useless
Isn't that predictable?, I mean, everyone can see the previous blockhash. I'd imagine having the code and the seed anyone could anticipate the value
I'd remove `mut` from different account attributes until the error disapeared
for this error :  
`'The given account is owned by a different program than expected`
is there a way to find out which account it is referring to?
Candy machine does this in an interesting way looking at the previous blockhash. I’d check out their code
`...but data from 'ctx' flows into 'ctx' here`
I got this error because of the lifetime
ok I was able to successfully deploy to localnet when starting the validator with `--no-bpf-jit`. I don't really get why :/
Thank you
great!!
ah yeah - you can't sign for it -- which makes sense of course 🙂
right, I get it now
and notice how it only returns the address (public key), I need a keypair in order to sign
ok right - the account can only be created by the program - as you said
yes, that gives me the address, but it doesn't actually create the account
I think i found an answers. If I read it right, a PDA can only be created from the program it's derived from since it needs the program's signature for the creation transaction
ok - so like from js?  then you can use 
 web3.PublicKey.findProgramAddress, right?
Anywhere, for now I'm testing from the programs own test script.
^^ where is the client?
I need to create a PDA for a program before calling it. `init` doesn't help in this case. This account needs to use multiple seeds for address derivation. But the SystemProgram instruction only accept a single String.
How come anchor always deals with arrays of seeds but SystemProgram.createAccountWithSeed only accepts 1 seed??
Is there a devnet faucet for usdc?
Thank you! If it is not hard for you, could you please share some doc or example how to do it correctly?
youre changing a struct that was deserialized from the account data. For normal accounts (not from `remaining_accounts`), anchor persists changes to deserialized structs. For accounts from `remaining_accounts`, you have to do it yourself
Hi, all! I have maybe stupid question, but if I pass some account to `remaining_accounts` as writable, than I get it in my instruction, cast it to actual account and try to change, inside intruction, it logs that account changed, but when I fetch it after instruction in tests - my changes were not applied. Maybe I missed something or did something wrong?

```
pub fn transfer_multiple(
        ctx: Context<TransferMultipleInternal>,
        shares: Vec<u64>,
    ) -> ProgramResult {
        let balance_from = &mut ctx.accounts.from;
        let mut counter = 0;
        if ctx.remaining_accounts.is_empty() {
            return Err(ErrorCode::DemoErrorCode.into());
        }
        for to_account in ctx.remaining_accounts {
            let my_decoded_account = &mut match Account::<Balance>::try_from(to_account) {
                Ok(account) => account,
                ProgramError => return Err(ErrorCode::DemoErrorCode.into()),
            };

            my_decoded_account.amount = match my_decoded_account.amount.checked_add(shares[counter])
            {
                Some(e) => e,
                None => return Err(ErrorCode::DemoErrorCode.into()),
            };
            msg!("My logs {} {} {}", my_decoded_account.amount, shares[counter], counter);
            counter += 1;
        }
        Ok(())
    }
```
I'm still having an issue where running `anchor build` + deploying to a local validator results in the transaction pending in `Finalizing transaction` forever...
Using `anchor test` works fine, also using an M1. Wondering if there have been any solutions to this 😦
Which does not exist
You UX data is wrong and it ventures into the fallback
yeah, that's what i've been reading, but can't we get entropy from execution times? ie: make a cpi call and measure how long it takes
There isn't really a super easy way to do this in your contract besides finding some way of inserting randomness from the outside world, as far as I know
been looking for a while, I see an accepted answer is asking too much
Hey, what's the accepted way of getting a random number?
```Error: Permission denied (os error 13)``` 
now i'm getting this when I try to run anchor init
when I try to run anchor init I'm getting ```Error: Workspace already initialized```
not sure what I did, it was working fine earlier
```remote: warning: File blog/app/test-ledger/rocksdb/000858.log is 75.07 MB; this is larger than GitHub's recommended maximum file size of 50.00 MB```

How do I delete these test-ledger files? Won't let me do it manually
So what does `    #[msg("Fallback functions are not supported")]` mean?
oh i see, thanks
0x65 = 101
my error code isnt in there?
https://github.com/project-serum/anchor/blob/master/lang/src/error.rs

you can find some info here
how do i debug errors like this? `    Program F1y1FTP91nwxbNUW3nXY6mKQzWawihwVYGwMsi7oKGyg failed: custom program error: 0x65`
Does anyone know why I get the error below when I run "anchor test" locally?
```Unable to start test validator.```

Found an answer
https://github.com/project-serum/anchor/issues/989
I think it comes from where you set the variable "provider" to

for example
```  const provider = anchor.Provider.local();
  anchor.setProvider(provider);```
Hi all 🙂 Where does the publickey from the following javascript command come from: program.provider.wallet.publicKey?
So just making sure this is right, a 10mb account would cost about 70 SOL in rent? lol
Hm yeah got it -- easier to do from the v2 program. Is it common to have this function available as an instruction that can be sent into the program by say only the authority that deployed the program. Like an upgrade_account instruction... since the program won't execute anything automatically when deployed
hey man i need a tutorial to build a swap pool and farms on my dapp 
Atrix  or Raydium which one i should use ?
Since you can only pass in so many in one tx
And it'll be somewhat painful to be honest, since you'll have to pass in each and every account you want to migrate, presumably in multiple different transactions
Very interesting
But you'd need to specifically write the logic for it
Got it
Well, maybe
Nope, not in there unfortunately
You would need to add an instruction to your program to do the migration
https://project-serum.github.io/anchor/cli/commands.html#migrate

I guess that's the intent of the migrate command? That you can add this kind of logic to your own migrate script?
Or is it just with like the solana CLI and using the program's authority?
Any public examples of this?
Yep, nothing will happen automatically
Will you need to migrate all the previously generated PDAs to new accounts with the updated struct as you launch the next version of the program?
What happens if you want to change the struct for a PDA between program versions?
based on the trx, can anyone tell what im doing wrong
ive searched a few discords and i can't find anyone else asking about that error
https://explorer.solana.com/tx/2U3oqdpqL63btJa3p7oVg2eJQKGhdYDmh4wYfH2MXzXqdfpYsZoZPXeR1JQGXNFsCeNwYWKHMqJwe9Hrq45GYxQM?cluster=devnet working on upgrading a cli function in metaplex to work with v2 cm. getting 3005 error  [
    LangErrorCode.AccountNotEnoughKeys,
    "Not enough account keys given to the instruction",
  ],
If you're in node you can do `(program.provider.wallet as NodeWallet).payer`
Hey guys is there a way to use `program.provider.wallet` as a Signer type?
invoke_aigned
Not directly in your solana program as far as I know, at least not yet
I think for local util functions you can  - but I’m a rust newbie - don’t really understand the contexts that well - mostly following a pattern cargo cult style
<@!134416332509675520> ☝️
One question about the error message
- Current error message is `failed to send transaction: Transaction simulation failed: Error processing Instruction 0: custom program error: 0x1777`

But I wanna a error message like this: `6007: Not Acceptable Data`
No, don't think that's possible (not unless someone/something other than the user initiates the first transfer)
Hey guys, is there a short cut way in the anchor/serum ts package to transfer custom token from one address to another?
got it. I'm basically wondering if this order could be reversed. Something like program pays user, user submits transaction, user reimburses program. I'm assuming that is not possible? I can't think of any way to do it but I'm not very experienced
But you could have your program control some funds and send the user some reimbursement as part of the tx I guess.
As far as I know you can't do this strictly-speaking (for example, the user will have to pay to submit the transaction, and that fee applies regardless of whether the tx succeeds or not).
is it possible to create a program where the program is required to pay the gas fee instead of the user?
Yeah, can't do it within the solana program itself
<@569289717582135296> Is possible call a function without params and context?
No worries, ser. Thanks for your answers! I had the feeling it wasn't going to be possible either way 😄
yeah - I don't know how you would do it? maybe you could have programs calling each other and waiting?
sorry!
Yeah, was thinking of that as well. Just wondered if it could be done directly in the program
^^ I don't think so - but you could make a timer run outside maybe and invoke the method?
Hey there, I was wondering if there is some way I can implement something like a setTimeout/setInterval in a Solana program. Basically, every fixed interval, I'd like to run a piece of code
its rust syntax - dereferencing i think?
this is I think the rust code on the other side --- 
https://github.com/ironaddicteddog/anchor-escrow/blob/master/programs/anchor-escrow/src/lib.rs  
-- the rpc method being called is "initialize"
this is from a initialize function inside a program
sorry -- was replying to djanstr 🙂
good question - I guess I don't really know what that syntax means
```authority = *ctx.accounts.authority.key```

what does the * in front of ctx mean in this context?
Thanks for reply. Quick question - in this test script (link to github shared above), ironaddicteddog has already generated a keypair for escrowAccount on client-side. what is the escrowAccount.createInstruction for
^^ isn't it creating the initial escrow account?
This is the src - https://github.com/ironaddicteddog/anchor-escrow/blob/master/tests/anchor-escrow.ts
hey guys, can someone explain what this is for in escrow example? 
instructions: [
                await program.account.escrowAccount.createInstruction(escrowAccount),
              ],
Is possible call a function without params and context?
I think the answer is yes -- I guess I can throw out the bump ?
they are EVM compatible and their proof of stake algorithm is supported by some deep learning algos as far as I know. But they are officially supporting Solana ecosystem and even Solana is listing them on their page as a partner.
want to verify that someone holds NFT a before unlocking NFT b
is getting an associated token account address the same as find program address ([walletKey, tokenProgramKey, mintKey],  associatedTokenProgramKey) ?
kind of unfortunate getting 429 errors when running my test suite
yes deploying/upgrading the program is basically sending the executable binary data broken down over many transactions
https://twitter.com/0xGoki/status/1471167946412019716
Okay, guess this is expected for upgrading programs as it's a buffer of data the BPFUpgradeableLoader
It's not just a log these are transactions live on devnet
^^(too)
it happens to me to -- I think someone forgot to take out a logging statement somewhere
Just started happening. No idea why.
Any idea why when I run anchor test transactions start spamming > 100X? 

```
msg 3yDPiGZxoPvzEJ3Kmo6sAGiTLJUj9yzFGWmGrFLW3eDP
msg 3yDPiGZxoPvzEJ3Kmo6sAGiTLJUj9yzFGWmGrFLW3eDP
... X 100
```
There's still a lot of improvements to make to solana so a fork doesnt really make sense
If it's just a fork, why would people use velas and not solana?
but if it diverges in meaningful ways than probably not
will probably work with velas if it uses the same runtime as solana
no idea
Hi all 🙂 Will it be possible to use Anchor to interact with Velas (as it is Solana fork) in the future? Do you have this on your roadmap :P?
Hi, I'm having trouble importing the cpi module of another crate when i do ```use ___::cpi::accounts``` it keeps saying unresolved import (im using rust-analyzer on vscode). I've added ```[features]
no-entrypoint = []
no-idl = []
no-log-ix-name = []
cpi = []``` in the cargo.toml of the callee and ```callee = {path = "../callee/", features = ["no-entrypoint","cpi"] }``` in the cargo.toml of the caller. It compiles though so is it an IDE error?
You and me both. Try https://hackmd.io/@ironaddicteddog/solana-anchor-escrow


//////////////////////////////////////////////////////////////////////////////////////////

usually can be run by anyone
off-chain process that invokes some smart contract (program) function
similar
js
thx goodgoblin, I'll try that
cranks!  i don't know i haven't heard of them 🙂 sorry  -- quick google - maybe its something from Serum? https://docs.projectserum.com/serum-ecosystem/help#what-is-crank-turning
what are cranks have heard this quite a few times ? Is it same as CRON job ?
oh ok - just looking at your logs it looked like maybe you were running a "built" version of react v.s. like npm start -- I don't know if it makes a difference or not - but if you are running a "built" version can try and clean it out and rebuild - or just run with npm start
I tried to start/stop the test validator on the localhost but it doesn't work anyway... I am just following step by step the full stack dev guide, it's weird that this doesn't work. I'll try to build it up again. Tks for checking though  !
Is the client also rust?  sorry I don't have exp running a rust client -- have only used javascript to test etc.
I don't know - do you mean like - based on the number of decimals in the mint -- does that alter what the total supply really means?
sorry! same kind of thing is just working for me:
`
import { getPhantomWallet } from '@solana/wallet-adapter-wallets';
`
I have it as part of a react project -- does it work in local testing?
I think the basic idea you are looking for is to make the tickets PDAs that are decorators to the mints that are part of the NFTs - something like that 
https://docs.metaplex.com/architecture/deep_dive/overview#decoration-as-pda-extensions
you could write all the state to your program on the chain - but I think you'd have to monitor and update it via a non-chain client - at least thats what I would assume
i made a simple vault -- i don't think i can help you -- but I guess you could store the date the vault was created and then check agains it when you try and unlock?
hey I'm trying store a 4 len byte array on-chain. my instruction is accepting the param as a [u8; 4] type, but I get `src.reduce is not a function` when trying to pass it in from the client. Should I be accepting it as a String and then convert that to the byte array in the program?
hey guys, is there a unction for parsing and showing spl tokens with the proper decimal point? Like formatEther on ethers. Thanks
Hi guys, I tried to run the front end app but I got this error, is there anybody who can help me ? 🙂 Attempted import error: 'getPhantomWallet' is not exported from '@solana/wallet-adapter-wallets' (imported as 'getPhantomWallet').
assets by path static/js/*.js 5.13 MiB
  assets by chunk 1.85 MiB (id hint: vendors)
    asset static/js/vendors-node_modules_toruslabs_solana-embed_dist_torus_esm_js.chunk.js 1.22 MiB [emitted] (id hint: vendors) 1 related asset
    asset static/js/vendors-node_modules_blocto_sdk_dist_blocto-sdk_umd_js.chunk.js 517 KiB [emitted] (id hint: vendors) 1 related asset
    asset static/js/vendors-node_modules_ledgerhq_hw-transport-webhid_lib-es_TransportWebHID_js.chunk.js 130 KiB [emitted] (id hint: vendors) 1 related asset
  asset static/js/bundle.js 3.26 MiB [emitted] (name: main) 1 related asset
  asset static/js/node_modules_project-serum_sol-wallet-adapter_dist_esm_index_js.chunk.js 9.64 KiB [emitted] 1 related asset
  asset static/js/node_modules_web-vitals_dist_web-vitals_js.chunk.js 6.87 KiB [emitted] 1 related asset
  asset static/js/_7874-_ed1b-_d17e.chunk.js 576 bytes [emitted] 1 related asset
asset asset-manifest.json 1.99 KiB [emitted]
asset index.html 1.67 KiB [emitted]
cached modules 4.69 MiB (javascript) 32.6 KiB (runtime) [cached] 442 modules
Hi, everyone. I am following this tutorial to create a ticket system (https://www.fmendez.com/building-a-simple-on-chain-point-of-sale-with-solana-anchor-and-react). I would like to modify the smart contract so that each ticket is NFT. Can someone help me?
does anyone have experience with building vaults? got a few questions about how to implement lock up periods, vault capital caps, calculating PnL based on varying amounts of deposits and total capital in the vault, as well as varying amounts of days in how long capital stays in a vault
also if anyone is wondering the same thing, i think you just init the large zero_copy account and pass the PDA in from client side, then when you’re actually reading/writing to it in future and using `#[account(mut)]` you can enforce the seed constraints. not 100% certain yet though as i haven’t tested it out myself
receiver in that example isn’t a PDA but easily could be
this is how i did it, idk if there’s a more elegant way to do it with anchor though
Does anyone have any references of programs that use lamport amounts in the program?  For example, transferring SOL instead of tokens to a PDA

Found answer:
https://stackoverflow.com/questions/70528742/how-to-transfer-sol-in-anchor-smart-contract-instruction/70574227
https://dev.to/dimfeld/starting-with-solana-part-4-4j5k
The program account is an account that holds some data that points to the executable bytecode (which is also an account). They both hold rent accordingly wrt their size (bytes)
Could someone explain to me the relationship between the "Program Account" and the "Program Executable Data Account" and are the SOL balances for each account the rent that the account is currently holding?

Would the #[program] part be the "Program Account" and the #[derive(Accounts)] be the "Program Executable Data Account"?
but I could be wrong
because you don't know the size
from what I've read you don't want to use Vec in solana
did you ever have success with this? I'm trying to do something similar
ah, haha. very simple. Thank you <@!831450660146642974>. You are god of Anchor and Rust!!!👍
https://github.com/solana-labs/solana-program-library/blob/master/token/js/client/token.js#L2282 allowOnwerOffCurve to true
Hi. <@!831450660146642974> I am trying to get associated token account. Its owner is PDA.
but Error occurs. I can't find why error comes out.😢  Help me!🙏 
``` 
 const [authority, bump] = 
    await anchor.web3.PublicKey.findProgramAddress(
      [Buffer.from("authority")],
      programId,
    );
 
  let tokenAccount = await Token.getAssociatedTokenAddress(
    ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, tokenMint, authority);
```
7TXTjiXn2GqLU3o26LX1aYan5vFtGV28HVAHo9ww3DP7 is authority.
Please help me!
anyone get this issue? ```% anchor --version
Only x86_64 / Linux distributed in NPM package right now.
Trying globally installed anchor.
Globally installed anchor version is not correct. Expected "anchor-cli 0.18.2", found "anchor-cli 0.20.1".```
thanks! its from a "hello world" increment counter
I believe
baseaccount is signing the transaction for running the create function
is this from a specific example?
those accounts are the inputs to that function apparently
well you're calling the 'create' function from the rust smart contract
Can someone explain the "signers: [baseAccount]" line at the bottom?
What is it saying the "baseAccount" variable we generated is a signer of?
Wouldn't the "user" be the signer? 

```  it("Creates a counter)", async () => {
    /* Call the create function via RPC */
    const baseAccount = anchor.web3.Keypair.generate();
    await program.rpc.create({
      accounts: {
        baseAccount: baseAccount.publicKey,
        user: provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      },
      signers: [baseAccount],
    });
```
for anyone else wondering the issue was I was using token:: not associated_token::
hey, I'm following the book and I'm a quarter of the way down when it first wants me to compile and I get this:

`
PS F:\SoftwareProjects\Rust\tic-tac-toe\programs\tic-tac-toe> anchor build
BPF SDK: \\?\C:\Users\Paul\.local\share\solana\install\releases\1.9.4\solana-release\bin\sdk\bpf
Can't get home directory path: environment variable not found
`

relevant details:

`
PS F:\SoftwareProjects\Rust\tic-tac-toe\programs\tic-tac-toe> solana --version
solana-cli 1.9.4 (src:8ce65878; feat:3258470607)

PS F:\SoftwareProjects\Rust\tic-tac-toe\programs\tic-tac-toe> yarn --version
1.22.4

PS F:\SoftwareProjects\Rust\tic-tac-toe\programs\tic-tac-toe> rustc --version
rustc 1.57.0 (f1edd0429 2021-11-29)

PS F:\SoftwareProjects\Rust\tic-tac-toe\programs\tic-tac-toe> anchor --version
anchor-cli 0.20.1

`


does anyone have any idea what I should do?

this is on Windows 10
The wallet calling the transaction is authority. I'm not sure what account I'm missing here that needs to be signing
but I get:
```
Error: Signature verification failed
```
If I try and call this function.

How do I create a token account for a user in anchor?
If I need to send a custom spl token but the user has no token account for it?
I assumed it was:
what do i do
i cant close it nor sign for it because it was done through the ATA program
I accidentally set a token accounts authority to itself and im realizing
theres no way to delete it or transfer from it right?
if you make a TokenAccount's owner itself, and the address is the associated token account
does this mean i can't use seeds for `zero_copy` accounts then? <:thonk:908303306038837258> 

not sure how i'll generate the pubkey for the state account in that case tbh <:sweatingman:599601488095870979>
Hello, may I know is it safe to use `usize` for the field inside account struct? for example,  struct user {pub index: usize, pub authority: Pubkey,}, will it generate deserialize issue?
definitely better ways to word this lol
it should sth like, "without it, a program would be vulnerable to a type confusion attack (which is a subtype of account injection attacks)"
hmm well actually I see how
how is it misleading?
So is the language in the "details" (expanded section) under here: <https://project-serum.github.io/anchor/tutorials/tutorial-1.html#initialize-instruction> is kind-of misleading then?
the discriminator checks that the given account is the expected state account from the state accounts the program has. so if a program has state accounts of type X, Y,Z, the discriminator checks that given account is e.g. type X.

you still need to check that the given account is actually owned by the correct program (which the Account type does for you)
Thank you; it looks like 'type parameter' is pretty much the answer I was after (as featured in Rust book)
Off the top of my head, in spoken language I'd probably call it the type-specifier, or type-specializer, or specialized-type or similar, depending on what I was trying to say about it.
From anchor tutorial/docs, re. 8-byte discriminator:
> Importantly, this allows a program to know for certain an account is indeed of a given type. Without it, a program would be vulnerable to account injection attacks
How does this protect against account injection? Couldn't an attacker figure out the discriminator by looking at any of the owned PDAs and copying the first 8 bytes into their malicious account before the crafted data?
What is the generic name for the Rust language thing between the < > signs?
If it was a function argument I would expect it to be within ( ). So I'm not sure what to call it
yeah -- I think it might be the timing issue there -- just a guess -- b/c it returns something right? it returns a WalletContext ?
Thank you. I am able to do everything I need using the local code and a test client within my anchor project. Currently, I am trying to build a client with an imported IDL, and the anchor 0.20.1 npm package installed, and my trouble is in setting the provider. Back to my original question, I guess I don't really understand why the `const provider = new anchor.Provider(connection, wallet, preflightCommitment);` would reject a `wallet` type that comes from the `useAnchorWallet()` feature from `@solana/wallet-adapter-react` package. Like, shouldn't they be the same or at least compatible?
if you are running locally -- i.e. from the command line -- maybe try this:
`      let wallet = anchor.default.Wallet.local();`
thank you!
Even more simple,  I am unsuccessful at importing or using the `anchor.Wallet` feature:
`
    import * as anchor from '@project-serum/anchor';
    // ...
    const keypair = new anchor.web3.Keypair(); 
    const awallet = new anchor.Wallet(keypair);
// ERROR:
// Attempted import error: 'Wallet' is not exported from '@project-serum/anchor' (imported as 'anchor').
`
what can cause       Program failed to complete: Access violation in stack frame 3 at address 0x200003a28 of size 8 by instruction #11500 ? I am getting that error before it even starts to run my code. How do you debug an issue like that?
new_with_signer is what you are looking for
then ``` let cpi_program = ctx.accounts.token_program.clone();
        let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer);```
you put the nonce and the seeds
```let seeds = &[
            ctx.accounts.check.to_account_info().key.as_ref(),
            &[ctx.accounts.check.nonce],
        ];
        let signer = &[&seeds[..]];
        let cpi_accounts = Transfer {
            from: ctx.accounts.vault.to_account_info().clone(),
            to: ctx.accounts.to.to_account_info().clone(),
            authority: ctx.accounts.check_signer.clone(),
        };```
you need to add the nonce and other stuff in order to sign. Have an example will send it
you can't pass the pda as signer, but since it's a pda it can sign the transaction as long as it's run in the program that it's derived from
I think i need to pass both the wallet key and the PDA key as "signers" - but not sure how to do it --- or do I not have to do it and all possible signers will be sent and I must have messed something up?
im getting this error:
"Cross-program invocation with unauthorized signer or writable account"
for the token set_authority program - I am trying to transfer authority for a vault token account owned by a PDA to a wallet --
interesting - try this 
`ls -la ~/.cache/solana/`
ls: .cache/solana/v1.21/bpf-tools: No such file or directory
well - try 
`ls -la .cache/solana/v1.21/bpf-tools`
should I run with sudo maybe
not sure
is it a permission problem?  why can't it write to that location?
getting this error when I run anchor build or anchor test
```Failed to install bpf-tools: Unable to write ".cache/solana/v1.21/bpf-tools/tmp-solana-bpf-tools-osx.tar.bz2": Custom { kind: Other, error: reqwest::Error { kind: Body, source: hyper::Error(Body, Custom { kind: UnexpectedEof, error: IncompleteBody }) } }
```
i don't know 🙂 i guess you could try it and see - i've initialized fields after the account was created - but I think you mean like add a new field ?  maybe it depends on how big it would be  -- how much space etc - ?  sorry -- i really don't know that much about how anchor works under the covers
Can I add more fields to an account once it’s created?
I think for rust  'edition2021' you need later than 1.56.0
idk -- I'm running this version of rust :
rustc --version
rustc 1.59.0-nightly (c5ecc1570 2021-12-15)
also rustup 1.24.3 (ce5817a94 2021-05-31)
how do I check if it's compatible ?
im on 19. 1 -- I think its some kind of rust setting - I know that's not helpful - but maybe check that the version of rust you have is compatible ?
just updated to v 20
is there a fix for this ?
```  feature `edition2021` is required
```
Liquidity Pool token
Cheers mate! It was ofcourse devnet and also had to airdrop some sol to actually deploy.
whats an LP token?


//////////////////////////////////////////////////////////////////////////////////////////

Hi .
I want to lock my tokens in contract for some time Which i am doing successfully.
**But how can i transfer back tokens to user who locked..?**

Can anyone help me or provide any example how to tranfer token from contract to user token account.
Thanks.
Success! Thank you.
How can I create an account for each one of my users where I can write data scoped to them by their User Wallet Pubkey?
https://dev.to/dimfeld/starting-with-solana-part-4-4j5k
this might be a good starting point, its a tutorial for a to-do list where each item on the list has an amount of SOL attached to it and is released when the task is marked complete
Is there anything about controlling program funds in the documentation? I would like the program to have funds in it and send them to the users under certain conditions
ahhhh thank you!
I want to create a token that will be used as a reward for playing some betting games on my site. Does it make any difference how I create it:  using CLI or  programmatically? 
Token has to be created once right? and then with CLI I can mint or burn periodically.
What are the benefits of programmatic creation of the tokens?
you can use the metaplex example. calling raw solana programs always looks the same, no matter whether the caller is an anchor program or not. you have to use the solana syscalls. you or the non-anchor program devs can ofc write functions to make it look nicer to anchor programs. which is what we have done for the token program. see the spl/token directory for that
i am trying to build am anchor protocol but im very blocked because idk how to invoke CPI a non-anchor program
paulx pls save me 🙏
Not really no, my use case is for calling my own programs and SPL ones
any examples of anchor that do CPI with a user-created protocol? E.g. CPI with Mango Markets
hmmm looks like it only uses spl and system program
But they use plain old solana_program for lots of stuff
They use anchor to define their own programs and contexts
haha true
None of my own yet until I get them working 😅
ohh but metaplex repo isnt in anchor 😦
do you have code examples 😮
duuude
Lifetime specifiers in Rust
Np apollo! I'm very familiar with CPI related frustration XD
Hey! Can someone explain what does the `'info` mean here?

```
pub struct Transfer<'info> {
    pub from: AccountInfo<'info>,
    pub to: AccountInfo<'info>,
    pub authority: AccountInfo<'info>,
}
```

I tried searching for it in the documentation but could not find it.. maybe it's more of a Rust question than specifically anchor? Thanks!
Thanks Ax!!
https://github.com/metaplex-foundation/metaplex-program-library/blob/master/nft-candy-machine/program/src/lib.rs#L247
Metaplex does it quite a few times
I'm trying to do CPI with a non-anchor program. It would be *extremely* helpful if I could see an example of this being done. Anyone know a resource?
As I understand, you can try using the constructor for AccountMeta which only needs the pubkey and then somehow build an AccountInfo from that?
thanks apollo and paul
Generate PDA, use anchor init
the init cmd creates and inits the account
Im still learning and was more so exploring options. Thinking about it, a PDA does make more sense
do you know what a PDA is?
why would you want to do that?
coupled with this
https://docs.rs/spl-token/latest/spl_token/instruction/fn.initialize_mint.html
this is what I was looking at
https://docs.rs/solana-program/latest/solana_program/system_instruction/fn.create_account.html
My real question was whether its possible to create the account used to init the mint on-chain as well, or if that should be passed in always?
https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html#spl-constraints
theres also the documentation
perfect thanks a lot, its pretty easy with anchor looks like
https://github.com/cqfd/anchor-token-studies
ill send u another one of his repos
Will dig around jet
Thanks, I dont think quidpro initializes a mint onchain though?
also, download "Jet Protocol"'s code base
https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo/src/lib.rs
anyone have an example of creating a new account + init a mint onchain?
I wish there was documentation where we could find the answers to these questions. I feel like every anchor dev should know these things
Very interesting. Did not know that. Good to know!
not the struct name though
awesome. Thanks so much paul
yes
I can rename the fields on my smart contract later, as long as the data itself remains the same right?

E.g. 
```
#[account]
pub struct MyStuff {
  pub dont_know_yet: Pubkey,
}
```

After I deploy the program, I can change `dont_know_yet`'s name to anything I want without causing problems, right?
Huh, it seems that my problem is due to the account created being just zeroes, even the discriminator.  I might be doing something wrong, I'll try to figure out if I'm doing something wrong before filing an issue. Thanks for answering tho, have a good one
just like you are doing now should work. pls file an issue with all your code if it doesnt
I'm a bit slow, so sorry about that lol... but I'm kinda lost. In my use case, which account would be `puppetPublicKey`? Follow-up question, how do I fetch such account using `program.account.<account-name>.fetch`?
yes
no, you can fetch it like any other account
Does that mean that if I initialize an account derived from `puppetMasterProgram` and even though it's owned by `puppetProgram` it's actually an account from `puppetMasterProgram`?

Basically, I'm creating something else entirely that I won't be able to easily "fetch" using anchor rpc namespace
i meant created by my program

gotcha, hmmm... That makes things tough lol. What's the usual workaround for that? Creating anticipated fields in advance?
wdym program-owned? all accounts are owned by programs. If youd like to extend the size of an account, you cant (yet, solana changes are coming)
hey paulx! Can I add fields to a program-owned account once it's created on the Solana blockchain?
the account `puppetPublicKey` refers to is not of type `puppet`
Thanks a lot <@!347689664855015424> that solved my error, I'm getting another error now tho. I'm getting `Error: Invalid account discriminator` when trying to `const puppet = await puppetProgram.account.puppet.fetch(puppetPublicKey);` 

Reading through the Anchor code it seems like the account discriminator for my newly created PDA doesn't match anchor expectations, any pointers to what could be causing this?
the puppet master program can create a pda that is owned by a different program using `owner = ` but that PDA must still be derived from the puppet master program. So in your js code, it should be `puppetMasterProgram.programId` as `findProgramAddress`'s last argument
Although I'm seeing this error:

> > Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account 
> >     Program 2W3NGfaYKz13aqtncJYgWEQUmzKcVhuKanHet5MCd8tx invoke [1]
> >     Program log: Instruction: CreatePuppet
> >     7AXEWRVSPavHvQtVzxCzQ5UKBRPgQ2mFtrcuH2hxjw1b's signer privilege escalated
> >     Program 2W3NGfaYKz13aqtncJYgWEQUmzKcVhuKanHet5MCd8tx consumed 8343 of 200000 compute units
> >     Program 2W3NGfaYKz13aqtncJYgWEQUmzKcVhuKanHet5MCd8tx failed: Cross-program invocation with unauthorized signer or writable account
Hey there frens, has anyone ever tried to create a PDA from a Program A to a Program B?

I'm trying to do this:

```rust
#[derive(Accounts)]
#[instruction(arguments: CreatePuppetArguments)]
pub struct CreatePuppet<'info> {
    #[account(mut, has_one = authority)]
    pub puppet_master: Account<'info, PuppetMaster>,
    // This is supposed to created a PDA in the Puppet program
    #[account(
        init,
        payer = authority,
        space = 5000,
        owner = puppet_program.key(),
        seeds = [
            b"puppet".as_ref(), 
            puppet_master.key().as_ref(),
        ],
        bump = arguments.bump,
    )]
    pub puppet: Account<'info, puppet::Puppet>,
    #[account(mut)]
    pub authority: Signer<'info>,
    pub system_program: Program<'info, System>,
    pub puppet_program: Program<'info, puppet::program::Puppet>,
}
```

And I'm calling it like this:

```typescript
const [puppetPublicKey, puppetBump] = await anchor.web3.PublicKey.findProgramAddress(
      [
        Buffer.from('puppet', 'utf-8'),
        puppetMasterKeypair.publicKey.toBuffer(),
      ],
      puppetProgram.programId
    );

await puppetMasterProgram.rpc.createPuppet({
      id: puppetId,
      bump: puppetBump,
    },{
      accounts: {
        puppet: puppetPublicKey,
        puppetMaster: puppetMasterKeypair.publicKey,
        authority: puppetMasterProgram.provider.wallet.publicKey,
        systemProgram: anchor.web3.SystemProgram.programId,
        puppetProgram: puppetProgram.programId,
      },
    })
```
Hey Guys, I just got this error when I was fetching data. Any ideas on where the error is pointing to?

`Uncaught (in promise) TypeError: Cannot read properties of null (reading 'subTree')`
correct
Sorry for the mega-block of text
The solution I came up with would be to have another instruction to be called through CPI for each single data point, that way the PDA can be derived for every single one
```rust
#[derive(Accounts)]
#[instruction(index: u32)]
pub struct AddOneCtx<'info> {
    #[account(
        init, payer = signer,
        seeds = [b"add", b"some_other_seed", index.to_le_bytes()],
        bump,
    )]
    pub data_point_acc: Account<'info, DataPoint>,
    pub signer: Signer<'info>
    pub system_program: Program<'info, System>,
}

pub fun add_data_point(ctx: Context<AddOneCtx>, index: u32, data_point: DataPoint) -> Result<()> {
    ctx.accounts.data_point_acc.set_inner(data_point);
    Ok(())
}
```
And then the first instruction would end up like this
```rust
pub fn add_data(ctx: Context<AddCtx>, data: Vec<DataPoint>) -> Result<()> {
    for i in 0..data.len() {
        // Add a PDA for each data point
        let index = ctx.accounts.add_acc.n_accounts + i;
        // Build the CPI context
        todo!("This is where I'm stuck");
        // Make the CPI call
        data::cpi::add_data_point(program_acc_info, cpi_ctx)
    }
    ctx.accounts.add_acc.n_accounts += data.len();
    Ok(())
}
```
I'm able to get all the public keys for the accounts that need to be included in this context, using `Pubkey::find_program_address`. However, I can't find a way to invoke an instruction by just including the public keys in the context, it already needs the `AccountInfo`s.
To summarize, my question is, how can an instruction send an account to another instruction, when it can't receive it in its context?
Does anyone know how to solve the following problem?
I have a program instruction that needs to create a variable number of accounts depending on an external factor. These need to be PDAs, because they need to be accessible later. The way I'm doing this is by adding the number of currently created PDAs as a seed for the next one. The instruction looks something like this.
```rust
#[derive(Accounts)]
pub struct AddCtx<'info> {
    #[account(
        mut,
        seeds = [b"add", b"some_other_seed"],
        bump
    )]
    pub add_acc: Account<'info, AddData>,
}

#[account]
pub struct AddData {
    pub n_accounts: u32,
}

#[account]
pub struct DataPoint {
    // Some data I want to store in an account
}

pub fn add_data(ctx: Context<AddCtx>, data: Vec<DataPoint>) -> Result<()> {
    for _ in 0..data.len() {
        // Add a PDA for each data point
        ...
    }
    ctx.accounts.add_acc.n_accounts += data.len();
    Ok(())
}
```
or are they actually different things?  i.e. creating a token account via the token program and greating an associated token account via the ata program result in 2 different accounts -- they do kind of the same thing but under the covers they aren't strictly the same?
ok - so associated token accounts are actually token accounts -- i.e. they are the same thing -- the difference is only that ATAs addresses are deterministically generated based on the wallet/mint combo?
it's just a way of standardising PDAs for token accounts i think
and the ATA is what i'd be looking for when i'm sending you a token
you can make token accounts with whatever addresses you like, but for each user + mint there is only one associated token account
an associated token account is just a token account generated by the token program iiuc
thank you -- makes sense now - i didn't understand the difference btw token account and associated token account and was confused - appreciate the explanation!
thank you  - sorry I didn't realize token account and associated token account were actually different things
Add null/error checking where necessary
Something like
```js
const responseAcc = await program.accounts.response.fetchNullable(pubKey);
const response = responseAcc.yourBool;
```
The way I understand it, no. The main idea is to create an account that your instruction should write its response into, and include it in your context. After invoking the instruction, your client can fetch that account and read the data.
https://github.com/project-serum/anchor/blob/e48f84c6bd7122a7d7744be2a9b25b7e8d2efc11/tests/ido-pool/programs/ido-pool/src/lib.rs#L117

For IDO Pool example.Does someone know a way how can I implement a functionality to allow only 10% withdraw at max. ? Do I need to maintain state of it somewhere in a PDA of user ? Any better approach
anyone knows what can be the problem? thanks
Hello guys, i have this problem with the anchor build command , it says : Failed to obtain package metadata: `cargo metadata` exited with an error: error: failed to load manifest for workspace member `
Can we return a result from an `anchor` instruction handler?
```
pub fn getBool(_ctx: Context<Initialize>) -> ProgramResult<bool, ProgramError> {
Ok(false)
}
```
And from client do something like:
```
const response = await program.rpc.getBool(...);
assert.equal(response,false);
```
In short how do I handle response types that are not errors or void?
the mint is like the address for the actual token itself, token accounts (and associated token accounts) are where instances of this token mint are stored. 

for example, if i have an NFT, there is only one token with the mint address for this NFT. when i have it, it’s in a token account that i own. when i send it to you, i pay to create an associated token account (that you own) for that mint and then i transfer the NFT from my token account to your new token account.
I have seen some blockposts about downgrading my solana version, but not sure if thats a good idea in general
thx a lot John! It's just that I applied all these steps, and it still seems to not work. Is there any other possibility that there is a anchor version mismatch? I even cross-compared the IDL on devnet (with `anchor fetch`, and the IDLs seem to be fine!)
Hey, are there bindings for the shared memory program within anchor?
Hi, can I use HashMap in Anchor code? I heard that Solana program doesn't support hashmap. right?
https://paulx.dev/blog/2021/01/14/programming-on-solana-an-introduction/#the-token-program-part-1
no. mints are referred to as mints.
using anchor
Are there any examples of safe sending custom amount of sol?
gm
Noting this here because someone might search for it and I just spent a long time figuring this out: If you're using the "--clone" feature and getting a "Attempt to load a program that does not exist" as part of "Transaction simulation failed" it is likely that you cloned the program but *not* the program data account. You need to clone both.
Do command + click on vscode to see the implementstion of that function
Pretty sure borrow is borrowing the reference to the lamports field
Could someone explain what this means
```let account_lamports = **item.to_account_info().lamports.borrow();```
specifically the "**" and "borrow()"
```solana config set --url localhost```
then check
```solana config get```
then run in a separate window
```solana-test-validator```
and then in original window
```solana airdrop 1```
then check
```solana account <your address>```
I've already airdropped SOL to my local wallet, which has 4 sol atm
Hey there I'm just getting started. When I run `anchor deploy` in the `basic-0` tutorial I get:
``` Error: Account <my public key> has insufficient funds for spend (1.06508184 SOL) + fee (0.00078 SOL)
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.```
but when i using phatom i can not get keypair right?
for signers
you see i am using keypair here 
 const offer = anchor.web3.Keypair.generate();
yes i have code using TS and sign by keypair below
but how i can using phatom for it? many thank
 const offer = anchor.web3.Keypair.generate();
  console.log("offer : ", offer.publicKey.toBase58());
  const [escrowedMakerTokens, escrowedMakerTokensBump] = await anchor.web3.PublicKey.findProgramAddress(
    [offer.publicKey.toBuffer()],
    program.programId
  );

  await program.rpc.make(
    escrowedMakerTokensBump,
    new anchor.BN(1),
    new anchor.BN(200000000),
    {
      accounts: {
        offer: offer.publicKey,
        offerMaker: myWallet.publicKey,
        offerMakersMakerTokens: offerMakersMakerTokens.address,
        escrowedMakerTokens: escrowedMakerTokens,
        makerMint: addressNFT,
        takerMint: MINT,
        tokenProgram: spl.TOKEN_PROGRAM_ID,
        rent: anchor.web3.SYSVAR_RENT_PUBKEY,
        systemProgram: anchor.web3.SystemProgram.programId,
      },
      signers: [offer]
    });
i assume you mean how to sign a function with a phantom wallet? you basically need to create a transaction and then use the wallet to sign it -- then you send it
thanks
Hi all ,
how can i using phantom signers for my rpc function?
I guess check the permissions on the file
thanks for explaining! so in practice are these "token accounts" what are referred to as "mints"?
i keep trying to deploy to mainnet fork and continue to get the 

Error: Pubsub error: ConnectionError(Http(Response { status: 405, version: HTTP/1.1, headers: {"server": "nginx/1.18.0 (Ubuntu)", "date": "Wed, 19 Jan 2022 00:58:45 GMT", "content-length": "0", "connection": "keep-alive"}, body: None }))
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.

any idea how to fix this ?
is this discord active?
and it always gives me permission issues
i give the exact location to my key
does anyone know why I cant do this command?

how is rent determined for a zero-copy account? Does it just use the Default size of the data in the account?
ahhh rugged myself. bad endianness. thx for being my rubber duckies
rm-ing the uint64 seed passes
something weird is happening, I'm init-ing a pda using the ix signer pubkey ++ epoch. but I get inconsistent errors on diffferent invocations:

err 1:
```
<PUBKEY_OF_PDA>: signer privilege escalated
'Program 11111111111111111111111111111111 failed: Cross-program invocation with unauthorized signer or writable account'
```

err 2:
```
provided seeds don't result in valid address
```
https://github.com/project-serum/anchor/blob/master/lang/src/error.rs#L5
Hello, I'm just wondering if we could have some custom token with balanceOf() override, just like ERC20 in solidity, so that we can change balance of every tokenAccount without mint of burn? Anyone know how that works? thanks in advance.
it is well defined. its an account owned by the token program of the token program account type which is also called  "Account"
a mint can in theory have infinite token accounts. a user can have multiple token accounts and even multiple token accounts for a single mint. but a user can only have one associated token account per mint
or actually, and idea why I could be getting the `0x64` error?

```
Transaction simulation failed: Error processing Instruction 1: custom program error: 0x64 
    Program 11111111111111111111111111111111 invoke [1]
    Program 11111111111111111111111111111111 success
    Program 5W8cgQkGhjniKuVikNyVq6Nh5mWVzHawRnXkWhL7risj invoke [1]
    Program 5W8cgQkGhjniKuVikNyVq6Nh5mWVzHawRnXkWhL7risj consumed 927 of 200000 compute units
    Program 5W8cgQkGhjniKuVikNyVq6Nh5mWVzHawRnXkWhL7risj failed: custom program error: 0x64

``` 

this is what the RPC call looks like:
```
return await this.program.rpc.create(bump, arg1, arg2, {
      accounts: {
        state: stateAddress,
        pool: poolAddress,
        tickmap: bitmapKeypair.publicKey,
        payer: payer.publicKey,
        rent: SYSVAR_RENT_PUBKEY,
        systemProgram: SystemProgram.programId
      },
      signers: [payer, bitmapKeypair],
      instructions: [await this.program.account.tickmap.createInstruction(bitmapKeypair)]
    }) 
``` 

any thoughts would be really appreciated 😅
I'm using anchor 0.20.1, and I need to reinstall because getting some `0x64` errors while using anchor
when I reinstall solana 1.8.5 (previously using 1.8.12), do I need to uninstall / reinstall my anchor from scratch as well?
anyone have any more examples of progams that uses the amount of lamport transferred in a transaction as an input?
for example, user1 sends 10 SOL to  user2, I'd like to take the "10" SOL from the transaction and use it in a program to increment a data account (where counter += amount of SOL user1 sent to user2)
ergh arguments in wrong order
Thanks!
Hmm I'll take a look
^^ idk but maybe you can use wrapped sol for it?  
https://spl.solana.com/token#wrapping-sol
Hey guys, is there an example program where I can create an account, fund it and then transfer the funds programmatically?
got it. I tried to code but the error is silent. Solana makes it so difficult.. why 😩
I think "token account" isn't well defined -- I think "associated token account" is what you kind of mean by it -- b/c I don't know what "token account" would be -- except for "mint"  - which maybe thats what it's meant to be?  its a good question
commented it out, looks like none of the accounts are being recognized as valid params
a bit confused about this argument err I'm getting.

Setup: 2 programs in the same anchor workspace, each with the correct program_ids in their respective files

Error: Invalid arguments: config not provided

Config is an account the ix expects, and I'm definitely passing it in. The variable is no undefined either so that's not the issue
hey, from what i read i am confused between associated token account and token account. So are you saying I can create 2 token accounts for a mint and transfer tokens among them? or does it have to be from one token account to another associated-token account
afaik -- each time you want to transfer or mint_to one of the tokens from the mint - it goes into a token account - so if thats what you mean by 2 token accounts -- then yes
Total noob question here - Can there be 2 Token accounts for same Mint? Does every mint have only one token account?
Yeah I feel like I was just looking at it comletely the wrong way
it defintely takes some getting used to 🙂
eth thought me nice 😄
For some reasons accounts seem so confusing to me because I think like shouldnt it be like a struct mapping or something
After looking through it a bit more I cant say for certain but my idea is that... On a transaction the signer that initialises pays the rent. But the program spends it
not sure exactly -- but maybe constraints could help? or you could use "init_if_needed" ? 
https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html
for PDAs good question - idk who pays the rent -- i thought the program but i don't really know
How can I use a custom error message when a collision on the initialization of a PDA account occurs?
Error: 2003: A raw constraint was violated
and the rent is then paid by the signer?
Ah okay so Im guessing on the anchor tutorial for example...  Each time initialise is being called by a different contract a new account gets created?
I think you’d put it in a token account that was owned by a PDA
What would the correct approach be for anchor?
On solidity I would use an address mapping key to a uint value
I am struggling coming from solidity 😛 lets say I was going to build a mechanism where people would deposit an SPL token in a vault
Ok I guess check and see what the IDL json supports
https://twitter.com/0xpemulis/status/1483115445389508610?s=21 just saw this ‘crank’ expl and thought of <@832140329301311488>
Thanks, i realized that solana doesn't handle balances numbers in the same way that etherium.


//////////////////////////////////////////////////////////////////////////////////////////

Are there any good guides on how to connect wallet and approve transactions with phantom on a React UI? Do I have to fetch the IDL everytime?
ok - I think the path is via "wallet.signTransaction" -- will go down that path 🙂
I have kind of a dumb question -- is there any way to use a wallet in a dapp to sign a transaction?  i.e. to prompt the user to agree to sign it?  or should i just be generating throwaway keys to sign things?
check and see what is in anchor.workspace.Calculator
Can Someone Please Help me out with this error i get whenever i run anchor test
is there a good example somewhere of transfering lamports? all I'm getting is errors saying the program needs to own the account to modify it?
another noob question: does the `with_signer` method of the `CpiContext` assumes that the last seed is the always bump? So I have to tack on the bump onto the seed list I used for `Pubkey::find_program_adress`?
gotchu
you cant access the caller from inside an instruction but you can ask the caller to pass in their account (or pubkey as ix data)
if it wasnt the providers pubkey, youd have to add it too, because `user` pays for `BaseAccount`'s creation
so, i want to set some constant params which are not going to change ever. they will be assigned by whosoever calls the initialise function for the first ever time. how do i do so
you can omit the `user` because it's the provider which pays for the tx and therefore anchor already has it registered as a signer
shouldn't the user go here? like provider.wallet?
not sure what you mean
```
await program.rpc.initialize({
    accounts: {
      baseAccount: baseAccount.publicKey,
      user: provider.wallet.publicKey,
      systemProgram: SystemProgram.programId
    },
    signers: [baseAccount] <-- add this
  });
```
can you guide me on how to do so? i guess the new error is associated the signing itself.
eesh, that is what it was. so sorry. tysm for the help.
oh, damn, right. so how do i restrict initialize to only one address, that is of the first caller?
maybe you did some renaming half-way and forgot to update the client side?
did you rename your `basic_0.json` file on purpose, to make this client work? I see that you are importing it with that name, while the module is called `splits_program`, which will lead to `splits_program.json`
also again, dont think this is related to your error but youre missing the `signers` array here. `BaseAccount` is getting created so its keypair has to sign
<@!691933164909756466> not related to your error but you can omit the `inited` property and this check `ctx.accounts.base_account.inited == false` in your initialize function. When you use the `init` constraint on an account, it will fail if the account already exists. Therefore, `ctx.accounts.base_account.inited == false` will always be true. Also, because your `BaseAccount` does not hold types with dynamic sizes, you can implement `Default` for it and omit the `space = 9000` (you cannot do this for `AdminAccount` because it contains a `Vec`)
as you can see, im not accepting any params
you can find the short program here: https://github.com/xedk/solana-splits/blob/main/programs/contracts/src/lib.rs
The error says "you tried to access index 0, but your array is of length 0"
Have you already posted this function, maybe?
just a runtime one
that is a still a program error
the program builds flawlessly
no, i'm not accessing any remaining accounts in this fn
are you perhaps accessing some `remaining_accounts` in your program, while not providing one?
this is a program side error, can you post that?
this is my client.js ^
```
const anchor = require("@project-serum/anchor");
const { SystemProgram } = anchor.web3;

const provider = anchor.Provider.env();
anchor.setProvider(provider);

async function main() {
  const idl = JSON.parse(
    require("fs").readFileSync("./target/idl/basic_0.json", "utf8")
  );

  const programId = new anchor.web3.PublicKey("51NDADRmoBvRPa4PQz7WixDurvS5SXncdnWGhM7nuNqK");
  const baseAccount = anchor.web3.Keypair.generate();
  const splitAdmin = anchor.web3.Keypair.generate();

  const program = new anchor.Program(idl, programId, provider);

  await program.rpc.initialize({
    accounts: {
      baseAccount: baseAccount.publicKey,
      user: provider.wallet.publicKey,
      systemProgram: SystemProgram.programId
    }
  });
}

console.log("Running client.");
main().then(() => console.log("Success"));

```

hey folks! im getting this error while running client.js
also writing tests for anchor programs? Should we just follow the standard solana program way?
ik about cpi on the solana library, but is there a specific way we should use it with anchor?
like how would i do it with anchor?
What to tell?
can anyone tell me about anchor and cross program invoking other anchor programs?
Hello, I'm currently working on using Systemtime on solana program.
but it constantly emits error, (it panicks) so I wonder how I could get current UTC time from rust file. 
Can you guys give me the clue?
Anyone know where I can find how transaction signatures are computed?
I feel so relieved rn, seems like I did finally understand it 😅 Thank you so much as always <@!134416332509675520> !
And yep, an associated token account is really just an associated token address (a pda derived from the associated token program), since the account itself is still owned by the spl token program
A token account both has that token-account kind of data as well as its AccountInfo owner field (the program owner) set to the spl token program
Yep, token account stuff goes in the corresponding AccountInfo's `.data` field
Also, I wanted to clarify a few things I've been confused about. 

So, a standard Account of Solana has the following fields, 
```
pub struct AccountInfo<'a> {
    pub key: &'a Pubkey,
    pub is_signer: bool,
    pub is_writable: bool,
    pub lamports: Rc<RefCell<&'a mut u64>>,
    pub data: Rc<RefCell<&'a mut [u8]>>,
    pub owner: &'a Pubkey,
    pub executable: bool,
    pub rent_epoch: Epoch,
}
```

Please let me know if any of the following points are wrong -

- This is mandatory for every Account that exists.
- The `owner` here is the **Program** that owns this account

Now, for a Token Account, or to be more specific, in `spl_token`, the struct `Account` is as follows:
```
pub struct Account {
    pub mint: Pubkey,
    pub owner: Pubkey,
    pub amount: u64,
    pub delegate: COption<Pubkey>,
    pub state: AccountState,
    pub is_native: COption<u64>,
    pub delegated_amount: u64,
    pub close_authority: COption<Pubkey>,
}
```

So, my first question is that, is this `spl_token`'s `Account` struct, what is stored in the `data` field of the `solana_program`'s `AccountInfo`?? 

Another question I have is that, is a TokenAccount is any account with the above mentioned struct as its `data`?? And an Associated Token Account is a TokenAccount with a specific address, or to be more precise a PDA derived from the Associated Token Program???
You'd have to build the instruction yourself, similar to what anchor does here: https://github.com/project-serum/anchor/blob/master/lang/syn/src/codegen/program/cpi.rs#L39
The `instruction::` thing just specifies the data part of the instruction, not the accounts (or the program_id, but I guess that should be clear from context)
Hmm, I'm actually not sure if there's a super easy way to go from that `instruction::CreateAuctionHouse` type to an actual solana instruction
```
  let transaction = Transaction::new_signed_with_payer(
    &[
      instruction::CreateAuctionHouse {
        bump: bump,
        fee_payer_bump: fee_payer_bump,
        treasury_bump: treasury_bump,
        seller_fee_basis_points: 10000,
        can_change_sale_price: true,
        requires_sign_off: true,
      },
    ],
    Some(&payer_key),
    &[&fee_payer_key, &treasury_key, &fee_payer_key],
    context.last_blockhash,
  );
```

```
expected struct `solana_sdk::instruction::Instruction`, found struct `mpl_auction_house::instruction::CreateAuctionHouse`rustc(E0308)
lib.rs(47, 7): expected struct `solana_sdk::instruction::Instruction`, found struct `mpl_auction_house::instruction::CreateAuctionHouse`
```

I'm trying to write some rust based specs for Metaplex auction house contract but am encountering a type mismatch when applying the instruction. Anyone have some examples of testings anchor programs in rust? I see there is an anchor rust client that accepts anchor structs but how do I connect that to the bank_client provided by the solana sdk test package?
Hi there, coming from buildspace with a quick rust question. i was going through the tests but can't seem to find anything relevant..
I want to remove an entry from a Vec, i've seen .remove and .retain but not sure
Just not possible to skip that in solana
And if you want to transfer sol to it, there's unfortunately no way around having to pass it back in from the client
You could store a Pubkey as a pointer to the actual account info though
Nope, that won't work unfortunately
can i store an AccountInfo or Signer as a field inside my #[account] struct? Trying to add the required lifetime gets me a Borsh serialization trait error. If not, is there a way for me to store an account and not just a pubkey, so that I can later transfer sol to it?
Yep, actually <@!448034961652449283> added it 🙂
is this pubkey thing a new thing? Must be, feels pretty useful
interesting
Check out `anchor idl --help`
Yeah, you have to explicitly upload it
i.e. doesn't default to having it
thanks, is upload different process than deploying with anchor?
You can try running `anchor idl fetch <prog-id>` (no guarantee one has been uploaded though)
alan do you know if one can find IDLs for a given program id?
```.rs
const admin_pk: Pubkey = anchor_lang::solana_program::pubkey!("asdfasdfsad");
```
```.toml
[dependencies]
...
solana-program = "1.9.2"
```
Ok I'm actually pretty confused about wtf rust/cargo is doing here, but solana_program has a macro to do just this, `pubkey!`. For some reason I have to add an explicit dependency on `solana_program` to my program's Cargo.toml (I don't know why, since anchor_lang re-exports solana_program 🤔)
There is a way but I'm trying to figure out how to use it :/ 1 sec
I am hardcoding a pubkey so to make certain functions "admin only"
You can pass in the admin account every txn, maybe use anchor constraints to check it? Not sure if possible
is there any other way to hardcode public key?
Is there a way to find the IDL for a given program ID? (Not my program)
Yeah, can't do a const pubkey like that unfortunately
for `Pubkey::new(pubkey_bytes);`
getting "calls in constants are limited to constant functions, tuple structs and tuple variants"
```const pubkey_bytes: &[u8] = "Hih8kbSfSdZQRJe1Sb3piCCzeuvtuHrqKt1oMi5yWqRm".as_bytes();
const admin_address: Pubkey = Pubkey::new(pubkey_bytes);```
Ok, then you'll have to use the `anchor_lang::solana_program::system_instruction::transfer` instruction + `invoke`
making an auction program so i need to send sol between the auction account and a phantom wlalet
yes it is
How you send sol depends on which program owns the source account. Is the source account here a wallet?
Nope, that's only for actual spl tokens (native sol isn't a token—you might be thinking of "wrapped sol")
hey ive been struggling to send native sol between two accounts - is anchor_spl::token::transfer the way to do it?
```
Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: custom program error: 0x0
```

This error is not in anchor, I think it's coming from here? https://github.com/solana-labs/solana-program-library/blob/master/token/program/src/error.rs#L13

But my account is definitely rent exempt...
that doesn't use `simulate` tho
You're going to have to explicitly write out all lifetime params for your instruction function, unfortunately:
```.rs
pub fn your_instruction<'a, 'b, 'c, 'info>(ctx: Context<'a, 'b, 'c, 'info, YourInstruction<'info>>) -> ProgramResult {
  ...
}
```
error: lifetime mismatch ...but data from `ctx` flows into `ctx`
Gonna be hard to explain it better than just reading the rust book: https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html
`ctx.accounts.msg_sender.to_account_info()` gives error
```
anchor_lang::solana_program::program::invoke(
                &ix,
                &[
                    ctx.accounts.msg_sender.to_account_info(),
                    ctx.remaining_accounts[index].to_account_info(),
                ],
);
```
The ondisk format is just [<32 bytes of private key> <32 bytes of public key>]
weird asf
yeah for some reason it looks that there was already an account using that address, rebuilt it with another program id and it deployed
Or can this keypair be generated using the solana cli?
Hi friends. Im trying to use https://docs.rs/solana-sdk/1.4.14/solana_sdk/signature/fn.read_keypair_file.html to read a keypair into a rust program, just wondering what format the json file should be in for this to work?
Account<'info, BlogState> can someone explain this to me in plain English? I am trying to understand lifetimes and what `'info` literally means here
Thank you very much.
It worked. I was looking to this documentation to make the code, maybe i got the concept of "owner" wrong this time
You then ask the spl token program to modify that mint (to get it set up to be a mint), but it can't do that because you set its owner to be the payer, not the spl token program
Definitely weird to `create_account` with the last argument as the payer (it's supposed to be the *program* that owns the account, here it would be the spl token program)
Are you sure there isn't already an account using that address?
there should be good instructions on the "Create react app" site -- im not an expert in react or create-react-app -- but yeah -- there is a way to "eject" - which just means all the config is open to you to change - and you can add the missing polyfills
any tips on what i can do to fix this and actually deploy to devnet
```
Error: Account <program address here> is not an upgradeable program or already in use
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }.
```
I'm trying to deploy to devnet and I'm getting this

The deploy wallet has enough SOL (10), I've used anchor build and updated the program id in lib.rs and in anchor.toml, and i've even added ```cluster = "devnet"``` under provider in anchor.toml
you can get the error code, and guess you can cast `LangErrorCode.InstructionMissing` to the right type to compare?
```ts
    try {
      const tx = await program.rpc.initialize({});
      console.log("Your transaction signature", tx);
    } catch (e) {
      console.log("error", e.code);
    }
```
ok sorry I was battling different versions for my anchor CLI, npm package, and crate
That might be the solution to this damn bug haha
I did use that command- how do I eject and which command to recreate the app? Thanks
Hi guys, any ideia why I'm getting this issue? `instruction modified data of an account it does not own`. Here is my codebase:
```rust
    pub fn create_mint(ctx: Context<CreateMint>) -> ProgramResult {
        let create_account_instruction = create_account(
            ctx.accounts.payer.key,
            ctx.accounts.mint.key,
            ctx.accounts.rent.minimum_balance(82).max(1),
            82,
            ctx.accounts.payer.key
        );

        invoke(
            &create_account_instruction,
            &[
                ctx.accounts.payer.to_account_info().clone(),
                ctx.accounts.mint.to_account_info().clone(),
                ctx.accounts.system_program.to_account_info().clone(),
            ]
        )?;

        let initialize_mint_instruction = initialize_mint(
            ctx.accounts.token_program.key,
            ctx.accounts.mint.key,
            ctx.accounts.payer.key,
            Some(ctx.accounts.payer.key),
            0
        ).unwrap();

        invoke(
            &initialize_mint_instruction,
            &[
                ctx.accounts.mint.to_account_info(),
                ctx.accounts.rent.to_account_info(),
            ]
        )?;
        Ok(())
    }
```
in my TS tests after calling an instruction
`assert(res.value.err == LangErrorCode.InstructionMissing`
No sure I got what you are trying to do?
How do I do something like `LangErrorCode.InstructionMissing` in my TS tests?
https://github.com/project-serum/anchor/blob/v0.18.2/ts/src/error.ts#L53
I feel so smart to have guessed you are using Anchor from a question in the Anchor discord
Are you familiar with the TS client lib?
I'm guessing from the above that you are using anchor. If by client you mean TS client, Anchor lets you create a program object that allows to easily call your program's functions, as well as fetching accounts.
eesh, ok. so how do i read some data stored on-chain from the client?
Oh this is a top level program function, not a helper function. You cannot return anything apart from an error or `Ok()`
see, i'm passing base_account.splits
```
pub fn get_acs(ctx: Context<ReaderContext>) -> ProgramResult {
        let base_account = &mut ctx.accounts.base_account;

        // this has to be returned: `base_account.splits`

        Ok(base_account.splits)
}
```
Better post your code snippet. Your function signature just needs to match what you actually return. In Rust you either use the familiar `return X;`, or just make the last expression evaluated in the function be the value you return: `X`. Note the absence of a semicolon in the latter.
it says `Ok expected () but got std:Vec::Vec`
is it supposed to go in OK(...)?
how do i return data from a function?
if you used create-react-app - there are some problems i ran into with webpack5 -- I ended up needing to "eject" the create react app so I could add the polyfills
Will install react-scripts@2.1.3, which is a breaking change
node_modules/svgo/node_modules/nth-check
  css-select  <=3.1.0
  Depends on vulnerable versions of nth-check
  node_modules/svgo/node_modules/css-select
    svgo  1.0.0 - 1.3.2
    Depends on vulnerable versions of css-select
    node_modules/svgo
      @svgr/plugin-svgo  <=5.5.0
      Depends on vulnerable versions of svgo
      node_modules/@svgr/plugin-svgo
        @svgr/webpack  4.0.0 - 5.5.0
        Depends on vulnerable versions of @svgr/plugin-svgo
        node_modules/@svgr/webpack
          react-scripts  >=2.1.4
          Depends on vulnerable versions of @svgr/webpack
          node_modules/react-scripts

6 moderate severity vulnerabilities
 

for more context
How do i capture the deployer address?
npm WARN EBADENGINE Unsupported engine {
npm WARN EBADENGINE   package: '@toruslabs/http-helpers@1.4.0',
npm WARN EBADENGINE   required: { node: '>=14.17.0', npm: '~6.x' },
npm WARN EBADENGINE   current: { node: 'v16.13.1', npm: '8.1.2' }
npm WARN EBADENGINE }

these are the warning I get when I install dependencies using npm - maybe has something to do with erros? Im on linux


//////////////////////////////////////////////////////////////////////////////////////////

im not running Linux so assuming the ca5rgo like I have been doing
cargo install --git https://github.com/project-serum/anchor --tag v0.20.1 anchor-cli --locked
or
npm i -g @project-serum/anchor-cli
which anchor should I download. I am a bit new on this...
Whats’s the difference between using the NodeWallet vs AnchorWallet? They have different functionality or different use cases? 

I’m building an app in Node.
thank you for the help!
ya. Let me try this again
you should be good then
this is an older iMac 5k
if you're on an m1 you will have to build from source
def. I have been referring to this
make sure you follow this part first: https://project-serum.github.io/anchor/getting-started/installation.html#install-rust
thanks for breaking down the issue and logic
ok let me retry
and you should be good
and not have that space there
start over
well iw ould blow out the repo
lol
the heck
now cant find a module
thats weird

hmmm ok one sec. It doing new things....oh shit ya.....ok
777 gave it execute perms
and it didn't have execute perms
permission denied, because you were trying to execute it, instead of passing it into ANCHOR_WALLET
remove the space
after anchor_wallet
you ahve a space
oh lol
basically does that a few more lines and just temrinates

something different but odd
oh weird wth one sec
let me rerun
ok
no that wouldn't matter
could that be the issue?
can i be in the basic 0 folder when doing the command?
its done this before when i started over, but ill try again
its odd right?
if that doesn't work, i would just blow out the entire repo and re-clone it and try from scratch
let me see
that's pretty weird.  i guess try `sudo chmod 777 /Users/Bryson/anchor-master/examples/tutorial/basic-0/walletid/id.json`  that should be over kill

one sec
oh it cut off
i remember i did do that....the issue was there so that why i tried to move the file closer to the project
the easiest thing to do is probably do `solana-keygen` and then you can do `ANCHOR_WALLET=~/.config/solana/id.json`   but that assumes you don't already have a real one there
i appreciate you taking the time with me to figure this out
ok let me see
that should show the permissions and everything in the folder
can you try `ls -alh /Users/Bryson/anchor-master/examples/tutorial/basic-0/walletid/*`
permissions
this permission bs has haunted me
i need to move my workflow away from mac
so no changes on it allowing me

yeah
ok ill try
?
sudo chmod a+r /Users/Bryson/anchor-master/examples/tutorial/basic-0/walletid/id.json
or you can just generate your own keypair and point to that one
this isn't really an anchor issue; but you can probably do `sudo chmod a+r <path_to_id.json>` to fix it
there it is.wont even let me access the file

let me see if i can send another
it said it didnt have permisiion
oh shit thats not what it said before. its because i moved the file back.
<@!288735346122948611> what does "no such file or directory: xyz" mean to you?
any ideas at all as to why this AccountDidNotDeserialize is happening ?
i successfully deployed with anchor....
do i need to do wallet address instead or location of id.json?

Hello guys I read the sealevel attacks  owner check example:https://github.com/project-serum/sealevel-attacks/blob/master/programs/2-owner-checks/secure/src/lib.rs I just curious why spl-token not add ownership check with spl-token:ID in the library, is it intended? Because I cannot find such validation in spl-token lib.
thats what it seems but i dont know why it would do that. Ya i will
This sounds like a file permission issue? Can you share your actual command and terminal output?
It’s a really generic error. Can you share more context?
probably too new of a program still to have enough people helping othe rpeople :/
Anchor needs more support lol.
can anyone help me. I am trying to run the client.js in this basic_0 test program. I enter my keypair location into this command and it denies me permissions. I am following the suggested doc direction and still not getting through.

ANCHOR_WALLET= /Users/Bryson/anchor-master/cli/src/SolanaWalletEscrow/id.json node client.js
Please help in figuring what is wrong
These are the rpc variables : tx: Transaction {
  signatures: [],
  feePayer: undefined,
  instructions: [
    TransactionInstruction {
      keys: [Array],
      programId: [PublicKey],
      data: <Buffer 34 df b1 eb 87 ab 49 60 05 00 00 00 00 00 00 00>
    }
  ],
  recentBlockhash: undefined,
  nonceInfo: undefined
}
signers: [
  Keypair {
    _keypair: { publicKey: [Uint8Array], secretKey: [Uint8Array] }
  }
]
options: undefined
hey guys, i am facing this error -> Transaction simulation failed: Error processing Instruction 0: Program failed to complete
It would just have a built in max length
I think you’d have a fixed length buffer to store the string, so they wouldn’t give space input
If I go the String route is asking users to give input for space dynamically idiomatic?
I would just init one and let it be ephemeral, but you can definitely just query accounts directly from a purely technical perspective, unsure if you can use anchors generated client or not
Is your question about whether you should store the raw ip addr bytes versus a string? Or about how to do the dynamic spacing part?
I'm trying to write a script that queries data from the my program's accounts using `anchor.Program`. I don't need to send any transactions, but it looks like I'm required to provide a wallet to use `Program` (it needs a `Provider` which needs a `wallet`). Is there any way to query and deserialize account data without a wallet?
dm me the code
I have a PR open which fixes a bug, what do I need to do to get it merged? I ran tests locally and they passed but unsure beyond that
I realized that I also had to make the `from` and `to` mutable, since they would be getting tokens removed/added to them. But now I'm getting a less descriptive error 
```
Error processing Instruction 0: invalid account data for instruction 
    Program 2Rqe9xhD7cvq2oYeFCJq2e18K4pQbiNSZNgX835J7S3w invoke [1]
    Program log: Instruction: Initialize
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [2]
    Program log: Instruction: Transfer
    Program log: Error: InvalidAccountData
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 1294 of 195471 compute units
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA failed: invalid account data for instruction
    Program 2Rqe9xhD7cvq2oYeFCJq2e18K4pQbiNSZNgX835J7S3w consumed 5823 of 200000 compute units
    Program 2Rqe9xhD7cvq2oYeFCJq2e18K4pQbiNSZNgX835J7S3w failed: invalid account data for instruction
```

Any idea how I can debug that error to figure out what data is invalid?
but it's a bit awkward with IpV6
I could have it be a byte array and store Ip addrs instead
I want to store a connection string on a PDA in a way that's anchor-esque. Since urls can be of various lengths I'm allowing users to specify the extra space to allocate for the field rather than allocating a fixed size for instances of the PDA
hey frens
trx failing - https://explorer.solana.com/tx/27wycrHvTgTsNC3wcZuv5T5FWDCpJ44GLc8Wyq28x2FdgMmaZdXu8G7kd5K9wehJ95mWZkaViRLYXCEVCf7Pe48Y?cluster=devnet
im trying to fix a program in metaplex to work with cm v2. calling the function here https://github.com/bonkworld/metaplex/blob/fix-gumdrop-v2/js/packages/gumdrop/src/components/Claim.tsx#L371-L406 . i updated the struct to match new candy machine data structure. the code continues to blow up here with AccountDidNotDeserialize https://github.com/bonkworld/metaplex-program-library/blob/v2-gumdrop/gumdrop/program/src/lib.rs#L337-L338 . im all out of ideas i've been stuck on this for days now, if anyone sees something extremly obvious
Okay, I see that now, thank you
Thanks!
Yeah that's what they told me over at the Solana dc too 😄
You'll have to pass that account in from the client.
You'll have to rethink your design unfortunately—it's just not possible in solana to dynamically look up accounts like that, they always always have to get specified ahead of time by the client.
nvrmind found here

https://solana-cookbook-git-fork-losman0s-using-mainnet-6e845e-cookbook.vercel.app/guides/get-program-accounts.html#facts
Anyone got a Typescript code snippet for pulling a program's PDAs given a program ID?
any reference
its a constant in web3.js
how we get address of this system token program
Hey, can I close an account with just a public key as the SOL destination? I wanna have PDAs that store who to send the lamports to when they are closed.
but something is clearly wrong with my code.
and tokens will get transferred to user's associated token account. Thats the goal
in this case i think both payer and signer are user as user is initiating this call
and payer should be a Signer?
i am just trying to modify those examples in hopes it would work. 😋
i have seen such examples floating on internet. not sure though
idk is it allowed to use associated_token with init_if_needed
mint refers to the TokenMint (pubkey) and token_program is system token program
what is diffeence betwen mint and tokenprogram
#[derive(Accounts)]
#[instruction(user_token_amt: u64)]
pub struct SendTokens<'info> {

    #[account(mut, signer)]
    pub user: AccountInfo<'info>,

    pub mint: Account<'info, Mint>,

    #[account(
        init_if_needed, 
        payer = user,
        associated_token::mint = mint,
        associated_token::authority = user,
    )]
    pub user_account: Account<'info, TokenAccount>,


    #[account(mut,constraint = vault_account.amount >= user_token_amt)]
    pub vault_account: Account<'info, TokenAccount>,

    pub vault_authority: AccountInfo<'info>,

    #[account(zero)]
    pub escrow_account: Box<Account<'info, EscrowAccount>>,

    pub system_program: AccountInfo<'info>,
    pub rent: Sysvar<'info, Rent>,
    pub token_program: AccountInfo<'info>,
}
any particular reason why common::close is private? use case - close remaining accounts
whats the source code
is this error because i have not upgraded my anchor to 0.2?
hey guys, getting an error when i use #[account(init_if_needed, payr.... Error says expecting = after init_if_needed. Any idea why is it expecting = and not ,
or do I create my own type and implement the `Id` trait myself
another question I have is if there is a `system_program` version that I can pass to `Program` account types?
in my context Anchor requires Rent because I am initializing an account. so right now I'm adding the Rent account to the context as a `Sysvar`. but these days you don't need to have your sysvar info passed along as an account so I was wondering what the alternative is because Anchor complains if I don't include the Rent sysvar
using init in to account so do i still need to provide it
#[derive(Accounts)]
pub struct Initialize<'info> {
    pub from :Account<'info,TokenAccount>,
    #[account(init,payer=authority,token::mint=mint,token::authority=authority)]
    pub to   :Account<'info,TokenAccount>,
    pub mint: Account<'info,Mint>,
    pub authority:Signer<'info>,
    #[account("token_program.key == &token::ID")]
    pub token_program:AccountInfo<'info>,
    pub rent:Sysvar<'info,Rent>,
    pub system_program: Program<'info, System>,
}
Good morning everyone! I'm trying to invoke an instruction through CPI (program A calling program B), however the accounts that need to be sent to program B can NOT be included in the context for program A, since program B needs to be invoked a variable number of times with different PDAs each time. In other words, program A needs to derive PDAs for program B during runtime.

The problem arises when constructing the CPI context for B, which expects `AccountInfo`s, however with `Pubkey::find_program_address` I only get the public keys for the PDA, not the AccountInfo. How would I achieve this?
```rent.to_account_info()```?  what are you trying to do?
how can I fix ```use the path separator to refer to an item: `rent::to_account_info````? I can pass Rent as a sysvar to the accounts struct but is there an alternative?
Anyone else knows what this error is caused by?     ```RangeError [ERR_OUT_OF_RANGE]: The value of "offset" is out of range. It must be >= 0 and <= 351. Received 390``` This occurs when I try to fetch an account using its publickey from devnet
in spl token burn is the authority the account who's burning from or the authority of who made the token?
Can anyone help ?
Yeah basically either you do your own similar thing to discriminator bytes, or use different amounts of space, or whatever
That's complicated now that im looking back at it
In general in a non-anchor program you'd have to have some other way to distinguish the accounts (e.g. in the token program, mints and token accounts take up different amounts of space, so that lets the program keep them straight)
no i was just using that to explain that one program interacts with the other
You're not talking about the anchor puppet example?
XD glad my +1 helped
The problem is, I'm doing Cpi from Puppet Master. Puppet is not an anchor program. So Puppet Master can't do `Account<'info, A>`, right?
Anchor adds the bytes automatically whenever you use the `Account` type
If you say `foo: Account<'info, A>`, anchor will ensure that it really is an A account
Also, does anchor automatically add these discriminator bytes? Or solana?
ahhh interesting. So say I'm doing CPI from Puppet Master to Puppet. So Puppet Master never has to worry about this case, right? Because the underlying program should handle it
Yep, as <@!925167601590616174> said it will add +1 byte (😛), followed by the serialization for the A or the B
That's what the account discriminator bytes are for (the extra 8 bytes in space calculations)
Say Puppet has two types of accounts that are owned by itself (Account A and Account B). Both have identical fields. Puppet's instruction `foo` is meant to take Account A, but a user passes Account B, which is still owned by the program and has the same fields. **How will the program know to throw an Error?**
+1 ^
anyone know the size of an enum variant for account space purposes?
e.g. 
```
enum Type {
    A,
    B,
}
...
#[account]
pub struct S {
    pub t: Type,
```
Got it, that makes sense thx
done change the idl.json to idl.ts
```json
import { Idl } from '@project-serum/anchor';
 export const idl: Idl = {
...
idl.json generate on anchor
...
}
```
```IdlError: Type not found: {"name":"betType","type":{"defined":"BetType"}}```
```rust
#[derive(Debug, Clone, Copy, Eq, PartialEq, AnchorDeserialize, AnchorSerialize)]
pub enum BetType {
    TwoFold,
    TenFold,
}
```
I am getting Idlerror: Type not found; but it seems right to me?

https://github.com/gdoteof/solana-gamba/blob/master/programs/gamba/src/state/bet.rs#L12-L22
can you help me with that?
thanks!
So you would use `invoke` if you've already got your necessary signatures from the client, and `invoke_signed` if you need to add on any additional signatures for some of your program-derived addresses
`invoke` just uses `invoke_signed` under the hood, but doesn't try to sign for any additional program-derived addresses (it passes an empty slice for the seeds argument)
Like, is there a reason to use signed over the the regular?
Can someone plz please explain the difference between `invoke()` and `invoke_signed()` to me plz.
If you are new though I would suggest you start by looking though the tests map of the anchor library to see exmaples of how the code is supposed to look. download this repo and check the tests folder for examples
here the owner should be  of type Signer<'info> or be noted annotated with #[account(signer)]

After approving I got into a different error though:
```
Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account 
```
Ohhhh silly me!! Thank you!! So in this case (where I'm sending from my own wallet) it would be the same as the `from`. That prompted me to sign!! 🥳
The owner is not the token account, the owner should be the person signing the transaction and owns the "from" token account
I'm trying to learn Rust/Anchor and I'm currently trying to make a simple program that would allow me to send an SPL token between wallets through a website using phantom.

This is my very simple contract:

```
#[program]
pub mod my_program {
    use super::*;
    pub fn initialize(
        ctx: Context<Initialize>,
    ) -> ProgramResult {
        let cpi_accounts = Transfer {
            from: ctx.accounts.from.clone(),
            to: ctx.accounts.to.clone(),
            authority: ctx.accounts.owner.clone(),
        };
        let cpi_program = ctx.accounts.token_program.clone();
        let cpi_context = CpiContext::new(cpi_program, cpi_accounts);
        token::transfer(cpi_context, 1)?;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    from: AccountInfo<'info>,
    to: AccountInfo<'info>,
    owner: AccountInfo<'info>,
    token_program: AccountInfo<'info>,
}
```

I deployed it, and trying to call it on the front-end with this:

```
        await program.rpc.initialize({
          accounts: {
            from: provider.wallet.publicKey, //phantom provided wallet, and holder of token
            to: new PublicKey('redacted'), //recipient wallet
            owner: new PublicKey('redacted'), //token account
            tokenProgram: new PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'),
          }
        })
```

But this is resulting in this error on the console:

```
Error: Transaction fee payer required
```

Is this something missing on the contract or do I need to do something else on the front end to ask for the signature/payment?
i fixed problem 🙂
i checked tutorials but can't understand problem 😦
Hello guys! I have an error: Error: 3012: The program expected this account to be already initialized but can't understand which account 😦 I have this account: ```#[derive(Accounts)]
pub struct Stake<'info> {
    pub token_addr: Account<'info, Mint>, // token mint address (agte mint, nft mint)
    pub token_from: Account<'info, TokenAccount>, // from which user associated account we can transfer
    //the authority allowed to transfer from token_from
    #[account(init, payer = user, space = 64)]
    pub staking_info: Account<'info, StakeInfo>,
    #[account(mut)]
    pub staking_account: Account<'info, TokenAccount>, // when we send money
    #[account(mut)]
    pub user: Signer<'info>,  // user who will stake
    pub token_program: Program<'info, Token>,  //  address for token program for transfer
    pub system_program: Program<'info, System>,
}

#[account]
pub struct StakeInfo {
    pub authority: Pubkey,
    pub last_redeem_date: i64,
}``` and this test ```await program.rpc.stake(
            new anchor.BN(5_000), {
                accounts: {
                    tokenAddr: mint.publicKey,
                    tokenFrom: walletTokenAccount,

                    stakingInfo: stakingInfo.publicKey,
                    stakingAccount: stakingAccount.publicKey,

                    user: user.publicKey,

                    tokenProgram: TOKEN_PROGRAM_ID,
                    systemProgram: web3.SystemProgram.programId,
                },
                instructions: [
                    await program.account.stakeInfo.createInstruction(stakingInfo),
                ],
                signers: [user, stakingInfo]
            });```
gotcha I'll look into the zero copy right now.
you can also use zero copy deserialization to go around this issue, but haven't used it yet so can't give you an opinion
no not always. Only with large contextes. I like to either box everything in the struct or nothing. So if I have a large context that is starting to hit the limit, I just box everything in there.
always?
I Box everything I can
If I'm getting stack errors (probably do to passing in lots of accounts) which accounts should I be "Box"'ing to pool them off the heap???
The token accounts? The one I'm creating?
Is zero copy deserialization any more efficient in terms of compute unit usage? Suppose I have a large array in there.
16 seeds max
you can provide any number of seeds i think, or just one if you want
the bump is determined by the findProgramAddress algorithm, which is in the link i sent, but its something that's returned to you and that you need to store
you provide fixed seeds (in this case the string "open auction", the owner's public key, and the string of the auction title)
```
const [auctionAddress, bump] = await anchor.web3.PublicKey.findProgramAddress([Buffer.from("open auction"), ownerAddress.toBytes(), Buffer.from(auctionTitle.slice(0, 32))], program.programId)
```
Is the "seed" value set by the user or is it hardcoded as part of the program? 
Is it that the "seed" value is fixed, and the "bump" is what increments in case the previously hashed address is a valid address?
And what does it mean "collection of seeds"? Why would there be multiple seeds?
you can deterministically rederive the same address with the same seeds and bump, so you can get the address of a pda later as long as you know those values
bc a given collection of seeds may not result in a valid address right away so the bump gives us more tries in a sense
no associated private key*, and then the bump is just a value that starts at 255 and is hashed along with the provided seeds and is decremented until we get a valid address
https://docs.solana.com/developing/programming-model/calling-between-programs#hash-based-generated-program-addresses

my understanding is that the seeds are used to generate an address that doesn't lie on the ed25519 curve, so it's not a valid public key
Could anyone explain or have any references with examples to better understand "seeds" and "bump value"? 
I don't really understand what they mean other than they have something to do with generating PDAs that don't have private keys
check out the "Cancel Implementation" of the tutorial, it cancels the item on the to-do list and returns the reward back to the owner

https://dev.to/dimfeld/starting-with-solana-part-4-4j5k

```// Return the tokens to the item creator
    item.close(item_creator.to_account_info())?;

    let item_key = ctx.accounts.item.to_account_info().key;
    list.lines.retain(|key| key != item_key);

    Ok(())```


//////////////////////////////////////////////////////////////////////////////////////////

How do I get different onchain program's anchor data structs to call with CPI?
Can anyone help me with this one?
Yeah confusing one
Your intuition is right that the name doesn't make sense
Ok cool will go with that
Yeah
but should I just put in the user_token_account it will be burned from?
Oh, well, the name really is `to`, but you're right that it shouldn't be
hmm but I tried building the program using 'from' and I get this error
Yeah, that name is wrong!
Performing a burn function in rust..looking at the docs it says that a Burn context is as follows:

pub struct Burn<'info> {
    pub mint: AccountInfo<'info>,
    pub to: AccountInfo<'info>,
    pub authority: AccountInfo<'info>,
}

But should the second account no be 'from' ? As in the users token account that you will be burning tokens from?
is there a way for a program to accept an arbitrary number of accounts of the same type? 

For example, if I want my program to mint tokens to all of the associated token accounts passed in, but the caller can pass in any number of token accts.

or is it cleaner for the program to accept 1 account and then pass in multiple instructions in the same transaction?
and im not talking about array, but more complex lists that hold objects
have you checked out how lists are implemented?
How can one implement a FIFO data structure in anchor ?
will the init macro fail if the given PDA already has an initialized account?
Really good tutorial here which you could easily modify to make the transfer time based: https://hackmd.io/@ironaddicteddog/solana-anchor-escrow
Hi every one.
I want to lock my tokens in contract which i am doing but  then want to transfer back to user after 1 day. 

I am stuck with that how can i transfer tokens back to user...
I am using bumpseed but giving me error when i try to call from devnet
Yeah - PDAs can be a bit confusing at first.  A PDA can sign transactions inside of the program where the PDA was generated, and nowhere else.  A good intro here: https://pencilflip.medium.com/learning-solana-3-what-is-a-program-derived-address-732b06def7c1
how would i seed an account with a number?
```
#[derive(accounts)]
#[instruction(bump)]
pub struct Foo<'info> {
    #[account(
        init, 
        seeds = [bar.key().as_ref(), &baz.to_ne_bytes()],
        bump = bump,
        payer = authority, 
        space = Foo::LEN,
    )]
    pub authority: Signer<'info>,
    #[account(mut)]
    pub bar: Account<'info, BarAccount>,
    pub baz: u64,
    pub system_program: Program<'info, System>,
}
``` My attempt is something along these lines, where baz is a u64
<@732815411808174111> 
Thank you so much...
I'm reading solana docs. I understood that PDA has NO related private key, so it cannot be used when signing tramsaction. But, then how program can be signer of that account?
The picture shows the point where I've lost
Sure!
Can I ask a question about Program derived address here?
Getting ```ctx flows into ctx here``` error
I want to create a guess game where user will submit Sol to the program and will guess the random number generated by program between some range. If guessed double money will be transferred and not then will lose his stake. So here how to make the program pay the fees for transfer of token from program to user and how to generate random number?

```
#[allow(unaligned_references)]
use anchor_lang::prelude::*;
use std::convert::TryInto;
pub use switchboard_program::VrfAccount;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod dice_game {
    use super::*;

    pub fn get_random(ctx: Context<GetRandom>, params: Value) -> ProgramResult {
        let luck = &ctx.accounts.values;

        let v = VrfAccount::new(luck)?;
        params.dice1 = String::from_utf8(v.get_verified_randomness().clone().unwrap()).unwrap();
        // params.dice2 = v.get_verified_randomness().unwrap();
        // luck.dice2 = VrfAccount::new(luck)?.try_into()?;

        // let v1 = format!("{:?}", String::from_utf8(params.dice1.clone()).unwrap());
        // let v2 = format!("{:?}", &params.dice2);
        msg!("Values are: {:?}", params.dice1);
        
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 8 + 64 + 64)]
    pub values: AccountInfo<'info>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}


#[derive(Accounts)]
#[instruction(params: Value)]
pub struct GetRandom<'info> {
    #[account(mut)]
    pub values: AccountInfo<'info>,
}

// #[account]
#[derive(Clone, AnchorSerialize, AnchorDeserialize)]
pub struct Value {
    dice1: String,
    // dice2: u64,
}
```
Perfect, ill have a go with that, thank you man!
located in /target/idl
idl has everything
Amazing! And programId would have to be manually input to the script, by taking it from anchor deploy?
```js
import idl from './idl/idl.json'
import { useAnchorWallet, useConnection, useWallet } from '@solana/wallet-adapter-react';
  const opts = {
    preflightCommitment: "processed"
  }
  const { connection } = useConnection();
  const wallet = useAnchorWallet();
const provider = new Provider(
    connection, wallet, opts.preflightCommitment,
  );
  const program = new Program(idl, programId, provider)```
Yes, in that case you'll need to import the IDL etc...
programId would be   program.programId
i cant run the JS isolated and have those work
Seemed by the docs that only works when doing "anchor test", no?
anchor does this for you ``` anchor.setProvider(anchor.Provider.env());

  const program = anchor.workspace.Perps as Program<Perps>;```
?
and then run the tests with:
const programId = new anchor.web3.PublicKey("<YOUR-PROGRAM-ID>");
you'll have to save it (private key of the generated account)
Any way to just run the JS by itself, using the last deployed program address?
oh! Cool! Thank you! <@!208527206966755329>
```anchor test --skip-deploy```
anchor test redeploys every time, and takes too long for just minor tests
Whats a quick way to run JS tests on an already deployed anchor program?
add the *pc.rs* file as it is then follow the code in *lib.rs*
they have an example interacting pyth with anchor. Really easy https://github.com/project-serum/anchor/tree/master/tests/pyth
I'm not sure too
I have some custom data feed (some TVL value), that im trying to feed in, not sure if pyth supports custom data feeds?
I use pyth, it's easy to use and has a lot of data-feeds but it depends on your needs
I found some chainlink + solana, but not sure if anything changes with Anchor, (and also custom data-feeds, rather than the provided price-feeds)
Is there any good tutorial / github repo on how to use custom chainlink data feeds in anchor programs?
nope, didn't work <:strug:599601512762703902>
ah wait lemme try something quick
```
Error: Custom: Invalid blockhash
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }.
```

Anyone else had this error when trying to deploy to devnet? I was able to deploy the same program yesterday, deploying it with a different keypair/id today and it's just doing this <:THONKING:567714720870563840>
can we use the agnostic orderbook inside anchor ?
Plz can anyone help???
you mean `ctx.program_id`?
Hey y'all, how can a program call itself? I'd like to call an instruction multiple times from another instruction
I'm not sure If I can access the programId in the context
how do I check if an account is owned by the program ?
When i run **anchor test** without running validator then it passes but when i run with solana local validator then its gives me error address not found.
Also when i run from devnet give me same error i am trying to create escrow...
how would I take an external account as an input to the function of program?

```pub fn test(
        ctx: Context<Test>,  
        amount: i64,
        buyer: ??
) -> ProgramResult {
        let key = buyer.pubkey?```
```        check_account_owner(a.user, program_id, DexError::InvalidStateAccountOwner)?;
```
smth wrong with my bump?
can someone please explain this error to me?
```
anchorpy.error.ProgramError: 2006: A seeds constraint was violated```
I think if you have anchor installed, you need to set the path in ~/.zshrc on a mac and then once the path is set, don't forget to run "source ~/.zshrc"

https://code2care.org/pages/permanently-set-path-variable-in-mac-zsh-shell
Hey guys,

I'm trying to deploy a program on devnet with solana sdk v1.9.4, anchor version v0.20.1 but I'm getting this error during the deployment:

Error: Pubsub error: UnexpectedMessageError("{\"error\": Object({\"code\": Number(-32601), \"message\": String(\"Method not found\")}), \"id\": Number(1), \"jsonrpc\": String(\"2.0\")}")

Anyone faced the same issue and found a workaround/solution? Appreciate the help, thanks 🙏
are you using macbook with an M1 chip?
Hello. every single time when I open up terminal, ```command not found: anchor```. how should I fix this problem? I installed using cargo and Mac OS.
hey everyone i want to know that is it possible to make a token contract using anchor framework where i can have some customization like of deducting a certain amount of fee on every transaction that happens on that token contract and send that fee to a liquidity pool and to the owner of that contract is this thing possible using the anchor framework ?
```const { item } = await addItem({ list, user: buyer, name: 'Coffee',});``` 
what does it mean to have the the brackets around "{ item }"?
if I don't use the brackets, then the test produces an error that says "Error: Invalid arguments: item not provided."
it does cost Sol everytime.
It seems like it costs sol every time. Am I doing something wrong?
yes, you have to deploy it everytime.
Hey quick question, whenever you update your rust code, in order to see the changes on my front-end side, do I need to deploy it everytime? Or is anchor build just sufficient?
yeah, basically.  client.js would be the literal client; which is talking to your program (which is the server, in the client-server analogy).

programs can call each other from on chain; but if _you_ (not being an on-chain program) or your users want to invoke functions, you would have to create a client, which in your case is client.js
anybody knows how to put a program to the isntructions ?
i think the expression means a program
im trying to replicate a web, but its minified 😦
boom baby!

bump
is it a local cluster issue?

so.....its throwing an error at the initialize. So how do i get this RPC to initiate. The code seems correct. What am I missing?
Hard to say, what are you trying to do? That would be a little instruction, but it's kind of weird since it doesn't pass any accounts 🤔

anyone knows what could be this minified expression ?
hello!
Yeah, best to just search the source code 😛
ty i didn't see anything on the anchor docs site about it
But you're probably doing a `Account<'info, Something>` and not passing an actual Something account.
Easiest way to learn about this stuff is to have a checkout of the anchor search and just ctrl-f through it
That means you're passing in a (probably empty) account that doesn't have any descriminator bytes (the first 8 bytes of an account managed by anchor)
can someone explain this error more in detail? i haven't found any info when searching discords AccountDiscriminatorNotFound: 3001,
will have to problem solve this later I guess. Dinner time LOL
rip my life
Ok, now you have a different bug 😉

You wrote `ANCHOR WALLET` with a space, not an underscore
i do? where?
You have a typo
Nope, `ANCHOR_WALLET=... node client.js`

i didnt use a local cluster
?>
can I set this local to the devnet cluster
anchor.setProvider(anchor.Provider.local());
let me try something
maybe im in the wrong path
is it a node issue?

Do that all in one line, `ANCHOR_WALLET=... node client.js`
should it run when I use no client.js
so i understand the logic, but when i run node client.js i get stuck.
is that where client.js comes in?
gotcha. I figured out how to get the program on the devnet. Question: what is the client.js? I cant ge tmy head around it. My logic on how this works is we deploy a program to the blockchain, this program holds instructions for how other accounts cna interact with eachother and their data in a trustless way, but what I dont get is what we do after that. Do we have to build an interface to interact with the program we wrote?
oh i see
in unix you can also do `export ANCHOR_WALLET=<YOUR-KEYPAIR-PATH>`  and then run `node client.js`
so doing `ABC=123 xyz`  declares an environment variable before running the executable `xyz` so that xyz can see it.  In case of NodeJS, these variable are available in process.env[] and that is what Anchor uses to look for the wallet
yes
its a variable outside the program
and which OS are you on
do you know what an OS environment variable is?
no
do you know what the syntax `ABC=123 xyz`  does/mean?
im trying to get to the end so I can say hey, look it works LOL
then it says dont use that client.js file that is provided for testing
lol
how do I move to this 
ANCHOR_WALLET=<YOUR-KEYPAIR-PATH> node client.js  

if it doesnt say how to use the client.js
```
(async ()=>{
  ...place the code here
})();
```
https://project-serum.github.io/anchor/tutorials/tutorial-0.html#generating-a-client
what is annoying is that there is no client.js help in these docs
you'll get there man just keep going!
may the force be with you 🙂
ya I am learning as I go....only 2 months in
Yeh you need to go learn more javascript.
The issue is that your not running await inside an async function (it only works in there)

But if you're not used to js you're going to run into issue after issue after issue once you fix that
Gotcha. Thanks I'll look into it.
I feel like the anchor-cli should just be able to use an rpc link like everything else
my issue is running the client.js file
I was going to say that I don't know how to deploy via RPC directly, but this project has a script to use deploy in nodejs that was helpful to me when I was starting...  https://github.com/DougAnderson444/solblog/blob/master/deploy.js
ohhh haha gotcha I was so confused for a bit <:bagsLUL:500156060439543819>
I was messaging <@!288735346122948611> but then wanted to reply to you but got distracted 🙂
I know how to set rpc's for the js side
sorry typo 🙂
Are you talking to me or do you mean <@!288735346122948611> ?
I need to set an rpc for the anchor-cli

aka the anchor deploy command
the "local" provider in anchor that you instantiate with `anchor.Provider.local()` looks for the environment variable that contains a path to the `id.json` file.
?
interesting
you can also mod the program and do `process.env.ANCHOR_WALLET = "/Users/Bryson/.config/solana/id.json";`
ok
https://project-serum.github.io/anchor/tutorials/tutorial-0.html#generating-a-client
im using anchor, but my issue is after getting the program on DevNet cluster, its telling me on anchor docs to do this " ANCHOR_WALLET=/Users/Bryson/.config/solana/id.json node client.js"
what exactly have you been trying to follow, native solana program implementation or using anchor?
im stuck at the client.js part
i have gotten the program ID
ya ive been trying to follow along lol
https://project-serum.github.io/anchor/getting-started/introduction.html
u r looking at anchor
anyone have ideas what this is?
How do I use an rpc for deploys?
The networks is really congested lately and:

Doing --provider.cluster <quicknode rpc here>
Always errors out with json 2.0 not returned etc

It just takes all my sol causing me to have to manually run solana program close
what does the `#[index]` attribute do for events?
it's driving me crazy
can anyone explain the error please
Transaction simulation failed: Error processing Instruction 1: custom program error: 0x1000761 
    Program 11111111111111111111111111111111 invoke [1]
    Program 11111111111111111111111111111111 success
    Program 9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin invoke [1]
    Program 9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin consumed 4652 of 200000 compute units
    Program 9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin failed: custom program error: 0x1000761
Error failed to send transaction: Transaction simulation failed: Error processing Instruction 1: custom program error: 0x1000761Transaction simulation failed: Error processing Instruction 1: custom program error: 0x1000761 
    Program 11111111111111111111111111111111 invoke [1]
    Program 11111111111111111111111111111111 success
    Program 9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin invoke [1]
    Program 9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin consumed 4652 of 200000 compute units
    Program 9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin failed: custom program error: 0x1000761
Error failed to send transaction: Transaction simulation failed: Error processing Instruction 1: custom program error: 0x1000761
Coming back to program keyfiles.  I'd like to understand from the security standpoint... if these files are exposed, what does that entail?
now once I have the ID generated, how do I generate the client.js
gotcha. thats great to know!

i get turned around too much
need to figure out the logic and keep learning rust more in depth
cant wait until i know this stuff more fluidly
And every 100kb costs 1.4 sol (based on the standard way of deploying)
deploy success
That will be at least several hundred kbs
got it guys and galls
BINGO!
The cost is for uploading your program's code, which requires rent-exempting the `.so` file
i added more into my account. lets see
Yep 😬
im just on dev...
my bad. thanks for the link. exactly what I was looking for.
are deploying programs on solana mainnet this expensive?
ack
https://docs.solana.com/developing/runtime-facilities/sysvars#clock
What do you mean?
u can?  but how would multiple nodes achieve consensus on this...  or am I missing something...
declare_id mismatch wouldn't cause that error fwiw
it has been two things for us as we started working (especially among multiple ppl), the declare_id() wouldn't match local `/target/deploy/*-keyfile.json` files or balance.
You can use `Clock::get()?.unix_timestamp`?
weird ok, let me work this out
I would airdrop yourself like 10
How much sol do you have? That error usually means you're too low
You can run a local validator though which lets you do whatever
now i get this

Devnet is “real” in that everyone is using the same devnet so if you’re deploying to an address embedded in a tutorial you’re gonna run up against it
solana program deploy /Users/Bryson/anchor/tests/escrow/target/deploy/escrow.so
Solana-keygen generates new keys.
new key generated
ok so i rebuilt it
can I delete and rebuild?
oh shoot so that key isnt the keypair i generated?
Solana generates -keyfile.json files in target/  make sure that it’s base58 encoded pubkey matches your declare_id
does connecting the address to devnet make the address unusable? or is it only when you connect it to the phantom
i created a new key and connected it then added 3 SOL

im trying to figure out the steps i need to do
so im a bit confused here. the declare id! is a hardwired address
How can I track/approximate time in a program?  As in I guess using slots to approximate a duration.
oh very cool (and insane) thanks
https://discord.com/channels/889577356681945098/889584618372734977/915190505002921994
I'll find a link
Heh, this is a funny one, has come up a few times in the discord
is there something im not understanding about solana here? cant think of a reason why the first case doesnt work and the second does
ran into some interesting behavior and wondering what's causing it:
i have a pda owned by my program with both sol and spl tokens in it
i have a function that takes in an accountinfo ("recipient")
the function does three things: transfer sol to the recipient, create the ATA for the recipient, and transfer spl tokens to the ATA

when the transfer sol happens before the other two, i get an error saying that  `sum of account balances before and after instruction do not match`

but when i just move it after the create ATA and transfer spl calls, everything works
🙂
i will check both ty
make sure your declare_id() matches the program id you are deploying to
that could be it
im probably dropping into old wallet
let me make sure the new config is connected
wait let me see
Airdrop yourself some more
lol
i put 3 in
Probably don't have enough sol in your wallet
whats going on here?
i see instructions but i dont know the logic
ideas?
like 2 months in haha. Appreciate it!
All good 😛
yup
im new dont judge me
Yeah, wallets live at accounts too!
derp
there it is
oh shit
You can't use it for both a wallet *and* your program id
is it because im assigning it to a wallet?
It's pretty likely that you're making a mistake with the key you're using (it's ~impossible to generate a fresh keypair and have an account live there—there's zero chance that's what's happening here)
can one not deploy on devnet?
and why are they duplicating keys?
lol
i just made it
I mean that makes sense, but how do i get a key no one on devnet has used?
maybe im missing something
isnt the point to practice deploying it to a devnet address?
how do i get a fresh key? I just made it lol
is there any opensource staking program that I can reference?
if you are trying to deploy to devnet, then yes you will need a new account because someone else will have already used that same key
Sounds like there's already something at that address. Are you sure you're using the right cluster?
I was going to say that if you really wanted to, you could just determine a dynamic length based on the runtime length of that string argument, using `#[instruction(the_string: String, ...)]` etc. Can then do `space = 8 + ... + the_string.len()` or whatever
and not upgradeable...
its a test .... but wont deploy saying its in use....
why i cant deploy this program to a new address I made?
any ideas?

do i need to somehow deploy it to a new address that hasnt been activated yet?
now saying not upgradeable
i thought i was supposed to link my keypair to wallet
gotcha. so i got to this part...but it says my address is in use
either one should work; but the npm command will typically go a bit smoother


//////////////////////////////////////////////////////////////////////////////////////////

Im trying to pass in the `clock` and `token` program Accountinfos into `invoke_signed`, but im getting the following error:

```lifetime mismatch

...but data from `clock` flows into `token_acc` here```
I am going through it now
`console.log("Your transaction signature", tx);` wasn't printed
I am getting this now
solana-install update
alright should i install everything from start or just `sh -c "$(curl -sSfL https://release.solana.com/v1.9.5/install)"`
Your solana install is too old I think (1.8.0)

heyy guys I am facing error every time I run anchor test

yep. seo optimized blogs suck.
What is the native token mint authority?
That entire tutorial is excellent - but you'll find specifically what you are looking for about halfway down the page.
Pretty good explanation of the difference between a keypair/solana wallet and an "anchor wallet" here: https://lorisleiva.com/create-a-solana-dapp-from-scratch/integrating-with-solana-wallets
I guess what I really want to do is jack into the info phantom has when it simulates a tx
kind of like phantom wallet before I click approve
Is there a way to simulate a function call in anchor?
ex:
```
await program.rpc.simulate.updateConfig()
```
I think i found my response. The declare_id should match with the program id in the local validator.
Here the `authority` is the payer for initializing an account, so it has to be mut (paying requires exclusive access to the authority account).
In general marking as mut is independent of marking something as a signer (sometimes you only need one).
I am having the same issue when i test example code ido_pool from anchor test on local-validator.
You wouldn't call that function (that's the entrypoint). You'd construct a mango instruction and do the CPI with `invoke/invoke_signed` (nothing anchor specific about doing a CPI)
Hello,

I have created an anchor project, i test it using ` anchor test ` it works fine. But when i test it by starting solana-local-validator and then `anchor test --skip-local-validator` i get the following error:
` Error: 3007: The given account is not owned by the executing program `
any ideas how to solve it?

Thanks in advance.
e.g. how would i call this function in another program: ```pub fn process(program_id: &Pubkey, accounts: &[AccountInfo], data: &[u8]) -> ProgramResult```
does anyone have some info about this? not sure how to do cpi calls to non-anchor programs
I think so but look into spl/token to be sure
is this all thats needed to implement a `Program` type? (assuming the pubkey is of a valid program onchain)
my other question is why do we add an account[(mut)] constraint on the signer? is this because we want the signing account to hold ownership of the initialized account?
solved! wasn't adding the space required to initialize the account
hi, struggling to resolve this error. i think it has somehting to do with Signer, but i'm really not sure where to start to fix this error
Thanks buddy.
Check out the "Cancelling an Item" portion of the tutorial
https://dev.to/dimfeld/starting-with-solana-part-4-4j5k

``` // Return the tokens to the item creator
    item.close(item_creator.to_account_info())?;```
```Here we use item.close to tell Anchor/Solana to delete the account and also transfer any balance on it to the item_creator account.```

something like this maybe?
Hi Everyone 
How can i close account after complete which i created with init..
Anyone else having issues with `anchor migrate`? https://github.com/project-serum/anchor/issues/1295
```
async function createUser(airdropBalance) {
  airdropBalance = airdropBalance ?? 10 * LAMPORTS_PER_SOL;
  let user = anchor.web3.Keypair.generate();
  let sig = await provider.connection.requestAirdrop(
    user.publicKey, airdropBalance);
  await provider.connection.confirmTransaction(sig);

  let wallet = new anchor.Wallet(user);
  let userProvider = new anchor.Provider(provider.connection,
    wallet, provider.opts);

  return {
    key: user,
    wallet,
    provider: userProvider,
  };
}
```

Could someone explain the difference between the user and wallet? And what exactly is does provider mean? And what does "provider.opts" do
ohk space was less
why is this happening
code: 3004,
  msg: 'Failed to serialize the account'
}
I think switchboard.xyz is there but not sure
cant use chainlink or its solana equivalent?
Can anyone help me with onchain random number generation on solana anchor?
logs
```'Program log: entrypoint [40]',```
```rust
 pub fn new_split(
        ctx: Context<NewSplitContext>,
        split_perc: Vec<u64>,
        split_keys: Vec<Pubkey>,
        split_account_bump: u8,
    ) -> ProgramResult {
        msg!("entrypoint {:?}", split_perc);``` librs function
```rust
#[derive(Accounts)]
#[instruction(split_perc:Vec<u64>,split_keys:Vec<Pubkey>,split_account_bump: u8)]
pub struct NewSplitContext<'info> {
    #[account(mut, has_one=authority)]
    pub base_account: Account<'info, BaseAccount>,
    #[account(
        init,
        seeds = [
            b"solsplit_account28",
            authority.key().as_ref(),
            &[base_account.splits_nonce as u8].as_ref()
        ],
        bump = split_account_bump,
        payer = authority
    )]
    pub split_account: Account<'info, SplitAccount>,
    #[account(mut)]
    pub authority: Signer<'info>,
    pub system_program: Program<'info, System>,
}``` function struct
```js
program.rpc.newSplit(
      [(new anchor.BN(60), new anchor.BN(40))],
      [provider.wallet.publicKey, atwo.publicKey],
      splitAccountBump,

      {
        accounts: {
          baseAccount: baseAccount,
          splitAccount: splitAccount,
          authority: provider.wallet.publicKey,
          systemProgram: SystemProgram.programId,
          // authority: provider.wallet.publicKey
        },
        // signers: [atwo],
      }
    );``` client
but when i send [60,40] i only get [40] in function entrypoint
ok so i have a fnction in which im sending a vector of u64
Any anchor nft minting repos that aren't candymachine floating around to look at?
Ok thanks for that!
Exactly what I am looking for, let me read through the article
https://dev.to/dimfeld/starting-with-solana-part-4-4j5k

this tutorial transfers SOL to a PDA and then released or returns the fund based on some condition, is this an idea of what you are looking for?
and then You can also view the validator logging by opening a separate window and running solana logs
in your tests
console.log('Count 1: ', account.count.toString())
i tried using msg but where does that appear
im running the program thru my client but i want to debug the program and println doesnt work
how do i log variables in my program
the system program has an instruction for sending sol, so you can just use that client side without writing any on chain stuff. however, since your wallet is a signer for the transaction, your on chain program also has the authority to send the sol from your wallet
If you find it please tag me too
I am gonna crash - hoping someone who has been in this space longer than my solid month can provide some guidance
agreed and I have found examples arounf Spl_tokens but not for native SOL
I have been fighting with some basics for a bit - and I can't see to get a good answer so far. The samples are either overly complex or incrementing counters...
if I am using a PDA, which will be like the vault of the game
I don't understand how the SOL transfer will work
I am also looking for the exact same thing +1
I am comparing some documentation from the solana cookbook about accounts, programs and transferring SOLs and trying to make sense of the Anchor representation. The typical anchor example has the Initialize derive. Using this example:

```rust
#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 8 + 8)]
    pub my_account: Account<'info, MyAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```
1. I want to interact with this using a Phantom wallet. So in this case, I can generate a `pubkey` which will be the account key for the program and the user will be the wallet's pubkey. Am I on the right track so far?
2. Now I want to transfer SOL from the wallet to this program
Looking to do something simple - from a Phantom wallet, transfer SOL to the program that the wallet user created. The idea being:
    1. Click a button to transfer `x` SOL
    2. The wallet opens and let the user authorize the action
    3. Generate a pubkey that the program will own (program_key)
    4. Use the IDL to call the initialize function on the program passing in the `program_key`, `wallet_key`, `SOL_amount`
    
```rust
#[derive(Accounts)]
pub struct Create<'info> {
    #[account(init, payer=user_authority_account_key, space= 16 + 16)]
    pub program_owned_account_key: Account<'info, ProgramOwnedAccount>,
    #[account(mut)]
    pub user_authority_account_key: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[account]
pub struct ProgramOwnedAccount {
    pub amount: u64,
    pub program_owned_account_key: Pubkey,
    pub user_authority_account_key: Pubkey
}
```
* Is this account setup sufficient for what I need to do?
* Will I be able to do the actual transfer. The docs says a transfer can only be made from an account that the program owns. From my understanding, the program doesn't own the wallet so how can the program move SOL from the wallet to itself?
i've listed their git repo as a dependency in the cargo.toml, and got all the right data, just not sure how to make the call
hey, i'm trying to do cpi calls to mango markets, are there any examples i can look at where cpi calls are done to non-anchor programs?
and also share the tests
this  is a bit out of context
Can you explain what your program is trying to do
Here is the account ```#[derive(Accounts)]
#[instruction(vault_bump: u8)]
pub struct InitVault<'info> {
    #[account(mut)]
    pub withdraw_authority: Signer<'info>,
    #[account(init, seeds=[b"vault"], bump=vault_bump, payer=withdraw_authority, space=200)]
    pub vault_pda: Account<'info, VaultPDA>,
    pub system_program: Program<'info, System>,
}```
```let program_id = "DiR3zknTTGDDncfLDgpmN75y3L2XMzyEtuM4Tpt16HMt"
        .parse::<Pubkey>()
        .unwrap();
    let program = client.program(program_id);
    let (vault_pda, vault_bump) = Pubkey::find_program_address(&[b"vault"], &program.id());

    let res = program
        .request()
        .accounts(accounts::InitVault {
            withdraw_authority: init_authority_pubkey,
            vault_pda,
            system_program: system_program::ID,
        })
        .args(instruction::InitVault {
            _vault_bump: vault_bump,
        })
        .send();```
Here is the interesting part of the code
Can someone help?
0xbbf, AccountOwnedByWrongProgram on tests that used to pass
I am running an anchor client and am getting this error
I've only done work with spl tokens sorry.
Honestly @me if someone links you i'd be interested as well
Do you know of any example I can look at for the following scenario? the user interacts with the program and deposits some SOL, and at the end of the game I return whatever they win and take some fee
Thank you turns out I was missing a signer
here is one <@!150033239493312512> https://github.com/cqfd/anchor-token-studies/blob/8c203ec85487c79dc1088c2fdeda1039235bec4f/programs/token-studies/src/lib.rs#L57
This is exactly what I was looking for
if I'm trying to have a program transfer funds, how do I test if the transfer went through?
```
        invoke(
            &transfer(
                user.to_account_info().key,
                owner.to_account_info().key,
                amount,
            ),
            &[
                user.to_account_info(),
                owner.to_account_info(),
                ctx.accounts.system_program.to_account_info(),
            ],
        )?;
```
what would I put on the test side to check?
or is the a way to put checks in the program?

I tried console.log the public keys for user and owner, but it looks like the amounts in the account didn't change
Any examples of token burning?
I can't seem to get the signers right.
or even better, just let the rpc commands take real enums
I finally figured out through searching this chat that the way to enums into typescript is by doing `{ variantName: {} }`  is anyone working on (or does something exist I am missing) so that one could so something like `MyEnum.VariantName.to_anchor_obj()` or something?
yes u can use `#[account(<constraints>)]` on top of each account
I guess I was wrong and they dont utilize `anchor` validation.
To do so I will need `attributes` like that: `#[account(init, payer = <target_account>, space = <num_bytes>)]`
Am I right?
https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html
so you always have to use it for mutable accounts
anchor checks the `mut` constraint when it creates the program interface description
Is there any reason to use double validation `anchor` + `viper`?

Rechecked QuarryProtocol, and looks like they utilize it, was it made for purpose?
```#[derive(Accounts)]
pub struct SetRole<'info> {
    /// The [Operator] of the [Rewarder].
    #[account(mut)]
    pub operator: Account<'info, Operator>,
    /// The [Operator::admin].
    pub admin: Signer<'info>,
    /// The account to give the role to.
    pub delegate: UncheckedAccount<'info>,
}```
+
```impl<'info> Validate<'info> for SetRole<'info> {
    fn validate(&self) -> ProgramResult {
        assert_keys_eq!(self.operator.admin, self.admin, Unauthorized);
        Ok(())
    }
}```
Yeah, Im dancing with documentation now, and still somethings I have to reask personally, otherwise its not always clear 🙂
Thx
yes, you can read all about it in the book
So I do validations in instructions under that line `#[derive(Accounts)]` right?
yes you dont have to use vipers. vipers has better error msgs currently but anchor's error msgs will soon improve as well
Do I understand right, that I can do it with anchor instead?
What are the options?
it's a different way of checking accounts using the vipers crate
I saw on that github repo they are using `account_validators.rs`
Is it typical solana implementation?
Or there is another way to do such checks?
They use anchor, but still I see those validations
https://github.com/QuarryProtocol/quarry/blob/master/programs/quarry-operator/src/account_validators.rs
thanks for reporting! thats a mistake in the book
https://book.anchor-lang.com/chapter_3/the_program_module.html
Looks like a typo
Share link please
in chapter 3.1.3 of the anchor book, why is it "init_data" instead of "data" ? 
``` 
#[program]
mod hello_anchor {
    use super::*;
    pub fn set_data(ctx: Context<SetData>, data: Data) -> ProgramResult {
        ctx.accounts.my_account.data = init_data.data;
        ctx.accounts.my_account.age = init_data.age;
        Ok(())
    }
}

#[account]
#[derive(Default)]
pub struct MyAccount {
    pub data: u64,
    pub age: u8
}

#[derive(AnchorSerialize, AnchorDeserialize, Eq, PartialEq, Clone, Copy, Debug)]
pub struct Data {
    pub data: u64,
    pub age: u8
}```
Ah, so if github repo is available, I just take instructions from there, right?
Whether that's the easy way since they published a crate/github repo, or the hard way (I don't know, looking at how their js code does it, etc.)
You just have to figure out, somehow, how to send instructions of the right form
Your code is 100s of kbs, so 100s of txs
Ah okay! Didn't know that
No, but this is why when you deploy your code it does a million transactions
Thanks a lot!
How do we build yield agregators then?
Thx for advice 😄
Is there any example?
Does it mean that maximum size of smart contract cant exceed 1232?
And if I will need it to be bigger I will have to split it?
Nice projects will publish helper crates
In general it will be hard lol
<@!134416332509675520> 
We have example of interaction with another contract:
```#[program]
mod puppet_master {
    use super::*;
    pub fn pull_strings(ctx: Context<PullStrings>, data: u64) -> ProgramResult {
        let cpi_program = ctx.accounts.puppet_program.to_account_info();
        let cpi_accounts = SetData {
            puppet: ctx.accounts.puppet.to_account_info(),
        };
        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
        puppet::cpi::set_data(cpi_ctx, data)
    }
}```
But how do I interact with conract that I didnt deploy, and the code of which I dont have in my project?
So I can use structures like `puppet::cpi::set_data()` ?
Even just sending the data to your contract won't really work, because each individual solana tx can only be 1232 bytes 😛
we better quit offtopic here 😄
Ok, good example is NFTs, right
Like ERC 721, check it 😉
Its a token with metadata\traits and contains values, lets say address for a picture
So at the dry end you have NFT (let it be an avatar picture) stored on chain, and you store on chain name, some other traits, and adress for a picture, and picture by it self stored for example on https://ipfs.io
This is where I still get confused. On what to do on-chain vs what to do on a regular server and then send it to the smart contract.
Sound better, cause you probably dont want to execute difficult calculations on chain
Every operation costs something
You want to use chain as ledger book
But maybe I can do that on the client-side and then send that data to the contract 🤔
Just wanted to read the data from an image inside of a contract.
Ah 😄 ok
Cause I wanted to say that is not super smart to store images on chain 🙂
Yeah, I am not sure that it can be used hehe. Just wanted to give it a try. Not sure how to check what is and is not allowed inside a contract
<@!134416332509675520> and thank you for all the answers, helps a lot 🙂
are you sure that you need `image` crate to be used inside of smart contract?
it could be
Maybe the dependency is too big? and cannot be used?
```
   Compiling crossbeam-epoch v0.9.6
Error: Function _ZN69_$LT$alloc..boxed..Box$LT$T$GT$$u20$as$u20$core..default..Default$GT$7default17h4a302a454c60900bE Stack offset of -10464 exceeded max offset of -4096 by 6368 bytes, please minimize large stack variables
```
so `#[derive(Accounts)]` is some kind of rules/restrictions that would be passed into function as an `ctx`?
I have this now 
```
[dependencies]
anchor-lang = "0.20.1"
image = "0.23.14"
```
I do not
Do you know text error to recongnize unsupported crates?
Do you know where I could check what crates work?
Okay I will try this!
Ah, some crates won't work on solana, maybe that's an issue?
You will have to provide path for dependencie like `anchor-lang = { path = "../../../../../lang" }`
or you can do it like that `anchor-lang = "0.20.1"` if that crate is available on https://crates.io/
And when I do  `anchor build` I get `error: could not compile scoped_threadpool`
What goes wrong?
Yeah, I have it there. Trying to add `image = "0.23.14"`
So not the top level one
In the `Cargo.toml` file *inside* the subdirectory with your program in it
That is what I thought but I am getting an error. Maybe the dependency is not supported?
No, that's how you specify a whole bunch of accounts that need to get passed to some instruction
Would be structure described under `#[derive(Accounts)]` be an `account type` aswell?
Yeah
Yeah, now got it.
However its not tottaly clear what is an `account type`?
Any structure described in rust under `[account]`?
I see it in `program.idl.types['MyType']` but not sure how to make that a normal type
how do I get the custom types defined in the IDL into typescript?  I have an emum defined but i think I must be doing something wrong
using `.toml` file
How can you add dependencies to an anchor program?
If you changed that struct to `MyAccountType` you'd do `puppet.account.myAccountType.fetch`, etc.
It corresponds to the `pub struct Data` part in the rust code
Yeah, confusing name :/
Ok, then it means that in line `puppet.account.data.fetch(newPuppetAccount.publicKey)`
`data` is an account type?
You can actually check this by opening up the generated idl file in `target/idl`
The latter, there will be two signers
Got it
Does it mean that that specific transaction would signed by `counter` only?
Or there would be 2 signers `counter` and `provider.wallet.publicKey`?
You're just adding on the keypair (in particular, the secret key part) to sign the tx from the client
For that specific tx
So we are promoting newly created account into signer for future interactions, right?
So it does the deserialization part for you (otherwise it would be raw bytes if you did `program.provider.connection.getAccountInfo(theAddress)`
`program.account.accountType.fetch` goes and grabs the account from the chain and parses its data assuming it's of type `AccountType` in rust
Yes its a keypair
But why do we need to interact with `account.data`?
If at the dry end we just get `puppetAccount` (the actual account data structure) and inside of that structure we have `data`
Looks like I dont understand what fetch really does here
`signers` is a list of *extra* signers, since the provider.wallet automatically signs so it can pay the tx fees
You've already deployed the contract at this point (that's why you're able to invoke it)
So `signers` is the list of signers of current transaction, right?
But we are the ones who deploy contract/programm, why don't we sign?
newPuppetAccount looks like it's a keypair, not the actual account data structure—that's what you get back when you fetch it.
The `counter` has to sign here because we're creating an account there (in general when you create an account in solana, its address has to sign)
I can't remember if it's already deployed yet, but you can/will soon be able to reallocate additional space (up to 10kb) to an account. But nothing will happen automatically, you'll have to remember to do it yourself!
Any oracle examples from anchor?
Or examples of someone getting NFT attributes from a rust program on Solana?
mfw when it's been using it this whole time I swear
I don't think it does but I also could be wrong lmao.
I have my rpc set in there already.
Doesn’t Anchor cli just use the current Solana config? Maybe I’m wrong - but i would think Solana config set —url [your rpc]
How do I use an RPC Node when running anchor deploy from the cli
Also would be glad to get explanations about test on js:
```puppetAccount = await puppet.account.data.fetch(newPuppetAccount.publicKey);
assert.ok(puppetAccount.data.eq(new anchor.BN(111)));```
Why do we need that line `await puppet.account.data.fetch(newPuppetAccount.publicKey)` ?
Why don't we just use `newPuppetAccount`?
Breaking my head trying to understand what is happening here.
Can someone explain next construction?
```accounts: {
        counter: counter.publicKey,
        user: provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      },
      signers: [counter],```
Why do we set `counter` and `signers` with the values from same source (account)?
Ok thanks for that. And so to increase at a later date I just rebuild and deploy again with a larger space variable? Or as the account will already be initiatilised how do I update the space ?
You can start with a shorter cap to save, and increase it as that list grows, if it makes sense for your use case
1024 pubkey strings is 1024 * 32 bytes. So you need to allocate that for the vec space.
I was putting in a pretty high number when deploying on devnet, but it is pretty expensive deploying to mainnet so seeing if I can make it more efficient
If I am going to create a struct to store some data on-chain as so :

#[account]
#[derive(Default)]
pub struct BaseAccount {
    pub mint_list: Vec<String>,
    pub bump: u8,
    pub nft_count: u8,   
}

Whereby mint list will store a Vector of a maximum of 1024 pubkey strings, how much space should I allocate to this account when I initialise it?
Basically I want to be able to write a function that is like `public async do_something(mything: MyType) -> Promise<..> {..}` and have MyType be type checked across both rust and ts
i have generated an IDL with a custom enum in it; how do i import that enum into typescript?  I tried "redefining" it the same way; but then it seems like it doesn't know how to encode it.

the closest thing i see is `program.idl.types['MyType']`
thanks a lot! 🙂
got it, i'll prob just split it up into two functions then
Mm, you have to be somewhat careful about it—I don't personally find it super confusing, but it leads to a lot of questions here.
is it deprecated tho? or ok to use?
There's `init_if_needed`
I think I've seen something like this, but I think it was deprecated
is there an account to initialize an account if it doesn't exist, and otherwise not fail?
specifically, i'll be making CPI calls to solend (spl-token-lending). curious if anyones done it before and if they have any insight for me
im going to need to do this later today. is there anything to keep in mind that is non obvious?


//////////////////////////////////////////////////////////////////////////////////////////

the multi-account approach seems potentially obnoxious because you have to pass all of them into the invocations; or know which are going to be read
ohh.. nm i wasn't quite groking what David what saying.  My example works if your data can fit in a single account; but I hadn't considered that multi account approach.  that's pretty interesting
Whether or not it is a PDA isn't really relevant.  For a FIFO or any variable length data; you can use a fixed length buffer.  https://github.com/gdoteof/solana-gamba/blob/master/programs/gamba/src/state/epoch.rs#L16

Your application logic needs to ensure you don't let more stuff get written to the buffer than space you've allocated for it
so you can have the datastructure here, in the list you can e.g. track state with a "head" and "tail" variable, and append to the tail, and pop from the head (or vice versa)
i mean a FIFO is a more specific version of a list, right?
It does makes sense to me but how can I implement a queue (fifo) using this ? A single PDA account which keeps track of head and n PDAs accounts which contains the main properties ?
if you know the size, just use an array, much easier haha
if it's something like a vector (i.e. length is not know), often ppl do this:
``` 
#[account]
pub struct List {
    pub head: u32,
}
``` 
which keeps track of the length of the list and then each element has it's own account
```
#[account]
pub struct ListElement {
    pub property1: Pubkey,
    pub property2: Pubkey,
    ...
}
``` 


then you would create a PDA in such a way to include this head, for example like this:
```
const [listElementAddres, listElementBump] = await PublicKey.findProgramAddress(
[SOME_GENERIC_SEED, listPosition],
    programId
) 
```

does that make sense?
allright, thanks for looking into it anyway! If I find the problem I will post it here
only guess is that your local and deployed frontend are not the same. other than that, idk myself
No I haven't do you have any repo link that I should look at ?
local is also targetting devnet
when you say local, are you saying that it works fine on localnet or is your local frontend version also targeting devnet?
oke... can you give me a little bit of guidance on how to fix it? locally it works fine.. just the deployed version is the problem
This means youre trying to call a function which does not exist in the program
I looked through old questions like mine but I can't figure out a solution based on answers that were given, so I'm sorry if this is a double question.. 

I'm running into this error when I try to "add a goal":
```Transaction simulation failed: Error processing Instruction 0: custom program error: 0x65 
    Program BYhgFTXaWGh2oxYRtQ7Xc4CzT7PWgZNwhe3us73HwRDz invoke [1]
    Program log: Custom program error: 0x65
    Program BYhgFTXaWGh2oxYRtQ7Xc4CzT7PWgZNwhe3us73HwRDz consumed 2150 of 200000 compute units
    Program BYhgFTXaWGh2oxYRtQ7Xc4CzT7PWgZNwhe3us73HwRDz failed: custom program error: 0x65```
```Error: 101: Fallback functions are not supported
    at Function.parse```

I have an Anchor project deployed to devnet. 
On my **local frontend everything is working perfectly fine**, but on my deployed frontend (netlify) I get these errors.. both my local frontend and my deployed frontend target "devnet"
If you want to check out the code my anchor project is at https://github.com/carlijnweijer/buildspace-solana-web3
and my frontend is at https://github.com/carlijnweijer/buildspace-solana-web3-frontend
D:\Worksapce>anchor init myepicproject2 --javascript
Error: yarn install failed: program not found
someone have meet this error ?
Really good tutorial here that goes into all the details: https://lorisleiva.com/create-a-solana-dapp-from-scratch
```program.rpc.initialize(yourObject.name, yourObject.age, contextAccounts)```
Got it , thank you. IF we are talking about JS part, how can I pass to initialize function? as {name : "test", age : 20}?
You'd have to pass them as separate variables as anchor doesn't support objects (yet). ```pub fn initialize(ctx: Context<Initialize>, name: String, age: i64)```
also any places where i can read more on the space part? I don't now how much space I should gives to the program
Thank you.. is Vector of Tuple something that is supported in Solana Program but just not with Anchor?
someone have meet this error ?
D:\Worksapce>anchor init myepicproject2 --javascript
Error: yarn install failed: program not found
what can i do for this ?
anyone?
I am not sure anymore if Vector works actually. there's been some questions before, im not sure if it worked in the end. Generally, I would try to write it in a different way as anchor is quite fragile when it comes to more complex data-types
i followed the anchor tutorial and installed solana-cli 1.9.4 and anchor-cli 0.20.1, which version would support vector of tuple?
hmm depends on the version, i would definitely go with array if thats an option
status is giving `IdlError: Type not found: {"type":{"defined":"(String, u16)"}}` when i `anchor test`... i guess Vector of tuple isn't supported?
or perhaps from a different angle, assuming I have a bunch of liquidity-providing positions, how would you calculate TVL?
I guess basically my question boils down to: is there a way to fetch a data-account, without providing it to the Account-context?
is there a way to traverse a list on-chain? 

i.e. a list that is implemented in a "anchor"'y way, i.e. you have one struct that is the positionList which records how many elements there are in total, and another struct, that contains the actual list-element information?
🙏
Hi all, I have 2 questions I am trying to run `anchor test` but it gave a `IdlError: Type not found: {"type":{"defined":"Address"}}`..... this is because I created the type alias `type Address = String;` and i suspect the IDL didn't map Address back to String... 

1. is it possible to use type alias when writing solana program? 
2. is it possible to use HashMap as I am having the same issue with HashMap... many people recommend using PDA but I am basically building a round-based game and so would simply like to store the result of the game like HashMap<RoundNumber, Winner>...
For example "Human {name: String, age: integer}"
Can I pass here some "complex" types - `pub fn initialize(ctx: Context<Initialize>, data: String)` instead of String?
Hey, folks. Currently trying to save simple object (several field) using anchor, but can't rly understand how I can pass this object
oh so that is default in the ctx . Thanks
Use `ctx.program_id`
How can  use program id of Current program in my rust code? I am creating account from my initialize method and I need to provide program id which is from current program. One option is I can pass from client as parameter but I thought program id we already defined by declareid macro so somehow we can refer.
Ubuntu 20.04.
What is could  be the problem? I installed everything i should have installed
found it ty
Hi, <@!831450660146642974>, Are you enjoying a good weekend? Please help me!🙏  I am facing same error now. https://discord.com/channels/889577356681945098/889702325231427584/934596708631973899
https://github.com/Kriptikz/anchor-pda-transfer-sol
they should be in the transaction logs I think
is there a way to access the bpf logs from frontend/react?
Looking for some help. I have the base of a very basic voting program. I want to require SPL tokens to be used for voting. Anyone willing to guide me a bit or point me in the right direction. ( I'm used to solidity and coming to solana is a bit of a system shock 🙂 )

anyone else getting this trying to deploy on mainnet right now?
I am facing this problem
running `anchor init [name]` is recently returning `Error: File exists (os error 17)` , anyone run into this before?
gm
Wow the explanations on the tutorial are really good, and the diagrams are great. Thanks!
How do I run tests in Dev Net using Dev Net's USDC?
Do I need to pass in the mint_authority account or something?
this is my struct
```

#[derive(Accounts)]
pub struct Deposit<'info> {
    #[account(mut)]
    pub mint: Account<'info, token::Mint>,

    #[account(mut)]
    pub wallet: Signer<'info>,

    #[account(init_if_needed, payer = wallet, associated_token::mint = mint, associated_token::authority = wallet)]
    pub vault: Account<'info, token::TokenAccount>,

    pub token_program: Program<'info, token::Token>,
    pub system_program: Program<'info, System>,
    pub associated_token_program: Program<'info, associated_token::AssociatedToken>,
    pub rent: Sysvar<'info, Rent>,
}
```
Im trying to create an ATA for wSOL, I keep getting this err and im not sure why

```
Program ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL invoke [2]
    Program ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL consumed 1953 of 190391 compute units
    Program ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL failed: insufficient account keys for instruction
```
Can anyone link any additional references to anchor programs that transfer native SOL in the instructions?
I've only been able to find one, the todo list with rewards
Great to know; thanks guys!!
No, only the first deploy actually costs that much—although I think annoyingly you need to have that amount in your account at the start of subsequent deploys, even though it won't really get spent
But also you don’t pay that cost when upgrading a program
It gets cheaper every minute!
Yeah i kept airdropping but it wasnt working. Didnt realize i needed like 5 sol to deploy
Every time I call “anchor deploy”, will it cost 5-6 SOL on mainnet? Sounds very expensive
`struct_one` is intended to exist in a 'one to many' relationship with `struct_two`
is it possible to initialize multiple accounts in one program, and then change data between them?
I have `FooProgram` that has methods `initialize_struct_one` and `initialize_struct_two`
 `struct_one` stands alone, and `struct_two` is seeded with `struct_one`.
`initialize_struct_one` initializes and integer to `0`, and `initialize_struct_two` increments the integer in `struct_one`. 

Even though these are both in the same program, it seems the compiler is treating it as a CPI, and I am getting the error `Cross-program invocation with unauthorized signer or writable account`
it says in the error message
`Error: Account PUBLIC_KEY has insufficient funds for spend (1.84766424 SOL) + fee (0.00133 SOL)`
Something like 1.4 sol / 100kb of deployed code
I think depends on the size of your contract. So maybe airdrop 5 or 6 SOL
howmuch SOL do i need to just deploy a txn?
Use `solana airdrop 1`. Max airdrop is 1 SOL at a time so might need to do it a few times.
Are you deploying to `devnet` ? You'll need to airdrop more `SOL` into your wallet.
Based on a simple counter program below, is it correct that one `user/authority` will have only one `BaseAccount`  account? 

If the same `authority` initializes a second account, can you still reference the first account? If so how? Would I need to keep a reference of the account off-chain somehow and pass it in to an instruction to find that account?


```
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod p0001 {
    use super::*;
    pub fn create(ctx: Context<Create>) -> ProgramResult {
        let base_account = &mut ctx.accounts.base_account;
        base_account.count = 0;
        Ok(())
    }

    pub fn increment(ctx: Context<Increment>) -> ProgramResult {
        let base_account = &mut ctx.accounts.base_account;
        base_account.count += 1;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Create<'info> {
    #[account(init, payer=user, space= 8 + 8)]
    pub base_account: Account<'info, BaseAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct Increment<'info> {
    #[account(mut)]
    pub base_account: Account<'info, BaseAccount>,
}

#[account]
pub struct BaseAccount {
    pub count: u64,
}
```
plz help 🙏🙏🙏
I don't have enough funds? huh?
I am trying to run `anchor deploy` but get the following error:

```
➜  solend-cpi git:(main) ✗ anchor deploy
Deploying workspace: https://api.devnet.solana.com
Upgrade authority: ~/.config/solana/id.json
Deploying program "solendcpi"...
Program path: ~/Desktop/solend-cpi/target/deploy/solendcpi.so...
=====================================================================
Recover the intermediate account's ephemeral keypair file with
`solana-keygen recover` and the following 12-word seed phrase:
=====================================================================
XXXXXXXXXXXX seed phrase here
=====================================================================
To resume a deploy, pass the recovered keypair as the
[BUFFER_SIGNER] to `solana program deploy` or `solana write-buffer'.
Or to recover the account's lamports, pass it as the
[BUFFER_ACCOUNT_ADDRESS] argument to `solana program close`.
=====================================================================
Error: Account PUBLIC_KEY has insufficient funds for spend (1.84766424 SOL) + fee (0.00133 SOL)
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }.
```
Does anchor generate javascript schema for deserializing your accounts, or do you just have to copy it to your javascript?
Solution: Add lifetimes

In the latest version of anchor how do I do this:


//////////////////////////////////////////////////////////////////////////////////////////

https://hackmd.io/@ironaddicteddog/anchor_example_escrow
Any good demo on creating vault using anchor to store spl token
Any full spl token transfer demo using anchor spl and cpi
Client call is like
From is spl token account holder by owner wallet account
To is also token account but hooded by other wallet address
Authority is same account as owner n owner account is used as signer
Hey <@!134416332509675520> , is this what you were referring to for doing CPI from a JS test? https://github.com/solana-labs/solana-program-library/tree/master/token-lending/js/src/instructions
Is there a way to not have the provider wallet not sign the transaction?  I want to write a test verify that someone calling an instruction with a key other than the wallet provider will fail?  It sounds like the JavaScript rpc calls always add the wallet as a signer
that series is really good
Yep that's where I got a bunch of ideas from - except I am stuck on the transfer SOL bit now
Not exactly sure what you mean, maybe check out this part of a tutorial which goes over testing on anchor. The explanations are really good and doesn't skip any steps, the diagrams are also great
https://lorisleiva.com/create-a-solana-dapp-from-scratch/testing-our-instruction
But this doesn't make sense from the smart contract case because on the client side all you have access to is the pubkey that is passed as an arg to the program's function
ex: 
```rust
create(ctx: Context<Create>, amount: u64, deposit_account:Pubkey) -> ProgramResult
```
In this case, the user who initially signed executed this does not know that the contract is actually transferring SOL to **another** account behind the scenes (that is the idea I am going for). I am passing in the pubkey here cause I don't know how to create one in Rust
Anyone been having issues using metaboss snapshot tool recently? I keep getting an operation timed out message, but solana network seems to be back firing on all cylinders, so didn't think it should be due to network errors. I have been trying using two custom RPCs, both timing out.
Howdy.  I'm having a hell of a time trying to figure out account constraints for a basic admin scenario.   For example, if I have a create_game instruction, I only want a top level authority to be able to execute that instruction.  What's the constraint look like?
I can use it directly right?
Maybe `Clock::get()?.unix_timestamp`?
RPC has method getBlockTime is there similar method which I can use in anchor solana rust?
And then pass it in to a tx
You'd have to, say, fetch that great big list and go find the account you care about
Yeah, you can't (in fact, you can only pass an absolute max of about 30 accounts into a solana tx)
Thanks Alan. So whats the best practice for this? Vec<PubKey> could be any length. How can I pre-specify all accounts if there could be any number of them?
thanks
You're making a mistake somehow, but I'm not sure how off the top of my head
No, it's on your end—you're messing up the CPI call, but to understand how you'll have to go source diving 🤿
But if you basically did `Keypair.generate()` then call `program.provider.connection.getAccountInfo(pubkey)` - there is no account so shouldn't return anything, maybe?
so it's not something on my end is it?
You'll have to go source diving to see where
You're invoking the candymachine program and then it's failing due to one of its own internal constraints
Add ` { ... features = ["no-entrypoint"] }` to that cargo dependency
but is it something on my end when trying to mint or when the program is created?
error[E0774]: `derive` may only be applied to `struct`s, `enum`s and `union`s
  --> programs/sbaddin/src/lib.rs:10:1
   |
10 | #[derive(Default)]
   | ^^^^^^^^^^^^^^^^^^ not applicable here
11 | vote_weight_record!(crate::ID);
   | ------------------------------- not a `struct`, `enum` or `union`

error: the `#[global_allocator]` in this crate conflicts with global allocator in: spl_governance

error[E0599]: no function or associated item named `default` found for struct `VoterWeightRecord` in the current scope
  --> programs/sbaddin/src/lib.rs:81:10
   |
11 | vote_weight_record!(crate::ID);
   | ------------------------------- function or associated item `default` not found for this
...
81 | #[derive(Accounts)]
   |          ^^^^^^^^ function or associated item not found in `VoterWeightRecord`
   |
   = help: items from traits can only be used if the trait is implemented and in scope
   = note: the following trait defines an item `default`, perhaps you need to implement it:
           candidate #1: `Default`
   = note: this error originates in the derive macro `Accounts` (in Nightly builds, run with -Z macro-backtrace for more info)

Some errors have detailed explanations: E0599, E0774.
For more information about an error, try `rustc --explain E0599`.
error: could not compile `sbaddin` due to 3 previous errors
In general you need to go source-diving to understand that errors mean
I'll post the full log
On the client you can call `program.provider.connection.getAccountInfo(pubkey)` but you only need to do this if your client is using that info somehow
If this is to me, yeah
I will try based on what <@!737915190045311067> suggested and see if it works
ex:
```
let user = anchor.web3.Keypair.generate();
let wallet = new anchor.Wallet(user);
```
Are you calling candymachine or something?
Is that the full log?
'Program log: Instruction: MintNft', 'Program log: Custom program error: 0x7d1', 'Program `programId` consumed 11601 of 
200000 compute units', 'Program programId failed: custom program error: 0x7d1']}}
has anyone seen this before:
`error: the #[global_allocator] in this crate conflicts with global allocator in: spl_governance`
Either you or something you're calling is
Can you post the full program log?
As I am trying to understand, on the client side I can do
```ts
anchor.web3.Keypair.generate()
```
But that's just the key - how do I get an Account out of that?
I'm not using any has_one constraint tho in my code
You have some `has_one =` constraint that is failing
Via its address
You have to pass it in from the client, like any other account
So how do you make an account from a pubkey?
<@!134416332509675520> sorry to @, any chance you know this?
Nope, you'll have to pass the account in from the client unfortunately (not possible to dynamically look up accounts like that from within your rust program—the client has to pre-specify *all* accounts)

Hey, does anyone know what does this error mean? 

`anchorpy.error.ProgramError: 2001: A has_one constraint was violated`
Mine is 
```rust
pub mod demo05 {
    use super::*;
    use solana_program::program::invoke;
    use solana_program::system_instruction::transfer;
    pub fn create(ctx: Context<Create>, amount: u64, deposit_account:Pubkey) -> ProgramResult {
        msg!("spk: inside create");
        let program_account = &mut ctx.accounts.program_owned_account;
        program_account.user_authority_account_key = *ctx.accounts.user_authority_account.key;
        program_account.amount = amount;
        program_account.deposit_account = deposit_account;

        let from = ctx.accounts.user_authority_account.key;
        let to = deposit_account.key();

        // not sure if this is the right approach
        // seems to be the web3.js approach
        // https://github.com/solana-labs/solana-web3.js/blob/master/examples/send_sol.js
        let tx = transfer(from, &to, amount);

        // see: https://github.com/solana-labs/solana-program-library/blob/master/examples/rust/transfer-lamports/src/processor.rs
        ctx.accounts.user_authority_account.try_borrow_lamports() -= amount;

        // NO idea how to handle the deposit_account since all I have is a pubkey...

        Ok(())
    }
}

// define the Create account to be used in the associated create() instruction
#[derive(Accounts)]
pub struct Create<'info> {
    #[account(init, payer=user_authority_account, space= 8 + 64 + 32 + 32)]
    pub program_owned_account: Account<'info, ProgramOwnedAccount>,
    #[account(mut)]
    pub user_authority_account: Signer<'info>,
    #[account(address = system_program::ID)]
    pub system_program: Program<'info, System>,
}

// the type being used in a struct decorated with the Accounts attribute, like in Create above
#[account]
pub struct ProgramOwnedAccount {
    pub amount: u64,
    pub user_authority_account_key: Pubkey,
    pub deposit_account: Pubkey,
}
```
Actually that's not my code - someone else posted it and I was asking them how they made the `AccountInfo`
I think your problem is a little different. Can you try changing     pub token_program: AccountInfo<'info>,
to  pub token_program: Program<'info, Token>,
It seems like you're suppose to  generate the keypair and create the account on the test side

this is from the todo list where he wrote functions to create multiple users for his tests
```
async function createUser(airdropBalance) {
  airdropBalance = airdropBalance ?? 10 * LAMPORTS_PER_SOL;
  let user = anchor.web3.Keypair.generate();
  let sig = await provider.connection.requestAirdrop(
    user.publicKey, airdropBalance);
  await provider.connection.confirmTransaction(sig);

  let wallet = new anchor.Wallet(user);
  let userProvider = new anchor.Provider(provider.connection,
    wallet, provider.opts);

  return {
    key: user,
    wallet,
    provider: userProvider,
  };
}

function createUsers(numUsers) {
  let promises = [];
  for(let i = 0; i < numUsers; i++) {
    promises.push(createUser());
  }

  return Promise.all(promises);
}

function programForUser(user) {
  return new anchor.Program(mainProgram.idl, mainProgram.programId,
    user.provider);
}```

for example he then creates two users to test his "add" function
```
describe('add', () => {
  it('Anyone can add an item to a list', async () => {
    const [owner, adder] = await createUsers(2);

    const adderStartingBalance = await getAccountBalance(adder.key.publicKey);
    const list = await createList(owner, 'list');
    const result = await addItem({
      list,
      user: adder,
      name: 'Do something',
      bounty: 1 * LAMPORTS_PER_SOL
    });
```
lol just saw that
If you look at my prev code, I am trying to call `transfer` and `invoke` but only have  a `Pubkey`..
<@!907013467049951243> haha funny I am having the same prob...
Is there a way to translate Pubkey to Account in Rust? I have a Vec<Pubkey> where each PubKey is the key of another account.
On the client side, it seems you have to do something like `KeyPair.generate()` but on the rust side you need a full on `AccountInfo` rather than just a `Pubkey`. 
1. How to either create an `AccountInfo` on the client side or
2. Create an `AccountInfo` in Rust/Anchor using the `Pubkey`
looks like `solana address -k target/deploy/myapp-keypair.json` does the trick
How do you define `AccountInfo` on the client side (assuming you did it)
All I know is to create a `Pubkey` based on the docs but lots of these calls require the `AccountInfo`..
From your code:
```rust
#[account(mut)]
    pub from: Account<'info,TokenAccount>,
    #[account(mut)]
    pub to: Account<'info,TokenAccount>,
    #[account(mut)]
    pub owner:Signer<'info>,
    pub authority: AccountInfo<'info>,
```
Is there a super dumb explanation on what it is and how to idiomatically keep it updated for programs?
hey all, I'm a bit confused on the program id macro `declare_id!`. Up until now I just sort of ignored it cause things just seemed to work. When I add a new program to the workspace I'd get the correct id for it by running tests and printing the programId from there; and then update the value. Now I've updated anchor version in my workspace and the programId has changed once again
But I originally wanted my anchor script to FEEL closer to my front end react scripts but making each thing a component (easier to reason about)
Maybe I’ll make an example repo real quick to explain the problem
I don’t remember it exactly but it so much of a pain in the ass o just moved it back into one file
The problem is working with the context yeh. I originally had every single related function, validation, data object, and relevant error code in one file (components) and then just forwarded the fns from the program (librs) to handler functions in those component rs files

I can’t remember the exact problem but basically something was encapsulated that stopped me from doing so because I needed two components to talk to eachother exactly
Thanks for the heads up. At first I had this all wrapped in the `invoke` call but the docs said it was for a CPI program so wasn't sure how to use it. Also in my case I am passing in the `Pubkey` of the account I want to send the SOL to but I have no idea how to convert it to an `AccountInfo` in order to call the `invoke`
You can definitely reuse helper functions. Just define them as a top-level function as opposed to a instruction function inside the `#[program]` struct. (You can *also* invoke those too, but yeah, it's slightly awkward because they have complicated arguments—but it's possible!)
I was able to split them but not in a way that made enough sense for me to do it. Reccomend just not for now sorry
My bad - wrong thread.
this is a large package, which part are you pointing to here?
Can solana sysvar https://docs.solana.com/developing/runtime-facilities/sysvars be used to generate temporary random number ?
like this? https://github.com/solana-labs/solana-program-library/blob/master/token/ts/src/instructions/initializeMint.ts
ahh gotcha
like `@solana/spl-token` for talking to the token program.
Ah, I don't mean an sdk as a backend server—I just mean a js lib that knows how to build instructions.
if my tests use an API, then my tests rely on a centralized backend server to function. So what if i rlly need to update my smart contract, but the API's server is down?
Is that bad? Why don't you want a js dependency?
getting signature verifcation failed
use anchor_lang::prelude::*;
use anchor_spl::token::{self,Mint,TokenAccount,Transfer};
use anchor_spl::token::Token;


declare_id!("2o72inQRyrGquF8vN4vRCoAiTRSkngYaxYekJ7CdhjBs");
#[program]
pub mod my_program {
    use super::*;
    pub fn initialize(
        ctx: Context<Initialize>,
    ) -> ProgramResult {
       
        let cpi_accounts = Transfer {
            from: ctx.accounts.from.to_account_info().clone(),
            to: ctx.accounts.to.to_account_info().clone(),
            authority:ctx.accounts.owner.to_account_info().clone(),
        };
        let cpi_program = ctx.accounts.token_program.clone();
        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
        token::transfer(cpi_ctx, 100)?;
       
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    
    #[account(mut)]
    pub from: Account<'info,TokenAccount>,
    #[account(mut)]
    pub to: Account<'info,TokenAccount>,

    #[account(mut)]
    pub owner:Signer<'info>,
    pub authority: AccountInfo<'info>,
    pub token_program: AccountInfo<'info>,
    pub system_program:Program<'info, System>,
}
hi any idea on signature varification failure
Hi mate, do you got the solution's for this, function calls another function without cpi and inside the same program, if you have, could you share the solution. and any resource code it might be helpful, thanks.
dms are open
any front end dev who can create cool website and dapp for us ?
I'm getting this error when running `anchor test` in the project repository. Anyone has any idea about how to resolve it?
Todo List that also shows how to transfer native SOL
https://dev.to/dimfeld/starting-with-solana-part-4-4j5k

Anchor version of escrow
https://hackmd.io/@ironaddicteddog/solana-anchor-escrow
Thanks man!
this tutorial has the best explanations 
https://lorisleiva.com/create-a-solana-dapp-from-scratch
book.anchor-lang.com
Hello everybody! Kind of starting fresh on anchor any docs or pieces of code you guys can refer me too!
I have been writing smart contract in Rust now the need of the hour is to learn a bit of anchor as well!
Would love some help on getting started with it....
Something like this, 
I've been trying to increment an "amount" field in other "item" accounts stored on a "list" account when SOL is sent to and from user, but haven't been able to get it to work

``` 
pub fn pay(
        ctx: Context<Pay>,
        amount: u64,
    ) -> ProgramResult {
        let user: &Signer = &ctx.accounts.user;

        let ix = anchor_lang::solana_program::system_instruction::transfer(
            &ctx.accounts.user.key(),
            &ctx.accounts.receiver.key(),
            amount * 1000000000,
        );
        anchor_lang::solana_program::program::invoke(
            &ix,
            &[
                ctx.accounts.user.to_account_info(),
                ctx.accounts.receiver.to_account_info(),
                ctx.accounts.system_program.to_account_info(),
            ],
        );

        Ok(())
    }


#[derive(Accounts)]
#[instruction(amount: u64)]
pub struct Pay<'info> {
     #[account(mut)]
    pub receiver: AccountInfo<'info>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```

I referenced this,
https://stackoverflow.com/questions/70528742/how-to-transfer-sol-in-anchor-smart-contract-instruction
The confusing bits are in this area:
```rust
// not sure if this is the right approach
        // seems to be the web3.js approach
// https://github.com/solana-labs/solana-web3.js/blob/master/examples/send_sol.js
        let tx = transfer(from, &to, amount);

        // see: https://github.com/solana-labs/solana-program-library/blob/master/examples/rust/transfer-lamports/src/processor.rs
        ctx.accounts.user_authority_account.try_borrow_lamports() -= amount;

        // NO idea how to handle the deposit_account since all I have is a pubkey...
```
How do you do a transfer of SOL in the rust code? Here is what I have so far but obviously it's not working. Anyone can offer up some ideas?
```rust
#[program]
pub mod demo05 {
    use super::*;
    use solana_program::program::invoke;
    use solana_program::system_instruction::transfer;
    pub fn create(ctx: Context<Create>, amount: u64, deposit_account:Pubkey) -> ProgramResult {
        msg!("spk: inside create");
        let program_account = &mut ctx.accounts.program_owned_account;
        if amount <= 0 {
            return Err(ErrorCode::AmountIsZero.into());
        }
        
        program_account.user_authority_account_key = *ctx.accounts.user_authority_account.key;
        program_account.amount = amount;
        program_account.deposit_account = deposit_account;
        let from = ctx.accounts.user_authority_account.key;
        let to = deposit_account.key();
        // not sure if this is the right approach
        // seems to be the web3.js approach
        let tx = transfer(from, &to, amount);

        // see: https://github.com/solana-labs/solana-program-library/blob/master/examples/rust/transfer-lamports/src/processor.rs
        ctx.accounts.user_authority_account.try_borrow_lamports() -= amount;

        // NO idea how to handle the deposit_account since all I have is a pubkey...

        Ok(())
    }
}

// define the Create account to be used in the associated create() instruction
#[derive(Accounts)]
pub struct Create<'info> {
    #[account(init, payer=user_authority_account, space= 8 + 64 + 32 + 32)]
    pub program_owned_account: Account<'info, ProgramOwnedAccount>,
    #[account(mut)]
    pub user_authority_account: Signer<'info>,
    #[account(address = system_program::ID)]
    pub system_program: Program<'info, System>,
}

#[account]
pub struct ProgramOwnedAccount {
    pub amount: u64,
    pub user_authority_account_key: Pubkey,
    pub deposit_account: Pubkey,
}
```
how u solve signature verification failed
How do I call a JS transaction with anchor, from a non-anchor program?
https://github.com/project-serum/anchor/tree/master/tests
go through the examples here 🙂
ahh so how do I specify the seeds in the macro if its just a string
so in anchor if you define that you want a PDA with a seed "myseed123", then that PDA created in another program will not have the same address
i dont know how to access it directly but i do know that under the hood it's already being used as part of the seed
want to use it for my PDA and seed macro
How do I access the program id variable
uses the heap instead of the stack
hmmm but the SDK relies on the API, which creates a dependency, no?
Or if you have their IDL as a file, you can load it up the same way you load your own IDL
Ideally they expose a js sdk you can install
Same issue
what's the best way to call a program that is not mine from my anchor tests?
https://docs.rs/anchor-lang/0.20.1/anchor_lang/?search=box
Reading this in the anchor docs:

"This is different from the solana program deploy command, because everytime it's run it will generate a new program address."

Is it recommended when deploying programs to mainnet to in that case use solana program deploy command instead of anchor deploy?
https://www.jetbrains.com/lp/mono/
This font is really nice
Why is there a `Box` used in some code i'm reading on gh, like: 
```
Box<Account<'info, TokenAccount>>
```
i think I'm meeting both of these requirements, i'm logging the bump and have had success and failures with  255, 254, and 253. 
```
let puppet_seeds = &[
  CONST_SEED,
  pubkey_b.as_ref(),
  pubkey_a.as_ref(),
  &[ctx.accounts.puppet_struct.bump],
];

puppet::cpi::puppet_funx(
  ctx.accounts.puppet_funx_ctx().with_signer(&[puppet_seeds]),
)?;```This is how I'm calling the CPI with signer seeds. I think this should be sufficient for passing the correct bump in, right?
yup
reference:
the compiler is not yelling at me so im gonna assume thats a yes
One way that could happen is if you're messing up the order of arguments to `#[instruction(...)]` (they need to match the order from the actual instruction function), or maybe you're inadvertently mixing up two different bumps (bumps have a 50/50 chance of being 255, so easy for things to "work" even if you're mixing them up)
does it make sense to use `init_if_needed` for simple token accounts?
it tells anchor the program's id.  anchor uses this probably for many things, but at minimum for address validation
hey guys! How i can create a new token for tests every time in one address?
Hey guys, rly silly question, but what does `declare_id` do?
Can anyone think of a reason / has anyone run into `Signer seeds do not result in a valid address` but only sometimes? It seems 50/50 on whether or not I get this error, where half the time it works fine.
Oh awesome. Great result
Subsequent deploys are ~free (seems like you annoyingly have to have roughly the same amount of sol in your wallet due to the details of how deploys work under the hood, but that sol won't actually get spent)
Does anyone know how much it costs to redeploy an anchor program to mainnet if you do minimal changes? My first deployment is going to cost a little under 2 SOL, but just wondering if I do a tiny change (like just one line), if I will have to pay a similar amount for each deployment?
i'm new to solana; i hadn't run into the 4kb stack size limit.  i didn't realize that limitation
i have accounts who have a data structure that's just a list of public keys; the data for those public keys is at pdas that are like [account_type, epoch, public_key].  i guess almost exactly the same; i just wasn't thinking of it in those terms
what i have is actually very similar though; but it's more like a hash table than a list
definitely has to be multi account for sure in many cases.  i hadn't considered using multiple in a continguous data structure like that.
some array is easiest for sure haha
i.e. fixed length buffers are probably good for u64 or somewhat simple data structures, but you might also hit the 4kb context pretty fast (again, depending on the input data..)
yh that's true, but if you have more complex data-models I think that's the only option, no?


//////////////////////////////////////////////////////////////////////////////////////////

thanks mate its work.
Sorry, if this type of thing happens again, I'll stop what I'm doing and create a fork if I can
I see
You're probably doing `program.rpc.doSomething` and forgot to define `program`
did you import your idl?
I was pulling my hair out getting unclear errors and this quirky state leakage
What is this error: 
```
TypeError: Cannot read property 'rpc' of undefined```
#[instruction(bump: u8)] is incorrect here because it should be  #[instruction(first_param:u64, bump: u8)]
I do the same.  
No repro under my current code, sorry.  I'm certain this was the issue:

```
   pub fn set_admin_settings(ctx: Context<SetAdminSettings>, first_param: u64, bump: u8) -> ProgramResult {
        let admin_settings = &mut ctx.accounts.admin_settings;
        admin_settings.admin_authority = *ctx.accounts.admin_authority.key;
        admin_settings.bump = bump;
        Ok(())
    }
#[derive(Accounts)]
#[instruction(bump: u8)]
pub struct SetAdminSettings<'info> {
    #[account(
        init,        
        seeds = [PDA_SEED_ADMIN],
        bump = bump,
        payer = authority,
        space = AdminSettings::SIZE
    )]
    pub admin_settings: Account<'info, AdminSettings>,    

    pub admin_authority: AccountInfo<'info>,
    #[account(mut, address = dapwords_initial_admin::ID)]
    pub authority: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```
This is why I never ever do an actual `anchor deploy` by the way when testing, I always just do `anchor test` and let anchor spin up a temporary validator
Not as far as I know 🤔 Just in the validator itself
I'm assuming there's some state/cache in the .anchor directory?
I'll see if I can get a repro, one sec.
Never run into anything like that
Could you show some program logs?
I've also just had weird corruption bugs that have caused runs to fail nondeterministically.  For example, I forgot a parameter name in an instruction and it was an opaque failure that gave a different error message on every test run.
I guess the only way to really deal with this would be to have pretty much every account have a [b"session", 2] seed
Yeah I usually write my tests in such a way that I make "new" accounts for each test/ignore the old ones
Yeah, and trying to write code that resets all possible state could be a rather big pain especially when dealing with accounts with PDA's
Right, I'm saying that the test-validator would need a "reset me" button, and I'm not sure it does
I can't really control how I talk to the test validator can I?  Is there an TS call to force account deletion no matter what?
So resetting is up to how you talk to the test validator in the background
Basically anchor itself doesn't have any js testing framework—it's just vanilla js tests
Actually now that I think about it, maybe the solana rust testing lib doesn't have this problem 🤔
What's surprising about it? The issue is that the js/ts tests are running against a live validator in the background
This is really surprising/scary considering we're dealing with chain programs.  No way to hack around it or lift out the testrunner?
Nope, no easy way to do this unfortunately :/
No way to reset test state between tests?  Makes it really hard to test things in isolation.
seems like my pda does not have enought sol but I can't solana airdrop my contract it does not work
is someone have an idea about how is it possible ? haha
Transaction simulation failed: Error processing Instruction 0: custom program error: 0x1 
    Program 3K1jZTmuKtqRNdzCUVXaMARNL28kegjRZiKo31dvR5gg invoke [1]
    Program log: Instruction: PlayGame
    Program 11111111111111111111111111111111 invoke [2]
    Transfer: insufficient lamports 0, need 10467840
    Program 11111111111111111111111111111111 failed: custom program error: 0x1
    Program 3K1jZTmuKtqRNdzCUVXaMARNL28kegjRZiKo31dvR5gg consumed 7794 of 200000 compute units
    Program 3K1jZTmuKtqRNdzCUVXaMARNL28kegjRZiKo31dvR5gg failed: custom program error: 0x1
so it gets hidden but there's a button people can click to see it
ERROR
```
Balance of Program Account account is 0
Balance of Authority/Wallet Account account is 500000000000000000
Balance of Deposit Account account is 0
Starting account creation and deposit...

Airdropping 2.5 lamports to UseAccount/Wallet 4oDmbjZsYoAcP9L3LLnGQcKMCZBXESt7npAAYAeCr94v
Airdropped signature [object Object]
Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account
Program BnHgqQKV6rjcJ371tkzHkjWJsEPQXt53hH84tWmqBEjZ invoke [1]
Program log: Instruction: Initialize
Program 11111111111111111111111111111111 invoke [2]
Program 11111111111111111111111111111111 success
Program 11111111111111111111111111111111 invoke [2]
Program 11111111111111111111111111111111 success
11111111111111111111111111111111's writable privilege escalated
Program BnHgqQKV6rjcJ371tkzHkjWJsEPQXt53hH84tWmqBEjZ consumed 18442 of 200000 compute units
Program BnHgqQKV6rjcJ371tkzHkjWJsEPQXt53hH84tWmqBEjZ failed: Cross-program invocation with unauthorized signer or writable account
```
TEST
```typescript
const provider = anchor.Provider.env();
anchor.setProvider(provider);
const idl = JSON.parse(readFileSync("./target/idl/demo06.json", "utf8"));
const program = anchor.workspace.Demo06 as Program<Demo06>;

// obviously not the best way to set this up...
const programAccount = anchor.web3.Keypair.generate();
const authority = provider.wallet;
const depositAccount = anchor.web3.Keypair.generate();

async function getBalance(pubkey: anchor.web3.PublicKey, accountName: string) {
  let balance = await provider.connection.getBalance(pubkey);
  console.log(`Balance of ${accountName} account is ${balance}`);
}

describe('demo06', () => {
  it('Is Created', async () => {
    console.log("STARTING TEST\n")
    console.log("Balance before creation\n");
    await getAllAccountBalance();

    console.log("Starting account creation and deposit...\n");

    // add some SOL to the authority/wallet
    await airDrop(authority.publicKey, 2.5);

    // send instruction to smart contract
    const tx = await program.rpc.initialize(new BN(1.3), {
      accounts:{
        programAccount: programAccount.publicKey,
        testDepositAccount: depositAccount.publicKey,
        authority: authority.publicKey,
        systemProgram:anchor.web3.SystemProgram.programId
      },
      signers:[depositAccount, programAccount]
    });
    console.log("Your transaction signature", tx);

    // verify the program account was created on the blockchain
    let pgAccount = await program.account.programAccount.fetch(programAccount.publicKey);
    console.log(`Program account on chain ${pgAccount}\n`);
    console.log("Balance After creation\n");
    await getAllAccountBalance();
    console.log("END TEST")
  });
});
```
I think I may have gotten something working but I re-did a new project to streamline stuff but running into the famous `Cross-program invocation with unauthorized signer or writable account error`. I looked at what other folks did with their but I am still stumped
Program:
```rust
declare_id!("BnHgqQKV6rjcJ371tkzHkjWJsEPQXt53hH84tWmqBEjZ");

#[program]
pub mod demo06 {
    use super::*;
    use solana_program::native_token::{lamports_to_sol, LAMPORTS_PER_SOL};
    use solana_program::system_instruction::transfer;
    pub fn initialize(ctx: Context<Create>, lamports_in: u64) -> ProgramResult {
        let program_account = &mut ctx.accounts.program_account;
        let authority_account = &mut ctx.accounts.authority;
        let system_account = &mut ctx.accounts.system_program;
        let test_deposit_account = &mut ctx.accounts.test_deposit_account;
        test_deposit_account.lamports = lamports_in * LAMPORTS_PER_SOL;

        let account_infos = [
            authority_account.to_account_info(),
            test_deposit_account.to_account_info(),
            system_account.to_account_info(),
        ];

        let tx = transfer(
            authority_account.key,
            &test_deposit_account.deposit_account,
            test_deposit_account.lamports,
        );
        solana_program::program::invoke(&tx, &account_infos);
        Ok(())
    }
}
#[derive(Accounts)]
pub struct Create<'info> {
    #[account(init, payer=authority, space=8+32+32)]
    program_account: Account<'info, CreateAccount>,
    #[account(init, payer=authority, space=8+32+8)]
    test_deposit_account: Account<'info, DepositAccount>,
    #[account(mut)]
    authority: Signer<'info>,
    system_program: Program<'info, System>,
}
#[account]
pub struct CreateAccount {
    program_account: Pubkey,
    authority: Pubkey,
}
#[account]
pub struct DepositAccount {
    deposit_account: Pubkey,
    lamports: u64,
}
```
my test keeps failing because the error is returned, but idk how to make the test pass against it
is there a proper way to write an anchor test for a scenario where you want to test a specific error code is returned?
Gonna repost as I don't know if it was hidden
Lets see now - so does that mean my giant code block from earlier got hidden as well?
really now - that would explain why I keep getting kicked off for no reason when I literally just do nothning
prolly because you have crypto in your name
discord keeps hiding your messages as "likely spammer"
<@!195345150132748288> this could be an idea: https://paulx.dev/blog/2021/01/14/programming-on-solana-an-introduction/
Are there any examples showing how to split up a program across multiple files?  I have a single, massively long lib.rs and it would be great if I could at least pull the data types into a separate file than the instructions
Any suggestions on the `Cross-program invocation with unauthorized signer or writable account` I posted a few hrs ago?
Associated token addresses are *always* PDAs (derived from the associated token program, not yours), so do you mean a regular, non-associated token account?
Not sure what that error is—can you post the full program log?
is there something like an `anchor build clean cache` command?
Hi  I have below struct where I want to update Pool account data which is PDA account. While Updating I am getting 3012 error which seems account is initialized but I am not using 'init'. Any idea? pub struct UpdatePool<'info> {

    #[account(signer)]
    owner : AccountInfo<'info>,
    margin_wallet : AccountInfo<'info>,
  
    #[account(mut, seeds=[(*rand.key).as_ref()], bump=_bump)]
    pool : Account<'info, Pool>,
    rand : AccountInfo<'info>,

}
Hey coming back to this from wayyy back. As I just got the same Owner cannot sign error - is my understanding correct then that attempting to create an associated token account for a PDA will result in that Owner cannot sign error ?
would it be possible to have one user request payment from another? and are there any examples of this?
But it would require having an external, off-chain program that acts like a chron job—you would need to poke your rust program when the time is right
You can use `Clock::get()?.unix_timestamp` to get the current time inside your rust program
are there any examples of programs that use time?
for example, payment is sent or received at some time interval based on agreement of two users
Can see some more examples here: https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo/src/lib.rs#L68
ok, i will search
Try searching the anchor repo for `bump =` to see a bunch of examples
understand, big thx! i suspected that i don't do anything with pda, but can't found how to do this
You'll have to figure out the right bump to use for that PDA (you're currently skipping that by saying just `bump` in the derive Accounts block)
Any time you do a token transfer, the authority over the tokens needs to sign the CPI. You're not doing that here.
```.rs
token::transfer(
            CpiContext::new_with_signer(
                ctx.accounts.token_program.to_account_info().clone(),
                transfer_cpi_accounts,
                &[
                  &[ctx.accounts.user.key().as_ref(), b"agrostaking", &[figure_out_the_right_bump]]
                ]
            ), value
        );
```
yes, i don't do this, where i can do this? sorry, i can't understand what this will do and why? 😦
You'll need to use `CpiContext::new_with_signer`
Doesn't look like you're actually signing with the staking_info seeds
hey, maybe someone can help pls?
Purely integers
can anchor's BN handle floats, or is it purely integers?
look at above test ,u need to pass all accounts
gm everyone,

How you you test your code when they use other programs accounts or invoke them?
Getting signature verification failure on this test
const { Program } = require("@project-serum/anchor");

const anchor = require("@project-serum/anchor");

const { publicKey } = require("@project-serum/anchor/dist/cjs/utils");

const { SystemProgram } = anchor.web3;

describe("basic-0", () => {


    anchor.setProvider(anchor.Provider.local());


    let secretKey = Uint8Array.from([57, 128, 78, 61, 58, 182, 228, 66, 81, 132, 18, 179, 221, 192, 252, 116, 136, 105, 13, 237, 140, 133, 171, 44, 211, 215, 16, 207, 239, 159, 107, 62, 86, 209, 127, 142, 67, 5, 67, 125, 152, 10, 20, 0, 30, 6, 99, 143, 147, 59, 18, 82, 73, 6, 36, 27, 92, 73, 70, 148, 71, 105, 246, 70]);

    const myAccount1 = anchor.web3.Keypair.fromSecretKey(secretKey);



    console.log(myAccount1.publicKey.toBase58());
    it("Uses the workspace to invoke the initialize instruction", async() => {


        const program = anchor.workspace.Basic0;

        // Execute the RPC.

        await program.rpc.initialize({

            accounts: {

                //from: ("Fg9bWdnMYqG5N9H7WCWtdeGo1Q3oNQcEQcgjGkHShhr3")
                from: ("Fg9bWdnMYqG5N9H7WCWtdeGo1Q3oNQcEQcgjGkHShhr3"),
                to: ("2hgSCKW4sSrsJcJR6WNH2yiDTDHSRTwqDSAc4LMY8VAN"),
                mint: ("A5hikrCr7AVL5SgxoaJJPy6XhJXgyQ5gCDTuQ272SV6n"),
                tokenProgram: ("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),
                //rent: [myAccount1],
                authority: [myAccount1],
                systemProgram: SystemProgram.programId,

            },

            signers: [myAccount1],

        });


    });

});
testfile is like this
use anchor_lang::prelude::*;
use anchor_spl::token::{self,Mint,TokenAccount,Transfer};
use anchor_spl::token::Token;


declare_id!("2o72inQRyrGquF8vN4vRCoAiTRSkngYaxYekJ7CdhjBs");




#[program]
pub mod my_program {
    use super::*;
    pub fn initialize(
        ctx: Context<Initialize>,
    ) -> ProgramResult {
       
        let cpi_accounts = Transfer {
            from: ctx.accounts.from.to_account_info().clone(),
            to: ctx.accounts.to.to_account_info().clone(),
            authority:ctx.accounts.authority.to_account_info().clone(),
        };
        let cpi_program = ctx.accounts.token_program.clone();
        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
        token::transfer(cpi_ctx, 100);
       
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {

    #[account(mut,associated_token::mint=mint,associated_token::authority=authority)]
    pub from: Account<'info,TokenAccount>,
    #[account(mut,associated_token::mint=mint,associated_token::authority=authority)]
    pub to: Account<'info,TokenAccount>,
    pub mint:AccountInfo<'info>,
    pub authority: Signer<'info>,
    pub rent :Sysvar<'info,Rent>,
    pub token_program: AccountInfo<'info>,
    pub system_program:Program<'info, System>,
}
hey any idea on signature varification faliure
and https://paulx.dev/blog/2021/01/14/programming-on-solana-an-introduction/#building-the-escrow-program-bob-s-transaction
https://project-serum.github.io/anchor/getting-started/introduction.html
hey can anyone tell me that how to make a token contract through anchor framework? is there any doc or help ?
hello, i have a problem when try transfer token from program token account (owner pda) to user wallet, but all my accounts "mut" ```pub fn unstake(ctx: Context<Unstake>) -> ProgramResult {
        let value = ctx.accounts.token_from.amount;

        let transfer_cpi_accounts = Transfer {
            from: ctx.accounts.token_from.to_account_info().clone(),
            to: ctx.accounts.token_to.to_account_info().clone(),
            authority: ctx.accounts.staking_info.to_account_info().clone()
        };

        token::transfer(
            CpiContext::new(
                ctx.accounts.token_program.to_account_info().clone(),
                transfer_cpi_accounts
            ), value
        );

        Ok(())
    } 
#[derive(Accounts)]
pub struct Unstake<'info> {
    #[account(mut)]
    pub token_from: Account<'info, TokenAccount>, // PDA agte token account for this user
    #[account(mut)]
    pub token_to: Account<'info, TokenAccount>, // user agte token account
    #[account(mut, seeds = [user.key().as_ref(), b"agrostaking"], bump)]
    pub staking_info: Account<'info, StakeInfo>,
    #[account(mut)]
    pub user: Signer<'info>,  // user who will unstake

    pub token_program: Program<'info, Token>,  //  address for token program for transfer
    pub system_program: Program<'info, System>,
}``` Where i have a mistake? 😦
nvm it's literally just .to_string() I just suck ass at reading rust docs
So in order to get `AccountInfos` I made the `deposit_account` be `init` and so on and added it to the signers array . Played around with removing the `init` but got other errors
I am kinda doing a very bad version of CPI here...
The error
```
Balance of Program Account account is 0
Balance of Authority/Wallet Account account is 500000000000000000
Balance of Deposit Account account is 0
Starting account creation and deposit...

Airdropping 2.5 lamports to UseAccount/Wallet 4oDmbjZsYoAcP9L3LLnGQcKMCZBXESt7npAAYAeCr94v
Airdropped signature [object Object]
Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account
Program BnHgqQKV6rjcJ371tkzHkjWJsEPQXt53hH84tWmqBEjZ invoke [1]
Program log: Instruction: Initialize
Program 11111111111111111111111111111111 invoke [2]
Program 11111111111111111111111111111111 success
Program 11111111111111111111111111111111 invoke [2]
Program 11111111111111111111111111111111 success
11111111111111111111111111111111's writable privilege escalated
Program BnHgqQKV6rjcJ371tkzHkjWJsEPQXt53hH84tWmqBEjZ consumed 18442 of 200000 compute units
Program BnHgqQKV6rjcJ371tkzHkjWJsEPQXt53hH84tWmqBEjZ failed: Cross-program invocation with unauthorized signer or writable account
```
The test:
```typescript
const provider = anchor.Provider.env();
anchor.setProvider(provider);
const idl = JSON.parse(readFileSync("./target/idl/demo06.json", "utf8"));
const program = anchor.workspace.Demo06 as Program<Demo06>;

// obviously not the best way to set this up...
const programAccount = anchor.web3.Keypair.generate();
const authority = provider.wallet;
const depositAccount = anchor.web3.Keypair.generate();

async function getBalance(pubkey: anchor.web3.PublicKey, accountName: string) {
  let balance = await provider.connection.getBalance(pubkey);
  console.log(`Balance of ${accountName} account is ${balance}`);
}

describe('demo06', () => {
  it('Is Created', async () => {
    console.log("STARTING TEST\n")
    console.log("Balance before creation\n");
    await getAllAccountBalance();

    console.log("Starting account creation and deposit...\n");

    // add some SOL to the authority/wallet
    await airDrop(authority.publicKey, 2.5);

    // send instruction to smart contract
    const tx = await program.rpc.initialize(new BN(1.3), {
      accounts:{
        programAccount: programAccount.publicKey,
        testDepositAccount: depositAccount.publicKey,
        authority: authority.publicKey,
        systemProgram:anchor.web3.SystemProgram.programId
      },
      signers:[depositAccount, programAccount]
    });
    console.log("Your transaction signature", tx);

    // verify the program account was created on the blockchain
    let pgAccount = await program.account.programAccount.fetch(programAccount.publicKey);
    console.log(`Program account on chain ${pgAccount}\n`);
    console.log("Balance After creation\n");
    await getAllAccountBalance();
    console.log("END TEST")
  });
});
```
I think I may have gotten something working but I re-did a new project to streamline stuff but running into the famous `Cross-program invocation with unauthorized signer or writable account` error. I looked at what other folks did with their but I am still stumped
```rust
declare_id!("BnHgqQKV6rjcJ371tkzHkjWJsEPQXt53hH84tWmqBEjZ");

#[program]
pub mod demo06 {
    use super::*;
    use solana_program::native_token::{lamports_to_sol, LAMPORTS_PER_SOL};
    use solana_program::system_instruction::transfer;
    pub fn initialize(ctx: Context<Create>, lamports_in: u64) -> ProgramResult {
        let program_account = &mut ctx.accounts.program_account;
        let authority_account = &mut ctx.accounts.authority;
        let system_account = &mut ctx.accounts.system_program;
        let test_deposit_account = &mut ctx.accounts.test_deposit_account;
        test_deposit_account.lamports = lamports_in * LAMPORTS_PER_SOL;

        let account_infos = [
            authority_account.to_account_info(),
            test_deposit_account.to_account_info(),
            system_account.to_account_info(),
        ];

        let tx = transfer(
            authority_account.key,
            &test_deposit_account.deposit_account,
            test_deposit_account.lamports,
        );
        solana_program::program::invoke(&tx, &account_infos);
        Ok(())
    }
}
#[derive(Accounts)]
pub struct Create<'info> {
    #[account(init, payer=authority, space=8+32+32)]
    program_account: Account<'info, CreateAccount>,
    #[account(init, payer=authority, space=8+32+8)]
    test_deposit_account: Account<'info, DepositAccount>,
    #[account(mut)]
    authority: Signer<'info>,
    system_program: Program<'info, System>,
}
#[account]
pub struct CreateAccount {
    program_account: Pubkey,
    authority: Pubkey,
}
#[account]
pub struct DepositAccount {
    deposit_account: Pubkey,
    lamports: u64,
}
```
```let account_lamports = **item.to_account_info().lamports.borrow();```
What does the double "**" in front of item mean?
How do I get the string version of a pubkey?
aka how do I get the string from:
```
let mint = stake.mint.key();
```
Hey is `anchor migrate` broken in the latest version or is it just my local?
ha I cant even remember how I did it now.
```
    #[account(init, payer=user,
      space=TodoList::space(&name, capacity),
      seeds=[
        b"todolist",
        user.to_account_info().key.as_ref(),
        name_seed(&name)
      ]
```
Could someone explain what the "seeds" portion of this code means? Specifically, what is the b"todolist" part for?
Yeah js but basically Im wondering if there's a way to load parts of a vector in account data but not the whole vector mainly to not load up data that I might not need to display
I'm leaving this here in case anyone searches for it though. durr
I'm stupid, i'm on a macbook now and it doesn't go off /home/username .. it's /Users/username
trying to run anchor deploy after setting everything up on a new computer:
```
✗ anchor deploy
Deploying workspace: http://localhost:8899
Upgrade authority: /home/username/.config/solana/id.json
Deploying program "my_prog"...
Program path: /Users/username/crypto/my_prog/target/deploy/my_prog.so...
Error: Dynamic program error: No default signer found, run "solana-keygen new -o /home/username/.config/solana/id.json" to create a new one
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.
```

I've verified that the id.json is there at that path already..
Oh i also run `anchor test` to test my code with the print statements
hi, i tried printing both with `msg!` and `println!` but when opening the program logs in the `.anchor` folder i dont see the print statements. Is there anything im missing?
Not totally sure what you mean—what bandwidth are you worried about? Are you trying to do this in js?
mainly for bandwidth purposes like loading only 25 items from vector in an account not the whole vector?
Anyone have a solution for loading lets say only a few items from an account holding a vector?
done
```json
return Keypair.fromSecretKey(
    Buffer.from(
      JSON.parse(
        fs.readFileSync(process.env.ANCHOR_WALLET, {
          encoding: "utf-8",
        })
      )
    )
  );
```

Property 'payer' does not exist on type 'Wallet'.ts(2339)

any help? thanks!
`pk.to_string()`
How do i get the string for a Pubkey?
ack. thanks.
It's a little bit awkward, you can use the `remaining_accounts` feature (try searching the anchor repo, should hopefully be fairly straightforward—it's just low-level)
I mixed this channel with solana's dev 🙂  somsone there responded with the cookbook link, that is super helpful.  https://solanacookbook.com/references/accounts.html#create-a-pda  

this now brings me to the next thing I need to figure out, this time anchor-related 🙂 - how can I pass a variable number of accounts from the client to a solana program while using anchor..  I should look at the macros it produces.    I need to make an interface that would receive a variable number of accounts.  This is easy in a traditional solana program. (as you can iterate incoming accounts)  ...all the examples of anchor though, so far, that I have seen, have been setting things up with static accounts (and by that I mean anchor macro-processed structs).   anyways, I'll dig a bit later, but if anything comes to mind, please lmk.
https://github.com/CrateProtocol/crate/blob/75d2c70a4e7bf227b5d4b82e96c5d884c81746f3/programs/crate-token/src/state.rs#L48
this is how crate does it if thats helpful
😄
appreciated! exactly what i was looking for
Depend on how much rounding error you can tolerate
As far as I can tell, using floating point isn't a good idea.  Check out the spl-math library.  Otherwise, simple fixed point multiply, first with u128 then divide and then go back to u64 should do it.
hi everyone, new to anchor and to rust as well. say i wanted to take a percentage of a transaction as a fee. as the amounts are in u64, what is best practice to take the percentage I want? should i cast the amount to f64 to multiply it by the desired ratio, or is there a method i'm unaware of?
It indeed does a CPI to the system program under the hood
Often you can get away with just using anchor's `init` attribute, would that work?
are there any examples of using the SystemProgram to create an account from within the solana program?  I presume this would require CPI invocation with a SystemInstruction...  just starting to look at this, would appreciate pointers if anyone has any.
Oh i also run `anchor test` to test my code with the print statements
Thanks a lot, read through the rust code and adjusted mine
I fixed it!!
hi, i tried printing both with `msg!` and `println!` but when opening the program logs in the `.anchor` folder i dont see the print statements. Is there anything im missing?
You the man alan. Thanks for the support.
Or ask about it in their discord etc.
Yeah, might have to just copy their rust code: https://github.com/solendprotocol/solana-program-library/blob/mainnet/token-lending/program/src/instruction.rs
Guess i'll just make my own instruction builders for those instructions
My plan was to just do something like:
```
const txn = new Transaction(
   solendSdk.createInitLendingMarket(...)
)

sendAndConfirmTransaction(txn)
```
On the other hand, `spl-lending` has the instruction builders for instructions like `InitLendingMarket`, but the parameters are different than solend: 
https://github.com/solana-labs/solana-program-library/tree/master/token-lending/js/src/instructions
https://github.com/solendprotocol/solend-sdk/tree/master/src/instructions
ugh alan i am stuck man .. I'm trying to integrate with Solend, who forked the `spl-lending` library, but Solend didn't provide all the instruction builders for all their transactions (e.g. `InitLendingMarket`)
Exactly how e.g. anchor talks to the spl token program from within rust
Ideally if you want to some random program X, they provide a way to build instructions (so a source code dependency)
But it's a way to build an instruction that you can invoke directly from the client (or add as an extra instruction to a tx, etc.)
Yeah (it's not really a "CPI" since that only happens within your rust program)
Ok, do you know what the `has_one` attribute does?
This one is what is in the source code for the function I'm trying to call
I am trying to interact with an already existing program, not create one
I am kinda making a bit of a guess here but it seems that's the idea
<@!314065112984190976> https://project-serum.github.io/anchor/tutorials/tutorial-2.html#defining-a-program
I think that the struct you pass in to your function also has to have a field called `wallet`
```pub struct MintNFT<'info> {
    #[account(
        mut,
        has_one = wallet
    )]```

this is the only bit of code where "has_one" appears
Could you help me out on where to look? I'm lost 😅


//////////////////////////////////////////////////////////////////////////////////////////

k, i think i solved the problem.

it warrants more discussion but...

changing `[programs.devnet]` to `[programs.localnet]` in my Anchor.toml,

and changing 

```
[provider]
cluster = "devnet"
```

to 

```
[provider]
cluster = "localnet"
```

seems to have worked.
hey <@!856894333180706876> , any ideas here? and/or best ways to address this?
correct
Thanks - So it allows someone to create/allocate the account on the chain independently but then the instruction with `#[account(zero)]` can guarantee that it has not been used?  Does this also mean the discriminator will then be set by an an instruction with `#[account(zero)]` even if the instruction does not mutate the account?
hey all, program_id question.

i cloned a repo containing an Anchor program from github (my own).

i `solana-test-validator -r` then `anchor deploy`.

the latter computes my `program_id`.

this `program_id` does *not* match that which i have in my repo's Anchor.toml nor in its `declare_id!` call (which is the program_id that was computed when i initially built this code locally, when writing it).

why might this be?
if you create an account in the previous instruction instead of creating it within the program via CPI
```#[account(zero)]``` All the docs say is "Checks the account discriminator is zero."  I see it used in the examples but can't figure out it's purpose.  Why/when would you ever want the discriminator to be zero?
<@!594851438560149505> <@!347689664855015424> thanks for the support
Hello , Im junior willing to work 7/24 on angular,react,vue . Need some salary for food seriously.
i forgot mut
Oh and this page: https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html  has unblocked me a few times.  It's only linked to in a spot at the bottom of a page of the docs.
I second that the tests directory is an invaluable resource, but there's a bit of a tradeoff in it.  It's vast, but the style and technics across the different examples are not consistent so I've spent a lot of time trying to figure out what the current / best way to do things is.  (I'm guessing that the older projects in there have not been reevaluated  as Anchor has evolved.)  For example, I had a hell of a time trying to track down the best way to deal with Tokens, and I'm still struggling to get something minted.  There's three or so projects: CFO, token-proxy, and, "misc."  The funny thing is that my current guess at the best way to handle tokens is in misc/context.rs which I just stumbled upon, and the javascript code exercising it is thin.
I updated to 1.8.13 via curl and was able to run with that (also on a mac)
Again I had the same issue where it said 1.7.15 was the latest compatible despite there being much newer versions available
i'm going to try to download 1.9.5 with curl
is this right? says solana cli 1.7 wtf
btw would anyone know why in macos im asked for permission to run almost any command, i have to use sudo all the time now, it used to not be like that
downloading an update
lol
Yeah, think that solana is too old

I had a similar issue when I first was setting up Anchor, and it was because my solana tools were too old
What version of the solana tools do you have installed?
anyone know why I get this error when i run
`anchor build`
Oh neat, didn't realize there were so many more examples, thanks!
Now you have some "global" state living at an account whose address is program-derived with seeds = "whatever".
But the basic idea is just to do something like
```.rs
#[derive(Accounts)]
pub struct YourInstruction<'info> {
  #[account(
      init,
      payer=somebody,
      seeds=[b"whatever"],
      bump,
      space=8 + ...,
  )]
  pub global_state: Account<'info, YourGlobalState>,
  ...
}
```
Have you tried looking in the tests/ directory? Lots more examples in there
Hi, quick beginner question. I was planning to use `#[state]` to store some "global" state for my program, but just got the warning that it is deprecated and will be removed soon. The deprecation message says `Use a PDA with static seeds instead`, but is there some example somewhere of how to create PDAs in anchor with static seeds? I don't think creating/using PDAs are covered in any of the Anchor basic examples in the repo
ohh right, I ended up just catching the error and skipping for those kind of accounts. As it is to do a token airdrop, so prob don't want those accounts getting tokens anyway!
Ah, I see—yeah, by default associated token addresses (the js part anyway) don't work with pdas, but there's an optional argument to say "don't worry, I know what I'm doing"
Trying to run the Token.getAssociatedTokenAddress function on JS. 

That account appears to be an escrow account for Solsea NFT Marketplace as best as I can tell..thats why I thought that maybe I couldn't generate an Associated Token Address for a PDA account?
what's the command to update `solana cli` and `spl-token` to the latest stable version ?
This is the full error

/Users/wally/repos/metaboss/node_modules/@solana/spl-token/lib/index.cjs.js:1747
      throw new Error(`Owner cannot sign: ${owner.toString()}`);
            ^

Error: Owner cannot sign: 8y2DF8mAmgNqPsJWBFHS7zGLPHz43PcEwKCK2Tj47d5m
    at Function.getAssociatedTokenAddress (/Users/wally/repos/metaboss/node_modules/@solana/spl-token/lib/index.cjs.js:1747:13)
Any way to get list of "mut" accounts as input of an instruction? Can we use remaining_accounts as mut?

Looked at the source, it could be, depending on how we pass them in input.
found the fix. embarassing. Make sure your context is the same as your instruction's name not the Accounts name

happens whenever I run 'anchor build'
Sorry if wrong channel
Not sure why I'm getting this error. Was there a change ?

I have a question about paulx's escrow program. I think this program is just for 1 trade, 

it is not possible to make multiple escrows open like
Alice - Bob
Alice - Mark
John - Mike

etc. 

Because there is only one pda account, am I right?
I know it's been a few days, but could you please share what solved your problem? I'm running into the same issue 🙂
Pretty much, but you just don't get any return data. All programs can receive instructions from clients, or other programs. The difficult part can be creating the instruction properly before you send it, especially if they aren't open source where you can see what data and accounts the instruction needs.
web2 analogy time: so are CPIs like API calls to another service or something?
where can I check this?
which is quite annoying
So option breaks it
you can just annotate the struct with Default and not use `space` and anchor will try to infer but it also only works if your default instances == max size
this is not always true. e.g. if the struct has options
whenever I create an account, do I need to add any additional (8) bytes the the space definition? Specifically, in the as below, should it be
```
    #[account(
        init,
        payer = initializer,
        space = 64,
        seeds = [bond_pool_account.key().as_ref()],
        bump = _bump_tvl_account
    )]
    pub tvl_account: Account<'info, TvlInfoAccount>, 
```

or
``` 
    #[account(
        init,
        payer = initializer,
        space = 8 + 64,
        seeds = [bond_pool_account.key().as_ref()],
        bump = _bump_tvl_account
    )]
    pub tvl_account: Account<'info, TvlInfoAccount>,
```

assuming that `TvlInfoAccount` only holds one u64 in it's account defition?
Found issue .. didn't source my profile v beginner 😆 thanks anyways
std::mem::size_of::<User>()
Hi,
Is there a way to automatically deduce the space of a struct?

```rust
    #[account(init, payer = author, space = User::LEN)]
    pub user: Account<'info, User>,
```
Here I need to `implement` by myself the LEN method of User struct.
Does Anchor provide a shorthand for this?
I tried using init_if_needed but I couldn't find the right stuff to make it work
What's the easiest way to remedy this?

but I used a tool called draffle to delete my unused accounts...
so now it cant send back bc
and just doing an spl token transfer

Okay funny scenario. 
I sent my solana program an nft. 
nomrally I could get it back using
😉
Rust is a multiplayer survival game
hi, what's rust?
haha I knew it was something simple. Thanks
yournumber as u64
Hey how can I get a `u8` into a `u64`?
is the answer.  took me an hour to figure it out.
```
export function u64ToSeed(num: BN) {
    return num.toBuffer('le', 8);
}
```
That PDA is not matching between javascript and rust.   Any idea on how to add a u64 to a seed in javascript?
```
  //word_index is a u64
 #[account(
        init,
        seeds = [PDA_SEED_MINT, game.key().as_ref(), &word_index.to_le_bytes()],
        bump = mint_bump,
        payer = user,
        mint::decimals = 0,
        mint::authority = game,
        mint::freeze_authority = game
    )]
    mint: Account<'info, Mint>,

 ///Javascript
  const [publicKey, bump] = findProgramAddressSync(
        [Buffer.from(PDA_SEED_MINT), gameAccountPda.publicKey.toBuffer(), new BN(wordSlotIndex).toBuffer()],
        program.programId
    );
```
Very beginner question: If an instruction returns an `Err` no state changes are persisted, correct?
wish i did
Refactored a bit and got it built - test failing but progress at least
```rust
pub mod demo06 {
    use super::*;
    use solana_program::native_token::{lamports_to_sol, LAMPORTS_PER_SOL};
    use solana_program::system_instruction::transfer;
    pub fn initialize(ctx: Context<Create>, lamports_in: u64) -> ProgramResult {
        let authority_account = &mut ctx.accounts.authority;
        let deposit_account = &mut ctx.accounts.deposit_account;
        let lamports_to_deposit = lamports_in * LAMPORTS_PER_SOL;

        msg!("force git");

        let account_infos = [
            authority_account.to_account_info(),
            deposit_account.to_account_info(),
        ];

        let tx = transfer(
            authority_account.key,
            deposit_account.key,
            lamports_to_deposit,
        );
        solana_program::program::invoke(&tx, &account_infos);

        Ok(())
    }
}

#[derive(Accounts)]
pub struct Create<'info> {
    #[account(init, payer=authority, space=8+32+32)]
    program_account: Account<'info, CreateAccount>,
    #[account(init, payer=authority, space=8)]
    deposit_account: AccountInfo<'info>,
    #[account(mut)]
    authority: Signer<'info>,
    system_program: Program<'info, System>,
}

#[account]
pub struct CreateAccount {
    program_account: Pubkey,
    authority: Pubkey,
}
```
The issue I have before the build will pass is 
```rust
let account_infos = [
            authority_account.to_account_info(), //from
            deposit_account,                     //to
        ];
```
How to go from a `Pubkey` to `AccountInfo` as required by the `invoke()` call
<@!134416332509675520> So I have something more simplified now
```rust
pub mod demo06 {
    use super::*;
    use solana_program::native_token::{lamports_to_sol, LAMPORTS_PER_SOL};
    use solana_program::system_instruction::transfer;
    pub fn initialize(ctx: Context<Create>, lamports_in: u64) -> ProgramResult {
        let program_account = &mut ctx.accounts.program_account;
        let authority_account = &mut ctx.accounts.authority;
        let system_account = &mut ctx.accounts.system_program;
        let deposit_account = &mut ctx.accounts.program_account.deposit_account;
        let lamports_to_deposit = lamports_in * LAMPORTS_PER_SOL;

        let account_infos = [
            authority_account.to_account_info(), //from
            deposit_account,                     //to
        ];

        let tx = transfer(authority_account.key, deposit_account, lamports_to_deposit);
        solana_program::program::invoke(&tx, &account_infos);

        Ok(())
    }
}

#[derive(Accounts)]
pub struct Create<'info> {
    #[account(init, payer=authority, space=8+32+32)]
    program_account: Account<'info, CreateAccount>,
    #[account(mut)]
    authority: Signer<'info>,
    system_program: Program<'info, System>,
}

#[account]
pub struct CreateAccount {
    program_account: Pubkey,
    authority: Pubkey,
    deposit_account: Pubkey,
}
```
thanks for taking a look, will refactor and see how it goes - appreciate it so much!
I think in my demo05 I had it as you suggested but took this approach as I wanted some code separation blah blah
That's probably the real intent, but as I was working this out in my head and trying to separate it out logically it seems to have made sense (clearly not!)
Are you sure you don't just want to pay `test_deposit_account.key()`?
I don't know why you want to use these inner fields at all haha
You then try to pay one of its un-set fields, which gives you the error you're getting
I'm saying that what you're doing right now is creating an account at `testDepositAccount` (so far so good), but then you never actually set any of its fields
If you really want to set it you need to set it in *rust*
Nope—forget the inner `depositAccount` thing, I'm not sure what you're trying to do with it
As for the storage bit, I am learning as I go...
so something like 
```rust
      accounts: {
        programAccount: programAccount.publicKey,
        testDepositAccount: {
          depositAccount: depositAccount.publicKey,
        },
        authority: authority.publicKey,
        systemProgram: anchor.web3.SystemProgram.programId
      },
      signers: [depositAccount, programAccount]
```
?
(I'm actually not sure what you're intending to do with those fields, e.g. why you have a `lamports: u64` in there—you don't need to store that yourself, solana does that for you)
So the test_deposit_account itself is initialized, but not its data (the `DepositAccount` struct)
You never actually give it a value (so it's zeroed out)
No, I'm saying that `test_deposit_account.deposit_account`, the inner `deposit_account` field, is never set
I am marking this as `init` - is this method to initialize wrong?
```rust
    #[account(init, payer=authority, space=8+32+8)]
    test_deposit_account: Account<'info, DepositAccount>,
```
You're paying `&test_deposit_account.deposit_account` (which is uninitialized), rather than, I don't know, `test_deposit_account.key()` or something
In the test I generated all new keys and pushed them to the rust program
so where in the code I am screwing up ?
Anyone know is the easiest way to get the minimum balance for rent exemption for a given account from inside a rust program?
Aka the system program
Ah, because you never actually set the destination account—so it defaults to the zero pubkey
hi, did you find any solution on this? need help about same thing.
latest with the sys program removed from the infos array
https://github.com/sparkydasrath/rust/tree/main/anchor/demo06
Is this on github?
Hmm, not sure why actually you're inadvertently trying to mutate the system program
removed and rebuilt - but same error (didn't expect this to have fixed it right off the bat)
One, don't need to pass the system program in that `account_infos` list
```typescript
const provider = anchor.Provider.env();
anchor.setProvider(provider);
const idl = JSON.parse(readFileSync("./target/idl/demo06.json", "utf8"));
const program = anchor.workspace.Demo06 as Program<Demo06>;

// obviously not the best way to set this up...
const programAccount = anchor.web3.Keypair.generate();
const authority = provider.wallet;
const depositAccount = anchor.web3.Keypair.generate();

async function getBalance(pubkey: anchor.web3.PublicKey, accountName: string) {
  let balance = await provider.connection.getBalance(pubkey);
  console.log(`Balance of ${accountName} account is ${balance}`);
}

describe('demo06', () => {
  it('Is Created', async () => {
    console.log("STARTING TEST\n")
    console.log("Balance before creation\n");
    await getAllAccountBalance();

    console.log("Starting account creation and deposit...\n");

    // add some SOL to the authority/wallet
    await airDrop(authority.publicKey, 2.5);

    // send instruction to smart contract
    const tx = await program.rpc.initialize(new BN(1.3), {
      accounts:{
        programAccount: programAccount.publicKey,
        testDepositAccount: depositAccount.publicKey,
        authority: authority.publicKey,
        systemProgram:anchor.web3.SystemProgram.programId
      },
      signers:[depositAccount, programAccount]
    });
    console.log("Your transaction signature", tx);

    // verify the program account was created on the blockchain
    let pgAccount = await program.account.programAccount.fetch(programAccount.publicKey);
    console.log(`Program account on chain ${pgAccount}\n`);
    console.log("Balance After creation\n");
    await getAllAccountBalance();
    console.log("END TEST")
  });
});
```
Aka the system program
```rust
declare_id!("BnHgqQKV6rjcJ371tkzHkjWJsEPQXt53hH84tWmqBEjZ");

#[program]
pub mod demo06 {
    use super::*;
    use solana_program::native_token::{lamports_to_sol, LAMPORTS_PER_SOL};
    use solana_program::system_instruction::transfer;
    pub fn initialize(ctx: Context<Create>, lamports_in: u64) -> ProgramResult {
        let program_account = &mut ctx.accounts.program_account;
        let authority_account = &mut ctx.accounts.authority;
        let system_account = &mut ctx.accounts.system_program;
        let test_deposit_account = &mut ctx.accounts.test_deposit_account;
        test_deposit_account.lamports = lamports_in * LAMPORTS_PER_SOL;

        let account_infos = [
            authority_account.to_account_info(),
            test_deposit_account.to_account_info(),
            system_account.to_account_info(),
        ];

        let tx = transfer(
            authority_account.key,
            &test_deposit_account.deposit_account,
            test_deposit_account.lamports,
        );
        solana_program::program::invoke(&tx, &account_infos);
        Ok(())
    }
}
#[derive(Accounts)]
pub struct Create<'info> {
    #[account(init, payer=authority, space=8+32+32)]
    program_account: Account<'info, CreateAccount>,
    #[account(init, payer=authority, space=8+32+8)]
    test_deposit_account: Account<'info, DepositAccount>,
    #[account(mut)]
    authority: Signer<'info>,
    system_program: Program<'info, System>,
}
#[account]
pub struct CreateAccount {
    program_account: Pubkey,
    authority: Pubkey,
}
#[account]
pub struct DepositAccount {
    deposit_account: Pubkey,
    lamports: u64,
}
```
1 is actually 0 in base58 (lol, confusing), so that's the all-zero public key
Or something, not sure
what does that 111 mean
You're somehow passing the wrong account in your CPI
So that's weird, you definitely can't mutate the system program 😛
`11111111111111111111111111111111's writable privilege escalated
`
all good - just appreciate you taking the time to help
```
Balance of Program Account account is 0
Balance of Authority/Wallet Account account is 500000000000000000
Balance of Deposit Account account is 0
Starting account creation and deposit...

Airdropping 2.5 lamports to UseAccount/Wallet 4oDmbjZsYoAcP9L3LLnGQcKMCZBXESt7npAAYAeCr94v
Airdropped signature [object Object]
Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account
Program BnHgqQKV6rjcJ371tkzHkjWJsEPQXt53hH84tWmqBEjZ invoke [1]
Program log: Instruction: Initialize
Program 11111111111111111111111111111111 invoke [2]
Program 11111111111111111111111111111111 success
Program 11111111111111111111111111111111 invoke [2]
Program 11111111111111111111111111111111 success
11111111111111111111111111111111's writable privilege escalated
Program BnHgqQKV6rjcJ371tkzHkjWJsEPQXt53hH84tWmqBEjZ consumed 18442 of 200000 compute units
Program BnHgqQKV6rjcJ371tkzHkjWJsEPQXt53hH84tWmqBEjZ failed: Cross-program invocation with unauthorized signer or writable account
```
Sorry, wasn't clear about that ^
Not in the `.anchor` directory, just like in the anchor test output in your terminal
Need to post the entire program log (how are you running this? via the tests? they ought to just print)
a fave of a few folks `Program BnHgqQKV6rjcJ371tkzHkjWJsEPQXt53hH84tWmqBEjZ failed: Cross-program invocation with unauthorized signer or writable account`
Which error?
<@!134416332509675520> based on the code and similar error I posted above, I am looking at the `.anchor\test-ledger\validator.log` but mine does not show any error messages just a few `warn` on start up and all `info` after...
You're either not signing for something correctly, or you've forgotten to mark one of the accounts as mut (the full program log will tell you)
(Need to sticky this) it helps to post the *full* program log (it will actually tell you what's going wrong here—there will be additional information)
I am getting the same. I posted some of my code earlier in the thread, how closely does yours match?
Hmm, good question, I'm not sure how they do that
Don't feel bad! I'm not very familiar with metaplex so I'm actually not sure the best way to find a given nft account 🤔
Gotcha thanks, any idea how the invictus rebasing works? According to the UI i am gaining new rebase tokens each second. Is a crank triggering that constantly?
Yeah, no way to do it on-chain, have to have some external program do the chron-ing
any clever ways to run a cron on chain? How do people give out rebase rewards on a schedule, with a crank?
Getting "Cross-program invocation with unauthorized signer or writable account" error, do anybody have ideas what might be the cause?
Hey guys
feel extremely embarrassed and ashamed, but would you please sharing some example on how this can be achieved?
anyone have an example of using serum dex with anchor? set up new market, make orders, check order book, etc.
Hey what does the --provider.wallet argument expect in the anchor CLI ? A path to a keypair? I can't seem to get it to work
Right. The client would have to just pass in the right token account
mmm… would you mind elaborating especially with proof? Checking through all 10k NFT, for example, is too computationally heavy right?
Yep, you'd have to have the client pass in proof (a token account with the right kind of nft mint, amount = 1, owner = the wallet, etc.)
hi all! is there any way to condition the program so it only executes if the wallet connected has one of NFT collection?


//////////////////////////////////////////////////////////////////////////////////////////

check the `account_info.data.borrow().len()`
Whats the best way to check account data size? To prevent it from exceeding 10 mb
just to make sure, with find_program_address.. it iterate an array of bumps from 255 to 0  and return the first valid pda right... meaning wherever i call find_program_address i would get the same pda and bump as long as i provide the same seeds and program_id?
thanks
i got it to work like this
u r right
So unless `ctx.program_id` is the exact same address as that "G1D..." thing, there's no reason to expect both lines above to work
Is that hardcoded program_id your actual program id? In general it's possible for `create_program_address` to fail (usually you have to pass an explicit bump calculated by `find_program_address`)
Those are actually the same type, so don't think that's your problem above
i noticed `ctx.program_id` belongs to `solana_program::pubkey::Pubkey` while `program_id` is `anchor_lang::prelude::Pubkey`
i am trying to have a program function that generates a bunch of account with PDA, the first line using `&ctx.program_id` doesn't works... but the second & third lines works.... is there a way to make it work?
thanks a lot
https://docs.rs/anchor-lang/latest/anchor_lang/context/struct.Context.html#structfield.program_id
wow cool thanks
`ctx.program_id`
any method to access the programId inside a program function?
Hey everyone,
do we have any example of anchor used in react ts project? I want to look and get some ideas (specially about subscribing to changes...)
how i can fix this error Cross-program invocation with unauthorized signer or writable account
Let me know if you need help implementing
Right, so I got this working but had to use typescript instead of JS
hi, how can i add arguments in anchor instruction without breaking js client? for example

pub mod my_program {
    use super::*;

    pub fn create(ctx: Context<Create>)

}
into:

pub mod my_program {
    use super::*;

    pub fn create(ctx: Context<Create>, amount: u64)

}

But have old ui app working with new instruction (new fields just appended)
This is a bit of an OMG for anyone else that runs into it:  If you see an `owner`  pubkey set to 0 after you call getAccountInfo... that's actually is 11111111111111111111111111111111  in base58.  Lost so much time to this. 
```
console.log('after airdrop', (await provider.connection.getAccountInfo(user.publicKey, 'confirmed')).owner);        
console.log('after airdrop', (await provider.connection.getAccountInfo(user.publicKey, 'confirmed')).owner.toBase58());
```
results in 
```
after airdrop PublicKey { _bn: <BN: 0> }
after airdrop 11111111111111111111111111111111
```
Stuck on the same thing, how do you generate a provider from a local keypair
hi all, sorry if this has been asked before. Is it possible in a client to use anchor to get values  returned by a function in an on-chain program? ie a simple 'getter function' on-chain that returns a string, then using anchor we get the value of the string? Or do we have to go down the route of writing to an account and reading from the account, as per this post https://discord.com/channels/889577356681945098/889702325231427584/933321451119968256

The only other solution I've found is to use events and simulate the tx which seems a bit too  complex and messy
And that gives me this error

const provider = anchor.Provider.env()
                                 ^

TypeError: Cannot read properties of undefined (reading 'env')
For reference, I am trying to access this in a nodeJS script. So if I wanted to make my own provider from scratch with a connection and a wallet, how would I do it? I tried the following:

const provider = anchor.Provider.env()

Passing in the environment variable to the command line as so:

ANCHOR_WALLET=... ANCHOR_PROVIDER_URL=... node script.js --provider.cluster mainnet
No matter what I do though, I cannot verify the owner of any account to print the system account through web3.  ` console.log(await program.provider.connection.getAccountInfo(provider.wallet.publicKey, 'confirmed'));`  always shows an owner of 0
Ugh.  Here's a big pain that explains a lot. I just realized that the accounts I've been using in my tests aren't full system accounts even though I aidropped to them.  They are owned by Pubkey: 0 not '1111111111'
Hi Guys... I am trying to create a Solana account in which I want to use a struct inside a struct. For example, there is an employee struct with name & age details and now I want to use an array of employees in #[account] of the company that will have other fields also.  I am facing a few problems like the default is not implemented. Any idea how I can do it.
Awh man i already read those, but i can't wrap my head around it because there isn't enough details.

for example, i've seen this crate used in candy_machine `mpl_token_metadata` extensively and the documentation is underwhelming
Well I just learned you can use custom errors with constraints too 🤯
https://project-serum.github.io/anchor/tutorials/tutorial-1.html#defining-a-program
https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html
you'd need to use `anchor.local()` or `anchor.env()`
its not a constructor, you cant user the `new <x>` syntax
I use seeds and bump there to verify the vault_access account passed in is the correct PDA. Look into program derived address's. https://docs.solana.com/developing/programming-model/calling-between-programs#program-derived-addresses
https://paulx.dev/blog/2021/01/14/programming-on-solana-an-introduction/#processor-part-2-pdas-part-2-cpis-part-1
Hey, i'm struggling to understand the Rust program flow,
`#[account]` and `#[derive(Accounts)]` to be specific.

any resources or explanation would be appreciated
what is this error Error: 102: The program could not deserialize the given instruction
Anyone got any ideas ?
The error being :

const provider = new anchor.Provider(solConnection, walletWrapper, {
                 ^

TypeError: anchor.Provider is not a constructor
Trying to run this in order to get some data from an account that was made by my program. But I am getting an error
Also, what would be the maximum amount of pubkey I could store in an account, and what would be the best way to store it there? For example, would I need to loop through and store a small amount in a bunch of small transactions, or would I be able to store it all in one big hit?
Hey there, I'm trying to store Vec<Pubkey> in an account on initialize method. I'm getting the error: "RangeError: encoding overruns Buffer". Can anyone help me out with this?
are there any solana programs that use zero knowledge proofs?
im doing transfers and then close, which seems to be throwing off something in solana
How do I close an account without running into `sum of account balances before and after instruction do not match`
I'd like to ensure that another account does **not** exist and fail the transaction if it does. Can't find a constraint that will do this type of check.
Whats an easy way to create and seed multiple wallets for an `anchor test`
Well I found my bug 😅 

Authority was set wrong in the transaction. Instead of market i should've set it to the pda itself.
```js
    console.log(marketSigner)
    console.log((await mintBase.getAccountInfo(lexBaseVault)).owner)
    console.log(signerBump)
    console.log((await program.account.lexMarket.fetch(lexMarket.publicKey)).signerBump)
```
Verified and owner is what i set and bump is also set correctly. So then what's the problem?
I don't think so.
Market and lexmarket are the same

Pda is program Id | market | signer_bump
(in initialization I set the signer_bump that I generated)

Data passed:
```js
    await program.rpc.withdraw(bobBump, new anchor.BN(10), {
      accounts: {
        owner: bob.publicKey,
        userAccount: bobUserAccount,
        market: lexMarket.publicKey,
        vault: lexBaseVault,
        tokenDest: bobAccountBase,
        priceOracle: stubPriceOracle.publicKey,
        tokenProgram: spl_token.TOKEN_PROGRAM_ID
      },
      signers: [bob]
    })
```
Doesn't seem like you're using the same seed setup between JS and rust (bad)
Looks like the `market`'s seeds are based on `lexMarket`'s key, but in the CPI above you're reusing `market`'s own address, right? `market.key()`
`8Gmnzgn2QbgXVAGHwx4pSAiQfECMdX7P71VUm9cP91Tx's signer privilege escalated`

It's signer I believe. But i don't understand why
Try looking at the full program log—it will tell you whether you forgot to mark an account as mut (both token accounts will need to be mut), or if you're signing incorrectly
I created a normal one but my program gives error:

```rust
    transfer(
        CpiContext::new_with_signer(
            ctx.accounts.token_program.to_account_info(),
            Transfer {
                from: ctx.accounts.vault.to_account_info(),
                to: ctx.accounts.token_dest.to_account_info(),
                authority: ctx.accounts.market.to_account_info(),
            },
            &[&[&ctx.accounts.market.key().to_bytes(), &[market.signer_bump]]]
        ),
        amount,
    )?;
```

and i created the vault like this:
```ts
    [marketSigner, signerBump] = await anchor.web3.PublicKey.findProgramAddress([lexMarket.publicKey.toBuffer()], program.programId)
    lexBaseVault = await mintBase.createAccount(marketSigner); // TODO: Investigate why associated token account didn't work
```

(famous Cross-program invocation with unauthorized signer or writable account)
anyone knows how to create associated token account for an pda owner with spl-token on JS?
what is bump?

how to learn about bump? 

what does those lines mean:

https://github.com/Kriptikz/anchor-token-vault/blob/master/programs/anchor-token-vault/src/lib.rs


why we use "seeds" and "bump" here?


//////////////////////////////////////////////////////////////////////////////////////////

you don't have too do all of the steps you mentioned above when you're testing. You can keep the validator off and just run `anchor test`. this command creates its own local validator, builds the program, deploys to the pre-created validator and runs the test suite
do I have to restart the solana validator after deploying?
thanks ace... did it but am getting the same result
i use the same environment
deploy the program to localnet using `anchor deploy`
btw... am using WSL2 in W11
Im testing on devnet atm, but will prolly deploy to mainnet when its ready
hey guys, new to Solana and Anchor
am trying to run a simple test example and am getting the error following:

--------------
mysolanaapp
Transaction simulation failed: Attempt to load a program that does not exist

    1) Is initialized!


  0 passing (41ms)
  1 failing

  1) mysolanaapp
       Is initialized!:
     Error: failed to send transaction: Transaction simulation failed: Attempt to load a program that does not exist
      at Connection.sendEncodedTransaction (node_modules/@solana/web3.js/lib/index.cjs.js:6634:13)
      at processTicksAndRejections (internal/process/task_queues.js:95:5)
      at async Connection.sendRawTransaction (node_modules/@solana/web3.js/lib/index.cjs.js:6593:20)
      at async sendAndConfirmRawTransaction (node_modules/@solana/web3.js/lib/index.cjs.js:8589:21)
      at async Provider.send (node_modules/@project-serum/anchor/dist/cjs/provider.js:90:22)
      at async Object.rpc [as initialize] (node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:31:31)
      at async Context.<anonymous> (tests/mysolanaapp.js:11:16)


error Command failed with exit code 1.
--------------


In order to get to this I've installed every dependency and I've run:
1. anchor build
2. solana program deploy <PATH>
3. Get the ProgramID and set it into my function
4. anchor test

and the error above is displayed.
Can anyone help me figuring out what's going on?
Thanks
ohhhhh lol now the error makes sense
oh nice, are you doing something on mainnet ?
so, are all program accounts rent-exempt?
So you'll have to pick a new one I'm afraid
If I'm understanding your question right, once you create a program account, you can't really delete it (you can close the accounts that hold the program code, but not the actual account whose address is the program_id)
so, I'll leave that there and wish you luck
yeah, i think so too. But it might be possible that you uploaded the program marking it as non-upgradable and now it wants to "upgrade" it but can't. Take that with a grain of salt tho, I'm past the knowledge stage of debugging and am now in gut-feeling mode
nvm, those are 2 separate instructions
Lol i think that is statically impossible - however, I’ll keep running it. I’ll be back in a couple of hours
https://github.com/solana-labs/solana-program-library/blob/master/token/program/src/processor.rs#L739
Since you never initialized it
That error is saying that the wrapped sol account isn't actually a token account
you are calling sys prgm with token prgm id
Ah, ok, got it
Oh wait maybe I need to initialize the account first
I'm following the solana cookbook: https://solanacookbook.com/references/token.html#wrapped-sol
```
     Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 1: incorrect program id for instruction

Transaction simulation failed: Error processing Instruction 1: incorrect program id for instruction
    Program 11111111111111111111111111111111 invoke [1]
    Program 11111111111111111111111111111111 success
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [1]
    Program log: Instruction: SyncNative
    Program log: Error: IncorrectProgramId
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 783 of 200000 compute units
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA failed: incorrect program id for instruction
    1) Is initialized!
```
Can you print the full error log?
Why are you making a token instruction from scratch like that, rather than using a helper method?
im trying to transfer my lamports into a wSOL TokenAccount
```
let tx = new Transaction().add(
      // trasnfer SOL
      SystemProgram.transfer({
        fromPubkey: alice.publicKey,
        toPubkey: wSolAccount.publicKey,
        lamports: amount,
      }),
      new TransactionInstruction({
        keys: [
          {
            pubkey: wSolAccount.publicKey,
            isSigner: false,
            isWritable: true,
          },
        ],
        data: Buffer.from(new Uint8Array([17])),
        programId: TOKEN_PROGRAM_ID,
      })
    );
```

Anyone know why this is telling me I have the wrong programId?
brutalllll
Unless the lending protocol gives you some help doing that, then yeah, you'd have to do it yourself I guess. Or maybe you could clone some existing accounts from mainnet?
That's how I would imagine you'd need to do things, yeah 😬
I'm having trouble writing tests for my anchor program because it integrates with a lending protocol. I want to write an e2e integration test, but that would require me to create a new mint, new lending market, and two new oracles. Am I doing this wrong? Is there a simpler approach?
And if the mint lives at one of your own derived addresses, then your own program can sign for that address (that's how PDAs work).
Yep, totally fine to do that
I was trying to think of a way to be able to know where a `Mint` account lives only knowing my program ID and a user's pubkey, but I'm not super sure that it makes sense (and what happens when/if I need the mint account to sign a transaction I wonder...)
Is it possible/does it make sense for a `Mint` account to live at a PDA?
just for fun you might check that the program id you are using doesn't exist already, although i don't know if that is possible
it's weird that it runs on devnet but not mainnet
yeah, that's what i meant. I don't think that's your problem since I think you did it right
No, but I did, recreate the deploy/project-keypair.json and copy pasted that address in the Anchor.toml and lib.rs - is that what we’re talking about?
I was but I also go it working. I didn't need to use typescript tho
did you check the program id with `anchor keys list`?
Another question: I just started to deploy my first program on mainnet with anchor, and it failed a couple of times, I closed the accounts and got my sol back. Great! But now I'm trying it again and I got this error :

Using: anchor deploy

`Error: Deploying program failed: Error processing Instruction 1: custom program error: 0x1
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.`

I then tried: solana deploy [key] [project.so]

`Error: Deploying program failed: Error processing Instruction 1: custom program error: 0x1` 

It passes all of the tests on devnet. Any thoughts? Or keep trying?
Yay! Thank you guys, that makes sense!
re 3) you cant get an AccountInfo from a static Pubkey but you can check that an incoming AccountInfo.key == static Pubkey
1. yes i think rent exemption fee is covered in the deployment fee
2. yes a pda needs someone to pay its rent
3. unfortunately i dont think this is possible in the solana model - you would need to pass the accountinfo from the client every time. cant just store a pubkey and send lamports to it bc solana needs to know what accounts are involved in every tx for parallelization reasons i think
Hey <@!134416332509675520>, I'm having troubles writing tests for my anchor program because it integrates with a lending protocol. I want to write an e2e integration test, but that would require me to create a new mint, new lending market, and two new oracles. Am I doing this wrong? Is there a simpler approach?
In the solana docs `Currently, all new accounts are required to be rent-exempt.`  so I'm assuming that means, when I deploy a program or spin up a PDA, the fees associated are it's 2year rent. Can anyone confirm?
Yeah I did in the end, but I had to do it in TypeScript. Were you having a similar issue_
Hi all! new here! 

A couple questions:

1. Does a program need to pay rent? Or is this covered in the deployment fee? (I'm using Anchor)
2. Does a PDA need to pay rent? Or is it exempt from the creation cost? (I'm using Anchor)
3. Is there a way to to send sol to a PubKey statically defined in the rust program? IE every-time lamports are transfered within a function, some are sent to a static address? (I would need a way to derive an AccountInfo from a Pubkey for this to work)
apart from that, i don't think it changes things much
well, you don't have infinite heap either
are there any drawbacks to using the `Box` type? it seems to magically solve my stack problems and i dont trust it lol
ref: https://docs.rs/anchor-lang/0.20.1/anchor_lang/accounts/boxed/index.html
that actually makes more sense, they probably didn't care to make it rent excempt
yeah, ok, wondered if it wasnt rent exempt, or more likely overwitten with null
maybe they 'upgraded' to an empty program? or maybe devnet gets emptied every once in a while
well, I thought not. but from what you are saying it sure seems like it
ok, wasnt specifically confused, more I didnt realise that the program used to be there, but has seemingly gone some time in last 20 days.  Can programs be deleted pls ?
ok, excellent, thank you. Prob more involved (ie setting up all the stuff the program needs), but def worth knowing for my next challenges
so yeah, i think you should be able to deploy it as usual
I've never done it before, but that file should be the compiled binary
you can download from sol explorer, go to the "Executable data" account and you can see the size with a download button
and then write it out to file and then solana deploy ?
?
so would that be connection.getProgramAccount(mainNetAccountId) to get the data
didnt know you could do that
ohhh... v nice !
if you wanna test that program you can try downloading the program data and uploading it to a local net
i checked testnet, and it's not there either
yeah, I think its on testnet. I got confused.... apologies for time wasted
that program doesn't show up on devnet, it does show up on mainnet tho
actually maybe I made a mistake 🙂
lol
9W959DqEETiGZocYWCQPaJ6sBmUzgfxXfqGeTEdp3aQP on devnet (orca program)
check on Solana Explorer, put in the program id you are using and check if it says it's executable
cant find where its thrown from unfortunately
I'm currently trying to find where it throws not executable . Also I'm comfortable calling `invoke` from in the program
yes indeed I did sir - thats where it first complained that its not executable
that or check if the program has a crate or IDL you can include in your project
have you tried accepting the program as an AccountInfo? You'd have to call the instruction manually tho
how much does it cost in SOL to create a new token account?
or alternatively some default program type I  can pass maybe ?
is there a constraint or something I can use to mark the address as executable without using `Program` please ?
I started setting the field to be Program<'info, <type>> - but I dont know what type should be, since its not an anchor program
hi, I'm trying to do CPI to a non anchor program, but getting `Account is not executable` and `instruction expected an executable account`
thanks for answering, I got it
If it is a PDA then you can't change its ownership
if it's not a TokenAccount, then it doesn't have an 'authority' field, unless you give it one
what do you mean custom account?
yeah, I mean set authority for custom account, maybe you know how to do it?
nvm its in the anchor toml file, the location of they wallet keypair
how does anchor deployment work lets say i wanna deploy to a testnet how do i provide a wallet account which will be the payer ?
technically the owner of a token account is always SystemProgram, but the authority is what you probably want to change, it refers to the effective token owner.
Hi, all. For token accounts, there is a method to set authority using token::set_authority, are there some way to set the owner for a custom account?
Account 3augRY5ZUQkhdUqfy4576rehusncZfn7TXN2udbBd1Ek is not an upgradeable program or already in use what am i doing wrong ?
that fixed it, thanks for making me look there
okay... nvm I just don't know how to spell 'prize' correctly, the prize_id I'm passing to the instruction is 'first-price' 🤦‍♂️
```typescript
    const [tokenPDA, bump] =
      await anchor.web3.PublicKey.findProgramAddress(
        [Buffer.from("oyga-giveaway-prize-holder"), Buffer.from(drawId), Buffer.from("first-prize")],
        program.programId
      );
```
how are you deriving the PDA in the client?
I'm not sure I understand what it means
Hey everyone, I have a frustrating error I don't even understand how it's possible. I have an instruction which should create a PDA and an associated token account (for a given mint). The associated token account must be owner by the PDA.

```rust
    #[account(
        init,
        payer = creator,
        associated_token::mint = mint,
        associated_token::authority = creator,
    )]
    pub token_acc: Account<'info, TokenAccount>,

    #[account(
        init,
        payer = creator,
        space = PrizeHolder::get_space(),
        seeds = [
            b"oyga-giveaway-prize-holder",
            draw_id.as_bytes(),
            prize_id.as_bytes(),
        ],
        bump,
    )]
    pub token_holder_pda: Account<'info, TokenHolder>,

    pub mint: Account<'info, Mint>,

    #[account(mut)]
    pub creator: Signer<'info>,
```

This is giving me the following error"
`<PDA>'s signer privilege escalated`
How do i change token decimal to zero
How do i update the anchor cli
The example I'm currently working from, initializes a PDA account for the user then allows them to vote yay or nay. I want to modify this program to accept a custom token as a vote. I've tried looking at a bunch of governance programs at least what I could find and they all seem way too complex for what I'm trying to do. I just want simple atm.
I'm trying to modify a vote program, to require a 1 token = 1 vote but cant seem to wrap my head around the program flow. I'm used to solidity.
Do I have to do these steps every time I change the code in rust? Since after I do anchor build (after changing my rust code), I don't see the new program Id generated, I see the same one as before.
so 
1. anchor build
2. update program ids and declare_id!s (**These two are the same right?)**
3. **anchor build again**
4. anchor deploy?
Step 2 also needs to update the `declare_id!`
Almost—a crucial step you're missing is that you need to *rerun* anchor build before you do `anchor deploy`
I am learning anchor right now, and for deploying a smart contract it seems like the flow is as follows, 
1. anchor build
2. update program ids into the client js side
3. anchor deploy 
4. save the IDL inside the target folder and copy them inside the app folder.
Is this correct?
Sure, go for it!
anyone willing to help me figure a few things out?
Oh nvm its mutable by default
How can I make an account mutable with #[account(init)]? Is it possible?
If rust then a vector should solve this, no?
rust function or js function?
Like I think remaing accounts might solve this but not sure how to use it for this
If they are of the same type
Like not defining the length
Can you pass in an array of accounts to a function ?
Thx
<@!499605357719453736>
`ANCHOR_WALLET="/Users/dg/.config/solana/id.json" ANCHOR_PROVIDER_URL="https://api.devnet.solana.com" ts-node init.ts --provider.cluster devnet`
I got it to work passing in the necessary anchor variables
I think I figured it out
Actually looks like I can simply cast an enum value to a u8
Do you know how I would cast to number? Do I need to implement a method?
Did u get this to work?
+1, I'm trying to do this as well
ah cool, thanks vm
i think the reason behind is that enums in rust could be more complex and have value (for pattern matching). I sometimes stored u8 myself then manually handled it. (you can cast enum to number, but i think reverse doesn't work)
I did it outside useeffect one time and it gave error and now it works! Thanks!
I would also suggest goign through the anchor tests/ directory
I've gone through the Anchor tutorial snippets and did Farza's buildspace course.  Now looking for some more substantial examples or tutorials.  Perhaps with interactions with the SPL and Token library.  Any ideas?
Hi all
I have an enum in my rust like:
```
#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub enum State {
    InActive,
    Active,
    Completed
}
```

And on the JS side I get:
```
{ active: {} }
```
Let me know if an example would help
How do I deserialize enums to something friendly like a number? I get deserialized objects like `state: { active: {} }` thats not really ideal 🤔
Register `onAccountChange` inside a `useEffect` hook and pass `setState` from a `useState` hook to the callback
Anyone knows how we can subscribe change of an account to react hook?
Thank you, for your help 🙂
Yeah
Ah... ok. So, in these cases, it is more like the "first" argument in the Rust def is the same as `self` in a method? Then, in JS the convention is to pass the context (`self`/`this`) as the final argument?
```.js
program.rcp.doSomething(a, b, c, d, {
  accounts: {
    ...
  }
});
```
<@!134416332509675520> Are they always in reverse order? That is, what happens if a method in Rust takes `a, b, c, d` arguments?
They are indeed swapped (it seems weird at first but is in practice much easier to read)
Hello there,
I am a little confused about this in the Anchor API:

It appears the argument positions between the function definition in Rust, and the function call in JS are swapped.
```rust
pub fn method(ctx: Context<MyContext>, arg_2: String) -> ProgramResult {
```
```js
await program.rpc.method("my String", { myContext });
```

Am I missing something? I get an error, when switching the JS arguments to match the Rust def.

_More code can be made available, but this is just coming from the Buildspace Solana, React, Rust Project_
(which does the same)
there's also `account_info.data_len()`  <@!419287884969803776>
Hi all, is it possible to pass a Vec<AccountInfo> or e.g. an array : [AccountInfo; 10] as an argument in a RPC call?
Cheers
Thanks dude 👍


//////////////////////////////////////////////////////////////////////////////////////////

On my react app, I have a keypair for an account my program created that has data. I need that keypair to be static for my site. So I believe I need to hide it.
how can I call a function of a already deployed program? 
Is it done by declaring deployed program's address, like it is done in solidity ?
cool, I'll have a look at those
I think every anchor example + all of the tests/ use JS to interact with the on-chain program, so you can look at those as examples
yes
Not totally sure I understand your question—you mean like using a JS client? That's sending instructions on-chain via the solana rpc infrastructure.
how can we interact with an on-chain program, sending instructions from our off-chain infrastructure?
Hey guys
that was the error. thank you cqfd
```.rs
use anchor_lang::AccountsClose;
account.close(who_to_send_the_lamports_to)?;
```
thanks tho!
ahh hmm sorry im not sure
Good point paul, thanks guys!!! 🦾
XD
I have never written Rust tests. I've written 1000+ lines of Anchor tests. Rust tests look funky to me.
yeah, i know about this. 

what i want is

```rust
if condition_is_met {
  account.close_or_something_like_this();
}
```
like

```
#[account(close = vault, ... )]
pub vault: Account<'info, Vault>
```
you can use the name of the variable
hi guys! how would you close a PDA from within an instruction. Typically, we'd use the 

`#[account(close = account_to_close_to)]`. But i'd like to close an account if a certain condition is met
i guess i will use sudo for now
thats so weird cos running `anchor test` on the anchor tutorial repo works
hmm anchor test still doesnt work despite the folder is now owned by me
Not sure why that happened
Yeah, guess so (or just change the owner without deleting it)
everything else is owned by me
the deploy folder is somehow owned by root, can i delete the folder and retry?
Which keypair are you trying to hide?
Do `ls -hla` and see who owns things
hmmm i simply anchor init, but i will look into it thanks
My guess is that the files in your anchor directory have weird permissions on them

You shouldn't need to—what goes wrong when you try?
any reason why i have to use sudo for `anchor test` to work?
one argument for writing tests in a different language than your program is that a misunderstanding of an aspect of the language of the program cannot propagate to your tests
GM all! Anyone know the best way to hide a keypair in a React App?
Lol, have you tried writing rust tests? Do you like it?
Do whatever your heart tells you 😌
Hey <@!134416332509675520> , good morning 🙂 I've been seeing a lot of people writing their anchor program's tests in Rust... Should I do that instead of writing them in Anchor's TS template?
Yep, all state like that needs to get stored in an account (not directly in a program). So you'd pass the account which keeps track of the `is_checked` state into program B.
Hello, let consider the following scenario:
* Anchor Program A store a state `is_checked` 
* Anchor Program B expose an instruction `transfer_if_is_checked_on_program_A`
Question: 
Is there a way using cpi, to read inside instruction `transfer_if_is_checked_on_program_A` of Program B the state `is_checked` stored in Program A?
Hmm... Perhaps, I committed a repo to github and then checked it out on a different machine. Perhaps I didn't commit the .gitignore -- Thanks!
Hey to do something like combining 3 nfts and creating a new nft, what would the appropriate work flow look like?
Isn’t that already created once you do “anchor init”?
What is the best practice to pass multiple AccountInfo’s to my rust program from client side? I guess I am looking for an alternative of this:

https://github.com/project-serum/anchor/pull/685
anyone got a link to a commit reveal scheme on solana?
trying to set up a svelte frontend and get the following error
```Transaction simulation failed: Attempt to load a program that does not exist ```
Any pointers on where I might be setting this up wrong
```
  const getProgram = () => {
    const program = new Program(
      idl as Idl,
      programID,
      getProvider()
    ) as Program<Anchor>;
    return program;
  };
```
anyone have a .gitignore they'd like to share 🙂 ?
I wanna be able to perform some action everytime a certain account makes a transaction
Is there a way to listen for events on Solana using the anchor js sdk?
awesome, thx <a:ScalebounceHeartRed:870562664412250182>
Or there ^ 🙂
There are lots of examples in the anchor tests/ directory
https://github.com/cqfd/anchor-token-studies
Hey guys. Has anybody stumbled upon any example code (using Anchor) that involves transferring spl tokens? I can see the anchor_spl crate but was unable to find any usage example.
Awesome, thanks for those resources. I think I finally wrapped my mind around accounts/rent, ill try addresses next.
Definitely check out these new intro bootcamp vids, they're very good: https://www.youtube.com/watch?v=O0uhZEfVPt8
You know a large chunk
Once you understand how accounts work (basically: they store data + money and have an owning program, and only that owning program can mutate their data/spend their money) and how addresses work (two main types, regular keypair addresses and program-derived addresses)
makes sense, I'm mainly a JS/Python dev so Rust is veryyyy different
Good news is I think solana's basic programming model is actually very simple, it's just a little hard to see it in the current docs (plus some naming choices are a bit unfortunate/lend themselves to confusion)
Yeah, happy to answer any questions—I actually don't know eth stuff super well, in part because I actually found it easier to get started with solana (probably because I already knew a decent amount of rust)
haha yah thats what i've found so far as well
Coming from solidity and not knowing rust, I feel Solana programming is so much more difficult to learn but exciting when things start working
I'm hoping something comes from all this, I work at Microsoft and got permission to explore web3 tech to see if it can add any value for my division, exciting stuff!
No worries! Way faster to learn this way, it's all good
Yep, you can just go ahead and try to do the transfer—if it fails the whole surrounding tx will roll back
(Im reading through the docs too, I promise, I just find the ecosystem to be less doc-heavy than Solidity and harder to find stuff)
And can I trust that the runtime will throw if the users account doesnt have the balance? Or do I have to explicitly check that it deposited after the transfer?
Ahhhh got it, thats what I was confused about!
(When the user signed the tx they authorized your program to do whatever it wants 🙀)
You would do that transfer directly within your program, by using the system program's `transfer` instruction (from the user's account to your program's account)
Alright that makes sense. 

So say I setup an account the program owns, how could I be sure that the person calling my program function has sent sol to the account?

Does it have to be sent in a separate, previous transaction?
found the error, thanks again. was stuck for an hour
Ok interesting since its the InitializeAccount instruction failing but my constraint is applied somewhere else
Solana doesn't directly have this concept. You'd need to transfer money to an account that the program has control over. This could either be to an account that is *owned* by the program (every account in solana has a program that owns it, and only this owning program can mutate the account's data or spend its money), or you could use an account owned by the system program that lives at a program-derived address derived from your program (a PDA).
I love you
So I think the token part of your program is actually ok, but you have some `constraint = ...` that is failing.
https://github.com/project-serum/anchor/blob/master/lang/src/error.rs#L48
0x7d3 = 2003
Do you know where to find those error codes?
``` #[account(
    init_if_needed, 
    payer = owner,
    seeds = [
      owner.key().as_ref(),
    ],
    bump = owner_reward_bump,
    token::mint = reward_mint,
    token::authority = owner
  )]
  pub owner_reward_token: Account<'info, TokenAccount>,
```

```
Program log: Instruction: InitializeAccount
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 3297 of 184101 compute units
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success
    Program log: Custom program error: 0x7d3
```

Any idea why my TokenAccount is failing to initialize?
That's good to know I'll try set that up again later then
Hi all, does anyone know of a resource/tutorial on how to accept payment to a Solana program function? I'm use to Solidity and just adding a `payable` flag, not sure how I can mark a function as payable and check the amount.
Yea exactly, I used dotenv. But I discovered it also works if u use local env variables
any one knows how to pass remaining accounts to anchor client program?
I figured it out! I needed more sol in my wallet! I had 3 sol in there although it said it would only take ~1.8sol. But I bumped my wallet to 5 sol. Turns out the actual cost of deployment was ~3.6 sol
So I did the following: 

1. wiped the target/deploy/* (The keypair and the .so file)
2. anchor build
3. solana address -k target/deploy/project-keypair.json 
4. copy/pasted that address as the program id in the  lib.rs file and Anchor.toml
5. anchor build
6. anchor deploy

and got the same error:

`Error: Deploying program failed: Error processing Instruction 1: custom program error: 0x1
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.`

Any thoughts? Is there a config I'm missing?
Cool and so to create your provider in the JS code, did you just pass it environment variables and call anchor.Provider.env() or something?
hmm inlining it like so seems to get rid of the issue. super weird but i guess it works
unsure how to get rid of this error. it seems to go away if i remove the if/else statement directly below it.
`token_auth_seeds` is defined as much in some lines above like:
```
let token_auth_seeds = &[b"speedgod".as_ref(), &[pda_token_auth_bump]];
```
Hey guys, we are trying to run anchor test on a persistent local cluster with
`anchor test --skip-deploy --skip-build --skip-local-validator`
and we are getting this error.

We already change anchor.toml and the declare_id of each program to match the .so file under the deploy folder using 
`solana-keygen pubkey <target/path to pubkey>`

What are we missing? Thanks
ps thanks for all the help <:bagsLove:500156064507887618>
Yeh I wanted to make sure account validation logic still ran without repeating the same code in multiple functions.
ok thats very handy, thanks
Can see some details here: https://github.com/solana-labs/solana/blob/master/program-runtime/src/compute_budget.rs#L78
Ah, I guess the advantage is that with an explicit CPI you make sure that the derive(Accounts) logic runs
You can CPI to yourself but in general I'm not sure why you would ever want to—you can just call the other instructions functions (they're just rust functions after all)
For sure that's what I figured
Have to pass them in from the client (always, no getting around this)
No, can't dynamically fetch any accounts within your program
if so any example repos would be clutch
Maybe kind of a weird question but can anchor programs call their own functions within themselves.

If so do they still validate inputs?
Like an invoked_signed cpi to myself?

Is CPI the way to do it or are there any examples of this?

on the same note can I do an equivalent of:
await program.account.data.fetch()
within my own program to get info about its accounts etc???
stuff like that
example: like is there a typical number range of cpi calls i can make in an ix before i run out of juice?
are there any sensible heuristics to reason about the computational load of my instruction logic as i write it out?
Hey, sure
<@134416332509675520> can I pick your brain in private for a moment? If you have time?
You can actually have a full rust expression there, including goofy things like
```.rs
constraint = {
  msg!("Hmm");
  1 + 2 > 0
}
```
Yep—is anything going wrong when you try?
Is it possible to do arithmetic in account constraints? eg `constraint (price * qty) <= user_token_account.amount`
In the YouTube video 'How to Anchor..', Armani has an example program that isn't checked into the anchor repo.  It mints and transfers token inside the smart contract.  Anyone know how i can get hold of that?
we've all been there 😅 .
thank you!
that was the problem ace... probably since I had the validator running there was some sort of collision, now it worked 🙂


//////////////////////////////////////////////////////////////////////////////////////////

thanks a lot!! 😍
ok I found the bug, it was actually in the `Anchor.toml` file, didn't change the program id variable 😅
mm could be, I have now copied the code from the course and still getting the errors
iirc that's the error you get when passing in an account that's not a program into a tx
Doesnt this look more like wrong workspace configuration? `Transaction simulation failed: This program may not be used for executing instructions`
You might be doing some illicit float operations, or using global mutable state, etc. 🙀
Does anybody know what this could be? Thanks! 🙂
```
Deploy success
🚀 Starting test...
Transaction simulation failed: This program may not be used for executing instructions 
    
Error run main:  SendTransactionError: failed to send transaction: Transaction simulation failed: This program may not be used for executing instructions
    at Connection.sendEncodedTransaction (/Users/gonzalo/Desktop/projects/buildspace/solana/myepicproject/node_modules/@solana/web3.js/lib/index.cjs.js:6591:13)
    at processTicksAndRejections (node:internal/process/task_queues:96:5)
    at async Connection.sendRawTransaction (/Users/gonzalo/Desktop/projects/buildspace/solana/myepicproject/node_modules/@solana/web3.js/lib/index.cjs.js:6550:20)
```
Hi! I'm having this error and I don't know how to solve it 😅. I've deployed the program to the devnet and I'm running `anchor test`  and the error is:
thank u
amazing
Then you need only to do what it does at the start, i.e. check that the ix count is 1
yea I think thats exactly what I want to achieve. I want to make sure the transaction only contains the mint_nft instruction . In my case its called something else obviously
perfect thanks!
`solana program deploy --help` gives some info on the `--max-len` option
You can set that when you deploy
Max size for what? Your program's code?
Super dumb question, when you init a new project, how do you set its size? I want the max amount of space to work on my program. I am assuming there is some arguement after anchor init?
Thanks! That was the issue
Also, if you're running `anchor deploy`, it's extremely easy to accidentally deploy a stale version of your `.so` file, so if your declare_id actually does match that id, I would rerun `anchor build` + `anchor deploy` just in case.
Does your `declare_id!` match Ds6fmsR2F2LwjHFEfg6F5LsyW8tcnmM2Ftmy4eDA9QU6?
Hey guys, im triying to run this client.js and I'm getting this error. Any help? 

`anchor.setProvider(anchor.Provider.local());

async function main() {
  const idl = JSON.parse(
    require("fs").readFileSync("./target/idl/fib.json", "utf8")
  );

  const programId = new anchor.web3.PublicKey("Ds6fmsR2F2LwjHFEfg6F5LsyW8tcnmM2Ftmy4eDA9QU6");


  const program = new anchor.Program(idl, programId);

  const fibonacci = anchor.web3.Keypair.generate();
  const tx = await program.rpc.initialize({
    accounts: {
      fibonacci: fibonacci.publicKey,
      user: anchor.Provider.local().wallet.publicKey,
      systemProgram: anchor.web3.SystemProgram.programId,
    },
    signers: [fibonacci],
  });

  let startTime = Date.now();
  while ((Date.now() - startTime) < 6000) {
    await program.rpc.newTerm({
      accounts: {
        fibonacci: fibonacci.publicKey,
      }
    })
  }
}

console.log("Running client.");
main().then(() => console.log("Success")); `
This snippet you pasted seems to be basically whitelisting what **instructions** a caller can bundle alongside that particular `mint_nft` instruction, in the same **transaction**
Are you maybe conflating "accounts in an instruction" and "instructions in a transaction"?
or should i check that each program_id (in this code snippet) == the accountIds passed into the &[AccountInfo]
So if i have a function defined that only takes in a certain number of accounts and want to ensure no other ix data is passed in, can i do something like 
 ```let mut idx = 0;
 let num_instructions = read_u16(&mut idx, &instruction_sysvar)
if (num_instructions > 1) throw err```
```rust
            current = start as usize;
            let num_accounts = read_u16(&mut current, &instruction_sysvar).unwrap();
            current += (num_accounts as usize) * (1 + 32);
            let program_id = read_pubkey(&mut current, &instruction_sysvar).unwrap();
```
this is where the program reads the particular ix's data. In this case the focused on retrieving the program address from the array of accounts passed to the ix
but my question is
that makes a lot of sense, i keep forgetting about this piece
oh amazing
what is `'info` do?
```rust
        for index in 0..num_instructions {
            let mut current = 2 + (index * 2) as usize;
            let start = read_u16(&mut current, &instruction_sysvar).unwrap();
```
this seems t indicate that after the ix count N of the first two bytes, the next `N * 2` bytes in  the byte array store where in the data array you can find the data for that particular ix
```rust
        let mut idx = 0;
        let num_instructions = read_u16(&mut idx, &instruction_sysvar)
```
the initial `2+` is because the first 2 bytes of data are to store how many ixs are in the tx
I put together the mint nft action for the metaplex js sdk. Its what we use for holaplex bulk mint. Though metaplex or holaplex discord prob the best place to talk NFTs 🙂

https://github.com/metaplex-foundation/js/blob/main/src/actions/mintNFT.ts
thanks !! .. that mint-nfts looks promising 🙂
I don't have off-hand recipes for you, but I think you'll probably find all you need around here:
https://github.com/metaplex-foundation/metaplex/blob/master/js/packages/cli/src/cli-nft.ts
https://github.com/metaplex-foundation/metaplex/blob/master/js/packages/cli/src/commands/mint-nft.ts
Getting there but still not getting how to get from the error number to the anchor error.

```
  match context.banks_client.process_transaction(transaction).await {
    Ok(()) => assert!(true),
    Err(TransportError::TransactionError(TransactionError::InstructionError(0, InstructionError::Custom(n)))) => {
      println!( "This is the error code: :{}", n);
    },
    _ => assert!(false),
  }
```

```
[2022-01-03T15:54:38.243466000Z DEBUG solana_runtime::message_processor] Program log: Custom program error: 0xbbf
[2022-01-03T15:54:38.243868000Z DEBUG solana_rbpf::vm] BPF instructions executed (interp): 12306
[2022-01-03T15:54:38.243881000Z DEBUG solana_rbpf::vm] Max frame depth reached: 16
[2022-01-03T15:54:38.243914000Z DEBUG solana_runtime::message_processor] Program 4uQeVj5tqViQh7yWWGStvkEG1Zmhx6uasJtWCJziofM consumed 13488 of 200000 compute units
[2022-01-03T15:54:38.243951000Z DEBUG solana_runtime::message_processor] Program 4uQeVj5tqViQh7yWWGStvkEG1Zmhx6uasJtWCJziofM failed: custom program error: 0xbbf
This is the error code: :3007
test test_create_auction_house_with_native_mint_success ... ok
```

Thanks for the help.
i am just unfamiliar how to link metadata to the token
<@!915682383905316864> do you know where i can find something like what solsea is doing .. i am assuming its all just using JS API
🙂
that is what i am looking for but i am looking for the actual code
yes lol.. i need a code for solsea.io
(I believe there are similar alternatives)
I don't think the candy machine is really what you're looking for anyway, since it is targeted at entire collection drops. Would some interface like this be what you're looking for?
https://solsea.io/create
https://docs.solsea.io/getting-started/faq/nfts-create-mint-list-delist
if not, can anyone tell me where can i ask this ? i just need a simpler contract than candy-machine .. that lets me mint and upload metadata at the right place so wallets can display what i minted
maybe this is the right place to ask.. so from what i understand NFT is just SPL-Token 1 of 1
but how do i make sure my metadata is linked to that token ? 
does anyone know ? i was looking at candy machine its much more than what i need for my purpose.. is there a simpler contract, where i can just upload metadata that Wallets can display and still mint the token ?
ok, thanks, just checked that! 

so basically, the impl would do the same thing as  #[account(constraint = mock_account.to_account_info().owner == program_id)]
If you jump to source on `TokenAccount`, for example, you can see how anchor impls it for 3rd party types
In general `Whatever` has to implement anchor's `Owner` trait. Any account struct you define via `#[account]` automatically impls that with your own program_id (from declare_id!) as its intended owner.
so how does anchor infer who is supposed to own it? if it's inside my context struct, then my program should own it?
Something like that
```.rs
match that_thing {
  Ok(()) => ...,
  Err(InstructionError(idx, Custom(n))) => ...,
  _ => ...
}
```
You don't have to match on each error number, no
Not sure there's any direct way to convert it to the anchor error enum, hmm
Ok thanks. If I do a match do I have to match each enum case? I imagine not but how do I convert `Custom(3007)` to the anchor lang error enum?
Not sure if this is your question, but just don't do that `unwrap()`; you can then `match` on the return value/check it makes sense, etc.
I'm writing some integration tests in rust for an anchor program. How can I parse the transport error into the relevant program error?

```
  let mut transaction = Transaction::new_signed_with_payer(
    &[Instruction::new_with_bytes(
      program_id,
      &data.data(),
      accs.to_account_metas(Some(false)),
    )],
    Some(&payer_key),
    &[&context.payer],
    context.last_blockhash,
  );

  context.banks_client.process_transaction(transaction).await.unwrap();
```

```
[2022-01-03T15:12:56.640265000Z DEBUG solana_runtime::message_processor] Program 11111111111111111111111111111111 success
[2022-01-03T15:12:56.640938000Z DEBUG solana_runtime::message_processor] Program log: Custom program error: 0xbbf
[2022-01-03T15:12:56.641301000Z DEBUG solana_rbpf::vm] BPF instructions executed (interp): 12306
[2022-01-03T15:12:56.641312000Z DEBUG solana_rbpf::vm] Max frame depth reached: 16
[2022-01-03T15:12:56.641335000Z DEBUG solana_runtime::message_processor] Program 4uQeVj5tqViQh7yWWGStvkEG1Zmhx6uasJtWCJziofM consumed 13488 of 200000 compute units
[2022-01-03T15:12:56.641367000Z DEBUG solana_runtime::message_processor] Program 4uQeVj5tqViQh7yWWGStvkEG1Zmhx6uasJtWCJziofM failed: custom program error: 0xbbf
test test_create_auction_house_with_native_mint_success ... FAILED

failures:

---- test_create_auction_house_with_native_mint_success stdout ----
thread 'test_create_auction_house_with_native_mint_success' panicked at 'called `Result::unwrap()` on an `Err` value: TransactionError(InstructionError(0, Custom(3007)))', auction-house/program/tests/lib.rs:95:63
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```
Can check out https://hackmd.io/XP15aqlzSbG8XbGHXmIRhg
Right, that won't work because you are manually decrementing the lamports of the wallet, but your program definitely doesn't own the wallet (it's owned by the system program).
That address is whatever the deployed/runtime program id is (it needs to match, unfortunately). When you run anchor build for the first time (amongst other ways) you get a fresh keypair in target/deploy.
You can use breakpoints in compiled languages too 😛 Just not sure how to do it when your program is running inside a validator, yeah
If that's an anchor type then it might work, but I think the Metadata type isn't, so you'll have to do the analogue of how TokenAccount is implemented
No, Account<'info, Whatever> checks that the owner is whatever is supposed to own Whatevers.
Yea I’m talking about this Found this in another post. bingo.

https://github.com/katopz/hello-rust-debug/blob/main/programs/debug_anchor/src/lib.rs#L72
is using the Account<> struct suffice for checking the program id of a program account, or do I have to be extra specific and add a constraint to verify the program id ?
Although you'll often see directly:
```rust
let (escrow_account_address, _) = Pubkey::find_program_address(&[b"escrow".as_ref()], &program_id);
```
unless you somehow use it several places
It stores the string "escrow" as a byte array, generally for use in the function deriving a PDA from it like so:

```rust
const ESCROW_PDA_SEED: &[u8] = b"escrow"; 
let (escrow_account_address, _) = Pubkey::find_program_address(&[ESCROW_PDA_SEED], &program_id);
```
hey, beginner question on anchor+rust,
`const ESCROW_PDA_SEED: &[u8] = b"escrow"; `
what is this doing?? can some one please explain.
thank you <@!915682383905316864> <:pepestar:884557572949032980>
it worked! but instead i used `program.transaction.increment()`, much easier to manage i think
if i wanted to use a metaplex metadata account in an instruction, would the correct way to do it be just importing the metaplex-token-metadata program, import the Metadata struct and use `Account<'info, Metadata>` in the accounts context struct of the instruction where im using it? or am i missing some steps somewhere here?
`program.instruction.increment()`
hello, beginner with anchor here. jsut wanted to ask if anyone has an idea on how i could extract the transaction itself from an rpc call like `program.rpc.increment()`? context is that i want to bundle three anchor rpc calls into one approval via phantom's `signAllTransactions()` method
i think you're right. giving the method a gander.
create token account for user -> deposit amount in it -> transfer ownership to PDA -> later have the program send amount back to user, or something like that
wouldn't that follow the same concept as the escrow program, apart from the fact that the withdraw part would for the the depositor instead of a second party?
it would require a signer for the program's wallet, which the client couldnt do. was their usdc address a pda? and if so how do i set up a pda as a token account for a specific mint i dont own
for mango markets and uxd's ido, they allowed for USDC deposit and withdrawal. the depositing part is straightforward, but how did they automate withdrawals?
hi guys, i'm curious to a pattern i've seen in popular dapps.

When a user wants to pick a username for the dapp, they dapps typically have the user sign a message with a nonce or sometimes the contents of the username.

I'm curious, why is it done like this?
Well In the solana_program
There is a log function in anchor though
Sir this is a compiled language
ok thanks!
I think it would have to be of the same format. If you directly look into the json file at that location it should look like an array of numbers. I believe you can change them and it would still work as long as you don't change the format. The program id is just supposed to be a unique identifier.
ok, is there a way for me to customizer that address?
When you use anchor build keypairs for your programs get generated in the target/deploy folder as json files. These can be accessed like ```solana address -k target/deploy/program_name.json``` They will not exist on chain until you have deployed the program with the labels in your lib and toml.
Has anyone got this error before when using the wallet adapter in a react app? ```./node_modules/@solana/wallet-adapter-base/lib/esm/signer.js 16:16
Module parse failed: Unexpected token (16:16)
File was processed with these loaders:
 * ./node_modules/babel-loader/lib/index.js
You may need an additional loader to handle the result of these loaders.
|           ...sendOptions
|         } = options;
>         signers?.length && transaction.partialSign(...signers);
|         transaction = await this.signTransaction(transaction);
|         const rawTransaction = transaction.serialize();
```
well they are two different programs so they would have different IDs, but how did they get those IDs?
where does anchor get `declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");` from and in the tutorial, why does the puppet master program use a different id? `declare_id!("HmbTLCmaGvZhKnn1Zfa1JVnp7vkMV4DYVxPLWBVoN65L");`
is there any reason this shouldn't work?

client 
```
const transaction = new Transaction({feePayer: wallet.publicKey});
const instruction = new TransactionInstruction({
  keys: [
    {pubkey:wallet.publicKey, isSigner:true, isWritable:true},
    {pubkey:housePubkey, isSigner:false, isWritable:false}
  ],
  programId: programId,
});

transaction.add(instruction);
transaction.recentBlockhash = (await connection.getRecentBlockhash()).blockhash;

await wallet.signTransaction(transaction);

const transactionHash = await sendAndConfirmRawTransaction(
  connection,
  transaction.serialize(),

);
```
program:
```
use solana_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint::ProgramResult,
    pubkey::Pubkey,
};

pub fn process_instruction(
    _program_id: &Pubkey,
    accounts: &[AccountInfo],
    _instruction_data: &[u8],
) -> ProgramResult {

    let account_info_iter = &mut accounts.iter();

    let source_info = next_account_info(account_info_iter)?;
    let destination_info = next_account_info(account_info_iter)?;

    **source_info.try_borrow_mut_lamports()? -= 5;
    **destination_info.try_borrow_mut_lamports()? += 5;

    Ok(())
}
```

getting this error
```
Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: instruction spent from the balance of an account it does not own
```
Wait…how do you debug anchor code with breakpoints lol
Found this in another post. bingo.

https://github.com/katopz/hello-rust-debug/blob/main/programs/debug_anchor/src/lib.rs#L72
Yes, I think that's it
was just about to write, the best thing I found was the "clone" option, is that what you mean?
I think there's a way to initialize the solana-test-validator with a preexisting history but that's pretty much the limit of my knowledge there.
was trying to setup a gitrepo with a clean example but getting errors linked to maybe what you were implying (that it's not supposed to work). I'll look into it a little more. Any advise on testing with CPI on programs that exist in devnet/mainnet (and not localnet)? Would the best way just be to deploy temp program to devnet with anchor and test as such? Seems a little excessive. Would be great to "fork" devnet/mainnet locally. Is that at all possible?
How are you building your `provider`?
No, won't work like that
How do you test a program that you import from a crate? I'm doing a CPI call to a program on devnet/mainnet and using their crate. I need to interact with that program as a client before testing my program. Is there a good way to locally deploy programs that are dependencies?
... not sure.. I imagined it just used my local source code for the program and retreived the accounts from devnet :S
I'm confused how you're talking to your program at all though if you didn't deploy it to devnet
the vanilla "initialize" test works fine AND ```account_a: UncheckedAccount<'info>,``` works fine
Full error:

```bash
 Is merged!: <<<< THIS IS JUST MY TEST NAME
     Error: 167: The given account is not owned by the executing program
      at Function.parse (node_modules/@project-serum/anchor/src/error.ts:41:14)
      at Object.rpc [as merge] (node_modules/@project-serum/anchor/src/program/namespace/rpc.ts:28:42)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)

```
sure, one sec
Can you post the full thing?
But what actual error do you get?
using ```const program = anchor.workspace.Foo as Program<Foo>;``` 😛
I wouldn't expect that to work at all lol
Mm, how are you talking to your program at all then? 🤔
nope but I am using a devnet connection as such, does that not suffice?

```javascript
 const connection = new anchor.web3.Connection(
    "https://api.devnet.solana.com",
    "confirmed"
  )
  const opts = anchor.Provider.defaultOptions();
  let wallet = new Wallet(Keypair.generate());
  anchor.setProvider(
    new Provider(
      connection,
      wallet,
      opts
    )
  );
```
Are you actually deploying your program to devnet? That token won't exist in your local validator
Ok, so I would have expected this to work now but still not working. Found a random token on devnet (https://solscan.io/token/Bhv8Dfw8rqNpgbTiL33fFUMtqJJGbdiBDGjrcmXpVkzG?cluster=devnet) that is owned by the `Token Program` (see solscan link).  So, what am I missing here :S ?

```rust

pub fn merge(ctx: Context<Merge>) -> ProgramResult {
    Ok(())
}

#[derive(Accounts)]
pub struct Merge<'info> {
    account_a: Account<'info, TokenAccount>,
}
```

```javascript
    const tx2 = await program.rpc.merge({
      accounts: {
        accountA: new PublicKey("Bhv8Dfw8rqNpgbTiL33fFUMtqJJGbdiBDGjrcmXpVkzG")
      },
    })
```
Ok cool, think I understand. Thanks yet again <@!134416332509675520> !
Oh, sorry, I guess you meant that
Whatever here isn't a program, it's a struct that implements anchor's Owner trait (which just says, "who should own me?")
ok thank you.. I think I "kinda" understand.. Trying to wrap my head around it still haha. Think how I understand it is that the passed in "pub key" is an account owned by the "Whatever" Program. So like you said, TokenAccount should be an account owned by the spl token program.
everything works great now, thanks Gs
or is that hilariously silly of me to say
in the json
can I just remove the chai text too lol
okay
I think there might be a separate way to tell ts about chai, can't remember—think it's googleable though
while you are here, i have an error in my tsconfig.json where it says cannot find destination file for 'chai', but I have chai installed, can I do `// @ts-ignore` here too?
In your case, you're apparently not passing in an initialized token account
thank you ser
So, for example, `Account<'info, OneOfYourAccounts>` verifies the the owning program matches your declare_id! (so double check it actually matches the runtime program id). Account<'info, TokenAccount> checks the account is owned by the spl token program, etc.
Any time you use `Account<'info, Whatever>` in anchor, anchor verifies that the incoming account belongs to whatever program is supposed to own Whatevers.
^ chad Alan to the rescue
okay
I think this is a current typing bug, just add a `// @ts-ignore` comment to the line above it :/
D:
weird... maybe try remove node_modules and do an "npm i" again? not sure bud :S
rest of the file is good, its under /tests/ folder
Property 'workspace' does not exist on type 'typeof import("/home/sal/Code/foo/node_modules/@project-serum/anchor/dist/cjs/index")
property workspace does not exist
what does the error say?
but a red line under workspace
yes
it is
looks good. Try a capital foo (if it isnt already?)

```const program = anchor.workspace.Foo as Program<Foo>; ```
my command to configure in describe is 

`const program = anchor.workspace.Foo as Program<Foo>;`
yes I Have that
yea actually, sorry, there is one more import (missed out in my copy paste):

```import { Foo } from '../target/types/foo';```

and your project structure would be (on the rust side)

programs/foo/src/lib.rs

and then your program something like:

```#[program]
pub mod foo {```
Is there an anchor.workspace in that default file under describe
Yes
Is this for your test .ts file
Think ethereum needs a contracts abi to interact with it (analogous to idl)
Check it for what exactly? I also thought one of the pros/cons of sealevel was anyone could pass in any account to any program (the program itself had to check it however). So, yea, a little confused still as to why I can't check it.

Regarding you question, I haven't had an error but im using a vanilla `anchor init` project. Here are my 'relevant' imports for your ref:

```javascript
import * as anchor from '@project-serum/anchor';
import { Program, Provider, Wallet } from '@project-serum/anchor';
import { PublicKey, Keypair } from "@solana/web3.js";
```
have you had an error with using anchor.workspace command to configure your program when testing in typescript?
check your current wallet maybe
Could someone help explain the following error? Why would a given account need to be owned by the executing program if it's not being  mutated in that program

```Error: 167: The given account is not owned by the executing program
```

Context:
lib.rs
```rust
pub fn merge(ctx: Context<Merge>) -> ProgramResult {
    Ok(())
}

#[derive(Accounts)]
pub struct Merge<'info> {
    account_a: Account<'info, TokenAccount>,
    account_b: UncheckedAccount<'info>,
}
```

anchor test:
```javascript
    const tx2 = await program.rpc.merge({
      accounts: {
        accountA: accountA,
        accountB: accountB,
      },
    })
```
nothing else under anchor has a problem, maybe need to import something else?
anyone have an error with the anchor.workspace command in their .ts files under /test?
is there a way to interact with solana programs without an IDL?
something like interfaces like in solidity?
I guess im a little confused why this starts here ```let mut current = 2 + (index * 2) as usize;```
My interpretation is that its getting all the instructions that were passed in, and checking for any it doesnt recognize. But how can u pass multiple instructions? Basically I want to do something similar, where I just want to check that only the instruction i recognize is being passed in
https://github.com/metaplex-foundation/metaplex/blob/master/rust/nft-candy-machine-v2/src/lib.rs
can someone explain what this is doing? 
``` let mut idx = 0;
        let num_instructions = read_u16(&mut idx, &instruction_sysvar)
            .map_err(|_| ProgramError::InvalidAccountData)?;

        let associated_token =
            Pubkey::from_str("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL").unwrap();

        for index in 0..num_instructions {
            let mut current = 2 + (index * 2) as usize;
            let start = read_u16(&mut current, &instruction_sysvar).unwrap();

            current = start as usize;
            let num_accounts = read_u16(&mut current, &instruction_sysvar).unwrap();
            current += (num_accounts as usize) * (1 + 32);
            let program_id = read_pubkey(&mut current, &instruction_sysvar).unwrap();

            if program_id != nft_candy_machine_v2::id()
                && program_id != spl_token::id()
                && program_id != anchor_lang::solana_program::system_program::ID
                && program_id != associated_token
            {
                msg!("Transaction had ix with program id {}", program_id);
                return Err(ErrorCode::SuspiciousTransaction.into());
            }
        }


```
Ok just some rubber ducking there hehe, problem solved 🦆
Oh maybe I need to use BN
On the other side I have:

```
        seeds = [
            b"edition".as_ref(),
            master_edition_account.key().as_ref(),
            &[master_edition_account.supply as u8].as_ref()
        ],
```
Following up on this from yesterday - would this be the correct way to do this on the JS side?
```
await anchor.web3.PublicKey.findProgramAddress(
        [
          Buffer.from("edition"),
          masterEditionAccount.toBuffer(),
          Buffer.from(masterEditionState.supply.toString()),
        ],
        program.programId
 );
```
if this is what you mean then here
```
import React, { useCallback, useEffect, useState } from 'react'

import { useConnection, useWallet } from '@solana/wallet-adapter-react';
import { Transaction, TransactionInstruction, sendAndConfirmTransaction, PublicKey } from '@solana/web3.js';


const Play = (props) => {

    const { connection } = useConnection();
    
    const wallet = useWallet();
    const housePubkey = new PublicKey('FN9ghw16B6R1SLd6bYXUFrCVgcSG87Ny9mfcTkT16ugC');
    const programId = new PublicKey('Hx6xhwfRwRydjc1P2n4krVwJzyGZzEpdwyFHazYVuniW');

    const callback = useCallback(async () => {

        if (!wallet.publicKey) {
            alert('error', 'Wallet not connected!');
            return;
        };

        const transaction = new Transaction({feePayer: wallet.publicKey});

        const instruction = new TransactionInstruction({
          keys: [{pubkey:wallet.publicKey, isSigner:true, isWritable:true}, {pubkey:housePubkey, isSigner:false, isWritable:false }],
          programId: programId,
        });

        transaction.add(instruction);
        transaction.recentBlockhash = (await connection.getRecentBlockhash()).blockhash;

        await wallet.signTransaction(transaction, connection);
        const transactionHash = await sendAndConfirmTransaction(
          connection,
          transaction,
          []
        );
        alert(transactionHash);

    }, [wallet, connection]);

    return (
        <button onClick={callback}>send</button>
    )
}

export default Play;
```
nah not currently. I gotta run to dinner but I'll debug some more after
Do you have your code on github?
The part that's currently failing (I can't quite tell what you've got there now)
the whole script for the component?
Can you print the current code you're using?
Yeah I'm always trying to convince myself to switch aha.

its now saying no signers, I presume its expecting me to pass the signer in the sendAndConfirmTransactions
This is way easier by the way if you use typescript lol, catches a lot of these types of errors
Maybe don't do the .serialize() part, just pass the tx itself
Hmm, now getting this, would I need to sign it some other way maybe?
```Uncaught (in promise) TypeError: transaction.sign is not a function```
`[class Token]`
https://github.com/solana-labs/solana-program-library/blob/master/token/js/client/token.js#L384
If you just console log `spl.Token` at runtime, what do you get?
Think you're missing an argument to sendAndConfirmTransaction (pass an extra empty array)
bump 🙂 still can't figure this out, seems incorrect
Just tried in a chrome instead of firefox and seeing this error before
```Uncaught (in promise) TypeError: signers is not iterable (cannot read property undefined)```
`process` is a node thing, so something in your code/your build process etc. thinks it's node, not the browser
Mm, I don't think that would lead to that error either, can you post the stack trace?
using solana wallet adapter
this is how I instantiate the wallet 
```
import { useConnection, useWallet } from '@solana/wallet-adapter-react';
import { Transaction, TransactionInstruction, sendAndConfirmTransaction, PublicKey } from '@solana/web3.js';

const { connection } = useConnection();
const wallet = useWallet();
const housePubkey = new PublicKey('XXXX');
const programId = new PublicKey('XXXX');
```
How did you instantiate the wallet, for example?
Please spoon feed us all
And no, I think it's a JS error, not in your rust code
Is that all of it?
How are you setting up the rest of the code?
You think its coming from the program itself?
I doubt that error is coming from that specific chunk of code
sorry for another question, not trying to get spoon fed.
what am I doing wrong here?
```
const transaction = new Transaction({feePayer: wallet.publicKey});

const instruction = new TransactionInstruction({
    keys: [{pubkey:wallet.publicKey, isSigner:true, isWritable:true},{pubkey:housePubkey, isSigner:false, isWritable:false }],
          programId: programId,
});

transaction.add(instruction);
transaction.recentBlockhash = (await connection.getRecentBlockhash()).blockhash;

await wallet.signTransaction(transaction, connection);
const transactionHash = await sendAndConfirmTransaction(connection, transaction.serialize());
alert(transactionHash);
```
getting this error
```Uncaught ReferenceError: process is not defined```
There are lots of examples if you search the anchor codebase
Does anyone know of any code examples of CPI with  `new_with_signer`? Trying to work out how to pass the `signer_seeds`
Using borsh, 4 bytes for the length + N * however much space borsh takes for each element
anyone know the initial space requirement for a vector (e.g. X + 32*(number of pubkeys stored))? new to rust and couldnt find a good answer
Thanks <@!134416332509675520>
It removes a significant portion of attackers . The quality ones will go for bigger targets 😆
Yeah but hardship helps
Mangling plus striping will make life a pain🤣
But I don't think this is a great security path for anything important
I don't know (and yeah, it's definitely not trivial to decompile stuff)
It's probably not super safe (maybe fairly safe, but certainly not super super safe)
Decompile shared object is a pain, does anchor support symbol striping ?
Also remember that your instructions in general expose a decent amount of information about what they'll do, since you have to submit *all* accounts in from the client
Someone in principle could download your source code and if they really wanted to, decompile it, etc.
🤣🤦‍♂️
No but
No!!!
But!
Ok
Ahhh
Only the external `do_something`
Yeah the problem is that it doesn’t run anything. So I’m asking, does it give interface instructions or internal ones ?
It just returns a little data structure that you could add into a transaction, asking your program to `do_something`
It doesn't run anything
I think you're confused about what `program.instruction.doSomething` returns
The if admin, is runtime check right? But the branch of not admin will return too if I ask for instructions only
It's a little data structure you can use to ask your program to `do_something`
`program.instruction` is just for your `pub fn do_something` instructions
Returning instructions including all branches?
Mm, sorry, I'm not really following what you mean 🤔
What about CPI? Will that show in instructions?
A program returning instructions set including all branches
Generally what you guard with admin-ness is mutations
What do you mean?
Lol, isn’t this like core solana ?
You'll have to find some other way to do things
Ok then that's bad 😛
I mean a smart attacker can read the instructions and understand what the result will be even if their not admin
It shows info only admin should have
Since if the instructions say “if not admin , error” but contain the rest
It does
But hopefully you're checking admin-ness correctly, so it doesn't matter (right?)
Mm, still not following where this is going—that will let them see/construct available instructions, yes
Not program.rpc
program.instruction
What do you mean by ask for instructions?
Will it include the branch that has the results for the admin?
But what if I just ask the program for instructions?
So if I try to run it, it will error
Let’s say I want to have one entrypoint for “admin” and I put the seeds/id restrictions to enforce it
Can you say more? Not sure what you mean. You always have to guard against the possibility of a client doing weird stuff.
Let’s say I limit a program endpoint to a specific account but someone is using the program and Idl and get the instructions set: will they be able to predict the result ?
Hey I'm referencing a few different anchor test file examples that all do the following:
```
import * as spl from '@solana/spl-token';
...
exampleMint = await spl.Token.createMint(program.provider.connection,
      wallet.payer,
      wallet.publicKey,
      wallet.publicKey,
      0,
      spl.TOKEN_PROGRAM_ID);
```
but when I attempt to use it I get ```  1) anchor-test
       "before all" hook for "Is initialized!":
     TypeError: spl.Token.createMint is not a function```
Any ideas why that'd be? I've got the same dependencies for `@solana/spl-token` as these examples
All good!
thankyou, sorry if that was a very noob question.
Oh right, so I can just simply use the account that was connected via a wallet? and not need to create one to interact with the program?
The source account will need to exist (since it needs to have some lamports), but the receiving account doesn't need to exist yet
I'm trying to make a program based off the transfer-lamports example from solana program library on github.

do I need to create accounts for the receiver/sender on the client side?
Sure. Might depend on what you mean/what you're trying to do
partially javascript
is it possible to create an account on the client side?
thank you!
yes i just wanted to confirm since when i type anchor init --help theres a flag for js but not ts
Typescript (have you tried running it?)
Now I'm getting Fallback Functions are not supported
I changed it to anchor.workspace.Mycalculatordapp
How do I select the Workspace
when i type `anchor init` does it default to javascript or typescript?


//////////////////////////////////////////////////////////////////////////////////////////

```loki:~ Loki$ solana-test-validator
--faucet-sol argument ignored, ledger already exists
Ledger location: test-ledger
Log: test-ledger/validator.log
⠴ Initializing...
Identity: BgxTwrAaQg2iNu29vxozFCZkNKpANLubBsgpK892eZ1F
Genesis Hash: 2uZLUtvTUABvsLr29HjjWMr3FYVYAPGyscjYBY1cMd54
Version: 1.9.5
Shred Version: 57039
Gossip Address: 127.0.0.1:1024
TPU Address: 127.0.0.1:1027
JSON RPC URL: http://127.0.0.1:8899
⠒ 00:00:56 | Processed Slot: 3079 | Confirmed Slot: 3078 | Finalized Slot: 3047```
I restarted my solana-test-validator as well
on the command line
maybe im doing this wrong?
`ANCHOR_WALLET="SolanaWallet/my-keypair.json" node client.js `
yes
I'm trying to make an Account like:
```
#[account]
pub Protocols {
   solend: Solend
   larix: Larix
   ...
}
```

I want each protocol to implement the same traits (e.g. all implement `deposit()` but have different implementations and parameters).

I want to be able to just do something like `protocol.deposit()` and it would call the relevant protocol

I'm not sure how to structure my data, though
So basically the `instructions: []` parameter client side runs those first and passes the data into my program
Thanks a million man!
I was just looking that up! the 300 is the size override! Hooray!
It's talking directly to the system program, not your program
Ah, ok. Might help to see the source for `createInstruction`: https://github.com/project-serum/anchor/blob/master/ts/src/program/namespace/account.ts#L284
Unless the `createInstruction(check, 300)` is actually creating the account? and the 300 is the space
Right, but I'm not sure where the space for the struct is allocated?

The `createInstruction(check, 300)`, I assume this is calling the `pub fn accounts(ctx: &Context<CreateCheck>, nonce: u8)`

It would know now how big the check struct is because everything is static, how much space the Vec would need say if I had a Vec<Pubkey> and needed it to hold say 40
Ah, yeah ^
In the JS file I image that first instruction is 

```
      instructions: [
        await program.account.check.createInstruction(check, 300),
        ...(await serumCmn.createTokenAccountInstrs(
          program.provider,
          vault.publicKey,
          mint,
          checkSigner
        )),
      ],
```
Why are you trying to use `account(zero)`?
No, I mean you're apparently going to use a separate instruction from the client
Is this the previous instruction?  The impl?
```
#[derive(Accounts)]
pub struct CreateCheck<'info> {
    // Check being created.
    #[account(zero)]
    check: Account<'info, Check>,
    // Check's token vault.
    #[account(mut, constraint = &vault.owner == check_signer.key)]
    vault: Account<'info, TokenAccount>,
    // Program derived address for the check.
    check_signer: AccountInfo<'info>,
    // Token account the check is made from.
    #[account(mut, has_one = owner)]
    from: Account<'info, TokenAccount>,
    // Token account the check is made to.
    #[account(constraint = from.mint == to.mint)]
    to: Account<'info, TokenAccount>,
    // Owner of the `from` token account.
    owner: AccountInfo<'info>,
    token_program: AccountInfo<'info>,
}

impl<'info> CreateCheck<'info> {
    pub fn accounts(ctx: &Context<CreateCheck>, nonce: u8) -> Result<()> {
        let signer = Pubkey::create_program_address(
            &[ctx.accounts.check.to_account_info().key.as_ref(), &[nonce]],
            ctx.program_id,
        )
        .map_err(|_| ErrorCode::InvalidCheckNonce)?;
        if &signer != ctx.accounts.check_signer.to_account_info().key {
            return Err(ErrorCode::InvalidCheckSigner.into());
        }
        Ok(())
    }
}
```
Yeah, sounds like you're planning on doing that in a prior, totally separate instruction (that's what account(zero) is for)
So you don't need to do `space =` at all (you've already allocated the space, in that previous instruction)
I guess it's a a disconnect. I assumed the size of an account needs to be initialized so it can be rent exempt
If this is account(zero) then you'd be creating the account (allocating its space) in a previous instruction
Not sure how to answer that—why does it matter where the space is allocated?
Not totally sure what you're asking about in terms of where the space is allocated—can you say more?
Pubkeys take up 32 bytes
Why 40 times KEYCOUNT?
I'm basically modifying the Cashier's check program, but need enough space for KEY_COUNT PubKeys. I don't see how that is init'd where the space is allocated.
So normally I'd use the `[account(init, payer = owner, space = 40*KEYCOUNT]` however the program I'm working on has to have the `[account(zero)]` in it and I'm not sure where the space is actually allocated
How much space does each pubkey take?
What have you tried so far?
About your null point, indeed, if you use a static array, each element will be all zeros
How would I do that? Say I wanted a Vec<Pubkey> and I needed space for 100
You would need to decide how much space is "enough". Borsh serializes a Vec<Foo> as 4 bytes for the length, and then serializes each Foo one after the other.
You can use static arrays, yes (annoyingly though, some lengths don't work for annoying borsh reasons)
Actually - I think I know why, there is no 'null' in rust. So a static array would have to have initialized data.  Second question, if I were to use a Vec, how would I reserve enough space for them out of the gate? I can't seem to use `[account(init, payer = owner, space = 40]` in a setup like the Cashiers Check example.
Is it possible to have static length arrays in a data account? 

length 1 works, but some others throw an error, thoughts?
```
#[account]
pub struct TreasureChest {
    pub nonce: u8,
    pub coach: Pubkey,
    pub lamports: u64,

    pub vaults: [Pubkey; 1], //bk k0 k1 k2 tc rt ac
    pub counts: [u64;    1],

    pub bomb: u64,

    pub hunters: [Pubkey; 1],
    pub winners: [Pubkey; 1],
}
```
Are you running your local `solana-test-validator`?
Would anyone know why I'm having this issue whenever i run the client.js on the basic_0 tutorial?
```bash
loki:basic-0 Loki$ ANCHOR_WALLET='SolanaWallet/my-keypair.json' node client.js 
Running client.
/Users/Loki/code/src/github.com/anchor/examples/tutorial/node_modules/@solana/web3.js/lib/index.cjs.js:5965
      throw new Error('failed to get recent blockhash: ' + e);
            ^

Error: failed to get recent blockhash: FetchError: request to http://localhost:8899/ failed, reason: connect ECONNREFUSED ::1:8899
    at Connection.getRecentBlockhash (/Users/Loki/code/src/github.com/anchor/examples/tutorial/node_modules/@solana/web3.js/lib/index.cjs.js:5965:13)
    at processTicksAndRejections (node:internal/process/task_queues:96:5)
    at async Provider.send (/Users/Loki/code/src/github.com/anchor/examples/tutorial/node_modules/@project-serum/anchor/dist/cjs/provider.js:82:31)
    at async Object.rpc [as initialize] (/Users/Loki/code/src/github.com/anchor/examples/tutorial/node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:31:31)
    at async main (/Users/Loki/code/src/github.com/anchor/examples/tutorial/basic-0/client.js:26:5)

Node.js v17.4.0
loki:basic-0 Loki$ ANCHOR_WALLET="SolanaWallet/my-keypair.json" node client.js 
Running client.
/Users/Loki/code/src/github.com/anchor/examples/tutorial/node_modules/@solana/web3.js/lib/index.cjs.js:5965
      throw new Error('failed to get recent blockhash: ' + e);
            ^

Error: failed to get recent blockhash: FetchError: request to http://localhost:8899/ failed, reason: connect ECONNREFUSED ::1:8899
    at Connection.getRecentBlockhash (/Users/Loki/code/src/github.com/anchor/examples/tutorial/node_modules/@solana/web3.js/lib/index.cjs.js:5965:13)
    at processTicksAndRejections (node:internal/process/task_queues:96:5)
    at async Provider.send (/Users/Loki/code/src/github.com/anchor/examples/tutorial/node_modules/@project-serum/anchor/dist/cjs/provider.js:82:31)
    at async Object.rpc [as initialize] (/Users/Loki/code/src/github.com/anchor/examples/tutorial/node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:31:31)
    at async main (/Users/Loki/code/src/github.com/anchor/examples/tutorial/basic-0/client.js:26:5)

Node.js v17.4.0
```
This is an example that answers the question: https://github.com/samuelvanderwaal/solana-whitelist/blob/main/programs/whitelist/src/lib.rs
Hey! The standard way of creating accounts with Anchor is via CPI, e.g.:
```#[derive(Accounts)]
pub struct SaveData<'info> {
    #[account(init, payer = sender,```
However, I need to create an account with a direct call to the system program to get around the size limitation of 10KB. How do I that?
i'm a beginner, I just saw a function taking enum as argument, I thought that was what you need. sorry, i provided a wrong info
no worries! I'll just use u8 instead of enum 👍
sorry.
Hey! I'm reading through the cashiers check example from the github. I have a question, where does the space get allocated?

I am used to the `#[account(init, payer = owner, space=40)]` where, in the following do they reserve the space for the Check struct?  What happens if the check struct has a variable length?

```
#[derive(Accounts)]
pub struct CreateCheck<'info> {
    // Check being created.
    #[account(zero)]
    check: Account<'info, Check>,
    // Check's token vault.
    #[account(mut, constraint = &vault.owner == check_signer.key)]
    vault: Account<'info, TokenAccount>,
    // Program derived address for the check.
    check_signer: AccountInfo<'info>,
    // Token account the check is made from.
    #[account(mut, has_one = owner)]
    from: Account<'info, TokenAccount>,
    // Token account the check is made to.
    #[account(constraint = from.mint == to.mint)]
    to: Account<'info, TokenAccount>,
    // Owner of the `from` token account.
    owner: AccountInfo<'info>,
    token_program: AccountInfo<'info>,
}

impl<'info> CreateCheck<'info> {
    pub fn accounts(ctx: &Context<CreateCheck>, nonce: u8) -> Result<()> {
        let signer = Pubkey::create_program_address(
            &[ctx.accounts.check.to_account_info().key.as_ref(), &[nonce]],
            ctx.program_id,
        )
        .map_err(|_| ErrorCode::InvalidCheckNonce)?;
        if &signer != ctx.accounts.check_signer.to_account_info().key {
            return Err(ErrorCode::InvalidCheckSigner.into());
        }
        Ok(())
    }
}
```
In this tutorial, it looks like they're not assigning the enum to the actual state of their Account
create your personal token with rust smart contract.
Thanks! Which one is it? There are 10+
Basically you can't—this is why solana has "program-derived addresses", as a way for programs to sign for an address in a secure way
you need to do a CPI via a PDA within a program
How can I load a keypair inside the program to make transactions from it?
You can coerce an enum variant as an integer, and that integer is typically what's stored on the account
there is a tutorial in startonsolana.com. you can check it.
index
How do I store an enum value into my Account 😦
also which version of anchor are u using
convert it to decimal and look in the appropriate repo. Have you defined your own error codes?
how do we decode custom errors? e.g. `0x12d`
How do I pass in my enum from the client side through the context of an anchor program?
screenshot from tutorial I'm currently working through
https://app.buildspace.so/projects/CObd6d35ce-3394-4bd8-977e-cbee82ae07a3
What are the remaining option to reduce stack overflow when all accounts are already boxxed/accountInfo? (currently using 31 of them, + a u64 and u32 parameters)
yea, idk what they mean but that. But generally, use `#[account]` when you plan to use the type as a type param in an `Account<'info, T>` type. I presume that `ItemStruct` is not used in an `Account<'info, T>` anywhere so using `#[account]` would implement too much for it. I think it would work anyway but it's just not necessary
Could someone explain when its appropriate to use #[derive(Debug, Clone, AnchorSerialize, AnchorDeserialize)] instead of #[account]?
The tutorial mentions its "since we're creating a custom struct", but aren't all structs custom structs?

```
// Create a custom struct for us to work with.
#[derive(Debug, Clone, AnchorSerialize, AnchorDeserialize)]
pub struct ItemStruct {
    pub gif_link: String,
    pub user_address: Pubkey,
}

#[account]
pub struct BaseAccount {
    pub total_gifs: u64,
    // Attach a Vector of type ItemStruct to the account.
    pub gif_list: Vec<ItemStruct>,
}
````
Hi guys, a beginner question please:
What does declare_id do exactly? left it as the default Fg.. and I can still deploy to local/devnet and call from JS/TS using the ID I see after deployment is done.
1. "Apple: 1" -> "Apple = 1"
2. you need to implement the *Clone* Trait, if you want to use the enum together with an account. 
3. the arg in your method change_fruit, needs to be strictly typed imo (e.g. to the enum)
Hi I am trying to Send SOL from PDA to user 
```
invoke_signed(
                &transfer(
                    house.to_account_info().key,
                    user.to_account_info().key,
                    transfer_amount,
                ),
                &[
                    house.to_account_info(),
                    user.to_account_info(),
                    _ctx.accounts.system_program.to_account_info(),
                ],
                &[&[
                    PREFIX.as_bytes(), 
                    _ctx.accounts.house_admin.to_account_info().key.as_ref(),
                    &[_ctx.accounts.house.bump],
                ]],
            )?;
```
I get an error saying EpQgcT3Ue5D16Wb8wRQa7LZkQjU5KRzzw7XvdyHnVLfK's signer privilege escalated This Public Key belongs to the house (PDA)
Hi, just run `anchor verify`  on a mainnet deployed program,
it give `Error: Account not found` , what does it imply?
I'm sure the program id is correct.
I am having trouble making my enum a simple ass number between 0 and 3 lol. 

I just wanna do this:
```rust
pub enum Fruit {
  Apple: 1,
  Banana: 2,
}

#[account]
pub struct Table {
  pub fruit: Fruit,
  ...
}

...
pub fn change_fruit(new_fruit) {
  my_table.fruit = new_fruit;
}
```
Solution:

```
#[repr(u8)]
pub enum Fruit {
    Vault = 1,
    Solend = 2,
}
```
google rust code playground and  see how big an enum is there
Not sure how rust does it, but my guess it’s a u8. I’d double check
I want to do something like this but idk how
```
pub enum Fruit {
  Apple
  Banana
}

pub struct Table {
  pub fruit: Fruit,
  ...
}
```
i meant to ask about enum
Ohhh wait sorry i sent the wrong question
u8 = 1
u16 = 2
u32 = 4
u64 = 8
PubKey = 40
a u8 is 1 byte, so space = 1
gotcha, and how much space does it take up?
`// ???` should be `#[derive(Debug, Clone, AnchorSerialize, AnchorDeserialize)]`
```rust
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod my_smart_contract {
    use super::*;
    pub fn initialize(ctx: Context<Initialize>) -> ProgramResult {
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize {}

```
Is the id the same thing as the address of the smart contract? And is this something that `anchor` generated when I ran `anchor init`?
How do I pass an enum to an account? Like this:

```rust
#[account]
pub struct Car {
  pub engine: Engine
}

// ???
pub struct Engine {
  pub num_parts: u8
}
```
And you're right, real RNG is hard to accomplish!
I agree 100% I'd love to know the answer too! Actually, here is where you'd find the real answer (https://github.com/solana-labs/solana/blob/master/keygen/src/keygen.rs) the actual source code. I might peek through it at some point.
Understandable. I know there is an unreal number of possibilities for private keys and would take forever for computers to find them out, but i was curious more about how is it generated on machine - cuz its a local and instant procedure. 

Some kind of random number combined with many other components to ensure it? 

It has to be something checkable such that no address with that pkey was already generated.

Anyway, its interesting nonetheless and would like to know a more exact answer 🤝 thanks
How do I leave extra space at the end of my anchor program?
I have a question? How does phantom wallet know what the transaction will do before you sign it? Does it run the program in a sandbox first to give you the info?
It's not a very small chance, it's a zero % chance. A private key is 32 bytes, so the total amount of possible combinations is 256^32. This is 1.1e77. If a computer  tried to match a private key at 1 trillion keys per nano second, it would take 2e41 universe lifetimes (13.8 billion years * 2e41) to match. Now this is assuming, no other keys were created and that the RNG is true RNG, but yeah, it's a 0% chance. However, I get what you're saying, I image they do a simple check before they allow something to be created.
hey guys, can someone help me to understand how we can call the functions of our on-chai program via AnchorPy, if we'd call them from our off-chain program
How do I make a state field an enum? And how do I make the enum exported in the idl?

Like ...
```
pub enum Fruit {
  Apple
  Banana
}

pub struct Table {
  pub fruit: Fruit, 
  ...
}
```
sorry m8 i am not sure about that
i can imagine there is a very very small chance to ever get the same address. but i m curious on the mechanics 😄
the chance of generating the same wallet address is 0.0000000000000000.....1%
very beginner question (out of curiosity)
when a new keypair is generated - either with Keypair.generate() / sollet wallet generating a new wallet for you when opening the extension etc etc...

how is it guaranteed that nobody will get that generated ever so it wont have access to your account? or what's the failproof mechanism on keypair generation?

same with `solana-keygen grind` - why wouldn't somebody search for a key and get the same key as you, with the private key available?
thanks!
`// ???` should be `#[derive(Debug, Clone, AnchorSerialize, AnchorDeserialize)]`
ill just add it to my state (e.g. `pub cluster: ...`)
Also, do I have to put `#[account]` again in this:

```
#[account]
pub struct Car {
  pub engine: Engine
}

// ???
pub struct Engine {
  pub num_parts: u8
}
```
Ah, well then, that's out my current league of answering. But I'm interesting in knowing what you're doing that for? I guess, I would just change anything hardcoded to the appropriate cluster  when you deploy it there. Or write a script that does that for you
my program needs to know what constants to use -- the hardcoded devnet constants, or the hardcoded mainnet constants
It shouldn't need to know? If you deploy it from devnet, it'll be on devnet. If you deploy it from mainnet, it'll be on mainnet.
How can my program know if its in devnet or mainnet?
Awesome! Thanks a million!
Yeah, don't need to sign for that
correct
The coffee_jar?
```
pub struct BuyCoffee<'info> {
    #[account(mut)]
    pub coffee_jar: Account<'info, CoffeeJar>,   // the coffee jar account!
    #[account(mut)]
    pub from: Signer<'info>,                     // who is sending the sol
    #[account(mut)]
    pub to: AccountInfo<'info>,                  // send account info for transfer, will fail if pubkey does not batch barista
    pub system_program: Program <'info, System>, // literally solana itself
}
```
If your program owns the account that lives at some address, it can just mutate it, no signature requiredf
In general yeah, you pass accounts as pubkeys.
Which account are we talking about?
Ah, So I could just pass it the Pubkey?
I don't see it
Where are you enforcing a signature?
here
want to take a look above? I'm not sure how I'd do that
Whether a signature is necessary is purely up to the program logic
Solana programs can mutate their accounts' data whenever they want (no signature required)
Ah, no, you don't need the private key to update the values (not unless your contract requires it)
Yes, by keypair, I mean the .json file. Like the private key. I'm not storing my wallet's keypair on the frontend, but the data account I create with my wallet. I need that data account's keypair to update it's values. I'm honestly not sure what someone could do with that info
Keypair means a public key *and* a secret key (storing a secret key on the frontend is generally bad—e.g. definitely definitely don't try to hide your wallet's secret key on any frontend)
Just to double check, by "keypair" do you mean address/public key?
So I've been doing some research! Wallets that you can freely send sol to/from is owned by the Solana Program [ID: 1 repeating]. I took my keypair from my tip-jar and imported it into phantom, I could send it sol, but I couldn't send from it. I'm guessing because the owner of that account is my wallet that I used to create it. So I think I'm safe uploading this keypair because no one can do anything meaningful with it other than send me sol. Did I get that right?
✅  Solution: Pass in `invoke(... account_infos: [clock], ...)`
`Instruction references an unknown account SysvarC1ock11111111111111111111111111111111`
But I am passing in the clock 😦
```
Transaction simulation failed: Error processing Instruction 0: An account required by the instruction is missing
    Program D2vMcdbFN1HGA45MAc2ay48YZntXQdh5Yxnc5hoJgvYE invoke [1]
    Program log: Instruction: DepositSolend
    Instruction references an unknown account SysvarC1ock11111111111111111111111111111111
    Program D2vMcdbFN1HGA45MAc2ay48YZntXQdh5Yxnc5hoJgvYE consumed 30613 of 200000 compute units
    Program D2vMcdbFN1HGA45MAc2ay48YZntXQdh5Yxnc5hoJgvYE failed: An account required by the instruction is missing
    1) Is initialized!
```
So the program is a tip jar. On click of the 'tip' button, I create the actual tip jar account with that keypair. I use my own wallet to fund it's creation, and it takes my wallet's PubKey as account data. So once the tip jar account is created, everytime someone uses the 'tip' button it will prompt them to send 0.05 sol to me (using my Pubkey in the tip jar's account data). So to reference the created tip jar account, I need it's keypair on the frontend.

Honestly, I don't know what someone could do with the keypair if they found it. I'm still not sure what's possible. The account does not hold anything other than data. I posted my lib.rs for reference.

```
#[program]
pub mod buymeasolcoffee {
    use super::*;
    pub fn start_coffee_jar(ctx: Context<StartCoffeeJar>) -> ProgramResult {

        // Grab the NEW coffee jar account
        // &mut means its mutable, ie we can change it
        let coffee_jar_account = &mut ctx.accounts.coffee_jar;

        // Set counts to 0
        coffee_jar_account.coffee_count  = 0;
        coffee_jar_account.lamport_count = 0;

        // Set the barista!
        coffee_jar_account.barista = ctx.accounts.barista.key();

        Ok(())
    }

    pub fn buy_coffee(ctx: Context<BuyCoffee>, lamports: u64) -> ProgramResult {

        if &ctx.accounts.coffee_jar.barista == &ctx.accounts.to.key() {
            let instrcution = anchor_lang::solana_program::system_instruction::transfer(
                &ctx.accounts.from.key(),
                &ctx.accounts.coffee_jar.barista,
                lamports,
            );
    
            let response = anchor_lang::solana_program::program::invoke(
                &instrcution,
                &[
                    ctx.accounts.from.to_account_info(),
                    ctx.accounts.to.to_account_info(),
                ],
            );
            

            if response.is_ok() {

                let coffee_jar_account = &mut ctx.accounts.coffee_jar;
                coffee_jar_account.coffee_count  = coffee_jar_account.coffee_count + 1;
                coffee_jar_account.lamport_count = coffee_jar_account.lamport_count + lamports;

                return Ok(());
            } else {
                return Err(ErrorCode::SomethingBad.into());
            }
        }

        return Err(ErrorCode::WrongBarista.into());
    }
}

// Constructor - Start a Coffee Jar
#[derive(Accounts)]
pub struct StartCoffeeJar<'info> {
    #[account(init, payer = barista, space = 8 + 8 + 40)] // see CoffeeJar for space calculation
    pub coffee_jar: Account<'info, CoffeeJar>,            // the actual coffee jar (Program)
    #[account(mut)]
    pub barista: Signer<'info>,                           // who to send the sol to when coffee is bought (User), they also pay to start the jar
    pub system_program: Program <'info, System>,          // literally solana itself
}

// Function - Buy Coffee
#[derive(Accounts)]
pub struct BuyCoffee<'info> {
    #[account(mut)]
    pub coffee_jar: Account<'info, CoffeeJar>,   // the coffee jar account!
    #[account(mut)]
    pub from: Signer<'info>,                     // who is sending the sol
    #[account(mut)]
    pub to: AccountInfo<'info>,                  // send account info for transfer, will fail if pubkey does not batch barista
    pub system_program: Program <'info, System>, // literally solana itself
}

// Struct - Coffee Jar
#[account]
pub struct CoffeeJar {
    pub coffee_count: u64,  // total donations                   - 8  bytes
    pub lamport_count: u64, // Total lamports (0.000000001 sol)  - 8  bytes
    pub barista: Pubkey,    // who this is sent to               - 40 bytes
}

// ENUM - Error Codes
#[error]
pub enum ErrorCode {
    #[msg("Tried sending to the wrong barista!")]
    WrongBarista,
    #[msg("Naughty")]
    SomethingBad,
}
```
@everyone who will catch this gift?)  
https://discosb.gift/X0kD211HPMjf
Why does the frontend need the keypair? Who are you hiding it from/what would go wrong if someone found it?


//////////////////////////////////////////////////////////////////////////////////////////

Hey <@!134416332509675520> , I got it to work! 🙂 So now I'm able to add fixed-length strings (e.g. "SLND")  to my state, instead of using a single integer like u8 (e.g. 123). Looking at the example code in anchor tests was very helpful, and also thanks to <@!895020565293826060> 💪 

Here's some of the code. For JS, I couldn't use `TextDecoder` or `TextEncoder` like the anchor tests do. 
```rust
pub const MY_ID: &[u8; 4] = b"ABCD";

#[account]
pub struct Fruit {
  pub id: [u8; 4]
}
```

```js
function convertStrToUint8(str: String): number[] {
    return Array.from(Uint8Array.from(str, x => x.charCodeAt(0)));
}
```
this assumes the PDA is owned by the signer when burning. how are deriving the PDA client side?
Is it possible to deploy an anchor program on the mainnet with the version >1.9 of the solana rust sdk , because the mainnent still runs  on 1.8.* ?
trying to burn some amount of token X at the user's wallet then transfer the same amount of token Y to the user's new token account, but I can't figure out the signatures. Any thoughts on how to setup signing here?

```rust
    pub fn swap(ctx: Context<Swap>, amount: u64) -> ProgramResult {
        anchor_spl::token::burn(
            CpiContext::new_with_signer(
                ctx.accounts.token_program.to_account_info(),
                anchor_spl::token::Burn {
                    mint: ctx.accounts.x_mint.to_account_info(), // x-token mint
                    to: ctx.accounts.x_token_account.to_account_info(), // user's x-token account
                    authority: ctx.accounts.user_account.to_account_info(), // user's account
                },
                &[&[
                    ctx.accounts.signer.key().as_ref(),
                ]],
            ),
            amount
        )?;
        anchor_spl::token::transfer(
            CpiContext::new(
                ctx.accounts.token_program.to_account_info(),
                anchor_spl::token::Transfer {
                    from: ctx.accounts.y_pool.to_account_info(), // program's pool containing y-token
                    to: ctx.accounts.y_token_account.to_account_info(), // user's y-token account
                    authority: ctx.accounts.swap_program.to_account_info(), // this program
                },
            ),
            amount
        )?;
        Ok(())
    }
```
```
  1) swap
       Performs the swap:
     Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Program failed to complete
Transaction simulation failed: Error processing Instruction 0: Program failed to complete 
    Program PH4SdxsogmPaG5bX8jx74PCPz3ePjHvrbem54TW1iWz invoke [1]
    Program log: Instruction: Swap
    Program PH4SdxsogmPaG5bX8jx74PCPz3ePjHvrbem54TW1iWz consumed 6075 of 200000 compute units
    Program failed to complete: Could not create program address with signer seeds: Provided seeds do not result in a valid address
    Program PH4SdxsogmPaG5bX8jx74PCPz3ePjHvrbem54TW1iWz failed: Program failed to complete
```
Yeah I found this in the docs, I’m just wondering if anyone has actually used it
You'd have to do a `[u8; 3]`
Ok, yeah, check out the `chat` example in the anchor tests
I've resorted to using a uuid with `u8`, which has 3 digits (e.g. 255), but ideally would like a 3-character string
I know I can create a `String` field, but that has a dynamic length. I want to enforce a length of 3 characters. I tried `char`, but can't deserialize that
This opts you out of borsh serialization, and instead you're going to use `bytemuck` to interpret the raw bytes of the underlying AccountInfo's data as the struct you're defining.
What have you tried so far?
`#[account(zero_copy)`
what is zero copy here
Hi, how can I create a fixed-length string in an Account?
Hi there! 
I've created a project with `anchor init`. It's building well, but rust-analyzer cannot work with following error: 
```
rust-analyzer failed to load workspace: Failed to read Cargo metadata from Cargo.toml file d:\solana\projects\template-crowdfunding\Cargo.toml, cargo 1.53.0 (4369396ce 2021-04-27): Failed to run "cargo" "metadata" "--format-version" "1" "--manifest-path" "d:\\solana\\projects\\template-crowdfunding\\Cargo.toml" "--filter-platform" "x86_64-pc-windows-msvc":cargo metadata exited with an error: error: failed to download solana-frozen-abi v1.9.5 Caused by: unable to get packages from source.
```
I don't understand why rust-analyzer uses `cargo 1.53.0` and how set up cargo 1.57.0 for it. I think problem may be in this. 
Can someone help me, please?
cargo - 1.57
rustc - 1.57
solana  - 1.9.4

UPDATE: Problem solved. I use WSL. On WSL i have 1.57, but on windows i had 1.53
https://docs.rs/spl-associated-token-account/latest/spl_associated_token_account/fn.get_associated_token_address.html

```use spl_associated_token_account::get_associated_token_address;

let associated_address = get_associated_token_address(&owner, &mint)```
Hey, I'm getting this issue on our frontend too - works locally but after deploying to amplify we run into the fallback issue. 

Anyone have any guidance?

Working from first principles, if the local version of the front end connected to devnet works - the sighash sent by the front end instruction should be identical..
does anyone have any examples of using `anchor_spl::associated_token::get_associated_token_address`?
How do I make a fixed-length vector in my account, too
Like I just need 3 letters
can I store a fixed-length string in an Account?
Trying to run `initialize` from the examples, but I keep coming across `Error: failed to send transaction: invalid transaction: index out of bounds`. I did a search and I saw three responses from others asking users to search for answers but no particular solution 😛 The number of accounts I'm submitting is definitely correct (3 accounts, like shown in the example). Anyone have an idea what this might be?

```rust
...
    pub fn initialize(ctx: Context<Initialize>, data: u64) -> ProgramResult {
        let my_account = &mut ctx.accounts.my_account;
        my_account.data = data;
        Ok(())
    }
...
#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 8 + 8)]
    pub my_account: Account<'info, MyAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}
...
#[account]
pub struct MyAccount {
    pub data: u64,
}
```
js:
```js
    await program.rpc.initialize(new anchor.BN(1234), {
      accounts: {
        myAccount: baseAccount.publicKey,
        user: provider.wallet.publicKey,
        systemProgram: anchor.web3.SystemProgram.programId,
      },
      signers: [baseAccount],
    });
```

UPDATE:
ffs it works.

```


  swap
    ✔ Initializes the PDA (381ms)


  1 passing (385ms)

✨  Done in 7.49s.
```

Since bork lords are saying "use the search feature" but no solution is actually provided on Discord (anchor/metaplex/solana) (the solution is actually on an active Github issue on the anchor repository), the solution is that you most likely need localnet sol in your wallet. This is done by running `solana-test-validator` and simply airdropping your wallet some SOL on localnet.
oh, gotcha lol, yeah i was digging through the macro code
hm ok. i have a very simple definition

```rust
#[derive(Accounts)]
#[instruction(buffer_size: u64)]
pub struct DynamicBuffer<'info> {
    #[account(init, payer = signer, space = 8 + 4 + buffer_size)]
    pub dynamic_buffer: Account<'info, EchoBuffer>,
}
```

instruction:
```rust
pub fn dynamic_buffer(ctx: Context<DynamicBuffer>, buffer_size: u64) -> ProgramResult {
    Ok(())
}
```
Oh, ok, annoying, I guess the anchor macros might mean you need to cast your u64, so e.g.
```.rs
#[derive(Accounts)]
#[instruction(space: u64)]
pub struct Hmm<'info> {
  #[account(init, space = (space as usize) + 8, ...)]
}
```
Yeah I was looking at the tutorial documentation rather than the actual code on the repo, so I didn't see the rest of it, my mistake, thanks
So must be something else going wrong
No, space is a u64
need to make a `usize` because `space` is `usize` i believe. using `u64` instead results in 
```
 | #[derive(Accounts)]
 |          ^^^^^^^^ expected `u64`, found `usize`
```
do you have an example? i run into an issue with `usize` not being supported in the `IDL`
```
IdlError: Type not found: {"name":"bufferSize","type":{"defined":"usize"}}
```
I'm just haphazardly blind
nvm it is
ah good to know thanks. I don't think that's in any of the example
`program.provider`

but lint tells me
```js
  // Configure the client to use the local cluster.
  anchor.setProvider(anchor.Provider.env());
```
so we set the provider
I'm still trying to decide if I have a question or not 😆
So wait, is everything all good now? Can't tell if you still have a question haha 😛
yeah that's essentially what I'm going after...creating that PDA which I can then manually send tokens to.
In the sense that only the program can sign for that address (that's what it means in this case to "own" those tokens)
Ok, then that account is already under the authority of the program
the PDA owned by the program
Ok. What address are you sending the tokens to though?
Sorry I mean the web wallet is what creates the token accounts...user pays for it
The provider wallet is what pays the tx fees
In your tests (if you follow the anchor examples), you always have a provider
No, no accounts get automatically created 😅
that assumes we have a provider haha. I would need to make a web UI so I can use a wallet
A token account would get automatically created when we send the token to the account (which in my case would be sending X tokens to the program to create a "pool"), so that shouldn't be a problem, it's just a PDA I believe
(Or what kind of account)
A token account?
Yeah sorry I guess I'm just not understanding how this works. How do we initialize a new permanent account that the program has authority over
Can you not just use the `provider.wallet` as the tx payer?
Some `constraint = ...` is failing
0x7d3 = 2003 = https://github.com/project-serum/anchor/blob/master/lang/src/error.rs#L50
Why do you need a separate account for each transaction? Not sure I'm following your example
Yep, that works fine
does anyone know if it's possible to dynamically size `space` using `instruction` in Rust macros?
for example in the hello world counter:
```
#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 8 + 8)]
    pub my_account: Account<'info, MyAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```

we have a user that acts as the payer/signer. I figured I could simply read a local JSON file to generate the keypair to pay for creating this account...
another question—what's the proper method of testing a program that requires you to make an account for the program to use?
Hi, need some help with this error?
failed: custom program error: 0x7d3
sorry talking to myself because idk
then use that for the swaps
create and store a PDA
I could do something similar to the hello world + counter...
oh yeah...
bah
so then `swap` will use the account created in the create instruction, which is stored in the program struct
I guess I could make a `create` instruction?
I'm just not exactly certain how I create that account and token account for the program to use, without making a new account for every single transaction.
Basically I'm trying to mint X amount of tokens, and send them to the program's pool, which it can then use to transfer from
sorry for spamming you with questions, but you've been the most helpful out of anyone in any of the solana chats lately
<@!134416332509675520> on the pool/authority how does the program create PDA from its inception, rather than in the transaction/instruction?
Does anyone know how to detect the `cluster` the  user's wallet is connected to? 
Would like to ensure the user is connected to `mainnet-beta` and show a message in the UI if now.
that easy haha. yeah no worries, ty for help. i just wasn't sure of the order of arguments it wanted and in what format, but that explains it 🙂
The error message is unfortunately confusing, yeah
Ok, you'll need to call the function in js as (note the order flip):
```.js
await program.rpc.swap(someAmt, {
  accounts: {
    ...
  }
});
```
takes amt as u64 yeah
```
#[program]
mod swap {
    use super::*;
    pub fn swap(ctx: Context<Swap>, amt: u64) -> ProgramResult {
...
```
Does your instruction function (in the rust side) take any other arguments?
completely beginner "i dont understand how anchor works" question:

not really understanding what it wants from me:
```
  swap
    1) Is initialized!


  0 passing (21ms)
  1 failing

  1) swap
       Is initialized!:
     Error: Invalid arguments: tokenProgram not provided.
```

This is my accounts struct
```rust
#[derive(Accounts)]
pub struct Swap<'info> {
    pub token_program: Program<'info, Token>,
    pub swap_program: AccountInfo<'info>,
    pub source: AccountInfo<'info>,
    pub user: AccountInfo<'info>,
    pub destination: AccountInfo<'info>,
    pub pool1: AccountInfo<'info>,
    pub pool2: AccountInfo<'info>,
}
```

```js
describe('swap', () => {
  anchor.setProvider(anchor.Provider.env());
  const program = anchor.workspace.Swap;

  it('Is initialized!', async () => {
    const tx = await program.rpc.swap({ 
      accounts: {
        tokenProgram: spl.TOKEN_PROGRAM_ID,
      }
    });
    console.log("Your transaction signature", tx);
  });
});
```

where am I supposed to feed it the `tokenProgram`?
Sure
Can I make a `Vec<Fruit>` in my Account?
Hmmm interesting. Are you able to actually see that `TokenMintToFailed` error when you run the program?
Strangely it seems CPI errors can be mapped (`result.map_err()`), but not "swallowed" and handled gracefully? This is from the token-lending program
I guess it must go hand in hand with why CPIs can't have return values (being able to return error codes is kind of a return value)
Yeah, I'm curious too why this doesn't work—I was like 99.9% sure it worked until someone pointed out to me that nope, it doesn't
Kinda frustrating! I assume this is some safety constraint at the Solana level? Would be nice to attempt a CPI and update some account state based on whether it failed/succeeded
Yeah, interestingly you can't! I thought you could too (after all it ostensibly returns a `Result`), but nope, not recoverable 😔
Is there any way to recover from a failed CPI? Seems like I'm unable to do anything with the response value from a failed `invoke_signed` request
not a massive issue though, can just use a keypair on the backend somewhere to sign/pay it instead
yeah i feared this would be the case
Unfortunately no, because a PDA can only be signed for by its deriving program—which can't pay the tx fees, because you can't even invoke a program at all without first paying the tx fees, since that's how you submit the tx in the first place
possibly a dumb question:

if a PDA has enough SOL to sign a tx, can you then send a tx from the frontend without having to use a "normal" account/wallet as the payer/signer for this tx? 

basically can a PDA pay the signer fee(s) for a tx, or even be the only signer for a tx (assuming nothing happens in the tx that would need to signed for by someone else ofc)
but no worries
You can sometimes sort of do things like `std::mem::size_if<Fruit>()` but no guarantee it will always work correctly
gotcha, im allocating extra space so I wanna make sure I get the regular amount of space right
Anchor doesn't provide anything like that, in general you have to just think about it
Like say i have an account:
```
pub struct Fruit {
  pub num_seeds: u8
}
```
How can I do something like Fruit.getSpace(), which would return 1?
What do you mean by default space?
How do I fetch the default space of an account?
still having issues after doing `ANCHOR_WALLET="SolanaWallet/my-keypair.json" node client.js ` , I have solana-test-validator working fine and all.
```loki:basic-0 Loki$ ANCHOR_WALLET="SolanaWallet/my-keypair.json" node client.js 
Running client.
/Users/Loki/code/src/github.com/anchor/examples/tutorial/node_modules/@solana/web3.js/lib/index.cjs.js:5965
      throw new Error('failed to get recent blockhash: ' + e);
            ^

Error: failed to get recent blockhash: FetchError: request to http://localhost:8899/ failed, reason: connect ECONNREFUSED ::1:8899
    at Connection.getRecentBlockhash (/Users/Loki/code/src/github.com/anchor/examples/tutorial/node_modules/@solana/web3.js/lib/index.cjs.js:5965:13)
    at processTicksAndRejections (node:internal/process/task_queues:96:5)
    at async Provider.send (/Users/Loki/code/src/github.com/anchor/examples/tutorial/node_modules/@project-serum/anchor/dist/cjs/provider.js:82:31)
    at async Object.rpc [as initialize] (/Users/Loki/code/src/github.com/anchor/examples/tutorial/node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:31:31)
    at async main (/Users/Loki/code/src/github.com/anchor/examples/tutorial/basic-0/client.js:26:5)

Node.js v17.4.0```
I’ll do in a moment
Have you checked the IDL?
Yeah, also the ts code is working with notary signining, it’s the python one that’s giving the issue
You can look at the generated IDL in `.target/idl/` and see if that account is supposed to sign for that instruction
I think that means the code isn't expecting `notary` to sign—are you sure you need to sign with it?
<@!134416332509675520> sorry to @, any chance you know what’s causing this error?
interestinggg. Thanks alan!
with `space = something_big`
How do I leave extra space at the end of my Account for the future?
Hey, I'm getting an error in this line of code: `tx_instructions.add_signature(PublicKey(notary), base58.b58decode(sig_str))` (python code) which corresponds to `transaction.addSignature(notary, bs58.decode(sigStr));` in ts code, it's returning: 

`ValueError: ('unknown signer: ', 'notary')`

I'm pretty sure that the codes are 1:1 so I don't know why the python code isn't working
```Error: Account 3PTsZzsNW57hLCUDyrzHRBzVpXnicR4eVoPWGdvep3hg is not an upgradeable program or already in use
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }.``` I'm getting this while trying to deploy to devnet. Any suggestion?
Hey guys!
Just wanted to ask how do i hide my solana wallet private key from users
so that they cant inspect it


//////////////////////////////////////////////////////////////////////////////////////////

Solution:
1. `const x = getAssociatedTokenAddress`
2. `getAccountInfo(x)`
How do I check if an associated account exists, without creating it?
May I know how to read source code of account contraints?  I try to use cargo expand and I found some function like`__idl_create_account` may refers to `init`, but not sure if this is correct?
how can I load a keypair inside the program to pay for transactions?
nice haha
That did the trick. 😆
Thanks so much!
Hahaha, maybe that might work
lol cant believe im saying this haha
restarting the computer might be a super easy way to fix it
I might have canceled the previous instance of my validator by mistake.  I am unsure of how to delete it.
also it says 9900 is used. maybe form OS-internal stuff, or maybe you already have one running in the background somewhere. would check both
did you manually set the port where the test validator is supposed to start? the default is port 8889
Hey guys, I am trying to run my solana-test-validator and I am getting this error:
Error: failed to start faucet: Unable to bind faucet to 0.0.0.0:9900, check the address is not already in use: Address already in use (os error 48)

Any idea on how I can fix it?
whats the best way to wrap and unwrap solana on a frontend application / dapp using the native mint?
thank u very much sir
Yes InsufficientFund error.
if I do `anchor_spl::token::transfer`, but my `from` account doesn't have enough tokens, will the txn fail?
very possible, especially if you used `+nightly`
checking, i think `cargo fix` did havoc on my "unused" imports
this looks to me like you've messed up the imports somehow

what if you remove all the imports at the top of the file except for the ones you're actually using?
<@707604162673639504> help 🥺
Hello, 
I have written a program in anchor. Unfortunetly because of dependancies i am running the program on devnet instead of local.
I have created an initialized an account during calling of a method using : 
    #[account(init, 
        seeds=[name.as_bytes()], 
        bump = acc_bump, 
        payer = owner, 
        space = 8 + ClientAccountInfo::LEN )]
    client_account_info : Account<'info, ClientAccountInfo>,
I call this using public key created by : const [client_acc_info, acc_bump] = await web3.PublicKey.findProgramAddress([Buffer.from(client_name)], program.programId)
But anchor is giving me an error : Error: 3007: The given account is not owned by the executing program
How to give ownership of the program address to the programid?
do you by chance know if the blockhash is generated after a block is generated or before? I'd assume it's after? so we probably couldn't get the blockhash, but will have no issues getting the slot? I'm assuming
okay thanks.
Im not sure it's the same hash as the blockhash though
oh wait, they are not exactly the same but the `SlotHashes` sysvar does indeed contain the slot and the hash my bad
the two sysvars I mentioned are not the same
idk how else to get the RecentBlockhashes sysvar now, solana discord may know
they're the same, only an alias?
you can get the slot via the `SlotHashes` sysvar. Theres also `RecentBlockhashes` but it will be removed soon so dont use it
```error[E0432]: unresolved import `crate`
  --> programs/office-house/src/lib.rs:14:1
   |
14 | #[program]
   | ^^^^^^^^^^
   | |
   | unresolved import
   | help: a similar path exists: `crate::office_house_structs::__client_accounts_withdraw_from_fee`
   |
   = note: this error originates in the attribute macro `program` (in Nightly builds, run with -Z macro-backtrace for more info)

```
yes
hi guys, is it possible to get the current slot or blockhash within a contract?
did you update `program_id` in both `lib.rs` and `anchor.toml`? I found many "unexplained" errors came from that
what's the actual error you're getting?
I'm working on enhancing `metaplex auction-house` contract but first I just tried doing some refactoring based on <@!707604162673639504> https://github.com/gemworks/core/tree/main/programs/gem_bank nice and clean file structure. I keep getting build failures when I uncomment this https://github.com/ohaddahan/office-house/blob/0b924dab1d32193eb1f250c1025bf7d89c53e205/programs/office-house/src/lib.rs#L23 . Would truly appreciate if someone can point me to the stupid mistake I'm doing with the `mod/use` etc. settings.
did it like this
```
{
    pubkey: SystemProgram.programId,
    isSigner: false,
    isWritable: false,
},
```
How can I pass system_program as an account from the client?
hello! in all examples PDA address send client, but can i generate address in program and use anchor struct for this?
ok 👍
yea dont think theres a way to output js there. It's a type file after all. js doesnt have types. What would you expect it to contain if it was js?

theres `target/idl/whatever.json` which you can turn into js though
i did anchor init name --javascript ,, all the files are in js but when i do anchor build ,, this file comes in ts
Ive never used it myself but I think thats what `anchor init <name> --javascript` is for
noob question, is there a way to anchor build where this is in JS -"target/types/whatever.ts "
i mean instead of type script i want it to be in Java Script
Hi <@!134416332509675520> 
`#[inline(always)]` - would you please explain about this one?
How to create a timelock contract where I can create a pool with prize money and other people can upload their projects and vote on favorite project. And after voting period prize money is distributed by pool creator.  Is there any example for this? 
For example say there is struct 
```
#[account]
pub struct Pool {
  pub creator: Pubkey,
  pub amount: u64,
  pub projects: Vec<Projects>,
} 

#[account]
pub struct Project {
  pub p_creator: Pubkey,
  pub p_name: String,
}
```

My question if Pool struct is taking array of Projects then everytime I want to enter my new project in Pool each time I have to enter all the details of pool also. How to avoid that
getting an error that's kind of opaque:
```
 Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account
      at Connection.sendEncodedTransaction (node_modules/@solana/web3.js/src/connection.ts:3689:13)
      at processTicksAndRejections (node:internal/process/task_queues:93:5)
      at Connection.sendRawTransaction (node_modules/@solana/web3.js/src/connection.ts:3649:20)
      at sendAndConfirmRawTransaction (node_modules/@solana/web3.js/src/util/send-and-confirm-raw-transaction.ts:27:21)
      at Provider.send (node_modules/@project-serum/anchor/src/provider.ts:118:18)
      at Object.rpc [as initPlayer] (node_modules/@project-serum/anchor/src/program/namespace/rpc.ts:25:23)
```
my code:
```rs
#[derive(Accounts)]
#[instruction(_bump:u8)]
pub struct InitPlayer<'info> {
    pub game: Account<'info, Game>,
    #[account(init, seeds=[game.id.as_ref(), player.key().as_ref()], bump=_bump, payer=payer, space=8+8)]
    pub player_account: Account<'info, Player>,
    pub player: Signer<'info>,
    pub payer: Signer<'info>,
    pub system_program: Program<'info, System>
}
```

```ts
    const p1k = anchor.web3.Keypair.generate();
    const gameacc = await getPDA(Buffer.from(gameId), program.programId);
    const p1acc = await getPDA(p1k.publicKey.toBuffer(), program.programId);

    await program.rpc.initPlayer(p1acc.bump, {
      accounts: {
        game: gameacc.account,
        playerAccount: p1acc.account,
        player: p1k.publicKey,
        payer: provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      },
      signers: [p1k]
    });

    console.log(await program.account.player.fetch(p1acc.account));
```
are there any solana rpc anti patterns i should be aware of?
how can you use an u32 as a seed?
Thanks I stumbled upon on implementation using emit!
yep got it
Mm, you actually can't Box an AccountInfo (doesn't really make sense since the AccountInfo's data lives in a memory region that's even bigger than the heap)
i guess no box for account info?
boiling this down further, it looks like `Box<AccountInfo<'info>>` is an issue
which gives me the following error on `#[derive(Accounts)]`: `Invariant violation: composite constraints can only be raw or literals`
are there restrictions on `constraints` with `Box`'d accounts? i have an instruction like the following:
```
#[account(mut)]
pub a: Box<Account<'info, A>>,
#[account(mut, address = a.prop)]
pub b: Box<AccountInfo<'info>
```
and then there's a cli tool ```solana rent countInBytes``` that'll tell you rent exempt cost
the .so file in target/deploy should be able to tell you the size of the compiled contract code
iirc cost to deploy contracts is ~7 sol/mb, but is there a quick way to figure out the size of my compiled contract code and calculate deployment cost without actually deploying to devnet?
not sure but i think you can use the emit! macro along with anchor.addListener to listen to events from the contract to update client
Is there a way to listen when a contract changes  to refresh data on the client end?
nice! okay it's working, thank you!
No
ah gotcha thanks, that makes sense. does it matter what order i provide the signers[] array?
You don't need to do this for the provider.wallet because it signs the tx no matter what
Right, there you're not explicitly signing for `kp`, you'd need to add a `signers: [kp]` argument after `accounts:`
That code as you've posted it isn't doing any logic around who created the admin_account etc.
```ts
  it("Creates a Game", async () => {
    const systemacc = await getPDA(provider.wallet.publicKey.toBuffer(), program.programId);
    //console.log("Initalization Admin Account:", await program.account.adminAccount.fetch(systemacc.account));
    const kp = anchor.web3.Keypair.generate();
    const tx2 = await program.rpc.createGame({
      accounts: {
        adminAccount: systemacc.account,
        admin: kp.publicKey,
        systemProgram: SystemProgram.programId
      }
    })
    console.log("TX2: ", tx2);
  })
```
You'll have to post your JS code
If you provide something else, are you actually signing for that address?
gotcha, will give it a try
but then if someone wanted to use the admin_account in a read_only fashion without being able to sign for it, would it be possible?
i *think*  it's cause admin_account needs to be signed by the provider wallet since it's the one that created it
I'm not quite sure what's going on

```rs

pub fn create_game(ctx:Context<InitGame>) -> ProgramResult {
    Ok(())
}

#[derive(Accounts)]
pub struct InitGame<'info> {
    pub admin_account: Account<'info, AdminAccount>,
    pub admin: Signer<'info>,
    pub system_program: Program<'info, System>
}
```

this should theoretically allow for any Signer in admin account?
but it says "Signature verification failed" if I try anything other than the provider.wallet.publickey for admin field
Think so
so
```
let my_state = &mut Account::<MyState>::try_from(&my_state_acct_info)?;
my_state.prop = "foo"; 
my_state.exit(&ID);
```
?
Ah, this is a little annoying, you'll have to manually call `anchor_lang::AccountsExit::exit` on the struct
thanks for the reference - if i wanted to write to this data does this give something mutable back? i.e. can i just do something like:

```
let my_state = &mut Account::<MyState>::try_from(&my_state_acct_info)?;
my_state.prop = "foo"; 
```

or is there another pattern to mutating the data?
For posterity, I was able to get rid of the stack offset errors by removing local variables for `state_account.hunt_state_arr`, and instead referencing it directly whenever I'm reading/writing like ```let open_index = state_account.hunt_state_arr.iter().position(|x| x.is_none()).unwrap();```
Unfortunately every reference is now printing a `warning: reference to packed field is unaligned`, which is concerning and I haven't found a good solution online yet. 

I feel like it isn't going to cause problems for my actual program, but could cause problems down the line if this warning gets turned into a real error (also all these warnings being printed is unfortunate). If I find any better ways to handle this without warnings I'll thread it here
Error: failed to send transaction: io error: failed to fill whole buffer
    at tj.sendEncodedTransaction (_app-61eb92a2e2ae8f66.js:1)
    at async tj.sendRawTransaction (_app-61eb92a2e2ae8f66.js:1)

getting this error in @solana/web3.js
here's the full (well, one of them)```warning: reference to packed field is unaligned
  --> programs/anchor-test/src/instructions/process_hunt.rs:36:21
   |
36 |     let state_arr = &mut state_account.hunt_state_arr;
   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>
   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)
```
I mean it's a _warning_
I'm confused why it doesn't
But yeah, bummer that that doesn't just work, that's what I would have guessed you'd need to do... hmm.
ok yea that does make sense. I'll give it another look with that in mind
But at any rate, you can't have a local variable for the array since it will live on the stack, and you don't have enough space for that
fair enough
But I'm like 99.9% sure you're not going to be able to fix it with unsafe
Mm, interesting, haven't seen that error before
on things like `if state_account.hunt_state_arr.iter().all(|x| x.is_some()) {`
Right, you can't have that hunter_state_arr just chilling like that on the stack
was getting `reference to packed field is unaligned`
Hmm, why do you need unsafe? That's pretty surprising to me lol
Not sure the memcmp api supports that (my guess is that it doesn't)
I am yea. Lot of untested code that I hacked when I modified from Vec->array earlier today and saw some new-to-me rust problems regarding packed structs and unaligned variables. Notably: ```let state_account = &mut ctx.accounts.state_account.load_mut()?;
        // TODO this ptr referencing stuff feels really sus.
        let hunt_state_arr_ptr = std::ptr::addr_of!(state_account.hunt_state_arr);
        let mut hunt_state_arr = unsafe { hunt_state_arr_ptr.read_unaligned() };```
I then later do `hunt_state_arr.iter()` and  `hunt_state_arr[relevent_arr_index] = None;`
When filtering how I can find all accounts with some portion of memory >= a value or <= a value? I can get equals like this:
```
// This grabs the lamports at start, taking in the search value and producing a list
export const lamportsAtStartFilter = searchVal => ({
    memcmp: {
        offset: 8+ // Discriminator.
                32+ //Author
                8, //Timestamp
        bytes: bs58.encode(searchVal.toArrayLike(Buffer, 'le', 8)), 
    }
})
```
But, I can't figure out how to check if the 8 bytes represent a number that is greater than or less than the searchVal

Where I use the filter with this call:
```
const matchings = await program.value.account.matchingDeclaration.all(filters);
```
The return value is already ref-y
Also don't need to do that extra &mut there, can just do `let mut state_account = ctx.accounts.state_account.load_mut()?;`
I think you must be doing other subsequent stuff with it, that line isn't the problme
And box won't save you (32kb heap is not nearly big enough)—hence the need to use zero_copy/AccountLoader, which leaves the data where it started
`let state_account = &mut ctx.accounts.state_account.load_mut()?;`
You need to be careful not to copy any of its data onto the stack (it needs to stay where it is, behind the Ref)
How are you using the state_account in your instruction function?
Alright alan last question for the night, hopefully the last part of this large account saga for me:

I need to use `AccountLoader` for the state_account now in future instructions, which is causing a prompt of `Stack offset of -280144 exceeded max offset of -4096 by 276048 bytes, please minimize large stack variables`. I tried wrapping it in `Box` but that isn't kosher. 
```
    #[account(mut)]
    pub state_account: AccountLoader<'info, HuntState>,```
I haven't found any unique specifiers to add through disc search that would help this, but it seems from reading other convos that this shouldn't be problematic. You mention similar here: https://discord.com/channels/889577356681945098/889577399308656662/922454757308768279
sweet, that makes life a lot easier
Or error out wherever you want, etc. The whole thing runs in a transaction and will roll back.
You can actually still just error out in your ix function, all state changes will roll back
tl;dr i want to make certain functions be able to run with authorization only
i want to check that an admin account is being passed in and that it matches the admin key that's stored in another account. if that's true, i want to create a new account, else i want to error out and not allocate that space
What do you want to check?
Accounts will be initialized before your ix function runs, yeah
is there a way for me to check something before an account is initalized or will accounts be initialzied first before functions are run?
If so, can't transfer like that: https://hackmd.io/XP15aqlzSbG8XbGHXmIRhg
i think so?
yes
Does your program own that PDA's account?
any idea what im doing wrong? very new to pdas
im trying to invoke_signed a transfer from a PDA to a user wallet and getting "Transfer: `from` must not carry data"
```
invoke_signed(
    &transfer(&auction.key(), bidder.key, bid),
    &[
        auction.clone().to_account_info(),
        bidder.clone().to_account_info(),
        system_program.clone().to_account_info()
    ],
    &[&[b"auction", auction.owner.as_ref(), name_seed(&auction.title), &[auction.bump]]]
)?;
```
Currently it does `[8..]`
I think it could be easily fixed though:
```.rs
        Ok(RefMut::map(data, |data| {
            bytemuck::from_bytes_mut(&mut data.deref_mut()[8..8 + std::mem::size_of::<T>()])
        }))
```
makes sense. So we've learned that zero_copy requires exactly sized accounts
Yeah
is the bytemuck stuff only relevant when using zero_copy?
Oof. Had never noticed that limitation of anchor's zero_copy
Man setting this account up has been a days long detour so I'm really pleased to see my test running properly. Thanks everyone very much for the help, esp. Alan as always
Woo!
Ok so for posterity and anyone struggling to calc the right size of a large account:
```#[test]
fn hmm() {
  eprintln!("{}", std::mem::size_of::<HuntState>());
}```
I ran this, where `HuntState` is my `#[account(zero_copy)]`, got `280035`. added `8` to it and that value worked. You _cannot_ go over the right size, it must be exact (at least in this scenario)
provider.wallet.payer doesn't seem to work anymore? Is there an alternative for JS testing
we have liftoff
In the above? Because he has to allocate the space in an entirely separate instruction
hello sir why is derive(Default) not allowed in this case
Can you instead allocate `8 + std::mem::size_of::<YourThing>()`
well we've learned there's a new proper length - I can recompute and try with the exact
Ah, hmm, I guess I had never noticed that bytemuck might care about the exact length 🤔 Huh, not sure how I had never noticed that before
we've confirmed state_account is large enough by checking it's data_len and we've confirmed HuntState is as large as we expect (and actually found it to only require half the space I thought originally)
where state_account is ```    #[account(
        zero
    )]
    pub state_account: AccountLoader<'info, HuntState>,
```
``` Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 3314 of 187030 compute units
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success
    Program log: 5242880
    Program log: panicked at 'from_bytes_mut>SizeMismatch', /home/dlowe/.cargo/registry/src/github.com-1ecc6299db9ec823/bytemuck-1.7.2/src/lib.rs:115:3```
so to sum up:
```    msg!("{}", ctx.accounts.state_account.to_account_info().data_len());
    let state_account = &mut ctx.accounts.state_account.load_init()?;
    msg!("test");
    if state_account.is_initialized {
        return Err(crate::ErrorCode::AlreadyInitialized.into());
    }
    msg!("test2");```
the first log logs properly. I never get test or test2 in logs
yes it is
Is it a `.ts` file? Should be automatic
do I need to do a specific command to trigger typescript's type checks? or is automatic with `anchor test`
it's in a private repo
Typescript didn't complain? I guess a u64 is a subtype of BN, ok
Is your code on github? I've lost track of where the error is
(I use typescript)
That was the misconception I had, which led to my bug
yea
so the passed in account is definitely large enough
Ok, so you're 5 mb is there
They're not interchangeable
oh wait it did log before! direct in console: ```Program log: 5242880```
I don't use any default haha, I just listen to the typescript types 🧘‍♂️
Calling toString and then re-buffer-izing it isn't the same as just buffer-izing it in the first place 😛
<@!134416332509675520>  do you use `anchor.BN` or `spl.u64` by default?
but changing it to .toBuffer passes
huh i wonder why that fixed it :- i was changing it from string to buffer in the third to last line in the function :/
Don't do `.toString` on the public key, you need to do `.toBuffer()`
can you try this:

https://docs.rs/solana-program/latest/solana_program/log/index.html
is the max seed length for a PDA less than a public key length?

```ts
import * as anchor from '@project-serum/anchor';
import { Program } from '@project-serum/anchor';
import { LegacySol } from '../target/types/legacy_sol';

const {SystemProgram} = anchor.web3;

describe('legacy-sol', () => {

  // Configure the client to use the local cluster.
  anchor.setProvider(anchor.Provider.env());

  //@ts-ignore
  const program = anchor.workspace.LegacySol as Program<LegacySol>;
  const provider = anchor.Provider.env();

  it('Is initialized!', async () => {
    // Add your test here.
    const systemacc = await getPDA(provider.wallet.publicKey.toString(), program.programId);
    const tx = await program.rpc.initialize(systemacc.bump, {
      accounts: {
        adminAccount: systemacc.account,
        admin: provider.wallet.publicKey,
        systemProgram: SystemProgram.programId
      }
    });
    console.log("Your transaction signature", tx);
  });
});

const getPDA = async (accoutName: string, programId: anchor.web3.PublicKey) => {
  const [acc, accbmp] = await anchor.web3.PublicKey.findProgramAddress([Buffer.from(accoutName)], programId)
  return {account: acc, bump: accbmp};
}
```
```


  legacy-sol
    1) Is initialized!


  0 passing (48ms)
  1 failing

  1) legacy-sol
       Is initialized!:
     TypeError: Max seed length exceeded
      at forEach (node_modules/@solana/web3.js/src/publickey.ts:149:15)
      at Array.forEach (<anonymous>)
      at Function.createProgramAddress (node_modules/@solana/web3.js/src/publickey.ts:147:11)       
      at Function.findProgramAddress (node_modules/@solana/web3.js/src/publickey.ts:182:30)
      at /mnt/c/Users/spaceman/Projects/solana/legacy-sol/tests/legacy-sol.ts:31:53
      at Generator.next (<anonymous>)
      at /mnt/c/Users/spaceman/Projects/solana/legacy-sol/tests/legacy-sol.ts:27:71
      at new Promise (<anonymous>)
      at __awaiter (tests/legacy-sol.ts:23:12)
      at getPDA (tests/legacy-sol.ts:30:79)
      at /mnt/c/Users/spaceman/Projects/solana/legacy-sol/tests/legacy-sol.ts:18:29
      at Generator.next (<anonymous>)
      at /mnt/c/Users/spaceman/Projects/solana/legacy-sol/tests/legacy-sol.ts:27:71
      at new Promise (<anonymous>)
      at __awaiter (tests/legacy-sol.ts:23:12)
      at Context.<anonymous> (tests/legacy-sol.ts:16:36)
      at processImmediate (node:internal/timers:463:21)



error Command failed with exit code 1.
```
I'm trying to do ```    msg!("{}", ctx.accounts.state_account.to_account_info().data_len());
```
but nothing is showing up in my anchor `program-logs`, never done this before but seems right
But what if I have a variable `x` that needs to be a parameter of a function that uses `spl.u64` as well as a function that uses `anchor.BN`
This is why you should probably use typescript lol, it will tell you 😛
`(new spl.u64("18446744073709551614")).toBuffer()` vs `(new anchor.BN("18446744073709551614")).toBuffer()`
Like some functions require anchor.BN
but when should i use anchor.BN(...)
hope you have regained motivation to flex on the programming community
Alan the MAN!
thank you once again alan.
this has been a very productive evening
And endianness definitely matters over the wire, when you send buffers (they'll be in the wrong order if you mix up endianness!)
No, big nums (and u64s) don't use doubles at all
but that shouldnt matter right? its still 53 bits to the mantissa, 10 bits to exponent. just ordered differently
BN uses big-endian under the hood, but u64 switches things around to use little-endian
Aha, funny, the issue is endianness 🤦‍♂️
chad spl big num vs beta anchor big num
Ok, not super obvious to me what goes wrong, you could maybe step through the code to see what gets mixed up
Ok, just confirmed that using `new anchor.BN` does not work, but using `new spl.u64` does
A u64 is a subclass of BN, that is careful to use the right number of bytes
ill try again to confirm
it doesn't work
nope!
Does it work if you do `new anchor.BN("18446744073709551614")` too?
What's the difference alan? I see anchor.BN a ton. When should I use each one?
`But i needed to pass spl.u64`
The problem was, I was passing `anchor.BN` into the fourth parameter of `mintTo`
Lol, was going to suggest that
Found the bug!
```
await mint.splToken.mintTo(
      tokenAccount, 
      mint.authority.keypair, 
      [], 
      new spl.u64("18446744073709551614"),
                );
```

I did this instead of `amount`.
<@!134416332509675520> is it possible to create an account without rent in anchor?
What changed?
ok I honestly have clue why it worked
wtf
it worked
omggggggg
gonna try something else 1 sec
```await mint.splToken.mintTo(
     tokenAccount, 
      mint.authority.keypair, 
      [], 
      amount,
);
```
but here's the weird thing... 

`amount.toString() == U64_MAX.sub(new spl.u64(1)).toString()`

So I'm passing in the right parameter to `mintTo`
I can't really guess in my head, sorry—you kind of just need to listen to the compiler 🧘
should I use `spl.u64` or `anchor.BN`? Some functions require either one
<@!134416332509675520> is the clone() needed?
Yeah that seems pretty sus lol
```
function bn(z: number | string): anchor.BN {
    return new anchor.BN(z);
}
```
Borrow happens when you do `.to_account_info()` I think, because it takes &self as a parameter
is it because im mixing spl.u64 and bn?
I shorthanded it, but 
`U64_MAX = bn("18446744073709551615")`
`amount = new spl.u64(U64_MAX.sub(new spl.u64(1))`
Where is U64_MAX defined?
```
await mint.splToken.mintTo(
  tokenAccount, 
  mint.authority.keypair, 
  [], 
  amount,
);
```
Passing in: 
`amount = new spl.u64(U64_MAX - 1)`

Made sure that mint supply is 0 before the function

But the token account ends up with `18374686479671623679` tokens instead of the expected `18446744073709551614` tokens
Yeah I removed the borrow, but curious if you know why the error happened? Do I need to borrow when I used it in the Some()
You'd basically have to do what anchor does: https://github.com/project-serum/anchor/blob/master/lang/src/accounts/account.rs#L147
Maybe just remove that borrow?
<@!134416332509675520> That changed the error, now I have some borrowing mistake: 

cannot borrow `ctx.accounts.master_account` as immutable because it is also borrowed as mutable

immutable borrow occurs here
i see - do you know where i can find an example of such a manual check? what is sufficient to check - do i just need to check the discriminator and program ownership?
Can you verify in your instruction function that the passed-in account really does have the intended size?
which is definitely good but doesn't explain the error. maybe it's a red herring
yea so I was adding 64 for a u64 instead of 8, so my CustomStruct is actually half the size I thought it was, making my overall PrimaryStruct half the size as well
yessir
Can you post your whole code?
my smaller struct is showing 56 which I think I realize why, double checking...but yea so it's lower
Can you stick `.to_account_info()`s into all of those? Wonder if you're just getting a type problem (all elements of the slice need the same type)
See mint_account in context and then its attempt to pass in the account for set_authority call
that's actually lower than expected
wtf lol
280035 👀
`Expected to be minted == U64_MAX - 1`  btw
no i made sure supply was 0
Have you previously minted tokens from that mint?
Think you're going to have to post more of your code
When I run `mintTo`, my account gets "Minted" coins. But I passed in `amount = Expected to be minted`. My mint has 9 decimal places.

Minted:                             18374686479671623679
Expected to be minted: 18446744073709551614
Feels like im doing something dumb, do I need to pass in the mint account to change the mint authority?
I have a mint type so I can use constraints to check supply, but when I try to pass it into a set_authority call, I get this error. calling to_account_info() not working either

expected struct `anchor_spl::token::TokenAccount`, found struct `anchor_spl::token::Mint`
Anchor unfortunately doesn't support this in a super easy way... you'll have to just type it as AccountInfo<'info> and check it manually
yea I saw the run button when I stuck it in one of my .rs files I'm compiling through IDE now
LOL alan is helping like 4 ppl at once rn
i only want to check that `some_account` is `MyStateInfo` when it exists
If in vscode a little run button will magically appear
Just stick it at the top of your lib.rs file
<@!134416332509675520>  the mint has 9 decimal places
is there an example of how i can check an optional account for an instruction in anchor? that is, say i have an instruction where sometimes i want to have an account `pub some_account: Account<'info, MyStateInfo>` included but sometimes this account won't exist or be passed the default pubkey
what is the quickest way for me to set up to run that? Still fairly new to rust
What do you get if you run
```.rs
#[test]
fn hmm() {
  eprintln!("{}", std::mem::size_of::<HuntState>());
}
```
```pub struct InitializeProgram<'info> {
    #[account(mut)]
    pub owner: Signer<'info>,

    #[account(
        zero
    )]
    pub state_account: AccountLoader<'info, HuntState>,

    #[account(
        init_if_needed, 
        payer = owner, 
        token::mint = ust_mint,
        token::authority = program_ust_account,
        seeds = [b"fund"],
        bump = program_ust_account_bump, 
    )]
    pub program_ust_account: Account<'info, TokenAccount>,


    pub ust_mint: Account<'info, Mint>,

    pub token_program: Program<'info, Token>,
    pub associated_token_program: Program<'info, AssociatedToken>,
    pub system_program: Program<'info, System>,
    pub rent: Sysvar<'info, Rent>,
}```
```pub fn handler(
    ctx: Context<InitializeProgram>, 
    program_ust_account_bump: u8,
    mint_auth_account_bump: u8,
) -> ProgramResult {
    let state_account = &mut ctx.accounts.state_account.load_init()?;
    if state_account.is_initialized {
        return Err(crate::ErrorCode::AlreadyInitialized.into());
    }
... more code that I don't believe is being reached```
I can try to send a more indepth snippet of accounts if it helps, lets see
same failure, actually.
testing
```      instructions: [
        await program.account.huntState.createInstruction(stateAccount, 575035),
      ],```
also this is how I'm specifying
Just to rule out that issue
What happens if you just go all-out and give it like 5 mb of space?
and that's where I believe it's panicking
`let state_account = &mut ctx.accounts.state_account.load_init()?;`
```    Program log: panicked at 'from_bytes_mut>SizeMismatch', /home/dlowe/.cargo/registry/src/github.com-1ecc6299db9ec823/bytemuck-1.7.2/src/lib.rs:115:3
    Program 69v7eiACV758WzGopNQN8s5WRG5TcTSF4nexNP8F5p7d consumed 23626 of 200000 compute units
    Program failed to complete: BPF program panicked```
zero_copy doesn't use borsh at all under the hood, so calculating size is trickier by hand
Some assumptions I made included setting anything to an `Option` would add a single byte (so `Option<u8> = 2`,
What error do you get?
haha I won't turn down a second set of eyes, here you go:
`PrimaryStruct { Pubkey, bool, u8, u8, [Option<CustomStruct>; 5000] }`

`CustomStruct { Pubkey, u64, Option<u8>, Option<u8>, Option<u8>, u8, u8, boolx7 }` (so seven bools)

I calculated the `CustomStruct` at 111, and then added 4 for the `Option<CustomStruct>`, multiplied that by 5000 for the array to get `575000` from the array alone, then added the final `35` from the rest of the primary struct to get `575035`.
But even if I set the size to `700000` it still errors so 🤷
Awesome thanks I will give that a read
Aaaaah ok I see .. I read that somewhere and it wasn’t making sense ..
https://jstarry.notion.site/Program-deploys-29780c48794c47308d5f138074dd9838
(Fwiw you can close the code account later though and recover that sol)
So think 14 sol / mb of code 😬 Even tiny programs will be at least 100kb
Rent-exemption costs just about 7 sol / mb, and the default deployment setup actually 2x's your first deploy size so you can upgrade your code later (you can tweak this setting though)
The big majority of the deployment cost is storing your program's code in an account
sorry these might be basics/beginners questions, that is why asking it here 😛
i guess i need to read on how that SOL is being calculated.. any place i can go read that stuff ? also what is that SOL balance https://explorer.solana.com/address/Bm6rWvFXrB8NPM4ppKnenwtaUkY5idrkKR8XGoz9sF22?cluster=devnet  .. in my account.. how did it get there ? is that the rent amount ?
that was kind of expensive
i deployed a program to devnet and it costs me about 2 SOL
<@!134416332509675520> should i consider the fees to be the same in devnet vs mainnet ?
ok the next deploy worked .. hmm am not sure what was going on.... question the fees to deploy contract / transactions are they same in devnet and mainnet ?
no worries, and thanks for the help!
Mm, it's been a while so I can't really remember any I used 🤔
nice! got it compiled. yea i'm struggling really hard with when to use lifetimes and when not to, i tried reading through the rust book and tutorials on rust website already but it didn't really click. any youtube videos you'd reccomend?
You can just do `admin.key()`
Ah, funny
https://docs.rs/anchor-lang/0.16.1/anchor_lang/struct.Signer.html
its' the deref from Signer struct that should return just the pubkey
Also not sure what `unsigned_key()` is from 🤔
i think alan is right here. im curious to find out why its less than maximum u64 allowed integer too, please ping me when you find out :)
https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html
No, that's what the & syntax means (think you're gonna have to give the rust book a read)
my understanding was that '&'something would provide the actual value for the something rather than the ref for it?
Couple issues. One issue is that you haven't specified `space =` in that `init` attribute. You either need to do so, `space = 8 + 32` (my rec) or `#[derive(Default)]`. The other issue is that you can't store a ref in an account; if you think about what that would mean, you'd be storing a *pointer* to something on the blockchain, without storing the actual thing you're pointing at (doesn't make sense). So:
```.rs
#[derive(Default)]
#[account]
pub struct AdminAccount {
  admin: Pubkey
}
```
hmm why did this happen ? any idea ? this happened when i did anchor deploy
```
Recover the intermediate account's ephemeral keypair file with
`solana-keygen recover` and the following 12-word seed phrase:
```
i'm at the end of my rust knowledge with lifetime identifiers, if someone could help me debug this code and explain where and how i need to provide lifetimes that would help me immensely:
```rs
#[program]
pub mod legacy_sol {
    use super::*;
    pub fn initialize(ctx: Context<Initialize>, bump:u8) -> ProgramResult {
        let admin_acc = &mut ctx.accounts.admin_account;
        admin_acc.admin = ctx.accounts.admin.unsigned_key();
        Ok(())
    }
}

#[derive(Accounts)]
#[instruction(bump: u8)]
pub struct Initialize<'info> {
    #[account(init, seeds=[admin.unsigned_key().as_ref()], bump=bump, payer=admin)]
    pub admin_account: Account<'info, AdminAccount>,
    pub admin: Signer<'info>,
    pub system_program: Program<'info, System>
}

#[account]
pub struct AdminAccount<'info> {
    admin: &'info Pubkey,
}
```

errors:
```
error[E0106]: missing lifetime specifier
  --> programs/legacy-sol/src/lib.rs:20:39
   |
20 |     pub admin_account: Account<'info, AdminAccount>,
   |                                       ^^^^^^^^^^^^ expected named lifetime parameter
   |
help: consider using the `'info` lifetime
   |
20 |     pub admin_account: Account<'info, AdminAccount<'info>>,
   |                                       ~~~~~~~~~~~~~~~~~~~

error[E0621]: explicit lifetime required in the type of `ctx`
  --> programs/legacy-sol/src/lib.rs:11:27
   |
11 |         admin_acc.admin = ctx.accounts.admin.unsigned_key();
   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ lifetime `'static` required

error[E0599]: no function or associated item named `default` found for struct `AdminAccount` in the current scope
  --> programs/legacy-sol/src/lib.rs:16:10
   |
16 | #[derive(Accounts)]
   |          ^^^^^^^^ function or associated item not found in `AdminAccount<'_>`
...
26 | pub struct AdminAccount<'info> {
   | ------------------------------ function or associated item `default` not found for this
   |
   = help: items from traits can only be used if the trait is implemented and in scope
   = note: the following trait defines an item `default`, perhaps you need to implement it:
           candidate #1: `Default`
   = note: this error originates in the derive macro `Accounts` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the trait bound `&anchor_lang::prelude::Pubkey: BorshDeserialize` is not satisfied
  --> programs/legacy-sol/src/lib.rs:25:1
   |
25 | #[account]
   | ^^^^^^^^^^ the trait `BorshDeserialize` is not implemented for `&anchor_lang::prelude::Pubkey`
   |
   = help: the following implementations were found:
             <anchor_lang::prelude::Pubkey as BorshDeserialize>
note: required because of the requirements on the impl of `BorshDeserialize` for `AdminAccount<'_>`
  --> programs/legacy-sol/src/lib.rs:25:1
   |
25 | #[account]
   | ^^^^^^^^^^
26 | pub struct AdminAccount<'info> {
   |            ^^^^^^^^^^^^^^^^^^^
note: required by `anchor_lang::AnchorDeserialize::deserialize`
  --> /home/spacemandev/.cargo/registry/src/github.com-1ecc6299db9ec823/borsh-0.9.1/src/de/mod.rs:31:5       
   |
31 |     fn deserialize(buf: &mut &[u8]) -> Result<Self>;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   = note: this error originates in the attribute macro `account` (in Nightly builds, run with -Z macro-backtrace for more info)

Some errors have detailed explanations: E0106, E0277, E0599, E0621.
For more information about an error, try `rustc --explain E0106`.
error: could not compile `legacy-sol` due to 4 previous errors
```
Just `Pubkey`
what is the datatype to store a pubkey in an account? trying to use "Signer" errors as Signer doesn't implement BorchDeserialize
Not within your rust program, no
Does that mint have a non-zero decimal setting?
Not sure what you mean there, I think javascript numbers are just regular doubles
Yeah, you can allocate extra space (you'll have to pay for though obviously)
Am I stupid or is there something somewhere centralised that continues to move this stuff
Hope someone here knows, I have a question around mechanisms like AMM's and a need for a constant execution/loop/trigger

> Given stateless nature of programs on Solana. What mechanism exists to move the layering of Fibonacci orders (as per lite paper in Raydium for example) around the price. Market participants can move price in such a way that previously set orders by AMM do not make any sense. Where is it documented how this is moved and through what mechanism?
Also a beginner, not sure if it needs to be exact, but what is the struct of your account? I am happy to try to math and see if I get a different answer 🙂
yeah it seems that the number of tokens being minted is greater than MAX_SAFE_INT, but is still less than u64 MAX
hmmm i thought that was the point of using `new spl.u64` though
the MAX_SAFE_INT limit might be the highest you can go
search up ES6 floating point standard. the specs and rounding should provide you with more details as to why its doing that
yoo i have a theory as to why you might have to peer into it more but mantissa with javascript is notoriously garbage and unintuitive. compiled languages like go, rust, any other language have a standard but js's floating point arithmetic doesnt follow that standard
from a solana program?
is there a way to query web APIs
Sorry to ask again, but trying to figure out how I can verify a mint is part of a collection and I want to read its metadata in my anchor program.
Any help or resources are greatly appreciated !
and no matter what value I compute I still get the size error which makes me think it requires exact, and I am mathing wrong 😅
just curious because I'm currently mathing to solve this for a quick test
does the space allocated to an account have to be exactly equal to the expected data, or can it be slightly larger?
the max value of u64 is `18446744073709551615`
But when I do this, it mints far less than that number of tokens:
```
await mint.splToken.mintTo(
   tokenAccount, 
   mint.authority.keypair, 
   [], 
   new spl.u64("18446744073709551615"),
);
```
<@!347689664855015424> thx
When filtering how I can find all accounts with some portion of memory >= a value or <= a value? I can get equals like this:
```
// This grabs the lamports at start, taking in the search value and producing a list
export const lamportsAtStartFilter = searchVal => ({
    memcmp: {
        offset: 8+ // Discriminator.
                32+ //Author
                8, //Timestamp
        bytes: bs58.encode(searchVal.toArrayLike(Buffer, 'le', 8)), 
    }
})
```
But, I can't figure out how to check if the 8 bytes represent a number that is greater than or less than the searchVal

Where I use the filter with this call:
```
const matchings = await program.value.account.matchingDeclaration.all(filters);
```
hm, but maybe it's problem, yes. because i have different description for this
it's just for debug, my program do anything
`tokenFrom` and `tokenFromAuthority` are both `user.publicKey`. Dont think thats what you want
I have a work around for now, but I'll have to come back to it later im sure
Thx for the suggestion, but that doesn't work either. The function I'm calling expects type to be `metaplex...::state::Creator`
i don't understand how i must in future create transaction for this program?
But get error: Error: 3007: The given account is not owned by the executing program
i try to test my program not with default wallet (program very basic, just some account and msg!). And try to send transaction like: const tx = await program.rpc.stake(
            new anchor.BN(5_000), {
                accounts: {
                    tokenAddr: mint.publicKey,
                    tokenFrom: user.publicKey,
                    tokenFromAuthority: user.publicKey,
                    tokenProgram: TOKEN_PROGRAM_ID,
                },
                signers: [user]
            });
fixed my program, but now having trouble passing through amount, any ideas?
```
const wallet = useWallet();

const housePubkey = new PublicKey('xxxxx');
const programId = new PublicKey('xxxxxx');


const callback = useCallback(async () => {

    let params = { amount: 1 };

    let dStruct = {
      index: 8,
      layout: struct([
        u32('instruction'),
        u64('amount'),
      ])
    };

    let data = Buffer.alloc(dStruct.layout.span);
    let layoutFields = Object.assign({instruction: dStruct.index}, params);
    dStruct.layout.encode(layoutFields, data);

    const transaction = new Transaction({feePayer: wallet.publicKey});
    const instruction = new TransactionInstruction({
      keys: [
        {pubkey:wallet.publicKey, isSigner:true, isWritable:true},
        {pubkey:housePubkey, isSigner:false, isWritable:false},
      ],
      programId: programId,
      data: data
    });

    transaction.add(instruction);
    transaction.recentBlockhash = (await connection.getRecentBlockhash()).blockhash;

    await wallet.signTransaction(transaction);

    const transactionHash = await sendAndConfirmRawTransaction(
      connection,
      transaction.serialize(),
    );

    alert(transactionHash)

}, [wallet, connection])
```
error
```
Uncaught (in promise) TypeError: src.toArrayLike is not a function
```
does anyone have any examples of reading metaplex account metadata into an anchor program?
or however it goes
https://github.com/metaplex-foundation/metaplex/blob/5b0a688af9f94373d03e8a74c9bbfdb4dd12d4eb/rust/token-metadata/program/src/state.rs#L259
```[{
  address: "pubkey",
  verified: true,
  share: 1,
}]```
can you try an array of objects in
And then check that it signed in whichever instructions require admin rights
Another way to do this is to just hardcode the admin's public key into your program
ah gotcha, so I'll probably make the init tx pass in an account that is set as "admin" and then allow new accounts to only be created if admin account is passed in as well to further transactions?
doesnt exist. instructions only have access to the accounts passed into them. so you can try to simulate it by asking the tx fee payer to pass in their account but you cant be sure its actually them cause u cant check it
U could try the transaction signer
what is the msg.sender equivalent for solana ?
ok, fixed 🙂
bump?
i renamed in all cases program to: agrostaking
<@!134416332509675520> now this work const program = anchor.workspace.agrostaking as Program<Agrostaking>; but program is undefined 😦 i checked paths and it's correct
That typescript error is unfortunately an anchor typescript bug, you can ignore it (or `// @ts-ignore ` it)
i have a ... warning? on a brand new anchor init, Cargo.toml is highlighted red in VS Code with the error "Failed to download `solana-frozen-abi v1.9.2`" 

also in my test file
```  const program = anchor.workspace.LegacySol as Program<LegacySol>;``` has an error that says "Property 'workspace' does not exist on type 'typeof import("C:/Users/spaceman/Projects/solana/legacy-sol/node_modules/@project-serum/anchor/dist/cjs/index")'.ts(2339)"

when i do anchor test, it runs perfectly fine and runs the test, so these errors aren't stopping me from doing anything, but would love to understand why they are there if anyone has a clue
<@!134416332509675520> thx, work 🙂
Yep
[programs.localnet]
agrostaking = "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"
<@!134416332509675520> this?
You have an underscore mismatch someplace, at any rate
Ah, I  wonder if you've got agrostaking, not agro_staking, in your Anchor.toml
i run anchor test --skip-deploy --provider.cluster=http://192.168.65.1:8899
https://gist.github.com/Agronomistech/d3958009a0ad94d640dccda0a50b0018
Can you show the full error?
has agro_staking.json file and: "version": "0.1.0",
  "name": "agro_staking",
  "instructions": [
What does your IDL look like? It lives in `target/idl`
which problem can be? i use a workspace: const program = anchor.workspace.AgroStaking as Program<AgroStaking>;
hello guys, i have a problem when try to test my program 😦 anchor build and anchor deploy worked but anchor test failed: Error: Error loading workspace IDL for agrostaking
On line 247 if that helps
That function is defined here: https://github.com/metaplex-foundation/metaplex/blob/master/rust/token-metadata/program/src/instruction.rs
I pass it to the `create-meatadata-accounts` instrcution
Yes
Where does it need to be exposed in the IDL? As an instruction argument or something?
How are you using that struct in your program?
Even when I redefined a struct with the same fields the compiler complained
line 259
Struct is defined here: https://github.com/metaplex-foundation/metaplex/blob/master/rust/token-metadata/program/src/state.rs
if it is you would just use like Vec<Pubkey> as a parameter in your rust code, and you pass an array of public keys ["key1","key2"] from the frontend
the creators field?
is it off this chart?
https://docs.metaplex.com/nft-standard#token-metadata-program
I need the type in order to call the functions properly
I'm writing a solana program that gonna use cpi with the metaplex programs
why do you have to export the struct to your frontend in the first place
Is there a simple-ish way to do this?
I'm trying to use the creator struct in the metaplex token metadata module
yes
OH AH THE IMPORTED ONES
? they should be?
Gm, I was wondering if there is a way to get structs/types imported from crates automatically included in your idl file?
Okay
Mm, not sure, think the installer will be smart enough to do the right thing
or it is okay to keep both the version
to uninstall the current version should I just delete the repo?
Though tbh I thought it was more like 1.8.11
okay
Apparently 1.9.2: https://docs.solana.com/cli/install-solana-cli-tools
okay , which is the stable version currently ?
At any rate, that solana cli is behind the cluster versions
New version of anchor doesn't work with it probably
earlier it used to work , about one month back
Think you need to upgrade your solana cli, yeah 😬
is there any way out without upgrading my solana cli?
how to solve this error? 
my solana cli version = 1.7.8


//////////////////////////////////////////////////////////////////////////////////////////

I think dynamic array is impossible for parameter in transaction.
what's the best way to get a pseudo random u8 ? recent blockhashes or slot hashes?
how to run a single test using the CLI?
single test using anchor: i tried on cli: anchor test -- -g 'mytestname" but it is passing the args to cargo bpf
Hi, I need to pass in accounts of another program into my program. Specifically, this one (but probably more from that file):

https://github.com/metaplex-foundation/metaplex/blob/master/rust/nft-candy-machine/src/lib.rs#L566

I copied the structs over manually into my lib.rs file but getting the following error:

```The given account is not owned by the executing program```

I'm assuming this is saying that my account doesn't own this "Config" account, which is being passed in. What would be the correct way to do this?
but you shouldnt have to modify anything if you add the "mut" option
hmm thats super weird... maybe theres some funky serialization stuff going on or so
have u tried giving it a named lifetime parameter? (also, thats a slice, not an array.)
it occurs an error because of 'users' arry.  #[program] -> expected named lifetime parameter
Hey, guys. Can I use array for parameter of anchor instruction?
```
pub fn getReward(ctx: Context<GetReward>, users: &[u32]) -> ...
```
so i was wondering if that was a requirement
odd, the only change I made to my program code to make tests pass was to remove a `mut` constraint
nope, it doesnt have to be, but can be
how should i handle the case where an account may be mutated in some cases but not in others (dependent on data in some of the other provided accounts)
does a mut constraint imply that the account _must_ be mutated?
https://tenor.com/view/the-simpsons-homer-simpson-good-bye-bye-no-gif-5173989
I owe this chat lots of debugging debt for this
Lmao
yes so it was in a hidden terminal in vscode
lol np. that explains the program logs
thank you for sanity checking
<@!161709591220977664> I'm so sorry
i had a test validator running
oh my god
are you running `anchor test`?
maybe this is an m1 mac bug?
no way
weird, just ran your program and worked fine for me
will look again in the morning 🙂 thanks all!
didnt work
I'll do that since I don't really need to store it
the only difference in the code is that you use _bump as a throwaway
yep
identical code 😦
did you also change it in Anchor.toml
Sorry missed pda part looking on my phone
yea that's right
doesn't a PDA not have a keypair?
its a PDA though
You need the account you’re creating to sign
yep :/
Even when not explicitly included
The wallet that pays is always signer 0
I thought my wallet signs this no matter what
can I use my wallet as the signer?
I can add a signer back
no signers in the client code, but i had added them previously
I just looked at your stack overflow
You have no signers in your client code?
yep
declare_id!("EespR7XYaCcPqNAZfuAdBFTsNGBoBgUJ65H5qH9Q8Ds1");
just to double check, EespR7XYaCcPqNAZfuAdBFTsNGBoBgUJ65H5qH9Q8Ds1  is your declare_id!() right
`9QbUfaFKL5jjYb6dcPRR3f3HjKcP2x8PND58uAJCvxnh` doesnt match any keys im using
```
Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account 
    Program EespR7XYaCcPqNAZfuAdBFTsNGBoBgUJ65H5qH9Q8Ds1 invoke [1]
    Program log: Instruction: Initialize
    9QbUfaFKL5jjYb6dcPRR3f3HjKcP2x8PND58uAJCvxnh's signer privilege escalated
    Program EespR7XYaCcPqNAZfuAdBFTsNGBoBgUJ65H5qH9Q8Ds1 consumed 3984 of 200000 compute units
    Program EespR7XYaCcPqNAZfuAdBFTsNGBoBgUJ65H5qH9Q8Ds1 failed: Cross-program invocation with unauthorized signer or writable account
```
What do your program logs say
ugh ok. thank you for helping! I'll take a look!
```
{
  provider_one: PublicKey {
    _bn: <BN: 6f34faa9dbed2e1e3f4a864f514355fe9301e3ebfe0c13dffe27f84612ddaec>
  },
  program_one: PublicKey {
    _bn: <BN: 6f34faa9dbed2e1e3f4a864f514355fe9301e3ebfe0c13dffe27f84612ddaec>
  }
}
```
BTW <@347689664855015424> I had a strange case where same method outside of program macro built fine but inside it complained about imports.
When I moved around the file structure it worked.
Is this expected?
ah then no clue, i have basically the same exact code as you :/ https://github.com/spacemandev-git/legacy-sol/blob/main/tests/01-setup.ts
I think you can block access to everyone in settings
and those keys match!
still same issue
ah
and provider should just be const provider = anchor.Provider.env()
Yea its probably a key issue- I have no other provider though
```
  // Configure the client to use the local cluster.
  anchor.setProvider(anchor.Provider.env());
  const program = anchor.workspace.Myprogram as Program<Myprogram>;
```
```ts
creator: provider.wallet.publicKey,
```
in your test code
without program infront of it
try provider.wallet.publicKey
oh
same error
yup
try doing bump=bump
maybe i should do bump = something?
deeply frustrating stuff :/
the previous code allowed any keypair, and i want to make base_account a singleton
Yep, I'm actually currently trying to make this a PDA
narrow it down to the PDA account or one of the others
if you use a regular keypair instead of the PDA do you still get the error?
no dice, still getting the error 😦
try replacing this part 
```
    #[account(address = system_program::ID)]
    pub system_program: AccountInfo<'info>,
```
with 
```rs
pub system_program: Program<'info, System>
```
thank you 🙂
one sec i'll take a look to see if i can spot anything obvious on your code
in my case it was cause my player seed for generating the PDA was different than the one anchor was using cause i forgot to pass in a parameter
I'm having this same problem- did you figure it out? Here's my stack overflow question.
https://stackoverflow.com/questions/70587929/anchor-error-when-trying-to-initialize-a-program-derived-account-pda
this solved a part of my problem 🙂
makes sense!

My mental model: 'one account' for the program is from EVM where the smart contract owns its tokens directly and its kind of embedded. I picture solana program as using disposable containers (accounts) as needed and generating those on the fly. Im writing something and have been using the user pubkey() as one of the seeds + ensure they are signing too. I am a noob though.
https://twitter.com/armaniferrante/status/1411589637760372737
https://twitter.com/armaniferrante/status/1411589639006154754

an old tweet from Armani that I'd like to make sure I understand. is the vulnerability:

- global PDA is `authority` of vault
- attacker calls my program with his account, my program does `invoke_signed`  CPI transfer, CPI checks pass because seeds are the same for everyone
-  is the implied solution to include the user's public key as a PDA seed, thereby the PDA is no longer global? and require the user to sign
What is the difference between having an access constraint inside an account (using has_one on top) vs. inside an instruction ?
For example in the increment counter instruction:
Im trying to define the context for one of my functions.
Anyone ever seen this error before?
Cheers <@!347689664855015424>
it's cause `init` will initialize `counter` as a rent-exempt account. For that the account needs some lamports. These lamports are provided by the payer. So the payer needs to be mutable
Oh wait, is it because they are paying with lamports and updating their account state? woops
For example in the anchor tutorial https://project-serum.github.io/anchor/tutorials/tutorial-2.html#defining-a-program why is the Create struct user mutable?
I get why functions that close accounts don't need mutable signers, but why do initialization functions? I don't understand why a signer ever needs to be mutable. I think I'm missing something important
dont know myself
hmmmm ok. that solves the bit about using pre-existing accounts. What about getting a proper `spl.Token` object from a given pubkey? (to interact with these pre-existing accounts)
torn down. but in your tests you can start a custom local validator with your required accounts loaded and then run `anchor test` with `--skip-local-validator`
Hey paul, do you know anything about this?
yup
so what happens when you're out of space? the tx for mutating the account fails?
you need to init with enough space for all your elements.accounts can not (yet) be resized
i am a little confused with how space works with dynamically allocated stuff like Vec. is there a way to check if the account has space available before trying to push a new value to it and then erroring for the user? or dynamically increasing the account size as new data comes in?
<@!501570363566587905> do you know any other solution for this other than using a `Vec`?
fuck yea, just compiled, thanks!
yes 🙂
it is. the error is telling you what to do!
i can implement it on my enum
oh but that's my enum
now it seems it wants Clone and that's not implemented for strings also maybe?
```rs
#[account]
pub struct Player{
    pub name: String,
    pub troop_cards: Vec<Troop>,
}

```
```
   Compiling legacy-sol v0.1.0 (/mnt/c/Users/spaceman/Projects/solana/legacy-sol/programs/legacy-sol)
error[E0277]: the trait bound `TroopClass: Clone` is not satisfied
   --> programs/legacy-sol/src/account.rs:27:5
    |
22  | #[account]
    | ---------- in this procedural macro expansion
...
27  |     pub class: TroopClass,
    |     ^^^^^^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `TroopClass`
    |
note: required by `clone`
    = note: this error originates in the derive macro `Clone` (in Nightly builds, run with -Z macro-backtrace for more info)
```
It's because of the `[Troop;6]`. Borsh (the serialization library anchor uses) wants arrays to be copy. but this array cant be copy because Troop isnt copy. and it cant be because string isnt copy
oh, i read a tutorials twice 😦 but a lot of information not founded, thx
it would be best if you just read the entire tutorial once which explains this. `user` is not found in scope because you probably didnt add a user field to your struct
ok so the problem is the `[Troop;6]` needs to be `Copy` but cannot be because `Troop` has a String field. This is interesting. Have you tried using a `Vec` for `troop_cards`
hm, i added this annotation #[account(init, payer = user, space = 64)] but get error: user - ^^^^ not found in this scope
yea looking back, using strings worked in my other accounts, so dunno why this account is acting up. I wonder if it has to do with the enum?
thx
https://project-serum.github.io/anchor/tutorials/tutorial-1.html#defining-a-program
how i can initialize account? in my program or client? i think i need to create a pda for this
<@!849035945487630337> https://discord.com/channels/889577356681945098/889702325231427584/928037853789835264
```rs
#[account]
pub struct Player{
    pub name: String,
    pub troop_cards: [Troop;6],
}

#[account]
pub struct Troop{
    pub name: String,
    pub description: String,
    pub link: String,
    pub class: TroopClass,
    pub power: u8,
    pub mod_inf: i8,
    pub mod_armor: i8,
    pub mod_air: i8,
}

#[derive(AnchorSerialize, AnchorDeserialize)]
pub enum TroopClass {
    Infantry,
    Armor,
    Aircraft
}

impl Default for TroopClass {
    fn default() -> Self { TroopClass::Infantry }
}
```

error:

```
error[E0277]: the trait bound `Troop: std::marker::Copy` is not satisfied
  --> programs/legacy-sol/src/account.rs:17:1
   |
17 | #[account]
   | ^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `Troop`
   |
   = note: required because of the requirements on the impl of `BorshDeserialize` for `[Troop; 6]`
   = help: see issue #48214
   = help: add `#![feature(trivial_bounds)]` to the crate attributes to enable
   = note: this error originates in the derive macro `AnchorDeserialize` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0277`.
error: could not compile `legacy-sol` due to previous error
```
it's possible. what does your code look like?
hi, maybe you can help me with Error: 3012: The program expected this account to be already initialized?
it seems that it's not possible to use strings with account structs? getting a "std::marker::Copy" is not implemented for MyStruct (assuming its cause String attributes don't implement copy being dynamic sized). what would be my way around this?
if theyre changed, they need to be mutable, if they just sign things, they dont
```#[derive(Accounts)]
pub struct Stake<'info> {
    pub token_addr: Account<'info, Mint>, // token mint address (agte mint, nft mint)
    #[account(mut)]
    //the token account to withdraw from
    pub token_from: Account<'info, TokenAccount>, // from which user associated account we can transfer
    //the authority allowed to transfer from token_from
    pub staking: Account<'info, StakeInfo>,
    pub staking_account: Account<'info, TokenAccount>, // when we send money
    pub token_from_authority: Signer<'info>,  // user who will stake
    pub token_program: Program<'info, Token>,  //  address for token program for transfer
}```
Why are some Signers mutable (#[account(mut)] and some not?
i have this problem too Error: 3012: The program expected this account to be already initialized
hi, have you resolved your problem?
When I try running the command with my keypair, I get an error "client.js not found"
please do not use @ everyone, do not crosspost, and do not post in # anchor-contributors. it's a channel for anchor contributors.

Your error means that youre trying to access an account that has not yet been initialized. So you should check whether the account thats causing the error has been initialized before
I'm currently working through the minimal example, specifically generating a client section
Hi! Noob question, but how do I run the client?
Hello, 
I am working on devnet. I have created token account using solana as a mint.
I have also airdropped enough SOL on my wallet and the created token account. But when i try to transfer i get insufficient fund error. 
What can i do to get balance on my token account.
"You may not realize that program data accounts (the accounts that store the executable byte-code for an on-chain program) can also be closed. Note however, that this does not mean that program accounts can be closed (those are immutable and can never be reclaimed, but it's fine they're pretty small). It's also important to keep in mind that once program data accounts are deleted, they can never be recreated for an existing program."
buffers are temporary accounts
is different than closing a program data account
that returns something empty, i'm pretty sure closing buffers
--buffers instead of --programs?
I'm running version 1.8.3 which I think is pretty recent??
but, it says "found argument --programs which wasn't expected"
this link says `solana program close -u mainnet-beta --programs --keypair ./admin_key.json` should work
specifically: https://jstarry.notion.site/Program-deploys-29780c48794c47308d5f138074dd9838#561f8e76208a46b8963092adabab2256
not working
solana program close
and i'd like to close the account & get my funds back
for a program
I have one on production (https://explorer.solana.com/address/3sVuWzrMzwtU6bRWFg8KL3uh9CR7tC41PaUMZYBSPSRq)
Is there a way to close a program executable data account?
now i am getting this message in terminal
Do you know about this issue ?
Error: 3003: Failed to deserialize the account
Thanks for reply
Is it possible to use a pda address as a seed to generate another pda address? running into some discriminator issues, unsure if that could be the cause
did you initialize pool_token_account in your tests?
Hi @everyone 
I am getting this error when i run **anchor test**
How can i fix this issue
can anchor test can make use of existing accounts on the cluster? or is everything that's done during test in some transient state that is always torn down on completion?

context: My program makes use of a few Mints which are statically defined in the program code, like this: ```const MINTS: [MintInfo; 1] = [
    MintInfo{ id: 1, mint: "EWWFTfiHWkSUDkNWvU4u7PuxCLAL2bEki57aLw9iVzzW"}
];```
These mints are not modifiable, so I can't swap them out for bogus mints during my test cases.

As a result I am running into confusion when trying to write the test cases. I can't tell if I'm able to do a call like `getSplToken("EWWFTfiHWkSUDkNWvU4u7PuxCLAL2bEki57aLw9iVzzW")` to set up a proper `spl.Token` object for testing. I can obviously define `mint_address` as a string or a `BN` in my test code, but utilizing it as an `spl.Token` is tripping me up.
sorry for question, how i can check in program which tokens and how many exist in pda account?
seems like I must have `handler` and `Accounts` in same file/mod of it blows up.
Solution to `3`: https://github.com/solana-labs/solana-program-library/blob/ea354ab358021aa08f774e2d4028b33ec56d4180/token/program/src/error.rs#L16
Where can I find what custom error `0x0` and `3` is?
empty string. (dont use `Default` to calculate space on strucst when you use types with dynamic sizes)
What does `#[program]` do that can screw up the imports?
Error:```error[E0432]: unresolved import `crate`
  --> programs/office-house/src/lib.rs:21:1
   |
21 | #[program]
   | ^^^^^^^^^^
   | |
   | unresolved import
   | help: a similar path exists: `crate::office_house_structs::withdraw_from_fee::__client_accounts_withdraw_from_fee`
   |
```
```
#[program]
pub mod office_house {
    use super::*;
    pub fn initialize(_ctx: Context<Initialize>) -> ProgramResult {
        Ok(())
    }

    pub fn doesnt_work_withdraw_from_fee<'info>(
        ctx: Context<'_, '_, '_, 'info, WithdrawFromFee<'info>>,
        amount: u64,
    ) -> ProgramResult {
        withdraw_from_fee(ctx, amount)
    }
}
```
I'm unable to build, took the only method I have outside the `#[program]` macro and it builds.
(and can it be changed after the account has been created?)
what does derive Default do when one of the struct components is a string? what's the default derivation of a string?


//////////////////////////////////////////////////////////////////////////////////////////

aha yes, using toArrayLike() was the missing piece!!
Always heartwarming to see noobs learning how to Solana
this is my first anchor program <@!347689664855015424>, its awsome 🙂
`ctx.program_id`
do i have the program id somewhere as an argument?
actually you could just print the the actual bytes and see the difference. Ive done that for you -> the rust code returns 8 bytes `[0,...,0]`.
 toBuffer returns a single byte `[0]`.  use `a.toArrayLike(Buffer, endian, length)` to `BN` instead
nah, it's not the string, i reduced it down to just 
```rs
let (pda2, _bmp2) = Pubkey::find_program_address(&[0_i64.to_be_bytes().as_ref()], ctx.program_id);
```
which gives: 
```
CqXarEYx6tvpwASk3ViCfWob4DeBxnK86zt2g63dU5P
```

and 
```ts
const zPda = await getPDA([new anchor.BN(0).toBuffer()], program.programId);
```
which gives
```
44pjoCWqimmXwWMq5DcxGSVNj8m6hjJqyXENHWPM8mBp
```

so it's definetely with the difference in how BN is being used here i just don't know what other thing to do about it
exactly!!!! totally agree!
https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo/src/lib.rs
Is "6" standard number of decimal places on a token? It seems that both USDT and USDC have 6 decimals. But I saw online that 9 was the standard
Hey guys!
I have a need to create a script on Anchorpy which creates multisig with two accounts, let's say created in Phantom, then I want to send from one account SOL to another by signing this transaction with multisig. 
That is, in order to send tokens both receiving and sending parties must agree. How do I need to change the Rust code for this?
I tried just substituting in Anchorpy a pubkey that wasn't created in the python function, but I got an error.
any examples of creating a token account with a pda?
Try this https://blog.chain.link/how-to-build-and-deploy-a-solana-smart-contract/
how do I call my anchor program with CPI? I'm looking at this example https://project-serum.github.io/anchor/tutorials/tutorial-3.html#defining-a-puppet-master-program but the cpi module is not there in the program crate.
I just remembered I think you have to do `Buffer.from(anchor.utils.bytes.utf8.encode(gameId))`
Admittedly I’m not too sure if this structure might make the rent expensive… is there a more economic way to do it?
Hi, I'm wanting to make a kind of ToDo list program where a ToDo Item can be created and I'd also like there to be a Project structure that holds a list of ToDo items.

Is the structure I'm looking for something like this -?

```rust
#[account]
pub struct ToDoItem {
    pub authority: Pubkey,
    pub name: String,
    pub id: String,
    pub is_completed: bool,
    pub color: String,
    pub assignee: Pubkey,
}

#[account]
pub struct Project {
    pub authority: Pubkey,
    pub tasks_data: Vec<u32>,
}
```
or I want Anchor will clarify which account's constraint is violated.
Let's use 'if' statement and use custom error to clarify mismatching errors.
It makes me difficult to find real error and where error comes from.
If constraint mismatches, it only shows 'A raw constraint was violated'
I suggest that let's not often use constraint attribute.
Hey, guys.
anchor build says

```To deploy this program:
  $ solana program deploy /Users/dig/Documents/dev/solana/solana-splits/splits/target/deploy/splits.so
The program address will default to this keypair (override with --program-id):
  /Users/dig/Documents/dev/solana/solana-splits/splits/target/deploy/splits-keypair.json```
I am deploying this program for the first time
could be one of those, would check these first
when you do anchor build it gives you a program id, you need to update this in Anchor.toml and declare_id!
did you modify the program-id properly?
I created a fresh keypair to deploy my program on devnet using anchor but it throws this error

`Error: Account 4m1eWNndyhE8eJyQcde8MYMV3tzP4wS5xsARZQTHAKpo is not an upgradeable program or already in use`
Hi! Is it possible to define array of accounts with anchor?
anyone knows how I can show failed transaction logs?
turns out its on the bottom of the solana explorer for explorer https://explorer.solana.com/tx/2tibFtG5tc4fNVMHV2J9dsyeE1cLPPJYgorkZ1Z2V5fJEPZ8xXSMKYtwDkKirURtZBBTUjsjZ4HaSTJ3JVp3me5B?cluster=devnet
doe anyone know where I can see the output of the `msg!` macro on Devnet?
doesnt use anchor but logic should be analogous
watched it a long time back
have you checked this video? https://www.youtube.com/watch?v=g5A5QKh15pQ&ab_channel=Chainlink
hmm good question....
If someone have already been through that type of error 🙂
To import a library I just need to add a a line in [dependencies] no ? I saw in a tutorial that they added 

chainlink = { git = "https://github.com/smartcontractkit/chainlink-solana", package = "chainlink-solana", features = ["no-entrypoint"] }

I’ve done the same thing but when I anchor build —> error on the image
anchor supports that as well. create acc in previous ix and then use `#[account(zero)]`
let me know when you find the answer, theres a tutorial on it during the Ignition hackathon
never used it before, but it seems as simple as just importing a library and adding it as one of the context accounts
Do you know how ? Does it seems complicated ?
Thanks for your answer ! Know I need to learn how to call chainlink with anchor 😅
Yeah I was just looking for chainlink !
theres chainlink oracles that generate random numbers etc. have a look at those. otherwise, not sure if anchor supports randomness, at least 1 month ago they didnt
welcome to anchor!
xD what happened haha
Hey guys ! Is someone know how to use random in a smart contract with Anchor ? 😀
is this normal...
i feel like i have no idea what i am doing, though i have just begun
ruminations of a starbucks barista
yo dont listen to a single word I just said I messed up my js test
at least i never defined anything as an associated token account in the Context, while generating associated token accounts as a pass on
:)
ok thanks chief
also in terms of serializations, they should be the same though
or do you mean the init functionality itself?
theyre not the same necessarily. if you re-generate associated token accounts multiple times it will always return the same (single) address. this is not true for token accounts
if you init them
do you know if associated token accounts and token accounts are the same
its proper syntax can confirm
token::mint references a property in the implementation, not sure if this is proper syntax..
maybe you can do it like this, adding constraints?
``` 
        constraint = bond_pool_redeemable_mint.mint_authority == COption::Some(bond_pool_account.key()),
```
hmm im not very familiar with this format, not sure if ive seen this before
I want to make self owned TokenAccounts
i guess i know the error but not sure how to resolve it
the program one works, the cli one doesnt
another was a mint from the cli
i derived 2 pda's during testing, 1 was a mint that the program created and owns

or did you create the token account? can you post some code?
how did you create the TokenAccount?
when I use a mint my program owns, it works
who i am assuming the authority is the token_program
the mint is created from cli
but am getting "signer's priviledge escalated"
I am trying to use the token:: macros to instantiate a TokenAccount
do i need to own the mint if I want to use token:: macros?
try rubbing it a little bit
when i want to retrieve my created PDA account base_account, i do:
```
#[derive(Accounts)]
pub struct incrementValue<'info> {
    #[account(mut)]
    pub base_account: Account<'info, BaseAccount>,
    #[account(address = system_program::ID)]
    pub system_program: AccountInfo<'info>,
}
```


and then
```
  const [baseAccountPDA, baseAccountPDABump] = await anchor.web3.PublicKey.findProgramAddress(
      [Buffer.from("seed")],
      program.programId
    );

    await program.rpc.incrementValue(baseAccountPDABump, {
      accounts: {
        baseAccount: baseAccountPDA,
        systemProgram: anchor.web3.SystemProgram.programId,
      }
    });
```

? everytime I try to do this I get:
```
Transaction simulation failed: Error processing Instruction 0: instruction modified the program id of an account 
    Program EespR7XYaCcPqNAZfuAdBFTsNGBoBgUJ65H5qH9Q8Ds1 invoke [1]
    Program log: Instruction: NameFloppydingdong
    Program EespR7XYaCcPqNAZfuAdBFTsNGBoBgUJ65H5qH9Q8Ds1 consumed 4212 of 200000 compute units
    Program EespR7XYaCcPqNAZfuAdBFTsNGBoBgUJ65H5qH9Q8Ds1 success
    failed to verify account 11111111111111111111111111111111: instruction modified the program id of an account
```
back to solidity lol
no luck
ok guys, i give up. I've tried to pass in an account not owned by my program into an anchor program for 3 days
<@!161709591220977664> was running into this
I think I saw this before when using declare!{} in more than one place
It almost feels like I need a way to just say "look Anchor, please, god, please, here is the owner of this account, I know Im not the owner"
yep, I can see it in the explorer
coincidentally my issue is because i'm using 1.8.5
I have the same issue :/ im on an m1 and my issue is caused by a version mismatch
If anyone else runs into this: it was Solana tools, needed 1.9.2, the start guide at https://project-serum.github.io/anchor/getting-started/installation.html#install-rust gives you 1.8.0, so just change the command to `sh -c "$(curl -sSfL https://release.solana.com/v1.9.2/install)"`
It was Solana tools, needed v1.9.2
thats def a cargo prob tho
should give u more info
I think
from that dir, and --verbose
run ` cargo +bpf build --target bpfel-unknown-unknown --release`
Nope, intel 10th gen
Any idea why I'm seeing this when trying to pass a PDA key?

```
Transaction simulation failed: Error processing Instruction 0: instruction modified the program id of an account 
    Program EespR7XYaCcPqNAZfuAdBFTsNGBoBgUJ65H5qH9Q8Ds1 invoke [1]
    Program log: Instruction: NameFloppydingdong
    Program 11111111111111111111111111111111 invoke [2]
    Program 11111111111111111111111111111111 success
    Program EespR7XYaCcPqNAZfuAdBFTsNGBoBgUJ65H5qH9Q8Ds1 consumed 12095 of 200000 compute units
    Program EespR7XYaCcPqNAZfuAdBFTsNGBoBgUJ65H5qH9Q8Ds1 success
    failed to verify account U8deX75Km847phPR7JqgDxhxYfjLZgkH7aRCaWxP3JB: instruction modified the program id of an account
```
Is this a Solana thing or an anchor thing, or a cargo thing? ```BPF SDK: /home/fish/.local/share/solana/install/releases/1.8.0/solana-release/bin/sdk/bpf
Running: rustup toolchain list -v
Running: cargo +bpf build --target bpfel-unknown-unknown --release
error: failed to download `solana-frozen-abi-macro v1.9.2`

Caused by:
  unable to get packages from source

Caused by:
  failed to parse manifest at `/home/fish/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-frozen-abi-macro-1.9.2/Cargo.toml`

Caused by:
  feature `edition2021` is required```
yes
Hi guys, I'm not seeing anything under .anchor/program-logs. Is there anything I could be missing. 

I'm running a local_validator and running anchor test with `anchor test --skip-local-validator`. I am getting a `Error: No such file or directory (os error 2)` at the end of the test run

Update: This is after removing all .DS_Store files also
hmm you're sure  it's initialized? you can see it in explorer?
yep, running a local test validator with a --clone option, to clone one from devnet
what's your client code doing? is the `Config` account initialized? sometimes the error message indicates something else wrong
but yea.. starting to lose hope 😦
(i.e. the 'nft_candy_machine', from above)
which is fine, i know it's not the owner. the owner is Metaplex Candy Machine program
think it's saying "'foo' program isnt the owner of the 'Config' account"
oh i see now
right so, in another program, im doing:

```rust
use nft_candy_machine::Config;

#[program]
pub mod foo {
    use super::*;
    pub fn initialize(ctx: Context<MyContext>) -> ProgramResult {
        Ok(())
    }
}

#[derive(Accounts)]
pub struct MyContext<'info> {
    config: Account<'info, Config>,
}
```


^ That will fail
i'm confused, the code you linked is in Anchor
been asking around for 4 days...
it's practically impossible with Anchor
how would you take this as an input in a vanilla solana program:

https://github.com/metaplex-foundation/metaplex/blob/master/rust/nft-candy-machine/src/lib.rs#L566
i think the easist way to frame this is
hard to debug without code... do you have more program logs?
how do programs read accounts they don't own ... is this not possible? I'm sure it is, so I'm guessing it's just complicated with Anchor?
i just need to read the data of an account that another program owns
So i guess the issue is, I know im not the owner and will never be
the error message sounds like you should check that account's  `owner` is your `program_id`
pub user: Signer<'info>,
implies a singature?
there's an `AccountInfo` type or you can put `Pubkey` in a struct
pub destination: Account<'info, System>,
no signature
is the a way to delcare an account that is just a pubkey?
thats true
trust what?  it doesn't guarantee it can find all the bugs
but then i have to trust them 😉  just as i trust you. more philosophical than practical.
context being, I'm trying to take an account declared/owned by another program as input
use https://twitter.com/soteria_bc
sorry to bug about this again, but still having issues with `The given account is not owned by the executing program` error, and would love some help 😦

Importing an account struct form another local program. However, when i try to use that account in an input context, I get that error. 

Something like:

program_a/lib.rs:
```rust

#[account]
#[derive(Default)]
pub struct Config {
    pub authority: Pubkey,
    pub data: ConfigData,
}
```

program_b/lib.rs:

```rust
#[derive(Accounts)]
pub struct MyContext<'info> {
    config: Account<'info, Config>,
}
```
lol do you know of anything a bit shorter and more concise? im quite new to this so its easy to get lost 😄
i've been thinking a lot about this. let's say down the line... how is the auditing going to actually work in practice? i can't imagine every dev auditing... is it fair to analogize to software packaging
the amm i just posted seems to handle all the token apis
I'm having a hard time finding good example contracts
I
Does anyone know of any contracts that can be used to deposit / withdraw tokens into a pool?
https://github.com/ironaddicteddog/anchor-amm/blob/master/programs/amm/src/lib.rs
this is pretty cool
yep, makes sense
less code in the to try to audit
just preferences i guess
in this case, its ok, since any CPI failures abort the whole transaction
hm, i do prefer flat over nested. re: failure, i suppose the onus to properly handle the error case falls on the CPI program writer (vs. client). more broadly, designing good APIs
well, easier to reason about the control flow of the program, since the failure to allocate is pulled outside
not to be annoying but what makes it cleaner? i'm still thinking through CPI vs. client doing it
haha, yea, typically thats "cleaner", but def a pia for devs
lol as in the client should be the one to allocate? i'm new to all this
armani pissing all over my caller allocated semantics
got it
https://github.com/project-serum/anchor/blob/master/lang/syn/src/codegen/accounts/constraints.rs#L638
yep CPI
so it calls it from within the ix via a cpi?
macro's `init` attribute implicitly does  `system_program::CreateAccount` for you
why would i pass system as an acccount param
is it passed as an argument?
what is system for though?
i think it's as paulx guessed, system_program should be included in your `Initialize` struct
```
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod token_omnibus {
    use super::*;
    pub fn initialize(_ctx: Context<Initialize>, data: SHA256) -> ProgramResult {
        Ok(())
    }
}

type SHA256 = [u8;32];

#[account]
struct AccountSet {
    root: SHA256,
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = account_set, space = 32)]
    pub account_set: Account<'info, AccountSet>,
}
```
i thought macro use was deprecated a while ago
you can do Vec<Pubkey> and then use them as seeds yes. having them in your ix obv means you cant write or read from the accs cause theyre just pubkeys, not accs
`pub system_program: Program<'info, System>`
that requires the system program to be declared in the struct as an account too
youre probably using the `init` constraint in your code somewhere right?
not in user code that i know of
is there a macro use somewhere?
i'm using stable
= note: this error originates in the derive macro `Accounts` (in Nightly builds, run with -Z macro-backtrace for more info)
do i need to use nightly?
have that
`use anchor_lang::prelude::*`
do i need a user macro somewhere?

```
   Compiling token-omnibus v0.1.0 (/Users/aeyakovenko/token-omnibus/programs/token-omnibus)
error[E0425]: cannot find value `system_program` in this scope
  --> programs/token-omnibus/src/lib.rs:20:10
   |
20 | #[derive(Accounts)]
   |          ^^^^^^^^ not found in this scope
```
or some type of manipulation on the vector that ensures the result is unique to only that vector, to keep the pda unique as well.
I only attempted to pass in a Vec<Accounts> so that when creating a pda, I could do something like this: seeds=[PREFIX.as_bytes(), *vector here*]
Would I be able to create a PDA using their addresses as seeds as well?
anchor currently does not support Vec<Accounts>(it may soon). But you could pass them in as a vec in your instruction data
log every single argument to that function individually is all I can suggest. from both the rust and ts function
but i'm unsure what needs to change
using BN
i think the problem is with typescript and how i'm doing the i64 to buffer
not a pubkey
its a random string
its
this is assuming that `gameId` is a pubkey in string form, not just any string
try `(new PublicKey(gameId)).toBuffer()`
I'm trying to create a pda, using a prefix + an arbitrary colletion of publickeys . I'm getting an error though: `unresolved import of __client_accounts_vec use of undeclared crate or module __client_accounts_vec`

Here's the code snippet
```#[derive(Accounts)]
#[instruction(bump: u8, share_list: Vec<u32>)]
pub struct Initialize<'info> {
    alice: Vec<UncheckedAccount<'info>>,
    bob: UncheckedAccount<'info>,

    #[account(init, seeds=[PREFIX.as_bytes(), alice.key().as_ref(), bob.key().as_ref()]```
My question is: Is there a way to store a collection of accounts in the struct so that I may reference them to create a pda using a prefix + each public key in that collection of accounts?

In the usual working code , alice is of type `UncheckedAccount<'info>` and not ``Vec<UncheckedAccount<`info>>``
gameid is a string, not a pubkey unfortunely
its just a wrapper
```ts
export const getPDA = async (accBuf: Buffer[], programId: anchor.web3.PublicKey) => {
  const [acc, accbmp] = await anchor.web3.PublicKey.findProgramAddress(accBuf, programId)
  return {account: acc, bump: accbmp};
}
```
also, if gameId is a `Pubkey` you can call `gameId.toBuffer()`
what does `getPDA` do?
this code 
```rs
let (pda, _bmp_seed) = Pubkey::find_program_address(&[id.as_ref(), 0_i64.to_be_bytes().as_ref(), 0_i64.to_be_bytes().as_ref()], ctx.program_id);
``` 
produces this as the pda: 
```
39erDrYUenMRLNRj5oDAVTacSpPL8vfzgtNaHbhiaXp6
```

while this code:
```ts
  const startLoc = await getPDA([Buffer.from(gameId), new anchor.BN(0).toBuffer(), new anchor.BN(0).toBuffer()], program.programId)
```
produces this as a PDA
```
FdCGugQzCrwX3FkReMST5kS21ogWFQoGjPG2QSYtwLMp
```

how can i make them produce the same PDA?
it works for me
1.8.11 works?
anchor uses solana 1.8.5 currently, looks like youre using 1.8.0, maybe thats causing problems? also is your solana-install up to date?
I see, it doesn't seem like what I want is available on crates.io. I'll try the metaplex discord but they're usually not as helpful 😦
usually all rust programs are in a crate. when you create a new project with cargo new, you create a crate. you can import a crate easily when its available on crates.io. but whats the best way to import metaplex programs is a question for the metaplex discord
did i miss a dependency somewhere?

aeyakovenko<@!439210198142550016>s-MBP-2 src % anchor build    
BPF SDK: /Users/aeyakovenko/.local/share/solana/install/releases/1.8.0/solana-release/bin/sdk/bpf
Running: rustup toolchain list -v
Running: cargo +bpf build --target bpfel-unknown-unknown --release
error: failed to download `solana-frozen-abi v1.9.3`
im getting this error while using `anchor deploy`

`Error: Deploying program failed: Error processing Instruction 1: invalid account data for instruction`
forgive me, as I'm really new to rust but, are all repos setup as crates? e.g. Is metaplex setup to be imported as a crate, like this one(https://github.com/metaplex-foundation/metaplex/tree/master/rust/nft-candy-machine)
import the crate and the type instead of redefining it locally
want to bump this... wish I didn't have to ask for help here, but still stuck 😦
https://alexgrinman.com/posts/building-decentralized-identity-verification-system-on-solana/ guys good tutorial with anchor by <@!794953333302493184>  check it out !
I tried
```
const pp = borsh.deserialize(
  ProgramAccountInfoSchema,
  ProgramAccountInfo,
  kk!.account.data
)
```
 And it emits this error: `Expected buffer length 1000 isn't within bounds: account_pubkey`
Is it possible to handle this?
I wanna parse data into particular schema
Hello, I fetched data from data account using getProgramAccounts.
it contains 
```
account:{data: Buffer(160), executable: false, lamports: 2004480, owner: PublicKey, rentEpoch: 244}
data:Buffer(160) [118, 195, 243, 217, 229, 128, 62, 121, 1, 0, 0, 0, 197, 61, 214, 2, 232, 3, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 32, 0, 0, 0, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 32, 0, 0, 0, …]
executable:false
lamports:2004480
owner:PublicKey {_bn: BN}
rentEpoch:244
__proto__:Object
pubkey:PublicKey {_bn: BN}
_bn:BN {negative: 0, words: Array(11), length: 10, red: null}
```
 this structure, and I'd like to parse that data into class in ts.
Question, can an ix take in a signature (from a signed message) and create a tx to transfer sol or spl without a frontend confirmation /approval ?
hey folks! im getting this error while deploying: 
```Error: Program's authority Some(7H2GHz1DkvFiofsio5sbSZPoMHEJR5G6RTteEi2hQa32) does not match authority provided 8JKBvGyW38gnpQeQ8sTg3acKpWH11tZHHYLFVnigFUqg```
i dont understand why it exists when every anchor build generates a new keypair
when you call the genesis hash, does that call the first block from the cluster?
i could make an account, borrow lamports and then close it to the system account, that seems super janky tho
sorry for necro, but can a program owned account send sol via borrow to a system account
I need to pass in 20 accounts into a transaction. Will that cause problems?
neither, just want to read some of the data in the account
what are you doing with it in your instructions? are you passing it in as mutable or as a signer?
already done in the next release
would love some help/tips/explanations on this 🙏
if you decide to keep `init_if_needed` for associated_token_accounts, could you make it so that the `token::mint` and `token::authority` parameters check constraints? (In the same way as `token::mint` and `token::authority` check constraints when we don't use `init_if_needed`)
But yeah I don't think it'll hurt to have some kind of warning, or to only have it enabled for ATAs
<:wewbama:695038269632675853>
Associated token accounts is all I've used it for so far
Perhaps we should disable it for everything except associated token accounts.
Yea exactly
It's ok to use it for this use case  init_if_needed. But generally it's a footgun.
Ah, reinitialisation attacks

Why are we not supposed to use `init_if_needed`? <:sweatingman:599601488095870979>
I have a `withdraw` instruction that deposits to an associated token account `token_account`. The problem is, I don't know if `token_account` exists, and I know we're not supposed to use `init_if_needed`. What's the alternative?


//////////////////////////////////////////////////////////////////////////////////////////

hi...
when i run anchor test its shoing this error
Program failed to complete: Access violation in stack frame 3 at address 0x200003dd0 of size 8 by instruction #10737
Thank you for the links <@!915682383905316864> <@!912046857000194158> !
How do I upgrade my project from anchor 0.18.2 to 0.20.0 ?
I downloaded anchor version 0.20.0 globally
I tried running cargo upgrade, which did stuff, but my `Cargo.toml` file is the same
https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html
https://doc.rust-lang.org/rust-by-example/scope/lifetime.html
theres great docs on the rust websitr
Is there any documentation to read further about it? Obviously when I query google I get nowhere since the term info is so generic 😅  So it's called a Rust lifetime?
Tangentially, the borrow checker is the part of the compiler that guarantees that your code is safe through ownership checks.
a protocol that has random chance involved and which needs to ensure the user can't "game" their own chances due to a psuedo-random generation method being used (e.g. something keyed off timestamp+userkey or something).  need verifiable randomness for this reason
I don't know the complete detail of **why** it is needed where it is needed, but **what** it is a lifetime. It is a Rust concept which is needed in certain cases when the *borrow checker* cannot work out some variable scopes (lifetimes) on its own. Devs then need to help it by specifying explicit lifetimes like `<'info>`.
Can anyone explain what <'info> is? Seems extremely basic, but I'm not understanding its function and see it everywhere
thanks ssj 👌 👌 👌
can anyone recommend a good place to look over an anchor smart contract being implemented to next.js/typescript stack ? Trying to learn rn
although with `Box` now it might not be needed actually (?) <a:Hmmmm:695129200260153375>
trick with anchor is to use `remaining_accounts` to pass accounts
lets you pass more than you can with only using accounts struct
just keep optimizing till you can make it work <a:Hmmmm:695129200260153375>
u cant afaik
How do I see how much stack space and heap space my txn used?
got the ans just had to update the solana-cli
Hey, not an Anchor question, but I'm triying to set a modal wallet conection gokiprotocol/walletkit. Whenever i try to import { WalletKitProvider } from "@gokiprotocol/walletkit"; on my React app i get the following error
"Attempted import error: 'SolletWalletAdapter' is not exported from '@solana/wallet-adapter-sollet' (imported as 'SolletWalletAdapter')."

Does anyone knows a solution to this?
no effect
also tried adding it in my manifest  Cargo.toml file
tried updating rust
how do i remove the cargo-feature=[edition2021] error from my project
Does anyone know of any public Anchor repos, basically a complete project, that use the Governance library?
yea, except this one lets you deposit tokens back
How do I check how much stack space and heap space my instruction used?
now I have another question, how do I make a gif?
I have already done it and installed it
go inside one of the directories <@!519625217098907669> metaplex-master for example then try running npm install
no, you should have a package.json not a package-lock.json
are u talking about that package? <@!800894271737561121>
Is this similar to https://github.com/saber-hq/merkle-distributor ?

i only have this
yes I think the error is that it cant find a package.json which is the file it uses to find the dependencies to install, are you in a folder that contains a package.json that you want to install dependencies for?
I have uninstalled nodejs, I have reinstalled it, I have restarted but nothing, I can't perform that command

and the first command is npm install but but I got this
okay im explain myself better, im doing with windows
there are a few examples under tests/
`pub type SHA256 = [u8; 32];` this might not be supported in this form yet 😒
https://github.com/project-serum/anchor/blob/master/tests/escrow/tests/escrow.ts#L90-L92
You mean instruction data like this?
Do you mean to run *** npm init -y ***

Hello can anyone help me with this?
how can i do a gif NFT?
I have a problem when creating the metadata
Hello
i was trying to hash a value but i am getting this err while deploying...i used (anchor_lang::solana_program::blake3::hash) for hashing
Hey, can you describe your use case further?
any clue <@!134416332509675520> ser
How burning works for both NFT and FT tokens. 
And can we make a Solana program for it, where we send some tokens and it'll burn?
https://discord.com/channels/889577356681945098/889577399308656662/924836504193368085
https://discord.com/channels/889577356681945098/889577399308656662/924946007639359488
You can refer answers in development channel.
not yet https://github.com/project-serum/anchor/issues/455
though they could def be added https://github.com/project-serum/anchor/blob/v0.19.0/lang/syn/src/idl/mod.rs#L18
has anyone experienced non-deterministic behavior when using local `banks client`? i'm sure i am just overlooking something but sometimes the same test passes then fails then passes... perhaps a question for solana not anchor
u can pass accounts and args <a:Hmmmm:695129200260153375> 
there isnt much else
what userdata exactly
Thank you.👍  It works. the error was in Anchor.toml
```
[scripts]
test = "ts-mocha -p ./tsconfig.json ..."
```
I changed it into
```
[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json ..."
```
and it works now.
can you paste your directory structure? presumable a test directory is missing. check your Anchor.toml there will be a `[scripts]` block with a test = that shows the command that runs when you `anchor test`
anchor build succeed here.

make sure you have `anchor-cli` installed
how do you pass userdata in the typescript rpc call?
When I enter ```anchor test```build succeed and such error comes out.
```
Error: No such file or directory (os error 2)
```
I wonder why such error comes out. Help me.
Hello. I have problem with anchor test.
this test has tokens? you mean just any test that requires using tokens in the test right https://github.com/project-serum/anchor/blob/master/tests/escrow/tests/escrow.ts#L66-L78
Are there any test examples with tokens?
If I kill the type it’s fine.
pub type SHA256 = [u8; 32];
are types not supported via idl?
oh dang, IdlError: Type not found: {"name":"data","type":{"defined":"SHA256"}}
How do I see how much stack space and heap space my txn used?
Forsure
thanks a ton.
yea absolutely. I'll do my due diligence first and then be down for a chat
Not sure your use case but have some ideas 😉
Forsure. Im currently working on something similar so feel free to dm
Alright this is huge for me. I'll have to deep dive it tomorrow
yea ikr lol
For now at least hehe
very very interesting
Txn
No u just pay the fees
Do they require payment for their service?
That's the correct link
https://docs.switchboard.xyz/randomness
that'd be huge
So sometime in the next 3 months
https://docs.switchboard.xyz/program
Q1 2022 VRF supposedly fully live
They're busy building
gotcha
There's a discord just not very active
sounds like no discord, just email comms?
But works well on devnet
Haven't heard back yet
If it wasn't live on mainnet
Not sure I asked why they gave me both
this is all really useful info by the way so thank you
does that mean there is a mainnet vrf?
I created an account on mainnet too and they whitelisted me on mainnet as well
Create an account via their instructions and email them
I can work with that for sure though
(yet)
it's not on mainnet and the devnet one you can only poll once every 10 seconds i believe (for switch board)
oh shit they have their own VRF? who do I contact to ask about getting on the list to use it 👀
Use another value
Add to what you are hashing
so i'm trying to figure out how to get a wider slice of the bytes
mind you the random value is currently only between 0-255
```
                let clock = Clock::get().unwrap();
                msg!("{} is current Slot", clock.slot);
                msg!("{:?} is the hash of the slot", hash(&clock.slot.to_be_bytes()));
                msg!("{:?} is the random value", hash(&clock.slot.to_be_bytes()).to_bytes()[0]);
```
clock has the current slot and you can hash it manually with importing
```
use anchor_lang::solana_program::hash::*;
```
I was whitelisted on their account list and querying their VRF service. Not fully released yet
Depending on use case slot hashes might be a problem with mev
Oh I was experimenting and couldn't get it working. Mind posting a snippet of how you derive it?

You're right that it may not work for me in the end, but as a temporary solution during dev it could be nice to have.
it's not true random and will probably not work for your usecase but i was able to figure out how to get a pseudo random number using slothashes
I did some reading and it sounds like I'd need to stand up my _own_ oracle essentially? If so please do tell me about your experience
for a source of VRF? Please do tell more
I'm using it now
Oh I see in the Anchor test the way they access array constants is:

```
  it("Should include BASE const in IDL", async () => {
    assert(
      miscIdl.constants.find(
        (c) => c.name === "BASE" && c.type === "u128" && c.value === "1_000_000"
      ) !== undefined
    );
  });
```

is this the canonical method?
Heyo! Quick q: Is there a way to access constants in a type safe way in typescript?

For example. In my contract I have:

```
#[constant]
const MY_CONSTANT: u64 = 42;
```

which exists in the idl as:

```
  "constants": [
    {
      "name": "MY_CONSTANT",
      "type": "u64",
      "value": "42"
    }
  ],
```

However, I'm not sure how to access it, is there a helper function to do this?

I'd love to access it in the same way you access account fields. Having a program.constants.MY_CONSTANT in typescript would be neat.
how to hash something on chain?
gotcha, thanks a ton!
For normal accounts you’ll be fine to do all, if you have larger accounts you may need to look into zero copy
https://docs.solana.com/developing/on-chain-programs/overview
😂
g2g guys
i cant remember name
F
youre a girl right
Haha that’s me
i think ive seen u on twitter btw
how many more accounts would I be able to add?
how much would that help?
hahaha
Box it up ser
I am passing in 11 accounts as parameters and need to pass in around 10 more
If before you hit your instruction logic, your accounts exceed stack limit and you’ll need to wrap it in a Box<> to allocate it into the heap
```
Program failed to complete: Access violation in stack frame 3 at address 0x200003fb0 of size 8 by instruction #12076
```

How can I debug this further?
https://github.com/step-finance/reward-pool
Any examples on deserializing an uncheckedaccount?
nice
are u actually anatoly
I think you meant to send that to me lol, which, thank you, will read into switchboard. If anyone has any knowledge about the ability of switchboard to provide VRF lemme know
https://twitter.com/switchboardxyz
You should check out Switchboard.
what is the resolution?
when trying to deploy on testnet
Invalid blockhash
im running into
yo
Hey team, came to a surprising realization today about randomness (or lack thereof) on Solana and just wanted to put my current understanding out there in case anyone has opinions or comments!

My project will require verifiable randomness to launch, which I didn't actually expect to be a blocker to achieve, but after researching all day I've come to the conclusion that **it is not currently possible to do _anything_ with verifiable randomness on Solana**. 

Further, the only way to do so will be if any oracle service (e.g. Chainlink) launches their own VRF oracle on chain - which may happen in the future, but there is no timeline - could be months or more.

This means that my project will be unable to complete and launch until these oracles are available (if ever). And on top of that, if they do become available, I'll need to pay some (hopefully tiny) amount of LINK from my contract every time I need a random number to use - meaning I will need to maintain a balance of LINK on the program or it will inevitably stop being able to function.

I would very much appreciate info and opinions on these topics!
Got it
Ah. Should be my pda
Same as https://github.com/solana-labs/solana-program-library/blob/master/token/program/src/instruction.rs#L894
It's either the owner or the delegate
I was imagining the client would delegate the amount to the pda prior to this instruction
What does authority mean in this context?  Why is it a required argument?
it says unsupported sysvar on execution but compiled. playing with it to see if i can print something out
get returns a result. you need to handle it. use `?` to shortcircuit
maybe SolanaSysvar::SlotHashes ?
missing  a `?`
```
  --> programs/legacy-sol/src/lib.rs:62:42
   |
62 |                 let slot_h: SlotHashes = SolanaSysvar::get();
   |                             ----------   ^^^^^^^^^^^^^^^^^^^ expected struct `anchor_lang::prelude::SlotHashes`, found enum `std::result::Result`
   |                             |
   |                             expected due to this
   |
   = note: expected struct `anchor_lang::prelude::SlotHashes`
                found enum `std::result::Result<_, anchor_lang::prelude::ProgramError>`
```
or iirc it has to be SolanaSysvar instead of Sysvar
```
BPF SDK: /home/spacemandev/.local/share/solana/install/releases/1.9.2/solana-release/bin/sdk/bpf
cargo-build-bpf child: rustup toolchain list -v
cargo-build-bpf child: cargo +bpf build --target bpfel-unknown-unknown --release
   Compiling legacy-sol v0.1.0 (/mnt/c/Users/spaceman/Projects/solana/legacy-sol/programs/legacy-sol)
error[E0599]: no function or associated item named `get` found for struct `anchor_lang::Sysvar<'_, _>` in the current scope
  --> programs/legacy-sol/src/lib.rs:62:50
   |
62 |                 let slot_h: SlotHashes = Sysvar::get();
   |                                                  ^^^ function or associated item not found in `anchor_lang::Sysvar<'_, _>`
```
does `let slot_h: SlotHashes = Sysvar::get()?` work?
i'm unsure what to pass in for it
like the other functions for SlotHashes
but it requires &self as one of the inputs
tried get
```
error[E0061]: this function takes 2 arguments but 0 arguments were supplied
  --> programs/legacy-sol/src/lib.rs:62:30
   |
62 |                 let slot_h = SlotHashes::get();
   |                              ^^^^^^^^^^^^^^^-- supplied 0 arguments
   |                              |
   |                              expected 2 arguments
   |
note: associated function defined here
  --> /home/spacemandev/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-program-1.9.2/src/slot_hashes.rs:32:12
   |
32 |     pub fn get(&self, slot: &Slot) -> Option<&Hash> {
   |            ^^^

For more information about this error, try `rustc --explain E0061`.
error: could not compile `legacy-sol` due to previous error
➜  legacy-sol git:(main) ✗
```
`let slot_hashes = SlotHashes::get()?;`
bumping this to see if anyone has any ideas on how to get access to slothashes during execution
And this should be 8 + 32 + 1 https://github.com/aeyakovenko/token-omnibus/blob/cda29655cce688c295f57fc0b6399eb476480f0c/programs/token-omnibus/src/lib.rs#L133
from and authority are equal
maybe this is intentional but this is saying that the token account is its own authority https://github.com/aeyakovenko/token-omnibus/blob/cda29655cce688c295f57fc0b6399eb476480f0c/programs/token-omnibus/src/lib.rs#L36
also, u can use account.key() instead of account.to_account_info().key()
Ah got it
you dont have to. by the time your code executes, anchor will have checked that all accounts are properly initialized
What about via js?
And then also the normal solana program-test crate works as well for integration tests.
You can run normal cargo unit tests. `cargo test --lib`.
How do I check the account is initialized?
space should be `space = 40` (once you have removed `initialized`). the anchor account discriminator takes 8 bytes
no need for an `initialized` field on your accounts. anchor handles that check for you
if you use additional functions, you can test them like you normally would. for instruction tests we dont have a guide on anchor tests yet (coming soon) so the tests folder in the repo is the best source I think
is there a guide on writing unit tests with anchor?
Yep working now! RIP idl
no tests yet
my first anchor program!  https://github.com/aeyakovenko/token-omnibus/blob/master/programs/token-omnibus/src/lib.rs
has anyone received this error using the @project-serum/anchor library with react ?
```
BREAKING CHANGE: webpack < 5 used to include polyfills for node.js core modules by default.
This is no longer the case. Verify if you need this module and configure a polyfill for it.
```
is there a way to take it off?
after i put a program on testnet or devnet
But thats my thoughts
Ok I think its because I wasnt copying the idl each time, will try again next time I’m on the computer
nvm https://giters.com/project-serum/anchor/issues/1059 have to do anchor `deploy` first
I'm following a tutorial that has me do `const programID = new PublicKey(idl.metadata.address);`.  my `idl.json` has no metadata field.  is this something that is dynamically generated or did I do something wrong?
I've tried a few annotations and types (Program, Account, Signer) for that chainlink var still can't get anything to stick
to the best of my knowledge, it works with the latest solana sdk
From what I can tell Pythwill likely have the same issue as it's using next_account_info as well
I pass that in as the chainlink arg
on the JS side, here's how I'm getting the PKEY

```const chainlinkPublicKey = new PublicKey('6dbkV6QCToTk6DRfuJyrGuz18kZ4rPUSHLLLVrryWdUC');
``` (that's the devnet btc address)
Right now I have it as AccountInfo, but if I try using the Account annotation, I get errors about not having access. In the current form it doesn't deserialize
```
#[derive(Accounts)]
pub struct Process<'info> {
    #[account(init, payer = user, space = 8 + 1 + 32 + 16)]
    pub story_account: Account<'info, story_account>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub chainlink: AccountInfo<'info>,
    pub system_program: Program<'info, System>,
}
```
So my main issue is just in the definition of accounts, I'm trying to set it up in a way that I can access chainlink
Absolutely one moment
what solana sdk works with anchor 0.19?
Can you post code snippets of what isn't working? I'll be looking into this too in the coming days so will be useful starting point. No promises
<@!161709591220977664> https://github.com/project-serum/anchor/issues/383 I just found an issue in the repo. It's not a supported feature
```toml
[provider]
cluster = "localnet"
wallet = "../../keypairs/dev.json"

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.spec.ts"
```

it's defined. but if i rebuild on a different computer and deploy, anchor will generate  a new keypair and use that.
you point to the cluster and keypair json
under [provider]
i think you define the keypair in Anchor.toml
yeah, i see it in the target folder. During build/deploy i'd like to do something like `anchor deploy --provider.wallet=WALLET` or `ANCHOR_WALLET=WALLET anchor deploy` but both commands are ignoring the defined wallet
I think it puts it there
Check the target folder
also, is there a way to override the deploy keypair in anchor?
<@!73802344810160128> i haven't used an oracle yet. but i'll sure give it a try and i'll try to maek a tutorial series on anchor when i have the time
Every annotation I used seemed to error
tempted to just go back to vanilla solana
I just couldn’t figure out how to pass an address in and convert it to address info to use with either lib
<@111233596173373440> pyth looks good, let me know if you ind a way to pass the accounts in, its essentially the same pattern as the chainlink lib
yeah, i don't think we can create get slothashes within a contract
are there any examples in buildspace or anchor that show how to remove item from a vec based on some input from an outside app?
```rs
pub fn get_feature() -> u8 {
    let slothash = SlotHashes::new();
    msg!("{:?} is the Slot Hash", slothash.slot_hashes());    
    return 0;
}
```
this is the closest i've been able to come to it, but get an error that SlotHashes::new() requires an argument (&self) and i don't know how/what to supply for that arguement
I have actually found https://github.com/project-serum/anchor/search?q=oracle
something called `pyth` which is doing something related to oracles and prices - will be delving into that in hopes of fetching an "unpredictable" value for my usage

ehh, actually, I don't think this is it
if it's within a contract, i tried to no avail
it's interesting how many people are asking similar questions right now. 

I'm trying to find a way to generate a random (or fairly pseudo-random) result without a real Chainlink VRF available. 

Options include either:
 - using recent slothashes + other data to generate a number that is sort-of random (not ideal) - which would involve something like what <@!161709591220977664> is asking for (getting a slothash and somehow deriving a value from it)
 - Utilizing a chainlink price feed, which is at least an unpredictable value, to derive my random value from - which is similar to what <@!73802344810160128> is asking above. I can find a number of people on this disc and other websites _talking_ about querying a chainlink oracle price feed as a data source, but can't find a single code example to reference to do so in anchor rust
can someone walk me through how to get the most recent slothash and cast it to a u8 ?
this is weird tbh. I have the wallet defined in anchor.toml. I think it's a bug
It’s probably generating because the private key isnt found in the target dir
Copy the target keypair
It's declared in the `Anchor.toml` file

```toml
[provider]
cluster = "localnet"
wallet = "../../keypairs/dev.json"

[programs.localnet]
crash = "8VQFmDx6YoJtDtQ9pPXzi3SQCQ18mEaSpgDEnEmr9uc9"

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.spec.ts"
```

and also 
```rust
declare_id!("8VQFmDx6YoJtDtQ9pPXzi3SQCQ18mEaSpgDEnEmr9uc9");
```

but whenever i switch computers, a new id is recreated on localnet
declare it
how can i keep program-id from changing on localnet when i build on a different machine?
why is the pda seed type different between the solana api and anchor? (nm, user error)
does anchor have a way to fake time, e.g. fast-forward a staking contract to make sure that expected values match in two or three years?
Not yet :/ I work on my defi projects only from 7AM to 9AM each days ! I make you an update tomorrow 🙂 tell me if you succeed to make it works
I know u can do through cmd line, but wondering if there are any contract examples so the user can claim and pay the rent fee
Anyone have a good guide on airdropping NFTs or allowing users to claim a specified ammount per address of NFTs in anchor?
Hey! Did you get the chainlink stuff working in any capacity? I've also just found myself at a point where I need a random number generated for me. Watching the hackathon workshop now
Basically i'm just wanting to pass in a pubkey and have it serialized to program info without owning it
Super beginner question. I'm trying to implement the chainlink price feed. Passing in one of the accounts into my app I'm not entirely sure how to annotate it so that I have anchor de-serialize it into account data.
You can give some other account the authority, doesn't have to be the sender
```    let cpi_accounts = Transfer {
        from: ctx.accounts.asset_src.to_account_info(),
        to: ctx.accounts.asset_dest.to_account_info(),
        authority: ctx.accounts.user.to_account_info(),
    };
    let cpi_token_program = ctx.accounts.token_program.clone();
    let cpi_ctx = CpiContext::new(cpi_token_program, cpi_accounts);
    token::transfer(cpi_ctx, amount)?;```
I had this, They'ved changed the structure a bit. I ended up forking and branching the older version: ```chainlink = { git = "https://github.com/mattvv/chainlink-solana", package = "chainlink-solana", branch = "stable", features = ["no-entrypoint"] }```
couldn't the client delegate the amount outside of this instruction
why does transfer require an authority?
This is the best solana smart contract i have seen
https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo/src/lib.rs
my guess wasnt right
any docs to make a spl token transfer from anchor?

        let cpi_program = ctx.accounts.token_program.to_account_info();
        let cpi_accounts = Transfer {
            destination: ctx.accounts.omnibus.to_account_info(),
            amount: data.amount,
        };
        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
        token::transfer(cpi_ctx, data);


//////////////////////////////////////////////////////////////////////////////////////////

yea thats what i did but hashmaps are more convenient and safer
idk if it will work for you, but i was able to get around my issue by using a vec. 
```    
pub features: Vec<Option<Feature>>
```

allowed to to basically have a <k,v> where the k is the index in the vec
thanks!
that's what I was looking for RIP 😛 I was using createAccountWithSeed
you mean higher level than web3.js's `findProgramAddress`  somehow?
Does anchor have any client side helpers for creating PDAs?
if anchor does the account initialization for me, do i need to create and asign the account to the rpc arguments somewhere?     

Error: Invalid arguments: accountSet not provided.
makes a lot of sense
ik its a major issue we cant use hashmaps, btrees and even custom structs give idl error
you might have pictured the program address sort of like a hash of the program, then. But that's actually just the location of the program on-chain
I would also like to know this
got it wasnt sure if the keypair changed based on the idl gnerated
it stays the same if you dont change ur config
yup, why should it change?
Is it weird, when I run anchorbuild, my programid is the same even if I changed some code? wondering if program ids stay the same on mainnet and devnet which wouldnmt make sene
code here https://github.com/xedk/solana-splits/blob/structmethod/programs/split/src/lib.rs
and whats this ```https://github.com/xedk/solana-splits/blob/structmethod/programs/split/src/lib.rs```
can someone explain why hashmaps arent supported in anchor idl
i have all installed but i cant do nothing

I have been trying for several days to create NFT with gif and I can't find any information or anything on the internet.
Hello can anyone help me pls?
ok so my issue was that IDL in ts had to have all typed explicitely casted to work... is this requirment with new version of anchotr?
```rust
pub struct Map {
    pub pub_key: Pubkey,
    pub integer: u64,
}

#[account]
pub struct BaseAccount {
    pub count: u64,
    pub mapvar: HashMap<u64, Vec<Map>>
}

}
```
i have a struct i want to store in the hasmap vector but i get this err ```the trait bound Map: std::clone::Clone is not satisfied

expected an implementor of trait std::clone::Clone
```
if i do this 
```pub mapvar: HashMap<u64, Vec<std::rc::Rc<Map>>>```
 then i get a diff error ```the trait bound std::rc::Rc<Map>: anchor_lang::AnchorSerialize is not satisfied

the trait anchor_lang::AnchorSerialize is not implemented for std::rc::Rc<Map>```
to what anchor expects
seems like idl is generated in wrong way

anyone else having issues loading program via idl in react?
lol nws
damn <@!347689664855015424> i am a fucktard.
thats what i meant
`anchor test --help` :)
why i need it and many others might as well. On Building the program, IDL generated automatically does not handle variable type- Tuple well. I can edit the JS test script but then running Anchor Test again generates faulty IDL file.
With `solana program dump ` and `[[test.genesis]]`  i can run programs locally for testing. is there anyway i can also copy a few accounts from mainnet and store them in the test.genesis block?
i use node 16, would that be an issue?
--help
hey guys, can i run anchor test without re-building and deployment?
seems like there are issues with anchor versions and the way idl is built..
actually getting this error:
```Argument of type '{ version: string; name: string; instructions: { name: string; accounts: { name: string; isMut: boolean; isSigner: boolean; }[]; args: { name: string; type: string; }[]; }[]; accounts: { name: string; type: { kind: string; fields: never[]; }; }[]; }' is not assignable to parameter of type 'Idl'.
  Types of property 'instructions' are incompatible.
    Type '{ name: string; accounts: { name: string; isMut: boolean; isSigner: boolean; }[]; args: { name: string; type: string; }[]; }[]' is not assignable to type 'IdlInstruction[]'.
      Type '{ name: string; accounts: { name: string; isMut: boolean; isSigner: boolean; }[]; args: { name: string; type: string; }[]; }' is not assignable to type 'IdlInstruction'.
        Types of property 'args' are incompatible.
          Type '{ name: string; type: string; }[]' is not assignable to type 'IdlField[]'.
            Type '{ name: string; type: string; }' is not assignable to type 'IdlField'.
              Types of property 'type' are incompatible.
                Type 'string' is not assignable to type 'IdlType'.ts(2345)
No quick fixes available
```
how can i further debug this? the implemenation works with node server, but not with react. so IDL should be good.
i fetched latest idl with `anchor verify <address>`
i am getting following error:
`Uncaught (in promise) TypeError: Reduce of empty array with no initial value`

so obv something with IDL is wrong.
i am trying to initialize program from IDL:
`  console.log(JSON.stringify(idl, null, 4));

  const program = new anchor.Program(
    idl as anchor.Idl,
    programAddress,
    provider
  );`
anytime man
thank you!
ahh cool
I have this in my code base

```rust
pub fn can_sign(key: &Pubkey) -> bool {
    Pubkey::from_str(SIGNER).unwrap().eq(key)
}
```

Then i also use 

```rust
pub struct SomeContext<'info> {
    #[account(
        constraint = can_sign(authority.to_account_info().key) @ CustomError::InvalidSigner
    )]
    pub authority: Signer<'info>,
}
```
talking about if someone tries to invoke the ix, want to make sure it fails unless the authority invokes it
well would it be something like only the authority can be the signer?
u can hard code the wallet's public key
whats the best way to ensure only the authority of a program can call an instruction?
why does a native mint token account persist from test to test on localnet but any other spl token does not?
No DAO here, working on an assignment as part of an interview
What kind of DAO are you building?
when trying to set an account attribute to an array like so:
```rs
#[account]
pub struct Game {
    pub id: String,
    pub admin: Pubkey,
    pub enabled: bool,
    pub features: [Feature; 255]
    //pub features: HashMap<u8, Feature>,
    //pub troop_templates: HashMap<u16, Troop>
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Copy)]
pub struct Feature {
    pub  name: String,
    pub rarity: u8,
    pub next_scan: i64, 
}
```

i get the error that trait 'copy' cannot be implemented for type String in feature. without the Copy trait, i'm unable to set it in the game struct as an array because it wants all fields to be Copy-able
it does
```rs
#[account]
pub struct Game {
    pub id: String,
    pub admin: Pubkey,
    pub enabled: bool,
    pub features: HashMap<u8, Feature>,
    pub troop_templates: HashMap<u16, Troop>
}
```
idk I am a beginner too :3
sounds like your account doesn't have a `features` property?
this is the corresponding entry point:
```rs
    pub fn create_game(ctx: Context<InitGame>, id:String, _bump:u8, admin_pk: Pubkey, _0_loc_bump:u8, features:HashMap<u8, Feature>, troops: HashMap<u16,Troop>) -> ProgramResult {
        if ctx.accounts.admin_account.key != ctx.accounts.admin.key() {
            return Err(ErrorCode::Unauthorized.into())
        } else {
            let game_account = &mut ctx.accounts.game_account;
            game_account.enabled = true; //TODO: Default to False and then change it via functions. For debug purposes we'll just enable the game
            game_account.admin = admin_pk;
            game_account.id = id.clone();
            game_account.features = features;
            game_account.troop_templates = troops;
            emit!(EventNewGame {game_id: id.clone(), game_admin: admin_pk});
            Ok(())
        }
    }
```
and context:
```rs
#[derive(Accounts)]
#[instruction(id: String, _bump:u8, admin_pk: Pubkey, _0_loc_bump:u8, features:HashMap<u8, Feature>, troop_templates:HashMap<u16, Troop>)]
pub struct InitGame<'info> {
    pub admin_account: Account<'info, Admin>,
    pub admin: Signer<'info>,
    pub system_program: Program<'info, System>,
    #[account(init,
        seeds=[id.as_ref()],
        bump=_bump, 
        payer=admin, 
        space=8+32+58+1
    )]
    pub game_account: Account<'info, Game>,
    #[account(init,
        seeds=[id.as_ref(), 0_i64.to_be_bytes().as_ref(), 0_i64.to_be_bytes().as_ref()],
        bump=_0_loc_bump,
        payer=admin,
        space=8+1028
    )]
    pub start_location: Account<'info, Location>,
}
```
assuming here:
```ts
  //initalize the game
  const gameId=_gid;
  const gameacc = await getPDA([Buffer.from(gameId)], program.programId);
  const startLoc = await getPDA([Buffer.from(gameId), new anchor.BN(0).toArrayLike(Buffer, "be", 8),new anchor.BN(0).toArrayLike(Buffer, "be", 8)], program.programId);

  await program.rpc.createGame(gameId, gameacc.bump, provider.wallet.publicKey, startLoc.bump, await getFeatures(), await getTroopList(),
    {
      accounts: {
        adminAccount: contractadmin.account,
        admin: provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
        gameAccount: gameacc.account,
        startLocation: startLoc.account,
      }
  })
```
trying to run anchor test on some code :/ unsure where in the code it's erroring
This tutorial is excellent.  Thanks for sharing
when do you get this error?
what does this error mean?
```
     IdlError: Type not found: {"name":"features","type":{"defined":"HashMap<u8,Feature>"}}
```
bump 😄
Ahhhhh. Thank you!! just saved me a ton of time
Not the base, the base is just for anchor
Ah , the cargo.toml in the programs folder
I keep getting this issue whenever I attempt to do so: `this virtual manifest specifies a [dependencies] section, which is not allowed`
Add it to your cargo.toml
how do I install anchor_spl?
Figured it out over on Solana discord. I was close - just needed to create the Uint8array: ```memcmp: {
   offset: 8, // Discriminator.
   bytes: bs58.encode(new Uint8Array([1])),
},```
np, you too
you deserve it
hope u have a good 2022
happy new years to you and your family
thanks man
yo
do `cpi = []` and see what happens
cpi? or no-entrypoint
that is disable it
does it work if you remove the feature?
whats the right way to do it then
mmmmm
if the entrypoint is not there the program cannot execute
for cpi
why do you have the no-entripoint feature enabled?
```Error: ELF error: ELF error: Multiple or no text sections, consider removing llc option: -function-sections
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }.```
but when I try to deploy it
when I build it it build ok
this is what the toml looks like
```[package]
name = "IDO"
version = "0.1.0"
description = "Created with Anchor"
edition = "2018"
resolver = "2"

[lib]
crate-type = ["cdylib", "lib"]
name = "ido"

[features]
no-entrypoint = []
no-idl = []
cpi = ["no-entrypoint"]
default = ["cpi"]

[dependencies]
anchor-lang = "0.20.0"
anchor-spl = "0.20.0"```
I am trying to compile a program with cpi
yes
once i download anchor v0.20.0, how do I actually upgrade my project to that anchor version? Do I only have to change `/Cargo.toml`?
Thank you very much <@!732815411808174111> !
And it's free. I haven't seen in anything worthwhile in Udemy yet.
hahaha yep, thanks I posted just one minute after hahahaha
See my post right above this.  I started here and it gave me almost all I needed to fully develop in Solana/anchor.
Hey guys, is there any good course about how to develope on Solana in coursera,udemy,etc?
This is really an excellent tutorial on creating Solana accounts via anchor, writing & reading text from them. One of the best quality tutorials I've come across. Lesson 3-6 is what you're looking for specifically.  https://lorisleiva.com/create-a-solana-dapp-from-scratch
how did you resolve this after adding the cpi part?
does anyone know the error when trying to deploy

Hey everyone
Anybody have an Anchor example writing text to an account, and then reading from it?
How would I pass a boolean value in a memcmp filter? Would it just be ```bytes: bs58.encode([01])``` or something to that effect? Buffers and base58 are fairly new to me.
I've seen a lot of anchor code talking about bumps. I looked through the official Solana docs and there's not much there about what a bump is and why it's important. Was just looking for clarification
So the follow is almost certainly really poor code, not sure if it's possible to cause a panic but I was screwing around with this and did the following:
```
    // A hash derived from adding together unix_timestamp and clock slot
    let basic_hash: Hash = hash(&(clock.unix_timestamp as i128 + clock.slot as i128).to_be_bytes());
    // Then, a u64 derived from the first 8 bytes of the hash.
    let pseudo_random_u64: u64 = u64::try_from_slice(&basic_hash.to_bytes()[0..8]).unwrap();
```

it creates a u64 from the hash of the two values.

Anyone, feel free to point out if the above is problematic. I know it's not true random, that's not really the goal since it's impossible afaik on-chain.

I casted the first two values (an i64 and a u64) to an i128 before hashing because I _think_ that would prevent overflow errors
also running `anchor idl fetch` throws following error:
`anchor idl fetch CUS1qwyVkxg2Pbt35iPU5x133Nfg2oaiUsshKhnRvWfH
thread 'main' panicked at 'Inside a workspace', cli/src/lib.rs:1359:47`
where IDL is typescript object. prob has to be loaded from json i would say?
i'm trying to use this to fetch idl
``const idl = await anchor.Program.fetchIdl(programAddress, provider);``

gets data is null error

and trying this:
``  const program = new anchor.Program(
    IDL as anchor.Idl,
    programAddress,
    provider
  );``
Hey <@439210198142550016> , I just quit my job as a backend engineer at Robinhood to build a Solana protocol. Would love to hear your feedback on it, if your DMs are open!
how do you load IDL into react FE? idl has to be in json file and loaded into object?
https://github.com/project-serum/anchor/issues/59
we did that in rust
would be cleaner
yea
shouldn't there be a TX builder or something
main gotcha is that the context is at the end in ts instead of the beginning in rust
got it
ah
Can pass that in via params like a normal function call.
var arr = Array<byte>(32).fill(0);
    const tx = await program.rpc.initialize({data: arr});
instruction data
is there an anchor/rust example that does a CPI to a 3p program (not system)?
What is the difference beween  [K in T] and [K in keyof T] in a indexed map?
What do you mean by user data? You can pass in the instruction data as the function parameters and you can pass in the "context" as the last param, which holds all the accounts and any additional signers you need on the tx.

https://project-serum.github.io/anchor/ts/index.html#Context
<@501570363566587905> I put the multisig up on devnet and ran the first test, but I’m getting an invalid data account error. Have you ran into it before?
do I have to supply the program's public key if not a user wallet even if the transaction doesn't need signed?
https://github.com/cqfd/quidproquo/blob/main/tests/quidproquo.ts
So like program.rpc.init(userdata, { accounts: …
Pass it in as first parameter to program.rpc.<method>
<@!501570363566587905> so in program.rpc.<method> how do i set the userdata?
build transaction with `program.instruction.something` instead of using `program.rpc.something`
Do I just rely on on the connected wallet signing the tx automatically be being part of the provider?
i guess this: https://discord.com/channels/889577356681945098/889702325231427584/929099272799027250 ?
which requires `sendTransaction(transaction, connection) in order to automatically sign the tx.
it's solana wallet adapter.
Yes! Integrating with phantom wallet.
are you integrating with Phantom wallet?
ohhh hahah cool 👍  didn't know that
You can use `program.simulate` as well.
But if you want to use `program.rpc` instead of `program.instruction`, here's a good example: 
https://github.com/cqfd/quidproquo/blob/main/tests/quidproquo.ts#L84
Personally, I use `program.instruction.*` instead of `program.rpc.*`. This way, you can use the `simulate` method: 

```const txn = new anchor.web3.Transaction();
    txn.add(
      program.instruction.myInstruction(
        myBump.
        mySecondBump,
        new anchor.BN(MY_MAX),
        {
          accounts: {
            payer: payer.publicKey, 
            stablecoinMint: stablecoinMintToken.publicKey,
            vault: vault,
            systemProgram: anchor.web3.SystemProgram.programId,
            tokenProgram: spl.TOKEN_PROGRAM_ID,
            rent: anchor.web3.SYSVAR_RENT_PUBKEY,
          },
      })

  const signers = [payer];
    if (simulate) {
      return await program.provider.simulate(txn, signers);
    } else {
      return await program.provider.send(txn, signers);
    }
  }
```
Looking to create a Program to make rpc requests *without* a provider (I don't want my user to have to connect their wallet) and it's looking for some kind of config file:

```ts
const program = new Program(IDL, programID);
```

I get this error:

`Uncaught (in promise) TypeError: __webpack_require__(...).readFileSync is not a function`

Because it's calling:

```
  static local(): NodeWallet {
    const process = require("process");
    const payer = Keypair.fromSecretKey(
      Buffer.from(
        JSON.parse(
          require("fs").readFileSync(process.env.ANCHOR_WALLET, {
            encoding: "utf-8",
          })
        )
      )
    );
    return new NodeWallet(payer);
  }
```

How do I set this up to work locally and also in production?
gotcha, im pulling up my code
Once you need to use Box youve officially become a solana dev
<@!912046857000194158> <@!347689664855015424> If the users keypair isn't available on the frontend, how do we pass it to signers?
Since we need to explicitly sign for the keypair user, signers: [theirKeypair] in the rpc call
np 👌
Thank you so much bro
pub fn initialize(ctx: Context<Initialize>, data: [u8; 32]) -> ProgramResult {
the "data" field
Fortunately, it's pretty straightforward <@!694458281388671077>
https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo/src/lib.rs#L219
Thanks..
But how can i use Box<> any example??
by user data, do you mean the `Context` and other instruction parameters?
Since we need to explicitly sign for the keypair user, `signers: [theirKeypair]` in the rpc call
If the users keypair isn't available on the frontend, how do we pass it to `signers`?
You've reached your 4KB stack limit. You need to move stuff to the heap using `Box<>`. For large accounts, use zero copy if you still need
how do i send userdata through the rpc command?

```
    var arr = Array<byte>(32).fill(0);
    const tx = await program.rpc.initialize({userdata: arr});
```
refer to the random.org api for atmospheric noise. the closest representation to true random we can generate. Would require you to provide an oracle for that.
If you search chat there is an answer, usually you need to use box<>


//////////////////////////////////////////////////////////////////////////////////////////

hey guys, I have many-to-many mapping of topics <> users. What is the best practice for maintaining such data on-chain. Do i need to create separate PDAs for each topic<>user map? Is there any reading material around this? Would appreciate if someone is open to a 30min consulting session
Hi, I encounter the same problem with yours. I have installed the yarn, but when i run "anchor init test". The error shows "Error: yarn install failed". I run the program on Windows10.
I've been seeing a number of tutorials where they bundle the program in with the front end, is it not better to keep them seperate?  Or is there a benefit to keeping everything together?
Any  way to have my program close PDAs that it has created? Is the easy solution to change the PublicKey of the program so that the accounts are no longer associated?
There's no stupid questions, so no offense but do keep the questions in the open chat. I assure you I'm the first one to ask stupid shit so no judgement
Thanks <@!915682383905316864> I'm gonna slide into your dm's for some really stupid questions later 😛
My bad my signer was different from user, it was the program_account
maybe you got the client snippet?
where do these accounts come from?
Neither program account nor service account
Oh yes sorry the program_account...but here the signer is a third account
you don't need to sign to receive lamports
from your snippet it's the other way around, which is why the signer needs to be `program_account`, the one being deducted lamports
And I am a bit confused...even though service_account is losing its lamports to public_account, how come only the signature of user is enough in the above example? 
All 3 are different accounts currently
shouldn;t the account that has debits, be a signer? to let the program take some lamports out?
so lets say I want to split this into 2 functions. One which will create this ledger account, and another function which will do the amount transfer between the service account and program account...Who should be the signer for the second function?
yes the program will automatically make a CPI call to create the ledger account because of the `init` attribute, and fail if that account already exists
So since I have mentioned init in the struct, this will create a new account right?
no it's an a per-account basis indeed
haha I see
The error is actually saying exactly this: "you tried to change the balance of an account not declared as mut"
I thought adding accounts below it means all are #[account(mut)]
OMFG thank you so much
yes, the same way you did for `user`
Do I need to add #[account(mut)] before each account?
for `program_account` and `ledger`
Yeah it seems you are missing at least a couple `mut` on you context definition
Error is: `Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: instruction changed the balance of a read-only account`
Better to resolve issues in the open for others' benefit. It would also be beneficial to post the actual error
Anyone here who doesn't mind me getting into their dm's for some simple quick questions regarding this?
Hey <@!831450660146642974> ?
My struct is this
`#[derive(Accounts)]
pub struct Create<'info> {
    #[account(init, payer = user, space = 8 + 64 + 64 + 64 + 64)]
    pub ledger: Account<'info, Ledger>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
    pub service_account: AccountInfo<'info>,
     pub program_account: AccountInfo<'info>
}`
Hey guys can someone help me here
My use case for a function
Debit an amount from a program_account and credit that amount to a service account. Parameters for this function should be service account, public account and an amount :u64
Can someone point out what I am doing wrong here?
`pub fn create(ctx:Context<Create>, id: String, amount: u64) -> ProgramResult {
        let ledger = &mut ctx.accounts.ledger;
        let service_account = &mut ctx.accounts.service_account;
        let program_account = &mut ctx.accounts.program_account;
        **program_account.try_borrow_mut_lamports()? -= amount;
        **service_account.try_borrow_mut_lamports()? += amount;
        ledger.amount = amount;
        Ok(())
    }`
no idea how u figured that lol well done
so in my typescript I had to call the struct fields as camelcase rather than the snake case i had defined in rust *face palm*
OMFG I figured it out. it's cause anchor converts underscore variable names to camel case
this is happening to numbers before they go into an account, but yes the account they eventually end up in is a 10kb account
Does the account have enough space allocated?
`#[account(init, payer = user, space = 64 + 64)]`
```rs
    pub fn debug(_ctx: Context<Debug>, x:Vec<DebugStruct>) -> ProgramResult {
        msg!("X: {:?}", x);
        Ok(())
    }   

#[derive(AnchorSerialize, AnchorDeserialize, Clone, PartialEq, Debug)]
pub struct DebugStruct{
    pub x:i64
}
```

```ts
    await program.rpc.debug([{x:new anchor.BN(-1)}], {accounts: {}});
```

^^^^This works as expected
hrmm....now i'm getting even weirder behavior. *all* my signed integers are referencing down to 0 as well >.< this is even more confusing because i wrote a debug function where everything is working as it should
Maybe related to the endianess of BN? What values do you get if you pass in -2, -3, 0, 1 and 2? Sorry not more helpful
hoping someone can help me figure this out. i'm passing in a struct with one of the fields being a negative number. in TS it's a BN(-1), but when printed out on the contract side it's 0

relevant code:
```ts
  //upload Features and Troop Lists
  const features = await getFeatures();
  console.log("-----------FEATURES----------------")
  console.log(features); //<--- features[0].next_scan == BN(-1) here

  await program.rpc.addFeatures(features, {
    accounts: {
      game: gameacc.account,
      authority: provider.wallet.publicKey
    }
  })
```

```rs
    pub fn add_features(ctx: Context<ModifyGame>, new_features: Vec<Feature>) -> ProgramResult {
        msg!("Features: {:?}", new_features); //<--- features[0].next_scan == 0 here
        let game = &mut ctx.accounts.game;
        game.features.extend(new_features.iter().cloned());
        Ok(())
    }
```

also the field (next_scan) is a *signed* integer, so it shouldn't be casting
```rs
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct Feature {
    pub weight: u8,
    pub name: String,
    pub next_scan: i64, 
}
```
i wasn't able to find any other way to do map, so yea just using Vec creatively 😅
Thanks! Is there any other map supported, or workaround is to use Vec creatively?
https://github.com/project-serum/anchor/issues/1266#issuecomment-1008185937
afaik HashMaps aren't supported currently
is it possible to use HashMap<T1, T2> as a type in a struct? Else how to use a map? I get a weird error when I do, and if I change it to Vec<T> it works normally... the IDL says 

            "type": {
              "defined": "HashMap<String,f64>"
            }

vs.

            "type": {
              "vec": "string"
            }

respectively
for my app, I was going to set up a backend layer that serves as the liason between FE and contract
Cause the contract works locally / backend wise but getting it to work with the FE is the part missing
hmm i havent implemented anchor in a frontend web app yet so i dont know
Feel like I’m still missing a thing or two
Not really yet for me at least lol
Separate question:

In my anchor typescript tests, who should I expect to be paying the gas fees?
have u found any good tutorials online?
gotcha
Pretty much doing the implementation from contract to website FE really at this point
wdym? Anchor has a separate package for each
you need to pass in a publicKey usually
best way to go for what? use the anchor ts library to convert most things
worked, the only weird thing was needing to to make sure its {enum.toLowerCase() : {}} instead of just {enum:{}}
What’s the best way to go from anchor_lang to typescript? Still can’t wrap my head around that portion of things fully
thanks, will try
<@!161709591220977664> I read this
but haven't tried it
https://2501babe.github.io/posts/anchor101.html
what's the best way to pass in an enum from TS through RPC for anchor?
owner is a generated keypair, not sure what I'm doing wrong since the same code was working before couple weeks ago
Getting signature verification failed for some reason when my code was working before.
user is my only Signer account in my program instruction
```rust
use std::str::FromStr;
```
Sure
Want to ask regarding grape
Can you accept me
<@770650336725172267>
or crate import
lol i cant seem to figure out how to import the from_str method. I see it implemented not sure whats wrong with my using
thanks!
yup
any account that anchor creates is rent exempt by default?


//////////////////////////////////////////////////////////////////////////////////////////

<<<<<<< HEAD
ohk will do
Basically yes, but I really think you should re-do the full tutorial, it'll be way more efficient
so i just do? ```
accounts:{
from:fromaddress,
to: toaddress
}```
<@!691933164909756466>
```await program.rpc.voteGif(giflink, {
        accounts: {
          baseAccount: baseAccount.publicKey,
        },
      });``` right now this is how i did it
Any time you pass *any* account you do so by passing its address in from the client, e.g.
```.js
await program.rpc.yourInstructionName({
  accounts: {
    someAccount: itsAddress // <-- these are all addresses
    ...
  }
});
```
I think you should work through the full anchor tutorial if you haven't already, it will help you understand this confusion
and how do you pass an address as an account
You need to pass in both addresses as accounts, from the client
```.rs
#[derive(Accounts)]
pub struct YourInstruction<'info> {
  pub their_account: AccountInfo<'info>,
  ...
}```
i only hv account of the person sending the sol not receiving
You pass it in from the client
but thats the problem how do you get their "account" by their public address
Definitely don't need remaining accounts for this, not sure where you got that from 🤔 You can just pass in their one single account
Still completely unsure what it means or how to move forward testing front end :/
Re: compiling errors caused by imports

I keep trying to specify exactly what file to find exports in, I keep getting that error for a few items, but I am now also getting this project serum error

Compiled with problems:

ERROR in ./node_modules/@project-serum/anchor/dist/browser/index.js 12:0-28

Module not found: Error: Can't resolve 'assert' in '/home/sal/mysolanaapp/app/node_modules/@project-serum/anchor/dist/browser'

BREAKING CHANGE: webpack < 5 used to include polyfills for node.js core modules by default.
This is no longer the case. Verify if you need this module and configure a polyfill for it.

If you want to include a polyfill, you need to:
    - add a fallback 'resolve.fallback: { "assert": require.resolve("assert/") }'
    - install 'assert'
If you don't want to include a polyfill, you can use an empty module like this:
    resolve.fallback: { "assert": false }


ERROR in ./node_modules/@solana/wallet-adapter-react-ui/lib/WalletConnectButton.js 29:6-15

export 'useWallet' (imported as 'useWallet') was not found in '@solana/wallet-adapter-react' (module has no exports)
but didnt get anything useful
i went thru the docs and tutorials
u said something abt reamining accounts
i want to send sol to another person using their public address
What's going wrong so far?
What part? What are you trying to do?
<@!134416332509675520> hey cn u explain how to get remaining accounts
nobody seems to have the same error as me for something as simple as importing wallet adapters
noob question since I keep getting this node module export  not found error... should I delete the node modules from my ./app directory, or is it using that one and not the node modules in the root?
ok - checked with the metaplex people - just to tie this up -- they generate a new keypair for the new mint -- so I guess then they use that "temp" keypair to transfer everything
Whats the best way to go about transferring lamports with a program? I looked into the example on the solana program library, but can't seem to interact with it from a client without errors.
Ok thanks for the reply. I will change the design,
You can't transfer account ownership unfortunately (it can only happen once, from the system program to some other program)
Hello, 
I have a question about program address. I have a program address which was created by program A. But it is really modified in program B. As it is created in program A, program B cannot really modify it as it is not owner of this address. How can i transfer ownership to program B. I tried it with SetAuthority but it seems it needs a signature of programA even if i am in program A while setting ownership. Am i missing something?
or use some kind of "program key" in the client - which would obviously be a bad idea
ok -- so an alternative I guess could have a program mint them via cpi -- that seems fine since yeah - the client doesn't really need the mint - just the token that comes out it
Yeah, I'm not sure (not v familiar with nft stuff), but I would be surprised if your client could just directly mint an nft
i could be doing it wrong - i'm trying to kind of copy the approach of "editions" that metaplex uses -- where each "edition" of an NFT is another mint and another token -- so I assumed that new mint would be owned by the holder of the "master" edition of the NFT
Mm, who has authority over the mint? It would be odd to be able to directly mint new tokens straight from the client, since that mean the client would have to have authority over the mint
ok that makes sense -- is what i'm trying to do impossible?  i.e. i want to let people mint new NFTs off an NFT they have -- or you are saying i need to call the underlying token program directly via lower level signing of a transaction with the wallet?
like one contract deploying many subcontracts
How do i implement factory contract in anchor
No, nothing is off with the way you're using the wallet, the issue is just that you can't get access to a wallet keypair in general (eg in the browser phantom will *never* give you the keypair)
the createMint code again :
`  let mintAccount = await spltoken.Token.createMint(
    provider.connection,
    userKeypair,
    userKeypair.publicKey,
    null,
    0,
    spltoken.TOKEN_PROGRAM_ID
  );`
and ended up with a mint on devnet - https://explorer.solana.com/address/H3QaBncWUqweyS4gja5LYMtSKvWzKPSjRU8FrV6xiKBr?cluster=devnet
i..e rather than use the wallet I did this:
`  //let userKeypair = wallet;
  let userKeypair = web3.Keypair.generate();
  let fromAirdropSignature = await provider.connection.requestAirdrop(
    userKeypair.publicKey,
    web3.LAMPORTS_PER_SOL,
  );
  // Wait for airdrop confirmation
  await provider.connection.confirmTransaction(fromAirdropSignature);`
actually the code seems to work if I generate a new keypair right before calling it -- so I guess something is off with the way I'm trying to use the wallet I think.
I guess I am a bit lost on the logic behind which account is the one the program sees as "Given" in my code, and how I can verify it is owned by the executing program (which I assume is just the pubkey I put in declare_id)
aand it seems to succeed
i will do that now that test passes
Ok, so you have an explicit `anchor deploy` step?
i just started spamming anchor test and build until test passed, but I truly don't understand why.

To answer your question <@!134416332509675520> I am runnign my tests against a local validator
Makes sense. That's what I thought
E.g. what does `lsof -i :8899` say?
Or are you letting `anchor test` spin one up for you?
Are you running your tests against a running solana validator?
anchor test after build
at what point are you getting this error?
something about a caller and callee, what I am wondering though is if the pubkey I put for declare_id is the same one I Have in program-logs, why am I getting this error?
So I am getting an error when I test saying "The given account is not owned by the executing program", I went through discord but others came to solutions that I didn't understand
With my understanding, no
is there any way to get account info with pub key in the program itself
gotchu
It's actually a bit annoying, for a variable number you'll have to use `remaining_accounts` (try searching the anchor repo for examples)
prolly a dumb question but how do i accept an array of accounts in a func?
v0.19, and there are just more of them as far as I know
And my real question is why? (Not why, I’m pissed I have to learn new error codes, but why, strictly a curiosity)
Hey, dumb question, but when did the error codes change from ~300 to ~3000
yep, gotcha
You will have to pass those accounts in from the client
how do i make it so that i can capture accounts which i can later transfer tokens to
so the array im accepting while deploying, it was a list of addresses
gotchu
Having just a pubkey isn't enough
Ah, no, in solana you always have to pass in any accounts you want to use
how do use just the pub key of someone to transfer them sol
```pub fn send_sol(ctx: Context<SendSol>, amount: u64) -> ProgramResult {
        // Get a reference to the account and increment total_gifs.
        let ix = anchor_lang::solana_program::system_instruction::transfer(
            &ctx.accounts.from.key(),
            &ctx.accounts.to.key(),
            amount,
        );
        anchor_lang::solana_program::program::invoke(
            &ix,
            &[
                ctx.accounts.from.to_account_info(),
                ctx.accounts.to.to_account_info(),
            ],
        )
    }```

here, when invoking, i don't have access to `account_info()`
What do you mean?
No, they're just regular rust static vars, right in the program itself
+1
like, the anchor_lang transfer thing asks for account info
How are static variables stored? Are they baked into the program itself? or anchor automatically creates an account for that?
or is it even possible?
also, how do i transfer sol with just the public key?
awesome!
Yeah then by far the simplest thing is to just bake them in
lol no, for now i don't want to change the vars i guess
But if you want to change those variables you can always just redeploy the whole program 😛
It can have *immutable* static variables (no global mutability though)
i see, does the static vars work though?
i'm really new to solana so was confused if the program can maintain state
Easiest way would be to just bake them into your program as static variables
You can initialize an account with the data you want to store, and pass this account pubkey from the frontend to you functions later on
I get the same error
did you find a solution ?
later, access them in rest of the functions. how do i go about it?
hey folks! i want to accept some params & store them while deploying the rust program, like admin pub key and an array with some info.
Awesome. Thanks for helping
The provider is an abstraction over both the connection as well as the wallet—so I wouldn't expect you to almost ever use the connection directly
On a related topic can I ask some more noob questions? In which context would one use the methods in connection and when in provider?
Ohh okay I see.
The connection itself won't know about the provider wallet
Think you actually want to use `provider.send` rather than just using the connection
```  const provider = anchor.Provider.env();
  const connection = provider.connection;
``` to be precise
```const connection = provider.connection;```. Anything unusual here?
Hmm, how have you defined `connection` here?
Stuck on something real noobish. Why would this testing code fail with `Signature verification failed`? `MyAccount` is a super simple account struct containing a single pubkey member
```
    const myAccount = anchor.web3.Keypair.generate();
    const initTokenAccountIx =
      await program.account.myAccount.createInstruction(myAccount);
    const tx = new Transaction();
    tx.add(initTokenAccountIx);
    await provider.connection.confirmTransaction(
      await connection.sendTransaction(tx, [myAccount]),
      "confirmed"
    );
```
oh ok - good luck 🙂
windows subsystem linux. currently trying to reinstall it and start all over
yeah 🙂 you can try it - i don't know if it will help but may give you more clues -- "bongo" is just whatever you called the import - i used bongo to try and be funny, but i realize it might be confusing - sorry
what is wsl?  and what error do you get?
I guess look at the first error and try and resolve that - -and then keep doing that -- i.e. 
`warning: zstd\lib\compress\fse_compress.c:21:10: fatal error: hist.h: No such file or directory` you might have luck googling that -- or looking into "zstd" -- looks like something weird with your rust install -- but im a complete rust newbie and also i run on mac - sorry!  if you are really struggle with windows it might be worth seeing if you can run a virtual linux machine maybe ?  if you are spending weeks might be worth looking into.  Sorry though!
(There's about a 50/50 chance that any such sha256 hash lands on the ed25519 curve)
I think this is easiest to understand by reading the source code for findProgramAddress. A program-derived address is just a sha256 hash under the hood, of the seeds + bump + program_id (plus a fixed string, not important). The purpose of the bump is just to make sure the resulting 32 bytes returned by the hash function *aren't* a valid ed25519 public key.
whenever i try to run `anchor test` it brings me to an error when trying to build  `solana-program` so it fails
hi! im trying to setup anchor and solana on wsl
<@!912046857000194158> <@!134416332509675520> can you suggest me some more advance codes to become more advance in anchor and solana
these are some awsome tutorials for beginers
<@!912046857000194158> <@!134416332509675520> thanks these were awsome tutorials for beginers just finished testing those
Why I even need it?
What is bump in findProgramAddress? Is there any docs about it?
a"type":{"defined":"Hash"}
Would the following code be valid??
```
    // the token account of owner
    #[account(
        init,
        payer = owner,
        associated_token::mint = mint,
        associated_token::authority = owner,
    )]
    owner_token_account: Account<'info, token::TokenAccount>,
```

I'm trying to do this later in the instruction, 
```
let seeds = &[&AUTH_PDA_SEED[..], &[_auth_pda_bump]];
// cpi call to mint 1 token to owner
        let cpi_accounts = token::MintTo {
            mint: ctx.accounts.mint.to_account_info(),
            to: ctx.accounts.owner_token_account.to_account_info(),
            authority: ctx.accounts.auth_pda.to_account_info()
        };
        let cpi_program = ctx.accounts.token_program.to_account_info();
        token::mint_to(CpiContext::new_with_signer(cpi_program, cpi_accounts, &[&seeds[..]]), 1)?;
```

But I am getting this error, 
`'Program 2HHQPmSdaRfhb5vVragacdGhcXFbT3e6cS4ei56J3ZLa failed: Cross-program invocation with unauthorized signer or writable account'`
Please guys I’ve been trying to install anchor on my windows machine for weeks now. I’m stuck here -

The following warnings were emitted during compilation:

warning: zstd\lib\compress\fse_compress.c:21:10: fatal error: hist.h: No such file or directory
warning:    21 | #include "hist.h"       /* HIST_count_wksp */
warning:       |          ^~~~~~~~
warning: compilation terminated.
warning: zstd\lib\compress\hist.c:20:10: fatal error: hist.h: No such file or directory
warning:    20 | #include "hist.h"
warning:       |          ^~~~~~~~
warning: compilation terminated.

error: failed to run custom build command for `zstd-sys v1.4.18+zstd.1.4.7`

Caused by:
  process didn't exit successfully: `C:\Users\HP\AppData\Local\Temp\cargo-installZ5pUrb\release\build\zstd-sys-f7e5dc0bb30787a0\build-script-build` (exit code: 1)

  --- stderr
  error occurred: Command "gcc.exe" "-O3" "-ffunction-sections" "-fdata-sections" "-m64" "-I" "zstd/lib/" "-I" "zstd/lib/common" "-I" "zstd/lib/legacy" "-fvisibility=hidden" "-DZSTD_LIB_DEPRECATED=0" "-DZSTDLIB_VISIBILITY=" "-DZDICTLIB_VISIBILITY=" "-DZSTDERRORLIB_VISIBILITY=" "-DZSTD_LEGACY_SUPPORT=1" "-o" "C:\\Users\\HP\\AppData\\Local\\Temp\\cargo-installZ5pUrb\\release\\build\\zstd-sys-302cf417acc75ab8\\out\\zstd\\lib\\compress\\fse_compress.o" "-c" "zstd\\lib\\compress\\fse_compress.c" with args "gcc.exe" did not execute successfully (status code exit code: 1).


warning: build failed, waiting for other jobs to finish...
error: failed to compile `anchor-cli v0.19.0 (https://github.com/project-serum/anchor?tag=v0.19.0#3afd1a22)`, intermediate artifacts can be found at `C:\Users\HP\AppData\Local\Temp\cargo-installZ5pUrb`

Caused by:
  build failed
yeah -- i mean - i don't know if it will help -- but then you can see what wallet-adapter-react has for methods
Hello, can I have an idea about 'Custom program error: 0xa8' 
When I make this transaction?

```
await program1.rpc.register(new anchor.BN(0), {
  accounts: {
    myAccount: dataAccount,
    program: program2.programId,
    authority: clientWalletAccount.publicKey,
  },
})
```
works now
alan ur a G
omfg
You forgot to mark that account as mut
`foraz9cGYqhwYVHmTo68GU4ED1zLFUD25ZWPTj9S4BX's writable privilege escalated`
```
Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account 
    Program 6qCDFG94uAzBniiAn2HqzbekKq7gozR2tMKzEBEHJTTz invoke [1]
    Program 11111111111111111111111111111111 invoke [2]
    Program 11111111111111111111111111111111 success
    foraz9cGYqhwYVHmTo68GU4ED1zLFUD25ZWPTj9S4BX's writable privilege escalated
    Program 6qCDFG94uAzBniiAn2HqzbekKq7gozR2tMKzEBEHJTTz consumed 16635 of 200000 compute units
    Program 6qCDFG94uAzBniiAn2HqzbekKq7gozR2tMKzEBEHJTTz failed: Cross-program invocation with unauthorized signer or writable account
```
Can you print the full program log?
Im working on building a simple contract with a deposit and withdraw function for an spl token.  I am planning on using the spl anchor approve instruction in order to delegate tokens when the deposit function is called. I am now attempting to figure out how to create a withdraw function.  What would be an appropriate instruction to use to “withdraw” or revoke access to a specific quantity of tokens?
I've tried using like every form of invocation to invoke the instruction I can find but im at a loss
& `Cross-program invocation with unauthorized signer or writable account`
Getting `Error: Account does not exist`
I have no idea why I can't send SOL here.

```
        let instruction = solana_program::system_instruction::transfer(
            &ctx.accounts.authority.key,
            &ctx.accounts.fora_community.key,
            CREATE_ACCOUNT_FEE
        );

        // Invoke the system program to transfer funds
        let transfer_result = solana_program::transaction::invoke(
            &instruction,
            &[
                ctx.accounts.system_program.to_account_info().clone(),
                ctx.accounts.authority.to_account_info().clone(),
                ctx.accounts.fora_community.to_account_info().clone(),
            ],
        );
```
If I airdrop a wallet, does it get created or do I have to use SystemProgram.createAccount?
any idea what can cause this? started popping after i did some refactoring
```27 | #[program]
   | ^^^^^^^^^^ could not find `__client_accounts_crate` in the crate root
```
<@!134416332509675520> I just wanted to say thank you! I finally figured it all out
i just put this in app.js?
hey folks, just wanted to bump this: can you only provide single instructions to the anchor multisig? seems like transaction only holds the info for a single Instruction
(i.e. when you execute a multisig transaction, can that only execute a single instruction)
and see what is in there -- or at least what your program can see
and then 
console.log(Object.keys(bongo);
ok -- try maybe importing to just 
`import * as bongo from '@solana/wallet-adapter-react';`
same here
can you look inside the 'wallet-adapter-react' folder? 
for example mine has an index.ts file with:
`export * from './ConnectionProvider';
export * from './errors';
export * from './useAnchorWallet';
export * from './useConnection';
export * from './useLocalStorage';
export * from './useWallet';
export * from './WalletProvider';`
oh ok 🙂 thanks
Ah, ok, yeah, you won't be able to use that API unfortunately (it's just not written quite right, you'll have to jump to source and re-do what it's doing under the hood—irritating)
where i pass in the wallet from useWallet -- i guess it kind of makes sense that the wallet's key isn't just available
trying this 
`  let userKeypair = wallet;
  let mintAccount = await spltoken.Token.createMint(
    provider.connection,
    userKeypair,
    userKeypair.publicKey,
    null,
    0,
    spltoken.TOKEN_PROGRAM_ID
  );`
oh - i get this error: 
`TypeError: unexpected type, use Uint8Array`
What do you mean? What goes wrong?
Ordinarily you would use anchor's `init` attribute to handle this
module has no exports
Compiled with problems:

ERROR in ./src/App.js 24:0-16

export 'getPhantomWallet' (imported as 'getPhantomWallet') was not found in '@solana/wallet-adapter-wallets' (module has no exports)


ERROR in ./src/App.js 41:17-26

export 'useWallet' (imported as 'useWallet') was not found in '@solana/wallet-adapter-react' (module has no exports)
not sure why the error requires something to export from
yeah I think I just tried importing more random things to fix it
and see if its truly not there or something else is bungling it?
maybe try and remove things you may not need - i.e. make a small page with only that import
eek
sorry - it does look fine
Im not sure how to go about making sure the versions are all correct and compatible
which one did you use?
copy pasting a configuration from another github repo did the job for me
you need to be careful which version to use. versions are super fragile on this package
i.e. show where you are importing it?
can you show the code?
been trying to test an app and I keep getting this error 

ERROR in ./src/App.js 41:17-26

export 'useWallet' (imported as 'useWallet') was not found in '@solana/wallet-adapter-react' (module has no exports)

any clue why this is? I have been banging my head against a wall over this all day, I should have the dependencies correct
is it not possible to call the spl.Token program in javascript with a wallet?
Anyone knows how I could pass a uninitialized account info to something like Account<'info, T>?

The SC will create the account if needed and I would like to just use the method `reload(&mut self)` after that to get data on the Account struct
<@!134416332509675520> sir, I just got back home and sent an nft directly from Phantom. The associated token account I derived is correct. It seems something is wrong with the way I use `createAssociatedTokenAccountInstruction()`

This is how I use it

```
Token.createAssociatedTokenAccountInstruction(
          ASSOCIATED_TOKEN_PROGRAM_ID,
          TOKEN_PROGRAM_ID,
          mintAddress,
          toTokenAccount,
          provider.wallet.publicKey,
          provider.wallet.publicKey
        )
```
I don't get where it can go wrong
Thank you, I will look into this
I think there is a chainlink oracle to do so, at least by november this was not possible in pure solana i remember. would have to dig in though, but you should be able to find stuff when you google `solana chainlink randomness´ or so. maybe someone else knows more
is there a way to add guaranteed randomness?
thanks man
gotcha, perfect
Nope (hence the existence of wrapped sol, to bring native sol into the spl token ecosystem)
nvm
I thought SOL itself was an SPL token as well
ooooh
Yes, *all* spl tokens go in token accounts (sol isn't an spl token)
but other SPL tokens have token accounts?
It's an account all by itself, owned by the system program
You should try taking your phantom wallet address and sticking it in explorer.solana.com
You might be thinking of "wrapped sol", which is indeed a tokenized version of sol
That store lamports but no data
Wallets are accounts all by themselves
wut
Nope
don't wallets have an associalted SOL token account?
Why are there any token accounts at all here?
But what token accounts are you referring to?
yes, so I have to pass in or derive their token accounts then?
Assuming you're transferring sol
Those don't sound like token accounts, just regular system program accounts
the signers and the apps wallet
Wouldn't expect anything to be derived for you 😛
Which token accounts?
last q, do i pass in their token accounts or does it derive that under the hood?
you're a king alan
If you're transferring sol from an account owned by the system program, yeah, you have to use the system program to do it
Yes, they're all CPIs (they have to talk to the spl token program)
in this case I could just use solana_program::system_instruction::transfer?
Are all anchor spl_token transfer CPIs? I will need escrows in the long run so I just went with what examples I could find to get the tokens transferring.
Yeah, that sounds like a regular transfer, not sure why you'd need to break in into two hops via an escrow
Here's where anchor does error parsing: https://github.com/project-serum/anchor/blob/master/ts/src/program/namespace/rpc.ts#L32
from : signer
to: appPubkey
What do you mean by a 1:1 transfer?
I have an escrow working fine but if I just want to send a 1:1 transfer in the contract; basically pay our apps token account a fee; do I even need an escrow?


//////////////////////////////////////////////////////////////////////////////////////////

lemme try increasing the size
isn't it supposed to show another error then ?
could you be running out of space on the account?
oh sorry
hmmm - maybe the objects get changed by the first call somehow?
it worked before i've no idea what i messed up
adding an item to a list
ya
and calling from js?
no they are the same calls
your error - I mean just guessing - maybe you added something to it the 2nd time that prevented serialization?  what changes between invocations?
^^ oh its definitely better -- but direct solana rust dev is always available to us as a reminder 🤓
it abstracts many stuff so i kinda feel very hard to debug 
don't take my word i'm just a beginner `:P`
I heard the term the other day on the solana podcast -- I think anchor in general has reduced the amount of glass chewing so I'm not complaining - just nice to know others feel it too 🙂
chewing glass ? i never saw it xD
is there a chewing glass emoji?  :chewing-glass:  🙂
Ok weird - changing the seed seemed to fix it
i mean it worked on the first one but keep getting error this `0xbbc` error after that
No one had this error ?
https://github.com/project-serum/anchor/blob/4422902e86fbfe2118d0e9fe8ec26596fc312e94/lang/src/error.rs#L115
I'm getting this error when i do the rpc call two times
you dont have to do anything to set that up
every account not declared in the validation struct but passed into the tx will magically appear in `ctx.remaining_accounts`
you dont add remaining accounts, they appear automatically on ctx
I have another program working fine - almost same -- in the same workspace etc.  -- could it be that the PDA is off?  probably something stupid - i'll try and make a new seed and see if it matters
hovering over it, it says: `invalid type`
but idk why there exists this error on `&`
Hey folks! I am trying to add remaining accounts to my struct to be consumed from the context. The params are being passed correctly as per https://docs.rs/anchor-lang/0.4.5/anchor_lang/struct.Context.html
for "The given account is owned by a different program than expected" is this an error in anchor validation or was it rejected by the program?  is there a way to find out which account -- ?  I assume it is the PDA account b/c its the only one passed in that is mutable - or marked as such
checkout the tests/events folder in the anchor repo
and this is what my event looks like on the program ```emit!(TestEvent {
            data: 6,
            label: "bye".to_string(),
        });```
hi everyone, I'm just getting started trying to use Event Emitters in Anchor. Does anyone have an example about how to listen for events on the frontend? This is what I tried on my front end ```createEventManager()
  .then(listener => {
    listener.addEventListener("TestEvent", (event) => console.log(event))
  })
  .catch(err => console.log(err))
``` but ran into this error ```throw new Error(`Could not find program invocation log line`)```
Hey everyone,

Just had a quick question about using Vecs of tuples in a struct. For example, I wanted to have the following:
```
pub struct ExampleStruct {
    pub a: Vec<(u8, u8)>,
}
```
This is able to build and deploy but running anchor test gives me a `User defined types not provided error`. I'm assuming that this means that Vecs of tuples aren't currently supported in the IDL.

Is my understanding here correct? If so, is there a workaround so that I could do something similar to this? I was thinking maybe `enum`s but that might be expensive. Thanks!
is there any way to re-run tests every time a file is saved? like a `anchor test --watch` flag or something similar?
is my seed maybe colliding with an existing program?  seems unlikely
The size matters, 1232 bytes is max
anyone have a code example on how to close an account?
`The given account is owned by a different program than expected` --- did I maybe generate the PDA incorrectly?
but that also means from the clientside on a dapp, the user will have to approve 3 transactions correct? hmmm
what are the limits around number of instructions in a transaction?
hmm no but mb someone else does
interesting, do you have any resources I can learn more to implement this?
and you also might have to use 3 tx and use delayed randommness cause otherwise your randomness can be gamed
you can add checks to your program that prevent that
I'm not sure, I'm still learning solana programs tbh
transaction 1 returns account to sent token to, transaction 2 sends it to that address
Isnt it possible for somebody else to just call my transaction 2 knowing my program_id
im not following
right, but how do I prevent anybody from sending the second type of transaction which specifies the account
yea I meant that you choose it onchain from the list of addresses in the first tx
its why I want to determine the recipient account onchain to prevent malicious intent from clientside
was thinking about that before but could it be a security issue if someone directly calls the second tx
but you could do it in two transactions. first, you send a tx that randomly chooses address key from the list you have stored in an account somewhere. you save that address in the tx. then in a second tx, you send tokens to that address
if your list is small, you can do this but if it's large it's not possible in a single transaction because all accounts have to be passed into the transaction and the tx has a size limit
Like I have a program account that stores an array of addresses and I randomly select which to transfer to when the program runs
and the reason for there being two options is that sometimes, you want an account to sign that is not a Signer type. then you can use the signer contraint. we might deprecate this constraint completely and add types like `AccountSignerMut`
Type Signer is the more up-to-date way (although they do the same thing)
so if my instruction takes an account and i wanna check if its a signer what is the preferred way to do it ? define its type as Signer or use #account(signer) ?
Can someone pls tell? 
I have the account as a parameter in the form of 
#[account(mut)]
 pub service_account: AccountInfo<'info>

And I want to first see how much balance of a mint this service_account has
And then debit the particular token
yes. really struggling with architecture here
<@!915682383905316864> <@!161709591220977664> <@!831450660146642974> <@!248066053161222144> can you guys pls help?
How do I read the amount of another token knowing its mint, (say SRM) in rust inside the smart contract?
Hey guys, I just tried `anchor test` but, there's some error. So I tried `sudo anchor test` and I got an error too. I'm practicing on Ubuntu 20.0.4 LTS and each version is below. I want to learn how to develop with anchor and solana. Please somebody help me 😫 

nodejs - 16.13.1
npm - 8.1.2
rustup - 1.24.3
rustc - 1.57.0
cargo - 1.57.0
solana-cli - 1.9.1
anchor-cli - 0.20.0

```
newmynixx@LAPTOP-JSMKVSS3:~/myepicproject$ anchor test
BPF SDK: /home/newmynixx/.local/share/solana/install/releases/1.9.4/solana-release/bin/sdk/bpf
cargo-build-bpf child: rustup toolchain list -v
cargo-build-bpf child: rustup toolchain link bpf /home/newmynixx/.local/share/solana/install/releases/1.9.4/solana-release/bin/sdk/bpf/dependencies/bpf-tools/rust
cargo-build-bpf child: cargo +bpf build --target bpfel-unknown-unknown --release
error: failed to create directory `/home/newmynixx/myepicproject/target/release`

Caused by:
  Permission denied (os error 13)
newmynixx@LAPTOP-JSMKVSS3:~/myepicproject$ sudo anchor test
Error: No such file or directory (os error 2)
```
8 is the minimum, max for CPI initiated calls (accounts created with init) is 10kb (10,400 bytes to be exact)
I need it to be really big. My account contains 4 fields, each being a vector of size 100
What is the maximum value of space= that I can use?
phantom wallet always shows the TokenAccount as long as it has a balance and the owner is the wallet address?
eg: if its not the ATA PDA, any custom PDA, as long as the owner is the wallet address and it has some balance, it will show right?
who are you transferring to then? its like wanting to pay someone money. only not knowing who someone is.
if its a seed constraint error, it will throw seeds violated. its likely your signer priviledges arent correct when invoking cpi. check that if you're calling cpi, all accounts that need to be signers are signers
is it possible to have different migration files kick off for different networks? when running `anchor migrate` ?
Hit a roadblock on a CPI calls to a contract pre-deployed locally. 
I have another contract using a PDA for `invoke_signed`, with correctly matching seeds. 
But, I keep on getting the `signer privilege escalated`
I also have the `#[account(mut)]` constraint set on the PDA

Are there other reasons for getting this error besides mis-matching seeds? 
Appreciate your help in advance 🙏
Is it possible to do a token transfer in my program without passing in the recipient? I want to randomly token transfer to an account and it's not feasible to pass in all possible accounts from the client side
is the owner the same as the authority?
for a TokenAccount
**What am I doing wrong here? There is no error here when i call the create instruction but the arrays seam to be empty id: [].
how should I fill them?**
**I have a struct **
`#[account]
pub struct Ledger {
    pub id: Vec<String>,
    pub amount: Vec<u64>,
    pub time: Vec<String>
}`
**And I want to initialize them to an empty vector in the create method. **
`#[derive(Accounts)]
pub struct Create<'info> {
    #[account(init, payer = user, space = 8 + 64 + 64 + 64 + 64)]
    pub ledger: Account<'info, Ledger>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
   
}`
`**In this create function i am doing the following**
    pub fn create(ctx:Context<Create>) -> ProgramResult {
        let ledger = &mut ctx.accounts.ledger;
        bets.id = get_id();
        bets.amount = get_amount();
        bets.time = get_time();
        Ok(())
    }`

**All these get_ functions return an array of size 20 which are empty
for eg: -**
`pub fn get_id() -> Vec<String> {
    let mut id_vec: Vec<String> = Vec::new();
    for _ in 0..10 {
        id_vec.push(DUMMY_TX_ID.to_string())
    }
    return id_vec;
}`
<@!134416332509675520> 
Would you like to share the code that is using the spl_math library's U256?
youre welcome 🙂 theres more on its way
the test repo is a super useful way of understanding the ts side of anchor (the 0.20 docs.rs stuff has been super great for the rust side) so thanks for putting them all together
iirc I created the public key there manually instead of importing it from solana/web3 cause they actually hadnt added it by then
correct!
🤦‍♀️ thank you that makes so much more sense
OH but not of bpf-upgradeable-state (the program from the anchor test); it's an actual *solana* internal
it has nothing to do with the program except for generating the programdata address in the tests
thats the key of the upgradeable bpf loader
unless it was used to gen `bpf_upgradeable_state-keypair.json` and that's why it's not in the repo?
`BPFLoaderUpgradeab1e11111111111111111111111` is used only in the findprogramaddresssync call and nowhere else in the repo
the anchor.toml file and the declare_id have a different key than the one used in the test in the code I shared above
yes the way to get the `programdata_address` is the same for all upgradeable programs
> the BPFLoader key isnt the one actually used

wdym?
odd internals question:
``` const programDataAddress = findProgramAddressSync(
    [program.programId.toBytes()],
    new anchor.web3.PublicKey("BPFLoaderUpgradeab1e11111111111111111111111")
  )[0];
```
This is from the anchor `bpf-upgradable-state` test. The `BPFLoader` key isn't the one actually used to deploy the program, but I'm assuming the test passes (since this is from the github). Is the seed used to find the program data address always the program id? And why is that different from the second input (which the api lists as `programId` but here is a public key that isn't used anywhere else).
and could this be used for a vault program?
what does the anchor_spl::token::Approve function do?
Anyone know why my transaction is failing to confirm on devnet? Using custom rpc as well. Keeps timing out after 30s
for sure
One sec let's dm 😆  I want to get the source and try running on my end and play with it a bit
sorry this is missing where some of the vars are initialized lemme send that too
```
 it('It lets you deposit', async () => {

    const offer = anchor.web3.Keypair.generate();
    const [escrowedTokensOfOfferMaker, escrowedTokensOfOfferMakerBump] = await anchor.web3.PublicKey.findProgramAddress(
      [offer.publicKey.toBuffer()],
      program.programId
    )
    let offerMakerCurrentCowAmounts = (await cowMint.getAccountInfo(offerMakerCowTokenAccount)).amount.toNumber();
    console.log(offerMakerCurrentCowAmounts)

    await program.rpc.deposit(
      escrowedTokensOfOfferMakerBump,
      new anchor.BN(2),
      {
        accounts: {
          offer: offer.publicKey,
          whoMadeTheOffer: program.provider.wallet.publicKey,
          tokenAccountFromWhoMadeTheOffer: offerMakerCowTokenAccount,
          escrowedTokensOfOfferMaker: escrowedTokensOfOfferMaker,
          kindOfTokenOffered: cowMint.publicKey,
          tokenProgram: spl.TOKEN_PROGRAM_ID,
          systemProgram: anchor.web3.SystemProgram.programId,
          rent: anchor.web3.SYSVAR_RENT_PUBKEY
        },
        signers: [offer]
      }
    );
    console.log("Starting Withdraw")
    await program.rpc.withdraw(
      {
        accounts: {
          offer: offer.publicKey,
          whoMadeTheOffer: program.provider.wallet.publicKey,
          whereTheEscrowedAccountWasFundedFrom: offerMakerCowTokenAccount,
          escrowedTokensOfOfferMaker: escrowedTokensOfOfferMaker,
          tokenProgram: spl.TOKEN_PROGRAM_ID,
        },
      }
    );
    
    //assert.equal(2, (await cowMint.getAccountInfo(escrowedTokensOfOfferMaker)).amount.toNumber());
    //offerMakerCurrentCowAmounts = (await cowMint.getAccountInfo(offerMakerCowTokenAccount)).amount.toNumber();
    //console.log(offerMakerCurrentCowAmounts)
    //let cook = (await cowMint.getAccountInfo(escrowedTokensOfOfferMaker)).amount.toNumber();
    //console.log(cook)



  });
```
Can I see the client side test as well
let me know if you need anything else!
Here is the source code for the instruction:
```
use anchor_lang::prelude::*;

use crate::state::*;
use anchor_spl::token::{Mint, Token, TokenAccount};

#[derive(Accounts)]
pub struct Withdraw<'info> {
    #[account(
        mut,
        constraint = offer.who_made_the_offer == who_made_the_offer.key(),
        close = who_made_the_offer
    )]
    pub offer: Account<'info, Bank>,

    #[account(mut)]
    pub who_made_the_offer: Signer<'info>,

    #[account(mut)]
    pub where_the_escrowed_account_was_funded_from: Account<'info, TokenAccount>,

    #[account(
        mut,
        seeds =[offer.key().as_ref()],
        bump = offer.escrowed_tokens_of_offer_maker_bump
    )]
    pub escrowed_tokens_of_offer_maker: Account<'info, TokenAccount>,

    pub token_program: Program<'info, Token>,
}

pub fn handler(ctx: Context<Withdraw>) -> ProgramResult {
    anchor_spl::token::transfer(
        CpiContext::new_with_signer(
            ctx.accounts.token_program.to_account_info(),
            anchor_spl::token::Transfer {
                from: ctx
                    .accounts
                    .escrowed_tokens_of_offer_maker
                    .to_account_info(),
                to: ctx
                    .accounts
                    .where_the_escrowed_account_was_funded_from
                    .to_account_info(),
                authority: ctx
                    .accounts
                    .escrowed_tokens_of_offer_maker
                    .to_account_info(),
            },
            &[&[
                ctx.accounts.offer.key().as_ref(),
                &[ctx.accounts.offer.escrowed_tokens_of_offer_maker_bump],
            ]],
        ),
        ctx.accounts.escrowed_tokens_of_offer_maker.amount,
    )
}
```
thank you for your willingness to help!
sounds good, here is the error message:
```Transaction simulation failed: Error processing Instruction 0: custom program error: 0x65 
    Program FZUqSDoE9P4PUEmiwgDSUKfE4cLp3KxfA8Z5ocbRrFS4 invoke [1]
    Program log: Custom program error: 0x65
    Program FZUqSDoE9P4PUEmiwgDSUKfE4cLp3KxfA8Z5ocbRrFS4 consumed 2567 of 200000 compute units
    Program FZUqSDoE9P4PUEmiwgDSUKfE4cLp3KxfA8Z5ocbRrFS4 failed: custom program error: 0x65
Translating error SendTransactionError: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: custom program error: 0x65
    at Connection.sendEncodedTransaction (/Users/michaelgiardino/Desktop/animal-trading-farm-public/node_modules/@solana/web3.js/src/connection.ts:3689:13)
    at processTicksAndRejections (node:internal/process/task_queues:96:5)
    at Connection.sendRawTransaction (/Users/michaelgiardino/Desktop/animal-trading-farm-public/node_modules/@solana/web3.js/src/connection.ts:3649:20)
    at sendAndConfirmRawTransaction (/Users/michaelgiardino/Desktop/animal-trading-farm-public/node_modules/@solana/web3.js/src/util/send-and-confirm-raw-transaction.ts:27:21)
    at Provider.send (/Users/michaelgiardino/Desktop/animal-trading-farm-public/node_modules/@project-serum/anchor/src/provider.ts:114:18)
    at Object.rpc [as withdraw] (/Users/michaelgiardino/Desktop/animal-trading-farm-public/node_modules/@project-serum/anchor/src/program/namespace/rpc.ts:24:23) {
  logs: [
    'Program FZUqSDoE9P4PUEmiwgDSUKfE4cLp3KxfA8Z5ocbRrFS4 invoke [1]',
    'Program log: Custom program error: 0x65',
    'Program FZUqSDoE9P4PUEmiwgDSUKfE4cLp3KxfA8Z5ocbRrFS4 consumed 2567 of 200000 compute units',
    'Program FZUqSDoE9P4PUEmiwgDSUKfE4cLp3KxfA8Z5ocbRrFS4 failed: custom program error: 0x65'
  ]
}
```
Lets keep it on here I think in case anyone else runs into this issue. If it gets to be a lot though we can maybe dm.
for sure, can I send you a dm or should i send it here?
Ah, custom program errors are fun 😆  are there any logs above that error? Gnna need to see some code to help out though.
Can anyone help me with debugging a `Program log: Custom program error: 0x65` issue. I am attempting to call the spl transfer instruction and im having a hard time figuring out where to look for the issue.
I'm also curious if you would even want multiple different PDA's for different accounts. I don't really see an obvious reason for needing many different PDA's. But I'm new to this stuff too.
I'm currently playing around with making vaults owned by a PDA that users can deposit sol to and then withdraw from. Basically create a PDA, then you create the vault which is a SystemAccount for that PDA so the program will have authority over the vault account. You will also need your own transfer_sol function in your program that does a CPI using invoke_signed. You create the the transfer instruction using the system_instruction::transfer function. You will then need also include the signers_seeds, the ones you used when creating the PDA, with the invoke_signed call so the runtime can verify the program calling this invoke_signed with the transfer instruction is the proper authority for transfering sol.
What do you mean by close PDA? Do you mean close the PDA Account? I haven't got to closing accounts yet, but anchor has a functions and attributes for closing accounts. The PDA (Program Derived Address) will always exist as far as I know, as it's just the program_id with some seeds hashed with it for allowing programs to sign transactions. If you know the seeds you can always generate the same PDA, you can't close an address. But you can close accounts associated with addresses.
What are the negative implications of only using one seed/bump for a PDA for different users accounts and just hardcoding it in, rather than saving the seed/bump in an account just taking up extra space?
I'm trying to create a basic "vault" program that keeps a record of balances owed to different people in SOL, and they can deposit and withdraw. Struggling on architecture , PDA, CPI and account types / ownership....

How can I make a vault account that holds sol and is owned by the program that changes its balance?

What additional accounts types would I have to have for add / withdraw?

Trying to make sense of Neodyme's examples: https://github.com/neodyme-labs/neodyme-breakpoint-workshop/blob/main/level0/src/processor.rs


//////////////////////////////////////////////////////////////////////////////////////////

Should i just create a new program and copy source code over
I want to deploy my program with a different program ID but i'm not sure the best way to go about it?
I'm getting this `Transaction simulation failed: Error processing Instruction 1: instruction modified the program id of an account` I've searched everywhere for that error without much success. There are some examples in this channel but none of the solutions worked. Can someone point me in the right direction?

My program is just minting some coins, transfering them and burning them. Here's the link to the detailed output I get when running `anchor test`: https://app.warp.dev/block/FWYGAhgRrEo1HhgbWvG1Kw

And this is the link to the gh repo: https://github.com/Francososa/francoin
<:thankyou:753524665930088508>
https://github.com/ironaddicteddog/anchor-escrow/blob/103578b363b414565a74adb935d2bfa9671e7d51/programs/anchor-escrow/src/lib.rs#L233
which are the best examples of wrapper to do cpi between anchor program and solana program? (except anchor_spl) <:scaredcat:848238059610439720>
I Can't figure out try Different system Ubuntu and Windows
how would someone handle this situation? if you need to change the structure of an account
Thank you. Do  you mean declaring my PDA in the context struct as a `#[account(mut, signer)]` ?
<@479752955655094272> I just kept redeploying 😂 and it worked
how do I close an account? and what are the requirements?
how did you fix it ?
I dont think so, I did it manually 💔 the other day
is there a way for anchor to rename my project from top to bottom? something from `test_project` to actual `project_name`?
Hi <@!501570363566587905> 
Can I implement the deserialize the accounts to get accounts array on the instruction?
<@!501570363566587905> <@!915682383905316864>
Does anyone have a suggestion about writing tests for such a program?
super thanks
You can use `metaplex-token-metadata` crate, require the metadata account in your Context struct as `Account<'info, Metadata>`, and you can read the fields inside with `ctx.accounts.metadata` inside your handler. The metadata PDA can be found by 
`const [metadataPubkey, metadataPubkeyBump] = await PublicKey.findProgramAddress([METADATA, METADATA_PUBKEY.toBuffer(), nftMint.toBuffer()], METADATA_PUBKEY)` where the constants are "metadata" and metadata programId
I think it can't be done. since them stored on separate blockchain Arweave or ipfs
Is there any way to get it if it is metaplex nft?
yes, but it can be changed
Are they metaplex nfts?
Is there any way I can get nft attributes in solana program?
i have a send sol function in which im sending sol from a user to my vault account but then in withdraw function which i made i cant withdraw sol from vault account to the users account because of ```Cross-program invocation with unauthorized signer or writable account ``` <@!915682383905316864>
actaully fixed that error but im getting another one
Hi everyone 🙂

I'm trying to write local tests for a program that needs to read some Metaplex Metadata accounts for given NFTs.

I see that I need to have the `https://crates.io/crates/metaplex-token-metadata` already deployed for me to refer some PDAs and call some instructions on it.

How can I deploy this contract before my tests for local development? Is this the right approach?
Also, you are transferring to the system_program? Is that really what you want to do?
You are transferring from msg_sender (mutating) but the account is not marked mut
afaik u cant
How can I add the accounts array on the context?
Pls reply guys really no other way for me to find this out ⬆️
Can someone pls tell? 
I have the account as a parameter in the form of 
#[account(mut)]
 pub service_account: AccountInfo<'info>

And I want to first see how much balance of a mint this service_account has
And then debit the particular token
```rust

        let ix = anchor_lang::solana_program::system_instruction::transfer(
            &msg_sender.key(),
            &ctx.accounts.system_program.key(),
            amount,
        );

        anchor_lang::solana_program::program::invoke(
            &ix,
            &[
                msg_sender.to_account_info(),
                ctx.accounts.system_program.to_account_info(),
            ],
        );```
```rust
#[derive(Accounts)]
pub struct SenderContext<'info> {
    #[account(mut)]
    pub base_account: Account<'info, BaseAccount>,
    pub msg_sender: Signer<'info>,
    pub system_program: Program<'info, System>,
}```
i got this error while doing that
code: 2000,
  msg: 'A mut constraint was violated'
}
Is it possible to transfer sol in pgorgram to system program
max size is 32. Probably you will have to maintain this mapping of different wallets off-chain
How do I setup a custom rpc node on anchor tests?
```rust
pub fn dynamically_allocate_buffer(ctx: Context<Dynamic>, size: u64) -> ProgramResult {
...
```
these are the main lines of importance
```rust
#[instruction(buffer_seed: u64, buffer_size: u64)]
pub struct Dynamic<'info> {
    #[account(init, payer = authority, space = 8 + 4 + buffer_size,
```
example:
```
error[E0308]: mismatched types
  --> programs/anchor-echo/src/lib.rs:44:10
   |
44 | #[derive(Accounts)]
   |          ^^^^^^^^ expected `u64`, found `usize`
```

```rust
#[derive(Accounts)]
#[instruction(buffer_seed: u64, buffer_size: u64)]
pub struct Dynamic<'info> {
    #[account(init, payer = authority, space = 8 + 4 + buffer_size,
    seeds = [b"dynamic", authority.key.as_ref()],
    bump)]
    pub buffer: Account<'info, Buffer>,
    #[account(mut)]
    pub authority: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[account]
pub struct Buffer {
    pub data: Vec<u8>,
}
```
is it currently possible to dynamically size account space via the `#instruction` macro? context here is I have a struct with a `Vec` that i don't know how large it'll be upfront (and want to allocate _just enough_ space at runtime)

the thing i'm running into is the `derive` macro seems to expect a `usize`, which is strange because vanilla solana expects `u64` --
Can someone pls tell? 
I have the account as a parameter in the form of 
#[account(mut)]
 pub service_account: AccountInfo<'info>

And I want to first see how much balance of a mint this service_account has
And then debit the particular token
Hi <@!501570363566587905> 
Would you please share the code that is using the spl_math U256?
I think you probably omitted parameters of instruction.
Is it possible to search through past events with web3.js, or only to subscribe to future events?
Solved this, was sending an incorrect address for the ATA
I'm not sure what account might be missing?
Hi -- I have the following struct:

```
#[derive(Accounts)]
pub struct ATA<'info> {
    #[account(
        init,
        payer = payer,
    associated_token::mint = mint,
        associated_token::authority = payer,
    )]
    pub token: Account<'info, TokenAccount>,
    pub mint: Account<'info, Mint>,
    pub escrow_account: Box<Account<'info, EscrowAccount>>,
    #[account(mut)]
    pub payer: Signer<'info>,
    pub rent: Sysvar<'info, Rent>,
    pub system_program: Program<'info, System>,
    pub token_program: Program<'info, Token>,
    pub associated_token_program: Program<'info, AssociatedToken>,
}
```

When i try to send a transaction like this:

```
let exchangeTx = program.transaction.ata(
            {
                accounts: {
                    token: toTokenAccountAddress,
                    mint: nft.mint,
                    escrowAccount: currentEscrow.pubkey,
                    payer: publicKey,
                    rent: anchor.web3.SYSVAR_RENT_PUBKEY,
                    systemProgram: anchor.web3.SystemProgram.programId,
                    tokenProgram: TOKEN_PROGRAM_ID,
                    associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID
                },
            }
        );
```

I'm getting the following error: 

Program returned error: An account required by the instruction is missing
Ty for clearing that up, much appreciated!
Whats the max seed length to generatea pda? im trying to generate based on multiple wallets would a hash of the wallets work?
which checks he account data length
it uses pack/unpack
AnchorPy is a client, like anchor-ts. You use it to interact with smart contracts written in Rust using anchor_lang. Anchor itself is an umbrella term
How does anchor differentiate between Account<'info,TokenAccount> and Account<'info,Mint> ? Since for these accounts there is no descriminator and they are deserialized using the u checked version where discriminator is not checked ?
Thank you
Hi all, I’m looking to try out Anchor this week and was wondering if there is any recommendation or functional difference between Anchor, anchor_lang, and AnchorPy?
` rent: anchor.web3.SYSVAR_RENT_PUBKEY,`
Anyone know what account pubkey I should pass as rent (`Sysvar<'info, Rent>` type)
guess it's snake_case rust against camelCase js. So in my case, in order to call down_vote I do 

```
 await program.rpc.downVote({
      accounts: {
        account: newUpVoteAccount.publicKey,
        voter: provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      }
    })
```
on the client. But how it's technically mapped I am not sure. Not that deep into the anchor framework
For constructing transactions myself against a program I'm a bit confused on how the program maps the instructions received to the right function...
oh sorry forgot to include the sizes 

```
 const DISCRIMINATOR_LENGTH: usize = 8;
const PUBLIC_KEY_LENGTH: usize = 32;
const EPOCH_TYPE_LENGTH: usize = 50 * 4;
const TIMESTAMP_LENGTH: usize = 8;
const STRING_LENGTH_PREFIX: usize = 4; // Stores the size of the string.
const MAX_TOPIC_LENGTH: usize = 50 * 4; // 50 chars max.
const MAX_CONTENT_LENGTH: usize = 280 * 4; // 280 chars max.
const DESCRIPTION_LENGTH: usize = 100 * 4; // 100 chars max
const URL_LENGTH: usize = 30 * 4; // 30 chars max url
const NAME_LENGTH: usize = 20 * 4; // 20 chars max name

impl VoteAccount {
    const LEN: usize = DISCRIMINATOR_LENGTH
        + PUBLIC_KEY_LENGTH
        + PUBLIC_KEY_LENGTH
        + STRING_LENGTH_PREFIX
        + EPOCH_TYPE_LENGTH;
}
```

so I guess it is 8 + 32 + 32 + 4 + 200

~~up_vote works flawlessly but the error is thrown for the down_vote call and I don't really get it~~

I think the solution was to change DownVote to: 
```
#[derive(Accounts)]
pub struct DownVote<'info> {
    #[account(mut)]
    pub account: Account<'info, VoteAccount>,
}

```

thus not include signer or program. I don't get it. Maybe because there isn't a signer for update account?
Might be the space you allocate for the VoteAccount. Try 8+VoteAccount::LEN, if VoteAccount::LEN is the size of the struct
on the blockchain
is there a way to get all token accounts of particular mint
hi, I am receiving this error ``` Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Failed to reallocate account data```

when I call the downVote after upVote:

```
 // up_vote allows users to vote on a message
    pub fn up_vote(ctx: Context<UpVote>, message_account: Pubkey) -> ProgramResult {
        let vote_account = &mut ctx.accounts.account;
        vote_account.epoch_type = String::from("upVote");
        vote_account.voter = *ctx.accounts.voter.key;
        vote_account.message_account = message_account;
        Ok(())
    }

    // close account when user downvotes
    pub fn down_vote(ctx: Context<DownVote>) -> ProgramResult {
        //let vote_account = &mut ctx.accounts.account;
        //let voter = &ctx.accounts.voter;
        //vote_account.epoch_type = String::from("");
        //vote_account.close(voter.to_account_info())?;
        Ok(())
    }
```

with voteAccount on these corresponding structs  
```#[derive(Accounts)]
pub struct UpVote<'info> {
    #[account(init,payer=voter,space=VoteAccount::LEN)]
    pub account: Account<'info, VoteAccount>,
    pub voter: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct DownVote<'info> {
    #[account(mut)]
    pub account: Account<'info, VoteAccount>,
    pub voter: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[account]
pub struct VoteAccount {
    pub message_account: Pubkey,
    pub voter: Pubkey,
    pub epoch_type: String,
} ```
 do anyone know what I'm missing?
<a:coding:850830817629437992>
(feel free to create one and open a pr)
no you'd have to make your own wrapper
is it possible to access `token-lending` with `anchor_spl` ? (as per anchor github, i think it's a no)
But the macro approach greatly simplifies the programming model particularly in the context of an e2e app in my opinion.
All the traits and types can be used as a library if you want to use the regular solana entrypoint.
You can do both.
Random Q:  Why did anchor decide to go the macro route instead of being an ordinary library? What specific problems were hard to solve with functions but easy with codegen/macros?
so smth flawed with the way im passing them. i logged all the accounts to verify, everything is well.
im certain it is because of the remaining accounts as passing remaining accounts on other fns breaks as well
it throws this error
Gotcha! I did the same but when I pass the remaining account like below

```
let send_sol_tx = await program.rpc.sendSol(
      new anchor.BN(0),
      new anchor.BN(2),
      {
        accounts: {
          baseAccount: baseAccount.publicKey,
          msgSender: provider.wallet.publicKey,
          user: provider.wallet.publicKey,
          systemProgram: SystemProgram.programId
        },
        remainingAccounts: [aone.publicKey, atwo.publicKey]
      }
    );
```
8 for `count: u64` and 40 for storing `authority: Pubkey` <@!569289717582135296> 
and i think i kinda have to calculate the space by myself
https://solanacookbook.com/references/anchor.html#calculating-account-space-size
i think its for field in the Account struct...
i should've tried `anchor expand` : P
Referring to this, I looked at the anchor examples for this and can't find any problem with my code. Does anyone know what would cause this error ``` Could not find program invocation log line``` from the Event listener on triggering the event?
oh good question - idk sorry
the left and right side of `+`
what is it trying to represent ?
https://github.com/project-serum/anchor/blob/4422902e86fbfe2118d0e9fe8ec26596fc312e94/examples/tutorial/basic-2/programs/basic-2/src/lib.rs#L25
https://github.com/project-serum/anchor/blob/4422902e86fbfe2118d0e9fe8ec26596fc312e94/examples/tutorial/basic-1/programs/basic-1/src/lib.rs#L24
no i mean why not `space = 128` ?
i guess it depends on what you are trying to put in it
`space = 64 + 64` what is this supposed to mean ? isn't giving 128 enough ?
i really am a beginner as well - so I am just guessing


//////////////////////////////////////////////////////////////////////////////////////////

Anchor.toml is probably a different version than your CLI
hey guys i am getting this error can someone help me with it.
How would one serialize instruction data for a program that is not mine? What information do I need to make a CPI to a 3p program somewhere on mainnet?
New to solana/anchor etc and going through some tutorials. The one thing I am trying to do is send SOL from a wallet to the smart contract but I only keep seeing Javascript implementations of this (creating a transaction). Is there an example of how to do this in the Rust code, triggered by a button press in the UI?
Unable to find the account
is there any reason why programs would be uploaded to localnet with different program ids than specified in code? I also have a block of `[programs.localnet]` in Anchor.toml but my programId when deployed still seem to be different
Thanks a lot for your reply.
This is a very good tutorial which demonstrates (among other things) using a PDA to sign/transfer funds.  Well, more specifically it's transferring spl-tokens, but you could do the same with SOL.  https://hackmd.io/@ironaddicteddog/solana-anchor-escrow
Hi <@!134416332509675520> <@!855419683515400223>
Could you let me know if there's any solution to add accounts array on the context?
If not, is there any way to deserialize the accounts on the instruction without context?
what are best practices for composing my on-chain program with other on-chain programs?

e.g. when users use my dapp, I want a bunch of stuff to happen and then a limit order to be submitted to a serum order book. would I do this by:

1. separating these two things into two separate instructions in the same transaction? i.e. a bunch of stuff happening on my dapp is instruction 1, and then submitting a new limit order to serum is instruction 2

2. do a cross-program invocation from my dapp that submits a limit order to serum? i.e. there's only one instruction sent to my dapp, and as part of the instruction's execution, a new limit order is sent to serum
I'm not sure what you need exactly, but there is `anchor verify` to check that local and onchain bytecodes match
hmm, so it seems to be a solana error but I am not sure how to interact with anchor to solve the problem. My struct looks like this ```
#[derive(Accounts)]
#[instruction(content: String,bump: u8)]
pub struct SendMessage<'info> {
    #[account(mut,has_one=authority)]
    pub user_account: Account<'info,User>,
    #[account(
        init,
        payer=authority,
        seeds = [
            b"epoch",
            user_account.key().as_ref(),
            &[user_account.message_count as u8].as_ref(),
        ],
        bump = bump,
        space = 10000  
    )]
    pub message_account: Account<'info, Message>,
    pub authority: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```
where user_account is an already existing account
It seems that this is related to adding dependency to rust smart contract. I have already added this into my cargo file. I am having issues when i am launching mocha tests. I want to know if my serum_dex.so is correctly deployed when i launch anchor test.
I don't know, you can grep sources to find out where this error occurs or ask on solana discord server
Thanks a lot
thanks! In my case I pass two accounts, how do I know where the error occurs?
https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#specifying-dependencies-from-git-repositories
How to correctly add an external library to my anchor project. 
Currently i am adding serum_dex.so to my anchor project and test it.
This is solana program error message and is not specific to Anchor
https://docs.rs/solana-program/1.4.6/src/solana_program/instruction.rs.html#164
how do people debug anchor error messages? this one confuses me  ```
Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Failed to reallocate account data
```
yes
You can take inspiration from here
https://docs.rs/anchor-spl/0.17.0/src/anchor_spl/token.rs.html#261
That's what I'm trying to figure out at the moment.
how are you receiving funds in the PDA? i have been trying, new to anchor, can i dm for a few quick questions haha
How can we manually deserialize an account from its address in rust with anchor?
Thank you. So all I would need to do is fund the PDA?
Hello,
I am writing a smart contract and testing using typescript. I have added dependency with serum_dex. 
My tests are failing while i am trying to create a market.
I want to check weather i have deployed correctly my serum_dex.so on the local validator before launching my tests.
How can i find it out?
Thx
if you can sign with it, then yes
as well as many others
There is one written in `./tests`
Good day! How can I pass additional accounts into `idl`, which I then could access with a `remaining_accounts()` function?
Hi, I have been looking for anchor dev for the past few weeks, and couldn't find one, might as well start to learn how to do it myself.

Any examples on simple escrow program?
Hi guys, just wanted to double check. Is it possible to have PDAs that are payers? (PDA payer).
I'm working on CPI calls to and existing protocol, and one of their instructions expects a particular address parameter to be a payer for the initialization of another account. But, I'm using a PDA (inside my program), since I don't want to rely on a client as a payer.
Hi all, I'm trying to test my program which uses metaplex metadata accounts. Is there any way for me to deploy the metaplex metadata contract in anchor JS tests to create metadata accounts?
vault account is an account created in context struct and is of type accountinfo, how do i get the seed for it
anyone saw this error before ? 0x7e0 working with spl-token faucet
for metaplex js you can do something like :
`const metadata = await Metadata.load(connection, pda`
I am getting this error after i rum anchor test i have installed mocha also still getting anchor command not found please help
it can be changed
Is there any way to get it if it is metaplex nft?
^^ for metaplex specifically?
is there any way to get metadata structure?
i want to use metadata via `Account<'info, Metadata>`, `ctx.accounts.metadata` inside my handler
but i don't know about metadata's structure
and these methods allow you filter --
<@!849284643999842304> -- one way to do it -- and I don't know if this is the best way -- if you look at the spl-token documentation -- https://spl.solana.com/token -- near the bottom it shows some RPC methods
😂  until i get my current program out the door i can't even think about what's next
i haven't even started on that one..
i need some anchor contracts
i will pay you to work on my project if you want 😛
I'm in pain 😩
every single person learning solana is probably saying that
lol <@!616045157925650453>
If anyone is offering any kind of tutoring service i will literally pay to help get my unstuck with a program i'm working on
looking for an example..
ok yeah -- if you know the token is in your local wallet - then you can find the token address from that I think
now i want to use sendToken but input there is this.. i am trying to figure out how to get the token account address .. 
```
interface ISendTokenParams {
  connection: Connection;
  wallet: Wallet;
  // token account address
  source: PublicKey;
  // destination wallet address
  destination: PublicKey;
  mint: PublicKey;
  amount: number | u64;
}
```
this is what i am using.. and it returns
```
  return {
    txId,
    mint: mint.publicKey,
    metadata: metadataPDA,
    edition: editionPDA,
  };
````
<@!569289717582135296> https://github.com/metaplex-foundation/js/blob/main/src/actions/mintNFT.ts#L110
Am in mobile now I will link the repo for more context
Lol no I am saying I can do that now
But I need to know how to do it programatically
yes 🙂
I can even transfer from phantom to another wallet
Yes !
ok -- so when you mint it it had to go to an account -- probably your local wallet
Mint address is returned by the mintNFT function so I can use that, but can’t seem to figure out how to get the token address
In sollet.io it shows those 2 values
Yes I think that is automatically done .. I need the from address.. I don’t think it can be the account holding the SOL .. it needs that underlying account
ok - the mint is the address - and then the wallet recieving it would need an account to send to
How do I get the address for that underlying token
oh ok - I _think_ you only need to transfer the underlying token
But having trouble figuring out exactly the values I need to give to transfer it  to another account
Yes I guess, I am learning / new to all this .. I am using the Metaplex / JS lib at the moment to mint NFT, now I want to transfer that NFT with sendToken function
https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html
Hey so what does this macro do: #[account(zero)]
are you looking for the Metaplex Metadata account for a particular mint?
this seems to be different form metadata account ?
but i am looking at metaplex/js lib and i can't seem to find, how to derive this Associated Token Metadata account
i see you need Mint address and Associated token to transfer a spl-token
hi anyone here know how i can derive associated token account ?
```
Mint Address: 5umaykH2cgRRTqe97xbVmhoNpeo2kWbtARboKqtXjMM3
Associated Token Metadata: CGHDeQahCktxW5yaMK2yNPWxSZiJnLkCnPLxESwMTAFv
```
Hi, where can I find the full list of Anchor.toml configurations?
libcrypto-1_1-x64.dll
is this a common error upon launchign solana-test-validator ?
Are you signing with the vault account owner? If the owner is a PDA you will need to use invoke_signed and pass in the seed and bump you used when generating the PDA.
Anyone have a resource I can use to learn how PDA seeds work?
thanks 😄
is there a front end repo that lets you transfer a selected nft to another wallet?
^ Really good to read through the commits of how he implemented this
https://github.com/project-serum/anchor/pull/790
There is one from Armani calling the associated token program. One sec
I feel like an idiot. Been trying that but forgot about Anchor.toml since i was in the program dir 😂
are there more examples? <:mortydumb:908904337361743882>
I believe you can just rebuild it:
```
anchor build

// Get the new program id.
solana address -k target/deploy/myepicproject-keypair.json

// Update Anchor.toml and lib.rs w/ new program id.
```


//////////////////////////////////////////////////////////////////////////////////////////

can anyone help me pls i got this one a run the command: cargo install --git https://github.com/project-serum/anchor --tag v0.20.1 anchor-cli --locked
Hey guys, i want to get a particular token balance on my react front end. I'm using the wallet kit provider and a phantom wallet. Does anyone has an example to use? Thanks
So if I want to change `program_id` , how can I get a valid one to deploy with?
I think it's due to me and my friend who work on same repo deploying with different wallets
While trying to deploy im getting: `Recover the intermediate account's ephemeral keypair file with`
Can you send example of front end call?
spl_token::instruction::transfer
you can use this instruction 

or you can look here:
https://github.com/solana-labs/solana-program-library/tree/master/examples/rust/transfer-lamports

in your front website call you need to specify how many lamports
Hello peeps,
I need to add a **random number generation** in my smart contract. I'm searching using oracle but chainlink only available on devnet.
Any tips on how to do / where to look?
Can anyone help ⏫
Basically on init I want to transfer x number of sol from user to the created account in the program
Hey <@!111233596173373440> <@!152089247254315008> 
How can I transfer a variable amount of sol (say x SOL) from a user wallet to the account that is being created by them in my smart Contract?
Currently when is pecify init and payer, the amount of sol is autoamtically calculated based on size i think, how can I transfer more sol than that if needed?
cc <@!347689664855015424>
You can't deserialize SlotHashes because it would be too big. Which is why it throws an error on execution like "unsupported sysvar". 
If you want to get the slot you can do : 

```rust
let data = slot_account.data.borrow();
let slot: u64 = u64::from_le_bytes(data[data.len() - 8..].try_into().unwrap());
```

(that's without using anchor)
this is what the docs say, if any one can simplify this "A data structure that can be used as an internal field for a zero copy deserialized account, i.e., a struct marked with #[account(zero_copy)].

" would appreciate it.
not sure where the non-account variant comes into play.
I know my usage uses `#[account(zero_copy)]` because...well, it's an account 🙂
was looking at the zero copy example in the anchor examples
no clue personally
any idea abt this ?
that was the issue fixed it everything works now https://github.com/xedk/solana-splits
aha understood
if your program is creating the account, it's a cross program invocation from your program -> system program to create the account, so limit of 10kb.

but if you create it directly from the client, it's client->system program, not a CPI, and not stuck under this technical limitation
An account created via CPI is limited to 10kb in size. That's the problem here. Why that is I do not know, but it's likely fairly technical
is there any explanation for this ?
by initializing the account on my own separately, then passing the already initialized account in, I bypass the quirky restriction that program init'd accounts must be max 10kb
what is the difference between #[zero_copy] and #[account(zero_copy)]
Yea https://discord.com/channels/889577356681945098/889702325231427584/923722638361231370
So I am no expert on this, but I think using `init` is essentially telling your program "hey, initialize this account for me". Which means your program is the one initializing the account - which means it is limited to 10kb instead of 10mb
cdnt init have created a normal account whose max size could have had been 10mb unless u pass seeds and bump , that is what init does if am not wrong.
genuinely curious about the last point if using init and #derive(default) would have had worked. still not clear on what #[account(zero_copy)] exactly does i think it marks the account so it is not deserialized at runtime
> if so is it wrong to use init here ? with zero_copy with #derive(default) , wouldnt that have calculated the space for you, or am i missing on something(most probably).
Honestly, no idea. I was banging my head against the wall for like two days before getting this working - this is what eventually worked
```await program.rpc.initializeProgram({
        accounts: {
          stateAccount: stateAccountKeypair.publicKey,
... other accounts,
          systemProgram: anchor.web3.SystemProgram.programId,
        },
        signers: [stateAccountKeypair],
        instructions: [
          await program.account.huntState.createInstruction(
            stateAccountKeypair,
            225043 <--- the number I was calc'ing
          ),
        ],
      });```
Here's a snippet of how that account is being created. The `createInstruction` instruction gets run first which initializes the `stateAccount` with the proper size before it gets passed into my program's `initializeProgram` instruction, where `&mut ctx.accounts.state_account.load_init()?;` gets called. I _think_ `load_init` gives ownership of the state_account over to the program, it appears to, but I actually should go confirm that no one else can modify the data of `state_account`.

>  is that why you needed to know the exact space your struct type will take
I needed to know the exact space because accounts that use `zero_copy` will currently fail if you give too little _or_ too much space.

Worth noting that this was extra stuff needed to be done because my state account is greater than some number (I think 1024KB or something?) and could not be a PDA for that reason (PDAs are limited to that number and under). By creating the account _not_ as a PDA and then giving ownership of the account over to my program,  I can make stateAccount as large as 10MB
<@!111233596173373440>  were u creating the account off chain on the client side in a different instruction and sending it to your program to get it initialized, if so is that why you needed to know the exact space your struct type will take to pass it when you create an account via systemProgram passing in the space parameter, if so is it wrong to use init here ? with zero_copy with #derive(default) , wouldnt that have calculated the space for you, or am i missing on something(most probably).
i get errors all the time 😩
https://github.com/evanmarshall/cross-pile hello anyone can help me with this pls
Hi! How can I use Anchor with such a Rust crate? https://docs.rs/stable-swap-client/1.6.7/stable_swap_client/index.html Do I need to spin up https://docs.rs/anchor-client/latest/anchor_client/ and which struct is the entry point in there?
Hey guys I am doing this in my smart contract 
`**program_account.try_borrow_mut_lamports()? -= (fees + remaining_amount);
**commission_account.try_borrow_mut_lamports()? += fees;
**service_account.try_borrow_mut_lamports()? += remaining_amount;`

And I get the error sum of account balances before and after instruction do not match
What am i getting wrong here?
When I  log the amounts fees, remaining_amount, they perfectly add up to the total amount of parameter
np
ah. gotcha. thanks a lot 😄
^
In your Context struct
```Rust
associated_account: Account<'info, TokenAccount>,
```
Then in your function you can get the amount
```Rust
let amount = ctx.accounts.associated_account.amount;
```
⚓
in anchor (rust)
In typescript?
```Typescript
 let _initializerTokenAccountA = await mintA.getAccountInfo(initializerTokenAccountA);   assert.ok(_initializerTokenAccountA.amount.toNumber() == initializerAmount);
```
Is this what you're looking for?
is it possible to check balance of an token account.?

before swap & after swap
are the accounts marked with the mut attribute?
yea i used the same one on client side which was 251 but it then gave me this error ```logs: [
    'Program 4tzDAD5KLntPhT8t3gjqs85vsT5aguZTNCoeRvKkt5zr invoke [1]',
    'Program log: Instruction: Withdraw',
    "82mC2udFeQk4QqGzY7YuLMX7ivL3D6kb6ygiquCq1nYJ's writable privilege escalated",
    'Program 4tzDAD5KLntPhT8t3gjqs85vsT5aguZTNCoeRvKkt5zr consumed 7926 of 200000 compute units',
    'Program 4tzDAD5KLntPhT8t3gjqs85vsT5aguZTNCoeRvKkt5zr failed: Cross-program invocation with unauthorized signer or writable account'
  ]```
I hard-coded the bump in that exercise, make sure that's correct, what bump is the test logging in the console?
When I  log the amounts fees, remaining_amount, they perfectly add up to the total amount of parameter
What am i getting wrong here?
Hey guys I am doing this in my smart contract 
`**program_account.try_borrow_mut_lamports()? -= (fees + remaining_amount);
**commission_account.try_borrow_mut_lamports()? += fees;
**service_account.try_borrow_mut_lamports()? += remaining_amount;`

And I get the error `sum of account balances before and after instruction do not match`
why do we use "#[account(zero)]" in conjunction with account loader ?
so it cannot be used for types like token account or mint etc ? (or is it possible if not then why exactly ? )
for what kind of accounts can we use the AccountLoader type, i assume its for all those accounts made using #[accountzero_copy)] ?
<@!347689664855015424> any hints
i followed this tut
https://github.com/Kriptikz/anchor-pda-transfer-sol/blob/master/programs/pda/src/lib.rs
```anchor_lang::solana_program::program::invoke_signed(
                        &ix,
                        &[
                            ctx.accounts.pda_account.to_account_info(),
                            ctx.accounts.receiver.to_account_info(),
                            ctx.accounts.system_program.to_account_info()
                        ],
                        &[&[b"test", &[254]]]
                    )?;```
```Program failed to complete: Could not create program address with signer seeds: Provided seeds do not result in a valid address``` im getting this error while doing invoke signed with pda and sender pubkey
Hey! Has anyone ever tried to go through this solana crowdfunding tutorial? (from using Rust to using Anchor) https://learn.figment.io/tutorials/build-a-crowdfunding-platform-on-solana#introduction
figured it out. i needed to send those accounts sol. not sure why that prohibits me from cloning.
Hey! Quick questions. How come Solana Test Validator can't fetch a few accounts from mainnet? Like this one:

[2022-01-13T10:02:14.352309000Z ERROR solana_test_validator] Failed to fetch HggGrUeg4ReGvpPMLJMFKV69NTXL1r4wQ9Pk9Ljutwyv: AccountNotFound: pubkey=HggGrUeg4ReGvpPMLJMFKV69NTXL1r4wQ9Pk9Ljutwyv
In this code, what is Account type?
If I put #[account] above the struct, it's type also can be Account ?
Here you go:
https://github.com/Kriptikz/anchor-pda-transfer-sol
I thought I saw a note in twitter a month or so ago about deploying a program such that the owner was not a keypair but rather a multisig / dao of some type. Anyone have a good article / page on how to deploy a program safely so that it's not just a keypair file protecting it
void that I worked it out.
Hey guys, how can I debug why I am getting this on one of my tests? ```  Error: Signature verification failed
      at Transaction.serialize (node_modules/@project-serum/anchor/node_modules/@solana/web3.js/src/transaction.ts:583:13)
      at Provider.send (node_modules/@project-serum/anchor/src/provider.ts:116:22)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at Object.rpc [as stake] (node_modules/@project-serum/anchor/src/program/namespace/rpc.ts:25:23)

```
I don't think so -- to use the wallet I think you need to create a separate transaction that is somehow signed by the wallet instead
then find it inside of the program and transfer to it and sign transactions from it
So, I assume I need to generate the PDA address on client, pass it to program and create it with system_instructions
Hey folks! I want to be able to create a PDA, store & then transfer sol from it. How can this be done?
Hello guys, a stupid question, I am not familiar with js, do you use any extensions for anchor js code? For some cases, like `program.rpc.someFunction` I cannot jump to the source code.
Hey guys, can I use `program.provider.wallet` as a Signer for say this call: ``` Token.createMint(
            program.provider.connection,
            program.provider.wallet,
            program.provider.wallet.publicKey,
            program.provider.wallet.publicKey,
            9,
            TOKEN_PROGRAM_ID,
        )```
<@!347689664855015424>  thanks for answering my mundane questions, even more motivated to increase my knowledge depth and help around in this community like you do.
What "Account" is this referring to? And what is "T"?
```#[account]
#[derive(Default)]
pub struct MyAccount {
    data: u64
}

#[derive(Accounts)]
pub struct SetData<'info> {
    #[account(mut)]
    pub my_account: Account<'info, MyAccount>```

```Account is generic over T. This T is a type you can create yourself to store data. In this example, we have created a struct MyAccount with a single data field to store a u64. Account requires T to implement certain functions (e.g. functions that (de)serialize T). Most of the time, you can use the #[account] attribute to add these functions to your data, as is done in the example.```
ah yes correct
ya that is what i meant with no way to deallocate a allocated space once you run out of 32kb of space u cannot deallocate something already assigned space right ? its a limitation of the bump allocator
yup, 32kb. but whether you can or cannot deallocate has nothing to so with the size of the heap but the way its memory allocator is implemented
in a program context if i allocate something on the heap in an instruction , after using it i cannot deallocate it and use that heap space in that same instruction for something else , since heap is also limited to the instruction which is around 32kb i think.
an allocator that keeps growing by adding new space but does not manage memory in any other way. clearly very fast but also inefficient cause you dont get to reuse freed memory cause there is no free
feel bad having to ask some terminology every now and then, no idea what a bump allocator is etc, could you refer some reading material so i could grasp some of this jargon ?
although this might not necessarily be true on solana rn cause they use a bump allocator which only provides simple functionality but is fast
heap is slower
it strongly suggest not inlining the function. inlining would result in it not getting its own stack space
Note that in the future stack frames will be removed so this won't be an issue.
so by default its stack allocated and we can force it to get allocated on the heap, is there any downside to doing this ? i assume it is generally preferred you allocate on the stack if possible (assumption even if its true idk the reason)
tldr on what the inline macro does ?
use functions and mark them with [inline(never)] if boxing doesnt help
in your accounts struct, that is
wrap accounts in box
any idioms or patterns to solve the large stack variables error ? or in general 9 is the max number of accounts a program instruction can take and the logic should be designed around that ? also how is this limit calculated , if each stack frame is of 4 kb how is this stack frame allocated in context to how many accounts and instruction data arguments my program is expecting ?
if i do `cd client ; blah blah` then blah blah never gets run
so whatever is parsing these scripts, its not just going straight to bash
complains that `client;` is not a directory
good to know
lol
nope!
`test = "cd client; yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"` doesn't work?
whatever i just made my own intermediary script lol
but the uh syntax here seems to be different than normal bash lol
i want to simply add `cd client` in front of `mocha blah blah`
modifying the test script in anchor.toml
im getting stuck on
thanks for the help
ty ty
glad it works now
i think it was just this inconsistent casing
super. I found this little blurb helpful... bottom of this page https://book.anchor-lang.com/chapter_3/milestone_project_tic-tac-toe.html
works now lol
trying again now
yeah i did. but then i noticed there was still a hyphen in another toml
did you run `anchor build` after you changed everything?
yeah i changed this in the toml, but did not affect outcome
I think the Rust programs are supposed to be snake-cased, so `solana_twitter` or in your case `nft_lending`
appears not to
i wonder if it matters that the output in target is called `nft_lending.so`
if it does not affect `anchor build` or `anchor deploy`
appears to be being ignored? like what does this do

yeah so
lol
oh no thats a solana cli feature
but this is undocumented in --help
i just notice with anchor test you can pass a --program-id
nice
when i manually copy her keypair.json to my `target/deploy`, it deploys properly
I think that keypair gets autogenerated at the first `anchor build`. Presumably you could have the keypair created elsewhere and use whatever you want
yeah
ill copy hers..
but the one in `target/deploy` seems downstream of other steps
yes that seems right
Ok, no guarantees, since I'm just an idiot in the chat here, but probably all three should match
no we dont
i doubt it, finding out now
okay, but you have the identical keypair file in the `target/deploy/` folder?
it doesnt have this id
when i use anchor deploy
yes its the same
Sorry, no, your wallet is just the payer when you go to deploy your program. You were saying you want the program ID to be the same, right?  You set that here (see highlighting):
1) and 2) are the same
thanks for the help btw
does that seem right <@!814176793400836128> ?
which leads to 3) being different
i think we dont hve the same thing here

from anchor.toml
i think the issue is that
You will need to check three things, I think: 1) declare ID is the same, 2) the public key in Anchor.toml on the line under `[programs.localnet]` matches, and 3) that the same keypair exists in your `target/deploy/` folder
yeah it looks like `anchor build` is just making some new rando keypair for my program, and i want to supply one
how can we do that? is it a mistake to try to expect it to be constant? seems like not given the `declare_id!` function
when i deploy an anchor program, the program id is different than what it is on my friend's machine. right now this id is hard coded in lib.rs, so we obviously want it to be constant across machines.
Yea they are
got it, nice share anyway. jet is on mainnet?
Probably just not updated yet.
I expect yes, if your program will use the SPL token program, you would initialize it in your accounts struct. An example from the solana-twitter program that uses the system_program:
nice! Why is there a heavy use of AccountInfo rather than Account?
Jet has some good anchor examples

https://github.com/jet-lab/jet-v1/tree/master/programs/jet/src/instructions
or can i get account from this pub key in anchor?
can i store token account instead of only pubkey
#[account]
pub struct Account {
    pub token_program: Pubkey,
}
fabulous!
thanks username was not correct.
ok let me check
Have you checked the path to the keypair file? Look in your Anchor.toml file and double check maybe?
i already created solana account
when i run **anchor test** givinig this error
Error: Unable to read keypair file
anyone can help?
hi, how can I program a contract so that using a method requires sending funds to/from a baseaccount?
Is there a better way to search or inspect the data inside accounts that were created by an anchor program? Assuming the program hasn't created many other accounts, it's not a problem, but after it's created 100's, or 1000's, the RPC servers will get hammered every time my client tries to do this: `structOfAccounts = await program.account.ashpools.all()`
`cargo install --git https://github.com/project-serum/anchor --tag v0.20.1 anchor-cli --locked`

is this a global install? im not too familiar w/ cargo
yeah i found the docs on this
need to use `cargo install` for macos
this package is linux only
(i was able to install 0.18, but get same error)
even after installing via npm, `where anchor` still goes to cargo bin
whats the recommendation for macos users
<:raise_eyebrow:405037568930086912>

actually i may not have upgraded anchor
i updated rust, anchor, and solana cli to most recent
i've cloned a project, and all anchor commands -- `test` `build` `deploy` error out with the same error:
Thank you. Looking into it.


//////////////////////////////////////////////////////////////////////////////////////////

and why do i get this error
im trying to deploy one program

ahh - much better 🙂
anyway to generate TS typing .d.ts for program client ?
Is there a way to use cpi on an account that's not a pda?
This is about the kind of thing I was looking for
https://docs.rs/anchor-lang/latest/anchor_lang/prelude/struct.Pubkey.html#impl-FromStr
Hey everybody, anybody knows of a good example of using CPI and returning data using an intermediary account?
Ok - yeah - I don't see a method for it - but I guess just thinking it through - the string is base58 encoded -- so .. maybe this stackoverflow question is similar :
https://stackoverflow.com/questions/48996294/how-do-i-convert-base58-encoded-data-to-a-vecu8-and-then-into-a-string
Thanks !
The problem is that I need to do this in Rust. 
In Rust I have a string that I got with solana adress , and now I need to turn it into a Pubkey that gives &[u8]
correct -- all programs are owned by the system I think
that program is system token program
and is program not owned by wallet?
ok - so then who owns PDAs?  the program 'owns' them
thats right
ok in terms of what kind of account- its actually a PDA from the system token program - right?
yes!
consider a mint is just an account, right?
I think its this under the covers: https://github.com/indutny/bn.js
i am noob in solana, i make a lot of  confusion with solana
so mint is owned by 'wallet' not token program..? am i right?
Big number objetct
sorry - I don't even know what BN is  🙂 - what is it?
the mint authority is 'owned' by a wallet yes
I don't think that's right -- the mint is owned by the token program -- a system program -- so there is no wallet involved
oh you are in js land - sorry I was assuming you meant in rust
yes mint is owned by program and program is owned by wallet
i just check that token is owned by my wallet at typescript oh..
btw -- a token mint's owner isn't a wallet - -its actually the token program
like - assume it is an input into your program -- an account that is input right?  -- 
`token_account: AccountInfo<'info>,`
then you should be able to do something like:
`ctx.accounts.token_account.to_account_info().owner`
right?
I am a noob - but not 100% sure this would work - or is even what you are asking for -- but if you know the public key - you can use js to 
`let mykey = new anchor.web3.PublicKey("8YPaZ9FhHTh6FHq2pf632BWgjKw7BpuJuyCR58NOTAREALKEY");`
then
`console.log("look at the bytes mom!", mykey.toBytes());`
like `mint.getAccountInfo()` ..?
^^ if you can get that as "AccountInfo" then you can get the owner
i want to get owner wallet public key from mint token
is there no way to get owner's information?
I don't think so -- the programId is the public key of the program
Hey guys, where i can get the anchor.BN documentation?
Hey guys can i get wallet account public key from programID?
Guys, hi!
Can you please tell me how can I get an array &[u8] from a key pair?

The situation is: I generated a key with solana-keygen new, and now I want to use that key in Rust code, but https://docs.rs/anchor-lang/0.17.0/anchor_lang/prelude/struct.Pubkey.html#method.new requires an array, and I can only get the public key as a string. 

Or am I confusing something and it needs a private key?
Good morning, one question what i need to put here? the path of the json wallet? or the key wallet?
When I implement `AnchorDeserialize` and `AnchorSerialize` by hand, I get `IdlError: Type not found`: do you know why?
The size is stored just before the data AFAIK
how would add a vector as data to an account? moreover, would rust be able to intuitively see the size of the vector and/or how would that be done in anchor?
```rust
#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 16 + 16 )]
    pub vote_account: Account<'info, VoteAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,

#[account]
pub struct VoteAccount {
    pub crunchy: u64,
    pub smooth: u64,
}
```
Why is it 16 + 16 after space? 
```rust
#[account(init, payer = user, space = 16 + 16 )]
```
Shouldn't it be 24 ? 
```rust
[ 8(discriminator) + 8(u64) + 8(u64) ] 
```
Noob here
how do i accept usdc in my program instead of sol
This was really good, thanks again. I figured I'd share--Brian Friel's example anchor program (https://www.brianfriel.xyz/learning-how-to-build-on-solana/) has the most no-BS client implementation I've seen so far (3/4 through, near the bottom). Quick + dirty, but mostly easy!
I want to do staking with my token. So they will stake 1 NFT + Token A, and they will get Token B as a reward with the amount scaling based on NFT rarity. Is this something I can do using Anchor?
Thanks so much!
When we're doing any sort of arithmetic in rust, for example transferring lamports, is it best to use `check_sub` and `check_add` over `+-`?? any reason why we wouldn't want to use the safer operations in `check_sub and check_add`?
Hello, I am trying to compile a smart contract but an getting an error when trying to use the anchor_spl crate
``` use of undeclared crate or module anchor_spl```
Is it possible for a "token mint account" to run out of rent and be deleted? And if so, what happens to all the "token accounts" that belong to the "token mint account" ? Or am I understanding this incorrectly
ah ok - I think anchor test conflicts with localnet - not sure how output gets sent with anchor test
This is a good one. The helpers.ts file is super helpful (as it's name implies!).  See how he initializes the objects before his test code - then you've got easy access to the program.rpc through your idl.  https://dev.to/findiglay/building-a-blog-on-solana-2pg8
i am using msg! but when I run an anchor test, what I wrote does not appear.
I think I just realized that a mint is a PDA of the token program -- so the mint isn't owned by whoever has the auth -- it's owned by the token program itself
like debug how its running?  you can use log statements and run it against localnet then you should be able to see what's happening
I don't think you'd need to do that - you would import the rust program as a program - i.e.  something like
`use synthnew::program::Synthprog;`
sorry, how can debug the rust contract?
I'm looking for the equivalent of the following JS code in Rust. Anchor noob here.

```js
    const program = new Program(
      idl as Idl,
      id,
      new Provider(bn.conn, null, {
        preflightCommitment: 'recent',
        commitment: 'recent',
      }),
    );
```
hi! whats the easiest/best way to look up an ATA of a mint and fetch it within a program method?
Any good tutorials on writing typescript clients for deployed anchor programs? That's actually the most opaque part of this process, for me
see .anchor/program-logs
I've noticed that "anchor test" command sometimes doesn't log messages from tests, whats the problem?
Another question, when I close a program, will it handle closing the IDL account created when i called anchor idl init?
sorry for the essay lol
hello, i was reading over this escrow program (https://github.com/ironaddicteddog/anchor-escrow/blob/master/programs/anchor-escrow/src/lib.rs) and i had some quick questions regarding token transfers with anchor if anyone had a second to answer. i see there is a `set_authority` call made in `initialize`, but in `cancel` the tokens are transfered back to the initializer but I don't see any explicit instructions set the authority back to the initializer (or rather remove the vault account's authority). is the logic just that the vault will still always have the authority on the initializer's token account but since the program calls `close_account` it's not a security concern? or does `close_account` explicitly remove authority?
so figured id just start fresh and close the program
cool, seeming to run into this issue when initializing my program  Error: 3007: The given account is not owned by the executing program, definitely the owner
that works
should be an easy one, whats the best way to safely generate a new programid if I want to close the program and deploy a new one? `solana-keygen new`? use PK?


//////////////////////////////////////////////////////////////////////////////////////////

thanks - yes - but in the case of a wallet -turns out its going to be owned by the system program - so address is fine for what i'm doing
I believe this does not check anything about ownership, but just that the account address equals your hardcoded value
and doing an init_if_needed. How much space do I need to specify?
Im specifying a Account<'info, TokenAccount> for one of my instructions
it seems like "TokenAccount"s aren't owned by wallets either - they are owned by the Token program - so i guess they are PDAs too
ok yes that worked 🙂  - using "address" instead of owner
`#[account(address = Pubkey::from_str("MYHARDCODEDKEY").unwrap())]
user: Signer<'info>,`
oh wait ... its a wallet address thats why its not working b/c its owned by the system, nvm
is there an easy way to use a constraint that a specific key owns an account ?  i.e. a hardcoded one?  
I'm trying this, but it doesn't appear to work - 
`#[account(owner = Pubkey::from_str("MYHARDCODEDKEY").unwrap())]
user: Signer<'info>,`
Why not Pyth?
Does it mean there are no programs for Chainlink deployed at mainnet but only for devenet? https://docs.chain.link/docs/solana/data-feeds-solana/#Solana%20Devnet
but maybe yeah if you only want the program to be an owner of something -- you don't need to actually create that address first?
I think the init approach is if you need to store data at the PDA address
i mean - I could be wrong 🙂 -i 'm looking through the anchor examples -- there is this :
`        let (pda, _bump_seed) = Pubkey::find_program_address(&[ESCROW_PDA_SEED], ctx.program_id);
        token::set_authority(ctx.accounts.into(), AuthorityType::AccountOwner, Some(pda))?;
`
Aha, i see. so in the famous escrow one i use pda as a stateless address (just to be owner of something and later signs it). So.. I assume it's not doable anchor way. 
Thanks.
i.e. you pass the key for PDA you generated into the function and then the program will make the PDA account that way via init
if you want to use anchor for it -- yeah -- you just do 
`#[account(init, seeds = [etc etc )]
famous_escrow_pda_account: Account<'info, FamousEscrowState>,`
Any otherway to create pda?
aha, my pda is simply a pubkey. created using Pubkey::find_program_address...
ok - you can pass a PDA as AccountInfo - it should work fine
(trying to do famous escrow myself, i want to assign pda as owner of a token account, I could do it manually myself however using anchor-spl requires accountInfo)
^^ what context are you trying to use it in?
(i know we can create pda account using macro but i want empty account for just handling ownership)
Hi,

Is there anyway to convert pda pubkey to account info? (I used pubkey::find...) Or is there any anchor way to create it?
Thank you
welcome <@!908560543990837298> ser
Hello, im just new
How to generate rust clienet?
I tried to manually serialize the parameters and adding necessary accounts to build a transaction but I guess I am missing something
Hi!

How can I generate the Instructions that I can use for builind transactions from an Anchor project?
``` Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: custom program error: 0x0``` 
with this error for 2nd attempt to create
this is what I tried to test with
```describe('these words will appear before tests', () => {
  const SolanaNetworkLocalConnection = anchor.Provider.local();
  anchor.setProvider(SolanaNetworkLocalConnection);

  const SignerTestID = anchor.web3.Keypair.generate();
  const ProgramID = anchor.workspace.Thisistheprogramname; //first letter of program name has to be CAPITAL for some reason

  it('create - this is the name of test', async () => {
    await ProgramID.rpc.createfunctionname("pass this text into function to test", {
      accounts: {
        nameofaccount: SignerTestID.publicKey,
        user: SolanaNetworkLocalConnection.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      },
      signers: [SignerTestID]
    });

    const DataStructAccount = await ProgramID.account.nameofDataStruct.fetch(SignerTestID.publicKey);  //nameofDataStruct is Data struct account, first letter has to be lowercase for some reason

    assert.ok(DataStructAccount.words === "pass this text into function to test");
    _variable = SignerTestID;
  });

  it('create again - this is the name of test', async () => {
    await ProgramID.rpc.createfunctionname("pass this text into function to test", {
      accounts: {
        nameofaccount: SignerTestID.publicKey,
        user: SolanaNetworkLocalConnection.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      },
      signers: [SignerTestID]
    });

    const DataStructAccount = await ProgramID.account.nameofDataStruct.fetch(SignerTestID.publicKey);  //nameofDataStruct is Data struct account, first letter has to be lowercase for some reason

    assert.ok(DataStructAccount.words === "pass this text into function to test");
    _variable = SignerTestID;
  });

});```
Or maybe I'm not testing it correctly
It seems like I can only call it once right now
What would I need to change if I want to call the "createfunctionname" multiple times to create different Data Accounts?
```use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]  
pub mod thisistheprogramname {
    use super::*;

    pub fn createfunctionname(ctx:Context<NameOfCreateStruct>, init_message: String) -> ProgramResult {
        let test = &mut ctx.accounts.nameofaccount;
        test.words = init_message;
        Ok(())

    }
}

#[derive(Accounts)]
pub struct NameOfCreateStruct<'info> {
    #[account(init, payer = user, space = 8 + 64 + 64 + 64 + 64)]
    pub nameofaccount: Account<'info, NameofDataStruct>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}

}

#[account]
pub struct NameofDataStruct {
    pub words: String,
    pub result: i64,
}

```
~~Why isn't my `memcmp` filter not working? Printing out everything without a filter I can see that the account I'm looking for is definitely there:
```
        const states = await program.account.contentState.all([
            {
                memcmp: {
                    offset: 8 + 2 + 8 + 32,
                    bytes: ownerMint.toBase58()
                }
            }
        ]);
```
My account struct looks like this:
```
#[account]
pub struct ContentState {
    pub bump: u8,
    pub price: u64,
    pub currency_mint: Pubkey,
    pub ownership_mint: Pubkey,
    pub viewership_mint: Pubkey,
}
```~~
Okay that was dumb wrong offset
How can I transfer some custom tokens from one wallet to another in my ts tests? This seams like it should be easy, but I cant seam to work this out.
Hey, I am sketching out a solana program based on an ETH smart contract. One thing I've been wondering about:
How do programs in solana generally keep track of global values, say the list of all players that participated in a specific raffle (dumb example). I don't really want a "raffle player list" account since it would have to be passed every time someone participates in a raffle, limiting concurrency. Do programs generally track this stuff offchain?
nvm, Clients can't sign for PDAs (only your program can)
how do i sign for a pda?
to_account_owner is defined as simply wallet.publicKey in the client
Hey guys, I want to transfer some sol from my program_account to a user wallet inside a smart contract. 
`
        let program_account = &mut ctx.accounts.program_account;
        let to_account = &mut ctx.accounts.to_account_owner;
        **program_account.try_borrow_mut_lamports()? -= final_amount;
        **to_account.try_borrow_mut_lamports()? += final_amount;`

Is this correct or am i missing something?
program_account is owned by the executing program and to_account_owner is a user wallet owned by the system program
Upon running this I get the error:
`Error: 168: Program ID was not as expected`
What am I doing wrong?
So we wrote some tests for this fn - https://github.com/Triptych-Labs/goki/blob/9e61dcb171382a2ba0433761aeffd92147d05a85/programs/smart-wallet/src/lib.rs#L575

Test - https://github.com/whymidnight/steakhouse/blob/f93f4a0a1bdcac0506bac4b8350c0b65100f6490/src/staking/tests/unwidthdraw/unwithdraw.go#L156

But when we ported the process to our React app, `@solana/web3.js` would either complain about wrong seeds or CPI escalation. Anyone mind helping my team out? A SOL is on the table 🙂
Very basic question - how do I log in an anchor program? I see solana uses the `msg!` macro but going through the examples (https://github.com/project-serum/anchor/tree/master/examples/tutorial) I see no mention of logging on the rust side of things
If a transactions is signed by a sender sending lamports, can the instructions of the transaction call a program owned by the receiver (who has authority over program to be called) but who has not signed the transaction because they are only receiving lamports? Or will the receiver also have the sign the transaction if the receiver wants the transaction instruction to call a program owned by the receiver?
if anyone got "Error: 3007: The given account is owned by a different program than expected 0000"   then make sure in program lib.rs declare_id!(xxxx)  is same as "solana program deploy path/to/app.so"  return
sounds out of my scope rn :/
Sort of—you'd have to encode them into the cpi instruction's own data.
Can you pass instructions into a cpi?
now getting "Error: 3007: The given account is owned by a different program than expected 0000"
the pub struct is the structure that I can consult from web3 to my contract?
hi i have a noob question
I want to do staking with my token. So they will stake 1 NFT + Token A, and they will get Token B as a reward with the amount scaling based on NFT rarity. Is this something I can do using Anchor?
<@!134416332509675520> fyi got it working, wasn't passing in mut on the containing context
thanks a lot
thanks i just found it from there
Maybe I'm not understanding the question, but do you not get what you need from /target/types?


//////////////////////////////////////////////////////////////////////////////////////////

ah, nice
as I understand, using Box<> stores the account info on the heap
so that frees up stack space
Thanks! Could you explain how that makes it possible under the hood?
and would prob have to be linear
(you'd need to match up the client calcs with whatever is done in the program)
i've been handling time issues by just saving a timestamp whenever the value changes, as well as the value, so that the next time you need it you just calculate whatever it is based on the: time diff and old value. won't work for all use-cases, but is one approach
^^ can you have another program that runs on a timer and calls the recover function ?
Well, I am developing game nfts. It has attribute hp. hp is reduced when it get damage. And it must be recovered over the time. How can I handle HP-recover? program hasn't got timer I think.
Hi I am getting this error after upgrading anchor to 20.1
```
error[E0609]: no field `mint` on type `anchor_lang::prelude::AccountInfo<'_>`
 --> programs/src/instructions/init_collateral_account.rs:6:10
  |
6 | #[derive(Accounts)]
  |          ^^^^^^^^ unknown field
  |
  = note: available fields are: `key`, `is_signer`, `is_writable`, `lamports`, `data` ... and 3 others
  = note: this error originates in the derive macro `Accounts` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: can't compare `&anchor_lang::prelude::Pubkey` with `anchor_lang::prelude::Pubkey`
 --> programs/src/instructions/init_collateral_account.rs:6:10
  |
6 | #[derive(Accounts)]
  |          ^^^^^^^^ no implementation for `&anchor_lang::prelude::Pubkey == anchor_lang::prelude::Pubkey`
  |
  = help: the trait `PartialEq<anchor_lang::prelude::Pubkey>` is not implemented for `&anchor_lang::prelude::Pubkey`
  = note: this error originates in the derive macro `Accounts` (in Nightly builds, run with -Z macro-backtrace for more info)
```
```
use anchor_lang::prelude::*;
use anchor_lang::Key;

use crate::state::*;

#[derive(Accounts)]
#[instruction(bump: u8)]
pub struct InitializeDepositAccount<'info> {

    #[account(has_one = market_authority)]
    pub market: AccountLoader<'info, Market>,

    pub market_authority: AccountInfo<'info>,

    #[account(has_one = market,
              has_one = deposit_note_mint)]
    pub reserve: AccountLoader<'info, Reserve>,

    pub deposit_note_mint: AccountInfo<'info>,

    #[account(mut, signer)]
    pub depositor: AccountInfo<'info>,

    #[account(init,
              seeds = [
                  b"deposits".as_ref(),
                  reserve.key().as_ref(),
                  depositor.key.as_ref()
              ],
              bump = bump,
              token::mint = deposit_note_mint,
              token::authority = market_authority,
              payer = depositor)]
    pub deposit_account: AccountInfo<'info>,

    #[account(address = anchor_spl::token::ID)]
    pub token_program: AccountInfo<'info>,
    pub system_program: AccountInfo<'info>,
    pub rent: Sysvar<'info, Rent>,
}

pub fn handler(_ctx: Context<InitializeDepositAccount>, _bump: u8) -> ProgramResult {

    msg!("initialized deposit account");
    Ok(())
}
```
select rust, and expand the snippet
https://solana-cookbook-git-fork-losman0s-using-mainnet-6e845e-cookbook.vercel.app/references/accounts.html#get-sol-balance
Hey guys! Is there a function in anchor to get the sol/lamports balance of a pubkey? in rust?
this makes sure that the discriminator data in the account passed is empty/zero: https://docs.rs/anchor-lang/latest/anchor_lang/__private/enum.ErrorCode.html#variant.ConstraintZero
how did you that?
>  rebuilt it with another program
I cant figure out how did you fix it. I am try it many times 🙂
hey guys,  can someone help me understand what this means :  #[account(zero)]
Yes thanks a lot for reply. Problem was solved by Box.
use Box accounts `Box<Account<'info, something>>`
Hello,

How to get rid of the following error : 
Error: Function _ZN11test__private8__global10buy17hba2d086706def913E Stack offset of -5280 exceeded max offset of -4096 by 1184 bytes, please minimize large stack variables

regards
Haven't tried it yet but I don't see why not. Technically it would be two CPI calls in the same function, init does the first one that creates the account and then you do a second one to transfer to that initialized account.
awesome, so it is possible to do a cpi token transfer from an existing tokenaccount to the one I just init in the same instruction?
I do that in this example project I'm working on:
https://github.com/Kriptikz/anchor-token-vault
```Error: Error loading workspace IDL```

what does this mean when running anchor test
This might be kind of a dumb question but I'm assuming there's no way to easily call an anchor function from another function (bc it needs all the info required in context)

Like lets say I have a redeem function people can call.
But I also have a close account function

I want my close account function to call the redeem function before it runs.
In solidity you just add that function to the declaration or whatever

In solana I need access to all those accounts so I can't do that.

I guess I just create a mod with that shared functionality and import it / call it or?

Just wondering if anyone has any good rust examples of doing this in a clean way

-Thanks
I'm having troubles installing Anchor on my MacOS. This is the command I'm using 
`cargo install --git https://github.com/project-serum/anchor --tag v0.20.1 anchor-cli --locked` and this is the error I'm getting . Any help would be much appreciated!
Can anyone explain the relationship or provide addition resources to help me better understand the relationship between 
#[derive(Accounts)] and #[account] 

do #[derive(Accounts)]  have their own address?

https://project-serum.github.io/anchor/tutorials/tutorial-1.html#defining-a-program
```#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 8 + 8)]
    pub my_account: Account<'info, MyAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[account]
pub struct MyAccount {
    pub data: u64,
}```
How do I init a TokenAccount thats owned by my program? If I'm doing an account init I believe I need to pass in the keypair as one of the signers which I'm not sure how to do
```anchor init name``` is giving me 
```Error: String is the wrong size```
oh yeah, that's how I caught the issue in the first place. It did place it as a warning at first though
My guess is to comply with popular linters
https://giphy.com/gifs/z1GQ9t8FxipnG
Hi, I just ran into a this error while running an `Anchor test` :

```Transaction simulation failed: Error processing Instruction 0: custom program error: 0x65```

Took me a while to figure out that writing my rust `fn` name in snake case while calling it as snake case in the  `program.rpc` object was the reason for the error. 

My question is why though?
i guess you could write the lottery part somewhere else if you wanted to and then use command line tools to transfer winnings ?
no 🙂 thats great
do you still want to know given that i solved the issue by updating solana cli?
what does your Cargo.toml file look like?
Hello, incoming noob question: Do you think it will be possible to build simple lottery just using SPL token program from Solana? or you think it will require developing own programs ?
Let say its a  simplest lottery : users buy tickets with the coin and play, if they win they receive tokens.
no issues if i just use cargo build instead of anchor build
it could be that anchor is using the wrong version of rust?
and i cant edit this package's
my manifest already has cargo-features line on it
any knowers know how to address this error?

edit: solved, i had to update solana cli


//////////////////////////////////////////////////////////////////////////////////////////

hey guys, any idea how to build vaults with Anchor and get an LP token?
Oh that's nice! Thank you.
I ended up wrapping code that needed the wallet in a 
`useEffect` loop like this:

`  useEffect(() =>{
    if(!props.wallet || !props.wallet.publicKey){
      console.log("wallet empty - returning");
      setListItems(<li>Scanning Wallet....</li>);
      return;
    }
    //this code here happily using the wallet
  }, [props.wallet]);
`
so when the wallet changed it would re-run
sure -- I don't understand it all either - sometimes helps just to try and explain it or have someone to talk with 🙂 - it is weird that WalletContextState isn't a wallet -- sometimes it takes a while for the wallet to initialize maybe -- so it could also be that its being used before its ready
Yes using react. And I have created a Wallet.tsx react component that wraps all the other pages, which contains the <ConnectionProvider> tags, but it's all in some convoluted way that works and yet I barely understand. Thinking maybe I should simplify and understand it a bit better, first. Thanks for the suggestion!
i see that `spl_associated_token_account::create_associated_token_account` requires me to provide ""[writeable] Associated token account address to be created" as an AccountInfo in the `invoke_signed` used to call the instruction

does this mean i need to initialize an empty Account and then just pass that in? if so how is that done in rust? so far ive only created new accounts in js
if you are running on devnet you can check in solscan
its just a guess!  hope it helps 🙂
If my program instruction throws an Err, are all the new init accounts not created? Sorry I'm learning more about anchor
I know mine is on mainnet since a long time 😄
let me try that
Good goblin! You are too good
maybe try by just setting your solana config to devnet?  could it be a key mismatch?
Hey Guys, I tried to "anchor deploy --provider.cluster devnet" and got this error: 
`Error: Deploying program failed: Error processing Instruction 1: custom program error: 0x1
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }`
are you using react or no ?
not sure if this is why --- but running in react I found I needed to wrap any components that referenced useWallet inside <ConnectionProvider></ConnectionProvider>
thanks a lot for sharing
huh, and here i was thinking the `owner` attribute was only a check
gm. Sort of puzzled here on using a connected wallet with an anchor client... A few examples use the `wallet-adapter-react` adapter with an anchor Provider, but, when I do the same w/ useWallet or useAnchorWallet, I am getting a mismatch of types: "WalletContextState not assignable to parameter of type Wallet." I understand *why* this is a problem, but not really how to resolve it. Any suggestions appreciated. Example:
`import { useWallet } from "@solana/wallet-adapter-react";
// ...
const wallet = useWallet();
const connection = new Connection(selectedNetwork, "confirmed");
const provider = new anchor.Provider(connection, wallet, "confirmed"); // <-- mismatched type occurs here 
`
Thanks for any help!
and then it worked!
so I had to mark it with this:
`    #[account(owner = Pubkey::from_str("MYPROGRAMID").unwrap())]`
the other thing I was doing was passing in 
`AccountInfo<'info>,` for a PDA from another program - and that was also failing
so that should fail b/c the account isn't a mint
ok -- so one thing that was wrong that I was doing was using 
`Account<'info, Mint>,` for an account that wasn't a mint
hahaha, I just wanted to try to understand why changing that solved that issue. Not checking the discriminator would explain it
sure -- its still not working 🙂 but i can dm it to you when it is
We manage to do it as:

```
...

let mut account_info_data = to_account.try_borrow_mut_data()?;
let buff: &mut [u8] = &mut account_info_data;
let mut cursor = std::io::Cursor::new(buff);
my_decoded_account.try_serialize(&mut cursor)?;

msg!("My logs {} {} {}", my_decoded_account.amount, shares[counter], counter);
```

Do not know, if it is the way, but it is working now! Thanks for help and showing direction!
<@!569289717582135296> could I see the entire context's definition? I'm still learning anchor and still don't understand when to use AccountInfo. I understand it's an account that is not deserialized, therefore anchor doesn't check its discriminator?? When would it be usefull then?
thanks 🙂 -  turns out i copy/pasted `Account<'info, Mint>,` instead should have been  `AccountInfo<'info>,`
the blockhash part of the new candy machine is useless
Isn't that predictable?, I mean, everyone can see the previous blockhash. I'd imagine having the code and the seed anyone could anticipate the value
I'd remove `mut` from different account attributes until the error disapeared
for this error :  
`'The given account is owned by a different program than expected`
is there a way to find out which account it is referring to?
Candy machine does this in an interesting way looking at the previous blockhash. I’d check out their code
`...but data from 'ctx' flows into 'ctx' here`
I got this error because of the lifetime
ok I was able to successfully deploy to localnet when starting the validator with `--no-bpf-jit`. I don't really get why :/
Thank you
great!!
ah yeah - you can't sign for it -- which makes sense of course 🙂
right, I get it now
and notice how it only returns the address (public key), I need a keypair in order to sign
ok right - the account can only be created by the program - as you said
yes, that gives me the address, but it doesn't actually create the account
I think i found an answers. If I read it right, a PDA can only be created from the program it's derived from since it needs the program's signature for the creation transaction
ok - so like from js?  then you can use 
 web3.PublicKey.findProgramAddress, right?
Anywhere, for now I'm testing from the programs own test script.
^^ where is the client?
I need to create a PDA for a program before calling it. `init` doesn't help in this case. This account needs to use multiple seeds for address derivation. But the SystemProgram instruction only accept a single String.
How come anchor always deals with arrays of seeds but SystemProgram.createAccountWithSeed only accepts 1 seed??
Is there a devnet faucet for usdc?
Thank you! If it is not hard for you, could you please share some doc or example how to do it correctly?
youre changing a struct that was deserialized from the account data. For normal accounts (not from `remaining_accounts`), anchor persists changes to deserialized structs. For accounts from `remaining_accounts`, you have to do it yourself
Hi, all! I have maybe stupid question, but if I pass some account to `remaining_accounts` as writable, than I get it in my instruction, cast it to actual account and try to change, inside intruction, it logs that account changed, but when I fetch it after instruction in tests - my changes were not applied. Maybe I missed something or did something wrong?

```
pub fn transfer_multiple(
        ctx: Context<TransferMultipleInternal>,
        shares: Vec<u64>,
    ) -> ProgramResult {
        let balance_from = &mut ctx.accounts.from;
        let mut counter = 0;
        if ctx.remaining_accounts.is_empty() {
            return Err(ErrorCode::DemoErrorCode.into());
        }
        for to_account in ctx.remaining_accounts {
            let my_decoded_account = &mut match Account::<Balance>::try_from(to_account) {
                Ok(account) => account,
                ProgramError => return Err(ErrorCode::DemoErrorCode.into()),
            };

            my_decoded_account.amount = match my_decoded_account.amount.checked_add(shares[counter])
            {
                Some(e) => e,
                None => return Err(ErrorCode::DemoErrorCode.into()),
            };
            msg!("My logs {} {} {}", my_decoded_account.amount, shares[counter], counter);
            counter += 1;
        }
        Ok(())
    }
```
I'm still having an issue where running `anchor build` + deploying to a local validator results in the transaction pending in `Finalizing transaction` forever...
Using `anchor test` works fine, also using an M1. Wondering if there have been any solutions to this 😦
Which does not exist
You UX data is wrong and it ventures into the fallback
yeah, that's what i've been reading, but can't we get entropy from execution times? ie: make a cpi call and measure how long it takes
There isn't really a super easy way to do this in your contract besides finding some way of inserting randomness from the outside world, as far as I know
been looking for a while, I see an accepted answer is asking too much
Hey, what's the accepted way of getting a random number?
```Error: Permission denied (os error 13)``` 
now i'm getting this when I try to run anchor init
when I try to run anchor init I'm getting ```Error: Workspace already initialized```
not sure what I did, it was working fine earlier
```remote: warning: File blog/app/test-ledger/rocksdb/000858.log is 75.07 MB; this is larger than GitHub's recommended maximum file size of 50.00 MB```

How do I delete these test-ledger files? Won't let me do it manually
So what does `    #[msg("Fallback functions are not supported")]` mean?
oh i see, thanks
0x65 = 101
my error code isnt in there?
https://github.com/project-serum/anchor/blob/master/lang/src/error.rs

you can find some info here
how do i debug errors like this? `    Program F1y1FTP91nwxbNUW3nXY6mKQzWawihwVYGwMsi7oKGyg failed: custom program error: 0x65`
Does anyone know why I get the error below when I run "anchor test" locally?
```Unable to start test validator.```

Found an answer
https://github.com/project-serum/anchor/issues/989
I think it comes from where you set the variable "provider" to

for example
```  const provider = anchor.Provider.local();
  anchor.setProvider(provider);```
Hi all 🙂 Where does the publickey from the following javascript command come from: program.provider.wallet.publicKey?
So just making sure this is right, a 10mb account would cost about 70 SOL in rent? lol
Hm yeah got it -- easier to do from the v2 program. Is it common to have this function available as an instruction that can be sent into the program by say only the authority that deployed the program. Like an upgrade_account instruction... since the program won't execute anything automatically when deployed
hey man i need a tutorial to build a swap pool and farms on my dapp 
Atrix  or Raydium which one i should use ?
Since you can only pass in so many in one tx
And it'll be somewhat painful to be honest, since you'll have to pass in each and every account you want to migrate, presumably in multiple different transactions
Very interesting
But you'd need to specifically write the logic for it
Got it
Well, maybe
Nope, not in there unfortunately
You would need to add an instruction to your program to do the migration
https://project-serum.github.io/anchor/cli/commands.html#migrate

I guess that's the intent of the migrate command? That you can add this kind of logic to your own migrate script?
Or is it just with like the solana CLI and using the program's authority?
Any public examples of this?
Yep, nothing will happen automatically
Will you need to migrate all the previously generated PDAs to new accounts with the updated struct as you launch the next version of the program?
What happens if you want to change the struct for a PDA between program versions?
based on the trx, can anyone tell what im doing wrong
ive searched a few discords and i can't find anyone else asking about that error
https://explorer.solana.com/tx/2U3oqdpqL63btJa3p7oVg2eJQKGhdYDmh4wYfH2MXzXqdfpYsZoZPXeR1JQGXNFsCeNwYWKHMqJwe9Hrq45GYxQM?cluster=devnet working on upgrading a cli function in metaplex to work with v2 cm. getting 3005 error  [
    LangErrorCode.AccountNotEnoughKeys,
    "Not enough account keys given to the instruction",
  ],
If you're in node you can do `(program.provider.wallet as NodeWallet).payer`
Hey guys is there a way to use `program.provider.wallet` as a Signer type?
invoke_aigned
Not directly in your solana program as far as I know, at least not yet
I think for local util functions you can  - but I’m a rust newbie - don’t really understand the contexts that well - mostly following a pattern cargo cult style
<@!134416332509675520> ☝️
One question about the error message
- Current error message is `failed to send transaction: Transaction simulation failed: Error processing Instruction 0: custom program error: 0x1777`

But I wanna a error message like this: `6007: Not Acceptable Data`
No, don't think that's possible (not unless someone/something other than the user initiates the first transfer)
Hey guys, is there a short cut way in the anchor/serum ts package to transfer custom token from one address to another?
got it. I'm basically wondering if this order could be reversed. Something like program pays user, user submits transaction, user reimburses program. I'm assuming that is not possible? I can't think of any way to do it but I'm not very experienced
But you could have your program control some funds and send the user some reimbursement as part of the tx I guess.
As far as I know you can't do this strictly-speaking (for example, the user will have to pay to submit the transaction, and that fee applies regardless of whether the tx succeeds or not).
is it possible to create a program where the program is required to pay the gas fee instead of the user?
Yeah, can't do it within the solana program itself
<@569289717582135296> Is possible call a function without params and context?
No worries, ser. Thanks for your answers! I had the feeling it wasn't going to be possible either way 😄
yeah - I don't know how you would do it? maybe you could have programs calling each other and waiting?
sorry!
Yeah, was thinking of that as well. Just wondered if it could be done directly in the program
^^ I don't think so - but you could make a timer run outside maybe and invoke the method?
Hey there, I was wondering if there is some way I can implement something like a setTimeout/setInterval in a Solana program. Basically, every fixed interval, I'd like to run a piece of code
its rust syntax - dereferencing i think?
this is I think the rust code on the other side --- 
https://github.com/ironaddicteddog/anchor-escrow/blob/master/programs/anchor-escrow/src/lib.rs  
-- the rpc method being called is "initialize"
this is from a initialize function inside a program
sorry -- was replying to djanstr 🙂
good question - I guess I don't really know what that syntax means
```authority = *ctx.accounts.authority.key```

what does the * in front of ctx mean in this context?
Thanks for reply. Quick question - in this test script (link to github shared above), ironaddicteddog has already generated a keypair for escrowAccount on client-side. what is the escrowAccount.createInstruction for
^^ isn't it creating the initial escrow account?
This is the src - https://github.com/ironaddicteddog/anchor-escrow/blob/master/tests/anchor-escrow.ts
hey guys, can someone explain what this is for in escrow example? 
instructions: [
                await program.account.escrowAccount.createInstruction(escrowAccount),
              ],
Is possible call a function without params and context?
I think the answer is yes -- I guess I can throw out the bump ?
they are EVM compatible and their proof of stake algorithm is supported by some deep learning algos as far as I know. But they are officially supporting Solana ecosystem and even Solana is listing them on their page as a partner.
want to verify that someone holds NFT a before unlocking NFT b
is getting an associated token account address the same as find program address ([walletKey, tokenProgramKey, mintKey],  associatedTokenProgramKey) ?
kind of unfortunate getting 429 errors when running my test suite
yes deploying/upgrading the program is basically sending the executable binary data broken down over many transactions
https://twitter.com/0xGoki/status/1471167946412019716
Okay, guess this is expected for upgrading programs as it's a buffer of data the BPFUpgradeableLoader
It's not just a log these are transactions live on devnet
^^(too)
it happens to me to -- I think someone forgot to take out a logging statement somewhere
Just started happening. No idea why.
Any idea why when I run anchor test transactions start spamming > 100X? 

```
msg 3yDPiGZxoPvzEJ3Kmo6sAGiTLJUj9yzFGWmGrFLW3eDP
msg 3yDPiGZxoPvzEJ3Kmo6sAGiTLJUj9yzFGWmGrFLW3eDP
... X 100
```
There's still a lot of improvements to make to solana so a fork doesnt really make sense
If it's just a fork, why would people use velas and not solana?
but if it diverges in meaningful ways than probably not
will probably work with velas if it uses the same runtime as solana
no idea
Hi all 🙂 Will it be possible to use Anchor to interact with Velas (as it is Solana fork) in the future? Do you have this on your roadmap :P?
Hi, I'm having trouble importing the cpi module of another crate when i do ```use ___::cpi::accounts``` it keeps saying unresolved import (im using rust-analyzer on vscode). I've added ```[features]
no-entrypoint = []
no-idl = []
no-log-ix-name = []
cpi = []``` in the cargo.toml of the callee and ```callee = {path = "../callee/", features = ["no-entrypoint","cpi"] }``` in the cargo.toml of the caller. It compiles though so is it an IDE error?
You and me both. Try https://hackmd.io/@ironaddicteddog/solana-anchor-escrow


//////////////////////////////////////////////////////////////////////////////////////////

usually can be run by anyone
off-chain process that invokes some smart contract (program) function
similar
js
thx goodgoblin, I'll try that
cranks!  i don't know i haven't heard of them 🙂 sorry  -- quick google - maybe its something from Serum? https://docs.projectserum.com/serum-ecosystem/help#what-is-crank-turning
what are cranks have heard this quite a few times ? Is it same as CRON job ?
oh ok - just looking at your logs it looked like maybe you were running a "built" version of react v.s. like npm start -- I don't know if it makes a difference or not - but if you are running a "built" version can try and clean it out and rebuild - or just run with npm start
I tried to start/stop the test validator on the localhost but it doesn't work anyway... I am just following step by step the full stack dev guide, it's weird that this doesn't work. I'll try to build it up again. Tks for checking though  !
Is the client also rust?  sorry I don't have exp running a rust client -- have only used javascript to test etc.
I don't know - do you mean like - based on the number of decimals in the mint -- does that alter what the total supply really means?
sorry! same kind of thing is just working for me:
`
import { getPhantomWallet } from '@solana/wallet-adapter-wallets';
`
I have it as part of a react project -- does it work in local testing?
I think the basic idea you are looking for is to make the tickets PDAs that are decorators to the mints that are part of the NFTs - something like that 
https://docs.metaplex.com/architecture/deep_dive/overview#decoration-as-pda-extensions
you could write all the state to your program on the chain - but I think you'd have to monitor and update it via a non-chain client - at least thats what I would assume
i made a simple vault -- i don't think i can help you -- but I guess you could store the date the vault was created and then check agains it when you try and unlock?
hey I'm trying store a 4 len byte array on-chain. my instruction is accepting the param as a [u8; 4] type, but I get `src.reduce is not a function` when trying to pass it in from the client. Should I be accepting it as a String and then convert that to the byte array in the program?
hey guys, is there a unction for parsing and showing spl tokens with the proper decimal point? Like formatEther on ethers. Thanks
Hi guys, I tried to run the front end app but I got this error, is there anybody who can help me ? 🙂 Attempted import error: 'getPhantomWallet' is not exported from '@solana/wallet-adapter-wallets' (imported as 'getPhantomWallet').
assets by path static/js/*.js 5.13 MiB
  assets by chunk 1.85 MiB (id hint: vendors)
    asset static/js/vendors-node_modules_toruslabs_solana-embed_dist_torus_esm_js.chunk.js 1.22 MiB [emitted] (id hint: vendors) 1 related asset
    asset static/js/vendors-node_modules_blocto_sdk_dist_blocto-sdk_umd_js.chunk.js 517 KiB [emitted] (id hint: vendors) 1 related asset
    asset static/js/vendors-node_modules_ledgerhq_hw-transport-webhid_lib-es_TransportWebHID_js.chunk.js 130 KiB [emitted] (id hint: vendors) 1 related asset
  asset static/js/bundle.js 3.26 MiB [emitted] (name: main) 1 related asset
  asset static/js/node_modules_project-serum_sol-wallet-adapter_dist_esm_index_js.chunk.js 9.64 KiB [emitted] 1 related asset
  asset static/js/node_modules_web-vitals_dist_web-vitals_js.chunk.js 6.87 KiB [emitted] 1 related asset
  asset static/js/_7874-_ed1b-_d17e.chunk.js 576 bytes [emitted] 1 related asset
asset asset-manifest.json 1.99 KiB [emitted]
asset index.html 1.67 KiB [emitted]
cached modules 4.69 MiB (javascript) 32.6 KiB (runtime) [cached] 442 modules
Hi, everyone. I am following this tutorial to create a ticket system (https://www.fmendez.com/building-a-simple-on-chain-point-of-sale-with-solana-anchor-and-react). I would like to modify the smart contract so that each ticket is NFT. Can someone help me?
does anyone have experience with building vaults? got a few questions about how to implement lock up periods, vault capital caps, calculating PnL based on varying amounts of deposits and total capital in the vault, as well as varying amounts of days in how long capital stays in a vault
also if anyone is wondering the same thing, i think you just init the large zero_copy account and pass the PDA in from client side, then when you’re actually reading/writing to it in future and using `#[account(mut)]` you can enforce the seed constraints. not 100% certain yet though as i haven’t tested it out myself
receiver in that example isn’t a PDA but easily could be
this is how i did it, idk if there’s a more elegant way to do it with anchor though
Does anyone have any references of programs that use lamport amounts in the program?  For example, transferring SOL instead of tokens to a PDA

Found answer:
https://stackoverflow.com/questions/70528742/how-to-transfer-sol-in-anchor-smart-contract-instruction/70574227
https://dev.to/dimfeld/starting-with-solana-part-4-4j5k
The program account is an account that holds some data that points to the executable bytecode (which is also an account). They both hold rent accordingly wrt their size (bytes)
Could someone explain to me the relationship between the "Program Account" and the "Program Executable Data Account" and are the SOL balances for each account the rent that the account is currently holding?

Would the #[program] part be the "Program Account" and the #[derive(Accounts)] be the "Program Executable Data Account"?
but I could be wrong
because you don't know the size
from what I've read you don't want to use Vec in solana
did you ever have success with this? I'm trying to do something similar
ah, haha. very simple. Thank you <@!831450660146642974>. You are god of Anchor and Rust!!!👍
https://github.com/solana-labs/solana-program-library/blob/master/token/js/client/token.js#L2282 allowOnwerOffCurve to true
Hi. <@!831450660146642974> I am trying to get associated token account. Its owner is PDA.
but Error occurs. I can't find why error comes out.😢  Help me!🙏 
``` 
 const [authority, bump] = 
    await anchor.web3.PublicKey.findProgramAddress(
      [Buffer.from("authority")],
      programId,
    );
 
  let tokenAccount = await Token.getAssociatedTokenAddress(
    ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, tokenMint, authority);
```
7TXTjiXn2GqLU3o26LX1aYan5vFtGV28HVAHo9ww3DP7 is authority.
Please help me!
anyone get this issue? ```% anchor --version
Only x86_64 / Linux distributed in NPM package right now.
Trying globally installed anchor.
Globally installed anchor version is not correct. Expected "anchor-cli 0.18.2", found "anchor-cli 0.20.1".```
thanks! its from a "hello world" increment counter
I believe
baseaccount is signing the transaction for running the create function
is this from a specific example?
those accounts are the inputs to that function apparently
well you're calling the 'create' function from the rust smart contract
Can someone explain the "signers: [baseAccount]" line at the bottom?
What is it saying the "baseAccount" variable we generated is a signer of?
Wouldn't the "user" be the signer? 

```  it("Creates a counter)", async () => {
    /* Call the create function via RPC */
    const baseAccount = anchor.web3.Keypair.generate();
    await program.rpc.create({
      accounts: {
        baseAccount: baseAccount.publicKey,
        user: provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      },
      signers: [baseAccount],
    });
```
for anyone else wondering the issue was I was using token:: not associated_token::
hey, I'm following the book and I'm a quarter of the way down when it first wants me to compile and I get this:

`
PS F:\SoftwareProjects\Rust\tic-tac-toe\programs\tic-tac-toe> anchor build
BPF SDK: \\?\C:\Users\Paul\.local\share\solana\install\releases\1.9.4\solana-release\bin\sdk\bpf
Can't get home directory path: environment variable not found
`

relevant details:

`
PS F:\SoftwareProjects\Rust\tic-tac-toe\programs\tic-tac-toe> solana --version
solana-cli 1.9.4 (src:8ce65878; feat:3258470607)

PS F:\SoftwareProjects\Rust\tic-tac-toe\programs\tic-tac-toe> yarn --version
1.22.4

PS F:\SoftwareProjects\Rust\tic-tac-toe\programs\tic-tac-toe> rustc --version
rustc 1.57.0 (f1edd0429 2021-11-29)

PS F:\SoftwareProjects\Rust\tic-tac-toe\programs\tic-tac-toe> anchor --version
anchor-cli 0.20.1

`


does anyone have any idea what I should do?

this is on Windows 10
The wallet calling the transaction is authority. I'm not sure what account I'm missing here that needs to be signing
but I get:
```
Error: Signature verification failed
```
If I try and call this function.

How do I create a token account for a user in anchor?
If I need to send a custom spl token but the user has no token account for it?
I assumed it was:
what do i do
i cant close it nor sign for it because it was done through the ATA program
I accidentally set a token accounts authority to itself and im realizing
theres no way to delete it or transfer from it right?
if you make a TokenAccount's owner itself, and the address is the associated token account
does this mean i can't use seeds for `zero_copy` accounts then? <:thonk:908303306038837258> 

not sure how i'll generate the pubkey for the state account in that case tbh <:sweatingman:599601488095870979>
Hello, may I know is it safe to use `usize` for the field inside account struct? for example,  struct user {pub index: usize, pub authority: Pubkey,}, will it generate deserialize issue?
definitely better ways to word this lol
it should sth like, "without it, a program would be vulnerable to a type confusion attack (which is a subtype of account injection attacks)"
hmm well actually I see how
how is it misleading?
So is the language in the "details" (expanded section) under here: <https://project-serum.github.io/anchor/tutorials/tutorial-1.html#initialize-instruction> is kind-of misleading then?
the discriminator checks that the given account is the expected state account from the state accounts the program has. so if a program has state accounts of type X, Y,Z, the discriminator checks that given account is e.g. type X.

you still need to check that the given account is actually owned by the correct program (which the Account type does for you)
Thank you; it looks like 'type parameter' is pretty much the answer I was after (as featured in Rust book)
Off the top of my head, in spoken language I'd probably call it the type-specifier, or type-specializer, or specialized-type or similar, depending on what I was trying to say about it.
From anchor tutorial/docs, re. 8-byte discriminator:
> Importantly, this allows a program to know for certain an account is indeed of a given type. Without it, a program would be vulnerable to account injection attacks
How does this protect against account injection? Couldn't an attacker figure out the discriminator by looking at any of the owned PDAs and copying the first 8 bytes into their malicious account before the crafted data?
What is the generic name for the Rust language thing between the < > signs?
If it was a function argument I would expect it to be within ( ). So I'm not sure what to call it
yeah -- I think it might be the timing issue there -- just a guess -- b/c it returns something right? it returns a WalletContext ?
Thank you. I am able to do everything I need using the local code and a test client within my anchor project. Currently, I am trying to build a client with an imported IDL, and the anchor 0.20.1 npm package installed, and my trouble is in setting the provider. Back to my original question, I guess I don't really understand why the `const provider = new anchor.Provider(connection, wallet, preflightCommitment);` would reject a `wallet` type that comes from the `useAnchorWallet()` feature from `@solana/wallet-adapter-react` package. Like, shouldn't they be the same or at least compatible?
if you are running locally -- i.e. from the command line -- maybe try this:
`      let wallet = anchor.default.Wallet.local();`
thank you!
Even more simple,  I am unsuccessful at importing or using the `anchor.Wallet` feature:
`
    import * as anchor from '@project-serum/anchor';
    // ...
    const keypair = new anchor.web3.Keypair(); 
    const awallet = new anchor.Wallet(keypair);
// ERROR:
// Attempted import error: 'Wallet' is not exported from '@project-serum/anchor' (imported as 'anchor').
`
what can cause       Program failed to complete: Access violation in stack frame 3 at address 0x200003a28 of size 8 by instruction #11500 ? I am getting that error before it even starts to run my code. How do you debug an issue like that?
new_with_signer is what you are looking for
then ``` let cpi_program = ctx.accounts.token_program.clone();
        let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer);```
you put the nonce and the seeds
```let seeds = &[
            ctx.accounts.check.to_account_info().key.as_ref(),
            &[ctx.accounts.check.nonce],
        ];
        let signer = &[&seeds[..]];
        let cpi_accounts = Transfer {
            from: ctx.accounts.vault.to_account_info().clone(),
            to: ctx.accounts.to.to_account_info().clone(),
            authority: ctx.accounts.check_signer.clone(),
        };```
you need to add the nonce and other stuff in order to sign. Have an example will send it
you can't pass the pda as signer, but since it's a pda it can sign the transaction as long as it's run in the program that it's derived from
I think i need to pass both the wallet key and the PDA key as "signers" - but not sure how to do it --- or do I not have to do it and all possible signers will be sent and I must have messed something up?
im getting this error:
"Cross-program invocation with unauthorized signer or writable account"
for the token set_authority program - I am trying to transfer authority for a vault token account owned by a PDA to a wallet --
interesting - try this 
`ls -la ~/.cache/solana/`
ls: .cache/solana/v1.21/bpf-tools: No such file or directory
well - try 
`ls -la .cache/solana/v1.21/bpf-tools`
should I run with sudo maybe
not sure
is it a permission problem?  why can't it write to that location?
getting this error when I run anchor build or anchor test
```Failed to install bpf-tools: Unable to write ".cache/solana/v1.21/bpf-tools/tmp-solana-bpf-tools-osx.tar.bz2": Custom { kind: Other, error: reqwest::Error { kind: Body, source: hyper::Error(Body, Custom { kind: UnexpectedEof, error: IncompleteBody }) } }
```
i don't know 🙂 i guess you could try it and see - i've initialized fields after the account was created - but I think you mean like add a new field ?  maybe it depends on how big it would be  -- how much space etc - ?  sorry -- i really don't know that much about how anchor works under the covers
Can I add more fields to an account once it’s created?
I think for rust  'edition2021' you need later than 1.56.0
idk -- I'm running this version of rust :
rustc --version
rustc 1.59.0-nightly (c5ecc1570 2021-12-15)
also rustup 1.24.3 (ce5817a94 2021-05-31)
how do I check if it's compatible ?
im on 19. 1 -- I think its some kind of rust setting - I know that's not helpful - but maybe check that the version of rust you have is compatible ?
just updated to v 20
is there a fix for this ?
```  feature `edition2021` is required
```
Liquidity Pool token
Cheers mate! It was ofcourse devnet and also had to airdrop some sol to actually deploy.
whats an LP token?


//////////////////////////////////////////////////////////////////////////////////////////

Hi .
I want to lock my tokens in contract for some time Which i am doing successfully.
**But how can i transfer back tokens to user who locked..?**

Can anyone help me or provide any example how to tranfer token from contract to user token account.
Thanks.
Success! Thank you.
How can I create an account for each one of my users where I can write data scoped to them by their User Wallet Pubkey?
https://dev.to/dimfeld/starting-with-solana-part-4-4j5k
this might be a good starting point, its a tutorial for a to-do list where each item on the list has an amount of SOL attached to it and is released when the task is marked complete
Is there anything about controlling program funds in the documentation? I would like the program to have funds in it and send them to the users under certain conditions
ahhhh thank you!
I want to create a token that will be used as a reward for playing some betting games on my site. Does it make any difference how I create it:  using CLI or  programmatically? 
Token has to be created once right? and then with CLI I can mint or burn periodically.
What are the benefits of programmatic creation of the tokens?
you can use the metaplex example. calling raw solana programs always looks the same, no matter whether the caller is an anchor program or not. you have to use the solana syscalls. you or the non-anchor program devs can ofc write functions to make it look nicer to anchor programs. which is what we have done for the token program. see the spl/token directory for that
i am trying to build am anchor protocol but im very blocked because idk how to invoke CPI a non-anchor program
paulx pls save me 🙏
Not really no, my use case is for calling my own programs and SPL ones
any examples of anchor that do CPI with a user-created protocol? E.g. CPI with Mango Markets
hmmm looks like it only uses spl and system program
But they use plain old solana_program for lots of stuff
They use anchor to define their own programs and contexts
haha true
None of my own yet until I get them working 😅
ohh but metaplex repo isnt in anchor 😦
do you have code examples 😮
duuude
Lifetime specifiers in Rust
Np apollo! I'm very familiar with CPI related frustration XD
Hey! Can someone explain what does the `'info` mean here?

```
pub struct Transfer<'info> {
    pub from: AccountInfo<'info>,
    pub to: AccountInfo<'info>,
    pub authority: AccountInfo<'info>,
}
```

I tried searching for it in the documentation but could not find it.. maybe it's more of a Rust question than specifically anchor? Thanks!
Thanks Ax!!
https://github.com/metaplex-foundation/metaplex-program-library/blob/master/nft-candy-machine/program/src/lib.rs#L247
Metaplex does it quite a few times
I'm trying to do CPI with a non-anchor program. It would be *extremely* helpful if I could see an example of this being done. Anyone know a resource?
As I understand, you can try using the constructor for AccountMeta which only needs the pubkey and then somehow build an AccountInfo from that?
thanks apollo and paul
Generate PDA, use anchor init
the init cmd creates and inits the account
Im still learning and was more so exploring options. Thinking about it, a PDA does make more sense
do you know what a PDA is?
why would you want to do that?
coupled with this
https://docs.rs/spl-token/latest/spl_token/instruction/fn.initialize_mint.html
this is what I was looking at
https://docs.rs/solana-program/latest/solana_program/system_instruction/fn.create_account.html
My real question was whether its possible to create the account used to init the mint on-chain as well, or if that should be passed in always?
https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html#spl-constraints
theres also the documentation
perfect thanks a lot, its pretty easy with anchor looks like
https://github.com/cqfd/anchor-token-studies
ill send u another one of his repos
Will dig around jet
Thanks, I dont think quidpro initializes a mint onchain though?
also, download "Jet Protocol"'s code base
https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo/src/lib.rs
anyone have an example of creating a new account + init a mint onchain?
I wish there was documentation where we could find the answers to these questions. I feel like every anchor dev should know these things
Very interesting. Did not know that. Good to know!
not the struct name though
awesome. Thanks so much paul
yes
I can rename the fields on my smart contract later, as long as the data itself remains the same right?

E.g. 
```
#[account]
pub struct MyStuff {
  pub dont_know_yet: Pubkey,
}
```

After I deploy the program, I can change `dont_know_yet`'s name to anything I want without causing problems, right?
Huh, it seems that my problem is due to the account created being just zeroes, even the discriminator.  I might be doing something wrong, I'll try to figure out if I'm doing something wrong before filing an issue. Thanks for answering tho, have a good one
just like you are doing now should work. pls file an issue with all your code if it doesnt
I'm a bit slow, so sorry about that lol... but I'm kinda lost. In my use case, which account would be `puppetPublicKey`? Follow-up question, how do I fetch such account using `program.account.<account-name>.fetch`?
yes
no, you can fetch it like any other account
Does that mean that if I initialize an account derived from `puppetMasterProgram` and even though it's owned by `puppetProgram` it's actually an account from `puppetMasterProgram`?

Basically, I'm creating something else entirely that I won't be able to easily "fetch" using anchor rpc namespace
i meant created by my program

gotcha, hmmm... That makes things tough lol. What's the usual workaround for that? Creating anticipated fields in advance?
wdym program-owned? all accounts are owned by programs. If youd like to extend the size of an account, you cant (yet, solana changes are coming)
hey paulx! Can I add fields to a program-owned account once it's created on the Solana blockchain?
the account `puppetPublicKey` refers to is not of type `puppet`
Thanks a lot <@!347689664855015424> that solved my error, I'm getting another error now tho. I'm getting `Error: Invalid account discriminator` when trying to `const puppet = await puppetProgram.account.puppet.fetch(puppetPublicKey);` 

Reading through the Anchor code it seems like the account discriminator for my newly created PDA doesn't match anchor expectations, any pointers to what could be causing this?
the puppet master program can create a pda that is owned by a different program using `owner = ` but that PDA must still be derived from the puppet master program. So in your js code, it should be `puppetMasterProgram.programId` as `findProgramAddress`'s last argument
Although I'm seeing this error:

> > Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account 
> >     Program 2W3NGfaYKz13aqtncJYgWEQUmzKcVhuKanHet5MCd8tx invoke [1]
> >     Program log: Instruction: CreatePuppet
> >     7AXEWRVSPavHvQtVzxCzQ5UKBRPgQ2mFtrcuH2hxjw1b's signer privilege escalated
> >     Program 2W3NGfaYKz13aqtncJYgWEQUmzKcVhuKanHet5MCd8tx consumed 8343 of 200000 compute units
> >     Program 2W3NGfaYKz13aqtncJYgWEQUmzKcVhuKanHet5MCd8tx failed: Cross-program invocation with unauthorized signer or writable account
Hey there frens, has anyone ever tried to create a PDA from a Program A to a Program B?

I'm trying to do this:

```rust
#[derive(Accounts)]
#[instruction(arguments: CreatePuppetArguments)]
pub struct CreatePuppet<'info> {
    #[account(mut, has_one = authority)]
    pub puppet_master: Account<'info, PuppetMaster>,
    // This is supposed to created a PDA in the Puppet program
    #[account(
        init,
        payer = authority,
        space = 5000,
        owner = puppet_program.key(),
        seeds = [
            b"puppet".as_ref(), 
            puppet_master.key().as_ref(),
        ],
        bump = arguments.bump,
    )]
    pub puppet: Account<'info, puppet::Puppet>,
    #[account(mut)]
    pub authority: Signer<'info>,
    pub system_program: Program<'info, System>,
    pub puppet_program: Program<'info, puppet::program::Puppet>,
}
```

And I'm calling it like this:

```typescript
const [puppetPublicKey, puppetBump] = await anchor.web3.PublicKey.findProgramAddress(
      [
        Buffer.from('puppet', 'utf-8'),
        puppetMasterKeypair.publicKey.toBuffer(),
      ],
      puppetProgram.programId
    );

await puppetMasterProgram.rpc.createPuppet({
      id: puppetId,
      bump: puppetBump,
    },{
      accounts: {
        puppet: puppetPublicKey,
        puppetMaster: puppetMasterKeypair.publicKey,
        authority: puppetMasterProgram.provider.wallet.publicKey,
        systemProgram: anchor.web3.SystemProgram.programId,
        puppetProgram: puppetProgram.programId,
      },
    })
```
Hey Guys, I just got this error when I was fetching data. Any ideas on where the error is pointing to?

`Uncaught (in promise) TypeError: Cannot read properties of null (reading 'subTree')`
correct
Sorry for the mega-block of text
The solution I came up with would be to have another instruction to be called through CPI for each single data point, that way the PDA can be derived for every single one
```rust
#[derive(Accounts)]
#[instruction(index: u32)]
pub struct AddOneCtx<'info> {
    #[account(
        init, payer = signer,
        seeds = [b"add", b"some_other_seed", index.to_le_bytes()],
        bump,
    )]
    pub data_point_acc: Account<'info, DataPoint>,
    pub signer: Signer<'info>
    pub system_program: Program<'info, System>,
}

pub fun add_data_point(ctx: Context<AddOneCtx>, index: u32, data_point: DataPoint) -> Result<()> {
    ctx.accounts.data_point_acc.set_inner(data_point);
    Ok(())
}
```
And then the first instruction would end up like this
```rust
pub fn add_data(ctx: Context<AddCtx>, data: Vec<DataPoint>) -> Result<()> {
    for i in 0..data.len() {
        // Add a PDA for each data point
        let index = ctx.accounts.add_acc.n_accounts + i;
        // Build the CPI context
        todo!("This is where I'm stuck");
        // Make the CPI call
        data::cpi::add_data_point(program_acc_info, cpi_ctx)
    }
    ctx.accounts.add_acc.n_accounts += data.len();
    Ok(())
}
```
I'm able to get all the public keys for the accounts that need to be included in this context, using `Pubkey::find_program_address`. However, I can't find a way to invoke an instruction by just including the public keys in the context, it already needs the `AccountInfo`s.
To summarize, my question is, how can an instruction send an account to another instruction, when it can't receive it in its context?
Does anyone know how to solve the following problem?
I have a program instruction that needs to create a variable number of accounts depending on an external factor. These need to be PDAs, because they need to be accessible later. The way I'm doing this is by adding the number of currently created PDAs as a seed for the next one. The instruction looks something like this.
```rust
#[derive(Accounts)]
pub struct AddCtx<'info> {
    #[account(
        mut,
        seeds = [b"add", b"some_other_seed"],
        bump
    )]
    pub add_acc: Account<'info, AddData>,
}

#[account]
pub struct AddData {
    pub n_accounts: u32,
}

#[account]
pub struct DataPoint {
    // Some data I want to store in an account
}

pub fn add_data(ctx: Context<AddCtx>, data: Vec<DataPoint>) -> Result<()> {
    for _ in 0..data.len() {
        // Add a PDA for each data point
        ...
    }
    ctx.accounts.add_acc.n_accounts += data.len();
    Ok(())
}
```
or are they actually different things?  i.e. creating a token account via the token program and greating an associated token account via the ata program result in 2 different accounts -- they do kind of the same thing but under the covers they aren't strictly the same?
ok - so associated token accounts are actually token accounts -- i.e. they are the same thing -- the difference is only that ATAs addresses are deterministically generated based on the wallet/mint combo?
it's just a way of standardising PDAs for token accounts i think
and the ATA is what i'd be looking for when i'm sending you a token
you can make token accounts with whatever addresses you like, but for each user + mint there is only one associated token account
an associated token account is just a token account generated by the token program iiuc
thank you -- makes sense now - i didn't understand the difference btw token account and associated token account and was confused - appreciate the explanation!
thank you  - sorry I didn't realize token account and associated token account were actually different things
Add null/error checking where necessary
Something like
```js
const responseAcc = await program.accounts.response.fetchNullable(pubKey);
const response = responseAcc.yourBool;
```
The way I understand it, no. The main idea is to create an account that your instruction should write its response into, and include it in your context. After invoking the instruction, your client can fetch that account and read the data.
https://github.com/project-serum/anchor/blob/e48f84c6bd7122a7d7744be2a9b25b7e8d2efc11/tests/ido-pool/programs/ido-pool/src/lib.rs#L117

For IDO Pool example.Does someone know a way how can I implement a functionality to allow only 10% withdraw at max. ? Do I need to maintain state of it somewhere in a PDA of user ? Any better approach
anyone knows what can be the problem? thanks
Hello guys, i have this problem with the anchor build command , it says : Failed to obtain package metadata: `cargo metadata` exited with an error: error: failed to load manifest for workspace member `
Can we return a result from an `anchor` instruction handler?
```
pub fn getBool(_ctx: Context<Initialize>) -> ProgramResult<bool, ProgramError> {
Ok(false)
}
```
And from client do something like:
```
const response = await program.rpc.getBool(...);
assert.equal(response,false);
```
In short how do I handle response types that are not errors or void?
the mint is like the address for the actual token itself, token accounts (and associated token accounts) are where instances of this token mint are stored. 

for example, if i have an NFT, there is only one token with the mint address for this NFT. when i have it, it’s in a token account that i own. when i send it to you, i pay to create an associated token account (that you own) for that mint and then i transfer the NFT from my token account to your new token account.
I have seen some blockposts about downgrading my solana version, but not sure if thats a good idea in general
thx a lot John! It's just that I applied all these steps, and it still seems to not work. Is there any other possibility that there is a anchor version mismatch? I even cross-compared the IDL on devnet (with `anchor fetch`, and the IDLs seem to be fine!)
Hey, are there bindings for the shared memory program within anchor?
Hi, can I use HashMap in Anchor code? I heard that Solana program doesn't support hashmap. right?
https://paulx.dev/blog/2021/01/14/programming-on-solana-an-introduction/#the-token-program-part-1
no. mints are referred to as mints.
using anchor
Are there any examples of safe sending custom amount of sol?
gm
Noting this here because someone might search for it and I just spent a long time figuring this out: If you're using the "--clone" feature and getting a "Attempt to load a program that does not exist" as part of "Transaction simulation failed" it is likely that you cloned the program but *not* the program data account. You need to clone both.
Do command + click on vscode to see the implementstion of that function
Pretty sure borrow is borrowing the reference to the lamports field
Could someone explain what this means
```let account_lamports = **item.to_account_info().lamports.borrow();```
specifically the "**" and "borrow()"
```solana config set --url localhost```
then check
```solana config get```
then run in a separate window
```solana-test-validator```
and then in original window
```solana airdrop 1```
then check
```solana account <your address>```
I've already airdropped SOL to my local wallet, which has 4 sol atm
Hey there I'm just getting started. When I run `anchor deploy` in the `basic-0` tutorial I get:
``` Error: Account <my public key> has insufficient funds for spend (1.06508184 SOL) + fee (0.00078 SOL)
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.```
but when i using phatom i can not get keypair right?
for signers
you see i am using keypair here 
 const offer = anchor.web3.Keypair.generate();
yes i have code using TS and sign by keypair below
but how i can using phatom for it? many thank
 const offer = anchor.web3.Keypair.generate();
  console.log("offer : ", offer.publicKey.toBase58());
  const [escrowedMakerTokens, escrowedMakerTokensBump] = await anchor.web3.PublicKey.findProgramAddress(
    [offer.publicKey.toBuffer()],
    program.programId
  );

  await program.rpc.make(
    escrowedMakerTokensBump,
    new anchor.BN(1),
    new anchor.BN(200000000),
    {
      accounts: {
        offer: offer.publicKey,
        offerMaker: myWallet.publicKey,
        offerMakersMakerTokens: offerMakersMakerTokens.address,
        escrowedMakerTokens: escrowedMakerTokens,
        makerMint: addressNFT,
        takerMint: MINT,
        tokenProgram: spl.TOKEN_PROGRAM_ID,
        rent: anchor.web3.SYSVAR_RENT_PUBKEY,
        systemProgram: anchor.web3.SystemProgram.programId,
      },
      signers: [offer]
    });
i assume you mean how to sign a function with a phantom wallet? you basically need to create a transaction and then use the wallet to sign it -- then you send it
thanks
Hi all ,
how can i using phantom signers for my rpc function?
I guess check the permissions on the file
thanks for explaining! so in practice are these "token accounts" what are referred to as "mints"?
i keep trying to deploy to mainnet fork and continue to get the 

Error: Pubsub error: ConnectionError(Http(Response { status: 405, version: HTTP/1.1, headers: {"server": "nginx/1.18.0 (Ubuntu)", "date": "Wed, 19 Jan 2022 00:58:45 GMT", "content-length": "0", "connection": "keep-alive"}, body: None }))
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.

any idea how to fix this ?
is this discord active?
and it always gives me permission issues
i give the exact location to my key
does anyone know why I cant do this command?

how is rent determined for a zero-copy account? Does it just use the Default size of the data in the account?
ahhh rugged myself. bad endianness. thx for being my rubber duckies
rm-ing the uint64 seed passes
something weird is happening, I'm init-ing a pda using the ix signer pubkey ++ epoch. but I get inconsistent errors on diffferent invocations:

err 1:
```
<PUBKEY_OF_PDA>: signer privilege escalated
'Program 11111111111111111111111111111111 failed: Cross-program invocation with unauthorized signer or writable account'
```

err 2:
```
provided seeds don't result in valid address
```
https://github.com/project-serum/anchor/blob/master/lang/src/error.rs#L5
Hello, I'm just wondering if we could have some custom token with balanceOf() override, just like ERC20 in solidity, so that we can change balance of every tokenAccount without mint of burn? Anyone know how that works? thanks in advance.
it is well defined. its an account owned by the token program of the token program account type which is also called  "Account"
a mint can in theory have infinite token accounts. a user can have multiple token accounts and even multiple token accounts for a single mint. but a user can only have one associated token account per mint
or actually, and idea why I could be getting the `0x64` error?

```
Transaction simulation failed: Error processing Instruction 1: custom program error: 0x64 
    Program 11111111111111111111111111111111 invoke [1]
    Program 11111111111111111111111111111111 success
    Program 5W8cgQkGhjniKuVikNyVq6Nh5mWVzHawRnXkWhL7risj invoke [1]
    Program 5W8cgQkGhjniKuVikNyVq6Nh5mWVzHawRnXkWhL7risj consumed 927 of 200000 compute units
    Program 5W8cgQkGhjniKuVikNyVq6Nh5mWVzHawRnXkWhL7risj failed: custom program error: 0x64

``` 

this is what the RPC call looks like:
```
return await this.program.rpc.create(bump, arg1, arg2, {
      accounts: {
        state: stateAddress,
        pool: poolAddress,
        tickmap: bitmapKeypair.publicKey,
        payer: payer.publicKey,
        rent: SYSVAR_RENT_PUBKEY,
        systemProgram: SystemProgram.programId
      },
      signers: [payer, bitmapKeypair],
      instructions: [await this.program.account.tickmap.createInstruction(bitmapKeypair)]
    }) 
``` 

any thoughts would be really appreciated 😅
I'm using anchor 0.20.1, and I need to reinstall because getting some `0x64` errors while using anchor
when I reinstall solana 1.8.5 (previously using 1.8.12), do I need to uninstall / reinstall my anchor from scratch as well?
anyone have any more examples of progams that uses the amount of lamport transferred in a transaction as an input?
for example, user1 sends 10 SOL to  user2, I'd like to take the "10" SOL from the transaction and use it in a program to increment a data account (where counter += amount of SOL user1 sent to user2)
ergh arguments in wrong order
Thanks!
Hmm I'll take a look
^^ idk but maybe you can use wrapped sol for it?  
https://spl.solana.com/token#wrapping-sol
Hey guys, is there an example program where I can create an account, fund it and then transfer the funds programmatically?
got it. I tried to code but the error is silent. Solana makes it so difficult.. why 😩
I think "token account" isn't well defined -- I think "associated token account" is what you kind of mean by it -- b/c I don't know what "token account" would be -- except for "mint"  - which maybe thats what it's meant to be?  its a good question
commented it out, looks like none of the accounts are being recognized as valid params
a bit confused about this argument err I'm getting.

Setup: 2 programs in the same anchor workspace, each with the correct program_ids in their respective files

Error: Invalid arguments: config not provided

Config is an account the ix expects, and I'm definitely passing it in. The variable is no undefined either so that's not the issue
hey, from what i read i am confused between associated token account and token account. So are you saying I can create 2 token accounts for a mint and transfer tokens among them? or does it have to be from one token account to another associated-token account
afaik -- each time you want to transfer or mint_to one of the tokens from the mint - it goes into a token account - so if thats what you mean by 2 token accounts -- then yes
Total noob question here - Can there be 2 Token accounts for same Mint? Does every mint have only one token account?
Yeah I feel like I was just looking at it comletely the wrong way
it defintely takes some getting used to 🙂
eth thought me nice 😄
For some reasons accounts seem so confusing to me because I think like shouldnt it be like a struct mapping or something
After looking through it a bit more I cant say for certain but my idea is that... On a transaction the signer that initialises pays the rent. But the program spends it
not sure exactly -- but maybe constraints could help? or you could use "init_if_needed" ? 
https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html
for PDAs good question - idk who pays the rent -- i thought the program but i don't really know
How can I use a custom error message when a collision on the initialization of a PDA account occurs?
Error: 2003: A raw constraint was violated
and the rent is then paid by the signer?
Ah okay so Im guessing on the anchor tutorial for example...  Each time initialise is being called by a different contract a new account gets created?
I think you’d put it in a token account that was owned by a PDA
What would the correct approach be for anchor?
On solidity I would use an address mapping key to a uint value
I am struggling coming from solidity 😛 lets say I was going to build a mechanism where people would deposit an SPL token in a vault
Ok I guess check and see what the IDL json supports
https://twitter.com/0xpemulis/status/1483115445389508610?s=21 just saw this ‘crank’ expl and thought of <@832140329301311488>
Thanks, i realized that solana doesn't handle balances numbers in the same way that etherium.


//////////////////////////////////////////////////////////////////////////////////////////

Are there any good guides on how to connect wallet and approve transactions with phantom on a React UI? Do I have to fetch the IDL everytime?
ok - I think the path is via "wallet.signTransaction" -- will go down that path 🙂
I have kind of a dumb question -- is there any way to use a wallet in a dapp to sign a transaction?  i.e. to prompt the user to agree to sign it?  or should i just be generating throwaway keys to sign things?
check and see what is in anchor.workspace.Calculator
Can Someone Please Help me out with this error i get whenever i run anchor test
is there a good example somewhere of transfering lamports? all I'm getting is errors saying the program needs to own the account to modify it?
another noob question: does the `with_signer` method of the `CpiContext` assumes that the last seed is the always bump? So I have to tack on the bump onto the seed list I used for `Pubkey::find_program_adress`?
gotchu
you cant access the caller from inside an instruction but you can ask the caller to pass in their account (or pubkey as ix data)
if it wasnt the providers pubkey, youd have to add it too, because `user` pays for `BaseAccount`'s creation
so, i want to set some constant params which are not going to change ever. they will be assigned by whosoever calls the initialise function for the first ever time. how do i do so
you can omit the `user` because it's the provider which pays for the tx and therefore anchor already has it registered as a signer
shouldn't the user go here? like provider.wallet?
not sure what you mean
```
await program.rpc.initialize({
    accounts: {
      baseAccount: baseAccount.publicKey,
      user: provider.wallet.publicKey,
      systemProgram: SystemProgram.programId
    },
    signers: [baseAccount] <-- add this
  });
```
can you guide me on how to do so? i guess the new error is associated the signing itself.
eesh, that is what it was. so sorry. tysm for the help.
oh, damn, right. so how do i restrict initialize to only one address, that is of the first caller?
maybe you did some renaming half-way and forgot to update the client side?
did you rename your `basic_0.json` file on purpose, to make this client work? I see that you are importing it with that name, while the module is called `splits_program`, which will lead to `splits_program.json`
also again, dont think this is related to your error but youre missing the `signers` array here. `BaseAccount` is getting created so its keypair has to sign
<@!691933164909756466> not related to your error but you can omit the `inited` property and this check `ctx.accounts.base_account.inited == false` in your initialize function. When you use the `init` constraint on an account, it will fail if the account already exists. Therefore, `ctx.accounts.base_account.inited == false` will always be true. Also, because your `BaseAccount` does not hold types with dynamic sizes, you can implement `Default` for it and omit the `space = 9000` (you cannot do this for `AdminAccount` because it contains a `Vec`)
as you can see, im not accepting any params
you can find the short program here: https://github.com/xedk/solana-splits/blob/main/programs/contracts/src/lib.rs
The error says "you tried to access index 0, but your array is of length 0"
Have you already posted this function, maybe?
just a runtime one
that is a still a program error
the program builds flawlessly
no, i'm not accessing any remaining accounts in this fn
are you perhaps accessing some `remaining_accounts` in your program, while not providing one?
this is a program side error, can you post that?
this is my client.js ^
```
const anchor = require("@project-serum/anchor");
const { SystemProgram } = anchor.web3;

const provider = anchor.Provider.env();
anchor.setProvider(provider);

async function main() {
  const idl = JSON.parse(
    require("fs").readFileSync("./target/idl/basic_0.json", "utf8")
  );

  const programId = new anchor.web3.PublicKey("51NDADRmoBvRPa4PQz7WixDurvS5SXncdnWGhM7nuNqK");
  const baseAccount = anchor.web3.Keypair.generate();
  const splitAdmin = anchor.web3.Keypair.generate();

  const program = new anchor.Program(idl, programId, provider);

  await program.rpc.initialize({
    accounts: {
      baseAccount: baseAccount.publicKey,
      user: provider.wallet.publicKey,
      systemProgram: SystemProgram.programId
    }
  });
}

console.log("Running client.");
main().then(() => console.log("Success"));

```

hey folks! im getting this error while running client.js
also writing tests for anchor programs? Should we just follow the standard solana program way?
ik about cpi on the solana library, but is there a specific way we should use it with anchor?
like how would i do it with anchor?
What to tell?
can anyone tell me about anchor and cross program invoking other anchor programs?
Hello, I'm currently working on using Systemtime on solana program.
but it constantly emits error, (it panicks) so I wonder how I could get current UTC time from rust file. 
Can you guys give me the clue?
Anyone know where I can find how transaction signatures are computed?
I feel so relieved rn, seems like I did finally understand it 😅 Thank you so much as always <@!134416332509675520> !
And yep, an associated token account is really just an associated token address (a pda derived from the associated token program), since the account itself is still owned by the spl token program
A token account both has that token-account kind of data as well as its AccountInfo owner field (the program owner) set to the spl token program
Yep, token account stuff goes in the corresponding AccountInfo's `.data` field
Also, I wanted to clarify a few things I've been confused about. 

So, a standard Account of Solana has the following fields, 
```
pub struct AccountInfo<'a> {
    pub key: &'a Pubkey,
    pub is_signer: bool,
    pub is_writable: bool,
    pub lamports: Rc<RefCell<&'a mut u64>>,
    pub data: Rc<RefCell<&'a mut [u8]>>,
    pub owner: &'a Pubkey,
    pub executable: bool,
    pub rent_epoch: Epoch,
}
```

Please let me know if any of the following points are wrong -

- This is mandatory for every Account that exists.
- The `owner` here is the **Program** that owns this account

Now, for a Token Account, or to be more specific, in `spl_token`, the struct `Account` is as follows:
```
pub struct Account {
    pub mint: Pubkey,
    pub owner: Pubkey,
    pub amount: u64,
    pub delegate: COption<Pubkey>,
    pub state: AccountState,
    pub is_native: COption<u64>,
    pub delegated_amount: u64,
    pub close_authority: COption<Pubkey>,
}
```

So, my first question is that, is this `spl_token`'s `Account` struct, what is stored in the `data` field of the `solana_program`'s `AccountInfo`?? 

Another question I have is that, is a TokenAccount is any account with the above mentioned struct as its `data`?? And an Associated Token Account is a TokenAccount with a specific address, or to be more precise a PDA derived from the Associated Token Program???
You'd have to build the instruction yourself, similar to what anchor does here: https://github.com/project-serum/anchor/blob/master/lang/syn/src/codegen/program/cpi.rs#L39
The `instruction::` thing just specifies the data part of the instruction, not the accounts (or the program_id, but I guess that should be clear from context)
Hmm, I'm actually not sure if there's a super easy way to go from that `instruction::CreateAuctionHouse` type to an actual solana instruction
```
  let transaction = Transaction::new_signed_with_payer(
    &[
      instruction::CreateAuctionHouse {
        bump: bump,
        fee_payer_bump: fee_payer_bump,
        treasury_bump: treasury_bump,
        seller_fee_basis_points: 10000,
        can_change_sale_price: true,
        requires_sign_off: true,
      },
    ],
    Some(&payer_key),
    &[&fee_payer_key, &treasury_key, &fee_payer_key],
    context.last_blockhash,
  );
```

```
expected struct `solana_sdk::instruction::Instruction`, found struct `mpl_auction_house::instruction::CreateAuctionHouse`rustc(E0308)
lib.rs(47, 7): expected struct `solana_sdk::instruction::Instruction`, found struct `mpl_auction_house::instruction::CreateAuctionHouse`
```

I'm trying to write some rust based specs for Metaplex auction house contract but am encountering a type mismatch when applying the instruction. Anyone have some examples of testings anchor programs in rust? I see there is an anchor rust client that accepts anchor structs but how do I connect that to the bank_client provided by the solana sdk test package?
Hi there, coming from buildspace with a quick rust question. i was going through the tests but can't seem to find anything relevant..
I want to remove an entry from a Vec, i've seen .remove and .retain but not sure
Just not possible to skip that in solana
And if you want to transfer sol to it, there's unfortunately no way around having to pass it back in from the client
You could store a Pubkey as a pointer to the actual account info though
Nope, that won't work unfortunately
can i store an AccountInfo or Signer as a field inside my #[account] struct? Trying to add the required lifetime gets me a Borsh serialization trait error. If not, is there a way for me to store an account and not just a pubkey, so that I can later transfer sol to it?
Yep, actually <@!448034961652449283> added it 🙂
is this pubkey thing a new thing? Must be, feels pretty useful
interesting
Check out `anchor idl --help`
Yeah, you have to explicitly upload it
i.e. doesn't default to having it
thanks, is upload different process than deploying with anchor?
You can try running `anchor idl fetch <prog-id>` (no guarantee one has been uploaded though)
alan do you know if one can find IDLs for a given program id?
```.rs
const admin_pk: Pubkey = anchor_lang::solana_program::pubkey!("asdfasdfsad");
```
```.toml
[dependencies]
...
solana-program = "1.9.2"
```
Ok I'm actually pretty confused about wtf rust/cargo is doing here, but solana_program has a macro to do just this, `pubkey!`. For some reason I have to add an explicit dependency on `solana_program` to my program's Cargo.toml (I don't know why, since anchor_lang re-exports solana_program 🤔)
There is a way but I'm trying to figure out how to use it :/ 1 sec
I am hardcoding a pubkey so to make certain functions "admin only"
You can pass in the admin account every txn, maybe use anchor constraints to check it? Not sure if possible
is there any other way to hardcode public key?
Is there a way to find the IDL for a given program ID? (Not my program)
Yeah, can't do a const pubkey like that unfortunately
for `Pubkey::new(pubkey_bytes);`
getting "calls in constants are limited to constant functions, tuple structs and tuple variants"
```const pubkey_bytes: &[u8] = "Hih8kbSfSdZQRJe1Sb3piCCzeuvtuHrqKt1oMi5yWqRm".as_bytes();
const admin_address: Pubkey = Pubkey::new(pubkey_bytes);```
Ok, then you'll have to use the `anchor_lang::solana_program::system_instruction::transfer` instruction + `invoke`
making an auction program so i need to send sol between the auction account and a phantom wlalet
yes it is
How you send sol depends on which program owns the source account. Is the source account here a wallet?
Nope, that's only for actual spl tokens (native sol isn't a token—you might be thinking of "wrapped sol")
hey ive been struggling to send native sol between two accounts - is anchor_spl::token::transfer the way to do it?
```
Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: custom program error: 0x0
```

This error is not in anchor, I think it's coming from here? https://github.com/solana-labs/solana-program-library/blob/master/token/program/src/error.rs#L13

But my account is definitely rent exempt...
that doesn't use `simulate` tho
You're going to have to explicitly write out all lifetime params for your instruction function, unfortunately:
```.rs
pub fn your_instruction<'a, 'b, 'c, 'info>(ctx: Context<'a, 'b, 'c, 'info, YourInstruction<'info>>) -> ProgramResult {
  ...
}
```
error: lifetime mismatch ...but data from `ctx` flows into `ctx`
Gonna be hard to explain it better than just reading the rust book: https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html
`ctx.accounts.msg_sender.to_account_info()` gives error
```
anchor_lang::solana_program::program::invoke(
                &ix,
                &[
                    ctx.accounts.msg_sender.to_account_info(),
                    ctx.remaining_accounts[index].to_account_info(),
                ],
);
```
The ondisk format is just [<32 bytes of private key> <32 bytes of public key>]
weird asf
yeah for some reason it looks that there was already an account using that address, rebuilt it with another program id and it deployed
Or can this keypair be generated using the solana cli?
Hi friends. Im trying to use https://docs.rs/solana-sdk/1.4.14/solana_sdk/signature/fn.read_keypair_file.html to read a keypair into a rust program, just wondering what format the json file should be in for this to work?
Account<'info, BlogState> can someone explain this to me in plain English? I am trying to understand lifetimes and what `'info` literally means here
Thank you very much.
It worked. I was looking to this documentation to make the code, maybe i got the concept of "owner" wrong this time
You then ask the spl token program to modify that mint (to get it set up to be a mint), but it can't do that because you set its owner to be the payer, not the spl token program
Definitely weird to `create_account` with the last argument as the payer (it's supposed to be the *program* that owns the account, here it would be the spl token program)
Are you sure there isn't already an account using that address?
there should be good instructions on the "Create react app" site -- im not an expert in react or create-react-app -- but yeah -- there is a way to "eject" - which just means all the config is open to you to change - and you can add the missing polyfills
any tips on what i can do to fix this and actually deploy to devnet
```
Error: Account <program address here> is not an upgradeable program or already in use
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }.
```
I'm trying to deploy to devnet and I'm getting this

The deploy wallet has enough SOL (10), I've used anchor build and updated the program id in lib.rs and in anchor.toml, and i've even added ```cluster = "devnet"``` under provider in anchor.toml
you can get the error code, and guess you can cast `LangErrorCode.InstructionMissing` to the right type to compare?
```ts
    try {
      const tx = await program.rpc.initialize({});
      console.log("Your transaction signature", tx);
    } catch (e) {
      console.log("error", e.code);
    }
```
ok sorry I was battling different versions for my anchor CLI, npm package, and crate
That might be the solution to this damn bug haha
I did use that command- how do I eject and which command to recreate the app? Thanks
Hi guys, any ideia why I'm getting this issue? `instruction modified data of an account it does not own`. Here is my codebase:
```rust
    pub fn create_mint(ctx: Context<CreateMint>) -> ProgramResult {
        let create_account_instruction = create_account(
            ctx.accounts.payer.key,
            ctx.accounts.mint.key,
            ctx.accounts.rent.minimum_balance(82).max(1),
            82,
            ctx.accounts.payer.key
        );

        invoke(
            &create_account_instruction,
            &[
                ctx.accounts.payer.to_account_info().clone(),
                ctx.accounts.mint.to_account_info().clone(),
                ctx.accounts.system_program.to_account_info().clone(),
            ]
        )?;

        let initialize_mint_instruction = initialize_mint(
            ctx.accounts.token_program.key,
            ctx.accounts.mint.key,
            ctx.accounts.payer.key,
            Some(ctx.accounts.payer.key),
            0
        ).unwrap();

        invoke(
            &initialize_mint_instruction,
            &[
                ctx.accounts.mint.to_account_info(),
                ctx.accounts.rent.to_account_info(),
            ]
        )?;
        Ok(())
    }
```
in my TS tests after calling an instruction
`assert(res.value.err == LangErrorCode.InstructionMissing`
No sure I got what you are trying to do?
How do I do something like `LangErrorCode.InstructionMissing` in my TS tests?
https://github.com/project-serum/anchor/blob/v0.18.2/ts/src/error.ts#L53
I feel so smart to have guessed you are using Anchor from a question in the Anchor discord
Are you familiar with the TS client lib?
I'm guessing from the above that you are using anchor. If by client you mean TS client, Anchor lets you create a program object that allows to easily call your program's functions, as well as fetching accounts.
eesh, ok. so how do i read some data stored on-chain from the client?
Oh this is a top level program function, not a helper function. You cannot return anything apart from an error or `Ok()`
see, i'm passing base_account.splits
```
pub fn get_acs(ctx: Context<ReaderContext>) -> ProgramResult {
        let base_account = &mut ctx.accounts.base_account;

        // this has to be returned: `base_account.splits`

        Ok(base_account.splits)
}
```
Better post your code snippet. Your function signature just needs to match what you actually return. In Rust you either use the familiar `return X;`, or just make the last expression evaluated in the function be the value you return: `X`. Note the absence of a semicolon in the latter.
it says `Ok expected () but got std:Vec::Vec`
is it supposed to go in OK(...)?
how do i return data from a function?
if you used create-react-app - there are some problems i ran into with webpack5 -- I ended up needing to "eject" the create react app so I could add the polyfills
Will install react-scripts@2.1.3, which is a breaking change
node_modules/svgo/node_modules/nth-check
  css-select  <=3.1.0
  Depends on vulnerable versions of nth-check
  node_modules/svgo/node_modules/css-select
    svgo  1.0.0 - 1.3.2
    Depends on vulnerable versions of css-select
    node_modules/svgo
      @svgr/plugin-svgo  <=5.5.0
      Depends on vulnerable versions of svgo
      node_modules/@svgr/plugin-svgo
        @svgr/webpack  4.0.0 - 5.5.0
        Depends on vulnerable versions of @svgr/plugin-svgo
        node_modules/@svgr/webpack
          react-scripts  >=2.1.4
          Depends on vulnerable versions of @svgr/webpack
          node_modules/react-scripts

6 moderate severity vulnerabilities
 

for more context
How do i capture the deployer address?
npm WARN EBADENGINE Unsupported engine {
npm WARN EBADENGINE   package: '@toruslabs/http-helpers@1.4.0',
npm WARN EBADENGINE   required: { node: '>=14.17.0', npm: '~6.x' },
npm WARN EBADENGINE   current: { node: 'v16.13.1', npm: '8.1.2' }
npm WARN EBADENGINE }

these are the warning I get when I install dependencies using npm - maybe has something to do with erros? Im on linux


//////////////////////////////////////////////////////////////////////////////////////////

im not running Linux so assuming the ca5rgo like I have been doing
cargo install --git https://github.com/project-serum/anchor --tag v0.20.1 anchor-cli --locked
or
npm i -g @project-serum/anchor-cli
which anchor should I download. I am a bit new on this...
Whats’s the difference between using the NodeWallet vs AnchorWallet? They have different functionality or different use cases? 

I’m building an app in Node.
thank you for the help!
ya. Let me try this again
you should be good then
this is an older iMac 5k
if you're on an m1 you will have to build from source
def. I have been referring to this
make sure you follow this part first: https://project-serum.github.io/anchor/getting-started/installation.html#install-rust
thanks for breaking down the issue and logic
ok let me retry
and you should be good
and not have that space there
start over
well iw ould blow out the repo
lol
the heck
now cant find a module
thats weird

hmmm ok one sec. It doing new things....oh shit ya.....ok
777 gave it execute perms
and it didn't have execute perms
permission denied, because you were trying to execute it, instead of passing it into ANCHOR_WALLET
remove the space
after anchor_wallet
you ahve a space
oh lol
basically does that a few more lines and just temrinates

something different but odd
oh weird wth one sec
let me rerun
ok
no that wouldn't matter
could that be the issue?
can i be in the basic 0 folder when doing the command?
its done this before when i started over, but ill try again
its odd right?
if that doesn't work, i would just blow out the entire repo and re-clone it and try from scratch
let me see
that's pretty weird.  i guess try `sudo chmod 777 /Users/Bryson/anchor-master/examples/tutorial/basic-0/walletid/id.json`  that should be over kill

one sec
oh it cut off
i remember i did do that....the issue was there so that why i tried to move the file closer to the project
the easiest thing to do is probably do `solana-keygen` and then you can do `ANCHOR_WALLET=~/.config/solana/id.json`   but that assumes you don't already have a real one there
i appreciate you taking the time with me to figure this out
ok let me see
that should show the permissions and everything in the folder
can you try `ls -alh /Users/Bryson/anchor-master/examples/tutorial/basic-0/walletid/*`
permissions
this permission bs has haunted me
i need to move my workflow away from mac
so no changes on it allowing me

yeah
ok ill try
?
sudo chmod a+r /Users/Bryson/anchor-master/examples/tutorial/basic-0/walletid/id.json
or you can just generate your own keypair and point to that one
this isn't really an anchor issue; but you can probably do `sudo chmod a+r <path_to_id.json>` to fix it
there it is.wont even let me access the file

let me see if i can send another
it said it didnt have permisiion
oh shit thats not what it said before. its because i moved the file back.
<@!288735346122948611> what does "no such file or directory: xyz" mean to you?
any ideas at all as to why this AccountDidNotDeserialize is happening ?
i successfully deployed with anchor....
do i need to do wallet address instead or location of id.json?

Hello guys I read the sealevel attacks  owner check example:https://github.com/project-serum/sealevel-attacks/blob/master/programs/2-owner-checks/secure/src/lib.rs I just curious why spl-token not add ownership check with spl-token:ID in the library, is it intended? Because I cannot find such validation in spl-token lib.
thats what it seems but i dont know why it would do that. Ya i will
This sounds like a file permission issue? Can you share your actual command and terminal output?
It’s a really generic error. Can you share more context?
probably too new of a program still to have enough people helping othe rpeople :/
Anchor needs more support lol.
can anyone help me. I am trying to run the client.js in this basic_0 test program. I enter my keypair location into this command and it denies me permissions. I am following the suggested doc direction and still not getting through.

ANCHOR_WALLET= /Users/Bryson/anchor-master/cli/src/SolanaWalletEscrow/id.json node client.js
Please help in figuring what is wrong
These are the rpc variables : tx: Transaction {
  signatures: [],
  feePayer: undefined,
  instructions: [
    TransactionInstruction {
      keys: [Array],
      programId: [PublicKey],
      data: <Buffer 34 df b1 eb 87 ab 49 60 05 00 00 00 00 00 00 00>
    }
  ],
  recentBlockhash: undefined,
  nonceInfo: undefined
}
signers: [
  Keypair {
    _keypair: { publicKey: [Uint8Array], secretKey: [Uint8Array] }
  }
]
options: undefined
hey guys, i am facing this error -> Transaction simulation failed: Error processing Instruction 0: Program failed to complete
It would just have a built in max length
I think you’d have a fixed length buffer to store the string, so they wouldn’t give space input
If I go the String route is asking users to give input for space dynamically idiomatic?
I would just init one and let it be ephemeral, but you can definitely just query accounts directly from a purely technical perspective, unsure if you can use anchors generated client or not
Is your question about whether you should store the raw ip addr bytes versus a string? Or about how to do the dynamic spacing part?
I'm trying to write a script that queries data from the my program's accounts using `anchor.Program`. I don't need to send any transactions, but it looks like I'm required to provide a wallet to use `Program` (it needs a `Provider` which needs a `wallet`). Is there any way to query and deserialize account data without a wallet?
dm me the code
I have a PR open which fixes a bug, what do I need to do to get it merged? I ran tests locally and they passed but unsure beyond that
I realized that I also had to make the `from` and `to` mutable, since they would be getting tokens removed/added to them. But now I'm getting a less descriptive error 
```
Error processing Instruction 0: invalid account data for instruction 
    Program 2Rqe9xhD7cvq2oYeFCJq2e18K4pQbiNSZNgX835J7S3w invoke [1]
    Program log: Instruction: Initialize
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [2]
    Program log: Instruction: Transfer
    Program log: Error: InvalidAccountData
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 1294 of 195471 compute units
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA failed: invalid account data for instruction
    Program 2Rqe9xhD7cvq2oYeFCJq2e18K4pQbiNSZNgX835J7S3w consumed 5823 of 200000 compute units
    Program 2Rqe9xhD7cvq2oYeFCJq2e18K4pQbiNSZNgX835J7S3w failed: invalid account data for instruction
```

Any idea how I can debug that error to figure out what data is invalid?
but it's a bit awkward with IpV6
I could have it be a byte array and store Ip addrs instead
I want to store a connection string on a PDA in a way that's anchor-esque. Since urls can be of various lengths I'm allowing users to specify the extra space to allocate for the field rather than allocating a fixed size for instances of the PDA
hey frens
trx failing - https://explorer.solana.com/tx/27wycrHvTgTsNC3wcZuv5T5FWDCpJ44GLc8Wyq28x2FdgMmaZdXu8G7kd5K9wehJ95mWZkaViRLYXCEVCf7Pe48Y?cluster=devnet
im trying to fix a program in metaplex to work with cm v2. calling the function here https://github.com/bonkworld/metaplex/blob/fix-gumdrop-v2/js/packages/gumdrop/src/components/Claim.tsx#L371-L406 . i updated the struct to match new candy machine data structure. the code continues to blow up here with AccountDidNotDeserialize https://github.com/bonkworld/metaplex-program-library/blob/v2-gumdrop/gumdrop/program/src/lib.rs#L337-L338 . im all out of ideas i've been stuck on this for days now, if anyone sees something extremly obvious
Okay, I see that now, thank you
Thanks!
Yeah that's what they told me over at the Solana dc too 😄
You'll have to pass that account in from the client.
You'll have to rethink your design unfortunately—it's just not possible in solana to dynamically look up accounts like that, they always always have to get specified ahead of time by the client.
nvrmind found here

https://solana-cookbook-git-fork-losman0s-using-mainnet-6e845e-cookbook.vercel.app/guides/get-program-accounts.html#facts
Anyone got a Typescript code snippet for pulling a program's PDAs given a program ID?
any reference
its a constant in web3.js
how we get address of this system token program
Hey, can I close an account with just a public key as the SOL destination? I wanna have PDAs that store who to send the lamports to when they are closed.
but something is clearly wrong with my code.
and tokens will get transferred to user's associated token account. Thats the goal
in this case i think both payer and signer are user as user is initiating this call
and payer should be a Signer?
i am just trying to modify those examples in hopes it would work. 😋
i have seen such examples floating on internet. not sure though
idk is it allowed to use associated_token with init_if_needed
mint refers to the TokenMint (pubkey) and token_program is system token program
what is diffeence betwen mint and tokenprogram
#[derive(Accounts)]
#[instruction(user_token_amt: u64)]
pub struct SendTokens<'info> {

    #[account(mut, signer)]
    pub user: AccountInfo<'info>,

    pub mint: Account<'info, Mint>,

    #[account(
        init_if_needed, 
        payer = user,
        associated_token::mint = mint,
        associated_token::authority = user,
    )]
    pub user_account: Account<'info, TokenAccount>,


    #[account(mut,constraint = vault_account.amount >= user_token_amt)]
    pub vault_account: Account<'info, TokenAccount>,

    pub vault_authority: AccountInfo<'info>,

    #[account(zero)]
    pub escrow_account: Box<Account<'info, EscrowAccount>>,

    pub system_program: AccountInfo<'info>,
    pub rent: Sysvar<'info, Rent>,
    pub token_program: AccountInfo<'info>,
}
any particular reason why common::close is private? use case - close remaining accounts
whats the source code
is this error because i have not upgraded my anchor to 0.2?
hey guys, getting an error when i use #[account(init_if_needed, payr.... Error says expecting = after init_if_needed. Any idea why is it expecting = and not ,
or do I create my own type and implement the `Id` trait myself
another question I have is if there is a `system_program` version that I can pass to `Program` account types?
in my context Anchor requires Rent because I am initializing an account. so right now I'm adding the Rent account to the context as a `Sysvar`. but these days you don't need to have your sysvar info passed along as an account so I was wondering what the alternative is because Anchor complains if I don't include the Rent sysvar
using init in to account so do i still need to provide it
#[derive(Accounts)]
pub struct Initialize<'info> {
    pub from :Account<'info,TokenAccount>,
    #[account(init,payer=authority,token::mint=mint,token::authority=authority)]
    pub to   :Account<'info,TokenAccount>,
    pub mint: Account<'info,Mint>,
    pub authority:Signer<'info>,
    #[account("token_program.key == &token::ID")]
    pub token_program:AccountInfo<'info>,
    pub rent:Sysvar<'info,Rent>,
    pub system_program: Program<'info, System>,
}
Good morning everyone! I'm trying to invoke an instruction through CPI (program A calling program B), however the accounts that need to be sent to program B can NOT be included in the context for program A, since program B needs to be invoked a variable number of times with different PDAs each time. In other words, program A needs to derive PDAs for program B during runtime.

The problem arises when constructing the CPI context for B, which expects `AccountInfo`s, however with `Pubkey::find_program_address` I only get the public keys for the PDA, not the AccountInfo. How would I achieve this?
```rent.to_account_info()```?  what are you trying to do?
how can I fix ```use the path separator to refer to an item: `rent::to_account_info````? I can pass Rent as a sysvar to the accounts struct but is there an alternative?
Anyone else knows what this error is caused by?     ```RangeError [ERR_OUT_OF_RANGE]: The value of "offset" is out of range. It must be >= 0 and <= 351. Received 390``` This occurs when I try to fetch an account using its publickey from devnet
in spl token burn is the authority the account who's burning from or the authority of who made the token?
Can anyone help ?
Yeah basically either you do your own similar thing to discriminator bytes, or use different amounts of space, or whatever
That's complicated now that im looking back at it
In general in a non-anchor program you'd have to have some other way to distinguish the accounts (e.g. in the token program, mints and token accounts take up different amounts of space, so that lets the program keep them straight)
no i was just using that to explain that one program interacts with the other
You're not talking about the anchor puppet example?
XD glad my +1 helped
The problem is, I'm doing Cpi from Puppet Master. Puppet is not an anchor program. So Puppet Master can't do `Account<'info, A>`, right?
Anchor adds the bytes automatically whenever you use the `Account` type
If you say `foo: Account<'info, A>`, anchor will ensure that it really is an A account
Also, does anchor automatically add these discriminator bytes? Or solana?
ahhh interesting. So say I'm doing CPI from Puppet Master to Puppet. So Puppet Master never has to worry about this case, right? Because the underlying program should handle it
Yep, as <@!925167601590616174> said it will add +1 byte (😛), followed by the serialization for the A or the B
That's what the account discriminator bytes are for (the extra 8 bytes in space calculations)
Say Puppet has two types of accounts that are owned by itself (Account A and Account B). Both have identical fields. Puppet's instruction `foo` is meant to take Account A, but a user passes Account B, which is still owned by the program and has the same fields. **How will the program know to throw an Error?**
+1 ^
anyone know the size of an enum variant for account space purposes?
e.g. 
```
enum Type {
    A,
    B,
}
...
#[account]
pub struct S {
    pub t: Type,
```
Got it, that makes sense thx
done change the idl.json to idl.ts
```json
import { Idl } from '@project-serum/anchor';
 export const idl: Idl = {
...
idl.json generate on anchor
...
}
```
```IdlError: Type not found: {"name":"betType","type":{"defined":"BetType"}}```
```rust
#[derive(Debug, Clone, Copy, Eq, PartialEq, AnchorDeserialize, AnchorSerialize)]
pub enum BetType {
    TwoFold,
    TenFold,
}
```
I am getting Idlerror: Type not found; but it seems right to me?

https://github.com/gdoteof/solana-gamba/blob/master/programs/gamba/src/state/bet.rs#L12-L22
can you help me with that?
thanks!
So you would use `invoke` if you've already got your necessary signatures from the client, and `invoke_signed` if you need to add on any additional signatures for some of your program-derived addresses
`invoke` just uses `invoke_signed` under the hood, but doesn't try to sign for any additional program-derived addresses (it passes an empty slice for the seeds argument)
Like, is there a reason to use signed over the the regular?
Can someone plz please explain the difference between `invoke()` and `invoke_signed()` to me plz.
If you are new though I would suggest you start by looking though the tests map of the anchor library to see exmaples of how the code is supposed to look. download this repo and check the tests folder for examples
here the owner should be  of type Signer<'info> or be noted annotated with #[account(signer)]

After approving I got into a different error though:
```
Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account 
```
Ohhhh silly me!! Thank you!! So in this case (where I'm sending from my own wallet) it would be the same as the `from`. That prompted me to sign!! 🥳
The owner is not the token account, the owner should be the person signing the transaction and owns the "from" token account
I'm trying to learn Rust/Anchor and I'm currently trying to make a simple program that would allow me to send an SPL token between wallets through a website using phantom.

This is my very simple contract:

```
#[program]
pub mod my_program {
    use super::*;
    pub fn initialize(
        ctx: Context<Initialize>,
    ) -> ProgramResult {
        let cpi_accounts = Transfer {
            from: ctx.accounts.from.clone(),
            to: ctx.accounts.to.clone(),
            authority: ctx.accounts.owner.clone(),
        };
        let cpi_program = ctx.accounts.token_program.clone();
        let cpi_context = CpiContext::new(cpi_program, cpi_accounts);
        token::transfer(cpi_context, 1)?;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    from: AccountInfo<'info>,
    to: AccountInfo<'info>,
    owner: AccountInfo<'info>,
    token_program: AccountInfo<'info>,
}
```

I deployed it, and trying to call it on the front-end with this:

```
        await program.rpc.initialize({
          accounts: {
            from: provider.wallet.publicKey, //phantom provided wallet, and holder of token
            to: new PublicKey('redacted'), //recipient wallet
            owner: new PublicKey('redacted'), //token account
            tokenProgram: new PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'),
          }
        })
```

But this is resulting in this error on the console:

```
Error: Transaction fee payer required
```

Is this something missing on the contract or do I need to do something else on the front end to ask for the signature/payment?
i fixed problem 🙂
i checked tutorials but can't understand problem 😦
Hello guys! I have an error: Error: 3012: The program expected this account to be already initialized but can't understand which account 😦 I have this account: ```#[derive(Accounts)]
pub struct Stake<'info> {
    pub token_addr: Account<'info, Mint>, // token mint address (agte mint, nft mint)
    pub token_from: Account<'info, TokenAccount>, // from which user associated account we can transfer
    //the authority allowed to transfer from token_from
    #[account(init, payer = user, space = 64)]
    pub staking_info: Account<'info, StakeInfo>,
    #[account(mut)]
    pub staking_account: Account<'info, TokenAccount>, // when we send money
    #[account(mut)]
    pub user: Signer<'info>,  // user who will stake
    pub token_program: Program<'info, Token>,  //  address for token program for transfer
    pub system_program: Program<'info, System>,
}

#[account]
pub struct StakeInfo {
    pub authority: Pubkey,
    pub last_redeem_date: i64,
}``` and this test ```await program.rpc.stake(
            new anchor.BN(5_000), {
                accounts: {
                    tokenAddr: mint.publicKey,
                    tokenFrom: walletTokenAccount,

                    stakingInfo: stakingInfo.publicKey,
                    stakingAccount: stakingAccount.publicKey,

                    user: user.publicKey,

                    tokenProgram: TOKEN_PROGRAM_ID,
                    systemProgram: web3.SystemProgram.programId,
                },
                instructions: [
                    await program.account.stakeInfo.createInstruction(stakingInfo),
                ],
                signers: [user, stakingInfo]
            });```
gotcha I'll look into the zero copy right now.
you can also use zero copy deserialization to go around this issue, but haven't used it yet so can't give you an opinion
no not always. Only with large contextes. I like to either box everything in the struct or nothing. So if I have a large context that is starting to hit the limit, I just box everything in there.
always?
I Box everything I can
If I'm getting stack errors (probably do to passing in lots of accounts) which accounts should I be "Box"'ing to pool them off the heap???
The token accounts? The one I'm creating?
Is zero copy deserialization any more efficient in terms of compute unit usage? Suppose I have a large array in there.
16 seeds max
you can provide any number of seeds i think, or just one if you want
the bump is determined by the findProgramAddress algorithm, which is in the link i sent, but its something that's returned to you and that you need to store
you provide fixed seeds (in this case the string "open auction", the owner's public key, and the string of the auction title)
```
const [auctionAddress, bump] = await anchor.web3.PublicKey.findProgramAddress([Buffer.from("open auction"), ownerAddress.toBytes(), Buffer.from(auctionTitle.slice(0, 32))], program.programId)
```
Is the "seed" value set by the user or is it hardcoded as part of the program? 
Is it that the "seed" value is fixed, and the "bump" is what increments in case the previously hashed address is a valid address?
And what does it mean "collection of seeds"? Why would there be multiple seeds?
you can deterministically rederive the same address with the same seeds and bump, so you can get the address of a pda later as long as you know those values
bc a given collection of seeds may not result in a valid address right away so the bump gives us more tries in a sense
no associated private key*, and then the bump is just a value that starts at 255 and is hashed along with the provided seeds and is decremented until we get a valid address
https://docs.solana.com/developing/programming-model/calling-between-programs#hash-based-generated-program-addresses

my understanding is that the seeds are used to generate an address that doesn't lie on the ed25519 curve, so it's not a valid public key
Could anyone explain or have any references with examples to better understand "seeds" and "bump value"? 
I don't really understand what they mean other than they have something to do with generating PDAs that don't have private keys
check out the "Cancel Implementation" of the tutorial, it cancels the item on the to-do list and returns the reward back to the owner

https://dev.to/dimfeld/starting-with-solana-part-4-4j5k

```// Return the tokens to the item creator
    item.close(item_creator.to_account_info())?;

    let item_key = ctx.accounts.item.to_account_info().key;
    list.lines.retain(|key| key != item_key);

    Ok(())```


//////////////////////////////////////////////////////////////////////////////////////////

How do I get different onchain program's anchor data structs to call with CPI?
Can anyone help me with this one?
Yeah confusing one
Your intuition is right that the name doesn't make sense
Ok cool will go with that
Yeah
but should I just put in the user_token_account it will be burned from?
Oh, well, the name really is `to`, but you're right that it shouldn't be
hmm but I tried building the program using 'from' and I get this error
Yeah, that name is wrong!
Performing a burn function in rust..looking at the docs it says that a Burn context is as follows:

pub struct Burn<'info> {
    pub mint: AccountInfo<'info>,
    pub to: AccountInfo<'info>,
    pub authority: AccountInfo<'info>,
}

But should the second account no be 'from' ? As in the users token account that you will be burning tokens from?
is there a way for a program to accept an arbitrary number of accounts of the same type? 

For example, if I want my program to mint tokens to all of the associated token accounts passed in, but the caller can pass in any number of token accts.

or is it cleaner for the program to accept 1 account and then pass in multiple instructions in the same transaction?
and im not talking about array, but more complex lists that hold objects
have you checked out how lists are implemented?
How can one implement a FIFO data structure in anchor ?
will the init macro fail if the given PDA already has an initialized account?
Really good tutorial here which you could easily modify to make the transfer time based: https://hackmd.io/@ironaddicteddog/solana-anchor-escrow
Hi every one.
I want to lock my tokens in contract which i am doing but  then want to transfer back to user after 1 day. 

I am stuck with that how can i transfer tokens back to user...
I am using bumpseed but giving me error when i try to call from devnet
Yeah - PDAs can be a bit confusing at first.  A PDA can sign transactions inside of the program where the PDA was generated, and nowhere else.  A good intro here: https://pencilflip.medium.com/learning-solana-3-what-is-a-program-derived-address-732b06def7c1
how would i seed an account with a number?
```
#[derive(accounts)]
#[instruction(bump)]
pub struct Foo<'info> {
    #[account(
        init, 
        seeds = [bar.key().as_ref(), &baz.to_ne_bytes()],
        bump = bump,
        payer = authority, 
        space = Foo::LEN,
    )]
    pub authority: Signer<'info>,
    #[account(mut)]
    pub bar: Account<'info, BarAccount>,
    pub baz: u64,
    pub system_program: Program<'info, System>,
}
``` My attempt is something along these lines, where baz is a u64
<@732815411808174111> 
Thank you so much...
I'm reading solana docs. I understood that PDA has NO related private key, so it cannot be used when signing tramsaction. But, then how program can be signer of that account?
The picture shows the point where I've lost
Sure!
Can I ask a question about Program derived address here?
Getting ```ctx flows into ctx here``` error
I want to create a guess game where user will submit Sol to the program and will guess the random number generated by program between some range. If guessed double money will be transferred and not then will lose his stake. So here how to make the program pay the fees for transfer of token from program to user and how to generate random number?

```
#[allow(unaligned_references)]
use anchor_lang::prelude::*;
use std::convert::TryInto;
pub use switchboard_program::VrfAccount;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod dice_game {
    use super::*;

    pub fn get_random(ctx: Context<GetRandom>, params: Value) -> ProgramResult {
        let luck = &ctx.accounts.values;

        let v = VrfAccount::new(luck)?;
        params.dice1 = String::from_utf8(v.get_verified_randomness().clone().unwrap()).unwrap();
        // params.dice2 = v.get_verified_randomness().unwrap();
        // luck.dice2 = VrfAccount::new(luck)?.try_into()?;

        // let v1 = format!("{:?}", String::from_utf8(params.dice1.clone()).unwrap());
        // let v2 = format!("{:?}", &params.dice2);
        msg!("Values are: {:?}", params.dice1);
        
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 8 + 64 + 64)]
    pub values: AccountInfo<'info>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}


#[derive(Accounts)]
#[instruction(params: Value)]
pub struct GetRandom<'info> {
    #[account(mut)]
    pub values: AccountInfo<'info>,
}

// #[account]
#[derive(Clone, AnchorSerialize, AnchorDeserialize)]
pub struct Value {
    dice1: String,
    // dice2: u64,
}
```
Perfect, ill have a go with that, thank you man!
located in /target/idl
idl has everything
Amazing! And programId would have to be manually input to the script, by taking it from anchor deploy?
```js
import idl from './idl/idl.json'
import { useAnchorWallet, useConnection, useWallet } from '@solana/wallet-adapter-react';
  const opts = {
    preflightCommitment: "processed"
  }
  const { connection } = useConnection();
  const wallet = useAnchorWallet();
const provider = new Provider(
    connection, wallet, opts.preflightCommitment,
  );
  const program = new Program(idl, programId, provider)```
Yes, in that case you'll need to import the IDL etc...
programId would be   program.programId
i cant run the JS isolated and have those work
Seemed by the docs that only works when doing "anchor test", no?
anchor does this for you ``` anchor.setProvider(anchor.Provider.env());

  const program = anchor.workspace.Perps as Program<Perps>;```
?
and then run the tests with:
const programId = new anchor.web3.PublicKey("<YOUR-PROGRAM-ID>");
you'll have to save it (private key of the generated account)
Any way to just run the JS by itself, using the last deployed program address?
oh! Cool! Thank you! <@!208527206966755329>
```anchor test --skip-deploy```
anchor test redeploys every time, and takes too long for just minor tests
Whats a quick way to run JS tests on an already deployed anchor program?
add the *pc.rs* file as it is then follow the code in *lib.rs*
they have an example interacting pyth with anchor. Really easy https://github.com/project-serum/anchor/tree/master/tests/pyth
I'm not sure too
I have some custom data feed (some TVL value), that im trying to feed in, not sure if pyth supports custom data feeds?
I use pyth, it's easy to use and has a lot of data-feeds but it depends on your needs
I found some chainlink + solana, but not sure if anything changes with Anchor, (and also custom data-feeds, rather than the provided price-feeds)
Is there any good tutorial / github repo on how to use custom chainlink data feeds in anchor programs?
nope, didn't work <:strug:599601512762703902>
ah wait lemme try something quick
```
Error: Custom: Invalid blockhash
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }.
```

Anyone else had this error when trying to deploy to devnet? I was able to deploy the same program yesterday, deploying it with a different keypair/id today and it's just doing this <:THONKING:567714720870563840>
can we use the agnostic orderbook inside anchor ?
Plz can anyone help???
you mean `ctx.program_id`?
Hey y'all, how can a program call itself? I'd like to call an instruction multiple times from another instruction
I'm not sure If I can access the programId in the context
how do I check if an account is owned by the program ?
When i run **anchor test** without running validator then it passes but when i run with solana local validator then its gives me error address not found.
Also when i run from devnet give me same error i am trying to create escrow...
how would I take an external account as an input to the function of program?

```pub fn test(
        ctx: Context<Test>,  
        amount: i64,
        buyer: ??
) -> ProgramResult {
        let key = buyer.pubkey?```
```        check_account_owner(a.user, program_id, DexError::InvalidStateAccountOwner)?;
```
smth wrong with my bump?
can someone please explain this error to me?
```
anchorpy.error.ProgramError: 2006: A seeds constraint was violated```
I think if you have anchor installed, you need to set the path in ~/.zshrc on a mac and then once the path is set, don't forget to run "source ~/.zshrc"

https://code2care.org/pages/permanently-set-path-variable-in-mac-zsh-shell
Hey guys,

I'm trying to deploy a program on devnet with solana sdk v1.9.4, anchor version v0.20.1 but I'm getting this error during the deployment:

Error: Pubsub error: UnexpectedMessageError("{\"error\": Object({\"code\": Number(-32601), \"message\": String(\"Method not found\")}), \"id\": Number(1), \"jsonrpc\": String(\"2.0\")}")

Anyone faced the same issue and found a workaround/solution? Appreciate the help, thanks 🙏
are you using macbook with an M1 chip?
Hello. every single time when I open up terminal, ```command not found: anchor```. how should I fix this problem? I installed using cargo and Mac OS.
hey everyone i want to know that is it possible to make a token contract using anchor framework where i can have some customization like of deducting a certain amount of fee on every transaction that happens on that token contract and send that fee to a liquidity pool and to the owner of that contract is this thing possible using the anchor framework ?
```const { item } = await addItem({ list, user: buyer, name: 'Coffee',});``` 
what does it mean to have the the brackets around "{ item }"?
if I don't use the brackets, then the test produces an error that says "Error: Invalid arguments: item not provided."
it does cost Sol everytime.
It seems like it costs sol every time. Am I doing something wrong?
yes, you have to deploy it everytime.
Hey quick question, whenever you update your rust code, in order to see the changes on my front-end side, do I need to deploy it everytime? Or is anchor build just sufficient?
yeah, basically.  client.js would be the literal client; which is talking to your program (which is the server, in the client-server analogy).

programs can call each other from on chain; but if _you_ (not being an on-chain program) or your users want to invoke functions, you would have to create a client, which in your case is client.js
anybody knows how to put a program to the isntructions ?
i think the expression means a program
im trying to replicate a web, but its minified 😦
boom baby!

bump
is it a local cluster issue?

so.....its throwing an error at the initialize. So how do i get this RPC to initiate. The code seems correct. What am I missing?
Hard to say, what are you trying to do? That would be a little instruction, but it's kind of weird since it doesn't pass any accounts 🤔

anyone knows what could be this minified expression ?
hello!
Yeah, best to just search the source code 😛
ty i didn't see anything on the anchor docs site about it
But you're probably doing a `Account<'info, Something>` and not passing an actual Something account.
Easiest way to learn about this stuff is to have a checkout of the anchor search and just ctrl-f through it
That means you're passing in a (probably empty) account that doesn't have any descriminator bytes (the first 8 bytes of an account managed by anchor)
can someone explain this error more in detail? i haven't found any info when searching discords AccountDiscriminatorNotFound: 3001,
will have to problem solve this later I guess. Dinner time LOL
rip my life
Ok, now you have a different bug 😉

You wrote `ANCHOR WALLET` with a space, not an underscore
i do? where?
You have a typo
Nope, `ANCHOR_WALLET=... node client.js`

i didnt use a local cluster
?>
can I set this local to the devnet cluster
anchor.setProvider(anchor.Provider.local());
let me try something
maybe im in the wrong path
is it a node issue?

Do that all in one line, `ANCHOR_WALLET=... node client.js`
should it run when I use no client.js
so i understand the logic, but when i run node client.js i get stuck.
is that where client.js comes in?
gotcha. I figured out how to get the program on the devnet. Question: what is the client.js? I cant ge tmy head around it. My logic on how this works is we deploy a program to the blockchain, this program holds instructions for how other accounts cna interact with eachother and their data in a trustless way, but what I dont get is what we do after that. Do we have to build an interface to interact with the program we wrote?
oh i see
in unix you can also do `export ANCHOR_WALLET=<YOUR-KEYPAIR-PATH>`  and then run `node client.js`
so doing `ABC=123 xyz`  declares an environment variable before running the executable `xyz` so that xyz can see it.  In case of NodeJS, these variable are available in process.env[] and that is what Anchor uses to look for the wallet
yes
its a variable outside the program
and which OS are you on
do you know what an OS environment variable is?
no
do you know what the syntax `ABC=123 xyz`  does/mean?
im trying to get to the end so I can say hey, look it works LOL
then it says dont use that client.js file that is provided for testing
lol
how do I move to this 
ANCHOR_WALLET=<YOUR-KEYPAIR-PATH> node client.js  

if it doesnt say how to use the client.js
```
(async ()=>{
  ...place the code here
})();
```
https://project-serum.github.io/anchor/tutorials/tutorial-0.html#generating-a-client
what is annoying is that there is no client.js help in these docs
you'll get there man just keep going!
may the force be with you 🙂
ya I am learning as I go....only 2 months in
Yeh you need to go learn more javascript.
The issue is that your not running await inside an async function (it only works in there)

But if you're not used to js you're going to run into issue after issue after issue once you fix that
Gotcha. Thanks I'll look into it.
I feel like the anchor-cli should just be able to use an rpc link like everything else
my issue is running the client.js file
I was going to say that I don't know how to deploy via RPC directly, but this project has a script to use deploy in nodejs that was helpful to me when I was starting...  https://github.com/DougAnderson444/solblog/blob/master/deploy.js
ohhh haha gotcha I was so confused for a bit <:bagsLUL:500156060439543819>
I was messaging <@!288735346122948611> but then wanted to reply to you but got distracted 🙂
I know how to set rpc's for the js side
sorry typo 🙂
Are you talking to me or do you mean <@!288735346122948611> ?
I need to set an rpc for the anchor-cli

aka the anchor deploy command
the "local" provider in anchor that you instantiate with `anchor.Provider.local()` looks for the environment variable that contains a path to the `id.json` file.
?
interesting
you can also mod the program and do `process.env.ANCHOR_WALLET = "/Users/Bryson/.config/solana/id.json";`
ok
https://project-serum.github.io/anchor/tutorials/tutorial-0.html#generating-a-client
im using anchor, but my issue is after getting the program on DevNet cluster, its telling me on anchor docs to do this " ANCHOR_WALLET=/Users/Bryson/.config/solana/id.json node client.js"
what exactly have you been trying to follow, native solana program implementation or using anchor?
im stuck at the client.js part
i have gotten the program ID
ya ive been trying to follow along lol
https://project-serum.github.io/anchor/getting-started/introduction.html
u r looking at anchor
anyone have ideas what this is?
How do I use an rpc for deploys?
The networks is really congested lately and:

Doing --provider.cluster <quicknode rpc here>
Always errors out with json 2.0 not returned etc

It just takes all my sol causing me to have to manually run solana program close
what does the `#[index]` attribute do for events?
it's driving me crazy
can anyone explain the error please
Transaction simulation failed: Error processing Instruction 1: custom program error: 0x1000761 
    Program 11111111111111111111111111111111 invoke [1]
    Program 11111111111111111111111111111111 success
    Program 9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin invoke [1]
    Program 9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin consumed 4652 of 200000 compute units
    Program 9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin failed: custom program error: 0x1000761
Error failed to send transaction: Transaction simulation failed: Error processing Instruction 1: custom program error: 0x1000761Transaction simulation failed: Error processing Instruction 1: custom program error: 0x1000761 
    Program 11111111111111111111111111111111 invoke [1]
    Program 11111111111111111111111111111111 success
    Program 9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin invoke [1]
    Program 9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin consumed 4652 of 200000 compute units
    Program 9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin failed: custom program error: 0x1000761
Error failed to send transaction: Transaction simulation failed: Error processing Instruction 1: custom program error: 0x1000761
Coming back to program keyfiles.  I'd like to understand from the security standpoint... if these files are exposed, what does that entail?
now once I have the ID generated, how do I generate the client.js
gotcha. thats great to know!

i get turned around too much
need to figure out the logic and keep learning rust more in depth
cant wait until i know this stuff more fluidly
And every 100kb costs 1.4 sol (based on the standard way of deploying)
deploy success
That will be at least several hundred kbs
got it guys and galls
BINGO!
The cost is for uploading your program's code, which requires rent-exempting the `.so` file
i added more into my account. lets see
Yep 😬
im just on dev...
my bad. thanks for the link. exactly what I was looking for.
are deploying programs on solana mainnet this expensive?
ack
https://docs.solana.com/developing/runtime-facilities/sysvars#clock
What do you mean?
u can?  but how would multiple nodes achieve consensus on this...  or am I missing something...
declare_id mismatch wouldn't cause that error fwiw
it has been two things for us as we started working (especially among multiple ppl), the declare_id() wouldn't match local `/target/deploy/*-keyfile.json` files or balance.
You can use `Clock::get()?.unix_timestamp`?
weird ok, let me work this out
I would airdrop yourself like 10
How much sol do you have? That error usually means you're too low
You can run a local validator though which lets you do whatever
now i get this

Devnet is “real” in that everyone is using the same devnet so if you’re deploying to an address embedded in a tutorial you’re gonna run up against it
solana program deploy /Users/Bryson/anchor/tests/escrow/target/deploy/escrow.so
Solana-keygen generates new keys.
new key generated
ok so i rebuilt it
can I delete and rebuild?
oh shoot so that key isnt the keypair i generated?
Solana generates -keyfile.json files in target/  make sure that it’s base58 encoded pubkey matches your declare_id
does connecting the address to devnet make the address unusable? or is it only when you connect it to the phantom
i created a new key and connected it then added 3 SOL

im trying to figure out the steps i need to do
so im a bit confused here. the declare id! is a hardwired address
How can I track/approximate time in a program?  As in I guess using slots to approximate a duration.
oh very cool (and insane) thanks
https://discord.com/channels/889577356681945098/889584618372734977/915190505002921994
I'll find a link
Heh, this is a funny one, has come up a few times in the discord
is there something im not understanding about solana here? cant think of a reason why the first case doesnt work and the second does
ran into some interesting behavior and wondering what's causing it:
i have a pda owned by my program with both sol and spl tokens in it
i have a function that takes in an accountinfo ("recipient")
the function does three things: transfer sol to the recipient, create the ATA for the recipient, and transfer spl tokens to the ATA

when the transfer sol happens before the other two, i get an error saying that  `sum of account balances before and after instruction do not match`

but when i just move it after the create ATA and transfer spl calls, everything works
🙂
i will check both ty
make sure your declare_id() matches the program id you are deploying to
that could be it
im probably dropping into old wallet
let me make sure the new config is connected
wait let me see
Airdrop yourself some more
lol
i put 3 in
Probably don't have enough sol in your wallet
whats going on here?
i see instructions but i dont know the logic
ideas?
like 2 months in haha. Appreciate it!
All good 😛
yup
im new dont judge me
Yeah, wallets live at accounts too!
derp
there it is
oh shit
You can't use it for both a wallet *and* your program id
is it because im assigning it to a wallet?
It's pretty likely that you're making a mistake with the key you're using (it's ~impossible to generate a fresh keypair and have an account live there—there's zero chance that's what's happening here)
can one not deploy on devnet?
and why are they duplicating keys?
lol
i just made it
I mean that makes sense, but how do i get a key no one on devnet has used?
maybe im missing something
isnt the point to practice deploying it to a devnet address?
how do i get a fresh key? I just made it lol
is there any opensource staking program that I can reference?
if you are trying to deploy to devnet, then yes you will need a new account because someone else will have already used that same key
Sounds like there's already something at that address. Are you sure you're using the right cluster?
I was going to say that if you really wanted to, you could just determine a dynamic length based on the runtime length of that string argument, using `#[instruction(the_string: String, ...)]` etc. Can then do `space = 8 + ... + the_string.len()` or whatever
and not upgradeable...
its a test .... but wont deploy saying its in use....
why i cant deploy this program to a new address I made?
any ideas?

do i need to somehow deploy it to a new address that hasnt been activated yet?
now saying not upgradeable
i thought i was supposed to link my keypair to wallet
gotcha. so i got to this part...but it says my address is in use
either one should work; but the npm command will typically go a bit smoother


//////////////////////////////////////////////////////////////////////////////////////////

Im trying to pass in the `clock` and `token` program Accountinfos into `invoke_signed`, but im getting the following error:

```lifetime mismatch

...but data from `clock` flows into `token_acc` here```
I am going through it now
`console.log("Your transaction signature", tx);` wasn't printed
I am getting this now
solana-install update
alright should i install everything from start or just `sh -c "$(curl -sSfL https://release.solana.com/v1.9.5/install)"`
Your solana install is too old I think (1.8.0)

heyy guys I am facing error every time I run anchor test

yep. seo optimized blogs suck.
What is the native token mint authority?
That entire tutorial is excellent - but you'll find specifically what you are looking for about halfway down the page.
Pretty good explanation of the difference between a keypair/solana wallet and an "anchor wallet" here: https://lorisleiva.com/create-a-solana-dapp-from-scratch/integrating-with-solana-wallets
I guess what I really want to do is jack into the info phantom has when it simulates a tx
kind of like phantom wallet before I click approve
Is there a way to simulate a function call in anchor?
ex:
```
await program.rpc.simulate.updateConfig()
```
I think i found my response. The declare_id should match with the program id in the local validator.
Here the `authority` is the payer for initializing an account, so it has to be mut (paying requires exclusive access to the authority account).
In general marking as mut is independent of marking something as a signer (sometimes you only need one).
I am having the same issue when i test example code ido_pool from anchor test on local-validator.
You wouldn't call that function (that's the entrypoint). You'd construct a mango instruction and do the CPI with `invoke/invoke_signed` (nothing anchor specific about doing a CPI)
Hello,

I have created an anchor project, i test it using ` anchor test ` it works fine. But when i test it by starting solana-local-validator and then `anchor test --skip-local-validator` i get the following error:
` Error: 3007: The given account is not owned by the executing program `
any ideas how to solve it?

Thanks in advance.
e.g. how would i call this function in another program: ```pub fn process(program_id: &Pubkey, accounts: &[AccountInfo], data: &[u8]) -> ProgramResult```
does anyone have some info about this? not sure how to do cpi calls to non-anchor programs
I think so but look into spl/token to be sure
is this all thats needed to implement a `Program` type? (assuming the pubkey is of a valid program onchain)
my other question is why do we add an account[(mut)] constraint on the signer? is this because we want the signing account to hold ownership of the initialized account?
solved! wasn't adding the space required to initialize the account
hi, struggling to resolve this error. i think it has somehting to do with Signer, but i'm really not sure where to start to fix this error
Thanks buddy.
Check out the "Cancelling an Item" portion of the tutorial
https://dev.to/dimfeld/starting-with-solana-part-4-4j5k

``` // Return the tokens to the item creator
    item.close(item_creator.to_account_info())?;```
```Here we use item.close to tell Anchor/Solana to delete the account and also transfer any balance on it to the item_creator account.```

something like this maybe?
Hi Everyone 
How can i close account after complete which i created with init..
Anyone else having issues with `anchor migrate`? https://github.com/project-serum/anchor/issues/1295
```
async function createUser(airdropBalance) {
  airdropBalance = airdropBalance ?? 10 * LAMPORTS_PER_SOL;
  let user = anchor.web3.Keypair.generate();
  let sig = await provider.connection.requestAirdrop(
    user.publicKey, airdropBalance);
  await provider.connection.confirmTransaction(sig);

  let wallet = new anchor.Wallet(user);
  let userProvider = new anchor.Provider(provider.connection,
    wallet, provider.opts);

  return {
    key: user,
    wallet,
    provider: userProvider,
  };
}
```

Could someone explain the difference between the user and wallet? And what exactly is does provider mean? And what does "provider.opts" do
ohk space was less
why is this happening
code: 3004,
  msg: 'Failed to serialize the account'
}
I think switchboard.xyz is there but not sure
cant use chainlink or its solana equivalent?
Can anyone help me with onchain random number generation on solana anchor?
logs
```'Program log: entrypoint [40]',```
```rust
 pub fn new_split(
        ctx: Context<NewSplitContext>,
        split_perc: Vec<u64>,
        split_keys: Vec<Pubkey>,
        split_account_bump: u8,
    ) -> ProgramResult {
        msg!("entrypoint {:?}", split_perc);``` librs function
```rust
#[derive(Accounts)]
#[instruction(split_perc:Vec<u64>,split_keys:Vec<Pubkey>,split_account_bump: u8)]
pub struct NewSplitContext<'info> {
    #[account(mut, has_one=authority)]
    pub base_account: Account<'info, BaseAccount>,
    #[account(
        init,
        seeds = [
            b"solsplit_account28",
            authority.key().as_ref(),
            &[base_account.splits_nonce as u8].as_ref()
        ],
        bump = split_account_bump,
        payer = authority
    )]
    pub split_account: Account<'info, SplitAccount>,
    #[account(mut)]
    pub authority: Signer<'info>,
    pub system_program: Program<'info, System>,
}``` function struct
```js
program.rpc.newSplit(
      [(new anchor.BN(60), new anchor.BN(40))],
      [provider.wallet.publicKey, atwo.publicKey],
      splitAccountBump,

      {
        accounts: {
          baseAccount: baseAccount,
          splitAccount: splitAccount,
          authority: provider.wallet.publicKey,
          systemProgram: SystemProgram.programId,
          // authority: provider.wallet.publicKey
        },
        // signers: [atwo],
      }
    );``` client
but when i send [60,40] i only get [40] in function entrypoint
ok so i have a fnction in which im sending a vector of u64
Any anchor nft minting repos that aren't candymachine floating around to look at?
Ok thanks for that!
Exactly what I am looking for, let me read through the article
https://dev.to/dimfeld/starting-with-solana-part-4-4j5k

this tutorial transfers SOL to a PDA and then released or returns the fund based on some condition, is this an idea of what you are looking for?
and then You can also view the validator logging by opening a separate window and running solana logs
in your tests
console.log('Count 1: ', account.count.toString())
i tried using msg but where does that appear
im running the program thru my client but i want to debug the program and println doesnt work
how do i log variables in my program
the system program has an instruction for sending sol, so you can just use that client side without writing any on chain stuff. however, since your wallet is a signer for the transaction, your on chain program also has the authority to send the sol from your wallet
If you find it please tag me too
I am gonna crash - hoping someone who has been in this space longer than my solid month can provide some guidance
agreed and I have found examples arounf Spl_tokens but not for native SOL
I have been fighting with some basics for a bit - and I can't see to get a good answer so far. The samples are either overly complex or incrementing counters...
if I am using a PDA, which will be like the vault of the game
I don't understand how the SOL transfer will work
I am also looking for the exact same thing +1
I am comparing some documentation from the solana cookbook about accounts, programs and transferring SOLs and trying to make sense of the Anchor representation. The typical anchor example has the Initialize derive. Using this example:

```rust
#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 8 + 8)]
    pub my_account: Account<'info, MyAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```
1. I want to interact with this using a Phantom wallet. So in this case, I can generate a `pubkey` which will be the account key for the program and the user will be the wallet's pubkey. Am I on the right track so far?
2. Now I want to transfer SOL from the wallet to this program
Looking to do something simple - from a Phantom wallet, transfer SOL to the program that the wallet user created. The idea being:
    1. Click a button to transfer `x` SOL
    2. The wallet opens and let the user authorize the action
    3. Generate a pubkey that the program will own (program_key)
    4. Use the IDL to call the initialize function on the program passing in the `program_key`, `wallet_key`, `SOL_amount`
    
```rust
#[derive(Accounts)]
pub struct Create<'info> {
    #[account(init, payer=user_authority_account_key, space= 16 + 16)]
    pub program_owned_account_key: Account<'info, ProgramOwnedAccount>,
    #[account(mut)]
    pub user_authority_account_key: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[account]
pub struct ProgramOwnedAccount {
    pub amount: u64,
    pub program_owned_account_key: Pubkey,
    pub user_authority_account_key: Pubkey
}
```
* Is this account setup sufficient for what I need to do?
* Will I be able to do the actual transfer. The docs says a transfer can only be made from an account that the program owns. From my understanding, the program doesn't own the wallet so how can the program move SOL from the wallet to itself?
i've listed their git repo as a dependency in the cargo.toml, and got all the right data, just not sure how to make the call
hey, i'm trying to do cpi calls to mango markets, are there any examples i can look at where cpi calls are done to non-anchor programs?
and also share the tests
this  is a bit out of context
Can you explain what your program is trying to do
Here is the account ```#[derive(Accounts)]
#[instruction(vault_bump: u8)]
pub struct InitVault<'info> {
    #[account(mut)]
    pub withdraw_authority: Signer<'info>,
    #[account(init, seeds=[b"vault"], bump=vault_bump, payer=withdraw_authority, space=200)]
    pub vault_pda: Account<'info, VaultPDA>,
    pub system_program: Program<'info, System>,
}```
```let program_id = "DiR3zknTTGDDncfLDgpmN75y3L2XMzyEtuM4Tpt16HMt"
        .parse::<Pubkey>()
        .unwrap();
    let program = client.program(program_id);
    let (vault_pda, vault_bump) = Pubkey::find_program_address(&[b"vault"], &program.id());

    let res = program
        .request()
        .accounts(accounts::InitVault {
            withdraw_authority: init_authority_pubkey,
            vault_pda,
            system_program: system_program::ID,
        })
        .args(instruction::InitVault {
            _vault_bump: vault_bump,
        })
        .send();```
Here is the interesting part of the code
Can someone help?
0xbbf, AccountOwnedByWrongProgram on tests that used to pass
I am running an anchor client and am getting this error
I've only done work with spl tokens sorry.
Honestly @me if someone links you i'd be interested as well
Do you know of any example I can look at for the following scenario? the user interacts with the program and deposits some SOL, and at the end of the game I return whatever they win and take some fee
Thank you turns out I was missing a signer
here is one <@!150033239493312512> https://github.com/cqfd/anchor-token-studies/blob/8c203ec85487c79dc1088c2fdeda1039235bec4f/programs/token-studies/src/lib.rs#L57
This is exactly what I was looking for
if I'm trying to have a program transfer funds, how do I test if the transfer went through?
```
        invoke(
            &transfer(
                user.to_account_info().key,
                owner.to_account_info().key,
                amount,
            ),
            &[
                user.to_account_info(),
                owner.to_account_info(),
                ctx.accounts.system_program.to_account_info(),
            ],
        )?;
```
what would I put on the test side to check?
or is the a way to put checks in the program?

I tried console.log the public keys for user and owner, but it looks like the amounts in the account didn't change
Any examples of token burning?
I can't seem to get the signers right.
or even better, just let the rpc commands take real enums
I finally figured out through searching this chat that the way to enums into typescript is by doing `{ variantName: {} }`  is anyone working on (or does something exist I am missing) so that one could so something like `MyEnum.VariantName.to_anchor_obj()` or something?
yes u can use `#[account(<constraints>)]` on top of each account
I guess I was wrong and they dont utilize `anchor` validation.
To do so I will need `attributes` like that: `#[account(init, payer = <target_account>, space = <num_bytes>)]`
Am I right?
https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html
so you always have to use it for mutable accounts
anchor checks the `mut` constraint when it creates the program interface description
Is there any reason to use double validation `anchor` + `viper`?

Rechecked QuarryProtocol, and looks like they utilize it, was it made for purpose?
```#[derive(Accounts)]
pub struct SetRole<'info> {
    /// The [Operator] of the [Rewarder].
    #[account(mut)]
    pub operator: Account<'info, Operator>,
    /// The [Operator::admin].
    pub admin: Signer<'info>,
    /// The account to give the role to.
    pub delegate: UncheckedAccount<'info>,
}```
+
```impl<'info> Validate<'info> for SetRole<'info> {
    fn validate(&self) -> ProgramResult {
        assert_keys_eq!(self.operator.admin, self.admin, Unauthorized);
        Ok(())
    }
}```
Yeah, Im dancing with documentation now, and still somethings I have to reask personally, otherwise its not always clear 🙂
Thx
yes, you can read all about it in the book
So I do validations in instructions under that line `#[derive(Accounts)]` right?
yes you dont have to use vipers. vipers has better error msgs currently but anchor's error msgs will soon improve as well
Do I understand right, that I can do it with anchor instead?
What are the options?
it's a different way of checking accounts using the vipers crate
I saw on that github repo they are using `account_validators.rs`
Is it typical solana implementation?
Or there is another way to do such checks?
They use anchor, but still I see those validations
https://github.com/QuarryProtocol/quarry/blob/master/programs/quarry-operator/src/account_validators.rs
thanks for reporting! thats a mistake in the book
https://book.anchor-lang.com/chapter_3/the_program_module.html
Looks like a typo
Share link please
in chapter 3.1.3 of the anchor book, why is it "init_data" instead of "data" ? 
``` 
#[program]
mod hello_anchor {
    use super::*;
    pub fn set_data(ctx: Context<SetData>, data: Data) -> ProgramResult {
        ctx.accounts.my_account.data = init_data.data;
        ctx.accounts.my_account.age = init_data.age;
        Ok(())
    }
}

#[account]
#[derive(Default)]
pub struct MyAccount {
    pub data: u64,
    pub age: u8
}

#[derive(AnchorSerialize, AnchorDeserialize, Eq, PartialEq, Clone, Copy, Debug)]
pub struct Data {
    pub data: u64,
    pub age: u8
}```
Ah, so if github repo is available, I just take instructions from there, right?
Whether that's the easy way since they published a crate/github repo, or the hard way (I don't know, looking at how their js code does it, etc.)
You just have to figure out, somehow, how to send instructions of the right form
Your code is 100s of kbs, so 100s of txs
Ah okay! Didn't know that
No, but this is why when you deploy your code it does a million transactions
Thanks a lot!
How do we build yield agregators then?
Thx for advice 😄
Is there any example?
Does it mean that maximum size of smart contract cant exceed 1232?
And if I will need it to be bigger I will have to split it?
Nice projects will publish helper crates
In general it will be hard lol
<@!134416332509675520> 
We have example of interaction with another contract:
```#[program]
mod puppet_master {
    use super::*;
    pub fn pull_strings(ctx: Context<PullStrings>, data: u64) -> ProgramResult {
        let cpi_program = ctx.accounts.puppet_program.to_account_info();
        let cpi_accounts = SetData {
            puppet: ctx.accounts.puppet.to_account_info(),
        };
        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
        puppet::cpi::set_data(cpi_ctx, data)
    }
}```
But how do I interact with conract that I didnt deploy, and the code of which I dont have in my project?
So I can use structures like `puppet::cpi::set_data()` ?
Even just sending the data to your contract won't really work, because each individual solana tx can only be 1232 bytes 😛
we better quit offtopic here 😄
Ok, good example is NFTs, right
Like ERC 721, check it 😉
Its a token with metadata\traits and contains values, lets say address for a picture
So at the dry end you have NFT (let it be an avatar picture) stored on chain, and you store on chain name, some other traits, and adress for a picture, and picture by it self stored for example on https://ipfs.io
This is where I still get confused. On what to do on-chain vs what to do on a regular server and then send it to the smart contract.
Sound better, cause you probably dont want to execute difficult calculations on chain
Every operation costs something
You want to use chain as ledger book
But maybe I can do that on the client-side and then send that data to the contract 🤔
Just wanted to read the data from an image inside of a contract.
Ah 😄 ok
Cause I wanted to say that is not super smart to store images on chain 🙂
Yeah, I am not sure that it can be used hehe. Just wanted to give it a try. Not sure how to check what is and is not allowed inside a contract
<@!134416332509675520> and thank you for all the answers, helps a lot 🙂
are you sure that you need `image` crate to be used inside of smart contract?
it could be
Maybe the dependency is too big? and cannot be used?
```
   Compiling crossbeam-epoch v0.9.6
Error: Function _ZN69_$LT$alloc..boxed..Box$LT$T$GT$$u20$as$u20$core..default..Default$GT$7default17h4a302a454c60900bE Stack offset of -10464 exceeded max offset of -4096 by 6368 bytes, please minimize large stack variables
```
so `#[derive(Accounts)]` is some kind of rules/restrictions that would be passed into function as an `ctx`?
I have this now 
```
[dependencies]
anchor-lang = "0.20.1"
image = "0.23.14"
```
I do not
Do you know text error to recongnize unsupported crates?
Do you know where I could check what crates work?
Okay I will try this!
Ah, some crates won't work on solana, maybe that's an issue?
You will have to provide path for dependencie like `anchor-lang = { path = "../../../../../lang" }`
or you can do it like that `anchor-lang = "0.20.1"` if that crate is available on https://crates.io/
And when I do  `anchor build` I get `error: could not compile scoped_threadpool`
What goes wrong?
Yeah, I have it there. Trying to add `image = "0.23.14"`
So not the top level one
In the `Cargo.toml` file *inside* the subdirectory with your program in it
That is what I thought but I am getting an error. Maybe the dependency is not supported?
No, that's how you specify a whole bunch of accounts that need to get passed to some instruction
Would be structure described under `#[derive(Accounts)]` be an `account type` aswell?
Yeah
Yeah, now got it.
However its not tottaly clear what is an `account type`?
Any structure described in rust under `[account]`?
I see it in `program.idl.types['MyType']` but not sure how to make that a normal type
how do I get the custom types defined in the IDL into typescript?  I have an emum defined but i think I must be doing something wrong
using `.toml` file
How can you add dependencies to an anchor program?
If you changed that struct to `MyAccountType` you'd do `puppet.account.myAccountType.fetch`, etc.
It corresponds to the `pub struct Data` part in the rust code
Yeah, confusing name :/
Ok, then it means that in line `puppet.account.data.fetch(newPuppetAccount.publicKey)`
`data` is an account type?
You can actually check this by opening up the generated idl file in `target/idl`
The latter, there will be two signers
Got it
Does it mean that that specific transaction would signed by `counter` only?
Or there would be 2 signers `counter` and `provider.wallet.publicKey`?
You're just adding on the keypair (in particular, the secret key part) to sign the tx from the client
For that specific tx
So we are promoting newly created account into signer for future interactions, right?
So it does the deserialization part for you (otherwise it would be raw bytes if you did `program.provider.connection.getAccountInfo(theAddress)`
`program.account.accountType.fetch` goes and grabs the account from the chain and parses its data assuming it's of type `AccountType` in rust
Yes its a keypair
But why do we need to interact with `account.data`?
If at the dry end we just get `puppetAccount` (the actual account data structure) and inside of that structure we have `data`
Looks like I dont understand what fetch really does here
`signers` is a list of *extra* signers, since the provider.wallet automatically signs so it can pay the tx fees
You've already deployed the contract at this point (that's why you're able to invoke it)
So `signers` is the list of signers of current transaction, right?
But we are the ones who deploy contract/programm, why don't we sign?
newPuppetAccount looks like it's a keypair, not the actual account data structure—that's what you get back when you fetch it.
The `counter` has to sign here because we're creating an account there (in general when you create an account in solana, its address has to sign)
I can't remember if it's already deployed yet, but you can/will soon be able to reallocate additional space (up to 10kb) to an account. But nothing will happen automatically, you'll have to remember to do it yourself!
Any oracle examples from anchor?
Or examples of someone getting NFT attributes from a rust program on Solana?
mfw when it's been using it this whole time I swear
I don't think it does but I also could be wrong lmao.
I have my rpc set in there already.
Doesn’t Anchor cli just use the current Solana config? Maybe I’m wrong - but i would think Solana config set —url [your rpc]
How do I use an RPC Node when running anchor deploy from the cli
Also would be glad to get explanations about test on js:
```puppetAccount = await puppet.account.data.fetch(newPuppetAccount.publicKey);
assert.ok(puppetAccount.data.eq(new anchor.BN(111)));```
Why do we need that line `await puppet.account.data.fetch(newPuppetAccount.publicKey)` ?
Why don't we just use `newPuppetAccount`?
Breaking my head trying to understand what is happening here.
Can someone explain next construction?
```accounts: {
        counter: counter.publicKey,
        user: provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      },
      signers: [counter],```
Why do we set `counter` and `signers` with the values from same source (account)?
Ok thanks for that. And so to increase at a later date I just rebuild and deploy again with a larger space variable? Or as the account will already be initiatilised how do I update the space ?
You can start with a shorter cap to save, and increase it as that list grows, if it makes sense for your use case
1024 pubkey strings is 1024 * 32 bytes. So you need to allocate that for the vec space.
I was putting in a pretty high number when deploying on devnet, but it is pretty expensive deploying to mainnet so seeing if I can make it more efficient
If I am going to create a struct to store some data on-chain as so :

#[account]
#[derive(Default)]
pub struct BaseAccount {
    pub mint_list: Vec<String>,
    pub bump: u8,
    pub nft_count: u8,   
}

Whereby mint list will store a Vector of a maximum of 1024 pubkey strings, how much space should I allocate to this account when I initialise it?
Basically I want to be able to write a function that is like `public async do_something(mything: MyType) -> Promise<..> {..}` and have MyType be type checked across both rust and ts
i have generated an IDL with a custom enum in it; how do i import that enum into typescript?  I tried "redefining" it the same way; but then it seems like it doesn't know how to encode it.

the closest thing i see is `program.idl.types['MyType']`
thanks a lot! 🙂
got it, i'll prob just split it up into two functions then
Mm, you have to be somewhat careful about it—I don't personally find it super confusing, but it leads to a lot of questions here.
is it deprecated tho? or ok to use?
There's `init_if_needed`
I think I've seen something like this, but I think it was deprecated
is there an account to initialize an account if it doesn't exist, and otherwise not fail?
specifically, i'll be making CPI calls to solend (spl-token-lending). curious if anyones done it before and if they have any insight for me
im going to need to do this later today. is there anything to keep in mind that is non obvious?


//////////////////////////////////////////////////////////////////////////////////////////

the multi-account approach seems potentially obnoxious because you have to pass all of them into the invocations; or know which are going to be read
ohh.. nm i wasn't quite groking what David what saying.  My example works if your data can fit in a single account; but I hadn't considered that multi account approach.  that's pretty interesting
Whether or not it is a PDA isn't really relevant.  For a FIFO or any variable length data; you can use a fixed length buffer.  https://github.com/gdoteof/solana-gamba/blob/master/programs/gamba/src/state/epoch.rs#L16

Your application logic needs to ensure you don't let more stuff get written to the buffer than space you've allocated for it
so you can have the datastructure here, in the list you can e.g. track state with a "head" and "tail" variable, and append to the tail, and pop from the head (or vice versa)
i mean a FIFO is a more specific version of a list, right?
It does makes sense to me but how can I implement a queue (fifo) using this ? A single PDA account which keeps track of head and n PDAs accounts which contains the main properties ?
if you know the size, just use an array, much easier haha
if it's something like a vector (i.e. length is not know), often ppl do this:
``` 
#[account]
pub struct List {
    pub head: u32,
}
``` 
which keeps track of the length of the list and then each element has it's own account
```
#[account]
pub struct ListElement {
    pub property1: Pubkey,
    pub property2: Pubkey,
    ...
}
``` 


then you would create a PDA in such a way to include this head, for example like this:
```
const [listElementAddres, listElementBump] = await PublicKey.findProgramAddress(
[SOME_GENERIC_SEED, listPosition],
    programId
) 
```

does that make sense?
allright, thanks for looking into it anyway! If I find the problem I will post it here
only guess is that your local and deployed frontend are not the same. other than that, idk myself
No I haven't do you have any repo link that I should look at ?
local is also targetting devnet
when you say local, are you saying that it works fine on localnet or is your local frontend version also targeting devnet?
oke... can you give me a little bit of guidance on how to fix it? locally it works fine.. just the deployed version is the problem
This means youre trying to call a function which does not exist in the program
I looked through old questions like mine but I can't figure out a solution based on answers that were given, so I'm sorry if this is a double question.. 

I'm running into this error when I try to "add a goal":
```Transaction simulation failed: Error processing Instruction 0: custom program error: 0x65 
    Program BYhgFTXaWGh2oxYRtQ7Xc4CzT7PWgZNwhe3us73HwRDz invoke [1]
    Program log: Custom program error: 0x65
    Program BYhgFTXaWGh2oxYRtQ7Xc4CzT7PWgZNwhe3us73HwRDz consumed 2150 of 200000 compute units
    Program BYhgFTXaWGh2oxYRtQ7Xc4CzT7PWgZNwhe3us73HwRDz failed: custom program error: 0x65```
```Error: 101: Fallback functions are not supported
    at Function.parse```

I have an Anchor project deployed to devnet. 
On my **local frontend everything is working perfectly fine**, but on my deployed frontend (netlify) I get these errors.. both my local frontend and my deployed frontend target "devnet"
If you want to check out the code my anchor project is at https://github.com/carlijnweijer/buildspace-solana-web3
and my frontend is at https://github.com/carlijnweijer/buildspace-solana-web3-frontend
D:\Worksapce>anchor init myepicproject2 --javascript
Error: yarn install failed: program not found
someone have meet this error ?
Really good tutorial here that goes into all the details: https://lorisleiva.com/create-a-solana-dapp-from-scratch
```program.rpc.initialize(yourObject.name, yourObject.age, contextAccounts)```
Got it , thank you. IF we are talking about JS part, how can I pass to initialize function? as {name : "test", age : 20}?
You'd have to pass them as separate variables as anchor doesn't support objects (yet). ```pub fn initialize(ctx: Context<Initialize>, name: String, age: i64)```
also any places where i can read more on the space part? I don't now how much space I should gives to the program
Thank you.. is Vector of Tuple something that is supported in Solana Program but just not with Anchor?
someone have meet this error ?
D:\Worksapce>anchor init myepicproject2 --javascript
Error: yarn install failed: program not found
what can i do for this ?
anyone?
I am not sure anymore if Vector works actually. there's been some questions before, im not sure if it worked in the end. Generally, I would try to write it in a different way as anchor is quite fragile when it comes to more complex data-types
i followed the anchor tutorial and installed solana-cli 1.9.4 and anchor-cli 0.20.1, which version would support vector of tuple?
hmm depends on the version, i would definitely go with array if thats an option
status is giving `IdlError: Type not found: {"type":{"defined":"(String, u16)"}}` when i `anchor test`... i guess Vector of tuple isn't supported?
or perhaps from a different angle, assuming I have a bunch of liquidity-providing positions, how would you calculate TVL?
I guess basically my question boils down to: is there a way to fetch a data-account, without providing it to the Account-context?
is there a way to traverse a list on-chain? 

i.e. a list that is implemented in a "anchor"'y way, i.e. you have one struct that is the positionList which records how many elements there are in total, and another struct, that contains the actual list-element information?
🙏
Hi all, I have 2 questions I am trying to run `anchor test` but it gave a `IdlError: Type not found: {"type":{"defined":"Address"}}`..... this is because I created the type alias `type Address = String;` and i suspect the IDL didn't map Address back to String... 

1. is it possible to use type alias when writing solana program? 
2. is it possible to use HashMap as I am having the same issue with HashMap... many people recommend using PDA but I am basically building a round-based game and so would simply like to store the result of the game like HashMap<RoundNumber, Winner>...
For example "Human {name: String, age: integer}"
Can I pass here some "complex" types - `pub fn initialize(ctx: Context<Initialize>, data: String)` instead of String?
Hey, folks. Currently trying to save simple object (several field) using anchor, but can't rly understand how I can pass this object
oh so that is default in the ctx . Thanks
Use `ctx.program_id`
How can  use program id of Current program in my rust code? I am creating account from my initialize method and I need to provide program id which is from current program. One option is I can pass from client as parameter but I thought program id we already defined by declareid macro so somehow we can refer.
Ubuntu 20.04.
What is could  be the problem? I installed everything i should have installed
found it ty
Hi, <@!831450660146642974>, Are you enjoying a good weekend? Please help me!🙏  I am facing same error now. https://discord.com/channels/889577356681945098/889702325231427584/934596708631973899
https://github.com/Kriptikz/anchor-pda-transfer-sol
they should be in the transaction logs I think
is there a way to access the bpf logs from frontend/react?
Looking for some help. I have the base of a very basic voting program. I want to require SPL tokens to be used for voting. Anyone willing to guide me a bit or point me in the right direction. ( I'm used to solidity and coming to solana is a bit of a system shock 🙂 )

anyone else getting this trying to deploy on mainnet right now?
I am facing this problem
running `anchor init [name]` is recently returning `Error: File exists (os error 17)` , anyone run into this before?
gm
Wow the explanations on the tutorial are really good, and the diagrams are great. Thanks!
How do I run tests in Dev Net using Dev Net's USDC?
Do I need to pass in the mint_authority account or something?
this is my struct
```

#[derive(Accounts)]
pub struct Deposit<'info> {
    #[account(mut)]
    pub mint: Account<'info, token::Mint>,

    #[account(mut)]
    pub wallet: Signer<'info>,

    #[account(init_if_needed, payer = wallet, associated_token::mint = mint, associated_token::authority = wallet)]
    pub vault: Account<'info, token::TokenAccount>,

    pub token_program: Program<'info, token::Token>,
    pub system_program: Program<'info, System>,
    pub associated_token_program: Program<'info, associated_token::AssociatedToken>,
    pub rent: Sysvar<'info, Rent>,
}
```
Im trying to create an ATA for wSOL, I keep getting this err and im not sure why

```
Program ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL invoke [2]
    Program ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL consumed 1953 of 190391 compute units
    Program ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL failed: insufficient account keys for instruction
```
Can anyone link any additional references to anchor programs that transfer native SOL in the instructions?
I've only been able to find one, the todo list with rewards
Great to know; thanks guys!!
No, only the first deploy actually costs that much—although I think annoyingly you need to have that amount in your account at the start of subsequent deploys, even though it won't really get spent
But also you don’t pay that cost when upgrading a program
It gets cheaper every minute!
Yeah i kept airdropping but it wasnt working. Didnt realize i needed like 5 sol to deploy
Every time I call “anchor deploy”, will it cost 5-6 SOL on mainnet? Sounds very expensive
`struct_one` is intended to exist in a 'one to many' relationship with `struct_two`
is it possible to initialize multiple accounts in one program, and then change data between them?
I have `FooProgram` that has methods `initialize_struct_one` and `initialize_struct_two`
 `struct_one` stands alone, and `struct_two` is seeded with `struct_one`.
`initialize_struct_one` initializes and integer to `0`, and `initialize_struct_two` increments the integer in `struct_one`. 

Even though these are both in the same program, it seems the compiler is treating it as a CPI, and I am getting the error `Cross-program invocation with unauthorized signer or writable account`
it says in the error message
`Error: Account PUBLIC_KEY has insufficient funds for spend (1.84766424 SOL) + fee (0.00133 SOL)`
Something like 1.4 sol / 100kb of deployed code
I think depends on the size of your contract. So maybe airdrop 5 or 6 SOL
howmuch SOL do i need to just deploy a txn?
Use `solana airdrop 1`. Max airdrop is 1 SOL at a time so might need to do it a few times.
Are you deploying to `devnet` ? You'll need to airdrop more `SOL` into your wallet.
Based on a simple counter program below, is it correct that one `user/authority` will have only one `BaseAccount`  account? 

If the same `authority` initializes a second account, can you still reference the first account? If so how? Would I need to keep a reference of the account off-chain somehow and pass it in to an instruction to find that account?


```
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod p0001 {
    use super::*;
    pub fn create(ctx: Context<Create>) -> ProgramResult {
        let base_account = &mut ctx.accounts.base_account;
        base_account.count = 0;
        Ok(())
    }

    pub fn increment(ctx: Context<Increment>) -> ProgramResult {
        let base_account = &mut ctx.accounts.base_account;
        base_account.count += 1;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Create<'info> {
    #[account(init, payer=user, space= 8 + 8)]
    pub base_account: Account<'info, BaseAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct Increment<'info> {
    #[account(mut)]
    pub base_account: Account<'info, BaseAccount>,
}

#[account]
pub struct BaseAccount {
    pub count: u64,
}
```
plz help 🙏🙏🙏
I don't have enough funds? huh?
I am trying to run `anchor deploy` but get the following error:

```
➜  solend-cpi git:(main) ✗ anchor deploy
Deploying workspace: https://api.devnet.solana.com
Upgrade authority: ~/.config/solana/id.json
Deploying program "solendcpi"...
Program path: ~/Desktop/solend-cpi/target/deploy/solendcpi.so...
=====================================================================
Recover the intermediate account's ephemeral keypair file with
`solana-keygen recover` and the following 12-word seed phrase:
=====================================================================
XXXXXXXXXXXX seed phrase here
=====================================================================
To resume a deploy, pass the recovered keypair as the
[BUFFER_SIGNER] to `solana program deploy` or `solana write-buffer'.
Or to recover the account's lamports, pass it as the
[BUFFER_ACCOUNT_ADDRESS] argument to `solana program close`.
=====================================================================
Error: Account PUBLIC_KEY has insufficient funds for spend (1.84766424 SOL) + fee (0.00133 SOL)
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }.
```
Does anchor generate javascript schema for deserializing your accounts, or do you just have to copy it to your javascript?
Solution: Add lifetimes

In the latest version of anchor how do I do this:


//////////////////////////////////////////////////////////////////////////////////////////

https://hackmd.io/@ironaddicteddog/anchor_example_escrow
Any good demo on creating vault using anchor to store spl token
Any full spl token transfer demo using anchor spl and cpi
Client call is like
From is spl token account holder by owner wallet account
To is also token account but hooded by other wallet address
Authority is same account as owner n owner account is used as signer
Hey <@!134416332509675520> , is this what you were referring to for doing CPI from a JS test? https://github.com/solana-labs/solana-program-library/tree/master/token-lending/js/src/instructions
Is there a way to not have the provider wallet not sign the transaction?  I want to write a test verify that someone calling an instruction with a key other than the wallet provider will fail?  It sounds like the JavaScript rpc calls always add the wallet as a signer
that series is really good
Yep that's where I got a bunch of ideas from - except I am stuck on the transfer SOL bit now
Not exactly sure what you mean, maybe check out this part of a tutorial which goes over testing on anchor. The explanations are really good and doesn't skip any steps, the diagrams are also great
https://lorisleiva.com/create-a-solana-dapp-from-scratch/testing-our-instruction
But this doesn't make sense from the smart contract case because on the client side all you have access to is the pubkey that is passed as an arg to the program's function
ex: 
```rust
create(ctx: Context<Create>, amount: u64, deposit_account:Pubkey) -> ProgramResult
```
In this case, the user who initially signed executed this does not know that the contract is actually transferring SOL to **another** account behind the scenes (that is the idea I am going for). I am passing in the pubkey here cause I don't know how to create one in Rust
Anyone been having issues using metaboss snapshot tool recently? I keep getting an operation timed out message, but solana network seems to be back firing on all cylinders, so didn't think it should be due to network errors. I have been trying using two custom RPCs, both timing out.
Howdy.  I'm having a hell of a time trying to figure out account constraints for a basic admin scenario.   For example, if I have a create_game instruction, I only want a top level authority to be able to execute that instruction.  What's the constraint look like?
I can use it directly right?
Maybe `Clock::get()?.unix_timestamp`?
RPC has method getBlockTime is there similar method which I can use in anchor solana rust?
And then pass it in to a tx
You'd have to, say, fetch that great big list and go find the account you care about
Yeah, you can't (in fact, you can only pass an absolute max of about 30 accounts into a solana tx)
Thanks Alan. So whats the best practice for this? Vec<PubKey> could be any length. How can I pre-specify all accounts if there could be any number of them?
thanks
You're making a mistake somehow, but I'm not sure how off the top of my head
No, it's on your end—you're messing up the CPI call, but to understand how you'll have to go source diving 🤿
But if you basically did `Keypair.generate()` then call `program.provider.connection.getAccountInfo(pubkey)` - there is no account so shouldn't return anything, maybe?
so it's not something on my end is it?
You'll have to go source diving to see where
You're invoking the candymachine program and then it's failing due to one of its own internal constraints
Add ` { ... features = ["no-entrypoint"] }` to that cargo dependency
but is it something on my end when trying to mint or when the program is created?
error[E0774]: `derive` may only be applied to `struct`s, `enum`s and `union`s
  --> programs/sbaddin/src/lib.rs:10:1
   |
10 | #[derive(Default)]
   | ^^^^^^^^^^^^^^^^^^ not applicable here
11 | vote_weight_record!(crate::ID);
   | ------------------------------- not a `struct`, `enum` or `union`

error: the `#[global_allocator]` in this crate conflicts with global allocator in: spl_governance

error[E0599]: no function or associated item named `default` found for struct `VoterWeightRecord` in the current scope
  --> programs/sbaddin/src/lib.rs:81:10
   |
11 | vote_weight_record!(crate::ID);
   | ------------------------------- function or associated item `default` not found for this
...
81 | #[derive(Accounts)]
   |          ^^^^^^^^ function or associated item not found in `VoterWeightRecord`
   |
   = help: items from traits can only be used if the trait is implemented and in scope
   = note: the following trait defines an item `default`, perhaps you need to implement it:
           candidate #1: `Default`
   = note: this error originates in the derive macro `Accounts` (in Nightly builds, run with -Z macro-backtrace for more info)

Some errors have detailed explanations: E0599, E0774.
For more information about an error, try `rustc --explain E0599`.
error: could not compile `sbaddin` due to 3 previous errors
In general you need to go source-diving to understand that errors mean
I'll post the full log
On the client you can call `program.provider.connection.getAccountInfo(pubkey)` but you only need to do this if your client is using that info somehow
If this is to me, yeah
I will try based on what <@!737915190045311067> suggested and see if it works
ex:
```
let user = anchor.web3.Keypair.generate();
let wallet = new anchor.Wallet(user);
```
Are you calling candymachine or something?
Is that the full log?
'Program log: Instruction: MintNft', 'Program log: Custom program error: 0x7d1', 'Program `programId` consumed 11601 of 
200000 compute units', 'Program programId failed: custom program error: 0x7d1']}}
has anyone seen this before:
`error: the #[global_allocator] in this crate conflicts with global allocator in: spl_governance`
Either you or something you're calling is
Can you post the full program log?
As I am trying to understand, on the client side I can do
```ts
anchor.web3.Keypair.generate()
```
But that's just the key - how do I get an Account out of that?
I'm not using any has_one constraint tho in my code
You have some `has_one =` constraint that is failing
Via its address
You have to pass it in from the client, like any other account
So how do you make an account from a pubkey?
<@!134416332509675520> sorry to @, any chance you know this?
Nope, you'll have to pass the account in from the client unfortunately (not possible to dynamically look up accounts like that from within your rust program—the client has to pre-specify *all* accounts)

Hey, does anyone know what does this error mean? 

`anchorpy.error.ProgramError: 2001: A has_one constraint was violated`
Mine is 
```rust
pub mod demo05 {
    use super::*;
    use solana_program::program::invoke;
    use solana_program::system_instruction::transfer;
    pub fn create(ctx: Context<Create>, amount: u64, deposit_account:Pubkey) -> ProgramResult {
        msg!("spk: inside create");
        let program_account = &mut ctx.accounts.program_owned_account;
        program_account.user_authority_account_key = *ctx.accounts.user_authority_account.key;
        program_account.amount = amount;
        program_account.deposit_account = deposit_account;

        let from = ctx.accounts.user_authority_account.key;
        let to = deposit_account.key();

        // not sure if this is the right approach
        // seems to be the web3.js approach
        // https://github.com/solana-labs/solana-web3.js/blob/master/examples/send_sol.js
        let tx = transfer(from, &to, amount);

        // see: https://github.com/solana-labs/solana-program-library/blob/master/examples/rust/transfer-lamports/src/processor.rs
        ctx.accounts.user_authority_account.try_borrow_lamports() -= amount;

        // NO idea how to handle the deposit_account since all I have is a pubkey...

        Ok(())
    }
}

// define the Create account to be used in the associated create() instruction
#[derive(Accounts)]
pub struct Create<'info> {
    #[account(init, payer=user_authority_account, space= 8 + 64 + 32 + 32)]
    pub program_owned_account: Account<'info, ProgramOwnedAccount>,
    #[account(mut)]
    pub user_authority_account: Signer<'info>,
    #[account(address = system_program::ID)]
    pub system_program: Program<'info, System>,
}

// the type being used in a struct decorated with the Accounts attribute, like in Create above
#[account]
pub struct ProgramOwnedAccount {
    pub amount: u64,
    pub user_authority_account_key: Pubkey,
    pub deposit_account: Pubkey,
}
```
Actually that's not my code - someone else posted it and I was asking them how they made the `AccountInfo`
I think your problem is a little different. Can you try changing     pub token_program: AccountInfo<'info>,
to  pub token_program: Program<'info, Token>,
It seems like you're suppose to  generate the keypair and create the account on the test side

this is from the todo list where he wrote functions to create multiple users for his tests
```
async function createUser(airdropBalance) {
  airdropBalance = airdropBalance ?? 10 * LAMPORTS_PER_SOL;
  let user = anchor.web3.Keypair.generate();
  let sig = await provider.connection.requestAirdrop(
    user.publicKey, airdropBalance);
  await provider.connection.confirmTransaction(sig);

  let wallet = new anchor.Wallet(user);
  let userProvider = new anchor.Provider(provider.connection,
    wallet, provider.opts);

  return {
    key: user,
    wallet,
    provider: userProvider,
  };
}

function createUsers(numUsers) {
  let promises = [];
  for(let i = 0; i < numUsers; i++) {
    promises.push(createUser());
  }

  return Promise.all(promises);
}

function programForUser(user) {
  return new anchor.Program(mainProgram.idl, mainProgram.programId,
    user.provider);
}```

for example he then creates two users to test his "add" function
```
describe('add', () => {
  it('Anyone can add an item to a list', async () => {
    const [owner, adder] = await createUsers(2);

    const adderStartingBalance = await getAccountBalance(adder.key.publicKey);
    const list = await createList(owner, 'list');
    const result = await addItem({
      list,
      user: adder,
      name: 'Do something',
      bounty: 1 * LAMPORTS_PER_SOL
    });
```
lol just saw that
If you look at my prev code, I am trying to call `transfer` and `invoke` but only have  a `Pubkey`..
<@!907013467049951243> haha funny I am having the same prob...
Is there a way to translate Pubkey to Account in Rust? I have a Vec<Pubkey> where each PubKey is the key of another account.
On the client side, it seems you have to do something like `KeyPair.generate()` but on the rust side you need a full on `AccountInfo` rather than just a `Pubkey`. 
1. How to either create an `AccountInfo` on the client side or
2. Create an `AccountInfo` in Rust/Anchor using the `Pubkey`
looks like `solana address -k target/deploy/myapp-keypair.json` does the trick
How do you define `AccountInfo` on the client side (assuming you did it)
All I know is to create a `Pubkey` based on the docs but lots of these calls require the `AccountInfo`..
From your code:
```rust
#[account(mut)]
    pub from: Account<'info,TokenAccount>,
    #[account(mut)]
    pub to: Account<'info,TokenAccount>,
    #[account(mut)]
    pub owner:Signer<'info>,
    pub authority: AccountInfo<'info>,
```
Is there a super dumb explanation on what it is and how to idiomatically keep it updated for programs?
hey all, I'm a bit confused on the program id macro `declare_id!`. Up until now I just sort of ignored it cause things just seemed to work. When I add a new program to the workspace I'd get the correct id for it by running tests and printing the programId from there; and then update the value. Now I've updated anchor version in my workspace and the programId has changed once again
But I originally wanted my anchor script to FEEL closer to my front end react scripts but making each thing a component (easier to reason about)
Maybe I’ll make an example repo real quick to explain the problem
I don’t remember it exactly but it so much of a pain in the ass o just moved it back into one file
The problem is working with the context yeh. I originally had every single related function, validation, data object, and relevant error code in one file (components) and then just forwarded the fns from the program (librs) to handler functions in those component rs files

I can’t remember the exact problem but basically something was encapsulated that stopped me from doing so because I needed two components to talk to eachother exactly
Thanks for the heads up. At first I had this all wrapped in the `invoke` call but the docs said it was for a CPI program so wasn't sure how to use it. Also in my case I am passing in the `Pubkey` of the account I want to send the SOL to but I have no idea how to convert it to an `AccountInfo` in order to call the `invoke`
You can definitely reuse helper functions. Just define them as a top-level function as opposed to a instruction function inside the `#[program]` struct. (You can *also* invoke those too, but yeah, it's slightly awkward because they have complicated arguments—but it's possible!)
I was able to split them but not in a way that made enough sense for me to do it. Reccomend just not for now sorry
My bad - wrong thread.
this is a large package, which part are you pointing to here?
Can solana sysvar https://docs.solana.com/developing/runtime-facilities/sysvars be used to generate temporary random number ?
like this? https://github.com/solana-labs/solana-program-library/blob/master/token/ts/src/instructions/initializeMint.ts
ahh gotcha
like `@solana/spl-token` for talking to the token program.
Ah, I don't mean an sdk as a backend server—I just mean a js lib that knows how to build instructions.
if my tests use an API, then my tests rely on a centralized backend server to function. So what if i rlly need to update my smart contract, but the API's server is down?
Is that bad? Why don't you want a js dependency?
getting signature verifcation failed
use anchor_lang::prelude::*;
use anchor_spl::token::{self,Mint,TokenAccount,Transfer};
use anchor_spl::token::Token;


declare_id!("2o72inQRyrGquF8vN4vRCoAiTRSkngYaxYekJ7CdhjBs");
#[program]
pub mod my_program {
    use super::*;
    pub fn initialize(
        ctx: Context<Initialize>,
    ) -> ProgramResult {
       
        let cpi_accounts = Transfer {
            from: ctx.accounts.from.to_account_info().clone(),
            to: ctx.accounts.to.to_account_info().clone(),
            authority:ctx.accounts.owner.to_account_info().clone(),
        };
        let cpi_program = ctx.accounts.token_program.clone();
        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
        token::transfer(cpi_ctx, 100)?;
       
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    
    #[account(mut)]
    pub from: Account<'info,TokenAccount>,
    #[account(mut)]
    pub to: Account<'info,TokenAccount>,

    #[account(mut)]
    pub owner:Signer<'info>,
    pub authority: AccountInfo<'info>,
    pub token_program: AccountInfo<'info>,
    pub system_program:Program<'info, System>,
}
hi any idea on signature varification failure
Hi mate, do you got the solution's for this, function calls another function without cpi and inside the same program, if you have, could you share the solution. and any resource code it might be helpful, thanks.
dms are open
any front end dev who can create cool website and dapp for us ?
I'm getting this error when running `anchor test` in the project repository. Anyone has any idea about how to resolve it?
Todo List that also shows how to transfer native SOL
https://dev.to/dimfeld/starting-with-solana-part-4-4j5k

Anchor version of escrow
https://hackmd.io/@ironaddicteddog/solana-anchor-escrow
Thanks man!
this tutorial has the best explanations 
https://lorisleiva.com/create-a-solana-dapp-from-scratch
book.anchor-lang.com
Hello everybody! Kind of starting fresh on anchor any docs or pieces of code you guys can refer me too!
I have been writing smart contract in Rust now the need of the hour is to learn a bit of anchor as well!
Would love some help on getting started with it....
Something like this, 
I've been trying to increment an "amount" field in other "item" accounts stored on a "list" account when SOL is sent to and from user, but haven't been able to get it to work

``` 
pub fn pay(
        ctx: Context<Pay>,
        amount: u64,
    ) -> ProgramResult {
        let user: &Signer = &ctx.accounts.user;

        let ix = anchor_lang::solana_program::system_instruction::transfer(
            &ctx.accounts.user.key(),
            &ctx.accounts.receiver.key(),
            amount * 1000000000,
        );
        anchor_lang::solana_program::program::invoke(
            &ix,
            &[
                ctx.accounts.user.to_account_info(),
                ctx.accounts.receiver.to_account_info(),
                ctx.accounts.system_program.to_account_info(),
            ],
        );

        Ok(())
    }


#[derive(Accounts)]
#[instruction(amount: u64)]
pub struct Pay<'info> {
     #[account(mut)]
    pub receiver: AccountInfo<'info>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```

I referenced this,
https://stackoverflow.com/questions/70528742/how-to-transfer-sol-in-anchor-smart-contract-instruction
The confusing bits are in this area:
```rust
// not sure if this is the right approach
        // seems to be the web3.js approach
// https://github.com/solana-labs/solana-web3.js/blob/master/examples/send_sol.js
        let tx = transfer(from, &to, amount);

        // see: https://github.com/solana-labs/solana-program-library/blob/master/examples/rust/transfer-lamports/src/processor.rs
        ctx.accounts.user_authority_account.try_borrow_lamports() -= amount;

        // NO idea how to handle the deposit_account since all I have is a pubkey...
```
How do you do a transfer of SOL in the rust code? Here is what I have so far but obviously it's not working. Anyone can offer up some ideas?
```rust
#[program]
pub mod demo05 {
    use super::*;
    use solana_program::program::invoke;
    use solana_program::system_instruction::transfer;
    pub fn create(ctx: Context<Create>, amount: u64, deposit_account:Pubkey) -> ProgramResult {
        msg!("spk: inside create");
        let program_account = &mut ctx.accounts.program_owned_account;
        if amount <= 0 {
            return Err(ErrorCode::AmountIsZero.into());
        }
        
        program_account.user_authority_account_key = *ctx.accounts.user_authority_account.key;
        program_account.amount = amount;
        program_account.deposit_account = deposit_account;
        let from = ctx.accounts.user_authority_account.key;
        let to = deposit_account.key();
        // not sure if this is the right approach
        // seems to be the web3.js approach
        let tx = transfer(from, &to, amount);

        // see: https://github.com/solana-labs/solana-program-library/blob/master/examples/rust/transfer-lamports/src/processor.rs
        ctx.accounts.user_authority_account.try_borrow_lamports() -= amount;

        // NO idea how to handle the deposit_account since all I have is a pubkey...

        Ok(())
    }
}

// define the Create account to be used in the associated create() instruction
#[derive(Accounts)]
pub struct Create<'info> {
    #[account(init, payer=user_authority_account, space= 8 + 64 + 32 + 32)]
    pub program_owned_account: Account<'info, ProgramOwnedAccount>,
    #[account(mut)]
    pub user_authority_account: Signer<'info>,
    #[account(address = system_program::ID)]
    pub system_program: Program<'info, System>,
}

#[account]
pub struct ProgramOwnedAccount {
    pub amount: u64,
    pub user_authority_account_key: Pubkey,
    pub deposit_account: Pubkey,
}
```
how u solve signature verification failed
How do I call a JS transaction with anchor, from a non-anchor program?
https://github.com/project-serum/anchor/tree/master/tests
go through the examples here 🙂
ahh so how do I specify the seeds in the macro if its just a string
so in anchor if you define that you want a PDA with a seed "myseed123", then that PDA created in another program will not have the same address
i dont know how to access it directly but i do know that under the hood it's already being used as part of the seed
want to use it for my PDA and seed macro
How do I access the program id variable
uses the heap instead of the stack
hmmm but the SDK relies on the API, which creates a dependency, no?
Or if you have their IDL as a file, you can load it up the same way you load your own IDL
Ideally they expose a js sdk you can install
Same issue
what's the best way to call a program that is not mine from my anchor tests?
https://docs.rs/anchor-lang/0.20.1/anchor_lang/?search=box
Reading this in the anchor docs:

"This is different from the solana program deploy command, because everytime it's run it will generate a new program address."

Is it recommended when deploying programs to mainnet to in that case use solana program deploy command instead of anchor deploy?
https://www.jetbrains.com/lp/mono/
This font is really nice
Why is there a `Box` used in some code i'm reading on gh, like: 
```
Box<Account<'info, TokenAccount>>
```
i think I'm meeting both of these requirements, i'm logging the bump and have had success and failures with  255, 254, and 253. 
```
let puppet_seeds = &[
  CONST_SEED,
  pubkey_b.as_ref(),
  pubkey_a.as_ref(),
  &[ctx.accounts.puppet_struct.bump],
];

puppet::cpi::puppet_funx(
  ctx.accounts.puppet_funx_ctx().with_signer(&[puppet_seeds]),
)?;```This is how I'm calling the CPI with signer seeds. I think this should be sufficient for passing the correct bump in, right?
yup
reference:
the compiler is not yelling at me so im gonna assume thats a yes
One way that could happen is if you're messing up the order of arguments to `#[instruction(...)]` (they need to match the order from the actual instruction function), or maybe you're inadvertently mixing up two different bumps (bumps have a 50/50 chance of being 255, so easy for things to "work" even if you're mixing them up)
does it make sense to use `init_if_needed` for simple token accounts?
it tells anchor the program's id.  anchor uses this probably for many things, but at minimum for address validation
hey guys! How i can create a new token for tests every time in one address?
Hey guys, rly silly question, but what does `declare_id` do?
Can anyone think of a reason / has anyone run into `Signer seeds do not result in a valid address` but only sometimes? It seems 50/50 on whether or not I get this error, where half the time it works fine.
Oh awesome. Great result
Subsequent deploys are ~free (seems like you annoyingly have to have roughly the same amount of sol in your wallet due to the details of how deploys work under the hood, but that sol won't actually get spent)
Does anyone know how much it costs to redeploy an anchor program to mainnet if you do minimal changes? My first deployment is going to cost a little under 2 SOL, but just wondering if I do a tiny change (like just one line), if I will have to pay a similar amount for each deployment?
i'm new to solana; i hadn't run into the 4kb stack size limit.  i didn't realize that limitation
i have accounts who have a data structure that's just a list of public keys; the data for those public keys is at pdas that are like [account_type, epoch, public_key].  i guess almost exactly the same; i just wasn't thinking of it in those terms
what i have is actually very similar though; but it's more like a hash table than a list
definitely has to be multi account for sure in many cases.  i hadn't considered using multiple in a continguous data structure like that.
some array is easiest for sure haha
i.e. fixed length buffers are probably good for u64 or somewhat simple data structures, but you might also hit the 4kb context pretty fast (again, depending on the input data..)
yh that's true, but if you have more complex data-models I think that's the only option, no?


//////////////////////////////////////////////////////////////////////////////////////////

thanks mate its work.
Sorry, if this type of thing happens again, I'll stop what I'm doing and create a fork if I can
I see
You're probably doing `program.rpc.doSomething` and forgot to define `program`
did you import your idl?
I was pulling my hair out getting unclear errors and this quirky state leakage
What is this error: 
```
TypeError: Cannot read property 'rpc' of undefined```
#[instruction(bump: u8)] is incorrect here because it should be  #[instruction(first_param:u64, bump: u8)]
I do the same.  
No repro under my current code, sorry.  I'm certain this was the issue:

```
   pub fn set_admin_settings(ctx: Context<SetAdminSettings>, first_param: u64, bump: u8) -> ProgramResult {
        let admin_settings = &mut ctx.accounts.admin_settings;
        admin_settings.admin_authority = *ctx.accounts.admin_authority.key;
        admin_settings.bump = bump;
        Ok(())
    }
#[derive(Accounts)]
#[instruction(bump: u8)]
pub struct SetAdminSettings<'info> {
    #[account(
        init,        
        seeds = [PDA_SEED_ADMIN],
        bump = bump,
        payer = authority,
        space = AdminSettings::SIZE
    )]
    pub admin_settings: Account<'info, AdminSettings>,    

    pub admin_authority: AccountInfo<'info>,
    #[account(mut, address = dapwords_initial_admin::ID)]
    pub authority: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```
This is why I never ever do an actual `anchor deploy` by the way when testing, I always just do `anchor test` and let anchor spin up a temporary validator
Not as far as I know 🤔 Just in the validator itself
I'm assuming there's some state/cache in the .anchor directory?
I'll see if I can get a repro, one sec.
Never run into anything like that
Could you show some program logs?
I've also just had weird corruption bugs that have caused runs to fail nondeterministically.  For example, I forgot a parameter name in an instruction and it was an opaque failure that gave a different error message on every test run.
I guess the only way to really deal with this would be to have pretty much every account have a [b"session", 2] seed
Yeah I usually write my tests in such a way that I make "new" accounts for each test/ignore the old ones
Yeah, and trying to write code that resets all possible state could be a rather big pain especially when dealing with accounts with PDA's
Right, I'm saying that the test-validator would need a "reset me" button, and I'm not sure it does
I can't really control how I talk to the test validator can I?  Is there an TS call to force account deletion no matter what?
So resetting is up to how you talk to the test validator in the background
Basically anchor itself doesn't have any js testing framework—it's just vanilla js tests
Actually now that I think about it, maybe the solana rust testing lib doesn't have this problem 🤔
What's surprising about it? The issue is that the js/ts tests are running against a live validator in the background
This is really surprising/scary considering we're dealing with chain programs.  No way to hack around it or lift out the testrunner?
Nope, no easy way to do this unfortunately :/
No way to reset test state between tests?  Makes it really hard to test things in isolation.
seems like my pda does not have enought sol but I can't solana airdrop my contract it does not work
is someone have an idea about how is it possible ? haha
Transaction simulation failed: Error processing Instruction 0: custom program error: 0x1 
    Program 3K1jZTmuKtqRNdzCUVXaMARNL28kegjRZiKo31dvR5gg invoke [1]
    Program log: Instruction: PlayGame
    Program 11111111111111111111111111111111 invoke [2]
    Transfer: insufficient lamports 0, need 10467840
    Program 11111111111111111111111111111111 failed: custom program error: 0x1
    Program 3K1jZTmuKtqRNdzCUVXaMARNL28kegjRZiKo31dvR5gg consumed 7794 of 200000 compute units
    Program 3K1jZTmuKtqRNdzCUVXaMARNL28kegjRZiKo31dvR5gg failed: custom program error: 0x1
so it gets hidden but there's a button people can click to see it
ERROR
```
Balance of Program Account account is 0
Balance of Authority/Wallet Account account is 500000000000000000
Balance of Deposit Account account is 0
Starting account creation and deposit...

Airdropping 2.5 lamports to UseAccount/Wallet 4oDmbjZsYoAcP9L3LLnGQcKMCZBXESt7npAAYAeCr94v
Airdropped signature [object Object]
Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account
Program BnHgqQKV6rjcJ371tkzHkjWJsEPQXt53hH84tWmqBEjZ invoke [1]
Program log: Instruction: Initialize
Program 11111111111111111111111111111111 invoke [2]
Program 11111111111111111111111111111111 success
Program 11111111111111111111111111111111 invoke [2]
Program 11111111111111111111111111111111 success
11111111111111111111111111111111's writable privilege escalated
Program BnHgqQKV6rjcJ371tkzHkjWJsEPQXt53hH84tWmqBEjZ consumed 18442 of 200000 compute units
Program BnHgqQKV6rjcJ371tkzHkjWJsEPQXt53hH84tWmqBEjZ failed: Cross-program invocation with unauthorized signer or writable account
```
TEST
```typescript
const provider = anchor.Provider.env();
anchor.setProvider(provider);
const idl = JSON.parse(readFileSync("./target/idl/demo06.json", "utf8"));
const program = anchor.workspace.Demo06 as Program<Demo06>;

// obviously not the best way to set this up...
const programAccount = anchor.web3.Keypair.generate();
const authority = provider.wallet;
const depositAccount = anchor.web3.Keypair.generate();

async function getBalance(pubkey: anchor.web3.PublicKey, accountName: string) {
  let balance = await provider.connection.getBalance(pubkey);
  console.log(`Balance of ${accountName} account is ${balance}`);
}

describe('demo06', () => {
  it('Is Created', async () => {
    console.log("STARTING TEST\n")
    console.log("Balance before creation\n");
    await getAllAccountBalance();

    console.log("Starting account creation and deposit...\n");

    // add some SOL to the authority/wallet
    await airDrop(authority.publicKey, 2.5);

    // send instruction to smart contract
    const tx = await program.rpc.initialize(new BN(1.3), {
      accounts:{
        programAccount: programAccount.publicKey,
        testDepositAccount: depositAccount.publicKey,
        authority: authority.publicKey,
        systemProgram:anchor.web3.SystemProgram.programId
      },
      signers:[depositAccount, programAccount]
    });
    console.log("Your transaction signature", tx);

    // verify the program account was created on the blockchain
    let pgAccount = await program.account.programAccount.fetch(programAccount.publicKey);
    console.log(`Program account on chain ${pgAccount}\n`);
    console.log("Balance After creation\n");
    await getAllAccountBalance();
    console.log("END TEST")
  });
});
```
I think I may have gotten something working but I re-did a new project to streamline stuff but running into the famous `Cross-program invocation with unauthorized signer or writable account error`. I looked at what other folks did with their but I am still stumped
Program:
```rust
declare_id!("BnHgqQKV6rjcJ371tkzHkjWJsEPQXt53hH84tWmqBEjZ");

#[program]
pub mod demo06 {
    use super::*;
    use solana_program::native_token::{lamports_to_sol, LAMPORTS_PER_SOL};
    use solana_program::system_instruction::transfer;
    pub fn initialize(ctx: Context<Create>, lamports_in: u64) -> ProgramResult {
        let program_account = &mut ctx.accounts.program_account;
        let authority_account = &mut ctx.accounts.authority;
        let system_account = &mut ctx.accounts.system_program;
        let test_deposit_account = &mut ctx.accounts.test_deposit_account;
        test_deposit_account.lamports = lamports_in * LAMPORTS_PER_SOL;

        let account_infos = [
            authority_account.to_account_info(),
            test_deposit_account.to_account_info(),
            system_account.to_account_info(),
        ];

        let tx = transfer(
            authority_account.key,
            &test_deposit_account.deposit_account,
            test_deposit_account.lamports,
        );
        solana_program::program::invoke(&tx, &account_infos);
        Ok(())
    }
}
#[derive(Accounts)]
pub struct Create<'info> {
    #[account(init, payer=authority, space=8+32+32)]
    program_account: Account<'info, CreateAccount>,
    #[account(init, payer=authority, space=8+32+8)]
    test_deposit_account: Account<'info, DepositAccount>,
    #[account(mut)]
    authority: Signer<'info>,
    system_program: Program<'info, System>,
}
#[account]
pub struct CreateAccount {
    program_account: Pubkey,
    authority: Pubkey,
}
#[account]
pub struct DepositAccount {
    deposit_account: Pubkey,
    lamports: u64,
}
```
my test keeps failing because the error is returned, but idk how to make the test pass against it
is there a proper way to write an anchor test for a scenario where you want to test a specific error code is returned?
Gonna repost as I don't know if it was hidden
Lets see now - so does that mean my giant code block from earlier got hidden as well?
really now - that would explain why I keep getting kicked off for no reason when I literally just do nothning
prolly because you have crypto in your name
discord keeps hiding your messages as "likely spammer"
<@!195345150132748288> this could be an idea: https://paulx.dev/blog/2021/01/14/programming-on-solana-an-introduction/
Are there any examples showing how to split up a program across multiple files?  I have a single, massively long lib.rs and it would be great if I could at least pull the data types into a separate file than the instructions
Any suggestions on the `Cross-program invocation with unauthorized signer or writable account` I posted a few hrs ago?
Associated token addresses are *always* PDAs (derived from the associated token program, not yours), so do you mean a regular, non-associated token account?
Not sure what that error is—can you post the full program log?
is there something like an `anchor build clean cache` command?
Hi  I have below struct where I want to update Pool account data which is PDA account. While Updating I am getting 3012 error which seems account is initialized but I am not using 'init'. Any idea? pub struct UpdatePool<'info> {

    #[account(signer)]
    owner : AccountInfo<'info>,
    margin_wallet : AccountInfo<'info>,
  
    #[account(mut, seeds=[(*rand.key).as_ref()], bump=_bump)]
    pool : Account<'info, Pool>,
    rand : AccountInfo<'info>,

}
Hey coming back to this from wayyy back. As I just got the same Owner cannot sign error - is my understanding correct then that attempting to create an associated token account for a PDA will result in that Owner cannot sign error ?
would it be possible to have one user request payment from another? and are there any examples of this?
But it would require having an external, off-chain program that acts like a chron job—you would need to poke your rust program when the time is right
You can use `Clock::get()?.unix_timestamp` to get the current time inside your rust program
are there any examples of programs that use time?
for example, payment is sent or received at some time interval based on agreement of two users
Can see some more examples here: https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo/src/lib.rs#L68
ok, i will search
Try searching the anchor repo for `bump =` to see a bunch of examples
understand, big thx! i suspected that i don't do anything with pda, but can't found how to do this
You'll have to figure out the right bump to use for that PDA (you're currently skipping that by saying just `bump` in the derive Accounts block)
Any time you do a token transfer, the authority over the tokens needs to sign the CPI. You're not doing that here.
```.rs
token::transfer(
            CpiContext::new_with_signer(
                ctx.accounts.token_program.to_account_info().clone(),
                transfer_cpi_accounts,
                &[
                  &[ctx.accounts.user.key().as_ref(), b"agrostaking", &[figure_out_the_right_bump]]
                ]
            ), value
        );
```
yes, i don't do this, where i can do this? sorry, i can't understand what this will do and why? 😦
You'll need to use `CpiContext::new_with_signer`
Doesn't look like you're actually signing with the staking_info seeds
hey, maybe someone can help pls?
Purely integers
can anchor's BN handle floats, or is it purely integers?
look at above test ,u need to pass all accounts
gm everyone,

How you you test your code when they use other programs accounts or invoke them?
Getting signature verification failure on this test
const { Program } = require("@project-serum/anchor");

const anchor = require("@project-serum/anchor");

const { publicKey } = require("@project-serum/anchor/dist/cjs/utils");

const { SystemProgram } = anchor.web3;

describe("basic-0", () => {


    anchor.setProvider(anchor.Provider.local());


    let secretKey = Uint8Array.from([57, 128, 78, 61, 58, 182, 228, 66, 81, 132, 18, 179, 221, 192, 252, 116, 136, 105, 13, 237, 140, 133, 171, 44, 211, 215, 16, 207, 239, 159, 107, 62, 86, 209, 127, 142, 67, 5, 67, 125, 152, 10, 20, 0, 30, 6, 99, 143, 147, 59, 18, 82, 73, 6, 36, 27, 92, 73, 70, 148, 71, 105, 246, 70]);

    const myAccount1 = anchor.web3.Keypair.fromSecretKey(secretKey);



    console.log(myAccount1.publicKey.toBase58());
    it("Uses the workspace to invoke the initialize instruction", async() => {


        const program = anchor.workspace.Basic0;

        // Execute the RPC.

        await program.rpc.initialize({

            accounts: {

                //from: ("Fg9bWdnMYqG5N9H7WCWtdeGo1Q3oNQcEQcgjGkHShhr3")
                from: ("Fg9bWdnMYqG5N9H7WCWtdeGo1Q3oNQcEQcgjGkHShhr3"),
                to: ("2hgSCKW4sSrsJcJR6WNH2yiDTDHSRTwqDSAc4LMY8VAN"),
                mint: ("A5hikrCr7AVL5SgxoaJJPy6XhJXgyQ5gCDTuQ272SV6n"),
                tokenProgram: ("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),
                //rent: [myAccount1],
                authority: [myAccount1],
                systemProgram: SystemProgram.programId,

            },

            signers: [myAccount1],

        });


    });

});
testfile is like this
use anchor_lang::prelude::*;
use anchor_spl::token::{self,Mint,TokenAccount,Transfer};
use anchor_spl::token::Token;


declare_id!("2o72inQRyrGquF8vN4vRCoAiTRSkngYaxYekJ7CdhjBs");




#[program]
pub mod my_program {
    use super::*;
    pub fn initialize(
        ctx: Context<Initialize>,
    ) -> ProgramResult {
       
        let cpi_accounts = Transfer {
            from: ctx.accounts.from.to_account_info().clone(),
            to: ctx.accounts.to.to_account_info().clone(),
            authority:ctx.accounts.authority.to_account_info().clone(),
        };
        let cpi_program = ctx.accounts.token_program.clone();
        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
        token::transfer(cpi_ctx, 100);
       
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {

    #[account(mut,associated_token::mint=mint,associated_token::authority=authority)]
    pub from: Account<'info,TokenAccount>,
    #[account(mut,associated_token::mint=mint,associated_token::authority=authority)]
    pub to: Account<'info,TokenAccount>,
    pub mint:AccountInfo<'info>,
    pub authority: Signer<'info>,
    pub rent :Sysvar<'info,Rent>,
    pub token_program: AccountInfo<'info>,
    pub system_program:Program<'info, System>,
}
hey any idea on signature varification faliure
and https://paulx.dev/blog/2021/01/14/programming-on-solana-an-introduction/#building-the-escrow-program-bob-s-transaction
https://project-serum.github.io/anchor/getting-started/introduction.html
hey can anyone tell me that how to make a token contract through anchor framework? is there any doc or help ?
hello, i have a problem when try transfer token from program token account (owner pda) to user wallet, but all my accounts "mut" ```pub fn unstake(ctx: Context<Unstake>) -> ProgramResult {
        let value = ctx.accounts.token_from.amount;

        let transfer_cpi_accounts = Transfer {
            from: ctx.accounts.token_from.to_account_info().clone(),
            to: ctx.accounts.token_to.to_account_info().clone(),
            authority: ctx.accounts.staking_info.to_account_info().clone()
        };

        token::transfer(
            CpiContext::new(
                ctx.accounts.token_program.to_account_info().clone(),
                transfer_cpi_accounts
            ), value
        );

        Ok(())
    } 
#[derive(Accounts)]
pub struct Unstake<'info> {
    #[account(mut)]
    pub token_from: Account<'info, TokenAccount>, // PDA agte token account for this user
    #[account(mut)]
    pub token_to: Account<'info, TokenAccount>, // user agte token account
    #[account(mut, seeds = [user.key().as_ref(), b"agrostaking"], bump)]
    pub staking_info: Account<'info, StakeInfo>,
    #[account(mut)]
    pub user: Signer<'info>,  // user who will unstake

    pub token_program: Program<'info, Token>,  //  address for token program for transfer
    pub system_program: Program<'info, System>,
}``` Where i have a mistake? 😦
nvm it's literally just .to_string() I just suck ass at reading rust docs
So in order to get `AccountInfos` I made the `deposit_account` be `init` and so on and added it to the signers array . Played around with removing the `init` but got other errors
I am kinda doing a very bad version of CPI here...
The error
```
Balance of Program Account account is 0
Balance of Authority/Wallet Account account is 500000000000000000
Balance of Deposit Account account is 0
Starting account creation and deposit...

Airdropping 2.5 lamports to UseAccount/Wallet 4oDmbjZsYoAcP9L3LLnGQcKMCZBXESt7npAAYAeCr94v
Airdropped signature [object Object]
Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account
Program BnHgqQKV6rjcJ371tkzHkjWJsEPQXt53hH84tWmqBEjZ invoke [1]
Program log: Instruction: Initialize
Program 11111111111111111111111111111111 invoke [2]
Program 11111111111111111111111111111111 success
Program 11111111111111111111111111111111 invoke [2]
Program 11111111111111111111111111111111 success
11111111111111111111111111111111's writable privilege escalated
Program BnHgqQKV6rjcJ371tkzHkjWJsEPQXt53hH84tWmqBEjZ consumed 18442 of 200000 compute units
Program BnHgqQKV6rjcJ371tkzHkjWJsEPQXt53hH84tWmqBEjZ failed: Cross-program invocation with unauthorized signer or writable account
```
The test:
```typescript
const provider = anchor.Provider.env();
anchor.setProvider(provider);
const idl = JSON.parse(readFileSync("./target/idl/demo06.json", "utf8"));
const program = anchor.workspace.Demo06 as Program<Demo06>;

// obviously not the best way to set this up...
const programAccount = anchor.web3.Keypair.generate();
const authority = provider.wallet;
const depositAccount = anchor.web3.Keypair.generate();

async function getBalance(pubkey: anchor.web3.PublicKey, accountName: string) {
  let balance = await provider.connection.getBalance(pubkey);
  console.log(`Balance of ${accountName} account is ${balance}`);
}

describe('demo06', () => {
  it('Is Created', async () => {
    console.log("STARTING TEST\n")
    console.log("Balance before creation\n");
    await getAllAccountBalance();

    console.log("Starting account creation and deposit...\n");

    // add some SOL to the authority/wallet
    await airDrop(authority.publicKey, 2.5);

    // send instruction to smart contract
    const tx = await program.rpc.initialize(new BN(1.3), {
      accounts:{
        programAccount: programAccount.publicKey,
        testDepositAccount: depositAccount.publicKey,
        authority: authority.publicKey,
        systemProgram:anchor.web3.SystemProgram.programId
      },
      signers:[depositAccount, programAccount]
    });
    console.log("Your transaction signature", tx);

    // verify the program account was created on the blockchain
    let pgAccount = await program.account.programAccount.fetch(programAccount.publicKey);
    console.log(`Program account on chain ${pgAccount}\n`);
    console.log("Balance After creation\n");
    await getAllAccountBalance();
    console.log("END TEST")
  });
});
```
I think I may have gotten something working but I re-did a new project to streamline stuff but running into the famous `Cross-program invocation with unauthorized signer or writable account` error. I looked at what other folks did with their but I am still stumped
```rust
declare_id!("BnHgqQKV6rjcJ371tkzHkjWJsEPQXt53hH84tWmqBEjZ");

#[program]
pub mod demo06 {
    use super::*;
    use solana_program::native_token::{lamports_to_sol, LAMPORTS_PER_SOL};
    use solana_program::system_instruction::transfer;
    pub fn initialize(ctx: Context<Create>, lamports_in: u64) -> ProgramResult {
        let program_account = &mut ctx.accounts.program_account;
        let authority_account = &mut ctx.accounts.authority;
        let system_account = &mut ctx.accounts.system_program;
        let test_deposit_account = &mut ctx.accounts.test_deposit_account;
        test_deposit_account.lamports = lamports_in * LAMPORTS_PER_SOL;

        let account_infos = [
            authority_account.to_account_info(),
            test_deposit_account.to_account_info(),
            system_account.to_account_info(),
        ];

        let tx = transfer(
            authority_account.key,
            &test_deposit_account.deposit_account,
            test_deposit_account.lamports,
        );
        solana_program::program::invoke(&tx, &account_infos);
        Ok(())
    }
}
#[derive(Accounts)]
pub struct Create<'info> {
    #[account(init, payer=authority, space=8+32+32)]
    program_account: Account<'info, CreateAccount>,
    #[account(init, payer=authority, space=8+32+8)]
    test_deposit_account: Account<'info, DepositAccount>,
    #[account(mut)]
    authority: Signer<'info>,
    system_program: Program<'info, System>,
}
#[account]
pub struct CreateAccount {
    program_account: Pubkey,
    authority: Pubkey,
}
#[account]
pub struct DepositAccount {
    deposit_account: Pubkey,
    lamports: u64,
}
```
```let account_lamports = **item.to_account_info().lamports.borrow();```
What does the double "**" in front of item mean?
How do I get the string version of a pubkey?
aka how do I get the string from:
```
let mint = stake.mint.key();
```
Hey is `anchor migrate` broken in the latest version or is it just my local?
ha I cant even remember how I did it now.
```
    #[account(init, payer=user,
      space=TodoList::space(&name, capacity),
      seeds=[
        b"todolist",
        user.to_account_info().key.as_ref(),
        name_seed(&name)
      ]
```
Could someone explain what the "seeds" portion of this code means? Specifically, what is the b"todolist" part for?
Yeah js but basically Im wondering if there's a way to load parts of a vector in account data but not the whole vector mainly to not load up data that I might not need to display
I'm leaving this here in case anyone searches for it though. durr
I'm stupid, i'm on a macbook now and it doesn't go off /home/username .. it's /Users/username
trying to run anchor deploy after setting everything up on a new computer:
```
✗ anchor deploy
Deploying workspace: http://localhost:8899
Upgrade authority: /home/username/.config/solana/id.json
Deploying program "my_prog"...
Program path: /Users/username/crypto/my_prog/target/deploy/my_prog.so...
Error: Dynamic program error: No default signer found, run "solana-keygen new -o /home/username/.config/solana/id.json" to create a new one
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.
```

I've verified that the id.json is there at that path already..
Oh i also run `anchor test` to test my code with the print statements
hi, i tried printing both with `msg!` and `println!` but when opening the program logs in the `.anchor` folder i dont see the print statements. Is there anything im missing?
Not totally sure what you mean—what bandwidth are you worried about? Are you trying to do this in js?
mainly for bandwidth purposes like loading only 25 items from vector in an account not the whole vector?
Anyone have a solution for loading lets say only a few items from an account holding a vector?
done
```json
return Keypair.fromSecretKey(
    Buffer.from(
      JSON.parse(
        fs.readFileSync(process.env.ANCHOR_WALLET, {
          encoding: "utf-8",
        })
      )
    )
  );
```

Property 'payer' does not exist on type 'Wallet'.ts(2339)

any help? thanks!
`pk.to_string()`
How do i get the string for a Pubkey?
ack. thanks.
It's a little bit awkward, you can use the `remaining_accounts` feature (try searching the anchor repo, should hopefully be fairly straightforward—it's just low-level)
I mixed this channel with solana's dev 🙂  somsone there responded with the cookbook link, that is super helpful.  https://solanacookbook.com/references/accounts.html#create-a-pda  

this now brings me to the next thing I need to figure out, this time anchor-related 🙂 - how can I pass a variable number of accounts from the client to a solana program while using anchor..  I should look at the macros it produces.    I need to make an interface that would receive a variable number of accounts.  This is easy in a traditional solana program. (as you can iterate incoming accounts)  ...all the examples of anchor though, so far, that I have seen, have been setting things up with static accounts (and by that I mean anchor macro-processed structs).   anyways, I'll dig a bit later, but if anything comes to mind, please lmk.
https://github.com/CrateProtocol/crate/blob/75d2c70a4e7bf227b5d4b82e96c5d884c81746f3/programs/crate-token/src/state.rs#L48
this is how crate does it if thats helpful
😄
appreciated! exactly what i was looking for
Depend on how much rounding error you can tolerate
As far as I can tell, using floating point isn't a good idea.  Check out the spl-math library.  Otherwise, simple fixed point multiply, first with u128 then divide and then go back to u64 should do it.
hi everyone, new to anchor and to rust as well. say i wanted to take a percentage of a transaction as a fee. as the amounts are in u64, what is best practice to take the percentage I want? should i cast the amount to f64 to multiply it by the desired ratio, or is there a method i'm unaware of?
It indeed does a CPI to the system program under the hood
Often you can get away with just using anchor's `init` attribute, would that work?
are there any examples of using the SystemProgram to create an account from within the solana program?  I presume this would require CPI invocation with a SystemInstruction...  just starting to look at this, would appreciate pointers if anyone has any.
Oh i also run `anchor test` to test my code with the print statements
Thanks a lot, read through the rust code and adjusted mine
I fixed it!!
hi, i tried printing both with `msg!` and `println!` but when opening the program logs in the `.anchor` folder i dont see the print statements. Is there anything im missing?
You the man alan. Thanks for the support.
Or ask about it in their discord etc.
Yeah, might have to just copy their rust code: https://github.com/solendprotocol/solana-program-library/blob/mainnet/token-lending/program/src/instruction.rs
Guess i'll just make my own instruction builders for those instructions
My plan was to just do something like:
```
const txn = new Transaction(
   solendSdk.createInitLendingMarket(...)
)

sendAndConfirmTransaction(txn)
```
On the other hand, `spl-lending` has the instruction builders for instructions like `InitLendingMarket`, but the parameters are different than solend: 
https://github.com/solana-labs/solana-program-library/tree/master/token-lending/js/src/instructions
https://github.com/solendprotocol/solend-sdk/tree/master/src/instructions
ugh alan i am stuck man .. I'm trying to integrate with Solend, who forked the `spl-lending` library, but Solend didn't provide all the instruction builders for all their transactions (e.g. `InitLendingMarket`)
Exactly how e.g. anchor talks to the spl token program from within rust
Ideally if you want to some random program X, they provide a way to build instructions (so a source code dependency)
But it's a way to build an instruction that you can invoke directly from the client (or add as an extra instruction to a tx, etc.)
Yeah (it's not really a "CPI" since that only happens within your rust program)
Ok, do you know what the `has_one` attribute does?
This one is what is in the source code for the function I'm trying to call
I am trying to interact with an already existing program, not create one
I am kinda making a bit of a guess here but it seems that's the idea
<@!314065112984190976> https://project-serum.github.io/anchor/tutorials/tutorial-2.html#defining-a-program
I think that the struct you pass in to your function also has to have a field called `wallet`
```pub struct MintNFT<'info> {
    #[account(
        mut,
        has_one = wallet
    )]```

this is the only bit of code where "has_one" appears
Could you help me out on where to look? I'm lost 😅


//////////////////////////////////////////////////////////////////////////////////////////

k, i think i solved the problem.

it warrants more discussion but...

changing `[programs.devnet]` to `[programs.localnet]` in my Anchor.toml,

and changing 

```
[provider]
cluster = "devnet"
```

to 

```
[provider]
cluster = "localnet"
```

seems to have worked.
hey <@!856894333180706876> , any ideas here? and/or best ways to address this?
correct
Thanks - So it allows someone to create/allocate the account on the chain independently but then the instruction with `#[account(zero)]` can guarantee that it has not been used?  Does this also mean the discriminator will then be set by an an instruction with `#[account(zero)]` even if the instruction does not mutate the account?
hey all, program_id question.

i cloned a repo containing an Anchor program from github (my own).

i `solana-test-validator -r` then `anchor deploy`.

the latter computes my `program_id`.

this `program_id` does *not* match that which i have in my repo's Anchor.toml nor in its `declare_id!` call (which is the program_id that was computed when i initially built this code locally, when writing it).

why might this be?
if you create an account in the previous instruction instead of creating it within the program via CPI
```#[account(zero)]``` All the docs say is "Checks the account discriminator is zero."  I see it used in the examples but can't figure out it's purpose.  Why/when would you ever want the discriminator to be zero?
<@!594851438560149505> <@!347689664855015424> thanks for the support
Hello , Im junior willing to work 7/24 on angular,react,vue . Need some salary for food seriously.
i forgot mut
Oh and this page: https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html  has unblocked me a few times.  It's only linked to in a spot at the bottom of a page of the docs.
I second that the tests directory is an invaluable resource, but there's a bit of a tradeoff in it.  It's vast, but the style and technics across the different examples are not consistent so I've spent a lot of time trying to figure out what the current / best way to do things is.  (I'm guessing that the older projects in there have not been reevaluated  as Anchor has evolved.)  For example, I had a hell of a time trying to track down the best way to deal with Tokens, and I'm still struggling to get something minted.  There's three or so projects: CFO, token-proxy, and, "misc."  The funny thing is that my current guess at the best way to handle tokens is in misc/context.rs which I just stumbled upon, and the javascript code exercising it is thin.
I updated to 1.8.13 via curl and was able to run with that (also on a mac)
Again I had the same issue where it said 1.7.15 was the latest compatible despite there being much newer versions available
i'm going to try to download 1.9.5 with curl
is this right? says solana cli 1.7 wtf
btw would anyone know why in macos im asked for permission to run almost any command, i have to use sudo all the time now, it used to not be like that
downloading an update
lol
Yeah, think that solana is too old

I had a similar issue when I first was setting up Anchor, and it was because my solana tools were too old
What version of the solana tools do you have installed?
anyone know why I get this error when i run
`anchor build`
Oh neat, didn't realize there were so many more examples, thanks!
Now you have some "global" state living at an account whose address is program-derived with seeds = "whatever".
But the basic idea is just to do something like
```.rs
#[derive(Accounts)]
pub struct YourInstruction<'info> {
  #[account(
      init,
      payer=somebody,
      seeds=[b"whatever"],
      bump,
      space=8 + ...,
  )]
  pub global_state: Account<'info, YourGlobalState>,
  ...
}
```
Have you tried looking in the tests/ directory? Lots more examples in there
Hi, quick beginner question. I was planning to use `#[state]` to store some "global" state for my program, but just got the warning that it is deprecated and will be removed soon. The deprecation message says `Use a PDA with static seeds instead`, but is there some example somewhere of how to create PDAs in anchor with static seeds? I don't think creating/using PDAs are covered in any of the Anchor basic examples in the repo
ohh right, I ended up just catching the error and skipping for those kind of accounts. As it is to do a token airdrop, so prob don't want those accounts getting tokens anyway!
Ah, I see—yeah, by default associated token addresses (the js part anyway) don't work with pdas, but there's an optional argument to say "don't worry, I know what I'm doing"
Trying to run the Token.getAssociatedTokenAddress function on JS. 

That account appears to be an escrow account for Solsea NFT Marketplace as best as I can tell..thats why I thought that maybe I couldn't generate an Associated Token Address for a PDA account?
what's the command to update `solana cli` and `spl-token` to the latest stable version ?
This is the full error

/Users/wally/repos/metaboss/node_modules/@solana/spl-token/lib/index.cjs.js:1747
      throw new Error(`Owner cannot sign: ${owner.toString()}`);
            ^

Error: Owner cannot sign: 8y2DF8mAmgNqPsJWBFHS7zGLPHz43PcEwKCK2Tj47d5m
    at Function.getAssociatedTokenAddress (/Users/wally/repos/metaboss/node_modules/@solana/spl-token/lib/index.cjs.js:1747:13)
Any way to get list of "mut" accounts as input of an instruction? Can we use remaining_accounts as mut?

Looked at the source, it could be, depending on how we pass them in input.
found the fix. embarassing. Make sure your context is the same as your instruction's name not the Accounts name

happens whenever I run 'anchor build'
Sorry if wrong channel
Not sure why I'm getting this error. Was there a change ?

I have a question about paulx's escrow program. I think this program is just for 1 trade, 

it is not possible to make multiple escrows open like
Alice - Bob
Alice - Mark
John - Mike

etc. 

Because there is only one pda account, am I right?
I know it's been a few days, but could you please share what solved your problem? I'm running into the same issue 🙂
Pretty much, but you just don't get any return data. All programs can receive instructions from clients, or other programs. The difficult part can be creating the instruction properly before you send it, especially if they aren't open source where you can see what data and accounts the instruction needs.
web2 analogy time: so are CPIs like API calls to another service or something?
where can I check this?
which is quite annoying
So option breaks it
you can just annotate the struct with Default and not use `space` and anchor will try to infer but it also only works if your default instances == max size
this is not always true. e.g. if the struct has options
whenever I create an account, do I need to add any additional (8) bytes the the space definition? Specifically, in the as below, should it be
```
    #[account(
        init,
        payer = initializer,
        space = 64,
        seeds = [bond_pool_account.key().as_ref()],
        bump = _bump_tvl_account
    )]
    pub tvl_account: Account<'info, TvlInfoAccount>, 
```

or
``` 
    #[account(
        init,
        payer = initializer,
        space = 8 + 64,
        seeds = [bond_pool_account.key().as_ref()],
        bump = _bump_tvl_account
    )]
    pub tvl_account: Account<'info, TvlInfoAccount>,
```

assuming that `TvlInfoAccount` only holds one u64 in it's account defition?
Found issue .. didn't source my profile v beginner 😆 thanks anyways
std::mem::size_of::<User>()
Hi,
Is there a way to automatically deduce the space of a struct?

```rust
    #[account(init, payer = author, space = User::LEN)]
    pub user: Account<'info, User>,
```
Here I need to `implement` by myself the LEN method of User struct.
Does Anchor provide a shorthand for this?
I tried using init_if_needed but I couldn't find the right stuff to make it work
What's the easiest way to remedy this?

but I used a tool called draffle to delete my unused accounts...
so now it cant send back bc
and just doing an spl token transfer

Okay funny scenario. 
I sent my solana program an nft. 
nomrally I could get it back using
😉
Rust is a multiplayer survival game
hi, what's rust?
haha I knew it was something simple. Thanks
yournumber as u64
Hey how can I get a `u8` into a `u64`?
is the answer.  took me an hour to figure it out.
```
export function u64ToSeed(num: BN) {
    return num.toBuffer('le', 8);
}
```
That PDA is not matching between javascript and rust.   Any idea on how to add a u64 to a seed in javascript?
```
  //word_index is a u64
 #[account(
        init,
        seeds = [PDA_SEED_MINT, game.key().as_ref(), &word_index.to_le_bytes()],
        bump = mint_bump,
        payer = user,
        mint::decimals = 0,
        mint::authority = game,
        mint::freeze_authority = game
    )]
    mint: Account<'info, Mint>,

 ///Javascript
  const [publicKey, bump] = findProgramAddressSync(
        [Buffer.from(PDA_SEED_MINT), gameAccountPda.publicKey.toBuffer(), new BN(wordSlotIndex).toBuffer()],
        program.programId
    );
```
Very beginner question: If an instruction returns an `Err` no state changes are persisted, correct?
wish i did
Refactored a bit and got it built - test failing but progress at least
```rust
pub mod demo06 {
    use super::*;
    use solana_program::native_token::{lamports_to_sol, LAMPORTS_PER_SOL};
    use solana_program::system_instruction::transfer;
    pub fn initialize(ctx: Context<Create>, lamports_in: u64) -> ProgramResult {
        let authority_account = &mut ctx.accounts.authority;
        let deposit_account = &mut ctx.accounts.deposit_account;
        let lamports_to_deposit = lamports_in * LAMPORTS_PER_SOL;

        msg!("force git");

        let account_infos = [
            authority_account.to_account_info(),
            deposit_account.to_account_info(),
        ];

        let tx = transfer(
            authority_account.key,
            deposit_account.key,
            lamports_to_deposit,
        );
        solana_program::program::invoke(&tx, &account_infos);

        Ok(())
    }
}

#[derive(Accounts)]
pub struct Create<'info> {
    #[account(init, payer=authority, space=8+32+32)]
    program_account: Account<'info, CreateAccount>,
    #[account(init, payer=authority, space=8)]
    deposit_account: AccountInfo<'info>,
    #[account(mut)]
    authority: Signer<'info>,
    system_program: Program<'info, System>,
}

#[account]
pub struct CreateAccount {
    program_account: Pubkey,
    authority: Pubkey,
}
```
The issue I have before the build will pass is 
```rust
let account_infos = [
            authority_account.to_account_info(), //from
            deposit_account,                     //to
        ];
```
How to go from a `Pubkey` to `AccountInfo` as required by the `invoke()` call
<@!134416332509675520> So I have something more simplified now
```rust
pub mod demo06 {
    use super::*;
    use solana_program::native_token::{lamports_to_sol, LAMPORTS_PER_SOL};
    use solana_program::system_instruction::transfer;
    pub fn initialize(ctx: Context<Create>, lamports_in: u64) -> ProgramResult {
        let program_account = &mut ctx.accounts.program_account;
        let authority_account = &mut ctx.accounts.authority;
        let system_account = &mut ctx.accounts.system_program;
        let deposit_account = &mut ctx.accounts.program_account.deposit_account;
        let lamports_to_deposit = lamports_in * LAMPORTS_PER_SOL;

        let account_infos = [
            authority_account.to_account_info(), //from
            deposit_account,                     //to
        ];

        let tx = transfer(authority_account.key, deposit_account, lamports_to_deposit);
        solana_program::program::invoke(&tx, &account_infos);

        Ok(())
    }
}

#[derive(Accounts)]
pub struct Create<'info> {
    #[account(init, payer=authority, space=8+32+32)]
    program_account: Account<'info, CreateAccount>,
    #[account(mut)]
    authority: Signer<'info>,
    system_program: Program<'info, System>,
}

#[account]
pub struct CreateAccount {
    program_account: Pubkey,
    authority: Pubkey,
    deposit_account: Pubkey,
}
```
thanks for taking a look, will refactor and see how it goes - appreciate it so much!
I think in my demo05 I had it as you suggested but took this approach as I wanted some code separation blah blah
That's probably the real intent, but as I was working this out in my head and trying to separate it out logically it seems to have made sense (clearly not!)
Are you sure you don't just want to pay `test_deposit_account.key()`?
I don't know why you want to use these inner fields at all haha
You then try to pay one of its un-set fields, which gives you the error you're getting
I'm saying that what you're doing right now is creating an account at `testDepositAccount` (so far so good), but then you never actually set any of its fields
If you really want to set it you need to set it in *rust*
Nope—forget the inner `depositAccount` thing, I'm not sure what you're trying to do with it
As for the storage bit, I am learning as I go...
so something like 
```rust
      accounts: {
        programAccount: programAccount.publicKey,
        testDepositAccount: {
          depositAccount: depositAccount.publicKey,
        },
        authority: authority.publicKey,
        systemProgram: anchor.web3.SystemProgram.programId
      },
      signers: [depositAccount, programAccount]
```
?
(I'm actually not sure what you're intending to do with those fields, e.g. why you have a `lamports: u64` in there—you don't need to store that yourself, solana does that for you)
So the test_deposit_account itself is initialized, but not its data (the `DepositAccount` struct)
You never actually give it a value (so it's zeroed out)
No, I'm saying that `test_deposit_account.deposit_account`, the inner `deposit_account` field, is never set
I am marking this as `init` - is this method to initialize wrong?
```rust
    #[account(init, payer=authority, space=8+32+8)]
    test_deposit_account: Account<'info, DepositAccount>,
```
You're paying `&test_deposit_account.deposit_account` (which is uninitialized), rather than, I don't know, `test_deposit_account.key()` or something
In the test I generated all new keys and pushed them to the rust program
so where in the code I am screwing up ?
Anyone know is the easiest way to get the minimum balance for rent exemption for a given account from inside a rust program?
Aka the system program
Ah, because you never actually set the destination account—so it defaults to the zero pubkey
hi, did you find any solution on this? need help about same thing.
latest with the sys program removed from the infos array
https://github.com/sparkydasrath/rust/tree/main/anchor/demo06
Is this on github?
Hmm, not sure why actually you're inadvertently trying to mutate the system program
removed and rebuilt - but same error (didn't expect this to have fixed it right off the bat)
One, don't need to pass the system program in that `account_infos` list
```typescript
const provider = anchor.Provider.env();
anchor.setProvider(provider);
const idl = JSON.parse(readFileSync("./target/idl/demo06.json", "utf8"));
const program = anchor.workspace.Demo06 as Program<Demo06>;

// obviously not the best way to set this up...
const programAccount = anchor.web3.Keypair.generate();
const authority = provider.wallet;
const depositAccount = anchor.web3.Keypair.generate();

async function getBalance(pubkey: anchor.web3.PublicKey, accountName: string) {
  let balance = await provider.connection.getBalance(pubkey);
  console.log(`Balance of ${accountName} account is ${balance}`);
}

describe('demo06', () => {
  it('Is Created', async () => {
    console.log("STARTING TEST\n")
    console.log("Balance before creation\n");
    await getAllAccountBalance();

    console.log("Starting account creation and deposit...\n");

    // add some SOL to the authority/wallet
    await airDrop(authority.publicKey, 2.5);

    // send instruction to smart contract
    const tx = await program.rpc.initialize(new BN(1.3), {
      accounts:{
        programAccount: programAccount.publicKey,
        testDepositAccount: depositAccount.publicKey,
        authority: authority.publicKey,
        systemProgram:anchor.web3.SystemProgram.programId
      },
      signers:[depositAccount, programAccount]
    });
    console.log("Your transaction signature", tx);

    // verify the program account was created on the blockchain
    let pgAccount = await program.account.programAccount.fetch(programAccount.publicKey);
    console.log(`Program account on chain ${pgAccount}\n`);
    console.log("Balance After creation\n");
    await getAllAccountBalance();
    console.log("END TEST")
  });
});
```
Aka the system program
```rust
declare_id!("BnHgqQKV6rjcJ371tkzHkjWJsEPQXt53hH84tWmqBEjZ");

#[program]
pub mod demo06 {
    use super::*;
    use solana_program::native_token::{lamports_to_sol, LAMPORTS_PER_SOL};
    use solana_program::system_instruction::transfer;
    pub fn initialize(ctx: Context<Create>, lamports_in: u64) -> ProgramResult {
        let program_account = &mut ctx.accounts.program_account;
        let authority_account = &mut ctx.accounts.authority;
        let system_account = &mut ctx.accounts.system_program;
        let test_deposit_account = &mut ctx.accounts.test_deposit_account;
        test_deposit_account.lamports = lamports_in * LAMPORTS_PER_SOL;

        let account_infos = [
            authority_account.to_account_info(),
            test_deposit_account.to_account_info(),
            system_account.to_account_info(),
        ];

        let tx = transfer(
            authority_account.key,
            &test_deposit_account.deposit_account,
            test_deposit_account.lamports,
        );
        solana_program::program::invoke(&tx, &account_infos);
        Ok(())
    }
}
#[derive(Accounts)]
pub struct Create<'info> {
    #[account(init, payer=authority, space=8+32+32)]
    program_account: Account<'info, CreateAccount>,
    #[account(init, payer=authority, space=8+32+8)]
    test_deposit_account: Account<'info, DepositAccount>,
    #[account(mut)]
    authority: Signer<'info>,
    system_program: Program<'info, System>,
}
#[account]
pub struct CreateAccount {
    program_account: Pubkey,
    authority: Pubkey,
}
#[account]
pub struct DepositAccount {
    deposit_account: Pubkey,
    lamports: u64,
}
```
1 is actually 0 in base58 (lol, confusing), so that's the all-zero public key
Or something, not sure
what does that 111 mean
You're somehow passing the wrong account in your CPI
So that's weird, you definitely can't mutate the system program 😛
`11111111111111111111111111111111's writable privilege escalated
`
all good - just appreciate you taking the time to help
```
Balance of Program Account account is 0
Balance of Authority/Wallet Account account is 500000000000000000
Balance of Deposit Account account is 0
Starting account creation and deposit...

Airdropping 2.5 lamports to UseAccount/Wallet 4oDmbjZsYoAcP9L3LLnGQcKMCZBXESt7npAAYAeCr94v
Airdropped signature [object Object]
Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account
Program BnHgqQKV6rjcJ371tkzHkjWJsEPQXt53hH84tWmqBEjZ invoke [1]
Program log: Instruction: Initialize
Program 11111111111111111111111111111111 invoke [2]
Program 11111111111111111111111111111111 success
Program 11111111111111111111111111111111 invoke [2]
Program 11111111111111111111111111111111 success
11111111111111111111111111111111's writable privilege escalated
Program BnHgqQKV6rjcJ371tkzHkjWJsEPQXt53hH84tWmqBEjZ consumed 18442 of 200000 compute units
Program BnHgqQKV6rjcJ371tkzHkjWJsEPQXt53hH84tWmqBEjZ failed: Cross-program invocation with unauthorized signer or writable account
```
Sorry, wasn't clear about that ^
Not in the `.anchor` directory, just like in the anchor test output in your terminal
Need to post the entire program log (how are you running this? via the tests? they ought to just print)
a fave of a few folks `Program BnHgqQKV6rjcJ371tkzHkjWJsEPQXt53hH84tWmqBEjZ failed: Cross-program invocation with unauthorized signer or writable account`
Which error?
<@!134416332509675520> based on the code and similar error I posted above, I am looking at the `.anchor\test-ledger\validator.log` but mine does not show any error messages just a few `warn` on start up and all `info` after...
You're either not signing for something correctly, or you've forgotten to mark one of the accounts as mut (the full program log will tell you)
(Need to sticky this) it helps to post the *full* program log (it will actually tell you what's going wrong here—there will be additional information)
I am getting the same. I posted some of my code earlier in the thread, how closely does yours match?
Hmm, good question, I'm not sure how they do that
Don't feel bad! I'm not very familiar with metaplex so I'm actually not sure the best way to find a given nft account 🤔
Gotcha thanks, any idea how the invictus rebasing works? According to the UI i am gaining new rebase tokens each second. Is a crank triggering that constantly?
Yeah, no way to do it on-chain, have to have some external program do the chron-ing
any clever ways to run a cron on chain? How do people give out rebase rewards on a schedule, with a crank?
Getting "Cross-program invocation with unauthorized signer or writable account" error, do anybody have ideas what might be the cause?
Hey guys
feel extremely embarrassed and ashamed, but would you please sharing some example on how this can be achieved?
anyone have an example of using serum dex with anchor? set up new market, make orders, check order book, etc.
Hey what does the --provider.wallet argument expect in the anchor CLI ? A path to a keypair? I can't seem to get it to work
Right. The client would have to just pass in the right token account
mmm… would you mind elaborating especially with proof? Checking through all 10k NFT, for example, is too computationally heavy right?
Yep, you'd have to have the client pass in proof (a token account with the right kind of nft mint, amount = 1, owner = the wallet, etc.)
hi all! is there any way to condition the program so it only executes if the wallet connected has one of NFT collection?


//////////////////////////////////////////////////////////////////////////////////////////

check the `account_info.data.borrow().len()`
Whats the best way to check account data size? To prevent it from exceeding 10 mb
just to make sure, with find_program_address.. it iterate an array of bumps from 255 to 0  and return the first valid pda right... meaning wherever i call find_program_address i would get the same pda and bump as long as i provide the same seeds and program_id?
thanks
i got it to work like this
u r right
So unless `ctx.program_id` is the exact same address as that "G1D..." thing, there's no reason to expect both lines above to work
Is that hardcoded program_id your actual program id? In general it's possible for `create_program_address` to fail (usually you have to pass an explicit bump calculated by `find_program_address`)
Those are actually the same type, so don't think that's your problem above
i noticed `ctx.program_id` belongs to `solana_program::pubkey::Pubkey` while `program_id` is `anchor_lang::prelude::Pubkey`
i am trying to have a program function that generates a bunch of account with PDA, the first line using `&ctx.program_id` doesn't works... but the second & third lines works.... is there a way to make it work?
thanks a lot
https://docs.rs/anchor-lang/latest/anchor_lang/context/struct.Context.html#structfield.program_id
wow cool thanks
`ctx.program_id`
any method to access the programId inside a program function?
Hey everyone,
do we have any example of anchor used in react ts project? I want to look and get some ideas (specially about subscribing to changes...)
how i can fix this error Cross-program invocation with unauthorized signer or writable account
Let me know if you need help implementing
Right, so I got this working but had to use typescript instead of JS
hi, how can i add arguments in anchor instruction without breaking js client? for example

pub mod my_program {
    use super::*;

    pub fn create(ctx: Context<Create>)

}
into:

pub mod my_program {
    use super::*;

    pub fn create(ctx: Context<Create>, amount: u64)

}

But have old ui app working with new instruction (new fields just appended)
This is a bit of an OMG for anyone else that runs into it:  If you see an `owner`  pubkey set to 0 after you call getAccountInfo... that's actually is 11111111111111111111111111111111  in base58.  Lost so much time to this. 
```
console.log('after airdrop', (await provider.connection.getAccountInfo(user.publicKey, 'confirmed')).owner);        
console.log('after airdrop', (await provider.connection.getAccountInfo(user.publicKey, 'confirmed')).owner.toBase58());
```
results in 
```
after airdrop PublicKey { _bn: <BN: 0> }
after airdrop 11111111111111111111111111111111
```
Stuck on the same thing, how do you generate a provider from a local keypair
hi all, sorry if this has been asked before. Is it possible in a client to use anchor to get values  returned by a function in an on-chain program? ie a simple 'getter function' on-chain that returns a string, then using anchor we get the value of the string? Or do we have to go down the route of writing to an account and reading from the account, as per this post https://discord.com/channels/889577356681945098/889702325231427584/933321451119968256

The only other solution I've found is to use events and simulate the tx which seems a bit too  complex and messy
And that gives me this error

const provider = anchor.Provider.env()
                                 ^

TypeError: Cannot read properties of undefined (reading 'env')
For reference, I am trying to access this in a nodeJS script. So if I wanted to make my own provider from scratch with a connection and a wallet, how would I do it? I tried the following:

const provider = anchor.Provider.env()

Passing in the environment variable to the command line as so:

ANCHOR_WALLET=... ANCHOR_PROVIDER_URL=... node script.js --provider.cluster mainnet
No matter what I do though, I cannot verify the owner of any account to print the system account through web3.  ` console.log(await program.provider.connection.getAccountInfo(provider.wallet.publicKey, 'confirmed'));`  always shows an owner of 0
Ugh.  Here's a big pain that explains a lot. I just realized that the accounts I've been using in my tests aren't full system accounts even though I aidropped to them.  They are owned by Pubkey: 0 not '1111111111'
Hi Guys... I am trying to create a Solana account in which I want to use a struct inside a struct. For example, there is an employee struct with name & age details and now I want to use an array of employees in #[account] of the company that will have other fields also.  I am facing a few problems like the default is not implemented. Any idea how I can do it.
Awh man i already read those, but i can't wrap my head around it because there isn't enough details.

for example, i've seen this crate used in candy_machine `mpl_token_metadata` extensively and the documentation is underwhelming
Well I just learned you can use custom errors with constraints too 🤯
https://project-serum.github.io/anchor/tutorials/tutorial-1.html#defining-a-program
https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html
you'd need to use `anchor.local()` or `anchor.env()`
its not a constructor, you cant user the `new <x>` syntax
I use seeds and bump there to verify the vault_access account passed in is the correct PDA. Look into program derived address's. https://docs.solana.com/developing/programming-model/calling-between-programs#program-derived-addresses
https://paulx.dev/blog/2021/01/14/programming-on-solana-an-introduction/#processor-part-2-pdas-part-2-cpis-part-1
Hey, i'm struggling to understand the Rust program flow,
`#[account]` and `#[derive(Accounts)]` to be specific.

any resources or explanation would be appreciated
what is this error Error: 102: The program could not deserialize the given instruction
Anyone got any ideas ?
The error being :

const provider = new anchor.Provider(solConnection, walletWrapper, {
                 ^

TypeError: anchor.Provider is not a constructor
Trying to run this in order to get some data from an account that was made by my program. But I am getting an error
Also, what would be the maximum amount of pubkey I could store in an account, and what would be the best way to store it there? For example, would I need to loop through and store a small amount in a bunch of small transactions, or would I be able to store it all in one big hit?
Hey there, I'm trying to store Vec<Pubkey> in an account on initialize method. I'm getting the error: "RangeError: encoding overruns Buffer". Can anyone help me out with this?
are there any solana programs that use zero knowledge proofs?
im doing transfers and then close, which seems to be throwing off something in solana
How do I close an account without running into `sum of account balances before and after instruction do not match`
I'd like to ensure that another account does **not** exist and fail the transaction if it does. Can't find a constraint that will do this type of check.
Whats an easy way to create and seed multiple wallets for an `anchor test`
Well I found my bug 😅 

Authority was set wrong in the transaction. Instead of market i should've set it to the pda itself.
```js
    console.log(marketSigner)
    console.log((await mintBase.getAccountInfo(lexBaseVault)).owner)
    console.log(signerBump)
    console.log((await program.account.lexMarket.fetch(lexMarket.publicKey)).signerBump)
```
Verified and owner is what i set and bump is also set correctly. So then what's the problem?
I don't think so.
Market and lexmarket are the same

Pda is program Id | market | signer_bump
(in initialization I set the signer_bump that I generated)

Data passed:
```js
    await program.rpc.withdraw(bobBump, new anchor.BN(10), {
      accounts: {
        owner: bob.publicKey,
        userAccount: bobUserAccount,
        market: lexMarket.publicKey,
        vault: lexBaseVault,
        tokenDest: bobAccountBase,
        priceOracle: stubPriceOracle.publicKey,
        tokenProgram: spl_token.TOKEN_PROGRAM_ID
      },
      signers: [bob]
    })
```
Doesn't seem like you're using the same seed setup between JS and rust (bad)
Looks like the `market`'s seeds are based on `lexMarket`'s key, but in the CPI above you're reusing `market`'s own address, right? `market.key()`
`8Gmnzgn2QbgXVAGHwx4pSAiQfECMdX7P71VUm9cP91Tx's signer privilege escalated`

It's signer I believe. But i don't understand why
Try looking at the full program log—it will tell you whether you forgot to mark an account as mut (both token accounts will need to be mut), or if you're signing incorrectly
I created a normal one but my program gives error:

```rust
    transfer(
        CpiContext::new_with_signer(
            ctx.accounts.token_program.to_account_info(),
            Transfer {
                from: ctx.accounts.vault.to_account_info(),
                to: ctx.accounts.token_dest.to_account_info(),
                authority: ctx.accounts.market.to_account_info(),
            },
            &[&[&ctx.accounts.market.key().to_bytes(), &[market.signer_bump]]]
        ),
        amount,
    )?;
```

and i created the vault like this:
```ts
    [marketSigner, signerBump] = await anchor.web3.PublicKey.findProgramAddress([lexMarket.publicKey.toBuffer()], program.programId)
    lexBaseVault = await mintBase.createAccount(marketSigner); // TODO: Investigate why associated token account didn't work
```

(famous Cross-program invocation with unauthorized signer or writable account)
anyone knows how to create associated token account for an pda owner with spl-token on JS?
what is bump?

how to learn about bump? 

what does those lines mean:

https://github.com/Kriptikz/anchor-token-vault/blob/master/programs/anchor-token-vault/src/lib.rs


why we use "seeds" and "bump" here?


//////////////////////////////////////////////////////////////////////////////////////////

you don't have too do all of the steps you mentioned above when you're testing. You can keep the validator off and just run `anchor test`. this command creates its own local validator, builds the program, deploys to the pre-created validator and runs the test suite
do I have to restart the solana validator after deploying?
thanks ace... did it but am getting the same result
i use the same environment
deploy the program to localnet using `anchor deploy`
btw... am using WSL2 in W11
Im testing on devnet atm, but will prolly deploy to mainnet when its ready
hey guys, new to Solana and Anchor
am trying to run a simple test example and am getting the error following:

--------------
mysolanaapp
Transaction simulation failed: Attempt to load a program that does not exist

    1) Is initialized!


  0 passing (41ms)
  1 failing

  1) mysolanaapp
       Is initialized!:
     Error: failed to send transaction: Transaction simulation failed: Attempt to load a program that does not exist
      at Connection.sendEncodedTransaction (node_modules/@solana/web3.js/lib/index.cjs.js:6634:13)
      at processTicksAndRejections (internal/process/task_queues.js:95:5)
      at async Connection.sendRawTransaction (node_modules/@solana/web3.js/lib/index.cjs.js:6593:20)
      at async sendAndConfirmRawTransaction (node_modules/@solana/web3.js/lib/index.cjs.js:8589:21)
      at async Provider.send (node_modules/@project-serum/anchor/dist/cjs/provider.js:90:22)
      at async Object.rpc [as initialize] (node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:31:31)
      at async Context.<anonymous> (tests/mysolanaapp.js:11:16)


error Command failed with exit code 1.
--------------


In order to get to this I've installed every dependency and I've run:
1. anchor build
2. solana program deploy <PATH>
3. Get the ProgramID and set it into my function
4. anchor test

and the error above is displayed.
Can anyone help me figuring out what's going on?
Thanks
ohhhhh lol now the error makes sense
oh nice, are you doing something on mainnet ?
so, are all program accounts rent-exempt?
So you'll have to pick a new one I'm afraid
If I'm understanding your question right, once you create a program account, you can't really delete it (you can close the accounts that hold the program code, but not the actual account whose address is the program_id)
so, I'll leave that there and wish you luck
yeah, i think so too. But it might be possible that you uploaded the program marking it as non-upgradable and now it wants to "upgrade" it but can't. Take that with a grain of salt tho, I'm past the knowledge stage of debugging and am now in gut-feeling mode
nvm, those are 2 separate instructions
Lol i think that is statically impossible - however, I’ll keep running it. I’ll be back in a couple of hours
https://github.com/solana-labs/solana-program-library/blob/master/token/program/src/processor.rs#L739
Since you never initialized it
That error is saying that the wrapped sol account isn't actually a token account
you are calling sys prgm with token prgm id
Ah, ok, got it
Oh wait maybe I need to initialize the account first
I'm following the solana cookbook: https://solanacookbook.com/references/token.html#wrapped-sol
```
     Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 1: incorrect program id for instruction

Transaction simulation failed: Error processing Instruction 1: incorrect program id for instruction
    Program 11111111111111111111111111111111 invoke [1]
    Program 11111111111111111111111111111111 success
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [1]
    Program log: Instruction: SyncNative
    Program log: Error: IncorrectProgramId
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 783 of 200000 compute units
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA failed: incorrect program id for instruction
    1) Is initialized!
```
Can you print the full error log?
Why are you making a token instruction from scratch like that, rather than using a helper method?
im trying to transfer my lamports into a wSOL TokenAccount
```
let tx = new Transaction().add(
      // trasnfer SOL
      SystemProgram.transfer({
        fromPubkey: alice.publicKey,
        toPubkey: wSolAccount.publicKey,
        lamports: amount,
      }),
      new TransactionInstruction({
        keys: [
          {
            pubkey: wSolAccount.publicKey,
            isSigner: false,
            isWritable: true,
          },
        ],
        data: Buffer.from(new Uint8Array([17])),
        programId: TOKEN_PROGRAM_ID,
      })
    );
```

Anyone know why this is telling me I have the wrong programId?
brutalllll
Unless the lending protocol gives you some help doing that, then yeah, you'd have to do it yourself I guess. Or maybe you could clone some existing accounts from mainnet?
That's how I would imagine you'd need to do things, yeah 😬
I'm having trouble writing tests for my anchor program because it integrates with a lending protocol. I want to write an e2e integration test, but that would require me to create a new mint, new lending market, and two new oracles. Am I doing this wrong? Is there a simpler approach?
And if the mint lives at one of your own derived addresses, then your own program can sign for that address (that's how PDAs work).
Yep, totally fine to do that
I was trying to think of a way to be able to know where a `Mint` account lives only knowing my program ID and a user's pubkey, but I'm not super sure that it makes sense (and what happens when/if I need the mint account to sign a transaction I wonder...)
Is it possible/does it make sense for a `Mint` account to live at a PDA?
just for fun you might check that the program id you are using doesn't exist already, although i don't know if that is possible
it's weird that it runs on devnet but not mainnet
yeah, that's what i meant. I don't think that's your problem since I think you did it right
No, but I did, recreate the deploy/project-keypair.json and copy pasted that address in the Anchor.toml and lib.rs - is that what we’re talking about?
I was but I also go it working. I didn't need to use typescript tho
did you check the program id with `anchor keys list`?
Another question: I just started to deploy my first program on mainnet with anchor, and it failed a couple of times, I closed the accounts and got my sol back. Great! But now I'm trying it again and I got this error :

Using: anchor deploy

`Error: Deploying program failed: Error processing Instruction 1: custom program error: 0x1
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.`

I then tried: solana deploy [key] [project.so]

`Error: Deploying program failed: Error processing Instruction 1: custom program error: 0x1` 

It passes all of the tests on devnet. Any thoughts? Or keep trying?
Yay! Thank you guys, that makes sense!
re 3) you cant get an AccountInfo from a static Pubkey but you can check that an incoming AccountInfo.key == static Pubkey
1. yes i think rent exemption fee is covered in the deployment fee
2. yes a pda needs someone to pay its rent
3. unfortunately i dont think this is possible in the solana model - you would need to pass the accountinfo from the client every time. cant just store a pubkey and send lamports to it bc solana needs to know what accounts are involved in every tx for parallelization reasons i think
Hey <@!134416332509675520>, I'm having troubles writing tests for my anchor program because it integrates with a lending protocol. I want to write an e2e integration test, but that would require me to create a new mint, new lending market, and two new oracles. Am I doing this wrong? Is there a simpler approach?
In the solana docs `Currently, all new accounts are required to be rent-exempt.`  so I'm assuming that means, when I deploy a program or spin up a PDA, the fees associated are it's 2year rent. Can anyone confirm?
Yeah I did in the end, but I had to do it in TypeScript. Were you having a similar issue_
Hi all! new here! 

A couple questions:

1. Does a program need to pay rent? Or is this covered in the deployment fee? (I'm using Anchor)
2. Does a PDA need to pay rent? Or is it exempt from the creation cost? (I'm using Anchor)
3. Is there a way to to send sol to a PubKey statically defined in the rust program? IE every-time lamports are transfered within a function, some are sent to a static address? (I would need a way to derive an AccountInfo from a Pubkey for this to work)
apart from that, i don't think it changes things much
well, you don't have infinite heap either
are there any drawbacks to using the `Box` type? it seems to magically solve my stack problems and i dont trust it lol
ref: https://docs.rs/anchor-lang/0.20.1/anchor_lang/accounts/boxed/index.html
that actually makes more sense, they probably didn't care to make it rent excempt
yeah, ok, wondered if it wasnt rent exempt, or more likely overwitten with null
maybe they 'upgraded' to an empty program? or maybe devnet gets emptied every once in a while
well, I thought not. but from what you are saying it sure seems like it
ok, wasnt specifically confused, more I didnt realise that the program used to be there, but has seemingly gone some time in last 20 days.  Can programs be deleted pls ?
ok, excellent, thank you. Prob more involved (ie setting up all the stuff the program needs), but def worth knowing for my next challenges
so yeah, i think you should be able to deploy it as usual
I've never done it before, but that file should be the compiled binary
you can download from sol explorer, go to the "Executable data" account and you can see the size with a download button
and then write it out to file and then solana deploy ?
?
so would that be connection.getProgramAccount(mainNetAccountId) to get the data
didnt know you could do that
ohhh... v nice !
if you wanna test that program you can try downloading the program data and uploading it to a local net
i checked testnet, and it's not there either
yeah, I think its on testnet. I got confused.... apologies for time wasted
that program doesn't show up on devnet, it does show up on mainnet tho
actually maybe I made a mistake 🙂
lol
9W959DqEETiGZocYWCQPaJ6sBmUzgfxXfqGeTEdp3aQP on devnet (orca program)
check on Solana Explorer, put in the program id you are using and check if it says it's executable
cant find where its thrown from unfortunately
I'm currently trying to find where it throws not executable . Also I'm comfortable calling `invoke` from in the program
yes indeed I did sir - thats where it first complained that its not executable
that or check if the program has a crate or IDL you can include in your project
have you tried accepting the program as an AccountInfo? You'd have to call the instruction manually tho
how much does it cost in SOL to create a new token account?
or alternatively some default program type I  can pass maybe ?
is there a constraint or something I can use to mark the address as executable without using `Program` please ?
I started setting the field to be Program<'info, <type>> - but I dont know what type should be, since its not an anchor program
hi, I'm trying to do CPI to a non anchor program, but getting `Account is not executable` and `instruction expected an executable account`
thanks for answering, I got it
If it is a PDA then you can't change its ownership
if it's not a TokenAccount, then it doesn't have an 'authority' field, unless you give it one
what do you mean custom account?
yeah, I mean set authority for custom account, maybe you know how to do it?
nvm its in the anchor toml file, the location of they wallet keypair
how does anchor deployment work lets say i wanna deploy to a testnet how do i provide a wallet account which will be the payer ?
technically the owner of a token account is always SystemProgram, but the authority is what you probably want to change, it refers to the effective token owner.
Hi, all. For token accounts, there is a method to set authority using token::set_authority, are there some way to set the owner for a custom account?
Account 3augRY5ZUQkhdUqfy4576rehusncZfn7TXN2udbBd1Ek is not an upgradeable program or already in use what am i doing wrong ?
that fixed it, thanks for making me look there
okay... nvm I just don't know how to spell 'prize' correctly, the prize_id I'm passing to the instruction is 'first-price' 🤦‍♂️
```typescript
    const [tokenPDA, bump] =
      await anchor.web3.PublicKey.findProgramAddress(
        [Buffer.from("oyga-giveaway-prize-holder"), Buffer.from(drawId), Buffer.from("first-prize")],
        program.programId
      );
```
how are you deriving the PDA in the client?
I'm not sure I understand what it means
Hey everyone, I have a frustrating error I don't even understand how it's possible. I have an instruction which should create a PDA and an associated token account (for a given mint). The associated token account must be owner by the PDA.

```rust
    #[account(
        init,
        payer = creator,
        associated_token::mint = mint,
        associated_token::authority = creator,
    )]
    pub token_acc: Account<'info, TokenAccount>,

    #[account(
        init,
        payer = creator,
        space = PrizeHolder::get_space(),
        seeds = [
            b"oyga-giveaway-prize-holder",
            draw_id.as_bytes(),
            prize_id.as_bytes(),
        ],
        bump,
    )]
    pub token_holder_pda: Account<'info, TokenHolder>,

    pub mint: Account<'info, Mint>,

    #[account(mut)]
    pub creator: Signer<'info>,
```

This is giving me the following error"
`<PDA>'s signer privilege escalated`
How do i change token decimal to zero
How do i update the anchor cli
The example I'm currently working from, initializes a PDA account for the user then allows them to vote yay or nay. I want to modify this program to accept a custom token as a vote. I've tried looking at a bunch of governance programs at least what I could find and they all seem way too complex for what I'm trying to do. I just want simple atm.
I'm trying to modify a vote program, to require a 1 token = 1 vote but cant seem to wrap my head around the program flow. I'm used to solidity.
Do I have to do these steps every time I change the code in rust? Since after I do anchor build (after changing my rust code), I don't see the new program Id generated, I see the same one as before.
so 
1. anchor build
2. update program ids and declare_id!s (**These two are the same right?)**
3. **anchor build again**
4. anchor deploy?
Step 2 also needs to update the `declare_id!`
Almost—a crucial step you're missing is that you need to *rerun* anchor build before you do `anchor deploy`
I am learning anchor right now, and for deploying a smart contract it seems like the flow is as follows, 
1. anchor build
2. update program ids into the client js side
3. anchor deploy 
4. save the IDL inside the target folder and copy them inside the app folder.
Is this correct?
Sure, go for it!
anyone willing to help me figure a few things out?
Oh nvm its mutable by default
How can I make an account mutable with #[account(init)]? Is it possible?
If rust then a vector should solve this, no?
rust function or js function?
Like I think remaing accounts might solve this but not sure how to use it for this
If they are of the same type
Like not defining the length
Can you pass in an array of accounts to a function ?
Thx
<@!499605357719453736>
`ANCHOR_WALLET="/Users/dg/.config/solana/id.json" ANCHOR_PROVIDER_URL="https://api.devnet.solana.com" ts-node init.ts --provider.cluster devnet`
I got it to work passing in the necessary anchor variables
I think I figured it out
Actually looks like I can simply cast an enum value to a u8
Do you know how I would cast to number? Do I need to implement a method?
Did u get this to work?
+1, I'm trying to do this as well
ah cool, thanks vm
i think the reason behind is that enums in rust could be more complex and have value (for pattern matching). I sometimes stored u8 myself then manually handled it. (you can cast enum to number, but i think reverse doesn't work)
I did it outside useeffect one time and it gave error and now it works! Thanks!
I would also suggest goign through the anchor tests/ directory
I've gone through the Anchor tutorial snippets and did Farza's buildspace course.  Now looking for some more substantial examples or tutorials.  Perhaps with interactions with the SPL and Token library.  Any ideas?
Hi all
I have an enum in my rust like:
```
#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub enum State {
    InActive,
    Active,
    Completed
}
```

And on the JS side I get:
```
{ active: {} }
```
Let me know if an example would help
How do I deserialize enums to something friendly like a number? I get deserialized objects like `state: { active: {} }` thats not really ideal 🤔
Register `onAccountChange` inside a `useEffect` hook and pass `setState` from a `useState` hook to the callback
Anyone knows how we can subscribe change of an account to react hook?
Thank you, for your help 🙂
Yeah
Ah... ok. So, in these cases, it is more like the "first" argument in the Rust def is the same as `self` in a method? Then, in JS the convention is to pass the context (`self`/`this`) as the final argument?
```.js
program.rcp.doSomething(a, b, c, d, {
  accounts: {
    ...
  }
});
```
<@!134416332509675520> Are they always in reverse order? That is, what happens if a method in Rust takes `a, b, c, d` arguments?
They are indeed swapped (it seems weird at first but is in practice much easier to read)
Hello there,
I am a little confused about this in the Anchor API:

It appears the argument positions between the function definition in Rust, and the function call in JS are swapped.
```rust
pub fn method(ctx: Context<MyContext>, arg_2: String) -> ProgramResult {
```
```js
await program.rpc.method("my String", { myContext });
```

Am I missing something? I get an error, when switching the JS arguments to match the Rust def.

_More code can be made available, but this is just coming from the Buildspace Solana, React, Rust Project_
(which does the same)
there's also `account_info.data_len()`  <@!419287884969803776>
Hi all, is it possible to pass a Vec<AccountInfo> or e.g. an array : [AccountInfo; 10] as an argument in a RPC call?
Cheers
Thanks dude 👍


//////////////////////////////////////////////////////////////////////////////////////////

On my react app, I have a keypair for an account my program created that has data. I need that keypair to be static for my site. So I believe I need to hide it.
how can I call a function of a already deployed program? 
Is it done by declaring deployed program's address, like it is done in solidity ?
cool, I'll have a look at those
I think every anchor example + all of the tests/ use JS to interact with the on-chain program, so you can look at those as examples
yes
Not totally sure I understand your question—you mean like using a JS client? That's sending instructions on-chain via the solana rpc infrastructure.
how can we interact with an on-chain program, sending instructions from our off-chain infrastructure?
Hey guys
that was the error. thank you cqfd
```.rs
use anchor_lang::AccountsClose;
account.close(who_to_send_the_lamports_to)?;
```
thanks tho!
ahh hmm sorry im not sure
Good point paul, thanks guys!!! 🦾
XD
I have never written Rust tests. I've written 1000+ lines of Anchor tests. Rust tests look funky to me.
yeah, i know about this. 

what i want is

```rust
if condition_is_met {
  account.close_or_something_like_this();
}
```
like

```
#[account(close = vault, ... )]
pub vault: Account<'info, Vault>
```
you can use the name of the variable
hi guys! how would you close a PDA from within an instruction. Typically, we'd use the 

`#[account(close = account_to_close_to)]`. But i'd like to close an account if a certain condition is met
i guess i will use sudo for now
thats so weird cos running `anchor test` on the anchor tutorial repo works
hmm anchor test still doesnt work despite the folder is now owned by me
Not sure why that happened
Yeah, guess so (or just change the owner without deleting it)
everything else is owned by me
the deploy folder is somehow owned by root, can i delete the folder and retry?
Which keypair are you trying to hide?
Do `ls -hla` and see who owns things
hmmm i simply anchor init, but i will look into it thanks
My guess is that the files in your anchor directory have weird permissions on them

You shouldn't need to—what goes wrong when you try?
any reason why i have to use sudo for `anchor test` to work?
one argument for writing tests in a different language than your program is that a misunderstanding of an aspect of the language of the program cannot propagate to your tests
GM all! Anyone know the best way to hide a keypair in a React App?
Lol, have you tried writing rust tests? Do you like it?
Do whatever your heart tells you 😌
Hey <@!134416332509675520> , good morning 🙂 I've been seeing a lot of people writing their anchor program's tests in Rust... Should I do that instead of writing them in Anchor's TS template?
Yep, all state like that needs to get stored in an account (not directly in a program). So you'd pass the account which keeps track of the `is_checked` state into program B.
Hello, let consider the following scenario:
* Anchor Program A store a state `is_checked` 
* Anchor Program B expose an instruction `transfer_if_is_checked_on_program_A`
Question: 
Is there a way using cpi, to read inside instruction `transfer_if_is_checked_on_program_A` of Program B the state `is_checked` stored in Program A?
Hmm... Perhaps, I committed a repo to github and then checked it out on a different machine. Perhaps I didn't commit the .gitignore -- Thanks!
Hey to do something like combining 3 nfts and creating a new nft, what would the appropriate work flow look like?
Isn’t that already created once you do “anchor init”?
What is the best practice to pass multiple AccountInfo’s to my rust program from client side? I guess I am looking for an alternative of this:

https://github.com/project-serum/anchor/pull/685
anyone got a link to a commit reveal scheme on solana?
trying to set up a svelte frontend and get the following error
```Transaction simulation failed: Attempt to load a program that does not exist ```
Any pointers on where I might be setting this up wrong
```
  const getProgram = () => {
    const program = new Program(
      idl as Idl,
      programID,
      getProvider()
    ) as Program<Anchor>;
    return program;
  };
```
anyone have a .gitignore they'd like to share 🙂 ?
I wanna be able to perform some action everytime a certain account makes a transaction
Is there a way to listen for events on Solana using the anchor js sdk?
awesome, thx <a:ScalebounceHeartRed:870562664412250182>
Or there ^ 🙂
There are lots of examples in the anchor tests/ directory
https://github.com/cqfd/anchor-token-studies
Hey guys. Has anybody stumbled upon any example code (using Anchor) that involves transferring spl tokens? I can see the anchor_spl crate but was unable to find any usage example.
Awesome, thanks for those resources. I think I finally wrapped my mind around accounts/rent, ill try addresses next.
Definitely check out these new intro bootcamp vids, they're very good: https://www.youtube.com/watch?v=O0uhZEfVPt8
You know a large chunk
Once you understand how accounts work (basically: they store data + money and have an owning program, and only that owning program can mutate their data/spend their money) and how addresses work (two main types, regular keypair addresses and program-derived addresses)
makes sense, I'm mainly a JS/Python dev so Rust is veryyyy different
Good news is I think solana's basic programming model is actually very simple, it's just a little hard to see it in the current docs (plus some naming choices are a bit unfortunate/lend themselves to confusion)
Yeah, happy to answer any questions—I actually don't know eth stuff super well, in part because I actually found it easier to get started with solana (probably because I already knew a decent amount of rust)
haha yah thats what i've found so far as well
Coming from solidity and not knowing rust, I feel Solana programming is so much more difficult to learn but exciting when things start working
I'm hoping something comes from all this, I work at Microsoft and got permission to explore web3 tech to see if it can add any value for my division, exciting stuff!
No worries! Way faster to learn this way, it's all good
Yep, you can just go ahead and try to do the transfer—if it fails the whole surrounding tx will roll back
(Im reading through the docs too, I promise, I just find the ecosystem to be less doc-heavy than Solidity and harder to find stuff)
And can I trust that the runtime will throw if the users account doesnt have the balance? Or do I have to explicitly check that it deposited after the transfer?
Ahhhh got it, thats what I was confused about!
(When the user signed the tx they authorized your program to do whatever it wants 🙀)
You would do that transfer directly within your program, by using the system program's `transfer` instruction (from the user's account to your program's account)
Alright that makes sense. 

So say I setup an account the program owns, how could I be sure that the person calling my program function has sent sol to the account?

Does it have to be sent in a separate, previous transaction?
found the error, thanks again. was stuck for an hour
Ok interesting since its the InitializeAccount instruction failing but my constraint is applied somewhere else
Solana doesn't directly have this concept. You'd need to transfer money to an account that the program has control over. This could either be to an account that is *owned* by the program (every account in solana has a program that owns it, and only this owning program can mutate the account's data or spend its money), or you could use an account owned by the system program that lives at a program-derived address derived from your program (a PDA).
I love you
So I think the token part of your program is actually ok, but you have some `constraint = ...` that is failing.
https://github.com/project-serum/anchor/blob/master/lang/src/error.rs#L48
0x7d3 = 2003
Do you know where to find those error codes?
``` #[account(
    init_if_needed, 
    payer = owner,
    seeds = [
      owner.key().as_ref(),
    ],
    bump = owner_reward_bump,
    token::mint = reward_mint,
    token::authority = owner
  )]
  pub owner_reward_token: Account<'info, TokenAccount>,
```

```
Program log: Instruction: InitializeAccount
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 3297 of 184101 compute units
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success
    Program log: Custom program error: 0x7d3
```

Any idea why my TokenAccount is failing to initialize?
That's good to know I'll try set that up again later then
Hi all, does anyone know of a resource/tutorial on how to accept payment to a Solana program function? I'm use to Solidity and just adding a `payable` flag, not sure how I can mark a function as payable and check the amount.
Yea exactly, I used dotenv. But I discovered it also works if u use local env variables
any one knows how to pass remaining accounts to anchor client program?
I figured it out! I needed more sol in my wallet! I had 3 sol in there although it said it would only take ~1.8sol. But I bumped my wallet to 5 sol. Turns out the actual cost of deployment was ~3.6 sol
So I did the following: 

1. wiped the target/deploy/* (The keypair and the .so file)
2. anchor build
3. solana address -k target/deploy/project-keypair.json 
4. copy/pasted that address as the program id in the  lib.rs file and Anchor.toml
5. anchor build
6. anchor deploy

and got the same error:

`Error: Deploying program failed: Error processing Instruction 1: custom program error: 0x1
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.`

Any thoughts? Is there a config I'm missing?
Cool and so to create your provider in the JS code, did you just pass it environment variables and call anchor.Provider.env() or something?
hmm inlining it like so seems to get rid of the issue. super weird but i guess it works
unsure how to get rid of this error. it seems to go away if i remove the if/else statement directly below it.
`token_auth_seeds` is defined as much in some lines above like:
```
let token_auth_seeds = &[b"speedgod".as_ref(), &[pda_token_auth_bump]];
```
Hey guys, we are trying to run anchor test on a persistent local cluster with
`anchor test --skip-deploy --skip-build --skip-local-validator`
and we are getting this error.

We already change anchor.toml and the declare_id of each program to match the .so file under the deploy folder using 
`solana-keygen pubkey <target/path to pubkey>`

What are we missing? Thanks
ps thanks for all the help <:bagsLove:500156064507887618>
Yeh I wanted to make sure account validation logic still ran without repeating the same code in multiple functions.
ok thats very handy, thanks
Can see some details here: https://github.com/solana-labs/solana/blob/master/program-runtime/src/compute_budget.rs#L78
Ah, I guess the advantage is that with an explicit CPI you make sure that the derive(Accounts) logic runs
You can CPI to yourself but in general I'm not sure why you would ever want to—you can just call the other instructions functions (they're just rust functions after all)
For sure that's what I figured
Have to pass them in from the client (always, no getting around this)
No, can't dynamically fetch any accounts within your program
if so any example repos would be clutch
Maybe kind of a weird question but can anchor programs call their own functions within themselves.

If so do they still validate inputs?
Like an invoked_signed cpi to myself?

Is CPI the way to do it or are there any examples of this?

on the same note can I do an equivalent of:
await program.account.data.fetch()
within my own program to get info about its accounts etc???
stuff like that
example: like is there a typical number range of cpi calls i can make in an ix before i run out of juice?
are there any sensible heuristics to reason about the computational load of my instruction logic as i write it out?
Hey, sure
<@134416332509675520> can I pick your brain in private for a moment? If you have time?
You can actually have a full rust expression there, including goofy things like
```.rs
constraint = {
  msg!("Hmm");
  1 + 2 > 0
}
```
Yep—is anything going wrong when you try?
Is it possible to do arithmetic in account constraints? eg `constraint (price * qty) <= user_token_account.amount`
In the YouTube video 'How to Anchor..', Armani has an example program that isn't checked into the anchor repo.  It mints and transfers token inside the smart contract.  Anyone know how i can get hold of that?
we've all been there 😅 .
thank you!
that was the problem ace... probably since I had the validator running there was some sort of collision, now it worked 🙂


//////////////////////////////////////////////////////////////////////////////////////////

thanks a lot!! 😍
ok I found the bug, it was actually in the `Anchor.toml` file, didn't change the program id variable 😅
mm could be, I have now copied the code from the course and still getting the errors
iirc that's the error you get when passing in an account that's not a program into a tx
Doesnt this look more like wrong workspace configuration? `Transaction simulation failed: This program may not be used for executing instructions`
You might be doing some illicit float operations, or using global mutable state, etc. 🙀
Does anybody know what this could be? Thanks! 🙂
```
Deploy success
🚀 Starting test...
Transaction simulation failed: This program may not be used for executing instructions 
    
Error run main:  SendTransactionError: failed to send transaction: Transaction simulation failed: This program may not be used for executing instructions
    at Connection.sendEncodedTransaction (/Users/gonzalo/Desktop/projects/buildspace/solana/myepicproject/node_modules/@solana/web3.js/lib/index.cjs.js:6591:13)
    at processTicksAndRejections (node:internal/process/task_queues:96:5)
    at async Connection.sendRawTransaction (/Users/gonzalo/Desktop/projects/buildspace/solana/myepicproject/node_modules/@solana/web3.js/lib/index.cjs.js:6550:20)
```
Hi! I'm having this error and I don't know how to solve it 😅. I've deployed the program to the devnet and I'm running `anchor test`  and the error is:
thank u
amazing
Then you need only to do what it does at the start, i.e. check that the ix count is 1
yea I think thats exactly what I want to achieve. I want to make sure the transaction only contains the mint_nft instruction . In my case its called something else obviously
perfect thanks!
`solana program deploy --help` gives some info on the `--max-len` option
You can set that when you deploy
Max size for what? Your program's code?
Super dumb question, when you init a new project, how do you set its size? I want the max amount of space to work on my program. I am assuming there is some arguement after anchor init?
Thanks! That was the issue
Also, if you're running `anchor deploy`, it's extremely easy to accidentally deploy a stale version of your `.so` file, so if your declare_id actually does match that id, I would rerun `anchor build` + `anchor deploy` just in case.
Does your `declare_id!` match Ds6fmsR2F2LwjHFEfg6F5LsyW8tcnmM2Ftmy4eDA9QU6?
Hey guys, im triying to run this client.js and I'm getting this error. Any help? 

`anchor.setProvider(anchor.Provider.local());

async function main() {
  const idl = JSON.parse(
    require("fs").readFileSync("./target/idl/fib.json", "utf8")
  );

  const programId = new anchor.web3.PublicKey("Ds6fmsR2F2LwjHFEfg6F5LsyW8tcnmM2Ftmy4eDA9QU6");


  const program = new anchor.Program(idl, programId);

  const fibonacci = anchor.web3.Keypair.generate();
  const tx = await program.rpc.initialize({
    accounts: {
      fibonacci: fibonacci.publicKey,
      user: anchor.Provider.local().wallet.publicKey,
      systemProgram: anchor.web3.SystemProgram.programId,
    },
    signers: [fibonacci],
  });

  let startTime = Date.now();
  while ((Date.now() - startTime) < 6000) {
    await program.rpc.newTerm({
      accounts: {
        fibonacci: fibonacci.publicKey,
      }
    })
  }
}

console.log("Running client.");
main().then(() => console.log("Success")); `
This snippet you pasted seems to be basically whitelisting what **instructions** a caller can bundle alongside that particular `mint_nft` instruction, in the same **transaction**
Are you maybe conflating "accounts in an instruction" and "instructions in a transaction"?
or should i check that each program_id (in this code snippet) == the accountIds passed into the &[AccountInfo]
So if i have a function defined that only takes in a certain number of accounts and want to ensure no other ix data is passed in, can i do something like 
 ```let mut idx = 0;
 let num_instructions = read_u16(&mut idx, &instruction_sysvar)
if (num_instructions > 1) throw err```
```rust
            current = start as usize;
            let num_accounts = read_u16(&mut current, &instruction_sysvar).unwrap();
            current += (num_accounts as usize) * (1 + 32);
            let program_id = read_pubkey(&mut current, &instruction_sysvar).unwrap();
```
this is where the program reads the particular ix's data. In this case the focused on retrieving the program address from the array of accounts passed to the ix
but my question is
that makes a lot of sense, i keep forgetting about this piece
oh amazing
what is `'info` do?
```rust
        for index in 0..num_instructions {
            let mut current = 2 + (index * 2) as usize;
            let start = read_u16(&mut current, &instruction_sysvar).unwrap();
```
this seems t indicate that after the ix count N of the first two bytes, the next `N * 2` bytes in  the byte array store where in the data array you can find the data for that particular ix
```rust
        let mut idx = 0;
        let num_instructions = read_u16(&mut idx, &instruction_sysvar)
```
the initial `2+` is because the first 2 bytes of data are to store how many ixs are in the tx
I put together the mint nft action for the metaplex js sdk. Its what we use for holaplex bulk mint. Though metaplex or holaplex discord prob the best place to talk NFTs 🙂

https://github.com/metaplex-foundation/js/blob/main/src/actions/mintNFT.ts
thanks !! .. that mint-nfts looks promising 🙂
I don't have off-hand recipes for you, but I think you'll probably find all you need around here:
https://github.com/metaplex-foundation/metaplex/blob/master/js/packages/cli/src/cli-nft.ts
https://github.com/metaplex-foundation/metaplex/blob/master/js/packages/cli/src/commands/mint-nft.ts
Getting there but still not getting how to get from the error number to the anchor error.

```
  match context.banks_client.process_transaction(transaction).await {
    Ok(()) => assert!(true),
    Err(TransportError::TransactionError(TransactionError::InstructionError(0, InstructionError::Custom(n)))) => {
      println!( "This is the error code: :{}", n);
    },
    _ => assert!(false),
  }
```

```
[2022-01-03T15:54:38.243466000Z DEBUG solana_runtime::message_processor] Program log: Custom program error: 0xbbf
[2022-01-03T15:54:38.243868000Z DEBUG solana_rbpf::vm] BPF instructions executed (interp): 12306
[2022-01-03T15:54:38.243881000Z DEBUG solana_rbpf::vm] Max frame depth reached: 16
[2022-01-03T15:54:38.243914000Z DEBUG solana_runtime::message_processor] Program 4uQeVj5tqViQh7yWWGStvkEG1Zmhx6uasJtWCJziofM consumed 13488 of 200000 compute units
[2022-01-03T15:54:38.243951000Z DEBUG solana_runtime::message_processor] Program 4uQeVj5tqViQh7yWWGStvkEG1Zmhx6uasJtWCJziofM failed: custom program error: 0xbbf
This is the error code: :3007
test test_create_auction_house_with_native_mint_success ... ok
```

Thanks for the help.
i am just unfamiliar how to link metadata to the token
<@!915682383905316864> do you know where i can find something like what solsea is doing .. i am assuming its all just using JS API
🙂
that is what i am looking for but i am looking for the actual code
yes lol.. i need a code for solsea.io
(I believe there are similar alternatives)
I don't think the candy machine is really what you're looking for anyway, since it is targeted at entire collection drops. Would some interface like this be what you're looking for?
https://solsea.io/create
https://docs.solsea.io/getting-started/faq/nfts-create-mint-list-delist
if not, can anyone tell me where can i ask this ? i just need a simpler contract than candy-machine .. that lets me mint and upload metadata at the right place so wallets can display what i minted
maybe this is the right place to ask.. so from what i understand NFT is just SPL-Token 1 of 1
but how do i make sure my metadata is linked to that token ? 
does anyone know ? i was looking at candy machine its much more than what i need for my purpose.. is there a simpler contract, where i can just upload metadata that Wallets can display and still mint the token ?
ok, thanks, just checked that! 

so basically, the impl would do the same thing as  #[account(constraint = mock_account.to_account_info().owner == program_id)]
If you jump to source on `TokenAccount`, for example, you can see how anchor impls it for 3rd party types
In general `Whatever` has to implement anchor's `Owner` trait. Any account struct you define via `#[account]` automatically impls that with your own program_id (from declare_id!) as its intended owner.
so how does anchor infer who is supposed to own it? if it's inside my context struct, then my program should own it?
Something like that
```.rs
match that_thing {
  Ok(()) => ...,
  Err(InstructionError(idx, Custom(n))) => ...,
  _ => ...
}
```
You don't have to match on each error number, no
Not sure there's any direct way to convert it to the anchor error enum, hmm
Ok thanks. If I do a match do I have to match each enum case? I imagine not but how do I convert `Custom(3007)` to the anchor lang error enum?
Not sure if this is your question, but just don't do that `unwrap()`; you can then `match` on the return value/check it makes sense, etc.
I'm writing some integration tests in rust for an anchor program. How can I parse the transport error into the relevant program error?

```
  let mut transaction = Transaction::new_signed_with_payer(
    &[Instruction::new_with_bytes(
      program_id,
      &data.data(),
      accs.to_account_metas(Some(false)),
    )],
    Some(&payer_key),
    &[&context.payer],
    context.last_blockhash,
  );

  context.banks_client.process_transaction(transaction).await.unwrap();
```

```
[2022-01-03T15:12:56.640265000Z DEBUG solana_runtime::message_processor] Program 11111111111111111111111111111111 success
[2022-01-03T15:12:56.640938000Z DEBUG solana_runtime::message_processor] Program log: Custom program error: 0xbbf
[2022-01-03T15:12:56.641301000Z DEBUG solana_rbpf::vm] BPF instructions executed (interp): 12306
[2022-01-03T15:12:56.641312000Z DEBUG solana_rbpf::vm] Max frame depth reached: 16
[2022-01-03T15:12:56.641335000Z DEBUG solana_runtime::message_processor] Program 4uQeVj5tqViQh7yWWGStvkEG1Zmhx6uasJtWCJziofM consumed 13488 of 200000 compute units
[2022-01-03T15:12:56.641367000Z DEBUG solana_runtime::message_processor] Program 4uQeVj5tqViQh7yWWGStvkEG1Zmhx6uasJtWCJziofM failed: custom program error: 0xbbf
test test_create_auction_house_with_native_mint_success ... FAILED

failures:

---- test_create_auction_house_with_native_mint_success stdout ----
thread 'test_create_auction_house_with_native_mint_success' panicked at 'called `Result::unwrap()` on an `Err` value: TransactionError(InstructionError(0, Custom(3007)))', auction-house/program/tests/lib.rs:95:63
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```
Can check out https://hackmd.io/XP15aqlzSbG8XbGHXmIRhg
Right, that won't work because you are manually decrementing the lamports of the wallet, but your program definitely doesn't own the wallet (it's owned by the system program).
That address is whatever the deployed/runtime program id is (it needs to match, unfortunately). When you run anchor build for the first time (amongst other ways) you get a fresh keypair in target/deploy.
You can use breakpoints in compiled languages too 😛 Just not sure how to do it when your program is running inside a validator, yeah
If that's an anchor type then it might work, but I think the Metadata type isn't, so you'll have to do the analogue of how TokenAccount is implemented
No, Account<'info, Whatever> checks that the owner is whatever is supposed to own Whatevers.
Yea I’m talking about this Found this in another post. bingo.

https://github.com/katopz/hello-rust-debug/blob/main/programs/debug_anchor/src/lib.rs#L72
is using the Account<> struct suffice for checking the program id of a program account, or do I have to be extra specific and add a constraint to verify the program id ?
Although you'll often see directly:
```rust
let (escrow_account_address, _) = Pubkey::find_program_address(&[b"escrow".as_ref()], &program_id);
```
unless you somehow use it several places
It stores the string "escrow" as a byte array, generally for use in the function deriving a PDA from it like so:

```rust
const ESCROW_PDA_SEED: &[u8] = b"escrow"; 
let (escrow_account_address, _) = Pubkey::find_program_address(&[ESCROW_PDA_SEED], &program_id);
```
hey, beginner question on anchor+rust,
`const ESCROW_PDA_SEED: &[u8] = b"escrow"; `
what is this doing?? can some one please explain.
thank you <@!915682383905316864> <:pepestar:884557572949032980>
it worked! but instead i used `program.transaction.increment()`, much easier to manage i think
if i wanted to use a metaplex metadata account in an instruction, would the correct way to do it be just importing the metaplex-token-metadata program, import the Metadata struct and use `Account<'info, Metadata>` in the accounts context struct of the instruction where im using it? or am i missing some steps somewhere here?
`program.instruction.increment()`
hello, beginner with anchor here. jsut wanted to ask if anyone has an idea on how i could extract the transaction itself from an rpc call like `program.rpc.increment()`? context is that i want to bundle three anchor rpc calls into one approval via phantom's `signAllTransactions()` method
i think you're right. giving the method a gander.
create token account for user -> deposit amount in it -> transfer ownership to PDA -> later have the program send amount back to user, or something like that
wouldn't that follow the same concept as the escrow program, apart from the fact that the withdraw part would for the the depositor instead of a second party?
it would require a signer for the program's wallet, which the client couldnt do. was their usdc address a pda? and if so how do i set up a pda as a token account for a specific mint i dont own
for mango markets and uxd's ido, they allowed for USDC deposit and withdrawal. the depositing part is straightforward, but how did they automate withdrawals?
hi guys, i'm curious to a pattern i've seen in popular dapps.

When a user wants to pick a username for the dapp, they dapps typically have the user sign a message with a nonce or sometimes the contents of the username.

I'm curious, why is it done like this?
Well In the solana_program
There is a log function in anchor though
Sir this is a compiled language
ok thanks!
I think it would have to be of the same format. If you directly look into the json file at that location it should look like an array of numbers. I believe you can change them and it would still work as long as you don't change the format. The program id is just supposed to be a unique identifier.
ok, is there a way for me to customizer that address?
When you use anchor build keypairs for your programs get generated in the target/deploy folder as json files. These can be accessed like ```solana address -k target/deploy/program_name.json``` They will not exist on chain until you have deployed the program with the labels in your lib and toml.
Has anyone got this error before when using the wallet adapter in a react app? ```./node_modules/@solana/wallet-adapter-base/lib/esm/signer.js 16:16
Module parse failed: Unexpected token (16:16)
File was processed with these loaders:
 * ./node_modules/babel-loader/lib/index.js
You may need an additional loader to handle the result of these loaders.
|           ...sendOptions
|         } = options;
>         signers?.length && transaction.partialSign(...signers);
|         transaction = await this.signTransaction(transaction);
|         const rawTransaction = transaction.serialize();
```
well they are two different programs so they would have different IDs, but how did they get those IDs?
where does anchor get `declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");` from and in the tutorial, why does the puppet master program use a different id? `declare_id!("HmbTLCmaGvZhKnn1Zfa1JVnp7vkMV4DYVxPLWBVoN65L");`
is there any reason this shouldn't work?

client 
```
const transaction = new Transaction({feePayer: wallet.publicKey});
const instruction = new TransactionInstruction({
  keys: [
    {pubkey:wallet.publicKey, isSigner:true, isWritable:true},
    {pubkey:housePubkey, isSigner:false, isWritable:false}
  ],
  programId: programId,
});

transaction.add(instruction);
transaction.recentBlockhash = (await connection.getRecentBlockhash()).blockhash;

await wallet.signTransaction(transaction);

const transactionHash = await sendAndConfirmRawTransaction(
  connection,
  transaction.serialize(),

);
```
program:
```
use solana_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint::ProgramResult,
    pubkey::Pubkey,
};

pub fn process_instruction(
    _program_id: &Pubkey,
    accounts: &[AccountInfo],
    _instruction_data: &[u8],
) -> ProgramResult {

    let account_info_iter = &mut accounts.iter();

    let source_info = next_account_info(account_info_iter)?;
    let destination_info = next_account_info(account_info_iter)?;

    **source_info.try_borrow_mut_lamports()? -= 5;
    **destination_info.try_borrow_mut_lamports()? += 5;

    Ok(())
}
```

getting this error
```
Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: instruction spent from the balance of an account it does not own
```
Wait…how do you debug anchor code with breakpoints lol
Found this in another post. bingo.

https://github.com/katopz/hello-rust-debug/blob/main/programs/debug_anchor/src/lib.rs#L72
Yes, I think that's it
was just about to write, the best thing I found was the "clone" option, is that what you mean?
I think there's a way to initialize the solana-test-validator with a preexisting history but that's pretty much the limit of my knowledge there.
was trying to setup a gitrepo with a clean example but getting errors linked to maybe what you were implying (that it's not supposed to work). I'll look into it a little more. Any advise on testing with CPI on programs that exist in devnet/mainnet (and not localnet)? Would the best way just be to deploy temp program to devnet with anchor and test as such? Seems a little excessive. Would be great to "fork" devnet/mainnet locally. Is that at all possible?
How are you building your `provider`?
No, won't work like that
How do you test a program that you import from a crate? I'm doing a CPI call to a program on devnet/mainnet and using their crate. I need to interact with that program as a client before testing my program. Is there a good way to locally deploy programs that are dependencies?
... not sure.. I imagined it just used my local source code for the program and retreived the accounts from devnet :S
I'm confused how you're talking to your program at all though if you didn't deploy it to devnet
the vanilla "initialize" test works fine AND ```account_a: UncheckedAccount<'info>,``` works fine
Full error:

```bash
 Is merged!: <<<< THIS IS JUST MY TEST NAME
     Error: 167: The given account is not owned by the executing program
      at Function.parse (node_modules/@project-serum/anchor/src/error.ts:41:14)
      at Object.rpc [as merge] (node_modules/@project-serum/anchor/src/program/namespace/rpc.ts:28:42)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)

```
sure, one sec
Can you post the full thing?
But what actual error do you get?
using ```const program = anchor.workspace.Foo as Program<Foo>;``` 😛
I wouldn't expect that to work at all lol
Mm, how are you talking to your program at all then? 🤔
nope but I am using a devnet connection as such, does that not suffice?

```javascript
 const connection = new anchor.web3.Connection(
    "https://api.devnet.solana.com",
    "confirmed"
  )
  const opts = anchor.Provider.defaultOptions();
  let wallet = new Wallet(Keypair.generate());
  anchor.setProvider(
    new Provider(
      connection,
      wallet,
      opts
    )
  );
```
Are you actually deploying your program to devnet? That token won't exist in your local validator
Ok, so I would have expected this to work now but still not working. Found a random token on devnet (https://solscan.io/token/Bhv8Dfw8rqNpgbTiL33fFUMtqJJGbdiBDGjrcmXpVkzG?cluster=devnet) that is owned by the `Token Program` (see solscan link).  So, what am I missing here :S ?

```rust

pub fn merge(ctx: Context<Merge>) -> ProgramResult {
    Ok(())
}

#[derive(Accounts)]
pub struct Merge<'info> {
    account_a: Account<'info, TokenAccount>,
}
```

```javascript
    const tx2 = await program.rpc.merge({
      accounts: {
        accountA: new PublicKey("Bhv8Dfw8rqNpgbTiL33fFUMtqJJGbdiBDGjrcmXpVkzG")
      },
    })
```
Ok cool, think I understand. Thanks yet again <@!134416332509675520> !
Oh, sorry, I guess you meant that
Whatever here isn't a program, it's a struct that implements anchor's Owner trait (which just says, "who should own me?")
ok thank you.. I think I "kinda" understand.. Trying to wrap my head around it still haha. Think how I understand it is that the passed in "pub key" is an account owned by the "Whatever" Program. So like you said, TokenAccount should be an account owned by the spl token program.
everything works great now, thanks Gs
or is that hilariously silly of me to say
in the json
can I just remove the chai text too lol
okay
I think there might be a separate way to tell ts about chai, can't remember—think it's googleable though
while you are here, i have an error in my tsconfig.json where it says cannot find destination file for 'chai', but I have chai installed, can I do `// @ts-ignore` here too?
In your case, you're apparently not passing in an initialized token account
thank you ser
So, for example, `Account<'info, OneOfYourAccounts>` verifies the the owning program matches your declare_id! (so double check it actually matches the runtime program id). Account<'info, TokenAccount> checks the account is owned by the spl token program, etc.
Any time you use `Account<'info, Whatever>` in anchor, anchor verifies that the incoming account belongs to whatever program is supposed to own Whatevers.
^ chad Alan to the rescue
okay
I think this is a current typing bug, just add a `// @ts-ignore` comment to the line above it :/
D:
weird... maybe try remove node_modules and do an "npm i" again? not sure bud :S
rest of the file is good, its under /tests/ folder
Property 'workspace' does not exist on type 'typeof import("/home/sal/Code/foo/node_modules/@project-serum/anchor/dist/cjs/index")
property workspace does not exist
what does the error say?
but a red line under workspace
yes
it is
looks good. Try a capital foo (if it isnt already?)

```const program = anchor.workspace.Foo as Program<Foo>; ```
my command to configure in describe is 

`const program = anchor.workspace.Foo as Program<Foo>;`
yes I Have that
yea actually, sorry, there is one more import (missed out in my copy paste):

```import { Foo } from '../target/types/foo';```

and your project structure would be (on the rust side)

programs/foo/src/lib.rs

and then your program something like:

```#[program]
pub mod foo {```
Is there an anchor.workspace in that default file under describe
Yes
Is this for your test .ts file
Think ethereum needs a contracts abi to interact with it (analogous to idl)
Check it for what exactly? I also thought one of the pros/cons of sealevel was anyone could pass in any account to any program (the program itself had to check it however). So, yea, a little confused still as to why I can't check it.

Regarding you question, I haven't had an error but im using a vanilla `anchor init` project. Here are my 'relevant' imports for your ref:

```javascript
import * as anchor from '@project-serum/anchor';
import { Program, Provider, Wallet } from '@project-serum/anchor';
import { PublicKey, Keypair } from "@solana/web3.js";
```
have you had an error with using anchor.workspace command to configure your program when testing in typescript?
check your current wallet maybe
Could someone help explain the following error? Why would a given account need to be owned by the executing program if it's not being  mutated in that program

```Error: 167: The given account is not owned by the executing program
```

Context:
lib.rs
```rust
pub fn merge(ctx: Context<Merge>) -> ProgramResult {
    Ok(())
}

#[derive(Accounts)]
pub struct Merge<'info> {
    account_a: Account<'info, TokenAccount>,
    account_b: UncheckedAccount<'info>,
}
```

anchor test:
```javascript
    const tx2 = await program.rpc.merge({
      accounts: {
        accountA: accountA,
        accountB: accountB,
      },
    })
```
nothing else under anchor has a problem, maybe need to import something else?
anyone have an error with the anchor.workspace command in their .ts files under /test?
is there a way to interact with solana programs without an IDL?
something like interfaces like in solidity?
I guess im a little confused why this starts here ```let mut current = 2 + (index * 2) as usize;```
My interpretation is that its getting all the instructions that were passed in, and checking for any it doesnt recognize. But how can u pass multiple instructions? Basically I want to do something similar, where I just want to check that only the instruction i recognize is being passed in
https://github.com/metaplex-foundation/metaplex/blob/master/rust/nft-candy-machine-v2/src/lib.rs
can someone explain what this is doing? 
``` let mut idx = 0;
        let num_instructions = read_u16(&mut idx, &instruction_sysvar)
            .map_err(|_| ProgramError::InvalidAccountData)?;

        let associated_token =
            Pubkey::from_str("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL").unwrap();

        for index in 0..num_instructions {
            let mut current = 2 + (index * 2) as usize;
            let start = read_u16(&mut current, &instruction_sysvar).unwrap();

            current = start as usize;
            let num_accounts = read_u16(&mut current, &instruction_sysvar).unwrap();
            current += (num_accounts as usize) * (1 + 32);
            let program_id = read_pubkey(&mut current, &instruction_sysvar).unwrap();

            if program_id != nft_candy_machine_v2::id()
                && program_id != spl_token::id()
                && program_id != anchor_lang::solana_program::system_program::ID
                && program_id != associated_token
            {
                msg!("Transaction had ix with program id {}", program_id);
                return Err(ErrorCode::SuspiciousTransaction.into());
            }
        }


```
Ok just some rubber ducking there hehe, problem solved 🦆
Oh maybe I need to use BN
On the other side I have:

```
        seeds = [
            b"edition".as_ref(),
            master_edition_account.key().as_ref(),
            &[master_edition_account.supply as u8].as_ref()
        ],
```
Following up on this from yesterday - would this be the correct way to do this on the JS side?
```
await anchor.web3.PublicKey.findProgramAddress(
        [
          Buffer.from("edition"),
          masterEditionAccount.toBuffer(),
          Buffer.from(masterEditionState.supply.toString()),
        ],
        program.programId
 );
```
if this is what you mean then here
```
import React, { useCallback, useEffect, useState } from 'react'

import { useConnection, useWallet } from '@solana/wallet-adapter-react';
import { Transaction, TransactionInstruction, sendAndConfirmTransaction, PublicKey } from '@solana/web3.js';


const Play = (props) => {

    const { connection } = useConnection();
    
    const wallet = useWallet();
    const housePubkey = new PublicKey('FN9ghw16B6R1SLd6bYXUFrCVgcSG87Ny9mfcTkT16ugC');
    const programId = new PublicKey('Hx6xhwfRwRydjc1P2n4krVwJzyGZzEpdwyFHazYVuniW');

    const callback = useCallback(async () => {

        if (!wallet.publicKey) {
            alert('error', 'Wallet not connected!');
            return;
        };

        const transaction = new Transaction({feePayer: wallet.publicKey});

        const instruction = new TransactionInstruction({
          keys: [{pubkey:wallet.publicKey, isSigner:true, isWritable:true}, {pubkey:housePubkey, isSigner:false, isWritable:false }],
          programId: programId,
        });

        transaction.add(instruction);
        transaction.recentBlockhash = (await connection.getRecentBlockhash()).blockhash;

        await wallet.signTransaction(transaction, connection);
        const transactionHash = await sendAndConfirmTransaction(
          connection,
          transaction,
          []
        );
        alert(transactionHash);

    }, [wallet, connection]);

    return (
        <button onClick={callback}>send</button>
    )
}

export default Play;
```
nah not currently. I gotta run to dinner but I'll debug some more after
Do you have your code on github?
The part that's currently failing (I can't quite tell what you've got there now)
the whole script for the component?
Can you print the current code you're using?
Yeah I'm always trying to convince myself to switch aha.

its now saying no signers, I presume its expecting me to pass the signer in the sendAndConfirmTransactions
This is way easier by the way if you use typescript lol, catches a lot of these types of errors
Maybe don't do the .serialize() part, just pass the tx itself
Hmm, now getting this, would I need to sign it some other way maybe?
```Uncaught (in promise) TypeError: transaction.sign is not a function```
`[class Token]`
https://github.com/solana-labs/solana-program-library/blob/master/token/js/client/token.js#L384
If you just console log `spl.Token` at runtime, what do you get?
Think you're missing an argument to sendAndConfirmTransaction (pass an extra empty array)
bump 🙂 still can't figure this out, seems incorrect
Just tried in a chrome instead of firefox and seeing this error before
```Uncaught (in promise) TypeError: signers is not iterable (cannot read property undefined)```
`process` is a node thing, so something in your code/your build process etc. thinks it's node, not the browser
Mm, I don't think that would lead to that error either, can you post the stack trace?
using solana wallet adapter
this is how I instantiate the wallet 
```
import { useConnection, useWallet } from '@solana/wallet-adapter-react';
import { Transaction, TransactionInstruction, sendAndConfirmTransaction, PublicKey } from '@solana/web3.js';

const { connection } = useConnection();
const wallet = useWallet();
const housePubkey = new PublicKey('XXXX');
const programId = new PublicKey('XXXX');
```
How did you instantiate the wallet, for example?
Please spoon feed us all
And no, I think it's a JS error, not in your rust code
Is that all of it?
How are you setting up the rest of the code?
You think its coming from the program itself?
I doubt that error is coming from that specific chunk of code
sorry for another question, not trying to get spoon fed.
what am I doing wrong here?
```
const transaction = new Transaction({feePayer: wallet.publicKey});

const instruction = new TransactionInstruction({
    keys: [{pubkey:wallet.publicKey, isSigner:true, isWritable:true},{pubkey:housePubkey, isSigner:false, isWritable:false }],
          programId: programId,
});

transaction.add(instruction);
transaction.recentBlockhash = (await connection.getRecentBlockhash()).blockhash;

await wallet.signTransaction(transaction, connection);
const transactionHash = await sendAndConfirmTransaction(connection, transaction.serialize());
alert(transactionHash);
```
getting this error
```Uncaught ReferenceError: process is not defined```
There are lots of examples if you search the anchor codebase
Does anyone know of any code examples of CPI with  `new_with_signer`? Trying to work out how to pass the `signer_seeds`
Using borsh, 4 bytes for the length + N * however much space borsh takes for each element
anyone know the initial space requirement for a vector (e.g. X + 32*(number of pubkeys stored))? new to rust and couldnt find a good answer
Thanks <@!134416332509675520>
It removes a significant portion of attackers . The quality ones will go for bigger targets 😆
Yeah but hardship helps
Mangling plus striping will make life a pain🤣
But I don't think this is a great security path for anything important
I don't know (and yeah, it's definitely not trivial to decompile stuff)
It's probably not super safe (maybe fairly safe, but certainly not super super safe)
Decompile shared object is a pain, does anchor support symbol striping ?
Also remember that your instructions in general expose a decent amount of information about what they'll do, since you have to submit *all* accounts in from the client
Someone in principle could download your source code and if they really wanted to, decompile it, etc.
🤣🤦‍♂️
No but
No!!!
But!
Ok
Ahhh
Only the external `do_something`
Yeah the problem is that it doesn’t run anything. So I’m asking, does it give interface instructions or internal ones ?
It just returns a little data structure that you could add into a transaction, asking your program to `do_something`
It doesn't run anything
I think you're confused about what `program.instruction.doSomething` returns
The if admin, is runtime check right? But the branch of not admin will return too if I ask for instructions only
It's a little data structure you can use to ask your program to `do_something`
`program.instruction` is just for your `pub fn do_something` instructions
Returning instructions including all branches?
Mm, sorry, I'm not really following what you mean 🤔
What about CPI? Will that show in instructions?
A program returning instructions set including all branches
Generally what you guard with admin-ness is mutations
What do you mean?
Lol, isn’t this like core solana ?
You'll have to find some other way to do things
Ok then that's bad 😛
I mean a smart attacker can read the instructions and understand what the result will be even if their not admin
It shows info only admin should have
Since if the instructions say “if not admin , error” but contain the rest
It does
But hopefully you're checking admin-ness correctly, so it doesn't matter (right?)
Mm, still not following where this is going—that will let them see/construct available instructions, yes
Not program.rpc
program.instruction
What do you mean by ask for instructions?
Will it include the branch that has the results for the admin?
But what if I just ask the program for instructions?
So if I try to run it, it will error
Let’s say I want to have one entrypoint for “admin” and I put the seeds/id restrictions to enforce it
Can you say more? Not sure what you mean. You always have to guard against the possibility of a client doing weird stuff.
Let’s say I limit a program endpoint to a specific account but someone is using the program and Idl and get the instructions set: will they be able to predict the result ?
Hey I'm referencing a few different anchor test file examples that all do the following:
```
import * as spl from '@solana/spl-token';
...
exampleMint = await spl.Token.createMint(program.provider.connection,
      wallet.payer,
      wallet.publicKey,
      wallet.publicKey,
      0,
      spl.TOKEN_PROGRAM_ID);
```
but when I attempt to use it I get ```  1) anchor-test
       "before all" hook for "Is initialized!":
     TypeError: spl.Token.createMint is not a function```
Any ideas why that'd be? I've got the same dependencies for `@solana/spl-token` as these examples
All good!
thankyou, sorry if that was a very noob question.
Oh right, so I can just simply use the account that was connected via a wallet? and not need to create one to interact with the program?
The source account will need to exist (since it needs to have some lamports), but the receiving account doesn't need to exist yet
I'm trying to make a program based off the transfer-lamports example from solana program library on github.

do I need to create accounts for the receiver/sender on the client side?
Sure. Might depend on what you mean/what you're trying to do
partially javascript
is it possible to create an account on the client side?
thank you!
yes i just wanted to confirm since when i type anchor init --help theres a flag for js but not ts
Typescript (have you tried running it?)
Now I'm getting Fallback Functions are not supported
I changed it to anchor.workspace.Mycalculatordapp
How do I select the Workspace
when i type `anchor init` does it default to javascript or typescript?


//////////////////////////////////////////////////////////////////////////////////////////

```loki:~ Loki$ solana-test-validator
--faucet-sol argument ignored, ledger already exists
Ledger location: test-ledger
Log: test-ledger/validator.log
⠴ Initializing...
Identity: BgxTwrAaQg2iNu29vxozFCZkNKpANLubBsgpK892eZ1F
Genesis Hash: 2uZLUtvTUABvsLr29HjjWMr3FYVYAPGyscjYBY1cMd54
Version: 1.9.5
Shred Version: 57039
Gossip Address: 127.0.0.1:1024
TPU Address: 127.0.0.1:1027
JSON RPC URL: http://127.0.0.1:8899
⠒ 00:00:56 | Processed Slot: 3079 | Confirmed Slot: 3078 | Finalized Slot: 3047```
I restarted my solana-test-validator as well
on the command line
maybe im doing this wrong?
`ANCHOR_WALLET="SolanaWallet/my-keypair.json" node client.js `
yes
I'm trying to make an Account like:
```
#[account]
pub Protocols {
   solend: Solend
   larix: Larix
   ...
}
```

I want each protocol to implement the same traits (e.g. all implement `deposit()` but have different implementations and parameters).

I want to be able to just do something like `protocol.deposit()` and it would call the relevant protocol

I'm not sure how to structure my data, though
So basically the `instructions: []` parameter client side runs those first and passes the data into my program
Thanks a million man!
I was just looking that up! the 300 is the size override! Hooray!
It's talking directly to the system program, not your program
Ah, ok. Might help to see the source for `createInstruction`: https://github.com/project-serum/anchor/blob/master/ts/src/program/namespace/account.ts#L284
Unless the `createInstruction(check, 300)` is actually creating the account? and the 300 is the space
Right, but I'm not sure where the space for the struct is allocated?

The `createInstruction(check, 300)`, I assume this is calling the `pub fn accounts(ctx: &Context<CreateCheck>, nonce: u8)`

It would know now how big the check struct is because everything is static, how much space the Vec would need say if I had a Vec<Pubkey> and needed it to hold say 40
Ah, yeah ^
In the JS file I image that first instruction is 

```
      instructions: [
        await program.account.check.createInstruction(check, 300),
        ...(await serumCmn.createTokenAccountInstrs(
          program.provider,
          vault.publicKey,
          mint,
          checkSigner
        )),
      ],
```
Why are you trying to use `account(zero)`?
No, I mean you're apparently going to use a separate instruction from the client
Is this the previous instruction?  The impl?
```
#[derive(Accounts)]
pub struct CreateCheck<'info> {
    // Check being created.
    #[account(zero)]
    check: Account<'info, Check>,
    // Check's token vault.
    #[account(mut, constraint = &vault.owner == check_signer.key)]
    vault: Account<'info, TokenAccount>,
    // Program derived address for the check.
    check_signer: AccountInfo<'info>,
    // Token account the check is made from.
    #[account(mut, has_one = owner)]
    from: Account<'info, TokenAccount>,
    // Token account the check is made to.
    #[account(constraint = from.mint == to.mint)]
    to: Account<'info, TokenAccount>,
    // Owner of the `from` token account.
    owner: AccountInfo<'info>,
    token_program: AccountInfo<'info>,
}

impl<'info> CreateCheck<'info> {
    pub fn accounts(ctx: &Context<CreateCheck>, nonce: u8) -> Result<()> {
        let signer = Pubkey::create_program_address(
            &[ctx.accounts.check.to_account_info().key.as_ref(), &[nonce]],
            ctx.program_id,
        )
        .map_err(|_| ErrorCode::InvalidCheckNonce)?;
        if &signer != ctx.accounts.check_signer.to_account_info().key {
            return Err(ErrorCode::InvalidCheckSigner.into());
        }
        Ok(())
    }
}
```
Yeah, sounds like you're planning on doing that in a prior, totally separate instruction (that's what account(zero) is for)
So you don't need to do `space =` at all (you've already allocated the space, in that previous instruction)
I guess it's a a disconnect. I assumed the size of an account needs to be initialized so it can be rent exempt
If this is account(zero) then you'd be creating the account (allocating its space) in a previous instruction
Not sure how to answer that—why does it matter where the space is allocated?
Not totally sure what you're asking about in terms of where the space is allocated—can you say more?
Pubkeys take up 32 bytes
Why 40 times KEYCOUNT?
I'm basically modifying the Cashier's check program, but need enough space for KEY_COUNT PubKeys. I don't see how that is init'd where the space is allocated.
So normally I'd use the `[account(init, payer = owner, space = 40*KEYCOUNT]` however the program I'm working on has to have the `[account(zero)]` in it and I'm not sure where the space is actually allocated
How much space does each pubkey take?
What have you tried so far?
About your null point, indeed, if you use a static array, each element will be all zeros
How would I do that? Say I wanted a Vec<Pubkey> and I needed space for 100
You would need to decide how much space is "enough". Borsh serializes a Vec<Foo> as 4 bytes for the length, and then serializes each Foo one after the other.
You can use static arrays, yes (annoyingly though, some lengths don't work for annoying borsh reasons)
Actually - I think I know why, there is no 'null' in rust. So a static array would have to have initialized data.  Second question, if I were to use a Vec, how would I reserve enough space for them out of the gate? I can't seem to use `[account(init, payer = owner, space = 40]` in a setup like the Cashiers Check example.
Is it possible to have static length arrays in a data account? 

length 1 works, but some others throw an error, thoughts?
```
#[account]
pub struct TreasureChest {
    pub nonce: u8,
    pub coach: Pubkey,
    pub lamports: u64,

    pub vaults: [Pubkey; 1], //bk k0 k1 k2 tc rt ac
    pub counts: [u64;    1],

    pub bomb: u64,

    pub hunters: [Pubkey; 1],
    pub winners: [Pubkey; 1],
}
```
Are you running your local `solana-test-validator`?
Would anyone know why I'm having this issue whenever i run the client.js on the basic_0 tutorial?
```bash
loki:basic-0 Loki$ ANCHOR_WALLET='SolanaWallet/my-keypair.json' node client.js 
Running client.
/Users/Loki/code/src/github.com/anchor/examples/tutorial/node_modules/@solana/web3.js/lib/index.cjs.js:5965
      throw new Error('failed to get recent blockhash: ' + e);
            ^

Error: failed to get recent blockhash: FetchError: request to http://localhost:8899/ failed, reason: connect ECONNREFUSED ::1:8899
    at Connection.getRecentBlockhash (/Users/Loki/code/src/github.com/anchor/examples/tutorial/node_modules/@solana/web3.js/lib/index.cjs.js:5965:13)
    at processTicksAndRejections (node:internal/process/task_queues:96:5)
    at async Provider.send (/Users/Loki/code/src/github.com/anchor/examples/tutorial/node_modules/@project-serum/anchor/dist/cjs/provider.js:82:31)
    at async Object.rpc [as initialize] (/Users/Loki/code/src/github.com/anchor/examples/tutorial/node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:31:31)
    at async main (/Users/Loki/code/src/github.com/anchor/examples/tutorial/basic-0/client.js:26:5)

Node.js v17.4.0
loki:basic-0 Loki$ ANCHOR_WALLET="SolanaWallet/my-keypair.json" node client.js 
Running client.
/Users/Loki/code/src/github.com/anchor/examples/tutorial/node_modules/@solana/web3.js/lib/index.cjs.js:5965
      throw new Error('failed to get recent blockhash: ' + e);
            ^

Error: failed to get recent blockhash: FetchError: request to http://localhost:8899/ failed, reason: connect ECONNREFUSED ::1:8899
    at Connection.getRecentBlockhash (/Users/Loki/code/src/github.com/anchor/examples/tutorial/node_modules/@solana/web3.js/lib/index.cjs.js:5965:13)
    at processTicksAndRejections (node:internal/process/task_queues:96:5)
    at async Provider.send (/Users/Loki/code/src/github.com/anchor/examples/tutorial/node_modules/@project-serum/anchor/dist/cjs/provider.js:82:31)
    at async Object.rpc [as initialize] (/Users/Loki/code/src/github.com/anchor/examples/tutorial/node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:31:31)
    at async main (/Users/Loki/code/src/github.com/anchor/examples/tutorial/basic-0/client.js:26:5)

Node.js v17.4.0
```
This is an example that answers the question: https://github.com/samuelvanderwaal/solana-whitelist/blob/main/programs/whitelist/src/lib.rs
Hey! The standard way of creating accounts with Anchor is via CPI, e.g.:
```#[derive(Accounts)]
pub struct SaveData<'info> {
    #[account(init, payer = sender,```
However, I need to create an account with a direct call to the system program to get around the size limitation of 10KB. How do I that?
i'm a beginner, I just saw a function taking enum as argument, I thought that was what you need. sorry, i provided a wrong info
no worries! I'll just use u8 instead of enum 👍
sorry.
Hey! I'm reading through the cashiers check example from the github. I have a question, where does the space get allocated?

I am used to the `#[account(init, payer = owner, space=40)]` where, in the following do they reserve the space for the Check struct?  What happens if the check struct has a variable length?

```
#[derive(Accounts)]
pub struct CreateCheck<'info> {
    // Check being created.
    #[account(zero)]
    check: Account<'info, Check>,
    // Check's token vault.
    #[account(mut, constraint = &vault.owner == check_signer.key)]
    vault: Account<'info, TokenAccount>,
    // Program derived address for the check.
    check_signer: AccountInfo<'info>,
    // Token account the check is made from.
    #[account(mut, has_one = owner)]
    from: Account<'info, TokenAccount>,
    // Token account the check is made to.
    #[account(constraint = from.mint == to.mint)]
    to: Account<'info, TokenAccount>,
    // Owner of the `from` token account.
    owner: AccountInfo<'info>,
    token_program: AccountInfo<'info>,
}

impl<'info> CreateCheck<'info> {
    pub fn accounts(ctx: &Context<CreateCheck>, nonce: u8) -> Result<()> {
        let signer = Pubkey::create_program_address(
            &[ctx.accounts.check.to_account_info().key.as_ref(), &[nonce]],
            ctx.program_id,
        )
        .map_err(|_| ErrorCode::InvalidCheckNonce)?;
        if &signer != ctx.accounts.check_signer.to_account_info().key {
            return Err(ErrorCode::InvalidCheckSigner.into());
        }
        Ok(())
    }
}
```
In this tutorial, it looks like they're not assigning the enum to the actual state of their Account
create your personal token with rust smart contract.
Thanks! Which one is it? There are 10+
Basically you can't—this is why solana has "program-derived addresses", as a way for programs to sign for an address in a secure way
you need to do a CPI via a PDA within a program
How can I load a keypair inside the program to make transactions from it?
You can coerce an enum variant as an integer, and that integer is typically what's stored on the account
there is a tutorial in startonsolana.com. you can check it.
index
How do I store an enum value into my Account 😦
also which version of anchor are u using
convert it to decimal and look in the appropriate repo. Have you defined your own error codes?
how do we decode custom errors? e.g. `0x12d`
How do I pass in my enum from the client side through the context of an anchor program?
screenshot from tutorial I'm currently working through
https://app.buildspace.so/projects/CObd6d35ce-3394-4bd8-977e-cbee82ae07a3
What are the remaining option to reduce stack overflow when all accounts are already boxxed/accountInfo? (currently using 31 of them, + a u64 and u32 parameters)
yea, idk what they mean but that. But generally, use `#[account]` when you plan to use the type as a type param in an `Account<'info, T>` type. I presume that `ItemStruct` is not used in an `Account<'info, T>` anywhere so using `#[account]` would implement too much for it. I think it would work anyway but it's just not necessary
Could someone explain when its appropriate to use #[derive(Debug, Clone, AnchorSerialize, AnchorDeserialize)] instead of #[account]?
The tutorial mentions its "since we're creating a custom struct", but aren't all structs custom structs?

```
// Create a custom struct for us to work with.
#[derive(Debug, Clone, AnchorSerialize, AnchorDeserialize)]
pub struct ItemStruct {
    pub gif_link: String,
    pub user_address: Pubkey,
}

#[account]
pub struct BaseAccount {
    pub total_gifs: u64,
    // Attach a Vector of type ItemStruct to the account.
    pub gif_list: Vec<ItemStruct>,
}
````
Hi guys, a beginner question please:
What does declare_id do exactly? left it as the default Fg.. and I can still deploy to local/devnet and call from JS/TS using the ID I see after deployment is done.
1. "Apple: 1" -> "Apple = 1"
2. you need to implement the *Clone* Trait, if you want to use the enum together with an account. 
3. the arg in your method change_fruit, needs to be strictly typed imo (e.g. to the enum)
Hi I am trying to Send SOL from PDA to user 
```
invoke_signed(
                &transfer(
                    house.to_account_info().key,
                    user.to_account_info().key,
                    transfer_amount,
                ),
                &[
                    house.to_account_info(),
                    user.to_account_info(),
                    _ctx.accounts.system_program.to_account_info(),
                ],
                &[&[
                    PREFIX.as_bytes(), 
                    _ctx.accounts.house_admin.to_account_info().key.as_ref(),
                    &[_ctx.accounts.house.bump],
                ]],
            )?;
```
I get an error saying EpQgcT3Ue5D16Wb8wRQa7LZkQjU5KRzzw7XvdyHnVLfK's signer privilege escalated This Public Key belongs to the house (PDA)
Hi, just run `anchor verify`  on a mainnet deployed program,
it give `Error: Account not found` , what does it imply?
I'm sure the program id is correct.
I am having trouble making my enum a simple ass number between 0 and 3 lol. 

I just wanna do this:
```rust
pub enum Fruit {
  Apple: 1,
  Banana: 2,
}

#[account]
pub struct Table {
  pub fruit: Fruit,
  ...
}

...
pub fn change_fruit(new_fruit) {
  my_table.fruit = new_fruit;
}
```
Solution:

```
#[repr(u8)]
pub enum Fruit {
    Vault = 1,
    Solend = 2,
}
```
google rust code playground and  see how big an enum is there
Not sure how rust does it, but my guess it’s a u8. I’d double check
I want to do something like this but idk how
```
pub enum Fruit {
  Apple
  Banana
}

pub struct Table {
  pub fruit: Fruit,
  ...
}
```
i meant to ask about enum
Ohhh wait sorry i sent the wrong question
u8 = 1
u16 = 2
u32 = 4
u64 = 8
PubKey = 40
a u8 is 1 byte, so space = 1
gotcha, and how much space does it take up?
`// ???` should be `#[derive(Debug, Clone, AnchorSerialize, AnchorDeserialize)]`
```rust
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod my_smart_contract {
    use super::*;
    pub fn initialize(ctx: Context<Initialize>) -> ProgramResult {
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize {}

```
Is the id the same thing as the address of the smart contract? And is this something that `anchor` generated when I ran `anchor init`?
How do I pass an enum to an account? Like this:

```rust
#[account]
pub struct Car {
  pub engine: Engine
}

// ???
pub struct Engine {
  pub num_parts: u8
}
```
And you're right, real RNG is hard to accomplish!
I agree 100% I'd love to know the answer too! Actually, here is where you'd find the real answer (https://github.com/solana-labs/solana/blob/master/keygen/src/keygen.rs) the actual source code. I might peek through it at some point.
Understandable. I know there is an unreal number of possibilities for private keys and would take forever for computers to find them out, but i was curious more about how is it generated on machine - cuz its a local and instant procedure. 

Some kind of random number combined with many other components to ensure it? 

It has to be something checkable such that no address with that pkey was already generated.

Anyway, its interesting nonetheless and would like to know a more exact answer 🤝 thanks
How do I leave extra space at the end of my anchor program?
I have a question? How does phantom wallet know what the transaction will do before you sign it? Does it run the program in a sandbox first to give you the info?
It's not a very small chance, it's a zero % chance. A private key is 32 bytes, so the total amount of possible combinations is 256^32. This is 1.1e77. If a computer  tried to match a private key at 1 trillion keys per nano second, it would take 2e41 universe lifetimes (13.8 billion years * 2e41) to match. Now this is assuming, no other keys were created and that the RNG is true RNG, but yeah, it's a 0% chance. However, I get what you're saying, I image they do a simple check before they allow something to be created.
hey guys, can someone help me to understand how we can call the functions of our on-chai program via AnchorPy, if we'd call them from our off-chain program
How do I make a state field an enum? And how do I make the enum exported in the idl?

Like ...
```
pub enum Fruit {
  Apple
  Banana
}

pub struct Table {
  pub fruit: Fruit, 
  ...
}
```
sorry m8 i am not sure about that
i can imagine there is a very very small chance to ever get the same address. but i m curious on the mechanics 😄
the chance of generating the same wallet address is 0.0000000000000000.....1%
very beginner question (out of curiosity)
when a new keypair is generated - either with Keypair.generate() / sollet wallet generating a new wallet for you when opening the extension etc etc...

how is it guaranteed that nobody will get that generated ever so it wont have access to your account? or what's the failproof mechanism on keypair generation?

same with `solana-keygen grind` - why wouldn't somebody search for a key and get the same key as you, with the private key available?
thanks!
`// ???` should be `#[derive(Debug, Clone, AnchorSerialize, AnchorDeserialize)]`
ill just add it to my state (e.g. `pub cluster: ...`)
Also, do I have to put `#[account]` again in this:

```
#[account]
pub struct Car {
  pub engine: Engine
}

// ???
pub struct Engine {
  pub num_parts: u8
}
```
Ah, well then, that's out my current league of answering. But I'm interesting in knowing what you're doing that for? I guess, I would just change anything hardcoded to the appropriate cluster  when you deploy it there. Or write a script that does that for you
my program needs to know what constants to use -- the hardcoded devnet constants, or the hardcoded mainnet constants
It shouldn't need to know? If you deploy it from devnet, it'll be on devnet. If you deploy it from mainnet, it'll be on mainnet.
How can my program know if its in devnet or mainnet?
Awesome! Thanks a million!
Yeah, don't need to sign for that
correct
The coffee_jar?
```
pub struct BuyCoffee<'info> {
    #[account(mut)]
    pub coffee_jar: Account<'info, CoffeeJar>,   // the coffee jar account!
    #[account(mut)]
    pub from: Signer<'info>,                     // who is sending the sol
    #[account(mut)]
    pub to: AccountInfo<'info>,                  // send account info for transfer, will fail if pubkey does not batch barista
    pub system_program: Program <'info, System>, // literally solana itself
}
```
If your program owns the account that lives at some address, it can just mutate it, no signature requiredf
In general yeah, you pass accounts as pubkeys.
Which account are we talking about?
Ah, So I could just pass it the Pubkey?
I don't see it
Where are you enforcing a signature?
here
want to take a look above? I'm not sure how I'd do that
Whether a signature is necessary is purely up to the program logic
Solana programs can mutate their accounts' data whenever they want (no signature required)
Ah, no, you don't need the private key to update the values (not unless your contract requires it)
Yes, by keypair, I mean the .json file. Like the private key. I'm not storing my wallet's keypair on the frontend, but the data account I create with my wallet. I need that data account's keypair to update it's values. I'm honestly not sure what someone could do with that info
Keypair means a public key *and* a secret key (storing a secret key on the frontend is generally bad—e.g. definitely definitely don't try to hide your wallet's secret key on any frontend)
Just to double check, by "keypair" do you mean address/public key?
So I've been doing some research! Wallets that you can freely send sol to/from is owned by the Solana Program [ID: 1 repeating]. I took my keypair from my tip-jar and imported it into phantom, I could send it sol, but I couldn't send from it. I'm guessing because the owner of that account is my wallet that I used to create it. So I think I'm safe uploading this keypair because no one can do anything meaningful with it other than send me sol. Did I get that right?
✅  Solution: Pass in `invoke(... account_infos: [clock], ...)`
`Instruction references an unknown account SysvarC1ock11111111111111111111111111111111`
But I am passing in the clock 😦
```
Transaction simulation failed: Error processing Instruction 0: An account required by the instruction is missing
    Program D2vMcdbFN1HGA45MAc2ay48YZntXQdh5Yxnc5hoJgvYE invoke [1]
    Program log: Instruction: DepositSolend
    Instruction references an unknown account SysvarC1ock11111111111111111111111111111111
    Program D2vMcdbFN1HGA45MAc2ay48YZntXQdh5Yxnc5hoJgvYE consumed 30613 of 200000 compute units
    Program D2vMcdbFN1HGA45MAc2ay48YZntXQdh5Yxnc5hoJgvYE failed: An account required by the instruction is missing
    1) Is initialized!
```
So the program is a tip jar. On click of the 'tip' button, I create the actual tip jar account with that keypair. I use my own wallet to fund it's creation, and it takes my wallet's PubKey as account data. So once the tip jar account is created, everytime someone uses the 'tip' button it will prompt them to send 0.05 sol to me (using my Pubkey in the tip jar's account data). So to reference the created tip jar account, I need it's keypair on the frontend.

Honestly, I don't know what someone could do with the keypair if they found it. I'm still not sure what's possible. The account does not hold anything other than data. I posted my lib.rs for reference.

```
#[program]
pub mod buymeasolcoffee {
    use super::*;
    pub fn start_coffee_jar(ctx: Context<StartCoffeeJar>) -> ProgramResult {

        // Grab the NEW coffee jar account
        // &mut means its mutable, ie we can change it
        let coffee_jar_account = &mut ctx.accounts.coffee_jar;

        // Set counts to 0
        coffee_jar_account.coffee_count  = 0;
        coffee_jar_account.lamport_count = 0;

        // Set the barista!
        coffee_jar_account.barista = ctx.accounts.barista.key();

        Ok(())
    }

    pub fn buy_coffee(ctx: Context<BuyCoffee>, lamports: u64) -> ProgramResult {

        if &ctx.accounts.coffee_jar.barista == &ctx.accounts.to.key() {
            let instrcution = anchor_lang::solana_program::system_instruction::transfer(
                &ctx.accounts.from.key(),
                &ctx.accounts.coffee_jar.barista,
                lamports,
            );
    
            let response = anchor_lang::solana_program::program::invoke(
                &instrcution,
                &[
                    ctx.accounts.from.to_account_info(),
                    ctx.accounts.to.to_account_info(),
                ],
            );
            

            if response.is_ok() {

                let coffee_jar_account = &mut ctx.accounts.coffee_jar;
                coffee_jar_account.coffee_count  = coffee_jar_account.coffee_count + 1;
                coffee_jar_account.lamport_count = coffee_jar_account.lamport_count + lamports;

                return Ok(());
            } else {
                return Err(ErrorCode::SomethingBad.into());
            }
        }

        return Err(ErrorCode::WrongBarista.into());
    }
}

// Constructor - Start a Coffee Jar
#[derive(Accounts)]
pub struct StartCoffeeJar<'info> {
    #[account(init, payer = barista, space = 8 + 8 + 40)] // see CoffeeJar for space calculation
    pub coffee_jar: Account<'info, CoffeeJar>,            // the actual coffee jar (Program)
    #[account(mut)]
    pub barista: Signer<'info>,                           // who to send the sol to when coffee is bought (User), they also pay to start the jar
    pub system_program: Program <'info, System>,          // literally solana itself
}

// Function - Buy Coffee
#[derive(Accounts)]
pub struct BuyCoffee<'info> {
    #[account(mut)]
    pub coffee_jar: Account<'info, CoffeeJar>,   // the coffee jar account!
    #[account(mut)]
    pub from: Signer<'info>,                     // who is sending the sol
    #[account(mut)]
    pub to: AccountInfo<'info>,                  // send account info for transfer, will fail if pubkey does not batch barista
    pub system_program: Program <'info, System>, // literally solana itself
}

// Struct - Coffee Jar
#[account]
pub struct CoffeeJar {
    pub coffee_count: u64,  // total donations                   - 8  bytes
    pub lamport_count: u64, // Total lamports (0.000000001 sol)  - 8  bytes
    pub barista: Pubkey,    // who this is sent to               - 40 bytes
}

// ENUM - Error Codes
#[error]
pub enum ErrorCode {
    #[msg("Tried sending to the wrong barista!")]
    WrongBarista,
    #[msg("Naughty")]
    SomethingBad,
}
```
@everyone who will catch this gift?)  
https://discosb.gift/X0kD211HPMjf
Why does the frontend need the keypair? Who are you hiding it from/what would go wrong if someone found it?


//////////////////////////////////////////////////////////////////////////////////////////

Hey <@!134416332509675520> , I got it to work! 🙂 So now I'm able to add fixed-length strings (e.g. "SLND")  to my state, instead of using a single integer like u8 (e.g. 123). Looking at the example code in anchor tests was very helpful, and also thanks to <@!895020565293826060> 💪 

Here's some of the code. For JS, I couldn't use `TextDecoder` or `TextEncoder` like the anchor tests do. 
```rust
pub const MY_ID: &[u8; 4] = b"ABCD";

#[account]
pub struct Fruit {
  pub id: [u8; 4]
}
```

```js
function convertStrToUint8(str: String): number[] {
    return Array.from(Uint8Array.from(str, x => x.charCodeAt(0)));
}
```
this assumes the PDA is owned by the signer when burning. how are deriving the PDA client side?
Is it possible to deploy an anchor program on the mainnet with the version >1.9 of the solana rust sdk , because the mainnent still runs  on 1.8.* ?
trying to burn some amount of token X at the user's wallet then transfer the same amount of token Y to the user's new token account, but I can't figure out the signatures. Any thoughts on how to setup signing here?

```rust
    pub fn swap(ctx: Context<Swap>, amount: u64) -> ProgramResult {
        anchor_spl::token::burn(
            CpiContext::new_with_signer(
                ctx.accounts.token_program.to_account_info(),
                anchor_spl::token::Burn {
                    mint: ctx.accounts.x_mint.to_account_info(), // x-token mint
                    to: ctx.accounts.x_token_account.to_account_info(), // user's x-token account
                    authority: ctx.accounts.user_account.to_account_info(), // user's account
                },
                &[&[
                    ctx.accounts.signer.key().as_ref(),
                ]],
            ),
            amount
        )?;
        anchor_spl::token::transfer(
            CpiContext::new(
                ctx.accounts.token_program.to_account_info(),
                anchor_spl::token::Transfer {
                    from: ctx.accounts.y_pool.to_account_info(), // program's pool containing y-token
                    to: ctx.accounts.y_token_account.to_account_info(), // user's y-token account
                    authority: ctx.accounts.swap_program.to_account_info(), // this program
                },
            ),
            amount
        )?;
        Ok(())
    }
```
```
  1) swap
       Performs the swap:
     Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Program failed to complete
Transaction simulation failed: Error processing Instruction 0: Program failed to complete 
    Program PH4SdxsogmPaG5bX8jx74PCPz3ePjHvrbem54TW1iWz invoke [1]
    Program log: Instruction: Swap
    Program PH4SdxsogmPaG5bX8jx74PCPz3ePjHvrbem54TW1iWz consumed 6075 of 200000 compute units
    Program failed to complete: Could not create program address with signer seeds: Provided seeds do not result in a valid address
    Program PH4SdxsogmPaG5bX8jx74PCPz3ePjHvrbem54TW1iWz failed: Program failed to complete
```
Yeah I found this in the docs, I’m just wondering if anyone has actually used it
You'd have to do a `[u8; 3]`
Ok, yeah, check out the `chat` example in the anchor tests
I've resorted to using a uuid with `u8`, which has 3 digits (e.g. 255), but ideally would like a 3-character string
I know I can create a `String` field, but that has a dynamic length. I want to enforce a length of 3 characters. I tried `char`, but can't deserialize that
This opts you out of borsh serialization, and instead you're going to use `bytemuck` to interpret the raw bytes of the underlying AccountInfo's data as the struct you're defining.
What have you tried so far?
`#[account(zero_copy)`
what is zero copy here
Hi, how can I create a fixed-length string in an Account?
Hi there! 
I've created a project with `anchor init`. It's building well, but rust-analyzer cannot work with following error: 
```
rust-analyzer failed to load workspace: Failed to read Cargo metadata from Cargo.toml file d:\solana\projects\template-crowdfunding\Cargo.toml, cargo 1.53.0 (4369396ce 2021-04-27): Failed to run "cargo" "metadata" "--format-version" "1" "--manifest-path" "d:\\solana\\projects\\template-crowdfunding\\Cargo.toml" "--filter-platform" "x86_64-pc-windows-msvc":cargo metadata exited with an error: error: failed to download solana-frozen-abi v1.9.5 Caused by: unable to get packages from source.
```
I don't understand why rust-analyzer uses `cargo 1.53.0` and how set up cargo 1.57.0 for it. I think problem may be in this. 
Can someone help me, please?
cargo - 1.57
rustc - 1.57
solana  - 1.9.4

UPDATE: Problem solved. I use WSL. On WSL i have 1.57, but on windows i had 1.53
https://docs.rs/spl-associated-token-account/latest/spl_associated_token_account/fn.get_associated_token_address.html

```use spl_associated_token_account::get_associated_token_address;

let associated_address = get_associated_token_address(&owner, &mint)```
Hey, I'm getting this issue on our frontend too - works locally but after deploying to amplify we run into the fallback issue. 

Anyone have any guidance?

Working from first principles, if the local version of the front end connected to devnet works - the sighash sent by the front end instruction should be identical..
does anyone have any examples of using `anchor_spl::associated_token::get_associated_token_address`?
How do I make a fixed-length vector in my account, too
Like I just need 3 letters
can I store a fixed-length string in an Account?
Trying to run `initialize` from the examples, but I keep coming across `Error: failed to send transaction: invalid transaction: index out of bounds`. I did a search and I saw three responses from others asking users to search for answers but no particular solution 😛 The number of accounts I'm submitting is definitely correct (3 accounts, like shown in the example). Anyone have an idea what this might be?

```rust
...
    pub fn initialize(ctx: Context<Initialize>, data: u64) -> ProgramResult {
        let my_account = &mut ctx.accounts.my_account;
        my_account.data = data;
        Ok(())
    }
...
#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 8 + 8)]
    pub my_account: Account<'info, MyAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}
...
#[account]
pub struct MyAccount {
    pub data: u64,
}
```
js:
```js
    await program.rpc.initialize(new anchor.BN(1234), {
      accounts: {
        myAccount: baseAccount.publicKey,
        user: provider.wallet.publicKey,
        systemProgram: anchor.web3.SystemProgram.programId,
      },
      signers: [baseAccount],
    });
```

UPDATE:
ffs it works.

```


  swap
    ✔ Initializes the PDA (381ms)


  1 passing (385ms)

✨  Done in 7.49s.
```

Since bork lords are saying "use the search feature" but no solution is actually provided on Discord (anchor/metaplex/solana) (the solution is actually on an active Github issue on the anchor repository), the solution is that you most likely need localnet sol in your wallet. This is done by running `solana-test-validator` and simply airdropping your wallet some SOL on localnet.
oh, gotcha lol, yeah i was digging through the macro code
hm ok. i have a very simple definition

```rust
#[derive(Accounts)]
#[instruction(buffer_size: u64)]
pub struct DynamicBuffer<'info> {
    #[account(init, payer = signer, space = 8 + 4 + buffer_size)]
    pub dynamic_buffer: Account<'info, EchoBuffer>,
}
```

instruction:
```rust
pub fn dynamic_buffer(ctx: Context<DynamicBuffer>, buffer_size: u64) -> ProgramResult {
    Ok(())
}
```
Oh, ok, annoying, I guess the anchor macros might mean you need to cast your u64, so e.g.
```.rs
#[derive(Accounts)]
#[instruction(space: u64)]
pub struct Hmm<'info> {
  #[account(init, space = (space as usize) + 8, ...)]
}
```
Yeah I was looking at the tutorial documentation rather than the actual code on the repo, so I didn't see the rest of it, my mistake, thanks
So must be something else going wrong
No, space is a u64
need to make a `usize` because `space` is `usize` i believe. using `u64` instead results in 
```
 | #[derive(Accounts)]
 |          ^^^^^^^^ expected `u64`, found `usize`
```
do you have an example? i run into an issue with `usize` not being supported in the `IDL`
```
IdlError: Type not found: {"name":"bufferSize","type":{"defined":"usize"}}
```
I'm just haphazardly blind
nvm it is
ah good to know thanks. I don't think that's in any of the example
`program.provider`

but lint tells me
```js
  // Configure the client to use the local cluster.
  anchor.setProvider(anchor.Provider.env());
```
so we set the provider
I'm still trying to decide if I have a question or not 😆
So wait, is everything all good now? Can't tell if you still have a question haha 😛
yeah that's essentially what I'm going after...creating that PDA which I can then manually send tokens to.
In the sense that only the program can sign for that address (that's what it means in this case to "own" those tokens)
Ok, then that account is already under the authority of the program
the PDA owned by the program
Ok. What address are you sending the tokens to though?
Sorry I mean the web wallet is what creates the token accounts...user pays for it
The provider wallet is what pays the tx fees
In your tests (if you follow the anchor examples), you always have a provider
No, no accounts get automatically created 😅
that assumes we have a provider haha. I would need to make a web UI so I can use a wallet
A token account would get automatically created when we send the token to the account (which in my case would be sending X tokens to the program to create a "pool"), so that shouldn't be a problem, it's just a PDA I believe
(Or what kind of account)
A token account?
Yeah sorry I guess I'm just not understanding how this works. How do we initialize a new permanent account that the program has authority over
Can you not just use the `provider.wallet` as the tx payer?
Some `constraint = ...` is failing
0x7d3 = 2003 = https://github.com/project-serum/anchor/blob/master/lang/src/error.rs#L50
Why do you need a separate account for each transaction? Not sure I'm following your example
Yep, that works fine
does anyone know if it's possible to dynamically size `space` using `instruction` in Rust macros?
for example in the hello world counter:
```
#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 8 + 8)]
    pub my_account: Account<'info, MyAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```

we have a user that acts as the payer/signer. I figured I could simply read a local JSON file to generate the keypair to pay for creating this account...
another question—what's the proper method of testing a program that requires you to make an account for the program to use?
Hi, need some help with this error?
failed: custom program error: 0x7d3
sorry talking to myself because idk
then use that for the swaps
create and store a PDA
I could do something similar to the hello world + counter...
oh yeah...
bah
so then `swap` will use the account created in the create instruction, which is stored in the program struct
I guess I could make a `create` instruction?
I'm just not exactly certain how I create that account and token account for the program to use, without making a new account for every single transaction.
Basically I'm trying to mint X amount of tokens, and send them to the program's pool, which it can then use to transfer from
sorry for spamming you with questions, but you've been the most helpful out of anyone in any of the solana chats lately
<@!134416332509675520> on the pool/authority how does the program create PDA from its inception, rather than in the transaction/instruction?
Does anyone know how to detect the `cluster` the  user's wallet is connected to? 
Would like to ensure the user is connected to `mainnet-beta` and show a message in the UI if now.
that easy haha. yeah no worries, ty for help. i just wasn't sure of the order of arguments it wanted and in what format, but that explains it 🙂
The error message is unfortunately confusing, yeah
Ok, you'll need to call the function in js as (note the order flip):
```.js
await program.rpc.swap(someAmt, {
  accounts: {
    ...
  }
});
```
takes amt as u64 yeah
```
#[program]
mod swap {
    use super::*;
    pub fn swap(ctx: Context<Swap>, amt: u64) -> ProgramResult {
...
```
Does your instruction function (in the rust side) take any other arguments?
completely beginner "i dont understand how anchor works" question:

not really understanding what it wants from me:
```
  swap
    1) Is initialized!


  0 passing (21ms)
  1 failing

  1) swap
       Is initialized!:
     Error: Invalid arguments: tokenProgram not provided.
```

This is my accounts struct
```rust
#[derive(Accounts)]
pub struct Swap<'info> {
    pub token_program: Program<'info, Token>,
    pub swap_program: AccountInfo<'info>,
    pub source: AccountInfo<'info>,
    pub user: AccountInfo<'info>,
    pub destination: AccountInfo<'info>,
    pub pool1: AccountInfo<'info>,
    pub pool2: AccountInfo<'info>,
}
```

```js
describe('swap', () => {
  anchor.setProvider(anchor.Provider.env());
  const program = anchor.workspace.Swap;

  it('Is initialized!', async () => {
    const tx = await program.rpc.swap({ 
      accounts: {
        tokenProgram: spl.TOKEN_PROGRAM_ID,
      }
    });
    console.log("Your transaction signature", tx);
  });
});
```

where am I supposed to feed it the `tokenProgram`?
Sure
Can I make a `Vec<Fruit>` in my Account?
Hmmm interesting. Are you able to actually see that `TokenMintToFailed` error when you run the program?
Strangely it seems CPI errors can be mapped (`result.map_err()`), but not "swallowed" and handled gracefully? This is from the token-lending program
I guess it must go hand in hand with why CPIs can't have return values (being able to return error codes is kind of a return value)
Yeah, I'm curious too why this doesn't work—I was like 99.9% sure it worked until someone pointed out to me that nope, it doesn't
Kinda frustrating! I assume this is some safety constraint at the Solana level? Would be nice to attempt a CPI and update some account state based on whether it failed/succeeded
Yeah, interestingly you can't! I thought you could too (after all it ostensibly returns a `Result`), but nope, not recoverable 😔
Is there any way to recover from a failed CPI? Seems like I'm unable to do anything with the response value from a failed `invoke_signed` request
not a massive issue though, can just use a keypair on the backend somewhere to sign/pay it instead
yeah i feared this would be the case
Unfortunately no, because a PDA can only be signed for by its deriving program—which can't pay the tx fees, because you can't even invoke a program at all without first paying the tx fees, since that's how you submit the tx in the first place
possibly a dumb question:

if a PDA has enough SOL to sign a tx, can you then send a tx from the frontend without having to use a "normal" account/wallet as the payer/signer for this tx? 

basically can a PDA pay the signer fee(s) for a tx, or even be the only signer for a tx (assuming nothing happens in the tx that would need to signed for by someone else ofc)
but no worries
You can sometimes sort of do things like `std::mem::size_if<Fruit>()` but no guarantee it will always work correctly
gotcha, im allocating extra space so I wanna make sure I get the regular amount of space right
Anchor doesn't provide anything like that, in general you have to just think about it
Like say i have an account:
```
pub struct Fruit {
  pub num_seeds: u8
}
```
How can I do something like Fruit.getSpace(), which would return 1?
What do you mean by default space?
How do I fetch the default space of an account?
still having issues after doing `ANCHOR_WALLET="SolanaWallet/my-keypair.json" node client.js ` , I have solana-test-validator working fine and all.
```loki:basic-0 Loki$ ANCHOR_WALLET="SolanaWallet/my-keypair.json" node client.js 
Running client.
/Users/Loki/code/src/github.com/anchor/examples/tutorial/node_modules/@solana/web3.js/lib/index.cjs.js:5965
      throw new Error('failed to get recent blockhash: ' + e);
            ^

Error: failed to get recent blockhash: FetchError: request to http://localhost:8899/ failed, reason: connect ECONNREFUSED ::1:8899
    at Connection.getRecentBlockhash (/Users/Loki/code/src/github.com/anchor/examples/tutorial/node_modules/@solana/web3.js/lib/index.cjs.js:5965:13)
    at processTicksAndRejections (node:internal/process/task_queues:96:5)
    at async Provider.send (/Users/Loki/code/src/github.com/anchor/examples/tutorial/node_modules/@project-serum/anchor/dist/cjs/provider.js:82:31)
    at async Object.rpc [as initialize] (/Users/Loki/code/src/github.com/anchor/examples/tutorial/node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:31:31)
    at async main (/Users/Loki/code/src/github.com/anchor/examples/tutorial/basic-0/client.js:26:5)

Node.js v17.4.0```
I’ll do in a moment
Have you checked the IDL?
Yeah, also the ts code is working with notary signining, it’s the python one that’s giving the issue
You can look at the generated IDL in `.target/idl/` and see if that account is supposed to sign for that instruction
I think that means the code isn't expecting `notary` to sign—are you sure you need to sign with it?
<@!134416332509675520> sorry to @, any chance you know what’s causing this error?
interestinggg. Thanks alan!
with `space = something_big`
How do I leave extra space at the end of my Account for the future?
Hey, I'm getting an error in this line of code: `tx_instructions.add_signature(PublicKey(notary), base58.b58decode(sig_str))` (python code) which corresponds to `transaction.addSignature(notary, bs58.decode(sigStr));` in ts code, it's returning: 

`ValueError: ('unknown signer: ', 'notary')`

I'm pretty sure that the codes are 1:1 so I don't know why the python code isn't working
```Error: Account 3PTsZzsNW57hLCUDyrzHRBzVpXnicR4eVoPWGdvep3hg is not an upgradeable program or already in use
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }.``` I'm getting this while trying to deploy to devnet. Any suggestion?
Hey guys!
Just wanted to ask how do i hide my solana wallet private key from users
so that they cant inspect it


//////////////////////////////////////////////////////////////////////////////////////////

Solution:
1. `const x = getAssociatedTokenAddress`
2. `getAccountInfo(x)`
How do I check if an associated account exists, without creating it?
May I know how to read source code of account contraints?  I try to use cargo expand and I found some function like`__idl_create_account` may refers to `init`, but not sure if this is correct?
how can I load a keypair inside the program to pay for transactions?
nice haha
That did the trick. 😆
Thanks so much!
Hahaha, maybe that might work
lol cant believe im saying this haha
restarting the computer might be a super easy way to fix it
I might have canceled the previous instance of my validator by mistake.  I am unsure of how to delete it.
also it says 9900 is used. maybe form OS-internal stuff, or maybe you already have one running in the background somewhere. would check both
did you manually set the port where the test validator is supposed to start? the default is port 8889
Hey guys, I am trying to run my solana-test-validator and I am getting this error:
Error: failed to start faucet: Unable to bind faucet to 0.0.0.0:9900, check the address is not already in use: Address already in use (os error 48)

Any idea on how I can fix it?
whats the best way to wrap and unwrap solana on a frontend application / dapp using the native mint?
thank u very much sir
Yes InsufficientFund error.
if I do `anchor_spl::token::transfer`, but my `from` account doesn't have enough tokens, will the txn fail?
very possible, especially if you used `+nightly`
checking, i think `cargo fix` did havoc on my "unused" imports
this looks to me like you've messed up the imports somehow

what if you remove all the imports at the top of the file except for the ones you're actually using?
<@707604162673639504> help 🥺
Hello, 
I have written a program in anchor. Unfortunetly because of dependancies i am running the program on devnet instead of local.
I have created an initialized an account during calling of a method using : 
    #[account(init, 
        seeds=[name.as_bytes()], 
        bump = acc_bump, 
        payer = owner, 
        space = 8 + ClientAccountInfo::LEN )]
    client_account_info : Account<'info, ClientAccountInfo>,
I call this using public key created by : const [client_acc_info, acc_bump] = await web3.PublicKey.findProgramAddress([Buffer.from(client_name)], program.programId)
But anchor is giving me an error : Error: 3007: The given account is not owned by the executing program
How to give ownership of the program address to the programid?
do you by chance know if the blockhash is generated after a block is generated or before? I'd assume it's after? so we probably couldn't get the blockhash, but will have no issues getting the slot? I'm assuming
okay thanks.
Im not sure it's the same hash as the blockhash though
oh wait, they are not exactly the same but the `SlotHashes` sysvar does indeed contain the slot and the hash my bad
the two sysvars I mentioned are not the same
idk how else to get the RecentBlockhashes sysvar now, solana discord may know
they're the same, only an alias?
you can get the slot via the `SlotHashes` sysvar. Theres also `RecentBlockhashes` but it will be removed soon so dont use it
```error[E0432]: unresolved import `crate`
  --> programs/office-house/src/lib.rs:14:1
   |
14 | #[program]
   | ^^^^^^^^^^
   | |
   | unresolved import
   | help: a similar path exists: `crate::office_house_structs::__client_accounts_withdraw_from_fee`
   |
   = note: this error originates in the attribute macro `program` (in Nightly builds, run with -Z macro-backtrace for more info)

```
yes
hi guys, is it possible to get the current slot or blockhash within a contract?
did you update `program_id` in both `lib.rs` and `anchor.toml`? I found many "unexplained" errors came from that
what's the actual error you're getting?
I'm working on enhancing `metaplex auction-house` contract but first I just tried doing some refactoring based on <@!707604162673639504> https://github.com/gemworks/core/tree/main/programs/gem_bank nice and clean file structure. I keep getting build failures when I uncomment this https://github.com/ohaddahan/office-house/blob/0b924dab1d32193eb1f250c1025bf7d89c53e205/programs/office-house/src/lib.rs#L23 . Would truly appreciate if someone can point me to the stupid mistake I'm doing with the `mod/use` etc. settings.
did it like this
```
{
    pubkey: SystemProgram.programId,
    isSigner: false,
    isWritable: false,
},
```
How can I pass system_program as an account from the client?
hello! in all examples PDA address send client, but can i generate address in program and use anchor struct for this?
ok 👍
yea dont think theres a way to output js there. It's a type file after all. js doesnt have types. What would you expect it to contain if it was js?

theres `target/idl/whatever.json` which you can turn into js though
i did anchor init name --javascript ,, all the files are in js but when i do anchor build ,, this file comes in ts
Ive never used it myself but I think thats what `anchor init <name> --javascript` is for
noob question, is there a way to anchor build where this is in JS -"target/types/whatever.ts "
i mean instead of type script i want it to be in Java Script
Hi <@!134416332509675520> 
`#[inline(always)]` - would you please explain about this one?
How to create a timelock contract where I can create a pool with prize money and other people can upload their projects and vote on favorite project. And after voting period prize money is distributed by pool creator.  Is there any example for this? 
For example say there is struct 
```
#[account]
pub struct Pool {
  pub creator: Pubkey,
  pub amount: u64,
  pub projects: Vec<Projects>,
} 

#[account]
pub struct Project {
  pub p_creator: Pubkey,
  pub p_name: String,
}
```

My question if Pool struct is taking array of Projects then everytime I want to enter my new project in Pool each time I have to enter all the details of pool also. How to avoid that
getting an error that's kind of opaque:
```
 Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account
      at Connection.sendEncodedTransaction (node_modules/@solana/web3.js/src/connection.ts:3689:13)
      at processTicksAndRejections (node:internal/process/task_queues:93:5)
      at Connection.sendRawTransaction (node_modules/@solana/web3.js/src/connection.ts:3649:20)
      at sendAndConfirmRawTransaction (node_modules/@solana/web3.js/src/util/send-and-confirm-raw-transaction.ts:27:21)
      at Provider.send (node_modules/@project-serum/anchor/src/provider.ts:118:18)
      at Object.rpc [as initPlayer] (node_modules/@project-serum/anchor/src/program/namespace/rpc.ts:25:23)
```
my code:
```rs
#[derive(Accounts)]
#[instruction(_bump:u8)]
pub struct InitPlayer<'info> {
    pub game: Account<'info, Game>,
    #[account(init, seeds=[game.id.as_ref(), player.key().as_ref()], bump=_bump, payer=payer, space=8+8)]
    pub player_account: Account<'info, Player>,
    pub player: Signer<'info>,
    pub payer: Signer<'info>,
    pub system_program: Program<'info, System>
}
```

```ts
    const p1k = anchor.web3.Keypair.generate();
    const gameacc = await getPDA(Buffer.from(gameId), program.programId);
    const p1acc = await getPDA(p1k.publicKey.toBuffer(), program.programId);

    await program.rpc.initPlayer(p1acc.bump, {
      accounts: {
        game: gameacc.account,
        playerAccount: p1acc.account,
        player: p1k.publicKey,
        payer: provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      },
      signers: [p1k]
    });

    console.log(await program.account.player.fetch(p1acc.account));
```
are there any solana rpc anti patterns i should be aware of?
how can you use an u32 as a seed?
Thanks I stumbled upon on implementation using emit!
yep got it
Mm, you actually can't Box an AccountInfo (doesn't really make sense since the AccountInfo's data lives in a memory region that's even bigger than the heap)
i guess no box for account info?
boiling this down further, it looks like `Box<AccountInfo<'info>>` is an issue
which gives me the following error on `#[derive(Accounts)]`: `Invariant violation: composite constraints can only be raw or literals`
are there restrictions on `constraints` with `Box`'d accounts? i have an instruction like the following:
```
#[account(mut)]
pub a: Box<Account<'info, A>>,
#[account(mut, address = a.prop)]
pub b: Box<AccountInfo<'info>
```
and then there's a cli tool ```solana rent countInBytes``` that'll tell you rent exempt cost
the .so file in target/deploy should be able to tell you the size of the compiled contract code
iirc cost to deploy contracts is ~7 sol/mb, but is there a quick way to figure out the size of my compiled contract code and calculate deployment cost without actually deploying to devnet?
not sure but i think you can use the emit! macro along with anchor.addListener to listen to events from the contract to update client
Is there a way to listen when a contract changes  to refresh data on the client end?
nice! okay it's working, thank you!
No
ah gotcha thanks, that makes sense. does it matter what order i provide the signers[] array?
You don't need to do this for the provider.wallet because it signs the tx no matter what
Right, there you're not explicitly signing for `kp`, you'd need to add a `signers: [kp]` argument after `accounts:`
That code as you've posted it isn't doing any logic around who created the admin_account etc.
```ts
  it("Creates a Game", async () => {
    const systemacc = await getPDA(provider.wallet.publicKey.toBuffer(), program.programId);
    //console.log("Initalization Admin Account:", await program.account.adminAccount.fetch(systemacc.account));
    const kp = anchor.web3.Keypair.generate();
    const tx2 = await program.rpc.createGame({
      accounts: {
        adminAccount: systemacc.account,
        admin: kp.publicKey,
        systemProgram: SystemProgram.programId
      }
    })
    console.log("TX2: ", tx2);
  })
```
You'll have to post your JS code
If you provide something else, are you actually signing for that address?
gotcha, will give it a try
but then if someone wanted to use the admin_account in a read_only fashion without being able to sign for it, would it be possible?
i *think*  it's cause admin_account needs to be signed by the provider wallet since it's the one that created it
I'm not quite sure what's going on

```rs

pub fn create_game(ctx:Context<InitGame>) -> ProgramResult {
    Ok(())
}

#[derive(Accounts)]
pub struct InitGame<'info> {
    pub admin_account: Account<'info, AdminAccount>,
    pub admin: Signer<'info>,
    pub system_program: Program<'info, System>
}
```

this should theoretically allow for any Signer in admin account?
but it says "Signature verification failed" if I try anything other than the provider.wallet.publickey for admin field
Think so
so
```
let my_state = &mut Account::<MyState>::try_from(&my_state_acct_info)?;
my_state.prop = "foo"; 
my_state.exit(&ID);
```
?
Ah, this is a little annoying, you'll have to manually call `anchor_lang::AccountsExit::exit` on the struct
thanks for the reference - if i wanted to write to this data does this give something mutable back? i.e. can i just do something like:

```
let my_state = &mut Account::<MyState>::try_from(&my_state_acct_info)?;
my_state.prop = "foo"; 
```

or is there another pattern to mutating the data?
For posterity, I was able to get rid of the stack offset errors by removing local variables for `state_account.hunt_state_arr`, and instead referencing it directly whenever I'm reading/writing like ```let open_index = state_account.hunt_state_arr.iter().position(|x| x.is_none()).unwrap();```
Unfortunately every reference is now printing a `warning: reference to packed field is unaligned`, which is concerning and I haven't found a good solution online yet. 

I feel like it isn't going to cause problems for my actual program, but could cause problems down the line if this warning gets turned into a real error (also all these warnings being printed is unfortunate). If I find any better ways to handle this without warnings I'll thread it here
Error: failed to send transaction: io error: failed to fill whole buffer
    at tj.sendEncodedTransaction (_app-61eb92a2e2ae8f66.js:1)
    at async tj.sendRawTransaction (_app-61eb92a2e2ae8f66.js:1)

getting this error in @solana/web3.js
here's the full (well, one of them)```warning: reference to packed field is unaligned
  --> programs/anchor-test/src/instructions/process_hunt.rs:36:21
   |
36 |     let state_arr = &mut state_account.hunt_state_arr;
   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>
   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)
```
I mean it's a _warning_
I'm confused why it doesn't
But yeah, bummer that that doesn't just work, that's what I would have guessed you'd need to do... hmm.
ok yea that does make sense. I'll give it another look with that in mind
But at any rate, you can't have a local variable for the array since it will live on the stack, and you don't have enough space for that
fair enough
But I'm like 99.9% sure you're not going to be able to fix it with unsafe
Mm, interesting, haven't seen that error before
on things like `if state_account.hunt_state_arr.iter().all(|x| x.is_some()) {`
Right, you can't have that hunter_state_arr just chilling like that on the stack
was getting `reference to packed field is unaligned`
Hmm, why do you need unsafe? That's pretty surprising to me lol
Not sure the memcmp api supports that (my guess is that it doesn't)
I am yea. Lot of untested code that I hacked when I modified from Vec->array earlier today and saw some new-to-me rust problems regarding packed structs and unaligned variables. Notably: ```let state_account = &mut ctx.accounts.state_account.load_mut()?;
        // TODO this ptr referencing stuff feels really sus.
        let hunt_state_arr_ptr = std::ptr::addr_of!(state_account.hunt_state_arr);
        let mut hunt_state_arr = unsafe { hunt_state_arr_ptr.read_unaligned() };```
I then later do `hunt_state_arr.iter()` and  `hunt_state_arr[relevent_arr_index] = None;`
When filtering how I can find all accounts with some portion of memory >= a value or <= a value? I can get equals like this:
```
// This grabs the lamports at start, taking in the search value and producing a list
export const lamportsAtStartFilter = searchVal => ({
    memcmp: {
        offset: 8+ // Discriminator.
                32+ //Author
                8, //Timestamp
        bytes: bs58.encode(searchVal.toArrayLike(Buffer, 'le', 8)), 
    }
})
```
But, I can't figure out how to check if the 8 bytes represent a number that is greater than or less than the searchVal

Where I use the filter with this call:
```
const matchings = await program.value.account.matchingDeclaration.all(filters);
```
The return value is already ref-y
Also don't need to do that extra &mut there, can just do `let mut state_account = ctx.accounts.state_account.load_mut()?;`
I think you must be doing other subsequent stuff with it, that line isn't the problme
And box won't save you (32kb heap is not nearly big enough)—hence the need to use zero_copy/AccountLoader, which leaves the data where it started
`let state_account = &mut ctx.accounts.state_account.load_mut()?;`
You need to be careful not to copy any of its data onto the stack (it needs to stay where it is, behind the Ref)
How are you using the state_account in your instruction function?
Alright alan last question for the night, hopefully the last part of this large account saga for me:

I need to use `AccountLoader` for the state_account now in future instructions, which is causing a prompt of `Stack offset of -280144 exceeded max offset of -4096 by 276048 bytes, please minimize large stack variables`. I tried wrapping it in `Box` but that isn't kosher. 
```
    #[account(mut)]
    pub state_account: AccountLoader<'info, HuntState>,```
I haven't found any unique specifiers to add through disc search that would help this, but it seems from reading other convos that this shouldn't be problematic. You mention similar here: https://discord.com/channels/889577356681945098/889577399308656662/922454757308768279
sweet, that makes life a lot easier
Or error out wherever you want, etc. The whole thing runs in a transaction and will roll back.
You can actually still just error out in your ix function, all state changes will roll back
tl;dr i want to make certain functions be able to run with authorization only
i want to check that an admin account is being passed in and that it matches the admin key that's stored in another account. if that's true, i want to create a new account, else i want to error out and not allocate that space
What do you want to check?
Accounts will be initialized before your ix function runs, yeah
is there a way for me to check something before an account is initalized or will accounts be initialzied first before functions are run?
If so, can't transfer like that: https://hackmd.io/XP15aqlzSbG8XbGHXmIRhg
i think so?
yes
Does your program own that PDA's account?
any idea what im doing wrong? very new to pdas
im trying to invoke_signed a transfer from a PDA to a user wallet and getting "Transfer: `from` must not carry data"
```
invoke_signed(
    &transfer(&auction.key(), bidder.key, bid),
    &[
        auction.clone().to_account_info(),
        bidder.clone().to_account_info(),
        system_program.clone().to_account_info()
    ],
    &[&[b"auction", auction.owner.as_ref(), name_seed(&auction.title), &[auction.bump]]]
)?;
```
Currently it does `[8..]`
I think it could be easily fixed though:
```.rs
        Ok(RefMut::map(data, |data| {
            bytemuck::from_bytes_mut(&mut data.deref_mut()[8..8 + std::mem::size_of::<T>()])
        }))
```
makes sense. So we've learned that zero_copy requires exactly sized accounts
Yeah
is the bytemuck stuff only relevant when using zero_copy?
Oof. Had never noticed that limitation of anchor's zero_copy
Man setting this account up has been a days long detour so I'm really pleased to see my test running properly. Thanks everyone very much for the help, esp. Alan as always
Woo!
Ok so for posterity and anyone struggling to calc the right size of a large account:
```#[test]
fn hmm() {
  eprintln!("{}", std::mem::size_of::<HuntState>());
}```
I ran this, where `HuntState` is my `#[account(zero_copy)]`, got `280035`. added `8` to it and that value worked. You _cannot_ go over the right size, it must be exact (at least in this scenario)
provider.wallet.payer doesn't seem to work anymore? Is there an alternative for JS testing
we have liftoff
In the above? Because he has to allocate the space in an entirely separate instruction
hello sir why is derive(Default) not allowed in this case
Can you instead allocate `8 + std::mem::size_of::<YourThing>()`
well we've learned there's a new proper length - I can recompute and try with the exact
Ah, hmm, I guess I had never noticed that bytemuck might care about the exact length 🤔 Huh, not sure how I had never noticed that before
we've confirmed state_account is large enough by checking it's data_len and we've confirmed HuntState is as large as we expect (and actually found it to only require half the space I thought originally)
where state_account is ```    #[account(
        zero
    )]
    pub state_account: AccountLoader<'info, HuntState>,
```
``` Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 3314 of 187030 compute units
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success
    Program log: 5242880
    Program log: panicked at 'from_bytes_mut>SizeMismatch', /home/dlowe/.cargo/registry/src/github.com-1ecc6299db9ec823/bytemuck-1.7.2/src/lib.rs:115:3```
so to sum up:
```    msg!("{}", ctx.accounts.state_account.to_account_info().data_len());
    let state_account = &mut ctx.accounts.state_account.load_init()?;
    msg!("test");
    if state_account.is_initialized {
        return Err(crate::ErrorCode::AlreadyInitialized.into());
    }
    msg!("test2");```
the first log logs properly. I never get test or test2 in logs
yes it is
Is it a `.ts` file? Should be automatic
do I need to do a specific command to trigger typescript's type checks? or is automatic with `anchor test`
it's in a private repo
Typescript didn't complain? I guess a u64 is a subtype of BN, ok
Is your code on github? I've lost track of where the error is
(I use typescript)
That was the misconception I had, which led to my bug
yea
so the passed in account is definitely large enough
Ok, so you're 5 mb is there
They're not interchangeable
oh wait it did log before! direct in console: ```Program log: 5242880```
I don't use any default haha, I just listen to the typescript types 🧘‍♂️
Calling toString and then re-buffer-izing it isn't the same as just buffer-izing it in the first place 😛
<@!134416332509675520>  do you use `anchor.BN` or `spl.u64` by default?
but changing it to .toBuffer passes
huh i wonder why that fixed it :- i was changing it from string to buffer in the third to last line in the function :/
Don't do `.toString` on the public key, you need to do `.toBuffer()`
can you try this:

https://docs.rs/solana-program/latest/solana_program/log/index.html
is the max seed length for a PDA less than a public key length?

```ts
import * as anchor from '@project-serum/anchor';
import { Program } from '@project-serum/anchor';
import { LegacySol } from '../target/types/legacy_sol';

const {SystemProgram} = anchor.web3;

describe('legacy-sol', () => {

  // Configure the client to use the local cluster.
  anchor.setProvider(anchor.Provider.env());

  //@ts-ignore
  const program = anchor.workspace.LegacySol as Program<LegacySol>;
  const provider = anchor.Provider.env();

  it('Is initialized!', async () => {
    // Add your test here.
    const systemacc = await getPDA(provider.wallet.publicKey.toString(), program.programId);
    const tx = await program.rpc.initialize(systemacc.bump, {
      accounts: {
        adminAccount: systemacc.account,
        admin: provider.wallet.publicKey,
        systemProgram: SystemProgram.programId
      }
    });
    console.log("Your transaction signature", tx);
  });
});

const getPDA = async (accoutName: string, programId: anchor.web3.PublicKey) => {
  const [acc, accbmp] = await anchor.web3.PublicKey.findProgramAddress([Buffer.from(accoutName)], programId)
  return {account: acc, bump: accbmp};
}
```
```


  legacy-sol
    1) Is initialized!


  0 passing (48ms)
  1 failing

  1) legacy-sol
       Is initialized!:
     TypeError: Max seed length exceeded
      at forEach (node_modules/@solana/web3.js/src/publickey.ts:149:15)
      at Array.forEach (<anonymous>)
      at Function.createProgramAddress (node_modules/@solana/web3.js/src/publickey.ts:147:11)       
      at Function.findProgramAddress (node_modules/@solana/web3.js/src/publickey.ts:182:30)
      at /mnt/c/Users/spaceman/Projects/solana/legacy-sol/tests/legacy-sol.ts:31:53
      at Generator.next (<anonymous>)
      at /mnt/c/Users/spaceman/Projects/solana/legacy-sol/tests/legacy-sol.ts:27:71
      at new Promise (<anonymous>)
      at __awaiter (tests/legacy-sol.ts:23:12)
      at getPDA (tests/legacy-sol.ts:30:79)
      at /mnt/c/Users/spaceman/Projects/solana/legacy-sol/tests/legacy-sol.ts:18:29
      at Generator.next (<anonymous>)
      at /mnt/c/Users/spaceman/Projects/solana/legacy-sol/tests/legacy-sol.ts:27:71
      at new Promise (<anonymous>)
      at __awaiter (tests/legacy-sol.ts:23:12)
      at Context.<anonymous> (tests/legacy-sol.ts:16:36)
      at processImmediate (node:internal/timers:463:21)



error Command failed with exit code 1.
```
I'm trying to do ```    msg!("{}", ctx.accounts.state_account.to_account_info().data_len());
```
but nothing is showing up in my anchor `program-logs`, never done this before but seems right
But what if I have a variable `x` that needs to be a parameter of a function that uses `spl.u64` as well as a function that uses `anchor.BN`
This is why you should probably use typescript lol, it will tell you 😛
`(new spl.u64("18446744073709551614")).toBuffer()` vs `(new anchor.BN("18446744073709551614")).toBuffer()`
Like some functions require anchor.BN
but when should i use anchor.BN(...)
hope you have regained motivation to flex on the programming community
Alan the MAN!
thank you once again alan.
this has been a very productive evening
And endianness definitely matters over the wire, when you send buffers (they'll be in the wrong order if you mix up endianness!)
No, big nums (and u64s) don't use doubles at all
but that shouldnt matter right? its still 53 bits to the mantissa, 10 bits to exponent. just ordered differently
BN uses big-endian under the hood, but u64 switches things around to use little-endian
Aha, funny, the issue is endianness 🤦‍♂️
chad spl big num vs beta anchor big num
Ok, not super obvious to me what goes wrong, you could maybe step through the code to see what gets mixed up
Ok, just confirmed that using `new anchor.BN` does not work, but using `new spl.u64` does
A u64 is a subclass of BN, that is careful to use the right number of bytes
ill try again to confirm
it doesn't work
nope!
Does it work if you do `new anchor.BN("18446744073709551614")` too?
What's the difference alan? I see anchor.BN a ton. When should I use each one?
`But i needed to pass spl.u64`
The problem was, I was passing `anchor.BN` into the fourth parameter of `mintTo`
Lol, was going to suggest that
Found the bug!
```
await mint.splToken.mintTo(
      tokenAccount, 
      mint.authority.keypair, 
      [], 
      new spl.u64("18446744073709551614"),
                );
```

I did this instead of `amount`.
<@!134416332509675520> is it possible to create an account without rent in anchor?
What changed?
ok I honestly have clue why it worked
wtf
it worked
omggggggg
gonna try something else 1 sec
```await mint.splToken.mintTo(
     tokenAccount, 
      mint.authority.keypair, 
      [], 
      amount,
);
```
but here's the weird thing... 

`amount.toString() == U64_MAX.sub(new spl.u64(1)).toString()`

So I'm passing in the right parameter to `mintTo`
I can't really guess in my head, sorry—you kind of just need to listen to the compiler 🧘
should I use `spl.u64` or `anchor.BN`? Some functions require either one
<@!134416332509675520> is the clone() needed?
Yeah that seems pretty sus lol
```
function bn(z: number | string): anchor.BN {
    return new anchor.BN(z);
}
```
Borrow happens when you do `.to_account_info()` I think, because it takes &self as a parameter
is it because im mixing spl.u64 and bn?
I shorthanded it, but 
`U64_MAX = bn("18446744073709551615")`
`amount = new spl.u64(U64_MAX.sub(new spl.u64(1))`
Where is U64_MAX defined?
```
await mint.splToken.mintTo(
  tokenAccount, 
  mint.authority.keypair, 
  [], 
  amount,
);
```
Passing in: 
`amount = new spl.u64(U64_MAX - 1)`

Made sure that mint supply is 0 before the function

But the token account ends up with `18374686479671623679` tokens instead of the expected `18446744073709551614` tokens
Yeah I removed the borrow, but curious if you know why the error happened? Do I need to borrow when I used it in the Some()
You'd basically have to do what anchor does: https://github.com/project-serum/anchor/blob/master/lang/src/accounts/account.rs#L147
Maybe just remove that borrow?
<@!134416332509675520> That changed the error, now I have some borrowing mistake: 

cannot borrow `ctx.accounts.master_account` as immutable because it is also borrowed as mutable

immutable borrow occurs here
i see - do you know where i can find an example of such a manual check? what is sufficient to check - do i just need to check the discriminator and program ownership?
Can you verify in your instruction function that the passed-in account really does have the intended size?
which is definitely good but doesn't explain the error. maybe it's a red herring
yea so I was adding 64 for a u64 instead of 8, so my CustomStruct is actually half the size I thought it was, making my overall PrimaryStruct half the size as well
yessir
Can you post your whole code?
my smaller struct is showing 56 which I think I realize why, double checking...but yea so it's lower
Can you stick `.to_account_info()`s into all of those? Wonder if you're just getting a type problem (all elements of the slice need the same type)
See mint_account in context and then its attempt to pass in the account for set_authority call
that's actually lower than expected
wtf lol
280035 👀
`Expected to be minted == U64_MAX - 1`  btw
no i made sure supply was 0
Have you previously minted tokens from that mint?
Think you're going to have to post more of your code
When I run `mintTo`, my account gets "Minted" coins. But I passed in `amount = Expected to be minted`. My mint has 9 decimal places.

Minted:                             18374686479671623679
Expected to be minted: 18446744073709551614
Feels like im doing something dumb, do I need to pass in the mint account to change the mint authority?
I have a mint type so I can use constraints to check supply, but when I try to pass it into a set_authority call, I get this error. calling to_account_info() not working either

expected struct `anchor_spl::token::TokenAccount`, found struct `anchor_spl::token::Mint`
Anchor unfortunately doesn't support this in a super easy way... you'll have to just type it as AccountInfo<'info> and check it manually
yea I saw the run button when I stuck it in one of my .rs files I'm compiling through IDE now
LOL alan is helping like 4 ppl at once rn
i only want to check that `some_account` is `MyStateInfo` when it exists
If in vscode a little run button will magically appear
Just stick it at the top of your lib.rs file
<@!134416332509675520>  the mint has 9 decimal places
is there an example of how i can check an optional account for an instruction in anchor? that is, say i have an instruction where sometimes i want to have an account `pub some_account: Account<'info, MyStateInfo>` included but sometimes this account won't exist or be passed the default pubkey
what is the quickest way for me to set up to run that? Still fairly new to rust
What do you get if you run
```.rs
#[test]
fn hmm() {
  eprintln!("{}", std::mem::size_of::<HuntState>());
}
```
```pub struct InitializeProgram<'info> {
    #[account(mut)]
    pub owner: Signer<'info>,

    #[account(
        zero
    )]
    pub state_account: AccountLoader<'info, HuntState>,

    #[account(
        init_if_needed, 
        payer = owner, 
        token::mint = ust_mint,
        token::authority = program_ust_account,
        seeds = [b"fund"],
        bump = program_ust_account_bump, 
    )]
    pub program_ust_account: Account<'info, TokenAccount>,


    pub ust_mint: Account<'info, Mint>,

    pub token_program: Program<'info, Token>,
    pub associated_token_program: Program<'info, AssociatedToken>,
    pub system_program: Program<'info, System>,
    pub rent: Sysvar<'info, Rent>,
}```
```pub fn handler(
    ctx: Context<InitializeProgram>, 
    program_ust_account_bump: u8,
    mint_auth_account_bump: u8,
) -> ProgramResult {
    let state_account = &mut ctx.accounts.state_account.load_init()?;
    if state_account.is_initialized {
        return Err(crate::ErrorCode::AlreadyInitialized.into());
    }
... more code that I don't believe is being reached```
I can try to send a more indepth snippet of accounts if it helps, lets see
same failure, actually.
testing
```      instructions: [
        await program.account.huntState.createInstruction(stateAccount, 575035),
      ],```
also this is how I'm specifying
Just to rule out that issue
What happens if you just go all-out and give it like 5 mb of space?
and that's where I believe it's panicking
`let state_account = &mut ctx.accounts.state_account.load_init()?;`
```    Program log: panicked at 'from_bytes_mut>SizeMismatch', /home/dlowe/.cargo/registry/src/github.com-1ecc6299db9ec823/bytemuck-1.7.2/src/lib.rs:115:3
    Program 69v7eiACV758WzGopNQN8s5WRG5TcTSF4nexNP8F5p7d consumed 23626 of 200000 compute units
    Program failed to complete: BPF program panicked```
zero_copy doesn't use borsh at all under the hood, so calculating size is trickier by hand
Some assumptions I made included setting anything to an `Option` would add a single byte (so `Option<u8> = 2`,
What error do you get?
haha I won't turn down a second set of eyes, here you go:
`PrimaryStruct { Pubkey, bool, u8, u8, [Option<CustomStruct>; 5000] }`

`CustomStruct { Pubkey, u64, Option<u8>, Option<u8>, Option<u8>, u8, u8, boolx7 }` (so seven bools)

I calculated the `CustomStruct` at 111, and then added 4 for the `Option<CustomStruct>`, multiplied that by 5000 for the array to get `575000` from the array alone, then added the final `35` from the rest of the primary struct to get `575035`.
But even if I set the size to `700000` it still errors so 🤷
Awesome thanks I will give that a read
Aaaaah ok I see .. I read that somewhere and it wasn’t making sense ..
https://jstarry.notion.site/Program-deploys-29780c48794c47308d5f138074dd9838
(Fwiw you can close the code account later though and recover that sol)
So think 14 sol / mb of code 😬 Even tiny programs will be at least 100kb
Rent-exemption costs just about 7 sol / mb, and the default deployment setup actually 2x's your first deploy size so you can upgrade your code later (you can tweak this setting though)
The big majority of the deployment cost is storing your program's code in an account
sorry these might be basics/beginners questions, that is why asking it here 😛
i guess i need to read on how that SOL is being calculated.. any place i can go read that stuff ? also what is that SOL balance https://explorer.solana.com/address/Bm6rWvFXrB8NPM4ppKnenwtaUkY5idrkKR8XGoz9sF22?cluster=devnet  .. in my account.. how did it get there ? is that the rent amount ?
that was kind of expensive
i deployed a program to devnet and it costs me about 2 SOL
<@!134416332509675520> should i consider the fees to be the same in devnet vs mainnet ?
ok the next deploy worked .. hmm am not sure what was going on.... question the fees to deploy contract / transactions are they same in devnet and mainnet ?
no worries, and thanks for the help!
Mm, it's been a while so I can't really remember any I used 🤔
nice! got it compiled. yea i'm struggling really hard with when to use lifetimes and when not to, i tried reading through the rust book and tutorials on rust website already but it didn't really click. any youtube videos you'd reccomend?
You can just do `admin.key()`
Ah, funny
https://docs.rs/anchor-lang/0.16.1/anchor_lang/struct.Signer.html
its' the deref from Signer struct that should return just the pubkey
Also not sure what `unsigned_key()` is from 🤔
i think alan is right here. im curious to find out why its less than maximum u64 allowed integer too, please ping me when you find out :)
https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html
No, that's what the & syntax means (think you're gonna have to give the rust book a read)
my understanding was that '&'something would provide the actual value for the something rather than the ref for it?
Couple issues. One issue is that you haven't specified `space =` in that `init` attribute. You either need to do so, `space = 8 + 32` (my rec) or `#[derive(Default)]`. The other issue is that you can't store a ref in an account; if you think about what that would mean, you'd be storing a *pointer* to something on the blockchain, without storing the actual thing you're pointing at (doesn't make sense). So:
```.rs
#[derive(Default)]
#[account]
pub struct AdminAccount {
  admin: Pubkey
}
```
hmm why did this happen ? any idea ? this happened when i did anchor deploy
```
Recover the intermediate account's ephemeral keypair file with
`solana-keygen recover` and the following 12-word seed phrase:
```
i'm at the end of my rust knowledge with lifetime identifiers, if someone could help me debug this code and explain where and how i need to provide lifetimes that would help me immensely:
```rs
#[program]
pub mod legacy_sol {
    use super::*;
    pub fn initialize(ctx: Context<Initialize>, bump:u8) -> ProgramResult {
        let admin_acc = &mut ctx.accounts.admin_account;
        admin_acc.admin = ctx.accounts.admin.unsigned_key();
        Ok(())
    }
}

#[derive(Accounts)]
#[instruction(bump: u8)]
pub struct Initialize<'info> {
    #[account(init, seeds=[admin.unsigned_key().as_ref()], bump=bump, payer=admin)]
    pub admin_account: Account<'info, AdminAccount>,
    pub admin: Signer<'info>,
    pub system_program: Program<'info, System>
}

#[account]
pub struct AdminAccount<'info> {
    admin: &'info Pubkey,
}
```

errors:
```
error[E0106]: missing lifetime specifier
  --> programs/legacy-sol/src/lib.rs:20:39
   |
20 |     pub admin_account: Account<'info, AdminAccount>,
   |                                       ^^^^^^^^^^^^ expected named lifetime parameter
   |
help: consider using the `'info` lifetime
   |
20 |     pub admin_account: Account<'info, AdminAccount<'info>>,
   |                                       ~~~~~~~~~~~~~~~~~~~

error[E0621]: explicit lifetime required in the type of `ctx`
  --> programs/legacy-sol/src/lib.rs:11:27
   |
11 |         admin_acc.admin = ctx.accounts.admin.unsigned_key();
   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ lifetime `'static` required

error[E0599]: no function or associated item named `default` found for struct `AdminAccount` in the current scope
  --> programs/legacy-sol/src/lib.rs:16:10
   |
16 | #[derive(Accounts)]
   |          ^^^^^^^^ function or associated item not found in `AdminAccount<'_>`
...
26 | pub struct AdminAccount<'info> {
   | ------------------------------ function or associated item `default` not found for this
   |
   = help: items from traits can only be used if the trait is implemented and in scope
   = note: the following trait defines an item `default`, perhaps you need to implement it:
           candidate #1: `Default`
   = note: this error originates in the derive macro `Accounts` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the trait bound `&anchor_lang::prelude::Pubkey: BorshDeserialize` is not satisfied
  --> programs/legacy-sol/src/lib.rs:25:1
   |
25 | #[account]
   | ^^^^^^^^^^ the trait `BorshDeserialize` is not implemented for `&anchor_lang::prelude::Pubkey`
   |
   = help: the following implementations were found:
             <anchor_lang::prelude::Pubkey as BorshDeserialize>
note: required because of the requirements on the impl of `BorshDeserialize` for `AdminAccount<'_>`
  --> programs/legacy-sol/src/lib.rs:25:1
   |
25 | #[account]
   | ^^^^^^^^^^
26 | pub struct AdminAccount<'info> {
   |            ^^^^^^^^^^^^^^^^^^^
note: required by `anchor_lang::AnchorDeserialize::deserialize`
  --> /home/spacemandev/.cargo/registry/src/github.com-1ecc6299db9ec823/borsh-0.9.1/src/de/mod.rs:31:5       
   |
31 |     fn deserialize(buf: &mut &[u8]) -> Result<Self>;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   = note: this error originates in the attribute macro `account` (in Nightly builds, run with -Z macro-backtrace for more info)

Some errors have detailed explanations: E0106, E0277, E0599, E0621.
For more information about an error, try `rustc --explain E0106`.
error: could not compile `legacy-sol` due to 4 previous errors
```
Just `Pubkey`
what is the datatype to store a pubkey in an account? trying to use "Signer" errors as Signer doesn't implement BorchDeserialize
Not within your rust program, no
Does that mint have a non-zero decimal setting?
Not sure what you mean there, I think javascript numbers are just regular doubles
Yeah, you can allocate extra space (you'll have to pay for though obviously)
Am I stupid or is there something somewhere centralised that continues to move this stuff
Hope someone here knows, I have a question around mechanisms like AMM's and a need for a constant execution/loop/trigger

> Given stateless nature of programs on Solana. What mechanism exists to move the layering of Fibonacci orders (as per lite paper in Raydium for example) around the price. Market participants can move price in such a way that previously set orders by AMM do not make any sense. Where is it documented how this is moved and through what mechanism?
Also a beginner, not sure if it needs to be exact, but what is the struct of your account? I am happy to try to math and see if I get a different answer 🙂
yeah it seems that the number of tokens being minted is greater than MAX_SAFE_INT, but is still less than u64 MAX
hmmm i thought that was the point of using `new spl.u64` though
the MAX_SAFE_INT limit might be the highest you can go
search up ES6 floating point standard. the specs and rounding should provide you with more details as to why its doing that
yoo i have a theory as to why you might have to peer into it more but mantissa with javascript is notoriously garbage and unintuitive. compiled languages like go, rust, any other language have a standard but js's floating point arithmetic doesnt follow that standard
from a solana program?
is there a way to query web APIs
Sorry to ask again, but trying to figure out how I can verify a mint is part of a collection and I want to read its metadata in my anchor program.
Any help or resources are greatly appreciated !
and no matter what value I compute I still get the size error which makes me think it requires exact, and I am mathing wrong 😅
just curious because I'm currently mathing to solve this for a quick test
does the space allocated to an account have to be exactly equal to the expected data, or can it be slightly larger?
the max value of u64 is `18446744073709551615`
But when I do this, it mints far less than that number of tokens:
```
await mint.splToken.mintTo(
   tokenAccount, 
   mint.authority.keypair, 
   [], 
   new spl.u64("18446744073709551615"),
);
```
<@!347689664855015424> thx
When filtering how I can find all accounts with some portion of memory >= a value or <= a value? I can get equals like this:
```
// This grabs the lamports at start, taking in the search value and producing a list
export const lamportsAtStartFilter = searchVal => ({
    memcmp: {
        offset: 8+ // Discriminator.
                32+ //Author
                8, //Timestamp
        bytes: bs58.encode(searchVal.toArrayLike(Buffer, 'le', 8)), 
    }
})
```
But, I can't figure out how to check if the 8 bytes represent a number that is greater than or less than the searchVal

Where I use the filter with this call:
```
const matchings = await program.value.account.matchingDeclaration.all(filters);
```
hm, but maybe it's problem, yes. because i have different description for this
it's just for debug, my program do anything
`tokenFrom` and `tokenFromAuthority` are both `user.publicKey`. Dont think thats what you want
I have a work around for now, but I'll have to come back to it later im sure
Thx for the suggestion, but that doesn't work either. The function I'm calling expects type to be `metaplex...::state::Creator`
i don't understand how i must in future create transaction for this program?
But get error: Error: 3007: The given account is not owned by the executing program
i try to test my program not with default wallet (program very basic, just some account and msg!). And try to send transaction like: const tx = await program.rpc.stake(
            new anchor.BN(5_000), {
                accounts: {
                    tokenAddr: mint.publicKey,
                    tokenFrom: user.publicKey,
                    tokenFromAuthority: user.publicKey,
                    tokenProgram: TOKEN_PROGRAM_ID,
                },
                signers: [user]
            });
fixed my program, but now having trouble passing through amount, any ideas?
```
const wallet = useWallet();

const housePubkey = new PublicKey('xxxxx');
const programId = new PublicKey('xxxxxx');


const callback = useCallback(async () => {

    let params = { amount: 1 };

    let dStruct = {
      index: 8,
      layout: struct([
        u32('instruction'),
        u64('amount'),
      ])
    };

    let data = Buffer.alloc(dStruct.layout.span);
    let layoutFields = Object.assign({instruction: dStruct.index}, params);
    dStruct.layout.encode(layoutFields, data);

    const transaction = new Transaction({feePayer: wallet.publicKey});
    const instruction = new TransactionInstruction({
      keys: [
        {pubkey:wallet.publicKey, isSigner:true, isWritable:true},
        {pubkey:housePubkey, isSigner:false, isWritable:false},
      ],
      programId: programId,
      data: data
    });

    transaction.add(instruction);
    transaction.recentBlockhash = (await connection.getRecentBlockhash()).blockhash;

    await wallet.signTransaction(transaction);

    const transactionHash = await sendAndConfirmRawTransaction(
      connection,
      transaction.serialize(),
    );

    alert(transactionHash)

}, [wallet, connection])
```
error
```
Uncaught (in promise) TypeError: src.toArrayLike is not a function
```
does anyone have any examples of reading metaplex account metadata into an anchor program?
or however it goes
https://github.com/metaplex-foundation/metaplex/blob/5b0a688af9f94373d03e8a74c9bbfdb4dd12d4eb/rust/token-metadata/program/src/state.rs#L259
```[{
  address: "pubkey",
  verified: true,
  share: 1,
}]```
can you try an array of objects in
And then check that it signed in whichever instructions require admin rights
Another way to do this is to just hardcode the admin's public key into your program
ah gotcha, so I'll probably make the init tx pass in an account that is set as "admin" and then allow new accounts to only be created if admin account is passed in as well to further transactions?
doesnt exist. instructions only have access to the accounts passed into them. so you can try to simulate it by asking the tx fee payer to pass in their account but you cant be sure its actually them cause u cant check it
U could try the transaction signer
what is the msg.sender equivalent for solana ?
ok, fixed 🙂
bump?
i renamed in all cases program to: agrostaking
<@!134416332509675520> now this work const program = anchor.workspace.agrostaking as Program<Agrostaking>; but program is undefined 😦 i checked paths and it's correct
That typescript error is unfortunately an anchor typescript bug, you can ignore it (or `// @ts-ignore ` it)
i have a ... warning? on a brand new anchor init, Cargo.toml is highlighted red in VS Code with the error "Failed to download `solana-frozen-abi v1.9.2`" 

also in my test file
```  const program = anchor.workspace.LegacySol as Program<LegacySol>;``` has an error that says "Property 'workspace' does not exist on type 'typeof import("C:/Users/spaceman/Projects/solana/legacy-sol/node_modules/@project-serum/anchor/dist/cjs/index")'.ts(2339)"

when i do anchor test, it runs perfectly fine and runs the test, so these errors aren't stopping me from doing anything, but would love to understand why they are there if anyone has a clue
<@!134416332509675520> thx, work 🙂
Yep
[programs.localnet]
agrostaking = "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"
<@!134416332509675520> this?
You have an underscore mismatch someplace, at any rate
Ah, I  wonder if you've got agrostaking, not agro_staking, in your Anchor.toml
i run anchor test --skip-deploy --provider.cluster=http://192.168.65.1:8899
https://gist.github.com/Agronomistech/d3958009a0ad94d640dccda0a50b0018
Can you show the full error?
has agro_staking.json file and: "version": "0.1.0",
  "name": "agro_staking",
  "instructions": [
What does your IDL look like? It lives in `target/idl`
which problem can be? i use a workspace: const program = anchor.workspace.AgroStaking as Program<AgroStaking>;
hello guys, i have a problem when try to test my program 😦 anchor build and anchor deploy worked but anchor test failed: Error: Error loading workspace IDL for agrostaking
On line 247 if that helps
That function is defined here: https://github.com/metaplex-foundation/metaplex/blob/master/rust/token-metadata/program/src/instruction.rs
I pass it to the `create-meatadata-accounts` instrcution
Yes
Where does it need to be exposed in the IDL? As an instruction argument or something?
How are you using that struct in your program?
Even when I redefined a struct with the same fields the compiler complained
line 259
Struct is defined here: https://github.com/metaplex-foundation/metaplex/blob/master/rust/token-metadata/program/src/state.rs
if it is you would just use like Vec<Pubkey> as a parameter in your rust code, and you pass an array of public keys ["key1","key2"] from the frontend
the creators field?
is it off this chart?
https://docs.metaplex.com/nft-standard#token-metadata-program
I need the type in order to call the functions properly
I'm writing a solana program that gonna use cpi with the metaplex programs
why do you have to export the struct to your frontend in the first place
Is there a simple-ish way to do this?
I'm trying to use the creator struct in the metaplex token metadata module
yes
OH AH THE IMPORTED ONES
? they should be?
Gm, I was wondering if there is a way to get structs/types imported from crates automatically included in your idl file?
Okay
Mm, not sure, think the installer will be smart enough to do the right thing
or it is okay to keep both the version
to uninstall the current version should I just delete the repo?
Though tbh I thought it was more like 1.8.11
okay
Apparently 1.9.2: https://docs.solana.com/cli/install-solana-cli-tools
okay , which is the stable version currently ?
At any rate, that solana cli is behind the cluster versions
New version of anchor doesn't work with it probably
earlier it used to work , about one month back
Think you need to upgrade your solana cli, yeah 😬
is there any way out without upgrading my solana cli?
how to solve this error? 
my solana cli version = 1.7.8


//////////////////////////////////////////////////////////////////////////////////////////

I think dynamic array is impossible for parameter in transaction.
what's the best way to get a pseudo random u8 ? recent blockhashes or slot hashes?
how to run a single test using the CLI?
single test using anchor: i tried on cli: anchor test -- -g 'mytestname" but it is passing the args to cargo bpf
Hi, I need to pass in accounts of another program into my program. Specifically, this one (but probably more from that file):

https://github.com/metaplex-foundation/metaplex/blob/master/rust/nft-candy-machine/src/lib.rs#L566

I copied the structs over manually into my lib.rs file but getting the following error:

```The given account is not owned by the executing program```

I'm assuming this is saying that my account doesn't own this "Config" account, which is being passed in. What would be the correct way to do this?
but you shouldnt have to modify anything if you add the "mut" option
hmm thats super weird... maybe theres some funky serialization stuff going on or so
have u tried giving it a named lifetime parameter? (also, thats a slice, not an array.)
it occurs an error because of 'users' arry.  #[program] -> expected named lifetime parameter
Hey, guys. Can I use array for parameter of anchor instruction?
```
pub fn getReward(ctx: Context<GetReward>, users: &[u32]) -> ...
```
so i was wondering if that was a requirement
odd, the only change I made to my program code to make tests pass was to remove a `mut` constraint
nope, it doesnt have to be, but can be
how should i handle the case where an account may be mutated in some cases but not in others (dependent on data in some of the other provided accounts)
does a mut constraint imply that the account _must_ be mutated?
https://tenor.com/view/the-simpsons-homer-simpson-good-bye-bye-no-gif-5173989
I owe this chat lots of debugging debt for this
Lmao
yes so it was in a hidden terminal in vscode
lol np. that explains the program logs
thank you for sanity checking
<@!161709591220977664> I'm so sorry
i had a test validator running
oh my god
are you running `anchor test`?
maybe this is an m1 mac bug?
no way
weird, just ran your program and worked fine for me
will look again in the morning 🙂 thanks all!
didnt work
I'll do that since I don't really need to store it
the only difference in the code is that you use _bump as a throwaway
yep
identical code 😦
did you also change it in Anchor.toml
Sorry missed pda part looking on my phone
yea that's right
doesn't a PDA not have a keypair?
its a PDA though
You need the account you’re creating to sign
yep :/
Even when not explicitly included
The wallet that pays is always signer 0
I thought my wallet signs this no matter what
can I use my wallet as the signer?
I can add a signer back
no signers in the client code, but i had added them previously
I just looked at your stack overflow
You have no signers in your client code?
yep
declare_id!("EespR7XYaCcPqNAZfuAdBFTsNGBoBgUJ65H5qH9Q8Ds1");
just to double check, EespR7XYaCcPqNAZfuAdBFTsNGBoBgUJ65H5qH9Q8Ds1  is your declare_id!() right
`9QbUfaFKL5jjYb6dcPRR3f3HjKcP2x8PND58uAJCvxnh` doesnt match any keys im using
```
Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account 
    Program EespR7XYaCcPqNAZfuAdBFTsNGBoBgUJ65H5qH9Q8Ds1 invoke [1]
    Program log: Instruction: Initialize
    9QbUfaFKL5jjYb6dcPRR3f3HjKcP2x8PND58uAJCvxnh's signer privilege escalated
    Program EespR7XYaCcPqNAZfuAdBFTsNGBoBgUJ65H5qH9Q8Ds1 consumed 3984 of 200000 compute units
    Program EespR7XYaCcPqNAZfuAdBFTsNGBoBgUJ65H5qH9Q8Ds1 failed: Cross-program invocation with unauthorized signer or writable account
```
What do your program logs say
ugh ok. thank you for helping! I'll take a look!
```
{
  provider_one: PublicKey {
    _bn: <BN: 6f34faa9dbed2e1e3f4a864f514355fe9301e3ebfe0c13dffe27f84612ddaec>
  },
  program_one: PublicKey {
    _bn: <BN: 6f34faa9dbed2e1e3f4a864f514355fe9301e3ebfe0c13dffe27f84612ddaec>
  }
}
```
BTW <@347689664855015424> I had a strange case where same method outside of program macro built fine but inside it complained about imports.
When I moved around the file structure it worked.
Is this expected?
ah then no clue, i have basically the same exact code as you :/ https://github.com/spacemandev-git/legacy-sol/blob/main/tests/01-setup.ts
I think you can block access to everyone in settings
and those keys match!
still same issue
ah
and provider should just be const provider = anchor.Provider.env()
Yea its probably a key issue- I have no other provider though
```
  // Configure the client to use the local cluster.
  anchor.setProvider(anchor.Provider.env());
  const program = anchor.workspace.Myprogram as Program<Myprogram>;
```
```ts
creator: provider.wallet.publicKey,
```
in your test code
without program infront of it
try provider.wallet.publicKey
oh
same error
yup
try doing bump=bump
maybe i should do bump = something?
deeply frustrating stuff :/
the previous code allowed any keypair, and i want to make base_account a singleton
Yep, I'm actually currently trying to make this a PDA
narrow it down to the PDA account or one of the others
if you use a regular keypair instead of the PDA do you still get the error?
no dice, still getting the error 😦
try replacing this part 
```
    #[account(address = system_program::ID)]
    pub system_program: AccountInfo<'info>,
```
with 
```rs
pub system_program: Program<'info, System>
```
thank you 🙂
one sec i'll take a look to see if i can spot anything obvious on your code
in my case it was cause my player seed for generating the PDA was different than the one anchor was using cause i forgot to pass in a parameter
I'm having this same problem- did you figure it out? Here's my stack overflow question.
https://stackoverflow.com/questions/70587929/anchor-error-when-trying-to-initialize-a-program-derived-account-pda
this solved a part of my problem 🙂
makes sense!

My mental model: 'one account' for the program is from EVM where the smart contract owns its tokens directly and its kind of embedded. I picture solana program as using disposable containers (accounts) as needed and generating those on the fly. Im writing something and have been using the user pubkey() as one of the seeds + ensure they are signing too. I am a noob though.
https://twitter.com/armaniferrante/status/1411589637760372737
https://twitter.com/armaniferrante/status/1411589639006154754

an old tweet from Armani that I'd like to make sure I understand. is the vulnerability:

- global PDA is `authority` of vault
- attacker calls my program with his account, my program does `invoke_signed`  CPI transfer, CPI checks pass because seeds are the same for everyone
-  is the implied solution to include the user's public key as a PDA seed, thereby the PDA is no longer global? and require the user to sign
What is the difference between having an access constraint inside an account (using has_one on top) vs. inside an instruction ?
For example in the increment counter instruction:
Im trying to define the context for one of my functions.
Anyone ever seen this error before?
Cheers <@!347689664855015424>
it's cause `init` will initialize `counter` as a rent-exempt account. For that the account needs some lamports. These lamports are provided by the payer. So the payer needs to be mutable
Oh wait, is it because they are paying with lamports and updating their account state? woops
For example in the anchor tutorial https://project-serum.github.io/anchor/tutorials/tutorial-2.html#defining-a-program why is the Create struct user mutable?
I get why functions that close accounts don't need mutable signers, but why do initialization functions? I don't understand why a signer ever needs to be mutable. I think I'm missing something important
dont know myself
hmmmm ok. that solves the bit about using pre-existing accounts. What about getting a proper `spl.Token` object from a given pubkey? (to interact with these pre-existing accounts)
torn down. but in your tests you can start a custom local validator with your required accounts loaded and then run `anchor test` with `--skip-local-validator`
Hey paul, do you know anything about this?
yup
so what happens when you're out of space? the tx for mutating the account fails?
you need to init with enough space for all your elements.accounts can not (yet) be resized
i am a little confused with how space works with dynamically allocated stuff like Vec. is there a way to check if the account has space available before trying to push a new value to it and then erroring for the user? or dynamically increasing the account size as new data comes in?
<@!501570363566587905> do you know any other solution for this other than using a `Vec`?
fuck yea, just compiled, thanks!
yes 🙂
it is. the error is telling you what to do!
i can implement it on my enum
oh but that's my enum
now it seems it wants Clone and that's not implemented for strings also maybe?
```rs
#[account]
pub struct Player{
    pub name: String,
    pub troop_cards: Vec<Troop>,
}

```
```
   Compiling legacy-sol v0.1.0 (/mnt/c/Users/spaceman/Projects/solana/legacy-sol/programs/legacy-sol)
error[E0277]: the trait bound `TroopClass: Clone` is not satisfied
   --> programs/legacy-sol/src/account.rs:27:5
    |
22  | #[account]
    | ---------- in this procedural macro expansion
...
27  |     pub class: TroopClass,
    |     ^^^^^^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `TroopClass`
    |
note: required by `clone`
    = note: this error originates in the derive macro `Clone` (in Nightly builds, run with -Z macro-backtrace for more info)
```
It's because of the `[Troop;6]`. Borsh (the serialization library anchor uses) wants arrays to be copy. but this array cant be copy because Troop isnt copy. and it cant be because string isnt copy
oh, i read a tutorials twice 😦 but a lot of information not founded, thx
it would be best if you just read the entire tutorial once which explains this. `user` is not found in scope because you probably didnt add a user field to your struct
ok so the problem is the `[Troop;6]` needs to be `Copy` but cannot be because `Troop` has a String field. This is interesting. Have you tried using a `Vec` for `troop_cards`
hm, i added this annotation #[account(init, payer = user, space = 64)] but get error: user - ^^^^ not found in this scope
yea looking back, using strings worked in my other accounts, so dunno why this account is acting up. I wonder if it has to do with the enum?
thx
https://project-serum.github.io/anchor/tutorials/tutorial-1.html#defining-a-program
how i can initialize account? in my program or client? i think i need to create a pda for this
<@!849035945487630337> https://discord.com/channels/889577356681945098/889702325231427584/928037853789835264
```rs
#[account]
pub struct Player{
    pub name: String,
    pub troop_cards: [Troop;6],
}

#[account]
pub struct Troop{
    pub name: String,
    pub description: String,
    pub link: String,
    pub class: TroopClass,
    pub power: u8,
    pub mod_inf: i8,
    pub mod_armor: i8,
    pub mod_air: i8,
}

#[derive(AnchorSerialize, AnchorDeserialize)]
pub enum TroopClass {
    Infantry,
    Armor,
    Aircraft
}

impl Default for TroopClass {
    fn default() -> Self { TroopClass::Infantry }
}
```

error:

```
error[E0277]: the trait bound `Troop: std::marker::Copy` is not satisfied
  --> programs/legacy-sol/src/account.rs:17:1
   |
17 | #[account]
   | ^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `Troop`
   |
   = note: required because of the requirements on the impl of `BorshDeserialize` for `[Troop; 6]`
   = help: see issue #48214
   = help: add `#![feature(trivial_bounds)]` to the crate attributes to enable
   = note: this error originates in the derive macro `AnchorDeserialize` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0277`.
error: could not compile `legacy-sol` due to previous error
```
it's possible. what does your code look like?
hi, maybe you can help me with Error: 3012: The program expected this account to be already initialized?
it seems that it's not possible to use strings with account structs? getting a "std::marker::Copy" is not implemented for MyStruct (assuming its cause String attributes don't implement copy being dynamic sized). what would be my way around this?
if theyre changed, they need to be mutable, if they just sign things, they dont
```#[derive(Accounts)]
pub struct Stake<'info> {
    pub token_addr: Account<'info, Mint>, // token mint address (agte mint, nft mint)
    #[account(mut)]
    //the token account to withdraw from
    pub token_from: Account<'info, TokenAccount>, // from which user associated account we can transfer
    //the authority allowed to transfer from token_from
    pub staking: Account<'info, StakeInfo>,
    pub staking_account: Account<'info, TokenAccount>, // when we send money
    pub token_from_authority: Signer<'info>,  // user who will stake
    pub token_program: Program<'info, Token>,  //  address for token program for transfer
}```
Why are some Signers mutable (#[account(mut)] and some not?
i have this problem too Error: 3012: The program expected this account to be already initialized
hi, have you resolved your problem?
When I try running the command with my keypair, I get an error "client.js not found"
please do not use @ everyone, do not crosspost, and do not post in # anchor-contributors. it's a channel for anchor contributors.

Your error means that youre trying to access an account that has not yet been initialized. So you should check whether the account thats causing the error has been initialized before
I'm currently working through the minimal example, specifically generating a client section
Hi! Noob question, but how do I run the client?
Hello, 
I am working on devnet. I have created token account using solana as a mint.
I have also airdropped enough SOL on my wallet and the created token account. But when i try to transfer i get insufficient fund error. 
What can i do to get balance on my token account.
"You may not realize that program data accounts (the accounts that store the executable byte-code for an on-chain program) can also be closed. Note however, that this does not mean that program accounts can be closed (those are immutable and can never be reclaimed, but it's fine they're pretty small). It's also important to keep in mind that once program data accounts are deleted, they can never be recreated for an existing program."
buffers are temporary accounts
is different than closing a program data account
that returns something empty, i'm pretty sure closing buffers
--buffers instead of --programs?
I'm running version 1.8.3 which I think is pretty recent??
but, it says "found argument --programs which wasn't expected"
this link says `solana program close -u mainnet-beta --programs --keypair ./admin_key.json` should work
specifically: https://jstarry.notion.site/Program-deploys-29780c48794c47308d5f138074dd9838#561f8e76208a46b8963092adabab2256
not working
solana program close
and i'd like to close the account & get my funds back
for a program
I have one on production (https://explorer.solana.com/address/3sVuWzrMzwtU6bRWFg8KL3uh9CR7tC41PaUMZYBSPSRq)
Is there a way to close a program executable data account?
now i am getting this message in terminal
Do you know about this issue ?
Error: 3003: Failed to deserialize the account
Thanks for reply
Is it possible to use a pda address as a seed to generate another pda address? running into some discriminator issues, unsure if that could be the cause
did you initialize pool_token_account in your tests?
Hi @everyone 
I am getting this error when i run **anchor test**
How can i fix this issue
can anchor test can make use of existing accounts on the cluster? or is everything that's done during test in some transient state that is always torn down on completion?

context: My program makes use of a few Mints which are statically defined in the program code, like this: ```const MINTS: [MintInfo; 1] = [
    MintInfo{ id: 1, mint: "EWWFTfiHWkSUDkNWvU4u7PuxCLAL2bEki57aLw9iVzzW"}
];```
These mints are not modifiable, so I can't swap them out for bogus mints during my test cases.

As a result I am running into confusion when trying to write the test cases. I can't tell if I'm able to do a call like `getSplToken("EWWFTfiHWkSUDkNWvU4u7PuxCLAL2bEki57aLw9iVzzW")` to set up a proper `spl.Token` object for testing. I can obviously define `mint_address` as a string or a `BN` in my test code, but utilizing it as an `spl.Token` is tripping me up.
sorry for question, how i can check in program which tokens and how many exist in pda account?
seems like I must have `handler` and `Accounts` in same file/mod of it blows up.
Solution to `3`: https://github.com/solana-labs/solana-program-library/blob/ea354ab358021aa08f774e2d4028b33ec56d4180/token/program/src/error.rs#L16
Where can I find what custom error `0x0` and `3` is?
empty string. (dont use `Default` to calculate space on strucst when you use types with dynamic sizes)
What does `#[program]` do that can screw up the imports?
Error:```error[E0432]: unresolved import `crate`
  --> programs/office-house/src/lib.rs:21:1
   |
21 | #[program]
   | ^^^^^^^^^^
   | |
   | unresolved import
   | help: a similar path exists: `crate::office_house_structs::withdraw_from_fee::__client_accounts_withdraw_from_fee`
   |
```
```
#[program]
pub mod office_house {
    use super::*;
    pub fn initialize(_ctx: Context<Initialize>) -> ProgramResult {
        Ok(())
    }

    pub fn doesnt_work_withdraw_from_fee<'info>(
        ctx: Context<'_, '_, '_, 'info, WithdrawFromFee<'info>>,
        amount: u64,
    ) -> ProgramResult {
        withdraw_from_fee(ctx, amount)
    }
}
```
I'm unable to build, took the only method I have outside the `#[program]` macro and it builds.
(and can it be changed after the account has been created?)
what does derive Default do when one of the struct components is a string? what's the default derivation of a string?


//////////////////////////////////////////////////////////////////////////////////////////

aha yes, using toArrayLike() was the missing piece!!
Always heartwarming to see noobs learning how to Solana
this is my first anchor program <@!347689664855015424>, its awsome 🙂
`ctx.program_id`
do i have the program id somewhere as an argument?
actually you could just print the the actual bytes and see the difference. Ive done that for you -> the rust code returns 8 bytes `[0,...,0]`.
 toBuffer returns a single byte `[0]`.  use `a.toArrayLike(Buffer, endian, length)` to `BN` instead
nah, it's not the string, i reduced it down to just 
```rs
let (pda2, _bmp2) = Pubkey::find_program_address(&[0_i64.to_be_bytes().as_ref()], ctx.program_id);
```
which gives: 
```
CqXarEYx6tvpwASk3ViCfWob4DeBxnK86zt2g63dU5P
```

and 
```ts
const zPda = await getPDA([new anchor.BN(0).toBuffer()], program.programId);
```
which gives
```
44pjoCWqimmXwWMq5DcxGSVNj8m6hjJqyXENHWPM8mBp
```

so it's definetely with the difference in how BN is being used here i just don't know what other thing to do about it
exactly!!!! totally agree!
https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo/src/lib.rs
Is "6" standard number of decimal places on a token? It seems that both USDT and USDC have 6 decimals. But I saw online that 9 was the standard
Hey guys!
I have a need to create a script on Anchorpy which creates multisig with two accounts, let's say created in Phantom, then I want to send from one account SOL to another by signing this transaction with multisig. 
That is, in order to send tokens both receiving and sending parties must agree. How do I need to change the Rust code for this?
I tried just substituting in Anchorpy a pubkey that wasn't created in the python function, but I got an error.
any examples of creating a token account with a pda?
Try this https://blog.chain.link/how-to-build-and-deploy-a-solana-smart-contract/
how do I call my anchor program with CPI? I'm looking at this example https://project-serum.github.io/anchor/tutorials/tutorial-3.html#defining-a-puppet-master-program but the cpi module is not there in the program crate.
I just remembered I think you have to do `Buffer.from(anchor.utils.bytes.utf8.encode(gameId))`
Admittedly I’m not too sure if this structure might make the rent expensive… is there a more economic way to do it?
Hi, I'm wanting to make a kind of ToDo list program where a ToDo Item can be created and I'd also like there to be a Project structure that holds a list of ToDo items.

Is the structure I'm looking for something like this -?

```rust
#[account]
pub struct ToDoItem {
    pub authority: Pubkey,
    pub name: String,
    pub id: String,
    pub is_completed: bool,
    pub color: String,
    pub assignee: Pubkey,
}

#[account]
pub struct Project {
    pub authority: Pubkey,
    pub tasks_data: Vec<u32>,
}
```
or I want Anchor will clarify which account's constraint is violated.
Let's use 'if' statement and use custom error to clarify mismatching errors.
It makes me difficult to find real error and where error comes from.
If constraint mismatches, it only shows 'A raw constraint was violated'
I suggest that let's not often use constraint attribute.
Hey, guys.
anchor build says

```To deploy this program:
  $ solana program deploy /Users/dig/Documents/dev/solana/solana-splits/splits/target/deploy/splits.so
The program address will default to this keypair (override with --program-id):
  /Users/dig/Documents/dev/solana/solana-splits/splits/target/deploy/splits-keypair.json```
I am deploying this program for the first time
could be one of those, would check these first
when you do anchor build it gives you a program id, you need to update this in Anchor.toml and declare_id!
did you modify the program-id properly?
I created a fresh keypair to deploy my program on devnet using anchor but it throws this error

`Error: Account 4m1eWNndyhE8eJyQcde8MYMV3tzP4wS5xsARZQTHAKpo is not an upgradeable program or already in use`
Hi! Is it possible to define array of accounts with anchor?
anyone knows how I can show failed transaction logs?
turns out its on the bottom of the solana explorer for explorer https://explorer.solana.com/tx/2tibFtG5tc4fNVMHV2J9dsyeE1cLPPJYgorkZ1Z2V5fJEPZ8xXSMKYtwDkKirURtZBBTUjsjZ4HaSTJ3JVp3me5B?cluster=devnet
doe anyone know where I can see the output of the `msg!` macro on Devnet?
doesnt use anchor but logic should be analogous
watched it a long time back
have you checked this video? https://www.youtube.com/watch?v=g5A5QKh15pQ&ab_channel=Chainlink
hmm good question....
If someone have already been through that type of error 🙂
To import a library I just need to add a a line in [dependencies] no ? I saw in a tutorial that they added 

chainlink = { git = "https://github.com/smartcontractkit/chainlink-solana", package = "chainlink-solana", features = ["no-entrypoint"] }

I’ve done the same thing but when I anchor build —> error on the image
anchor supports that as well. create acc in previous ix and then use `#[account(zero)]`
let me know when you find the answer, theres a tutorial on it during the Ignition hackathon
never used it before, but it seems as simple as just importing a library and adding it as one of the context accounts
Do you know how ? Does it seems complicated ?
Thanks for your answer ! Know I need to learn how to call chainlink with anchor 😅
Yeah I was just looking for chainlink !
theres chainlink oracles that generate random numbers etc. have a look at those. otherwise, not sure if anchor supports randomness, at least 1 month ago they didnt
welcome to anchor!
xD what happened haha
Hey guys ! Is someone know how to use random in a smart contract with Anchor ? 😀
is this normal...
i feel like i have no idea what i am doing, though i have just begun
ruminations of a starbucks barista
yo dont listen to a single word I just said I messed up my js test
at least i never defined anything as an associated token account in the Context, while generating associated token accounts as a pass on
:)
ok thanks chief
also in terms of serializations, they should be the same though
or do you mean the init functionality itself?
theyre not the same necessarily. if you re-generate associated token accounts multiple times it will always return the same (single) address. this is not true for token accounts
if you init them
do you know if associated token accounts and token accounts are the same
its proper syntax can confirm
token::mint references a property in the implementation, not sure if this is proper syntax..
maybe you can do it like this, adding constraints?
``` 
        constraint = bond_pool_redeemable_mint.mint_authority == COption::Some(bond_pool_account.key()),
```
hmm im not very familiar with this format, not sure if ive seen this before
I want to make self owned TokenAccounts
i guess i know the error but not sure how to resolve it
the program one works, the cli one doesnt
another was a mint from the cli
i derived 2 pda's during testing, 1 was a mint that the program created and owns

or did you create the token account? can you post some code?
how did you create the TokenAccount?
when I use a mint my program owns, it works
who i am assuming the authority is the token_program
the mint is created from cli
but am getting "signer's priviledge escalated"
I am trying to use the token:: macros to instantiate a TokenAccount
do i need to own the mint if I want to use token:: macros?
try rubbing it a little bit
when i want to retrieve my created PDA account base_account, i do:
```
#[derive(Accounts)]
pub struct incrementValue<'info> {
    #[account(mut)]
    pub base_account: Account<'info, BaseAccount>,
    #[account(address = system_program::ID)]
    pub system_program: AccountInfo<'info>,
}
```


and then
```
  const [baseAccountPDA, baseAccountPDABump] = await anchor.web3.PublicKey.findProgramAddress(
      [Buffer.from("seed")],
      program.programId
    );

    await program.rpc.incrementValue(baseAccountPDABump, {
      accounts: {
        baseAccount: baseAccountPDA,
        systemProgram: anchor.web3.SystemProgram.programId,
      }
    });
```

? everytime I try to do this I get:
```
Transaction simulation failed: Error processing Instruction 0: instruction modified the program id of an account 
    Program EespR7XYaCcPqNAZfuAdBFTsNGBoBgUJ65H5qH9Q8Ds1 invoke [1]
    Program log: Instruction: NameFloppydingdong
    Program EespR7XYaCcPqNAZfuAdBFTsNGBoBgUJ65H5qH9Q8Ds1 consumed 4212 of 200000 compute units
    Program EespR7XYaCcPqNAZfuAdBFTsNGBoBgUJ65H5qH9Q8Ds1 success
    failed to verify account 11111111111111111111111111111111: instruction modified the program id of an account
```
back to solidity lol
no luck
ok guys, i give up. I've tried to pass in an account not owned by my program into an anchor program for 3 days
<@!161709591220977664> was running into this
I think I saw this before when using declare!{} in more than one place
It almost feels like I need a way to just say "look Anchor, please, god, please, here is the owner of this account, I know Im not the owner"
yep, I can see it in the explorer
coincidentally my issue is because i'm using 1.8.5
I have the same issue :/ im on an m1 and my issue is caused by a version mismatch
If anyone else runs into this: it was Solana tools, needed 1.9.2, the start guide at https://project-serum.github.io/anchor/getting-started/installation.html#install-rust gives you 1.8.0, so just change the command to `sh -c "$(curl -sSfL https://release.solana.com/v1.9.2/install)"`
It was Solana tools, needed v1.9.2
thats def a cargo prob tho
should give u more info
I think
from that dir, and --verbose
run ` cargo +bpf build --target bpfel-unknown-unknown --release`
Nope, intel 10th gen
Any idea why I'm seeing this when trying to pass a PDA key?

```
Transaction simulation failed: Error processing Instruction 0: instruction modified the program id of an account 
    Program EespR7XYaCcPqNAZfuAdBFTsNGBoBgUJ65H5qH9Q8Ds1 invoke [1]
    Program log: Instruction: NameFloppydingdong
    Program 11111111111111111111111111111111 invoke [2]
    Program 11111111111111111111111111111111 success
    Program EespR7XYaCcPqNAZfuAdBFTsNGBoBgUJ65H5qH9Q8Ds1 consumed 12095 of 200000 compute units
    Program EespR7XYaCcPqNAZfuAdBFTsNGBoBgUJ65H5qH9Q8Ds1 success
    failed to verify account U8deX75Km847phPR7JqgDxhxYfjLZgkH7aRCaWxP3JB: instruction modified the program id of an account
```
Is this a Solana thing or an anchor thing, or a cargo thing? ```BPF SDK: /home/fish/.local/share/solana/install/releases/1.8.0/solana-release/bin/sdk/bpf
Running: rustup toolchain list -v
Running: cargo +bpf build --target bpfel-unknown-unknown --release
error: failed to download `solana-frozen-abi-macro v1.9.2`

Caused by:
  unable to get packages from source

Caused by:
  failed to parse manifest at `/home/fish/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-frozen-abi-macro-1.9.2/Cargo.toml`

Caused by:
  feature `edition2021` is required```
yes
Hi guys, I'm not seeing anything under .anchor/program-logs. Is there anything I could be missing. 

I'm running a local_validator and running anchor test with `anchor test --skip-local-validator`. I am getting a `Error: No such file or directory (os error 2)` at the end of the test run

Update: This is after removing all .DS_Store files also
hmm you're sure  it's initialized? you can see it in explorer?
yep, running a local test validator with a --clone option, to clone one from devnet
what's your client code doing? is the `Config` account initialized? sometimes the error message indicates something else wrong
but yea.. starting to lose hope 😦
(i.e. the 'nft_candy_machine', from above)
which is fine, i know it's not the owner. the owner is Metaplex Candy Machine program
think it's saying "'foo' program isnt the owner of the 'Config' account"
oh i see now
right so, in another program, im doing:

```rust
use nft_candy_machine::Config;

#[program]
pub mod foo {
    use super::*;
    pub fn initialize(ctx: Context<MyContext>) -> ProgramResult {
        Ok(())
    }
}

#[derive(Accounts)]
pub struct MyContext<'info> {
    config: Account<'info, Config>,
}
```


^ That will fail
i'm confused, the code you linked is in Anchor
been asking around for 4 days...
it's practically impossible with Anchor
how would you take this as an input in a vanilla solana program:

https://github.com/metaplex-foundation/metaplex/blob/master/rust/nft-candy-machine/src/lib.rs#L566
i think the easist way to frame this is
hard to debug without code... do you have more program logs?
how do programs read accounts they don't own ... is this not possible? I'm sure it is, so I'm guessing it's just complicated with Anchor?
i just need to read the data of an account that another program owns
So i guess the issue is, I know im not the owner and will never be
the error message sounds like you should check that account's  `owner` is your `program_id`
pub user: Signer<'info>,
implies a singature?
there's an `AccountInfo` type or you can put `Pubkey` in a struct
pub destination: Account<'info, System>,
no signature
is the a way to delcare an account that is just a pubkey?
thats true
trust what?  it doesn't guarantee it can find all the bugs
but then i have to trust them 😉  just as i trust you. more philosophical than practical.
context being, I'm trying to take an account declared/owned by another program as input
use https://twitter.com/soteria_bc
sorry to bug about this again, but still having issues with `The given account is not owned by the executing program` error, and would love some help 😦

Importing an account struct form another local program. However, when i try to use that account in an input context, I get that error. 

Something like:

program_a/lib.rs:
```rust

#[account]
#[derive(Default)]
pub struct Config {
    pub authority: Pubkey,
    pub data: ConfigData,
}
```

program_b/lib.rs:

```rust
#[derive(Accounts)]
pub struct MyContext<'info> {
    config: Account<'info, Config>,
}
```
lol do you know of anything a bit shorter and more concise? im quite new to this so its easy to get lost 😄
i've been thinking a lot about this. let's say down the line... how is the auditing going to actually work in practice? i can't imagine every dev auditing... is it fair to analogize to software packaging
the amm i just posted seems to handle all the token apis
I'm having a hard time finding good example contracts
I
Does anyone know of any contracts that can be used to deposit / withdraw tokens into a pool?
https://github.com/ironaddicteddog/anchor-amm/blob/master/programs/amm/src/lib.rs
this is pretty cool
yep, makes sense
less code in the to try to audit
just preferences i guess
in this case, its ok, since any CPI failures abort the whole transaction
hm, i do prefer flat over nested. re: failure, i suppose the onus to properly handle the error case falls on the CPI program writer (vs. client). more broadly, designing good APIs
well, easier to reason about the control flow of the program, since the failure to allocate is pulled outside
not to be annoying but what makes it cleaner? i'm still thinking through CPI vs. client doing it
haha, yea, typically thats "cleaner", but def a pia for devs
lol as in the client should be the one to allocate? i'm new to all this
armani pissing all over my caller allocated semantics
got it
https://github.com/project-serum/anchor/blob/master/lang/syn/src/codegen/accounts/constraints.rs#L638
yep CPI
so it calls it from within the ix via a cpi?
macro's `init` attribute implicitly does  `system_program::CreateAccount` for you
why would i pass system as an acccount param
is it passed as an argument?
what is system for though?
i think it's as paulx guessed, system_program should be included in your `Initialize` struct
```
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod token_omnibus {
    use super::*;
    pub fn initialize(_ctx: Context<Initialize>, data: SHA256) -> ProgramResult {
        Ok(())
    }
}

type SHA256 = [u8;32];

#[account]
struct AccountSet {
    root: SHA256,
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = account_set, space = 32)]
    pub account_set: Account<'info, AccountSet>,
}
```
i thought macro use was deprecated a while ago
you can do Vec<Pubkey> and then use them as seeds yes. having them in your ix obv means you cant write or read from the accs cause theyre just pubkeys, not accs
`pub system_program: Program<'info, System>`
that requires the system program to be declared in the struct as an account too
youre probably using the `init` constraint in your code somewhere right?
not in user code that i know of
is there a macro use somewhere?
i'm using stable
= note: this error originates in the derive macro `Accounts` (in Nightly builds, run with -Z macro-backtrace for more info)
do i need to use nightly?
have that
`use anchor_lang::prelude::*`
do i need a user macro somewhere?

```
   Compiling token-omnibus v0.1.0 (/Users/aeyakovenko/token-omnibus/programs/token-omnibus)
error[E0425]: cannot find value `system_program` in this scope
  --> programs/token-omnibus/src/lib.rs:20:10
   |
20 | #[derive(Accounts)]
   |          ^^^^^^^^ not found in this scope
```
or some type of manipulation on the vector that ensures the result is unique to only that vector, to keep the pda unique as well.
I only attempted to pass in a Vec<Accounts> so that when creating a pda, I could do something like this: seeds=[PREFIX.as_bytes(), *vector here*]
Would I be able to create a PDA using their addresses as seeds as well?
anchor currently does not support Vec<Accounts>(it may soon). But you could pass them in as a vec in your instruction data
log every single argument to that function individually is all I can suggest. from both the rust and ts function
but i'm unsure what needs to change
using BN
i think the problem is with typescript and how i'm doing the i64 to buffer
not a pubkey
its a random string
its
this is assuming that `gameId` is a pubkey in string form, not just any string
try `(new PublicKey(gameId)).toBuffer()`
I'm trying to create a pda, using a prefix + an arbitrary colletion of publickeys . I'm getting an error though: `unresolved import of __client_accounts_vec use of undeclared crate or module __client_accounts_vec`

Here's the code snippet
```#[derive(Accounts)]
#[instruction(bump: u8, share_list: Vec<u32>)]
pub struct Initialize<'info> {
    alice: Vec<UncheckedAccount<'info>>,
    bob: UncheckedAccount<'info>,

    #[account(init, seeds=[PREFIX.as_bytes(), alice.key().as_ref(), bob.key().as_ref()]```
My question is: Is there a way to store a collection of accounts in the struct so that I may reference them to create a pda using a prefix + each public key in that collection of accounts?

In the usual working code , alice is of type `UncheckedAccount<'info>` and not ``Vec<UncheckedAccount<`info>>``
gameid is a string, not a pubkey unfortunely
its just a wrapper
```ts
export const getPDA = async (accBuf: Buffer[], programId: anchor.web3.PublicKey) => {
  const [acc, accbmp] = await anchor.web3.PublicKey.findProgramAddress(accBuf, programId)
  return {account: acc, bump: accbmp};
}
```
also, if gameId is a `Pubkey` you can call `gameId.toBuffer()`
what does `getPDA` do?
this code 
```rs
let (pda, _bmp_seed) = Pubkey::find_program_address(&[id.as_ref(), 0_i64.to_be_bytes().as_ref(), 0_i64.to_be_bytes().as_ref()], ctx.program_id);
``` 
produces this as the pda: 
```
39erDrYUenMRLNRj5oDAVTacSpPL8vfzgtNaHbhiaXp6
```

while this code:
```ts
  const startLoc = await getPDA([Buffer.from(gameId), new anchor.BN(0).toBuffer(), new anchor.BN(0).toBuffer()], program.programId)
```
produces this as a PDA
```
FdCGugQzCrwX3FkReMST5kS21ogWFQoGjPG2QSYtwLMp
```

how can i make them produce the same PDA?
it works for me
1.8.11 works?
anchor uses solana 1.8.5 currently, looks like youre using 1.8.0, maybe thats causing problems? also is your solana-install up to date?
I see, it doesn't seem like what I want is available on crates.io. I'll try the metaplex discord but they're usually not as helpful 😦
usually all rust programs are in a crate. when you create a new project with cargo new, you create a crate. you can import a crate easily when its available on crates.io. but whats the best way to import metaplex programs is a question for the metaplex discord
did i miss a dependency somewhere?

aeyakovenko<@!439210198142550016>s-MBP-2 src % anchor build    
BPF SDK: /Users/aeyakovenko/.local/share/solana/install/releases/1.8.0/solana-release/bin/sdk/bpf
Running: rustup toolchain list -v
Running: cargo +bpf build --target bpfel-unknown-unknown --release
error: failed to download `solana-frozen-abi v1.9.3`
im getting this error while using `anchor deploy`

`Error: Deploying program failed: Error processing Instruction 1: invalid account data for instruction`
forgive me, as I'm really new to rust but, are all repos setup as crates? e.g. Is metaplex setup to be imported as a crate, like this one(https://github.com/metaplex-foundation/metaplex/tree/master/rust/nft-candy-machine)
import the crate and the type instead of redefining it locally
want to bump this... wish I didn't have to ask for help here, but still stuck 😦
https://alexgrinman.com/posts/building-decentralized-identity-verification-system-on-solana/ guys good tutorial with anchor by <@!794953333302493184>  check it out !
I tried
```
const pp = borsh.deserialize(
  ProgramAccountInfoSchema,
  ProgramAccountInfo,
  kk!.account.data
)
```
 And it emits this error: `Expected buffer length 1000 isn't within bounds: account_pubkey`
Is it possible to handle this?
I wanna parse data into particular schema
Hello, I fetched data from data account using getProgramAccounts.
it contains 
```
account:{data: Buffer(160), executable: false, lamports: 2004480, owner: PublicKey, rentEpoch: 244}
data:Buffer(160) [118, 195, 243, 217, 229, 128, 62, 121, 1, 0, 0, 0, 197, 61, 214, 2, 232, 3, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 32, 0, 0, 0, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 32, 0, 0, 0, …]
executable:false
lamports:2004480
owner:PublicKey {_bn: BN}
rentEpoch:244
__proto__:Object
pubkey:PublicKey {_bn: BN}
_bn:BN {negative: 0, words: Array(11), length: 10, red: null}
```
 this structure, and I'd like to parse that data into class in ts.
Question, can an ix take in a signature (from a signed message) and create a tx to transfer sol or spl without a frontend confirmation /approval ?
hey folks! im getting this error while deploying: 
```Error: Program's authority Some(7H2GHz1DkvFiofsio5sbSZPoMHEJR5G6RTteEi2hQa32) does not match authority provided 8JKBvGyW38gnpQeQ8sTg3acKpWH11tZHHYLFVnigFUqg```
i dont understand why it exists when every anchor build generates a new keypair
when you call the genesis hash, does that call the first block from the cluster?
i could make an account, borrow lamports and then close it to the system account, that seems super janky tho
sorry for necro, but can a program owned account send sol via borrow to a system account
I need to pass in 20 accounts into a transaction. Will that cause problems?
neither, just want to read some of the data in the account
what are you doing with it in your instructions? are you passing it in as mutable or as a signer?
already done in the next release
would love some help/tips/explanations on this 🙏
if you decide to keep `init_if_needed` for associated_token_accounts, could you make it so that the `token::mint` and `token::authority` parameters check constraints? (In the same way as `token::mint` and `token::authority` check constraints when we don't use `init_if_needed`)
But yeah I don't think it'll hurt to have some kind of warning, or to only have it enabled for ATAs
<:wewbama:695038269632675853>
Associated token accounts is all I've used it for so far
Perhaps we should disable it for everything except associated token accounts.
Yea exactly
It's ok to use it for this use case  init_if_needed. But generally it's a footgun.
Ah, reinitialisation attacks

Why are we not supposed to use `init_if_needed`? <:sweatingman:599601488095870979>
I have a `withdraw` instruction that deposits to an associated token account `token_account`. The problem is, I don't know if `token_account` exists, and I know we're not supposed to use `init_if_needed`. What's the alternative?


//////////////////////////////////////////////////////////////////////////////////////////

hi...
when i run anchor test its shoing this error
Program failed to complete: Access violation in stack frame 3 at address 0x200003dd0 of size 8 by instruction #10737
Thank you for the links <@!915682383905316864> <@!912046857000194158> !
How do I upgrade my project from anchor 0.18.2 to 0.20.0 ?
I downloaded anchor version 0.20.0 globally
I tried running cargo upgrade, which did stuff, but my `Cargo.toml` file is the same
https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html
https://doc.rust-lang.org/rust-by-example/scope/lifetime.html
theres great docs on the rust websitr
Is there any documentation to read further about it? Obviously when I query google I get nowhere since the term info is so generic 😅  So it's called a Rust lifetime?
Tangentially, the borrow checker is the part of the compiler that guarantees that your code is safe through ownership checks.
a protocol that has random chance involved and which needs to ensure the user can't "game" their own chances due to a psuedo-random generation method being used (e.g. something keyed off timestamp+userkey or something).  need verifiable randomness for this reason
I don't know the complete detail of **why** it is needed where it is needed, but **what** it is a lifetime. It is a Rust concept which is needed in certain cases when the *borrow checker* cannot work out some variable scopes (lifetimes) on its own. Devs then need to help it by specifying explicit lifetimes like `<'info>`.
Can anyone explain what <'info> is? Seems extremely basic, but I'm not understanding its function and see it everywhere
thanks ssj 👌 👌 👌
can anyone recommend a good place to look over an anchor smart contract being implemented to next.js/typescript stack ? Trying to learn rn
although with `Box` now it might not be needed actually (?) <a:Hmmmm:695129200260153375>
trick with anchor is to use `remaining_accounts` to pass accounts
lets you pass more than you can with only using accounts struct
just keep optimizing till you can make it work <a:Hmmmm:695129200260153375>
u cant afaik
How do I see how much stack space and heap space my txn used?
got the ans just had to update the solana-cli
Hey, not an Anchor question, but I'm triying to set a modal wallet conection gokiprotocol/walletkit. Whenever i try to import { WalletKitProvider } from "@gokiprotocol/walletkit"; on my React app i get the following error
"Attempted import error: 'SolletWalletAdapter' is not exported from '@solana/wallet-adapter-sollet' (imported as 'SolletWalletAdapter')."

Does anyone knows a solution to this?
no effect
also tried adding it in my manifest  Cargo.toml file
tried updating rust
how do i remove the cargo-feature=[edition2021] error from my project
Does anyone know of any public Anchor repos, basically a complete project, that use the Governance library?
yea, except this one lets you deposit tokens back
How do I check how much stack space and heap space my instruction used?
now I have another question, how do I make a gif?
I have already done it and installed it
go inside one of the directories <@!519625217098907669> metaplex-master for example then try running npm install
no, you should have a package.json not a package-lock.json
are u talking about that package? <@!800894271737561121>
Is this similar to https://github.com/saber-hq/merkle-distributor ?

i only have this
yes I think the error is that it cant find a package.json which is the file it uses to find the dependencies to install, are you in a folder that contains a package.json that you want to install dependencies for?
I have uninstalled nodejs, I have reinstalled it, I have restarted but nothing, I can't perform that command

and the first command is npm install but but I got this
okay im explain myself better, im doing with windows
there are a few examples under tests/
`pub type SHA256 = [u8; 32];` this might not be supported in this form yet 😒
https://github.com/project-serum/anchor/blob/master/tests/escrow/tests/escrow.ts#L90-L92
You mean instruction data like this?
Do you mean to run *** npm init -y ***

Hello can anyone help me with this?
how can i do a gif NFT?
I have a problem when creating the metadata
Hello
i was trying to hash a value but i am getting this err while deploying...i used (anchor_lang::solana_program::blake3::hash) for hashing
Hey, can you describe your use case further?
any clue <@!134416332509675520> ser
How burning works for both NFT and FT tokens. 
And can we make a Solana program for it, where we send some tokens and it'll burn?
https://discord.com/channels/889577356681945098/889577399308656662/924836504193368085
https://discord.com/channels/889577356681945098/889577399308656662/924946007639359488
You can refer answers in development channel.
not yet https://github.com/project-serum/anchor/issues/455
though they could def be added https://github.com/project-serum/anchor/blob/v0.19.0/lang/syn/src/idl/mod.rs#L18
has anyone experienced non-deterministic behavior when using local `banks client`? i'm sure i am just overlooking something but sometimes the same test passes then fails then passes... perhaps a question for solana not anchor
u can pass accounts and args <a:Hmmmm:695129200260153375> 
there isnt much else
what userdata exactly
Thank you.👍  It works. the error was in Anchor.toml
```
[scripts]
test = "ts-mocha -p ./tsconfig.json ..."
```
I changed it into
```
[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json ..."
```
and it works now.
can you paste your directory structure? presumable a test directory is missing. check your Anchor.toml there will be a `[scripts]` block with a test = that shows the command that runs when you `anchor test`
anchor build succeed here.

make sure you have `anchor-cli` installed
how do you pass userdata in the typescript rpc call?
When I enter ```anchor test```build succeed and such error comes out.
```
Error: No such file or directory (os error 2)
```
I wonder why such error comes out. Help me.
Hello. I have problem with anchor test.
this test has tokens? you mean just any test that requires using tokens in the test right https://github.com/project-serum/anchor/blob/master/tests/escrow/tests/escrow.ts#L66-L78
Are there any test examples with tokens?
If I kill the type it’s fine.
pub type SHA256 = [u8; 32];
are types not supported via idl?
oh dang, IdlError: Type not found: {"name":"data","type":{"defined":"SHA256"}}
How do I see how much stack space and heap space my txn used?
Forsure
thanks a ton.
yea absolutely. I'll do my due diligence first and then be down for a chat
Not sure your use case but have some ideas 😉
Forsure. Im currently working on something similar so feel free to dm
Alright this is huge for me. I'll have to deep dive it tomorrow
yea ikr lol
For now at least hehe
very very interesting
Txn
No u just pay the fees
Do they require payment for their service?
That's the correct link
https://docs.switchboard.xyz/randomness
that'd be huge
So sometime in the next 3 months
https://docs.switchboard.xyz/program
Q1 2022 VRF supposedly fully live
They're busy building
gotcha
There's a discord just not very active
sounds like no discord, just email comms?
But works well on devnet
Haven't heard back yet
If it wasn't live on mainnet
Not sure I asked why they gave me both
this is all really useful info by the way so thank you
does that mean there is a mainnet vrf?
I created an account on mainnet too and they whitelisted me on mainnet as well
Create an account via their instructions and email them
I can work with that for sure though
(yet)
it's not on mainnet and the devnet one you can only poll once every 10 seconds i believe (for switch board)
oh shit they have their own VRF? who do I contact to ask about getting on the list to use it 👀
Use another value
Add to what you are hashing
so i'm trying to figure out how to get a wider slice of the bytes
mind you the random value is currently only between 0-255
```
                let clock = Clock::get().unwrap();
                msg!("{} is current Slot", clock.slot);
                msg!("{:?} is the hash of the slot", hash(&clock.slot.to_be_bytes()));
                msg!("{:?} is the random value", hash(&clock.slot.to_be_bytes()).to_bytes()[0]);
```
clock has the current slot and you can hash it manually with importing
```
use anchor_lang::solana_program::hash::*;
```
I was whitelisted on their account list and querying their VRF service. Not fully released yet
Depending on use case slot hashes might be a problem with mev
Oh I was experimenting and couldn't get it working. Mind posting a snippet of how you derive it?

You're right that it may not work for me in the end, but as a temporary solution during dev it could be nice to have.
it's not true random and will probably not work for your usecase but i was able to figure out how to get a pseudo random number using slothashes
I did some reading and it sounds like I'd need to stand up my _own_ oracle essentially? If so please do tell me about your experience
for a source of VRF? Please do tell more
I'm using it now
Oh I see in the Anchor test the way they access array constants is:

```
  it("Should include BASE const in IDL", async () => {
    assert(
      miscIdl.constants.find(
        (c) => c.name === "BASE" && c.type === "u128" && c.value === "1_000_000"
      ) !== undefined
    );
  });
```

is this the canonical method?
Heyo! Quick q: Is there a way to access constants in a type safe way in typescript?

For example. In my contract I have:

```
#[constant]
const MY_CONSTANT: u64 = 42;
```

which exists in the idl as:

```
  "constants": [
    {
      "name": "MY_CONSTANT",
      "type": "u64",
      "value": "42"
    }
  ],
```

However, I'm not sure how to access it, is there a helper function to do this?

I'd love to access it in the same way you access account fields. Having a program.constants.MY_CONSTANT in typescript would be neat.
how to hash something on chain?
gotcha, thanks a ton!
For normal accounts you’ll be fine to do all, if you have larger accounts you may need to look into zero copy
https://docs.solana.com/developing/on-chain-programs/overview
😂
g2g guys
i cant remember name
F
youre a girl right
Haha that’s me
i think ive seen u on twitter btw
how many more accounts would I be able to add?
how much would that help?
hahaha
Box it up ser
I am passing in 11 accounts as parameters and need to pass in around 10 more
If before you hit your instruction logic, your accounts exceed stack limit and you’ll need to wrap it in a Box<> to allocate it into the heap
```
Program failed to complete: Access violation in stack frame 3 at address 0x200003fb0 of size 8 by instruction #12076
```

How can I debug this further?
https://github.com/step-finance/reward-pool
Any examples on deserializing an uncheckedaccount?
nice
are u actually anatoly
I think you meant to send that to me lol, which, thank you, will read into switchboard. If anyone has any knowledge about the ability of switchboard to provide VRF lemme know
https://twitter.com/switchboardxyz
You should check out Switchboard.
what is the resolution?
when trying to deploy on testnet
Invalid blockhash
im running into
yo
Hey team, came to a surprising realization today about randomness (or lack thereof) on Solana and just wanted to put my current understanding out there in case anyone has opinions or comments!

My project will require verifiable randomness to launch, which I didn't actually expect to be a blocker to achieve, but after researching all day I've come to the conclusion that **it is not currently possible to do _anything_ with verifiable randomness on Solana**. 

Further, the only way to do so will be if any oracle service (e.g. Chainlink) launches their own VRF oracle on chain - which may happen in the future, but there is no timeline - could be months or more.

This means that my project will be unable to complete and launch until these oracles are available (if ever). And on top of that, if they do become available, I'll need to pay some (hopefully tiny) amount of LINK from my contract every time I need a random number to use - meaning I will need to maintain a balance of LINK on the program or it will inevitably stop being able to function.

I would very much appreciate info and opinions on these topics!
Got it
Ah. Should be my pda
Same as https://github.com/solana-labs/solana-program-library/blob/master/token/program/src/instruction.rs#L894
It's either the owner or the delegate
I was imagining the client would delegate the amount to the pda prior to this instruction
What does authority mean in this context?  Why is it a required argument?
it says unsupported sysvar on execution but compiled. playing with it to see if i can print something out
get returns a result. you need to handle it. use `?` to shortcircuit
maybe SolanaSysvar::SlotHashes ?
missing  a `?`
```
  --> programs/legacy-sol/src/lib.rs:62:42
   |
62 |                 let slot_h: SlotHashes = SolanaSysvar::get();
   |                             ----------   ^^^^^^^^^^^^^^^^^^^ expected struct `anchor_lang::prelude::SlotHashes`, found enum `std::result::Result`
   |                             |
   |                             expected due to this
   |
   = note: expected struct `anchor_lang::prelude::SlotHashes`
                found enum `std::result::Result<_, anchor_lang::prelude::ProgramError>`
```
or iirc it has to be SolanaSysvar instead of Sysvar
```
BPF SDK: /home/spacemandev/.local/share/solana/install/releases/1.9.2/solana-release/bin/sdk/bpf
cargo-build-bpf child: rustup toolchain list -v
cargo-build-bpf child: cargo +bpf build --target bpfel-unknown-unknown --release
   Compiling legacy-sol v0.1.0 (/mnt/c/Users/spaceman/Projects/solana/legacy-sol/programs/legacy-sol)
error[E0599]: no function or associated item named `get` found for struct `anchor_lang::Sysvar<'_, _>` in the current scope
  --> programs/legacy-sol/src/lib.rs:62:50
   |
62 |                 let slot_h: SlotHashes = Sysvar::get();
   |                                                  ^^^ function or associated item not found in `anchor_lang::Sysvar<'_, _>`
```
does `let slot_h: SlotHashes = Sysvar::get()?` work?
i'm unsure what to pass in for it
like the other functions for SlotHashes
but it requires &self as one of the inputs
tried get
```
error[E0061]: this function takes 2 arguments but 0 arguments were supplied
  --> programs/legacy-sol/src/lib.rs:62:30
   |
62 |                 let slot_h = SlotHashes::get();
   |                              ^^^^^^^^^^^^^^^-- supplied 0 arguments
   |                              |
   |                              expected 2 arguments
   |
note: associated function defined here
  --> /home/spacemandev/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-program-1.9.2/src/slot_hashes.rs:32:12
   |
32 |     pub fn get(&self, slot: &Slot) -> Option<&Hash> {
   |            ^^^

For more information about this error, try `rustc --explain E0061`.
error: could not compile `legacy-sol` due to previous error
➜  legacy-sol git:(main) ✗
```
`let slot_hashes = SlotHashes::get()?;`
bumping this to see if anyone has any ideas on how to get access to slothashes during execution
And this should be 8 + 32 + 1 https://github.com/aeyakovenko/token-omnibus/blob/cda29655cce688c295f57fc0b6399eb476480f0c/programs/token-omnibus/src/lib.rs#L133
from and authority are equal
maybe this is intentional but this is saying that the token account is its own authority https://github.com/aeyakovenko/token-omnibus/blob/cda29655cce688c295f57fc0b6399eb476480f0c/programs/token-omnibus/src/lib.rs#L36
also, u can use account.key() instead of account.to_account_info().key()
Ah got it
you dont have to. by the time your code executes, anchor will have checked that all accounts are properly initialized
What about via js?
And then also the normal solana program-test crate works as well for integration tests.
You can run normal cargo unit tests. `cargo test --lib`.
How do I check the account is initialized?
space should be `space = 40` (once you have removed `initialized`). the anchor account discriminator takes 8 bytes
no need for an `initialized` field on your accounts. anchor handles that check for you
if you use additional functions, you can test them like you normally would. for instruction tests we dont have a guide on anchor tests yet (coming soon) so the tests folder in the repo is the best source I think
is there a guide on writing unit tests with anchor?
Yep working now! RIP idl
no tests yet
my first anchor program!  https://github.com/aeyakovenko/token-omnibus/blob/master/programs/token-omnibus/src/lib.rs
has anyone received this error using the @project-serum/anchor library with react ?
```
BREAKING CHANGE: webpack < 5 used to include polyfills for node.js core modules by default.
This is no longer the case. Verify if you need this module and configure a polyfill for it.
```
is there a way to take it off?
after i put a program on testnet or devnet
But thats my thoughts
Ok I think its because I wasnt copying the idl each time, will try again next time I’m on the computer
nvm https://giters.com/project-serum/anchor/issues/1059 have to do anchor `deploy` first
I'm following a tutorial that has me do `const programID = new PublicKey(idl.metadata.address);`.  my `idl.json` has no metadata field.  is this something that is dynamically generated or did I do something wrong?
I've tried a few annotations and types (Program, Account, Signer) for that chainlink var still can't get anything to stick
to the best of my knowledge, it works with the latest solana sdk
From what I can tell Pythwill likely have the same issue as it's using next_account_info as well
I pass that in as the chainlink arg
on the JS side, here's how I'm getting the PKEY

```const chainlinkPublicKey = new PublicKey('6dbkV6QCToTk6DRfuJyrGuz18kZ4rPUSHLLLVrryWdUC');
``` (that's the devnet btc address)
Right now I have it as AccountInfo, but if I try using the Account annotation, I get errors about not having access. In the current form it doesn't deserialize
```
#[derive(Accounts)]
pub struct Process<'info> {
    #[account(init, payer = user, space = 8 + 1 + 32 + 16)]
    pub story_account: Account<'info, story_account>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub chainlink: AccountInfo<'info>,
    pub system_program: Program<'info, System>,
}
```
So my main issue is just in the definition of accounts, I'm trying to set it up in a way that I can access chainlink
Absolutely one moment
what solana sdk works with anchor 0.19?
Can you post code snippets of what isn't working? I'll be looking into this too in the coming days so will be useful starting point. No promises
<@!161709591220977664> https://github.com/project-serum/anchor/issues/383 I just found an issue in the repo. It's not a supported feature
```toml
[provider]
cluster = "localnet"
wallet = "../../keypairs/dev.json"

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.spec.ts"
```

it's defined. but if i rebuild on a different computer and deploy, anchor will generate  a new keypair and use that.
you point to the cluster and keypair json
under [provider]
i think you define the keypair in Anchor.toml
yeah, i see it in the target folder. During build/deploy i'd like to do something like `anchor deploy --provider.wallet=WALLET` or `ANCHOR_WALLET=WALLET anchor deploy` but both commands are ignoring the defined wallet
I think it puts it there
Check the target folder
also, is there a way to override the deploy keypair in anchor?
<@!73802344810160128> i haven't used an oracle yet. but i'll sure give it a try and i'll try to maek a tutorial series on anchor when i have the time
Every annotation I used seemed to error
tempted to just go back to vanilla solana
I just couldn’t figure out how to pass an address in and convert it to address info to use with either lib
<@111233596173373440> pyth looks good, let me know if you ind a way to pass the accounts in, its essentially the same pattern as the chainlink lib
yeah, i don't think we can create get slothashes within a contract
are there any examples in buildspace or anchor that show how to remove item from a vec based on some input from an outside app?
```rs
pub fn get_feature() -> u8 {
    let slothash = SlotHashes::new();
    msg!("{:?} is the Slot Hash", slothash.slot_hashes());    
    return 0;
}
```
this is the closest i've been able to come to it, but get an error that SlotHashes::new() requires an argument (&self) and i don't know how/what to supply for that arguement
I have actually found https://github.com/project-serum/anchor/search?q=oracle
something called `pyth` which is doing something related to oracles and prices - will be delving into that in hopes of fetching an "unpredictable" value for my usage

ehh, actually, I don't think this is it
if it's within a contract, i tried to no avail
it's interesting how many people are asking similar questions right now. 

I'm trying to find a way to generate a random (or fairly pseudo-random) result without a real Chainlink VRF available. 

Options include either:
 - using recent slothashes + other data to generate a number that is sort-of random (not ideal) - which would involve something like what <@!161709591220977664> is asking for (getting a slothash and somehow deriving a value from it)
 - Utilizing a chainlink price feed, which is at least an unpredictable value, to derive my random value from - which is similar to what <@!73802344810160128> is asking above. I can find a number of people on this disc and other websites _talking_ about querying a chainlink oracle price feed as a data source, but can't find a single code example to reference to do so in anchor rust
can someone walk me through how to get the most recent slothash and cast it to a u8 ?
this is weird tbh. I have the wallet defined in anchor.toml. I think it's a bug
It’s probably generating because the private key isnt found in the target dir
Copy the target keypair
It's declared in the `Anchor.toml` file

```toml
[provider]
cluster = "localnet"
wallet = "../../keypairs/dev.json"

[programs.localnet]
crash = "8VQFmDx6YoJtDtQ9pPXzi3SQCQ18mEaSpgDEnEmr9uc9"

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.spec.ts"
```

and also 
```rust
declare_id!("8VQFmDx6YoJtDtQ9pPXzi3SQCQ18mEaSpgDEnEmr9uc9");
```

but whenever i switch computers, a new id is recreated on localnet
declare it
how can i keep program-id from changing on localnet when i build on a different machine?
why is the pda seed type different between the solana api and anchor? (nm, user error)
does anchor have a way to fake time, e.g. fast-forward a staking contract to make sure that expected values match in two or three years?
Not yet :/ I work on my defi projects only from 7AM to 9AM each days ! I make you an update tomorrow 🙂 tell me if you succeed to make it works
I know u can do through cmd line, but wondering if there are any contract examples so the user can claim and pay the rent fee
Anyone have a good guide on airdropping NFTs or allowing users to claim a specified ammount per address of NFTs in anchor?
Hey! Did you get the chainlink stuff working in any capacity? I've also just found myself at a point where I need a random number generated for me. Watching the hackathon workshop now
Basically i'm just wanting to pass in a pubkey and have it serialized to program info without owning it
Super beginner question. I'm trying to implement the chainlink price feed. Passing in one of the accounts into my app I'm not entirely sure how to annotate it so that I have anchor de-serialize it into account data.
You can give some other account the authority, doesn't have to be the sender
```    let cpi_accounts = Transfer {
        from: ctx.accounts.asset_src.to_account_info(),
        to: ctx.accounts.asset_dest.to_account_info(),
        authority: ctx.accounts.user.to_account_info(),
    };
    let cpi_token_program = ctx.accounts.token_program.clone();
    let cpi_ctx = CpiContext::new(cpi_token_program, cpi_accounts);
    token::transfer(cpi_ctx, amount)?;```
I had this, They'ved changed the structure a bit. I ended up forking and branching the older version: ```chainlink = { git = "https://github.com/mattvv/chainlink-solana", package = "chainlink-solana", branch = "stable", features = ["no-entrypoint"] }```
couldn't the client delegate the amount outside of this instruction
why does transfer require an authority?
This is the best solana smart contract i have seen
https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo/src/lib.rs
my guess wasnt right
any docs to make a spl token transfer from anchor?

        let cpi_program = ctx.accounts.token_program.to_account_info();
        let cpi_accounts = Transfer {
            destination: ctx.accounts.omnibus.to_account_info(),
            amount: data.amount,
        };
        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
        token::transfer(cpi_ctx, data);


//////////////////////////////////////////////////////////////////////////////////////////

yea thats what i did but hashmaps are more convenient and safer
idk if it will work for you, but i was able to get around my issue by using a vec. 
```    
pub features: Vec<Option<Feature>>
```

allowed to to basically have a <k,v> where the k is the index in the vec
thanks!
that's what I was looking for RIP 😛 I was using createAccountWithSeed
you mean higher level than web3.js's `findProgramAddress`  somehow?
Does anchor have any client side helpers for creating PDAs?
if anchor does the account initialization for me, do i need to create and asign the account to the rpc arguments somewhere?     

Error: Invalid arguments: accountSet not provided.
makes a lot of sense
ik its a major issue we cant use hashmaps, btrees and even custom structs give idl error
you might have pictured the program address sort of like a hash of the program, then. But that's actually just the location of the program on-chain
I would also like to know this
got it wasnt sure if the keypair changed based on the idl gnerated
it stays the same if you dont change ur config
yup, why should it change?
Is it weird, when I run anchorbuild, my programid is the same even if I changed some code? wondering if program ids stay the same on mainnet and devnet which wouldnmt make sene
code here https://github.com/xedk/solana-splits/blob/structmethod/programs/split/src/lib.rs
and whats this ```https://github.com/xedk/solana-splits/blob/structmethod/programs/split/src/lib.rs```
can someone explain why hashmaps arent supported in anchor idl
i have all installed but i cant do nothing

I have been trying for several days to create NFT with gif and I can't find any information or anything on the internet.
Hello can anyone help me pls?
ok so my issue was that IDL in ts had to have all typed explicitely casted to work... is this requirment with new version of anchotr?
```rust
pub struct Map {
    pub pub_key: Pubkey,
    pub integer: u64,
}

#[account]
pub struct BaseAccount {
    pub count: u64,
    pub mapvar: HashMap<u64, Vec<Map>>
}

}
```
i have a struct i want to store in the hasmap vector but i get this err ```the trait bound Map: std::clone::Clone is not satisfied

expected an implementor of trait std::clone::Clone
```
if i do this 
```pub mapvar: HashMap<u64, Vec<std::rc::Rc<Map>>>```
 then i get a diff error ```the trait bound std::rc::Rc<Map>: anchor_lang::AnchorSerialize is not satisfied

the trait anchor_lang::AnchorSerialize is not implemented for std::rc::Rc<Map>```
to what anchor expects
seems like idl is generated in wrong way

anyone else having issues loading program via idl in react?
lol nws
damn <@!347689664855015424> i am a fucktard.
thats what i meant
`anchor test --help` :)
why i need it and many others might as well. On Building the program, IDL generated automatically does not handle variable type- Tuple well. I can edit the JS test script but then running Anchor Test again generates faulty IDL file.
With `solana program dump ` and `[[test.genesis]]`  i can run programs locally for testing. is there anyway i can also copy a few accounts from mainnet and store them in the test.genesis block?
i use node 16, would that be an issue?
--help
hey guys, can i run anchor test without re-building and deployment?
seems like there are issues with anchor versions and the way idl is built..
actually getting this error:
```Argument of type '{ version: string; name: string; instructions: { name: string; accounts: { name: string; isMut: boolean; isSigner: boolean; }[]; args: { name: string; type: string; }[]; }[]; accounts: { name: string; type: { kind: string; fields: never[]; }; }[]; }' is not assignable to parameter of type 'Idl'.
  Types of property 'instructions' are incompatible.
    Type '{ name: string; accounts: { name: string; isMut: boolean; isSigner: boolean; }[]; args: { name: string; type: string; }[]; }[]' is not assignable to type 'IdlInstruction[]'.
      Type '{ name: string; accounts: { name: string; isMut: boolean; isSigner: boolean; }[]; args: { name: string; type: string; }[]; }' is not assignable to type 'IdlInstruction'.
        Types of property 'args' are incompatible.
          Type '{ name: string; type: string; }[]' is not assignable to type 'IdlField[]'.
            Type '{ name: string; type: string; }' is not assignable to type 'IdlField'.
              Types of property 'type' are incompatible.
                Type 'string' is not assignable to type 'IdlType'.ts(2345)
No quick fixes available
```
how can i further debug this? the implemenation works with node server, but not with react. so IDL should be good.
i fetched latest idl with `anchor verify <address>`
i am getting following error:
`Uncaught (in promise) TypeError: Reduce of empty array with no initial value`

so obv something with IDL is wrong.
i am trying to initialize program from IDL:
`  console.log(JSON.stringify(idl, null, 4));

  const program = new anchor.Program(
    idl as anchor.Idl,
    programAddress,
    provider
  );`
anytime man
thank you!
ahh cool
I have this in my code base

```rust
pub fn can_sign(key: &Pubkey) -> bool {
    Pubkey::from_str(SIGNER).unwrap().eq(key)
}
```

Then i also use 

```rust
pub struct SomeContext<'info> {
    #[account(
        constraint = can_sign(authority.to_account_info().key) @ CustomError::InvalidSigner
    )]
    pub authority: Signer<'info>,
}
```
talking about if someone tries to invoke the ix, want to make sure it fails unless the authority invokes it
well would it be something like only the authority can be the signer?
u can hard code the wallet's public key
whats the best way to ensure only the authority of a program can call an instruction?
why does a native mint token account persist from test to test on localnet but any other spl token does not?
No DAO here, working on an assignment as part of an interview
What kind of DAO are you building?
when trying to set an account attribute to an array like so:
```rs
#[account]
pub struct Game {
    pub id: String,
    pub admin: Pubkey,
    pub enabled: bool,
    pub features: [Feature; 255]
    //pub features: HashMap<u8, Feature>,
    //pub troop_templates: HashMap<u16, Troop>
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Copy)]
pub struct Feature {
    pub  name: String,
    pub rarity: u8,
    pub next_scan: i64, 
}
```

i get the error that trait 'copy' cannot be implemented for type String in feature. without the Copy trait, i'm unable to set it in the game struct as an array because it wants all fields to be Copy-able
it does
```rs
#[account]
pub struct Game {
    pub id: String,
    pub admin: Pubkey,
    pub enabled: bool,
    pub features: HashMap<u8, Feature>,
    pub troop_templates: HashMap<u16, Troop>
}
```
idk I am a beginner too :3
sounds like your account doesn't have a `features` property?
this is the corresponding entry point:
```rs
    pub fn create_game(ctx: Context<InitGame>, id:String, _bump:u8, admin_pk: Pubkey, _0_loc_bump:u8, features:HashMap<u8, Feature>, troops: HashMap<u16,Troop>) -> ProgramResult {
        if ctx.accounts.admin_account.key != ctx.accounts.admin.key() {
            return Err(ErrorCode::Unauthorized.into())
        } else {
            let game_account = &mut ctx.accounts.game_account;
            game_account.enabled = true; //TODO: Default to False and then change it via functions. For debug purposes we'll just enable the game
            game_account.admin = admin_pk;
            game_account.id = id.clone();
            game_account.features = features;
            game_account.troop_templates = troops;
            emit!(EventNewGame {game_id: id.clone(), game_admin: admin_pk});
            Ok(())
        }
    }
```
and context:
```rs
#[derive(Accounts)]
#[instruction(id: String, _bump:u8, admin_pk: Pubkey, _0_loc_bump:u8, features:HashMap<u8, Feature>, troop_templates:HashMap<u16, Troop>)]
pub struct InitGame<'info> {
    pub admin_account: Account<'info, Admin>,
    pub admin: Signer<'info>,
    pub system_program: Program<'info, System>,
    #[account(init,
        seeds=[id.as_ref()],
        bump=_bump, 
        payer=admin, 
        space=8+32+58+1
    )]
    pub game_account: Account<'info, Game>,
    #[account(init,
        seeds=[id.as_ref(), 0_i64.to_be_bytes().as_ref(), 0_i64.to_be_bytes().as_ref()],
        bump=_0_loc_bump,
        payer=admin,
        space=8+1028
    )]
    pub start_location: Account<'info, Location>,
}
```
assuming here:
```ts
  //initalize the game
  const gameId=_gid;
  const gameacc = await getPDA([Buffer.from(gameId)], program.programId);
  const startLoc = await getPDA([Buffer.from(gameId), new anchor.BN(0).toArrayLike(Buffer, "be", 8),new anchor.BN(0).toArrayLike(Buffer, "be", 8)], program.programId);

  await program.rpc.createGame(gameId, gameacc.bump, provider.wallet.publicKey, startLoc.bump, await getFeatures(), await getTroopList(),
    {
      accounts: {
        adminAccount: contractadmin.account,
        admin: provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
        gameAccount: gameacc.account,
        startLocation: startLoc.account,
      }
  })
```
trying to run anchor test on some code :/ unsure where in the code it's erroring
This tutorial is excellent.  Thanks for sharing
when do you get this error?
what does this error mean?
```
     IdlError: Type not found: {"name":"features","type":{"defined":"HashMap<u8,Feature>"}}
```
bump 😄
Ahhhhh. Thank you!! just saved me a ton of time
Not the base, the base is just for anchor
Ah , the cargo.toml in the programs folder
I keep getting this issue whenever I attempt to do so: `this virtual manifest specifies a [dependencies] section, which is not allowed`
Add it to your cargo.toml
how do I install anchor_spl?
Figured it out over on Solana discord. I was close - just needed to create the Uint8array: ```memcmp: {
   offset: 8, // Discriminator.
   bytes: bs58.encode(new Uint8Array([1])),
},```
np, you too
you deserve it
hope u have a good 2022
happy new years to you and your family
thanks man
yo
do `cpi = []` and see what happens
cpi? or no-entrypoint
that is disable it
does it work if you remove the feature?
whats the right way to do it then
mmmmm
if the entrypoint is not there the program cannot execute
for cpi
why do you have the no-entripoint feature enabled?
```Error: ELF error: ELF error: Multiple or no text sections, consider removing llc option: -function-sections
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }.```
but when I try to deploy it
when I build it it build ok
this is what the toml looks like
```[package]
name = "IDO"
version = "0.1.0"
description = "Created with Anchor"
edition = "2018"
resolver = "2"

[lib]
crate-type = ["cdylib", "lib"]
name = "ido"

[features]
no-entrypoint = []
no-idl = []
cpi = ["no-entrypoint"]
default = ["cpi"]

[dependencies]
anchor-lang = "0.20.0"
anchor-spl = "0.20.0"```
I am trying to compile a program with cpi
yes
once i download anchor v0.20.0, how do I actually upgrade my project to that anchor version? Do I only have to change `/Cargo.toml`?
Thank you very much <@!732815411808174111> !
And it's free. I haven't seen in anything worthwhile in Udemy yet.
hahaha yep, thanks I posted just one minute after hahahaha
See my post right above this.  I started here and it gave me almost all I needed to fully develop in Solana/anchor.
Hey guys, is there any good course about how to develope on Solana in coursera,udemy,etc?
This is really an excellent tutorial on creating Solana accounts via anchor, writing & reading text from them. One of the best quality tutorials I've come across. Lesson 3-6 is what you're looking for specifically.  https://lorisleiva.com/create-a-solana-dapp-from-scratch
how did you resolve this after adding the cpi part?
does anyone know the error when trying to deploy

Hey everyone
Anybody have an Anchor example writing text to an account, and then reading from it?
How would I pass a boolean value in a memcmp filter? Would it just be ```bytes: bs58.encode([01])``` or something to that effect? Buffers and base58 are fairly new to me.
I've seen a lot of anchor code talking about bumps. I looked through the official Solana docs and there's not much there about what a bump is and why it's important. Was just looking for clarification
So the follow is almost certainly really poor code, not sure if it's possible to cause a panic but I was screwing around with this and did the following:
```
    // A hash derived from adding together unix_timestamp and clock slot
    let basic_hash: Hash = hash(&(clock.unix_timestamp as i128 + clock.slot as i128).to_be_bytes());
    // Then, a u64 derived from the first 8 bytes of the hash.
    let pseudo_random_u64: u64 = u64::try_from_slice(&basic_hash.to_bytes()[0..8]).unwrap();
```

it creates a u64 from the hash of the two values.

Anyone, feel free to point out if the above is problematic. I know it's not true random, that's not really the goal since it's impossible afaik on-chain.

I casted the first two values (an i64 and a u64) to an i128 before hashing because I _think_ that would prevent overflow errors
also running `anchor idl fetch` throws following error:
`anchor idl fetch CUS1qwyVkxg2Pbt35iPU5x133Nfg2oaiUsshKhnRvWfH
thread 'main' panicked at 'Inside a workspace', cli/src/lib.rs:1359:47`
where IDL is typescript object. prob has to be loaded from json i would say?
i'm trying to use this to fetch idl
``const idl = await anchor.Program.fetchIdl(programAddress, provider);``

gets data is null error

and trying this:
``  const program = new anchor.Program(
    IDL as anchor.Idl,
    programAddress,
    provider
  );``
Hey <@439210198142550016> , I just quit my job as a backend engineer at Robinhood to build a Solana protocol. Would love to hear your feedback on it, if your DMs are open!
how do you load IDL into react FE? idl has to be in json file and loaded into object?
https://github.com/project-serum/anchor/issues/59
we did that in rust
would be cleaner
yea
shouldn't there be a TX builder or something
main gotcha is that the context is at the end in ts instead of the beginning in rust
got it
ah
Can pass that in via params like a normal function call.
var arr = Array<byte>(32).fill(0);
    const tx = await program.rpc.initialize({data: arr});
instruction data
is there an anchor/rust example that does a CPI to a 3p program (not system)?
What is the difference beween  [K in T] and [K in keyof T] in a indexed map?
What do you mean by user data? You can pass in the instruction data as the function parameters and you can pass in the "context" as the last param, which holds all the accounts and any additional signers you need on the tx.

https://project-serum.github.io/anchor/ts/index.html#Context
<@501570363566587905> I put the multisig up on devnet and ran the first test, but I’m getting an invalid data account error. Have you ran into it before?
do I have to supply the program's public key if not a user wallet even if the transaction doesn't need signed?
https://github.com/cqfd/quidproquo/blob/main/tests/quidproquo.ts
So like program.rpc.init(userdata, { accounts: …
Pass it in as first parameter to program.rpc.<method>
<@!501570363566587905> so in program.rpc.<method> how do i set the userdata?
build transaction with `program.instruction.something` instead of using `program.rpc.something`
Do I just rely on on the connected wallet signing the tx automatically be being part of the provider?
i guess this: https://discord.com/channels/889577356681945098/889702325231427584/929099272799027250 ?
which requires `sendTransaction(transaction, connection) in order to automatically sign the tx.
it's solana wallet adapter.
Yes! Integrating with phantom wallet.
are you integrating with Phantom wallet?
ohhh hahah cool 👍  didn't know that
You can use `program.simulate` as well.
But if you want to use `program.rpc` instead of `program.instruction`, here's a good example: 
https://github.com/cqfd/quidproquo/blob/main/tests/quidproquo.ts#L84
Personally, I use `program.instruction.*` instead of `program.rpc.*`. This way, you can use the `simulate` method: 

```const txn = new anchor.web3.Transaction();
    txn.add(
      program.instruction.myInstruction(
        myBump.
        mySecondBump,
        new anchor.BN(MY_MAX),
        {
          accounts: {
            payer: payer.publicKey, 
            stablecoinMint: stablecoinMintToken.publicKey,
            vault: vault,
            systemProgram: anchor.web3.SystemProgram.programId,
            tokenProgram: spl.TOKEN_PROGRAM_ID,
            rent: anchor.web3.SYSVAR_RENT_PUBKEY,
          },
      })

  const signers = [payer];
    if (simulate) {
      return await program.provider.simulate(txn, signers);
    } else {
      return await program.provider.send(txn, signers);
    }
  }
```
Looking to create a Program to make rpc requests *without* a provider (I don't want my user to have to connect their wallet) and it's looking for some kind of config file:

```ts
const program = new Program(IDL, programID);
```

I get this error:

`Uncaught (in promise) TypeError: __webpack_require__(...).readFileSync is not a function`

Because it's calling:

```
  static local(): NodeWallet {
    const process = require("process");
    const payer = Keypair.fromSecretKey(
      Buffer.from(
        JSON.parse(
          require("fs").readFileSync(process.env.ANCHOR_WALLET, {
            encoding: "utf-8",
          })
        )
      )
    );
    return new NodeWallet(payer);
  }
```

How do I set this up to work locally and also in production?
gotcha, im pulling up my code
Once you need to use Box youve officially become a solana dev
<@!912046857000194158> <@!347689664855015424> If the users keypair isn't available on the frontend, how do we pass it to signers?
Since we need to explicitly sign for the keypair user, signers: [theirKeypair] in the rpc call
np 👌
Thank you so much bro
pub fn initialize(ctx: Context<Initialize>, data: [u8; 32]) -> ProgramResult {
the "data" field
Fortunately, it's pretty straightforward <@!694458281388671077>
https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo/src/lib.rs#L219
Thanks..
But how can i use Box<> any example??
by user data, do you mean the `Context` and other instruction parameters?
Since we need to explicitly sign for the keypair user, `signers: [theirKeypair]` in the rpc call
If the users keypair isn't available on the frontend, how do we pass it to `signers`?
You've reached your 4KB stack limit. You need to move stuff to the heap using `Box<>`. For large accounts, use zero copy if you still need
how do i send userdata through the rpc command?

```
    var arr = Array<byte>(32).fill(0);
    const tx = await program.rpc.initialize({userdata: arr});
```
refer to the random.org api for atmospheric noise. the closest representation to true random we can generate. Would require you to provide an oracle for that.
If you search chat there is an answer, usually you need to use box<>


//////////////////////////////////////////////////////////////////////////////////////////

hey guys, I have many-to-many mapping of topics <> users. What is the best practice for maintaining such data on-chain. Do i need to create separate PDAs for each topic<>user map? Is there any reading material around this? Would appreciate if someone is open to a 30min consulting session
Hi, I encounter the same problem with yours. I have installed the yarn, but when i run "anchor init test". The error shows "Error: yarn install failed". I run the program on Windows10.
I've been seeing a number of tutorials where they bundle the program in with the front end, is it not better to keep them seperate?  Or is there a benefit to keeping everything together?
Any  way to have my program close PDAs that it has created? Is the easy solution to change the PublicKey of the program so that the accounts are no longer associated?
There's no stupid questions, so no offense but do keep the questions in the open chat. I assure you I'm the first one to ask stupid shit so no judgement
Thanks <@!915682383905316864> I'm gonna slide into your dm's for some really stupid questions later 😛
My bad my signer was different from user, it was the program_account
maybe you got the client snippet?
where do these accounts come from?
Neither program account nor service account
Oh yes sorry the program_account...but here the signer is a third account
you don't need to sign to receive lamports
from your snippet it's the other way around, which is why the signer needs to be `program_account`, the one being deducted lamports
And I am a bit confused...even though service_account is losing its lamports to public_account, how come only the signature of user is enough in the above example? 
All 3 are different accounts currently
shouldn;t the account that has debits, be a signer? to let the program take some lamports out?
so lets say I want to split this into 2 functions. One which will create this ledger account, and another function which will do the amount transfer between the service account and program account...Who should be the signer for the second function?
yes the program will automatically make a CPI call to create the ledger account because of the `init` attribute, and fail if that account already exists
So since I have mentioned init in the struct, this will create a new account right?
no it's an a per-account basis indeed
haha I see
The error is actually saying exactly this: "you tried to change the balance of an account not declared as mut"
I thought adding accounts below it means all are #[account(mut)]
OMFG thank you so much
yes, the same way you did for `user`
Do I need to add #[account(mut)] before each account?
for `program_account` and `ledger`
Yeah it seems you are missing at least a couple `mut` on you context definition
Error is: `Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: instruction changed the balance of a read-only account`
Better to resolve issues in the open for others' benefit. It would also be beneficial to post the actual error
Anyone here who doesn't mind me getting into their dm's for some simple quick questions regarding this?
Hey <@!831450660146642974> ?
My struct is this
`#[derive(Accounts)]
pub struct Create<'info> {
    #[account(init, payer = user, space = 8 + 64 + 64 + 64 + 64)]
    pub ledger: Account<'info, Ledger>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
    pub service_account: AccountInfo<'info>,
     pub program_account: AccountInfo<'info>
}`
Hey guys can someone help me here
My use case for a function
Debit an amount from a program_account and credit that amount to a service account. Parameters for this function should be service account, public account and an amount :u64
Can someone point out what I am doing wrong here?
`pub fn create(ctx:Context<Create>, id: String, amount: u64) -> ProgramResult {
        let ledger = &mut ctx.accounts.ledger;
        let service_account = &mut ctx.accounts.service_account;
        let program_account = &mut ctx.accounts.program_account;
        **program_account.try_borrow_mut_lamports()? -= amount;
        **service_account.try_borrow_mut_lamports()? += amount;
        ledger.amount = amount;
        Ok(())
    }`
no idea how u figured that lol well done
so in my typescript I had to call the struct fields as camelcase rather than the snake case i had defined in rust *face palm*
OMFG I figured it out. it's cause anchor converts underscore variable names to camel case
this is happening to numbers before they go into an account, but yes the account they eventually end up in is a 10kb account
Does the account have enough space allocated?
`#[account(init, payer = user, space = 64 + 64)]`
```rs
    pub fn debug(_ctx: Context<Debug>, x:Vec<DebugStruct>) -> ProgramResult {
        msg!("X: {:?}", x);
        Ok(())
    }   

#[derive(AnchorSerialize, AnchorDeserialize, Clone, PartialEq, Debug)]
pub struct DebugStruct{
    pub x:i64
}
```

```ts
    await program.rpc.debug([{x:new anchor.BN(-1)}], {accounts: {}});
```

^^^^This works as expected
hrmm....now i'm getting even weirder behavior. *all* my signed integers are referencing down to 0 as well >.< this is even more confusing because i wrote a debug function where everything is working as it should
Maybe related to the endianess of BN? What values do you get if you pass in -2, -3, 0, 1 and 2? Sorry not more helpful
hoping someone can help me figure this out. i'm passing in a struct with one of the fields being a negative number. in TS it's a BN(-1), but when printed out on the contract side it's 0

relevant code:
```ts
  //upload Features and Troop Lists
  const features = await getFeatures();
  console.log("-----------FEATURES----------------")
  console.log(features); //<--- features[0].next_scan == BN(-1) here

  await program.rpc.addFeatures(features, {
    accounts: {
      game: gameacc.account,
      authority: provider.wallet.publicKey
    }
  })
```

```rs
    pub fn add_features(ctx: Context<ModifyGame>, new_features: Vec<Feature>) -> ProgramResult {
        msg!("Features: {:?}", new_features); //<--- features[0].next_scan == 0 here
        let game = &mut ctx.accounts.game;
        game.features.extend(new_features.iter().cloned());
        Ok(())
    }
```

also the field (next_scan) is a *signed* integer, so it shouldn't be casting
```rs
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct Feature {
    pub weight: u8,
    pub name: String,
    pub next_scan: i64, 
}
```
i wasn't able to find any other way to do map, so yea just using Vec creatively 😅
Thanks! Is there any other map supported, or workaround is to use Vec creatively?
https://github.com/project-serum/anchor/issues/1266#issuecomment-1008185937
afaik HashMaps aren't supported currently
is it possible to use HashMap<T1, T2> as a type in a struct? Else how to use a map? I get a weird error when I do, and if I change it to Vec<T> it works normally... the IDL says 

            "type": {
              "defined": "HashMap<String,f64>"
            }

vs.

            "type": {
              "vec": "string"
            }

respectively
for my app, I was going to set up a backend layer that serves as the liason between FE and contract
Cause the contract works locally / backend wise but getting it to work with the FE is the part missing
hmm i havent implemented anchor in a frontend web app yet so i dont know
Feel like I’m still missing a thing or two
Not really yet for me at least lol
Separate question:

In my anchor typescript tests, who should I expect to be paying the gas fees?
have u found any good tutorials online?
gotcha
Pretty much doing the implementation from contract to website FE really at this point
wdym? Anchor has a separate package for each
you need to pass in a publicKey usually
best way to go for what? use the anchor ts library to convert most things
worked, the only weird thing was needing to to make sure its {enum.toLowerCase() : {}} instead of just {enum:{}}
What’s the best way to go from anchor_lang to typescript? Still can’t wrap my head around that portion of things fully
thanks, will try
<@!161709591220977664> I read this
but haven't tried it
https://2501babe.github.io/posts/anchor101.html
what's the best way to pass in an enum from TS through RPC for anchor?
owner is a generated keypair, not sure what I'm doing wrong since the same code was working before couple weeks ago
Getting signature verification failed for some reason when my code was working before.
user is my only Signer account in my program instruction
```rust
use std::str::FromStr;
```
Sure
Want to ask regarding grape
Can you accept me
<@770650336725172267>
or crate import
lol i cant seem to figure out how to import the from_str method. I see it implemented not sure whats wrong with my using
thanks!
yup
any account that anchor creates is rent exempt by default?


//////////////////////////////////////////////////////////////////////////////////////////

=======
>>>>>>> 20bea11087240cc616c020a0810cf4b960b99b41
