Not sure how haha
I now need to convert an &mut &[u8] into an &mut [u8]
Thanks! It is just Pubkey.to_bytes()
https://discord.com/channels/889577356681945098/889577399308656662/906082959193411596
Like that is what it is, but for the library I am using it needs the primative type
Does anyone know how to convert an Anchor Pubkey into a [u8; 32]
https://doc.rust-lang.org/std/option/enum.Option.html
I'm quite new to Rust, but I think this is the way x)
niiiiiiiiiiiiice - I'm figuring out how to unwrap / wrap the <T> from Option  in order to create all operation functions (create, destruct, switch, etc) but if it works in the end that's sweet
I am currently using a crate called sodalite, but would be nice if there were something native in Anchor as I am using the Pubkey struct in Anchor as my endpoint input
`nacl.sign.detached.verify(message, signature, publicKey)`
This funciton but in Rust
Is there a tweetnacl package in the anchor_lang rust crate that I can use to verify a signature like in tweetnacl-js
Loader uses `zero_copy` deserialization, Account uses regular anchor serialization
I also get errors that I dont add default for luke systemprogram, clock, and so on. 
```
error[E0277]: the trait bound `anchor_lang::Program<'_, anchor_lang::System>: Default` is not satisfied
  --> programs/baby/src/instructions/initialize_baby.rs:38:5
   |
38 |     pub system_program: Program<'info, System>,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `anchor_lang::Program<'_, anchor_lang::System>`
   |
   = note: required by `std::default::Default::default`
   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the trait bound `anchor_lang::Program<'_, anchor_spl::token::Token>: Default` is not satisfied
  --> programs/baby/src/instructions/initialize_babylon.rs:39:5
   |
39 |     pub token_program: Program<'info, Token>,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `anchor_lang::Program<'_, anchor_spl::token::Token>`
   |
   = note: required by `std::default::Default::default`
   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the trait bound `anchor_lang::Sysvar<'_, anchor_lang::prelude::Clock>: Default` is not satisfied
  --> programs/baby/src/instructions/initialize_baby.rs:40:5
   |
40 |     pub clock: Sysvar<'info, Clock>,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `anchor_lang::Sysvar<'_, anchor_lang::prelude::Clock>`
```
Any thoughts here 🙂 Thank you all
What do I do with the account?
Hi team stuck on providing constraints on my accounts and getting a bit stuck. I believe the error is coming from pda
```
#[derive(Accounts)]
#[instruction(bump: u8)]
pub struct InitializeProgram<'info> {
    #[account(mut, signer)]
    pub initializer: AccountInfo<'info>,
    #[account(
        init,
        payer = initializer,
        space = 8 + std::mem::size_of::<BabyData>())]
    pub baby_data: ProgramAccount<'info, BabyData>,
    #[account(
        init,
        payer = initializer,
        space = 8 + std::mem::size_of::<WhiteData>())]
    pub white_data: ProgramAccount<'info, WhiteData>,
    #[account(
        init,
        payer = initializer,
        space = 8 + std::mem::size_of::<UlistData>())]
    pub ulist_data: ProgramAccount<'info, UlistData>,
    #[account(mut, signer)]
    pub usdc_token_account: Account<'info, TokenAccount>,
    #[account(mut, signer)]
    pub sol_token_account: Account<'info, TokenAccount>,
    #[account(seeds = [TREE_PDA_SEED.as_ref()], bump = bump)]
    pub pda_account: AccountInfo<'info>,
    #[account(mut)]
    pub treasury_wallets: Account<'info, TreasuryWallets>,
    pub system_program: Program<'info, System>, 
    pub token_program: Program<'info, Token>,
    pub clock: Sysvar<'info, Clock>,
}
```
For babydata, ulistdata, and whitedata I have 
```
#[account]
#[derive(Default)]
pub struct UData{
    pub bump: u8,
    pub key: Pubkey
}
```
The error that shows up for these structs is 
error[E0071]: expected struct, variant or union type, found type error
 --> programs/babylon/src/state/baby_data.rs:3:1
  |
3 | #[account]
  | ^^^^^^^^^^ not a struct
  |
If you're on MacOS you need to build from source, npm package is only supported for Linux.
Hello, I'm trying to call rpc function (candy machine mint) inside my frontend vue script, I connected the wallet, checked candy machine program object, all functions like signTransaction are there but when I call it I'm getting the error inside wallet adapter ```TypeError: this.emit is not a function
    at Object.<anonymous> (vendor.dc4156ad.js:70)
    at Generator.next (<anonymous>)
    at vendor.dc4156ad.js:70
    at new Promise (<anonymous>)
    at __awaiter$3 (vendor.dc4156ad.js:70)
    at Object.signTransaction (vendor.dc4156ad.js:70)
    at Provider.send (vendor.dc4156ad.js:183)
    at async Object.mintNft (vendor.dc4156ad.js:207)
    at async ni (index.14c73809.js:1)
    at async n (index.14c73809.js:1)```, I changed phantom and solflare adapter and the error appears inside both adapter.ts files. What can be wrong?
Just use the instructions on https://project-serum.github.io/anchor/getting-started/installation.html#install-solana - all the needed commands are in there. You can use NPM to install anchor-cli or build from source.
What is the difference btw `Loader<'info, ChatRoom>` and `Account<'info, ChatRoom>`?
sorry for my english 'im french
No, actually I was following a tutorial on how to develop on the solana network. However in that tutorial it said to install anchore - cli so I googled it directly, then below the tutorial there was a discord link.
Did you ever find an answer to this?
Ok thanks, wasn't clear on where to find this example
you asked for resources that do what you want, the ido pool example in `anchor/tests` does that
?
it probably was just the machine struggling a bit to run the test validator
ok, increasing that to `20_000` worked for me
ok, i'm trying alan's recommended approach 
```
[test]
startup_wait = 10000
```
IDO pool
Sirs are there any tutorials/resources which show how to CPI to an already deployed token where the mint authority is my Program
it happened when i tried to add 
```

[[test.genesis]]
address = "9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin"
program = "../../target/deploy/serum_dex.so"
```
to the Anchor.toml file. But quite weirdly, even after I delete those lines it still doesn't run
Hi
tried deleting the program target directory and the test ledger directory
getting a silently failing local net
```
   > cat .anchor/test-ledger/test-ledger-log.txt 
Ledger location: .anchor/test-ledger
Log: .anchor/test-ledger/validator.log
Initializing...
```
did u get it to work, i am basically trying to do the same thing (PDA with global account and simulate multiple users interacting with the program)
so `accounts: { user1: Keypair.generate(), user2: Keypair.generate(), ...}`
if you want to generate new keypairs, you can use ` Keypair.generate()`
this is the one that uses the default key, saved on your file system
how can you create multiple user accounts in a test file ? I tried to replace ```accounts: {  user: provider.wallet.publicKey }```  (when creating new accounts) with a key i generate on the go with ``anchor.web3.Keypair.generate();``. but i didn't do the trick
unfortunately yes, but started to work on something else
What do you mean? There's no "anchore" on that page, so not sure how you got to that other github repo
the repo github
What went wrong?
so i try used this link
haha xD, i think i'm in the wrong github because i want use this for develop in solana
That's a similarly-named but totally different project haha, you're either in the wrong discord or on the wrong github repo

i used that :
https://project-serum.github.io/anchor/getting-started/installation.html#install-anchor
Is that how you're trying to install anchor?
Haha, anchorecli is something totally different I think 😛
When you use `init`, your anchor code will make a cross-program invocation to the system program to create that account. Doing it in a separate instruction from the client (could be prepended to the transaction) doesn't actually do a cross-program invocation, it just runs that instruction directly.
Hello everyone, i have just install anchor-cli but when i started the command anchor --version, its not working. Can you help me please ?
By the way, I'm a bit confused, aren't we creating via CPI ? what's the difference with creating via instructon? 🤔
Hmm still need to mess around. you mean the client like front-end right?
Hello, on initialization how can i store some solana in the contract until certain action?
Hey guys, is there any documentation on the instruction attribute?
thx for your help i installed using npm i have this :
It's very straightforward, you just need to add some derive macros on top of the enum
Search for `enum` in `anchor/tests` or serum/swap repo inside .rs files
Yeah the serum errors are pretty cool
Is anyone actively working on adding more verbose debugging?
You know serum has a really weird debug thing that actually prints out the line number the error happened
How to implement enum in anchor?
Or havign your program panic if its runtime program id doesn't match its declare_id! (your stuff is def wrong if they don't match)
Think this is a good example of how a noiser debug version of anchor would be good—these errors could be self-explanatory if they logged a bunch more
It seems to be popping up an awful lot
I'm curious what the root cause could be for so many errors related to incorrectly owned accounts
Hi, do you still getting 0ax7 error?
ok
Basically just need to figure out what borsh didn't like—e.g. double check you're using the right account, it has the expected length, etc.
It will give you some kind of borsh error, not sure if it has more info about what borsh didn't like
Ok, cool. Might as well try logging additional error stuff then I guess, in that `map_err` above
Atleast its non null
It looks correct
Let me check
Like, if you await program.provider.connection.getAccountInfo(metaDataAcc)
Does the data in there look correct to you?
Yes I am testing on devnet
This is the way I am computing it
const [metaDataAcc, metaDataAccBump] = await anchor.web3.PublicKey.findProgramAddress(
      [
        Buffer.from("metadata"),
        TOKEN_METADATA_PROGRAM_ID.toBuffer(),
        NFTTokenMint.toBuffer(),
      ],
      TOKEN_METADATA_PROGRAM_ID
    );
And you're testing on devnet?
let TOKEN_METADATA_PROGRAM_ID  = new anchor.web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s");
and it is owned by TOKEN_METADATA_PROGRAM
THis is the account on devnet
Yep
``metaDataAcc is DR3Dr7YxBNCMMCTwyB34evv6D6Y6HYH53bTT6P16YV8r``
Does that account actually store metadata in it? It won't automatically—in general it will just be an empty account unless you've made sure it actually has metadata in it (not automatic, especially when testing locally)
<@!712332112128376885> 
Can you help me with the below, I see you have done something similar before

`let metaData = metaplex_token_metadata::state::Metadata::try_from_slice(*ctx.accounts.token_metadata_account
        .try_borrow_data()?).map_err(|_| ProgramError::InvalidAccountData)?; 
The following is not working for me I get InvalidAccountData
FYI the token_metadata_account is of type AccountInfo
and it also exists
in short it is correct , can you just help me point the issue`
mm, very abstract but I think I get the idea, thanks! <@!163857206721249280>
I still have a fairly laymen's understanding of it all, but you do some math, and when a number is on that curve, you get a public and private key out of it. But if the formula lands outside of the curve, then all you can get is a public key out of it, so by bumping your seeds until you find an off-the-curve value, you are able to generate public keys that cannot possibly have a private key counterpart, and thus cannot be signed by anybody. So they're safe to use as storage account addresses, to be used by the program only, without risking anybody happening upon any private key for them
Yep, the right hand side of `space =` can be any expression—e.g. you could even specify it from the client with an `#[instruction(how_much_space: u64)]` (that would be kind of weird, just an example)
I thought something was wrong and I was nearly hitting the numeric limit for the u8 type... that wouldn't have been good!  😆
What is the concept of the `elliptic curve` about?
whew! Thanks! That makes sense, and makes me feel better  😅
I am experimenting with that right now and I get high values too.
I don't understand very well the concept of the `curve` , but regarding the value, as mentioned in this article https://www.brianfriel.xyz/understanding-program-derived-addresses/,  `In Solana, we start with bump = 255 and simply iterate down through bump = 254, bump = 253, etc. until we get an address that is not on the elliptic curve.`
question: Are very large bump values normal to encounter? I see code samples everywhere of bump parameters being u8, which maxes out at 255. And I also see mentions of being on/off the ec curve having a 50% chance. But then I print out my bump values from findProgramAddress, and they are super high, like 248 or 254... is this normal? Do the bumps count backwards maybe? I'm a bit confused on how they could reach such high numbers
Or `instruction`
Using the keyword `space`
You should try searching around the `anchor/tests` directory
oh, do you mind, sharing code snippet example?
this is how I currently code this
```
pub mod test {
    use super::*;
    pub fn initialize(ctx: Context<Initialize>) -> ProgramResult {
// how to set the space?
Ok(())
}
}

#[derive(Accounts)]
pub struct Initialize<'info>{
  #[account(init,payer=user,space=??)]
  pub data: Account<'info,DataStruct>,
  pub user: Signer<'info>,
#[account(address=system_program::ID)]
pub system_program: Program<'info,System>,
}

#[account]
pub struct DataStruct {
  pub user_address: Pubkey,
  // etc, potentially costly data
}
```
You can pass it in as an argument from the instructions
If I am not wrong that is not possible. The space needed has to be defined before deploy
Ah thanks for the clarification <@!248066053161222144> . Can we set account space dynamically on invoking the function?
say doing things like #[account(init, payer=user,space=*some function*)] ?
It's 10mb for accounts created in instructions, it's 10kb for accounts created via CPI
I count that maximum we can get is  10,240 bytes. is that correct? 🤔
Hi, wanted to ask, I encountered this
```
Transaction simulation failed: Error processing Instruction 0: Failed to reallocate account data 
    Program 5R5vVZtvt6abcozWVcxqgq43FBtPvuK2kqmR4ktCTXqQ invoke [1]
    Program 11111111111111111111111111111111 invoke [2]
    Program 11111111111111111111111111111111 success
    SystemProgram::CreateAccount data size limited to 10240 in inner instructions
    Program 5R5vVZtvt6abcozWVcxqgq43FBtPvuK2kqmR4ktCTXqQ consumed 200000 of 200000 compute units
    Program 5R5vVZtvt6abcozWVcxqgq43FBtPvuK2kqmR4ktCTXqQ failed: Failed to reallocate account data
Translating error SendTransactionError: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Failed to reallocate account data
{
  logs: [
    'Program 5R5vVZtvt6abcozWVcxqgq43FBtPvuK2kqmR4ktCTXqQ invoke [1]',
    'Program 11111111111111111111111111111111 invoke [2]',
    'Program 11111111111111111111111111111111 success',
    'SystemProgram::CreateAccount data size limited to 10240 in inner instructions',
    'Program 5R5vVZtvt6abcozWVcxqgq43FBtPvuK2kqmR4ktCTXqQ consumed 200000 of 200000 compute units',
    'Program 5R5vVZtvt6abcozWVcxqgq43FBtPvuK2kqmR4ktCTXqQ failed: Failed to reallocate account data'
  ]
}
Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Failed to reallocate account data
```

does this mean that there are limit to how much data we can store?
not a question. I am a beginner and got an upvote thing working thanks to <@!163804384193413120>'s guide. I am so psyched.
https://github.com/project-serum/anchor/blob/master/tests/ido-pool/programs/ido-pool/src/lib.rs#L332
do you need an init for an account.. Is there any good examples you can point to me of live code. Appreciate the hhelp
possible you forgot a `account(init,...`?
as a constraint
Thanks for following up but they align. I think the issue surrounds how I created my pda
this is likely that the value in `declare_id!()` is different from your key in `anchor keys list`
try
```
anchor build, anchor keys list --> go grab your key and update declare_id --> anchor build -> anchor deploy -> anchor test
```
Do you think I need to adjust token account constraints at all
Hi tthere I have is regarding how to properly put constraints around TokenAccounts in your program... so like I get this error. I think the error is caused either by my pda or my token accounts in this temp project I am working on.. 
     Error: 167: The given account is not owned by the executing program


 #[account(mut)]
    pub usdc_token_account: Account<'info, TokenAccount>,
    #[account(mut)]
    pub sol_token_account: Account<'info, TokenAccount>,
    #[account(seeds = [TREASURY_PDA_SEED.as_ref()], bump = _bump_seed)]
    pub pda_account: AccountInfo<'info>,


I think my error is coming from erither the TokenAccount or my pda constraints
Hi there, 
Im currently trying to run anchor testcases against the devnet, Ive changed the setting in `Anchor.toml` to devnet, and ran `anchor test --skip-deploy` after `anchor deploy `, However I got this error
```
TypeError: Cannot read property 'programId' of undefined
TypeError: Cannot read property 'rpc' of undefined
```
has anyone run into this issue before?
(so I used `solana deploy` and not `solana program deploy`)
I deployed this program using `solana -k admin_key.json -u mainnet-beta deploy <path-to-so-file>`
Here is the deployed program on main-net: https://explorer.solana.com/address/JBAnZXrD67jvzkWGgZPVP3C6XB7Nd7s1Bj7LXvLjrPQA
`solana -k admin_key.json -u mainnet-beta program show --programs ` shows an empty table
What does `solana program show --programs` return
not sure if it's possible to reclaim SOL from that
ahhh, I see -- I used the old `solana deploy` which does not use an upgradeable bpf loader
Yes, there is, you can read about it here.
https://jstarry.notion.site/Program-deploys-29780c48794c47308d5f138074dd9838#561f8e76208a46b8963092adabab2256
It deploys the program correctly, but for some reason fails on next steps
```
Deploying workspace: https://api.devnet.solana.com
Upgrade authority: /home/sheep/.config/solana/id.json
Deploying program "fixed"...
```
I have a deployed program with `solana [...] deploy`
https://explorer.solana.com/address/JBAnZXrD67jvzkWGgZPVP3C6XB7Nd7s1Bj7LXvLjrPQA
Is there any way to close a deployed program & recover the Sol:
Hi all quick question: I am gettting this error when anchor deploying: Error: Program's authority Some(7aN6TLYfg3NDBHHxKWLTctHDaSJT2mT9fPZGgVaABVCp) does not match authority provided 7YSUUrPrUDWn4muyrq2KiWRbfYk57LF1BfcDCeYpoEBT
Any thoughts whatt is causing this
I am pair coding with afriend
But I tthink I did all the required work, I went to toml and pointed the wallet to where it is located on my computer and so on
Any thoughhts :))
And this is the only line in  `Anchor.toml`  that I changed
```
[provider]
# cluster = "localnet"
cluster = "devnet"
```
I do have 
```
json_rpc_url: "https://api.devnet.solana.com"
```
in config.yml set
Oh, yes, I see that it tries to connect to localhost for some reason
It looks like it's looking for a local test validator so you might have misconfigured
Good day! I'm getting this error, when trying to run tests on `devnet` on `1.8.5`. Am I doing something wrong?
```
Translating error Error: failed to get recent blockhash: FetchError: request to http://localhost:8899/ failed, reason: connect ECONNREFUSED 127.0.0.1:8899
```
can you paste the code where you have this address ?
Quick question, I am getting this error when I run anchor deploy: Error: Program's authority Some(7aN6TLYfg3NDBHHxKWLTctHDaSJT2mT9fPZGgVaABVCp) does not match authority provided 7YSUUrPrUDWn4muyrq2KiWRbfYk57LF1BfcDCeYpoEBT
thank you will check this out 🙂
did you trying installing using npm instead?
https://github.com/project-serum/anchor#getting-started
also check this out
https://discord.com/channels/889577356681945098/889606719829835816/909947411550580766
Great thanks
https://docs.rs/anchor-derive-accounts/0.18.2/anchor_derive_accounts/derive.Accounts.html
if ur on the serum discord i'd ask there
and how they work
Hi all what is the best way to learn anchor constraints
or setup a new market
👋 are there more recent instructions on how to build and deploy serum-dex? the readme was last updated 9 months ago rip

cargo build-bpf compiles but I'm not sure if I just yolo anchor deploy that and no clue how to actually setup the markets
https://discord.com/channels/889577356681945098/889702325231427584/915263210960076891 always open 😊!
🥲
IT'S BEAUTIFUL
BY GOD IT WORKS
IT WORKS
hm, will keep on investigating ...
which feels like it should be more than enough to do whatever needs to be done
(in addition to the 1.39 already used for the deploy)
it's odd though b/c I know I still had 0.9 sol in the deploy account
That's the only reason I know it off by heart
If you discord search the error when you get it you will see 100 people posting about 0x1
Yeah when it says 0x1 custom program error I wasn't sure "is this the Solana chain, is this a loader, is this anchor, is this my code?"
Or sometimes the errors are inside the processor file, for Solana
You need to find the error.rs file for the program that's giving you the error
Discord search and all over Solana source
Is there a place where I can find the error code definitions?
No I mean that's literally what 0x1 error means
maybe ... but the thing is I was able to deploy w/o issues (on main net) using the other method (`solana [...] deploy` instead of `solana [...] program deploy`)
not enough solana
so im unsure how to query for the data in my ts test
uh, hey again, soooo im building this out, and everything is set up, and it seems to succeed in creating the PDA and storing the data and all that? but, the weird this is that the IDL doesn't generate anything about the ManyFacedAccount account type
This looks like it's using the latest BPF loader
Hm, here's the deployed program: https://explorer.solana.com/address/JBAnZXrD67jvzkWGgZPVP3C6XB7Nd7s1Bj7LXvLjrPQA
Does mainnet not yet support the new BPF loader or something?
(which uses the old BPF loader)
However, I just deployed to mainnet by running `solana -k admin_key.json -u mainnet-beta deploy target/deploy/pixels.so `
but if I swap `devnet` with `mainnet-beta` the command fails w/ the above error
Ok interesting: I can deploy to devnet using `solana -k admin_key.json -u devnet program deploy target/deploy/pixels.so`
Oh ... does Anchor support "solana program deploy" or does it only support "solana deploy"?
it's worth noting that I can deploy to devnet without issue
`Error: Deploying program failed: Error processing Instruction 1: custom program error: 0x1`
Does anyone know what this means when deploying a program:
is there an easy way to see which accounts can take what keywords in its macro? like this <https://github.com/project-serum/anchor/pull/790>
yh man, thanks a lot!! 🙂
makes sense, thanks a lot for your help :). We have fun times ahead of us
You can use `anchor_lang::solana_program::instruction::Instruction` and start trying to construct one
You would have to build those same instructions in rust (probably a bit tedious, but doable) and invoke them with `invoke_signed` (passing in any relevant accounts from the client, including the orca program)
so all the instructions are clear from the frontend API, what is unclear to me though is: how to make the same CPI calls from within rust? i.e. I guess we have to send instructions to the orca program address, etc.? 

i guess this is not specific to orca, but is true also for serum, saber, etc., where a typescript API is present (to be "reverse engineered"), but where the program has to do the call, as it owns certain pools
Probably wouldn't be too bad to port into your rust code
You could always source-dive in the sdk and see how they build their instructions 🔬
yeah they have a typescript sdk which is good. Just wanted to know if I can do the same from within the smart-contract. Would be much cooler 🙂
Yep (not sure if its open source or not—do they have a JS sdk or something?)
Thanks for your answer. I guess this means that I would need the orca source code as a cargo dependency (in my case).?
Normally in rust you'd just depend on the other program's code as a cargo dependency and use that to construct your CPI calls (e.g. how anchor talks to the spl token program)
The IDL won't help within your rust code, only from JS/TS (well, I guess it technically could help from within rust, but don't think that's implemented 🤔)
yeah i think so, i will let yall know either way 🙂
😭
hey guys, im wondering, assuming we have the IDL for another program (that is not deployed by us). similar to typescript, is there a way to invoke other solana programs from within anchor / solana rust code? Concretley I want to send liquidity to the orca LPs from within a smart contract.
I completely broke my app by trying to implement Typescript so I went back to studying 💩
Looks promising, would be interested in knowing how it went
So setting like a meta structure to hold different kinds of objects, and switching between them to exchange the data type held
Great, it’s exactly what i was looking for 🙂


//////////////////////////////////////////////////////////////////////////////////////////

And this program doesn't expose any ways to mutate the account aside from someone accepting the offer or the original maker canceling it.
Right, only an account's owning program can make changes to it
```
#[derive(Accounts)]
#[instruction(escrowed_maker_tokens_bump: u8, offer_maker_amount: u64, offer_taker_amount: u64)]
pub struct Make<'info> {
    #[account(init, payer = offer_maker, space = 8 + 32 + 32 + 8 + 1)]
    pub offer: Account<'info, Offer>, 
```
In this example, nobody can make changes to `offer` except the program, right? Not even offer_maker can make changes to the `offer` right?
Thank you very much, I initially thought that any custom account inited by the program is automatically owned by the program and also has the program authority.
But you have to implement that yourself, it's not built-in to solana
Yeah, you'll have to have some access control stuff if you want to limit who can mutate an account
Thank you, I'll try it out!
```.rs
hashv("global:initialize").to_bytes()[..8]
```
So basically anyone can edit the account inited by the program unless its authority is set explicitly, right?
So that empty data vec there isn't quite right, it'll have to have something like:
Anchor expects the first 8 bytes of every instruction to be a "sighash"
Oh, you're not calling your anchor program quite right
Accounts in solana don't in general have an authority (they always have a program owner, but authority is something your program will have to decide on itself)
```
     Error: 100: 8 byte instruction identifier not provided
```
Oh, but how can I then pass a program itself? If I try to pass it as an accountInfo I get errors anyway.
```
#[program]
pub mod test {
    use super::*;
    pub fn initialize(ctx: Context<Initialize>) -> ProgramResult {
        let ix: Instruction = Instruction {
            program_id: ctx.accounts.rec.key(),
            accounts: ctx.accounts.rec.to_account_metas(None),
            data: vec![],
        };

        solana_program::program::invoke(&ix, &[ctx.accounts.rec.to_account_info()])?;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    pub rec: AccountInfo<'info>,
}
```
In case of custom data account, what's the authority would be?
When you initialize a TokenAccount you have to say who the authority should be, e.g. with the `token::authority` attribute
Sorry, I misread your post
No, the owner of that TokenAccount is the spl token program
And spl-token is the owner?
What about the authority of the initialized TokenAccount i.e, Account<'info, TokenAccount> by the program?
Program is the authority of the TokenAccount?
Check out anchor's `trait Owner` (try searching the anchor codebase)
Woww very cool
Any #[account] struct Whatever in your program says that it shoudl be owned by your program
Ohhh wow how does it do that?
So Mints say they should be owned by the spl token program
Account<'info, Whatever> verifies that the account is owned by *whichever program Whatever says should own it*
I tried explaining this above, not sure if you saw
We pass in Mint account in the same way (Account<'info, Mint>), but the program does not own that mint account
But what about this?
https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo/src/lib.rs#L184
No! It does check: that's what Account<'info, Offer> does
https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo/src/lib.rs#L202

I'm trying to say:

The escrow program does NOT check if `Offer` is owned by the program in the `Accept` instruction. So what if a hacker uses the `Accept ` instruction, and passes in their own self-created `Offer` account
okay, i got some confusion about the `init`
I think it's the case when the fake frontend attracts the users.
Still not sure what you mean by that either haha, your program can init accounts it doesn't own
only if the account is inited by the program
Not totally sure what you mean by that 🤔
I will run a test to verify the following:

`pub account: Account<'info, X>,`

"Any time we pass data through a context like this, then the program has ownership over `account` that has type `X`"
Even if that's the case, the instruction is `Accept` so there's no need to take the fake account for the caller.
Did your question get cleared up? Not totally sure
true
<@!897327536147681291>  yes, but what if the user passes in data that mimics the format of the `Offer` structure
Not necessarily, you can also `init` token accounts, mints, etc.
I think the offer is created by the program, i.e inited by the program, so the owner is the program.
Which owner is expected is determined by the struct you have in there, Offer or Mint etc.
In that case it's checking ownership by the spl token program
No, it also checks ownership!
For example, when we pass in `Account<'info, Mint>`, our program doesn't own the Mint account
That just deserializes and verifies the structure of the data passed in
is program ownership checked by `Account<'info, Offer>` though?
like if offer.owner == PDA
The offer account itself is owned by the program (that's checked by Account<'info, Offer>). The offer's maker is *not* owned by the program (they're just some random person)
If the offer's owner is owned by the program? Not quite sure what you mean
In this escrow program, we do NOT check to see if the offer's owner is owned by the program. Is this fine because the program cannot close an account it does not own?

https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo/src/lib.rs#L197
You'll need to pass your own programId lol, since you're going to try to call it (I think, guessing here)
Oh, yes, it clicked, thank you!
Sort of like how you have to pass the systemProgram when you want to eventually call it
Think you'll have to do that (so you actually need 1 account in that Initialize struct—your own program!)
```
    1   ¦ const tx = await program.rpc.initialize(0, {});
```
When you called the program the first time around, from the client, did you also pass your own program's programId as an account?
It says that 
```
     Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: An account required by the instruction is missing
```
Does Anchor need any accounts by default? Or have I forgot something?
Good day! Why can't I recursively call this simple program?
```
#[program]
pub mod test {
    use super::*;
    pub fn initialize(ctx: Context<Initialize>, i: u8) -> ProgramResult {
        let ix: Instruction = Instruction {
            program_id: id(),
            accounts: vec![],
            data: vec![i + 1],
        };

        solana_program::program::invoke(&ix, &[])?;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize {}
```
Its just only a single global state account for contract so, would have to update global struct. If I don't it will break my contract ?
One trick you can try: you can sneak in some logs into any anchor attribute that takes an expression as its right-hand side. It can be a little tricky to make sure the attribute "runs" early enough, but e.g. you can do goofy things like
```.rs
bump = {
  msg!("wtf: {:?}", the_account.to_account_info().owner);
  the_bump
},
...
```
yes I know, but I'm not seeing it. guess I'm going to have to strip the instruction down to where it works and add stuff until it breaks again.
Short of editign the anchor source to log more stuff (possible if you're comfy doing that), I think you just need to verify each `Account` has the expected owner :/
It could be any `Account<'info, Whatever>` (including token accounts etc., which need to be owned by the spl token program)
Anchor is complaining an account doesn't belong to the program, is there a way to find out which account it's talking about because just that error on its own is not very useful
So you can update your program, will just have to be careful presumably
Any change you make will have to support the old format too (those accounts won't automatically update to reflect the new format—you'd have to patch them up or something)
Hey,

I would like to know if we can update current contact deployed on mainnet. I want to alter the current struct which I used to store data and like to add few properties to current struct . Is it possible if I change the structure of my data structure , it will not break anything with current data stored in accounts which interacted with it earlier ?
https://www.notion.so/Debugging-Custom-Anchor-Errors-b8540dd418c44a4e939ab17c56a3fd3b
does this help?
sry just searched
is there any way to estimate how much a smart contract will cost to deploy
Regular Windows won’t work
Use WSL
Anybody?
Now that I understand what is happening, the error makes sense. It would still be nice if the error was more descriptive or recommended checking the type
<@134416332509675520> What does error 66 mean?
It works on nested structs
That error message is very confusing 😆
This makes sense and using BN() works
`minimumPrice` is almost certainly the correct version, and then you get the error because you haven't used a BN
This appears to be a bug in anchor's serialization :/ I think something is defaulting to zero (ugh) if you spell the field wrong 🤦‍♂️
They are u128 in Rust, but it seams so wierd, that it fails only on fields like "minimumPrice" but not "minimumprice"
(Obviously not a great error experience)
If they're u64s and up then yes
Do you maybe need to be using `anchor.BN` for those numbers?
The same errors also occurs, when passing multiple structs
Ohwell, passing each struct individually is still much better than passing all values individually. Thanks so much for you help!
Seems like nested structs don't work very well, bummer!
Hmm, I don't think so, but when I try doing this locally I get all kinds of incorrect/useless typescript errors :/ Hadn't noticed that this was so fragile.
I am using windows and trying to install with cmd
`cargo install --git https://github.com/project-serum/anchor --tag v0.18.0 anchor-cli --locked`
Hello everyone, I am trying to install anchor-cli but I am getting this error. 
Can somebody help?
I'm on Anchor 0.19.0
`let exampleStruct = {
      valueTwo: 1,
      terms: {
        minimumPrice: 0,
      }
    };`
Errors with src.toArrayLike is not a function,
but 
`let exampleStruct = {
      valueTwo: 1,
      terms: {
        minimumprice: 0,
      }
    };` 
works
Are there any reserved field names?
Think you'll have to post more code
I have tried this approach, but when trying to pass a struct with nested structs I get the following error
TypeError: src.toArrayLike is not a function
But I don't think there's an easy way to refer to the expected typescript type :/
You would pass it as a JS object, `{ oneField: ..., otherField: ... }`
Or how would I construct the value in the typescript test?
Ah, hmm, not sure actually
Can I import the generated type into TypeScript?
Yep, can just do
```.rs
#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub struct YourStruct {
  ...
}
```
Because I need to initialize a few values and would not like to pass them all individualy
Is it possible that a rust function, for example initialize, takes a struct as input?
yeah thought that was the case, thanks for confirming 🙇‍♂️
I think anchor's IDL generation stuff doesn't understand the type, you'll probably have to use an i64 instead (that's what the timestamp is under the hood)
hey, I am running into this issue when. using `UnixTimestamp` from solana_program;
```IdlError: Type not found: {"name":"lockTime","type":{"defined":"UnixTimestamp"}}
```
is this happening because this type is defined in an external crate? I have seen some issues similar to that before
but the program keypair allows you to access program info, your system wallet holds sol for paying fees
im not entirely sure why that gave you those errors, maybe has to do with the solana balance for the account provided by the program's keypair
can you please explain your intuition on how/why those changes fixed it? still confused about the differences beteween wallet keypair vs. program keypair and how to know when to use what
happy to help <a:trippyBoneZone:789725627544371221>
oh shit it worked!! <@!800692321619542017> you're the GOAT man, thanks so much
I think you want your keypair set to your system wallet, can update with `solana config set -k <path-to-wallet>`
<@!800692321619542017> here's the error trace and what my solana config get returns
also can you post the error you're getting?
copy the value for `Keypair Path` into `Anchor.toml`
try ```solana config get```
does that file exist? try using the full path too
Still getting the error unfortunately 😦
<@!800692321619542017> Could you quickly describe the differences between the two and what each is used for? The only thing I could find regarding keypairs was https://docs.solana.com/wallet-guide/file-system-wallet which didn't cover this.
something like `~/.config/solana/id.json`
it should be your wallet keypair, not the programs keypair
I'm getting the same error as <@!719422966756278302> and I can't figure out why. To confirm, the Anchor.toml wallet should just be my keypair file location correct?
Hi,
Can I use a struct as an argument to rust function?
that was all you bro! i just linked to alan's random code XD
100%, I appreciate your help
now you have the experience. that's worth a lot 👌
thanks, been trying to figure out how to do this forever <:KEKW:716296709793251359>
thanks for sharing
very cool stuff man, good work 😄
```#[derive(Accounts)]
pub struct Join<'info> {
    user: AccountInfo<'info>,
    #[account(mut)]
    airdrop: Account<'info, Airdrop>,
    #[account(mut)]
    airdrop_owned_lamports: AccountInfo<'info>,
    system_program: Program<'info, System>,
}
```
can you post the `Join` struct?
This is on the anchor side:
```pub fn join(
        ctx: Context<Join>
    ) -> Result<()> {
        let user_list = &ctx.accounts.airdrop.user_list;
        let max_users = ctx.accounts.airdrop.max_users;

        if user_list.len() == max_users as usize {
            return Err(ErrorCode::UserListFull.into())
        }

        let user = ctx.accounts.user.to_account_info();
        let from = &mut ctx.accounts.airdrop_owned_lamports.to_account_info();
        let airdrop = &mut ctx.accounts.airdrop.to_account_info();
        **from.try_borrow_mut_lamports()? -= 1_000_000_000;
        **airdrop.try_borrow_mut_lamports()? += 1_000_000_000;
        ctx.accounts.airdrop.user_list.push(user.key());
        Ok(())
    }
```
This is on the client side
```const tempAcct = anchor.web3.Keypair.generate();

    const programId = new anchor.web3.PublicKey(program.idl.metadata.address);

    const transaction = new anchor.web3.Transaction().add(
      anchor.web3.SystemProgram.createAccount({
        fromPubkey: users[0].publicKey,
        lamports: 1 * LAMPORTS_PER_SOL,
        newAccountPubkey: tempAcct.publicKey,
        programId: programId,
        space: 256,
      })
    );

    const signature = await anchor.web3.sendAndConfirmTransaction(
      provider.connection,
      transaction,
      [users[0], tempAcct],
    );

    await program.rpc.join(
      {
        accounts: {
          user: users[0].publicKey,
          airdrop: airdrop.publicKey,
          airdropOwnedLamports: tempAcct.publicKey,
          systemProgram: anchor.web3.SystemProgram.programId,
        },
        signers: [],
      }
    );
```
can you paste the code you wrote for this? would be very interested to see, might help me as well with my own app
So I ended up having to use SystemProgram to create an account owned by the program I wanted to transfer lamports to, transfer lamports in the same instruction, and then pass the account as argument to the rpc call, from there I could do try_borrow_mut_lamports()
yeah - i've seen people do like create-react-app into it
client side app?
what is the `app` directory for?
There is no reason other than preventing creating a token account for something that isn't a valid mint. From what i see
https://github.com/solana-labs/solana-program-library/blob/master/token/program/src/processor.rs#L85-L87 here
Perfect. That makes sense. Thank you Mr. Pikachoo
you can't, the token program expects the account, not the pubkey alone
For 2), why not just do this to create the account like this:
```
#[account(
        mut,
        associated_token::mint = **offer.taker_mint**,
        associated_token::authority = *offer.offer_maker*,
    )]
    pub offer_makers_taker_tokens: Box<Account<'info, TokenAccount>>,
```
That way, we don't need to pass in `taker_mint` or `offer_maker`
Awesome thank you 🙏🏼
something i saw today that's pretty simple. Lines 3-8
https://gist.github.com/cqfd/ffbdebbbcd3460ec822c3e63572cc282#file-dumb-rs-L3
1) Yes, it constrains the address, a shorthand of the raw constraint. Maybe a `has_one = taker_min` on the offer account constraint would be more canonical, i tend to prefer has_one, it makes it clear all in one constraint on the program account
2) Creating a token account `offer_makers_taker_tokens`, requires the mint account `taker_mint`. This is required by the token program initialize_account cpi
3) same as 2.
https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo/src/lib.rs#L227

1) What is `address = offer.taker_mint` doing? Is that a short-hand for a constraint?
2) Why are we asking the user to pass in `taker_mint` if we already can access it via `offer.taker_mint`? 
3) ^ Same with `offer_takers_maker_tokens`. For this one, is it because we're making changes to the account, so Sealevel needs to know in advance?
Does anyone have any references for transferring lamports from a user to a program account?
Hit my goal today, thanks <@!134416332509675520>  and <@!903369685570035822>
Looks that tooling hasn't been developed in Solana yet
Hmmm, in my last job we used Postgres and could have the DB reset before each test
ohhh damn that makes sense
oh interesting
oh lol my b bad question
At any rate I just write tests however lol, don't read too much into them
And those are basically just declaring variables so I can reference them later in the other tests (their init part is async so I don't think I can do it in the top-level describe, since as far as I remember describe doesn't support async—though maybe it does?)
`beforeEach` unfortunately doesn't work for keeping the tests totally separate, because the validator maintains state between all of them (not like in a backend test where you maybe run each test in an isolated tx that rolls back after running the test)
<@!134416332509675520> 

https://github.com/cqfd/quidproquo/blob/main/tests/quidproquo.ts#L27

What's the benefit of keeping some initialization code (L15-L25) before the `before` statement? Why not just have it all in the `before` statement

Also, why didn't you use `beforeEach`? This way, you can ensure that your tests are completely separate
Programs I think have to be rent exempt in solana (no other option)
Ah, you need a `declare_id!` (try searching the anchor repo for examples)
It doesn't say so in the docs: https://project-serum.github.io/anchor/cli/commands.html#deploy
Does `anchor deploy` automatically make our program rent exempt?
this for anchor 0.19.0
do i need anything from `solana_program`?
i have `use anchor_lang::prelude::*;` in this particular file
what imports do i need for this?
am now running into issues with finding IDs (e.g. `cannot find value ID in the crate root`)

```
7 | #[account]
  | ^^^^^^^^^^ not found in the crate root
  |
```
Your program lives at an account too (which account depends on how you deployed—it might not be at your programId but rather at a PDA derived from it)
You can always fetch an account with `program.provider.connection.getAccountInfo(theAddress)` and then see how big its `.data` is
How do I calculate the size of (A) my program and (B) of of an account? I want to do:
`getMinimumBalanceForRentExemption(program.size())` and `getMinimumBalanceForRentExemption(account)`

More importantly, how could I have figured this out myself?
I'm looking for co-founders also
I'd appreciate that!
ill dm you i can give you a couple ideas as well
that's the move then, hit MVP then integrate with others
so apps dont have to integrate it directly into their code
you will really like railgun then. their vision it basically provide a front-facing anonymity tool that you can connect to any app
guess that's going back into the backlog for now lol
My use case is to shield publicly facing content creators.
but it's coming
anonymity on solana is something that is still not really a thing yet
guess i didnt think about that lol. but i think their target is Q1 next year
it's in development rn still, not released, and they havent shown the code yet
Is lava open source?
rail uses ZK-SNARKs and lava uses ZK-STARKs, which are superior
Zero-Knowledge proofs and such
yes
were you the guy i told about lava cash and railgun? if not, check them out, lava is solana native and rail is cross platform but they are doing a solana app
I was hoping it would be a couple hash functions  or something. Iwas told to checkout railgun, it's definitely possible; but I think you're right. It probably has to go through a whole layer of anonymizing transactions.
But eh I have no idea
Like, fancier crypto than asymmetric keys/hashing
I have no idea how to think about anonymity but fwiw I suspect it's hard
right
Someone can always snoop the explorer and put 2 and 2 together, etc.
So don't think this will work for anonymity, at least not very well
Mm, at the end of the day if you want to have some notion of authority you'll always have to pass both accounts to the instruction—the account itself *and* its authority, so your program can check the authority signed
My ideal scenario is that those unique usernames can't be traced back to that wallet
My first use case is have one wallet that can pay to open multiple unique accounts with unique usernames.
Or would anonymity have to go through like an anonymizing transaction layer?
Right now the users wallet is attached as the authority. If I exclude that authority pubKey and people try to fetch that account data, could they not see the pubkey and not know which wallet controls the account?
What do you mean?
Is exluding the authority a way of not being able to see who controls the account?
So you have to decide if you want to enforce that kind of access pattern etc.
(But in general if your program owns an account, it can mutate its data whenever it wants—authority stuff is just a matter of politeness/your program not being dumb, you have to implement it yourself)
perfect
```
#[derive(Accounts)]
pub struct Update<'info> {
    #[account(mut, has_one = authority)]
    pub fora_persona: Account<'info, ForaPersona>,
    pub authority: Signer<'info>,
}
```
Yeah, if you wanted to only let a certain user etc. update the account, then yeah, you'd need to add an `authority: Pubkey` or whatever field to it, and subsequently make sure that account signed the tx whenever it tries to update the account
```
    pub fn create(ctx: Context<Create>, username: String, bump: u8) -> ProgramResult {
        let fora_persona = &mut ctx.accounts.fora_persona;
        let authority: &Signer = &ctx.accounts.authority;
        let clock: Clock = Clock::get().unwrap();

        fora_persona.authority = *authority.key;
        fora_persona.username = username;
        fora_persona.timestamp = clock.unix_timestamp;
        fora_persona.bump = bump;
        
        Ok(())
    }
```
yes
The ForaPersona account?
to make it's state editable
would you attach an authority to make it editable?
sincerely thankful man I appreciate this
To say this a slightly different way, program-derived addresses are kind of deliberately *not* keypair addresses (they aren't public keys at all—they're deliberately constructed so that they don't have corresponding private keys at all)
And the program needs to know somehow what seeds to expect (usually bump too but the bump is derivable from the seeds if you're being lazy)
You still need to `findProgramAddress` on the client and pass in that address, but yeah, if it's a PDA then no keypair stuff
so I don't need to generate a keypair at all on the client side? Just send in the username and bump and then the PDA derives and signs it itself?
In this case, when creating that account, anchor understands that because you have `seeds = [...]` it needs to have the program sign for the address (creating an account requires that its address signs)
hmm
So not possible to sign for them from the client
Ah, you mean on the client? PDAs are funny in that they can only be signed for by their deriving program, from within the program itself
<@!134416332509675520> why don't I need a signer here?
yea that works lol
holy fuck 1 sec
Is your declare_id! correct? (Does it match the id printed in the program logs?)
Error: 167: The given account is not owned by the executing program
What was your question about signing about though?
```
     const programAddress = await anchor.web3.PublicKey.findProgramAddress(
        [Buffer.from(username)],
        program.programId
      );
```
would you recommend just bumping to the newest version
```
    // Create the new account and initialize it with the program.
    const tx = await program.rpc.create("ryan", new anchor.BN(bump), {
      accounts: {
        authority: provider.wallet.publicKey,
        foraPersona: foraPersona,
        systemProgram: anchor.web3.SystemProgram.programId,
      },
      signers: [],
    });
```
Mm, that's such an old version that I'm not sure how to help
should i be using the latest version?
running into these errors when trying to build anchor 0.10.0: `the trait bound Pubkey: BorshSerialize is not satisfied`
```
#[derive(Accounts)]
#[instruction(username: String, bump: u8)]
pub struct Create<'info> {
    #[account(init, seeds = [username.as_ref()], bump = bump, payer = authority, space = ForaPersona::LEN)]
    pub fora_persona: Account<'info, ForaPersona>,
    #[account(mut)]
    pub authority: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```
Sign when?
How would I sign it?
So then if someone tries to use the same string they'll get an account collision
You could init an account that lives at a PDA with that string (or maybe a hash of it) as its seeds
Any ideas on requiring a string to be unique? Like for a @username alias?
https://discord.com/channels/889577356681945098/889702325231427584/918588830012043324
I don't mind digging, that's totally fine! I'll take whatever you've got
I have some example programs you can look at if you want, but might be more in the weeds than you're looking for—not sure
https://www.brianfriel.xyz/how-to-create-a-token-on-solana/
Anybody got any good resources to read up (or watch) regarding tokens from a developer perspective? I'm looking to dig into ERC20 (and maybe 721) equivalent concepts in Solana, and my cursory understanding is that tokens are a fairly different beast on SOL vs. the EVM.
Couldn't remember if there was some other gotcha
personally i can work with non-data/system-owned ones, that's fine for my needs, but im willing to fund both conditions, or just the first, whatever works
Ah ok, that was the distinction
If there's data on the account then it's definitely not owned by the system program (if owned by the system program then it's "easy", otherwise hard)
i thought it had to do with account ownership
It's actually an additional complication whether there's data on the account or not (at least I think it is)
You want PDAs that have data to be payers and that's quite a bit more difficult!
whatever you think is fair x how long you think it will take
yeah mainly i just want PDAs to be able to pay for things
https://github.com/project-serum/anchor/issues/1120
Although it doesn't matter what program ultimately owns the PDA. In fact it's better if the executing program itself owns the account because then you don't need to do CPI to transfer lamports, so its compute cost is lower
In this situation though my requirement are different from yours. My thing involves including additional instructions for assigning space larger than the typical 10kb limit of PDAs. But still paying from a PDA payer account
I only build stuff for money that I was already going to make for myself
How much we talking!
and as i said before, im willing to fund any issues i create
well if you ~~nerds~~ fine gentlemen dont mind ill make an issue to track unless one's already been created
Ha, yeah
Really hard to keep the details straight with PDAs sometimes
Actually take that back about two CPI calls, it's two CPI calls for program owned PDA
It's a little annoying that it would take 2 CPI calls to system program instead of one to create the account. But I could definitely see myself adding this PDA payer functionality in the near future. If only to my own fork
Yeah
so you are saying add the functionality for being able to make system-program-owned PDAs as payers is easy(ish) but not so easy for program-owned PDAs
dude there's so much i'd like to add but im a dum
Yeh, exactly
Milk duds should really start getting very familiar with the constraints rust code so they can add lots of cool new PDA functionality!
Right, anchor would just have to realize "oh this payer has seeds = [...] on it, it's a pda"
It shouldn't be too hard to pass in the seeds and bump though since they're available
You need to be able to add the signature
😔 😔 😔
It doesn't yet know how to sign for them
Right, not currently, because anchor doesn't support PDA payers
Unlikely
later on
i mean `payer`
or sorry
meaning i can use that PDA as a value for `payer`?
Worth trying it though to see what happens
I think it will still glitch out over the ownership of the account though
Ah you're right
You can just send it money lol (it'll be automatically owned by the system program, and its PDAness means your program can sign for it)
If the account isn't going to store any data, you actually don't even need to init it
It defaults to the current program otherwise
You would have to set the owner as the system program
I'm actually not sure that works—also, do you even need to init an empty account like that?
No
because if that's the case i could probably work with that and not have to use data-holding program owned PDAs
So let me get this straight, if i do an account like this
```
#[account(
        init,
        payer = signer,
        seeds=["myseed".as_ref()],
        bump
    )]
cool_pda: AccountInfo<'info>,
```
then that account is owned by the system program and can later be used as a payer?
thx
im trying to see my options for other accounts paying for the data
https://discord.com/channels/889577356681945098/889584618372734977/915189998108676117
as with everything with my app, nothing is simple XD but basically when the tx submitter makes the tx, some of the data he creates is not really for his benefit, it's for another person's benefit, so yeah
Dumb question, but could the tx submitter just pay for the init?
hmm okay.. i could just have seperate accounts then, one for data and the other for storing my extra lamports
Not impossible, I can try to find a thread, but it's weirdly complicated (partially due to a solana bug)
So, is honestly quite tricky to get it to be able to pay
No, if there's data in there then its owned by your program
gotcha. when i define a PDA with such and such seeds and use it to store a `struct` of data like `User` or just an account with no specific data, are those owned by the system program?
Because the system program's `create_account` doesn't support it
I would try to design into the system you have available. Not sure why I find it so triggering. Probably because I want to do the same things but know they aren't all that straightforward
Having the payer be an account owned by your program is actually surprisingly complicated lol
Not in general (PDAness is independent of program owership), e.g. you can init a token account that lives at one of your PDAs
not manually 😦
when anchor `init`s PDAs, those are owned by the program right? those are the same ones i wanna send lamports to and define them as payers later
yes please ❤️ and i can make an issue as well
Manually of course
I've chatted with Alan before about the main ways this can be done. PDA with no data and owned by system program is one, and it's somewhat simpler. PDA owned by program (also with no data?) Is different but still doable
Yes but the PDA has to have no data in it and be owned by the system program
Ok, let me see how hard it would be to add this
Haha 😆
aaaaaaaa
This is something that might be easier to add to anchor though
then serialization manually
😭
That's the CPI you'll have to do manually
Right, I'm saying you'll have to do the init yourself
yeah but if you init an account, you have to define a payer up front
You'd want to use the lower-level program.connection.getAccountInfo(escrowedMakerTokens)
the output of `getAccountInfo` doesn't have any lamports-related fields except `rentExemptReserve`, which is null
`connection.getMinimumBalanceForRentExemption(theSpace)`
Rent-exemption is kind of sneaky, it's just about having enough lamports for your space
What do you mean? I'm saying you'd have to do whatever CPI requires payment yourself (with invoke_signed etc.)
I want to check manually in my program to practice / become good at Solana

I am checking if an account is rent-exempt by doing this:

```
const console.log(await makerMint.getAccountInfo(escrowedMakerTokens))
```

But I am not sure what field to check... `rentExemptReserve` is null.
how would this be done manually? if anchor pays for things up front before i cant do anything.
Mm, I don't think this currently works—it could work but anchor isn't quite smart enough to do it yet. (So, it's possible in solana to pay for stuff with a PDA, but anchor hasn't learned how to yet—you'll have to do it manually)
You could do it that way, or do some anchor source-diving to see where the rent-exemption is calculated
Yep, it'll be rent-exempt
can a PDA be defined as a `payer`?
How do I verify this using the anchor client? Like `const accountInfo = account.getAccountInfo(...)...?`
When we initialize an account like this, is it automatically rent exempt?
```
#[account(init, payer = ..., ...)
```
Did the Serum creators make anchor? What's all this dex code: `anchor/spl/src/dex.rs`
will try to check this 😄
I'm actually not sure now that I think about it how staking contracts show a continuously updating reward count 🤔 Like if you stake sol with lido
ok, big thx!
ah, increase counter in off chain software?
You would then have your program keep track of how much time has passed since they last claimed, etc.
You could also have the user perform the poking when they go to claim their rewards/unstake their thing
Possibly—it would be tough for the bot to update everyone's accounts (in solana you have to pass in every account relevant to a tx from the client!)
ok, understand. In general algorithm can be like this? User "stake" his tokens, program create pda and send this tokens to this account. Every N seconds bot call a program and we update counter in each staked pda? When user "claim" we send tokens from mint address (program has access to this acc) we send tokens to this pda?
(Or, well, sometimes its relevant, just not for whether a program can update an account—that depends on ownership)
PDA-ness is generally not relevant—the question is whether or not your program *owns* a given account (not the same thing as having *derived* a given address)
yes, i think about this, but think blockchain has more native method 🙂
got it. thanks!
interesting. And program can update any pda account?
easy way would be to just manually update it with a dev account
idk i just started on solana like 2 weeks ago but maybe trigger an update from the staking account to a rate adjuster contract when a new user is created then have the rate adjuster contract call an update rate function in the staking account, like a circular cross program invocation
Yep (for any solana program really)
is the recommended way to view rust logs for anchor?
holy moly thanks!! it works
In general you might need an off-chain program (a bot) to poke your contract now and then
`msg!` (if the test passes you'll have to look in `.anchor/program-logs/` for it)
is there anyway to println! in the rust program while you are testing using anchor test? 

I've tried println! but when i run anchor test, i don't see the print statements
but who will update another contract? 🙂 and run it
I'm pretty new also but I would just store a staking rate in state and then update that from another contract based on conditions
hey guys, maybe some ideas for this?)

My argument would be that these are just utility functions, you can still see who owns what wallet and how much money they are withdrawing/depositing from the dApp. You just wouldn't know what account their source of income is.
Of all the things that regulators plan to go after, anonymization stuff is top of their list
Can I hire you? lol
It does, just implicitly: https://github.com/project-serum/anchor/blob/master/ts/src/provider.ts#L109
why? KYC?
Anonymizing account ownership is bad
Why does `program.provider.wallet` not need to sign transactions during tests?
Hello devs! I'm a novice at solana contracts and have some stupid questions 🙂 I want to create a simple staking contract but can't imagine how to increase a reward counter per each user and change APY? Because program can manipulate with pda only when user create some instructions and interacte with program?
I haven’t looked closely but I think you should show this graph to some VCs and raise $10m with it
<@!903369685570035822> what's the complexity on something like this? Can I do it with a couple simple hash functions?
check out railgun and lava cash
when he posts complex algorithms in <#889702325231427584>  XD
Or perhaps this
Any thoughts on anonymizing account ownership?
This has some examples of interacting with the spl token program (also some PDAs in there): https://github.com/cqfd/anchor-token-studies, and this is a pretty heavily commented escrow program (related to how staking would work): https://github.com/cqfd/quidproquo
The staking example would be a generalization of this
You could maybe check out this repo: https://github.com/cqfd/anchor-visitors, it has an example of some per-user state stored in an account that lives at a PDA
not yet, kind of new to solana/rust in general but figuring things as i go
No built-in libraries as far as I know—have you looked much at program-derived addresses yet?
awesome, are there any builtin librarys or references you can point me to for this?
That means the staking account will have an "obvious"/guessable address that your frontend can calculate with `PublicKey.findProgramAddress`
For keeping track of the account, assuming it's per user + mint (or if it's an nft, maybe its just per-mint, since only once can be live at any given moment, etc.), you could store the staking account at a program-derived address with e.g. seeds = [user.key().as_ref(), mint.key().as_ref()]
You'll probably need a new staking account per user/mint/whatever, managed by your program
For 1. Idk how to init the program account size and for 2. I'm not sure how to keep track of the user accounts when calling the rpc endpoint from the client-side
sorry noob question here but I'm trying to implement staking with metaplex tokens. If I were to code it in solidity I would keep a mapping of structs to store each users staking data. Should I 1. store each users data within the associated program account or 2. Make a new staking account to hold a particular users data?
thanks! will take a look 🙏
This is a simple example of a program-controlled mint (sounds relevant to what you said): https://github.com/cqfd/anchor-token-studies
any help or guidance is appreciated it.
Hello people!
I am trying to create or implement  a simple token.
so far so good I found on your repo these two examples....
https://github.com/project-serum/anchor/tree/master/tests/swap --> i believe it is a good starting point to study.
https://github.com/project-serum/anchor/tree/master/tests/spl/token-proxy --> no idea what it does but has the name token on it 😂


//////////////////////////////////////////////////////////////////////////////////////////

I am not familiar myself, but I'd advise simply putting your questions out there, for your sake 😅
Anyone here familiar with the project-serum multisig source code? I love the implementation, and I have a couple of questions!
Found it, it is creating the account on the client first as you said. Many thanks!
So that means it already has space in it by the time it gets sent to the initialize_config function
Yeah, I don't see (yet) where they're actually `init`ing the config
Allocating in the client?
And not actually using Default to avoid specifying space
So they must be allocating the account in a separate instruction I guess
Ah, yeah, it does have a vec in there 🤔
Thanks! How they got away without specifying the size? The candy machine config has variable lines and the only reference to anything close to the data size requirements is the constraint `config.to_account_info().data_len() >= CONFIG_ARRAY_START+4+(data.max_number_of_lines as usize)*CONFIG_LINE_SIZE + 4 + (data.max_number_of_lines.checked_div(8).ok_or(ErrorCode::NumericalOverflowError)? as usize)`. I tried to add my field here, but then the client fails. I am not adding the fields directly to the struct, I am adding them to the borsh vec area to avoid having to deserialise them all at once.
for things like String/Vec, does Default just allocate 0 space?
It seems that candymachine uses `#[derive(Default)]` to skip having to specify `space`. If you want to add more fields in there and they're variable-length (e.g. a String, or a Vec), Default won't give you the right amount of space and you'll have to specify space manually with `space = ...`.
~~What language is that? 🤔~~ And why don't you know how long the string is?
Alright... so i'm trying to make an instruction to an anchor program in the same transaction as an instruction to a non-anchor program. I create the struct in python, however my initialize takes a pda. so i need to pass it the bump and string, but I'm unsure how 'long' the string is. My understanding is it'll be like this:

```python
INITIALIZE = construct.Struct(
    "variant" / _Sighash(), "bump" / DecimalAdapter(1), "str_len" / DecimalAdapter(4), "str" / ?????Adapter(?)
)
```

any ideas?
Hi! I am trying to create a custom candy machine (forked from metaplex) where the Config struct stores more information. At the moment I cannot figure out how I can increase the space requirement for the account. I can see the macros `#[account(mut, constraint= config.to_account_info().owner == program_id && config.to_account_info().data_len() >= CONFIG_ARRAY_START + 4 ...]` which I believe is where the size of the account data is specified, but I don't seem to be able to increase its value. When I try to initialize the config account, I get an error `Error deploying config to Solana network. ProgramError: 143: A raw constraint was violated`. Any ideas?
so like you would put `zero` on top of this token account, if you wanted to create a token account that had an external signer / the account was already created but not initialized by token program
ah right. I always imagined that the purpose of `zero` was to make sure an account was empty before you initialized it with some data
I don't think so—zero checks if the first 8 bytes are zero, which I think wouldn't make sense for token accounts (they don't have discriminators at all). I guess it might not error if you've allocated the 165 bytes for the token account in a previous instruction though, but not sure what zero is adding
like zero + init tokens
works?
going to test this out now for a video but in advance, does anyone know if 
```
#[account(
  zero,
  token::mint = mint,
  token::authority = authority
)]
  this_token: Account<'info, TokenAccount>
```
program.account.accountName.fetch(publicKey) works for what I need
.decode only gives me the Buffer. How can I deserialize the data?
`.decode` in the anchor TS library should help
How can I deserialize data recieved from getAccountInfo RPC endpoint if the data was serialized by Anchor?
Loading up the confirmed transaction is an RPC call, and you have the transaction id from the RPC call that sent the transaction
You have to load up the confirmed transaction and inspect the program logs if you want to return data to the client
yes from what I know of and seen until now
other than `Ok(())`?
so, a program handler can never return some info to the client?
AFAIK we can't return something from contract
I dont really care to store this value in an account
the return is just showing a transaction id
is there any way to get the value returned back from an rpc call from my smart contract?
thanks mate!
`new anchor.BN(1639181611)` for u64
I'm struggling with understanding how to pass values to the handlers
```rs
#[program]
pub mod test_anchor {
    use super::*;
    pub fn initialize(
        ctx: Context<Create>,
        authority: Pubkey,
        start_time: u64,
        end_time: u64,
        start_price: u64,
        reserve_price: Option<u64>,
    ) -> ProgramResult {
```
doing something like this is obviously failing
```js
    // const tx = await program.rpc.initialize({});
    const tx = await program.rpc.initialize(
      program.provider.wallet.publicKey,
      1639181611,
      1641021206
      // etc...
    );
```
Am I supposed to pass in objects?
Yeah, can presumably do all that in one program
Just gotta jump to source currently
<@!134416332509675520> I suppose "start up" is the wrong language (I'm a full-stack dev), it would be a project that creates the auction account and also a token account, yea?
This may be a dumb question, but where do I look up documentation for anchor constructs like Transfer() function?
i.e. the token account that it is selling
and this can all be done in the same project space? Basically, it'd be nice to have a program that starts the auction up (I'm creating an auction) and also starts up the token account.
appreciate this direction you're givine me
oh interesting
You'd do a similar thing for this token account holding the 1 token
The example I posted above gives the program control over the mint by making the mint's authority a program-derived address (only the program can sign for its program-derived addresses—hence giving the program authority over the minting process)
Ok, this'll be a good exercise then
I watched a video that mentioned that, but I wouldn't say I fully understand them.
Have you read up on program-derived addresses yet?
And when someone calls claim, you take some sol and transfer the token to them (presumably the whole tx fails if the token has already been claimed)
But if you want a single claimable token, then you could have your program have authority over a single token account with 1 token in it
Either way is fine—the example I posted above could be tweaked pretty easily to make the `airdrop` call requires sol
...or whatever is simpler
for this example I think I'd just want one singular token.
Or can someone keep calling claim and passing in more sol?
By token do you mean mint here? Like, a single brand of token? How many individual tokens will there be—only only one?
<@!134416332509675520> can I run by what I *think* has to happen for my program? I'm basically building a simple proof-of-concept. 

Basically, I want my account to create a token upon initialization

then I am creating a `claim` endpoint, which anyone can call.

`claim` will check that it has received a certan amount of Sol and then will transfer ownership of the token to whoever gave the Sol. And then it will mark the token as "sold".

Seem reasonable?
but I appreciate the tips
I'm into that
But yeah, currently there aren't many docs at all—you're going to have to get used to source-diving 🤿 😁
oh awsome
For transferring ownership, you would use the `anchor_spl::token::set_authority` call, which should be relatively straightforward if you work through some other examples
I'll check that
I have a bit, but some of them are rather robust. I'm a relative beginner and I'm trying to build a super simple proof.
Here's an example of a program-controlled mint, fwiw: https://github.com/cqfd/anchor-token-studies
Do you mean anchor documentation? Kind of doubt there is any yet tbh. Have you looked through the anchor tests?
Could someone point me to the up-to-date documentation on how to create tokens and transfer token ownership?
I don't think there's an issue 🤔 but not 100% sure, so probably better to just do the seeds check haha
The thing I'm a little worried about is something like this: https://gist.github.com/jstarry/ab03017fa05b7352261115c9bd5cfc4e
ah yeah ur right, the offer isn't signing anything. We're just using the offer to calculate the PDA
I guess I just mean that the program itself is trying to sign for one of its PDAs, whose seeds happen to be based on the offer (the offer itself isn't really signing anything)
But yeah maybe we're saying the same thing
"sign for" is wrong, it should be "sign the transaction"
The program itself is what is signing here: it says, ok, I will try to sign for the escrowed_make_tokens' address
What do you mean by sign for here? I think we might be on the same page but the language you're using is slightly confusing to me 🤔
But (the thing I need to think about), the `invoke_signed` api is slightly dumb and doesn't require you to be specify exactly which thing you're signing for: you just chuck seeds+bumps into that api and it will match them against the accounts
so the passed in `offer` must be able to sign for TokenAccount `escrowed_maker_tokens`
what u said
yeah
it's because you used the `ctx.accounts.offer` bump and seeds to calculate the PDA
The thing I need to think through a bit more is that the way the program signs for the escrowed_maker_tokens is via those seeds, which are based on the `offer`
ohhh i see
oh thanks for the correction

the signer must be the authority of  the TokenAccount`escrowed_maker_tokens`. The authority of `escrowed_maker_tokens` is `escrowed_maker_tokens`, as seen by https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo/src/lib.rs#L180

I don't get why it fails if there's a different offer, then
Maybe I'm misunderstanding what you wrote though 🤔
Ah, no—the signer here is the authority over the escrowed_maker_tokens, which happens to be its own address
I think you're almost right:

The authority comes from `escrowed_maker_tokens`, yes. 
So the signer must have ownership over `escrowed_maker_tokens`. 
The signer must be `escrowed_maker_tokens.offer`, then. No other offer will work
Interesting. Will test it out! Thanks for the help!
Yep
So take the `basic_1` example in the tutorial, say I want to log the time when the account is initialized:

```
pub fn initialize(ctx: Context<Initialize>, data: u64) -> ProgramResult {
        let my_account = &mut ctx.accounts.my_account;
        my_account.data = data;
        Clock::get()?.unix_timestamp; -----> I just add the function call here?
        Ok(())
    }
```

Is this a correct use of the clock?
(Sometimes you still do, if you're invoking some other program via CPI and it expects you to still pass it as an account)
Currently you can actually just do `Clock::get()?.unix_timestamp` etc., no need to pass it as an account anymore
Quick question: How do I incorporate a `sysvar: clock` into a program? I would like to see a minimum working example if it's possible. Thanks in advance!
Does that mean the crucial bit is here (l. 76++)?
```rust
                    authority: ctx.accounts.escrowed_maker_tokens.to_account_info(),
                },
                &[&[
                    ctx.accounts.offer.key().as_ref(),
                    &[ctx.accounts.offer.escrowed_maker_tokens_bump],
                ]],
```
the authority comes from the `escrowed_maker_tokens` account provided in the instruction (could be any offer the caller chooses to provide), but the signature uses `escrowed_maker_tokens_bump` which is tied to the offer account? Hence both need to match or it fails
custom program error: 0x1
https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo/src/lib.rs#L206

We do not need to make sure that the `escrowed_maker_tokens` is derived from the PDA of `offer`, because the transfer function (L67) would fail if `escrowed_maker_tokens` was not owned by the signer. The `offer` needs to sign for `escrowed_maker_tokens`, but it can't do that if it's not the owner
<@!912046857000194158> I'm still curious about the specific reason why you believe it is not needed, if you'd like to share?
oh okay cool 🙂
Anchor now has a SystemAccount<'info> you can use for that if you want
so I could store user public keys for users in program, call the program from client side to get the list of users and use those keys to get account infos, then pass all the account infos into a distribution function?
but that error'd out
hmm, ok, ill just do that for now. At first i thought it was `Account<'info, SystemAccount>`
yeah I think so
how does one express a regular solana account owned by the system that someone uses to store lamports. just `AccountInfo<'info>` right ? (no, it's not a signer)
I figured this was the case <:KEKW:716296709793251359>
So if you want to send a list of people some tokens, you gotta pass every one of them in from the client as an account 😬
Ah, you in general can't deserialize an AccountInfo—the only way to get an AccountInfo is by passing it in from the client as an account
I'm working on an airdrop program to learn, and I'm trying to collect a list of users to send SPL tokens to, but SPL token transfer CPI calls require AccountInfos
yeah, like state is stored in a struct. AccountInfo defined in one of those structs gives ```the trait `BorshDeserialize` is not implemented for `anchor_lang::prelude::AccountInfo<'_>```
Yep, that's a good observation—I'm not 100% sure I need that change, will have to think about it some more
What part specifically would make it fail, if someone where to input another `escrowed_maker_tokens` (e.g. with higher value tokens in it)?
You mean store on file?
save?
is there any way to save account info in anchor rust?
<@!134416332509675520> 
https://github.com/cqfd/quidproquo/commit/14c44d0b6cbb9579ece6fc44dff2b44f8e1f8282

Hmm alan why'd u add this? Even without this change, "Accept" would fail because the `offer` can't sign for another `escrowed_maker_tokens`.
ohh i didnt realize it was a rust think. I kept typing in "anchor solana" lol
?
https://doc.rust-lang.org/std/boxed/struct.Box.html
One more question about ur escrow program <@!134416332509675520> , What is `Box<...>?`
https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo/src/lib.rs#L219

I  can't find anything online about it
I've written down a ton of notes / comments
I've learned so much from taking apart every line of ur escrow program
Gotcha, thanks so much alan


//////////////////////////////////////////////////////////////////////////////////////////

hello guys. i was confused in rust and solana. its really cool and i like that. i want to learn anchor by creating an program with this struct: for ex: we have a token named A and my program named B. a user holds x amount of A token in B program then the program returns x*2 token to user after 24H. anyone have a roadmap or example for me?
Hello, I was wondering, can Solana programs hold tokens (native SOL for example) like Ethereum Smart contracts? If yes, how so? (any links appreciated, can't find anything that relevant)
As a follow-up, if they do keep the private key, are they able to modify the data in the account?
Awesome, thanks!
or anchor deploy redeployes it again ?
How do people update a program already deployed on mainnet. Does this command will be of use to update an existing deployed program on mainnet :

```anchor upgrade <target/deploy/program.so> --program-id <program-id>```
You're changing the balance of an account in your instruction, so it needs to be marked as mutable <@!454291700945387520>
Hey 🙂 
Anyone ever closed an account using anchor ? Unsure how i can use this method from an account info https://docs.rs/anchor-lang/0.19.0/anchor_lang/prelude/struct.Account.html#method.close
Nope! If the account is owned by your program then that address won't need to sign again unless you make it.
do we need to keep an account's private key around if we never expect it to sign anything? i.e. I want users of my program to create a large account to hold items in a queue and set the owner of that account to my program. that account will then be given in my program's instructions. do the users of my program need to keep the public key of that account around for any reason?
Yeah, I just came across https://github.com/project-serum/anchor/issues/945, I changed the `test` script to `yarn ts-mocha ...` and it worked! 😄

Thank you <@!134416332509675520>
You need to have `ts-mocha` isntalled. Depending on which version of anchor you're using, you'll need to install it globally, or maybe just running `yarn` inside your project will install it
Also, my test script for typescript seems to be error-ing out for me with this, 
`Failed to run test: ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts: No such file or directory (os error 2)`
It seems to be working now, but I'm not sure what I was doing differently initially then ?
Mm, get rid of the & in your instruction argument: `tags: Vec<String>` instead
```
 pub fn add_question(ctx: Context<AddQuestion>, title: String, content: String, tags: &Vec<String>) -> ProgramResult {
        let question: &mut Account<Question> = & mut ctx.accounts.question;
        let author: &Signer = &ctx.accounts.author;
        let clock: Clock = Clock::get().unwrap();

        // VALIDATION
        if title.chars().count() > 100 {
            return Err(ErrorCode::TitleTooLong.into());
        }

        if content.chars().count() > 256 {
            return Err(ErrorCode::ContentTooLong.into());
        }

        if tags.len() > 5 {
            return Err(ErrorCode::TooManyTags.into());
        }
        else {
            for tag in tags {
                if tag.len() > 20 {
                    return Err(ErrorCode::TagTooLong.into());
                }
            }
        }

        question.author = *author.key;
        question.timestamp = clock.unix_timestamp;
        question.title = title;
        question.content = content;
        question.tags = *tags;

        Ok(())
    }
```
This is my whole function
I tried passing `&Vec<String>` and then doing, `question.tags = *tags` but then I got this error,

`'&' without an explicit lifetime name cannot be used here`
Still the same error :/
Try `tags.clone()` maybe?
In an Anchor instruction function, such as below
`pub fn add_question(ctx: Context<AddQuestion>, title: String, content: String, tags: Vec<String>) -> ProgramResult`

I'm trying to do,
```
question.author = *author.key;
question.timestamp = clock.unix_timestamp;
question.title = title;
question.content = content;
question.tags = tags;
```

And it gives me the error, 
`use of moved values 'tags'`

Any help please?
I found that spl_token::approve is not widely used as in the solidity.
Rather than using approve, many programs prefer tranferring to PDA, i.e. when implementing escrow.
Is this because of design choice or just convention?
Could make a PR if you want!
Might just not exist yet (doing the CPI call yourself though shouldn't be too tricky though)
I can't find the anchor-equivalent of spl_token::revoke. 
Is there any reason not supporting the revoke instruction if there is really no instruction of anchor_spl::revoke?
all this time i was debugging my rust programe 😬.

Thank you again.
<@!134416332509675520> this works. Thanks a lot. Now I feel bad wasting 2hrs trying to figure it out of my own instead of coming here earlier.
😉
ohh wait
just `anchor.BN(0)`
await program.rpc.upvoteGif(anchor.BN(0), {
    accounts: {
      baseAccount: baseAccount.publicKey,
      user: provider.wallet.publicKey,
    },
  })
Are you doing `new anchor.BN(0)` or just `anchor.BN(0)`?

but now i'm getting this error
Hey, thanks for the help. I've been trying to debug it for 2-3 hrs. Thanks a lot.
u64s and up in rust have to be passed as anchor.BN (big numbers)
The error message isn't great (honestly, we should fix this), but you'll need to do `new anchor.BN(0)` there instead of just passing the `index` arg as `0`.
but I'm getting error: `TypeError: src.toArrayLike is not a function`
I'm using it like this in anchor

```await program.rpc.addGif('https://media.giphy.com/media/kvSp97J1kBVqo/giphy.gif', {
    accounts: {
      baseAccount: baseAccount.publicKey,
      user: provider.wallet.publicKey,
    },
  })

  account = await program.account.baseAccount.fetch(baseAccount.publicKey);
  console.log('👀 GIF Count', account.totalGifs.toString())

   // Access gif_list on the account!
  console.log('👀 GIF List', account.gifList)

  await program.rpc.upvoteGif(0, {
    accounts: {
      baseAccount: baseAccount.publicKey,
      user: provider.wallet.publicKey,
    },
  })

  await program.rpc.upvoteGif(0, {
    accounts: {
      baseAccount: baseAccount.publicKey,
      user: provider.wallet.publicKey,
    },
  })
  await program.rpc.upvoteGif(0, {
    accounts: {
      baseAccount: baseAccount.publicKey,
      user: provider.wallet.publicKey,
    },
  })```
Hey, I'm new to rust.

I've made a vector. I just need too change the value of an element in the vector. Each element is basically a struct. How to change the value of field of a struct in a vector in rust?

```
pub fn upvote_gif(ctx: Context<AddGif>, index: u64) -> ProgramResult {
        let base_account = &mut ctx.accounts.base_account;
        base_account.gif_list[index as usize].upvote += 1;
        Ok(())
    }
```
ran into an issue with `anchor test`

What I did:
1. `anchor init mysolanaapp` 🆗 
2. cd mysolanaapp 🆗 
3. anchor build 🆗 
4. solana-test-validator 🆗 
5. anchor deploy 🆗 
6. anchor test ⛔ 

`anchor test` throws exceptions (see more details at the bottom)

```
$ /Users/yiksanchan/source/yiksanchan/mysolanaapp/node_modules/.bin/mocha -t 1000000 tests/

/Users/yiksanchan/source/yiksanchan/mysolanaapp/node_modules/ws/lib/websocket-server.js:136
  /**

SyntaxError: Invalid or unexpected token
```

Any help?
You can definitely run anchor in the browser, but you'll have to use some webpack-y bundler thing, yeah.
The bulk of the deployment cost is space for your program's code, yeah. The exchange rate for rent exemption is 7 sol / mb, and the upgradeable bpf loader deployment process (the default) reserves 2x your program's code size so you can upgrade it in the future.
Post it in <#889606719829835816> too 🙂 (Also, make sure to delete the large preview boxes lol)
It’s outputs when you run the test
oh cool, how do I access the transaction logs?
is it required to implement tokens and an escrow process to transfer sol between two accounts?
As there's no current browser build for anchor (please do point me in the right direction if there is one), I'm trying to decode the data manually. Does anyone have any tips or example code of them doing it themselves? 

Currently, I'm trying to piece it together from here: https://github.com/project-serum/anchor/blob/fcb07eb8c3c9355f3cabc00afa4faa6247ccc960/ts/src/coder/state.ts
Then it’s consoles that in transaction logs
You could use {!msg(variable); variable}
while building out the rust programs
`anchor test` doesn't run that info.
is it possible to get `println()` information?
Why is the `UnixTimestamp` attribute on the Solana clock an `i64` and not a `u64`? https://docs.rs/solana-program/1.6.2/solana_program/clock/type.UnixTimestamp.html
looking into tokens now
I understand it costs about 2.6 SOL to permanently deploy a program on main net. I’ve also heard that’s about equal to the price to deploy something for 2 years (if it was “pro rated” compared to shorter period cost). 2 years is ~700 days.
Does that mean that if I only wanted to deploy something to main net for 1 week, at current values, that would cost me about $5?
perhaps this is the way
appreciate the help
`use anchor_spl::token::{self, CloseAccount, Mint, SetAuthority, TokenAccount, Transfer};`
check out this.
https://hackmd.io/@ironaddicteddog/anchor_example_escrow#:~:text=token%3A%3Atransfer(%0A%20%20%20%20%20%20%20%20%20%20%20%20ctx.accounts.into_transfer_to_initializer_context()%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20ctx.accounts.escrow_account.taker_amount%2C%0A%20%20%20%20%20%20%20%20)%3F%3B
got the go somewhere but ;
yea!
So, the `get_current_price` fn is giving me trouble, so I just changed it to a flat value of 1000.
but now it's giving me this error:
```
     Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: instruction spent from the balance of an account it does not own
```
I feel it's probably related to how I've set up the signers/owners of my accounts
🎉
now that you point it out
makes sense
nice, thanks
```rs
#[derive(Accounts)]
pub struct Claim<'info> {
    #[account(mut)]
    pub auction: Account<'info, Auction>,

    #[account(mut)]
    pub authority: AccountInfo<'info>,

    #[account(mut)]
    pub purchaser: Signer<'info>,
}
```
`#[account(mut)]`
basically whatever you're going to mutate needs
check the addProposal one from mine for example
https://github.com/Necmttn/anchor-voting/blob/master/anchor-voting/programs/anchor-voting/src/lib.rs#L97-L98
but you derive authority account as not mutable
you're mutating the authorities balance


founded
https://docs.solana.com/implemented-proposals/readonly-accounts
I'm reading this
yes
is the first test case passes ?
the error I'm getting is
```
Transaction simulation failed: Error processing Instruction 0: instruction changed the balance of a read-only account 
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS invoke [1]
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS consumed 3774 of 200000 compute units
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS success
    failed to verify account BGRVd3Wphe5apC6hvLZW5jZeyfiRR2VMJbiqYb4GaPot: instruction changed the balance of a read-only account
Translating error SendTransactionError: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: instruction changed the balance of a read-only account
    at Connection.sendEncodedTransaction (/Users/ajtj/rust_projects/test_anchor/node_modules/@solana/web3.js/src/connection.ts:3689:13)
    at processTicksAndRejections (internal/process/task_queues.js:95:5)
    at Connection.sendRawTransaction (/Users/ajtj/rust_projects/test_anchor/node_modules/@solana/web3.js/src/connection.ts:3649:20)
    at sendAndConfirmRawTransaction (/Users/ajtj/rust_projects/test_anchor/node_modules/@solana/web3.js/src/util/send-and-confirm-raw-transaction.ts:27:21)
    at Provider.send (/Users/ajtj/rust_projects/test_anchor/node_modules/@project-serum/anchor/src/provider.ts:114:18)
    at Object.rpc [as claim] (/Users/ajtj/rust_projects/test_anchor/node_modules/@project-serum/anchor/src/program/namespace/rpc.ts:24:23) {
  logs: [
    'Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS invoke [1]',
    'Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS consumed 3774 of 200000 compute units',
    'Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS success',
    'failed to verify account BGRVd3Wphe5apC6hvLZW5jZeyfiRR2VMJbiqYb4GaPot: instruction changed the balance of a read-only account'
  ]
}
```
hm
maybe anchor's not working
but this method comes from `"@solana/wallet-adapter-react";`
checkout how i use the balance in front end user
https://github.com/Necmttn/anchor-voting/blob/master/components/requestAirdrop.tsx
yea, I wonder where the account was designated as `read-only`
it's a odd error
Question: I need to do validation on an account that conditionally _doesn't exist_. Is there a way to run this validation conditionally, or do I need to split this functionality out into two RPC calls (one where the account needs to be specified since it exists, and one where it doesn't need to be specified since it doesn't exist)?
<@!234375765104394240> this would be where I started making these transactions
Can you show me the code a bit ?
Hmm, must be because I'm changing the providers balance maybe, I dunno
<@!234375765104394240> you ever deal with this?
```
Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: instruction changed the balance of a read-only account`?
```
nice
` await provider.connection.getBalance(newUser.publicKey);`
I've been strugglign trying to figure this out for a while, thanks! Do you know how to check the balance of the newUser?
Great example. I'm curious if there's anything I need to pay extra attention to when using anchor with Next.js
https://anchor-voting.dapp.necmttn.com/ you can play with it here.
normally the provider.wallet is loadded with 1000 sol when you testing in `localnet` but new keypair is comes empty so need to fuel the tank first 🙂
yeap
this is excellent
is this how you give a keypair account money to spend?
```ts
const newUser = anchor.web3.Keypair.generate();
  before(async () => {
    const signature = await program.provider.connection.requestAirdrop(
      newUser.publicKey,
      1 * LAMPORTS_PER_SOL
    );
    await program.provider.connection.confirmTransaction(signature);
  });
```
checkout this; 
https://github.com/Necmttn/anchor-voting

https://github.com/Necmttn/anchor-voting/blob/master/anchor-voting/tests/anchor-voting.ts
https://github.com/Necmttn/anchor-voting/blob/master/anchor-voting/programs/anchor-voting/src/lib.rs
<@!234375765104394240> do you know how to create a PDA account?
thank you
`    await provider.connection.getBalance(provider.wallet.publicKey);`
`provider.connection`  has a method for `getBalance`
how do I check the balance of the `provider.wallet`?
alpine's & livewires  <@!423148715948244994> ?  welcome on board 🖖
thats about how much it cost me, but i do think it depends on the program size. not sure. I also think that you can get it back if you destroy the program
I was trying to get a ballpark of how much SOL it takes to deploy a program. From my limited research it seems I'll need 2.6 SOL to deploy a program on mainnet (I could very well be wrong though)
guess i just needed more money. Damn is it expensive to deploy programs lol
hm deployment to devnet seemed to go fine, but when deploying to mainnet, i got an error: 
```
Error: Deploying program failed: Error processing Instruction 1: custom program error: 0x1
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }.
```
ty sir!
that should do it!
Ok, I just got past it by changing from 0.18 to 0.17 in programs/x/src/Cargo.toml

Also run "cargo clean" and remove the Cargo.locks files from your project's root
i'm stuck on this as well, any help would be appreciated 🙂
Hey folks, anyone hit this error?

I'm brand new to Rust/Anchor and just followed all the happy-path setup instructions to get an anchor project going and can't get past this.

I've gone through the whole process on a friends computer, same thing.

I think I'm officially out of ideas lol - anybody see something I don't here?

(seems to be related to this PR maybe? https://github.com/project-serum/anchor/pull/1030)
Cool!
it worked 🙏 🙏 🙏
And yes lol, it'll work 😛
You can import the ForaPersona type from your other program (see basic-3 for how to do this)
if that just works that would be amazin
Ok, I'm saying rather than passing `author_alias: Pubkey` as an instruction argument, pass it as an actual account:
```.rs
    #[account(constraint = author_alias.authority == author.key())]
    pub author_alias: Account<'info, ForaPersona>,
```
any idea what `custom program error: 0x1` means?
yes
Is the `author: Signer` in that call the same thing that has authority over the ForaPersona account?
the authority would still be theirs, but they could attach anyones username to it if they wanted
yes
Inside `send_short_text`?
Hence the need for hacky BigNumber stuff
Someone could post under anyones alias.
Javascript numbers are doubles and can only support integers up to 2^53, so not quite big enough for u64s or bigger in rust
got it
The `program.rpc` part does, definitely
It's a BigNumber
And no, anchor.BN has nothing to do with sending the data to the server 🤔
It's just an aesthetically pleasing number, that's all
Can you try one more time to explain what's not working above? I feel like I'm so close to understanding and it's killing me haha
Hey guys can you guys help me understand what the relevance of anchor.BN(1234)? I just wanted to know if this "1234" has any form of meaning to it, or if its just arbitrary. I am aware that anchor.BN is sending the data to the server using rpc nodes, is that correct?
thank you so much though
no i think i just have to hack on it and find my way out of the dark here
Lol, ok, I think I'm just confused about what we're both confused about—is your problem fixed? 😆
lol idk either seemed relevant at the time
Ok—not sure what that implies though haha
This Persona PDA is being generated from a username string so it guaranteed the username is unique.
You're doing that in the creation call
I think I'm still confused about what you're trying to do, why can't you just pass both accounts, the fora_persona one as well as its `.authority` account?
oooh
Right, PDAs don't have private keys
But that account could sign if have the fora_persona sign for it as one of its PDAs, and cross-program invoke the other program
it is a PDA though, there is no private key?
You'd have to pass it along with its actual authority
fuck
Ok, then you're right, that won't be enough (it can't sign from the client)
yes it is pointing to the ForaPersona account
And then the authority would sign
If it's pointing at the ForaPersona account, then you'd need to pass *both* the ForaPersona account as well as its authority
Ah, I'm confused—what is author_alias pointing at?
Even if it is a PDA and has no privateKey?
In the top function when you are creating shortText

```
    pub fn send_short_text(ctx: Context<SendShortText>, topic: String, content: String, author_alias: Pubkey) -> ProgramResult {
        let short_text: &mut Account<ShortText> = &mut ctx.accounts.short_text;
        let author: &Signer = &ctx.accounts.author;
        let clock: Clock = Clock::get().unwrap();

        if topic.chars().count() > MAX_TOPIC_CHARACTERS {
            return Err(ErrorCode::TopicTooLong.into())
        }

        if content.chars().count() > MAX_CONTENT_CHARACTERS {
            return Err(ErrorCode::ContentTooLong.into())
        }

        short_text.author = *author.key;
          //////// HOW TO KNOW author_alias.authority === author.authority
        short_text.author_alias = author_alias;

```
No that seems fine
So passing it as an account is strictly more powerful.
You can still get access to its pubkey with `ctx.accounts.author_alias.key()` etc.
^ does that spark anything or seem off?
Ah, ok—the trick is to not pass that as an *argument*, but as an account, and make it be a Signer.
The `author_alias: Pubkey` argument?
Sorry, trying to read your code—in which part do you want to verify this?
Cuz right now you can attach any account as an alias
But how to verify that the signer is the authority on the PDA?
And I am attaching that PDA pubkey as an alias to the shortText Account
Alright, this is the full scope and it's tested and working. So I am creating a PDA from a username seed.
```

#[program]
pub mod fora_persona {
    use super::*;

    pub fn create(ctx: Context<Create>, username: String, bump: u8) -> ProgramResult {
        let fora_persona = &mut ctx.accounts.fora_persona;
        let authority: &Signer = &ctx.accounts.authority;
        let clock: Clock = Clock::get().unwrap();

        fora_persona.authority = *authority.key;
        fora_persona.username = username;
        fora_persona.timestamp = clock.unix_timestamp;
        fora_persona.bump = bump;
        
        Ok(())
    }

    pub fn update(ctx: Context<Update>) -> ProgramResult {
        let fora_persona = &mut ctx.accounts.fora_persona;
        Ok(())
    }
}

#[derive(Accounts)]
#[instruction(username: String, bump: u8)]
pub struct Create<'info> {
    #[account(init, seeds = [username.as_ref()], bump = bump, payer = authority, space = ForaPersona::LEN)]
    pub fora_persona: Account<'info, ForaPersona>,
    #[account(mut)]
    pub authority: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```
```

    it('Can attach an account alias', async () => {
      // Generate a Persona PDA from username
      await createPersona("some-wallet-alias")

      // PDA always has same address
      const [personaAddress] = await derivePersona("some-wallet-alias")

      // Call the "SendShortText" instruction on behalf of this other user.
      const shortText = anchor.web3.Keypair.generate();
      await program.rpc.sendShortText('solana', 'Yay Low Fees!', personaAddress, {
          accounts: {
              shortText: shortText.publicKey,
              author: program.provider.wallet.publicKey,
              systemProgram: anchor.web3.SystemProgram.programId,
          },
          signers: [shortText],
      });

      // Fetch the account details of the created shortText.
      const shortTextAccount = await program.account.shortText.fetch(shortText.publicKey);

      // Ensure it has the right data.
      assert.equal(shortTextAccount.author.toBase58(),  program.provider.wallet.publicKey.toBase58());
      assert.equal(shortTextAccount.authorAlias.toBase58(),  personaAddress.toBase58());
      assert.equal(shortTextAccount.topic, 'solana');
      assert.equal(shortTextAccount.content, 'Yay Low Fees!');
      assert.ok(shortTextAccount.timestamp);
  });
```
```
#[program]
pub mod fora_short_text {
    use super::*;
    pub fn send_short_text(ctx: Context<SendShortText>, topic: String, content: String, author_alias: Pubkey) -> ProgramResult {
        let short_text: &mut Account<ShortText> = &mut ctx.accounts.short_text;
        let author: &Signer = &ctx.accounts.author;
        let clock: Clock = Clock::get().unwrap();

        if topic.chars().count() > MAX_TOPIC_CHARACTERS {
            return Err(ErrorCode::TopicTooLong.into())
        }

        if content.chars().count() > MAX_CONTENT_CHARACTERS {
            return Err(ErrorCode::ContentTooLong.into())
        }

        short_text.author = *author.key;
        short_text.author_alias = author_alias;
        short_text.timestamp = clock.unix_timestamp;
        short_text.topic = topic;
        short_text.content = content;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct SendShortText<'info> {
    #[account(init, payer = author, space = ShortText::LEN)]
    pub short_text: Account<'info, ShortText>,
    #[account(mut)]
    pub author: Signer<'info>,
    #[account(address = system_program::ID)]
    pub system_program: AccountInfo<'info>,
}

#[account]
pub struct ShortText {
    pub author: Pubkey,
    pub author_alias: Pubkey,
    pub timestamp: i64,
    pub topic: String,
    pub content: String,
}
```
`/Users/new/.local/share/solana/install/active_release/bin/cargo-build-bpf`
What do you get if you say `which cargo-build-bpf`?
there is that file there yes
let me check, thanks for your help
What my cargo setup does is realize that in my from-source solana install (not the installer thing you did above), there's a solana/bin directory with an executable in there, cargo-build-bpf
Do you have a `cargo-build-bpf` file inside /Users/new/.local/share/solana/install/releases/1.8.6/solana-release/bin/ ?
Oh, got it
that's what is in the output above. but I did a search and see that it should just be a symlink to /usr/bin/cargo...
How did you figure out that anchor test uses that cargo?
Basically some account you're trying to use doesn't have any sol in it
ok, I notice that `/Users/new/.rustup/toolchains/bpf/bin/cargo` is where `anchor test` invokes cargo in the output, but `which cargo` points to `Users/new/.cargo/bin/cargo`, for instance I can run `cargo build` in that directory just fine
What does solana config get say though?
https://api.devnet.solana.com
Which network are you running the script against?
like 30 sol
`solana config get`
yeah
Does your local solana keypair have any money in it?
That's an actual real solana error
Although when I am successfully able to run the deploy
I keep getting this error
Attempt to debit an account but found no record of a prior credit.
Try passing the extra arg `--dns-result-order=ipv4first` to that `node` command that was failing above
Ah, ok, what version of node are you using?
Hmm I have no idea how you could have cargo stuff built for the wrong osx version
no :S is that going to be my cargo install I need to redo?
Ah, yeah, how did you manage to do that haha—did you like downgrade os versions?
my local validator is working. I tried doing anchor test, and now I get this error, Error: failed to send transaction: Transaction simulation failed: Attempt to debit an account but found no record of a prior credit.
I guess there's a clue in that error... I'm on OSx 10 and it does say built for 11: `Referenced from: /Users/new/.rustup/toolchains/bpf/bin/cargo (which was built for Mac OS X 11.0)`
rustc 1.57.0 (f1edd0429 2021-11-29)
Never seen that error before, so I wonder if your rust setup is weird
Mm, what version of rust are you using? `rustc --version`
Hello! I'm having some trouble using the anchor cli. I am trying to run anchor test in a directory created with `anchor init`
```
$ anchor test
BPF SDK: /Users/new/.local/share/solana/install/releases/1.8.6/solana-release/bin/sdk/bpf
cargo-build-bpf child: rustup toolchain list -v
cargo-build-bpf child: cargo +bpf build --target bpfel-unknown-unknown --release
dyld: lazy symbol binding failed: Symbol not found: ____chkstk_darwin
  Referenced from: /Users/new/.rustup/toolchains/bpf/bin/cargo (which was built for Mac OS X 11.0)
  Expected in: /usr/lib/libSystem.B.dylib

dyld: Symbol not found: ____chkstk_darwin
  Referenced from: /Users/new/.rustup/toolchains/bpf/bin/cargo (which was built for Mac OS X 11.0)
  Expected in: /usr/lib/libSystem.B.dylib

$ anchor --version
anchor-cli 0.19.0
```
This is potentially a goofy way to do things but you can also do this:
```.rs
constraint = {
  // do whatever you want here
  msg!("Hmm");
  the_constraint
}
```
Yep `constraint = the_constraint @ YourCustomError`
Hi guys, has anyway to put a custom message in a constraint violation?
Is your local validator running? `lsof -i :8899`
Could I get some insight on this issue please?
Hey guys, I am new to anchor and am trying out the tutorials right now. However, I got an error after doing ANCHOR_WALLET=<YOUR-KEYPAIR-PATH> node client.js. 

(node:29671) UnhandledPromiseRejectionWarning: Error: failed to get recent blockhash: FetchError: request to http://localhost:8899/ failed, reason: connect ECONNREFUSED 127.0.0.1:8899
one sec let me post some code
one of those accounts is a PDA without a signature
Yep, you could do that
take that example and add one more account and verify they're all owned by the same wallet
Right—the basic-2 example does almost exactly that!
Basically I need to validate that two accounts have the same authority before allowing a post.
yea one second
Since all of this is covered in the tutorial
I've worked through them all.
I would suggest carefully working through some anchor examples
But if you pass it as an account, then yes, solana will magically give you all of the account's data 😛
It's true that if you pass it as an instruction argument, that won't work—it'll just be a pubkey (not enough)
Can you post some code?
How are you passing it?
If I just pass in a Pubkey does Anchor do some magic under the hood to show me that entire accounts data?
😈
Yep, that's true
The wallet is different than the UserProfile. I am passing in both pubkeys and it works. But there doesn't seem to be a way from preventing someone from passing in whatever UserProfile pubkey they want
Like, have you tried and it didn't work?
But why can't you use the user profile in there?
because I'm inside of the Post initialization function
Why don't you think you can query the user profile?
Have you worked through anchor's basic-2 example?
UserProfile has that field. I don't understand how to access it when creating the Post. since I can't query the UserProfile
(The wallet in this case)
And then you'd verify that the UserProfile's authority really did sign
No, you would need to somehow write down on-chain the ownership link (UserProfile would include a field called, like, owner: Pubkey, or authority: Pubkey)
So if I'm the program and I need you to prove to me that you're some public key, I need to require you to sign the tx for that public key
So sign the UserProfile Pubkey with the wallet and then pass it in?
The one thing a devious client can't fake is a signature
Tell me alan lol How could I possibly verify that chain of ownership?
There's one thing devious clients *can't* do though
So right now I have to ability to post under an app account; but anyone could pass in any pubkey and post under that persons profile
Yep, devious clients can pass whatever accounts they want
I'm sending my wallet and the UserProfile pubkey to Post.create. But couldn't anybody claim to be that UserProfile and post under it without checking that the UserProfile pubkey is also owned by the wallet?
So you'd just have to pass in whatever accounts are relevant
Reading an account means passing it into the instruction from the client (not possible in solana to dynamically look up accounts from within your program)
What do you mean by an initiation function? Just like an instruction handler?
or anywhere in Anchor
Do you have an example of reading an account in an initiation function?
Im trying my best 😢  lol
Tbh I don't really follow your diagrams haha, but in general in solana you can read any account you want
To check that the UserProfile is authorized by the signer?
So I could read the UserProfile account in the Post.create function?

And you actually can't really query another program in solana (cross-program invocations don't support return values). You can only read from accounts.
hmm, im not understanding why you need to query another program?
I can query another program inside a initialization function?
check if the signer public key and the owner field both match
you could put a data field in the `UserProfiles` account called `owner:Pubkey` or somesuch. Then you can simply query for it and check it
How could I verify that another PublicKey is owned by the wallet that is signing the post? I have this functionality working, but a poster can put any UserProfiles public key in it.
In Web2 I would just query the UserProfile and check that they're equal. But on solana I can not query cross program I can only invoke. Maybe a set_profile function and a round trip invocation?


//////////////////////////////////////////////////////////////////////////////////////////

I'm struggling to find how to check a wallet's spl-token balance. Can anyone point me to an example?
`BROWSER= anchor test` fix the issue
Ok this is because I've a `BROWSER` env variable set, VS Code server set this variable
Hey I get `Error: Provider env is not available on browser.` when I try to run `anchor test`
The error is when mocha is run, I guess mocha run the test in a browser context but I don't know why
To be exact the error is triggered here https://github.com/project-serum/anchor/blob/master/ts/src/provider.ts#L48
(I'm on a fresh `anchor init myepicproject --javascript`, coming from buildspace 😉)
I see, it means that the path of ```anchor test``` call should match the path of ```which cargo-build-bpf```, right?
Ah, interesting, that actually looks right to me
i try ```which cargo-build-bpf``` Should I reinstall solana??
That looks like your solana installation is messed up (what does `which cargo-build-bpf` say?)
hello, I have a question about ```anchor test```
if you had a same question, pls tell me how to solve it.
haha thank you !
```Error: Invalid account discriminator``` Why am I getting this guys when initializing an account?
That one is for you <@!307914484876312596> , I forgot to hit reply again goddamit
what you declare there needs to match the output of `solana-keygen pubkey ./target/deploy/<program name>-keypair.json`, which is the address at which your program was actually deployed (whereas the one specified by default in `declare_id!` is only a placeholder)
`declare_id!("fewjiof89237r934yf280923ru023i")`
You might not have updated the program id declared in `lib.rs` after the first deploy
let me see your question
haha sorry I should've hit "reply"
me ?
```
[workspace]
members = [
    "programs/*"
]

```
you might have add a feature flag in some dependencies you declare, like for instance:
`spl-token = { version = "3.1.1", features = ["no-entrypoint"] }`
<@!341381788620423168>  can you paste your Cargo.toml for the packages involved?
this is the code that causes the error: ```  let program_id = match exe.cmd {
        SubCommand::Pools { .. } => hydra_pools::ID,
        SubCommand::Farming { .. } => hydra_farming::ID,
        SubCommand::Staking { .. } => hydra_staking::ID,
    };
```
anyone got any ideas?
I am putting together a cli tool to call the different programs I have however I am getting this random error:
hey guys,
have you ever figured this out? did updating rustc help? I'm running into the same issue now with anchor v0.19.0 and rustc 1.59.0-nightly
And I don't know from where it's coming since I just took a basic contract and successfully built and deployed it :/
Hi, I have this little problem when I try to test my contract :
```
 test
Transaction simulation failed: Attempt to load a program that does not exist 
    
    1) Is initialized!


  0 passing (124ms)
  1 failing

  1) test
       Is initialized!:
     Error: failed to send transaction: Transaction simulation failed: Attempt to load a program that does not exist
      at Connection.sendEncodedTransaction (node_modules/@solana/web3.js/src/connection.ts:3689:13)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at Connection.sendRawTransaction (node_modules/@solana/web3.js/src/connection.ts:3649:20)
      at sendAndConfirmRawTransaction (node_modules/@solana/web3.js/src/util/send-and-confirm-raw-transaction.ts:27:21)
      at Provider.send (node_modules/@project-serum/anchor/src/provider.ts:118:18)
      at Object.rpc [as initialize] (node_modules/@project-serum/anchor/src/program/namespace/rpc.ts:25:23)



error Command failed with exit code 1.
info Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.
```
How to add padding to accounts in Anchor? I get the `the trait bound [u8; 100]: BorshSerialize is not satisfied`
i was copying this <https://github.com/jet-lab/jet-v1/blob/master/programs/jet/src/errors.rs> but now i see that the other error file i was referencing does use prelude <https://github.com/blockworks-foundation/voter-stake-registry/blob/master/programs/voter-stake-registry/src/error.rs>
yeh, totally weird, anchor lang prelude works
ok, cool, i'll try that out instead. Thanks!
I only have `use anchor_lang::prelude::*;` and the error macro works
yep, i tried both `use anchor_lang::error;` and `use anchor_lang::*`
Do you import the anchor prelude in errors.rs?
I checked many times and everything seems right, can anyone help me find out?
`     Error: provided too many arguments 251,500,1000,[object Object] to instruction initialize expecting: vaultAccountBump,initializerAmount`
ah right thx
Maybe not a bug exactly, but it's weird/Justin Starry said they want to fix/improve it.
This weird pre-CPI imbalance check: https://discord.com/channels/889577356681945098/889584618372734977/915190505002921994
Any tips on sorting this out? Cant access the Solana discord for some reason...
hey I'm trying out the openquest rust calculator tutorial. Whenever I enter "solana account (my key)" command on terminal i get a "AccountNotFound: pubkey=" error. Was also getting a tcp connect error before, but after i set a new keygen (solana-keygen new --force) I get the AccountNotFound
which bug?
so weird, because lots of people use separate `error.rs` files, i wonder what i'm doing differently
when they're in the same file, in lib.rs, there's no issue
the compile error is over the `#[error]` macro
in error.rs
```rust
#[error]
pub enum ErrorCode {
    #[msg("Function not yet implemented")]
    NotImplemented, // 300
}
```
and in lib.rs
```rust
    pub fn resolve_market(ctx: Context<ResolveMarket>) -> ProgramResult {
        //
        Err(ErrorCode::NotImplemented.into())
        // Ok(())
    }
```
```
expected non-macro attribute, found attribute macro `error`
not a non-macro attribute
```
Trying to use custom errors but getting a compile error
Reinstalled rust.. Getting other error on anchor build:
```root@User:/mnt/c/Users/User/Desktop/V/anchor-escrow# anchor build
BPF SDK: /root/.local/share/solana/install/releases/1.8.5/solana-release/bin/sdk/bpf
cargo-build-bpf child: rustup toolchain list -v
cargo-build-bpf child: cargo +bpf build --target bpfel-unknown-unknown --release
   Compiling blake3 v1.2.0
   Compiling num-traits v0.2.14
   Compiling syn v1.0.82
   Compiling solana-frozen-abi-macro v1.9.0
   Compiling solana-frozen-abi v1.9.0
   Compiling solana-program v1.9.0
   Compiling aho-corasick v0.7.18
error[E0463]: can't find crate for `rustc_version`
 --> /root/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-frozen-abi-1.9.0/build.rs:1:1
  |
1 | extern crate rustc_version;
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't find crate

error[E0463]: can't find crate for `rustc_version`
 --> /root/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-program-1.9.0/build.rs:1:1
  |
1 | extern crate rustc_version;
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't find crate

error[E0463]: can't find crate for `proc_macro2`
   --> /root/.cargo/registry/src/github.com-1ecc6299db9ec823/syn-1.0.82/src/lib.rs:307:1
    |
307 | extern crate proc_macro2;
    | ^^^^^^^^^^^^^^^^^^^^^^^^^ can't find crate

For more information about this error, try `rustc --explain E0463`.
error[E0463]: can't find crate for `rustc_version`
 --> /root/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-frozen-abi-macro-1.9.0/build.rs:1:1
  |
1 | extern crate rustc_version;
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't find crate

error: could not compile `solana-frozen-abi` due to previous error
warning: build failed, waiting for other jobs to finish...
error[E0463]: can't find crate for `memchr`
 --> /root/.cargo/registry/src/github.com-1ecc6299db9ec823/aho-corasick-0.7.18/src/prefilter.rs:6:5
  |
6 | use memchr::{memchr, memchr2, memchr3};
  |     ^^^^^^ can't find crate

error: build failed```
Can i manually download arrayvec v0.7.2 ?
What about doing `cargo clean` ?
Have you tried looking at that messed up Cargo.toml file in the error message? I wonder if you can spot something wrong with it
just came here and whuala
Ah, ok, hmm
everything was working fine lol
im using wsl
```rustc 1.59.0-nightly (686e313a9 2021-11-27)```
Also, not sure any of this stuff works on windows lol (most people have to use WSL as far as I know)
What is your `rustc --version`? Not sure what the problem could be
Cannot solve this error: 
```failed to download `arrayvec v0.7.2```
Yes, i think so too. Trying to reinstall rust..
Hmm, not sure what's up with that (something is wrong with your cargo)
anchor build :
Make sure you've run `anchor build`
any ideas?
```Cannot find module '../target/types/anchor_escrow' or its corresponding type declarations.```
in anchor ts-client 0.19.0 there is no `anchor.workspace.<app_name>` how can i get the `programId`?
anchor build works now. why? I don't know...
2. copy/paste Cargo.lock text (all of it) from working project that builds to the broken one.

This error started happening whenever I created a new project...Don't know why. Here's the fix...
1. change programs/Cargo.toml to this:
I was able to fix this issue. This is what it looks like...
Is there an easy way to wipe anchor and it's dependencies? My setup stopped working today and now I just see this message:   failed to read `/Users/yoshiioko/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-frozen-abi-macro-1.9.0/Cargo.toml`
when I run "anchor build"
Explained better than I can ^
https://discord.com/channels/889577356681945098/889577399308656662/907579111101329428
It's most likely due to the sighash of your instruction being wrong, hence when it looks it up on the program that you're calling it fails and has no fallback function
must be my Context variable
error*
but even when i comment out the cpi call i get the
yeah i'm doing CPI
hmm
This usually occurs for me when doing CPI where interface is improperly specified
im not sure what a fallback function is
Error: 101: Fallback functions are not supported
is anyone familiar with this error?
only react client example.
there is no cli example
ah, cli?
There are no cli example using the IDL in these?
And then you can see the good example in the test folder of Escrow example.

not too sure I follow? and I cant see an cli example in your doc?
https://github.com/bmstar2012/solana-reference
if you start rust and anchor, you can reference my git.
I shared my experience.
Hey guys, anyone got any good examples of building a rust cli to work with the anchor IDL contracts?
Hello everyone. I'm brand new here as of a few minutes ago.

I'm current experimenting with anchor (I have already developed an on-chain application on solana without anchor).
I've followed the guide and created an anchor program and have a runnable client.js as described here https://project-serum.github.io/anchor/tutorials/tutorial-0.html#generating-a-client

I'm new to javascript/typescript and my IDE (VsCode)  so maybe this is a configuration outside of anchor. Is there a way to actually generate the .js or .ts  client source code from the IDL? My IDE doesn't auto-complete the dynamically created methods from the "generating-a-client" example
in any case, the naming should be improved yes - I basically took a mock app I had lying around and shoved the state into it lol
nice. yeah im also really bad at adding 100 console logs lol
backtrace once again on the thank-yous to alan, who gave me the idea, i just wrote it out in a program
and that both states are upgradeable
Will keep the rest of the tests since they show that the account interactions actually work
I should clean up the console logs anyway
Thanks to you, you figured out the backend part so 😄
but yeah, this is awesome man, glad to be able to do this on client side now thanks to you 🙂
i condensed it down to this, just because i only wanted to see that the state changed and that it could be parsed by js. Also I changed base account to state account as the name cause i kept getting confused as to what base account was, so you will have to change back the test script or change the rust.
how do people normally do something like a payable function would be done in Solidity, where the function performs logic based on the amount paid in the msg.value? (like calling a payable function in a token pre-sale or something, to reserve some token allocation based on the amount paid, to be used at a later distribution date)
Haha thanks, I have like 2 total working days put into studying Rust / Anchor so I'd be amazed if this is something even remotely useful 😆
haha yeah just trying to understand what's what, because im very interested in how you did this
maybe the console log is over-verbized now
you probably just want to look at the last test, the others are just atomic tests for the basic functions
yeah these tests are hard to read 😄 let me see if i cant clean up a little

it is supposed to throw an error, but it should pass
1 is, the one `Cannot decrement initial state!`
unless it's supposed to fail?
wbu?
the tests are failing for me, a couple are
i don't think you can reduce the rent, it has to be rent exempt if i am not wrong
no, more like a thousand $ or more
I did a breaking change in the second state, with the u32 -> u64 so the interacting program will need to account for that when reading the state and parse accordingly
downside: for each state version you probably need a new state structure, and manually keep compatibility with all previous states
the upside is that you're in complete control of the structure and can upgrade the accounts
So either you build switchable states (if that makes sense at all), or you use state as a placeholder for upgradeable data
What's clear here is that you can't really keep both states with data since the program account doesn't hold state and the account can only hold 1 state
sick, will look in a min
Need to improve the readme as well
done - took a bit longer since I needed to put kid to bed.  Better test coverage and state upgrading example
If I wanted to deploy a smart contract to main net for a week (7 days) - would a cost estimate of about $5 be correct?
yeah took me a while to find it so i like to share it lol
right now just following sample code from programs i use / know well... this is useful
oh! tyvm!!!
yeah they are multi-purpose.
something for your bookmarks
https://docs.rs/anchor-derive-accounts/0.19.0/anchor_derive_accounts/derive.Accounts.html
https://discord.com/channels/889577356681945098/889606719829835816/909947411550580766
ah nvm, i see it for account(mut) as well as account(init).. giving it a try
or does that need to be done in the body of the instruction
is there  an #account[] constraint for checking that its a pda with seeds+bump?
Thanks Alan!
I did not expect full examples there 🙂
holy smokes! exactly this!
Have you looked at the anchor tests/ directory?
Hey guys, can you recommend any beginner friendly repos with Anchor programs? Some slightly more complicated than the basic ones. Cheers!
Just to leave a response for others with the same issue. I was using webpack to build my browser app with a dependency on anchor. It wouldn't work because `process.env` was undefined in the browser console. The fix was installing: `npm i process` and then adding:
```
plugins: [
        // fix "process is not defined" error:
        // (do "npm install process" before running the build)
        new webpack.ProvidePlugin({
            process: 'process/browser',
        }),
    ]
```
to the webpack config.
I got some freeish time now, so I'll quickly push that
lmk when you do, im interesed to see that
sound advice, will build on that
that way you're proving that this all works
couple suggestions to make this better:
add a handler to switch back and forth between states, that way you can write test cases to prove that either case works in the typescript
add log statements in the test inside each of the state cases
brb
it's a simpler case than yours but should work in any case
https://github.com/srps/mysolanaapp
let me up this example to GitHub
like Github, got it
```abc```
can you post the rust structs?
yeah put 3 on top and 3 on bottom
Use backtick
Sorry I need to l2Discord - worst formatting ever
```let account = await program.account.baseAccount.fetch(BaseAccount.publicKey);

    switch (Object.keys(account.current)
      .filter(key => key.endsWith("State"))[0]) {
      case "firstState":
        assert.ok(account.current.firstState.count.toNumber() === 0);
        break;
      case "secondState":
        assert.ok(account.current.secondState.count.toNumber() === 0);
        break;
      default:
        throw new Error("Unknown state");
    } ```
right now I'm just doing it manually, I think you got farther from this already but I'll share in a min
if you come up with something good i'd definitely like to see the code
If we look at the Solana contract we can test for the object keys and derive the type from that.
I already asked there but got no answers. But since <@!501570363566587905> is here I'm trying my luck.
they seem dead over there, idk how ur supposed to integrate with their programs
lol true
No one ever answers any question there.
https://discord.gg/YDnUBBv5
Can I DM one of the core devs here about a question on Serum? (because it is not Anchor related)
You use the system program whenever you `init` an account (amongst other things)
i might make an issue, worst case i think there's some way to get the data byte array and parse it, otherwise doing a program log and then grabbing the logs
I'm also stuck there hehe
no progress regarding deserializing the object in JS, I suppose
gotcha, going to check it out. I had to step away this past week - barely any time for anything serious so I just kinda skipped Discord 😦
p much. if you scroll up in <#889606719829835816> you can see my full example
i figured it out already
Ah, so you used a simple match to check the kind of object passed and deserialize on the fly, cool
Don't transfer lamports
`Failed to run test: node tests/myproject.js: No such file or directory (os error 2)`
this is what i get when i run `node tests/myproject.js` manually
i'm getting the following error when i run `anchor test`
Not sure what you mean by "call a TokenAccountA" ?
Does this help?
https://stackoverflow.com/questions/68236211/how-to-transfer-custom-token-by-solana-web3-js
Hi everyone, does anyone know how to call a TokenAccountA with the public key of the TokenAccount. I want to use the function 'getOrCreateAssociatedAccountInfo' to generate an account for a user from TokenAccountA
But for starters you snippet #1 is definitely a better starting point, as you are using Anchor (and its Provider) to communicate with **your** program
If not tell me and we can dig in a bit
It sounds quite similar to a lot of issues answered before. Could this snippet/conversation (zendevil/cqfd) help you?
Question for you sir:
Do you have an example that shows what a CPI to transfer lamports looks like?
so 1, I am not sure which address to use and 2, i am not sure why the respective errors arise with each different address
this will return an "invalid instruction data" error
```this.PROGRAM_ID = new PublicKey("11111111111111111111111111111111");
        this.connection = new Connection('http://localhost:8899');
        this.provider = new anchor.Provider(this.connection, wallet, anchor.Provider.defaultOptions())   
        this.program = new anchor.Program(idl, this.PROGRAM_ID, this.provider);
    ```
this will later on return a 0xa8 address error
```this.PROGRAM_ID = new PublicKey(idl.metadata.address);
        this.connection = new Connection('http://localhost:8899');
        this.provider = new anchor.Provider(this.connection, wallet, anchor.Provider.defaultOptions())   
        this.program = new anchor.Program(idl, this.PROGRAM_ID, this.provider);
        ```
and it gives two errors
but when i use anchor deploy, i plug in the deployed address to my react frontend
they do call the program. using anchor test, in the ./tests/project_name.js file, when i import {SystemProgram} and log SystemProgram.programId its "111111111111111111111111111111111"
Does your test actually call your program? Only logs from the System program would show if the only thing you do is create accounts for instance
hi all, when I use anchor deploy, it gives me a programId address to where my program was deployed (local net). yet, when logging for tests, it's always "11111111111111111111111111111111". when do i actually use that program address?
not that i know of 😦 i dont know that deep into anchor
I'm using `remaining_accounts` for the number of accounts i need to close is variable, that's why i'm looking to close them from an accountInfo type. Is there a way to go from account info to account so i can close them ?
just make sure you provide the account of the person who gets all the sol inside the account ur closing
just call it on an instance of an `Account` 🙂 `my_account.close()` or somesuch
https://github.com/project-serum/anchor/tree/master/tests
https://github.com/project-serum/anchor/tree/master/examples/tutorial
check through these programs, recommend to go step by step through the basic ones first and understand all the parts
https://docs.solana.com/developing/programming-model/overview
https://spl.solana.com/
steps 3, 4 and 5 are not necessary if you just want to run tests. anyway your issue is mainly because you are running a test validator, and anchor test already does that


//////////////////////////////////////////////////////////////////////////////////////////

That means you're doing something where you need to pass the system_program as an account: add `system_program: Program<'info, System>` to your accounts struct and should be all set
Yep, you'll need to set it in one of your shell's init scripts (e.g. I'm using zsh, and put that kind of line into my .zshenv file in my computer's home directory). If you're on bash it's probably in your .bashrc etc.
problem is every time i open a new terminal, I have to export the path again. is there a way to do this once and not have to keep exporting on each new terminal window?
im on a mac m1, followed the solana downlaod tutorial but i need to keep exporting the PATH (guide stated PATH=$PWD/bin:$PATH)
could u send your Accounts struct too
just bumping this:

i'm running into the following error:

`error[E0425]: cannot find value system_program in this scope`

```
  |
5 | #[derive(Accounts)]
  |          ^^^^^^^^ not found in this scope
  |
  = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)
```

when trying to write instruction structs
i have `use anchor_lang::prelude::*;`
do i need an explicit import here?
this is 0.19.0
Gotcha thanks
That means expect the account not to have its discriminator bytes set yet (anchor uses the first 8 bytes of account storage to hold an "account discriminator"). The idea with #[account(zero)] is you sometimes need to allocate the storage for an account in a separate instruction, so its anchor hasn't had a chance yet to set those discriminator bytes.
what does account(zero) mean?
thank you! nice to have confirmation
Is anyone else running into `unresolved import` errors when trying to use the CPI feature to make calls to another program?
https://project-serum.github.io/anchor/tutorials/tutorial-3.html#defining-a-puppet-master-program
<@!134416332509675520> Can you perhaps help me? My program compiles okay, but then in the tests, I cannot instantiate my program because apparently workspace does not exist on anchor. I used escrow example as the baseline.
my tests work fine
I'm having a weird test-related issue here as well:
Build succeeds, but the program initialization does not work, anchor.workspace is giving error that workspace is not a property of anchor. Any hints on why? (i'm using typescript for tests)
I' using Ubuntu in a docker container
no I'm using `0.18.2` I think
are you using an M1 machine as well?
I have the same issue. Are you using the 0.19.0 version?
is it weird that `anchor test` works perfectly but if I run `anchor localnet` + `anchor deploy` on localnet it's stuck on `[0/1] Finalizing transaction` forever?
thanks for the help, todays not my day so im going to move on to another tutorial haha
not sure if it's related to mac, may need to seek help from the command you're using.
im on a mac m1 so tbh im pretty sure thats the reason for the os errors
that did resolve it slightly, but now having an error unable to read keypair file - its defaulting the keypair to the folders ive saved the tutorials to. "Unable to read keypair file"
In your `Anchor.toml` file, edit the `scripts` section as follows: 
> [scripts]
> test = "npx ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"
In your `Anchor.toml` file, edit the `scripts` section as follows: 
> [scripts]
> test = "npx ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"
still getting the os error 20 after installing mocha again...
Make sure you've actually got ts-mocha (or mocha, whichever testing library you're using) actually installed
I know you are busy <@!501570363566587905> but maybe you can help out here, because a lot of people have issues, with that and I want to unterstand whats the best and safest workflow
Here's my repo for the problem.
seems a bit complicated, in fact, it's not.
https://github.com/cryptoJLee/nft-rental-sol/tree/feature-syntheticnft
Im completing the openquest calculator tutorial. when i run "anchor test" after all code is written i just get a "Error: Not a directory (os error 20)". Any fixes for this?
Mm, good question, I'm not sure! I don't really know what the best workflow is for this kind of thing, will have to see what other people think
I think you're going to have to post your code to a github repo—I tried doing something similar to what I think you're describing in the basic-3 example and it seemed to work fine.
<@!134416332509675520> one question: anchor 18.2 requires solana 1.9, which is not released on the mainnet, should you really develop production contracts with solana 1.9 when, its not released on the mainnet
same question with using anchor 19.0 which requires rust edition 2021
<@!134416332509675520>  Please have a look and let me know. I tried hours and can't find any solutions. 🙏 🙏 🙏
Any solutions to this problem?
seems like the solana-program is updated to `1.9.0` three days ago and it's breaking the most recent programs.
I updated the solana to `1.9.0` and the error is gone.
How can I store something in AccountInfo?
> rustup 1.24.3 (ce5817a94 2021-05-31)
> info: This is the version for the rustup toolchain manager, not the rustc compiler.
> info: The currently active `rustc` version is `rustc 1.57.0 (f1edd0429 2021-11-29)
Anyone got this error?
----------------------------------------------------------------------------------------
> error: failed to download `solana-frozen-abi v1.9.0`
> 
> Caused by:
>   unable to get packages from source
> 
> Caused by:
>   failed to parse manifest at `/home/aaa/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-frozen-abi-1.9.0/Cargo.toml`
> 
> Caused by:
>   feature `edition2021` is required
> 
>   consider adding `cargo-features = ["edition2021"]` to the manifest
----------------------------------------------------------------------------------------
you are on mainnet so this is why the airdrop is failing. try this first `solana config set --url devnet`
ProgramAccount is deprecated in favor of just Account, and yeah, Signer and `#[account(signer)]` do essentially the same thing but `Signer` is a bit nicer (it bakes the fact that someone signed into the type)
Config File: /Users/<user>/.config/solana/cli/config.yml
RPC URL: https://api.mainnet-beta.solana.com
WebSocket URL: wss://api.mainnet-beta.solana.com/ (computed)
Keypair Path: /Users/<user>/.config/solana/id.json
Commitment: confirmed
Just type `BROWSER= anchor test` instead of `anchor test`
whats `solana config get -v` say?
When I run solana airdrop 10<address> on my localnet I get the following error:
**"% solana airdrop 10 <address>
Requesting airdrop of 10 SOL
Error: airdrop request failed. This can happen when the rate limit is reached."
**
Any advice?
I have a program A that calls another program B using CPI.
TokenBumps is a struct used as a param on the instruction of the program B.
And in TypeScript, the IDL of program A shoots an error.
Type not found: {"name":"bumps","type":{"defined":"TokenBumps"}}

Is there any way to fix this error?
I am wanting to build a cli that using subcommand and can talk to all my different programs I have in the protocol.
I have put a test-protocol repo up here that reproduces the issue if anyone can have a quick looks and let me know if you see the issue: https://github.com/utx0/test-protocol/tree/main
Hey guys, I am getting a random build issue when I am using this code in a cli I am build: ```    let program_id = match exe.cmd {
        SubCommand::Pooling { .. } => pooling::ID,
        SubCommand::Farming { .. } => farming::ID,
        SubCommand::Multisig { .. } => multisig::ID,
        SubCommand::Staking { .. } => staking::ID,
    };```
Has anyone had issues where your system crashes when trying to install anchor?
I'm running the command `cargo install --git https://github.com/project-serum/anchor anchor-cli --locked`
And while compiling, my desktop fans would go crazy and my system would crash. I'm on windows 10 using the linux subsystem
this is 0.19.0
do i need an explicit import here?
i have `use anchor_lang::prelude::*;`
when trying to write instruction structs
i'm running into the following error:

`error[E0425]: cannot find value system_program in this scope`

```
  |
5 | #[derive(Accounts)]
  |          ^^^^^^^^ not found in this scope
  |
  = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)
```
where can I check this? Having same problem
Anyone know if there is a difference between these two bits of example code?
```
#[derive(Accounts)]
pub struct Increment<'info> {
    #[account(mut, has_one = authority)]
    pub counter: Account<'info, Counter>,
    pub authority: Signer<'info>,
}
```

```
#[derive(Accounts)]
pub struct Auth<'info> {
    #[account(mut, has_one = authority)]
    pub data: ProgramAccount<'info, MyData>,
    #[account(signer)]
    pub authority: AccountInfo<'info>,
}
```


 - I'm not sure the difference between `ProgramAccount` and `Account` structs here
- more importantly, I'm curious if there is a difference between specifying the Signer account as:
`pub authority: Signer<'info>,`
vs
`    #[account(signer)]`
`    pub authority: AccountInfo<'info>,`
nvm, "freeze_authority" is an option
is there any documentation for those spl-token annotations?
`mint::authority` does this set both the mint and freeze authority?
Hello! I am running into some ssl issue when running anchor test on devnet

I can make https requests from my local but not sure where I can specify a custom cert authority. Also tried export NODE_EXTRA_CA_CERTS
```
Error: failed to get recent blockhash: FetchError: request to https://api.devnet.solana.com/ failed, reason: unable to get local issuer certificate
    at Connection.getRecentBlockhash (/Users/samantha.han/Web3/epicproject/node_modules/@solana/web3.js/lib/index.cjs.js:5965:13)
```
how can I configure the name of the ix?
how are the program instructions named for the likes of serum, for example? for my program instructions, they show up as unknown, for serum, it has its own name
Awesome! Thanks, I didn't know about this method.
I think you'll have to do `ctx.accounts.that_token_account.reload()` to reflect the result of the CPI
for a program to accept sol deposits, do you need to create a token account?
would be better if I can just rely on `token_account.amount`
well yes, theoretically I'd be able to derive the new amount from the transfer amount and the old amount, but it's not super practical as the transfer happens inside a method that I'm calling which calls another method that does the transfer
I'm not sure I totally understand the question, but if you make a transfer between two accounts that means that you have both accounts available in the ctx, and that whatever operation is applied to them will be reflected. E.g.  (A: 10), (B: 0) provided => call "transfer 1 from A to B" => (A: 9), (B: 1) , and you would be able to log those value and see the expected amounts.
Do you have a specific worry in mind?
If I do a token transfer within my contract using CPI into a token account `token_account: Account<'info, TokenAccount>` , will `token_account.amount` reflect the updated value, or the one deserialized when instantiating the ctx?
Thanks! I'll try to make it work with this. Much appreciated Milk duds 🙏
if you have an object of type `anchor_lang::Account<'info, anchor_spl::token::TokenAccount>`, then you can call the `amount()` method.
he never calls it in this program but you can see how he's using token accounts.
https://github.com/cqfd/quidproquo
so you'd do something like
`ctx.accounts.offer_takers_taker_tokens.amount()`
If I tell you:
1. client-side (e.g. frontend): retrieve the associated token account for the particular token mint you want to check (there is a web3.js function for it) and provide it as an account in the call to your contract
2. program side read this account and do a simple check ~~`ctx.token_account.balance > 0`~~  `ctx.accounts.token_account.amount() > 0`
is there something specific that is unclear to you?
In a smart contract. I'm looking to check if a user is holding a particular SPL token (or perhaps one from a list) in order to execute
in what context?


//////////////////////////////////////////////////////////////////////////////////////////

when submitting an instruction?
is there a way to easily print out all the pubkeys of the `accounts`
debugging in anchor can be such a pain sometimes
it can be the token account owner, but it's difficult to make it the payer
nope, not unless you do some crazy shit
Gotcha! PDA can sign the tx but can't pay to initialize a new account
and the PDA has data on it / already is owned by a program
no, this means that you're trying to use a PDA to pay for a new account
Ah! Okay I did have a slight seeds issue. But now running into `Transfer: 'from' must not carry data` which I think is suggesting I can't initialize a new account with a PDA as a signer
i don't see why passing the AccountInfo into the puppet program via CPI would cause you any errors if it's an unitialized account
seeds and bump
are you including `seeds` in the puppet program accounts context
i think you'll get around the issue by doing what you're doing already, just using a mutable accountinfo to pass into the pupper program
you're going to run into problems if puppet master and puppet are separate programs
well
It sounds like you're saying either the original signer or the "pupper master" program could init the account directly with the system program before the CPI?
Can you say more about that first part? I'm haven't tried to do anything directly with the system program. Have just added the `init` flag to an account's `#[account()]` macro and attempted calling that instruction via another program. I've tried passing in the account to the "puppet master" as a mutable `AccountInfo`  but this tends to result in `unauthorized signer or writable account` when the CPI is attempted
Yes on all these! Can post a link to an example soon.
are initing a PDA
are you using the `init` key word
are you using the correct seeds
There's two steps, creating the account with a system program call and then initing it with your custom program function
assuming you include the account in the account context there shouldn't be any issue with creating the account
Struggling with this same problem right now as well! Does anyone know how to init a new account via a CPI call? The catch-22 seems to be that all Solana accounts used in a transaction have to specified ahead of time.. but the account I want to init via CPI isn't initialized when the signer first submits the transaction. So I keep running into `Cross-program invocation with unauthorized signer or writable account` errors wrt the accounts I'm trying to init via CPI
Not really sure what that trait is for if not for that
I expected the `instruction::xxx` structs to implement `InstructionData`, but apparently they don't
It'd probably solve the issue, was my first thought but I was hoping for something less ugly
ok, i was just trying to check if the sha256 thing was actually a solution to your problem or if you just didn't like the solution
Without having to use the restrictive anchor client
it sounds like you have to do everything manually anyway, is all i'm saying
Yeah, I'm just trying to build an Instruction I can send to a validator
maybe i don't fully understand what that is
you said you're constructing the instructions manually without using the client API though?
lol
Hm, kinda annyoing having to do that manually
though not 100% sure that's correct
i think `sha256(global:{funcname})[0:8]` is what the discriminator uses
if you get
```
Error: Unable to read keypair file
```
Make sure that you've run 
```
solana-keygen new
```
if you're on a new computer

Update:
Alternatively check that the `wallet` path is correct in your `Anchor.toml` file
e.g.
```
[provider]
cluster = "localnet"
wallet = "/root/.config/solana/id.json"
```
Anyone able to help with this?
https://explorer.solana.com/address/So11111111111111111111111111111111111111112 ?
thanks
Btw does anyone know the Mint account for the SOL token? How do I find it?
changing ownership requires access to the account data which means the program needs reference to it, so it has to be explicitly specified.
ouch , I guess would have to handle it if they end up being blank
you cannot pass an array of token accoutns, you need to pass each account one-by-one
Hi guys , sorry if this is a stupid question , but am writing a contract and want to pass an array of token accounts owned by a single account to be owned by the pda , is this possible
Heeeelp! Is is possible for the program to initialize a regular token account (without any data)?
Yeah I think so
hello, does `pub rent: Sysvar<'info, Rent>,` this also check if the rent account is actually the rent sysvar?
yo thanxs I got my answer
This snippet gave the same number
```javascript
const rent = await program.provider.connection.getMinimumBalanceForRentExemption(89)
```
i think your account needs to be funded with 2 years worth of storage funds to be rent exempt...
I created a PDA using anchor, and while inspecting, their is one question jumping in my mind, is `the transfer amount(sol) ◎0.00151032` in the image, is the minimum amount to be rent exempt. and is it automatically get deducted while signing the txn.
google for solana rust escrow tutorial, and read up on PDAs
is there a thread above with an example of this?
Yeah, right but I wanna another way rather than PDA
You can make use of PDA
Thanks
https://discord.com/channels/889577356681945098/889702325231427584/909034790030823425
Guys I have created nft, but I don't know how to fill information in it? like how to store json and is it even possible?
You need to transfer the ownership (and signing rights) to a PDA which will be owned by your program. Then you dont need to sign it yourself anymore.
which i cant do :(
so even though i can pass in the proper addresses for validating authority and whatever, in the end, it needs me to sign
the issue is, because the user is not me, their wallet creates the provider for the program, and in turn, they are signing that transaction
and this is giving me an issue because i want to allow users to mint for one specific rpc function, but the signer needs to be a secret/my keypair
so when I create a program with a provider, the wallet signs all transactions
You mean like a regular web2 application? Sure, but  then it would not be on the blockchain 😉
Jokes aside, you can control what data should live on the blockchain and then only transact those bits, which should minimize the amount of signing.
is there a way to create a program on frontend without having the wallet sign everything?
Hi <@!134416332509675520>
Hey, I'm trying to construct anchor txs in rust (without using the client API as I want to send them over a TpuClient) and I can't get the instructions serialized in a way such that they also contain the discriminator: are there any examples on how to do this?
I have 2 programs, a puppeteer and a puppet for example. 
There is a function on the puppet, which creates new PDAs with a ctx looking like that:
> #[account(init_if_needed, seeds = [b"new_acc".as_ref()], bump, payer = user)]
> pub new_acc: Account<'info, NewAcc>
I'd like to call this function with the puppeteer using the CPI, but as far as I understand, I need to pass this PDA as a ctx to the puppeteer function, but it's still not initialized at the moment.
that's from this question which has another approach as well, but I don't know enough to say which one would be better:
https://stackoverflow.com/questions/69382867/how-do-i-get-list-of-tokens-owned-by-me
maybe this will be useful?
https://docs.solana.com/developing/clients/jsonrpc-api#gettokenaccountsbyowner
no worries  👍
yeah, lol! I know that feeling  😆 
It's all very manual, and in some ways more restrictive
But thanks so much for the help though. I might DM you with questions later if you don't mind
Coming from solidity everything is hard 😩
yeah, I am still learning myself. But if all the wallets can determine/discover the held NFTs of a publickey, then it must not be too hard
you can store the data on-chain, and fetch the accounts that hold the data, in order to compile your list of accounts to put into your instruction from the client. So storing such information on-chain can still be part of a solution to certain problems, but it would be used mainly for the client to reference the data (and maybe for on-chain validation of the accounts somebody is requesting to change, if such controls are needed)
Seems client side needs to know more than just a wallet but also scan the wallet for their mints which I'm not sure how to do at this moment
Oh you are completely right I think. The accounts array must be predetermined
Struct containing mint address which will function as seed for the program owned token account and some values set by program instruction
what do you mean by NFT data? ownership status, or something else?
like, you can't even reference a PDA's data even if you know the address on-chain, without having it passed into the instruction from the client. That's because of how the accounts array is used to safely parallelize access to account data. So the account access has to be pre-determined via that array in the instruction. Hence the need for off-chain processing even if you had an on-chain approach that could otherwise work to know the arbitrary account addresses. That is based on my understanding of everything anyways
Basically have several users with one to many relationship to a struct containing nft data. Want to get all the NFT data somehow with just the user wallet address
How about vectors in solana
your question/scenario is a tad confusing, but hashmap as far as I know is just simply not available in Solana. You can see a bit more explanation here: https://stackoverflow.com/a/68477522/200818

So it seems you just have to get creative with how you reference your data. And I think since you need to always pass in from the client, any account that you want access to, you will always need to offload some of the logic onto the client for iteration and/or pagination of whatever list of results you may need to process, and then pass those accounts into the instruction that needs it. Does that make sense? I can't speak too much to your use case since it was a bit unclear to me what you're trying to do (but I'm also still learning as well, so maybe I am missing some context around your question)
I was actually trying to do the same thing today. For each user wallet address I want to set up a PDA that implements a HashMap<Pubkey, data> to keep track of multiple NFT mints and map it to some data. 
I can't use the PDA for the hashmap data because I won't be able to get all of the data just from a single user PDA from the original user wallet address.
A potential second option is maybe I could have multiple NFT PDA's set up for my user PDA but then I would need a vector (which is indeterminate size anyways) in my user PDA to keep track of all NFT's accounts. This is under assumption I want to get all my data from just being given a user wallet.
Hopefully I wasn't too confusing and I'm thinking of doing the first option of using the one PDA to store a hashmap but I'm still new to everything and not sure what the ideal approach is
If I follow the Token Metadata standard will my NFTs be consumeable on Metaplex + Phantom? What's the best practice for minting NFTs outside of candy-machine?
```    
#[account(mut, constraint = admin_acccount.key() == Pubkey::from_str("Fp7nWGtfb1LFwzZcgmNkMRPzaWbmQ6DDwEndqUQXvLAs"))]
pub admin_acccount: AccountInfo<'info>,
```

How can I ensure that provided admin key is same as `Fp7nWGtfb1LFwzZcgmNkMRPzaWbmQ6DDwEndqUQXvLAs`.

It seems that there is no `from_str` on Pubkey struct
Have you looked into PDAs for that kind of purpose? I think that’s typically the go-to approach to storing associative information, especially when an indeterminate size
Hi <@!134416332509675520> 
Could you explain me how I can implement the hashmap<Pubkey, u32> on the account?
~~Hey is there a way to skip program upgrade when running `anchor test`~~
**solved**: There is a `--skip-deploy` & `--skip-build` that's not mentioned in the docs
https://docs.solana.com/developing/test-validator
yep 🙂
by default? why? to pay for transactions?
there's no harm. As long as it's a valid key. Everytime you start up a new test validator it will airdrop a bunch of sol to whatever key is at that address
thanks bro
any harm in overwriting my local solana keypair?

i've just been doing local dev. could restart test validator without consequence.
yw
I see, thanks for the help!
Dont think it does. You would need explicit owner check. I.e. on the token_account you would need to add owner=user, and add another account which will be named user, and that one would have signer constraint
Or does that still not solve the problem of a caller referencing something they don't own 🤔
Yeah within the function I check `.amount >= 1`
Almost there. Right now anyone can call this by passing the desired token addresses. You need to make sure that the signer of the transaction indeed owns those tokens, or rather they own the accounts which hold the tokens
use constraint:
constraint = accountA.mint == mintAddress.key()
Captains and crew, I spent the day writing my first smart contract, but I'm pretty sure I wrote it in the ugliest fashion possible. Can anyone offer critique/advice? I simply want to allow entry to a `fn()` for holders of an NFT in a list (or one of a collection). The entry `Context` in this case is the `UpdateAsHolder` `struct`. My terrible, no-good, naive solution is this: 
```fn is_access_token(input_token: anchor_lang::solana_program::pubkey::Pubkey) -> bool {
    let v = [
        "teST8ZSPiHKifT6tvWhzQdSZz57NeaX7jaMkfGSwcyF".to_owned(),
        "testGaCLrEdHAhBkN2V44igJc7RfEoz3A2S63pW1rzV".to_owned()
    ];
    let input_token_str = &bs58::encode(input_token).into_string();
    msg!("Validating against input_token: {}", input_token);
    if v.contains(input_token_str) {
        return true;
    }
    return false;
}

#[derive(Accounts)]
pub struct UpdateAsHolder<'info> {
    #[account(mut, constraint = is_access_token(token_account.mint))]
    pub token_account: Account<'info, TokenAccount>,
}```
Is there an `#[account()]` constraint that can check to see if a token account being passed is of a particular mint?
when i try to just put in `#[account(token::mint = my_spl_token_mint)]` it says i also need `init`, but im not trying to create it, i just want to check it
thx (:
yes
also, can i set the authority as a PDA? if so, I have to provide the seeds into order to sign a CPI to transfer tokens i assume?
`token::authority=my_sys_act`
This property sets the address that is allowed to send tokens out of the Token Account, correct?
If you look at the source, checkout line 112+ in the test js file
found it
can you link to that?
Derives the pda in js and then passes it in
Looking at the escrow example from paulx blog that's what he does
hm maybe all I need to do is pass the Pubkey, and not the account, then initialize an account for that Pubkey... let's try
anchor_spl::token::initialize_account
yeah, there is one in anchor-spl too
Found this too https://docs.rs/solana-sdk/1.4.4/solana_sdk/system_instruction/fn.create_account.html
#[account(init)] does not work sadly - or at least I didnt figure out which type to use, since init requires a struct for data type
Since the program is an executable, its account is immutable, so you def need to create a new account for treasury. I think using #[account(init, ...)] can work? I am unsure other ways to create a token account for sol... looking into that now myself, all the examples are js 😄
Thanks, that's what I thought. So in order to initialize my program with a SOL token account which the program will be able to transact out of, I would need a new token account which I would transfer ownership to the PDA?
In solana the way you transfer authority "to the program itself" is via a PDA, because if the authority/owner were literally the program's id, then you wouldn't have any way for the program to sign for that address (this is exactly what PDAs give you: the ability for the program to sign for them)
What do you mean by a PDA key? What you wrote is totally correct, the program can sign for its derived addresses, which means PDAs are what you want to use if your program has authority over some account ("authority" isn't a built-in solana concept, it just means "can sign for some address, and in so doing can convince some other program to do something"—so e.g. having authority over a token account means you can sign in such a way that you convince the spl token program to, say, send some of the tokens somewhere else, etc.)
It worked. Thanks a lot!
From what I understand the program derives the PDA account and sets the authority to be the PDA. Since the program can sign using the PDA + bump, then it can access tokens in the PDA account. Im pretty new but that's my understanding. Im a little fuzzy on what the difference between the PDA key and a PDA authority, can someone clarify the difference?
Thanks for the answer. Let me try it
it looks like your solana version is too old, try to install 1.9.0
in the anchor repo /tests/escrow/
What escrow example are you referencing?
I see. In that case I dont even need to pass this account to the initialize instruction, right - the program can just derive it.
In the escrow example the account under escrow transfers ownership to a PDA account - why not transfer the ownership to the program address itself? Is that less secure?
Hi everyone. I'm new to Rust world.. so couldn't find a fix for this. Anyone can help please?
Ok, then you just need to make sure your program can sign for that address (it'll have to be a PDA). (To be pedantic for a sec, this is different from program ownership. That account will be owned by the system program probably, not your program, but your program will be able to sign for the account's address.)
I figured out my issue!  So my struct has 3 fields other than the public key: a string, and two numbers.  I was trying to memcpm the first number assuming that the string would take up 64 bytes of memory.  But that's the max memory and I was comparing the wrong offset.  So basically I had to convert the string to utf8 and see how many bytes it actually takes up and then use that offset.  And I had to base58 encode the number to compare it.  Thanks for help
Hey guys any idea on how to make your spl token show up in fantom with name and icon and not just address? Looked everywhere I could but can't find anything
no data, just SOL balance.
update: i think issues regarding these lines invoke error messages like:

`149: An associated constraint was violated`.
is the following line considered a constraint?

`associated_token::mint = swap_state.bar_coin_mint,`
can PDAs even store data or balances or are they only for signing (i.e. owning) other accounts?
no, only tokens
Will the account store any data?
The program needs to own that account of course.
Hey people. I'm writing a program that will own a treasury account. What is the best way to go around initializing this account? Should that account be passed to the program on initialization (already created) or should the program generate a PDA account. This account will store SOL tokens.
ty
Whoops `progam.provider.connection`
From https://lorisleiva.com/create-a-solana-dapp-from-scratch/testing-our-instruction
```
it('cannot provide a topic with more than 50 characters', async () => {
        try {
            const tweet = anchor.web3.Keypair.generate();
            const topicWith51Chars = 'x'.repeat(51);
            await program.rpc.sendTweet(topicWith51Chars, 'Hummus, am I right?', {
                accounts: {
                    tweet: tweet.publicKey,
                    author: program.provider.wallet.publicKey,
                    systemProgram: anchor.web3.SystemProgram.programId,
                },
                signers: [tweet],
            });
        } catch (error) {
            assert.equal(error.msg, 'The provided topic should be 50 characters long maximum.');
            return;
        }

        assert.fail('The instruction should have failed with a 51-character topic.');
    });
```
hmm, it says `Property 'connect' does not exist on type 'Provider'`
Nooby question: does anyone have an example of a js/ts test where a smart contract is expected to throw an `Err` ?
await program.provider.connect.getAccountInfo(theAccountPubkey)
is there a way to output the bytes in an account? would help for my testing to see what value I need to compare with
what I was referring to was this one in particular:

> a.toArray(endian, length) - convert to byte Array, and optionally zero pad to length, throwing if already exceeding
https://www.npmjs.com/package/bn.js?activeTab=readme
signed works as well. I guess it makes sense haha
ok I'm wrong
I might be wrong about the signed bit. Let me see (I always use it for unsigned)
ah I shouldn't need since it's signed 16 bit
BigNumber (bn.js), a popular library to handle numbers that cannot be contained in js `number`. But it is for unsigned (I think? 🤔 )
how can I check how it got serialized?  I wrote the implementation for this
what is BN?
it's `i16`, will try to find a similar technique.  thanks!
Feel like there's got to be an easier way though lol, that buffer stuff is so gross :/
How about using BN's `toArray` ?
You would have to check how that number got serialized. For example if it's a u64 and got encoded as little endian, you would do something like
```.js
let buf = Buffer.alloc(8);
buf.writeBigUInt64LE(123, 0); // ugh
base58.encode(buf)
```

**Error: 3012: The program expected this account to be already initialized**

Getting this error for an Account<'info, TokenAccount>  which does not exist. I tried specifying #[account(init, payer=payer)] but for some reason this does not compile? What am I doing wrong?
Ok I think I answered sideways again. The issue is the type of what you compare to, a number like you wrote
Looks similar to what you have I think?
```
    {
      filters: [
        {
          memcmp: {
            offset: XXX
            bytes: base58.encode(Buffer.from("string I look for)),
          },
        },
      ],
    }
```
is a working filter
I have a rust syntax question, can anyone help?

For `memcpm`, I need to supply a `bs58` encoded value, but my value is a number, not as string.

`bs58.encode(Buffer.from(`${aNumber}`)),` does not work

This is in a test
urgh finally...thanks for that had to change it to my specific directory


//////////////////////////////////////////////////////////////////////////////////////////

Sorry, the issue with my janky `msg!` approach (I think)
what did u mean by this btw?
for sure, give me a few min
Yeah, just as long as it actually reproduces the error lol
Ok, well, would be pretty easy for me to debug locally I think, just kind of awkward remotely
if i put together a minimal lib.rs is that cool too? and you can just paste it in a new anchor program
i do not 😦 but i can put something together if you really need it. but uh, it's a large codebase and such, and confidential. but let me see if i can put together a minimal codebase that singles out the problem
Do you have this in a github repo anywhere?
yep
```
'Program 8yBiqm4eZjDQACD5JnZrvoKB6nyE9xDh3yvMiPnWtTpL invoke [1]',
'Program log: Instruction: DoStuff',
'Program 11111111111111111111111111111111 invoke [2]',
'Program 11111111111111111111111111111111 success',
'Program 11111111111111111111111111111111 invoke [2]',
'Program 11111111111111111111111111111111 success',
'Program log: ostensible owner: 23E8Ff9cicYffUCFEvbuVyySu7nhr8rzLefTrCjjVf3H',
"Program log: wtf is this thing's owner: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
'Program log: Custom program error: 0x7df',
'Program 8yBiqm4eZjDQACD5JnZrvoKB6nyE9xDh3yvMiPnWtTpL consumed 74024 of 200000 compute units',
'Program 8yBiqm4eZjDQACD5JnZrvoKB6nyE9xDh3yvMiPnWtTpL failed: custom program error: 0x7df'
```
`Owner: 23E8Ff9cicYffUCFEvbuVyySu7nhr8rzLefTrCjjVf3H`
Gives the proper owner when i log it in js (user pda)
Can you post the full program log? (Always easier to understand than snippets)
Lol, macros are weird
Ohhh, hmm, I think I see what the issue is
What if you check the owner in JS?
thanks!
:/
<@!134416332509675520> this is exactly what i have for when the account is created
maybe this video could give you some pointers (there might be better resources on Google, I'm not sure): https://medium.com/gitcoin/commit-reveal-scheme-on-ethereum-25d1d1a25428
But when I check locally what I wrote above seems to jump to the right owner
So I wonder if that's actually your problem (though still possible I'm just confused)
As far as I can tell locally `.owner` should actually give you the user space owner, not the underlying account owner
Is it possible you accidentally set its owner to the spl token program? 🤔
commit/reveal is a way to deal with these things. You basically "commit" an obfuscated proof  of what the users chose, and "reveal" the choices once both have played their turn
how would i check for the authority
i guess .owner is the program owner? not the authority?
Well, huh
yeah i was about to say xD
Oh, whoops, 1 sec
```
'Program log: ostensible owner: B6UtLbKjQHCYgHfjxAqBb2QvWRBp1MhpZTyAXJaLuBE3',
"Program log: wtf is this thing's owner: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
```
👀
there are some rock paper scissor games coming out, is there a way to obfuscate the user's choice so that the opponent couldn't see it
ill try lol
u crazy man
Hacky thing to try:
```.rs
#[account(
    init_if_needed,
    payer = signer,
    seeds = [b"muh seed"],
    token::mint = spl_mint,
    token::authority = {
        msg!("ostensible owner: {:?}", usePDA.key());
        msg!("wtf is this thing's owner: {:?}", user_token_account.owner);
        usePDA // maybe usePDA.clone() if you get an error
    },
    bump = thebump
)]
user_token_account: Account<'info, TokenAccount>,
```
yeah, when it's created, the authority is the same as the authority im specifying when modifying it, i just double and triple checked :/
but ill have to rethink to only use ints
yeah its a multiplier (game) that can be a decimal
You can always use a numerator and a denominator separately, as u64s or whatever (don't quote me on that)
it is also expensive in terms of compute budget compared to integer operations. If your call is heavy that might cause issues down the road
Why did you want to use floats in the first place? To get like a percentage of something?
I will multiply by 10 and just have not as granular inner workings
damn ok
I'm not sure anchor supports this yet (it's pretty rare to use them, tbh)
Ahh, any way to pass in floats?
BN is also purely for integers, so will auto-truncate any float stuff
Is the owner/authority of that token account definitely `usePDA`?
Because im retarded 😄
I have the same terminology than you in mind for some reason. But definitely owner vs authority sounds more distinct and less confusing that program vs user-space owner
Right, so why are you using floats at all? I'm confused about that
this is all i get
```
'Program 8yBiqm4eZjDQACD5JnZrvoKB6nyE9xDh3yvMiPnWtTpL invoke [1]',
'Program log: Instruction: DoStuff',
'Program 11111111111111111111111111111111 invoke [2]',
'Program 11111111111111111111111111111111 success',
'Program 11111111111111111111111111111111 invoke [2]',
'Program 11111111111111111111111111111111 success',
'Program log: Custom program error: 0x7df',
'Program 8yBiqm4eZjDQACD5JnZrvoKB6nyE9xDh3yvMiPnWtTpL consumed 51089 of 200000 compute units',
'Program 8yBiqm4eZjDQACD5JnZrvoKB6nyE9xDh3yvMiPnWtTpL failed: custom program error: 0x7df'
``` 
😦
<@!134416332509675520> Thanks, I ended up doing something like that. You end up losing the decimals when you try to transfer. Im running into issues passing in f64 as a type for an instruction argument, is that not supported? Trying to us BN on the JS end.
yeah im just repeating what u said lol
program owner, the token program, like u said, and the user owner, which i guess is the same as authority
Can you show the full program log?
sorry i meant token accounts
yeah that's what im doing. here's what i have, and it's the same for the context in which i init or just modify
```
#[account(
    init_if_needed,
    payer = signer,
    seeds = [b"muh seed"],
    token::mint = spl_mint,
    token::authority = usePDA,
    bump = thebump
)]
user_token_account: Account<'info, TokenAccount>,
```
but i still get the token owner constraint error from anchor
I think it's much easier to think in terms of "which program can mutate this account" (program owner) and "how does something or someone sign for this address" (depends on address type: keypair addresses use their private key, PDAs get their deriving program to sign for them)
System accounts don't store any separate owner field etc., it's just their address
What do you mean for system accounts? What's the user space owner of a system account? I guess the address itself?
yeah the naming is awful lol, i also know for system accounts there are 2 owners, program owner and user space owner
And you have to provide `token::authority` whenever you init a token account, regardless of whether it lives at a PDA
Anchor uses "authority" for "whoever needs to sign", and owner for "program that can mutate or spend this thing's money"
The spl token program unfortunately picked a crappy name for the token authority thing, and *also* called it "owner"
`owner` in anchor means the *program* owner, which for a token account is always the spl token program
`token::authority` is the "owner" of the tokens, aka whoever needs to sign in order to move them
couple things im confused about for TokenAccounts

1. seems that if I init a PDA token account, i have to provide `token::mint` and `token::authority`. What exactly is the authority?
2. seems that if i access that same token account later i get a `ConstraintTokenOwner` error. I assume this is related to the `owner` field defined in here
https://docs.rs/anchor-derive-accounts/0.19.0/anchor_derive_accounts/derive.Accounts.html
so what exactly is the difference between authority and owner?
Whoops, think my discord got confused about the timeline, not sure why I had that message in my view
Gotta run anchor build first
Mm, you can do `(the_lamports as f64) * 9.123` for example. Not 100% sure why you want to do that though
This is what worked for me. Thanks man! Don't know wtf the issue is/was
super dumb question... but how do we multiply lamport amount by a float? how are decimals handled?
I want to receive the compiled message as an instruction data, but it says the BorshSerialize is not implemented for Message structure. Is there any workaround to receive raw data and transit it into Message format?
Great! This also means I wont't need the `is_initialized` field.
Yep! This is actually exactly what the `#[account(zero)]` annotation is for 🙂 It says "I haven't had a chance to set this thing's discriminator yet"
How can I initialize it before and have anchor just write state to it
Is it possible to just check whether an account is empty? I have an account that cannot be initialized using CPI (it's too big), so I need to create it before I call my contract. But if I initialize it in an instruction before, anchor will complain that it doesn't match the 8 byte discriminator.
protip
```javascript
TypeError: src.toArrayLike is not a function
```
means you're passing in `this_arg` as a string and not using `new anchor.BN(this_arg)`
anyone can explain this error to me installing anchor ? warning: /usr/local/include/string.h:50:26: error: unknown type name 'hashkit_string_st'
Don't think so, no (I only use it when some other program does, e.g the spl token program)
is there any point in using `solana_program::program_option::COption` vs the std `Option`?
AccountInfo is solana's low-level type for an account. Calling `.to_account_info()` on an Anchor account gives you the low-level solana account that was used to create the anchor one.
how to understand to_account_info() works?
Sometimes code just need a little discord encouragement 😌
I.... don't ..... even.... now it works just fine lol. zzzzz
sure, let me modify the code to that option again
Could you say more about what goes wrong then? Think I'm confused
no, just need a regular account
Do you need the account to be a token account? (The wrapped-sol approach)
I'm confused, why doesn't a system_program owned account work?
zzz this is so annoying:
- I need a treasury account for SOL balance which the program would be able to debit.
- I tried passing a PDA derived from programID - this account cannot be "init" because then it requires token::mint and token::authority which ends up creating a wrapped sol account. If I dont specify init, and transfer lamports for rent before calling the program, then the account is owned by the system program and the instruction will not allow it because it is not owned by the program.
- I also tried passing in a random account generated with Keypair.generate(), which I also added lamports for rent. My plan was to transfer the ownership of that account to a PDA owned by the program, but then again, I cannot transfer this ownership because this new account is not owned by my wallet. I also tried to add that treasury account as signer (I assumed it would need to sign to transfer the ownership) but that didnt work either.
I'm not sure about the cli syntax to close that account, but I'm pretty positive there will be a cli command to do it
Ok, so the account is owned by the spl token program
Mm, every account in solana has a program owner (there's also other notions of ownership, like token ownership, that are separate concepts—only program ownership is relevant for closing an account)
this is the account: https://solscan.io/account/FEUBkELRxknLBLRK6NW4twh68bGmpHpYNkEpyj6WKMBh?cluster=devnet
the owner is not a program, but my wallet address
Which program owns the account? That's the important thing—in general you always have to ask the owning program to close the account for you
my wallet is owner of an account, how do I close that owned account (i.e. transfer funds back to my wallet)? Trying to do that via cli
im gonna come back tomorrow i think you answered my question already
How is the multisig implemented?
I think that sounds ok (not totally sure if it's the best solution, but nothing sounds impossible/wrong, lol)
that is my train of logic. unsure if it's flawed.
I want a multisig as an ata owner because the funds there would be controlled by a group rather than one person, but an ata specifically because the group would choose to transfer funds into and out of the multisig wallet (multisig pda i guess).
I want to make a multisig wallet the owner of an ata on spl token program.  custom token. Transactions in the program therefore need users (my multisig one of them) to sign, before going through. Everyone but multisigs would just be a useAnchorWallet kind of thing, but because the multisig is only a pda, it is only an address, and thus has no private key, and cant be a keypair, and can't sign
Can you say more? It's true that PDAs aren't keypairs, but that wouldn't necessarily mean they can't be used in a multisig (they can still be signed for)
If it's owned by your own program though (I don't know, maybe you also want to store some data in there), then it doesn't really matter—you don't need a signature in order to transfer money from your own accounts
if its a pda, isnt that only an address? eg: it's not a keypair, and can't really sign...
apologies for the interruption. I'm trying to set up a multisig but it says on the docs a multisig can be used where "pubkeys" are used, and i'm in turn facing a similar "i need a keypair" problem
Whether you need to sign for it depends on which program owns it—if it's going to be owned by the system program, then yeah, you'll want it to live at a PDA so your program can sign for it (necessary in order to convince the system program to transfer its money)
That's the thing - my treasury account needs to be signable by the program (so it can debit it). So that probably means it should be a PDA? and to initialize it, I would need to send it lamports for rent before it is used by the program?
No—mutating/spending money is entirely about which program owns the account. E.g. you can have a token account (always owned by the spl token program) that lives at one of *your* PDAs. Maybe I'm misunderstanding your question though 🤔
If all you're using an account for is to hold sol, you actually don't even need to init it—you can just send it money and it'll just magically exist (though be aware that even empty accounts require a bit of rent, so if you send too little sol the rent collector will just take it from you 😆)
with custom token you would use mint account and do mint.createAccount(), but how do you do it for a regular account (to hold the vanilla SOL balance)
Does anyone have example code how to create a new account in JS/TS?
Given this, can account which is derived from a program (i.e. PDA) hold balance (it would be owned by the system program). And in that case only that program would be able to debit the account, since only the program can sign for that account, right?
Essentially, if an account lives at a program derived address, only that program can do debit the account / mutate account data, right?
the owner is the token program, right, thanks
You can't pay for creating accounts with sol from an ATA
i am stumped i tried to add field to my struct and now i get ``     RangeError [ERR_OUT_OF_RANGE]: The value of "offset" is out of range. It must be >= 0 and <= 102. Received 3821286566`` for everything
so did you find a workaround to this? I'm trying to send SOL from an ATA, and bumped into a similar problem to you
do I need to instantiate a new intermediary account and use it?
if I usually used a CPI call to do a transfer instruction, does that mean that if I'm passing that account to a different CPI call, I won't be able to trigger the transfer? even though I'm passing the signer?
yeah it should
The vec's provided is empty and the strings are "Random" and "RAND" which should fit the space constraints right?
here 256 bytes mean limit right, so you have to provide data according to it, see provided field exceed the limit or not
for holding data length
just tried it, I'm getting the same error. What's the reason for the extra 8?
try this one
8 + 8 +32+32+256+256+256+256
But the error is the same
So I've tried 8+32+32+256+256+256+256 which seems to follow the space constraints
you have to calculate the total bytes, like 
u64 take 8 bytes
Pubkey take 32 bytes
In string we have to provide limit like upto 256 bytes or so
same with vec
```    #[account]
    pub struct VaultAccount{
        pub mint_fee: u64, //divided by 1000 for minting fee, so 1 is 0.1% fee
        pub vault_mint: Pubkey,
        pub authority: Pubkey,
        pub vault_name: String,
        pub nft_creators: Vec<Pubkey>,
        pub nft_symbol: String,
        pub nft_accounts: Vec<Pubkey>

    }```
share your `VaultAccount` struct
```    #[derive(Accounts)]
    #[instruction(mint_bump:u8)]
    pub struct InitializeVault<'info> {
        #[account(init, payer = authority, space = 8+64+64)]
        pub vault_account: Account<'info, VaultAccount>,
        #[account(mut)]
        pub authority: Signer<'info>,
        #[account(init,
            space = 8+64+64,
            payer = authority,
            mint::decimals = 16,
        mint::authority = vault_account,
        seeds = [b"mint".as_ref(), vault_account.key().as_ref()],
        bump = mint_bump,
        )]
        pub vault_mint: Account<'info, Mint>,
        pub rent: Sysvar<'info, Rent>,
        pub token_program: Program<'info, Token>,
        pub system_program: Program<'info, System>,

    }```  Tried to allocate ore space to both accounts and still get the same error
I think you are providing inappropriate space, try space = 8 +64 +64
Any ideas why? It seems pretty straight forward
I keep getting ``` Error: 102: The program could not deserialize the given instruction``` on this instruction ```    #[derive(Accounts)]
    #[instruction(mint_bump:u8)]
    pub struct InitializeVault<'info> {
        #[account(init, payer = authority, space = 64+64)]
        pub vault_account: Account<'info, VaultAccount>,
        #[account(mut)]
        pub authority: Signer<'info>,
        #[account(init,
            payer = authority,
            mint::decimals = 16,
        mint::authority = vault_account,
        seeds = [b"mint".as_ref(), vault_account.key().as_ref()],
        bump = mint_bump,
        )]
        pub vault_mint: Account<'info, Mint>,
        pub rent: Sysvar<'info, Rent>,
        pub token_program: Program<'info, Token>,
        pub system_program: Program<'info, System>,

    }```   ```    pub fn initialize_vault(ctx: Context<InitializeVault>, _mint_bump: u8, vault_name: String, nft_creators: Vec<Pubkey>, nft_symbol: String, mint_fee: u64) -> ProgramResult {
        let vault_account = &mut ctx.accounts.vault_account;
        vault_account.mint_fee = mint_fee;
        vault_account.authority = *ctx.accounts.authority.key;
        vault_account.vault_name = vault_name;
        vault_account.vault_mint = *ctx.accounts.vault_mint.to_account_info().key;
        vault_account.nft_creators = nft_creators;
        vault_account.nft_symbol = nft_symbol;
        Ok(())
    }```
Thanks!
"anchor test --skip-local-validator"
just do
and when you test
you can manually run solana-test-validator
if anchor test by itself doesnt work
I don't have a test validator running in the background or anything
Does someone know why I keep running into this error when I run ``anchr test``? ```Error: failed to get recent blockhash: FetchError: request to http://localhost:8899/ failed, reason: connect ECONNREFUSED 127.0.0.1:8899```
I know, but I was trying to use associated token address for the program itself
that's already in the context (the first anchor parameter on the rust function) automatically:
ctx.program_id
Can you pass program's own ID as to its instruction?
https://github.com/project-serum/anchor/blob/08174e84a6db0e945e93a91bb1f2770365f68f4c/ts/src/error.ts#L53
love it
Never mind... looking at anchor_client
await provider.connection.getAccountInfo
How do I do this, but in Rust
`Custom program error: 0xbc4`
3012??
how does one deciper this???
Hi, I'm trying to install anchor on MacOS with this command line: cargo install --git https://github.com/project-serum/anchor anchor-cli --locked, and i keep having this issue as it shows on the terminal picture above, any help would be welcome, thank you
can program also have an ATA?
sure
yeah, but I probably need to add constraints on those accounts so they match the native_mint and spl_token no?
authority also needs to be an account
you might need to pass in the mint as an account as well
spl_token::native_mint::ID
whatever the sol mint address is
I see. What would the values for those be if I want to use a SOL token account?
with mint and authority
`token::mint`, `token::authority`
you need to use the right synatx
yeh, you can't init a token account like that
oh right
36 | #[derive(Accounts)]
   |          ^^^^^^^^ function or associated item not found in `TokenAccount`
usually there's an error message
Why does this not compile?
#[account(signer)]
    pub initializer: AccountInfo<'info>,

    #[account(
        init,
        seeds = [b"somethign".as_ref(),],
        bump = token_bump,
        payer = initializer
    )]
    pub pda_account: Account<'info, TokenAccount>,
Especially sine localnet will keep that pda balance ongoing every test you run >>
Hello, hoping someone can help me with some debuggin too. How can you check the sol balance of a pda before and after a transaction in your typescript testing? Getting the account info with `const pda_info = await provider.connection.getAccountInfo(pda)` and printing it seems to always print the latest, even if I have await.. what am I missing?


//////////////////////////////////////////////////////////////////////////////////////////

you got to pass in a commitment or config the provider object to not default to recent
Just tried, I get this error  -> Error: Using Connection with default commitment: `recent`, but method requires at least `confirmed`
Boom. That did it. Thank you. 🙂
create the tx, that returns the sig, then call `getTransaction` and it returns the tx object with a fee field
So uninstall that npm thing and install the anchor cli directly from cargo (explained in the installation instructions)
I think there is, looking at the `Provider` class looks like it defaults to recent
Sounds like you're on mac, in which case you shouldn't use the npm anchor-cli package (the installation instructions actually say this, it's just easy to miss)
not sure it is related, I want to get it in my typescript tests to ensure amounts are correctly calculated in program side
Has anyone ever encountered this error before? Trying to install dependencies, but hitting a snag.

```
➜  projects anchor --version
Only x86_64 / Linux distributed in NPM package right now.
Trying globally installed anchor.
Globally installed anchor version is not correct. Expected "anchor-cli 0.18.2", found "anchor-cli 0.19.0".
```
Cool. Not sure if there is a tweak/option to the provider or RPC call itself that allows to wait for confirmation.
do what I just did
ty ser
ah that did it
hi guys, is there a way to get fees for a transaction? can't find anything in docs
lemme try
I am not certain about whether the rpc call waits for confirmation. Have you try a dumb sleep between the call and the `getTransaction` ?
```
testCase() -> {
  invokeInstruction()
   makeRpcCall()
}
```
it should be, all the calls happen within the context of a test case
can you make a channel or thread for faq's?
is the test validator still running when that `getTransaction` function gets called?
I can see the logs in `.anchor/program-logs`
hey I'm trying to check out tx logs from a test context. I create tx and then use the signature `provider.connection.getTransaction(signature)` but get a null response
ok let me try
(Temporarily forget the custom error)
Try doing this instead:
```.rs
constraint = {
  msg!("actual token amount = {}", token.amount);
  token.amount == 1
}
```
I cannot ... compiler throwing error its a field and not a function
I really need to make myself a scratchpad program for quick checks like that
Purely guessing here haha
oh ok let me try this out
if it is the same type as used inside the function, it might actually be `.amount()`?
oh so .amount does'nt gives the balance of that token ?
You might be right that it is simply `.amout` that is wrong
but that does'nt makes sense to me as I'm logging on frontend the amount and checking on explorer as well and the token account balance for that user is 1 but the error contradicts
thanks let me try this out
original message: https://discord.com/channels/889577356681945098/889702325231427584/921100903191306240
```rust
#[account(
    init_if_needed,
    payer = signer,
    seeds = [b"muh seed"],
    token::mint = spl_mint,
    token::authority = {
        msg!("ostensible owner: {:?}", usePDA.key());
        msg!("wtf is this thing's owner: {:?}", user_token_account.owner);
        usePDA // maybe usePDA.clone() if you get an error
    },
    bump = thebump
)]
user_token_account: Account<'info, TokenAccount>,
```
That might help you, let me see if I find it
I saw alan post a snippet to run prints from the constraint
ah wow, ok.
I'm facing some strange issue . From frontend I'm sending a token account of a owner which has balance 1 and on program I'm checking on constraint that amount of that token should be 1 but what happens is sometimes the txns go through and sometimes it throws the error 0x12f = 303 which means the amount is not one

``` 
  #[account(mut, 
        constraint = token.amount == 1   @CustomError::TokenAmountError, 
        constraint = token.owner == owner.key()  @CustomError::TokenOwnerError
   )]
   pub token: Account<'info, TokenAccount>

.....

#[error]
pub enum CustomError {
    #[msg("You are not authorized to call this action.")]
    Unauthorized,

    #[msg("Overflow error")]
    Overflow,

    #[msg("Token hasn't unlocked yet")]
    NotUnlockedYet,

    #[msg("Owner does'nt hold this token")]
    TokenAmountError,

    #[msg("Owner of token and token account passed does'nt match")]
    TokenOwnerError
}

```
Oh thank you!   so the #[account(init, seeds = [b"myseed".as_ref()], bump=mybump, payer=user] macro is what actually creates the account at that address?
Thanks for the clarification. I'll go back to school now
A very common example of an account with data that lives at a PDA is an associated token account. It's a token account (owned by spl token program), so definitely has data, but its address is derived from the associated token program.
PDAness only affects how you *sign* for the address (only the deriving program can sign for its PDAs)
And yes, you can have whatever kind of account you want at a program-derived address (well, almost, for obscure solana reasons it can only be <= 10kb in size, not the usual full 10mb—but other than that it can be whatever kind of account you want)
Yes, PDA = program-derived *address*, not account!
Program side: `ctx.accounts.my_token_account.amount()`
Definitely!
going to just try it out -- probably the best way 🙂
i guess there is no reason the PDA couldn't have data as well.... and probably for most programs they do
like the famous escrow example has the PDA "own" a completely separate "account"
until it is successful -- but even then its just an address -- i.e. a key -- though I guess any data would be written to it?  idk now actually 🙂
yes - I was wrong -- i for some reason thought "FindPDA" was going to make an account --b/c under the covers it calls "CreatePDA"
Nevermind me
Haha I think I'll confuse you further
I always only thought it was A for Address
Thanks yeah!  I guess the fact that accounts need to still be initialized even after you "found" a PDA should have tipped me off
Maybe I'm wrong though, I just googled and someone uses the acronym for Program Derived Account
I agree. You might want to see PDAs as simple signers. Calling them "accounts" might throw you off
How can I check amount of a token account inside the anchor ?
I think its the latter --- PDAs are accounts that are owned by the program -- but a program can have multiple PDAs
this might be a dumb question - but do PDAs have data or are they only used to own other accounts which have data?
In my test code, I'm trying to switch the provider (and the associated wallet), but it seems the program instance derived after switching the provider still uses the old provider. What am I missing?

const secondWallet = new anchor.Wallet(Keypair.generate());
  const secondProvider = new anchor.Provider(
    provider.connection,
    secondWallet,
    anchor.Provider.defaultOptions());
    anchor.setProvider(secondProvider);
    const programOverride = anchor.workspace.SeekersRoyalties as Program<SeekersRoyalties>;
You should likely ask this in the <#889584618372734977>  channel, as it is more closely related to the language specifics on how macros work.
Or any solution to changing the declare_id! value at compile time ?
Can someone tell me why declare_id!("ABC...") works when passing a string, but when using declare_id!(include_str!("filename.txt")) it doesn't because it cannot convert &str to Pubkey?
Found it in source code. nvm
ok thanks <@!134416332509675520> 🙂
Using `size_of` or relying on `Default` just won't cut it (no way to automagically decide how big you want those strings to be)
Yeah. Also, the fact that you've got some dynamically sized types (the Strings) means that you *have to* calculate the space manually (you need to decide how big you're willing to let those strings get)
<@!134416332509675520> I'm trying to find a link to TOML specification for anchor. Can I have multiple providers?
I want to use different wallets in each.
this is my struct I assume I should just go and calculate that manually rather then rely on size_of? 😄 
```#[account]
pub struct MyAccount {
    pub myKey: Pubkey,
    pub myKey1: Pubkey,
    pub myKey2: Pubkey,
    pub myKey3: Pubkey,
    
    pub string1: String,
    pub bool1: bool,

    pub num_32: u32,
    pub num_32_1: u32,

    pub num_64: u64,          
    pub num_64_1: u64, 
    pub num_64_2: u64, 
    
    pub status: Status, // enum
}
```
ah, maybe just me being lazy.. 2 secs let me sanitize it a bit
No guarantee that `size_of` will work in general!
Can you show your account struct definition?
If you want to mutate some account's data or spend its money, you must go through its owning program (you need to ask it, somehow, to do the mutation/spend the money for you)
did you ever find a solution to this? I'm also running into 
```Error: 102: The program could not deserialize the given instruction
```
but I just defined size as this so I assume it should work 🤷 
```
 space = 64 + size_of::<MyAccount>()
```
Ok, perfect.
Got it, the rule in solana is that only an account's owning program is allowed to mutate its data or spend its lamports (no exceptions)
Basically, is mutation via program instructions the only way to mutate the data?
The question is whether only program can mutate this data, or does the wallet that deployed the program also have access to it?
Sure. So when you want to init a data account i.e. Account<'info, DataType>, this account is initialized and its owner is set to the program id
Could you say more about this q? (Or did you already get it answered?) Not sure I understand what you're asking 🤔
Can I have more than 1 wallet? in the test code?
Yeah, this is a funny quirk of how base58 encoding works—you would think "1111111...111" would be have all its bytes set to 1, but no, 0 gets encoded as "1"!
BTW, can someone point me to an example where RPC call is done (signed) by non-wallet account?
Interesting!
Yeah, also Pubkey.default.
system program address
how can i take square root of a u128 , i used precise number  from spl_math crate but sometimes i am running out of compute units so what is the effecient way to handle square root
i.e. uninitialized
is '11111111111111111111111111111111' the value for "empty" Pubkey?
in the JS/TS tests, is it possible to re-run the validator after each test case? the problem is that tests leave state behind which limits what you can test against
but this is signing with the PDA, I get that. I was asking about data account that the program owns. I'm guessing this is done under the hood by solana
https://github.com/project-serum/anchor/blob/db193d824887f12881c93853f3c4821cca5d09b1/tests/lockup/programs/lockup/src/lib.rs#L480
great, thanks
This is why all accounts are owned by the system program by default
Only the program that owns an account has permission to change data on it
If a program owns an account it can changes the data on that account
So the token account owner is the PDA for that reason. The escrow example is a bit dumb though. You should transfer tokens to an intermediate account. You don't want to transfer ownership of an ATA
how does that work for a data account then? How does program sign the data mutation transaction?
Basically the program can't sign, only a PDA can sign
All accounts are owned by programs. PDAs only act as signers in some instances
Isn't the signer the one that sends the transaction? Technically, anyone can do that. I want it only to be possible for the wallet that initially deployed the program to be able to call that instruction.
Just make that account be a signer
All accounts are owned by programs. What we can set to allow a wallet or a program to transfer authority/decrease an account balance is to set the user-space ownership aka authority
absolutely, because they can have many accounts under escrow and to find the correct one for each user
aaaaah ofc
Yes so I think that is to set the "user-space" ownership, which is different from the program ownership
line 54
let (pda, _bump_seed) = Pubkey::find_program_address(&[ESCROW_PDA_SEED], ctx.program_id);
        token::set_authority(ctx.accounts.into(), AuthorityType::AccountOwner, Some(pda))?;
can you show me the exact line you refer to in the escrow example, when you say "the account under escrow is put under ownership of a PDA"
well if you make a data account with init, the account.owner will = program id
From the Solana Docs (https://docs.solana.com/developing/programming-model/calling-between-programs#program-derived-addresses) "Using a program derived address, a program may be given the authority over an account and later transfer that authority to another."
I believe PDAs **are** how you'd make a program own an account, actually
Hi <@!134416332509675520> 
Would you please check my DM?
I have shared my code
Are there any security implications to a data account being owned by the program itself, compared to being owned by a PDA?
The reason why I ask is that in the escrow example, the account under escrow is put under ownership of a PDA. Would putting the program as the owner not be secure enough?
Hi <@!134416332509675520> 
Would you like the code for this one?
- create an account to store the program data
- add it to the context and init the data on the initialize function
I've seen people ask before and I believe they do the same. `pub initializer: Signer<'info>` is the new, cleaner way to run that validation.
Thanks. Will do that then.
how about using the anchor program object to build the instruction only (`program.instruction` namespace), then build the tx yourself, sign it with a brand new `const wrongDude = Keypair.generate()` and send it using a plain web3.js `connection`?
Oh, is there any difference between:
#[account(signer)]
pub initializer: AccountInfo<'info>,

and 

pub initializer: Signer<'info>,
Btw, I want to add some tests to make sure that non-program-owner cannot call certain instructions? How do I specify different caller in an RPC call other than my wallet. I think the wallet automatically signs all transactions, right?
Glad to help! It's a good inspiration for a cookbook entry
Thanks for this tip, this will be very useful in the future 🙂
oh, found it, but does not say much
Where can I see the logs?
I've stopped my local validator and ran pure "anchor test" and now it was properly updated. I never got an error about running it more than once. That is weird indeed.
You should also check the confirmation levels you're using to get the account
The only times I've seen an account not update the data on it are
- not set as mut
- validator is slow and you need to sleep / wait for the account to be confirmed
Add a msg! Call to say you've updated you're data
Have you tried storing the transaction id and looking at the program logs
If it had been initialised
You should get an error message if you ran it more than once
Yeah. But what it could be is that I'm running validator separately. And I did call this instruction several times. That likely means that on consecutive calls it would not initialize the account (since it was previously already initialized) and it would not be mutable?
Are you awaiting your transaction function call in TS
Try sleeping and waiting for your local validator to fully process the transaction
The other most common issue is that you're just not waiting long enough
If it's init in the same transaction then it's automatically set mut
it was initialized in the transaction, I guess it would not need to be specified as mut then?
Have you set royalty account to mut
<@!248066053161222144> question for you friend, for some reason this code here does not update the account properly. I dont get any errors, but the treasury_bump is left uninitialized (=0) after initialize() is executed - while the expected value would be 253.

pub fn initialize(ctx: Context<Initialize>, treasury_bump: u8) -> ProgramResult {
        let account = &mut ctx.accounts.royalty_account;
        account.treasury_bump = treasury_bump;
        Ok(())
    }
It seems like you need to read up on PDAs and also creating accounts via a system program call on chain
If you look how the accounts structure is defined you will see this is not a PDA (they have a seed and bump). This is just initializing regular data-holding account. Now why you need this account as a signer is so you can transfer the ownership of it to the program.
#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 8 + 8)]
    pub my_account: Account<'info, MyAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}
You don't need to specify the space of the account. Anchor will do it automatically unless you're using strings or vectors in your struct
Hi, this is really a beginner question, but I cannot understand quite a bit.

This code is a part of anchor basic example-1
```
await program.rpc.initialize(new anchor.BN(1234), {
      accounts: {
        myAccount: myAccount.publicKey,
        user: provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      },
      signers: [myAccount],
});
```

I believe above code is initializing an account in the way of PDA, since new account is derived from another program(deployed program on rust side), and systemProgram is making it.

But I cannot understand why signers field accepts myAccount.

Isn't that new account is derived from the program?

so why signer is [myAccount]? Isn't the PDA just needs publicKey of myAccount?

Isn't that just not a PDA?

Thank you.
Yes just copy that as is and import to phantom
the contents of that file—a list of ints—is my private key? what command do you use to map it to base58?
function sig of what is being interacted with 
```
pub fn initialize_user(
    ctx: Context<InitializeUser>,
    _user_nonce: u8,
    optional_accounts: InitializeUserOptionalAccounts,
)
``` so makes sense `CpiContext` cant interact w/ it but how can I access the `initialize_user` function with CPI then?
trying to interact with a contract on chain with CPI getting 
```
expected struct `anchor_lang::Context`, found struct `anchor_lang::CpiContext`
``` when I try to pass the context to call it? 

followed this https://github.com/project-serum/anchor/blob/master/examples/tutorial/basic-3/programs/puppet-master/src/lib.rs but substituted the function calls and programs for the one interacting with.
How can I use assert.rejects to check the custom error?
OK, got it
Thanks
Wherever you put your keypair. I keep mine in a diff output folder than the default
```

// The program to execute.
const program = anchor.workspace.Basic1;

// The Account to create.
const myAccount = anchor.web3.Keypair.generate();

// Create the new account and initialize it with the program.
await program.rpc.initialize(new anchor.BN(1234), {
  accounts: {
    myAccount: myAccount.publicKey,
    user: provider.wallet.publicKey,
    systemProgram: SystemProgram.programId,
  },
  signers: [myAccount],
});

```
As seen above, we pass both the accounts and signers for the Context.


```
pub fn initialize(ctx: Context<Initialize>, data: u64) -> ProgramResult {
        let my_account = &mut ctx.accounts.my_account;
        my_account.data = data;
        Ok(())
    }
```

initialize method accepts Context and its generic type is Initialize.

But Initialize struct has no fields for signers.

```
#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 8 + 8)]
    pub my_account: Account<'info, MyAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}

```

I believe we need a signer when making transactions which modify accounts data.

So I thought that's what the 'user' filed of Initialize struct for.

But why we pass signers: [myAccount] when calling initialize method?

Is it internally used by anchor?



Isn't something like below would make more sense?

```
#[derive(Accounts)]
pub struct Initialize<'info> {
    accounts: {
      #[account(init, payer = user, space = 8 + 8)]
      pub my_account: Account<'info, MyAccount>,
      #[account(mut)]
      pub user: Signer<'info>,
      pub system_program: Program<'info, System>,
    },
    signers: ...
}

```

What am I missing?

Is the Initialize struct a subset of Context<Initialize>? since Initialize has #[derive(Accounts)] macro?

Then where can I see the full description of Context?
0x1773 = 6003, and a program's custom error codes start at 6000 now. So that would be the 4th custom error code.
where's this file located? would it not be `Keypair Path: /Users/will/.config/solana/id.json`?
Hi <@!134416332509675520> 
`failed: custom program error: 0x1773`
Would you please explain this error detail?
Do I need to specify the exact size of my account here?

```#[derive(Accounts)]
pub struct InitializeMyAccount<'info> {
    #[account(init, space = MyAccount::LEN)]
    pub my_account: Account<'info, MyAccount>
}```

What about on the client side? I'm coming from Solana with no anchor and I'm very confused as to how I perform the client-side of this instruction. Normally I would create the empty/unintialized program account with the exact amount of space, and then in the same transaction create and provide it to this instruction. Example:

```
  const createMyAccountIx = SystemProgram.createAccount({
    programId: programId,
    space: My_ACCOUNT_SIZE,
    lamports: await connection.getMinimumBalanceForRentExemption(MY_ACCOUNT_SIZE, 'singleGossip'),
    fromPubkey: ownerAccountInfo.publicKey,
    newAccountPubkey: myAccount.publicKey});


  const instruction = new TransactionInstruction({
    programId,
    keys: [
      { pubkey: ownerAccountInfo.publicKey, isSigner: true, isWritable: false },
      { pubkey: myAccount, isSigner: false, isWritable: true },
    ],
    data: Buffer.from(Uint8Array.of(0))
  });
  await sendAndConfirmTransaction(
    connection,
    new Transaction().add(
      createMyAccountIx,
      instruction
      ),
    [ownerAccountInfo, myAccount],
  );
```

However, I can't seem to find code examples of real clients. Just tests. All of the tests use this `anchor.web3.Keypair.generate()` method of creating these accounts, but is that really the de-facto way of doing it? Does anchor automatically take care of creating the uninitialized/empty account and account sizing?
can we read our anchor.toml files into React? what is the preferred syntax?
vim into the file and just copy it including the brackets
hey all. how do i get my local wallet's private key, such that i can load it into my phantom wallet?
If I wanted to reverse engineer a staking contract for learning purposes. Would that project be pure rust or should I bootstrap with anchor
the keypair? or the account? The system program owns all standard wallet-type accounts if I'm not mistaken. Though of course the keypair is your own for signing, etc.
what program
who is the owner of the keypair
when i make a new account on phantom wallet
thank you!
https://github.com/metaplex-foundation/metaplex/blob/master/rust/nft-candy-machine-v2/src/lib.rs#L19
https://github.com/metaplex-foundation/metaplex/blob/master/rust/nft-candy-machine-v2/Cargo.toml#L23
is there such a thing as "anchor_spl" module?   I want to access the "Mint" struct through it but I can't seem to get the import right - probably doing something stupid
like, whatever the case, I imagine Anchor can and will adapt. But I was also kind of relying on the manual signing and sending approach to be able to add signatures to a transaction as a means of validation from an authoritative source. If I can no longer do that, and signature data sent as parameters can not be validated on-chain (my digging has come up with nothing to emulate ecrecover()-style signature validation on-chain in Solana), then I cannot see a way to perform any kind of signature-based validation of transactions or input data... but maybe I am missing something?
looking now
by any chance: https://discord.com/channels/889577356681945098/889702325231427584/921054837695713282 😄
I feel like the interfaces I've seen for the wallet adapters have the signTransaction() and signAllTransactions() methods though, which mirror those from the deprecated methods on Phantom wallet
error is :
```TypeError: src.toArrayLike is not a function
    at BNLayout.encode (/home/gilles/Documents/perso/nft/solana/tuto-nft/buildspace_tuto_solana_rust/myepicproject/node_modules/@project-serum/borsh/dist/lib/index.js:35:37)
    at Structure.encode (/home/gilles/Documents/perso/nft/solana/tuto-nft/buildspace_tuto_solana_rust/myepicproject/node_modules/buffer-layout/lib/Layout.js:1263:26)
    at InstructionCoder._encode (/home/gilles/Documents/perso/nft/solana/tuto-nft/buildspace_tuto_solana_rust/myepicproject/node_modules/@project-serum/anchor/dist/cjs/coder/instruction.js:85:28)
    at InstructionCoder.encode (/home/gilles/Documents/perso/nft/solana/tuto-nft/buildspace_tuto_solana_rust/myepicproject/node_modules/@project-serum/anchor/dist/cjs/coder/instruction.js:70:21)
    at /home/gilles/Documents/perso/nft/solana/tuto-nft/buildspace_tuto_solana_rust/myepicproject/node_modules/@project-serum/anchor/dist/cjs/program/namespace/index.js:32:97
    at ix (/home/gilles/Documents/perso/nft/solana/tuto-nft/buildspace_tuto_solana_rust/myepicproject/node_modules/@project-serum/anchor/dist/cjs/program/namespace/instruction.js:26:23)
    at txFn (/home/gilles/Documents/perso/nft/solana/tuto-nft/buildspace_tuto_solana_rust/myepicproject/node_modules/@project-serum/anchor/dist/cjs/program/namespace/transaction.js:12:20)
    at Object.rpc [as sendSol] (/home/gilles/Documents/perso/nft/solana/tuto-nft/buildspace_tuto_solana_rust/myepicproject/node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:8:24)
    at main (/home/gilles/Documents/perso/nft/solana/tuto-nft/buildspace_tuto_solana_rust/myepicproject/tests/myepicproject.js:83:21)
```
I'm not sure it would be disruptive for Anchor specifically. the wallet adapter widely used right now is from solana-labs I believe. (just a thought, I've not looked into this much)
Hello here, thanks for the great work. As a beginner, I was trying this code but I got into a JS error when testing with 
```// Now let us try to send some SOL to a newly created keypair
  const friendToSendAccount = anchor.web3.Keypair.generate();

  await program.rpc.sendSol(10000 /*in lamports*/, {
    accounts: {
      from: baseAccount.publicKey,
      to: friendToSendAccount.publicKey,
      systemProgram: SystemProgram.programId,
    },
  });

  console.log('Sent sols!');
```
I guess for multi-sig, the secondary signature could get signed first then the transaction can be handed off to the wallet to sign and send, but doesn't the first signer normally pay for the transaction? So I feel like that may not work
so I found this:
https://docs.phantom.app/integrating/sending-a-transaction

but this makes me wonder: the signTransaction() function is deprecated on Phantom wallet now, but all the wallet adapters that I've seen leverage that function for the rpc hooks (and the new supported function on phantom is signAndSendTransaction()). That makes me wonder how disruptive this will be to Anchor once that functionality is dropped, and also for things like potential for multi-sig too.  😬
Yeah Github is sorta Google for Solana right now haha
that's how I imagined it going. I wonder if there's any documentation about this process. It seems that everything is still so new in the ecosystem that many details are often not easily confirmed through a google search
All a guess, though
Now I am wondering why simulation does not require the user to sign. But in the end the Phantom extension has full control over your private key, so it probably does sign the tx -> simulates -> displays balance change -> waits for you to click to send the real deal.
Actually I believe these two things have nothing to do with each  other. I think phantom _simulates_ a transation to display the expected balance change
yeah, I'm pretty new to everything, so I haven't used phantom too much, but I assume phantom prompts for a signature for this kind of stuff. So I am wondering how they would know what amount to prompt the user to approve
Do you mean the phantom feature?
I was wondering about transferring SOL, if you perform this on-chain as a result of some calculation, but the signature has to be signed by the client's web3 wallet before submitting, how does this approval work? I assume the client signs for the amount of SOL that they will be transferring? How does the wallet know how much SOL is going to be transferred before this occurs?
How can I get the program_id inside lib.rs?
I'm also using this code as a example of how to use find_program_address, maybe can help you https://github.com/anatoliprodev/custom_auction/blob/008458453f4385fa806f249cae1d6506a8465b8e/src/instruction.rs
<@!134416332509675520> tagging u since u were part of that convo
trying this now, is there no need to specify that lamports left the escrow account to bob's account?
ty!
Perfect
https://docs.rs/anchor-lang/latest/anchor_lang/prelude/struct.Pubkey.html#method.find_program_address
Yes there is also a find_program_address. Let me see where it is
yeah
You mean derive a PDA address from seeds in a contract?
is there anyway to easily derive addresses in the function
Thank you very much
Just removed the baseAccount from signers and it worked
I ctrl + left click on the log and I was moved to a signer verification function
It's exactly this
You probably have another issue though, here. You are passing baseAccount (a PublicKey) as signer to the tx. However `signers` is an array of Keypair or Signer objects (those are the types which have a `.publicKey` field)
If you want to display a pretty version for instance, you can do `baseAccount.toString()`
Actually the first log shows you that baseAccount is itself an object of type PublicKey
I'm sure that is something really silly
Hi guys. I really don't understand what I'm doing wrong here. Console.log baseAccount show me he have a public key but when I try to console.log baseAccount.publicKey he returns me undefined.
ok yeah - that was it
b/c I see this: error: failed to download `solana-frozen-abi v1.9.1`
i'll try upgrading solana
i made a new anchor project and then got this on build
is there a usual cause when seeing this error:
consider adding `cargo-features = ["edition2021"]` to the manifest
Heh
this is gonna take a while lol
<@!134416332509675520> well, when i condense it into a seperate program and test it, it works, i have no clue what the issue is
o


//////////////////////////////////////////////////////////////////////////////////////////

Nevermind, I added an `if (wallet) {}` around the `provider` initialization. That should do I guess.
Just did that, got this error,

```
Argument of type 'AnchorWallet | undefined' is not assignable to parameter of type 'Wallet'.
  Type 'undefined' is not assignable to type 'Wallet'.
```
useAnchorWallet
Can someone help ? Trying to run anchor build

Things I have tried - Uninstalling solana and installing again but same response

anchor cli version - 0.19.0
solana cli version - 1.9.1

```
BPF SDK: /home/mship/.local/share/solana/install/releases/1.9.1/solana-release/bin/sdk/bpf
cargo-build-bpf child: rustup toolchain list -v
cargo-build-bpf child: rustup toolchain link bpf /home/mship/.local/share/solana/install/releases/1.9.1/solana-release/bin/sdk/bpf/dependencies/bpf-tools/rust
error: not a directory: '/home/mship/.local/share/solana/install/releases/1.9.1/solana-release/bin/sdk/bpf/dependencies/bpf-tools/rust/lib' ```
For this piece of code, 
```
const wallet = useWallet();

const getProvider = async () => {
   const connection = new Connection(
      "https://api.devnet.solana.com",
      "processed"
    );
    const provider = new Provider(connection, wallet, {
      preflightCommitment: "processed",
    });
    return provider;
};
```

The `wallet` is of type `WalletContextState` and the constructor for `Provider` expects a type of `Wallet`.

Hence I get this error, 
```
Argument of type 'WalletContextState' is not assignable to parameter of type 'Wallet'.
  Types of property 'signTransaction' are incompatible.
    Type '((transaction: Transaction) => Promise<Transaction>) | undefined' is not assignable to type '(tx: Transaction) => Promise<Transaction>'.
      Type 'undefined' is not assignable to type '(tx: Transaction) => Promise<Transaction>'.
```

**Any workarounds?? **I was thinking of using an older version of `@solana/wallet-adapter-react` so that it doesn't return a `WalletContextState` which I believe is something recently implemented.
basically someone will own the account at pda2 -- or will own a token associated to it - so want them to be able to point back to pda1 who is their "parent"
Ok thanks -- just checking that general its ok to store keys in data  -- but I guess that should have been obvious
Not sure one is better than the other, but I often use the seeds approach (just one less thing to store in an account). Guess it depends on what you're trying to do/how you want to remember your addresses.
will try with the data approach
Is it possible if I can have multiple anchor versions installed and switch them accordingly ?
If i want to tie a new accounts PDA (pda2) to another PDA (pda1) -- is better to make pda2 include pda1 in the seed?  or put pda1's address in pda2 account's data?
ahhhh 🤦‍♂️ I was missing that on the Program A (the one doing the cpi) thank you again. Do you guys have a tip jar? I feel like I should be giving back after all these silly questions 😂
Nope, you actually can't sign from the client for a PDA (only a PDA's deriving program can sign for it!). That error means you forgot to mark the account as `#[account(mut)]` in your rust program.
in this case, do you need to provide anything in the `signers` array on the client? Right now I just pass something like this;
```            {
                accounts: {                                
                    pdaAccount: pdaAddress,
                    otherAccounts..     
```
But I run into this error, where I see the `<pdaAddress> writeable privelege escalated`;
```
Cross-program invocation with unauthorized signer or writable account
```
which I guess means I am not signing properly
Got it. Did you get your earlier question answered then?
A multisig wallet is an account struct at an address that does the multisig magic (owner vec, signing, checking signers etc). But the actual address used during transactions isn’t the multisig itself then. It’s another key pair
Nope. In general in solana you always have to pass in any accounts your tx cares about (no exceptions).
Is it possible to init a PDA account in Program B via CPI from program A without the client having to pass in the PDA? 

I was hoping to generate seeds and do the findProgramAddress etc inside of Program A, but I don't think I really understand why that can't be done without the client passing in the pda
something like that: https://github.com/project-serum/anchor/blob/master/tests/chat/tests/chat.js#L7 would setup the wallet properly. Are you using something similar?
I suspect something it not right in `const provider = getProvider();`
can you print `provider.wallet.publicKey`
Can someone help me with this error?: "Wrong input type for account "user" in the instruction accounts object for instruction "startStuffOff". Expected PublicKey or string". More details: https://stackoverflow.com/questions/70403156/wrong-input-type-for-account-user-in-the-instruction-accounts-object-for-instr
You could of course store lamports on an account owned by your program though?
If I understand your question, no. What people usually mean by a wallet is an owned by the system program that just stores lamports.
Or rather, do all accounts from all programs, wallets, everything, take up space and are located on the system program
Can the pubkey of a walletkeypair also be an account struct on a program?
As a separate observation from a very new solana/anchor dev, I am surprised that (for a Metaplex NFT transfer) the developer has to handle the lamport transfers to pay each creator's cut themself before doing the token transfer.  I guess I figured the cut would be taken automatically when the token is transferred, but it does make more sense now.

Trying to piece it together, does that mean that this transaction would fail if the NFT creators are not credited the proper percentage of the rest of the lamports transferred in this instruction?
actually if it's causing one creator to not be sent it's fair share maybe it _is_ the reason, but I'm unfamiliar
I know this is 10 days old but you've got a bug in this code, ```else if y == 4 {
                        if i.address != *ctx.accounts.creator1.key {
                            return Err(ProgramError::Custom(0x1));
                        }

        
                        let temp =  sfb_cut as u64 * i.share as u64 / 100;
                        
                        **ctx.accounts.offer.to_account_info().try_borrow_mut_lamports()? -= temp;
                        **ctx.accounts.creator4.to_account_info().try_borrow_mut_lamports()? += temp;
                    }```
it's checking against `ctx.accounts.creator1` instead of `ctx.accounts.creator4`
Don't think it's related to your problem though
Hi, I'm bit confusing with the program account and the app account, and the managing of data, can any one explain. how that actually works? and in terms of accounts and its storing of data.
where can find the explanation for the best to understand.
No guarantees, just extremely (extremely) unlikely to have a collision
✨ math ✨ haha
how does solana ensure generated keypairs are new and never before used
``program.account.yourAccountType.subscribe(someAccountAddress).addListener("change", freshAccount => {
  // do stuff with the account
});``
Never mind, found it in Discord history
https://github.com/bonedaddy/event_test/blob/main/programs/event_test/src/lib.rs
Like how do you listen to an event such as the one in this repo?
Was reading the source code and came upon it and think it can solve some of my problems
Does someone have a good example of the #[event] macro in Anchor
On that version of anchor your custom errors would start at 300, so 311 would be the 12th one.
Why am I getting this error on localhost?
`Requesting airdrop of 1 SOL
Error: airdrop request failed. This can happen when the rate limit is reached.`
If I wanted to subscribe to web sockets to get updates on a Solana smart contract - any suggested resources?
I know the docs but would like to see an example implementation

I'm trying to get to the bottom of an error. Came up 0x137 which is 311. How far down an error code list is that?
It worked!  I made the PDA and could read back the data I put in it.
Are you on an M1 mac by any chance
Do you have SOL in the wallet you use to deploy?
sorry coop -- not ignoring you - but that error is pretty grim -- did deploying ever work?
Need help deploying project.  I keep getting "Error: Deploying program failed: Error processing Instruction 1: custom program error: 0x1
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }."
frgt to change lamports to sol. tysm
anchor --version
anchor-cli 0.19.0
fwiw
I thought i was going to take down devnet or something -- so I switched to localnet and had the same
Nope, if it's working you should be able to see the change
seems to be working ok - but when I deploy a program I see 
msg 7UsTL2sy9Fblahblahblah.... 
like 180 times --
when i invoke system_instruction::transfer on localnet, it does not reflect a change in lamport/sol balance in the localnet wallets. is this normal?
oh u know what, my fault!
yea with a struct
Is it an actual account, like with a struct etc.? How much space are you using?
maybe I'm doing something wrong, but when I init a PDA I expect that it'll be funded with a minRentExempt balance but instead it's being funded a little extra + minRentExempt
if u go with the latter then no need 2 sleep
or ` const provider = anchor.Provider.local( undefined,  { commitment: 'confirmed', preflightCommitment: 'confirmed' })`
sleep
yea so do exactly what was suggested to me haha
both commitments return null


//////////////////////////////////////////////////////////////////////////////////////////

eh shit. Upon startup i want to initialize the account if it hasn't been created before, and then i want to reset counter to 0. So i send those two instructions. Now ix 1 will fail, and then not do the reset. Any thoughts without using init_if_needed?
the takeaway
- one of the issues with using `init_if_needed` is that you could end up running initialization logic twice, and unintended bugs could slip in where the already initialized account is reinit with alternate values or changed somehow
in fact, thank you for giving me a great example to share with people in the future
thank you. deleted
it leads to exactly the kinds of bugs you already ran into
I don't 🙂
unless you have a really really compelling use case
yes
So is it better to just call init, and then let the tx fail if it's already 'init'ed?
there's something i've seen in code `cfg=test` but never actually used myself
please delete `init_if_needed`though, is there really ever any reason you need to call initialize twice
Is there a way to say... use this id for testing, and this other id for deploying?
Argh! It was correct, but 167 was referring to me leaving the wrong program-id at the top. annoying 🙂
That makes sense, didn't realize I needed to do that. I tried adding the authority like this:

```rust

#[derive(Accounts)]
#[instruction(bump: u8, sym: String)]
pub struct Initialize<'info> {
    #[account(init_if_needed,
        payer=authority, 
        seeds=[sym.as_bytes(), authority.key().as_ref()], bump=bump
    )]
    pub sequence_account: Account<'info, SequenceAccount>,
    pub authority: Signer<'info>,
    pub system_program: Program<'info, System>
}
```

and then when I call it, to get the address:
```ts
const [address, bump] = await anchor.web3.PublicKey.findProgramAddress([Buffer.from("ACCT_SEED_123"), program.provider.wallet.publicKey.toBuffer()], program.programId)
```

but it errors with:
```
Error: 167: The given account is not owned by the executing program
```
trying to run ido-pool example from anchor repo. Getting error -> Custom program error: 0xa7 . Does anyone knows how to resolve that ?
I think you mean program.account.escrowState
This is a `useWorkspace()` hook I implemented for my anchor + nextjs + **Typescript** project,
```
import { useAnchorWallet } from "@solana/wallet-adapter-react";
import { Connection } from "@solana/web3.js";
import { Provider, Program, Idl } from "@project-serum/anchor";
import { PublicKey } from "@solana/web3.js";

import idl from "../../target/idl/sol_pay.json";

const PROGRAM_ID = new PublicKey(idl.metadata.address);

const useWorkspace = () => {
  const wallet = useAnchorWallet();
  const connection = new Connection("https://api.devnet.solana.com");
  if (wallet) {
    const provider = new Provider(connection, wallet, {
      preflightCommitment: "processed",
    });
    const program = new Program(idl as Idl, PROGRAM_ID, provider);
    return {
      wallet,
      connection,
      provider,
      program,
    };
  }
  return undefined;
};

export default useWorkspace;
```

I believe my way of importing the `IDL` is wrong, because in the code below, 
```
const accounts = await workspace.program.escrowState.fetch()
```

I get this error, 
```
Property 'escrowState' does not exist on type 'Program<Idl>'.ts(2339)
```

Any help?? <@!134416332509675520>  🙌
Looks like the coding gods have already answered my prays : https://github.com/project-serum/anchor/pull/1160
Hey is there a way to do a rust expand on the `anchor build` process and see what code is generated?
Yeah, seems like you would definitely want to use `init` here, not `init_if_needed`.
you can also add the authority as a seed to the PDA for the counter
it should just fail
really, you shouldn't even be able to run init a second time with the same string name
Ah. That would make sense. There’s no test right now, but I will create one.
since you don't enforce a check that the authority is the one doing the initialization
my guess is that when you run the init function a second time it overwrites the first authority
Haha I think you even told me that.
ok, i see what's happening here and it's great because it's a good example of why no one should use `init_if_needed`
is this failing test in the tests file?
Hey so there seems to be a minor issue with my counter program. If i try to use a different wallet to initialize another account with the same name as my first sequence account, the first account gets messed up and no longer works. Would anyone mind taking a look? https://github.com/ljump12/sequence_enforcer
If i mint an NFT in my code and make a PDA for the metaplex token metadata program is it going to cost 0.01 SOL or just transactions fees? https://cdn.discordapp.com/attachments/895018937161510993/921856611021094912/Screen_Shot_2021-12-18_at_1.06.35_PM.png
It is definitely not a deprecated feature
https://github.com/project-serum/anchor/blob/master/tests/misc/programs/misc/src/context.rs#L75
https://github.com/project-serum/anchor/blob/master/tests/misc/programs/misc/src/lib.rs#L101
See for instance in this case all the arguments to this program call are exclusively used for account validation (so directly in the Context struct), which is why you can see `_arg_name` signifying those are unused.
I believe this is what you would use when you want to use one or more of the arguments you pass to the program call during accounts validation
Here's an example from project Serum / anchor tests: https://github.com/project-serum/anchor/blob/master/tests/misc/programs/misc/src/context.rs#L195-L204
Hey friends, sometimes I see an `instruction` macro, like this:

```
#[instruction(token_bump: u8, mint_bump: u8)]
```

Is this an old thing? Is it documented? Can I find it in docs.rs somewhere?


//////////////////////////////////////////////////////////////////////////////////////////

so the token account which I'm transferring the token(NFT) from user is a PDA token account whose seeds are (user key + token key + "token")
what is this PDA for then?
I thought you said the token account itself was the PDA?
Got it but after transferring the token to user how do I know which token id he transferred to program. Because my seeds are based on user addy + token addy + fixed string  (2 things I can get but the issue is token account which has been transferred to program)
just use ur own seeds of course
yeah, then in typescript you can query for that PDA like so
```
let [userPDA, userBump] = await anchor.web3.PublicKey.findProgramAddress(
  [Buffer.from("user"), signer.publicKey.toBuffer()], program.programId,
);
```
its derived based on token address and user address
[user.key().as_ref(), token.key().as_ref(), b"token".as_bytes()]
just a single string? or some accounts as well?
what is the seed?
yes
I'm a beginner myself, so my help is limited. I'll ask you this: the token account owned by the program is a PDA right? Derived based on some seed?
Let me give you some context what I'm trying to do. I have transferred NFT of user to token account owned by program  and now I want to show to the user that NFT are stored in the program account when he connects the wallet.
On that same topic, are any good resources for accomplishing the above? I've yet to see a concrete example for transaction fees on custom SPL tokens... which might be popular for the new wave of blockchain games popping up (which often have on-chain fees for transactions as part of the token economics).
All good 😌
Sorry about that!
Oh my bad
I'm not the original poster haha, not sure what they did (I'm just explaining what's possible)
Thanks, make sense. Is this what you ended up doing in the end?
with some modification
this might help you
https://spl.solana.com/token#finding-all-token-accounts-for-a-wallet
(You could of course just have the client pass in that hardcoded account though—that's fine)
There's no way around passing in that account, no (a pubkey in your program isn't enough unfortunately)
no normal program accounts.
are you talking about token program accounts? cause i have an example for that
I want to get all the program accounts owned by program  for a particular user. How can I do that ? I know getProgramAccounts gets all the accounts owned by program but when I pass user public key in memcmp filter to get the users accounts it does'nt shows any results. Do anyone know how to get users account ?
I'm in a similar predicament. How did you go about implementing this. The only approach I can muster up is using an escrow account to deduct a % of the transaction. Are there any other better approaches?
for anyone who comes searching for this error (`blockstore error`) in the future - the solution ended up being (and you're not gonna believe me) - turning off Dropbox app (my repo is in dropbox folder)

I don't know why/how but it works (at least for now)

For a more serious solution <@!417857235079790592> put a lot more brainpower into it and described steps here - https://github.com/solana-labs/solana/issues/21452

I'm not too sure how one would go about changing `MAX_GENESIS_ARCHIVE_UNPACKED_SIZE` within the context of anchor, but if someone knows pls comment
hi friends, I am having trouble understanding why users cant use program keys.

say in js on program init, we use the web3.keypair() function or generate them, we also have to serve the js to client right? as it is the client side of the rpc. cant users for apps write some malicious scripts in the chrome terminal, borrowing our generated program keypairs, and authorize commands they shouldnt be able to?
Nice, thank you guys
yes
huh... okay that makes sense lol, thanks alan ❤️
One more question: the_mint is mint pubkey?
return Err(ErrorCode::MyError.into())
If i do something like this
```
return Err(ErrorCode::MyError);
```
I get 
```
expected enum `anchor_lang::prelude::ProgramError`, found enum `ErrorCode`
```
Also, i know this is a weird question to ask, maybe it's a rust noob question, but for the life of me i cant figure out how to return a custom error code directly in the program handlers
yes, that is correct. i will give you mine too
```
match &ctx.accounts.many_faced_pda.current {
    Some(State::FirstState { first_hi1, first_hi2 }) => {
        msg!("it's a variant of FirstState");
        msg!("first hi1: {}", first_hi1);
        msg!("first hi2: {}", first_hi2);
    }
    Some(State::SecondState { second_hi1, second_hi2 }) => {
        msg!("it's a variant of SecondState");
        msg!("second hi1: {}", second_hi1);
        msg!("second hi2: {}", second_hi2);
    }
    _ => panic!("aaaaaaaa"),  // fallback
}
```
What are the most common causes of this type of error?
Im getting the following when trying to call my programs initialize function in an anchor test ```Translating error SendTransactionError: failed to send transaction: Transaction simulation failed: Attempt to load a program that does not exist````
will do, thanks
you could try search the solana tech discord, might get more hits in the history there
I'm sometimes getting this error from anchor:
```
Error: failed to start validator: Failed to create ledger at .anchor/test-ledger: blockstore error
```
and it seems to be non-determenistic, eg sometimes I'll comment some stuff out, then comment it back in and the error is gone

any ideas what might be causing this? (I fear the answer might be "absolute anything")
are there a way to get the sum of all extra fee in a transaction, e.g. transaction fee + account rent fee
Ty
You can try the `#[account(init, payer = whoever, associated_token_account::mint = the_mint, associated_token_account::authority = the_user)` annotation
How can I create a token associated account on anchor?
No idea what you mean haha
so to clarify, by aligning types with solana's 8 byte word you actually save on compute budget?
Hi <@!134416332509675520> 
How can I return `Err` on the `match` - None?
It's marked as mut in general because paying requires mutability
Yeah, it's just an account, that happens to be marked as the payer for some other account's initialization (have to pay for account rent)
Just bumpi g my question
Not via the npm package (you should uninstall that). You'll have to build from source: https://project-serum.github.io/anchor/getting-started/installation.html#build-from-source-for-other-operating-systems
anchor is not avaible forWindows 10 ?

Hello everyone, i have always a problem when i install anchor
You can create multiple accounts within a single tx, no problem 👍
A question, anyone have tried to create multiple account? So I'm thinking like I need to create a post with some tags. In my mind, I  think a user will have to pay for creating the post... and the tags related. Any recommendation about this? Why do I think the user will be popped up twice to say...creating a post? 😅
we do this for a couple different reasons in the main protocol on some of the state structs, but yes, the main reason is for more memory efficient access/storage with C-level alignment
<https://github.com/blockworks-foundation/ido-pool/blob/81d3b1972617afd3f246a22c04fd24909e2bbe4b/programs/ido-pool/src/lib.rs#L132-L133>
Is it possible someone can spoof this call and provide wrong amount in the RPC call  ? https://github.com/blockworks-foundation/ido-pool/blob/81d3b1972617afd3f246a22c04fd24909e2bbe4b/programs/ido-pool/src/lib.rs#L127
looking at jet's state struct - eg this one - https://github.com/jet-lab/jet-v1/blob/master/programs/jet/src/state/reserve.rs#L113

it seems they're using `zero_copy` for more efficient memory use

and I'm guessing the `repr(C)` that they have on the config just above is probably needed because it's passed in as parameters from the user - and maybe that prevents fields from being switched around (just a wild guess)
I know this has been asked before, but does anyone have a good example of parsing an optional account using `remaining_accounts`?
ok ok I think it all clicks together
Yep
okkk that makes a lot of sense. So it's a more efficient way to handle memory. 

Would I be right guessing that that has an impact on compute budget use?
Not many (just more typing), since in solana you actually aren't currently charged per compute unit lol. (Not sure how much more compute the boxing takes though)
but zero copy only loads the bits of the array you need at the times you request them
Are there any tradeoffs to using `Box` and pushing data onto the heap? Does this cost more gas or slow down transaction processing?
regular anchor deserialization all goes into memory
ok very interesting, so zero copy is like "dumb deserialization" if I can put it that way?

what's the benefit of using it? I'm guessing speed / space requirements?
https://discord.com/channels/889577356681945098/891724485177245717/915091416336707606
but i don't understand anything about it
there was a github issue recently about switching to repr(C)
Zero copy says nah, don't actually deserialize anything—just assume those raw bytes in the underlying AccountInfo *already* look like a Whatever would in memory (this is somewhat restrictive and doesn't work for all rust types, e.g. vecs or Strings, since they store their data in the heap)
The default behavior in anchor is `Account<'info, Whatever>`, which will read the raw bytes in the underlying account and use the borsh serialization library to deserialize those bytes into a nice `Whatever` struct. This struct will live on the stack (or maybe the heap if you did `Box<Account<'info, Whatever>>`).
I see - and just for someone totally new to this whole zero copy thing, what exactly does it do and why is it important?
I'm not sure why you would need to care about this unless you're doing some kind of zero copy thing
like in general should I be trying to align my state structs? or it doesn't matter and I'm overthining?
Ah, interesting. I'm not sure then!
I've seen the jet protocol specify C and transparent on top of its structs
E.g. `#[account(zero_copy)]` already uses repr(packed) for you
You ordinarily don't have to specify those manually—when are you thinking of doing so?
ok sounds like `packed` in particular is getting deprecated from rust. What about the other 2?
I've got a question about alignment. I don't come from a C background, but I googled around and understand that in certain scenarios (when variables not aligned) structs are padded to make them faster to read for the CPU.

When writing anchor programs, when if ever should I be using these 3?

`#[repr(C)]`
`#[repr(packed)]`
`#[repr(transparent)]`
yes my bad! that fixed it
make sure it's pub
const should work fine
Hello sirs. How would I wrap my SOL (to WSOL) in my javascript test file
I tried putting a `const` in there but it didn't work - maybe I messed up the imports
What kind of variable? In general yeah, you can put any expression there as long as it's in scope
when I'm doing `#[account(init, payer=user, space=8+X)]` - I'm guessing there currently is no way to insert a variable into X instead of typing out the number manually?
I wouldn't have thought about checking versionning before a while XD
that's true, I didn't have more at the time but <@!326107472098099201>  gave me a huge hint looking this direction.
I haven't upgraded all but solving the anchor versionning solved it, thanks a lot to both of you for answering!
use AccountLoader when I'm using zero copy, otherwise use Account
but ok I see the point
I've only checked the other way around - `Loader` works for accounts created with `init`
AccountLoader will *not* do that, and instead just pretend/hope that the `.data` already looks like a Whatever
Account<'info, Whatever> will deserialize a Whatever from the underlying AccountInfo's `.data` field
`AccountLoader` (`Loader` got deprecated I think) is what you need to use for `zero_copy` accounts (does `Account` work for them too? 🤔 Never thought about that before, would have guessed no)
when should I be using `Loader` vs using `Account`? Both seem to work?
oh interesting, yeah that's true
and it reduces the number of bytes in your transaction
in a sense that it simplifies client-side code?
it's actually kind of a big deal not to have to include the extra instruction to create an account
They use seeds and are signed for by the program
Init is for PDAs
ok got it! Thanks a ton 🙏
If you can get away with `init` you probably should (it's just easier). Sometimes you can't though, because `init` will run into the 10kb limit on CPI account initialization.
`#[account(zero)]` is for when you initialized the account in a separate instruction, so it's been allocated but doesn't have any data in it (in particular, it doesn't have anchor's 8 byte discriminator yet)
sorry could you clarify the connection between PDAs and the 2 macros above?
Add that trait
It is giving me error: 
```the trait anchor_lang::AccountSerialize is not implemented for `SetCharacter<'info>```
It simplifies things in multiple ways
My personal recommendation would be to always use PDAs unless you have a good reason not to
got it! Is there a recommended approach between `account(init)` and `account(zero)`? Sounds like both achieve the same result and the only difference is passing the extra instruction in js/ts
I just derive default on all structs, no reason not to
Ah maybe
I think, right? Maybe that changed somehow
If you've derived Default ^
So long as you're not using Vecs or Strings in your struct then anchor will automatically calculate the amount of bytes needed
try with sudo  ``last command``
I run "anchor deploy"
then got an error: "Error: Unable to write /Users/loris/.config/solana/id.json: Permission denied (os error 13)"
from your wording I'm guessing it's not necessary and if I omit it anchor will figure it out automatically?
Ah I see, thank you very much, <@!134416332509675520>
Otherwise you'll have to do some source-diving to see how they do it in their own program
Often times the other program will expose a lib that does it for you, e.g. with metaplex you can write something like `Metadata::from_account_info(the_account_info)`
Oh man, is there any sample I can refer to? I think it's not the rare case in the on-chain programs.
Use the `space` keyword in the constraints to manually specify the number of bytes to allocate to the account
Gonna have to do some manual deserialization of its `.data` field 💪
Anchor already does this for you. It adds a discriminator of 8 bytes to the start of the program account that indicates if it's been init. So long as you omit the init keyword in any future calls it will verify the account has data in it
thanks, and how to cast the ``ctx.accounts.the_account_in_question`` into custom struct used in the original program? 🙂
You would (in anchor anyway) declare `the_account_in_question: AccountInfo<'info>` in your `#[derive(Accounts)]` thing, and then you can look at `ctx.accounts.the_account_in_question.owner` etc. in your instruction function.
You should look into how project-serum/swap repo uses wrapped sol to transfer Solana maybe. Or you have to do it manually with by calling the system program `transfer` function
as I'm new to solana, could you give me the code example to do this?
Just take a look at its data and program owner—if there's data in there or the owner isn't the system_program, it has definitely been initialized.
No, has to have account info loaded in the transaction
Add the missing traits to the custom struct. Look in anchor/tests for some examples. 
It's like
```
#[derive(AnchorSerialize, AnchorDeserialize, Default, Clone)]
pub struct 
```
I have a vault program which stores the token in a pda account. 
My other programs need to check if there's a token in the vault. 
Since solana has no way of returning value from CPI, the other programs need to load the PDA account of a vault program.
I don't know how to do it, please let me know if there's any way.
and a related question - since we're not using `[account(init)]` with the zero copy approach, how does our program know how much space to allocate for the new account? Because we're not specifying it manually anymore?
How to check if PDA account exists(i.e inited and have data in it) from other program?
so is having a state that's > 10kb in size the only usecase for `#[account(zero)]` over `#[account(init)]`?

What if I was to only use the zero approach in my code? Is there any downside to it?
yes I think you can do that, just make sure the from account is passed in with `Signer` wrapped
I'm just trying to use a program to transfer lamports to a public key without no included account context
The from account is included in the transaction but does the receiving account has to as well? I know I could include a PDA and transfer it there and put it under the correct authority but that seems a bit much
if you need some account you or your program dont own to transfer you the fees, you will need to make sure that account get passed into the handler function with `Signer`
Very newbie question but I'm having trouble receiving sol, could someone help me with a template function to have the account receive sol from the user's wallet, and then have the account send sol to my wallet, if that's a thing?
Is there a good strategy for using `try_borrow_mut_lamports` when you only have a public key? My use case is that I want to charge a fee for a program I'm writing. Essentially that fee would be transferred upon initialization to a hard coded public address. All of the examples I've seen show using accounts but is there a way to get around it?
Can anyone help me with this?
How to get rid of this error. 
```the trait anchor_lang::AccountSerialize is not implemented for SetCharacter<'info>```
```the trait Clone is not implemented for SetCharacter<'info>```

Following is the program
```#[program]
pub mod my_game {
    use super::*;
    pub fn initialize(ctx: Context<InitializeCharacter>) -> ProgramResult {
        Ok(())
    }

    pub fn setCharacter(ctx: Context<SetCharacter>, lifeOrigin: LifeOrigin) -> ProgramResult {
        let character_life = &mut ctx.accounts.character_origin;
        let char_attrib = &mut ctx.accounts.character_attrib;

        character_life.lifeOrigin = LifeOrigin::lifeOrigin;
        char_attrib.character_attrib = CharacterAttributes::default();
        
        Ok(())
    }
}

#[derive(Accounts, AnchorSerialize, AnchorDeserialize)]
pub struct InitializeCharacter<'info> {
    // #[account(init, payer = user)]
    pub character: Account<'info, SetCharacter<'info>>,

    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct SetCharacter<'info> {
    #[account(mut)]
    pub character_origin: Account<'info, LifeOrigin>,
    pub character_attrib: Account<'info, CharacterAttributes>,
}
#[derive(AnchorSerialize, AnchorDeserialize)]
pub enum LifeOrigin {
    Corporate(String),
    Slums(String),
}
impl LifeOrigin {
    fn getLife(lifeOrigin: LifeOrigin) {
        match lifeOrigin {
            LifeOrigin::Corporate(_) => "Corporate Guy",
            LifeOrigin::Slums(_) => "Slums Survivor",
        };
    }
}

#[account]
pub struct CharacterAttributes {
    damage: u64,
    resistance: u64,
    throw_distance: u64,
}

impl Default for CharacterAttributes {
    fn default() -> CharacterAttributes {
        CharacterAttributes {
            damage: 100,
            resistance: 30,
            throw_distance: 5,
        }
    }
}
```
🤦‍♂️
Lol... https://github.com/dtolnay/cargo-expand
I'm just getting the error `Found argument '--expand' which wasn't expected, or isn't valid in this context` even though I opened a terminal in the directory with my `lib.rs` file. 🤔
anyone had issues with this?
the keypair file is there and it seems to be pointing to the correct one `target/deploy/program.json`
Random question - I keep on getting: `Error: failed to read keypair for program:`
however because its called from the frontend, cant clients do that transfer too? essentially draining the treasury account
like say I have a treasury account address, and users can spl_token::transfer into that, but to transfer out, I need the program to sign for the transaction/invocation instead
what is inhibiting the client to spoof authorized calls? because they have access to the program keys. cant they just edit some of our javascript and ruin our day?
but to invote rpc calls, it is client side, and we have to fetch our public program keypair client side
so say we have certain functions on the rust side that requires the signer to be the program (authorized)
i have a hypothetical question more like
To double check, I reinstalled global mocha and voila, the anchor (only version  I've installed) produces again 'test= yarn run mocha... ' . Again I uninstalled it, test again anchor init and it  produced still 'yarn run mocha', which is inconsistent, but after 10 minutes or so it started producing again test= mocha -t 100... so there is some latency to detect there is not global mocha but  in the end it generates mocha without 'yarn run', just when there is not global mocha to be picked up.  This held me back some time,  probing to find what the heck was going on, but at least now I can continue implementing, 👍
yea the way i understand it is that the derive Accounts macro basically validates stuff about transactions thru the #[account] attribute, you use the keys to pass stuff to the attribute like who should pay state rent, rejecting txs not sent by authority, etc
ok newb q. whats the `user` field in the `Initialize` struct? seems to be the account that is signing the init tx. what does it mean for the `user` to be marked mutable? why isnt this field included in other Context structs, only init ones? is it just a way to specify who the payer is?
Oh I see
The system program's programId is actually all zeros—which is maybe kind of surprising since it looks like all 1s in base58, but that's just cause base58 encodes digits that way (0 -> "1", 3 -> "4", etc.)
And that could be part of the issue for sure
It's possible the marinade program they're interacting with uses that version
Sirs why does this print 0 to my console:
`const anchor = require("@project-serum/anchor");`
`console.log(anchor.web3.SystemProgram.programId);`
Result:
`PublicKey { _bn: <BN: 0> }`
Update anchor, it looks like you are using 0.14.0 when the latest version is 0.18.2
The screenshot isn't helpful either because it seems incomplete / partial
Can you be more literal about what the error you're getting is
You're not really giving enough information in a clear enough way that we can help you troubleshoot
Another related thing that is maybe confusing: if some `Signer<'info>` is the provider.wallet, it doesn't need to be added to the `signers: [...]` array because it will already sign automatically, since it's the wallet paying to submit the tx (requires a signature no matter what)
The `signer: [...]` thing is for adding a keypair signature from the client. One situation where this is necessary even if there's no `Signer<'info>` is if you're creating an account that lives at a keypair address; solana forces the addresses of new accounts to sign, and the only way to do this for a keypair address is to sign from the client.
Hello peeps!
Hope you are doing good!
I have asked in the wrong chat maybe but I don't know how to handle this error as I'm not the creator of the full stuff for once.
Not sure if the error is mine or other.

I'm having a program that I turnt into an rust SDK to be callable by anyone and trigger marinade function.

Then when I import the SDK I get en error saying it can't compile anchor_lang because I haven't selected the good version of Solana (which is a crate of crate dependency and anchor_lang is imported in the one I use)

 a little help would be appreciated on how to deal with this :)
Thanks !
(I go to bed will check tmr morning)
Usually this is handled automatically by the `Account<'info, Whatever>` type, assuming you implemented Whatever with `#[account]`.
i been through a couple of examples, i sometimes see a ``signer: [account]`` param passed in a program call (``await program.rpc.anyFuction({})``) and sometimes not at all. 

I first thought that it was because the context passed didn't need any `` user: Signer<'info>`` but it seems like it's not that ?
b/c it looks like anchor implicitly defines an ID variable, not sure if this is correct tho
I ended up doing:
```rust
        let storage_info = &ctx.accounts.storage;
        if *storage_info.owner != ID {
            return Err(ErrorCode::StorageOwnerNotProgram.into());
        }
```
Is there a  explanation on how to do this
(Otherwise my program would not be able to mutate the external account)
How do I check if a given account can be mutated by my program's account?

For example: If I have a game, I might have a method in the program called `update_storage` that accepts a new external account to store data in.
However, I'd need to check that this new external account was owned by my program.
It depends from what you want to do. If just return `bool` then: `result.is_err()`.
Like return a false value rather than erroring out of the whole program
How do you do error handling in rust, i.e. I have a function that returns Result<usize, ()>. I want to do something if the function errors
it sounds like you used two different versions of the cli, one will generate the one with `yarn run` prefix
LOL that must be it, thanks man, I will try to do that
I did the Solana/Anchor project from _buildspace and succesfully implemented it
As I'm playing with the tool I hit some bumps so I better spun off a new ubuntu VM (21.10) to test anchor in isolation.

To avoid problems in such environment,   I added section ```[test] 

startup_wait = 30000```

 as it says somewhere in this discord to get rid of error Unable to start test validator

When I had installed mocha globally the anchor init myproject --javascript  command generates an Anchor.toml file with a  script entry  line like this:  `test = "yarn run mocha -t 1000000 tests/"`, which I guess should runs the local mocha module that anchor init installed at node_modules (?);  but when running anchor test I kept getting  error Command "mocha"  not found and asked me to check yarn webpage to know more about run command  (coundl't find answer, I have nvm to manage node and I tried also with NODE_PATH and simlinks to not avail).
So, I uninstalled global mocha, and generated new anchor init project but now that line on  script  is generated like  `test = "mocha -t 1000000 tests/"`, which won't run and again gave me the  error mocha not found. I don't get  why anchor  removed yarn and goes for global mocha, now that there is no global mocha?
So I manually edit the script to add yarn `test = "yarn run mocha -t 1000000 tests/"` and now it  works

Isn't it backwards?
I don't know if this help but I just change "declare_id!(...)" in lib.rs to actual program id when run "anchor deploy"  and the error gone
how (or where) does one find the idl for the SPL programs, specifically I'm looking for the name-service idl. thanks in advance
Good day! What is the go-to way of reading and parsing events written into logs with `emit!` macro?


//////////////////////////////////////////////////////////////////////////////////////////

Did you get this solved? I’m dealing with the same issue lol
Has anyone come across the case where when starting up an anchor project, building it successfully, trying to deploy it and seeing the msg output being printed repeatedly? Not sure what’s going on.
im getting the exact same error and i have seen others with the same issue but there's no solution. Can anyone help me with this pls. Any help is appreciated thanks
hey man did you manage to get this resolved?
OK
Then program.account.thatAccountType.all() will fetch all of them
Yeah
Thanks
Is the account owned by your program?
For ex:
The user_info is stored on the PDA - the seeds is the user's pubKey
I would like to get all users list
Any `Account<'info, OneOfYourAccounts>` will break
May I know a specific situation about  not work correctly here?
Your program will in general not work correctly if you use the wrong `declare_id!`, no.
Hello guys, a quick question about program_id, it seems the anchor can work even if I put others address to my program_id field. Will it generate any vulnerability?
Can you be more specific? You can fetch all accounts owned by a program, but that's not the same thing as all PDAs derived from a program
Hi <@!134416332509675520> 
Is there any way to fetch all of the PDA accounts from the program?
Is there anything I should know about devnet and how it differs from localnet before I start using it? Is there anything I should be wary of doing considering it's a public dev chain?
Might be using the wrong value, will check
That sounds like an actual error, right? 🤔
```     Error: 141: A has_one constraint was violated
```
Does it not work?
it works with ```Account<'info,TokenAccount>```
another question ```    pub pyth: AccountInfo<'info>,``` is it correct to do ```has_one = pyth```
Also don't need that `async` for what it's worth
weird
It works now after I put it inside the test
How are you calling it?
I still have 2 tests after the sleep, it just finishes and ignore them
```async function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}
```
it skips the rest
What happens when you try? This won't have anything to do with anchor, just JS/TS
doing regular ts await doesn't seem to work
how do you sleep in anchor ts ?
thank you
https://spl.solana.com/associated-token-account
> A user may own arbitrarily many token accounts belonging to the same mint which makes it difficult for other users to know which account they should send tokens to and introduces friction into many other aspects of token management. This program introduces a way to deterministically derive a token account key from a user's main System account address and a token mint address, allowing the user to create a main token account for each token they own. We call these accounts Associated Token Accounts.
Yup, I was unfamiliar with this. Makes way more sense now
Their address is program-derived based on the owner (the maker) and the mint (the taker token), so no need to guess it/remember it
Are you familiar with how associated token accounts work?
hey <@!134416332509675520> , I'm looking at ```    #[account(
        mut,
        associated_token::mint = taker_mint,
        associated_token::authority = offer_maker,
    )]
    pub offer_makers_taker_tokens: Box<Account<'info, TokenAccount>>,
```
(https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo/src/lib.rs#L219)  and don't understand what I'm seeing.
 
`offer_makers_taker_tokens` is the account which the taker's payment is sent to when an offer is taken, and it is provided when `accept` is called. 

I don't understand where the account comes from and how it would be accessed by the maker after the transfer is completed, though. There is verification that the `offer_maker` is the owner and that it's mint is the proper `mint`, but how would the person calling `accept` find this account's PubKey to provide it in the first place?

My best guess would have been that the offer maker would provide this address as part of the `offer` itself, but `offer_makers_taker_tokens` is not a field on an `Offer`
Ah thanks I will check that out.
There is a new and improved version of the IDO pool in the anchor tests directory
Is it safe to use old anchor version or better switch to new ones ... I see a lot of people forking mango ido pool code have to use 0.13.2 version. Is it better to upgrade that code to be compatible with new anchor version ?
gossip address and tpu address are different ports
the JSON RPC is on :8899
Ah. What port is it listening on?
interestingly, I have one running right now as root but when I run that command as both root and non-root, no hits
`lsof -i :8899`
Do you still have a validator running in the background? Need to make sure it's not already running
yea mine doesn't work out of the box like that lol - when I try to just run `anchor test` it will fail on `Transaction simulation failed: Attempt to load a program that does not exist `
But again, I think that's a me problem. Will have to look into fixing my permissions
ah
`anchor test` all by itself actually does a little genesis magic (I'm fuzzy on this tbh) to not have to literally deploy
`anchor test` is supposed to deploy right? You say it lets you skip deploying - but I though it technically launches the validator, deploys, then takes down the validator
oh yea, I think my workflow isn't ideal currently then. my `solana-test-validator` fails if I don't run it as root, and so when I run `anchor test` the validator doesn't actually spin up.  I should probably address that
This lets you skip deploying (annoying and, judging from questions in the discord, very error prone)
So I just run `anchor test` without any validator running in the background
I just hopped on for the morning and ran anchor deploy and anchor test, it actually deployed with the same programId (which I didn't expect)
I actually never use an actual live validator to test, I always let anchor spin one up for me
For all I know it's not expected behavior - did you just restart to test? Maybe it only happens to me 🙂
lmao
I guess I hardly ever restart my computer so haven't noticed 😅
is localnet chain data expected to persist?
Hmm, not sure why that would happen
so if I spin up a test-validator, deploy a program, kill the test validator and restart it - my program is still there when I run `solana program show <programid>`. But if I come back another day, restart my computer and kick off the test-validator, that same programId will no longer be found (`Unable to find the account <programid>`).

Seems like it's sticking around if I kill the validator and restart it, but lost either after some amount of time or in between full computer restarts. Is that expected?
yeah makes sense
Cuz we will call them from other places I guess
how come functions have to be public?
Oh ok, thanks
Ngmi (lol), that's too old, gonna have to update
1.8.0
What version of solana are you using?
where should I add it?
But now it asks this
Turning off hyper v helped
when I try to run solana-test-validator I get `Aborted (core dumped)`
Now I have another problem lel, I hate setting up env
oh ok that makes sense - i do remember upgrading anchor took like a half hour for me yeah 🙂
Rust package management basically leads to 1 black hole per project
If it was a fresh install, it was probably pulling a lot of crates, just not giving much feedback.
oh ok 😅
idk what was problem, but its fixed I guess
It was like that for 20 mins and after started building
Just nothing
do you have an anchor project? i.e. anchor init testanchor
no output at all?
Like anchor is installed and everything should be fine, but anchor build just does nothing, can anyone help?
Just installed anchor on ubuntu and anchor build still does nothing
What do you mean by get the same problem? You only need to use invoke_signed if you need your program to sign for a program-derived address (doesn't sound like the donator lives at one—seems like they're a regular keypair address that signs from the client)
the account is just an empty slate, you store any data you want on it. For example, who the account's owner is
that's something you have to store inside the account itself
i don't understand the question
so that links the owner (who initialised jt) to the account created?
you would just use `program.accounts.{accountName}.fetch(accountPubkey)` to check if the account exists or not
not sure if this is anchor or more javascript related
is there any way to have a program that creates an account for a player and saves it somehow so the next time the player tries to create an account, they are automatically logged in?
Got it thanks
some programs, like the SPL token program, enforce that their accounts are created rent exempt
don't think so
Is there any available attribute for checking if an account is rent exempted or not?
like `#[account(mut)]`
anchor build doesn't work
You're right about the error. It's showing that "writable privilege escalated"

When I try using invoke, I get the same problem:
```
let ix = anchor_lang::solana_program::system_instruction::transfer(
            &ctx.accounts.donater.key(),
            &ctx.accounts.receiver.key(),
            ORACLE_FEE,
        );

        anchor_lang::solana_program::program::invoke(
            &ix,
            &[
                ctx.accounts.donater.to_account_info(),
                ctx.accounts.receiver.to_account_info(),
                ctx.accounts.system_program.to_account_info()
            ]
        )?;
```

I'm guessing that I may have to use `invoke_signed` but I'm not sure how to get the the "donater"'s seeds. The "donater" is a signer of the request already.
check this
https://project-serum.github.io/anchor/ts/classes/AccountClient.html#createInstruction
you can create accounts from the client side too and the size can be dynamic
wait hold on
well yeah cuz it can be 32 bytes long
So even if ur string to send is 8 bytes long. You pay the fixed amount set in the account constraints?
you can declare the space in the account contraints
yes, you can't change the allocation afterwards, you need to declare it upfront
If I wanted 64 byte string after would I need to make another PDA?
Like a 32 byte string
When I init an PDA with data. do i need to specify the size of the data and I'm stuck with that size once the initial allocation
If you scroll up in your program logs you'll probably see a message saying some account's writable privileges were escalated.
And I think the actual issue (once you fix the token transfer thing) is that you haven't marked the `receiver` as `mut`.
So you're trying to do a lamport transfer? Why are you doing a `token::transfer` rather than a `system_instruction::transfer` + `invoke`?
I'm trying to implement a simple example and running into: "Cross-program invocation with unauthorized signer or writable account".

The goal is for a user who is a signer to send lamports to another user who is not a signer. 

```
pub fn donate(
        ctx: Context<Donate>,
    ) -> ProgramResult {
        let cpi_accounts = Transfer {
            from: ctx.accounts.donater.to_account_info().clone(),
            to: ctx.accounts.receiver.to_account_info().clone(),
            authority: ctx.accounts.donater.to_account_info().clone(),
        };
        let cpi_program = ctx.accounts.system_program.to_account_info().clone();
        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
        token::transfer(cpi_ctx, 10000)?;
        Ok(())
    }

#[derive(Accounts)]
pub struct Donate<'info> {
    #[account(mut)]
    pub donater: Signer<'info>,
    pub receiver: AccountInfo<'info>,
    pub system_program: Program<'info, System>,
}
```

The client code is pretty simple:
```
        await this.program.rpc.donate({
            accounts: {
                donater: this.keypair.publicKey,
                receiver: receiver.publicKey,
                // rent: anchor.web3.SYSVAR_RENT_PUBKEY,
                systemProgram: anchor.web3.SystemProgram.programId,
            },
            signers: [this.keypair],
        });
    }
```

I understand (I hope) that using `try_borrow_mut_lamports` requires that the program owns the account so that won't work. 

Does anyone have any simple examples for transfering lamports to an account where the receiver doesn't sign the transaction, only the sender does?
ah interesting, I'll keep that in mind thanks!
Not quite—it will *recalculate* the bump for you. The downside is that this costs compute.
if you provide no bump, like:

```rust
#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(signer, mut)]
    pub initializer: AccountInfo<'info>,
    #[account(
        init,
        seeds = [b”a".as_ref(), b”b".as_ref(), b”c".as_ref()],
        bump,
        payer = initializer,
        space = 8 + MinterState::LEN,
    )]
    pub state_account: Account<'info, MinterState>,
    pub system_program: Program<'info, System>,
}
```

Will it use the default bump?
Does your `declare_id!` use the program_id "9pkYv3S..." from that screenshot? If not, then you need to update it to match.
I realize this is prob a better place to ask

New to solana and anchor dev and going through the anchor tutorial examples. Kinda confused about one thing for now.. when you do a anchor init AppName and you ge the declare_id! - if I want to deploy this to devnet then that should be replaced. Is it with the public key of a keypair you gen locally or something else?
if you are having trouble with getting all of this working and learning solana, could you try working on something simpler first maybe?
I have just used ``AcountLoader`` and it shows this error when ``initialize`` call in ``client.js``.
```The given account is not owned by the executing program```
https://github.com/samuelvanderwaal/solana-whitelist/issues/1
It is splitting my head nowadays.
Please help me.
Hello
FYI - figured it out, and posting what I learned here for reference. Basically I had installed yarn not at the project level, but at the folder one level up. so it was looking for stuff to be installed there (my user folder) instead of where it actually was at the project level. The solve - delete yarn.lock and package.json from the user folder, and install yarn in the project folder
ah yes, i see. i was looking at the wrong instruction, makes more sense now. The init was failing, and then that was trying to access the account later. The init is failing because 'Cross-program invocation with unauthorized signer or writable account' But let me bang around on it for a bit, probably just have my instructions wrong 🙂
not always, it's officially the `account not owned by program` error right? This means that you might be trying to use an account that hasn't already been initialized and is still owned by the system program
Is error 167 always a declare_id error? I've redeployed to devnet, and my instructions to it are getting the 167 error. I've triple checked that I 'anchor build' then 'anchor deploy ...' with the correct declare_id, and now i'm stumped.
Think I've installed it correctly, but when I type 'mocha' in the command line I get a 'command not found issue
Can anyone help? I've been stuck on this for a while and not sure what to do! I think it may be an issue with mocha not working correctly, but not sure
created a new anchor project, and tried to run 'anchor test' and am getting this error

yup, thanks
and if it returns with NULL then add the init instruction
`program.accounts.this_counter.fetch(this_counter_pubkey)`
thats what i figured.
it's really quite simple, you just check if the account exists or not


//////////////////////////////////////////////////////////////////////////////////////////

Yeah that's sorted it. Thanks!

For anyone else looking for the `programId` parameter of `getParsedTokenAccountsByOwner()`, it is always: `TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA`
ahh ok I'll give that a go.. yeah makes a lot more sense
And the only other thing that makes sense to filter on is the mint
Because you're already specifying the owner of the token
I assume so (haven't actually tried, but I don't know what other program id could make sense)
oh what it is asking for the native one?
All token accounts are owned by the spl token program
What do you want that program id to mean?
Is it possible to get someone else's program ID?
Honestly not sure why it's a filter option at all
Ah, you need to use the actual SPL token program id
Mm, not sure, you can definitely just do it yourself with new PublicKey but you need to get it right 😛
So this app has a different program ID I guess
Oh no I'm doing it from a separate app.. cos I've just been following tutorials, I just copied the ID from the other app. Is that the issue?
Did you use the `@solana/spl-token`'s TOKEN_PROGRAM_ID as the value?
That's what I tried and I get this error 

The same as if I put any other address that isn't a program ID in there, but it's copied from the .cache folder of my uploaded collection
What about using `programId: theSplTokenProgram`
Ah, ok
but I've just started with solana so there's maybe just an entirely different way I should be doing it
I think it's required
Can you just leave off the filter entirely?
Then is there another way to target a whole collection, where the mint addresses are different for each one?
So just `{ mint: theMint }`
I think you would skip that `programId` filter and just use the mint one (I think)
The comment was from when I was using the mint parameter and is now a lie
Oh sorry it's inside the `filter` type. its defined as:

```
      const filter = {
        mint: PublicKey
      }
      |
      {
          programId: PublicKey
      };
```
But I'm currently working with my own program. got 2 tokens in my wallet from a standard (I think) metaplex collection... but when I use the mint parameter I can only see one, so need to use the program ID.. .but none of the keys I get from my JSON are working, so wondering if I need to do some extra formatting
getParsedTokenAccountsByOwner doesn't take one 🤔
Also, which programId parameter are you referring to?
No, whatever you're doing will only happen on a single network
dunno if it reads from mainnet too
but I'm on devnet
I have a program that I can read the accounts of, or just anyone else's
~~Which program are you trying to get parsed accounts for?~~
Trying to get all NFTs from user wallet, from either my own collection or someone else's.. doesn't particularly matter which
Anyone able to enlighten me about where to find the correct key for the `programId` parameter in `getParsedTokenAccountsByOwner()`?

I dunno if I just need to do more formatting than `new PublicKey("key_goes_here")`
can anyone please help me with this
i've built most of my app already but i'm just confused with this
could anyone give me some tips on how i might build something with built in reward? like based on certain requirements that need to be fulfilled from my backend
i airdroped more sols and deployed that contract , getting a different err
okay let me try that too
yeah yes, it was working fine untill last week, i have deployed it multiple times on devnet
Yeah, the first thing to try would be to get yourself more devnet sol.
When you say "deploying 4 contracts at once", is that literally in one command?
i have also tried deploying that specifc contract which throws err, but still getting the same
Any way to deploy only 1 to try?
Is 10 SOL enough though? I've seen programs deploy for 5 SOL easy, and they were not huge
yes , i have about 10 sols and deploying 4 contracts at once
Do you have lamports in the deploying wallet?
I'm having problems compiling with anchor:
BPF SDK: /Users/z/.local/share/solana/install/releases/1.8.3/solana-release/bin/sdk/bpf
Compiling solana-program v1.9.1
error[E0658]: use of unstable library feature 'debug_non_exhaustive'
/Users/z/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-program-1.9.1/src/account_info.rs:48:11
   |
48 |         f.finish_non_exhaustive()
   |           ^^^^^^^^^^^^^^^^^^^^^
   |
   = note: see issue #67364 <https://github.com/rust-lang/rust/issues/67364> for more information
   = help: add `#![feature(debug_non_exhaustive)]` to the crate attributes to enable
i am getting this error while deploying in devnet , but it is getting deployed in localnet
(difference being that my example uses `provider.wallet`, where the stackoverflow answer has stored the `wallet` property directly inside their `provider` variable)
In case anyone else comes here struggling... seems like the issue is that I was attempting to sign the transaction programatically, but I do not have the user's credentials stored programatically... this stack overflow answer shows how to restructure the transaction to request a signature from the user before it is sent: https://stackoverflow.com/a/69050522/2285440
ooh lol I see. Thanks I'll try there too
create grid isn't anything, it's just this person's custom function name
you could try asking this in solana tech discord as well, this looks like one of their examples
<https://docs.solana.com/developing/programming-model/accounts#rent>
ah I haven't seen that createGrid method. Guess I need to get reading. Thanks that helps a lot!
https://docs.solana.com/developing/runtime-facilities/sysvars#rent
```
 txn.add(
        await program.instruction.createGrid(
          GRID_SEED,
          newBump,
          {
            accounts: {
              signerAccount: provider.wallet.publicKey,
              gridAccount: newPda,
              systemProgram: SystemProgram.programId,
            },
            signers: [provider.wallet],
          }
        )
      );
```
im a noob too but i can show you my similar code when i provide provider.wallet in case that helps (im using anchor rpc call) <@!881052567747043369>
np urs is more important, mine just curious
bump ... sry for burying you 😛
GM all.

Just been working through the buildspace tutorial and now doing the independent tasks. Struggling to work out how to transfer SOL.

I was originally going to do it from within react's `App.js` file, using this example: https://github.com/solana-labs/solana-web3.js/blob/master/examples/send_sol.js

But I've realised that I can't create the `Signer` type without access to the user's private key. So now I am clueless as to how I would create the transaction. Any help would be greatly appreciated.

Here is my function (obv. `provider.wallet` doesn't work):

```
  const sendTip = async (payeeAddress) => {
    try {
      const provider = getProvider();
      const recipient = new PublicKey(payeeAddress);

      let connection = new web3.Connection(
        web3.clusterApiUrl('devnet'),
        'confirmed',
      );

      // Add transfer instruction to transaction
      let transaction = new web3.Transaction().add(
        web3.SystemProgram.transfer({
          fromPubkey: provider.wallet.publicKey,
          toPubkey: recipient,
          lamports: web3.LAMPORTS_PER_SOL / 100, // 0.01 SOL
        }),
      );

      // Sign transaction, broadcast, and confirm
      let signature = await web3.sendAndConfirmTransaction(
        connection,
        transaction,
        [provider.wallet],
      );
      console.log('SIGNATURE', signature);

    } catch(error) {
      console.error("function `sendTip` has reported an error:", error);
    }
  };
```
in anchor, what is specifying rent in your list of accounts used for?

like https://github.com/project-serum/anchor/pull/202/files#diff-9a9a1df604bb00f9ae5c845737bb0bad073f6617d3fa26550f9d812143687d6dR109

```
#[derive(Accounts)]
pub struct CreateLargeAccount<'info> {
    #[account(init)]
    event_q: Loader<'info, EventQ>,
    rent: Sysvar<'info, Rent>,
}
```
how do i setup a custom rpc node on anchor tests?
I believe `&ID` macro is what you're looking for
How do you access the program ID that was declared in declare_id inside a function?
Thanks <@!798837544640446494>
So that's the problem right there. Somewhere in the solana import, you're bringing in some dependency that's only supposed to run on node. 

Take a look here: https://github.com/evanmarshall/sol-rng-client/blob/main/src/index.js
This shows how you could make the connection from a browser.
hi no - its just kind of working but i haven't switched from localnet yet
So I imported to solana web3 package in my react app so my smart contract could render on my react site.
I'm pretty confused about what you're actually doing because that's not your file, that's from @solana/web3.js I believe. 

What are the steps to reproduce your problem? In particular, why do you have anything open in chrome and what made it? 

When you create an anchor project, it doesn't come with a react app so you created one inside. With your react app, it shouldn't import all of the solana web3 stuff by default, so you had to add it somewhere. I'm not seeing the file you edited to import the solana web3 stuff.

I'm pretty new to solana too so I could certainly be wrong.
<@!798837544640446494> sorry but here is my index.ts

export * from './account';
export * from './blockhash';
export * from './bpf-loader-deprecated';
export * from './bpf-loader';
export * from './connection';
export * from './epoch-schedule';
export * from './ed25519-program';
export * from './fee-calculator';
export * from './keypair';
export * from './loader';
export * from './message';
export * from './nonce-account';
export * from './publickey';
export * from './stake-program';
export * from './system-program';
export * from './secp256k1-program';
export * from './transaction';
export * from './validator-info';
export * from './vote-account';
export * from './sysvar';
export * from './errors';
export * from './util/borsh-schema';
export * from './util/send-and-confirm-transaction';
export * from './util/send-and-confirm-raw-transaction';
export * from './util/cluster';

/**
 * There are 1-billion lamports in one SOL
 */
export const LAMPORTS_PER_SOL = 1000000000;
I don't have those files in my folder structure
What does your client.ts & index.ts file look like?
<@!798837544640446494> its just a blank screen
I'm not totally sure this is the issue but it looks like you may be importing some of the node dependencies that shouldn't be served to the front end. You can't just copy the code from the tests.

What does your client code look like?
I have updated the node packages
I am having issues getting my react app to render
Thank you for explaining it. That makes a lot more sense than what I was thinking before (as more of an ownership statement).
Nothing about ownership—it's purely about giving solana information about how to schedule running transactions on the cluster. E.g. if two transactions both want to write to some account, solana has to run them in sequence (can't parallelize them)
Marking the receiver as mut tells solana "I'm gonna need exclusive access to this account!"
Right, that's what I was suggesting above—you need to mark the receiver as mut
It works if I add `#[account(mut)]` above the `pub receiver: AccountInfo<'info>,` I'm still confused though as the client doesn't pass in anything except the pubkey of the receiver. Also the donater doesn't own the receiver and both addresses are created with: `anchor.web3.Keypair.generate()` and then airdropped to fund.
Does anchor have support for VecDeque?
is there a way to do cpi without access to the idl or source code of the called program? it seems that for it to work, you need to serialize/encode the instruction data. thus, you somehow need access to the actual program that you want to cross invoke.

eg: you cant just say ```invoke(target_program_id, function_name([]accounts))``` excuse the pseudocode
Here's the full error:
```
Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account 
    Program Bty5iscY33GnVqzstci1gVNaikxt9aPFW4Q1FmyEqseR invoke [1]
    Program log: Is signer: true
    GjN4RMKJ7foi3ej1PaYiLBNscx62x2JWBMyMfapkFjFt's writable privilege escalated
    Program Bty5iscY33GnVqzstci1gVNaikxt9aPFW4Q1FmyEqseR consumed 200000 of 200000 compute units
    Program Bty5iscY33GnVqzstci1gVNaikxt9aPFW4Q1FmyEqseR failed: Cross-program invocation with unauthorized signer or writable account
Translating error SendTransactionError: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account
    at Connection.sendEncodedTransaction (/Users/evanmarshall/Documents/solana/sol-rng/top/node_modules/@solana/web3.js/lib/index.cjs.js:6591:13)
    at processTicksAndRejections (node:internal/process/task_queues:96:5)
    at async Connection.sendRawTransaction (/Users/evanmarshall/Documents/solana/sol-rng/top/node_modules/@solana/web3.js/lib/index.cjs.js:6550:20)
    at async sendAndConfirmRawTransaction (/Users/evanmarshall/Documents/solana/sol-rng/top/node_modules/@solana/web3.js/lib/index.cjs.js:8513:21)
    at async Provider.send (/Users/evanmarshall/Documents/solana/sol-rng/top/node_modules/@project-serum/anchor/dist/cjs/provider.js:85:22)
    at async Object.rpc [as donate] (/Users/evanmarshall/Documents/solana/sol-rng/top/node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:11:31)
    at async UserSession.donate (/Users/evanmarshall/Documents/solana/sol-rng/top/app/sessions.js:89:9)
    at async runClient (/Users/evanmarshall/Documents/solana/sol-rng/top/app/client.js:36:5) {
  logs: [
    'Program Bty5iscY33GnVqzstci1gVNaikxt9aPFW4Q1FmyEqseR invoke [1]',
    'Program log: Is signer: true',
    "GjN4RMKJ7foi3ej1PaYiLBNscx62x2JWBMyMfapkFjFt's writable privilege escalated",
    'Program Bty5iscY33GnVqzstci1gVNaikxt9aPFW4Q1FmyEqseR consumed 200000 of 200000 compute units',
    'Program Bty5iscY33GnVqzstci1gVNaikxt9aPFW4Q1FmyEqseR failed: Cross-program invocation with unauthorized signer or writable account'
  ]
}
```

The public key causing the problem is: "GjN4RMKJ7foi3ej1PaYiLBNscx62x2JWBMyMfapkFjFt" which is the public key of the "receiver" account.

Additional info:
anchor-cli 0.18.2
solana-cli 1.8.0
Absolutely and I really appreciate your help. 

Here's the program code:
```
pub fn donate(
        ctx: Context<Donate>,
    ) -> ProgramResult {
        msg!("Is signer: {}", ctx.accounts.donater.is_signer);

        let ix = anchor_lang::solana_program::system_instruction::transfer(
            &ctx.accounts.donater.key(),
            &ctx.accounts.receiver.key(),
            100000,
        );
    
        anchor_lang::solana_program::program::invoke(
            &ix,
            &[
                ctx.accounts.donater.to_account_info(),
                ctx.accounts.receiver.to_account_info(),
                ctx.accounts.system_program.to_account_info()
            ]
        )?;
        
        Ok(())
    }

#[derive(Accounts)]
pub struct Donate<'info> {
    #[account(signer, mut)]
    pub donater: AccountInfo<'info>,
    pub receiver: AccountInfo<'info>,
    pub system_program: Program<'info, System>,
}
```

Here's the client code:
```
await this.program.rpc.donate({
            accounts: {
                donater: this.keypair.publicKey,
                receiver: this.receiverPubkey,
                systemProgram: anchor.web3.SystemProgram.programId,
            },
            signers: [this.keypair],
        });
```
And can you post your code that's using the system_program transfer?
No need to sign for the recipient. Can you post the full program log?
I mean that I get the same issue if I just use invoke: "Cross-program invocation with unauthorized signer or writable account" with the public key of the recipient either using system_program & invoke or Transfer & token::transfer. 
Is it impossible to just send lamports to an account that isn't a signer? 

I know I can send lamports to a PDA and then the other user can withdraw from the PDA but this feels way more complicated than my use case.  I feel like I'm missing something simple.
Ahhhh okay that’s a relief, so I can just let it go until it actually deploys 😅
I think someone just forgot to delete a log line in solana lol
that's my experience when deploying, eventually it deploys though, after spamming `msg <address>`


//////////////////////////////////////////////////////////////////////////////////////////

can you also check `is_signer` when executing a CPI from one Program to another?

For example


```
let example_pda = ctx.accounts.example_pda.to_account_info();
    let seeds: &[&[u8]] = &[b"example"];
    let signer_seeds = &[&seeds[..]];
    let cpi_accounts = SetDataAuth {
      example_account: ctx.accounts.example_account.to_account_info(),
      authority: example_pda,
    };


    let cpi_ctx = CpiContext::new_with_signer(
      cpi_program,
      cpi_accounts,
      signer_seeds
    );
    
    programA::cpi::set_data_auth(cpi_ctx, data)
```
`CpiAccount` was replaced with `Account`, which also covers the old `ProgramAccount` use case, right?
Yep. You can then check programmatically with the `is_signer` property (solana itself sets it to true or false depending on whether the account signed)
so that is the only mechanism solana uses to ensure this account signed this transaction right ?
Yep. Solana will verify that that account really did sign.
<@!134416332509675520>  have a solana theory question sort of, in solana when you require a account be a signer is it because that account "is_signer" property is going to be checked on chain ?
thanks
Don't think there's any built-in command to do it, no. Not sure if it's literally impossible though
Is it possible ?
How can I close IDL account of a program ?
In general, yes.
so I have to save the address?
When you created the account you had to decide on which address to use (so don't forget it, lol)
So you just need to know the right address
There isn't necessarily just one address for the account (there could be an arbitrary number of  ClientData accounts)
here the "theAddressOfTheAccount" is the publicKey of client account right? what if I want to get that?
You would do `await program.account.clientData.fetch(theAddressOfTheAccount)`
#[derive(Accounts)]
pub struct Client<'info> {
    client: Account<'info, ClientData>,
}

#[account]
pub struct ClientData {
    active: bool,
    amount_raised: u64
}

I have this I want to get the PublicKey of the client account
What do you mean by a program account? I'm going to need way more information to help
I want to get the data of program account. how can I get that?
If it's one of your own account types then you can do `program.account.yourAccountTypeName.fetch(itsAddress)`
Yes
What do you mean by read? Do you mean parse/deserialize?
how can I read buffer data returned from getAccountInfo?
I think you might be mistaken, `my_account_info.lamports` gives you that refcell stuff, `.lamports()` gives you a u64
What does your `Anchor.toml` say?
otherwise you have to run BROWSER= everytime
`export BROWSER=` is more correct
Wht to do?
anchor test not switching to localnet even after doing config set localhost
With rust I find it's trial and error until the compiler stops complaining and gives me what I want
Probably need to Google how to use deref mut
It does, at least for CPI, not in the client
If I have AccountInfo how can i get the number of lamports in it as a u64? 
If example_acc_inf is an AccountInfo then 
example_acc_inf.lamports() returns a  Rc<RefCell<&'a mut u64>>.
Is there a good way to turn an address that is formated as a string into a PublicKey?
Serum was written in the before times
Anchor doesn't seem to have helper functions to interface with serum, but it was made by the serum team it seems like ?
ty!
Use `.lamports()` rather than `.lamports`
Good evening guys. Anyone knows how to fix this issue or another way to do this constraint? I want compare user sol balance with a pre-fixed amount
Yeah
Hey guys, quick question, does `Rent::minimum_balance` on Rust side does the same as `anchor.program.provider.connection.getMinimumBalanceForRentExemption` on TypeScrypt side? Just could not figure out from sources. Thanks in advance!
Assuming the source is owned by your program, you'd do something like this:
```.rs
fn transfer_from_account_we_own(
    src: &mut AccountInfo, // we better own this account though
    dst: &mut AccountInfo,
    amount: u64,
) -> ProgramResult {
    **src.try_borrow_mut_lamports()? = src
        .lamports()
        .checked_sub(amount)
        .ok_or(ProgramError::InvalidArgument)?;
    **dst.try_borrow_mut_lamports()? = dst
        .lamports()
        .checked_add(amount)
        .ok_or(ProgramError::InvalidArgument)?;
    Ok(())
}
```
So just to double check, the source account here is owned by your program? How you do a transfer depends on which program owns the source account
The idea is making a simple donation matching contract (Alice can put X lamports into the declaration and when Bob donates Y lamports in the future if Y<X then Y of the declaration's lamports and Y of Bob's lamports are sent on. Then the declaration has X-Y lamports. If Carol comes along and donates Z<X-Y lamports then Z of Carol's lamports and Z of the declaration's lamports are sent on)
My goal in the end is to have a function which creates a declaration account. I want the `author' who is calling the function to have their lamports decreased and the declaration account's lamports increased by the same amount. Then I want to make another function that allows someone else, Bob, to send lamports then both Bob and the declaration accounts lamports get dedecuted and sent off to a final unrelated public address
I just want to read it so I can decrement it as much as I am adding to the declaration account
author_account_info.lamports
but I am not sure how to access the the u64 inside of
but I am getting the error that unwrap isn't defined
and I am doing this: 

        let dest_starting_lamports = declaration_account_info.lamports();
        **declaration_account_info.lamports.borrow_mut() = 
            dest_starting_lamports.checked_add(donation_amount).ok_or(ErrorCode::InsufficientFunds)?;

        **author_account_info.lamports.borrow_mut() = author_account_info.lamports.unwrap()-donation_amount;
I am trying to move funds from one account to another
Easier to help too if you tell us what struggles you're having
Have you tried searching the discord? Lots of past discussions of this, not sure how easy they are to find though
I want to transfer lamports from one account to another and I am struggling.
Does anyone have examples of of the system program transfer function in use?


//////////////////////////////////////////////////////////////////////////////////////////

More random guesses, what does `gcc --version`, `cc --version` etc. say?
detail about my mac
i tried it , but same
Desperation move, but does `cargo clean` help at all?
this is the final message it gives me when the build failed: error: failed to compile `anchor-cli v0.19.0 (https://github.com/project-serum/anchor#51aeb08a)`, intermediate artifacts can be found at `/var/folders/lk/ln8l958s1w52xjm8p_49rmc00000gp/T/cargo-installdBLLSm`
I've been looking everywhere, form the github issues to the discord, nobody can tell me something about why i can't install anchor on my mac
I'm using nightly, which is at 1.59, so I figured 1.58 was the latest, but guess not
??
Ah, huh
this is what i have as outcome when i run rustup update: info: syncing channel updates for 'stable-x86_64-apple-darwin'
info: checking for self-updates

  stable-x86_64-apple-darwin unchanged - rustc 1.57.0 (f1edd0429 2021-11-29)

info: cleaning up downloads & tmp directories
Just for the heck of it, can you upgrade that? Latest is 1.58 (kind of skeptical it will fix anything, but worth a shot)
rustc 1.57.0 (f1edd0429 2021-11-29)
What does `rustc --version` say?
or this error: error: failed to run custom build command for `hidapi v1.2.7`
my rust is updated
Can maybe try searching the discord, I'm not sure off the top of my head how to fix this problem. Maybe make sure your rust is up to date, etc.?
installing anchor on a 2019 non m1 macbook pro
Hi, anyone can help with this: error: failed to run custom build command for `ring v0.16.20`
I found `provider.sendAll` always give u  a failed estimated balance change on Phantom, have anyone got the same experience?
```@solana/wallet-adapter-react'```
how to use adapter wallet for anchor provider ?
titteee
https://github.com/solana-labs/solana/blob/b8837c04ec3976c9c16d028fbee86f87823fb97f/cli/src/cluster_query.rs#L1742
awesome ty
basically they have been created by deriving the address from seed+bump, now they exist, owned by the program, and are "queryable" through that ownership
Yes. And I'm sure there is a rust version of this.
ah cool, yea this might be it then. so basically I'm able to query for all accounts owned by a program
What you get in response is this struct, so each account matching the query will be returned along with its address: https://github.com/project-serum/anchor/blob/af926876c57b90f4a54a4c10c21440f9c8dc0887/ts/src/program/namespace/account.ts#L370
(maybe I am misunderstanding the context)
through filtered queries like these for instance: https://github.com/project-serum/anchor/blob/master/tests/misc/tests/misc.js#L744
let's say I have a few PDAs initialized, how do I get the addresses after the fact?
I guess it is an option. What I am wondering though is if you need that. Isn't it possible for you to simply query all accounts of that type, and using client-side logic to do what you want to do on a specific one? You wouldn't care about the seed that way (having the addresses straight up), apart from creation time. And you wouldn't have to be careful about synchronizing your PDAs with an "address book" (vector of seeds) when you close one for instance.
If I store the seed in the account's data then I'd need to know the account address in order to fetch its seed, but need the seed to derive the address
I think I've misspoke. I mistook bump for seed. So basically store the seeds in a vector. That way, off-chain I can query a single account that returns the list of seeds, then derive the addresses using the list
Sounds reasonable to me, although I'm not the most nuanced in Anchor. Would storing the bump within each account's data, and making a filtered query for all these accounts be an alternative? That would make you fetch more data to retrieve the bumps list, but you'd also be able to more naturally access the bump within the `#[derive(Accounts)]` macro, when passing these accounts to the program.
lets say i wanted to init multiple pdas over time and to also have an easy way to derive them off chain. would storing the bumps in a vector and seed in some other pda “state” struct be reasonable approach?
Thanks, this fixed the problem.
Ah, sorry, you need to `use anchor_lang::AccountsClose;` I guess
Huh, interesting
Sorry, that was for my previous test. That code returns this error:
no method named `close` found for struct `std::boxed::Box<anchor_lang::Account<'_, structs::MyStruct>>` in the current scope
How did that produce the error above? There's no mutable reference etc.
ctx.accounts.my_struct_account.close(ctx.accounts.reciever.to_account_info())?;
Can you show me the code you're writing that produces that error?
anchor-lang = "0.19.0"
Hmm, what version of anchor_lang are you using?
The problem is that I have Box<Account<'info, MyStruct>>, and get the following error:
no method named `close` found for mutable reference `&mut std::boxed::Box<anchor_lang::Account<'_, structs::MyStruct>>` in the current scope
If you have an `Account<'info, Whatever>`, you can just do
```.rs
ctx.accounts.your_account.close(account_info_to_send_the_sol_to)?;
```
Sounds like you're signing incorrectly 😛 Unknown signer means you're signing with something that actually isn't supposed to sign.
I am constantly getting unknown signer: Something
even though i am signing correctly in anchor test
Hi, is there any way to call this function or do I have to copy it?
aren't we supposed to use seeds and bump in the context of initializing a PDA?
quick question guys; can someone tell what is the difference between these two usages of the seeds contraint?

```
#[derive(Accounts)]
#[instruction(nonce: u8)]
pub struct TestInstructionConstraint<'info> {
    #[account(
        seeds = [b"my-seed", my_account.key.as_ref()],
        bump = nonce,
    )]
    pub my_pda: AccountInfo<'info>,
    pub my_account: AccountInfo<'info>,
}
```

and 

```
#[derive(Accounts)]
#[instruction(domain: String, seed: Vec<u8>, bump: u8)]
pub struct TestPdaInit<'info> {
    #[account(
        init,
        seeds = [b"my-seed", domain.as_bytes(), foo.key.as_ref(), &seed],
        bump = bump,
        payer = my_payer,
    )]
    pub my_pda: Account<'info, DataU16>,
    pub my_payer: AccountInfo<'info>,
    pub foo: AccountInfo<'info>,
    pub system_program: AccountInfo<'info>,
}
```

These are all taken from the original repo https://github.com/project-serum/anchor/blob/master/tests/misc/programs/misc/src/context.rs#L65
Generate a custom keypair `solana-keygen new -o program-keypair.json`, or copy one generated via `anchor build` in `target/deploy/program-keypair.json` out of there, and track it somehow (usual security rules apply there, depending on whether it's a prod program or just for testing). Then specify that keypair file in your deploy command whenever you `deploy` / `upgrade`
a new program ID is output everytime I delete the target folder and run anchor build and anchor deploy, which files to save so that I always get the same program ID whichever machine I run the anchor deploy
This is my context struct,
```
#[account(
        mut,
        constraint = mint.supply == 0,
        constraint = mint.freeze_authority.unwrap() == mint_auth.key(),
        constraint = mint.mint_authority.unwrap() == mint_auth.key(),
)]
mint: Account<'info, token::Mint>,
#[account(
        init,
        seeds = [b"metadata".as_ref(), self::id().to_bytes(), <mint_address>],
        ...
        ...
)]
metadata_account: Account<'info, CommunityMetadata>,
```

How would I go about getting the `mint`'s address as one of the seeds for `metadata_account`?? 
And is `self::id().to_bytes()` the correct way for getting the Program ID??
Out of curiosity, does anyone know if lets say a program owned account's SOL balance goes to 0, what will happen to the mint accounts and token accounts it owns? Will the whole mint just disappear?
Fwiw: It was because I was checking transfer amount + token_account.lamports = the increase in lamports post close_instruction - but the token_account.lamports includes the `amount` of wrapped sol it contains.
sike i might just be stupid
I also transferred wrapped sol to a native token account, and saw the token account `amount` field incremented, but not the lamports field.. 🤔
It checks if native && amount != 0, then sets your amount to 0 and poof its gone
does anyone know how to unwrap a native token account onchain? - 

https://github.com/solana-labs/solana-program-library/blob/master/token/program/src/processor.rs#L623-L655

It looks like if you do a close instruction on a native account - your wrapped sol turns to ash
Yes I changed the devnet to localnet in the [provider] section and it worked
ok so it seems a PDA can't send sol to a system owned address, but can a PDA send sol to a PDA?
is there no anchor implementation of invoke_signed
+1 to that! Thank you so much <@!134416332509675520> . 

Just another query, I was going through this repo, and I also came across `#[account(zero_copy)] , which I wasn't able to find in the docs as well here https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html

What does that do?
thanks alan big fan btw <:hugheart:851872735700844575>
Actually not sure, but you can see them in `.anchor/program-logs` inside your project
tells anchor to expect `some_account` to *not* have its discriminator bytes yet.
`#[account(zero)]` is a somewhat specialized usecase: when you allocate an account in a separate instruction, anchor won't have had a chance yet to set those 8 discriminator bytes. Doing
```.rs
#[derive(Accounts)]
pub struct MyAccounts<'info> {
    #[account(zero)]
    pub some_account: Account<'info, Whatever>
}
```
Both of those accounts look the same as raw bytes (both take 4 bytes). But when anchor actually serializes them to an account, it uses an additional 8 bytes at the beginning that's (roughly) a hash of the struct name. This lets anchor make sure not to accidentally treat a OneAccountType account as a SomeOtherType account (without the discriminator bytes you could get confused, since they look similar as far as their content bytes go).
The account discriminator stuff is anchor's way of making sure you don't accidentally misinterpret the data in an account. When you say
```.rs
#[account]
pub struct OneAccountType {
  a: u8,
  b: u8,
  c: u8,
  d: u8
}

#[account]
pub struct SomeOtherType {
  x: u32
}
```
I think the easiest way to get a feel for the `#[derive(Accounts)]` stuff is by looking at anchor examples + the tests/ directory. The basic idea is that you're declaring "I expect to receive accounts that look like this"; you're asking anchor to deserialize stuff, check that this or that account signed, etc.
super noob question how can i get tests to print logs from tx
Any doc/article/tweet explaining the structure of Accounts?

Also, what is the use for the discriminator with reference to accounts? and what is the use-case for `#[account(zero)]`?
Hello, I want to test an error condition. The output looks like the following:
```Transaction simulation failed: Error processing Instruction 0: custom program error: 0x0 
    Program 8LxiqthNj9nBBLUWNZUNhAfBJYaUMY97TDzgPAFCq4TJ invoke [1]
    Program log: Instruction: RegisterMint
    Program 11111111111111111111111111111111 invoke [2]
    Program 11111111111111111111111111111111 success
    Program 11111111111111111111111111111111 invoke [2]
    Allocate: account Address { address: 6U12CLNmVk1wCKYFS7uNkPginAwB4mEnYpxHrrPnJFHG, base: None } already in use
    Program 11111111111111111111111111111111 failed: custom program error: 0x0
    Program 8LxiqthNj9nBBLUWNZUNhAfBJYaUMY97TDzgPAFCq4TJ consumed 200000 of 200000 compute units
    Program 8LxiqthNj9nBBLUWNZUNhAfBJYaUMY97TDzgPAFCq4TJ failed: custom program error: 0x0
```
Can someone show me how I can assert that my request fails with this "account address already in use" error? I understand I can run a  try/catch but after catching I don't even know what the object shape is
thank you
got it
The provider wallet, as far as I know
Oh. That's specified in your Anchor.toml I think
Understood, but is there a way to define/predict which account is the payer before deploying?
Thank you so much!
No, not possible like that. In solana you always have to pass any accounts you are about in from the client (not possible to dynamically look them up like that in your rust program)
I have a PubKey and I want to get the AccountInfo for the associated account. Is this possible? I have tried to do this:

  //get the account info
        let some_acct_info : AccountInfo = SOME_ADDRESS.to_account().to_account_info();

I also tried:
//get the account info
        let some_acct_info : AccountInfo = SOME_ADDRESS.to_account_info();
You can estimate how much you'll need to pay by noting that rent-exemption for the upgradeable deployment workflow costs 7*2 sol / mb (so e.g. a 500kb .so file would cost roughly 7 sol)
You're paying for storing your compiled code on-chain (the .so file in target/deploy)
how/where can we see which account will need funds before deployment?
```Error: Account 4RJZ2rNmTXrVZAgxYxSnjNPdwHxsDP14Tv1oK4LbQQLH has insufficient funds for spend (1.06374552 SOL) + fee (0.000775 SOL)
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.```
ran anchor deploy and got this error
You can do
```.rs
use std::str::FromStr;
let pk = Pubkey::from_str("asdfasdfsa").unwrap();
```
How can you go from a string to a PubKey?
Thank you so much!
@here help needed with anchor build
anyone know how to fix

```
({"Object.<anonymous>":function(module,exports,require,__dirname,__filename,global,jest){export * from './useWalletModal';
                                                                                             ^^^^^^

    SyntaxError: Unexpected token 'export'
```

when running tests in a project created using create-react-app

When trying to use `import { WalletModalButton } from "@solana/wallet-adapter-react-ui";`


//////////////////////////////////////////////////////////////////////////////////////////

`some_account_n`
just having to list out N accounts
What do you find unpleasing aesthetically about the above?
yea i guess it's not an anchor limitation, moreso how programming model was designed
there's no other way than manually writing the initialization code
what did you have in mind?
I want to init several PDAs within one tx but was wondering if there was a more aesthetically pleasing way then to just list out all the accounts in the instruction?
e.g.
```
#[account(
        init,
        seeds = [b"ACCOUNT_1"],
        payer = admin,
    )]
    pub some_account_1: Account<'info, SomeAccount>,
    #[account(
        init,
        seeds = [b"ACCOUNT_2"],
        payer = admin,
    )]
    pub some_account_2: Account<'info, SomeAccount>,
```
gm frens
What have you tried so far?
From the MintPubkey
<@!134416332509675520> 
How can I get the MintAccountInfo on the tests?
Does it mean there are no programs for Chainlink deployed at mainnet but only for devenet? https://docs.chain.link/docs/solana/data-feeds-solana/#Solana%20Devnet
About tokens/lamports etc., it just means that you can have an account that lives at the PDA address—any account you want (slight asterisk because there's a weird technical limitation on how big accounts can be if they live at PDAs, because all accounts that live at PDAs have to be allocated/init'd via a CPI—whatever)
Only the deriving program can sign for one of its derived addresses, so someone else knowing the seeds doesn't matter—what's relevant is making sure you're program isn't dumb and blindly signs for its PDAs without making sure it makes sense etc. But at the end of the day *only* the deriving program can sign, so it's just up to you to make sure your program isn't dumb/gullible.
A PDA is a program-derived address, so indeed, it's just an address, and an account may or may not live there.
https://twitter.com/pencilflip/status/1455948263853600768
Hi guys, i was wondering what is the idiomatic way to create PDA in Anchor and where to read about it?
Also you could discord search for it. We discussed it recently enough in the rust chat
I've seen this done in Mango's voter locking program
I mean unit testing it in rust.
How do I test anchor programs?
I have another PDA question, what if another person know our seed and create the PDA, can that PDA sign transaction?
I guess to put it another way, is a PDA an account itself? Can you get the account info and put lamports in it? I thought it was just an address. If it is just an address what does it mean for tokens/lamports to be on it?
hello , can someone explain to me the different between is_signer and is write-able? in AccountMeta? If something is writable, doesn't it always required to be signer as well?
can the address be used accross programs or no
eg i have a "StructA" in 2 diff program's code
if i 2 programs deserialize the same formatted struct, can they get the same info?
Your program can sign for one of its derived PDAs, but not sure what you mean above. Like, have a token account whose authority/owner is a PDA?
What do you mean by "allow a PDA to sign for it"?
I have a PDA question as well, but even more basic. Lets say I have an account and I want to allow a PDA to sign for it in the future, can I do that? If not, how do you create an account a PDA can sign for?
Ok, not sure what to suggest other than triple checking you can `create_program_address` with those seeds + bump and get the address you're expecting, hmm
i just need to get these message logs
no worries, you've been helpful
Ah
that's why i have the `.concat()`
Sorry, 50/50 chance I'm being dumb and tired right now
But the bump has multiple nestings
for pubkeys
i think `seeds.chunks(32).collect::<Vec<&[u8]>>().as_slice()` somehow gets you to that format
Maybe that doesn't matter somehow and I'm being dumb?
So note the different nesting from what you have
In general signing for one PDA looks like
```.rs
&[
  &[ b"some seed".as_ref(), b"whatever".as_ref(), &[the_bump] ]
]
```
just 1, but the seed format is dynamic
How many PDAs are you trying to sign for? Just 1?
To me the way you're using the bump there looks wrong (too nested)
Hmm, I'm suggesting a change that shouldn't change anything though, right?
but it's still kinda brutal
then your seeds are 
```
        seeds
            .iter()
            .map(|v| v.as_slice())
            .collect::<Vec<&[u8]>>()
            .as_ref()
```
you can first declare a `Vec<Vec<u8>>`
I figured out a "clean" way to do it
kinda hard to change it up as it switches based on input
It's funny how hard it is to read seeds in solana, lol
Have you tried that seeds change?
so i'm just really confused :/
yeah i figured that as well
Like, I can't think of anything
Hmm. Anchor itself shouldn't have almost anything to do with the code above, for what it's worth
yeah it's a weird way to do it for sure, but it does work. can confirm that the tests indeed passed on a pre-anchor version of the code on a different branch.
I'm maybe being dumb though
The way you're using the bump up there looks suspicious to me (I'm a little sleepy though), should it rather be
```.rs
&[
    [seeds.chunks(32).collect::<Vec<&[u8]>>().as_slice(), &[bump]],
]
```
yeah just like above, but it's possible that other stuff changed in the input/previous instructions. I did do a `create_program_address`  to match the keys and they appear to match (the unwrapped enum my test showed me didn't correspond to mismatched keys)
Anchor wouldn't have changed anything with what you wrote above, unless I'm totally missing something
Wait, how are you doing it in anchor though? Just like the above?
i'm talking to some solana internal guys about how to fix those...
really hard to do without logs
it says i'm getting some privilege escalation. I'm not even sure if this is where the error is, but it seemed like the most reasonable guess
No that's fine in anchor—so what's going wrong then?
can i not do this is anchor?
Oh the code is identical
Ok, cool, so that works? How are you doing it with anchor?
haha pretty sure i'm doing this the correct way as it was working pre-anchor:
```
    let new_order_instruction = agnostic_orderbook::instruction::new_order(
        *accts.aaob_program.key,
        *accts.orderbook.key,
        *accts.market_signer.key,
        *accts.event_queue.key,
        *accts.bids.key,
        *accts.asks.key,
        agnostic_orderbook::instruction::new_order::Params {
            max_base_qty: max_base_qty.m as u64,
            max_quote_qty: u64::max_value(),
            limit_price: limit_price_aob,
            side,
            match_limit,
            callback_info: callback_info.to_vec(),
            post_only,
            post_allowed,
            self_trade_behavior,
        },
    );
    invoke_signed_unchecked(
        &new_order_instruction,
        &[
            accts.aaob_program.clone(),
            accts.orderbook.clone(),
            accts.market_signer.clone(),
            accts.event_queue.clone(),
            accts.bids.clone(),
            accts.asks.clone(),
        ],
        &[[
            seeds.chunks(32).collect::<Vec<&[u8]>>().as_slice(),
            &[&[bump]],
        ]
        .concat()
        .as_slice()],
    )?;
```
How are you signing for the PDA?
I've given up on using anchor magic and reverted most of my structs back to AccountInfos because it's easier to control
and the CPI is failing for some unknown reason
but what i think is happening is that i'm trying to sign with a PDA
```
thread 'test_simple_trade' panicked at 'called `Result::unwrap()` on an `Err` value: TransactionError(InstructionError(0, PrivilegeEscalation))', 
```
this is all i have because no message logs 😦
What goes wrong? Like, what error etc?
How exactly does the `is_signer` field of `to_account_metas` work? The comment makes me think that setting it to `Some(true)` is sufficient to allow my PDA to sign, but it seems to break
yea found it. https://github.com/project-serum/anchor/blob/51aeb08ae1c93f9f759c6e244e3fa724c9a916a7/lang/attribute/account/src/lib.rs#L175 called inside `Account::exit`
I don't see why this can't be automated 🙂
but lots from the system program
none from the programs :/
So you don't get any msgs at all now?
It's just kind of annoying (easier to use `init`)
initializing accounts using  the system program directly and not cpi
though not sure if he's dealt with this particular issue before
i guess i can ask armani
sad
Hmm, no idea honestly
after the `msg` logs stopped working
Why isn't what done by default?
but the program itself is kind of a black box when it fails
so i can use this to (poorly) trace where in my test i'm reaching
why isn't this done by default ?
notice how it's tagged with `solana_runtime`
This is a snippet of what currently shows up:
```
[2021-12-23T23:59:06.278363000Z TRACE solana_runtime::system_instruction_processor] process_instruction: CreateAccount { lamports: 555352320, space: 79664, owner: DxLbvXdGt9JzdnQU4cFF4B42ExpqoPw29zs2zVQS6YHh }
[2021-12-23T23:59:06.278454000Z TRACE solana_runtime::system_instruction_processor] keyed_accounts: [KeyedAccount { is_signer: false, is_writable: false, key: 11111111111111111111111111111111, account: RefCell { value: Account { lamports: 1, data.len: 14, owner: NativeLoader1111111111111111111111111111111, executable: true, rent_epoch: 0, data: 73797374656d5f70726f6772616d } } }, KeyedAccount { is_signer: true, is_writable: true, key: 9uTF3Jo8C6LNKJJoWmmmru5A3VxsQ9Zm4j42mqd6X94B, account: RefCell { value: Account { lamports: 999996391455840, data.len: 0, owner: 11111111111111111111111111111111, executable: false, rent_epoch: 0 } } }, KeyedAccount { is_signer: true, is_writable: true, key: 4w3yYhLono52FoguhZD2ULsjxsM8C52obruEkqUVtT19, account: RefCell { value: Account { lamports: 0, data.len: 0, owner: 11111111111111111111111111111111, executable: false, rent_epoch: 0 } } }]
```
when it's a program log
it gets tagged with `solana::message_processor`
previously i was seeing logs with `msg!`
Can you see logs with `println!`?
Aha! Okay so it writes the discriminator in the end. Thought it's left like that
i think i compiles the code down to BPF and allows you to execute against the binary
I actually have no idea how that works now that I think about it, haha
What does cargo test-bpf even do?
stdout
Oh. Have never used that before—where were your logs getting printed when they were working? 🤔
So unless you go out of your way to do something dumb, you can only use `#[account(zero)]` when you're initializing the account (so there's nothing in its remaining bytes at all generally, just zeros)
By checking that the discriminator is zero (and then filling in the correct one at the end of the instruction), you can only have a zero discriminator in very specific circumstances (I can't think of any besides allocating the account in a separate instruction)
E.g. imagine you have two account types like this; they could get confused because their `.data` looks similar:
```.rs
#[account]
pub struct OneAccount {
  a: u8,
  b: u8,
  c: u8,
  d: u8
}

#[account]
pub struct OtherAccount {
  x: u32
}
```
So in this case, if I have a zero discriminator, how will anchor know that I'm passing the correct struct to the program ?
Yeah, pretty sure the regular AccountsExit stuff does it
```The discriminator is defined by the first 8 bytes of the Sha256 hash of the account's Rust identifier--i.e., the struct type name--and ensures no account can be substituted for another.``` just to make sure, does this mean that discriminator makes anchor know that the correct struct was passed to the program ?
i'm testing with `cargo test-bpf` still
actually, I cant find the code for this. But I think it has to be true
wait idk if i can
sounds good
and then the discriminator is still added at the end of the ix by anchor
Try looking in `.anchor/program-logs`
`msg!` doesn't seem to print
E.g. with `#[account(zero)]`, which does indeed skip using them (well, sort of—it asserts that the discriminator is zero, which is different from "skipping" it)
There is still the question of the program longs not showing up
You can't skip using discriminators unless you deliberately go out of your way not to
Hmm, not sure what you mean 🤔
awesome
appreciate it, thanks!
&account.data[..8] = [
    22,
    77,
    255,
    134,
    163,
    41,
    57,
    134,
]
thank god
cool
just zero
i guess not
no
```
    #[account(zero)]
    #[account(mut)]
```
does that work or no
```.rs
#[account(zero)]
pub the_account: AccountLoader<....>
```
the program won't verify the input, but more like deserializes into that struct. So I guess that won't be problematic. What's the need for discriminators if we can stop using them then ?
i think i'm dumb
wait 2 macros right?
Huh, had never noticed that before lol
ah just zero then
is what my compiler is telling me
`mut cannot be provided with zeroed`
and this
u need `mut` and `zero`
for sure let me try it
this I mean
yes you should add that
so didn't really need anchor
I implemented the zero copy from scratch before
could that be the problem?
back then i used `#[account(mut)]`
So no security risk unless you bypass using `Account<'info, Whatever>` aka do something dumb
when i used the AccountLoader
hm maybe it was because i didn't have the `#[account(zero)]`
the function
Right—a zero discriminator is still a (wrong) discriminator 🙂
you definitely need that if you want to use zero copy. send me the code that breaks
I had market_product_group: AccountLoader<'info, MarketProductGroup>,
isn't that what discriminators are for
yeah it was breaking when i had that
Passing an account that have maybe similar byte size but doesn't match the structure
I dont see an `AccountLoader` type in there
Can you say more? What risk do you have in mind?
wydm by instruction
<@!134416332509675520> in that case, the account won't have a discriminator. Wouldn't that cause a major risk ?
```
#[derive(Accounts)]
pub struct InitializeMarketProductGroup<'info> {
    authority: Signer<'info>,
    #[account(zero)]
    market_product_group: AccountInfo<'info>,
    #[account(mut)]
    vault: AccountInfo<'info>,
    vault_mint: Account<'info, Mint>,
    fee_collector: AccountInfo<'info>,
    fee_model_program: AccountInfo<'info>,
    fee_model_configuration_acct: AccountInfo<'info>,
    risk_engine_program: AccountInfo<'info>,
    sysvar_rent: AccountInfo<'info>,
    system_program: Program<'info, System>,
    token_program: Program<'info, Token>,
}
```
sure
Ok could you share your derive(Accounts) and your instruction?
Ah, could be a different tx, or just a separate instruction within the same tx
I know 🙂 I mean the case where we want bigger accounts
No, CPIs are all within the overall tx you started from the client
so in the latter case, there would be a seperate tx (invoke my program + allocate account)?
Not sure what you mean. Your anchor program cpi's to the system program
previously had the `mut` constraint
another unrelated program i have is that my `msg` logs in the program no longer show up in my tests. I added the `zero` constraint.
holy, never knew that init are done using a cpi, kinda weird thinking about it. what program invokes the init?
have you added the `mut` constraint to that account?
yeah outside the program
so not in the program?
After I await the tx that creates the Foo account and then anchor ix that populates it
It's currently just a weird quirk that accounts created via a cpi (e.g. any `init` you do in anchor) can only be 10kb in size, whereas issuing a direct instruction to the system program from the client (not via a CPI) can go all the way to 10mb
where do you check this?
CPI = solana thing where you invoke another program, discriminator = pure anchor thing where anchor writes 8 bytes into your accounts to make sure you don't mistake a Foo account for a Bar account
I see, and what's the relation between cpi and discriminator ?
you can create the account in a previous instruction with a normal system program instruction so it can be larger cause thats not a cpi
all of the fields on my struct are correct besides the first 8 bytes :/
and how does zero make you able to create accounts > 10kb ?
dont think so
Could be that `anchor` and `solana-program-test` just don't mesh well?
if you create the account in a previous instruction (e.g. cause it's >10KB and you cant use CPI) instead of using `init`, then you can use `zero` to make sure it's not used yet
hm for context, i'm migrating over a code base that didn't use anchor over to anchor. It's failing on test cases that previously worked and after the instruction supposedly succeeded, i see that the first 8 bytes are still 0's
```
[programs/foo/tests/common/utils.rs:82] &account.data[..8] = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
]
```
it doesnt write the discriminator but that doesnt matter. anchor writes the discriminator for you after your instruction.
nope, because I don't think that function actually writes the discriminator. It seems to do a check to make sure that the first 8 bytes are 0, but I don't see where it actually makes the copy. At least in my version of the code
```
let mut foo = ctx.accounts.foo.load_init()?;
```
so this doesn't work?
So it needs the discriminator to not fail, but I also have no other way to write the discriminator (which i assume works normally when you do `#[account(init, ...)]`)
I think it must have called `try_from` somewhere and failed on this block:
```
        if disc_bytes != &T::discriminator() {
            return Err(ErrorCode::AccountDiscriminatorMismatch.into());
        }
```
I was getting 3002's when trying to test my code
why are you creating the `AccountLoader` yourself?
why would I need to check that ?
I could try to just directly copy it, but I'm sure there must be a less dirty way to do this
```
    let loader: AccountLoader<'_, Foo> =
        AccountLoader::try_from_unchecked(ctx.program_id, accts.foo.as_ref())?;
    let mut foo = loader.load_init()?;
```
Lets me do stuff, but it doesn't actually set the 8 bytes
how do you set the discriminator of an account that was created in a separate instruction? I'm generating an account >10KB so I can't do it in a CPI
`zero` asserts that the account discriminator is zero. `init` creates an account
what's the difference between zero and init ? <@!134416332509675520>
It worked!
Thank you I will try that!
Ah, yeah, you forgot to mark the givewell account as mut
Can you post your actual program log? I wonder if you forgot to mark something as mut
the author is the provider.wallet for this test
I do this in the .ts file:

// Now lets use our new command!
    await program.rpc.matchIfSmaller(new anchor.BN(donation/2), {
        accounts: {
            // Accounts here...
            matching: matching.publicKey,
            author: program.provider.wallet.publicKey,
            systemProgram: anchor.web3.SystemProgram.programId,
            giveWellAcctInfo: giveWellpubkey,
        },
        signers: [matching],
    });
Has the author signed from the client?
// get the author
        let author: &Signer = &ctx.accounts.author;

        // get the give well account info
        let give_well_acct_info: &AccountInfo= &ctx.accounts.give_well_acct_info;
        //send lamports from the author to give well
        let my_tranfer_instruction = transfer(author_account_info.key, give_well_acct_info.key, matchable_donation);
        //Now we want to pass this instruction to invoke
        invoke(&my_tranfer_instruction, 
                &[author_account_info, give_well_acct_info.to_account_info()],
        )?;



Gives me the error: Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account

But, this has worked for me in another function with the same setup for author, but where the receiving entity is different. Any advice?
Is there a native way to sort on timestamps when fetching? When I fetch accounts they aren't always returned in the order that I created them. I am solving this now by just doing a `.sort` on the frontend.
I think what you need here is ``#[account(init)]`` if you are initializing the matching account. In that case, it's needed as signer. Otherwise you can do ``#[account(signer)]``
Cause you are passing matching as signer, yet you don't have it as a signer in the context
But i keep getting an error "unknown signer"
I am doing it this way:

//Get an account for a public key
    const addressbs58 = "Bazj7if5Gbf7VwEVQjGSfM4kyByrzuRrRoKeje7f2dwv"
    const giveWellpubkey = new PublicKey(addressbs58);

    // Now lets use our new command!
    await program.rpc.matchIfSmaller(new anchor.BN(donation/2), {
        accounts: {
            // Accounts here...
            matching: matching.publicKey,
            author: program.provider.wallet.publicKey,
            systemProgram: anchor.web3.SystemProgram.programId,
            giveWellAcctInfo: giveWellpubkey,
        },
        signers: [matching],
    });
I want to get the account for a given public key address and then pass in the account in a test
Those are the list of attributes that you can use. As far as I know if you do ```pub matching: Account<'info,MatchingDeclaration>``` anchor will check if the provided account follows the MatchingDeclaration Structure
https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html
I want to check in #[derive(Accounts)] if I was really handed a MatchingDeclaration, but I am not sure what to do in the #[account(...)] to do that. Any advice? 

#[derive(Accounts)]
pub struct MatchIfSmaller<'info>{
    pub matching: Account<'info, MatchingDeclaration>,
    #[account(mut)]
    pub author: Signer<'info>,
    #[account(address=system_program::ID)]
    pub system_program: AccountInfo<'info>,
    #[account(address=givewell::ID)]
    pub give_well_acct_info: AccountInfo<'info>,
}
`msg!("Log something {}", something);`
I want to log various values so I know what they are
How do you log things using anchor?
I know right, but thank you anyway, you made me look at the issue from a different approach
Wow, interesting
i tried it, run it back again, the it was installed, with anchor-cli --version : anchor-cli 0.19.0
Then i saw that one on Github as a lifesaver: sudo mv /usr/local/include /usr/local/include_old
because it was giving me a lot of warining
i start investigating this error instead from the log: "error Never include this file directly. Use <lzma.h> instead."
Oh shit, what did you change?
I get it running  and installed 🍾
As long as it's not like derived from some mutating variable is as good as constant. So it's possible per se but the community is going to update the rent exemption amount and give lots of warning ahead of time IF they do update the amount.
Yes fair point, without clear warning this would wreck the space haha
good enough as constant for me
Yeah thus far rent has never changed. You'll get lots of warning
I actually never considered this. I always assumed rent would be constant (or going down if anything, if sol price made it an accessibility issue like it is sorta becoming for program deployment)
When is the account minimum rent exemption updated? Like if it's the off chance that an epoch rolls over and rent exemption is raised right as we calculate rent, is it possible that it is not rent exempt?
account rent exemption. thanks for helping!
Actually this might have something to do with cc, because here's the first that was thrown at me:   error occurred: Command "cc" "-O3" "-ffunction-sections" "-fdata-sections" "-fPIC" "-m64" "-arch" "x86_64" "-I" "etc/hidapi/hidapi" "-Wall" "-Wextra" "-o" "/var/folders/lk/ln8l958s1w52xjm8p_49rmc00000gp/T/cargo-installjJ5iEj/release/build/hidapi-e4c2831a1597e2ad/out/etc/hidapi/mac/hid.o" "-c" "etc/hidapi/mac/hid.c" with args "cc" did not execute successfully (status code exit status: 1).
cc --version: Apple clang version 13.0.0 (clang-1300.0.29.30)
Target: x86_64-apple-darwin21.2.0
Thread model: posix
InstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin
gcc --version:Configured with: --prefix=/Applications/Xcode.app/Contents/Developer/usr --with-gxx-include-dir=/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/4.2.1
Apple clang version 13.0.0 (clang-1300.0.29.30)
Target: x86_64-apple-darwin21.2.0
I would like to help you but I'm not sure I understood the question. Are you talking about account rent exemption, or transaction fee?
Is there any chance that minimum rent will go up asynchronously before a contract is executed? I'm wondering if I should pad the lamport requirement like 5-10% for important transactions.


//////////////////////////////////////////////////////////////////////////////////////////

Gotcha, so if another struct has only a `Pubkey`, I can't use it as a destination address, right? I have a vector of structs, where which struct contains a `Pubkey` of a user that originally passed some data. I was thinking maybe I can use data from this vector to send tips to people who appended the vector.
<@!721030147871866881> is likely onto something. You just hit the next issue in your program so I guess your provider is fine now at least.
all `AccountInfo`s used in a program must be passed into the instruction at the beginning, i.e. must be specified in the Accounts struct (except for `remaining_accounts` which dont have to be specified in the Accounts struct but still need to be passed)
gm y'all,  can I go from `Pubkey` to `AccountInfo`? Trying to implement sending a tip here
workspace pascal cases program names, so it capitalizes first letter of program name. Try `const program = anchor.workspace.GmProgram;` assuming your program name is `gm_program` in rust
tried that
https://github.com/project-serum/anchor/blob/master/ts/src/provider.ts#L46
yeah try using `const provider = anchor.Provider.local();` instead
I believe this is due to how you initialize your provider through `const provider = anchor.Provider.env();`
This probably works in the context of `anchor test` because that command injects environment variables from `Anchor.toml` or some defaults to the shell, before actually running the `mocha` command (I did not check though, so speculating here for now).
There must be another way to instantiate it. `local()` or something like that. Let me see
p.s. im noob @ writing tests
the code.
`const anchor = require('@project-serum/anchor');
const { SystemProgram } = anchor.web3;

const main = async() => {
  const provider = anchor.Provider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.gmProgram;
  const myAccount = anchor.web3.Keypair.generate();
  await program.rpc.initialize({
    accounts: {
      myAccount: myAccount.publicKey,
      user: provider.wallet.publicKey,
      systemProgram: SystemProgram.programId,
    },
    signers: [myAccount],
  });

  account = await program.account.myAccount.fetch(myAccount.publicKey);
  console.log(account.message)
}

const runMain = async () => {
  try {
    await main();
    process.exit(0);
  } catch (error) {
    console.error(error);
    process.exit(1);
  }
};

runMain();`
hi. im trying to run a client.js file but it showing up this `ANCHOR_PROVIDER_URL`
Try this just to transpile and run: 
import {
  // @ts-ignore
  workspace,
  Program,
} from "@project-serum/anchor";
thanks! will have a look
```TSError: ⨯ Unable to compile TypeScript:
mush-sol.ts:10:26 - error TS2339: Property 'workspace' does not exist on type 'typeof import("/[...]/mush-sol/node_modules/@project-serum/anchor/dist/cjs/index")'.```
when I try to run I am getting a compilation error
I see - any known workaround?
Check out this issue https://github.com/project-serum/anchor/issues/1153. I just checked beta release on npm and issue still present as far as i can tell. You can import workspace directly and use // @ts-ignore on the import just to hold you over and run your tests.
Ah, my understanding is that this is a typescript bug in the current anchor version (your code should run fine I think)
<@!134416332509675520> ?
anyone know how to resolve this error in the test file?
```Property 'workspace' does not exist on type 'typeof import("/[...]/node_modules/@project-serum/anchor/dist/cjs/index")'```
```import * as anchor from '@project-serum/anchor';
import { Program } from '@project-serum/anchor';
import { MushSol } from '../target/types/mush_sol';

describe('mush-sol', () => {

  // Configure the client to use the local cluster.
  anchor.setProvider(anchor.Provider.env());

  const program = anchor.workspace.MushSol as Program<MushSol>;

  it('Is initialized!', async () => {
    // Add your test here.
    const tx = await program.rpc.initialize({});
    console.log("Your transaction signature", tx);
  });
});
```
I haven't used the loader a ton so i'll defer to others, but in general it seems unnecessary to perform the same computation of generating the ref more than once even if it's cheap today.
or nah
but wondering if that's important in any way
memory, i g
Do you explicitly trade off anything by storing the ref?
wondering if I should be storing an account or loading every time
is .load() expensive?
This is very helpful!
When testing this in Anchor - do you deploy testnet NFTs, then read the data?
Since it is read-only, I do not need any contract calls yet
It is a rust dependency, i 'use metaplex_token_metadata::{self, state::Metadata}' it at the beginning of lib.rs 
https://crates.io/crates/metaplex-token-metadata
Sure. Thank you! 
How do you have your account read metaplex_token_metadata - is the definition for metaplex_token_metadata taken from another smart contract (the metaplex one) copied to your project?
I'm trying to get something like that working, the project has preminted NFTs, I handle read-only metadata and NFT transfers inside the program. Reading metadata account requires the pubkey of it, and I just use metaplex_token_metadata::{self, state::Metadata} to deserialize it. The pubkey is found like 
    const [metadataPubkey, metadataPubkeyBump] = await PublicKey.findProgramAddress([METADATA, METADATA_PUBKEY.toBuffer(), nftMint.toBuffer()], METADATA_PUBKEY)

If you have specific questions about it, I can elaborate further
How would I interact with a Metaplex NFT from my own smart contract in Anchor? I want to use NFTs in a game
I know I need to have instructions that read the mint, token account, token account auth & metaplex metadata, but I don't know how to code that 
I'm guessing that involves CPI & PDAs, using structs I write that are patterned after the Metaplex ones & can read their data given their smart contract address


//////////////////////////////////////////////////////////////////////////////////////////

I think you could solve some of your problem by making each user account a PDA. This pattern creates a "virtual" or "distributed" hashmap that scales up/down as users enter/exit.  Separately, I'm not sure this is exactly related, but you could explore using a merkle tree as a concise data structure. Here's saber's implementation of uniswap/oz's merkle distributor https://github.com/saber-hq/merkle-distributor.
It might for instance help increase the probability that all NFTs would be claimed in a particular page, and allow rent recovery for it
Some kind of "pagination" might also be something to look into for these huge structures
I'm wondering if with these numbers you will hit compute budget issues
I will try to compute rent cost of a map where entries are `key[NftIdentifier]->Value[userPubKey]` with 30,000 entries and see how unreasonable that value is
Well the "simplest" solution right now seems to be create a map of a size that can fit the max possible entries based on total NFTs in the collection - I'd estimate it to max at 30,000 for my actual project (which is more complex than the example)
Idk how much a map of tokenId->userKey would cost of there was say, 40,000 entries..
As to an immediate solution with some sort of switch between account, I am not too sure, but it's worth exploring
And at that point instead of trying to scale up, maybe I just pay the rent for the maximum
I think there is change coming... sometime that allows resizing of accounts. At least I think I heard that. It would probably solve this issue
There would be a theoretical maximum, as there is a finite set of NFTs in my actual project. It may be a lot 5000 or 10000) but there is a max
Another option would be if I could use a single "resultMap" for all shuffles that is constantly modified and maintained after each shuffle, that would work too, but I'd need to be able to increase the allocated byte size of the map as it grows, since it would reasonably be expected to grow over time as users don't claim in reasonable time. Maybe that's possible...during shuffle, if the alloced bytes for the map is too small, create a new state account with a larger size. I don't know if that kind of code is really feasible though
And you might be able to find ways to incentivize people to claim
Then there might be a separate solution for this issue. A sort of time limit after which an archiver instruction can be run to store those unclaimed NFTs in a more cost effective structure, while claiming back the huge one. Granted this might still end up costing some upfront amount, but that's a general issue of scaling structures at the current price point
And if a shuffle is being done every day...hm
Well you may have to maintain the state of each shuffle for a long time (or forever) if even a single user does not claim their NFT
Yes. And I don't believe it would be too bad. The rent will be non-negligeable for thousands but even then it's feasible. Especially since it can be claimed back after the suffling, so in that sense not really a "cost"
Which, for a program of 100 not so bad, but if it's scaling up to 1000 or 10000 at potential max could maybe cost a lot of rent, but would potentially be a solution
yea maybe! I think that could require storing a large mapping of NFT to owner in state? Maybe you could get away with just NFT->newOwnerKey
(this claiming happening after the "shuffle" instruction has been called and has done its magic on a state account of the program)
Wouldn't there be way to decouple the shuffling from the actual re-assignment of ownership? I'm thinking the only moment you really need to do so is when the users actually come to claim their own shuffled NFT.
It wouldn't require all signatures, but since each escrow account is being mutated they would all need to be passed in the transaction instructions I believe
Why would the shuffle transaction require all signatures? Wouldn't it instead require only the PDA they have been delegated to to sign?
Is there anything I'm not thinking of that can be applied here to better work with the account number restraint?
This restraint on the number of accounts that can be touched in a single transaction feels very limiting to any more complicated programs working at scale. 

Creating an example to reference:
Say a program is being built such that owners of a given NFT collection can sign their NFT over to the program to hold on to. Once 100 owners have done so, the deposited NFTs have their owners shuffled, and afterwards, each owner can claim the NFT they now own.

This would require individual transactions for each owner to deposit their NFT, then one "giant" processing transaction to do the shuffle, then individual transactions as all owners claim whichever NFT they now own.


I am struggling to see a way to do this cleanly if limited to something like 30 accounts being touched per transaction. The "giant" transaction would need (at minimum) all 100 escrow accounts passed to transfer ownership. Breaking this up to multiple transactions creates a number of potential problems, especially WRT fair randomization and managing of state
Thanks!
Yes that raises a ton of problems to my initial design. Will need to think on it
Maintain a var somewhere to say it's mid-processing to lock other functionality while all transactions are being fed and executed
I take it I'd have to break it up into a bunch of transactions, woof
Very problematic, hm
Oh, that'd be problematic
But it's also just kind of awkard in general in solana, because the absolute max number of accounts you can touch in a single tx is ~30 (absolute absolute max) because the entire tx has to fit in 1232 bytes
Oh I've seen that
This is unfortunately kind of awkward in anchor, you'll have to use `remaining_accounts`
Perhaps you pass an array of accounts in the instruction?
Hmm...sort of. If I want a transaction to modify a set of accounts under the program's control and that is a dynamic number of accounts, that is at odds with the current code I've seen where you specific a static number of accounts for an instruction
Oh I see! That makes sense
Can't do it from within your program (you have to pass any accounts you care about into your program from the client)
Like during program transaction execution
What about from rust?
Yep, there's an rpc call for this: https://docs.solana.com/developing/clients/jsonrpc-api#getprogramaccounts
Try printing the actual serialization itself, `println!("{:?}", s.try_to_vec())`, and see if that clears it up
Yeah, can't think of any other reason to use it deliberately (boxing Accounts that is)
```rust
    let s= String::from("abcde");
    println!("{}", s.as_bytes().len()); // 5
    println!("{}", s.try_to_vec().unwrap().len()); // 9
```
Why do I get `9` as output with borsh's try_to_vec?
Can provide more context if needed
Hey all, got a question. 

 Is there a best practice way for a program to track all escrow accounts under it's control at a given time? Maintain a map? Is there a lookup function to get all accounts a program owns?
is the box pointer only used when you expect the stack size to exceed solana's stack limit?
Yeah, wallet accounts are owned by the system program.
this was very helpful, thank you. i remember reading about the 8 byte discriminator, but didn't make the connection it needed to go in the `data` field
Are all externally owned accounts (the ones controlled by people) owned by the System Program?
Key solana mental model thing: if you want to mutate an account's data (moving tokens mutates a token account's data, for example) you always have to go through the account's owning program (only an account's owning program is allowed to mutate it or spend its money). So it only makes sense to ask the system program to mutate/spend some money for an account owned by the system program (so, for example, the system program transfer function is *not* a general purpose sol transfer function—it only works if the source account is owned by the system program, since otherwise the system program wouldn't be able to spend its money)
About your last question, you wouldn't be able to use the system program for this, you'd have to use the spl token program to move/burn nfts (nfts are tokens).
Cool i think i am missing these signers
Yes, but you'll also have to sign for any accounts you're creating (if they live at keypair addresses, as opposed to PDAs)
Thanks for reply.
I have specified signers. But may be not the correct one. 
I should list all the keys which have #[account(signer)] in the Account defination right
Your best bet to figure out how to do the CPI is to read the candy-machine source: https://github.com/metaplex-foundation/metaplex/blob/master/rust/nft-candy-machine/src/lib.rs#L489
Check out the `signers: [...]` argument
You've probably forgotten to sign for an account (in your JS/TS code)
Hello, 
I am writing a smart contract in anchor. I am getting following error message while i am executing tests in typescript.
      Error: Signature verification failed
      at Transaction.serialize (node_modules/@solana/web3.js/src/transaction.ts:583:13)
      at Provider.send (node_modules/@project-serum/anchor/src/provider.ts:116:22)
Does it mean there are not correct signers or the function which i am calling does not have correct signature?
yes. yes
Yep, think so
hi everyone! simple question. is the cost to deploy to mainnet the same as devnet? couldn't find a definitive answer regarding this.
gm sers! I'm in the process of googling stuff about Solana, but I thought maybe I drop a question here because somebody may have already done what I want to implement. 

So, in short, I want to be able to call Metaplex candy machine mint function from another program via CPI (obv, lol). The problem is that I don't know how to set up the context properly. Metaplex docs aren't the best.

Also, my future program is supposed to take NFTs from accounts that invoke it. So, you interact with my program, your old NFT gets taken away and you receive a new one from Metaplex. As far as I understood, you can do this kind of thing via System Program. Is that so?
But the CPI callee can't really be rewritten to support that, since the callee program definitely doesn't own the PDA account that *you* own
What do you mean by works here? If your program owns the account, then yeah, you can yank its lamports—you could then, like, transfer them to a system account that you then pass to the CPI (it's actually a bit tricky to get that to work, unfortunately, b/c of a sorta-bug in solana, but it's possible)
trying to do that rn before asking the CPI guys to rewrite their program
would it work with `try_borrow_mut_lamports` by any chance?
That system program account could live at a PDA though
Right, that won't work unfortunately (you're going to have to find a system program account that can be the payer)
in my case (how I do it right now), the owner is a PDA owner by the caller. 

but the program requires this same PDA to also pay to initialize an account.
 
this is a contradiction as I see it?
So what you're saying might make sense, but I'm not sure yet
PDAness doesn't really have anything to do with ownership (program ownership of an account = program is allowed to mutate an account's data/spend its money)
"to be a PDA (because my caller should own it)" not sure I understand that either 🤔
thanks a lot again! 🙂
i think i was confused because the CPI callee requires this owner to be both the authority, and the payer. i require the authority to be a PDA (because my caller should own it). and i need the payer to be a system-program (for reasons outlined above). 

so both to be separate as I understand (but theyre not right now, leading to this error).
And it'll have to have some money in it 😛
got it. i think this dissolves a lot of confusion! 🙂
It can't be an account owned by any other program
At any rate, that `owner` needs to be a system program account, based on the way the callee is written
Not sure what that means 🤔
The error message above indicates that you're accidentally specifying a payer as a non-system account (won't work)
so I defined this owner as the caller' owned PDA
Right, how are you passing it in though, when you do the CPI? Who is that account when you do the CPI?
yet another account, who is completely unrelated lol
``` 
#[account(mut)]
pub owner: Signer<'info>,
```
That owner account will have to be owned by the system program
Ok, so who is the owner account you're passing in?
Oh, can't read lol
~~I'm confused by that snippet, why isn't there a payer?~~
but on a different account
``` 
#[account(init,
        seeds = [b"exampleSeed",
        owner.to_account_info().key.as_ref()],
        bump = bump, 
        payer = owner,
    )]
    pub position: AccountLoader<'info, Position>,
```
yes
Is the callee program doing an `init` with a `payer` somewhere?
That token account is definitely not owned by the system program (and the callee program isn't expecting it to be)
The error above is about the callee program trying to get an account to pay for something
Ah, that's not the account from the error above
this is the callee's context:
``` 
#[account(mut,
        constraint = &account_x.mint == token_x.to_account_info().key,
        constraint = &account_x.owner == owner.key,
    )]
    pub account_x: Box<Account<'info, TokenAccount>>,
```
(which is the "from" account)
So, not owned by the system program then? Sounds like the callee is expecting a system account
it is currently owned by the CPI callee
Not sure, can you show the `derive(Accounts)` block? Is the source account somehow owned by your program?
hmm. so something is off while generating the PDA probably?
(Or rather, the program you're calling is expecting to be passed an account owned by the system program)
No, that error is about doing a transfer (looks like you're doing a transfer with the system program, but the source account isn't actually owned by the system program—that won't work)
also as a (maybe) very specific example.
I specify an account in the CPI caller as 
```
pub position: AccountInfo<'info>,
```
 (as mentioned above). 
The CPI callee specifies this account to be a 
``` 
#[account(init,
        seeds = [b"positionv1",
        owner.to_account_info().key.as_ref(),
        &position_list.load()?.head.to_le_bytes()],
        bump = bump, payer = owner,
    )]
    pub position: AccountLoader<'info, Position>,
``` 
I get the following error:
```
'Program 3vTbhuwJwR5BadSH9wt29rLf91S57x31ynQZJpG9cf7E invoke [1]',
    'Program log: Depositing reserve to pools!',
    'Program 77yFpTqxesQNz7Styk6yTRBaEcW9LxDKPvA46HfuA77z invoke [2]',
    'Program 11111111111111111111111111111111 invoke [3]',
    'Transfer: `from` must not carry data',
    'Program 11111111111111111111111111111111 failed: invalid program argument',
    'Program 77yFpTqxesQNz7Styk6yTRBaEcW9LxDKPvA46HfuA77z consumed 15912 of 167139 compute units',
    'Program 77yFpTqxesQNz7Styk6yTRBaEcW9LxDKPvA46HfuA77z failed: invalid program argument',
    'Program 3vTbhuwJwR5BadSH9wt29rLf91S57x31ynQZJpG9cf7E consumed 48773 of 200000 compute units',
    'Program 3vTbhuwJwR5BadSH9wt29rLf91S57x31ynQZJpG9cf7E failed: invalid program argument' 
``` 
`Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: invalid program argument`

Is this anything specific to the `AccountLoader`, which requires to be initialized when passed on?(https://docs.rs/anchor-lang/latest/anchor_lang/struct.AccountLoader.html). It says `Namely, one must call load, load_mut, or load_init, before reading or writing to the account`
Right—it's up to the program you CPI to to figure out its own fancy anchor types, you just pass raw accounts
also just to make sure, the input to the CPI calle (the context of the calle) can be all "AccountInfo"s? doesn't have to be any fancy "AccountLoader<'info, CustomDatastructure>" or even "Account<'info, Token>"?
I would expect their own typescript to stay pretty up to date
also, alan, idk how I can thank you answering all these questions (and having worked on NLP before hahhaa). i wanna send you a gift at some point. lmk any of your addresses and i'll be sure to whitelist / send sth to it 🙂
yeah, orca's typescript (because we took the IDL from their typescript hahaha)
But yeah, upgradeable contracts are always a risk unfortunately 😬
For 3. do you mean the orca typescript? Or yours?
1. Nah, probably not super painful (well, depends on how comfy you are doing this kind of thing—it'll just be translating TS to rust basically)
2. You just have to pass the right addresses from the client (into your rust program), and then forward them along—no need to interact with fancy anchor types in any way (at the CPI level those types no longer exist/are relevant—you only use AccountInfo)
got it. for some followup questions xD 
(1) I assume this will be quite painful. Especially if they dont use anchor right? 
(2) if they use anchor, i won't be able to deconstruct the datatypes they're passing on (i.e. whether it is an AccountInfo, an Account<'info, CustomDataTye> or AccountLoader)
(3) whenever the orca contract changes, and the typescript files are not updated, this will introduce "smart contract" risk, right?
Eg. https://github.com/orca-so/typescript-sdk/blob/main/src/model/orca/farm/orca-farm.ts#L60
Ah, ok—no, your solana program can't interact with that frontend SDK. What you could do though is source-dive and see how the orca sdk builds instructions, and do that from within your solana program as CPIs.
so the issue im facing right now is the following:
I want to interact with let's say orca. Orca only has their frontend SDK public though (they don't have their rust code public, e.g.). 
Some logic requires running through a backend that we're writing. I.e. we're writing a solana program rust. 

Given Orca's frontend SDK, is there a way that our solana program (written in rust), can interact with it?

Does the question make more sense now? Sorry if this is a bit abstract and at times confusing.
Can you say more? Don't think I'm following your question. What do you mean by a CPI with just frontend APIs? You can definitely interact with contracts purely from the front end  (that's how you interact with your own program, of course)
You're getting that error because all anchor instructions use the first 8 bytes of the `TransactionInstruction` data as a "sighash" (in this case, pseudo-code = `sha256("global:<ix-name>")[..8]`). So that's what you're missing.
0x64 = 100, which means `InstructionMissing` if you look in anchor's error.rs file:
```.rs
    #[msg("8 byte instruction identifier not provided")]
    InstructionMissing = 100
```
or is there a way to make CPI calls by just having frontend APIs?
im facing the issue where I have access to a bunch of frontend APIs, but no way to interact with these contracts through a program
incredibly naive question: is it possible to make RCP calls on bhealf of a program? I would assume no, or is there some way to achieve this?
i'm trying to understand what Anchor JS is doing undert-the-hood by re-implementing the "minimal example" using  `solana/web3.js`

This is tutorial 0, i.e. the minimal program. there's only one tiny line of code:  `await program.rpc.initialize`. i'm using vanilla `solana/web3.js` to do the same effective call inside `basic-0.js`

it's the simplest possible program, but when i run `anchor test --skip-local-validator`

i get: `custom program error: 0x64`

```
    // anchor tutorial example
    await program.rpc.initialize();

    // me: using vanilla Solana
    await new Connection("http://localhost:8899", 'singleGossip')
        .sendTransaction(
            new Transaction().add(
                new TransactionInstruction({
                  programId: "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS",
                  keys: []
                })
            ),
            [new Account(privateKey)]
        )
```
i'm sure i'm just missing something. does anyone have any insights?

(`[new Account(privateKey)]` is the signer and i made sure it has SOL in my localnet)
thanks for chatting with me on this
yea that was my intuition also
something like that, yes. I have not worked on a use case like this at all, so I might be off, but in general I think it's best for you to avoid trying to scale ws account subscriptions.
for like channel posts
And then just have a channel subscription
Ah yea that seems totally sane
so basically just poll my friends on the frontend
That way you can handle the refreshing of the huge amount of accounts by slowly, periodically querying all accounts of this type (= 1 request, you filter as you wish client-side), and at the same time setup the subscriptions for the hanful of accounts in scope
I do not know if there is a way to listen to changes on a set of accounts using websockets (I'm assuming that's what you are using), but I would advise that (if it makes sense for your use case) you would maybe allow a slower "refresh" time for the data of entities that can reach a huge number (for instance the status of all the Discord users of this channel), and focus the "real-time" feel on more specific interactions (for instance this chat we participate in right now, and the status of users in scope)?
Yea i'm trying to get around an n + X somehow; maybe this is all handled by some caching integration
Have you worked with Message at all? I don't see any examples anywhere and it seems relevant
So I think you are somewhat conflating mutating and fetching data.
Yea that doesnt make sense
I'm trying to figure out a way to constrain the number of subscriptions on the users frontend
I don't really understand why you'd have to make that many requests actually. I you have N users, then their status should be contained in each user's account, and then only mutated by the users themselves 1 by 1, isn't it?
the set_online function is defined in the users metadata program
or not?
yh but the user should invoke those commands, they should pay for it xD otherwise you will run out of money very fast haha
I'm imagining running a loop in a set_online program method and calling a cpi to set_online status in each friends friend list. Would be great to send 100 of those instructions at once instead of one by one
what do you refer to when you say batching here actually? xD
Any good resources for batching for beginners?
good idea
also perhaps you can check if metaplex has some realtime functionality. or games actually, a lot of NFT-using games probably use realtime stuff and encountered the same problem I would assume. perhaps worth pinging or asking around some devs around those communities
but doing anything over n accounts is usually not a good idea, you wanna do hashing / O(1) operations etc. as much as possible (even if you call this one once for every user)
yh its tricky, but i think in reality many solutions are often like this. you can still store the full state on-chain, you would just have an extra "bit" that people can ping to understand if they should fetch their own state. and for each user you have have it fetch a select set of PDAs for example (this way he doesnt fetch everything). thinking out loud here, not fully sure if i understand your issue well
anyways thanks for the help
idk if that works either though cuz then they're getting subscribed to like every single state update across the whole app. And I'm trying to avoid anything thats not on chain to help me learn also it feels like cheating.
oooh something like an on-chain redux hash map state is interesting
my gut feeling wold be to have some logic off-chain. perhaps you could have a global state that keeps track of if stuff was updated or not, and accordingly lets people fetch from it (global state / hash instead of n accounts). idk enough about your accounts and needs tho to answer this properly
Or the friend account subscribed to the user metadata account and then could update state locally
I don't think theres a way around it either. I was hoping a user could just set their online status in their metadata and then it broadcasted that to all the friend accounts that somehow referenced it.
not sure if this is possible. you want to modify n accounts, this will require at least n calls (or you batch them together somehow, but if you have n accounts, it will scale linearly in any case)
tldr; trying to figure out how avoid n + 1000 calls for a friends list feature thats similar to discords
Thanks for the info, I really appreciate all the help I get here.

tldr; trying to figure out how avoid n  + 1000 calls for a friends list feature thats similar to discords

For context, I currently have a naive implementation of a friends list account which just contains an array that holds Pubkeys. My frontend fetches that then fetches the associated metadata to display the personas username, online status, etc.

This is not ideal because I end up making a bunch of network requests 1:1 for metadata, and I end up with a subscription to each of those metadata accounts 1:1 to see when they change their online status. This isn't scaleable because people can have hundreds and thousands of friends.

My next feature is friend requests. This gets more messy with the naive implementation guaranteeing both parties agreed to be friends.

So now I'm refactoring to use a friend program instead of a friends-list program, where I am either the requester or the requested. This cuts down to only two subscriptions for changes. I was hoping I could just reference the accounts metadata somehow and get that updated in real-time. If i have to store that status in the friend account I would have to call setOnlineStatus like 100+ calls to each friend account if I can't just reference their account metadata somehow.
So think my answer would be no
There is no special treatment of account field
I am not sure I understand the question exactly. If you want to make a CPI involving the friend account, you would necessarily have to pass it as part of the input accounts to the program call. That would be completely distinct from the fact that you have a "reference" to this other account in the ForAFriend account.
do those changes propagate?
And the friend definition was `pub friend: Pubkey,`
Hmm, I see, so if the account struct was defined in this program it would be stored in the program but what would happen if it was a seperate account referenced with cpi?
I don't have 100% certainty as I have not specifically tried that, but I would say yes, that would trigger a change event. Afaik these custom-typed fields are just that, structs within the account struct. Maybe your question comes from the idea that this code would lead to 2 **separate** accounts with a relationship between the 2, like for DB entities relationships?
Will changes in a cpi linked account also be broadcasted to subscribers?
Consider this friend account:

```
#[account]
pub struct ForaFriend {
    pub authority: Pubkey,
    pub friend: ForaPersona,
    pub requested: bool,
    pub accepted: bool,
    pub bump: u8,
}
```

If the `ForaPersona` account updates some data, say a boolean, and I am listening for program account changes with  `onProgramAccountChange`  on my `ForaFriend` account. Will it broadcast that change? Or does the data have to be stored directly on the ForaFriend account?
Understood, thank you sir
Just do `from.to_account_info()`, no star.
An AccountInfo is what solana gives you when you pass an account pubkey (address) in from the client. The issue is you can't go from Pubkey --> AccountInfo dynamically, within your rust program; you instead have to have your client tell solana ahead of time "I care about this account"
If I don't use `to_account_info()`, I'm getting the type err
I think I almost got it except for one thing, I'm passing `Signer` struct as a tip sender and I try to use `.to_account_info()` on it, but I get this error
Gotcha, since I don't know the difference between `AccountInfo` and `Pubkey`, I can't get my head around the process. Google mode on
correct, you cant use just the `Pubkey`


//////////////////////////////////////////////////////////////////////////////////////////

yes https://docs.rs/anchor-client/0.19.0/anchor_client/
I didn’t know that, so UIs can use program.rpc in browser?
Is there an anchor client for rust?
No, regular `program.rpc` also gets confirmation (it has to since the provider wallet is the user's phantom wallet, or whatever, and it has to at least pay the tx fees, which requires a signature)
I found the answer it is with package mocha-logger
how to do transaction batching in anchor??
interestingly I found it's from the `spl-token-metadata` lib, didnt go through any CPI execution
Hello,
 Is there a way to log messages in typescript tests file, apparently console.log does not work.
If youre using the newest anchor version, this cannot be an anchor error (they start at 100). So youre probably calling a program via CPI which returns that error.
Pubkey
For a program that doesnt get initialized by the creator. Is there a way to hard code an authority?
Does anyone know for this kind of custom error
```custom program error: 0x1b```
where can I find relevant info? Many thanks!!
also, if you'd like, when my project launches i can send you an NFT 
finished the anchor program and learning React/Typescript, surprisingly almost done with the MVP and dapp despite me asking these basic questions
thanks! appreciate the help
No, I believe only option for fe is manual ix -> sendTx
if i use `program.rpc` function instead of creating an instruction manually with `program.instruction` function, will it also make the browser extension wallet pop up for user to click confirm?

(i was looking on example code online that looks like it created an instruction manually and used solana web3.js lib to sign txn manually)
Yes and I didn't answer your question directly lol! For anchor instruction generator fn you don't pass in signers, just any rpc args and accounts obj.
oh cool yeah im on the frontend, so when user hits approve in browser it will fill in that array automatically 👍
If you're using a browser extension with an npm package, then that package should compute a signature for you with a special sendTx function (i.e. when the user hits approve in browser). On the other hand, if you're working server side, including integration tests, then you need to pass in all signers to sendTx fn or anchor rpc fn.
When instantiating an anchor instruction, do I have to populate the `signers` array right away? Or does it automatically get populated when I sign the transaction with the wallet?

```
return program.instruction.myInstruction(
         {
           accounts: {
             user: provider.wallet.publicKey,
             systemProgram: SystemProgram.programId,
           },
           signers: [], // <-- do I have to put the Keypair for the "user" here now? or does signing the whole instruction do this automatically 
         });
```
don't remember anymore, but my hunch, knowing a bit more about anchor, is that you can only collect current events. You'd need to parse the chain and store past events manually I think
Without seeing the code, it sounds like the issue is that the CPI to token program is missing a signature for a valid MintTo call. If you wrote the program making the MintTo CPI, then you can potentially add the fix at that call is my guess with proper signer seeds using a pda as mint authority. If you can send through the signature from the parent or outermost CPI, then that should work as well--I'd love to test that. I'm not sure implications of mint authority being the mint itself, I haven't seen that before.
mint::authority = mint // < this is the field name during init
however, it's not a signer, and its authority is set to itself via
I'm getting signer's priviledge escalated on the Mint struct/account
the rebase instruction calls MintTo, which is another cpi
im having the multisig program approve and execute a rebase instruction on another program
is it possible to call a cpi through a cpi?
Did you ever get an answer to this? I'd be curios to know what any alternatives are.
```
```
And you can type nicely-formatted code blocks by doing three backticks "`" + your code + three more backticks
No, this is something else (the error message is trying to tell you what, but that error can show up for some surprisingly non-intuitive reasons)
Can you show your whole instruction function?
I own the account I am trying to decrement, but not the one I am trying to increment. Is that the issue?

Or is the issue that the escrow is at a PDA address?

Or is the issue something else?
When I run this:


        //Declaring in this way to make readability easier
        let dest_account_info = give_well_acct_info;
        let source_account_info = escrow_account_info;

        let dest_starting_lamports = dest_account_info.lamports();
        **dest_account_info.lamports.borrow_mut() = dest_starting_lamports
            .checked_add(donation_amount)
            .ok_or(ErrorCode::OverflowError)?;

        let source_starting_lamports = source_account_info.lamports();
        **source_account_info.lamports.borrow_mut() = source_starting_lamports
                .checked_sub(donation_amount)
                .ok_or(ErrorCode::OverflowError)?;


I get the following error:

   Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: sum of account balances before and after instruction do not match
You'll have to do something like this:
```.rs
fn transfer_from_account_we_own(
    src: &mut AccountInfo, // we better own this account though
    dst: &mut AccountInfo,
    amount: u64,
) -> ProgramResult {
    **src.try_borrow_mut_lamports()? = src
        .lamports()
        .checked_sub(amount)
        .ok_or(ProgramError::InvalidArgument)?;
    **dst.try_borrow_mut_lamports()? = dst
        .lamports()
        .checked_add(amount)
        .ok_or(ProgramError::InvalidArgument)?;
    Ok(())
}
```
This is a key mental model thing to understand about solana: if you want to mutate an account's data or spend its money (<-- what you want to do now), you have to go through the program that owns the account. You're trying to use the system program's `transfer` instruction to transfer some money from one of your own program's accounts. That doesn't work in solana—because the account is owned by your program, *only your program* can spend the account's money (the system program can't do it for you because it doesn't own the account).
Hi I get the error:
"
    Transfer: `from` must not carry data"

When trying to transfer funds. I tried to solve this by createing a new empty kind of account:

#[account]
pub struct Escrow {}

But it still contains data. And I get the same error about from must not carry data. 

How can I create an account that can hold lamports such that it can be from the address in a transfer instruction?
in my programs/chainlink-pro/cargo.toml file
```
[dependencies]
anchor-lang = "0.18.2"
anchor-spl = {version = "0.18.2"}
spl-token = {version = "3.2.0", features = ["no-entrypoint"]}
solana-program = "=1.8.0"
borsh = "0.9.1"
borsh-derive = "0.9.1"
chainlink = { git = "https://github.com/smartcontractkit/chainlink-solana", package = "chainlink-solana", features = ["no-entrypoint"] }
```
what's the matter?
help me
```
Failed to obtain package metadata: Error during execution of `cargo metadata`:     Updating git repository `https://github.com/smartcontractkit/chainlink-solana`
error: no matching package named `chainlink-solana` found
location searched: https://github.com/smartcontractkit/chainlink-solana
```
when i run anchor build, error occurs
and i did the same in anchor project
i successfully built solana-chainlink-demo project on github
hello, i am having trouble with solana chainlink
I am getting the following error: 
"Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: invalid program argument"

I have determined it is coming from the following line:
        invoke_signed(&my_tranfer_instruction_1, 
                &[declaration_account_info, give_well_acct_info.to_account_info()],
                &[&seeds], 
        )?;

Where seeds and the transfer instruction are defined as follows:
let (_pda, bump_seed) = Pubkey::find_program_address(&[b"givewell"], program_id);

        //send lamports from the declaration to give well
        let my_tranfer_instruction_1 = transfer(declaration_account_info.key, give_well_acct_info.key, matchable_donation);

        let seeds = [&b"givewell"[..], &[bump_seed]];
        //Now we want to pass this instruction to invoke_signed
        invoke_signed(&my_tranfer_instruction_1, 
                &[declaration_account_info, give_well_acct_info.to_account_info()],
                &[&seeds], 
        )?;

I am having trouble figuring out what is wrong
Thanks! I was missing a signer
Take a look at the target/idl file for your program, it will list each account that needs to sign
(They can't sign from the client—only their deriving program can sign for them, not possible to do it on the client)
No
Can a PDA be passed in as a signer?
E.g. if you're init-ing an account that lives at a keypair address, the address of the new account needs to sign too
You likely forgot to sign the tx with a necessary signer
What generally causes a 
    " Error: Signature verification failed"
error?
About signing transactions for the account, that's not a question of program ownership—your program can sign for one of its program-derived address regardless of which program owns the *account* that lives there.
So you have to find the address on the client and pass it in as an account
You would then call this in JS like
```.js
const [theAccount, bump] = await PublicKey.findProgramAddress([Buffer.from("something")], program.programId);

await program.rpc.someInstruction({
  accounts: {
    theAccount: theAccount,
    somePayer: program.provider.wallet.publicKey,
    systemProgram: anchor.web3.SystemProgram.programId
  }
});
```
So you're trying to create an account that lives at a PDA? The easiest way to do it is with anchor's `init` attribute:
```.rs
#[derive(Accounts)]
pub struct SomeInstruction<'info> {
  #[account(
      init,
      payer = some_payer,
      seeds = [b"something"],
      bump,
      space = 8 + however_much_space_you_need
  )]
  pub the_account: Account<'info, Whatever>,
  #[account(mut)]
  pub some_payer: Signer<'info>,
  pub system_program: Program<'info, System>
}
```
I'm sorry I feel really lost with how to actually write something here. I think I get the PDA by doing this:

let program_id: &Pubkey = &ID;
let (pda, _bump_seed) = Pubkey::find_program_address(&[b"somthing"], program_id);

But now lets say I have some account passed in by the client:

let declaration: &mut Account<MatchingDeclaration> = &mut ctx.accounts.matching;

Can I do something so that later this program can sign transactions for this account? I tried doing this with assign:

  let owner_transfer_transaction = assign(&decl_acct_pubkey, &pda);
//Now we want to pass this instruction to invoke
            invoke(&owner_transfer_transaction, 
                &[declaration.to_account_info()],
            )?;

But this gave me the error "
     Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: instruction illegally modified the program id of an account".

If not, do I need to create a fresh account in Rust? I thought you needed the client to pass in all accounts?
No, no return values from calling your contract. You can fake it though by passing in an account where you want to write the return value
can you return values from the rpc? is it bi-directional? also how does pyth network work on the rust package, if you cant get return results on the rust side (akin to first question)
Accounts that live at PDAs are created in the same way as any other account (their only peculiarity is in how you sign for the address)
What is the CPI call to make an account at a specific (PDA) address?
Currently thinking the best solution I'll have is changing my overall program structure to limit the max number of entries in this state mapping to a more reasonable amount, reducing rent costs probably by a factor of 10x, and then just pay the rent cost at that point. We shall see.
fair enough 🙂
I would think it is, but I never really worked on interacting with these so I might be off.
ah, if the only way to access the IPFS data during program execution is passing as a TX arg, then yes, I likely would run into tx size limit
So the idea would be to make a hybrid client retrieving that structure from a storage oriented blockchain (Filecoin/Arweave) and passing it as argument to the program call? Cause I think you'd again hit tx size limits
LOL, I will try to avoid this, thank you so much!
ok one last question for now WRT the large amount of state I need to keep track of described above (a map of pubkeys that could be as large as 30,000 entries). 

I'm not familiar with IPFS, but is it worth exploring trying to store this map off-chain on IPFS to reduce costs?
Effectively creating a DOS attack
Fun fact: this (needlessly marking an account as mut) is what lead to one of the Solana slowdowns a while back. Some bot marking their accounts as mut for no reason and spamming like crazy.
Oh I see thank you!
It is not a vulnerability to your program per se, but is not a good thing as it will prevent parallelization of transactions accessing that account.
Will it be any vulnerability if I make one account `mut`, but actually not change data or lamports during the tx?
You only need stuff to be mut if the tx will modify its data or lamport balance
And thank you <@721030147871866881> as well of course. This convo is a huge help even if I'm still unsure of feasibility
I'll mark it down for looking into
Incentivize how?
Last thing i'd look at is something like serum's queue model as well. You can incentivize off-chain actors to do the churn of writing to many users' accounts.
Yea very good points. That would be hyper complex. I hope I can find a clearer way
Sorry, another question, should signer be mut? Because I saw some  source code they set signer to `mut`, but none actual data change on these account. Just curious if there are any vulnerability if list a account `mut`, but actually not necessary.
Thanks <@915682383905316864> for the help. Unfortunate realization that my project will have a far, far higher rent cost than I anticipated. Really hope rent reductions are on the horizon as I fear it could kill the project at current costs
The rent issue was initial gut thing which made me suggest pda-virtual hashmap. So even with pdas as keys for map, you'd have to do something batch together tx that mutate max accounts per remaining accounts array (including robust validation/checks of those accounts once on-chain) and then cache which accounts have already been mutated (if one-time, could use bool flag which would be nice).  Pattern is a little rough and requires a lot more client-side work with generating pdas and formatting remaining accounts array. Also on-chain validation of remaining accounts is crucial. You could also batch together user structs in PDAs and assign user indexes/nonces instead of using their wallet as a seed but that too requires more off-chain management.
I see, thank you so much!
There isn't much difference, though Signer is slightly nicer because it encodes the signing-ness in the type
May I ask another question about signer? I saw we can announce a signer in two ways in Anchor one is using #[account(signer)], another way is using `Signer<'info>`  do you know any difference between these two?
Thank you!
So I would say yes, mark it as mut
Sometimes you can get away with leaving it out (because the payer happens to be the provider wallet, which is automatically mut), but yeah, the payer does need to be mut at the end of the day
Hello guys, should we always make an account #[account(mut)] if it is a payer in struct?
You could try it in rust directly, maybe: https://stackoverflow.com/questions/68255026/how-to-get-memory-occupied-by-an-object-in-rust-from-the-code-itself
I easily could have made a mistake here though
assuming each map entry is 64 bytes total (unsure), a max of 30,000 entries would potentially calc to $8,000 rent
welp no idea if this is accurate but
https://bbodi.github.io/notecalc3/notecalc#eJx90MtKxTAQBuD9PMWAro7gqc2xuPENBBc-wJDWKQZzIxewb--kByRCNYuQMF_-STJvhTNFTuTXQnpZQvWFYp0_ecNnVCPMP6JmmfoSdEWnI7EvqZXm_0Lv8DARfHV7gOHc0gcZAOczThc0GQ8awQ3mYLXXmGQvrum23Fk7QBvrJGHDfUsb1OUJ315ffjGOYfnoyPR4NTvgL3axkDPeuOpECXpQalLjbgBiMgtTWEkuQsbTe7BWp3b_cRjwVkSfc9VrSLRWa9tDBB41whP2v3HCP_oAfAP-DplQ
Would bytes-per-entry of the map above be 32+32? (NFT escrow account key + user pub key)
Haha. Not sure if the merkle tree might be usable on the data structure part, though. Haven't looked into that.
You're totally right. Back to drawing board.
Yea that was my thought as well
Wouldn't this hit the issues initially mentioned, of capping how much NFTs can be shuffled to the amount of accounts that can be passed as inputs to the call?


//////////////////////////////////////////////////////////////////////////////////////////

Thanks gary and alan 🙂
A transaction can consist of multiple instructions that are executed atomically. Use `program.rpc` to run a transaction (and you can specify prerequisite instructions that will execute before the RPC , that will run before the actual RPC call). Use `program.instruction` to include it as a prerequisite instruction to another RPC call in a transaction.
That said, with a Keypair.generate() you *also* need to remember the address itself, since it's random (whereas for PDAs you get to pick memorable seeds)
You only need to worry about custody of that private key if you subsequently need someone to sign for it
program.instruction just builds the instruction, it doesn't actually run anything
What do you mean by "for a wallet account"? I'm assuming by a wallet account, you mean using the `Pubkey` of the user's address (of which the private key is stored in their hardware wallet / browser / etc).

The main thing I'm trying to avoid is using accounts generated through `anchor.web3.Keypair.generate();`, since that would require custody of the generated private key. So I'm assuming the implementation of the above statement would _not_ involve this line and instead just use an already existing `Pubkey` such as the user's address. Am I misunderstanding your intent?
What's the difference between using `program.instruction` and `program.rpc`?
But e.g. for a wallet account, it wouldn't make sense to use them
Yeah, that could be a reason to use PDAs
`simulate` might be handy if you don't actually want to run the tx for real, just see if it errors etc.
What if you don't want your end user to have to custody the private key of the created account though (which would be needed for signatures)? In that case, should you use a PDA? (Let me know if I'm misunderstanding something)
<@!134416332509675520> Why use `program.provider.simulate` instead of just `program.rpc.myInstruction`?
That's how I learned
💯  thanks
1. Check out this tutorial: https://hackmd.io/@ironaddicteddog/solana-anchor-escrow
2. Then go through all this code because it's way better and solves some of the problems of hackmd's version: https://github.com/cqfd/quidproquo/tree/main/programs/quidproquo
https://github.com/cqfd/quidproquo/tree/main/programs/quidproquo
hey can anyone tell me where i can get more anchor programs for learning 
i have read four examples
Basically anchor's `Account` type already checks this stuff for you, so not sure why you need to test it yourself
Sometimes you just can't think of any good seeds to use. Sometimes you really want the user/some human etc. to be able to sign, rather than your program itself
Why are you trying to test for this? Are you worried about seeing incorrect discriminator bytes?
If you use a side program then the account will have the wrong owner, so don't think that will work either
Super helpful. Thanks alan
As a rule of them, when should you not use a PDA for an account and instead use a regular account?
and then pass the account in to the actual program I'm trying to exploit <@!134416332509675520> ?
okay so have a side program just to allocate with a desrim
I think you could do e.g.
```.rs
#[derive(Accounts)]
pub struct BogusDiscriminator<'info> {
  #[account(init, payer = some_payer, space = 8)]
  pub account: AccountInfo<'info>,

  #[account(mut)]
  pub payer: Signer<'info>,

  pub system_program: Program<'info, System>
}

pub fn bogus_discriminator(ctx: Context<BogusDiscriminator>) -> ProgramResult {
  // go write those bytes
  Ok(())
}
```
This is my first time writing a Solana program and I'm not sure if I used the best style. Ideally I'd like the program to be top-notch before going to production (from a security perspective as well). Does anyone have any auditors they recommend (free and paid)?
hmm
With your own custom instruction
If you treat it as an `AccountInfo` then you can write whatever you want in there
You could have the account be owned by your program though, and just never interact with it as an `Account<'info, Whatever>` (that will auto-write the right discriminator bytes)
hm okay
While it's still owned by the system program? Don't think so, no
I want to test my program with bad accounts. so when I first create an account it's owned by the systemprogram, is there an instruction i can invoke to modify the data to include some rand 8 bytes desrim?
No, all writes have to go through the owning program
Figured that's the example you were referencing in this case! Thank you!
is it possible to set the 8 byte discriminator of some randomly created account using the web3 pkg?
But a good example to look at is associated token accounts: they're owned by the spl token program (like all token accounts) but their address is derived from the associated token program (totally different program).
You would find the address using `A`'s program_id, and then use program A to CPI to the system program when you create the account. A can sign for the address using `invoke_signed`, and the `system_instruction::create_account` instruction lets you set the owner.
Why use `program.provider.simulate` instead of just `program.rpc.myInstruction`?
Do you literally just use `findProgramAddress`, input program A's address, and then set the owner to program B?

Also sorry if this question is obvious, but how can you set an accounts owner?
Thanks for the detailed response!

One additional question, how would you derive a PDA from program A but set its owner to program B?
So to summarize: 1) basically can't change an account's owner (once it's owned by a non-system program it's too late); 2) being able to sign for an address isn't relevant for writing to the account that lives there—that's purely up to the owning program (it may ask for a signature but it doesn't need to); 3) accounts that live at PDAs are *not* necessarily owned by the program that derived the address (and program ownership is the only thing that's relevant to being able to write to the account's data or spend its money); and 4) being able to sign for a keypair account doesn't let you write to the account (again only program ownership lets you do that).
Knowing the private key for a keypair account doesn't let you mutate the account (only the owning program can do that, and it doesn't need a signature to do so—it might ask for one for program-specific reasons, but it doesn't need one)
For example, you can have a token account (owned by the spl token program) that lives at an address derived from your program—that means your program can sign for the address, but it doesn't mean your program can write to the account!
PDAness of an address is independent of which program owns the *account* that lives there
And *only* the owning program can ever write to an account's data or spend its money
You can only change an account's owning program once, from the system program to some other program (so, effectively you can't change the owner once it's owned by your program)
+1 ^
How do you change an accounts owner? Is it possible to write to an account as long as you have the private key for that account, or would you also need to be the owner (so you would need to be owner + have a signature on the account)?

One thing I'm confused about, is why would you want to use non PDA accounts in your programs? PDAs have clearly defined rules that they are owned and can only be modified by the program that created it, while it seems that user generated accounts could be modified by the private key at any time.
Thanks alan 🙌
wowwww i would have never known that
Usually `await program.account.yourAccountType.fetch(theAddress)`
Btw do you guys know if a program already exists to do staking / unstaking custom tokens in solana .. basically would like to lock the tokens when someone is staking
(My program owns the account)
In my tests, how do I deserialize this account's data and actually read it?
Got it
Mm, unfortunately no, you'll have to manually replace the declare_id! part *and then re-run anchor build before deploying*
It will replace that when I do anchor build ?
Aaah 😌 got it
Anchor just happens to hard-code an id when you generate a project, but it will generate a real one when you first run `anchor build`
No, the program id you'll deploy at is generated (amongst other ways) by `anchor build`
In anchor examples they have that declare_id! before we even deploy the program, trying to figure out how to get that
<@304790899785728000> thanks for the explanation but isn’t program-id generated after you deploy the program ?
Yeah that makes sense thanks, I'll dig around and see if I can find another example, maybe Jet
I don't think that example actually uses pyth itself, it's just an example of writing your own oracle
Im just starting to look at pyth, is the example on anchor github for consuming or publishing data, I can't tell what's going on hehe
that's straightforward 😛
gotcha XD
`mint::freeze_authority` 😛
```
#[account(
        init,
        payer = payer,
        seeds = [...],
        bump = bump,
        mint::decimals = 9,
        mint::authority = mint, 
    )]
    pub mint: Account<'info, Mint>,
```
How can I set the `freeze_authority` as well here?
What have you tried so far?
If you regenerate a new keypair then yeah, subsequent deploys will use it automatically (remember to update your declare_id! though!)
Thanks <@!134416332509675520>, is there a way for me to force Anchor to deploy it into a new programId?
No, the keypair file is a full keypair (public *and* private keys)
I'm trying to write a contract that does the following: 
* take some amount of SOL from an user account
* return either nothing or the double amount
Quite simple 😉 can anyone point in the right direction?
Can I infer the keypair file from the programId then?
I was trying to work on a different computer, I assumed the target folder would be deterministic and would rebuild anyways 😅
Why are you deleting the target folder?
`target/deploy/your_program-keypair.json` is the address at which you'll deploy your program, so don't delete that if you want to keep using that same address
After deleting the target folder and rebuilding it with anchor build, I think I gave lost the ability to upgrade the contract. I was able to call 'anchor deploy' repeatedly on devnet, to successfully upgrade the program. My filesystem wallet keypair did not change. Every time I rebuild the target folder, I get a different keypair file in the target/deploy folder. 

Is there a way for me to continue to be able to upgrade the program? Do I need to record this generated keypair as a secret for all my projects along with my wallet keypair?
yeah, the problem is in ensuring deterministic builds I guess - which this takes care of by using a docker image with pinned deps
wah ok there is the methodology
https://project-serum.github.io/anchor/getting-started/verification.html#verifying
yeah i believe this would work
<@!499334426828865547> Did you find the answer? I would think dumping the program from mainnet to a local binary, and computing the sha for comparison, somehow, but I'm not certain.
Q: do all the relevant accounts need to be passed into a solana program, or is there a way to do lookups inside of the code? in my case, I have hardcoded account ids and it would be nice to lookup that account info in the actual rust program instead of having a client look it up + pass it in as an instruction. is this an anti-pattern / not allowed? it would be nice to not have to trust the client to lookup/pass data in properly and to just do it all on the "backend" in the rust code for the actions that are read only
the declare_id! macros defines the public key of the program, aka the program id. a program is just a solana account that is executable, and like all accounts it has a public key (which is synonym for program id). when you call instructions on a program, that program_id is passed as context. when an account is created with an owner of that program id, only that program can write data to that account (anyone can read/credit it though) and that is enforced by the solana runtime. might be missing something so hopefully someone else can fill in any gaps; in fact, I am wondering myself if there is any use for the private key that accompanies the public key/program id for a program?
Is there any way to ensure that instructions can never be called alone- that is, ensure that multiple instructions bundled into a single transaction are never run independently of each other?

Or do I have to always assume that I need to design instruction calls such that the program can't be exploited and can recover from a mangled state where it runs one instruction but not another (in the case that, somehow, a user decides to call my program from their own client with their own manually bundled instructions into different transactions)

Is the best way to do it to just write multiple programs and then call CPIs to the other programs from within a larger, overarching, program? I assume this isn't the elegant way to do it
Is that just a pub key 🔑 for a main account ? I can’t seem to find a good explanation on that
Hi guys .. I am new to rust but I am still very confused about declare_id! Macro .. what id are we hardcoding there ?
Is there no way to *get* an existing mint of type `spl.Token`? We can *create* a mint of type `spl.Token` by using `createMint`
GM! Does anyone know of a repository or some example code that does a cpi call to a program deployed on devnet or mainnet? Something beyond the anchor tutorial :)
is there any reason not to have error come with a readable error as well?
i thought i was doing something wrong with anchor but `Err(JupiterError::SlippageToleranceExceeded.into())` not printing a human readable error is just normal
Is there no way to `getMint`? I know we can do `createMint`
given a tx address on localhost, how can i find out information about the transaction? (compute units used, cost, etc?)
Ooo interesting, good tip. Thanks alan 👍
One pro tip (since this came up on twitter): it's usually helpful to just jump right to the source, since the instruction handlers are usually not too bad to read: https://github.com/solana-labs/solana-program-library/blob/master/token/program/src/processor.rs#L488
My b. But I wish the error logs were more descriptive
I never actually created a token account for `depositorTokenAccount` .
Where is the bang head on table emoji?
My guess is that you're trying to send it to a token account whose mint is different (you make the mint right above the `mintTo` call, so how do you already have a `depositorTokenAccount` lying around with mint = `stablecointMint`?)


Can you show the whole program log?
mintTo
Which one fails?
<@!134416332509675520>  any idea?
I've tried changing all the data but nothing works
```
// Mint
stablecoinMint = await spl.Token.createMint(
  program.provider.connection,
  mintCreator,
  mintCreator.publicKey,
  mintCreator.publicKey,
  9,  // decimal places
  spl.TOKEN_PROGRAM_ID
);

// Mint To
await stablecoinMint.mintTo(
  depositorTokenAccount.publicKey, 
  mintCreator, 
  [], 
  1000,
);
```
This doesn't work. I get the error: `Transaction simulation failed: Error processing Instruction 0: invalid account data for instruction`
aah, I see. Good
ProgramAccount is actually deprecated now, you can just use Account!
<@!134416332509675520> , What's the difference between ProgramAccount and Account?
```
pub staker: Account<'info, Staker>
pub staker: ProgramAccount<'info, Staker>
``` 
staker is a PDA. I think they are same.
damn. not sure how I'm going to log all this data then
I don't think you'll be able to write anything directly during program execution (your rust/solana code, that is), since the only "writable media" your program itself has access to is account storage
So now that I understand how expensive storing data on-chain is, I'm trying to find alternative ways to preserve some data that I want to be able to fetch from my frontend, but don't actually need available for anything on-chain in the future (though having that as a possibility is a good thing).

I want to be able to write the data directly during program execution and have the user executing the transaction pay the cost. 

Is this the type of thing that Arweave is built for?

Every "run" of my program would generate data that could be roughly 20-120 kB. arweavefees.com says that would cost ~$.002 which seems incredibly good. Just unsure if I can apply it here.
Yep, that's the state of the art I think (just have to live with a little editor confusion about anchor sometimes)
You can do `Rent::default().minimum_balance(size_of_thing)`
Also any general advice on VScode extensions to add to rust? I have:
Rust v0.7.8 by "The Rust Programming Language" 
and
rust-analyzer v0.2.842 by "matklad"

Though the rust-analyzer seems confused by anchor and solana imports. Anyway, suggestions for nice extensions you have found would be awesome!
How can you in rust get the amount of lamports required to make something of size X rent-free?
also sounds like a bug
sounds right
Assuming I'm guessing the right issue (justin starry told me about it): https://discord.com/channels/889577356681945098/889584618372734977/915190505002921994
I'm still confused tbh
Yep! Bet the reason why switching the order fixes things is one of the "surprisingly non-intuitive reasons" I mentioned, solana can be weird
LOL LOL LOL with <@!501570363566587905> 's help the problem was that I was doing two transfers. One from an account my program owned by directly altering lamports, the other from an account my program didn't own (the "author" of the transaction).  

At the start I did the direct lamport edits first then the invoke transaction. This would error.

When you switch them (first you invoke a transfer then you directly alter lamports) it works.
Thanks Alan
7 SOL/mb sounds so crazy expensive lol, I know on-chain storage is always said to be expensive but damn
but at current prices this would cost me ~$1,600 which is a hell of a lot better than the $8,000 my last design would have cost. Chances are I'm missing some complexity I'll find out later but, hey, improvements are improvements
🤞 since I assume if it changes it will bring cost down
Nope (though it might)
Again I have heard rumblings it may be more efficient in the future but nothing concrete
That is a useful benchmark. That rent exemption cost hasn't changed like ever, right?
Sounds plausible (easy number to remember is rent exemption is about 7 sol / mb)
(back from my convos yesterday) Iterated on my design a bit, I'm attempting to estimate rent for a single large array, size of 5000, where each entry is essentially 5 pubkeys, some bools, and a u64.
I believe I've calculated it correctly here, estimating it to cost approx 7.97 SOL. 

Would appreciate anyone taking a look to tell me if anything seems off. Thanks!

https://bbodi.github.io/notecalc3/notecalc#eJx1kF1OwzAQhN99ipHgoZSK_NBQFYkTgASCA1hOsiGWHDvyj0o4PZsEpD6Ut7U8883sZhneyUY0yjTJqKidRec8lIXyXk1wHYL-JlR5nu9w6skTSDU92OUn9M60AbEndhnjTtp-olVRPYosQ4W3VD_TFHY81s4ZHpwlpIe9qKdIQY7k5ZIjV9wTyvIItm7uS2xR3eAWm-JvYptNwyLVFFg8lxK_qC4ZI-doGaJPTeRvXA7Z4owixBWCM8oq-PkQRbFfqPND0hcNY5SDtnpIAxMPd8cDPl5fhBCj1w1J10l2S21ly_srP7cq8xzXrDhHrGq-7NpzUCMLL2Vwu3_I4gfx0Y6s
gotcha, that makes sense. Thanks alan 🙂
u64
what size of unsigned int would be used for balances for something like USDT/USDC/UST?
Ok, cool (fwiw, knowing it within the program itself would either require you to just hardcode it, or look it up via the bpf upgradeable loader account)
I was trying to know the public key of the authority from within the program itself. No worries, I found another solution that avoids needing to know the authority all together 👌
hey everyone! I am trying to figure out how to use types from other libraries inside of my anchor program: example I want to use solana token lending program types (ex. `Reserve`) in my code. are there examples somewhere of how to do this?

I am a little stuck and am new to anchor/rust so would appreciate any resources/examples.
I think the upgrade authority by default is just your solana keypair (you can set it in Anchor.toml): https://docs.solana.com/cli/deploy-a-program#set-a-programs-upgrade-authority
i kinda just see that as the "owner" of the program
yeah ^ authority to deploy the program
Authority to deploy the program?
Sorry—what do you mean by "authority" though? Like, which address are you talking about?
By owner, I meant the authority of the program

I was trying to gate an instruction so it can only be called by the authority of the program. In the instruction, I would do something like: `if program.authority != payer.id { throw Error }`

But this kinda seems like an anti-pattern, because smart contracts should be fully usable by anyone in the world it seems
I think I asked this earlier, but what do you mean by owner? If *you* don't know the owner id then you're kind of in trouble (presumably *you* are the owner, or at least some keypair you control is, assuming you're able to deploy the program)
You could hardcode the address into the program, or if you really want, you can dynamically load who the current upgrade authority is (if there is one): https://github.com/solana-labs/solana/blob/master/sdk/program/src/bpf_loader_upgradeable.rs#L45
how do you know the owner ID tho?
with an account signed by an owner
You can store the owner's id inside a PDA account, pass this account inside your instruction and verify that pubkeys match?
Question: How do I make an instruction only callable by the program owner?
If you're not reading/writing them, you can store their keys in a program-owned account. Then, just pass in the program-owned account's public key into your instruction
Maybe this requires a redesign of your program architecture
Why pass all 12-13 accounts in? Are you read/writing them all?
oof yeah
It is just that with Anchor I started to hit limits with approximately 12-13 accounts (even though I `box`ed everything inside contexts)
Thank you! :3
<@!788122420765917184>  ^ that is what someone said in the Solana discord space
""it can vary based on what is passed in, but i recall around 30/ish atm has been able to fit, and the transaction size 1232 bytes, around 15+ I would start looking to see what your numbers and size are. this may be increasing in the not to distant future""
i gotchu 1 sec
Good day! In general, how many accounts can I pass into a single instruction?


//////////////////////////////////////////////////////////////////////////////////////////

i dont know typescript/javascript much, had a hard time finding it
ahhh there it is! thank you! it was really bugging me lol
This part maybe? https://github.com/project-serum/anchor/blob/master/ts/src/program/namespace/state.ts#L245
I'm trying to understand the what the generated code is doing in ctor(). The call to private::Ctor::try_accounts(prog_id, &mut remaining_accounts,....). I cant find where the in the client code the accountinfo argument is formed. Specifically the from, base, to, system_program, and program accountinfos.
But that intentional error is happening here: https://github.com/cqfd/quidproquo/blob/main/tests/quidproquo.ts#L182
Don't think there's an easy way to prevent that error from logging, at least as far as I know
Hi everyone . I'm so glad to be here. I have a question, I'm writing NFT staking pool. But I need more resources to write. can someone help me?
I think the code looks working well, where does the error come out?
expected error? is there any way to remove that errors?
Can it be that it's refetched too fast? How about a quick test adding a small `sleep` between the call and the refetch
do you actually refetch accounts after the RPC call?
Having trouble incrementing the state of "votes" . What could be the issue
I figured it was probably user error 😂
The accounts themselves will stay the same—whether that breaks your new *program* though depends on how you updated your code 😉
What is verified?
Does upgrading rust programs break/corrupt existing accounts
https://anchor.projectserum.com/build/92

I saw this on twitter but i dont know what im looking at XD
Thanks. That's clear now
Yep, that's a common pattern
So wouldn't be better to find that on the client side? I mean, you could always pass the bump as parameter
I see. I am checking that only. Thanks
Each choice of bump has ~1/2 chance of getting you off-curve (this is why it's slightly risky to use find_program_address within your contract, because it could take several iterations to find a suitably bumpy bump)
Yep, I think it's helpful to just read the source for find_program_address, it's actually super simple: just keep sha256 hashing seeds + bump + program_id (plus a fixed string, not important), starting with bump = 255. If you get something off-curve, great; otherwise, uh, try bump = 254, etc.
So normal accounts on solana uses ed25519 ECDSA algorithm and PDAs somehow are not on that elliptical curve I guess.
Yeah, think so
Okay so say programA has PDA address and there is another program called programB and it having chances of colliding with PDA address of programA are (1/2^255)
Because only ~half of the addresses are valid public keys—the other half is fair game for PDAs 🙂
Yeah but I don't get how could PDA be off that set if they still are stored as 32 bytes
I think the number is 2^255
Addresses are 32 bytes = 256 bits in solana, and about half of them are valid public keys—that's about 2^255, which is an impossibly large number
Off-topic but related to above: Is there any links you recommend or keywords to do some research on this topic? I am so curious to know the numbers of available PDA/publicKeys eccetera
Any other PDA (they're just sha256 hashes under the hood)
Other PDAs in the sense with other PDAs of the same program if ever collided?
You'd have to have pre-allocated some extra space, and then all new fields would have to go at the end
They could potentially collide with other PDAs (they're just a sha256 hash under the hood) but that's incredibly unlikely
They actually can't possibly collide with normal keypair accounts (they're deliberately constructed so that they're not actual public keys, in the cryptographic sense)
And is there any possibility of them colliding with normal accounts?
1. Paulx - this one is a good start
2. Hackmd - check this out next, with s grain of salt.
3. Quidproquo - check out this one last. Go really in-depth on it, line-by-line. The other two escrows arent as good, but they explain a lot of concepts from this one
okay
many, i'm sure there's an exact number tho
https://discord.com/channels/889577356681945098/889577399308656662/921103289750274068 maybe try searching?
How many PDA I can create with a program?
Adding a new field would increase the space requirements of the account, so wondering how that works with already existing accounts without the new field
what's the best way to handle backwards compatibility when adding a new field to some PDA account struct? Is it usually done by just creating new struct suffixed with Vn?
Creating a system where a program acts like a proxy for the user wallets, both for the solana and for any other mint. This is what I mean by virtual wallet. A second level wallet fully controlled by a program
Not sure what you mean by virtual wallet though
Mm, think so, if I'm understanding you correctly. You also don't *need* to use the associated token account machinery at all if you don't want to (it's just a special address to store a token account—you can use your own if you want).
<@!134416332509675520> So I could create a PDA for the user acting as the Solana virtual wallet, and then create associated token accounts using that pda as input for the associated token program?
So it's still a token account (owned by the spl token program), but the address is derived from the associated token program (different program entirely).
An associated token account does live at a program-derived address, just not one derived from *your* program: it's derived from the associated token program.
That's just logging an *expected* error.
But it showed error
I am running `anchor test` in https://github.com/cqfd/quidproquo
Hi community.
Got It thanks
it is, but it also Token prefix I believe
An associated token account is not generated by a seed like a pda correct?
hmm im not sure if i understand your question
Okay so I will need to also store the user publickey in that to verify if the program should sign on that wallet behalf? Cause with PDA I could just play with the seed without needing to store the user key
otherwise it might complain that its not a token account that you are interacting with
you need to create an (associated) token account for that as far as I know
Is a PDA able to just own Solana tokens or could a SPLToken Mint be set ?
hey guys, is there a quick and easy way to check if an account is a valid mint or not?
check your program id's and when in doubt slap a ```#[account(mut)]``` on everything
for this account in particular

im running into 0xbbf, program owner errors
glad I'm not the only one who feels that way haha
It’s anchor
We’re all struggling here
Nah
Yep never mind I just realized I completely misunderstood this and it was a simple js typo.

Guess I just needed to type it out to figure it out.
Sorry for wasting your time lmao
What’s ur js code looking like

gives me this error

Sorry I'm not wording this very well
I just meant I init'd a pda account for this struct like in the photo above
what do you mean by making the application state an account

So I'm trying to do something pretty basic (store some spl tokens in an anchor program).

If I generate an account for my programs state I can do this no problem bc I can create a pda spl-token account to store and send tokens to.

The problem arises when I don't want to generate a new account. aka I want everyone to be able to see the same application state.

Obviously my first thought was okay make the application state a pda so I can derive it back for everyone, but then I can't create a pda of a pda lmao. Aka now I can't create the pda spl-token account.

What's the actual correct way to approach this?

Broken code snippit for reference:
you can manually check addresses via
address = Pubkey::from_str(pool_owner.key).unwrap()

or the contraint macro
the pool can be a PDA derived from the creator/owner key against the program ID
theres a bunch of ways you can approach this
I am trying smart contract using quadratic funding but the thing is that I am not sure how to differentiate between pool owner and project registrars under the pool.  Can anyone help me with this.

```
#[program]
pub mod solqaud {
    use super::*;
    pub fn start_match_pool(ctx: Context<StartMatchPool>) -> ProgramResult {
        let match_pool = &mut ctx.accounts.match_pool;
        match_pool.pool_id = 0;
        Ok(())
    }

    pub fn create_match_pool(ctx: Context<CreateMatchPool>, p_name: String) -> ProgramResult {
        let match_pool = &mut ctx.accounts.match_pool;
        let creator = &mut ctx.accounts.creator;

        let p_id = 1;

        let my_project = MyProject {
            project_id: p_id,
            project_owner: *creator.to_account_info().key,
            project_name: p_name.to_string(),
        };

        match_pool.projects_in_pool.push(my_project);

        Ok(())
    }
}

#[derive(Accounts)]
pub struct StartMatchPool<'info> {
    #[account(mut)]
    pub match_pool: Account<'info, MatchPool>,
    pub creator: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct CreateMatchPool<'info> {
    #[account(mut)]
    pub match_pool: Account<'info, MatchPool>,
    pub creator: Signer<'info>,
    // pub system_program: Program<'info, System>,
}

#[derive(Debug, Clone, AnchorSerialize, AnchorDeserialize)]
pub struct MyProject {
    project_id: u16,
    project_owner: Pubkey,
    project_name: String,
}

#[account]
pub struct MatchPool {
    pool_id: u8,
    pool_owner: Pubkey,
    pool_amount: u64,
    projects_in_pool: Vec<MyProject>,
}
```
https://github.com/cqfd/quidproquo
Guys are there any examples of anchor programs that does escrow or staking tokens ?
try_accounts is a generated function, the main entry point that does account constraint checks for an Accounts derived struct. In the end it will return an Accounts that has passed validation, or an Error.
I'm trying to understand the what the generated code is doing in __ctor(). The call to __private::Ctor::try_accounts(prog_id, &mut remaining_accounts,....). I cant find where the in the client code the accountinfo argument is formed. Specifically the from, base, to, system_program, and program accountinfos.
Can someone please explain what `try_accounts` is doing here? https://github.com/jet-lab/jet-v1/blob/master/programs/jet/src/instructions/withdraw.rs#L77
I am actually confused on what the wrap SOL address I should be transferring to and the mintAuthhority of that wsol address. Are you awarer?
thanks much
heck, ok. Totally fine, I was just trying to be efficient with data stored on-chain by trying to forego it
You'd have to do that on the client
Alas, nope—you can't dynamically look up an AccountInfo just based off a pubkey like that (you always have to pass in any accounts you care about)
Is that feasible?
I'm storing some data in a vec, and the entries each include an escrow token account's Pubkey.  I'm looking to find the vec entry where this logged Pubkey matches a mint (`Account<'info, Mint>`) I'm passing in, something like: ```state_vec.position(|&x| tokenAccountFromPubKey(x.token_escrow_account).mint == ctx.accounts.token_mint);```
Or, sorry, if you have an Account<'info, TokenAccount>, then yeah, you can get its mint's pubkey, but not the mint account itself
Not directly within your solana program (you'd have to look up the right mint and pass it in from the client)
pda's dont need to sign
ok issue was that im blind
In rust, if I have the `Pubkey` of an escrow token account, I can get the token's mint from just that data right?
i did but i think i found out a discrepancy
yeahh me neither
"<string> - Transaction, as an encoded string. The transaction must have a valid blockhash, but is not required to be signed."
Have you posted the snippets anywhere?
Huh, interesting, had never noticed that: https://docs.solana.com/developing/clients/jsonrpc-api#simulatetransaction
1 sec igu
<@!171442868190314497> I'm a noob but noticed in your quick screenies you aren't using `Signer` for the `Accounts` which require signing. May be related
oops just realized rent is different than system_program
how come?
however, only 1 of them requires the new account to be a signer while the other does
I am in a situation where I have 2 very similar, nearly identical code snippets. which init new accounts
Ok <@!134416332509675520>  i think `simulate` doesn't check the signers
An Anchor conceptual question, it's ok to say that the struct below #[derivates(Accounts)] is an Accounts Deserializer or there is a better concept? Pd: is for an anchor section in the solanacookbook
And i'm overriding signers to be `[]`
I'm just toggling my `simulate` variable
here's the code im using

the signer is supposed to be paying for the new accounts to be created tho

Can you post the program logs from the simulation?
yeah but it fails when I use `send`
https://tenor.com/view/joey-sandwich-gif-20961585
The simulation actually works? That's definitely surprising to me
Idk why though. `simulate` should fail because i didnt pass any signers
When I run `program.provider.send` , I need to pass `vaultCreator` as the signer.
But when I run `program.provider.simulate`, it works without any signers?
makes sense thank you very much.
that is why all AMMs use wrapped SOL
but most programs want wrapped SOL so that they only handle tokens
you can directly transfer it
>?
Thank you. As theory clarification, bc SOL is not SPL token we need to wrap SOL in order to transfer it between different accounts, right>
last i checked the types were broken though so i had to do something like:
` (Token as any).createSyncNativeInstruction(TOKEN_PROGRAM_ID, toAccount)`
just like the CLI but in JS
sol transfer to the wSOL ATA (making sure it exists) + sync native
Question how to you wrap sol in the native_mint. Trying to write an instruction so that the sol deposited is wrapped in the native mint so I can send sol from one account to another? 

Wrapping 1 SOL into GJTxcnA5Sydy8YRhqvHxbQ5QNsPyRKvzguodQEaShJje This is how you do CLI..your able to wrap sol into some account. 

How do you do this via JS
ty tho
emphasis on baked
lol
Im a lil baked, so i was looking through the projects node modules, instead of ./app
im sure someone has ran into that before
google a tutorial for those errors
yep
TY 🙏
found*
I find it!
if your using create react app ur kinda out of luck
it would be in ur root folder
Gotcha. I'm having a hard time finding my webpack.config. I don't see it under node_modules
i'm just not sure how to structure things yet. lmao
u just need to follow the instructions
```

const webpack = require("webpack");
....
....
....
plugins: [
    new webpack.ProvidePlugin({
      Buffer: ["buffer", "Buffer"],
    }),
    new webpack.ProvidePlugin({
      process: "process/browser",
    }),
  ]
```
like the comment says
You need to polyfill those in webpack.config
create react app?
I think I'm sufficiently confused haha that you'd have to post a github repo of what you've tried so far lol

Like i'd just have to hard code an authority if I didnt want to have to pass in a program account
Hey sorry to bother again. I get this compile error, i think issue with webpack?
storing data like nickname, description, etc
like user storage
xD
the user account
So then what account are those seeds for?
Something like counter
What is that program_account?
`#[account(init, seeds = [program_account.key().as_ref(), user.key().as_ref()], bump]`
Just ran yarn install and it compiled this time!
But that's not an admin right?
Sure, that could work
And user is signer
Do you mean wrapped sol? Sol itself isn't a token
` #[account(init, seeds = [b" user.key().as_ref()], bump]`
I'm probably just not explaining things right
xD
Sorry, think I'm just totally misunderstanding
Or are you saying something different?
Clients *can't* sign for PDAs (only your program can)
No
Hi all, what is the mint_key and pub_key for sol on Devnet?
As in what is the devnet SOL address :))
they do if u verify they are the signer
PDA seeds don't have anything to do with security unfortunately
a pubkey u have key pair to
or maybe not a signer
🤔 what would that accomplish? Not sure what you mean
Yeah so you have to derive every PDA from a signer pubkey
Do you maybe need to `yarn` install something?
But they *can't* sign for arbitrary addresses
Yes, definitely true that clients can pass in arbitrary stuff
Like in candy machine v2 from metaplex. u can pass in any candy machine
I think you're over-focusing on that specific example 🤔
using ur functions
Or candy machine
like they init their own Counter
But they could pass in a authority account
https://tenor.com/view/dying-monkey-dying-gif-13123180
xD
If you set the admin yourself then of course the user themselves won't get to set it

Hi guys, very noob here so any help would be super appreciative. I'm working through this tutorial https://www.brianfriel.xyz/learning-how-to-build-on-solana/

however, my problem is when I'm trying to deploy my front end. Running npm start yields the following error
I think you should fiddle around with implementing this
No, you don't!
😛
but u have to trust the user to give the right account
I kept on receiving the error "Error: failed to send transaction: invalid transaction: Transaction failed to sanitize accounts offsets correctly" 

Solution: type in your Program ID into Anchor.toml (<directory> = "[Program ID]" and source/lib.rs (declare_id!)

I'd love to hear is anyone has a better way to find Program ID - I currently had to run anchor test once before it showing up
Accounts aren't stateless of course
You could store a blessed admin in an account
its all stateless
I dont understand how dynamic would work
And then verify that either I signed or that admin signed
You would just hardcode (or if you really want, dynamically set) their address into your program
signer
pubkey
a wallet
What is their address?
yea
Who is this authority though? Like an admin user?
An authority or you
Who do you want to be able to modify, say, my account?
but isn't that the case with any program
Who counts as a valid authority in your program?
You would have to just have fancier logic
The create function
In that example, yes
What do you mean by init a program?
I honestly don't understand what you're describing lol
with their own counter account
Like anyone can init a program
At the end of the day only your own program can write to its accounts, so you would just have to have some way to decide who counts as a valid authority (I think I'm not understanding what you're trying to do though 🤔)
basically you can only instance a program
like the user could set any authority
You would have to define that yourself 😛
yeah but what defines an authority if the user makes the account
https://project-serum.github.io/anchor/tutorials/tutorial-2.html#defining-a-program
Your program would need to verify that that authority signed the transaction that attempts to modify the user account
Like if I want an authority who can edit a user's account
Mm, don't think I understand what you're asking about 🤔
So I would do like (program_account.pubkey + user.pubkey) in the pda generation
So like I want to blacklist an PDA from being updated by a user.
and every PDA uses that account in PDA pubkey gen?
So do most programs have like a "metadata account"
Pretty much only by requiring a known address sign the transaction
In a smart contract how is there any way to set an authority for calling functions?
https://tenor.com/view/big-bite-nom-yum-tasty-delicious-gif-14275177
I'll provide unlimited support for early access to the jito sandwich press
gotcha
Those are just to help make the number more readable (apparently not always successfully lol): https://doc.rust-lang.org/rust-by-example/primitives/literals.html
<@!134416332509675520>
There actually isn't any anchor wrapper yet for the system program (actually not sure why though), so currently you need to do the `invoke`/`invoke_signed` stuff yourself I think
awesome!
But if you hop to source on TokenAccount you'll see it has its own impl of Owner
It's just that when you use `#[account]` to declare one of your own accounts, it automagically impls that trait and returns your current program's ID
ah okay
Nope! `Account<'info, TokenAccount>` checks that the account is owned by the spl token program (the struct you parameterize `Account` over has to impl anchor's `Owner` trait)
thx for the help on this. I think it makes sense. So ownership is checked at the account deserialization step. I assume the `TokenAccount` just skips program ownership check
Thank you
https://media3.giphy.com/media/3owypkSIpM8xw6p7W0/giphy.gif?cid=ecf05e47vsr89fvh4if4ip2bg4rg57x9v6mfuh3ii7rs4l28&rid=giphy.gif&ct=g
In other words, ctx.accounts.to gets passed zero times (bad)
You're passing `ctx.accounts.from` twice
This is a great resource I look back on frequently
https://github.com/cqfd/quidproquo/tree/main/programs/quidproquo
Thanks, I'll give that a shot
And way less bugs
Way simpler to use anchor
yeah u probably wanna do something like this instead:
```
// Transfer the maker's tokens to the escrow account.
        anchor_spl::token::transfer(
            CpiContext::new(
                ctx.accounts.token_program.to_account_info(),
                anchor_spl::token::Transfer {
                    from: ctx.accounts.offer_makers_maker_tokens.to_account_info(),
                    to: ctx.accounts.escrowed_maker_tokens.to_account_info(),
                    // The offer_maker had to sign from the client
                    authority: ctx.accounts.offer_maker.to_account_info(),
                },
            ),
            offer_maker_amount,
        )
```
Uh... I just found it on a code snippet online: https://i.imgur.com/b94aOcG.png
Why are you using `anchor_lang::solana_program::program::invoke` instead of anchor's wrappers?
Forget `invoke_signed`
Basically, my prediction for the bug is that your program doesn't have ownership over the account you're trying to debit. Like, you never passed in the signature for the account you want to debit
I have no idea what that is though
It says I need a signers seed:
I'm not sure. Anyone know the answer to <@!369956017594957824> 's question?
hmmmmmmmm
good question
no worries man
check out examples online, im not sure of the exact format
Thanks again I think it does. Still a little at the noob stage where I'm trying to piece together a fundamental understanding. One followup, what purpose do regular token accounts have if one should use an associated token account, in general?
How would you do that?
if anything was unclear lmk
np 👍  did that answer all your questions?
So on the clint side, you gotta specify what you wanna do
The smart contract itself doesn't care if the passed in token account is an associated TokenAccount or just a random TokenAccount
Thank you for these responses btw <@!912046857000194158> 🙏
Accounts are only closed when rent goes to 0 OR if the owner closes it
The example is creating a simple escrow program where Alice wants to send X tokens and receive Y tokens in exchange from Bob. There are 2 instructions, one to initialize the escrow by Alice and then for Bob to take the escrow terms / do the swap.
Accounts are only closed when rent goes to 0
You need to create an associated token account and put lamport rent in it before you can deposit funds into it. (Or, the person depositing funds into your associated token account needs to pay for the lamport rent)
What do u mean by "right thing to do here"? What's the example
"    - Is there any sort of cleanup after the token account is emptied out and no longer used? How does this work?"

Depends if it still has rent. You can close out the account if you want using the `#[account(close = ...)]` with anchor
So the right thing to do here would to instead pass in the associated token account (if exists, if not create it) instead of creating a regular token account? Is this possible even if the balance of the respective token is 0?
It definitely doesn't look at all the user's token accounts
hmmm i dont think that's how it works. the associated token account lives at a certain address. It stores its own token balance
- Norm: Try to stick to associated token accounts, so that you just have one account per token. https://spl.solana.com/associated-token-account
and pass in the correct signer
maybe try `invoke_signed`
- This question relates to the canonical vanilla Rust example of making an escrow program, referenced here: https://hackmd.io/@ironaddicteddog/solana-starter-kit#2-Escrow-Program-using-vanilla-Rust
- When we call `process_init_escrow`, we used a brand new, client-side-created token account for Alice for token X and Y. Alice could already have a token account for token X and Y, but we create them specifically for this program.
    - Is this the norm for Solana? To create a separate token account for a given token every time a program needs to interact with it?
    - Is token spending management, etc. all handled by the associated token program? Does it just aggregate all token X accounts for Alice, so when she opens a wallet, she sees the consolidated balance?
    - Is there any sort of cleanup after the token account is emptied out and no longer used? How does this work?
Does anyone know why this is happening or how to fix it?
```
Transaction simulation failed: Error processing Instruction 0: An account required by the instruction is missing 
    Program 97Fe24XfPSAKXaQ6ycZ2B8LeMwGQM9iZx73MRbmihHNh invoke [1]
    Program log: Instruction: SendSol
    Instruction references an unknown account GkbNRZ8n6B5j3Zj2FNPiryarnDtefQK3WVX1A3B4UZMR
    Program 97Fe24XfPSAKXaQ6ycZ2B8LeMwGQM9iZx73MRbmihHNh consumed 4218 of 200000 compute units
    Program 97Fe24XfPSAKXaQ6ycZ2B8LeMwGQM9iZx73MRbmihHNh failed: An account required by the instruction is missing
```
But if I send 1 SOL from one user to a *different* user, then I get this error in the JavaScript console:
It works when I send 1 SOL from one user to the *same* user e.g. user A to user A.
Rust
```
pub fn send_sol(ctx: Context<SendSol>, amount: String) -> ProgramResult {
        let amount_as_num: u64 = amount.parse().unwrap();
        let ix = anchor_lang::solana_program::system_instruction::transfer(
            &ctx.accounts.from.key(),
            &ctx.accounts.to.key(),
            amount_as_num
        );
        anchor_lang::solana_program::program::invoke(
            &ix,
            &[
                ctx.accounts.from.to_account_info(),
                ctx.accounts.from.to_account_info()
            ]
        );
        Ok(())
    }

...

#[derive(Accounts)]
pub struct SendSol<'info> {
    #[account(mut)]
    from: Signer<'info>,
    #[account(mut)]
    to: AccountInfo<'info>,
    system_program: Program<'info, System>,
}
```
JavaScript
```
const sendSol = async(to) => {
    try {
      const provider = getProvider();
      const program = new Program(idl, programID, provider);
      await program.rpc.sendSol('1', {
        accounts: {
          from: provider.wallet.publicKey,
          to,
          systemProgram: SystemProgram.programId
        }
      });
      console.log("Successfuly send 1 SOL to", to.toString());
    }
    catch (error) {
      console.log("Error sending 1 SOL:", error)
    }
  }
```
Can anyone help me out with this bug? I'm trying to send 1 SOL with this code:
sheesh
sounds like your declare_id! or anchor.toml pubkeys aren't correct?
Is there a tutorial or example on how to create NFT in anchor?
for readability
"comma"
just commas
https://github.com/Gajesh2007/staking-rewards/blob/main/programs/reward-pool/src/lib.rs#L23

in this line, what is `_` ?

_noob_question
It's for sure the PDA that I'm passing in since when I comment it out, the ix succeeds
running into some weird issues in tests. I have two programs in my workspace let's say prog1 and prog2. I am deriving a PDA using prog2's programId and then invoking an ix on prog2 to init the pda but getting `The given account is not owned by the executing program`
(https://github.com/project-serum/anchor/blob/master/lang/attribute/account/src/lib.rs#L109)
ty
awesome
e.g. If you create an account holding a CandyMachine config or whatever it's called, it will check at runtime that the program owning that account is `candy_machine::ID`
I think specifically it will check that the struct `Whatever` has been created in the correct crate/program
I think the short version is that `Account<'info, Whatever>` already checks both that the account's data looks like a Whatever *and* that the owner is correct
:thonking:
hm yea
Oh, sorry, I guess it is also checking the owner (not sure why you'd do that in the same function, it's an independent concern)
That's just making sure the address matches your expectations
That's different from program ownership (the program that derived a PDA address is independent of the program which owns the *account* that lives there)
checking that some Account<PdaAccount> public key matches a certain seed
I've seen some flavor of this in programs:
```
fn check_pda_account(pda_acc: &Account<PDAAccount>, prog_id: &Pubkey) -> ProgramResult {
    let (pda, _bump) = Pubkey::find_program_address(&[&PDA_ACCOUNT_SEED], prog_id);
    let info = pda_acc.to_account_info();
    if *info.key != pda || info.owner != prog_id {
        return Err(ErrorCode::Unauthorized.into());
    }
    Ok(())
}
```
Part of solana's ownership semantics is that if your program owns an account, you know *for sure* that it was your program which wrote any data there
What PDA checks do you mean?
oh snap
Once you've made that assignment once it's fixed forever
No, you only get to change program ownership once, from system_program --> some other program
i could just change the owner of account to the side program right? I'm trying to see if a user can do this and exploit my program. If a user can't then what's the point of having PDA checks in the program?
So the system program obviously absolutely requires a signature in order to do a wallet transfer
This is kind of a bland answer, but you would require a signature whenever it "makes sense", e.g. proves that the caller has access to some private key
And as you said previously, for writes _technically_ the owning program does not need the signature from the private key if it owns the account. Correct?

As a general rule of thumb, when should you require a signature from an account that was generated with `anchor.web3.Keypair.generate();` if your program doesn't need that signature for writes since it's the account owner? In my mind requiring a signature only makes sense when it's the `Pubkey` of a users wallet (and you can ensure they own that wallet).

Seems like an antipattern to require a signature from accounts with generated keypairs, given the UX would be subpar for private key custody.


//////////////////////////////////////////////////////////////////////////////////////////

Hi all, I'm trying to read transactions in a block and am having a hard time figuring out how to unpack the data field of an instruction. How do I know what type the data field should be`BorshDeserialize`d to?
I'm getting `Program log: Custom program error: 0x65` after using `invoke_signed` - does anyone know how to troubleshoot this?
Awesome thank you, that does look promising. What would the toml file look like? I was trying something like:
`
[test.validator]
url = "http://localhost:8899"

[test.validator.clone]
# data feed account
feed = "AdtRGGhmqvom3Jemp5YNrxd9q9unX36BZk1pujkkXijL"
`
but I still dont see the account being cloned
Sorry, what do you mean? I’m trying to write a Solana program on-chain and Solana programs cannot access Arweave…
As per this: https://discord.com/channels/889577356681945098/899315988087054397/916055815721467945, another way would be to add the same options in `Anchor.toml`, yes. The rust SDK seems to have some promising methods to load/clone accounts/programs programmatically here: https://github.com/solana-labs/solana/blob/bced07a099e5b34f5b8a5411109a6adfa0a96a0c/test-validator/src/lib.rs#L175. However I have not had the chance to try them out yet.
Thanks!
Take a look at the function definition, think it will be clear—there's an argument for what kind of authority you're trying to set
Ok, how do I transfer the freeze authority
No, only one authority type at a time
Thanks! Does that also transfer the freeze authority and everything
anchor_spl::token::set_authority (that/the underlying cpi to the token program is the *only* way to change a mint's authority)
What is the easiest way to change a mint's authority
Hi team, is there a way to use the solana-test-validator clone feature in anchor test? I see that I could skip local validator and spin up my own local instance with the accounts/programs i need cloned but I was wondering if there's an easier way, maybe in the Anchor.toml file?
its not being done inside an anchor program but it shouldn't make a difference
here's an example: https://github.com/RohanKapurDEV/warlock/blob/master/src/handlers/fetch_miner.rs#L127
https://docs.rs/anchor-lang/0.18.2/anchor_lang/trait.AccountDeserialize.html#tymethod.try_deserialize
cool let me try
program.account.fetch(pubkey)
How can I read data on an account ? How can I decode it ? (It's not a token account data. Data stored on a PDA)
Thank you so much!
Yep.
sorry i'm dense. So i'll send the signed transaction not specifying lamports, and the anchor program will magically just attach whatever fee it thinks is appropriate?
got it, thanks guys will try that
```
#[account]
#[derive(Default)]
```
no it's a thing you put above your account data struct
so instead of #[derive(Accounts)] I do #[derive(Default)] ?
but it got made optional now for some reason
it used to be the "default" in anchor
derive default also saves a bunch of hassle with initializing variables
🙂 nice.
sorry, i forget about this
haha
^ you do if you don't derive Default though (but yeah, can just derive Default)
when i take the space part out it compains
so long as you're not storing a `Vec` or `String` in your account
you also don't need to manually specify the `space`
That's using init (one of the anchor init macros)
i try to discourage people from using `init_if_needed`
`init` is `init_if_needed` without the `if_needed` part
you should do as much as possible inside the program to keep your life simple
my struct looks like this: 
```rust

#[derive(Accounts)]
#[instruction(bump: u8, sym: String)]
pub struct Initialize<'info> {
    #[account(init_if_needed,
        payer=authority, 
        seeds=[sym.as_bytes()], bump=bump,
        space=8 // account_discriminator
        + 32 // pubkey
        + 8 // sequence_num
    )]
    pub sequence_account: Account<'info, SequenceAccount>,
    pub authority: Signer<'info>,
    pub system_program: Program<'info, System>
}
```
what is 'using init'?
`getMinimumBalanceForRentExemption` is the function
Ok, then anchor inside the anchor program will calculate rent (if you used `init`)
yes.
But are you sending the tx to an anchor program?
there's a function calculating rent exempt sol
you mad man
sending this tx from a java program.
ah, yea unfortunately i can't use anchor 😦 so i have to buld and send the tx directly
`space` can be automatically calculated by anchor or you can specify how many bytes you need
not exactly, anchor does the maths for you based on the `space` required
and it just deducts 2 years rent so its rent exempt by default?
assuming you mean using `init`. In solana you don't send along Sol, it just looks at your `payer`s balance and deducts the rent payment from that
another super beginner question, when I call initialize it makes me a new account right? When sending that tx do I have to send more lamports somehow in on the tx (because accounts take rent right)? Or will the client magically do that for me
<:salute:746135852324749443>
Almost. Borsh doesn't just directly serialize strings like that, you'll have to have an extra 4 bytes out front for the length of the string
ok, so for my clarity... i want to call initialize first

my init:
```rust

    pub fn initialize(ctx: Context<Initialize>, _bump: u8, _sym: String) -> ProgramResult {
        let sequence_account = &mut ctx.accounts.sequence_account;
        sequence_account.authority = *ctx.accounts.authority.key;
        Ok(())
    }
```

So data will be [sha256('global:initialize')[0:8] + 1byte_bump + 'mystring'.tobuffer]
Two different 8-byte thingies 😛
That's the account discriminator, not the sighash
why global: instead of account:, i found account: at the bottoe of https://github.com/kevinheavey/anchorpy/blob/main/src/anchorpy/coder/accounts.py
Yeah, your data will be [ 8 bytes of sighash + arg1 bytes + arg2 bytes + ...]
Just to bump, I can run my own `yarn deploy:localnet` command fine, just have to be very careful to deploy the right .so file.
The sighash will probably be sha256("global:your_fn_name")[..8]
Just rerunning `anchor deploy` *doesn't rebuild the program*, so if you change your declare_id you need to rerun anchor build (to get a new .so file that reflects the correct id) and then run deploy
Ok, so i have my program deployed to devnet, and now I'm trying to write raw instrunctions to send. How do I specify which method I want to call on my program?  Do  i sha256 hash "account:method_name" and take the first 8 bytes of that? and thats the first 8 bytes of my data?
Ok, and can fix it locally. I bet the problem is that you have to be pretty careful to rerun anchor build before deploying.
Ah, ok, can reproduce that locally 👍 👀
yep, `anchor test` is alright, it's the `yarn deploy:devnet` that fails at the migration part
Ok, I just ran the tests locally and they all passed, is that expected?
Thanks, you've done a lot for me already! You can check the repo here: https://github.com/Dodecahedr0x/stead-rent-programs
If you can send me a git repo I can figure out what's happening locally, probably can't help anymore remotely, sorry!
Is this the version of the program that still doesn't work if you try to init?
Tx hash on devnet: 517AZmALtkK5XECAZJ5yEZXxN524zPscFCxnbHjdBdFpVRqfU82EAB7ie8uyLRE7j5yfTpwshkzBJ9geafDP3Si4
The answer is still the program id
good catch
(They need to match)
Ah, need to get rid of that #[instruction(bump: u8)] part, you aren't actually declaring it in the instruction fn too
I had an empty endpoint context but had the same error, so I tried adding a dummy account
Sadly i run into a new error:
```
Transaction simulation failed: Error processing Instruction 0: custom program error: 0x66 
    Program TrXDop6spRAwHDsSpvY51PxHkvZXKGNYC6bygXZLNC2 invoke [1]
    Program log: Custom program error: 0x66
    Program TrXDop6spRAwHDsSpvY51PxHkvZXKGNYC6bygXZLNC2 consumed 2321 of 200000 compute units
    Program TrXDop6spRAwHDsSpvY51PxHkvZXKGNYC6bygXZLNC2 failed: custom program error: 0x66
```

when I run 
```
#[derive(Accounts)]
#[instruction(bump: u8)]
pub struct Test<'info> {
    pub account: Signer<'info>
}

#[program]
mod xxx {
    use super::*;

    pub fn test(ctx: Context<Test>) -> ProgramResult {
        msg!("{:?}", state::State::owner());
        Ok(())
    }

    ...
}
```
Basically, the ownership check that is failing is just an if statement, two things are not equal to each other, and I'm curious why
I want to see what the owner is in a version fo the program that doesn't work—it will end up being something (somehow) different from that declare_id!
Right—I want to see what the owner is in real life though, since apparently it's different!
On the test it said that the owner was the ID of the program (TrXDop6spRAwHDsSpvY51PxHkvZXKGNYC6bygXZLNC2)
This is just a debugging hack (I didn't need it for some reason locally, I could just use that `#[test]` trick)
It's a static function on the struct itself, no need to have an actual account of that type
Ah, sorry, I mean skip that kind of account entirely and just log the static owner:
```.rs
msg!("{:?}", state::State::owner())
```
i added `ctx.accounts.state.to_account_info().owner.log();` in my initializeState instruction and the log is now:
```
Transaction simulation failed: Error processing Instruction 0: custom program error: 0x0 
    Program TrXDop6spRAwHDsSpvY51PxHkvZXKGNYC6bygXZLNC2 invoke [1]
    Program 11111111111111111111111111111111 invoke [2]
    Allocate: account Address { address: Cv8gnYcoV5JTfS5AMTjA4sPHhTFV3v9bNnx3FsC2mqx6, base: None } already in use
    Program 11111111111111111111111111111111 failed: custom program error: 0x0
    Program TrXDop6spRAwHDsSpvY51PxHkvZXKGNYC6bygXZLNC2 consumed 200000 of 200000 compute units
    Program TrXDop6spRAwHDsSpvY51PxHkvZXKGNYC6bygXZLNC2 failed: custom program error: 0x0
```
It suggests that the state account already exists, which makes sense if the program address is static and its state account as well
Or edit the anchor source to log more info there, etc.
Just to find a way to see, yeah, who do you think you're supposed to be owned by?
No test to muck things up
Ok, to close the loop: I would try making a dummy endpoint where you just msg! the intended owner
Well, not sure—maybe I only find it sketchy because I'm confused about rust modules
Ok, not sure—at any rate I think including that #[account] macro in a different file from your program's declare_id seems super sketchy to me (honestly surprised it works—I'll have to understand how rust modules work in more detail)
Actually I missread: the test runs fine, and says the owner = the program Id
```
error[E0659]: `xxx` is ambiguous
  --> /mnt/c/Users/me/solana/xxx/programs/xxx/src/lib.rs:19:9
   |
19 | pub mod xxx {
   |         ^^^^^^^^^^ ambiguous name
   |
   = note: ambiguous because of multiple potential import sources
   = note: `xxx` could refer to a crate passed with `--extern`
   = help: use `::xxx` to refer to this crate unambiguously
```
The above works for me locally, but guess I've got a different module organization than you do
Can you show it? Not sure—just have to figure out the right syntax for specifying that struct
I'm getting the error that say's my program module's name is ambiguous
(Or, at any rate, find a way to log State's intended `owner()`)
You should get a little run button in vscode, curious what that prints if you run it as a little standalone test
One thing you could try, go back to the old organization and add this to your main file:
```.rs
#[test]
fn wtf() {
  eprintln!("{:?}", state::State::owner());
}
```
Yep, `pub mod state` in `lib.rs`, declared the state module and its state struct following Rust book guidelines
Yeah, I tried a similar thing locally and it actually worked fine, and the cargo expand output makes me think it *should* work fine
How are/were you depending on that file in your main program file? Like, did you do something like `mod state;` or whatever?
Ok, interesting, guess I'm learning about how modules work in rust
Well, with that kind of error, you kind of have to be single file maxi!
Another reason why I'm a single-file maxi 😆 (Kidding, sort of)
1 sec
I'm honestly not sure how that file above isn't a compile error lol, thinking about it
do you know why?
wtf?
Damn, it worked!
Can you just for a sec move that into the main program file? I'm actually not sure how that works in its own file tbh
Yep, I reused jet protocol's project structure because i thinks it's cleaner
Ah, hmm. So it's in a different file?
The whole file:
```
use anchor_lang::prelude::*;

/// The global state of the program
#[account]
pub struct State {
    /// The bump used to generate this PDA
    pub bump: u8, 

    /// The wallet to which fees are given
    pub fee_earner: Pubkey,

    /// The portion of the sale which goes to the fee earner
    /// Denominated in basis points
    pub fee_amount: u16,
}

impl State {
    pub const LEN: usize = 40 + 3;
}
```
How is State declared?
after the imports, before the declaration of the program
Hmm, yeah, looks good
```
...

declare_id!("TrXDop6spRAwHDsSpvY51PxHkvZXKGNYC6bygXZLNC2");

#[program]
...
```
Ok, so can you screenshot your `declare_id` lol
I checked the ID matches in `lib.rs`, `target/idl/xxx.json` and `Anchor.toml` but maybe I missed one?
The log is weird because it looks like the account has been initialized:
```
'Program TrXDop6spRAwHDsSpvY51PxHkvZXKGNYC6bygXZLNC2 invoke [1]',
    'Program 11111111111111111111111111111111 invoke [2]',
    'Program 11111111111111111111111111111111 success',
    'Program log: Custom program error: 0xa7',
    'Program TrXDop6spRAwHDsSpvY51PxHkvZXKGNYC6bygXZLNC2 consumed 10137 of 200000 compute units',
    'Program TrXDop6spRAwHDsSpvY51PxHkvZXKGNYC6bygXZLNC2 failed: custom program error: 0xa7'
```

I only run `anchor test` for tests, `anchor deploy && anchor migrate` for the deployment (with correct wallet and cluster
And just to double check—you aren't doing any explicit `anchor deploy` as part of the tests? Sounds like no (good), just want to rule that out
Can you show the full program log output?
Yeah, it basically has to be that state account, so provided that it really hasn't already been initialized somehow, I'm like 90% sure it's a declare_id issue (not 100% sure, sounds like you've already checked this—but not currently sure how else you could get this error)
I checked all IDs. I'm letting anchor run everything for the test, but migrating to devnet
And how are you running the tests? Deploying locally or letting anchor spin things up etc.?
Does your `declare_id!` match the actual runtime id of the program? (You can see this runtime id in the program logs)
I checked program ID, signers balance, string encoding of the seed, I don't understand where it comes from. The only program that should be owned by the executing program is the state account, which is unique since it's a program address generated by a static seed
Hi all, I'm trying having calling this instruction of my program: 
```
#[derive(Accounts)]
#[instruction(bump: u8)]
pub struct InitializeState<'info> {
    /// The exhibition
    #[account(
        init,
        seeds = [b"state"],
        bump = bump,
        payer = payer,
        space = State::LEN
    )]
    pub state: Account<'info, State>,

    /// The wallet paying the transaction
    pub payer: AccountInfo<'info>,

    pub rent: Sysvar<'info, Rent>,
    pub system_program: Program<'info, System>,
}
```
with the following code:
```
const [state, stateBump] =
  await anchor.web3.PublicKey.findProgramAddress(
    [Buffer.from("state")],
    program.programId
  );

await program.rpc.initializeState(
  stateBump,
  provider.wallet.publicKey,
  100, // 1% fee
  {
    accounts: {
      state: state,
      payer: provider.wallet.publicKey,
      rent: SYSVAR_RENT_PUBKEY,
      systemProgram: SystemProgram.programId,
    }
  }
);
```

In the `anchor test`, everthing runs fine, but when I run the same code in the `anchor migrate`, it fails giving me a `The given account is not owned by the executing program`.
`init_if_needed`
Signer<'info> is sligthly nicer because it encoded the fact that they signed into the type (can't forget it). But otherwise they're equivalent.
No, not possible unfortunately—you always have to pass accounts in from the clients.
you can derive the address using the bump and program address
what's the difference between using `Signer<'info>` and `#[account(signer)]`? Which one is preferred?
but related to this, is there a way to conditionally init? like if the account is already initialized, do nothing
I don’t know the address ahead of time because the seed for it is created within the program
token metadata need to be deployed on arweave
#[account(init)]
sorry for being confusing. Been awake for 18 hrs lol
for writing tests in TS, when should I be using `coder` vs `accounts` directly?

the below 2 seem to achieve the same result:

option 1
```ts
const acc = await program.account.shardr.fetch(shardr.publicKey);
```

option 2
```ts
const info = await provider.connection.getAccountInfo(shardr.publicKey);

const acc = program.coder.accounts.decode("Shardr", info.data);
```
Is there a way to construct an AccountInfo within a Program, rather than passing it in? This is for a PDA whose seeds are generated by the running program itself, so I don't know ahead of time which seed will be used
How do I deploy the Metaplex token metadata programs with `anchor deploy`?
How do you get the program ID of a program when running `anchor test` on localnet??
Code:

```
        let metadata_infos = vec![
            ctx.accounts.payer.to_account_info(),
            ctx.accounts.metadata.to_account_info(),
            ctx.accounts.mint.to_account_info(),
            ctx.accounts.mint_authority.to_account_info(),
            ctx.accounts.token_metadata_program.to_account_info(),
            ctx.accounts.token_program.to_account_info(),
            ctx.accounts.system_program.to_account_info(),
            ctx.accounts.rent.to_account_info(),
            // Removed since candy machine account isn't created
            //candy_machine.to_account_info(),
        ];

        invoke(
            &create_metadata_accounts(
                *ctx.accounts.token_metadata_program.key,
                *ctx.accounts.metadata.key,
                *ctx.accounts.mint.key,
                *ctx.accounts.mint_authority.key,
                *ctx.accounts.payer.key,
                // TODO: Is this the correct update_authority for the metadata? Should potentially be showroom wallet
                *ctx.accounts.payer.key,
                // TODO: Allow user to specify NFT name / symbol / URI?
                "TEST_NAME".to_string(),
                "TEST_SYMBOL".to_string(),
                "TEST_URI".to_string(),
                Some(creators),
                0,
                true,
                true,
            ),
            metadata_infos.as_slice(),
        )?;

```

Code above is copied from Metaplex (but using `invoke` instead of `invoke_signed`: https://github.com/metaplex-foundation/metaplex/blob/master/rust/nft-candy-machine/src/lib.rs#L131-L174)
Call to `create_metadata_accounts` is failing with error `instruction expected an executable account`. The program logs print `Account metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s is not executable`, so for some reason it seems like this code is trying to execute the Metaplex program which should be fine? Is this issue because I'm running Anchor locally (and not on a testnet where the Metaplex address is `metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s`)?  🤔
Ok, so i sha256 hash "account:method_name" and take the first 8 bytes of that? and thats the first 8 bytes of my data?
I can't use typescript or anchorpy client because i'm sending these tx's from a different language, so just need to determine what bytes to send at the beginning of the data 🙂
Ok, so i have my program deployed to devnet, and now I'm trying to write raw instrunctions to send. How do I specify which method I want to call on my program? When i've interacted with other programs you use the first 4 bytes of the data to show which method to interact with. Is it the same here?
explain?
Looking at the documentation, https://project-serum.github.io/anchor/cli/commands.html#build what would be the difference between `acnhor deploy` and `anchor update` after a change in a smart contract already deployed?
what a legendary framework this is, I haven't seen something so clever in a long time
https://github.com/project-serum/anchor/pull/641
solved it, it was code using the old syntax as detaild in this change
maybe trying to init a pda without a bump argument?
need more info, but probably paste your account context
hi all, stupid question
`error: bump must be provided with seeds`
is there somewhere I can read up more to understand what is missing here?
https://medium.com/@pirosb3/using-pdas-and-spl-token-in-anchor-and-solana-df05c57ccd04
https://github.com/PirosB3/SafePaySolana
This app has some examples
Along with a full understanding of the Associated Token Account program you will understand how to use it in anchor 🙂
https://spl.solana.com/associated-token-account
Also searching through the anchor codebase in general
Nope, just reading anchor tests (or writing the code 😛)
Thanks a lot man. Has any doc to that command/macro?
Sorry, my bad, `associated_token::`
This error is displayed when I try to use this annotation. I need to import something to make this work?
Do you guys know where I can find more info on minting an NFT through anchor without going through metaplex etc?
Might take the wrong direction here, but what if i'm looking to integrate my NFT minting instructions within my own program (Let's say depending on other instructions within my program it will automatically mint a NFT on day X or something)
you are being very confusing lol
so the origin and destination are both PDAs?
Since the token is no more with the user but when the user connects the wallet I want to show that he still holds the token and is stored in the smart contract
I'm transferring the NFT from user wallet to PDA Token account (with seeds as user address + token account address + "token")
so you transfering from that PDA, where exactly are you transfering into then?
sorry i got busy

when i used cargo i have this error
Yes, in borsh
https://discord.com/channels/889577356681945098/889702325231427584/916004299933368350
when calculating space
does bool take 1 byte ?
just map it to `ProgramResult` and use `?`


//////////////////////////////////////////////////////////////////////////////////////////

Ah - it looks like when you deploy a contract for the first time, the output program_id from `anchor deploy` is saved in the generated IDL, and then you're supposed to replace the hardcoded one.
What is the difference between the hard-coded program id here: `declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");` and the program_id outputted from running `anchor deploy`. Specifically, referring to this example: https://project-serum.github.io/anchor/tutorials/tutorial-0.html
Thank you so much! That was the problem
Gotcha, thanks for the link man0s
You always need to put the extra `8` <@!691062112621035672>
Your account doesn't have nearly enough space to store those values. You need to do `8 + 16 + 16` . Notice the extra `8` in the front.
There is a website that actually shows all builds and associated program address/repo
https://discord.com/channels/889577356681945098/889702325231427584/925381515561549836
thanks
oo interesting
Now you can verify anytime if the program deployed on mainnet it the one shown in the linked open source repo
Can someone pls explain to me what this means / what its doing? 
https://twitter.com/simplyianm/status/1475937757419560962?s=21
I thought the required space would be inferred from the struct itself
Do you need to specify the space in the macro of the fibonacci account?
Hi is therre a central list of rpc errors like this : index.js:1 Transaction simulation failed: Error processing Instruction 0: custom program error: 0x178c  that I can reference to understand what  0x178c error is referring to please 🙂
Trying to figure out where the errors arer located
and this is the .rs
`#[program]
mod fib {

    use super::*;

    pub fn initialize(ctx: Context<Initialize>) -> ProgramResult {
        let fibonacci = &mut ctx.accounts.fibonacci;
        fibonacci.previous = 0;
        fibonacci.current = 1;
        Ok(())
    }

}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 8 + 8)]
    pub fibonacci: Account<'info, Fibonacci>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[account]
pub struct Fibonacci {
    previous: u128,
    pub current: u128,
}
`
Thanks!
Anyone knows what could be happening?

This s the RPC call:
`    const tx = await program.rpc.initialize({
      accounts: {
        fibonacci: fibonacci.publicKey,
        user: anchor.Provider.env().wallet.publicKey,
        systemProgram: SystemProgram.programId,
      },
      signers: [fibonacci],
    });`
Hi! I'm trying to test a simple Initialize struction but i keep getting this error `Error: 3003: Failed to deserialize the account`
Is there any way I can send a message with class to the program like using borsh? There's new anchor.BN(), and I wonder if it is possible to get data as struct
Hello, why we need declare_id in the root of lib.rs?
The `msg!` thing you said worked, that was helpful. Thanks!
😦
Fixes what? Don't think there's anything new that will help you see which constraint fails
from the anchor 0.19.0 code, it seems like the new version fixes that right
One thing you can try though is to use a constraint block:
```.rs
#[account(constraint = {
  msg!("log stuff");
  foo == bar // <-- the actual constraint part
})]
```
Currently you just have to do some good old fashioned debugging lol
```Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: custom program error: 0x8f```
This is a RawConstraint error. How do I see *which* constraint was actually violated?
Hey is there any blog/tutorial on how to develop nft staking with custom spl Tokens?
ohhhhh thank you sir
ok, I understand! Thank you both, much appreciated!
You don't get to pick the bumps—they're determined by the seeds. So you would need different seeds for each PDA (think of the seeds as the "name" of the PDA)
you can use the payer pubkey in the seed. Nothing to store for them to access it then
(e.g. what if you want a pda account in for your program per new user - like a user vault or something?)
or is that an anti-pattern? I.e. you should just use different seeds?
Ok I see, so if you want to make multiple PDAs with the same seed and keep track of this, you'd have to be smart about the bumps and store them somehow, right?
But yes, each bump has about a 50/50 chance of working, so in general there will be many values that bump you off the curve (those will lead to different PDA addresses though! so don't use them)
You don't provide a starting bump—you just use `findProgramAddress`, which loops down from 255 until it finds something off curve.
Hi all, been searching discord but still confused about a couple things. The first being, is there only 1 valid bump for a given seed? Going off of this, "In Solana, we start with bump = 255 and simply iterate down through bump = 254, bump = 253, etc. until we get an address that is not on the elliptic curve". Let's say 250 is a valid bump. If you provide bump=255 from the client side, then it'll find 250. But, what if, you provide 245? Also, how do string bumps work in this case?
If i run solana program deploy target/deploy/file.so, the programs runs and I get the Program ID which I can then Use to run *anchor test*. This Solves my Problem but It also means that the command *anchor deploy* does not work
it's a two part command. build and deploy
After I run anchor build I do not get the program ID
Note: after the initial build, you need to copy your program id and replace the id's in lib.rs and anchor.toml
<@!747996083636011078> we meet again 😄 . I think u can just let anchor handle everything by running 
- first start your local validator
- run `anchor build && anchor deploy` (no need to define your program name in the command.
- stop local validator
- try running `anchor test` again
Can Someone Please help me with this error i am getting
Transaction simulation failed: Error processing Instruction 2: custom program error: 0x8e :any idea what this 0x8e error is?
what is `zero copy` and why it matters?
Yeh I just had to switch to new_with_signer and it worked
I just tried both NodeWallet and anchor.Wallet today with the 0.18 anchor version (instead of 0.19 which I had tody). worked without any errors!
if its a PDA you would have to do new_with_signer yes. if its not a PDA, you need to pass the "signer" macro into that accounts macro
basically that one is not able to sign
can you check which of the input accounts corresponds to the address starting with `5gUP..`? You can console log all variables and it should become clear
maybe I need to be calling new_with_signer and not new?
I'm not quite sure how to correctly restructure my code for that though.

Yeh of course
can you post the full error message? it usually tells you if its a signer issue, or a writable issue
am I wrong here?

So I thought the authority should be the account bc I set it as it's own authority when initing it:
nvm it is right the program just wasn't deployed right so I was testing on an old version.
in this version I get this error instead:
```
Cross-program invocation with unauthorized signer or writable account
```

Okay so I sent some spl tokens to a pda account owned by my program and now I'm trying to get the program to send them back. I'm getting the error:
```
owner does not match
```
Which I assume would mean the pda authority isn't matching the pda account but the code looks right to me. Anyone see something I'm missing?
authority should be owner of depositor_token_account .
authority is wrong now. It should be ```authority: ctx.accounts.depositor.to_account_info()```
Greetings! What tools exist in the Solana ecosystem for doing airdrops of tokens? Is there an OpenZeppelin type company with audited smart contracts or tools but for Solana? Thanks in advance!
```
anchor_spl::token::transfer(
    CpiContext::new(
        ctx.accounts.token_program.to_account_info(),
        anchor_spl::token::Transfer {
            from: ctx.accounts.depositor_token_account.to_account_info(),
            to: ctx.accounts.vault.to_account_info(),
            authority: ctx.accounts.depositor_token_account.to_account_info(),
        },
    ),
    amount,
)?;
```
I keep getting the error `Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account`. 

But I made sure all the accounts are writable with `#[account(mut, ...)]`. 
And I had `depositor`  as the `Signer<'info>`.
Is it possible to convert a byte buffer to an idl's account
Ah question, so i've run into the issue with cargo where "feature edition2021 is required" for the solana-frozen-abi package.. 

I updated Solana to v1.8.11 as it seems most people solved this issue upgrading Solana... buut now anchor build/anchor test don't output anything when trying
which version did you upgrade to?
Whats the best way to listen to the program account for changes?
Maybe you can use Vec too idk
That's one way, at least. Curious if alan has any other ideas
```
#[account(
    init,
    bump = bump
    seeds = [sequence_number]
)]
pub user_account: Account<'info, UserAccount>
```
you can use a PDA with a number as the seed value
beginner question: 
I'm trying to make a program that can generate 600 total accounts. I want a user to be able to "name" an account, ensure that name is unique, and then increment a counter. 

Do I need to store these accounts in a vector? or can i just leave them all ~floating around~
thank you 🙏
it worked!
Did that fix it?
idk what that does but I will look it up XD thanks
`use anchor_lang::prelude::*;`


Probably need to see way more of that file
<@!134416332509675520>  any ideas? 👀
wat
ok, that's actually a very useful point I did not know/understand. Thanks again!
Yeah (or rather, by "passing it as an account" from the client = specifying that you care about its address from the client)
I've been running the Solana Test Validator. And verified the program deployed etc
ohhh ok. So, the only way to 'load' a program/account is through function inputs ?
So just like other accounts you have to tell solana ahead of time that you want it to load them
Programs live in accounts
oh i see
Using a constant for the address isn't enough—you need to tell solana (from the client) that we care about the *account*
sorry, here: https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo/src/lib.rs#L33
Where?
why not just use a constant here tho: 

https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo
Right, I'm saying you *have* to do that (you need some way to tell the client, "you need to pass the token program")
Ive seen this in all examples, just using yours
e.g. https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo/src/lib.rs#L187
What do you mean?
but anchor seems to force this too no? in contexts
That's why you have to pass the System Program too, etc.
Annoyingly, you actually *have* to pass it in solana—anytime you want to CPI to a program you have to pass it as an account
(i.e. why not just have it as a constant in our program)
Why do we always provide token_program as an input to our program functions? Is this for supporting new token_program addresses in the future?
Just calling `.toBuffer()` on a bignum doesn't specify anything about how many bytes to use, endianness, etc.
Maybe try doing `bs58.encode(searchVal.toArrayLike(Buffer, 'le', 8))`
One way you could get this is if you added a function but forgot to redeploy (assuming you're running against a live validator, rather than just letting anchor test spin one up for you)
Going to look into that
In response to myself I found this:
> That means you tried to invoke an instruction whose "sighash" doesn't match anything the program knows about. Anchor supports having a fallback function that can handle these, and you probably don't have one—how are you attempting to invoke your instruction?
any code snippets of that would be much appreciated
Anyone have any code snippets of working with time in rust/anchor? Like adding some days to the clocks unix timestamp etc etc
Hello there! I'm trying to run a program function but keep running into the following error: ProgramError: 101: Fallback functions are not supported

The trace doesn't really seem to provide much context as to what would cause this. I'm curious where I should start when debugging this issue, and what causes this error code in the first place. Thanks!
I am trying to filter an account by an entry that is a u64 in the rust code. When I write the filter as a test I don't get what I expect:
```
it('can filter MatchingDeclarations by donatedLamporstAtStart', async () => {
    const searchVal = new anchor.BN(donation);
    const matchAccounts = await program.account.matchingDeclaration.all([
        {
            memcmp: {
                offset: 8+ // Discriminator.
                        32+ //Author
                        8, //Timestamp
                bytes: bs58.encode(searchVal.toBuffer()), // donation.toBase58(),
            }
        }
    ]);

    assert.equal(matchAccounts.length, 4);
    assert.ok(matchAccounts.every(matchAccount => {
        return matchAccount.account.donatedLamportsAtStart.toNumber() == donation
    }))
});
```
I find no matching accounts (though there should be 4). I think the problem is in my attempt to create the bytes. Any advice?
Just cause one of them complained about stack space but the other didn't
<@!134416332509675520> why'd you not use `Box` here, but then used `Box` on Line 219? 
https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo/src/lib.rs#L209
i'm pretty confused, but its working now. yay
ahhh nevermind I mistated. The real reason it didnt work is because I had solana logs running! I needed to run the test-validator, but not run solana logs.
The documents actually stated that 🤦‍♂️
I figured it out, I didn't read the anchor documents carefully enough. I had a test-validator already running. I had to shut it off and then run anchor test
i have not, i just thought the built in tests should pass and thought maybe i had some kind of  local test-validator configuration issue . I think I'll try running it on the devnet and see if it works there
Oh my bad- have you tried isolating the problem? Make sure the msgs appear in a manually started localhost .ts test or on devnet?
I am running solana-test-validator version 1.9.0, maybe thats incompatiable with anchor 0.19?
I've run that , i see the logs in the solana logs session, but the anchor tests/events test is not passing, it doesn't see the logs.
run `solana logs —url localhost` in another terminal
i probably wouldve never figured that out without your help lol thanks
ohhhhh i see
yup there is indeed a log there, hmm maybe something is funky with the test. not sure why it hangs
You need to look at the actual version that corresponds to your Cargo.toml etc.
You're likely looking at a different version of it than the version of anchor you're actually using in your program
yeah i saw that file but it doesn't have 0x8f (143)
https://github.com/project-serum/anchor/blob/v0.18.0/ts/src/error.ts
Been looking up and down the repo
I can't find that file :/
You just get used to going hex -> decimal -> look up in error.ts in the anchor source (lol)
how did u know that it's the Constraint error? Where could I have found that info online? I searched Google a lot
Yeah, that's one of your own anchor errors, not a token program error. 0x8f = 143 which is the old number for ConstraintRaw (a `constraint =`) [edit: discord inserting happy faces lol]

Why do you think that's where the error is coming from? Can you post the full program log?
https://github.com/solana-labs/solana-program-library/blob/ea354ab358021aa08f774e2d4028b33ec56d4180/token/program/src/error.rs#L10
oh I see, ok perfect. Thanks so much, so helpful!
No, questions are all good! The `authority: ` argument there is just part of the API for doing a token transfer—you have to pass in the account that has authority over the `from` token account, and then the spl token program will verify that the authority account signed
So, does that line above (line 38) have anything to do with that "signing" or would it have worked fine without that line too?

I.e. is there any part of that code that explicitly gives permission to do the transfer or is just the fact that the user calls that function enough? Could one just have a function like this that would if anyone called it? I promise, this is last question haha
```
    pub fn hack() -> ProgramResult {
        anchor_spl::token::transfer(
            CpiContext::new(
                token_program_account, 
                anchor_spl::token::Transfer {
                    from: victim_account, 
                    to: scammer_account,
                    authority: victim_account,
                },
            ),
            99999999999,
        )
    }
```
probably check `./.anchor/program-logs` in your project's root directory
I'm trying to run the tests/events but its hanging and never receiving events, i see the program executing on the validator though
If I'm running a local test validator, is there anything I need to do to get the validator to send msgs!() to anchor client?
So because the offer_maker signs the tx from the client, they implicitly give permission to do that transfer
The offer_makers_maker_tokens (mouthful) are already owned by the offer_maker (they kicked off the offer process by showing up with some tokens in their offer_makers_maker_tokens account, and then transfer them to the escrowed_maker_tokens account)
Ok, so this is a little more intuitive to me. The offer account AND escrow_maker_tokens is initialized in the program, which is how I would have went about this. Would love a clarification though: 
Where/How exactly does the offer_maker give permission here:

https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo/src/lib.rs#L38

I do see that we have the 'Signer' here, is that where the permission comes from? A little confused on the magic/link there? If so, would that mean we could use ` authority: ctx.accounts.offer_maker.to_account_info(),` for any action that would require that authority?
Whoa, amazing! thank you, will take a look🙏🏻
(This is my anchor escrow program if you want to see how I would think about it: https://github.com/cqfd/quidproquo)
Ah, ok, I haven't actually really read that example before, I might be wrong about how it's structured
Where are you looking?
`Transaction simulation failed: Error processing Instruction 0: custom program error: 0x8f`

How do I see what `0x8f` is? I can only find errors 0 - 15
Ok hmmm.. So it looks like the flow is like this:

1) User ('initializer') creates temp_account with N tokens
2) calls program's initialize with temp_account
3) program takes ownership of temp_account
4) program transfers from temp_deposit_account to vault

I guess my confusion is, steps 1-4 seem like  a way just for the user to put money into the vault. Isn't there a more direct way to do this?

Unless my understanding of the flow above is incorrect. Appreciate the quick response and help 🙂
thanks for the response. I went with hard-coding a public address in the contract.
Whereas the vault account does indeed get created within the instruction
Pretty sure that's the token account that starts the whole thing off, so yeah, that has to exist prior to doing anything else
Hi everyone, am going through the anchor-escrow contract/post and was wondering the following; is the initializer_desposit_token_account always meant to be created by the client first, then passed into the program? Would it make sense to create the temporary deposit token account for the initializer IN the program? 

Link for convenience: https://github.com/ironaddicteddog/anchor-escrow/blob/master/programs/anchor-escrow/src/lib.rs#L24
Not from calling it, but you can force them to sign with a key they don't have access to (more or less equivalent to blocking them)
Solution: https://github.com/solana-labs/solana-program-library/blob/ea354ab358021aa08f774e2d4028b33ec56d4180/token/program/src/error.rs#L10
`Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: custom program error: 0x3`

Where can I see what `custom program error: 0x3` is?
<@!350632015852208140> is it possible to prevent a 3rd-party from calling your contract?
this also worked as expected. thank you!
life saver! thank you
cqfd (alan) said: "here's an example of how you can access your program's upgrade authority at runtime: https://github.com/cqfd/anchor-upgradeable-loader"
thank you, <@!350632015852208140> I'll check it out now. I didn't know which of the channels to post the question
i feel like theres also a more elegant way, but this one works for sure
i think these guys just had hardcoded it: https://github.com/gopartyparrot/ido-pool/blob/prt/programs/ido-pool/src/lib.rs
it is possible as much as i remember, but i'd need to find a code snippet.
Dont cross post pls 🙂
hi guys i need some help with anchor, assuming this code 

```
pub struct Launch<'info> {
    // this is owned by the current program
    #[account(
        init,
        payer = authority,
        space = LaunchControl::space(),
        seeds = [
            b"crashies",
            authority.to_account_info().key.as_ref(),
        ],
        bump = bump
    )]
    pub launch_control: Account<'info, LaunchControl>,

    #[account(mut)]
    pub authority: Signer<'info>,

    pub system_program: Program<'info, System>,
}
```

is it possible to determine if `authority` created the current program? 

Basically, I only want to allow an endpoint to run only if the `authority` also created the program. Is this possible?
thanks a lot again man!! 🙂
nono you're not, makes absolute sense. i just got ahead of myself again. will try manual building
ahhh, yh true, this was the main issue. i'll check it out. thanks a lot, i'll have a look! 🙂
I think I'm confused where you're getting stuck
you can check the logs in the `.anchor/program-logs` folder, or the terminal output when you run `anchor test`. are you running anchor test on localnet or devnet?
Ah, got it—yeah I would just mint those tokens ahead of time (I mean, I don't know, maybe it's ok to just embed the keypair—but you don't need a wallet for that! You just need a keypair)
like, its "global" tokens, shared across all users
but the mintauthority needs to authority minting new tokens, no? xD
That's not the log I mean, I mean the output of the solana validator
yh i use this library which is good: https://github.com/solstar-tech/easy-spl
No need for a keypair because you'll just use the user's wallet to sign the tx
why it don't invoke other program...? plz help 😦
No, you'll just build the tx manually and then submit it
like, literally the contents of mintTo? but wouldnt this require the keypair at some point either?
The spl token js code is not very convenient to use unfortunately
but It seems no wrong
I double-checked log
Ah, ok. By far the easiest way to do this is to actually skip the `mintTo` function and just copy its implementation (dumb, but that's the easiest way 🤦‍♂️)
Hello,
```
Instruction { program_id: C65rg4TFFUq5JMN00000000000BBryweLbiD8t6higVvrE, accounts: [AccountMeta { pubkey: Bfm2Bad4dFVyH000000007S5TRUzmQnXMPYnvMcr3, is_signer: false, is_writable: true }], data: [79, 0, 0, 0, 180, 171, 4, 0, 232, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 44, 0, 0, 0, 57, 75, 117, 99, 90, 105, 68, 97, 49, 106, 102, 112, 57, 103, 88, 55, 114, 55, 114, 112, 49, 114, 55, 86, 120, 86, 67, 114, 120, 85, 115, 83, 104, 118, 112, 68, 107, 103, 57, 56, 75, 98, 115, 87, 44, 0, 0, 0, 57, 75, 117, 99, 90, 105, 68, 97, 49, 106, 102, 112, 57, 103, 88, 55, 114, 55, 114, 112, 49, 114, 55, 86, 120, 86, 67, 114, 120, 85, 115, 83, 104, 118, 112, 68, 107, 103, 57, 56, 75, 98, 115, 87, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 48, 48, 48, 48, 48, 48, 48, 48] }
[AccountInfo { key: Bfm2Bad4dFVyHP4h5000000RUzmQnXMPYnvMcr3 owner: C65rg4TFFUq5JM00000000UtBBryweLbiD8t6higVvrE is_signer: false is_writable: true executable: false rent_epoch: 0 lamports: 0 data.len: 144  data: 0100000000000000e803000050f7c96100000000640000002c000000394b75635a694461316a6670396758377237727031723756785643727855735368767044 ... }]
```
to mint new tokens to play around with the application
yes, i use the user's wallet. but the the `mintTo` function still requires the mintauthority key
Mm, if it's for dev purposes, can you not just still use the user's wallet?
at least, thats what i had in mind
and for that i need a global mint authority whose keypair is shared
only for dev purposes, i want to mint some tokens to the user through the click of a button
Why wouldn't you use the phantom one etc?
yh theres quite some discrepancies between node and browser, annoying when trying to integrate
Why do you need to create a wallet yourself in the browser?
Yeah, anchor just doesn't even export the Wallet creation stuff in the browser :/
ah sorry, shouldve been more explicit
ah its in browser
Oof, misread
Ah, I'm sorry, you're doing this in the browser?
also tested it before with the UInt8Array.fom instead of Buffer.from, had the same error as the ones we discussed prior to that
i feel like theres some typescript stupidity going on
gives me 
``` 
TypeError: _project_serum_anchor__WEBPACK_IMPORTED_MODULE_4__.Wallet is not a function
``` 
shit is Fd up 😅
Ah, no
```.ts
const mintAuthority = new anchor.Wallet(mintAuthorityKeypair)
```
very annoying
but from a type perspective theyre pretty similar in their constructor
``` 
const mintAuthority: Wallet = Wallet.fromKeypair(qPoolContext.connection, mintAuthorityKeypair);
``` 
this doesnt
weird thing is, 
``` 
const mintAuthorityKeypair: Keypair = Keypair.fromSecretKey(uintarray);
``` 
this works fine
nope, doesnt do the trick
What if you do Buffer.from instead of Uint8Array from
im pretty sure its some typescript / babel stuff. but i have no idea about babel, so looking for another function to do the job
yeah
Where does stuff actually break then? The `.fromSecretKey` part?
and modified some numbers
no solana on that
yh its a dev keypair, no worries 🤣
Careful about posting that!
my god
lmao
the array is taken from the `.config/solana/id.json` file
very dirty
```
const uintarray: Uint8Array = Uint8Array.from([  149,226,18,86,166,52,2,141,172,220,209,227,65,253,79,35,131,85,164,23,25,8,248,223,90,167,172,144,133,236,229,146,188,230,180,3,5,118,190,238,157,122,51,60,83,186,124,199,151,67,175,226,211,199,1,115,172,75,72,51,82,16,255,4
        ]) 
        const mintAuthorityKeypair: Keypair = Keypair.fromSecretKey(uintarray);
```
Seems to work fine for me, how are you getting the keypair?
`ts-ignore` doesnt seem to do all the job. neither does `@ts-expect-error`
was trying that for a couple hours before, keep getting this one
``` 
Unhandled Runtime Error
TypeError: Class constructor Blob cannot be invoked without 'new'

Source
src/qpools-sdk/splpasta/tx/token-instructions.ts (37:21) @ new PublicKeyLayout

  35 | 
  36 | 
> 37 | class PublicKeyLayout extends BufferLayout.Blob {
     |                     ^
  38 |   constructor(property) {
  39 |     super(32, property);
  40 |   }
```
Kind of annoying, you can do
```.ts
// @ts-ignore
const wallet = new anchor.Wallet(theKeypair);
```
all right
Sorry, can you post the actual log output though?
```
pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();
    let account = next_account_info(accounts_iter)?;
    let mut account_data = ProgramAccountInfo::try_from_slice(&account.data.borrow())?;
    if account.owner != program_id {
        msg!("Account does not have the correct program id");
        return Err(ProgramError::IncorrectProgramId);
    }
    let data_from_client = InstructionInfo::try_from_slice(instruction_data).unwrap();
    let is_deposit = data_from_client.is_deposit;
    if is_deposit {
        account_data.region = "BASEMENT".to_string();
    } else {
        account_data.region="00000000".to_string();
    }
    let instruction = Instruction {
        program_id: *program_id,
        accounts: vec![AccountMeta::new(*account.key, false)],
        data: ProgramAccountInfo::try_to_vec(&account_data).unwrap()
    };

    invoke(&instruction, accounts)?;
    Ok(())
}
```
That's my entire program, and input program_id and accounts is other program B's program ID and program B's account. so invoke supposed to invoke program B I assume...
ah got it.. yeah actually it started complaining about the following..
``` 

Module parse failed: Unexpected token (8:32)
You may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders
|  * Node only wallet.
|  */
>
``` 
will dig a bit deeper, seems uncommon
Ah, hmm, I guess this doesn't really work currently with typescript very well (it *is* exported but not in a typescript friendly way)
of course!
Can you post your entire program log? Much easier to debug that way
also NodeWallet is part of @project-serum/anchor? my editor cant seem to import this
again, did you try msg! macro? xD it gives you really good insights to place some logs between all function calls to understand if the program even runs until there. maybe im overseeing something obvious too tho
I think it was just a 🤷‍♂️ kind of decision tbh lol
got it, thank you, I guess my question is why mocha is the default, a few of my friends thought it's implied they should use it and so they kept using it
It does, but you can switch it out with 1 line
got it, I was under impression that it runs mocha by default
You can actually use whatever you want for tests, anchor doesn't really dictate anything (just switch out the command to run in your Anchor.toml file)
I updated my question, it does not contain for loop 🙂
nice, cheers! 🙂
Going the other direction is provided by the `NodeWallet` class (you just pass it a keypair as its one constructor argument)
can you provide some more logs? did you try debugging using `msg!()` macro, if the for loop runs etc.?
ah yeah that makes sense. but what about the other way around? that should technically work, no?
You in general can't convert a Wallet to a Keypair (for example, your phantom wallet will never ever leak your actual keypair)
hey folks, I wonder what informed using mocha vs jest by default? Is there anything we need to know if we plan to migrate?
I made custom Instruction
```
 let instruction = Instruction {
        program_id: *program_id,
        accounts: vec![AccountMeta::new(*account.key, false)],
        data: ProgramAccountInfo::try_to_vec(&account_data).unwrap()
    };
```
for invoke
```
    invoke(&instruction, accounts)?;
```
but it didn't invoke target program. May I know why?
any idea if there is a way to convert the `Keypair` type to the `Wallet` type? (and vice versa)? Having lots of troubles with these as I am moving between tests and the web-app
nice :)
It tries to be, yeah (not 100% perfectly typed, but it tries)
is anchor typescript friendly?
btw is there any way to get the source code of a program by providing its address ? or we just have to trust them ?
Ah i see...
But there's no solana rule that says the owning program needs a signature in order to mutate an account's data/spend its money
E.g. system_instruction::transfer definitely requires a signature, but that's only because it wouldn't make any sense otherwise
Yes. Signatures are 100% optional/up to the program logic.
so the program can change the data without even a signature from owner ?
ya but that's the usual way that's why we're keeping the keypair in react at the first place...
You can't currently resize accounts, but you apparently will be able to soon, in an upcoming release
did you ever figure this out? I ended up creating a new keypair (i.e. new account) also. But would like to know how to avoid breaking my programs and actually upgrading them
At the end of the day *only* an account's owning program can mutate its data (whether this requires a signature is up to the program)
Knowing the keypair for an account address doesn't necessarily mean they can change the data there (that's up to your program)
i mean anyone with access to they keypair can change the account data like changing someone else's gif...
i'm kinda new to react so i thought the keypair in the server would be accessible to anyone while react can access it as its a frontend framework
ty sir, I completely forgot to refetch
If it is just providing access to the programs within the account, your frontend is just a UI for that right? but I am not sure of all the implications
not sure lol
is it secure to store the keypair in json at frontend ?
didn't participate it it `:(` can we check it now ?
buildspace went over that in section3, gotta generate the keypair as json and reuse it, so u dont always generate new 1
when running `anchor build` I'm getting an error ```dyld: lazy symbol binding failed: Symbol not found: ____chkstk_darwin
  Referenced from: /Users/Tom/.rustup/toolchains/bpf/bin/cargo
  Expected in: /usr/lib/libSystem.B.dylib```
Debian?
Are there any WSL distros that support npm anchor or do you always have to build it?
What have you tried so far? You would just need to decide on an address for it and create it the way you create any other account
how should i create the single account ?
You would just pick a single account to store it in
i don't see any example for that : (
i mean i don't wan't each user to initialize an account to store the gif i just want to store the list in one account owned by the program
https://github.com/project-serum/anchor/blob/master/examples/tutorial/basic-1/programs/basic-1/src/lib.rs
how do i store `gifList` in one program account instead of initializing it in each `baseAccount` ?
Beastttt
<@!912046857000194158> randomly, here's an example of how you can access your program's upgrade authority at runtime: https://github.com/cqfd/anchor-upgradeable-loader


//////////////////////////////////////////////////////////////////////////////////////////

best i can find is `program.idl.errors`
i know it's in my IDL 🤔
So I can do things in JS like `assert.ok(txnError == ErrorCode.Overflow)`
How do I pull my program-defined #[error] enum into my test file?
ohhh interesting. Woulda never known that lol. Thanks!
The first one is probably the index of the instruction that errored (you can submit multiple instructions in a single tx)
<@!134416332509675520>  I found a way to pull the error from `simulate`: `simulationResult.value.err.InstructionError`
That command outputs an array of two elements:
```
0:0
1:{Custom: 167}
[[Prototype]]:Object
length:2
```

But what do each of those two values represent? Second one is the error code, but idk about the first
You'd have to do something like `seeds = [..., &[master_account.supply as u8]]`
Ok nice, then 255 will do for now 😄
Yep, with a u8 there's only ever one byte, so don't have to decide how to interpret multiple bytes
So if I change to u8 I don't need to worry about the endians?
Great info, thanks a lot for the help 🙏
Way simpler if you can only ever have 0-255 for the total supply 😉
But you could just as easily have the opposite convention (little-endian): "123" = 1 x 10^0 + 2 x 10^1 + 3 x 10^2 = 321 in big-endian
spent like 2 hours yesterday transforming strings into like 8 different variations
E.g. decimal numbers are implicitly big-endian, 123 == 1 x 10^2 + 2 x 10^1 + 3 x 10^0
You suffer through it like the rest of us lmao
ok, back to CS 101 for me hehehe
Mm, not sure where to read about them, besides like wikipedia—the issue is just that as soon as a number would take up more than 1 byte you have to decide what order to write the bytes in
I'm a JS dev. Where do I learn about these concepts like endian bytes? Does Rust lang documentation cover whats relevant?
ah I see
You just have to be careful to serialize the 8 little-endian bytes in the same way as you do it on the rust side
And then from the JS side it's a tiny bit annoying,
```.js
const supply = new anchor.BN(1000); // or whatever
supply.toArrayLike(Buffer, 'le', 8)
```
Ok, could do e.g. `seeds = [..., master_account.supply..to_le_bytes().as_ref()]`
i.e. if supply is at 10, I can find PDA for each account 1 - 10 and get data for each.
Basically, I want to be able to check the supply of the "master" so that I can then query every "puppet" account
Yeah u64
`master_account.supply` is presumably a u64, so you need to decide on an endianness when converting to bytes
What datatype are you using for the edition?
Using numbers as seeds is actually slightly awkward, since you need to decide how to convert them to bytes
Not sure if that makes sense, or would I just increment bump?
Perhaps something like:
seeds = [b"puppet".as_ref(), master_account.key().as_ref(), master_account.supply]
Not sure how to pass the edition number
Something like:
seeds = [b"puppet".as_ref(), master_account.key().as_ref(), ...?]
I would like to derive a PDA with master account key + "puppet" + puppet number (i.e edition)
Great example thanks
I don't know of a tutorial off-hand, but this escrow program has a bunch of them: https://github.com/cqfd/quidproquo
Are there any tutorials you can recommend on doing CPI with PDAs?
as a short follow up, to use structs in other programs, you'd have to import it as a crate then from the crate?
ohh interesting
Or in examples/basic-3 in the anchor source
https://project-serum.github.io/anchor/tutorials/tutorial-3.html#defining-a-puppet-program
i cant find online
where is that tutorial?
But yeah, you often have accounts under your program's control and hence need to allocate/initalize/create them etc.
Nope, no standard methods in solana—everything is up to whatever your program is doing
Beginner question here 👋 
Is initialize some kind of standard method? Is it required? I see most of the examples implement this...
You would have one program depend on the other's source code, e.g. check out the basic-3 anchor tutorial
how would you deserialize it then?
Gotcha, I see. Thanks alan 👌
Mm, they would both be able to *deserialize* it, but both doing `Account<'info, Vault>` wouldn't work since that also checks for program ownership
<@!691933164909756466>
say I had a vault struct in program A,

```#[account]
pub struct Vault{
  pub storage: u64,
}```

and i copy and pasted that into program B. would both be able to read the storage field?
Mm... what do you mean? Deserialization is just deserialization, so I assume the answer is yes but I'm not quite sure what you're asking
can two programs deserialize the same Account struct if its defined in both programs?
And for 2. I often check for specific error codes.
At any rate for 1. I don't think switching test frameworks will help, you'd just have to do something where after each test you restart the validator with a fresh state
1. This is unfortunately more of an issue with the test validator itself (e.g. in a normal web backend testing situation you run each test in its own little transaction and then roll it back after test completion—I'm not sure the test validator exposes an easy way to do that)
2. Not sure, I never actually use the simulation feature in tests, I just run it for real
<@!134416332509675520> 
I have two concerns about the current testing framework that anchor is using:
**1. Unit tests aren't siloed.** Modifying state in one unit test also modifies the next. Are there any alternatives you recommend instead of mocha?
**2.  program.provider.simulate masks errors.** When I expect an error, I just do `assert.notEqual(res.value.err, null);`. But this doesn't actually check if the error was caused by what I expected it to be. Are there any altneratives?
kek 🙂
Honestly not sure how you could have done that though lol 😛
Sounds like you didn't do the associated token part correctly, hmm

Can you show the actual program log? Easier to look at than the js stack trace
```.rs
#[derive(Accounts)]
pub struct DoTheTransfer<'info> {
  #[account(mut)]
  pub source: Signer<'info>,

  #[account(mut)]
  pub destination: AccountInfo<'info>
}
```
<@!134416332509675520> sir, sorry to bother again. Does this have to do with the bump (I don't know what it is yet). Happens after I use the correct method to create an account
No, can't use that, you have to pass their address in as an account
If you already know B's address then it's not clear to me at all why you need your own program to do this

Just pass their address in as an account from the client
Ok, then you know their account info 🙂
i dont hv the struct
ik their address
If you don't know their address?
Then how will you later enforce that B and only B can withdraw it?
i dont hv their account info
Why not just send it directly to B?
withdraw function allows user B to claim the sol
.
like if i store the sol in system program
Which withdraw function?
i think i cn make it using the withdraw function
Not possible in solana—tbh I think you should probably downshift and work through the anchor tutorials, the task you're working on now will be tough until you understand solana/anchor a bit better
how do i send sol to account whose account info struct i dont hv
i presume its senders/signers account
Yeah, so that's just some account, not your program itself etc.
Thanks a bunch!
No IDL (it's not an anchor program), just use that instruction builder and have it run before your actual rpc call
Gotcha, thank you very much! Do you think I can get idl for AssociatedToken account and just do an rpc call? Rpc calls feel so straightforward
`spl.Token.createAssociatedTokenAccountInstruction`
```#[derive(Accounts)]
pub struct SenderContext<'info> {
    #[account(mut)]
    pub base_account: Account<'info, BaseAccount>,
    pub msg_sender: Signer<'info>,
}```
You'd have to look at the `SenderContext` struct to see what it means
Yeah, "base account" is just what you've happened to name one of the accounts, it doesn't mean anything by itself
```rust
pub fn send_sol(ctx: Context<SenderContext>, amount: u64) -> ProgramResult {
        let base_account = &mut ctx.accounts.base_account;
        let msg_sender = ctx.accounts.msg_sender.key();

        for split in base_account.splits.iter() {
            let split_percentage = Percentage::from(split.percentage);
            let split_amount = split_percentage.apply_to(amount);

            // let ix = anchor_lang::solana_program::system_instruction::transfer(
            //     &msg_sender,
            //     &split.address,
            //     split_amount,
            // );
            
           let ix = anchor_lang::solana_program::system_instruction::transfer(
                &msg_sender,
                &split.address,
                split_amount,
            );

            anchor_lang::solana_program::program::invoke(
                &ix,
                &[
                    ctx.accounts.from.to_account_info(),
                    ctx.accounts.to.to_account_info(),
            
                ]
            )
        }

        Ok(())
    }``` this is my code
Pretty sure there's already a helper function to do this for you though
You need to instead send an instruction to the associated token program asking it to create the account for you (you can't do it yourself)
Ok, yeah, that call to `createAccount` won't work, you can't sign for that PDA from the client (it's impossible to sign for PDAs from the client—only their deriving programs can sign for them)
so a bypass method is storing it in contract
like im trying to calculate sol value then send it from to person but i dont have Account info struct of that person who ive to send to
```
const nft = new Token(
        connection,
        mint,
        TOKEN_PROGRAM_ID,
        provider
      )

      const rent = await connection.getMinimumBalanceForRentExemption(
        MintLayout.span
      );

      const toTokenAccount = await Token.getAssociatedTokenAddress(
        ASSOCIATED_TOKEN_PROGRAM_ID, 
        TOKEN_PROGRAM_ID, 
        mint, 
        receiver
      )

      const toTokenAccountInfo = await provider.connection.getAccountInfo(toTokenAccount);

      if (toTokenAccountInfo == null) {
        const instruction = anchor.web3.SystemProgram.createAccount({
          fromPubkey: provider.wallet.publicKey,
          newAccountPubkey: toTokenAccount,
          space: MintLayout.span,
          lamports: rent,
          programId: TOKEN_PROGRAM_ID,
        })
        
        const trans = await setWalletTransaction(instruction)

        const signature = await signAndSend(provider, trans)
```
And the function to set instruction to the wallet is

```
const setWalletTransaction = async (instruction) => {
    const provider = getProvider();
    const transaction = new Transaction();
    transaction.add(instruction);
    transaction.feePayer = provider.wallet.publicKey;
    let hash = await provider.connection.getRecentBlockhash();
    console.log("blockhash", hash);
    transaction.recentBlockhash = hash.blockhash;
    return transaction;
  }
```
<@!134416332509675520>
Where did you get the term "base account" from though?
or is there a direct method to do this
user A send sol to contract, user B withdraws it from contract
Can you post some code?
im creating a withdraw function
"base account" isn't an independently meaningful term in solana as far as I know, you'll have to say more about what you're doing
is it the account of the contract
Guys what is base account
Yessir, blz gib me a second
Can you post the code you're running?
It's not enough to just find the address
But creating an associated token account requires invoking the associated token program
I think that might not be the actual error you're getting—are you also signing for the owner of the *source* tokens?
Yessir, I can’t understand how can a token acconunt sign, since I don’t have a key pair for it. So, I can derive the associated token address, but I don’t have any additional data to create the account. I know I should be able to crate an associatd account for someone else, but I don’t understand how that new account can sign.

In my mental model? The only available signer is my Keypair stored in phantom
Basically google 😬
in the IDL there are some error numbers but they only go from 300-310
and how can I try to find its source code?
It's raising an error but there's no way to tell why, it will depend on what that program is doing (just have to go source-diving)
Ok, you'll unfortunately have to go find that program's source and go see if you can find its custom error enum
I'm trying to understand how everything in this space works as I'm new
no it's not I'm trying to interact with
Ok, cool, is MEisE1HzehtrDpAAT8PnLHjpSSkRYakotTuJRPjTpo8 your program?
If it's an associated token account then you yourself don't need to sign for it (the associated token program will sign for it, since the address is one of its PDAs)
Here's the full output: 

```solana.rpc.core.RPCException: {'code': -32002, 'message': 'Transaction simulation failed: Error processing Instruction 0: custom program error: 0x3f', 'data': {'accounts': None, 'err': {'InstructionError': [0, {'Custom': 63}]}, 'logs': ['Program MEisE1HzehtrDpAAT8PnLHjpSSkRYakotTuJRPjTpo8 invoke [1]', 'Program log: Custom program error: 0x3f', 'Program MEisE1HzehtrDpAAT8PnLHjpSSkRYakotTuJRPjTpo8 consumed 17673 of 200000 compute units', 'Program MEisE1HzehtrDpAAT8PnLHjpSSkRYakotTuJRPjTpo8 failed: custom program error: 0x3f']}}```
So it's not the recipient that needs to sign, it's the token account's own address
What address does it live at? That address will need to sign
So you're creating a token account?
The issue here is that I don't have idl, I'm trying to send an SPL token and sign the tx with phantom. So, I need to create an account first. Logically, there's no one on the other end, so how can I sign for them?

Since associated accts are deterministic, I can't generate a keypair for a specific acct, right?
Usually people forget to sign with the keypair of an account they're about to create
You can see which one by opening up your idl file in `target/idl` and checking which accounts are ostensibly supposed to sign
You aren't signing the tx with some account that needs to sign
<@!134416332509675520> hello sir, happy NY! do you know why I get this all the time?
You may be able to see more information in the full program log
In general you'd have to think through the code you're invoking and see where it can return an error code
We would need to know way more about what you're doing—what program are you invoking? That error is just a number, so there's no way to tell what program it came from etc.
What do you mean with  type of program?
The program keypair itself is just used for deploying (the public half is the program's program_id)
No, it's your `~/.config/solana/id.json` probably
Who is `program.provider.wallet`? I thought it was the keypair of the program right
I don't think there's enough information there to tell—what kind of program are you invoking etc.?
Anyone?
There might be some testing api to initiate a fake account, not sure though
In this case, *only* your program can sign for that address ==> only your program can control the mint
Mint authority always works the same way: the mint authority needs to sign
I wish there was some testing framework that allowed some "superuser" to perform those types of actions
😦
Right, then you can't mintTo from the client, only from within your own program
```
#[account(
        init,
        payer = payer,
        seeds = [b"mint", mint.key().as_ref(), payer.key().as_ref()],
        bump = mint_bump,
        mint::decimals = 9,
        mint::authority = mint, 
        mint::freeze_authority = mint,  
    )]
    pub mint: Account<'info, Mint>,
```
This is the original mint I created through the program
You have to ask your program to please do it
If that address is a program-derived address derived from your program (~"your program owns the mint") then you can't do it from the client
Hello you all ! I am currently building a program using the Anchor framework. To test this program, I need to generate some NFTs. As the Metadata program doesn't exist in the local validator, I made a release build of it and used Amman to load the Metadata program. In my test, when I try to send the CreateMetadata transaction with sendAndConfirmTransaction, I've got these two errors:

Transaction simulation failed: Error processing Instruction 0: invalid account data for instruction
ELF error: Incompatible ELF: wrong machine

As I double checked from the data, I think that the issue has to be with the ELF error in the first case.
But I don't know how to solve this elf error. The program is deployed, I can see it with the explorer or with getAccountInfo.

Is it the right way to write js tests that deals with NFTs ?
What do you mean by your program owns? You need to specifically pass the keypair of the *address* that has authority over th eaccount
```
mint.mintTo(
   vault,
   owner: ????????,
   [],
   100,
)
```
My program owns `mint`. For the second parameter, I need to pass the program somehow. What should I put for the second parameter?
.
Hey, how can I know what is this error? 

`solana.rpc.core.RPCException: {'code': -32002, 'message': 'Transaction simulation failed: Error processing Instruction 0: custom program error: 0x3f', 'data': {'accounts': None, 'err': {'InstructionError': [0, {'Custom': 63}]}`

(this only happens when I use the anchorpy module, with the JS one everything goes through perfectly)
Could you unpack this please, sir? I'm trying to create an SPL token acct to transfer FNT, but I get `Error: Signature verification failed`
Would the following code be valid??
```
    // the token account of owner
    #[account(
        init,
        payer = owner,
        associated_token::mint = mint,
        associated_token::authority = owner,
    )]
    owner_token_account: Account<'info, token::TokenAccount>,
```

I'm trying to do this later in the instruction, 
```
let seeds = &[&AUTH_PDA_SEED[..], &[_auth_pda_bump]];
// cpi call to mint 1 token to owner
        let cpi_accounts = token::MintTo {
            mint: ctx.accounts.mint.to_account_info(),
            to: ctx.accounts.owner_token_account.to_account_info(),
            authority: ctx.accounts.auth_pda.to_account_info()
        };
        let cpi_program = ctx.accounts.token_program.to_account_info();
        token::mint_to(CpiContext::new_with_signer(cpi_program, cpi_accounts, &[&seeds[..]]), 1)?;
```

But I am getting this error, 
`'Program 2HHQPmSdaRfhb5vVragacdGhcXFbT3e6cS4ei56J3ZLa failed: Cross-program invocation with unauthorized signer or writable account'`
Hello guys, happy NY! Is there any straightforward way to send an SPL token using Anchor in conjunction with Phantom? I've spent 2 days googling, feel ded...

Trying to do it like this

```
const nft = new Token(
            connection,
            mint,
            TOKEN_PROGRAM_ID,
            wallet
        )
```
And then `const toTokenAccount = await nft.getOrCreateAssociatedAccountInfo(receiver);` to create an associated account first.

The issue with that is the `wallet` argument has to be of specific type. Otherwise, SPL library can't get public key. I tried many different ways of passing `wallet`, but I think I need to do something completely different, like first creating a tx and then signing it with Phantom. Am I right?

But if that's the case, then I'm breaking the original flow of `getOrCreateAssociatedAccountInfo()` function, which creates and associated acct if it doesn't exist, but returns an acc if it exists.

I could've rewritten all the functions from the lib to accomodate for my case, but it feels like I'm just moving in the wrong direction and the answer is much simpler.
theyre not derived
How are token accounts derived then?

I am aware that AssociatedTokenAccounts can be derived as follows, 
```
  const getAssociatedTokenAccountAddress = async (
    owner: PublicKey,
    mint: PublicKey
  ) => {
    return (
      await PublicKey.findProgramAddress(
        [owner.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mint.toBuffer()],
        ASSOCIATED_TOKEN_PROGRAM_ID
      )
    )[0];
  };
```
can be useful for programs
Why would we allow a user to have multiple token accounts then?
clarification: ONE associated token account per mint
yes. (a user can ofc have multiple wallets which can each have ONE associated token account)
Does this mean a user can have multiple Token Accounts and only ONE Associated Token Account?
I'm a little confused about the Account Constraints `token` and `associated_token`. What is the use case for each?
https://spl.solana.com/associated-token-account#motivation
Is there a difference between Token Accounts and Associated Token Accounts?
Okay, ill try it out
think you can omit the authorities, not 100% sure tho
Thanks!
```
#[account(init, payer = authority, mint::authority = authority, mint::decimals = 9, mint::freeze_authority = authority)
pub mint: Account<'info, Mint>
```
My use case is something like a social platform, where a user can create his/her own community token
Is there a way I could create an account and initialize it as a Mint through the Account Constraints? Or do I have to create it in a separate instruction? Or maybe a CPI?
dont think so. am currently writing some
Is there any documentation for Account Constraints such as,
```
token::mint = mint,
token::authority = owner,
```
Does it serialize and deserialize properly
Can they access the same data?
If I have the same struct/Account across two programs
how can I search it? do you remember any keywords?
tough question, I think it was asked in the discord before, but cant remember the answer
Hello, Is there any anchor web3 API which fetches all program's data account at once???
For those who want to test anchor with jest -> This is working example
```
ANCHOR_PROVIDER_URL=https://solana-api.projectserum.com ANCHOR_WALLET=~/.config/solana/id.json ./node_modules/.bin/jest -i tests/**.*
```
Thanks!
I found it, no need to answer it
I want to find default values when I run ```anchor test``` command
where can I find ANCHOR_PROVIDER_URL and other const variables?
it works
Thanks bro!
run the same command, but with `ANCHOR_WALLET=~/.config/solana/id.json npm run ...` . its probably not able to find your environment variables, which includes your local walllet
Can you guys tell me what caused this? I simply ran jest -i tests/**.*
Hello, I'm trying to test anchor project with jest.
and I'm facing this error:
```
TypeError [ERR_INVALID_ARG_TYPE]: The "path" argument must be of type string or an instance of Buffer or URL. Received undefined
```
I don't know why I'm getting this such a thing...
(i.e. when you execute a multisig transaction, can that only execute a single instruction)
can you only provide single instructions to the anchor multisig? seems like transaction only holds the info for a single `Instruction`
In this case, signers: [myAccount] but not [user]?

Does someone know why we usually pass the pubkey of created account instead of the one of Signer type at signers:[..] argument when we call the instruction?
SPLToken.NATIVE_MINT is SOLs mint right?
Is the "owner" of the TokenAccount the Token program, and the "authority" the user?
`Error: Signature verification failed`
```
await accrueMintToken.burn(
  userProgramTokenAccount,
  user.publicKey,
  [],
  10,
);
```
Hmm it still isn't working
The program has authority of the mint that created userProgramTokenAccount
But the account is an associated account from the address of the user
The authority over the token account has to sign off on getting some of their tokens burnt
Who is the authority over the userProgramTokenAccount?
```
await programToken.burn(
      userProgramTokenAccount,
      owner???,
      [],
      10,
    );
```
In my JS tests, how do I make my program sign for the txn to burn tokens?
You might be called `program.rpc. ..` 
Looks like `program` is undefined here.
Hey folks, beginner here trying to run `anchor test` but receive this error where the workspace can't find `.rpc`
ah I know why, I was looking in the wrong place https://docs.rs/solana-program/1.4.4/solana_program/pubkey/struct.Pubkey.html#method.from_str
ty
I had looked through docs for a `to_str` for too long, honestly I don't know how I missed it here https://docs.rs/anchor-lang/0.13.2/anchor_lang/prelude/struct.Pubkey.html but sure enough, `to_string` is there
`to_string().as_str()` works
Think you can just do `&ctx.accounts.provided_gear_mint.key().to_string()`
I'm trying to create an SPL token (https://openquest.xyz/quest/solana-my-money)
Is there a way to pass my own metadata to the token? e.g. mint a new Token, and pass an Arweave link to the Token as metadata?
Is there a cleaner way to write this conversion of Pubkey->str_array? I'm still quite new to rust and this seems heavy-handed, but I think it is valid

```
const GEAR_MINTS: [&str; 1] = ["kithbUj3JCAJYFU7A1vcMAhDdvQ8EheWSCkRwkhLj2s"];
...
if !crate::GEAR_MINTS.contains(
    &std::str::from_utf8(
        &ctx.accounts.provided_gear_mint.key().to_bytes()
    ).unwrap(),
) {
    return Err(ErrorCode::BadMintProvided.into());
}```
All good!
Damn. That worked! Thanks alan 😭 Such a noob mistake.
If you know it won't be null/undefined you can stick a `!` after it
That sounds like it's saying that the public key you're passing might (at least statically) be null/undefined for some reason, but at runtime it isn't (so it works fine)
` Type 'PublicKey | null | undefined' is not assignable to type 'Address | Accounts<never>'.` This is the error it throws
using the IDL from `target/types`
Using `// @ts-ignore` lets the instruction call pass and succeed as well in the frontend 
So looks like the type check is the only thing failing.
Trying to call some instruction say `program.rpc.instructionName()` with the correct args and accounts fails with type checks.
While the same call written as anchor test passess and it doesn't complain?
Does types work in anchor? I am trying to use `target/types` from the frontend.
Option three is the simplest (if you really want to change those mints you can always just redeploy)
(For really big integers, aka anything over 2^53, you need to use quotes like that since JS doubles can't necessarily represent them)
No, a BN is an arbitrarily big integer, e.g.
```.js
new anchor.BN("999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999")
```
not sure that's a good question
So like option 3 but I hardcode an enum into my program. Can an enum be referenced as a `constraint` (like option 1) or would I still do it during program execution like in option 2?
use an enum
Hey, another question regarding constraints and security.
I have an ix that passes the following: 
```    #[account(mut, constraint = provided_gear_pda.mint == provided_gear_mint.key())]
    pub provided_gear_pda: Box<Account<'info, TokenAccount>>,
    pub provided_gear_mint: Box<Account<'info, Mint>>,```
now, `provided_gear_mint` is allowed to be one of three specifically whitelisted mints. This will be the case for the entire lifetime of the program, but it can be any of those three types in any transaction being made.

What is the best way to enforce that? I have a few ideas. 

Option One involves storing the whitelisted mint Pubkeys in a state account array, and using that account like (pseudocode) `constraint = state_account.whitelisted_gear.contains(provided_gear_mint.key())`.  Not sure if that's feasible.

Option Two involves not using `constraint`, but then in my actual processing doing essentially the same check of `state_account.whitelisted_gear.contains(...)` and erroring out on a failure.

Option Three, I'm also aware that I could effectively hardcode the mint Pubkeys in my program itself rather than storing in state, and error out in the same way as Option Two. 

Any thoughts/better options?
- Is `anchor.BN` the equivalent of rust's `u64`?
- How can I get the maximum value of `anchor.BN`?
ah gotcha, nice! thank you 🙂
(which are implemented via msg!)
It listens to `emit!` statements
https://project-serum.github.io/anchor/ts/classes/Program.html#addEventListener
what does it listen to? msg!() statements?
anchor has an event listener api
what's the solana way to "subscribe" to events that is supported in EVM?
It`s alive, thank you very much!
Wow! I did not know about order. Thank you. Need to read doc carefully. Thank you I will try and write back!
You've accidentally flipped the order of your `#[instruction(...)]` arguments (they need to match the actual instruction function itself)
I'm a noob too but I think your system_program and token_program lines are wrong. Should be `Program<'info, System>` and `Program<'info, Token>` where Token comes from `anchor_spl::token::{Token}`
Hey, guys! I have such a code to create internal token vault but it is failed on step when creating token account. It fails with error  `Cross-program invocation with unauthorized signer or writable account` and I could not figure out what is wrong. Decided to ask here. Thanks in advance for answers!

```

// Just an empty method for now
pub fn deposit(ctx: Context<Deposit>, to_bump: u8, amount: u64) -> ProgramResult {
     Ok(())
}

//.....

#[derive(Accounts)]
#[instruction(amount: u64, to_bump: u8)]
pub struct Deposit<'info> {
    #[account(mut, constraint = from.amount < amount @ ErrorCode::DepositAmountToHigh)]
    pub from: Account<'info, TokenAccount>,
    #[account(init,
              seeds = [b"tokenkey".as_ref()],
              bump = to_bump,
              payer = authority,
              token::mint = mint,
              token::authority = authority)]
    pub to: Account<'info, TokenAccount>,
    #[account(mut, signer)]
    pub authority: AccountInfo<'info>,
    pub system_program: AccountInfo<'info>,
    pub token_program: AccountInfo<'info>,
    pub rent: Sysvar<'info, Rent>,
    #[account(mut)]
    pub mint: Account<'info, Mint>,
}
```
> (why use a PDA derived from some other program when you can use one of your own) 
Yea, my original mindset was "because that's the standard practice" - but it's standard for _users_ to use the associated_account program, not standard for programs to use it. Awesome.
yea that makes total sense to me now. Thanks!
Yeah, that's my suggestion. The purpose of associated token accounts in my mind is to give you an obvious address at which to store some tokens. For a program though, you might *already* have an obvious address to store those tokens (some PDA derived from your own program), in which case no need to use the associated token program (why use a PDA derived from some other program when you can use one of your own)
Not an identical instruction, no (so another hacky way around this is to just add an instruction argument that you change between calls, just so the instruction isn't identical)
so:
for a user that wants to hold `tokenA`, they need their own associated token account for `tokenA` to hold it. This is for standardization, so the user doesn't accidentally get multiple token accounts for `tokenA` by mistake. It's not technically necessary to use associated tokens here, but it's best practice.

for a program that wants to hold `tokenA`,  I figured it would be similar for similar reasons. But your suggestion is to instead make a PDA for `tokenA` (using e.g. `token::mint = tokenA_mint`), NOT making use of the associated account program, this way the program maintains the ability to "sign" for the account.

Do I have that right?
Can you send the same instruction call more than once on the same block and get a parallel procesing?
I'm actually not sure the cleanest way to wait for a fresh blockhash
Dumbest thing you can do is sleep for a bit 😛
Another begginers question, I'm running multiple rpc call with the same instruction and I'm getting this error. Is there a way to increase the nonce of the transaction for avoiding this error? I'm running this multiple times:
`  it("Creates a new Fibonacci term", async () => {

    await program.rpc.newTerm({
      accounts: {
        fibonacci: fibonacci.publicKey,
      },
    });

    const account = await program.account.fibonacci.fetch(fibonacci.publicKey);
    console.log(account.current)

    assert.ok(account.current.eq(new anchor.BN(3)))
  });`
They're useful for a particular situation that doesn't apply in this case
I would honestly suggest forgetting about associated token accounts for now
hm....trying to piece this together now
If you want a token account controlled by your own program, its authority will need to be a program-derived address derived from your own program
ah right, I recall reading how the associated token account itself is used to derive associated accounts
Hence your program can't sign for it
The address here is an associated token address, which is derived from a totally different program
That trick only works if the address is derived from *your* program
Ah, no
You can just have any old token account whose authority is a PDA derived from your program
`tokenA_account` was supposed to be `tokenA_associated_account` - which I believe is the standard way to assign authority for these (authority is set to the account itself since its a PDA)
If all you want is a token account controlled by your program, you don't need to use an associated token account
oh crap that was a typo
Mm, what is `tokenA_account` here? A PDA derived from your program?
so tokenA is some token that my program works with, the program would have an associated account  (_for_ `tokenA`) already initialized and likely holding some `tokenA`. The user may be receiving some `tokenA` from the program in this transaction
Why would the program have an associated token account? What do you mean by that?
the program's associated account for `tokenA`
I'm having a hard time parsing that
(That reads funny to me though—why is tokenA_account the owner of some associated tokens?)
That says this had better be tokenA_account's (associated) token account for holding tokenA_mint tokens.
What do you mean by the associated account of the program?
which it will fail _at that point_ if a user didn't provide the exact assoc. account required (the one derived from the program)
And defining it this way just means the transaction will fail if `tokenA_associated_account` isn't an associated account of the provided mint...it doesn't mean it's necessarily the associated account of the program. But that part comes into play when later do `CpiContext::new_with_signer` to transfer from/to that account
Yep
Just to clarify: the only thing special about an associated token account is its address (PDA derived from the associated token program); the account itself is just a token account.
Gotcha. So I can just do:
``` #[account( 
        mut,
        associated_token::mint = tokenA_mint,
        associated_token::authority = tokenA_account,
    )]
    pub tokenA_associated_account: Box<Account<'info, TokenAccount>>,
```
No, associated token accounts automatically live at program-derived addresses derived from the associated token program—you don't get to pick their seeds/bump, because they're automatically based on the token owner + mint.
I think I'm confusing myself. If I'm providing the account in an ix for an "associated token account" that my program owns, does that require seed/bump? I know normally PDAs require seeds and bumps, but what about a PDA that is of an associated token account for the program?
Can a PDA even be an associated token account?
```
    #[account( 
        mut,
        associated_token::mint = tokenA_mint,
        associated_token::authority = tokenA_account,
        seeds = [b"tokenA"],
        bump = tokenA_token_bump, 
    )]
    pub tokenA_associated_account: Box<Account<'info, TokenAccount>>,
```
I don't think seed/bump applies here
thank you
I would update it (1.8.0 is also kind of old now)
Something is wrong with your solana install unfortunately
Hello guys I pretty new I was using anchor fine on my mac when I switched to a windows laptop I keep getting this error i cant seem to know the issue pls help

Not sure why `msg!` wouldn't work (that's the normal way to log)
How can I log to stdout? Inside my program I log `msg!("hello world!");` but it does not show up in the Solana logs. My rust logs are set as, `export RUST_LOG=solana_runtime::system_instruction_processor=trace,solana_runtime::message_processor=info,solana_bpf_loader=debug,solana_rbpf=debug`


//////////////////////////////////////////////////////////////////////////////////////////

I don't have any examples off hand, but there are web3 helper functions for making the instructions, e.g. `anchor.web3.Ed25519Program.createInstructionWithPrivateKey`
REEEE
ahh
it is working now
Idk
<:room_temp_iq:797341877111095316>
What do you mean? declare_id! needs to be the address your program is deployed to 🤔
REEE REEE MCGEEE
I dummy, declare_id! needs the address of the wallet I using
classic response of any examples of how to do this?
Interestingly, no, seems you have to invoke it as a separate instruction: https://discord.com/channels/889577356681945098/889702325231427584/908493345079328799
I think that means you don't have yarn installed (npm install -g yarn)
Has anyone ever gotten this error "Error: failed to send transaction: invalid transaction: Transaction failed to sanitize accounts offsets correctly"? I'm literally just trying to run the out of the box example 😦
would appreciate any help
> anchor init testsolanaapp --javascript
Error: yarn install failed: The system cannot find the file specified. (os error 2)
> anchor --version
anchor-cli 0.18.2
> node --version
v12.14.1
> rustc --version
rustc 1.57.0 (f1edd0429 2021-11-29)
> yarn --version
1.22.17
hey guys trying to learn solana following these https://dev.to/dabit3/the-complete-guide-to-full-stack-solana-development-with-react-anchor-rust-and-phantom-3291 and i was able to install the dependencies correctly. however i keep running into this error when i try to run anchor init
hey, how did you use verify? can you just do a cpi call as here? https://github.com/project-serum/anchor/blob/master/examples/tutorial/basic-3/programs/puppet-master/src/lib.rs#L13-L18
Hey this is my idl: https://pastebin.com/aUqSRfFA

I haven't changed anything but I'm not too familiar with it, not sure if there's any issues with it
is `default()` instruction a way to catch any instruction calls that aren't mentioned above?

I've seen jet has it, but unsure if "default" actually means anything to anchor

https://github.com/jet-lab/jet-v1/blob/master/programs/jet/src/lib.rs#L168
the bot basically won't know which one is valid
yeah but let's say another program invokes my program while emitting a similar event that has same discriminator. In my bot how would I know which one is which ?
Not sure I follow, you should be fine. Even if it's CPI your program still follows the same rules?
You got the link in <#889577356681945101>
That's not an issue, but I'm worried about illicit program logs that might interfere, for example a user calls my program from their program and emit a program log with similar discriminator <@!248066053161222144>
On the ancho repo??
Just have to scrape the program logs after the fact by going through old transaction signatures
There is none
<@!248066053161222144> what's the best way to listen to events emitted by a program using program logs ?
But yeh, I dunno, just got to read a lot more
And you can pass in space via instructions
If onchain then you can use `init` but it has to be a PDA
If off chain, then you set the space in the client and use the `zero` constraint token
You can create an account on chain or off chain
You should try to look at the examples in anchor test repo
Yeh you're mixing up a lot of stuff here
My intention was to defined the space through client like this
```
await program.rpc.createPost({
account: {
post: post.publicKey,
        user: provider.wallet.publicKey,
      systemProgram: SystemProgram.programId,
space: 150 <-- defined 
}
})
```
the code IDE throws error like this
```
cannot find type `u256` in this scope
not found in this scope
```
eh sorry, I mean like this
```
#[derive(Accounts)]
pub struct CreatePost<'info> {
    #[account(init,payer=user,space=9000)]
    pub post: Account<'info, Post>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub space: u256,
    pub system_program: Program<'info, System>,
}
```
Because init is just for PDAs now
I think you need `zero` instead of init maybe
Oh
Assuming space is defined somewhere else
It all looks fine
Which part are you uncertain about?
Hi, wanted to ask. Can we do this?
```
#[derive(Accounts)]
pub struct CreateTag<'info> {
    #[account(init,payer = user, space = space)]
    pub tag: Account<'info, Tag>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```
There is an updated version of ido pool there already
Have you looked in anchor/tests
Lol, would love to know what actually ended up being the fix in terms of the validator code. Very weird error.
also if anyone has any better examples of liquidity pools programs
the only changes that i've made for this contract is the `CpiAccount` struct with the new `Account` struct that changed on the latest version, and the directive for the account that is `#[account(init)]` on the program and i just added the fee payer to be there...
Hey guys any one knows what is causing this issue i'm following this program over here
https://github.com/blockworks-foundation/ido-pool
and re-adding tests to the latest anchor version so i can build my program on top of it and when i'm initializing the pool i got this error over here:
```
Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 1: custom program error: 0x0
```
lol amazing - just git pull, rebuilding solana-test-validator fixed it 😅
I cant seam to find any examples of testing within the rust code?
ha nice I just found that one.
https://github.com/jet-lab/jet-v1
Hey guys, whats a great codebase to look at and get a feel for a full system built in anchor?
is there an instruction without a name? did you modify it manually maybe?
what does your idl look like?
Hey guys have been having this issue for a while now. Would appreciate any help I can get.
Hey guys i have a quick question about my tests with anchor i got this error from the solana library but idk how to track those:
```
Transaction simulation failed: Error processing Instruction 1: custom program error: 0xa2
logs: [
    'Program 11111111111111111111111111111111 invoke [1]',
    'Program 11111111111111111111111111111111 success',
    'Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS invoke [1]',
    'Program log: Custom program error: 0xa2',
    'Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS consumed 4694 of 200000 compute units',
    'Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS failed: custom program error: 0xa2'
  ]
Program Error: 8 byte discriminator did not match what was expected
error: {
  code: 162,
  msg: '8 byte discriminator did not match what was expected'
}
```
I'm updating the address in lib.rs and Anchor.toml
just tried to create a new solana keygen and a new keypair for the target/deploy
Hey guys, how you're doing?
I have a problem with my rust program....

I created a program after some tries with a test one... and now after `build and deploy` I have a error message saying  the bellow message when I run `anchor test`... can you please help me to solve that?

```
ProgramError: 167: The given account is not owned by the executing program
    at Function.parse (/Users/lucassilveira/Developer/SOLANA/PROGRAMS/gifs/node_modules/@project-serum/anchor/dist/cjs/error.js:40:20)
    at Object.rpc [as initialize] (/Users/lucassilveira/Developer/SOLANA/PROGRAMS/gifs/node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:16:58)
    at processTicksAndRejections (internal/process/task_queues.js:95:5)
    at async main (/Users/lucassilveira/Developer/SOLANA/PROGRAMS/gifs/tests/gifs.js:12:12)
    at async runMain (/Users/lucassilveira/Developer/SOLANA/PROGRAMS/gifs/tests/gifs.js:61:5) {
  code: 167,
  msg: 'The given account is not owned by the executing program'```
I saw this was asked before but there wasn't any solution: https://discord.com/channels/889577356681945098/889702325231427584/905091429376868362

Question. My localhost phantom wallet shows a spinning wheel, so I'm unable to view balances, etc. I'm able to approve transactions however which is weird. The validator is running. Any ideas ?
can you share that repository?
Dang I had just left my computer. Thanks for helping though that’s a good suggestion about adding logs. I think 1.9.0, is that what you’re on (on M1 I think I saw you say that earlier)
Well, if you're building solana from source you could always add some additional logs to the solana source: https://github.com/solana-labs/solana/blob/master/program-runtime/src/pre_account.rs#L58
What does the `--version` say? 1.9.0?
I tried reproducing that code locally and it ran with no problems.
Latest on M1 mac though  built from source
This is such an odd error to get that I wonder if it'll go away if you upgrade your validator.
What version of solana are you running?
hi everyone we run into this while building ido pool
No idea what it could mean
Yeh, the illegally modified program id is another weird error that's been popping up a lot more lately
weird
Nope, seems to be working for me (the website anyway)
github down for anyone else?
Yeah, definitely an interesting error message 🤔
no but i can try pushing it to github in a bit...just nuked the whole workspace and tried again and still same thing 🥴
Do you have your code in a repo anywhere?
Hmm
oh no it fails before that if i comment out the create associated token it still fails, thats also a function from `@solana/spl-token`
So I sort of think the actual mint part worked fine, and then for some reason the getOrCreateAssociated thing failed
Right, but the program log itself says the create mint part succeeded—your createMint function does multiple things
did it? stacktrace shows `      at Function.createMint (node_modules/@solana/spl-token/client/token.js:427:5)`
Looks like it actually did initalize the mint
Yeah, just to double check, are you sure this is the part of the code that's failing? Looks like the token program part actually succeeded (to some extent anyway), right?
looks like rent program throwing that error?
```
Transaction simulation failed: Error processing Instruction 1: instruction illegally modified the program id of an account
    Program 11111111111111111111111111111111 invoke [1]
    Program 11111111111111111111111111111111 success
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [1]
    Program log: Instruction: InitializeMint
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 2279 of 200000 compute units
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success
    failed to verify account SysvarRent111111111111111111111111111111111: instruction illegally modified the program id of an account
    1) Create certificate
    2) Use certificate
    3) Revoke certificate


  0 passing (613ms)
  3 failing

  1) certificates
       Create certificate:
     Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 1: instruction illegally modified the program id of an account
      at Connection.sendEncodedTransaction (node_modules/@solana/web3.js/src/connection.ts:3689:13)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at Connection.sendRawTransaction (node_modules/@solana/web3.js/src/connection.ts:3649:20)
      at Connection.sendTransaction (node_modules/@solana/web3.js/src/connection.ts:3637:12)
      at Object.sendAndConfirmTransaction (node_modules/@solana/web3.js/src/util/send-and-confirm-transaction.ts:29:21)
      at Function.createMint (node_modules/@solana/spl-token/client/token.js:427:5)
```
Can you show the full program log output?
the createMint call fails with that error...ive used this many times before i dont understand how it could give that error
just calling this function 
```
const createMint = async (
  connection
): Promise<[web3.Keypair, web3.PublicKey, splToken.Token]> => {
  // Generate a new wallet keypair and airdrop SOL
  var fromWallet = web3.Keypair.generate();
  var fromAirdropSignature = await connection.requestAirdrop(
    fromWallet.publicKey,
    web3.LAMPORTS_PER_SOL
  );
  // Wait for airdrop confirmation
  await connection.confirmTransaction(fromAirdropSignature);

  // Create new token mint
  const mint = await splToken.Token.createMint(
    connection,
    fromWallet,
    fromWallet.publicKey,
    null,
    1,
    splToken.TOKEN_PROGRAM_ID
  );

  // Get the token account of the fromWallet Solana address, if it does not exist, create it
  const fromTokenAccount = await mint.getOrCreateAssociatedAccountInfo(
    fromWallet.publicKey
  );
  return [fromWallet, fromTokenAccount.address, mint];
};
```
Can you post more of your code? Not sure why the payer thing would lead to that error 🤔
Hmm, you can get the `payer` in your TS tests be doing (silly-looking) `(program.provider.wallet as NodeWallet).payer`, lol
I think this also may be leading to me getting `instruction illegally modified the program id of an account` I just need to create a mint to use for my test and i copied the JS from https://github.com/solana-labs/solana-program-library/blob/master/token/js/examples/create_mint_and_transfer_tokens.js and its leading to that error
https://www.notion.so/Debugging-Custom-Anchor-Errors-b8540dd418c44a4e939ab17c56a3fd3b
in older versions of anchor you used to be able to get the keypair to execute other transactions like
```
    const mint = await spl.Token.createMint(
      provider.connection,
      provider.wallet.payer,
      provider.wallet.payer.publicKey,
      null,
      2,
      TOKEN_PROGRAM_ID
    );
```
like provider.wallet.payer...where did this go?
anyone? https://discord.com/channels/889577356681945098/889577356681945101/916145013916839946
oh snap very cool!
🙂
Yes it sucks, this is why many of us use Anchor
Yep.
some developers will use incrementing counters, others will use a hash-based approach
so it sounds like instruction serialization/deserialization is totally up to the program developer, there isn't a standardized way
Cool!
<@!134416332509675520> it passed! Thanks alan!
Yep. Arguments just get serialized into the rest of the ix data
just to confirm, arguments of the instruction do not affect the function signature?
WOW, so if my function is:
```
    pub fn foobar(ctx: Context<Bar>) -> ProgramResult {
        Ok(())
    }
```

Then `sha256("global:foobar")[..8]`?
It's not actually a sig-hash in the fn signature sense, but yeah, similar idea
Yeah, basically
wow ok that makes sense! so it's like of like Ethereum for smart contracts, the function signature is hashed
You'll likely need to do something like (pseudo code) `sha256("global:your_ix_name")[..8]` at the front of the data vec
is that not the case?
Nope
Every anchor instruction starts with 8 bytes for the "sighash", which identifies which ix function to invoke
oh.. I thought it uses an increental integer like `Token` and `SystemProgram`
huh?
(It doesn't uses indexes etc. to dispatch)
Looks like you're missing the 8 byte sighash that anchor uses
What's the instruction index?
the Anchor instruction function handler accepts no arguments
<@!134416332509675520> it's just this
```
let mut instruction_set: Vec<u8> = vec![SNOWBALL_TRADE_INSTRUCTION_IDX];
```
So just 1 byte, which is the instruction index
How are you building the `data` part of the instruction?
In addition to what Tom said, in terms of syntax you can specify as many:
```
[[test.clone]]
address = "XXX"
[[test.clone]]
address = "YYY"
...
```
as you need (Toml array syntax). However be aware that there currently seems to be a max size of 10Mb that'll get the validator to throw at genesis (which can easily be reached for complex programs). This is being addressed here: https://github.com/solana-labs/solana/pull/21596
Ah, ok, then that error does make sense haha 😛
<@!134416332509675520> I am using Anchor to call another Anchor program, but I'm intentionally not using the bindings because I wanted to treat the interface as opaque. 
```
let mut instruction_set: Vec<u8> = vec![SNOWBALL_TRADE_INSTRUCTION_IDX];
```
`SNOWBALL_TRADE_INSTRUCTION_IDX` is `1` because the instruction I want to call is the second one in the list of instructions defined in the IDL.

```
            let account_infos: Vec<AccountInfo> = vec![
                ctx.accounts.token_program.to_account_info(),
            ];
            let account_metas: Vec<AccountMeta> = account_infos.iter().map(|info| info.to_account_meta()).collect();

            let ix = solana_program::instruction::Instruction {
                program_id: *ctx.accounts.snowball_program.key,
                accounts: account_metas,
                data: instruction_set,
            };
            invoke(
                &ix,
                account_infos.as_slice(),
                // &outer
            )
```
You can't transfer to a program because a program can't sign any transactions, only a PDA could sign and become freeze authority
so, actually I am calling an Anchor program, but I'm not using the Anchor bindings intentionally
ah
100-300 is errors defined by anchor right?
So 0x64 isn't necessarily an anchor error (assuming you know that you're actually getting failing at that CPI, and not earlier in your program)
Which program are you invoking? In general custom errors are custom to the program you call
8 bytes == u64 right?
right, the error message says `8 byte instruction identifier not provided`
u64 is 64 bit
u8 means 8 bits 😛
is instruction u64 or u8?
Wait.. is instruction first 8 bytes or 1 byte (8 bit)?
Which is surprising because I thought that I added my instruction sob.
```
    #[msg("8 byte instruction identifier not provided")]
    InstructionMissing = 100,
```
I got error 0x64
Aha!
❤️ no worries brother. thats just so stupid that it's making u log in, idk why that doesnt happen to me
Thank you so uch
use together with this
https://github.com/project-serum/anchor/blob/master/lang/src/error.rs
one sec i got something for u i think
weird, i can view it publicly just fine

what does it say when you click on the link?
That's awesome man! I don't have a Notion account tho, is there any way to read this publicly? thanks!
if you are transferring freeze authority of a mint to a program, you need an AccountInfo of the currently executing program. Does this mean the program has to be passed into the ctx as an account? The ctx automatically has programId but not AccountInfo for the current program right
https://www.notion.so/Debugging-Custom-Anchor-Errors-b8540dd418c44a4e939ab17c56a3fd3b
did you try this yet?
example here https://github.com/project-serum/anchor/pull/834
`[[test.clone]]
address = "AdtRGGhmqvom3Jemp5YNrxd9q9unX36BZk1pujkkXijL"
`


//////////////////////////////////////////////////////////////////////////////////////////

sounds like a general linux issue not an anchor issue

the reason it doesn't work in root mode is because in root your PATH is different and anchor executable is not on it. Also you probably don't want to run as root:)

make sure both cargo and anchor are installed on whatever PATH you're using

For example in use mode
but when i  use in normal mode is work but it need permission each time. anyone know how to work it in admin mode ?

Hello when i use anchor test in root mod some command is unreconized
This has been showing up a lot lately and I'm really curious what newbies are doing to make it happen
Please post what you find if you figure out what's causing this error
oh i figured it out. The tests fail if I'm running the `solana-test-validator` at the same time
ok huge thanks, will check this out
Hi there, I'm just running through the Getting Started tutorial and have come to the end of the "Minimal Example" everything worked as expected until I ran the `anchor test`. This is my error: `Error: failed to send transaction: Transaction simulation failed: Attempt to load a program that does not exist`. Any suggestions ?
this prints out nices logs of each constraint as its checked
actually I just realized, we never got the original feature to work, or kind of extended it, you can see how we use it

our fork
https://github.com/microwavedcola1/anchor/commit/64f7baea8d0e2529a4659f3094694d657042bbd1
how-we-use
https://github.com/blockworks-foundation/voter-stake-registry/blob/master/programs/voter-stake-registry/Cargo.toml#L22
found this in the examples/tests

but there are no further infos in the logs

`[features]
anchor-debug = ["anchor-syn/anchor-debug"]`
sorry didnt found anything in the docs and github after a quick search, how does this work
You can use the anchor-debug feature
I know what this error means, but just for faster debugging
got the following error. Is there a way to debug which account of the many I pass to the program is the wrong one? 

`Error: 167: The given account is not owned by the executing program`
I ended up just closing the account and re-initiating it. not sure if there's a better way though
I have used `remainingAccounts` for this purpose.
How do you pass in an optional Pubkey from the javascript Anchor client?
if I've already initialized a program account of a certain size, is there a way to add another field to it? I'm getting a "Failed to deserialize this account" error
i would think so since the serde won't work on that account (most likely)
I guess the next time Anchor tries to read from that account it'll throw an exception?
but i've not changed the layout of the data
un-related follow-up, does anyone know how anchor deploys work? For example: I have this PDA account that has some existing data
yeah i was thinking the same... 2 years rent from exempt  used to calc per day
`getMinimumBalanceforRentExemption` for anyone else w/ this problem
yeah -- I ended up using the rent exempt amount & multiplying it by the right number
oh..you mean specifically for a certain number of days as opposed to the rent exempt amount
solanapy has something...i think it would be similar in web3.js
I looked through @solana/web3.js docs, but I didn't see anything on rent
i.e let's say I want to create an account that is 20kb in size & I want it to have enough rent for 5 days
Is there any way to use web3 to calculate the correct amount of Sol to give to a newly created account?
Were you able to get it working? I have the same issue.
if i include recent blockhashes account in the inputs, i keep getting "exceeded maximum number of instructions allowed"... it doesnt happen with clock or any other program...simply including it causes it to error out with that message....
ah found the answer to this at  https://docs.solana.com/developing/runtime-facilities/sysvars
Make sure the cluster is pointing to the right net (devnet, localnet) on the anchor.toml file
That was the bug for me.
Check out this issue on GH. There are some ideas on how to resolve this
https://github.com/project-serum/anchor/issues/168
(outside of passing it in)
how do i get the recent blockhash inside an anchor program?
perfect, yeah saw the release notes - just wanted to double check - appreciate it!
They're basically equivalent but the latter is slightly preferable (it encodes more in the types)
instead of: 
```
 #[account(signer)]
     user_authority: AccountInfo<'info>,    
```
should i do:
```
user_authority: Signer<'info>,    
```
hey guys how to set id type in a struct for a rust program?
did a little more research and figured out that solana setup for windows is mostly broken.. stuff works a lot smoother in WSL though


//////////////////////////////////////////////////////////////////////////////////////////

I'm an idiot thanks
Just as the string. `anchor.BN` is for Big Numbers, not strings.
How do I pass in a string instead of using an integer?

```
const tx = await program.rpc.create(provider.wallet.publicKey, new anchor.BN("My Username"), {
      accounts: {
        myAccount: myAccount.publicKey,
        user: provider.wallet.publicKey,
        systemProgram: anchor.web3.SystemProgram.programId,
      },
      signers: [myAccount],
    });


#[account]
pub struct MyAccount {
    pub username: String,
    pub authority: Pubkey,
}
```
`*ctx.program_id` gives the pubkey of the program. Thank you!
Mm, the address of your program is accessible as `ID` or `ctx.program_id` (not sure if this will actually give you what you want, but that's the current program's address)
Given a `Mint`, you can get its extant supply with `.supply`
okay.
I need to invoke another program on chain and send the current program address as the argument.
myapp::cpi::initialize_token(cpi_ctx, bumps, name, symbol, `this`);
`this` should be the address of the calling program.
How can I pass the right address?
Did you figure out how to get total supply of token within a program? I think trying to unpack the data field of an account may work?
You're going to have to be more specific (anchor/solana is quite different from solidity, so I doubt you can just port stuff—maybe take a look at https://github.com/hyperledger-labs/solang)
Hi everyone. 
I have some problem in writing anchor program. 
Need to get `this` on anchor. I'm exporting some solidity code and need to translate `address(this)` from solidity.
Any ideas for this? Thank you in advance.
hey all. i'm building a web app. when i invoke an anchor command in a react component, like so:

https://github.com/cavaunpeu/anchor-escrow-program/blob/a2e58c4338b17c73f9a4a49d1d546c71e856a9ca/src/client.tsx#L6

my app fails to build with the attached error.

this happens with and without `solana-test-validator` running.

using:

```
@project-serum/anchor@0.18.2
@solana/web3.js@1.31.0
```

Edit: this seems to have been a `vite` issue. I resolved it via the following thread:

https://github.com/vitejs/vite/issues/2618

Namely, i added `<script>window.global = window;</script>` to my index.html.
https://giphy.com/gifs/sorry-okay-nevermind-11EVpyEaQQvSVi
that's a whole lot of pasting code for nothing
bah! I checked `Anchor.toml` and my program id hadn't been updated
and when I say "very similar" I just mean not using `anchor.workspace` to generate my `program`
when I run `solana-test-validator` and run a very similar node client, I don't get any errors btw, I can `initialize` and `update`
full error : 
```
1) getting-started
       Is initialized!:
     Error: 167: The given account is not owned by the executing program
      at Function.parse (node_modules/@project-serum/anchor/src/error.ts:41:14)
      at Object.rpc [as initialize] (node_modules/@project-serum/anchor/src/program/namespace/rpc.ts:28:42)
      at processTicksAndRejections (internal/process/task_queues.js:95:5)
```
thanks in advance for any help. trying to learn anchor from first prinicples
```
use anchor_lang::prelude::*;

declare_id!("6HDC66Uu6rWrw2TtYw5vrwyKmzjArd1D68QeNXnhD5ZX");

#[program]
pub mod getting_started {
    use super::*;
    pub fn initialize(ctx: Context<Initialize>, data: u64) -> ProgramResult {
        let my_account = &mut ctx.accounts.my_account;
        my_account.data = data;
        msg!("Initialize!! {}", my_account.data);
        Ok(())
    }

    pub fn update(ctx: Context<Update>, data: u64) -> ProgramResult {
        let my_account = &mut ctx.accounts.my_account;
        my_account.data = data;
        msg!("Updated {}", my_account.data);
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 8 + 8)]
    pub my_account: Account<'info, MyAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct Update<'info> {
    #[account(mut)]
    pub my_account: Account<'info, MyAccount>,
}

#[account]
pub struct MyAccount {
    pub data: u64,
}
```
gm

I'm getting an error in my `anchor test` in my version of `basic_2` from the tutorial. The error is `Error: 167: The given account is not owned by the executing program` and I guess I just have to post all the code here to have any chance of figuring it out so here goes nothing... 

```
import * as anchor from '@project-serum/anchor';
import { Program } from '@project-serum/anchor';
import { GettingStarted } from '../target/types/getting_started';
const { SystemProgram } = anchor.web3;
describe('getting-started', () => {

  // Configure the client to use the local cluster.
  anchor.setProvider(anchor.Provider.env());

  const program = anchor.workspace.GettingStarted as Program<GettingStarted>;
  const myAccount = anchor.web3.Keypair.generate();

  it('Is initialized!', async () => {
    // Add your test here.
    const tx = await program.rpc.initialize(new anchor.BN(1234), {
      accounts: {
        myAccount: myAccount.publicKey,
        user: anchor.getProvider().wallet.publicKey,
        systemProgram: SystemProgram.programId,
      },
      signers: [myAccount],
    });
    console.log("Your transaction signature", tx);
  });
  
});
```
I'll post the program code in the next message
why is the ``metadata`` field not always part of the IDL, after ``anchor build`` ?
but implementing alan's changes now :)
hello that was actually the main issue
What does it do?
Ha, right, missed that 😆
Surprised no one mentioned this, you're using a generated keypair instead of findProgramAdress
```const Header = () => {
    let [ solBalance, setSolBalance ] = useState(0);

    const connection = new Connection(clusterApiUrl('devnet'), 'confirmed');
    const keypair = Keypair.generate();

    const getBalances = async () => {
        const solBalance = await connection.getBalance(keypair.publicKey);
        console.log('Balance: ' + solBalance);
    }

    useEffect(() => {
        getBalances();
    });```

Hi guys, I'm trying to get the connected wallet balance and add it to the components state... For some reason it is not working. Would appreciate if someone could help me out
That's pretty sweet. Can't wait to reach that level once I get past these basics. Thanks again!!
Yeah, the wallet will definitely not give you access to the secret key—it will only allow you to ask it to sign a tx (or look at its public key)
when I write actual front end stuff, I won't need the user's secret keys for these things, right? 
The solana wallet adapter handles all these?
Yeah, now I'm curious about why the encoding works that way (taking a look at the fromSecretKey source)
whoa, i thought they were just the secret key. Thanks alan!
You just skip specifying space at all (anchor knows how much space an spl mint takes), but you need to specify the `mint::` annotations I mentioned above
whats the proper way to init without space= macro for spl mint?
So it's just `bs58.encode(thoseBytes)`—is that what you're asking about?
Ok, had to double check, I think that secret string is just the base58 encoding of the bytes in that json file (I was a little confused, because the 64 bytes in the file are actually split between the secret 32 bytes + the pubkey's 32 bytes at the end)
I don't need it. Just saw it on the code, and was curious how people get that from the uin8 array.
I would have guessed a keypair was enough
Haha, ok—to your question, why do you need a string version of the private key? Trying to scan that link
Yes, that's what's is happening (and I agree on it being unusual 😅😅)
Just to double check I'm understanding, the source of the funds will presumably need to sign the tx (so, gonna presumably need an actual keypair for them, not just their public key). But the destination wallet doesn't need to pay. So, yeah, if the fee payer here is different from the source wallet, you'll need two signatures (a bit unusual)
Hi super beginner question again! 
I'm doing this web3js tutorial, but with my own wallets- https://yihau.github.io/solana-web3-demo/tour/transfer.html

This is just transferring 1 sol from one address to another, while another wallet is paying the fee. So, there are three wallets here in this code. I'm aware of the account model, where accounts can be credited but not debited from, and this is why I think they need the keypairs of the two wallets they're paying. 

My question is- how do I get that keypair in the string format? If I export the private key from solflare wallet, I'm getting a uint8 array, from which I can generate the public key (using fromSecretKey). 

Is there a way I can convert the uint8 array private key to a string private key? I know I can just use the uint8 array, but I'm just wondering if there's anything that makes this conversion possible
For example, that's part of what you're doing when you mark an account as `mut`: telling solana that it can't parallelize the tx with others that care about that account too
Solana handles all of that for you (well, in terms of sequencing operations/agreeing on the eventual state)
What are the best practices using web3 requests in your  react components?
Just a basic question on ownership if I have a global state (just a PDA with static seed) and storing some data on it and some users who access the RPC instruction does change the data on that global state. What will happen when mutiple users trying to change the data on same account. Would there would be error  ? From web2 perspective we have to handle the concurrency.   How does solana/ rust handles it ?
Generally no 😉 Best bet is to search the anchor codebase for examples
and thank you for the help, will likely make it programmatic rather than manually configuring it
is there documentation somewhere for these 2 macros?
But whatever, whether you want to make an instance of your own wrapper type or an actual mint, somebody still has to pay rent
I would say just make an actual mint (although possible I'm misunderstanding what you're trying to do), but then you'll have to decide who has authority to actually mint new coins etc.
You can make a mint programmatically, and nothing about it is tied to your program
That depends on who the mint authority is (which you'll need to specify above)
mint is my own type, its just a wrapper around the address and pubkeys associated with the real spl mint
no I think you are right. if I make a mint programatically, do I have to create the token as well in the program? and can they be accessed outside the scope of the program?
So is `Mint` one of your own types? Or the anchor_spl type?
my idea was to make a proper mint and account on the spl token program, this mint is more like an authentication struct holding pubkeys that approve minting functions within the program. my train of thought was
1, I potentially want the mint to outlive the program, if i ever take the program down.
2, I dont want to limit the token to the program, potentially making it cross chain (?), and I thought having the program init the spl mint may raise issues.

is the classic course of action to have program init spl token mint and is that applicable here?
As Tom said, the system_program won't pay for it (you'll likely need to make the user wallet pay rent, unless you've got some random account lying around for this kind of thing). Also, I would expect you to need to use the `mint::decimals` and `mint::authority` attributes in that init, and get rid of the space (you're initializing a mint account, which is presumably owned by the spl token program, not your program?)
unfortunately its a workaround, for some strange reason anchor-debug feature is not kicking in in the syn crate (when we explicitly enable it any anchor projects feature list in cargo.toml), and our workaround is to to basically always log wherever we see the `#[cfg(feature = "anchor-debug")]`, see https://github.com/microwavedcola1/anchor/commit/e34bd34cd08261b9d54290db2bcc84cbd168acb1
it's not creating or destroying directly from the signer, the program still calls it
pass in a signer and get them to pay
the chat room example has similar code from memory
like it truly is a program owned account, no one should have the ability to fund, destroy, do anything with it but the program itself
how do most people fund program owned accounts?
-.-
the system program isn't going to pay for your account 😁
check the payer = bit
im sure something in my syntax or logic is wrong but i do not know what it is
but in my mind, 1, i am not asking for a signer at all. how can i resolve this issue?
it gives an "unauthorized signer or writable account" error, or the signer is not expected, something along those lines
```rs
#[derive(Accounts)]
pub struct InitMint<'info>{
    #[account(
        init,
        payer = system_program,
        seeds = [
            "initmint".as_ref(),
            system_program.key.as_ref(),
        ],
        space = 8,
        bump,
    )]
    pub mint: Account<'info, Mint>,

    pub system_program: Program<'info, System>,
}```

```js
const mintAccount = anchor.web3.Keypair.generate();

    const tx = await program.rpc.initMint({
      accounts:{
        mint: mintAccount.publicKey,
        systemProgram: SystemProgram.programId,
      },
    });```
hello friends i have once again ran into an issue
But it doesn't work if your type has variable-length components, since the default instance will usually be too short
Ty for all the help btw, I will find some way to repay you
Yeah, the only thing anchor uses Default for is calculating space if you didn't specify it yourself
Fairly new to Rust, so with the line `#[derive(Default)]` it generates an impl of the `Default` trait automatically for me right? Where do I find documentation for the `Default` trait? Couldn't find it here: https://docs.rs/anchor-lang/0.5.0/anchor_lang/derive.Accounts.html . I guess all the `Default` trait does is calculate the size?
omg it all makes sense now
Or you can snag the final 32 bytes of that u8 array and manually base58 it
Ha, you can get the base58 string by doing `solana address`
mb if its like a really really dumb question
not like a string
yeah but it points to an id.json, and its just a [u8] array
That wallet is specified in tests by the ANCHOR_WALLET env var (which ends up being what your Anchor.toml says)
is it in a file somewhere or generated
ah
`program.provider.wallet.publicKey`
how do i get the wallet address or where do i find it during the anchor test process
Mm, I'm not sure, sorry!
So you mean your solana wallet? `solana address`
i have a part where #[account(address = Pubkey::from_str(xyz))]
how do you get the address from an config/id.json in testing?
Ah, also, you probably don't want to derive(Default) if you're going to have to calculate space yourself manually (definitely will considering that Option)
Just noticed my test passed when increasing size of the account... Ty very much
Option<Pubkey> will take 32 + 1 bytes
This is what my account looks like:

```
#[account]
#[derive(Default)]
pub struct ShowroomMetadata {
    pub wallet: Pubkey,
    pub showroom_dependency: Option<Pubkey>,
    pub price: u64,
    pub uuid: String,
}
```

And this is what my account struct looks like:

```
#[derive(Accounts)]
pub struct InitializeShowroom<'info> {
    // 8 byte discriminator + 32 bytes for Pubkey + 32 bytes for Option<Pubkey> + 8 bytes for price + 4 byte u32 len + 6 byte uuid
    #[account(init, payer = payer, space = 8 + 32 + 32 + 8 + 4 + 6)]
    pub showroom: ProgramAccount<'info, ShowroomMetadata>,
    #[account(mut)]
    pub payer: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```

This worked before I added in the `Option<Pubkey>` parameter. 🤔
so this means there is no native on-chain equivalent to the ecrecover function in Solidity? Could multisig perhaps be a good stand-in to replace that kind of functionality? (for instance, to have an authoritative server partial sign a transaction before the user submits it)
Failed to serialize the account I think will often be a space issue
Ah, k
Updated to pass in `null` instead of `undefined` to get to the last error (previously wasn't defining the parameter as Optional in my Solana program RPC correctly)
What are you changing?
How do you keep getting different errors, haha 🤔
That could actually trigger that specific error (`#[instruction(...)]` needs to exactly match the order of your actual args, at least left to right)
Yes I am, but not for this specific parameter. I also made sure to update the space that the account is taking to include the Optional value.

Getting this error now: `     Error: 164: Failed to serialize the account` . This is probably an issue within my Solana program since I'm hitting log statements within my RPC call
Or, are you using any `#[instruction(...)]` stuff?
That's a bit of an odd error to get—have you updated your IDL after making any changes to the program? (Ordinarily that would happen automatically by anchor build, but just checking)
That looks fine
You ought to be able to pass optional arguments as `null`, yeah.
When I pass in `null` / `undefined` for the optional parameter. Is there a different way to pass them in? Looking at the IDL and it looks like this:

```
            "type": {
               "option": "publicKey"
             }
```
How have you declared the rust instruction function?
Turns out the error is actually this: ` Error: 102: The program could not deserialize the given instruction`
Yeah this is for an anchor program, and it's for the instruction function parameters
Is this for an anchor program? Do you mean an optional account? (I think that specific error only shows up for accounts, not instruction function parameters)
<@!248066053161222144> downgrading and rebuilding source on m1 machine to 1.8.5 did the trick 🙂
legend
hhehe thank yu
ah!
Keep getting the error ` Error: Invalid arguments: <parameter name> not provided.` when I pass in `undefined` / `null` for that parameter
How do you pass in an optional parameter in `@solana/web3.js`?
And testnet is mostly 1.8.0 🤷
So I don't really know what's up with that
Although mainnet is running 1.8.5
So you can't directly use it on-chain from your own program, you have to do this weird thing where you submit a separate instruction asking the program to verify a signature
Right, I'm saying that you actually can't CPI to the ed25519 program (not sure why, it's just not allowed)
It looks like they're running 1.7.14
Through Solana beach
So one way to do it is to look at what the validators are running
going to test with stable 1.8.5 lets see
I see some interesting code here (https://github.com/hyperledger-labs/solang/blob/c898fb79a1d6370544172ad9eb88bb0ff715ad6a/tests/solana_tests/signature_verify.rs), but it is for a unit test, which might not be runnable in an on-chain program
this looks like this is for js code? Would you happen to have any code samples for rust that can be executed on-chain?
stupid question <@!248066053161222144> I have been looking where to find running version but I can't seem to find out what version `https://api.devnet.solana.com` is running
You can add that to a tx and submit it, and it will succeed if the signature works, otherwise it will abort the rest of the tx.
It's got a funny api, you have to send a separate instruction to that program (can't CPI to it, oddly). Something like:
```.js
    const ix = anchor.web3.Ed25519Program.createInstructionWithPublicKey({
      message: Buffer.from("Message we've ostensibly signed"),
      publicKey: thePublicKeyToVerifyAgainst,
      signature: theSignature
    })
```
ah yeah that would explain the method not found
It's likely not 1.9
Check the version running on devnet
I have this solana cli version
`solana-cli 1.9.0 (src:devbuild; feat:158695402)`
I have sufficient devnet sol on the account
hey peeps, I can deploy to localnet during test and separately running the test validator but when I try to deploy to devnet I keep getting this error

```bash
Error: RPC response error -32601: Method not found
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.
```
did you have any info around the usage for this program? I'm digging through threads, trying to get signature validation working, but running into issues with using the dalek crate for this, as mentioned by others. I'd like to find out how to use this program to validate signatures
yep that was the issue -- didn't account for the 8 byte discriminator
That means that you probably didn't allocate the right amount of space for the account
not sure if this is anchor bugor not
that's the method that is causing the issue
`anchor.setProvider(anchor.Provider.local())` sets the client provider to localnet, is there a similar way to connect to devnet?
```rust
    pub fn zero_game_storage(ctx: Context<ZeroGameStorage>) -> ProgramResult {
        let mut storage: RefMut<'_, GameStorage> = ctx.accounts.storage.load_init()?;
}
```
Hm, now I"m getting:
```rust
    'Program log: libstd rust_begin_panic',
    "Program log: panicked at 'from_bytes_mut>SizeMismatch', bytemuck-1.7.2/src/lib.rs:115:3",
```
Then it will have its discriminator set
So use `#[account(zero)]` the first time, and use load_init() in that ix function
oh I see
Look at the example I posted above, it uses `load_init()` (which writes the discriminator for you)
oh I guess I'll just use zero everywhere?
is complaining about missing the 8-byte discrim
ahh, & that's an issue I think:
```rust
    #[account(mut)]
    storage: AccountLoader<'info, GameStorage>,
```
At the end of the day you'll always have to go through whichever program owns that account (so not possible to just write data yourself—you'll always have to invoke the owning program)
is it through the id.json file and how would you do it
how can you change provider wallet address for testing on localnet in node?
Anyone know how to use @solana/web3.js to write raw data to an account?
every time someone gets a constraint error, i would love for the response to just be use `anchor-debug`
shout out <@!837011211795038260> - well done ser 👏
that'd be awesome
<@!837011211795038260> has fixed `anchor-debug` which is supposed to be an error checking thing that prints out all the details of the constraint checks which should make something like this easier to debug, hopefully they get a chance to make a pull request to the main anchor soon!
it seems like based on the frequency of this error, and also the incorrect account discriminator error, that it's quite often the people are passing in uninit / uncreated accounts and not realising it
oh sure - yeah I was trying to call "withdraw" fro an SPL token account that wasn't inited
yeh, just rephrasing for my own understanding
inlining worked
yup, figured out
so you're passing in a token account that isn't inited / actually owned by the SPL token program
is there any way to get around this? -- maybe my inlining the const?
oh the `BOARD_SIZE_USIZE`?
Hm, what do you mean when you say const?
Ah... it might not work with a const like that?
you were right - I was checking for a number of consecutive calls to fail, first being deposit, second withdraw. If deposit fails.. by definition there's no token account to withdraw from, and so withdraw fails for a different reason
it's trying to generate IDL & failing for the `GameStorage` struct??
I suspect
but this happens
when running `anchor test`
the program compiles
Oh, hmm I think there (*might*) be a bug in IDL generation:
```
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: ParseIntError { kind: InvalidDigit }', lang/syn/src/idl/mod.rs:143:76
```
Basically, is every token account etc. an actual token account? (Already initialized, etc.?)
Address type won't matter, could be any `Account<'info, Whatever>` (including Account<'info, TokenAccount>)
which account is it likely to be? a state-holding PDA or a token account?
So I would double check the owner of any Account<'info, Whatever> you're passing in (can always do this manually with `await program.provider.connection.getAccountInfo(thatAccount)`)
interesting... let me go check the dumb way first:D
There are only two known ways to get this 0xa7 error: the annoying/dumb way (incorrect declare_id!), and the non-annoying way, where you really are passing an account with the wrong owner
now I guess it's time to update code to use arrays instead of vecs
AccountLoader
ok, got it working -- I just had to update verywhere to use
hm also getting this error - in place of another one during an `expect().to.be.rejectedWith` statement

the code can't be wrongly handling any of the accounts because it works just fine two tests above (where I'm testing the positive, non-error case)
Ah, sorry, Loader is deprecated (use AccountLoader)
Account won't work with zero_copy
AccountLoader
Am I supposed to use `AccountLoader` or Loader (https://docs.rs/anchor-lang/latest/anchor_lang/struct.Loader.html)?
Looks like you're using AccountLoader (that's good), did you maybe forget to save the file or something?
That error message doesn't match what you posted just above
I'm pretty sure I need to manually implement serialization?
pub storage: Account<'info, GameStorage>,
    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `anchor_lang::AccountSerialize` is not implemented for `GameStorage`
Struct + context:
```rust
#[derive(Accounts)]
pub struct ZeroGameStorage<'info> {
    #[account(mut, seeds = [], bump = game_account.bump, has_one = storage)]
    game_account: Account<'info, GameState>,

    #[account(address = ADMIN_PUB_KEY)]
    pub admin: Signer<'info>,

    #[account(zero, rent_exempt = skip)]
    pub storage: AccountLoader<'info, GameStorage>,
}


#[account(zero_copy)]
pub struct GameStorage {
    states: [u8; BOARD_SIZE_USIZE],
    owners: [Pubkey; BOARD_SIZE_USIZE],
}
```
You need to use AccountLoader, not Account
No, zero_copy is for explicitly skipping deserialization entirely 😛
to update borsh version
oh damn, this might require a patch in Anchor
oh I think I'm running into this: https://github.com/near/borsh/issues/36#issuecomment-882934079
Oh, are you using AccountLoader instead of Account?
Can you post that struct?
maybe I need to manuallly implement serialize
oh interesting it is saying " the trait `anchor_lang::AccountSerialize` is not implemented for `GameStorage`" when I use `zero_copy`
Then finally:
```.rs
pub fn initialize(ctx: Context<Initializer>) -> ProgramResult {
  let huge = ctx.accounts.huge_account.load_init()?;
  ...
}
```
And then
```.rs
#[derive(Accounts)]
pub struct Initializer<'info> {
  #[account(zero)]
  // already allocated this thing in a previous instruction
  // because given huge size, not possible in a CPI
  pub huge_account: AccountLoader<'info, MyHugeAccount>
}
```
No (probably going to have to look through the anchor repo for examples), but basically:
```.rs
#[account(zero_copy)]
pub struct MyHugeAccount {
  owners: [Pubkey; 10000]
}
```
do you use `ZeroCopy` like `#[derive(Accounts, ZeroCopy)]`
It's a bit restrictive (no heap-allocated things like vecs, no strings, etc.), but you can go all the way up to 10mb
You should probably also look at `zero_copy`
You'd have to use an actual array
is there a way to just write to a raw buffer
Yeah, that vec won't work (way too big for the heap)
so the size is too big
yeah BOARD_SIZE_USIZE is 10_000
that makes sense now
```rust
    pub fn create_game_storage(ctx: Context<CreateGameStorage>) -> ProgramResult {
        ctx.accounts.storage.states = vec![0; BOARD_SIZE_USIZE];
        ctx.accounts.storage.owners = vec![Pubkey::default(); BOARD_SIZE_USIZE];
        Ok(())
    }
```
Can you post the actual error?
Mm, how are you doing the initialization? Each stack frame is only 4kb and the heap is only 32kb
and i'm getting memory allocation errors
that is about 0.32 mb in size
i'm trying to initialize this struct
is there a max limit for the amount of memory a solana program can use on-chain?
Think it's `rent_exempt = skip`
i think your solana config is set to local?
same, just less amount
`solana airdrop 5 <ADDR>`
alas I'm not sure what the real rust syntax here is ... will see if I can dig around in tests & find out
What was the full command you ran? I'm still getting an rpc error (I wonder if my solana install is too new locally?)
which I can avoid by using `#[account(rent_exempt = <skip>)]    `
this is an anchor check
oh, i see
Works now! Mayne i should read the error lines more carefully. Thanks though <@!134416332509675520>
5 is the Limit
```
Transaction executed in slot 98910460:
  Block Time: 2021-12-06T01:28:56+05:30
  Recent Blockhash: Gf421jdexMJcChN3XAUKy3XNUSYAb96P5ek15JMwRktA
  Signature 0: 2RNVGmekwGYPMiFcQkC5rTsGnRek2EveCK5g3pExPdewggbqvWyPqa2m9H8HnjRXPhU2LonjBn7cpSn7sHaHpffQ
  Account 0: srw- 9B5XszUGdMaxCZ7uSQhPzdks5ZQSmWxrmzCSvtJ6Ns6g (fee payer)
  Account 1: -r-x MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr
  Instruction 0
    Program:   MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr (1)
    Data: "request too large; req: ◎10, cap: ◎5"
  Status: Ok
    Fee: ◎0.000005
    Account 0 balance: ◎1547911.337579944 -> ◎1547911.337574944
    Account 1 balance: ◎0.52149888
  Log Messages:
    Program MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr invoke [1]
    Program log: Memo (len 40): "request too large; req: ◎10, cap: ◎5"
    Program MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr consumed 33081 of 200000 compute units
    Program MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr success
```
Is 10 Sol a huge amount ? I mean 2000 bucks is but cmon XD
Actually, hmm, when I try to do `solana airdrop` with my config set to devnet I get an rpc error 🤔
so it shouldn't need rent exemption, right?
this account is an external one (created by the process described above)
but now I get an error saying "a rent exempt constraint was violated" -- from my understanding of rent exemption, it only applies to program accounts themselves
ok, so I managed to use `zero` to get Anchor to not complain when I pass in the empty account
No, don't think you need a local validator (you need an rpc connection to devnet, so need you solana config get to say devnet stuff)
local validator is not needed in this case right? Should i generate a new keypair?
Yeah, think so (haven't used that either haha, but it's what I would use I guess)
`solana airdrop 10 <ADDR>`
Mm, not sure, I would just use the solana command line
How are you requesting the airdrop?
https://www.spl-token-ui.com/#/sol-airdrop this should work right?
no it says balance unchanged and asks me to confirm
Are you airdropping to the right network etc.?
Is your balance changing after doing the airdrop?
Please help. any ideas where i can look?
oh amazing, tysm 🙂
That says "I'm gonna make this a Foo, but it's currently zeroed out"
Ah, ok, sounds like you want `#[account(zero)]` then
and skip any deserialization check
I want to pass the account into anchor
so it's just an empty account
So initially I create the account using web3.js
Or is it totally zeroed out?
I'm think I'm confused about what you're trying to do—does the data in the account look like the type?
I am trying to Airdrop some SOL on devnet, in order to deploy a program on it. but its not working : 
```
Deploying workspace: https://api.devnet.solana.com
Upgrade authority: /home/powerconstruct/.config/solana/id.json
Deploying program "mysolapp"...
Program path: /home/powerconstruct/home/mysolapp/target/deploy/mysolapp.so...
==================================================================================
Recover the intermediate account's ephemeral keypair file with
`solana-keygen recover` and the following 12-word seed phrase:
==================================================================================
sock shield audit false problem dinner volcano card lunch question illness kitchen
==================================================================================
To resume a deploy, pass the recovered keypair as
the [PROGRAM_ADDRESS_SIGNER] argument to `solana deploy` or
as the [BUFFER_SIGNER] to `solana program deploy` or `solana write-buffer'.
Or to recover the account's lamports, pass it as the
[BUFFER_ACCOUNT_ADDRESS] argument to `solana program close`.
==================================================================================
Error: Account CiPN93qQT9yMe9dyJvdrojuYUK3W1MSun2zHdo3i1Eo5 has insufficient funds for spend (1.353894 SOL) + fee (0.004265 SOL)
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }.
```
I tried using https://www.spl-token-ui.com/#/sol-airdrop as well as CLI commands
I just want to ignore deserialization checks
And yeah, all `init`s happen via CPIs, so 10kb limit 😦
I want to pass it with the type, since I want to serialize data
Yeah, in this case it will be owned by your program
so I will be forced to create this account outside of Anchor
*limit
alas it looks like there's the 10KB limt
I think it does set the owner to the program

But anchor also knows how to `init` token accounts and mints, which will be owned by the spl token program.
Not always—if you `init` one of your own `#[account]` structs, then yes.
or wait, maybe it does -- time to experiment I guess
oh no, it seems like it doesn't 😦
when using the init property, does anchor automatically set the owner to the program?
Ah, well, that won't work if the account already stores data though
Yeah, probably
oh, I also guess the right thing to do is just use `init` inside Anchor & have Anchor create the acc
Can you pass the account as a raw `AccountInfo<'info>`? That will skip all anchor checks
since I created the account using web3.js
well right now, anchor will try to deserialize the account & it will fail since there's no 8-byte discrim
so basically I just want Anchor to write to that account
Is there a way to tell anchor to not do a deserialization check? for example; let's say I'm passing in an external account (that stores some data), and I want anchor to "reset" that account
That would be some other repo, yeah (not sure where, but definitely not in anchor itself)
Anchor doesn't have any react-specific code itself
maybe the react code is somewhere else?
but couldn't find it in the repo
since I figured that would do basically what I'm doing
and yeah, I grepped through anchor for `useCreateAccount` or whatever the hook is called
I see I see -- that makes sense
It needs to sign too because you're creating a new account there (the system program requires that the new account's address sign too)
Is that `storageKp` signing the tx too? (Doesn't look like it from the snippet above)
One trick to see how to do this kind of thing is to just search the anchor codebase for examples
here is the instruction that is being added to the transaction
I guess for context:
```
    const storageKp = anchor.web3.Keypair.generate();
    const txnInstruction = anchor.web3.SystemProgram.createAccount({
        fromPubkey: adminKp.publicKey,
        newAccountPubkey: storageKp.publicKey,
        lamports: rentPerGameLength,
        space: storageBytes,
        programId: program.programId,
    })
```
signature verification fails here
Specifically:
```
    const txn = new anchor.web3.Transaction({ feePayer: adminKp.publicKey })
    const { blockhash } = await provider.connection.getRecentBlockhash();
    txn.recentBlockhash = blockhash
    txn.add(txnInstruction)
    txn.sign(adminKp)
    assert.ok(txn.verifySignatures())
```
even when I  replace the empty array with `[adminKp]`
ok, I managed to get the recent blockhash but now it's complaining about failed signature verification
currently googling to see how I can get that using web3.js but maybe someone already has the answer here off the top of their head
but it is saying "recent blockash required"
Does anyone know how to send a transaction in Solana using web3.js? 

I'm trying:
```
    const txn = new anchor.web3.Transaction()
    txn.add(txnInstruction)
    txn.sign(adminKp)

    await anchor.web3.sendAndConfirmTransaction(provider.connection, txn, [])
```


//////////////////////////////////////////////////////////////////////////////////////////

Or how to use PreciseNumber
Hi, how can I use an U256 from spl_math in a Account struct field?
user error 🤦‍♂️ please ignore this one!
forgot to remove that
Ah!
Are you using an `#[instruction(...)]` annotation under the `#[derive(Accounts)]` part?
```     Error: 102: The program could not deserialize the given instruction
```
Mm, yeah, that seems plausible—does it seem to work?
<@!134416332509675520>
am I doing this correctly ?
```#[account(
        mut,
        close = authority,
        seeds = [pool.to_account_info().key.as_ref(),authority.key.as_ref()],
        bump,
    )]
    pub user_deposit: Account<'info, UserDeposit>,
    #[account(mut)]
    pub authority: Signer<'info>,```
instead of preflightCommitment
Try getting rid of that option and using `skipPreflight: true`
currently its set to finalized. Here I should set it to preflight ?

const provider = new anchor.Provider(solConnection, walletWrapper, {
    preflightCommitment: 'finalized',
  });
test_index is somehow always 0 from the logs in the program - is there any additional specification i have to do for this value to actually be known inside the program?
yet when i invoke with the following ```    let tx = await provider.send(
      (() => {
        const tx = new Transaction();
        tx.add(
          SystemProgram.transfer({
            fromPubkey: payer.publicKey,
            toPubkey: receiver.publicKey,
            lamports: 1000000000,
          })
        );
        tx.add(program.instruction.test({ accounts: {
          testProgram: systemSysVarKey
        }}))
        tx.add(program.instruction.test({ accounts: {
          testProgram: systemSysVarKey
        }}))
        console.dir(tx, { depth: 5 })
        return tx;
      })(),
      [
        // Signers
        payer
      ]
    );```
hi all, had a question around including multiple instructions in a single tx in anchor - i have a program function that simply logs out the current index like this ```    pub fn test(ctx: Context<Test>) -> ProgramResult {
        let index = sysvar::instructions::load_current_index_checked(&ctx.accounts.test_program)?;
        msg!("test index = {:}", 0);
        Ok(())
    }```
ah its private currently...
Haven't tried that
Out of curiosity, what happens if you skip preflight (aka transaction simulation—literally every name in solana is slightly confusing 😆)?
Got a repo? Sadly I suck at guessing
Ok I might be wrong about the blockhash thing. You are using anchor (duh) and it seems the rpc call gets a fresh one every call.
not quite sure ... I just loop around the above over a file which have mint public keys and call the instruction
Is it always the same tx you send, or does it update every iteration?
I am mostly guessing, don't take anything at heart yet haha. I'm thinking this could be a mix of the blockhash caching + the tx being dropped because detected as duplicate.
so I can't do anything other than re-running those failed ones again ?
Specifically I am looking at these bits:
https://github.com/solana-labs/solana-web3.js/blob/master/src/connection.ts#L3619
https://github.com/solana-labs/solana-web3.js/blob/8d18805b00d0a04084bcfaf9a52741201d743df6/src/connection.ts#L3463
I think you might be hitting an issue with the blockhash caching going on in the web3 lib
Calling this instruction over a loop for 1000 times but most of the time I get that blockhash not found error
```const [pda, bump] = await anchor.web3.PublicKey.findProgramAddress(
                [
                    Buffer.from(anchor.utils.bytes.utf8.encode(PREFIX)),
                    mint.toBuffer(),
                ],
                PROGRAM_ID
            );

            
            const txid = await anchorProgram.rpc.addMetadata(data, {
                accounts: {
                    authority: walletWrapper.publicKey,
                    mint: mint,
                    mintData: pda,
                    systemProgram: anchor.web3.SystemProgram.programId,
                }
            });```
is there a way to do this ?
Might need a bit more. Like the snippet containing the tx creation and sending
Transaction simulation failed: Blockhash not found 
    
```Translating error SendTransactionError: failed to send transaction: Transaction simulation failed: Blockhash not found
    at Connection.sendEncodedTransaction (/home/ship/Documents/scripts-test/node_modules/@solana/web3.js/lib/index.cjs.js:6591:13)
    at runMicrotasks (<anonymous>)
    at processTicksAndRejections (internal/process/task_queues.js:93:5)
    at async Connection.sendRawTransaction (/home/ship/Documents/scripts-test/node_modules/@solana/web3.js/lib/index.cjs.js:6550:20)
    at async sendAndConfirmRawTransaction (/home/ship/Documents/scripts-test/node_modules/@solana/web3.js/lib/index.cjs.js:8513:21)
    at async Provider.send (/home/ship/Documents/scripts-test/node_modules/@project-serum/anchor/dist/cjs/provider.js:85:22)
    at async Object.rpc [as addMetadata] (/home/ship/Documents/scripts-test/node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:11:31) {
  logs: []
}```
Way easier to debug if you post the exact stack trace 🙏
The error doesn't necessarily seem to match, but do you refresh your blockhash once in a while?
Getting a lot of blockhash not found error while calling an instruction inside the loop for most of the iteration . Does someone know what could be the issue ?
If it's one of your program's accounts, then you have to drain its lamports (try searching for try_borrow_mut_lamports)
It depends on which program owns the account, not really on whether it lives at a program-derived address.
I remember something like close, not exactly sure
how do I close a pda and get rent back ?
you can use anchor `await program.account.name.fetch(address);`
nice, thanks
how do i fetch a variable from my program's state account using web3js
then you can `await program.rpc.method()`
you can pass the wallet object to Provider

```
    const provider = new anchor.Provider(conn, wallet, {
      preflightCommitment: "recent",
    });

    const idl = await anchor.Program.fetchIdl(programId, provider);
    const program = new anchor.Program(idl, programId, provider);
```
how would I use anchor with solana's wallet adapter - https://github.com/solana-labs/wallet-adapter

it won't give me the private key ofc, is there a way to still call `program.rpc.methodName()`?
I can see the IDL in the `target/idl/pools.json`
Hey guys,  I am getting this with a new repo when I run `anchor test` : ```Error: Error loading workspace IDL for pools
``` Any ideas why this is failing?
Got it. I tried to get the program A accountinfo by passing it through the accounts, not thought I should sign it using Program A's keypair.
Then I'll switch to using PDA, which is pretty much more solana way.
Thank you <@!134416332509675520>  for detailed explanation!
You would then have program B verify that that A passed it the right program-derived address (anchor doesn't currently automate this kind of check, so will have to do it manually), and that it signed.
This is definitely a weird way to do what you want though, which is to enforce that it was program A that called program B. Another path would be to pass a program-derived address derived from A (say, with empty seeds), and then when A calls B, have A sign for that PDA (only A can do so).
In general in solana it's not possible to go from Pubkey to AccountInfo *within* your program; you have to pass *all* accounts you care about in from the client. So you technically could do what you suggest above if you pass the program_id as an account *and* somehow manage to sign for it (you'd have to use your program's keypair!).
I think you'll probably have to do this in a slightly different way in solana, using PDAs (I see you mention not doing that above).
Program A is the signer for the Program B, actually `#[account(signer)] pub signer: AccountInfo<'info>`
That is, only Program A can call the method of Program B. (kind of onlyOwner in solidity)
That won't work, at least not in any easy way (the program A itself can't sign for its own program_id—you would have to have signed for that program_id from the *client*, which I guess isn't strictly speaking impossible but would be weird)
When you say A needs to be the signer, you mean literally A as its program_id?
but @ cqfd is very generous in the level of engagement he offers and sometimes others too, it's not a given though!
ideally this channel is more for debugging errors and stuff
it's kind of hard to answer program design questions
Any ideas to this?
i'm just being lazy
also initing token accounts requires mints to be passed in as accounts too, so it's probably fine to leave it this way
or maybe it would be too easy for people to footgun by using a mint pubkey that is invalid / no a mint
however, i don't know what the security implications would be?
it would be preferable if it took a public key instead of an account
yeh, i was thinking that it required the account but was hoping that maybe there was a way around
Mm, for some reason I wrote them to require an actual account, but I guess that was dumb/could be changed 🤔
random question: do the ATA constraints require you to pass in the actual mint account and deserialize it or can you just use a public key?
*`anchor.toml`
give me a sec I need to check...
and you all have the same repo, same public key in `declare id` and in the `anchor.toml` file
and you run `anchor test` and it fails for some of you but not others?
yep
are you guys working off a common repo?
Doing an *actual* deploy (like, you start your `solana-test-validator` in the background and do an `anchor deploy`) will require a keypair, yes. But you can also just run `anchor test` and it will do some magic to run your tests against a validator without an actual deploy
what issue?
yeah we are like day one with anchor and having this issue
(It's annoying that they can get out of sync—anchor may automate this in the future)
Yes, the declare_id needs to match the actual program id at runtime
but if you create new acconts on a new deployment with a different programid it will fail
It just declares that that's your expected program id + embeds a static ID variable into your program (this is useful in various situations)
but it's mostly for checking that program accounts have the correct program owner
it is a security checking
I was under the impression that the `declare_id` did some sort of security checking?
it's a different case if you wanted to start doing devnet stuff but for local net, this stuff just works
yes, `anchor test` is local net by default
even if you deploy them to your localnet setup?
and there's no keypairs in there
anyone can pull them and run the programs in them with `anchor test`
it's the same with all `anchor/test` program directories
im still finding my training wheels here
there's nothing special about it
love to have a look
whats your repo?
i think anchor loads the program at genesis, so it doesn't even matter what the private key is
all i know is that other people regularly pull my repo, with the public key in declare id and they have no issue
So then each time a dev wants to build/deploy/test they have to update with there own progrmids
without needing the private key / keypair
you can just have the same public key in `declare id` on everyone's computer and it just works
what am i missing with this for team developemern?
i'll be honest, i don't think we even share keypairs amongst my team
mind you I am just fucking around with this now, but `anchor key list` seam to keep generating new programids even with the same keys
I am just wanting to setup a project that all the developers can just run with and not have to change the programids all the tiem
cause it's just local net, my team works that way
then there's no issue with just having a common keypair for all your team to use
Now that I wouldnt do
is the program id keypair you're working with the same as what's deployed on mainnet
nah, i'm just joking, it's ok
Is this  not a newbies corner?
lol
i feel like if you're asking that question, should you be doing smart contract development!
whats the security risk if I added the keypairs into the repo? Im not 100% how these programid keypairs work?
I think you would have to find some way to distribute a keypair to everyone on the team for local deployment (deploying requires an actual keypair, versus just doing `anchor test`, which doesn't require actually deploying—if that's good enough, you can just hardcode a suitable `declare_id!` + Anchor.toml value)
hey, how can I setup anchor so my programid are built the same for all the team memeber for a localnet deployment?
Yeah It did. Before when I was trying it was failing. Thanks a lot!
It will already show up as initialized to be empty.
Nvm. Passed the test
Thanks. And during Initialization, For example when A tweet is created it does not have comments. So how do I initialize the vector?
Not `#[account]`
Oh, sorry, misread your snippet. Do this instead:
```.rs
#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub struct Comment {
  ...
}
```
``` IdlError: Type not found:  ``` Gives this error
What goes wrong with this approach?
```
#[account]
pub struct Tweet<'info> {
    pub author: Pubkey,
    pub timestamp: i64,
    pub topic: String,
    pub content: String,
    pub likes: u64,
    pub comments: Vec<Account<Comment, 'info>>,
    pub image_url: String,
}

#[account]
pub struct Comment {
    pub commenter: String,
    pub comment: String,
}
```
I am having these structs. I tried using a hashmap instead of the ocmment struct but that also gave an error. Is there a workaround?
Any ideas for this?
Basically you'll have to do it manually—anchor doesn't have a slick way to express conditional inits yet.
Nor in Solana
No
Hey guys. Is there a way to serialize hashmaps in anchor?
How can we deploy a program to mainnet ? Just connect with mainnet on local and anchor deploy does this ? Or anything more needs to be taken care of ?
Well, I can see a workaround with init\_if\_needed, which may work in my case, but it's would still be a bad design decision
im wondering this too
How can i make PDAs without using the Account Contexts? like in the regular code inside the program handlers
Is there a way to create new PDA only under specific condition with anchor? 
I could make multiple functions for different situations, but it doesn't sound great.
anyway, it's not a big deal, just a quirk that had me scratching my head on an anchor error for a while
yeah it seems to just take the first argument after the Context argument, instead of matching the variable names
i think it occurs because `#[instruction(account_bump: u8)]` is just a raw decoding, not actually using the borsh struct fields
it is indeed a trap
the reason this is is because how the code is written?
Hi, <@!134416332509675520> 
I am working to build the `deposit` function to deposit the user's NFT to the contract but no idea how to build this Context
```
pub struct Deposit<'info> {
  pub token_mint: Box<Account<'info, Mint>>,

  pub token_metadata: UncheckedAccount<'info>,

  pub token_from_authority: Signer<'info>,

  #[account(mut)]
  pub token_from: Box<Account<'info, TokenAccount>>,

  #[account(
    init,
    payer = token_from_authority,
    token::mint = token_mint,
    token::authority = token_vault,
    seeds = [ token_mint.key().as_ref() ],
    bump = _nonce_vault,
    )]
  pub token_vault: Box<Account<'info, TokenAccount>>,

  pub system_program: Program<'info, System>,
  pub token_program: Program<'info, Token>,
  pub rent: Sysvar<'info, Rent>,
}
```
so, im really confused on something. It seems that the order of your arguments in your program handlers matters in how this line is processed
`#[instruction(account_bump: u8)]`
So if I have a handler like this:
`pub fn doing_stuff(ctx: Context<DoingStuff>, cool_object:MyObject, account_bump:u8) -> ProgramResult {`
it doesnt work and i get a seed constraints error. But if I do this:
`pub fn doing_stuff(ctx: Context<DoingStuff>, account_bump:u8, cool_object:MyObject) -> ProgramResult {`
then suddenly it works.

Any reason why this is and what i can do to have the bump seeds at the end of the arguments instead of the beginning?
I have two programs A and B.
Program A needs to call B::method1 and in the B::method1's context accounts, A should be `signer`. (not PDA and method1 checks for authority that Program A's account info should be present as the `signer`)
In this case, how to define the signer in the cpi_accounts  of B::method1 ?  
I can have the Pubkey of A as `ctx.program_id` but can't get the account info of A.
Thanks in advance.
I think I am confused on the link between the actual token and where that metadata lives, in a different account? How does the token know about this account?
When I mint a token, how do I decorate that token with metadata, like how metaplex does it? Do I add the accounts to the same struct as the mint pubkey:
`

#[derive(Accounts)]
pub struct Mint<'info> {
    #[account(mut)]
    pub mint: Account<'info, token::Mint>,
    pub mint_authority: AccountInfo<'info>,

    // wallet token account where the minted tokens will be sent
    #[account(init_if_needed, payer = wallet, associated_token::mint = mint, associated_token::authority = wallet)]
    pub destination: Account<'info, token::TokenAccount>,

    #[account(mut, has_one = mint, has_one = mint_authority)]
    pub config: Account<'info, Config>,

    #[account(mut)]
    pub wallet: Signer<'info>,

    pub system_program: Program<'info, System>,
    pub token_program: Program<'info, token::Token>,
    pub associated_token_program: Program<'info, associated_token::AssociatedToken>,
    pub rent: Sysvar<'info, Rent>,
}
`
like "config" in this example? or am I misunderstanding
The exact same thing happened to me yesterday.  😆
Oh my...I think that's it. 🤦‍♂️
Try to update the cargo.toml file from your program’s folder, you may be updating the toml in your project root
hmmmm 🤔
Seems fine to me.
Here's my `/etc/hosts` - anything look weird to you?
think maybe it's an issue with not being able to resolve localhost to 127.0.0.1?
I'm on a mac - no weird firewall settings I can think of which would prevent me from accessing that port in my local
yup!
when you run the local ledger, do you see `JSON RPC URL: http://127.0.0.1:8899` in the output?
can't remember whether I had set it to `localhost` or `devnet` last...but in either case: I just ran ^ and retried but got the same error
mmm, I'm not sure. I assume you've already set solana to use localhost via `solana config set --url localhost`?
yup I'm running `solana-test-validator` in a separate terminal. Is there more I need to do? 🤔
I could be wrong here, but you might need to have your local ledger running via `solana-test-validator`.
Heyo! Just trying to go through the anchor basic tutorial right now and hitting an error:

```
Translating error Error: failed to get recent blockhash: FetchError: request to http://localhost:8899/ failed, reason: connect ECONNREFUSED ::1:8899
at Connection.getRecentBlockhash
```

^ happens when I run `ANCHOR_WALLET=... node client.js`

Any help is appreciated! 🙏
How do you add crates to cargo? I've added the package I want under `[dependencies]` followed by `cargo build`, but I run into this error: ```
Failed to obtain package metadata: Error during execution of `cargo metadata`: error: failed to parse manifest at `/Users/user/projects/solana/sol-vod/Cargo.toml`

Caused by:
  this virtual manifest specifies a [dependencies] section, which is not allowed
```. I feel like I'm missing some simple step.
Hi!, in case that a `solana airdrop` in localhost is not working, try deleting the test-ledger directory, and run`solana-test-validator` again.
lmk if u end up finding anything tho <@!134416332509675520>
if i were to track marketplaces, it looks like https://github.com/milktoastlab/SolanaNFTBot has a good solution of parsing token transfers?
only have been interacting with them, not actually writing and compiling them
im not sure, havent delve into the smart contracts part of anchor too far
Presumably not that bad?
Now I'm curious how hard it is to decompile the magic eden source from their uploaded .so file
yup looking into it
There's also `anchor idl --help`
ty! will look into it... i was also confused because i had to my example idls from json on my own, but for candymachine, i could use the fetch function...
ohhh
`anchor idl init` I think
is that an anchor command?
Mm, not sure, I haven't looked at magiceden much—if they don't have anything open sourced then it'll probably be tricky? Not sure though
how do you explicitly upload the IDL?
ahh, im currently looking at the magic eden program. Does this mean that I wont be able to easily decode instructions?
Not necessarily, you have to explicitly upload the IDL (so possible it's an anchor program but they just didn't upload the IDL)
assuming it to be true, but i want to clarify
if `anchor.Program.fetchIdl` returns null, does that mean that that program wasnt not made with anchor?
When in doubt about which token account to send the tokens to, yeah, you'd use an associated token address
No—that's why you actually have to `transfer` to a *token* account, not a wallet directly
If I spl_token::transfer a token to a wallet, does it automatically find the ATA for that token type owned by the wallet? Or does the receiver field need to be the ATA
hi everyone,
are there any way in anchor to get the total fee of SOL gonna pay for a transaction including account rent fee + transaction fee.
Like if u hv a pending transaction, Phatom would able to preview total fee required and break down the instructions involved. 
Is it possible to get that figure with anchor?


//////////////////////////////////////////////////////////////////////////////////////////

I believe its sha256("account:accountName")[..8] (first 8 bytes of the sha hash)
`pub struct Fanout {
    alice_share: u16,
    bob_share: u16,
    bump: u8,
}`

For this struct, would the size of the account be 8+2+2+1=13 bytes to calculate rent exemption/size at initialization?
But instead of "global", it's "account:"
https://discord.com/channels/889577356681945098/889577356681945101/896294171667730492
how does anchor generate the first 8 bytes to store in a data account? if i want to generate them myself manually
Trying that as well
Ah, actually, one thing you could try doing real quick is to just move the token transfer *above* the sol transfer part
Ok Taking a look at it
So it's fixable (if my guess is right), but you'll have to do some discord-diving in that thread (look above a bit) to see how to sneak around it
My guess is that you're running into a quite annoying solana thing: https://discord.com/channels/889577356681945098/889584618372734977/915190505002921994 😬
Another update I i just keep the SPL Token transfer and comment everything else it works
But If I include it its failing
AS per the transaction
https://explorer.solana.com/tx/4cvwh2jpTXEfwv6LAG7XBZ9BAcy3RA2SmyhMYfrUqumCJbj7NAXrExuozKqosH7BnM2MRroqVBe27iV9nWB2rjZk?cluster=devnet
because if I comment out the SPL Token Transfer in the end of ix function  it consumes only 28k units
It seems like I am running out of compute units very strange

<@!134416332509675520> 
This is my IX function

```


```
It fails write at the end when I doing the Token Transfer i.e If I comment that out everything works but If I include it I get the following error
wow ok!! A lot I learned from this thread!! Thanks <@!134416332509675520>
That's one use-case, yeah
ah so the fact that we use PDA, is a bit like an identifier to some underlying account owned by some other program, and then if we want to do something about that account, we just sign with seed with the PDA so the owner program will perform the operation accordingly
Whether or not a program asks you/something to sign before it mutates or spends one of its owned account's money is purely a politeness thing (/ program correctness/not being dumb)
Account ownership == the right to mutate the account's data or spend its money
(In fact, if you own an account, *only you* can move its lamports—asking the system program to do it would fail!)
Nope—if you own an account you can also just yoink its lamports
I think Im getting there ~~ so this means the dex program and update the data inside that account, but cannot transfer lamports in it as it cannot sign am I right?
But that doesn't mean the dex needs to sign for that address—if your program owns an account, it can do whatever it wants with it (no need to sign anything, at least not necessarily)
Ok, the dex is storing stuff in the account, so the account itself needs to be owned by the dex (otherwise the dex can't store stuff there)
yes I think its storing some data
Mm, isn't the dex like storing stuff in this account? What is this account for?
I guess reason why Im not understanding the whole thing well is that, if the program wont need to sign for an account, then why not just let it be owned by a system account?
Why does it need to sign for it? I'm not super familiar with the dex
as in, the program wont be able to sign for it right?
Why wouldn't the program be able to access it?
understood, but the question would then be does the code here https://github.com/armaniferrante/serum-quickstart/blob/master/tests/utils/index.js#L293 effectively just create an account, paid by the wallet, and the account will reside under the program, but program cannot access it cuz its no PDA? or maybe Im missing some context?
Just like how you make a token account that lives at one of your program's PDAs
So, if you want to make it a PDA, then you'd have to do this stuff from within your own program, via a cross-program invocation to the serum dex (plus the system program I guess, to allocate the account)
That account there must live at a keypair address
Yeah, that client-side call won't work for a PDA (you can't sign for the address client-side)
reason Im asking is cuz Im going through the serum dex test case (more like a demo I suppose) https://github.com/armaniferrante/serum-quickstart/blob/master/tests/utils/index.js#L293 I dont see any special handling when the code is creating account under the dexProgram. So how can the dexProgram later on sign for these accounts?
e.g.
```
    SystemProgram.createAccount({
      fromPubkey: wallet.publicKey,
      newAccountPubkey: <...>,
      lamports: await connection.getMinimumBalanceForRentExemption(165),
      space: 165,
      programId: TOKEN_PROGRAM_ID,
    }),
```
if I want to make this a PDA account, I guess I try to derive the pubicKey using seed and bump and put it in `newAccountPubkey`
ugh ok lol.... ok I will ignore the 3rd type for now. So another question,  for `createAccount` how will be seed, and bump be passed into the API call?
Extra weirdly, the createAccountWithSeed addresses *can't sign at all*, lol.
createAccountWithSeed is a weird other API (it's a *third* type of solana address: keypair addresses, program-derived addresses, and these weird with-seed addresses)
Confusingly, no—the createAccountWithSeed instruction actually isn't for PDAs at all (for PDAs you just continue to use the createAccount instruction, just like with keypair addresses, but with the caveat that only the deriving program can use it—won't work from the client because the client can't sign for that PDA, only the deriving program can)
Hi alan, one follow-up question on this, Im looking at some of the solana web3 apis 
- https://solana-labs.github.io/solana-web3.js/modules.html#CreateAccountParams
- https://solana-labs.github.io/solana-web3.js/modules.html#CreateAccountWithSeedParams
so I guess for the param with seed, does it mean the owning program will be able to sign right? But how about the param without seed tho?
Check out the anchor tests/ directory!
Is there any more complex example of anchor than the tutorials on github?
Your program can sign for one of its derived addresses with `invoke_signed` if it knows the right seeds+bump
Yep, but only the deriving program can sign for a PDA (that's part of what they're for—they're funny addresses that are *not* actual public keys, designed so that their deriving program can "sign" for them)
Noob question: Is it possible to sign using a PDA in Solana? 
Context: I want a PDA to own a token account which can then transfer to other accounts.
That was it! Thanks!
ahh! I don't think I was updating my IDL! Let me try that.
Are you somehow not updating your IDL when you make those changes? The `#[account(mut)]` attribute ought to update the IDL to make sure the JS asks for mutable/exclusive access to that account
What does it mean to pass an account as mutable from the frontend's perspective (e.g, making an RPC call)? For example, this is how is passed (second account on the list): 

```rust
    try {
        const tx = new Transaction();
        tx.add(
            program.transaction.acceptOffer(
                {
                    accounts: {
                        offer: new PublicKey(openOffer.offer),
                        whoMadeTheOffer: new PublicKey(openOffer.whoMadeTheOffer),
                        whoIsTakingTheOffer: wallet.publicKey,
                        escrowedTokensOfOfferMaker: new PublicKey(openOffer.escrowedTokensOfOfferMaker),
                        accountHoldingWhatMakerWillGet: new PublicKey(openOffer.whereToSendWhatsWanted), // account where the wanted pigs will be sent 
                        accountHoldingWhatReceiverWillGive: new PublicKey(tokenAssociatedAccount), // where to put the cows I'm receiving
                        accountHoldingWhatReceiverWillGet: new PublicKey(openOffer.accountHoldingWhatReceiverWillGet), // where i'm I getting my cows
                        kindOfTokenWantedInReturn: new PublicKey(openOffer.kindOfTokenWantedInReturn),
                        tokenProgram: spl.TOKEN_PROGRAM_ID,
                    }
                }
            )
        );
        const signature = await sendTransaction(tx, program.provider.connection);
        await program.provider.connection.confirmTransaction(signature, 'processed');

```
and the second error means you're passing in an account as readonly that needs to be mutable (or an incorrect signer)
a mut constraint being violated means you're not passing in an account as mutable
Question.  I have the following field that triggers a `mut` violation: `Program log: Custom program error: 0x8c`

```rust
    #[account(mut)]
    pub who_made_the_offer: AccountInfo<'info>,
```

When I remove the `#[account(mut)]` attribute, I get:

```rust
CRC1NoRZbBFeZsAxd6oVnp8UBAukG28dTrH7s3nXmGRG's writable privilege escalated
    Program 6iHfHR4e2KusjUQMoqEgjNqaxw4Cgg5R3xgKrCorxEHN consumed 200000 of 200000 compute units
    Program 6iHfHR4e2KusjUQMoqEgjNqaxw4Cgg5R3xgKrCorxEHN failed: Cross-program invocation with unauthorized signer or writable account
```

Where `CRC1NoRZbBFeZsAxd6oVnp8UBAukG28dTrH7s3nXmGRG` is 

```rust
pub who_made_the_offer: AccountInfo<'info>,
```

Any hints on what I should be looking for?
I don't think rust will let you impl AnchorSerialize for it directly, because of the trait "orphan rule": https://doc.rust-lang.org/book/ch10-02-traits.html#implementing-a-trait-on-a-type
solana 🤷
yes, my bad
Would it be possible to use PreciseNumber directly instead of U256?
And then added simple integrational tests to check that everything else is working
I rewrote my logic to not use `Clock` sysvar or anything else Anchor related, tested those functions in pure Rust code
more computation = more fees similar to ethereum
still tho, why limit to 1million or 200k just leave it pay as you go
but yeah
you mean 1 million x)
<https://jstarry.notion.site/Transaction-Fees-f09387e6a8d84287aa16a34ecb58e239#6c4bae9a910641028cc4f3a747be7a6d>
i dunno, i'm looking for it now
DISCORD SEARCH or google
where can I find that ?
WOW!
they're introducing a 100k limit soon, check out jstarry's blog post about it
would love to see someone doing this
<@!248066053161222144> what's the best way to increase the 200k unit limit ? in a hacky way
and the more people who ask for the time feature, the faster they will likely implement it
we're limited by what solana itself can do
we're all built on top of the solana test validator, the solana sdk
it's a solana thing though
I am using anchor for my test framework though, every module I import comes from Anchor aswell
they might implement something if people keep asking about it there
try checking in the solana tech discord
did you find any solution ? Would like to mock time aswell
This might work, let me try
(Might be better ways to implement those functions, haven't checked)
Mm, can you try doing something annoying like this?
```.rs
#[derive(Clone)]
pub struct U256(spl_math::uint::U256);

impl AnchorSerialize for U256 {
    fn serialize<W: std::io::Write>(&self, writer: &mut W) -> std::io::Result<()> {
        let mut buf = [0u8; 32];
        self.0.to_little_endian(&mut buf[..]);
        writer.write_all(&buf)
    }
}

impl AnchorDeserialize for U256 {
    fn deserialize(buf: &mut &[u8]) -> Result<Self, std::io::Error> {
        Ok(Self(spl_math::uint::U256::from_little_endian(buf)))
    }
}

impl Deref for U256 {
    type Target = spl_math::uint::U256;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
```
use spl_math::precise_number::*;
use anchor_lang::prelude::*;
    #[derive(Accounts)]
    pub struct Adjust {
        pub rate: PreciseNumber,
       
    }
thanks!
ok
Mm, not sure, I haven't looked at serum much yet.
Did you do any sol transfers earlier in the function?
<@!134416332509675520> are there any examples you've come across of using anchor to call serum-dex (`placeOrder`, `cancelOrder` etc.)?
Can you show the rest of your instruction function? I wonder if you're running into some bizarre solana weirdness
If the phantom wallet is how you set up your `program.provider`, then you don't have to do anything, it will sign every transaction automatically. The reason why you can't get access to a `wallet.payer` property is because in phantom will never ever reveal your secret key to JS.
What does it mean
/// Program's instruction lamport balance does not equal the balance after the instruction
FPr the above pice of code, both the offer_tkaers_nft_token and offer_makers_nft_Account have been init
```        anchor_spl::token::transfer(
            CpiContext::new(
                ctx.accounts.token_program.to_account_info(),
                anchor_spl::token::Transfer {
                    from: ctx.accounts.offer_takers_nft_token.to_account_info(),
                    to: ctx.accounts.offer_makers_nft_account.to_account_info(),
                    // Cute trick: the escrowed_maker_tokens is its own
                    // authority/owner (and a PDA, so our program can sign for
                    // it just below)
                    authority: ctx.accounts.offer_taker.to_account_info(),
                },
            ),
            1,
        )?;
```
I get the above error while doing a CPI to do a NFT transfer
```failed: sum of account balances before and after instruction do not match
```
Question. What's the correct way to make the current signed user (phantom wallet) sign a transaction. For some reason, the `payer` object in the provider wallet is undefined (which seems to be the only object that provides a Keypair for the current user):

```go
program.provider.wallet.payer
undefined
```

I'm currently getting:

```rust
6tCkKrMgUBvxiQi5nFuxujG758142fWb11hTeUv4eeqy's writable privilege escalated
    Program 6iHfHR4e2KusjUQMoqEgjNqaxw4Cgg5R3xgKrCorxEHN consumed 200000 of 200000 compute units
    Program 6iHfHR4e2KusjUQMoqEgjNqaxw4Cgg5R3xgKrCorxEHN failed: Cross-program invocation with unauthorized signer or writable account
```

The error above doesn't happen on my test-cases, only while testing from the frontend I created for the app.
yeah, there's gunna be a lot less support for it
okay thanks that make sense. I was thinking if I was just poking around I would prefer to use python but that seems to have fewer examples
but js and ts have become the languags for web dev pretty much
i think there's a python version too
pretty much that, the web3 js library is pretty much the most built up so far
random question--why does it seem standard to interact with Solana using TS/JS instead of another language? I am not familiar enough to understand the tradeoffs here, is it just easier to integrate into websites?
should just be `use anchor_lang::prelude::*;`
this is because of this `use anchor_lang::{prelude::*, solana_program::account_info::Account};`
what errors are you getting?
i'll play around with it, thanks for the tip
you can handle those parts if you want
there are `anchor test` flags like `--skip-deploy` and `--skip-local-validator`
yea you don't need it
interesting i think i'm not supposed to have a validator running already then?
`anchor test` should start a local test validator and deploy (i.e. do all the setup for you)
ya that tut is pretty good
this tutorial i'm following has me run `anchor test` before deploying but the tests fail unless it's deployed
ill check it out, but yeah i mean real toys 😉
nvm
oh you meant real apps
I found this tutorial really good, working through it now https://lorisleiva.com/create-a-solana-dapp-from-scratch/
Hey guys, other than jet protocol what are some other good codebase examples of anchor for us keen newbies in the house?
Hi Anchor people.  I'm looking at a tutorial and it says `#[account(init, payer = author, space = Tweet::LEN)]` will make `author` pay for the rent-exempt money for the Tweet account.  Does this mean anchor makes rent rent-exempt by default, or is there some syntax i'm missing that marks it as rent-exempt?
rosetta is the number 1 emulator
i think i had to build from source for anchor on m1 too which was super weird
theres so many rando issues you will get atm
i would really not recommend using non rosetta for like another 6 months lol
i have the lifetime on the struct ;s
just implementing a simple blog program
```
use anchor_lang::{prelude::*, solana_program::account_info::Account};

use std::str::from_utf8;



declare_id!("GCEkHsFut3ceGvAsixoB3DtF32YxhoMXhkRKJf73Ueb1");

#[program]
pub mod solana_blog {
    use super::*;
    pub fn initialize(ctx: Context<Initialize>) -> ProgramResult {

        let blog_acc = &mut ctx.accounts.blog_account;
        blog_acc.authority = *ctx.accounts.authority.key;
        Ok(())
    }

        pub fn make_post(
            ctx: Context<MakePost>,
            new_post: Vec<u8>

        )-> ProgramResult{
            // post detail

            let post = from_utf8(&new_post).map_err(|err| {
                msg!("Invalid UTF-8, from byte {}", err.valid_up_to());
                ProgramError::InvalidInstructionData
            })?;
            msg!(post);

            let blog_acc = &mut ctx.accounts.blog_account;
            blog_acc.latest_post = new_post;

            Ok(())
        }
            
        
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(
        init, 
        payer = authority,
        space = 8 // account discriminator
        + 32      // pubkey
        + 566     // make the posts max 566 bytes long
    )]
    pub blog_account: Account<'info, BlogAccount>,
    // #[account(mut)]
    pub authority: Signer<'info>,
    pub system_program: Program<'info, System>


}

#[derive(Accounts)]
pub struct MakePost<'info> {
    #[account(
        mut,
        has_one = authority
    )]
    pub blog_account: Account<'info, BlogAccount>,
    pub authority: Signer<'info>,
}

#[account]
pub struct BlogAccount {
    pub latest_post: Vec<u8>,
    pub authority: Pubkey
}
```
Not sure I like the fact I cant use cargo test...
hmm
try `anchor test` not `cargo test`
yep, just tested again using `anchor init hello_anchor && cd hello_anchor && cargo test` and same result.
all I did here was `anchor init anchor_vanilla && cd anchor_vanillia && cargo test` and it fails no matter the name of the parent
Seeing the whole thing would make it clearer
I'm terrible with lifetimes but probably you are missing the lifetime on the struct the account is part of
`anchor init` again but use a name different from that parent folder 😬
Hey guys, when running `cargo test` on a vanilla project I am getting this error: ```
running 1 test
test test_id ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests anchor_vanilla
error[E0659]: `anchor_vanilla` is ambiguous (name vs any other name during import resolution)
  --> /home/utx0/Code/poc/anchor_vanilla/programs/anchor_vanilla/src/lib.rs:6:9
   |
6  | pub mod anchor_vanilla {
   |         ^^^^^^^^^^^^^^ ambiguous name
   |
   = note: `anchor_vanilla` could refer to a crate passed with `--extern`
   = help: use `::anchor_vanilla` to refer to this crate unambiguously
note: `anchor_vanilla` could also refer to the module defined here
  --> /home/utx0/Code/poc/anchor_vanilla/programs/anchor_vanilla/src/lib.rs:6:1
   |
6  | / pub mod anchor_vanilla {
7  | |     use super::*;
8  | |     pub fn initialize(ctx: Context<Initialize>) -> ProgramResult {
9  | |         Ok(())
10 | |     }
11 | | }
   | |_^
   = help: use `crate::anchor_vanilla` to refer to this module unambiguously

error: aborting due to previous error

For more information about this error, try `rustc --explain E0659`.
``` But if i change the naming anchor then fails to generate the IDL files.
dafuq....
even though, obviously, Account takes in these 2 parameters
for:
```
Account<'lifetime, arg>
```
getting:
```
this trait takes 0 lifetime arguments but 1 lifetime argument was supplied
expected 0 lifetime arguments
```
thanks
legend
default is 5000
in Anchor.toml
```
[test]
startup_wait = 30000
```
hey guys, I got an issue when i run `anchor test` its failing as the due to the validator still `Initializing...` is there anyway to increase the timeout for this?
Great thanks for the added context. I don't have a mac but am trying to help a friend get setup on one. 😅
I think most of the M1 issues on github are not M1 problems or not anchor problems
Beyond needing to build solana-test-validator from source i never had any issues with M1 and anchor
I can't imagine there being issues caused by Anchor specifically.
<@!867369388608061470> are there addittional problems with the M1 and Anchor after setting up via your tutorial?
tysm <@!134416332509675520> i owe you a coffee

damn you really know your stuff
But yeah, that's in hex, not base58 like solana expects
And use that instead
Do `console.log(provider.wallet.publiKey.toString())`
```console.log(provider.wallet.publicKey);```
```PublicKey {
  _bn: <BN: 5a5750b02434f935a9c7d5d0cfb657f86cd2a901d6c3472276ace0c6xxxxxxxx>
}```
Maybe you're using hex?
Where are you getting a len 64 string? In base58 pubkeys are ~44-ish digits
its for a cpi transfer, because we have to send the receiver as an account from the frontend, i want to make sure the receiver is one I own, or else the client can plug in two random accounts and still run my functions, which shouldnt happen
but it gives an WrongSize value error
I am trying to check
``` address = Pubkey::from_str("len 64 from js side").unwrap()```
here
What have you tried so far? Do you have access to an `Account<'info, TokenAccount>` or what?
whats the syntax to verify an ATA owner is a specific address?
cool, thanks!
E.g. `new anchor.BN("1000000000000000000000000000000000000000000000")`
It gives you a way to represent arbitrarily big integers
so in short it's a converter/helper utility?
E.g. `Math.pow(2, 53) === Math.pow(2, 53) + 1`
The issue is that numbers in JS are doubles under the hood, so they annoyingly can only represent integers up to 2^53 (not quite big enough for a u64 type in rust).
Big Number
Hi, https://project-serum.github.io/anchor/ts/classes/bn.html what acronym is BN?
I think it is an illustrative example and not meant to be a production escrow program
Bookmarked 👍
Fwiw I wrote up an escrow repo here if you want to see my take: https://github.com/cqfd/quidproquo (not having read the other ones super carefully)
wow this tutorial sucks then 😂
Or, well, I guess you sort of get to pick them—but you generally don't
Ah, haven't read that tutorial—if they're using a single seed though then they'll only have *one* account (bumps are deterministic! you don't get to pick them)
I'm doing this escrow tutorial: https://hackmd.io/@ironaddicteddog/solana-anchor-escrow
We create this `vault_account` to temporarily hold the initiator's funds. But the way it's written right now, I think it would only support the creation of a few vault addresses at a time because there are a finite number of PDAs we can generate with 0 < bump < 255 and a constant seed
Yep!
What is this PDA used for? Is it the ADDRESS of the new token wallet we create?
But find_program_address starts at 255 and just tries sequentially downwards until it finds one that works.
Every bump has about a 50/50 chance of "working".
Sort of—there's the bump that you would get by calling find_program_address (always deterministic), but it's true that lots of other bumps could push the address off the curve (they would lead to different addresses though!)
Under the hood it constructs some cross-program invocations for you.
That says we want to `init` a token account with mint `mint_a` and authority (the "owner" of the tokens) equal to `initiator`. The token account will live at one of our program's derived addresses, with those seeds + bump. The `initiator` will also pay for the token account's rent.
I think a given seed can have multiple valid bumps
So if you want different addresses, you have to pick different seeds (you don't get a choice for the bump—it's a function of the seeds)
alan! my friend
Program-derived addresses are deterministic: given the same seeds you'll always get the same bump plus same resulting address.
<@!501570363566587905>  can u please help
I have 4 questions about the `#[account(...)` macro i posted above. Would really appreciate help
i want to verify a certain TokenAccount owner is a specific hardcoded address
what should the string input to pubkey::from_str be? is the way i pulled it wrong?
Soon. 😉
Would love this as well
I think documentation would be most helpful, so hundreds of developers can use it
I am trying to find documentation online but i see any about the things I posted
Maybe we should do some type of office hours.
^ +1... Would be really great if we could have more community helpers to help us understand anchor 🙏
please
but https://www.youtube.com/watch?v=mR3Ipaju-ec will work for installing solana on rosetta
```
#[account(
        init,  // TODO: Why is this initializing a token account? how does that work?
        seeds = [b"token-seed".as_ref()],  // TODO: wtf
        bump = vault_account_bump,  // TODO: wtf
        payer = initiator,
        token::mint = mint_a,  // automatically initializes a TokenAccount
        token::authority = initiator,  // TODO: shouldn't this be the PDA?
    )]
    pub vault_account: Account<'info, TokenAccount>,
```

Can someone please explain what is going on here? I understand how the seeds + bump are used to generate the PDA
for anchor? my audio broke and i have been too lazy to rerecord it
Do you have a setup video?
theres prolly some more rando bugs i havent encountered, but for ver ybasic stuff yeah you wont notice
😂
lol it works until you want to use anchor / do anything on localnet
did u ever find an example 🙂
Ok I now understand that the bump is the value where the public address falls off the Ed25519 curve. But what if one user arrives at the same bump as another user, and they both try to use that bump to create accounts? Then both the `vault_account`s will have the same address, no?
im getting a ```value: WrongSize``` for pubkey::from_str("a string of len 64")

i got the public key using provider.wallet.publicKey in the clientside js
it returned:
```PublicKey {
  _bn: <BN: a string of len 64>
}```
Check out the Paulx tutorial
You just find the first bump that takes it off the curve
That's not how bumps work
Am I the only person who uses WSL
```
    #[account(
        init,
        seeds = [b"token-seed".as_ref()],
        bump = vault_account_bump,
        payer = initializer,
        token::mint = mint,
        token::authority = initializer,
    )]
    pub vault_account: Account<'info, TokenAccount>,
```

If vault_acount_bump is u8, then can't we only create 255 different possible PDAs here?
Tag <@!917870235497938974>
<@867369388608061470> did a video
Haha yeah, I'm still using rosetta 😛
Great news, though I'm skeptical!
No rosetta etc.
I think it's possible you don't even need to do anything special now—not 100% sure about that but I did a setup with someone last week and as far as I know it just worked 🤔
What is the best setup guide for M1?
oki
Oh, sorry, I misremembered the context of that question, one sec
Pubkey::find_program_address
how to make PDAs manually
ahh thank you, it didnt show up in google search index
Yes. https://project-serum.github.io/anchor/ts/index.html
does anchor have api documentation like solana/web3  does?
like https://solana-labs.github.io/solana-web3.js/modules.html#TransactionSignature
i want to know for example what are `new anchor.Provider()` doing and what argument options and the types
gm
what issue are you facing? can you post a code snippet?


//////////////////////////////////////////////////////////////////////////////////////////

the output file does have them but would be useful to confirm some things in an automated fashion
is it possible to get tx logs in the unit test environment? i've tried getConfirmedTransaction but the provider commitment level doesn't seem to match the expected level?
Ah, do `associated_token::mint` and `associated_token::authority` instead
Any example how to create associated account would be helpful!
```error: expected `=`
   --> programs/airdrop/src/lib.rs:118:64
    |
118 | ...   #[account(init, payer = taker, associated_token_account** >>> :: <<<** mint = airdrop_token_account.mint, associated_token_account::authority = t...
    |```
Does someone know how to create associated token account if it's not existing?

I tried:
```
        #[account(init, payer = taker, associated_token_account::mint = airdrop_token_account.mint, associated_token_account::authority = taker)]
        pub taker_receive_token_account: Account<'info, TokenAccount>
```
But im getting following error:
would you happen to have any list of links related to Solana learning resources, etc? Something similar to those "Awesome SomeLibrary" repos that are sometimes created? I think it could be a great resource! I'd probably read just about every link on it
ahhh, great! Thanks for the link! I'll dig in. 👍
Slightly more complicated than that (transaction fees are about how many signatures have to be verified) but yeah, basically! https://jstarry.notion.site/Transaction-Fees-f09387e6a8d84287aa16a34ecb58e239
hmm, so compute resources, strictly speaking, are basically free? You just gotta be within the allocated compute budget? interesting. And so the only thing you actually pay for in each transaction is the rent incurred?
Solana doesn't really have gas fees (just a compute budget)—the only thing you pay for is the rent cost (which is actually fairly expensive, currently around $1/kb)
that would be my guess anyways, from seeing the publicKey/address and the error number
`0xc` is 12 in decimal, so I imagine it would be error 13. The address you posted pulls up the "Token Metadata Program" here: https://explorer.solana.com/address/metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s

That name implies the relevant source code would be here: https://github.com/metaplex-foundation/metaplex/blob/626d15d82be241931425cf0b11105dbf25bc9ef8/rust/token-metadata/program/src/error.rs

Error number 12 (actually 13 because of a zero start-index on enums), in that file would be: 
```/// Symbol too long
    #[error("Symbol too long")]
    SymbolTooLong,```
I always wondered some of the details around this as well... I assume that the amount of space you put into the parameter will also affect the gas amount, correct? So, even if you are not using it all right away (like having some of the space allocated for the empty Vec, as an example), you still need to pay the rent exemption gas fees up front, correct? So you have to find a balance between sufficient capacity for growth and lower gas fees?
I am having some problems with the IDL generation for TS types, namely
IdlError: Type not found: {"name":"terms","type":{"defined":"Terms"}}
Terms is a struct, that is embeeded in another like:
#[account]
pub struct Terms {
    pub fee: u128,
}

#[account]
pub struct MainStruct {
    pub terms: Terms,
}
Did you make any progress on this gary? Thanks for the pda idea btw
Ahhh, ok! 😕  Thank you! I think, that I just misunderstand something, but no.
Yep, gotta just think of an ok max amount of space (it's annoying)
Hey, one more stupid question about storing `Vec` of things in account. So we need always specify `space` in `account` macro, but if I do not know upfront how many things will be in my `Vec`, I should anyway have some `MAX`limit for it to calculate space? Or how best to do this, maybe somebody could share some best practice example? Thanks in advance.
Thanks
push is working
Did it work?
store the pubKeys in an array
What have you tried so far?
how can I add a new data to this one?
Yep
```
pub struct UserAccount {
  pub keys: Vec<Pubkey>,
}
```
Like this
Yeah can remove the Option
Do you definitely want an *optional* vec? What difference do you want to maintain between a None vs a Some(empty vec)? Could you just have your account store a Vec, no Option part?
You'll have to check if the Option part is None
Hi <@!134416332509675520> 
How are you doing?

Could you let me know how I can push the `Pubkey` to the `Option<Vec<Pubkey>>`?
```
pub struct UserAccount {
  pub keys: Option<Vec<Pubkey>>,
}

pub fn stake(ctx: Context<Data>) {  
  ctx.accounts.user_account.keys.push(*ctx.accounts.initializer.key);
}
```
hi. i have some experience with evm and was going to write a liquidation bot. are there any protocols on solana that offer flash loans?
Doing a CPI to the Metaplex program and getting this error: `    'Program metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s failed: custom program error: 0xc'`

How do I check what Metaplex error this is?
Creating a program that interacts with the Metaplex NFT contracts and want to test it out
Can I run `anchor test` on devnet and have it deploy a program before the tests start?
https://pencilflip.medium.com/learning-solana-3-what-is-a-program-derived-address-732b06def7c1
How can I use the Metaplex NFT programs on localnet?
PDA?
Use a PDA?
you can use `msg!("{:?}", my_object)` to print out what a value looks like at any point
How would y’all enforce uniqueness of a username on a ProgramAccount? I want to add a username field and have it be unique across the application.
if i dont have the idl of a program, i cant decode the transactions yeah?
is there an easy swap to swap the build from ts target to js
if playerdata.blue_player == PubKey(0) {
            playerdata.blue_player = *ctx.accounts.new_user.key;
        }
anyone know a good way to check if an address is a null address?
when i initialise an account without giving blue_player a value, it's initialised to PublicKey { _bn: <BN: 0> }
pub struct PlayerData {
    pub red_player : Pubkey,
    pub blue_player : Pubkey,
}
but i'm not sure how to check if it's a zero address in the program
playerdata.blue_player == 0??
something like that
in your program handler you can do `ctx.accounts.user.to_info()`
is there anyway to access Signer info from a transaction?
eg. #[derive(Accounts)]
pub struct Create<'info> {
    #[account(init, payer = user, space = 10)]
    pub base_account : Account<'info, Board>,
    #[account(mut)]
    pub user : Signer<'info>,
    pub system_program : Program<'info,System>,
}
from user
is there a reason why "a seeds constraint was violated" only appears on some tests? even without touching the code
stuck on spinner, txns fail
anyone ever have issues with phantom localnet not loading?
Hmm I would test that, and let me know if it works!
so if i just want the user as a signer i don't need it to be mutable?
So it needs to change the state of the account
Because anchor is deducting lamports from `user` under the hood
gm
to create an account like this:
#[derive(Accounts)]
pub struct Create<'info> {
    #[account(init, payer = user, space = 10)]
    pub base_account : Account<'info, Board>,
    #[account(mut)]
    pub user : Signer<'info>,
    pub system_program : Program<'info,System>,
}
how come the user account needs to be mutable?
Cool thanks for that tip
ohhhhhh
By the way, I would suggest setting up your editor so you can mouse over variables and see their types
You always need to pass something of type PublicKey for those addresses/accounts. Here offer is a Keypair, so gotta pass its `.publicKey`. Whereas escrowedMakerTokens is a PDA, so it's *already* a PublicKey instance, no need to dot anything.
gotcha
so technically this instruction needs 2 total signatures
i guess to initialize it needs a signature of the account as well since it's initializing it on the blockchain. i havent worked with using `init` beyond PDAs so this is an educated guess
https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo/src/lib.rs#L162
What does this mean and how do i get a more specific error? 
(Trying to run `anchor test`)
can you post the struct in that defines all the accounts?
`offerMaker` is the signer
it is,
But what about `offer`? That's an account we initialize
is that account defined as a Signer in the program? if so, that's why
Why do we pass just the publicKey for non-TokenAccounts, but then pass the keypair for `offerMakersMakerTokens`?
I'm having trouble updating my version of anchor. Right now I'm on 0.9.0 and when I upgrade to 0.19.0 using yarn my tests start failing with `Error: Error loading workspace IDL for project`
that is ctx.accounts.from(), instead of going through the inference
Alright! thanks! I wonder why not just call .from() if that is where it will end up anyways :S
Rust is relying on type inference here: `token::set_authority` needs a CpiContext argument, so rust is smart enough to go find that `from` impl (`.into()` uses a standard rust trait, From, under the hood)
But I do not understand how ctx.accounts.into() calls the from implementation defined in the escrow program. I assume that this is something Rust-language specific but I can not figure out what

Because that is the only ways the params makes sense when looking at the set_authority implementation by anchor:

And I assume that the ctx.accounts.into(), in some way calls this function which is defined below

In the anchor/test/escrow example project, inside the initialize_escrow function the call to set_authority looks like this:
I see, thank you!
If the escrowed tokens lived at a keypair address (not a PDA), then yeah, the keypair would have to go in that `signers` array
Any time you create an account in solana (teensy asterisk here) the address needs to sign
Right. The issue is that PDAs *can't* sign from the client (not physically possible, because they're not actual public keys with corresponding private keys), so the program has to sign for it
Hmm but `signers: [offer]`  instead of `signers: [offer, escrowedMakerTokens]`
https://github.com/cqfd/quidproquo/blob/main/tests/quidproquo.ts#L100
No, here we're init-ing the escrowed tokens accounts, so it needs to sign too!
Only the `offer` signs this transaction though, so we don't need `escrowedMakerTokens` to sign
The client actually isn't passing in the seeds—its passing in the derived *address*, which is different (given just the address you can't guess the seeds necessarily)
The `seeds = [...]` annotation tells anchor how to sign for that address (necessary because we're initializing an account there—that requires a signature)

What's the point of giving `seeds` parameter if we're going to just pass the value in anyways during tests?

code: https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo/src/lib.rs#L170
test: https://github.com/cqfd/quidproquo/blob/main/tests/quidproquo.ts#L79

<@!134416332509675520>
perfect tysm
Not sure what you mean. They're PDAs derived from the associated token program: https://github.com/project-serum/anchor/blob/master/ts/src/utils/token.ts#L18
There's a lot of stuff coming in 1.9
are ata accounts derived the same way normal addresses are? eg: the seed constraints can be used interchangeably
this is to calculate the current rent stats, how much sol you need to store data and such
it's like a number but big
BN = BigNum: https://discord.com/channels/889577356681945098/889702325231427584/917910080010211328
`new anchor.BN(1234)`

What the heck is this LOL
gotcha, thanks
Don't think there's any way to do this currently, no—I think anchor would have to add a special method to Account for this
Anchor question, but maybe a rust question:
is there a one-liner i can to assign an entire account data struct to an `Account<>`
So for example:
```
let new_user:User = User { // init my 8 or 9 fields }
ctx.accounts.user = new_user; // error: expected struct `anchor_lang::Account`, found struct `User`
```
Something sorta like that i guess
That way i dont have to access each field on the ctx account to update it
Why do we need to pass this into context?:

`pub rent: Sysvar<'info, Rent>`
probably not for at least 4 more months tho
gotcha
Soon™️
the answer is soonTM
so the answer is no basically
hey, thanks
i had a discussion on the main solana discord about this:
https://discord.com/channels/428295358100013066/517163444747894795/917940076275707904
looks like solana supports it
Hi :) Can you resize solana accounts? If so, how?
I'm gonna look to the code and try to find something
Ok, i fixed the typo and the error changed: TypeError: (0 , common_1.translateAddress)(...).toBuffer is not a function. I don't know if there is more silly typos like that
🤦‍♂️
You have a caps error: PublicKey --> publicKey

lol sorry
Heh, can't seen any line numbers in there 😛
I'm testing this. I dont know why but when I remove from line 29 to 44 the error stops..
Ok, so probably the error is happening somewhere else?
I really did not expect this output

What about `console.log(dataAccount.publicKey.toBuffer())`?
sure
Can you do `console.log(dataAccount.publicKey)` real quick?
node tests
Is this in the browser? Or in your node tests
I'm trying to use my public key to generate a seed but i get this error "TypeError: Cannot read properties of undefined (reading 'buffer')". I'm sure that dataAccount.publicKey exists
ohhh interesting
It's not possible within your program to dynamically look up an account based on its pubkey—you have to have the client declare its interest ahead of time
So no way to avoid passing the account in from the client
Yeah, solana just doesn't work that way—you have to pass in *all* accounts you care about.
and then fetch the details when we need them
Why can't we just store the Pubkey of that account though?
ok yeah confirmed
testing now
`the_account.to_account_info().data_len();` might be it
To say that more clearly, the escrowed_maker_tokens needs to be a token account, which is a whole separate account unto itself, so no, it can't be part of the Offer.
Alas, the nature of solana is that you need to pass stuff every time
https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo/src/lib.rs#L169

<@!134416332509675520> : Why didn't you make `escrowed_maker_tokens` a field of the account `Offer` ? This way, users don't need to pass it in every time
oh sick ty
Ohhh. Got it. Yeah, you can do `the_account.to_account_info().data.len()` probably
ah this is less for the derive and more for if i'm interacting with the pda later on (specifically, transfering lamports from that pda to another address while ensuring the pda remains rent exempt)
im reading ur erscrow program cqfd. It's a lot better than the hackmd one, which is poorly explained and not written well
amazing
Yep
In general there's no way to automatically get a good static size, but there are workarounds—you can have your struct derive Default and then skip the `space` attribute
```
    #[account(
        init,
        payer = offer_maker,
        seeds = ["apple"],
        bump = _bump,
    )]
```
To be clear -- this initializes a new account that is located at the address of the PDA in memory... right?
any instance of a struct (like the Fanout struct specified above)
Do you mean a static size for any instance of the type?
Not totally sure what you mean—how would the account know its size at that point?
ty <@!134416332509675520> is there a way to pass in something like account.size() instead of the sum to calculate the rent exemption elsewhere in a program? so like instead of

`rent.minimum_balance(8+2+2+1).max(1)`
`rent.minimum_balance(account.size()).max(1)`


//////////////////////////////////////////////////////////////////////////////////////////

<<<<<<< HEAD
Not sure how haha
I now need to convert an &mut &[u8] into an &mut [u8]
Thanks! It is just Pubkey.to_bytes()
https://discord.com/channels/889577356681945098/889577399308656662/906082959193411596
Like that is what it is, but for the library I am using it needs the primative type
Does anyone know how to convert an Anchor Pubkey into a [u8; 32]
https://doc.rust-lang.org/std/option/enum.Option.html
I'm quite new to Rust, but I think this is the way x)
niiiiiiiiiiiiice - I'm figuring out how to unwrap / wrap the <T> from Option  in order to create all operation functions (create, destruct, switch, etc) but if it works in the end that's sweet
I am currently using a crate called sodalite, but would be nice if there were something native in Anchor as I am using the Pubkey struct in Anchor as my endpoint input
`nacl.sign.detached.verify(message, signature, publicKey)`
This funciton but in Rust
Is there a tweetnacl package in the anchor_lang rust crate that I can use to verify a signature like in tweetnacl-js
Loader uses `zero_copy` deserialization, Account uses regular anchor serialization
I also get errors that I dont add default for luke systemprogram, clock, and so on. 
```
error[E0277]: the trait bound `anchor_lang::Program<'_, anchor_lang::System>: Default` is not satisfied
  --> programs/baby/src/instructions/initialize_baby.rs:38:5
   |
38 |     pub system_program: Program<'info, System>,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `anchor_lang::Program<'_, anchor_lang::System>`
   |
   = note: required by `std::default::Default::default`
   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the trait bound `anchor_lang::Program<'_, anchor_spl::token::Token>: Default` is not satisfied
  --> programs/baby/src/instructions/initialize_babylon.rs:39:5
   |
39 |     pub token_program: Program<'info, Token>,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `anchor_lang::Program<'_, anchor_spl::token::Token>`
   |
   = note: required by `std::default::Default::default`
   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the trait bound `anchor_lang::Sysvar<'_, anchor_lang::prelude::Clock>: Default` is not satisfied
  --> programs/baby/src/instructions/initialize_baby.rs:40:5
   |
40 |     pub clock: Sysvar<'info, Clock>,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `anchor_lang::Sysvar<'_, anchor_lang::prelude::Clock>`
```
Any thoughts here 🙂 Thank you all
What do I do with the account?
Hi team stuck on providing constraints on my accounts and getting a bit stuck. I believe the error is coming from pda
```
#[derive(Accounts)]
#[instruction(bump: u8)]
pub struct InitializeProgram<'info> {
    #[account(mut, signer)]
    pub initializer: AccountInfo<'info>,
    #[account(
        init,
        payer = initializer,
        space = 8 + std::mem::size_of::<BabyData>())]
    pub baby_data: ProgramAccount<'info, BabyData>,
    #[account(
        init,
        payer = initializer,
        space = 8 + std::mem::size_of::<WhiteData>())]
    pub white_data: ProgramAccount<'info, WhiteData>,
    #[account(
        init,
        payer = initializer,
        space = 8 + std::mem::size_of::<UlistData>())]
    pub ulist_data: ProgramAccount<'info, UlistData>,
    #[account(mut, signer)]
    pub usdc_token_account: Account<'info, TokenAccount>,
    #[account(mut, signer)]
    pub sol_token_account: Account<'info, TokenAccount>,
    #[account(seeds = [TREE_PDA_SEED.as_ref()], bump = bump)]
    pub pda_account: AccountInfo<'info>,
    #[account(mut)]
    pub treasury_wallets: Account<'info, TreasuryWallets>,
    pub system_program: Program<'info, System>, 
    pub token_program: Program<'info, Token>,
    pub clock: Sysvar<'info, Clock>,
}
```
For babydata, ulistdata, and whitedata I have 
```
#[account]
#[derive(Default)]
pub struct UData{
    pub bump: u8,
    pub key: Pubkey
}
```
The error that shows up for these structs is 
error[E0071]: expected struct, variant or union type, found type error
 --> programs/babylon/src/state/baby_data.rs:3:1
  |
3 | #[account]
  | ^^^^^^^^^^ not a struct
  |
If you're on MacOS you need to build from source, npm package is only supported for Linux.
Hello, I'm trying to call rpc function (candy machine mint) inside my frontend vue script, I connected the wallet, checked candy machine program object, all functions like signTransaction are there but when I call it I'm getting the error inside wallet adapter ```TypeError: this.emit is not a function
    at Object.<anonymous> (vendor.dc4156ad.js:70)
    at Generator.next (<anonymous>)
    at vendor.dc4156ad.js:70
    at new Promise (<anonymous>)
    at __awaiter$3 (vendor.dc4156ad.js:70)
    at Object.signTransaction (vendor.dc4156ad.js:70)
    at Provider.send (vendor.dc4156ad.js:183)
    at async Object.mintNft (vendor.dc4156ad.js:207)
    at async ni (index.14c73809.js:1)
    at async n (index.14c73809.js:1)```, I changed phantom and solflare adapter and the error appears inside both adapter.ts files. What can be wrong?
Just use the instructions on https://project-serum.github.io/anchor/getting-started/installation.html#install-solana - all the needed commands are in there. You can use NPM to install anchor-cli or build from source.
What is the difference btw `Loader<'info, ChatRoom>` and `Account<'info, ChatRoom>`?
sorry for my english 'im french
No, actually I was following a tutorial on how to develop on the solana network. However in that tutorial it said to install anchore - cli so I googled it directly, then below the tutorial there was a discord link.
Did you ever find an answer to this?
Ok thanks, wasn't clear on where to find this example
you asked for resources that do what you want, the ido pool example in `anchor/tests` does that
?
it probably was just the machine struggling a bit to run the test validator
ok, increasing that to `20_000` worked for me
ok, i'm trying alan's recommended approach 
```
[test]
startup_wait = 10000
```
IDO pool
Sirs are there any tutorials/resources which show how to CPI to an already deployed token where the mint authority is my Program
it happened when i tried to add 
```

[[test.genesis]]
address = "9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin"
program = "../../target/deploy/serum_dex.so"
```
to the Anchor.toml file. But quite weirdly, even after I delete those lines it still doesn't run
Hi
tried deleting the program target directory and the test ledger directory
getting a silently failing local net
```
   > cat .anchor/test-ledger/test-ledger-log.txt 
Ledger location: .anchor/test-ledger
Log: .anchor/test-ledger/validator.log
Initializing...
```
did u get it to work, i am basically trying to do the same thing (PDA with global account and simulate multiple users interacting with the program)
so `accounts: { user1: Keypair.generate(), user2: Keypair.generate(), ...}`
if you want to generate new keypairs, you can use ` Keypair.generate()`
this is the one that uses the default key, saved on your file system
how can you create multiple user accounts in a test file ? I tried to replace ```accounts: {  user: provider.wallet.publicKey }```  (when creating new accounts) with a key i generate on the go with ``anchor.web3.Keypair.generate();``. but i didn't do the trick
unfortunately yes, but started to work on something else
What do you mean? There's no "anchore" on that page, so not sure how you got to that other github repo
the repo github
What went wrong?
so i try used this link
haha xD, i think i'm in the wrong github because i want use this for develop in solana
That's a similarly-named but totally different project haha, you're either in the wrong discord or on the wrong github repo

i used that :
https://project-serum.github.io/anchor/getting-started/installation.html#install-anchor
Is that how you're trying to install anchor?
Haha, anchorecli is something totally different I think 😛
When you use `init`, your anchor code will make a cross-program invocation to the system program to create that account. Doing it in a separate instruction from the client (could be prepended to the transaction) doesn't actually do a cross-program invocation, it just runs that instruction directly.
Hello everyone, i have just install anchor-cli but when i started the command anchor --version, its not working. Can you help me please ?
By the way, I'm a bit confused, aren't we creating via CPI ? what's the difference with creating via instructon? 🤔
Hmm still need to mess around. you mean the client like front-end right?
Hello, on initialization how can i store some solana in the contract until certain action?
Hey guys, is there any documentation on the instruction attribute?
thx for your help i installed using npm i have this :
It's very straightforward, you just need to add some derive macros on top of the enum
Search for `enum` in `anchor/tests` or serum/swap repo inside .rs files
Yeah the serum errors are pretty cool
Is anyone actively working on adding more verbose debugging?
You know serum has a really weird debug thing that actually prints out the line number the error happened
How to implement enum in anchor?
Or havign your program panic if its runtime program id doesn't match its declare_id! (your stuff is def wrong if they don't match)
Think this is a good example of how a noiser debug version of anchor would be good—these errors could be self-explanatory if they logged a bunch more
It seems to be popping up an awful lot
I'm curious what the root cause could be for so many errors related to incorrectly owned accounts
Hi, do you still getting 0ax7 error?
ok
Basically just need to figure out what borsh didn't like—e.g. double check you're using the right account, it has the expected length, etc.
It will give you some kind of borsh error, not sure if it has more info about what borsh didn't like
Ok, cool. Might as well try logging additional error stuff then I guess, in that `map_err` above
Atleast its non null
It looks correct
Let me check
Like, if you await program.provider.connection.getAccountInfo(metaDataAcc)
Does the data in there look correct to you?
Yes I am testing on devnet
This is the way I am computing it
const [metaDataAcc, metaDataAccBump] = await anchor.web3.PublicKey.findProgramAddress(
      [
        Buffer.from("metadata"),
        TOKEN_METADATA_PROGRAM_ID.toBuffer(),
        NFTTokenMint.toBuffer(),
      ],
      TOKEN_METADATA_PROGRAM_ID
    );
And you're testing on devnet?
let TOKEN_METADATA_PROGRAM_ID  = new anchor.web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s");
and it is owned by TOKEN_METADATA_PROGRAM
THis is the account on devnet
Yep
``metaDataAcc is DR3Dr7YxBNCMMCTwyB34evv6D6Y6HYH53bTT6P16YV8r``
Does that account actually store metadata in it? It won't automatically—in general it will just be an empty account unless you've made sure it actually has metadata in it (not automatic, especially when testing locally)
<@!712332112128376885> 
Can you help me with the below, I see you have done something similar before

`let metaData = metaplex_token_metadata::state::Metadata::try_from_slice(*ctx.accounts.token_metadata_account
        .try_borrow_data()?).map_err(|_| ProgramError::InvalidAccountData)?; 
The following is not working for me I get InvalidAccountData
FYI the token_metadata_account is of type AccountInfo
and it also exists
in short it is correct , can you just help me point the issue`
mm, very abstract but I think I get the idea, thanks! <@!163857206721249280>
I still have a fairly laymen's understanding of it all, but you do some math, and when a number is on that curve, you get a public and private key out of it. But if the formula lands outside of the curve, then all you can get is a public key out of it, so by bumping your seeds until you find an off-the-curve value, you are able to generate public keys that cannot possibly have a private key counterpart, and thus cannot be signed by anybody. So they're safe to use as storage account addresses, to be used by the program only, without risking anybody happening upon any private key for them
Yep, the right hand side of `space =` can be any expression—e.g. you could even specify it from the client with an `#[instruction(how_much_space: u64)]` (that would be kind of weird, just an example)
I thought something was wrong and I was nearly hitting the numeric limit for the u8 type... that wouldn't have been good!  😆
What is the concept of the `elliptic curve` about?
whew! Thanks! That makes sense, and makes me feel better  😅
I am experimenting with that right now and I get high values too.
I don't understand very well the concept of the `curve` , but regarding the value, as mentioned in this article https://www.brianfriel.xyz/understanding-program-derived-addresses/,  `In Solana, we start with bump = 255 and simply iterate down through bump = 254, bump = 253, etc. until we get an address that is not on the elliptic curve.`
question: Are very large bump values normal to encounter? I see code samples everywhere of bump parameters being u8, which maxes out at 255. And I also see mentions of being on/off the ec curve having a 50% chance. But then I print out my bump values from findProgramAddress, and they are super high, like 248 or 254... is this normal? Do the bumps count backwards maybe? I'm a bit confused on how they could reach such high numbers
Or `instruction`
Using the keyword `space`
You should try searching around the `anchor/tests` directory
oh, do you mind, sharing code snippet example?
this is how I currently code this
```
pub mod test {
    use super::*;
    pub fn initialize(ctx: Context<Initialize>) -> ProgramResult {
// how to set the space?
Ok(())
}
}

#[derive(Accounts)]
pub struct Initialize<'info>{
  #[account(init,payer=user,space=??)]
  pub data: Account<'info,DataStruct>,
  pub user: Signer<'info>,
#[account(address=system_program::ID)]
pub system_program: Program<'info,System>,
}

#[account]
pub struct DataStruct {
  pub user_address: Pubkey,
  // etc, potentially costly data
}
```
You can pass it in as an argument from the instructions
If I am not wrong that is not possible. The space needed has to be defined before deploy
Ah thanks for the clarification <@!248066053161222144> . Can we set account space dynamically on invoking the function?
say doing things like #[account(init, payer=user,space=*some function*)] ?
It's 10mb for accounts created in instructions, it's 10kb for accounts created via CPI
I count that maximum we can get is  10,240 bytes. is that correct? 🤔
Hi, wanted to ask, I encountered this
```
Transaction simulation failed: Error processing Instruction 0: Failed to reallocate account data 
    Program 5R5vVZtvt6abcozWVcxqgq43FBtPvuK2kqmR4ktCTXqQ invoke [1]
    Program 11111111111111111111111111111111 invoke [2]
    Program 11111111111111111111111111111111 success
    SystemProgram::CreateAccount data size limited to 10240 in inner instructions
    Program 5R5vVZtvt6abcozWVcxqgq43FBtPvuK2kqmR4ktCTXqQ consumed 200000 of 200000 compute units
    Program 5R5vVZtvt6abcozWVcxqgq43FBtPvuK2kqmR4ktCTXqQ failed: Failed to reallocate account data
Translating error SendTransactionError: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Failed to reallocate account data
{
  logs: [
    'Program 5R5vVZtvt6abcozWVcxqgq43FBtPvuK2kqmR4ktCTXqQ invoke [1]',
    'Program 11111111111111111111111111111111 invoke [2]',
    'Program 11111111111111111111111111111111 success',
    'SystemProgram::CreateAccount data size limited to 10240 in inner instructions',
    'Program 5R5vVZtvt6abcozWVcxqgq43FBtPvuK2kqmR4ktCTXqQ consumed 200000 of 200000 compute units',
    'Program 5R5vVZtvt6abcozWVcxqgq43FBtPvuK2kqmR4ktCTXqQ failed: Failed to reallocate account data'
  ]
}
Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Failed to reallocate account data
```

does this mean that there are limit to how much data we can store?
not a question. I am a beginner and got an upvote thing working thanks to <@!163804384193413120>'s guide. I am so psyched.
https://github.com/project-serum/anchor/blob/master/tests/ido-pool/programs/ido-pool/src/lib.rs#L332
do you need an init for an account.. Is there any good examples you can point to me of live code. Appreciate the hhelp
possible you forgot a `account(init,...`?
as a constraint
Thanks for following up but they align. I think the issue surrounds how I created my pda
this is likely that the value in `declare_id!()` is different from your key in `anchor keys list`
try
```
anchor build, anchor keys list --> go grab your key and update declare_id --> anchor build -> anchor deploy -> anchor test
```
Do you think I need to adjust token account constraints at all
Hi tthere I have is regarding how to properly put constraints around TokenAccounts in your program... so like I get this error. I think the error is caused either by my pda or my token accounts in this temp project I am working on.. 
     Error: 167: The given account is not owned by the executing program


 #[account(mut)]
    pub usdc_token_account: Account<'info, TokenAccount>,
    #[account(mut)]
    pub sol_token_account: Account<'info, TokenAccount>,
    #[account(seeds = [TREASURY_PDA_SEED.as_ref()], bump = _bump_seed)]
    pub pda_account: AccountInfo<'info>,


I think my error is coming from erither the TokenAccount or my pda constraints
Hi there, 
Im currently trying to run anchor testcases against the devnet, Ive changed the setting in `Anchor.toml` to devnet, and ran `anchor test --skip-deploy` after `anchor deploy `, However I got this error
```
TypeError: Cannot read property 'programId' of undefined
TypeError: Cannot read property 'rpc' of undefined
```
has anyone run into this issue before?
(so I used `solana deploy` and not `solana program deploy`)
I deployed this program using `solana -k admin_key.json -u mainnet-beta deploy <path-to-so-file>`
Here is the deployed program on main-net: https://explorer.solana.com/address/JBAnZXrD67jvzkWGgZPVP3C6XB7Nd7s1Bj7LXvLjrPQA
`solana -k admin_key.json -u mainnet-beta program show --programs ` shows an empty table
What does `solana program show --programs` return
not sure if it's possible to reclaim SOL from that
ahhh, I see -- I used the old `solana deploy` which does not use an upgradeable bpf loader
Yes, there is, you can read about it here.
https://jstarry.notion.site/Program-deploys-29780c48794c47308d5f138074dd9838#561f8e76208a46b8963092adabab2256
It deploys the program correctly, but for some reason fails on next steps
```
Deploying workspace: https://api.devnet.solana.com
Upgrade authority: /home/sheep/.config/solana/id.json
Deploying program "fixed"...
```
I have a deployed program with `solana [...] deploy`
https://explorer.solana.com/address/JBAnZXrD67jvzkWGgZPVP3C6XB7Nd7s1Bj7LXvLjrPQA
Is there any way to close a deployed program & recover the Sol:
Hi all quick question: I am gettting this error when anchor deploying: Error: Program's authority Some(7aN6TLYfg3NDBHHxKWLTctHDaSJT2mT9fPZGgVaABVCp) does not match authority provided 7YSUUrPrUDWn4muyrq2KiWRbfYk57LF1BfcDCeYpoEBT
Any thoughts whatt is causing this
I am pair coding with afriend
But I tthink I did all the required work, I went to toml and pointed the wallet to where it is located on my computer and so on
Any thoughhts :))
And this is the only line in  `Anchor.toml`  that I changed
```
[provider]
# cluster = "localnet"
cluster = "devnet"
```
I do have 
```
json_rpc_url: "https://api.devnet.solana.com"
```
in config.yml set
Oh, yes, I see that it tries to connect to localhost for some reason
It looks like it's looking for a local test validator so you might have misconfigured
Good day! I'm getting this error, when trying to run tests on `devnet` on `1.8.5`. Am I doing something wrong?
```
Translating error Error: failed to get recent blockhash: FetchError: request to http://localhost:8899/ failed, reason: connect ECONNREFUSED 127.0.0.1:8899
```
can you paste the code where you have this address ?
Quick question, I am getting this error when I run anchor deploy: Error: Program's authority Some(7aN6TLYfg3NDBHHxKWLTctHDaSJT2mT9fPZGgVaABVCp) does not match authority provided 7YSUUrPrUDWn4muyrq2KiWRbfYk57LF1BfcDCeYpoEBT
thank you will check this out 🙂
did you trying installing using npm instead?
https://github.com/project-serum/anchor#getting-started
also check this out
https://discord.com/channels/889577356681945098/889606719829835816/909947411550580766
Great thanks
https://docs.rs/anchor-derive-accounts/0.18.2/anchor_derive_accounts/derive.Accounts.html
if ur on the serum discord i'd ask there
and how they work
Hi all what is the best way to learn anchor constraints
or setup a new market
👋 are there more recent instructions on how to build and deploy serum-dex? the readme was last updated 9 months ago rip

cargo build-bpf compiles but I'm not sure if I just yolo anchor deploy that and no clue how to actually setup the markets
https://discord.com/channels/889577356681945098/889702325231427584/915263210960076891 always open 😊!
🥲
IT'S BEAUTIFUL
BY GOD IT WORKS
IT WORKS
hm, will keep on investigating ...
which feels like it should be more than enough to do whatever needs to be done
(in addition to the 1.39 already used for the deploy)
it's odd though b/c I know I still had 0.9 sol in the deploy account
That's the only reason I know it off by heart
If you discord search the error when you get it you will see 100 people posting about 0x1
Yeah when it says 0x1 custom program error I wasn't sure "is this the Solana chain, is this a loader, is this anchor, is this my code?"
Or sometimes the errors are inside the processor file, for Solana
You need to find the error.rs file for the program that's giving you the error
Discord search and all over Solana source
Is there a place where I can find the error code definitions?
No I mean that's literally what 0x1 error means
maybe ... but the thing is I was able to deploy w/o issues (on main net) using the other method (`solana [...] deploy` instead of `solana [...] program deploy`)
not enough solana
so im unsure how to query for the data in my ts test
uh, hey again, soooo im building this out, and everything is set up, and it seems to succeed in creating the PDA and storing the data and all that? but, the weird this is that the IDL doesn't generate anything about the ManyFacedAccount account type
This looks like it's using the latest BPF loader
Hm, here's the deployed program: https://explorer.solana.com/address/JBAnZXrD67jvzkWGgZPVP3C6XB7Nd7s1Bj7LXvLjrPQA
Does mainnet not yet support the new BPF loader or something?
(which uses the old BPF loader)
However, I just deployed to mainnet by running `solana -k admin_key.json -u mainnet-beta deploy target/deploy/pixels.so `
but if I swap `devnet` with `mainnet-beta` the command fails w/ the above error
Ok interesting: I can deploy to devnet using `solana -k admin_key.json -u devnet program deploy target/deploy/pixels.so`
Oh ... does Anchor support "solana program deploy" or does it only support "solana deploy"?
it's worth noting that I can deploy to devnet without issue
`Error: Deploying program failed: Error processing Instruction 1: custom program error: 0x1`
Does anyone know what this means when deploying a program:
is there an easy way to see which accounts can take what keywords in its macro? like this <https://github.com/project-serum/anchor/pull/790>
yh man, thanks a lot!! 🙂
makes sense, thanks a lot for your help :). We have fun times ahead of us
You can use `anchor_lang::solana_program::instruction::Instruction` and start trying to construct one
You would have to build those same instructions in rust (probably a bit tedious, but doable) and invoke them with `invoke_signed` (passing in any relevant accounts from the client, including the orca program)
so all the instructions are clear from the frontend API, what is unclear to me though is: how to make the same CPI calls from within rust? i.e. I guess we have to send instructions to the orca program address, etc.? 

i guess this is not specific to orca, but is true also for serum, saber, etc., where a typescript API is present (to be "reverse engineered"), but where the program has to do the call, as it owns certain pools
Probably wouldn't be too bad to port into your rust code
You could always source-dive in the sdk and see how they build their instructions 🔬
yeah they have a typescript sdk which is good. Just wanted to know if I can do the same from within the smart-contract. Would be much cooler 🙂
Yep (not sure if its open source or not—do they have a JS sdk or something?)
Thanks for your answer. I guess this means that I would need the orca source code as a cargo dependency (in my case).?
Normally in rust you'd just depend on the other program's code as a cargo dependency and use that to construct your CPI calls (e.g. how anchor talks to the spl token program)
The IDL won't help within your rust code, only from JS/TS (well, I guess it technically could help from within rust, but don't think that's implemented 🤔)
yeah i think so, i will let yall know either way 🙂
😭
hey guys, im wondering, assuming we have the IDL for another program (that is not deployed by us). similar to typescript, is there a way to invoke other solana programs from within anchor / solana rust code? Concretley I want to send liquidity to the orca LPs from within a smart contract.
I completely broke my app by trying to implement Typescript so I went back to studying 💩
Looks promising, would be interested in knowing how it went
So setting like a meta structure to hold different kinds of objects, and switching between them to exchange the data type held
Great, it’s exactly what i was looking for 🙂


//////////////////////////////////////////////////////////////////////////////////////////

And this program doesn't expose any ways to mutate the account aside from someone accepting the offer or the original maker canceling it.
Right, only an account's owning program can make changes to it
```
#[derive(Accounts)]
#[instruction(escrowed_maker_tokens_bump: u8, offer_maker_amount: u64, offer_taker_amount: u64)]
pub struct Make<'info> {
    #[account(init, payer = offer_maker, space = 8 + 32 + 32 + 8 + 1)]
    pub offer: Account<'info, Offer>, 
```
In this example, nobody can make changes to `offer` except the program, right? Not even offer_maker can make changes to the `offer` right?
Thank you very much, I initially thought that any custom account inited by the program is automatically owned by the program and also has the program authority.
But you have to implement that yourself, it's not built-in to solana
Yeah, you'll have to have some access control stuff if you want to limit who can mutate an account
Thank you, I'll try it out!
```.rs
hashv("global:initialize").to_bytes()[..8]
```
So basically anyone can edit the account inited by the program unless its authority is set explicitly, right?
So that empty data vec there isn't quite right, it'll have to have something like:
Anchor expects the first 8 bytes of every instruction to be a "sighash"
Oh, you're not calling your anchor program quite right
Accounts in solana don't in general have an authority (they always have a program owner, but authority is something your program will have to decide on itself)
```
     Error: 100: 8 byte instruction identifier not provided
```
Oh, but how can I then pass a program itself? If I try to pass it as an accountInfo I get errors anyway.
```
#[program]
pub mod test {
    use super::*;
    pub fn initialize(ctx: Context<Initialize>) -> ProgramResult {
        let ix: Instruction = Instruction {
            program_id: ctx.accounts.rec.key(),
            accounts: ctx.accounts.rec.to_account_metas(None),
            data: vec![],
        };

        solana_program::program::invoke(&ix, &[ctx.accounts.rec.to_account_info()])?;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    pub rec: AccountInfo<'info>,
}
```
In case of custom data account, what's the authority would be?
When you initialize a TokenAccount you have to say who the authority should be, e.g. with the `token::authority` attribute
Sorry, I misread your post
No, the owner of that TokenAccount is the spl token program
And spl-token is the owner?
What about the authority of the initialized TokenAccount i.e, Account<'info, TokenAccount> by the program?
Program is the authority of the TokenAccount?
Check out anchor's `trait Owner` (try searching the anchor codebase)
Woww very cool
Any #[account] struct Whatever in your program says that it shoudl be owned by your program
Ohhh wow how does it do that?
So Mints say they should be owned by the spl token program
Account<'info, Whatever> verifies that the account is owned by *whichever program Whatever says should own it*
I tried explaining this above, not sure if you saw
We pass in Mint account in the same way (Account<'info, Mint>), but the program does not own that mint account
But what about this?
https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo/src/lib.rs#L184
No! It does check: that's what Account<'info, Offer> does
https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo/src/lib.rs#L202

I'm trying to say:

The escrow program does NOT check if `Offer` is owned by the program in the `Accept` instruction. So what if a hacker uses the `Accept ` instruction, and passes in their own self-created `Offer` account
okay, i got some confusion about the `init`
I think it's the case when the fake frontend attracts the users.
Still not sure what you mean by that either haha, your program can init accounts it doesn't own
only if the account is inited by the program
Not totally sure what you mean by that 🤔
I will run a test to verify the following:

`pub account: Account<'info, X>,`

"Any time we pass data through a context like this, then the program has ownership over `account` that has type `X`"
Even if that's the case, the instruction is `Accept` so there's no need to take the fake account for the caller.
Did your question get cleared up? Not totally sure
true
<@!897327536147681291>  yes, but what if the user passes in data that mimics the format of the `Offer` structure
Not necessarily, you can also `init` token accounts, mints, etc.
I think the offer is created by the program, i.e inited by the program, so the owner is the program.
Which owner is expected is determined by the struct you have in there, Offer or Mint etc.
In that case it's checking ownership by the spl token program
No, it also checks ownership!
For example, when we pass in `Account<'info, Mint>`, our program doesn't own the Mint account
That just deserializes and verifies the structure of the data passed in
is program ownership checked by `Account<'info, Offer>` though?
like if offer.owner == PDA
The offer account itself is owned by the program (that's checked by Account<'info, Offer>). The offer's maker is *not* owned by the program (they're just some random person)
If the offer's owner is owned by the program? Not quite sure what you mean
In this escrow program, we do NOT check to see if the offer's owner is owned by the program. Is this fine because the program cannot close an account it does not own?

https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo/src/lib.rs#L197
You'll need to pass your own programId lol, since you're going to try to call it (I think, guessing here)
Oh, yes, it clicked, thank you!
Sort of like how you have to pass the systemProgram when you want to eventually call it
Think you'll have to do that (so you actually need 1 account in that Initialize struct—your own program!)
```
    1   ¦ const tx = await program.rpc.initialize(0, {});
```
When you called the program the first time around, from the client, did you also pass your own program's programId as an account?
It says that 
```
     Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: An account required by the instruction is missing
```
Does Anchor need any accounts by default? Or have I forgot something?
Good day! Why can't I recursively call this simple program?
```
#[program]
pub mod test {
    use super::*;
    pub fn initialize(ctx: Context<Initialize>, i: u8) -> ProgramResult {
        let ix: Instruction = Instruction {
            program_id: id(),
            accounts: vec![],
            data: vec![i + 1],
        };

        solana_program::program::invoke(&ix, &[])?;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize {}
```
Its just only a single global state account for contract so, would have to update global struct. If I don't it will break my contract ?
One trick you can try: you can sneak in some logs into any anchor attribute that takes an expression as its right-hand side. It can be a little tricky to make sure the attribute "runs" early enough, but e.g. you can do goofy things like
```.rs
bump = {
  msg!("wtf: {:?}", the_account.to_account_info().owner);
  the_bump
},
...
```
yes I know, but I'm not seeing it. guess I'm going to have to strip the instruction down to where it works and add stuff until it breaks again.
Short of editign the anchor source to log more stuff (possible if you're comfy doing that), I think you just need to verify each `Account` has the expected owner :/
It could be any `Account<'info, Whatever>` (including token accounts etc., which need to be owned by the spl token program)
Anchor is complaining an account doesn't belong to the program, is there a way to find out which account it's talking about because just that error on its own is not very useful
So you can update your program, will just have to be careful presumably
Any change you make will have to support the old format too (those accounts won't automatically update to reflect the new format—you'd have to patch them up or something)
Hey,

I would like to know if we can update current contact deployed on mainnet. I want to alter the current struct which I used to store data and like to add few properties to current struct . Is it possible if I change the structure of my data structure , it will not break anything with current data stored in accounts which interacted with it earlier ?
https://www.notion.so/Debugging-Custom-Anchor-Errors-b8540dd418c44a4e939ab17c56a3fd3b
does this help?
sry just searched
is there any way to estimate how much a smart contract will cost to deploy
Regular Windows won’t work
Use WSL
Anybody?
Now that I understand what is happening, the error makes sense. It would still be nice if the error was more descriptive or recommended checking the type
<@134416332509675520> What does error 66 mean?
It works on nested structs
That error message is very confusing 😆
This makes sense and using BN() works
`minimumPrice` is almost certainly the correct version, and then you get the error because you haven't used a BN
This appears to be a bug in anchor's serialization :/ I think something is defaulting to zero (ugh) if you spell the field wrong 🤦‍♂️
They are u128 in Rust, but it seams so wierd, that it fails only on fields like "minimumPrice" but not "minimumprice"
(Obviously not a great error experience)
If they're u64s and up then yes
Do you maybe need to be using `anchor.BN` for those numbers?
The same errors also occurs, when passing multiple structs
Ohwell, passing each struct individually is still much better than passing all values individually. Thanks so much for you help!
Seems like nested structs don't work very well, bummer!
Hmm, I don't think so, but when I try doing this locally I get all kinds of incorrect/useless typescript errors :/ Hadn't noticed that this was so fragile.
I am using windows and trying to install with cmd
`cargo install --git https://github.com/project-serum/anchor --tag v0.18.0 anchor-cli --locked`
Hello everyone, I am trying to install anchor-cli but I am getting this error. 
Can somebody help?
I'm on Anchor 0.19.0
`let exampleStruct = {
      valueTwo: 1,
      terms: {
        minimumPrice: 0,
      }
    };`
Errors with src.toArrayLike is not a function,
but 
`let exampleStruct = {
      valueTwo: 1,
      terms: {
        minimumprice: 0,
      }
    };` 
works
Are there any reserved field names?
Think you'll have to post more code
I have tried this approach, but when trying to pass a struct with nested structs I get the following error
TypeError: src.toArrayLike is not a function
But I don't think there's an easy way to refer to the expected typescript type :/
You would pass it as a JS object, `{ oneField: ..., otherField: ... }`
Or how would I construct the value in the typescript test?
Ah, hmm, not sure actually
Can I import the generated type into TypeScript?
Yep, can just do
```.rs
#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub struct YourStruct {
  ...
}
```
Because I need to initialize a few values and would not like to pass them all individualy
Is it possible that a rust function, for example initialize, takes a struct as input?
yeah thought that was the case, thanks for confirming 🙇‍♂️
I think anchor's IDL generation stuff doesn't understand the type, you'll probably have to use an i64 instead (that's what the timestamp is under the hood)
hey, I am running into this issue when. using `UnixTimestamp` from solana_program;
```IdlError: Type not found: {"name":"lockTime","type":{"defined":"UnixTimestamp"}}
```
is this happening because this type is defined in an external crate? I have seen some issues similar to that before
but the program keypair allows you to access program info, your system wallet holds sol for paying fees
im not entirely sure why that gave you those errors, maybe has to do with the solana balance for the account provided by the program's keypair
can you please explain your intuition on how/why those changes fixed it? still confused about the differences beteween wallet keypair vs. program keypair and how to know when to use what
happy to help <a:trippyBoneZone:789725627544371221>
oh shit it worked!! <@!800692321619542017> you're the GOAT man, thanks so much
I think you want your keypair set to your system wallet, can update with `solana config set -k <path-to-wallet>`
<@!800692321619542017> here's the error trace and what my solana config get returns
also can you post the error you're getting?
copy the value for `Keypair Path` into `Anchor.toml`
try ```solana config get```
does that file exist? try using the full path too
Still getting the error unfortunately 😦
<@!800692321619542017> Could you quickly describe the differences between the two and what each is used for? The only thing I could find regarding keypairs was https://docs.solana.com/wallet-guide/file-system-wallet which didn't cover this.
something like `~/.config/solana/id.json`
it should be your wallet keypair, not the programs keypair
I'm getting the same error as <@!719422966756278302> and I can't figure out why. To confirm, the Anchor.toml wallet should just be my keypair file location correct?
Hi,
Can I use a struct as an argument to rust function?
that was all you bro! i just linked to alan's random code XD
100%, I appreciate your help
now you have the experience. that's worth a lot 👌
thanks, been trying to figure out how to do this forever <:KEKW:716296709793251359>
thanks for sharing
very cool stuff man, good work 😄
```#[derive(Accounts)]
pub struct Join<'info> {
    user: AccountInfo<'info>,
    #[account(mut)]
    airdrop: Account<'info, Airdrop>,
    #[account(mut)]
    airdrop_owned_lamports: AccountInfo<'info>,
    system_program: Program<'info, System>,
}
```
can you post the `Join` struct?
This is on the anchor side:
```pub fn join(
        ctx: Context<Join>
    ) -> Result<()> {
        let user_list = &ctx.accounts.airdrop.user_list;
        let max_users = ctx.accounts.airdrop.max_users;

        if user_list.len() == max_users as usize {
            return Err(ErrorCode::UserListFull.into())
        }

        let user = ctx.accounts.user.to_account_info();
        let from = &mut ctx.accounts.airdrop_owned_lamports.to_account_info();
        let airdrop = &mut ctx.accounts.airdrop.to_account_info();
        **from.try_borrow_mut_lamports()? -= 1_000_000_000;
        **airdrop.try_borrow_mut_lamports()? += 1_000_000_000;
        ctx.accounts.airdrop.user_list.push(user.key());
        Ok(())
    }
```
This is on the client side
```const tempAcct = anchor.web3.Keypair.generate();

    const programId = new anchor.web3.PublicKey(program.idl.metadata.address);

    const transaction = new anchor.web3.Transaction().add(
      anchor.web3.SystemProgram.createAccount({
        fromPubkey: users[0].publicKey,
        lamports: 1 * LAMPORTS_PER_SOL,
        newAccountPubkey: tempAcct.publicKey,
        programId: programId,
        space: 256,
      })
    );

    const signature = await anchor.web3.sendAndConfirmTransaction(
      provider.connection,
      transaction,
      [users[0], tempAcct],
    );

    await program.rpc.join(
      {
        accounts: {
          user: users[0].publicKey,
          airdrop: airdrop.publicKey,
          airdropOwnedLamports: tempAcct.publicKey,
          systemProgram: anchor.web3.SystemProgram.programId,
        },
        signers: [],
      }
    );
```
can you paste the code you wrote for this? would be very interested to see, might help me as well with my own app
So I ended up having to use SystemProgram to create an account owned by the program I wanted to transfer lamports to, transfer lamports in the same instruction, and then pass the account as argument to the rpc call, from there I could do try_borrow_mut_lamports()
yeah - i've seen people do like create-react-app into it
client side app?
what is the `app` directory for?
There is no reason other than preventing creating a token account for something that isn't a valid mint. From what i see
https://github.com/solana-labs/solana-program-library/blob/master/token/program/src/processor.rs#L85-L87 here
Perfect. That makes sense. Thank you Mr. Pikachoo
you can't, the token program expects the account, not the pubkey alone
For 2), why not just do this to create the account like this:
```
#[account(
        mut,
        associated_token::mint = **offer.taker_mint**,
        associated_token::authority = *offer.offer_maker*,
    )]
    pub offer_makers_taker_tokens: Box<Account<'info, TokenAccount>>,
```
That way, we don't need to pass in `taker_mint` or `offer_maker`
Awesome thank you 🙏🏼
something i saw today that's pretty simple. Lines 3-8
https://gist.github.com/cqfd/ffbdebbbcd3460ec822c3e63572cc282#file-dumb-rs-L3
1) Yes, it constrains the address, a shorthand of the raw constraint. Maybe a `has_one = taker_min` on the offer account constraint would be more canonical, i tend to prefer has_one, it makes it clear all in one constraint on the program account
2) Creating a token account `offer_makers_taker_tokens`, requires the mint account `taker_mint`. This is required by the token program initialize_account cpi
3) same as 2.
https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo/src/lib.rs#L227

1) What is `address = offer.taker_mint` doing? Is that a short-hand for a constraint?
2) Why are we asking the user to pass in `taker_mint` if we already can access it via `offer.taker_mint`? 
3) ^ Same with `offer_takers_maker_tokens`. For this one, is it because we're making changes to the account, so Sealevel needs to know in advance?
Does anyone have any references for transferring lamports from a user to a program account?
Hit my goal today, thanks <@!134416332509675520>  and <@!903369685570035822>
Looks that tooling hasn't been developed in Solana yet
Hmmm, in my last job we used Postgres and could have the DB reset before each test
ohhh damn that makes sense
oh interesting
oh lol my b bad question
At any rate I just write tests however lol, don't read too much into them
And those are basically just declaring variables so I can reference them later in the other tests (their init part is async so I don't think I can do it in the top-level describe, since as far as I remember describe doesn't support async—though maybe it does?)
`beforeEach` unfortunately doesn't work for keeping the tests totally separate, because the validator maintains state between all of them (not like in a backend test where you maybe run each test in an isolated tx that rolls back after running the test)
<@!134416332509675520> 

https://github.com/cqfd/quidproquo/blob/main/tests/quidproquo.ts#L27

What's the benefit of keeping some initialization code (L15-L25) before the `before` statement? Why not just have it all in the `before` statement

Also, why didn't you use `beforeEach`? This way, you can ensure that your tests are completely separate
Programs I think have to be rent exempt in solana (no other option)
Ah, you need a `declare_id!` (try searching the anchor repo for examples)
It doesn't say so in the docs: https://project-serum.github.io/anchor/cli/commands.html#deploy
Does `anchor deploy` automatically make our program rent exempt?
this for anchor 0.19.0
do i need anything from `solana_program`?
i have `use anchor_lang::prelude::*;` in this particular file
what imports do i need for this?
am now running into issues with finding IDs (e.g. `cannot find value ID in the crate root`)

```
7 | #[account]
  | ^^^^^^^^^^ not found in the crate root
  |
```
Your program lives at an account too (which account depends on how you deployed—it might not be at your programId but rather at a PDA derived from it)
You can always fetch an account with `program.provider.connection.getAccountInfo(theAddress)` and then see how big its `.data` is
How do I calculate the size of (A) my program and (B) of of an account? I want to do:
`getMinimumBalanceForRentExemption(program.size())` and `getMinimumBalanceForRentExemption(account)`

More importantly, how could I have figured this out myself?
I'm looking for co-founders also
I'd appreciate that!
ill dm you i can give you a couple ideas as well
that's the move then, hit MVP then integrate with others
so apps dont have to integrate it directly into their code
you will really like railgun then. their vision it basically provide a front-facing anonymity tool that you can connect to any app
guess that's going back into the backlog for now lol
My use case is to shield publicly facing content creators.
but it's coming
anonymity on solana is something that is still not really a thing yet
guess i didnt think about that lol. but i think their target is Q1 next year
it's in development rn still, not released, and they havent shown the code yet
Is lava open source?
rail uses ZK-SNARKs and lava uses ZK-STARKs, which are superior
Zero-Knowledge proofs and such
yes
were you the guy i told about lava cash and railgun? if not, check them out, lava is solana native and rail is cross platform but they are doing a solana app
I was hoping it would be a couple hash functions  or something. Iwas told to checkout railgun, it's definitely possible; but I think you're right. It probably has to go through a whole layer of anonymizing transactions.
But eh I have no idea
Like, fancier crypto than asymmetric keys/hashing
I have no idea how to think about anonymity but fwiw I suspect it's hard
right
Someone can always snoop the explorer and put 2 and 2 together, etc.
So don't think this will work for anonymity, at least not very well
Mm, at the end of the day if you want to have some notion of authority you'll always have to pass both accounts to the instruction—the account itself *and* its authority, so your program can check the authority signed
My ideal scenario is that those unique usernames can't be traced back to that wallet
My first use case is have one wallet that can pay to open multiple unique accounts with unique usernames.
Or would anonymity have to go through like an anonymizing transaction layer?
Right now the users wallet is attached as the authority. If I exclude that authority pubKey and people try to fetch that account data, could they not see the pubkey and not know which wallet controls the account?
What do you mean?
Is exluding the authority a way of not being able to see who controls the account?
So you have to decide if you want to enforce that kind of access pattern etc.
(But in general if your program owns an account, it can mutate its data whenever it wants—authority stuff is just a matter of politeness/your program not being dumb, you have to implement it yourself)
perfect
```
#[derive(Accounts)]
pub struct Update<'info> {
    #[account(mut, has_one = authority)]
    pub fora_persona: Account<'info, ForaPersona>,
    pub authority: Signer<'info>,
}
```
Yeah, if you wanted to only let a certain user etc. update the account, then yeah, you'd need to add an `authority: Pubkey` or whatever field to it, and subsequently make sure that account signed the tx whenever it tries to update the account
```
    pub fn create(ctx: Context<Create>, username: String, bump: u8) -> ProgramResult {
        let fora_persona = &mut ctx.accounts.fora_persona;
        let authority: &Signer = &ctx.accounts.authority;
        let clock: Clock = Clock::get().unwrap();

        fora_persona.authority = *authority.key;
        fora_persona.username = username;
        fora_persona.timestamp = clock.unix_timestamp;
        fora_persona.bump = bump;
        
        Ok(())
    }
```
yes
The ForaPersona account?
to make it's state editable
would you attach an authority to make it editable?
sincerely thankful man I appreciate this
To say this a slightly different way, program-derived addresses are kind of deliberately *not* keypair addresses (they aren't public keys at all—they're deliberately constructed so that they don't have corresponding private keys at all)
And the program needs to know somehow what seeds to expect (usually bump too but the bump is derivable from the seeds if you're being lazy)
You still need to `findProgramAddress` on the client and pass in that address, but yeah, if it's a PDA then no keypair stuff
so I don't need to generate a keypair at all on the client side? Just send in the username and bump and then the PDA derives and signs it itself?
In this case, when creating that account, anchor understands that because you have `seeds = [...]` it needs to have the program sign for the address (creating an account requires that its address signs)
hmm
So not possible to sign for them from the client
Ah, you mean on the client? PDAs are funny in that they can only be signed for by their deriving program, from within the program itself
<@!134416332509675520> why don't I need a signer here?
yea that works lol
holy fuck 1 sec
Is your declare_id! correct? (Does it match the id printed in the program logs?)
Error: 167: The given account is not owned by the executing program
What was your question about signing about though?
```
     const programAddress = await anchor.web3.PublicKey.findProgramAddress(
        [Buffer.from(username)],
        program.programId
      );
```
would you recommend just bumping to the newest version
```
    // Create the new account and initialize it with the program.
    const tx = await program.rpc.create("ryan", new anchor.BN(bump), {
      accounts: {
        authority: provider.wallet.publicKey,
        foraPersona: foraPersona,
        systemProgram: anchor.web3.SystemProgram.programId,
      },
      signers: [],
    });
```
Mm, that's such an old version that I'm not sure how to help
should i be using the latest version?
running into these errors when trying to build anchor 0.10.0: `the trait bound Pubkey: BorshSerialize is not satisfied`
```
#[derive(Accounts)]
#[instruction(username: String, bump: u8)]
pub struct Create<'info> {
    #[account(init, seeds = [username.as_ref()], bump = bump, payer = authority, space = ForaPersona::LEN)]
    pub fora_persona: Account<'info, ForaPersona>,
    #[account(mut)]
    pub authority: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```
Sign when?
How would I sign it?
So then if someone tries to use the same string they'll get an account collision
You could init an account that lives at a PDA with that string (or maybe a hash of it) as its seeds
Any ideas on requiring a string to be unique? Like for a @username alias?
https://discord.com/channels/889577356681945098/889702325231427584/918588830012043324
I don't mind digging, that's totally fine! I'll take whatever you've got
I have some example programs you can look at if you want, but might be more in the weeds than you're looking for—not sure
https://www.brianfriel.xyz/how-to-create-a-token-on-solana/
Anybody got any good resources to read up (or watch) regarding tokens from a developer perspective? I'm looking to dig into ERC20 (and maybe 721) equivalent concepts in Solana, and my cursory understanding is that tokens are a fairly different beast on SOL vs. the EVM.
Couldn't remember if there was some other gotcha
personally i can work with non-data/system-owned ones, that's fine for my needs, but im willing to fund both conditions, or just the first, whatever works
Ah ok, that was the distinction
If there's data on the account then it's definitely not owned by the system program (if owned by the system program then it's "easy", otherwise hard)
i thought it had to do with account ownership
It's actually an additional complication whether there's data on the account or not (at least I think it is)
You want PDAs that have data to be payers and that's quite a bit more difficult!
whatever you think is fair x how long you think it will take
yeah mainly i just want PDAs to be able to pay for things
https://github.com/project-serum/anchor/issues/1120
Although it doesn't matter what program ultimately owns the PDA. In fact it's better if the executing program itself owns the account because then you don't need to do CPI to transfer lamports, so its compute cost is lower
In this situation though my requirement are different from yours. My thing involves including additional instructions for assigning space larger than the typical 10kb limit of PDAs. But still paying from a PDA payer account
I only build stuff for money that I was already going to make for myself
How much we talking!
and as i said before, im willing to fund any issues i create
well if you ~~nerds~~ fine gentlemen dont mind ill make an issue to track unless one's already been created
Ha, yeah
Really hard to keep the details straight with PDAs sometimes
Actually take that back about two CPI calls, it's two CPI calls for program owned PDA
It's a little annoying that it would take 2 CPI calls to system program instead of one to create the account. But I could definitely see myself adding this PDA payer functionality in the near future. If only to my own fork
Yeah
so you are saying add the functionality for being able to make system-program-owned PDAs as payers is easy(ish) but not so easy for program-owned PDAs
dude there's so much i'd like to add but im a dum
Yeh, exactly
Milk duds should really start getting very familiar with the constraints rust code so they can add lots of cool new PDA functionality!
Right, anchor would just have to realize "oh this payer has seeds = [...] on it, it's a pda"
It shouldn't be too hard to pass in the seeds and bump though since they're available
You need to be able to add the signature
😔 😔 😔
It doesn't yet know how to sign for them
Right, not currently, because anchor doesn't support PDA payers
Unlikely
later on
i mean `payer`
or sorry
meaning i can use that PDA as a value for `payer`?
Worth trying it though to see what happens
I think it will still glitch out over the ownership of the account though
Ah you're right
You can just send it money lol (it'll be automatically owned by the system program, and its PDAness means your program can sign for it)
If the account isn't going to store any data, you actually don't even need to init it
It defaults to the current program otherwise
You would have to set the owner as the system program
I'm actually not sure that works—also, do you even need to init an empty account like that?
No
because if that's the case i could probably work with that and not have to use data-holding program owned PDAs
So let me get this straight, if i do an account like this
```
#[account(
        init,
        payer = signer,
        seeds=["myseed".as_ref()],
        bump
    )]
cool_pda: AccountInfo<'info>,
```
then that account is owned by the system program and can later be used as a payer?
thx
im trying to see my options for other accounts paying for the data
https://discord.com/channels/889577356681945098/889584618372734977/915189998108676117
as with everything with my app, nothing is simple XD but basically when the tx submitter makes the tx, some of the data he creates is not really for his benefit, it's for another person's benefit, so yeah
Dumb question, but could the tx submitter just pay for the init?
hmm okay.. i could just have seperate accounts then, one for data and the other for storing my extra lamports
Not impossible, I can try to find a thread, but it's weirdly complicated (partially due to a solana bug)
So, is honestly quite tricky to get it to be able to pay
No, if there's data in there then its owned by your program
gotcha. when i define a PDA with such and such seeds and use it to store a `struct` of data like `User` or just an account with no specific data, are those owned by the system program?
Because the system program's `create_account` doesn't support it
I would try to design into the system you have available. Not sure why I find it so triggering. Probably because I want to do the same things but know they aren't all that straightforward
Having the payer be an account owned by your program is actually surprisingly complicated lol
Not in general (PDAness is independent of program owership), e.g. you can init a token account that lives at one of your PDAs
not manually 😦
when anchor `init`s PDAs, those are owned by the program right? those are the same ones i wanna send lamports to and define them as payers later
yes please ❤️ and i can make an issue as well
Manually of course
I've chatted with Alan before about the main ways this can be done. PDA with no data and owned by system program is one, and it's somewhat simpler. PDA owned by program (also with no data?) Is different but still doable
Yes but the PDA has to have no data in it and be owned by the system program
Ok, let me see how hard it would be to add this
Haha 😆
aaaaaaaa
This is something that might be easier to add to anchor though
then serialization manually
😭
That's the CPI you'll have to do manually
Right, I'm saying you'll have to do the init yourself
yeah but if you init an account, you have to define a payer up front
You'd want to use the lower-level program.connection.getAccountInfo(escrowedMakerTokens)
the output of `getAccountInfo` doesn't have any lamports-related fields except `rentExemptReserve`, which is null
`connection.getMinimumBalanceForRentExemption(theSpace)`
Rent-exemption is kind of sneaky, it's just about having enough lamports for your space
What do you mean? I'm saying you'd have to do whatever CPI requires payment yourself (with invoke_signed etc.)
I want to check manually in my program to practice / become good at Solana

I am checking if an account is rent-exempt by doing this:

```
const console.log(await makerMint.getAccountInfo(escrowedMakerTokens))
```

But I am not sure what field to check... `rentExemptReserve` is null.
how would this be done manually? if anchor pays for things up front before i cant do anything.
Mm, I don't think this currently works—it could work but anchor isn't quite smart enough to do it yet. (So, it's possible in solana to pay for stuff with a PDA, but anchor hasn't learned how to yet—you'll have to do it manually)
You could do it that way, or do some anchor source-diving to see where the rent-exemption is calculated
Yep, it'll be rent-exempt
can a PDA be defined as a `payer`?
How do I verify this using the anchor client? Like `const accountInfo = account.getAccountInfo(...)...?`
When we initialize an account like this, is it automatically rent exempt?
```
#[account(init, payer = ..., ...)
```
Did the Serum creators make anchor? What's all this dex code: `anchor/spl/src/dex.rs`
will try to check this 😄
I'm actually not sure now that I think about it how staking contracts show a continuously updating reward count 🤔 Like if you stake sol with lido
ok, big thx!
ah, increase counter in off chain software?
You would then have your program keep track of how much time has passed since they last claimed, etc.
You could also have the user perform the poking when they go to claim their rewards/unstake their thing
Possibly—it would be tough for the bot to update everyone's accounts (in solana you have to pass in every account relevant to a tx from the client!)
ok, understand. In general algorithm can be like this? User "stake" his tokens, program create pda and send this tokens to this account. Every N seconds bot call a program and we update counter in each staked pda? When user "claim" we send tokens from mint address (program has access to this acc) we send tokens to this pda?
(Or, well, sometimes its relevant, just not for whether a program can update an account—that depends on ownership)
PDA-ness is generally not relevant—the question is whether or not your program *owns* a given account (not the same thing as having *derived* a given address)
yes, i think about this, but think blockchain has more native method 🙂
got it. thanks!
interesting. And program can update any pda account?
easy way would be to just manually update it with a dev account
idk i just started on solana like 2 weeks ago but maybe trigger an update from the staking account to a rate adjuster contract when a new user is created then have the rate adjuster contract call an update rate function in the staking account, like a circular cross program invocation
Yep (for any solana program really)
is the recommended way to view rust logs for anchor?
holy moly thanks!! it works
In general you might need an off-chain program (a bot) to poke your contract now and then
`msg!` (if the test passes you'll have to look in `.anchor/program-logs/` for it)
is there anyway to println! in the rust program while you are testing using anchor test? 

I've tried println! but when i run anchor test, i don't see the print statements
but who will update another contract? 🙂 and run it
I'm pretty new also but I would just store a staking rate in state and then update that from another contract based on conditions
hey guys, maybe some ideas for this?)

My argument would be that these are just utility functions, you can still see who owns what wallet and how much money they are withdrawing/depositing from the dApp. You just wouldn't know what account their source of income is.
Of all the things that regulators plan to go after, anonymization stuff is top of their list
Can I hire you? lol
It does, just implicitly: https://github.com/project-serum/anchor/blob/master/ts/src/provider.ts#L109
why? KYC?
Anonymizing account ownership is bad
Why does `program.provider.wallet` not need to sign transactions during tests?
Hello devs! I'm a novice at solana contracts and have some stupid questions 🙂 I want to create a simple staking contract but can't imagine how to increase a reward counter per each user and change APY? Because program can manipulate with pda only when user create some instructions and interacte with program?
I haven’t looked closely but I think you should show this graph to some VCs and raise $10m with it
<@!903369685570035822> what's the complexity on something like this? Can I do it with a couple simple hash functions?
check out railgun and lava cash
when he posts complex algorithms in <#889702325231427584>  XD
Or perhaps this
Any thoughts on anonymizing account ownership?
This has some examples of interacting with the spl token program (also some PDAs in there): https://github.com/cqfd/anchor-token-studies, and this is a pretty heavily commented escrow program (related to how staking would work): https://github.com/cqfd/quidproquo
The staking example would be a generalization of this
You could maybe check out this repo: https://github.com/cqfd/anchor-visitors, it has an example of some per-user state stored in an account that lives at a PDA
not yet, kind of new to solana/rust in general but figuring things as i go
No built-in libraries as far as I know—have you looked much at program-derived addresses yet?
awesome, are there any builtin librarys or references you can point me to for this?
That means the staking account will have an "obvious"/guessable address that your frontend can calculate with `PublicKey.findProgramAddress`
For keeping track of the account, assuming it's per user + mint (or if it's an nft, maybe its just per-mint, since only once can be live at any given moment, etc.), you could store the staking account at a program-derived address with e.g. seeds = [user.key().as_ref(), mint.key().as_ref()]
You'll probably need a new staking account per user/mint/whatever, managed by your program
For 1. Idk how to init the program account size and for 2. I'm not sure how to keep track of the user accounts when calling the rpc endpoint from the client-side
sorry noob question here but I'm trying to implement staking with metaplex tokens. If I were to code it in solidity I would keep a mapping of structs to store each users staking data. Should I 1. store each users data within the associated program account or 2. Make a new staking account to hold a particular users data?
thanks! will take a look 🙏
This is a simple example of a program-controlled mint (sounds relevant to what you said): https://github.com/cqfd/anchor-token-studies
any help or guidance is appreciated it.
Hello people!
I am trying to create or implement  a simple token.
so far so good I found on your repo these two examples....
https://github.com/project-serum/anchor/tree/master/tests/swap --> i believe it is a good starting point to study.
https://github.com/project-serum/anchor/tree/master/tests/spl/token-proxy --> no idea what it does but has the name token on it 😂


//////////////////////////////////////////////////////////////////////////////////////////

I am not familiar myself, but I'd advise simply putting your questions out there, for your sake 😅
Anyone here familiar with the project-serum multisig source code? I love the implementation, and I have a couple of questions!
Found it, it is creating the account on the client first as you said. Many thanks!
So that means it already has space in it by the time it gets sent to the initialize_config function
Yeah, I don't see (yet) where they're actually `init`ing the config
Allocating in the client?
And not actually using Default to avoid specifying space
So they must be allocating the account in a separate instruction I guess
Ah, yeah, it does have a vec in there 🤔
Thanks! How they got away without specifying the size? The candy machine config has variable lines and the only reference to anything close to the data size requirements is the constraint `config.to_account_info().data_len() >= CONFIG_ARRAY_START+4+(data.max_number_of_lines as usize)*CONFIG_LINE_SIZE + 4 + (data.max_number_of_lines.checked_div(8).ok_or(ErrorCode::NumericalOverflowError)? as usize)`. I tried to add my field here, but then the client fails. I am not adding the fields directly to the struct, I am adding them to the borsh vec area to avoid having to deserialise them all at once.
for things like String/Vec, does Default just allocate 0 space?
It seems that candymachine uses `#[derive(Default)]` to skip having to specify `space`. If you want to add more fields in there and they're variable-length (e.g. a String, or a Vec), Default won't give you the right amount of space and you'll have to specify space manually with `space = ...`.
~~What language is that? 🤔~~ And why don't you know how long the string is?
Alright... so i'm trying to make an instruction to an anchor program in the same transaction as an instruction to a non-anchor program. I create the struct in python, however my initialize takes a pda. so i need to pass it the bump and string, but I'm unsure how 'long' the string is. My understanding is it'll be like this:

```python
INITIALIZE = construct.Struct(
    "variant" / _Sighash(), "bump" / DecimalAdapter(1), "str_len" / DecimalAdapter(4), "str" / ?????Adapter(?)
)
```

any ideas?
Hi! I am trying to create a custom candy machine (forked from metaplex) where the Config struct stores more information. At the moment I cannot figure out how I can increase the space requirement for the account. I can see the macros `#[account(mut, constraint= config.to_account_info().owner == program_id && config.to_account_info().data_len() >= CONFIG_ARRAY_START + 4 ...]` which I believe is where the size of the account data is specified, but I don't seem to be able to increase its value. When I try to initialize the config account, I get an error `Error deploying config to Solana network. ProgramError: 143: A raw constraint was violated`. Any ideas?
so like you would put `zero` on top of this token account, if you wanted to create a token account that had an external signer / the account was already created but not initialized by token program
ah right. I always imagined that the purpose of `zero` was to make sure an account was empty before you initialized it with some data
I don't think so—zero checks if the first 8 bytes are zero, which I think wouldn't make sense for token accounts (they don't have discriminators at all). I guess it might not error if you've allocated the 165 bytes for the token account in a previous instruction though, but not sure what zero is adding
like zero + init tokens
works?
going to test this out now for a video but in advance, does anyone know if 
```
#[account(
  zero,
  token::mint = mint,
  token::authority = authority
)]
  this_token: Account<'info, TokenAccount>
```
program.account.accountName.fetch(publicKey) works for what I need
.decode only gives me the Buffer. How can I deserialize the data?
`.decode` in the anchor TS library should help
How can I deserialize data recieved from getAccountInfo RPC endpoint if the data was serialized by Anchor?
Loading up the confirmed transaction is an RPC call, and you have the transaction id from the RPC call that sent the transaction
You have to load up the confirmed transaction and inspect the program logs if you want to return data to the client
yes from what I know of and seen until now
other than `Ok(())`?
so, a program handler can never return some info to the client?
AFAIK we can't return something from contract
I dont really care to store this value in an account
the return is just showing a transaction id
is there any way to get the value returned back from an rpc call from my smart contract?
thanks mate!
`new anchor.BN(1639181611)` for u64
I'm struggling with understanding how to pass values to the handlers
```rs
#[program]
pub mod test_anchor {
    use super::*;
    pub fn initialize(
        ctx: Context<Create>,
        authority: Pubkey,
        start_time: u64,
        end_time: u64,
        start_price: u64,
        reserve_price: Option<u64>,
    ) -> ProgramResult {
```
doing something like this is obviously failing
```js
    // const tx = await program.rpc.initialize({});
    const tx = await program.rpc.initialize(
      program.provider.wallet.publicKey,
      1639181611,
      1641021206
      // etc...
    );
```
Am I supposed to pass in objects?
Yeah, can presumably do all that in one program
Just gotta jump to source currently
<@!134416332509675520> I suppose "start up" is the wrong language (I'm a full-stack dev), it would be a project that creates the auction account and also a token account, yea?
This may be a dumb question, but where do I look up documentation for anchor constructs like Transfer() function?
i.e. the token account that it is selling
and this can all be done in the same project space? Basically, it'd be nice to have a program that starts the auction up (I'm creating an auction) and also starts up the token account.
appreciate this direction you're givine me
oh interesting
You'd do a similar thing for this token account holding the 1 token
The example I posted above gives the program control over the mint by making the mint's authority a program-derived address (only the program can sign for its program-derived addresses—hence giving the program authority over the minting process)
Ok, this'll be a good exercise then
I watched a video that mentioned that, but I wouldn't say I fully understand them.
Have you read up on program-derived addresses yet?
And when someone calls claim, you take some sol and transfer the token to them (presumably the whole tx fails if the token has already been claimed)
But if you want a single claimable token, then you could have your program have authority over a single token account with 1 token in it
Either way is fine—the example I posted above could be tweaked pretty easily to make the `airdrop` call requires sol
...or whatever is simpler
for this example I think I'd just want one singular token.
Or can someone keep calling claim and passing in more sol?
By token do you mean mint here? Like, a single brand of token? How many individual tokens will there be—only only one?
<@!134416332509675520> can I run by what I *think* has to happen for my program? I'm basically building a simple proof-of-concept. 

Basically, I want my account to create a token upon initialization

then I am creating a `claim` endpoint, which anyone can call.

`claim` will check that it has received a certan amount of Sol and then will transfer ownership of the token to whoever gave the Sol. And then it will mark the token as "sold".

Seem reasonable?
but I appreciate the tips
I'm into that
But yeah, currently there aren't many docs at all—you're going to have to get used to source-diving 🤿 😁
oh awsome
For transferring ownership, you would use the `anchor_spl::token::set_authority` call, which should be relatively straightforward if you work through some other examples
I'll check that
I have a bit, but some of them are rather robust. I'm a relative beginner and I'm trying to build a super simple proof.
Here's an example of a program-controlled mint, fwiw: https://github.com/cqfd/anchor-token-studies
Do you mean anchor documentation? Kind of doubt there is any yet tbh. Have you looked through the anchor tests?
Could someone point me to the up-to-date documentation on how to create tokens and transfer token ownership?
I don't think there's an issue 🤔 but not 100% sure, so probably better to just do the seeds check haha
The thing I'm a little worried about is something like this: https://gist.github.com/jstarry/ab03017fa05b7352261115c9bd5cfc4e
ah yeah ur right, the offer isn't signing anything. We're just using the offer to calculate the PDA
I guess I just mean that the program itself is trying to sign for one of its PDAs, whose seeds happen to be based on the offer (the offer itself isn't really signing anything)
But yeah maybe we're saying the same thing
"sign for" is wrong, it should be "sign the transaction"
The program itself is what is signing here: it says, ok, I will try to sign for the escrowed_make_tokens' address
What do you mean by sign for here? I think we might be on the same page but the language you're using is slightly confusing to me 🤔
But (the thing I need to think about), the `invoke_signed` api is slightly dumb and doesn't require you to be specify exactly which thing you're signing for: you just chuck seeds+bumps into that api and it will match them against the accounts
so the passed in `offer` must be able to sign for TokenAccount `escrowed_maker_tokens`
what u said
yeah
it's because you used the `ctx.accounts.offer` bump and seeds to calculate the PDA
The thing I need to think through a bit more is that the way the program signs for the escrowed_maker_tokens is via those seeds, which are based on the `offer`
ohhh i see
oh thanks for the correction

the signer must be the authority of  the TokenAccount`escrowed_maker_tokens`. The authority of `escrowed_maker_tokens` is `escrowed_maker_tokens`, as seen by https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo/src/lib.rs#L180

I don't get why it fails if there's a different offer, then
Maybe I'm misunderstanding what you wrote though 🤔
Ah, no—the signer here is the authority over the escrowed_maker_tokens, which happens to be its own address
I think you're almost right:

The authority comes from `escrowed_maker_tokens`, yes. 
So the signer must have ownership over `escrowed_maker_tokens`. 
The signer must be `escrowed_maker_tokens.offer`, then. No other offer will work
Interesting. Will test it out! Thanks for the help!
Yep
So take the `basic_1` example in the tutorial, say I want to log the time when the account is initialized:

```
pub fn initialize(ctx: Context<Initialize>, data: u64) -> ProgramResult {
        let my_account = &mut ctx.accounts.my_account;
        my_account.data = data;
        Clock::get()?.unix_timestamp; -----> I just add the function call here?
        Ok(())
    }
```

Is this a correct use of the clock?
(Sometimes you still do, if you're invoking some other program via CPI and it expects you to still pass it as an account)
Currently you can actually just do `Clock::get()?.unix_timestamp` etc., no need to pass it as an account anymore
Quick question: How do I incorporate a `sysvar: clock` into a program? I would like to see a minimum working example if it's possible. Thanks in advance!
Does that mean the crucial bit is here (l. 76++)?
```rust
                    authority: ctx.accounts.escrowed_maker_tokens.to_account_info(),
                },
                &[&[
                    ctx.accounts.offer.key().as_ref(),
                    &[ctx.accounts.offer.escrowed_maker_tokens_bump],
                ]],
```
the authority comes from the `escrowed_maker_tokens` account provided in the instruction (could be any offer the caller chooses to provide), but the signature uses `escrowed_maker_tokens_bump` which is tied to the offer account? Hence both need to match or it fails
custom program error: 0x1
https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo/src/lib.rs#L206

We do not need to make sure that the `escrowed_maker_tokens` is derived from the PDA of `offer`, because the transfer function (L67) would fail if `escrowed_maker_tokens` was not owned by the signer. The `offer` needs to sign for `escrowed_maker_tokens`, but it can't do that if it's not the owner
<@!912046857000194158> I'm still curious about the specific reason why you believe it is not needed, if you'd like to share?
oh okay cool 🙂
Anchor now has a SystemAccount<'info> you can use for that if you want
so I could store user public keys for users in program, call the program from client side to get the list of users and use those keys to get account infos, then pass all the account infos into a distribution function?
but that error'd out
hmm, ok, ill just do that for now. At first i thought it was `Account<'info, SystemAccount>`
yeah I think so
how does one express a regular solana account owned by the system that someone uses to store lamports. just `AccountInfo<'info>` right ? (no, it's not a signer)
I figured this was the case <:KEKW:716296709793251359>
So if you want to send a list of people some tokens, you gotta pass every one of them in from the client as an account 😬
Ah, you in general can't deserialize an AccountInfo—the only way to get an AccountInfo is by passing it in from the client as an account
I'm working on an airdrop program to learn, and I'm trying to collect a list of users to send SPL tokens to, but SPL token transfer CPI calls require AccountInfos
yeah, like state is stored in a struct. AccountInfo defined in one of those structs gives ```the trait `BorshDeserialize` is not implemented for `anchor_lang::prelude::AccountInfo<'_>```
Yep, that's a good observation—I'm not 100% sure I need that change, will have to think about it some more
What part specifically would make it fail, if someone where to input another `escrowed_maker_tokens` (e.g. with higher value tokens in it)?
You mean store on file?
save?
is there any way to save account info in anchor rust?
<@!134416332509675520> 
https://github.com/cqfd/quidproquo/commit/14c44d0b6cbb9579ece6fc44dff2b44f8e1f8282

Hmm alan why'd u add this? Even without this change, "Accept" would fail because the `offer` can't sign for another `escrowed_maker_tokens`.
ohh i didnt realize it was a rust think. I kept typing in "anchor solana" lol
?
https://doc.rust-lang.org/std/boxed/struct.Box.html
One more question about ur escrow program <@!134416332509675520> , What is `Box<...>?`
https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo/src/lib.rs#L219

I  can't find anything online about it
I've written down a ton of notes / comments
I've learned so much from taking apart every line of ur escrow program
Gotcha, thanks so much alan


//////////////////////////////////////////////////////////////////////////////////////////

hello guys. i was confused in rust and solana. its really cool and i like that. i want to learn anchor by creating an program with this struct: for ex: we have a token named A and my program named B. a user holds x amount of A token in B program then the program returns x*2 token to user after 24H. anyone have a roadmap or example for me?
Hello, I was wondering, can Solana programs hold tokens (native SOL for example) like Ethereum Smart contracts? If yes, how so? (any links appreciated, can't find anything that relevant)
As a follow-up, if they do keep the private key, are they able to modify the data in the account?
Awesome, thanks!
or anchor deploy redeployes it again ?
How do people update a program already deployed on mainnet. Does this command will be of use to update an existing deployed program on mainnet :

```anchor upgrade <target/deploy/program.so> --program-id <program-id>```
You're changing the balance of an account in your instruction, so it needs to be marked as mutable <@!454291700945387520>
Hey 🙂 
Anyone ever closed an account using anchor ? Unsure how i can use this method from an account info https://docs.rs/anchor-lang/0.19.0/anchor_lang/prelude/struct.Account.html#method.close
Nope! If the account is owned by your program then that address won't need to sign again unless you make it.
do we need to keep an account's private key around if we never expect it to sign anything? i.e. I want users of my program to create a large account to hold items in a queue and set the owner of that account to my program. that account will then be given in my program's instructions. do the users of my program need to keep the public key of that account around for any reason?
Yeah, I just came across https://github.com/project-serum/anchor/issues/945, I changed the `test` script to `yarn ts-mocha ...` and it worked! 😄

Thank you <@!134416332509675520>
You need to have `ts-mocha` isntalled. Depending on which version of anchor you're using, you'll need to install it globally, or maybe just running `yarn` inside your project will install it
Also, my test script for typescript seems to be error-ing out for me with this, 
`Failed to run test: ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts: No such file or directory (os error 2)`
It seems to be working now, but I'm not sure what I was doing differently initially then ?
Mm, get rid of the & in your instruction argument: `tags: Vec<String>` instead
```
 pub fn add_question(ctx: Context<AddQuestion>, title: String, content: String, tags: &Vec<String>) -> ProgramResult {
        let question: &mut Account<Question> = & mut ctx.accounts.question;
        let author: &Signer = &ctx.accounts.author;
        let clock: Clock = Clock::get().unwrap();

        // VALIDATION
        if title.chars().count() > 100 {
            return Err(ErrorCode::TitleTooLong.into());
        }

        if content.chars().count() > 256 {
            return Err(ErrorCode::ContentTooLong.into());
        }

        if tags.len() > 5 {
            return Err(ErrorCode::TooManyTags.into());
        }
        else {
            for tag in tags {
                if tag.len() > 20 {
                    return Err(ErrorCode::TagTooLong.into());
                }
            }
        }

        question.author = *author.key;
        question.timestamp = clock.unix_timestamp;
        question.title = title;
        question.content = content;
        question.tags = *tags;

        Ok(())
    }
```
This is my whole function
I tried passing `&Vec<String>` and then doing, `question.tags = *tags` but then I got this error,

`'&' without an explicit lifetime name cannot be used here`
Still the same error :/
Try `tags.clone()` maybe?
In an Anchor instruction function, such as below
`pub fn add_question(ctx: Context<AddQuestion>, title: String, content: String, tags: Vec<String>) -> ProgramResult`

I'm trying to do,
```
question.author = *author.key;
question.timestamp = clock.unix_timestamp;
question.title = title;
question.content = content;
question.tags = tags;
```

And it gives me the error, 
`use of moved values 'tags'`

Any help please?
I found that spl_token::approve is not widely used as in the solidity.
Rather than using approve, many programs prefer tranferring to PDA, i.e. when implementing escrow.
Is this because of design choice or just convention?
Could make a PR if you want!
Might just not exist yet (doing the CPI call yourself though shouldn't be too tricky though)
I can't find the anchor-equivalent of spl_token::revoke. 
Is there any reason not supporting the revoke instruction if there is really no instruction of anchor_spl::revoke?
all this time i was debugging my rust programe 😬.

Thank you again.
<@!134416332509675520> this works. Thanks a lot. Now I feel bad wasting 2hrs trying to figure it out of my own instead of coming here earlier.
😉
ohh wait
just `anchor.BN(0)`
await program.rpc.upvoteGif(anchor.BN(0), {
    accounts: {
      baseAccount: baseAccount.publicKey,
      user: provider.wallet.publicKey,
    },
  })
Are you doing `new anchor.BN(0)` or just `anchor.BN(0)`?

but now i'm getting this error
Hey, thanks for the help. I've been trying to debug it for 2-3 hrs. Thanks a lot.
u64s and up in rust have to be passed as anchor.BN (big numbers)
The error message isn't great (honestly, we should fix this), but you'll need to do `new anchor.BN(0)` there instead of just passing the `index` arg as `0`.
but I'm getting error: `TypeError: src.toArrayLike is not a function`
I'm using it like this in anchor

```await program.rpc.addGif('https://media.giphy.com/media/kvSp97J1kBVqo/giphy.gif', {
    accounts: {
      baseAccount: baseAccount.publicKey,
      user: provider.wallet.publicKey,
    },
  })

  account = await program.account.baseAccount.fetch(baseAccount.publicKey);
  console.log('👀 GIF Count', account.totalGifs.toString())

   // Access gif_list on the account!
  console.log('👀 GIF List', account.gifList)

  await program.rpc.upvoteGif(0, {
    accounts: {
      baseAccount: baseAccount.publicKey,
      user: provider.wallet.publicKey,
    },
  })

  await program.rpc.upvoteGif(0, {
    accounts: {
      baseAccount: baseAccount.publicKey,
      user: provider.wallet.publicKey,
    },
  })
  await program.rpc.upvoteGif(0, {
    accounts: {
      baseAccount: baseAccount.publicKey,
      user: provider.wallet.publicKey,
    },
  })```
Hey, I'm new to rust.

I've made a vector. I just need too change the value of an element in the vector. Each element is basically a struct. How to change the value of field of a struct in a vector in rust?

```
pub fn upvote_gif(ctx: Context<AddGif>, index: u64) -> ProgramResult {
        let base_account = &mut ctx.accounts.base_account;
        base_account.gif_list[index as usize].upvote += 1;
        Ok(())
    }
```
ran into an issue with `anchor test`

What I did:
1. `anchor init mysolanaapp` 🆗 
2. cd mysolanaapp 🆗 
3. anchor build 🆗 
4. solana-test-validator 🆗 
5. anchor deploy 🆗 
6. anchor test ⛔ 

`anchor test` throws exceptions (see more details at the bottom)

```
$ /Users/yiksanchan/source/yiksanchan/mysolanaapp/node_modules/.bin/mocha -t 1000000 tests/

/Users/yiksanchan/source/yiksanchan/mysolanaapp/node_modules/ws/lib/websocket-server.js:136
  /**

SyntaxError: Invalid or unexpected token
```

Any help?
You can definitely run anchor in the browser, but you'll have to use some webpack-y bundler thing, yeah.
The bulk of the deployment cost is space for your program's code, yeah. The exchange rate for rent exemption is 7 sol / mb, and the upgradeable bpf loader deployment process (the default) reserves 2x your program's code size so you can upgrade it in the future.
Post it in <#889606719829835816> too 🙂 (Also, make sure to delete the large preview boxes lol)
It’s outputs when you run the test
oh cool, how do I access the transaction logs?
is it required to implement tokens and an escrow process to transfer sol between two accounts?
As there's no current browser build for anchor (please do point me in the right direction if there is one), I'm trying to decode the data manually. Does anyone have any tips or example code of them doing it themselves? 

Currently, I'm trying to piece it together from here: https://github.com/project-serum/anchor/blob/fcb07eb8c3c9355f3cabc00afa4faa6247ccc960/ts/src/coder/state.ts
Then it’s consoles that in transaction logs
You could use {!msg(variable); variable}
while building out the rust programs
`anchor test` doesn't run that info.
is it possible to get `println()` information?
Why is the `UnixTimestamp` attribute on the Solana clock an `i64` and not a `u64`? https://docs.rs/solana-program/1.6.2/solana_program/clock/type.UnixTimestamp.html
looking into tokens now
I understand it costs about 2.6 SOL to permanently deploy a program on main net. I’ve also heard that’s about equal to the price to deploy something for 2 years (if it was “pro rated” compared to shorter period cost). 2 years is ~700 days.
Does that mean that if I only wanted to deploy something to main net for 1 week, at current values, that would cost me about $5?
perhaps this is the way
appreciate the help
`use anchor_spl::token::{self, CloseAccount, Mint, SetAuthority, TokenAccount, Transfer};`
check out this.
https://hackmd.io/@ironaddicteddog/anchor_example_escrow#:~:text=token%3A%3Atransfer(%0A%20%20%20%20%20%20%20%20%20%20%20%20ctx.accounts.into_transfer_to_initializer_context()%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20ctx.accounts.escrow_account.taker_amount%2C%0A%20%20%20%20%20%20%20%20)%3F%3B
got the go somewhere but ;
yea!
So, the `get_current_price` fn is giving me trouble, so I just changed it to a flat value of 1000.
but now it's giving me this error:
```
     Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: instruction spent from the balance of an account it does not own
```
I feel it's probably related to how I've set up the signers/owners of my accounts
🎉
now that you point it out
makes sense
nice, thanks
```rs
#[derive(Accounts)]
pub struct Claim<'info> {
    #[account(mut)]
    pub auction: Account<'info, Auction>,

    #[account(mut)]
    pub authority: AccountInfo<'info>,

    #[account(mut)]
    pub purchaser: Signer<'info>,
}
```
`#[account(mut)]`
basically whatever you're going to mutate needs
check the addProposal one from mine for example
https://github.com/Necmttn/anchor-voting/blob/master/anchor-voting/programs/anchor-voting/src/lib.rs#L97-L98
but you derive authority account as not mutable
you're mutating the authorities balance


founded
https://docs.solana.com/implemented-proposals/readonly-accounts
I'm reading this
yes
is the first test case passes ?
the error I'm getting is
```
Transaction simulation failed: Error processing Instruction 0: instruction changed the balance of a read-only account 
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS invoke [1]
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS consumed 3774 of 200000 compute units
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS success
    failed to verify account BGRVd3Wphe5apC6hvLZW5jZeyfiRR2VMJbiqYb4GaPot: instruction changed the balance of a read-only account
Translating error SendTransactionError: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: instruction changed the balance of a read-only account
    at Connection.sendEncodedTransaction (/Users/ajtj/rust_projects/test_anchor/node_modules/@solana/web3.js/src/connection.ts:3689:13)
    at processTicksAndRejections (internal/process/task_queues.js:95:5)
    at Connection.sendRawTransaction (/Users/ajtj/rust_projects/test_anchor/node_modules/@solana/web3.js/src/connection.ts:3649:20)
    at sendAndConfirmRawTransaction (/Users/ajtj/rust_projects/test_anchor/node_modules/@solana/web3.js/src/util/send-and-confirm-raw-transaction.ts:27:21)
    at Provider.send (/Users/ajtj/rust_projects/test_anchor/node_modules/@project-serum/anchor/src/provider.ts:114:18)
    at Object.rpc [as claim] (/Users/ajtj/rust_projects/test_anchor/node_modules/@project-serum/anchor/src/program/namespace/rpc.ts:24:23) {
  logs: [
    'Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS invoke [1]',
    'Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS consumed 3774 of 200000 compute units',
    'Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS success',
    'failed to verify account BGRVd3Wphe5apC6hvLZW5jZeyfiRR2VMJbiqYb4GaPot: instruction changed the balance of a read-only account'
  ]
}
```
hm
maybe anchor's not working
but this method comes from `"@solana/wallet-adapter-react";`
checkout how i use the balance in front end user
https://github.com/Necmttn/anchor-voting/blob/master/components/requestAirdrop.tsx
yea, I wonder where the account was designated as `read-only`
it's a odd error
Question: I need to do validation on an account that conditionally _doesn't exist_. Is there a way to run this validation conditionally, or do I need to split this functionality out into two RPC calls (one where the account needs to be specified since it exists, and one where it doesn't need to be specified since it doesn't exist)?
<@!234375765104394240> this would be where I started making these transactions
Can you show me the code a bit ?
Hmm, must be because I'm changing the providers balance maybe, I dunno
<@!234375765104394240> you ever deal with this?
```
Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: instruction changed the balance of a read-only account`?
```
nice
` await provider.connection.getBalance(newUser.publicKey);`
I've been strugglign trying to figure this out for a while, thanks! Do you know how to check the balance of the newUser?
Great example. I'm curious if there's anything I need to pay extra attention to when using anchor with Next.js
https://anchor-voting.dapp.necmttn.com/ you can play with it here.
normally the provider.wallet is loadded with 1000 sol when you testing in `localnet` but new keypair is comes empty so need to fuel the tank first 🙂
yeap
this is excellent
is this how you give a keypair account money to spend?
```ts
const newUser = anchor.web3.Keypair.generate();
  before(async () => {
    const signature = await program.provider.connection.requestAirdrop(
      newUser.publicKey,
      1 * LAMPORTS_PER_SOL
    );
    await program.provider.connection.confirmTransaction(signature);
  });
```
checkout this; 
https://github.com/Necmttn/anchor-voting

https://github.com/Necmttn/anchor-voting/blob/master/anchor-voting/tests/anchor-voting.ts
https://github.com/Necmttn/anchor-voting/blob/master/anchor-voting/programs/anchor-voting/src/lib.rs
<@!234375765104394240> do you know how to create a PDA account?
thank you
`    await provider.connection.getBalance(provider.wallet.publicKey);`
`provider.connection`  has a method for `getBalance`
how do I check the balance of the `provider.wallet`?
alpine's & livewires  <@!423148715948244994> ?  welcome on board 🖖
thats about how much it cost me, but i do think it depends on the program size. not sure. I also think that you can get it back if you destroy the program
I was trying to get a ballpark of how much SOL it takes to deploy a program. From my limited research it seems I'll need 2.6 SOL to deploy a program on mainnet (I could very well be wrong though)
guess i just needed more money. Damn is it expensive to deploy programs lol
hm deployment to devnet seemed to go fine, but when deploying to mainnet, i got an error: 
```
Error: Deploying program failed: Error processing Instruction 1: custom program error: 0x1
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }.
```
ty sir!
that should do it!
Ok, I just got past it by changing from 0.18 to 0.17 in programs/x/src/Cargo.toml

Also run "cargo clean" and remove the Cargo.locks files from your project's root
i'm stuck on this as well, any help would be appreciated 🙂
Hey folks, anyone hit this error?

I'm brand new to Rust/Anchor and just followed all the happy-path setup instructions to get an anchor project going and can't get past this.

I've gone through the whole process on a friends computer, same thing.

I think I'm officially out of ideas lol - anybody see something I don't here?

(seems to be related to this PR maybe? https://github.com/project-serum/anchor/pull/1030)
Cool!
it worked 🙏 🙏 🙏
And yes lol, it'll work 😛
You can import the ForaPersona type from your other program (see basic-3 for how to do this)
if that just works that would be amazin
Ok, I'm saying rather than passing `author_alias: Pubkey` as an instruction argument, pass it as an actual account:
```.rs
    #[account(constraint = author_alias.authority == author.key())]
    pub author_alias: Account<'info, ForaPersona>,
```
any idea what `custom program error: 0x1` means?
yes
Is the `author: Signer` in that call the same thing that has authority over the ForaPersona account?
the authority would still be theirs, but they could attach anyones username to it if they wanted
yes
Inside `send_short_text`?
Hence the need for hacky BigNumber stuff
Someone could post under anyones alias.
Javascript numbers are doubles and can only support integers up to 2^53, so not quite big enough for u64s or bigger in rust
got it
The `program.rpc` part does, definitely
It's a BigNumber
And no, anchor.BN has nothing to do with sending the data to the server 🤔
It's just an aesthetically pleasing number, that's all
Can you try one more time to explain what's not working above? I feel like I'm so close to understanding and it's killing me haha
Hey guys can you guys help me understand what the relevance of anchor.BN(1234)? I just wanted to know if this "1234" has any form of meaning to it, or if its just arbitrary. I am aware that anchor.BN is sending the data to the server using rpc nodes, is that correct?
thank you so much though
no i think i just have to hack on it and find my way out of the dark here
Lol, ok, I think I'm just confused about what we're both confused about—is your problem fixed? 😆
lol idk either seemed relevant at the time
Ok—not sure what that implies though haha
This Persona PDA is being generated from a username string so it guaranteed the username is unique.
You're doing that in the creation call
I think I'm still confused about what you're trying to do, why can't you just pass both accounts, the fora_persona one as well as its `.authority` account?
oooh
Right, PDAs don't have private keys
But that account could sign if have the fora_persona sign for it as one of its PDAs, and cross-program invoke the other program
it is a PDA though, there is no private key?
You'd have to pass it along with its actual authority
fuck
Ok, then you're right, that won't be enough (it can't sign from the client)
yes it is pointing to the ForaPersona account
And then the authority would sign
If it's pointing at the ForaPersona account, then you'd need to pass *both* the ForaPersona account as well as its authority
Ah, I'm confused—what is author_alias pointing at?
Even if it is a PDA and has no privateKey?
In the top function when you are creating shortText

```
    pub fn send_short_text(ctx: Context<SendShortText>, topic: String, content: String, author_alias: Pubkey) -> ProgramResult {
        let short_text: &mut Account<ShortText> = &mut ctx.accounts.short_text;
        let author: &Signer = &ctx.accounts.author;
        let clock: Clock = Clock::get().unwrap();

        if topic.chars().count() > MAX_TOPIC_CHARACTERS {
            return Err(ErrorCode::TopicTooLong.into())
        }

        if content.chars().count() > MAX_CONTENT_CHARACTERS {
            return Err(ErrorCode::ContentTooLong.into())
        }

        short_text.author = *author.key;
          //////// HOW TO KNOW author_alias.authority === author.authority
        short_text.author_alias = author_alias;

```
No that seems fine
So passing it as an account is strictly more powerful.
You can still get access to its pubkey with `ctx.accounts.author_alias.key()` etc.
^ does that spark anything or seem off?
Ah, ok—the trick is to not pass that as an *argument*, but as an account, and make it be a Signer.
The `author_alias: Pubkey` argument?
Sorry, trying to read your code—in which part do you want to verify this?
Cuz right now you can attach any account as an alias
But how to verify that the signer is the authority on the PDA?
And I am attaching that PDA pubkey as an alias to the shortText Account
Alright, this is the full scope and it's tested and working. So I am creating a PDA from a username seed.
```

#[program]
pub mod fora_persona {
    use super::*;

    pub fn create(ctx: Context<Create>, username: String, bump: u8) -> ProgramResult {
        let fora_persona = &mut ctx.accounts.fora_persona;
        let authority: &Signer = &ctx.accounts.authority;
        let clock: Clock = Clock::get().unwrap();

        fora_persona.authority = *authority.key;
        fora_persona.username = username;
        fora_persona.timestamp = clock.unix_timestamp;
        fora_persona.bump = bump;
        
        Ok(())
    }

    pub fn update(ctx: Context<Update>) -> ProgramResult {
        let fora_persona = &mut ctx.accounts.fora_persona;
        Ok(())
    }
}

#[derive(Accounts)]
#[instruction(username: String, bump: u8)]
pub struct Create<'info> {
    #[account(init, seeds = [username.as_ref()], bump = bump, payer = authority, space = ForaPersona::LEN)]
    pub fora_persona: Account<'info, ForaPersona>,
    #[account(mut)]
    pub authority: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```
```

    it('Can attach an account alias', async () => {
      // Generate a Persona PDA from username
      await createPersona("some-wallet-alias")

      // PDA always has same address
      const [personaAddress] = await derivePersona("some-wallet-alias")

      // Call the "SendShortText" instruction on behalf of this other user.
      const shortText = anchor.web3.Keypair.generate();
      await program.rpc.sendShortText('solana', 'Yay Low Fees!', personaAddress, {
          accounts: {
              shortText: shortText.publicKey,
              author: program.provider.wallet.publicKey,
              systemProgram: anchor.web3.SystemProgram.programId,
          },
          signers: [shortText],
      });

      // Fetch the account details of the created shortText.
      const shortTextAccount = await program.account.shortText.fetch(shortText.publicKey);

      // Ensure it has the right data.
      assert.equal(shortTextAccount.author.toBase58(),  program.provider.wallet.publicKey.toBase58());
      assert.equal(shortTextAccount.authorAlias.toBase58(),  personaAddress.toBase58());
      assert.equal(shortTextAccount.topic, 'solana');
      assert.equal(shortTextAccount.content, 'Yay Low Fees!');
      assert.ok(shortTextAccount.timestamp);
  });
```
```
#[program]
pub mod fora_short_text {
    use super::*;
    pub fn send_short_text(ctx: Context<SendShortText>, topic: String, content: String, author_alias: Pubkey) -> ProgramResult {
        let short_text: &mut Account<ShortText> = &mut ctx.accounts.short_text;
        let author: &Signer = &ctx.accounts.author;
        let clock: Clock = Clock::get().unwrap();

        if topic.chars().count() > MAX_TOPIC_CHARACTERS {
            return Err(ErrorCode::TopicTooLong.into())
        }

        if content.chars().count() > MAX_CONTENT_CHARACTERS {
            return Err(ErrorCode::ContentTooLong.into())
        }

        short_text.author = *author.key;
        short_text.author_alias = author_alias;
        short_text.timestamp = clock.unix_timestamp;
        short_text.topic = topic;
        short_text.content = content;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct SendShortText<'info> {
    #[account(init, payer = author, space = ShortText::LEN)]
    pub short_text: Account<'info, ShortText>,
    #[account(mut)]
    pub author: Signer<'info>,
    #[account(address = system_program::ID)]
    pub system_program: AccountInfo<'info>,
}

#[account]
pub struct ShortText {
    pub author: Pubkey,
    pub author_alias: Pubkey,
    pub timestamp: i64,
    pub topic: String,
    pub content: String,
}
```
`/Users/new/.local/share/solana/install/active_release/bin/cargo-build-bpf`
What do you get if you say `which cargo-build-bpf`?
there is that file there yes
let me check, thanks for your help
What my cargo setup does is realize that in my from-source solana install (not the installer thing you did above), there's a solana/bin directory with an executable in there, cargo-build-bpf
Do you have a `cargo-build-bpf` file inside /Users/new/.local/share/solana/install/releases/1.8.6/solana-release/bin/ ?
Oh, got it
that's what is in the output above. but I did a search and see that it should just be a symlink to /usr/bin/cargo...
How did you figure out that anchor test uses that cargo?
Basically some account you're trying to use doesn't have any sol in it
ok, I notice that `/Users/new/.rustup/toolchains/bpf/bin/cargo` is where `anchor test` invokes cargo in the output, but `which cargo` points to `Users/new/.cargo/bin/cargo`, for instance I can run `cargo build` in that directory just fine
What does solana config get say though?
https://api.devnet.solana.com
Which network are you running the script against?
like 30 sol
`solana config get`
yeah
Does your local solana keypair have any money in it?
That's an actual real solana error
Although when I am successfully able to run the deploy
I keep getting this error
Attempt to debit an account but found no record of a prior credit.
Try passing the extra arg `--dns-result-order=ipv4first` to that `node` command that was failing above
Ah, ok, what version of node are you using?
Hmm I have no idea how you could have cargo stuff built for the wrong osx version
no :S is that going to be my cargo install I need to redo?
Ah, yeah, how did you manage to do that haha—did you like downgrade os versions?
my local validator is working. I tried doing anchor test, and now I get this error, Error: failed to send transaction: Transaction simulation failed: Attempt to debit an account but found no record of a prior credit.
I guess there's a clue in that error... I'm on OSx 10 and it does say built for 11: `Referenced from: /Users/new/.rustup/toolchains/bpf/bin/cargo (which was built for Mac OS X 11.0)`
rustc 1.57.0 (f1edd0429 2021-11-29)
Never seen that error before, so I wonder if your rust setup is weird
Mm, what version of rust are you using? `rustc --version`
Hello! I'm having some trouble using the anchor cli. I am trying to run anchor test in a directory created with `anchor init`
```
$ anchor test
BPF SDK: /Users/new/.local/share/solana/install/releases/1.8.6/solana-release/bin/sdk/bpf
cargo-build-bpf child: rustup toolchain list -v
cargo-build-bpf child: cargo +bpf build --target bpfel-unknown-unknown --release
dyld: lazy symbol binding failed: Symbol not found: ____chkstk_darwin
  Referenced from: /Users/new/.rustup/toolchains/bpf/bin/cargo (which was built for Mac OS X 11.0)
  Expected in: /usr/lib/libSystem.B.dylib

dyld: Symbol not found: ____chkstk_darwin
  Referenced from: /Users/new/.rustup/toolchains/bpf/bin/cargo (which was built for Mac OS X 11.0)
  Expected in: /usr/lib/libSystem.B.dylib

$ anchor --version
anchor-cli 0.19.0
```
This is potentially a goofy way to do things but you can also do this:
```.rs
constraint = {
  // do whatever you want here
  msg!("Hmm");
  the_constraint
}
```
Yep `constraint = the_constraint @ YourCustomError`
Hi guys, has anyway to put a custom message in a constraint violation?
Is your local validator running? `lsof -i :8899`
Could I get some insight on this issue please?
Hey guys, I am new to anchor and am trying out the tutorials right now. However, I got an error after doing ANCHOR_WALLET=<YOUR-KEYPAIR-PATH> node client.js. 

(node:29671) UnhandledPromiseRejectionWarning: Error: failed to get recent blockhash: FetchError: request to http://localhost:8899/ failed, reason: connect ECONNREFUSED 127.0.0.1:8899
one sec let me post some code
one of those accounts is a PDA without a signature
Yep, you could do that
take that example and add one more account and verify they're all owned by the same wallet
Right—the basic-2 example does almost exactly that!
Basically I need to validate that two accounts have the same authority before allowing a post.
yea one second
Since all of this is covered in the tutorial
I've worked through them all.
I would suggest carefully working through some anchor examples
But if you pass it as an account, then yes, solana will magically give you all of the account's data 😛
It's true that if you pass it as an instruction argument, that won't work—it'll just be a pubkey (not enough)
Can you post some code?
How are you passing it?
If I just pass in a Pubkey does Anchor do some magic under the hood to show me that entire accounts data?
😈
Yep, that's true
The wallet is different than the UserProfile. I am passing in both pubkeys and it works. But there doesn't seem to be a way from preventing someone from passing in whatever UserProfile pubkey they want
Like, have you tried and it didn't work?
But why can't you use the user profile in there?
because I'm inside of the Post initialization function
Why don't you think you can query the user profile?
Have you worked through anchor's basic-2 example?
UserProfile has that field. I don't understand how to access it when creating the Post. since I can't query the UserProfile
(The wallet in this case)
And then you'd verify that the UserProfile's authority really did sign
No, you would need to somehow write down on-chain the ownership link (UserProfile would include a field called, like, owner: Pubkey, or authority: Pubkey)
So if I'm the program and I need you to prove to me that you're some public key, I need to require you to sign the tx for that public key
So sign the UserProfile Pubkey with the wallet and then pass it in?
The one thing a devious client can't fake is a signature
Tell me alan lol How could I possibly verify that chain of ownership?
There's one thing devious clients *can't* do though
So right now I have to ability to post under an app account; but anyone could pass in any pubkey and post under that persons profile
Yep, devious clients can pass whatever accounts they want
I'm sending my wallet and the UserProfile pubkey to Post.create. But couldn't anybody claim to be that UserProfile and post under it without checking that the UserProfile pubkey is also owned by the wallet?
So you'd just have to pass in whatever accounts are relevant
Reading an account means passing it into the instruction from the client (not possible in solana to dynamically look up accounts from within your program)
What do you mean by an initiation function? Just like an instruction handler?
or anywhere in Anchor
Do you have an example of reading an account in an initiation function?
Im trying my best 😢  lol
Tbh I don't really follow your diagrams haha, but in general in solana you can read any account you want
To check that the UserProfile is authorized by the signer?
So I could read the UserProfile account in the Post.create function?

And you actually can't really query another program in solana (cross-program invocations don't support return values). You can only read from accounts.
hmm, im not understanding why you need to query another program?
I can query another program inside a initialization function?
check if the signer public key and the owner field both match
you could put a data field in the `UserProfiles` account called `owner:Pubkey` or somesuch. Then you can simply query for it and check it
How could I verify that another PublicKey is owned by the wallet that is signing the post? I have this functionality working, but a poster can put any UserProfiles public key in it.
In Web2 I would just query the UserProfile and check that they're equal. But on solana I can not query cross program I can only invoke. Maybe a set_profile function and a round trip invocation?


//////////////////////////////////////////////////////////////////////////////////////////

I'm struggling to find how to check a wallet's spl-token balance. Can anyone point me to an example?
`BROWSER= anchor test` fix the issue
Ok this is because I've a `BROWSER` env variable set, VS Code server set this variable
Hey I get `Error: Provider env is not available on browser.` when I try to run `anchor test`
The error is when mocha is run, I guess mocha run the test in a browser context but I don't know why
To be exact the error is triggered here https://github.com/project-serum/anchor/blob/master/ts/src/provider.ts#L48
(I'm on a fresh `anchor init myepicproject --javascript`, coming from buildspace 😉)
I see, it means that the path of ```anchor test``` call should match the path of ```which cargo-build-bpf```, right?
Ah, interesting, that actually looks right to me
i try ```which cargo-build-bpf``` Should I reinstall solana??
That looks like your solana installation is messed up (what does `which cargo-build-bpf` say?)
hello, I have a question about ```anchor test```
if you had a same question, pls tell me how to solve it.
haha thank you !
```Error: Invalid account discriminator``` Why am I getting this guys when initializing an account?
That one is for you <@!307914484876312596> , I forgot to hit reply again goddamit
what you declare there needs to match the output of `solana-keygen pubkey ./target/deploy/<program name>-keypair.json`, which is the address at which your program was actually deployed (whereas the one specified by default in `declare_id!` is only a placeholder)
`declare_id!("fewjiof89237r934yf280923ru023i")`
You might not have updated the program id declared in `lib.rs` after the first deploy
let me see your question
haha sorry I should've hit "reply"
me ?
```
[workspace]
members = [
    "programs/*"
]

```
you might have add a feature flag in some dependencies you declare, like for instance:
`spl-token = { version = "3.1.1", features = ["no-entrypoint"] }`
<@!341381788620423168>  can you paste your Cargo.toml for the packages involved?
this is the code that causes the error: ```  let program_id = match exe.cmd {
        SubCommand::Pools { .. } => hydra_pools::ID,
        SubCommand::Farming { .. } => hydra_farming::ID,
        SubCommand::Staking { .. } => hydra_staking::ID,
    };
```
anyone got any ideas?
I am putting together a cli tool to call the different programs I have however I am getting this random error:
hey guys,
have you ever figured this out? did updating rustc help? I'm running into the same issue now with anchor v0.19.0 and rustc 1.59.0-nightly
And I don't know from where it's coming since I just took a basic contract and successfully built and deployed it :/
Hi, I have this little problem when I try to test my contract :
```
 test
Transaction simulation failed: Attempt to load a program that does not exist 
    
    1) Is initialized!


  0 passing (124ms)
  1 failing

  1) test
       Is initialized!:
     Error: failed to send transaction: Transaction simulation failed: Attempt to load a program that does not exist
      at Connection.sendEncodedTransaction (node_modules/@solana/web3.js/src/connection.ts:3689:13)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at Connection.sendRawTransaction (node_modules/@solana/web3.js/src/connection.ts:3649:20)
      at sendAndConfirmRawTransaction (node_modules/@solana/web3.js/src/util/send-and-confirm-raw-transaction.ts:27:21)
      at Provider.send (node_modules/@project-serum/anchor/src/provider.ts:118:18)
      at Object.rpc [as initialize] (node_modules/@project-serum/anchor/src/program/namespace/rpc.ts:25:23)



error Command failed with exit code 1.
info Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.
```
How to add padding to accounts in Anchor? I get the `the trait bound [u8; 100]: BorshSerialize is not satisfied`
i was copying this <https://github.com/jet-lab/jet-v1/blob/master/programs/jet/src/errors.rs> but now i see that the other error file i was referencing does use prelude <https://github.com/blockworks-foundation/voter-stake-registry/blob/master/programs/voter-stake-registry/src/error.rs>
yeh, totally weird, anchor lang prelude works
ok, cool, i'll try that out instead. Thanks!
I only have `use anchor_lang::prelude::*;` and the error macro works
yep, i tried both `use anchor_lang::error;` and `use anchor_lang::*`
Do you import the anchor prelude in errors.rs?
I checked many times and everything seems right, can anyone help me find out?
`     Error: provided too many arguments 251,500,1000,[object Object] to instruction initialize expecting: vaultAccountBump,initializerAmount`
ah right thx
Maybe not a bug exactly, but it's weird/Justin Starry said they want to fix/improve it.
This weird pre-CPI imbalance check: https://discord.com/channels/889577356681945098/889584618372734977/915190505002921994
Any tips on sorting this out? Cant access the Solana discord for some reason...
hey I'm trying out the openquest rust calculator tutorial. Whenever I enter "solana account (my key)" command on terminal i get a "AccountNotFound: pubkey=" error. Was also getting a tcp connect error before, but after i set a new keygen (solana-keygen new --force) I get the AccountNotFound
which bug?
so weird, because lots of people use separate `error.rs` files, i wonder what i'm doing differently
when they're in the same file, in lib.rs, there's no issue
the compile error is over the `#[error]` macro
in error.rs
```rust
#[error]
pub enum ErrorCode {
    #[msg("Function not yet implemented")]
    NotImplemented, // 300
}
```
and in lib.rs
```rust
    pub fn resolve_market(ctx: Context<ResolveMarket>) -> ProgramResult {
        //
        Err(ErrorCode::NotImplemented.into())
        // Ok(())
    }
```
```
expected non-macro attribute, found attribute macro `error`
not a non-macro attribute
```
Trying to use custom errors but getting a compile error
Reinstalled rust.. Getting other error on anchor build:
```root@User:/mnt/c/Users/User/Desktop/V/anchor-escrow# anchor build
BPF SDK: /root/.local/share/solana/install/releases/1.8.5/solana-release/bin/sdk/bpf
cargo-build-bpf child: rustup toolchain list -v
cargo-build-bpf child: cargo +bpf build --target bpfel-unknown-unknown --release
   Compiling blake3 v1.2.0
   Compiling num-traits v0.2.14
   Compiling syn v1.0.82
   Compiling solana-frozen-abi-macro v1.9.0
   Compiling solana-frozen-abi v1.9.0
   Compiling solana-program v1.9.0
   Compiling aho-corasick v0.7.18
error[E0463]: can't find crate for `rustc_version`
 --> /root/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-frozen-abi-1.9.0/build.rs:1:1
  |
1 | extern crate rustc_version;
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't find crate

error[E0463]: can't find crate for `rustc_version`
 --> /root/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-program-1.9.0/build.rs:1:1
  |
1 | extern crate rustc_version;
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't find crate

error[E0463]: can't find crate for `proc_macro2`
   --> /root/.cargo/registry/src/github.com-1ecc6299db9ec823/syn-1.0.82/src/lib.rs:307:1
    |
307 | extern crate proc_macro2;
    | ^^^^^^^^^^^^^^^^^^^^^^^^^ can't find crate

For more information about this error, try `rustc --explain E0463`.
error[E0463]: can't find crate for `rustc_version`
 --> /root/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-frozen-abi-macro-1.9.0/build.rs:1:1
  |
1 | extern crate rustc_version;
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't find crate

error: could not compile `solana-frozen-abi` due to previous error
warning: build failed, waiting for other jobs to finish...
error[E0463]: can't find crate for `memchr`
 --> /root/.cargo/registry/src/github.com-1ecc6299db9ec823/aho-corasick-0.7.18/src/prefilter.rs:6:5
  |
6 | use memchr::{memchr, memchr2, memchr3};
  |     ^^^^^^ can't find crate

error: build failed```
Can i manually download arrayvec v0.7.2 ?
What about doing `cargo clean` ?
Have you tried looking at that messed up Cargo.toml file in the error message? I wonder if you can spot something wrong with it
just came here and whuala
Ah, ok, hmm
everything was working fine lol
im using wsl
```rustc 1.59.0-nightly (686e313a9 2021-11-27)```
Also, not sure any of this stuff works on windows lol (most people have to use WSL as far as I know)
What is your `rustc --version`? Not sure what the problem could be
Cannot solve this error: 
```failed to download `arrayvec v0.7.2```
Yes, i think so too. Trying to reinstall rust..
Hmm, not sure what's up with that (something is wrong with your cargo)
anchor build :
Make sure you've run `anchor build`
any ideas?
```Cannot find module '../target/types/anchor_escrow' or its corresponding type declarations.```
in anchor ts-client 0.19.0 there is no `anchor.workspace.<app_name>` how can i get the `programId`?
anchor build works now. why? I don't know...
2. copy/paste Cargo.lock text (all of it) from working project that builds to the broken one.

This error started happening whenever I created a new project...Don't know why. Here's the fix...
1. change programs/Cargo.toml to this:
I was able to fix this issue. This is what it looks like...
Is there an easy way to wipe anchor and it's dependencies? My setup stopped working today and now I just see this message:   failed to read `/Users/yoshiioko/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-frozen-abi-macro-1.9.0/Cargo.toml`
when I run "anchor build"
Explained better than I can ^
https://discord.com/channels/889577356681945098/889577399308656662/907579111101329428
It's most likely due to the sighash of your instruction being wrong, hence when it looks it up on the program that you're calling it fails and has no fallback function
must be my Context variable
error*
but even when i comment out the cpi call i get the
yeah i'm doing CPI
hmm
This usually occurs for me when doing CPI where interface is improperly specified
im not sure what a fallback function is
Error: 101: Fallback functions are not supported
is anyone familiar with this error?
only react client example.
there is no cli example
ah, cli?
There are no cli example using the IDL in these?
And then you can see the good example in the test folder of Escrow example.

not too sure I follow? and I cant see an cli example in your doc?
https://github.com/bmstar2012/solana-reference
if you start rust and anchor, you can reference my git.
I shared my experience.
Hey guys, anyone got any good examples of building a rust cli to work with the anchor IDL contracts?
Hello everyone. I'm brand new here as of a few minutes ago.

I'm current experimenting with anchor (I have already developed an on-chain application on solana without anchor).
I've followed the guide and created an anchor program and have a runnable client.js as described here https://project-serum.github.io/anchor/tutorials/tutorial-0.html#generating-a-client

I'm new to javascript/typescript and my IDE (VsCode)  so maybe this is a configuration outside of anchor. Is there a way to actually generate the .js or .ts  client source code from the IDL? My IDE doesn't auto-complete the dynamically created methods from the "generating-a-client" example
in any case, the naming should be improved yes - I basically took a mock app I had lying around and shoved the state into it lol
nice. yeah im also really bad at adding 100 console logs lol
backtrace once again on the thank-yous to alan, who gave me the idea, i just wrote it out in a program
and that both states are upgradeable
Will keep the rest of the tests since they show that the account interactions actually work
I should clean up the console logs anyway
Thanks to you, you figured out the backend part so 😄
but yeah, this is awesome man, glad to be able to do this on client side now thanks to you 🙂
i condensed it down to this, just because i only wanted to see that the state changed and that it could be parsed by js. Also I changed base account to state account as the name cause i kept getting confused as to what base account was, so you will have to change back the test script or change the rust.
how do people normally do something like a payable function would be done in Solidity, where the function performs logic based on the amount paid in the msg.value? (like calling a payable function in a token pre-sale or something, to reserve some token allocation based on the amount paid, to be used at a later distribution date)
Haha thanks, I have like 2 total working days put into studying Rust / Anchor so I'd be amazed if this is something even remotely useful 😆
haha yeah just trying to understand what's what, because im very interested in how you did this
maybe the console log is over-verbized now
you probably just want to look at the last test, the others are just atomic tests for the basic functions
yeah these tests are hard to read 😄 let me see if i cant clean up a little

it is supposed to throw an error, but it should pass
1 is, the one `Cannot decrement initial state!`
unless it's supposed to fail?
wbu?
the tests are failing for me, a couple are
i don't think you can reduce the rent, it has to be rent exempt if i am not wrong
no, more like a thousand $ or more
I did a breaking change in the second state, with the u32 -> u64 so the interacting program will need to account for that when reading the state and parse accordingly
downside: for each state version you probably need a new state structure, and manually keep compatibility with all previous states
the upside is that you're in complete control of the structure and can upgrade the accounts
So either you build switchable states (if that makes sense at all), or you use state as a placeholder for upgradeable data
What's clear here is that you can't really keep both states with data since the program account doesn't hold state and the account can only hold 1 state
sick, will look in a min
Need to improve the readme as well
done - took a bit longer since I needed to put kid to bed.  Better test coverage and state upgrading example
If I wanted to deploy a smart contract to main net for a week (7 days) - would a cost estimate of about $5 be correct?
yeah took me a while to find it so i like to share it lol
right now just following sample code from programs i use / know well... this is useful
oh! tyvm!!!
yeah they are multi-purpose.
something for your bookmarks
https://docs.rs/anchor-derive-accounts/0.19.0/anchor_derive_accounts/derive.Accounts.html
https://discord.com/channels/889577356681945098/889606719829835816/909947411550580766
ah nvm, i see it for account(mut) as well as account(init).. giving it a try
or does that need to be done in the body of the instruction
is there  an #account[] constraint for checking that its a pda with seeds+bump?
Thanks Alan!
I did not expect full examples there 🙂
holy smokes! exactly this!
Have you looked at the anchor tests/ directory?
Hey guys, can you recommend any beginner friendly repos with Anchor programs? Some slightly more complicated than the basic ones. Cheers!
Just to leave a response for others with the same issue. I was using webpack to build my browser app with a dependency on anchor. It wouldn't work because `process.env` was undefined in the browser console. The fix was installing: `npm i process` and then adding:
```
plugins: [
        // fix "process is not defined" error:
        // (do "npm install process" before running the build)
        new webpack.ProvidePlugin({
            process: 'process/browser',
        }),
    ]
```
to the webpack config.
I got some freeish time now, so I'll quickly push that
lmk when you do, im interesed to see that
sound advice, will build on that
that way you're proving that this all works
couple suggestions to make this better:
add a handler to switch back and forth between states, that way you can write test cases to prove that either case works in the typescript
add log statements in the test inside each of the state cases
brb
it's a simpler case than yours but should work in any case
https://github.com/srps/mysolanaapp
let me up this example to GitHub
like Github, got it
```abc```
can you post the rust structs?
yeah put 3 on top and 3 on bottom
Use backtick
Sorry I need to l2Discord - worst formatting ever
```let account = await program.account.baseAccount.fetch(BaseAccount.publicKey);

    switch (Object.keys(account.current)
      .filter(key => key.endsWith("State"))[0]) {
      case "firstState":
        assert.ok(account.current.firstState.count.toNumber() === 0);
        break;
      case "secondState":
        assert.ok(account.current.secondState.count.toNumber() === 0);
        break;
      default:
        throw new Error("Unknown state");
    } ```
right now I'm just doing it manually, I think you got farther from this already but I'll share in a min
if you come up with something good i'd definitely like to see the code
If we look at the Solana contract we can test for the object keys and derive the type from that.
I already asked there but got no answers. But since <@!501570363566587905> is here I'm trying my luck.
they seem dead over there, idk how ur supposed to integrate with their programs
lol true
No one ever answers any question there.
https://discord.gg/YDnUBBv5
Can I DM one of the core devs here about a question on Serum? (because it is not Anchor related)
You use the system program whenever you `init` an account (amongst other things)
i might make an issue, worst case i think there's some way to get the data byte array and parse it, otherwise doing a program log and then grabbing the logs
I'm also stuck there hehe
no progress regarding deserializing the object in JS, I suppose
gotcha, going to check it out. I had to step away this past week - barely any time for anything serious so I just kinda skipped Discord 😦
p much. if you scroll up in <#889606719829835816> you can see my full example
i figured it out already
Ah, so you used a simple match to check the kind of object passed and deserialize on the fly, cool
Don't transfer lamports
`Failed to run test: node tests/myproject.js: No such file or directory (os error 2)`
this is what i get when i run `node tests/myproject.js` manually
i'm getting the following error when i run `anchor test`
Not sure what you mean by "call a TokenAccountA" ?
Does this help?
https://stackoverflow.com/questions/68236211/how-to-transfer-custom-token-by-solana-web3-js
Hi everyone, does anyone know how to call a TokenAccountA with the public key of the TokenAccount. I want to use the function 'getOrCreateAssociatedAccountInfo' to generate an account for a user from TokenAccountA
But for starters you snippet #1 is definitely a better starting point, as you are using Anchor (and its Provider) to communicate with **your** program
If not tell me and we can dig in a bit
It sounds quite similar to a lot of issues answered before. Could this snippet/conversation (zendevil/cqfd) help you?
Question for you sir:
Do you have an example that shows what a CPI to transfer lamports looks like?
so 1, I am not sure which address to use and 2, i am not sure why the respective errors arise with each different address
this will return an "invalid instruction data" error
```this.PROGRAM_ID = new PublicKey("11111111111111111111111111111111");
        this.connection = new Connection('http://localhost:8899');
        this.provider = new anchor.Provider(this.connection, wallet, anchor.Provider.defaultOptions())   
        this.program = new anchor.Program(idl, this.PROGRAM_ID, this.provider);
    ```
this will later on return a 0xa8 address error
```this.PROGRAM_ID = new PublicKey(idl.metadata.address);
        this.connection = new Connection('http://localhost:8899');
        this.provider = new anchor.Provider(this.connection, wallet, anchor.Provider.defaultOptions())   
        this.program = new anchor.Program(idl, this.PROGRAM_ID, this.provider);
        ```
and it gives two errors
but when i use anchor deploy, i plug in the deployed address to my react frontend
they do call the program. using anchor test, in the ./tests/project_name.js file, when i import {SystemProgram} and log SystemProgram.programId its "111111111111111111111111111111111"
Does your test actually call your program? Only logs from the System program would show if the only thing you do is create accounts for instance
hi all, when I use anchor deploy, it gives me a programId address to where my program was deployed (local net). yet, when logging for tests, it's always "11111111111111111111111111111111". when do i actually use that program address?
not that i know of 😦 i dont know that deep into anchor
I'm using `remaining_accounts` for the number of accounts i need to close is variable, that's why i'm looking to close them from an accountInfo type. Is there a way to go from account info to account so i can close them ?
just make sure you provide the account of the person who gets all the sol inside the account ur closing
just call it on an instance of an `Account` 🙂 `my_account.close()` or somesuch
https://github.com/project-serum/anchor/tree/master/tests
https://github.com/project-serum/anchor/tree/master/examples/tutorial
check through these programs, recommend to go step by step through the basic ones first and understand all the parts
https://docs.solana.com/developing/programming-model/overview
https://spl.solana.com/
steps 3, 4 and 5 are not necessary if you just want to run tests. anyway your issue is mainly because you are running a test validator, and anchor test already does that


//////////////////////////////////////////////////////////////////////////////////////////

That means you're doing something where you need to pass the system_program as an account: add `system_program: Program<'info, System>` to your accounts struct and should be all set
Yep, you'll need to set it in one of your shell's init scripts (e.g. I'm using zsh, and put that kind of line into my .zshenv file in my computer's home directory). If you're on bash it's probably in your .bashrc etc.
problem is every time i open a new terminal, I have to export the path again. is there a way to do this once and not have to keep exporting on each new terminal window?
im on a mac m1, followed the solana downlaod tutorial but i need to keep exporting the PATH (guide stated PATH=$PWD/bin:$PATH)
could u send your Accounts struct too
just bumping this:

i'm running into the following error:

`error[E0425]: cannot find value system_program in this scope`

```
  |
5 | #[derive(Accounts)]
  |          ^^^^^^^^ not found in this scope
  |
  = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)
```

when trying to write instruction structs
i have `use anchor_lang::prelude::*;`
do i need an explicit import here?
this is 0.19.0
Gotcha thanks
That means expect the account not to have its discriminator bytes set yet (anchor uses the first 8 bytes of account storage to hold an "account discriminator"). The idea with #[account(zero)] is you sometimes need to allocate the storage for an account in a separate instruction, so its anchor hasn't had a chance yet to set those discriminator bytes.
what does account(zero) mean?
thank you! nice to have confirmation
Is anyone else running into `unresolved import` errors when trying to use the CPI feature to make calls to another program?
https://project-serum.github.io/anchor/tutorials/tutorial-3.html#defining-a-puppet-master-program
<@!134416332509675520> Can you perhaps help me? My program compiles okay, but then in the tests, I cannot instantiate my program because apparently workspace does not exist on anchor. I used escrow example as the baseline.
my tests work fine
I'm having a weird test-related issue here as well:
Build succeeds, but the program initialization does not work, anchor.workspace is giving error that workspace is not a property of anchor. Any hints on why? (i'm using typescript for tests)
I' using Ubuntu in a docker container
no I'm using `0.18.2` I think
are you using an M1 machine as well?
I have the same issue. Are you using the 0.19.0 version?
is it weird that `anchor test` works perfectly but if I run `anchor localnet` + `anchor deploy` on localnet it's stuck on `[0/1] Finalizing transaction` forever?
thanks for the help, todays not my day so im going to move on to another tutorial haha
not sure if it's related to mac, may need to seek help from the command you're using.
im on a mac m1 so tbh im pretty sure thats the reason for the os errors
that did resolve it slightly, but now having an error unable to read keypair file - its defaulting the keypair to the folders ive saved the tutorials to. "Unable to read keypair file"
In your `Anchor.toml` file, edit the `scripts` section as follows: 
> [scripts]
> test = "npx ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"
In your `Anchor.toml` file, edit the `scripts` section as follows: 
> [scripts]
> test = "npx ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"
still getting the os error 20 after installing mocha again...
Make sure you've actually got ts-mocha (or mocha, whichever testing library you're using) actually installed
I know you are busy <@!501570363566587905> but maybe you can help out here, because a lot of people have issues, with that and I want to unterstand whats the best and safest workflow
Here's my repo for the problem.
seems a bit complicated, in fact, it's not.
https://github.com/cryptoJLee/nft-rental-sol/tree/feature-syntheticnft
Im completing the openquest calculator tutorial. when i run "anchor test" after all code is written i just get a "Error: Not a directory (os error 20)". Any fixes for this?
Mm, good question, I'm not sure! I don't really know what the best workflow is for this kind of thing, will have to see what other people think
I think you're going to have to post your code to a github repo—I tried doing something similar to what I think you're describing in the basic-3 example and it seemed to work fine.
<@!134416332509675520> one question: anchor 18.2 requires solana 1.9, which is not released on the mainnet, should you really develop production contracts with solana 1.9 when, its not released on the mainnet
same question with using anchor 19.0 which requires rust edition 2021
<@!134416332509675520>  Please have a look and let me know. I tried hours and can't find any solutions. 🙏 🙏 🙏
Any solutions to this problem?
seems like the solana-program is updated to `1.9.0` three days ago and it's breaking the most recent programs.
I updated the solana to `1.9.0` and the error is gone.
How can I store something in AccountInfo?
> rustup 1.24.3 (ce5817a94 2021-05-31)
> info: This is the version for the rustup toolchain manager, not the rustc compiler.
> info: The currently active `rustc` version is `rustc 1.57.0 (f1edd0429 2021-11-29)
Anyone got this error?
----------------------------------------------------------------------------------------
> error: failed to download `solana-frozen-abi v1.9.0`
> 
> Caused by:
>   unable to get packages from source
> 
> Caused by:
>   failed to parse manifest at `/home/aaa/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-frozen-abi-1.9.0/Cargo.toml`
> 
> Caused by:
>   feature `edition2021` is required
> 
>   consider adding `cargo-features = ["edition2021"]` to the manifest
----------------------------------------------------------------------------------------
you are on mainnet so this is why the airdrop is failing. try this first `solana config set --url devnet`
ProgramAccount is deprecated in favor of just Account, and yeah, Signer and `#[account(signer)]` do essentially the same thing but `Signer` is a bit nicer (it bakes the fact that someone signed into the type)
Config File: /Users/<user>/.config/solana/cli/config.yml
RPC URL: https://api.mainnet-beta.solana.com
WebSocket URL: wss://api.mainnet-beta.solana.com/ (computed)
Keypair Path: /Users/<user>/.config/solana/id.json
Commitment: confirmed
Just type `BROWSER= anchor test` instead of `anchor test`
whats `solana config get -v` say?
When I run solana airdrop 10<address> on my localnet I get the following error:
**"% solana airdrop 10 <address>
Requesting airdrop of 10 SOL
Error: airdrop request failed. This can happen when the rate limit is reached."
**
Any advice?
I have a program A that calls another program B using CPI.
TokenBumps is a struct used as a param on the instruction of the program B.
And in TypeScript, the IDL of program A shoots an error.
Type not found: {"name":"bumps","type":{"defined":"TokenBumps"}}

Is there any way to fix this error?
I am wanting to build a cli that using subcommand and can talk to all my different programs I have in the protocol.
I have put a test-protocol repo up here that reproduces the issue if anyone can have a quick looks and let me know if you see the issue: https://github.com/utx0/test-protocol/tree/main
Hey guys, I am getting a random build issue when I am using this code in a cli I am build: ```    let program_id = match exe.cmd {
        SubCommand::Pooling { .. } => pooling::ID,
        SubCommand::Farming { .. } => farming::ID,
        SubCommand::Multisig { .. } => multisig::ID,
        SubCommand::Staking { .. } => staking::ID,
    };```
Has anyone had issues where your system crashes when trying to install anchor?
I'm running the command `cargo install --git https://github.com/project-serum/anchor anchor-cli --locked`
And while compiling, my desktop fans would go crazy and my system would crash. I'm on windows 10 using the linux subsystem
this is 0.19.0
do i need an explicit import here?
i have `use anchor_lang::prelude::*;`
when trying to write instruction structs
i'm running into the following error:

`error[E0425]: cannot find value system_program in this scope`

```
  |
5 | #[derive(Accounts)]
  |          ^^^^^^^^ not found in this scope
  |
  = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)
```
where can I check this? Having same problem
Anyone know if there is a difference between these two bits of example code?
```
#[derive(Accounts)]
pub struct Increment<'info> {
    #[account(mut, has_one = authority)]
    pub counter: Account<'info, Counter>,
    pub authority: Signer<'info>,
}
```

```
#[derive(Accounts)]
pub struct Auth<'info> {
    #[account(mut, has_one = authority)]
    pub data: ProgramAccount<'info, MyData>,
    #[account(signer)]
    pub authority: AccountInfo<'info>,
}
```


 - I'm not sure the difference between `ProgramAccount` and `Account` structs here
- more importantly, I'm curious if there is a difference between specifying the Signer account as:
`pub authority: Signer<'info>,`
vs
`    #[account(signer)]`
`    pub authority: AccountInfo<'info>,`
nvm, "freeze_authority" is an option
is there any documentation for those spl-token annotations?
`mint::authority` does this set both the mint and freeze authority?
Hello! I am running into some ssl issue when running anchor test on devnet

I can make https requests from my local but not sure where I can specify a custom cert authority. Also tried export NODE_EXTRA_CA_CERTS
```
Error: failed to get recent blockhash: FetchError: request to https://api.devnet.solana.com/ failed, reason: unable to get local issuer certificate
    at Connection.getRecentBlockhash (/Users/samantha.han/Web3/epicproject/node_modules/@solana/web3.js/lib/index.cjs.js:5965:13)
```
how can I configure the name of the ix?
how are the program instructions named for the likes of serum, for example? for my program instructions, they show up as unknown, for serum, it has its own name
Awesome! Thanks, I didn't know about this method.
I think you'll have to do `ctx.accounts.that_token_account.reload()` to reflect the result of the CPI
for a program to accept sol deposits, do you need to create a token account?
would be better if I can just rely on `token_account.amount`
well yes, theoretically I'd be able to derive the new amount from the transfer amount and the old amount, but it's not super practical as the transfer happens inside a method that I'm calling which calls another method that does the transfer
I'm not sure I totally understand the question, but if you make a transfer between two accounts that means that you have both accounts available in the ctx, and that whatever operation is applied to them will be reflected. E.g.  (A: 10), (B: 0) provided => call "transfer 1 from A to B" => (A: 9), (B: 1) , and you would be able to log those value and see the expected amounts.
Do you have a specific worry in mind?
If I do a token transfer within my contract using CPI into a token account `token_account: Account<'info, TokenAccount>` , will `token_account.amount` reflect the updated value, or the one deserialized when instantiating the ctx?
Thanks! I'll try to make it work with this. Much appreciated Milk duds 🙏
if you have an object of type `anchor_lang::Account<'info, anchor_spl::token::TokenAccount>`, then you can call the `amount()` method.
he never calls it in this program but you can see how he's using token accounts.
https://github.com/cqfd/quidproquo
so you'd do something like
`ctx.accounts.offer_takers_taker_tokens.amount()`
If I tell you:
1. client-side (e.g. frontend): retrieve the associated token account for the particular token mint you want to check (there is a web3.js function for it) and provide it as an account in the call to your contract
2. program side read this account and do a simple check ~~`ctx.token_account.balance > 0`~~  `ctx.accounts.token_account.amount() > 0`
is there something specific that is unclear to you?
In a smart contract. I'm looking to check if a user is holding a particular SPL token (or perhaps one from a list) in order to execute
in what context?


//////////////////////////////////////////////////////////////////////////////////////////

when submitting an instruction?
is there a way to easily print out all the pubkeys of the `accounts`
debugging in anchor can be such a pain sometimes
it can be the token account owner, but it's difficult to make it the payer
nope, not unless you do some crazy shit
Gotcha! PDA can sign the tx but can't pay to initialize a new account
and the PDA has data on it / already is owned by a program
no, this means that you're trying to use a PDA to pay for a new account
Ah! Okay I did have a slight seeds issue. But now running into `Transfer: 'from' must not carry data` which I think is suggesting I can't initialize a new account with a PDA as a signer
i don't see why passing the AccountInfo into the puppet program via CPI would cause you any errors if it's an unitialized account
seeds and bump
are you including `seeds` in the puppet program accounts context
i think you'll get around the issue by doing what you're doing already, just using a mutable accountinfo to pass into the pupper program
you're going to run into problems if puppet master and puppet are separate programs
well
It sounds like you're saying either the original signer or the "pupper master" program could init the account directly with the system program before the CPI?
Can you say more about that first part? I'm haven't tried to do anything directly with the system program. Have just added the `init` flag to an account's `#[account()]` macro and attempted calling that instruction via another program. I've tried passing in the account to the "puppet master" as a mutable `AccountInfo`  but this tends to result in `unauthorized signer or writable account` when the CPI is attempted
Yes on all these! Can post a link to an example soon.
are initing a PDA
are you using the `init` key word
are you using the correct seeds
There's two steps, creating the account with a system program call and then initing it with your custom program function
assuming you include the account in the account context there shouldn't be any issue with creating the account
Struggling with this same problem right now as well! Does anyone know how to init a new account via a CPI call? The catch-22 seems to be that all Solana accounts used in a transaction have to specified ahead of time.. but the account I want to init via CPI isn't initialized when the signer first submits the transaction. So I keep running into `Cross-program invocation with unauthorized signer or writable account` errors wrt the accounts I'm trying to init via CPI
Not really sure what that trait is for if not for that
I expected the `instruction::xxx` structs to implement `InstructionData`, but apparently they don't
It'd probably solve the issue, was my first thought but I was hoping for something less ugly
ok, i was just trying to check if the sha256 thing was actually a solution to your problem or if you just didn't like the solution
Without having to use the restrictive anchor client
it sounds like you have to do everything manually anyway, is all i'm saying
Yeah, I'm just trying to build an Instruction I can send to a validator
maybe i don't fully understand what that is
you said you're constructing the instructions manually without using the client API though?
lol
Hm, kinda annyoing having to do that manually
though not 100% sure that's correct
i think `sha256(global:{funcname})[0:8]` is what the discriminator uses
if you get
```
Error: Unable to read keypair file
```
Make sure that you've run 
```
solana-keygen new
```
if you're on a new computer

Update:
Alternatively check that the `wallet` path is correct in your `Anchor.toml` file
e.g.
```
[provider]
cluster = "localnet"
wallet = "/root/.config/solana/id.json"
```
Anyone able to help with this?
https://explorer.solana.com/address/So11111111111111111111111111111111111111112 ?
thanks
Btw does anyone know the Mint account for the SOL token? How do I find it?
changing ownership requires access to the account data which means the program needs reference to it, so it has to be explicitly specified.
ouch , I guess would have to handle it if they end up being blank
you cannot pass an array of token accoutns, you need to pass each account one-by-one
Hi guys , sorry if this is a stupid question , but am writing a contract and want to pass an array of token accounts owned by a single account to be owned by the pda , is this possible
Heeeelp! Is is possible for the program to initialize a regular token account (without any data)?
Yeah I think so
hello, does `pub rent: Sysvar<'info, Rent>,` this also check if the rent account is actually the rent sysvar?
yo thanxs I got my answer
This snippet gave the same number
```javascript
const rent = await program.provider.connection.getMinimumBalanceForRentExemption(89)
```
i think your account needs to be funded with 2 years worth of storage funds to be rent exempt...
I created a PDA using anchor, and while inspecting, their is one question jumping in my mind, is `the transfer amount(sol) ◎0.00151032` in the image, is the minimum amount to be rent exempt. and is it automatically get deducted while signing the txn.
google for solana rust escrow tutorial, and read up on PDAs
is there a thread above with an example of this?
Yeah, right but I wanna another way rather than PDA
You can make use of PDA
Thanks
https://discord.com/channels/889577356681945098/889702325231427584/909034790030823425
Guys I have created nft, but I don't know how to fill information in it? like how to store json and is it even possible?
You need to transfer the ownership (and signing rights) to a PDA which will be owned by your program. Then you dont need to sign it yourself anymore.
which i cant do :(
so even though i can pass in the proper addresses for validating authority and whatever, in the end, it needs me to sign
the issue is, because the user is not me, their wallet creates the provider for the program, and in turn, they are signing that transaction
and this is giving me an issue because i want to allow users to mint for one specific rpc function, but the signer needs to be a secret/my keypair
so when I create a program with a provider, the wallet signs all transactions
You mean like a regular web2 application? Sure, but  then it would not be on the blockchain 😉
Jokes aside, you can control what data should live on the blockchain and then only transact those bits, which should minimize the amount of signing.
is there a way to create a program on frontend without having the wallet sign everything?
Hi <@!134416332509675520>
Hey, I'm trying to construct anchor txs in rust (without using the client API as I want to send them over a TpuClient) and I can't get the instructions serialized in a way such that they also contain the discriminator: are there any examples on how to do this?
I have 2 programs, a puppeteer and a puppet for example. 
There is a function on the puppet, which creates new PDAs with a ctx looking like that:
> #[account(init_if_needed, seeds = [b"new_acc".as_ref()], bump, payer = user)]
> pub new_acc: Account<'info, NewAcc>
I'd like to call this function with the puppeteer using the CPI, but as far as I understand, I need to pass this PDA as a ctx to the puppeteer function, but it's still not initialized at the moment.
that's from this question which has another approach as well, but I don't know enough to say which one would be better:
https://stackoverflow.com/questions/69382867/how-do-i-get-list-of-tokens-owned-by-me
maybe this will be useful?
https://docs.solana.com/developing/clients/jsonrpc-api#gettokenaccountsbyowner
no worries  👍
yeah, lol! I know that feeling  😆 
It's all very manual, and in some ways more restrictive
But thanks so much for the help though. I might DM you with questions later if you don't mind
Coming from solidity everything is hard 😩
yeah, I am still learning myself. But if all the wallets can determine/discover the held NFTs of a publickey, then it must not be too hard
you can store the data on-chain, and fetch the accounts that hold the data, in order to compile your list of accounts to put into your instruction from the client. So storing such information on-chain can still be part of a solution to certain problems, but it would be used mainly for the client to reference the data (and maybe for on-chain validation of the accounts somebody is requesting to change, if such controls are needed)
Seems client side needs to know more than just a wallet but also scan the wallet for their mints which I'm not sure how to do at this moment
Oh you are completely right I think. The accounts array must be predetermined
Struct containing mint address which will function as seed for the program owned token account and some values set by program instruction
what do you mean by NFT data? ownership status, or something else?
like, you can't even reference a PDA's data even if you know the address on-chain, without having it passed into the instruction from the client. That's because of how the accounts array is used to safely parallelize access to account data. So the account access has to be pre-determined via that array in the instruction. Hence the need for off-chain processing even if you had an on-chain approach that could otherwise work to know the arbitrary account addresses. That is based on my understanding of everything anyways
Basically have several users with one to many relationship to a struct containing nft data. Want to get all the NFT data somehow with just the user wallet address
How about vectors in solana
your question/scenario is a tad confusing, but hashmap as far as I know is just simply not available in Solana. You can see a bit more explanation here: https://stackoverflow.com/a/68477522/200818

So it seems you just have to get creative with how you reference your data. And I think since you need to always pass in from the client, any account that you want access to, you will always need to offload some of the logic onto the client for iteration and/or pagination of whatever list of results you may need to process, and then pass those accounts into the instruction that needs it. Does that make sense? I can't speak too much to your use case since it was a bit unclear to me what you're trying to do (but I'm also still learning as well, so maybe I am missing some context around your question)
I was actually trying to do the same thing today. For each user wallet address I want to set up a PDA that implements a HashMap<Pubkey, data> to keep track of multiple NFT mints and map it to some data. 
I can't use the PDA for the hashmap data because I won't be able to get all of the data just from a single user PDA from the original user wallet address.
A potential second option is maybe I could have multiple NFT PDA's set up for my user PDA but then I would need a vector (which is indeterminate size anyways) in my user PDA to keep track of all NFT's accounts. This is under assumption I want to get all my data from just being given a user wallet.
Hopefully I wasn't too confusing and I'm thinking of doing the first option of using the one PDA to store a hashmap but I'm still new to everything and not sure what the ideal approach is
If I follow the Token Metadata standard will my NFTs be consumeable on Metaplex + Phantom? What's the best practice for minting NFTs outside of candy-machine?
```    
#[account(mut, constraint = admin_acccount.key() == Pubkey::from_str("Fp7nWGtfb1LFwzZcgmNkMRPzaWbmQ6DDwEndqUQXvLAs"))]
pub admin_acccount: AccountInfo<'info>,
```

How can I ensure that provided admin key is same as `Fp7nWGtfb1LFwzZcgmNkMRPzaWbmQ6DDwEndqUQXvLAs`.

It seems that there is no `from_str` on Pubkey struct
Have you looked into PDAs for that kind of purpose? I think that’s typically the go-to approach to storing associative information, especially when an indeterminate size
Hi <@!134416332509675520> 
Could you explain me how I can implement the hashmap<Pubkey, u32> on the account?
~~Hey is there a way to skip program upgrade when running `anchor test`~~
**solved**: There is a `--skip-deploy` & `--skip-build` that's not mentioned in the docs
https://docs.solana.com/developing/test-validator
yep 🙂
by default? why? to pay for transactions?
there's no harm. As long as it's a valid key. Everytime you start up a new test validator it will airdrop a bunch of sol to whatever key is at that address
thanks bro
any harm in overwriting my local solana keypair?

i've just been doing local dev. could restart test validator without consequence.
yw
I see, thanks for the help!
Dont think it does. You would need explicit owner check. I.e. on the token_account you would need to add owner=user, and add another account which will be named user, and that one would have signer constraint
Or does that still not solve the problem of a caller referencing something they don't own 🤔
Yeah within the function I check `.amount >= 1`
Almost there. Right now anyone can call this by passing the desired token addresses. You need to make sure that the signer of the transaction indeed owns those tokens, or rather they own the accounts which hold the tokens
use constraint:
constraint = accountA.mint == mintAddress.key()
Captains and crew, I spent the day writing my first smart contract, but I'm pretty sure I wrote it in the ugliest fashion possible. Can anyone offer critique/advice? I simply want to allow entry to a `fn()` for holders of an NFT in a list (or one of a collection). The entry `Context` in this case is the `UpdateAsHolder` `struct`. My terrible, no-good, naive solution is this: 
```fn is_access_token(input_token: anchor_lang::solana_program::pubkey::Pubkey) -> bool {
    let v = [
        "teST8ZSPiHKifT6tvWhzQdSZz57NeaX7jaMkfGSwcyF".to_owned(),
        "testGaCLrEdHAhBkN2V44igJc7RfEoz3A2S63pW1rzV".to_owned()
    ];
    let input_token_str = &bs58::encode(input_token).into_string();
    msg!("Validating against input_token: {}", input_token);
    if v.contains(input_token_str) {
        return true;
    }
    return false;
}

#[derive(Accounts)]
pub struct UpdateAsHolder<'info> {
    #[account(mut, constraint = is_access_token(token_account.mint))]
    pub token_account: Account<'info, TokenAccount>,
}```
Is there an `#[account()]` constraint that can check to see if a token account being passed is of a particular mint?
when i try to just put in `#[account(token::mint = my_spl_token_mint)]` it says i also need `init`, but im not trying to create it, i just want to check it
thx (:
yes
also, can i set the authority as a PDA? if so, I have to provide the seeds into order to sign a CPI to transfer tokens i assume?
`token::authority=my_sys_act`
This property sets the address that is allowed to send tokens out of the Token Account, correct?
If you look at the source, checkout line 112+ in the test js file
found it
can you link to that?
Derives the pda in js and then passes it in
Looking at the escrow example from paulx blog that's what he does
hm maybe all I need to do is pass the Pubkey, and not the account, then initialize an account for that Pubkey... let's try
anchor_spl::token::initialize_account
yeah, there is one in anchor-spl too
Found this too https://docs.rs/solana-sdk/1.4.4/solana_sdk/system_instruction/fn.create_account.html
#[account(init)] does not work sadly - or at least I didnt figure out which type to use, since init requires a struct for data type
Since the program is an executable, its account is immutable, so you def need to create a new account for treasury. I think using #[account(init, ...)] can work? I am unsure other ways to create a token account for sol... looking into that now myself, all the examples are js 😄
Thanks, that's what I thought. So in order to initialize my program with a SOL token account which the program will be able to transact out of, I would need a new token account which I would transfer ownership to the PDA?
In solana the way you transfer authority "to the program itself" is via a PDA, because if the authority/owner were literally the program's id, then you wouldn't have any way for the program to sign for that address (this is exactly what PDAs give you: the ability for the program to sign for them)
What do you mean by a PDA key? What you wrote is totally correct, the program can sign for its derived addresses, which means PDAs are what you want to use if your program has authority over some account ("authority" isn't a built-in solana concept, it just means "can sign for some address, and in so doing can convince some other program to do something"—so e.g. having authority over a token account means you can sign in such a way that you convince the spl token program to, say, send some of the tokens somewhere else, etc.)
It worked. Thanks a lot!
From what I understand the program derives the PDA account and sets the authority to be the PDA. Since the program can sign using the PDA + bump, then it can access tokens in the PDA account. Im pretty new but that's my understanding. Im a little fuzzy on what the difference between the PDA key and a PDA authority, can someone clarify the difference?
Thanks for the answer. Let me try it
it looks like your solana version is too old, try to install 1.9.0
in the anchor repo /tests/escrow/
What escrow example are you referencing?
I see. In that case I dont even need to pass this account to the initialize instruction, right - the program can just derive it.
In the escrow example the account under escrow transfers ownership to a PDA account - why not transfer the ownership to the program address itself? Is that less secure?
Hi everyone. I'm new to Rust world.. so couldn't find a fix for this. Anyone can help please?
Ok, then you just need to make sure your program can sign for that address (it'll have to be a PDA). (To be pedantic for a sec, this is different from program ownership. That account will be owned by the system program probably, not your program, but your program will be able to sign for the account's address.)
I figured out my issue!  So my struct has 3 fields other than the public key: a string, and two numbers.  I was trying to memcpm the first number assuming that the string would take up 64 bytes of memory.  But that's the max memory and I was comparing the wrong offset.  So basically I had to convert the string to utf8 and see how many bytes it actually takes up and then use that offset.  And I had to base58 encode the number to compare it.  Thanks for help
Hey guys any idea on how to make your spl token show up in fantom with name and icon and not just address? Looked everywhere I could but can't find anything
no data, just SOL balance.
update: i think issues regarding these lines invoke error messages like:

`149: An associated constraint was violated`.
is the following line considered a constraint?

`associated_token::mint = swap_state.bar_coin_mint,`
can PDAs even store data or balances or are they only for signing (i.e. owning) other accounts?
no, only tokens
Will the account store any data?
The program needs to own that account of course.
Hey people. I'm writing a program that will own a treasury account. What is the best way to go around initializing this account? Should that account be passed to the program on initialization (already created) or should the program generate a PDA account. This account will store SOL tokens.
ty
Whoops `progam.provider.connection`
From https://lorisleiva.com/create-a-solana-dapp-from-scratch/testing-our-instruction
```
it('cannot provide a topic with more than 50 characters', async () => {
        try {
            const tweet = anchor.web3.Keypair.generate();
            const topicWith51Chars = 'x'.repeat(51);
            await program.rpc.sendTweet(topicWith51Chars, 'Hummus, am I right?', {
                accounts: {
                    tweet: tweet.publicKey,
                    author: program.provider.wallet.publicKey,
                    systemProgram: anchor.web3.SystemProgram.programId,
                },
                signers: [tweet],
            });
        } catch (error) {
            assert.equal(error.msg, 'The provided topic should be 50 characters long maximum.');
            return;
        }

        assert.fail('The instruction should have failed with a 51-character topic.');
    });
```
hmm, it says `Property 'connect' does not exist on type 'Provider'`
Nooby question: does anyone have an example of a js/ts test where a smart contract is expected to throw an `Err` ?
await program.provider.connect.getAccountInfo(theAccountPubkey)
is there a way to output the bytes in an account? would help for my testing to see what value I need to compare with
what I was referring to was this one in particular:

> a.toArray(endian, length) - convert to byte Array, and optionally zero pad to length, throwing if already exceeding
https://www.npmjs.com/package/bn.js?activeTab=readme
signed works as well. I guess it makes sense haha
ok I'm wrong
I might be wrong about the signed bit. Let me see (I always use it for unsigned)
ah I shouldn't need since it's signed 16 bit
BigNumber (bn.js), a popular library to handle numbers that cannot be contained in js `number`. But it is for unsigned (I think? 🤔 )
how can I check how it got serialized?  I wrote the implementation for this
what is BN?
it's `i16`, will try to find a similar technique.  thanks!
Feel like there's got to be an easier way though lol, that buffer stuff is so gross :/
How about using BN's `toArray` ?
You would have to check how that number got serialized. For example if it's a u64 and got encoded as little endian, you would do something like
```.js
let buf = Buffer.alloc(8);
buf.writeBigUInt64LE(123, 0); // ugh
base58.encode(buf)
```

**Error: 3012: The program expected this account to be already initialized**

Getting this error for an Account<'info, TokenAccount>  which does not exist. I tried specifying #[account(init, payer=payer)] but for some reason this does not compile? What am I doing wrong?
Ok I think I answered sideways again. The issue is the type of what you compare to, a number like you wrote
Looks similar to what you have I think?
```
    {
      filters: [
        {
          memcmp: {
            offset: XXX
            bytes: base58.encode(Buffer.from("string I look for)),
          },
        },
      ],
    }
```
is a working filter
I have a rust syntax question, can anyone help?

For `memcpm`, I need to supply a `bs58` encoded value, but my value is a number, not as string.

`bs58.encode(Buffer.from(`${aNumber}`)),` does not work

This is in a test
urgh finally...thanks for that had to change it to my specific directory


//////////////////////////////////////////////////////////////////////////////////////////

Sorry, the issue with my janky `msg!` approach (I think)
what did u mean by this btw?
for sure, give me a few min
Yeah, just as long as it actually reproduces the error lol
Ok, well, would be pretty easy for me to debug locally I think, just kind of awkward remotely
if i put together a minimal lib.rs is that cool too? and you can just paste it in a new anchor program
i do not 😦 but i can put something together if you really need it. but uh, it's a large codebase and such, and confidential. but let me see if i can put together a minimal codebase that singles out the problem
Do you have this in a github repo anywhere?
yep
```
'Program 8yBiqm4eZjDQACD5JnZrvoKB6nyE9xDh3yvMiPnWtTpL invoke [1]',
'Program log: Instruction: DoStuff',
'Program 11111111111111111111111111111111 invoke [2]',
'Program 11111111111111111111111111111111 success',
'Program 11111111111111111111111111111111 invoke [2]',
'Program 11111111111111111111111111111111 success',
'Program log: ostensible owner: 23E8Ff9cicYffUCFEvbuVyySu7nhr8rzLefTrCjjVf3H',
"Program log: wtf is this thing's owner: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
'Program log: Custom program error: 0x7df',
'Program 8yBiqm4eZjDQACD5JnZrvoKB6nyE9xDh3yvMiPnWtTpL consumed 74024 of 200000 compute units',
'Program 8yBiqm4eZjDQACD5JnZrvoKB6nyE9xDh3yvMiPnWtTpL failed: custom program error: 0x7df'
```
`Owner: 23E8Ff9cicYffUCFEvbuVyySu7nhr8rzLefTrCjjVf3H`
Gives the proper owner when i log it in js (user pda)
Can you post the full program log? (Always easier to understand than snippets)
Lol, macros are weird
Ohhh, hmm, I think I see what the issue is
What if you check the owner in JS?
thanks!
:/
<@!134416332509675520> this is exactly what i have for when the account is created
maybe this video could give you some pointers (there might be better resources on Google, I'm not sure): https://medium.com/gitcoin/commit-reveal-scheme-on-ethereum-25d1d1a25428
But when I check locally what I wrote above seems to jump to the right owner
So I wonder if that's actually your problem (though still possible I'm just confused)
As far as I can tell locally `.owner` should actually give you the user space owner, not the underlying account owner
Is it possible you accidentally set its owner to the spl token program? 🤔
commit/reveal is a way to deal with these things. You basically "commit" an obfuscated proof  of what the users chose, and "reveal" the choices once both have played their turn
how would i check for the authority
i guess .owner is the program owner? not the authority?
Well, huh
yeah i was about to say xD
Oh, whoops, 1 sec
```
'Program log: ostensible owner: B6UtLbKjQHCYgHfjxAqBb2QvWRBp1MhpZTyAXJaLuBE3',
"Program log: wtf is this thing's owner: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
```
👀
there are some rock paper scissor games coming out, is there a way to obfuscate the user's choice so that the opponent couldn't see it
ill try lol
u crazy man
Hacky thing to try:
```.rs
#[account(
    init_if_needed,
    payer = signer,
    seeds = [b"muh seed"],
    token::mint = spl_mint,
    token::authority = {
        msg!("ostensible owner: {:?}", usePDA.key());
        msg!("wtf is this thing's owner: {:?}", user_token_account.owner);
        usePDA // maybe usePDA.clone() if you get an error
    },
    bump = thebump
)]
user_token_account: Account<'info, TokenAccount>,
```
yeah, when it's created, the authority is the same as the authority im specifying when modifying it, i just double and triple checked :/
but ill have to rethink to only use ints
yeah its a multiplier (game) that can be a decimal
You can always use a numerator and a denominator separately, as u64s or whatever (don't quote me on that)
it is also expensive in terms of compute budget compared to integer operations. If your call is heavy that might cause issues down the road
Why did you want to use floats in the first place? To get like a percentage of something?
I will multiply by 10 and just have not as granular inner workings
damn ok
I'm not sure anchor supports this yet (it's pretty rare to use them, tbh)
Ahh, any way to pass in floats?
BN is also purely for integers, so will auto-truncate any float stuff
Is the owner/authority of that token account definitely `usePDA`?
Because im retarded 😄
I have the same terminology than you in mind for some reason. But definitely owner vs authority sounds more distinct and less confusing that program vs user-space owner
Right, so why are you using floats at all? I'm confused about that
this is all i get
```
'Program 8yBiqm4eZjDQACD5JnZrvoKB6nyE9xDh3yvMiPnWtTpL invoke [1]',
'Program log: Instruction: DoStuff',
'Program 11111111111111111111111111111111 invoke [2]',
'Program 11111111111111111111111111111111 success',
'Program 11111111111111111111111111111111 invoke [2]',
'Program 11111111111111111111111111111111 success',
'Program log: Custom program error: 0x7df',
'Program 8yBiqm4eZjDQACD5JnZrvoKB6nyE9xDh3yvMiPnWtTpL consumed 51089 of 200000 compute units',
'Program 8yBiqm4eZjDQACD5JnZrvoKB6nyE9xDh3yvMiPnWtTpL failed: custom program error: 0x7df'
``` 
😦
<@!134416332509675520> Thanks, I ended up doing something like that. You end up losing the decimals when you try to transfer. Im running into issues passing in f64 as a type for an instruction argument, is that not supported? Trying to us BN on the JS end.
yeah im just repeating what u said lol
program owner, the token program, like u said, and the user owner, which i guess is the same as authority
Can you show the full program log?
sorry i meant token accounts
yeah that's what im doing. here's what i have, and it's the same for the context in which i init or just modify
```
#[account(
    init_if_needed,
    payer = signer,
    seeds = [b"muh seed"],
    token::mint = spl_mint,
    token::authority = usePDA,
    bump = thebump
)]
user_token_account: Account<'info, TokenAccount>,
```
but i still get the token owner constraint error from anchor
I think it's much easier to think in terms of "which program can mutate this account" (program owner) and "how does something or someone sign for this address" (depends on address type: keypair addresses use their private key, PDAs get their deriving program to sign for them)
System accounts don't store any separate owner field etc., it's just their address
What do you mean for system accounts? What's the user space owner of a system account? I guess the address itself?
yeah the naming is awful lol, i also know for system accounts there are 2 owners, program owner and user space owner
And you have to provide `token::authority` whenever you init a token account, regardless of whether it lives at a PDA
Anchor uses "authority" for "whoever needs to sign", and owner for "program that can mutate or spend this thing's money"
The spl token program unfortunately picked a crappy name for the token authority thing, and *also* called it "owner"
`owner` in anchor means the *program* owner, which for a token account is always the spl token program
`token::authority` is the "owner" of the tokens, aka whoever needs to sign in order to move them
couple things im confused about for TokenAccounts

1. seems that if I init a PDA token account, i have to provide `token::mint` and `token::authority`. What exactly is the authority?
2. seems that if i access that same token account later i get a `ConstraintTokenOwner` error. I assume this is related to the `owner` field defined in here
https://docs.rs/anchor-derive-accounts/0.19.0/anchor_derive_accounts/derive.Accounts.html
so what exactly is the difference between authority and owner?
Whoops, think my discord got confused about the timeline, not sure why I had that message in my view
Gotta run anchor build first
Mm, you can do `(the_lamports as f64) * 9.123` for example. Not 100% sure why you want to do that though
This is what worked for me. Thanks man! Don't know wtf the issue is/was
super dumb question... but how do we multiply lamport amount by a float? how are decimals handled?
I want to receive the compiled message as an instruction data, but it says the BorshSerialize is not implemented for Message structure. Is there any workaround to receive raw data and transit it into Message format?
Great! This also means I wont't need the `is_initialized` field.
Yep! This is actually exactly what the `#[account(zero)]` annotation is for 🙂 It says "I haven't had a chance to set this thing's discriminator yet"
How can I initialize it before and have anchor just write state to it
Is it possible to just check whether an account is empty? I have an account that cannot be initialized using CPI (it's too big), so I need to create it before I call my contract. But if I initialize it in an instruction before, anchor will complain that it doesn't match the 8 byte discriminator.
protip
```javascript
TypeError: src.toArrayLike is not a function
```
means you're passing in `this_arg` as a string and not using `new anchor.BN(this_arg)`
anyone can explain this error to me installing anchor ? warning: /usr/local/include/string.h:50:26: error: unknown type name 'hashkit_string_st'
Don't think so, no (I only use it when some other program does, e.g the spl token program)
is there any point in using `solana_program::program_option::COption` vs the std `Option`?
AccountInfo is solana's low-level type for an account. Calling `.to_account_info()` on an Anchor account gives you the low-level solana account that was used to create the anchor one.
how to understand to_account_info() works?
Sometimes code just need a little discord encouragement 😌
I.... don't ..... even.... now it works just fine lol. zzzzz
sure, let me modify the code to that option again
Could you say more about what goes wrong then? Think I'm confused
no, just need a regular account
Do you need the account to be a token account? (The wrapped-sol approach)
I'm confused, why doesn't a system_program owned account work?
zzz this is so annoying:
- I need a treasury account for SOL balance which the program would be able to debit.
- I tried passing a PDA derived from programID - this account cannot be "init" because then it requires token::mint and token::authority which ends up creating a wrapped sol account. If I dont specify init, and transfer lamports for rent before calling the program, then the account is owned by the system program and the instruction will not allow it because it is not owned by the program.
- I also tried passing in a random account generated with Keypair.generate(), which I also added lamports for rent. My plan was to transfer the ownership of that account to a PDA owned by the program, but then again, I cannot transfer this ownership because this new account is not owned by my wallet. I also tried to add that treasury account as signer (I assumed it would need to sign to transfer the ownership) but that didnt work either.
I'm not sure about the cli syntax to close that account, but I'm pretty positive there will be a cli command to do it
Ok, so the account is owned by the spl token program
Mm, every account in solana has a program owner (there's also other notions of ownership, like token ownership, that are separate concepts—only program ownership is relevant for closing an account)
this is the account: https://solscan.io/account/FEUBkELRxknLBLRK6NW4twh68bGmpHpYNkEpyj6WKMBh?cluster=devnet
the owner is not a program, but my wallet address
Which program owns the account? That's the important thing—in general you always have to ask the owning program to close the account for you
my wallet is owner of an account, how do I close that owned account (i.e. transfer funds back to my wallet)? Trying to do that via cli
im gonna come back tomorrow i think you answered my question already
How is the multisig implemented?
I think that sounds ok (not totally sure if it's the best solution, but nothing sounds impossible/wrong, lol)
that is my train of logic. unsure if it's flawed.
I want a multisig as an ata owner because the funds there would be controlled by a group rather than one person, but an ata specifically because the group would choose to transfer funds into and out of the multisig wallet (multisig pda i guess).
I want to make a multisig wallet the owner of an ata on spl token program.  custom token. Transactions in the program therefore need users (my multisig one of them) to sign, before going through. Everyone but multisigs would just be a useAnchorWallet kind of thing, but because the multisig is only a pda, it is only an address, and thus has no private key, and cant be a keypair, and can't sign
Can you say more? It's true that PDAs aren't keypairs, but that wouldn't necessarily mean they can't be used in a multisig (they can still be signed for)
If it's owned by your own program though (I don't know, maybe you also want to store some data in there), then it doesn't really matter—you don't need a signature in order to transfer money from your own accounts
if its a pda, isnt that only an address? eg: it's not a keypair, and can't really sign...
apologies for the interruption. I'm trying to set up a multisig but it says on the docs a multisig can be used where "pubkeys" are used, and i'm in turn facing a similar "i need a keypair" problem
Whether you need to sign for it depends on which program owns it—if it's going to be owned by the system program, then yeah, you'll want it to live at a PDA so your program can sign for it (necessary in order to convince the system program to transfer its money)
That's the thing - my treasury account needs to be signable by the program (so it can debit it). So that probably means it should be a PDA? and to initialize it, I would need to send it lamports for rent before it is used by the program?
No—mutating/spending money is entirely about which program owns the account. E.g. you can have a token account (always owned by the spl token program) that lives at one of *your* PDAs. Maybe I'm misunderstanding your question though 🤔
If all you're using an account for is to hold sol, you actually don't even need to init it—you can just send it money and it'll just magically exist (though be aware that even empty accounts require a bit of rent, so if you send too little sol the rent collector will just take it from you 😆)
with custom token you would use mint account and do mint.createAccount(), but how do you do it for a regular account (to hold the vanilla SOL balance)
Does anyone have example code how to create a new account in JS/TS?
Given this, can account which is derived from a program (i.e. PDA) hold balance (it would be owned by the system program). And in that case only that program would be able to debit the account, since only the program can sign for that account, right?
Essentially, if an account lives at a program derived address, only that program can do debit the account / mutate account data, right?
the owner is the token program, right, thanks
You can't pay for creating accounts with sol from an ATA
i am stumped i tried to add field to my struct and now i get ``     RangeError [ERR_OUT_OF_RANGE]: The value of "offset" is out of range. It must be >= 0 and <= 102. Received 3821286566`` for everything
so did you find a workaround to this? I'm trying to send SOL from an ATA, and bumped into a similar problem to you
do I need to instantiate a new intermediary account and use it?
if I usually used a CPI call to do a transfer instruction, does that mean that if I'm passing that account to a different CPI call, I won't be able to trigger the transfer? even though I'm passing the signer?
yeah it should
The vec's provided is empty and the strings are "Random" and "RAND" which should fit the space constraints right?
here 256 bytes mean limit right, so you have to provide data according to it, see provided field exceed the limit or not
for holding data length
just tried it, I'm getting the same error. What's the reason for the extra 8?
try this one
8 + 8 +32+32+256+256+256+256
But the error is the same
So I've tried 8+32+32+256+256+256+256 which seems to follow the space constraints
you have to calculate the total bytes, like 
u64 take 8 bytes
Pubkey take 32 bytes
In string we have to provide limit like upto 256 bytes or so
same with vec
```    #[account]
    pub struct VaultAccount{
        pub mint_fee: u64, //divided by 1000 for minting fee, so 1 is 0.1% fee
        pub vault_mint: Pubkey,
        pub authority: Pubkey,
        pub vault_name: String,
        pub nft_creators: Vec<Pubkey>,
        pub nft_symbol: String,
        pub nft_accounts: Vec<Pubkey>

    }```
share your `VaultAccount` struct
```    #[derive(Accounts)]
    #[instruction(mint_bump:u8)]
    pub struct InitializeVault<'info> {
        #[account(init, payer = authority, space = 8+64+64)]
        pub vault_account: Account<'info, VaultAccount>,
        #[account(mut)]
        pub authority: Signer<'info>,
        #[account(init,
            space = 8+64+64,
            payer = authority,
            mint::decimals = 16,
        mint::authority = vault_account,
        seeds = [b"mint".as_ref(), vault_account.key().as_ref()],
        bump = mint_bump,
        )]
        pub vault_mint: Account<'info, Mint>,
        pub rent: Sysvar<'info, Rent>,
        pub token_program: Program<'info, Token>,
        pub system_program: Program<'info, System>,

    }```  Tried to allocate ore space to both accounts and still get the same error
I think you are providing inappropriate space, try space = 8 +64 +64
Any ideas why? It seems pretty straight forward
I keep getting ``` Error: 102: The program could not deserialize the given instruction``` on this instruction ```    #[derive(Accounts)]
    #[instruction(mint_bump:u8)]
    pub struct InitializeVault<'info> {
        #[account(init, payer = authority, space = 64+64)]
        pub vault_account: Account<'info, VaultAccount>,
        #[account(mut)]
        pub authority: Signer<'info>,
        #[account(init,
            payer = authority,
            mint::decimals = 16,
        mint::authority = vault_account,
        seeds = [b"mint".as_ref(), vault_account.key().as_ref()],
        bump = mint_bump,
        )]
        pub vault_mint: Account<'info, Mint>,
        pub rent: Sysvar<'info, Rent>,
        pub token_program: Program<'info, Token>,
        pub system_program: Program<'info, System>,

    }```   ```    pub fn initialize_vault(ctx: Context<InitializeVault>, _mint_bump: u8, vault_name: String, nft_creators: Vec<Pubkey>, nft_symbol: String, mint_fee: u64) -> ProgramResult {
        let vault_account = &mut ctx.accounts.vault_account;
        vault_account.mint_fee = mint_fee;
        vault_account.authority = *ctx.accounts.authority.key;
        vault_account.vault_name = vault_name;
        vault_account.vault_mint = *ctx.accounts.vault_mint.to_account_info().key;
        vault_account.nft_creators = nft_creators;
        vault_account.nft_symbol = nft_symbol;
        Ok(())
    }```
Thanks!
"anchor test --skip-local-validator"
just do
and when you test
you can manually run solana-test-validator
if anchor test by itself doesnt work
I don't have a test validator running in the background or anything
Does someone know why I keep running into this error when I run ``anchr test``? ```Error: failed to get recent blockhash: FetchError: request to http://localhost:8899/ failed, reason: connect ECONNREFUSED 127.0.0.1:8899```
I know, but I was trying to use associated token address for the program itself
that's already in the context (the first anchor parameter on the rust function) automatically:
ctx.program_id
Can you pass program's own ID as to its instruction?
https://github.com/project-serum/anchor/blob/08174e84a6db0e945e93a91bb1f2770365f68f4c/ts/src/error.ts#L53
love it
Never mind... looking at anchor_client
await provider.connection.getAccountInfo
How do I do this, but in Rust
`Custom program error: 0xbc4`
3012??
how does one deciper this???
Hi, I'm trying to install anchor on MacOS with this command line: cargo install --git https://github.com/project-serum/anchor anchor-cli --locked, and i keep having this issue as it shows on the terminal picture above, any help would be welcome, thank you
can program also have an ATA?
sure
yeah, but I probably need to add constraints on those accounts so they match the native_mint and spl_token no?
authority also needs to be an account
you might need to pass in the mint as an account as well
spl_token::native_mint::ID
whatever the sol mint address is
I see. What would the values for those be if I want to use a SOL token account?
with mint and authority
`token::mint`, `token::authority`
you need to use the right synatx
yeh, you can't init a token account like that
oh right
36 | #[derive(Accounts)]
   |          ^^^^^^^^ function or associated item not found in `TokenAccount`
usually there's an error message
Why does this not compile?
#[account(signer)]
    pub initializer: AccountInfo<'info>,

    #[account(
        init,
        seeds = [b"somethign".as_ref(),],
        bump = token_bump,
        payer = initializer
    )]
    pub pda_account: Account<'info, TokenAccount>,
Especially sine localnet will keep that pda balance ongoing every test you run >>
Hello, hoping someone can help me with some debuggin too. How can you check the sol balance of a pda before and after a transaction in your typescript testing? Getting the account info with `const pda_info = await provider.connection.getAccountInfo(pda)` and printing it seems to always print the latest, even if I have await.. what am I missing?


//////////////////////////////////////////////////////////////////////////////////////////

you got to pass in a commitment or config the provider object to not default to recent
Just tried, I get this error  -> Error: Using Connection with default commitment: `recent`, but method requires at least `confirmed`
Boom. That did it. Thank you. 🙂
create the tx, that returns the sig, then call `getTransaction` and it returns the tx object with a fee field
So uninstall that npm thing and install the anchor cli directly from cargo (explained in the installation instructions)
I think there is, looking at the `Provider` class looks like it defaults to recent
Sounds like you're on mac, in which case you shouldn't use the npm anchor-cli package (the installation instructions actually say this, it's just easy to miss)
not sure it is related, I want to get it in my typescript tests to ensure amounts are correctly calculated in program side
Has anyone ever encountered this error before? Trying to install dependencies, but hitting a snag.

```
➜  projects anchor --version
Only x86_64 / Linux distributed in NPM package right now.
Trying globally installed anchor.
Globally installed anchor version is not correct. Expected "anchor-cli 0.18.2", found "anchor-cli 0.19.0".
```
Cool. Not sure if there is a tweak/option to the provider or RPC call itself that allows to wait for confirmation.
do what I just did
ty ser
ah that did it
hi guys, is there a way to get fees for a transaction? can't find anything in docs
lemme try
I am not certain about whether the rpc call waits for confirmation. Have you try a dumb sleep between the call and the `getTransaction` ?
```
testCase() -> {
  invokeInstruction()
   makeRpcCall()
}
```
it should be, all the calls happen within the context of a test case
can you make a channel or thread for faq's?
is the test validator still running when that `getTransaction` function gets called?
I can see the logs in `.anchor/program-logs`
hey I'm trying to check out tx logs from a test context. I create tx and then use the signature `provider.connection.getTransaction(signature)` but get a null response
ok let me try
(Temporarily forget the custom error)
Try doing this instead:
```.rs
constraint = {
  msg!("actual token amount = {}", token.amount);
  token.amount == 1
}
```
I cannot ... compiler throwing error its a field and not a function
I really need to make myself a scratchpad program for quick checks like that
Purely guessing here haha
oh ok let me try this out
if it is the same type as used inside the function, it might actually be `.amount()`?
oh so .amount does'nt gives the balance of that token ?
You might be right that it is simply `.amout` that is wrong
but that does'nt makes sense to me as I'm logging on frontend the amount and checking on explorer as well and the token account balance for that user is 1 but the error contradicts
thanks let me try this out
original message: https://discord.com/channels/889577356681945098/889702325231427584/921100903191306240
```rust
#[account(
    init_if_needed,
    payer = signer,
    seeds = [b"muh seed"],
    token::mint = spl_mint,
    token::authority = {
        msg!("ostensible owner: {:?}", usePDA.key());
        msg!("wtf is this thing's owner: {:?}", user_token_account.owner);
        usePDA // maybe usePDA.clone() if you get an error
    },
    bump = thebump
)]
user_token_account: Account<'info, TokenAccount>,
```
That might help you, let me see if I find it
I saw alan post a snippet to run prints from the constraint
ah wow, ok.
I'm facing some strange issue . From frontend I'm sending a token account of a owner which has balance 1 and on program I'm checking on constraint that amount of that token should be 1 but what happens is sometimes the txns go through and sometimes it throws the error 0x12f = 303 which means the amount is not one

``` 
  #[account(mut, 
        constraint = token.amount == 1   @CustomError::TokenAmountError, 
        constraint = token.owner == owner.key()  @CustomError::TokenOwnerError
   )]
   pub token: Account<'info, TokenAccount>

.....

#[error]
pub enum CustomError {
    #[msg("You are not authorized to call this action.")]
    Unauthorized,

    #[msg("Overflow error")]
    Overflow,

    #[msg("Token hasn't unlocked yet")]
    NotUnlockedYet,

    #[msg("Owner does'nt hold this token")]
    TokenAmountError,

    #[msg("Owner of token and token account passed does'nt match")]
    TokenOwnerError
}

```
Oh thank you!   so the #[account(init, seeds = [b"myseed".as_ref()], bump=mybump, payer=user] macro is what actually creates the account at that address?
Thanks for the clarification. I'll go back to school now
A very common example of an account with data that lives at a PDA is an associated token account. It's a token account (owned by spl token program), so definitely has data, but its address is derived from the associated token program.
PDAness only affects how you *sign* for the address (only the deriving program can sign for its PDAs)
And yes, you can have whatever kind of account you want at a program-derived address (well, almost, for obscure solana reasons it can only be <= 10kb in size, not the usual full 10mb—but other than that it can be whatever kind of account you want)
Yes, PDA = program-derived *address*, not account!
Program side: `ctx.accounts.my_token_account.amount()`
Definitely!
going to just try it out -- probably the best way 🙂
i guess there is no reason the PDA couldn't have data as well.... and probably for most programs they do
like the famous escrow example has the PDA "own" a completely separate "account"
until it is successful -- but even then its just an address -- i.e. a key -- though I guess any data would be written to it?  idk now actually 🙂
yes - I was wrong -- i for some reason thought "FindPDA" was going to make an account --b/c under the covers it calls "CreatePDA"
Nevermind me
Haha I think I'll confuse you further
I always only thought it was A for Address
Thanks yeah!  I guess the fact that accounts need to still be initialized even after you "found" a PDA should have tipped me off
Maybe I'm wrong though, I just googled and someone uses the acronym for Program Derived Account
I agree. You might want to see PDAs as simple signers. Calling them "accounts" might throw you off
How can I check amount of a token account inside the anchor ?
I think its the latter --- PDAs are accounts that are owned by the program -- but a program can have multiple PDAs
this might be a dumb question - but do PDAs have data or are they only used to own other accounts which have data?
In my test code, I'm trying to switch the provider (and the associated wallet), but it seems the program instance derived after switching the provider still uses the old provider. What am I missing?

const secondWallet = new anchor.Wallet(Keypair.generate());
  const secondProvider = new anchor.Provider(
    provider.connection,
    secondWallet,
    anchor.Provider.defaultOptions());
    anchor.setProvider(secondProvider);
    const programOverride = anchor.workspace.SeekersRoyalties as Program<SeekersRoyalties>;
You should likely ask this in the <#889584618372734977>  channel, as it is more closely related to the language specifics on how macros work.
Or any solution to changing the declare_id! value at compile time ?
Can someone tell me why declare_id!("ABC...") works when passing a string, but when using declare_id!(include_str!("filename.txt")) it doesn't because it cannot convert &str to Pubkey?
Found it in source code. nvm
ok thanks <@!134416332509675520> 🙂
Using `size_of` or relying on `Default` just won't cut it (no way to automagically decide how big you want those strings to be)
Yeah. Also, the fact that you've got some dynamically sized types (the Strings) means that you *have to* calculate the space manually (you need to decide how big you're willing to let those strings get)
<@!134416332509675520> I'm trying to find a link to TOML specification for anchor. Can I have multiple providers?
I want to use different wallets in each.
this is my struct I assume I should just go and calculate that manually rather then rely on size_of? 😄 
```#[account]
pub struct MyAccount {
    pub myKey: Pubkey,
    pub myKey1: Pubkey,
    pub myKey2: Pubkey,
    pub myKey3: Pubkey,
    
    pub string1: String,
    pub bool1: bool,

    pub num_32: u32,
    pub num_32_1: u32,

    pub num_64: u64,          
    pub num_64_1: u64, 
    pub num_64_2: u64, 
    
    pub status: Status, // enum
}
```
ah, maybe just me being lazy.. 2 secs let me sanitize it a bit
No guarantee that `size_of` will work in general!
Can you show your account struct definition?
If you want to mutate some account's data or spend its money, you must go through its owning program (you need to ask it, somehow, to do the mutation/spend the money for you)
did you ever find a solution to this? I'm also running into 
```Error: 102: The program could not deserialize the given instruction
```
but I just defined size as this so I assume it should work 🤷 
```
 space = 64 + size_of::<MyAccount>()
```
Ok, perfect.
Got it, the rule in solana is that only an account's owning program is allowed to mutate its data or spend its lamports (no exceptions)
Basically, is mutation via program instructions the only way to mutate the data?
The question is whether only program can mutate this data, or does the wallet that deployed the program also have access to it?
Sure. So when you want to init a data account i.e. Account<'info, DataType>, this account is initialized and its owner is set to the program id
Could you say more about this q? (Or did you already get it answered?) Not sure I understand what you're asking 🤔
Can I have more than 1 wallet? in the test code?
Yeah, this is a funny quirk of how base58 encoding works—you would think "1111111...111" would be have all its bytes set to 1, but no, 0 gets encoded as "1"!
BTW, can someone point me to an example where RPC call is done (signed) by non-wallet account?
Interesting!
Yeah, also Pubkey.default.
system program address
how can i take square root of a u128 , i used precise number  from spl_math crate but sometimes i am running out of compute units so what is the effecient way to handle square root
i.e. uninitialized
is '11111111111111111111111111111111' the value for "empty" Pubkey?
in the JS/TS tests, is it possible to re-run the validator after each test case? the problem is that tests leave state behind which limits what you can test against
but this is signing with the PDA, I get that. I was asking about data account that the program owns. I'm guessing this is done under the hood by solana
https://github.com/project-serum/anchor/blob/db193d824887f12881c93853f3c4821cca5d09b1/tests/lockup/programs/lockup/src/lib.rs#L480
great, thanks
This is why all accounts are owned by the system program by default
Only the program that owns an account has permission to change data on it
If a program owns an account it can changes the data on that account
So the token account owner is the PDA for that reason. The escrow example is a bit dumb though. You should transfer tokens to an intermediate account. You don't want to transfer ownership of an ATA
how does that work for a data account then? How does program sign the data mutation transaction?
Basically the program can't sign, only a PDA can sign
All accounts are owned by programs. PDAs only act as signers in some instances
Isn't the signer the one that sends the transaction? Technically, anyone can do that. I want it only to be possible for the wallet that initially deployed the program to be able to call that instruction.
Just make that account be a signer
All accounts are owned by programs. What we can set to allow a wallet or a program to transfer authority/decrease an account balance is to set the user-space ownership aka authority
absolutely, because they can have many accounts under escrow and to find the correct one for each user
aaaaah ofc
Yes so I think that is to set the "user-space" ownership, which is different from the program ownership
line 54
let (pda, _bump_seed) = Pubkey::find_program_address(&[ESCROW_PDA_SEED], ctx.program_id);
        token::set_authority(ctx.accounts.into(), AuthorityType::AccountOwner, Some(pda))?;
can you show me the exact line you refer to in the escrow example, when you say "the account under escrow is put under ownership of a PDA"
well if you make a data account with init, the account.owner will = program id
From the Solana Docs (https://docs.solana.com/developing/programming-model/calling-between-programs#program-derived-addresses) "Using a program derived address, a program may be given the authority over an account and later transfer that authority to another."
I believe PDAs **are** how you'd make a program own an account, actually
Hi <@!134416332509675520> 
Would you please check my DM?
I have shared my code
Are there any security implications to a data account being owned by the program itself, compared to being owned by a PDA?
The reason why I ask is that in the escrow example, the account under escrow is put under ownership of a PDA. Would putting the program as the owner not be secure enough?
Hi <@!134416332509675520> 
Would you like the code for this one?
- create an account to store the program data
- add it to the context and init the data on the initialize function
I've seen people ask before and I believe they do the same. `pub initializer: Signer<'info>` is the new, cleaner way to run that validation.
Thanks. Will do that then.
how about using the anchor program object to build the instruction only (`program.instruction` namespace), then build the tx yourself, sign it with a brand new `const wrongDude = Keypair.generate()` and send it using a plain web3.js `connection`?
Oh, is there any difference between:
#[account(signer)]
pub initializer: AccountInfo<'info>,

and 

pub initializer: Signer<'info>,
Btw, I want to add some tests to make sure that non-program-owner cannot call certain instructions? How do I specify different caller in an RPC call other than my wallet. I think the wallet automatically signs all transactions, right?
Glad to help! It's a good inspiration for a cookbook entry
Thanks for this tip, this will be very useful in the future 🙂
oh, found it, but does not say much
Where can I see the logs?
I've stopped my local validator and ran pure "anchor test" and now it was properly updated. I never got an error about running it more than once. That is weird indeed.
You should also check the confirmation levels you're using to get the account
The only times I've seen an account not update the data on it are
- not set as mut
- validator is slow and you need to sleep / wait for the account to be confirmed
Add a msg! Call to say you've updated you're data
Have you tried storing the transaction id and looking at the program logs
If it had been initialised
You should get an error message if you ran it more than once
Yeah. But what it could be is that I'm running validator separately. And I did call this instruction several times. That likely means that on consecutive calls it would not initialize the account (since it was previously already initialized) and it would not be mutable?
Are you awaiting your transaction function call in TS
Try sleeping and waiting for your local validator to fully process the transaction
The other most common issue is that you're just not waiting long enough
If it's init in the same transaction then it's automatically set mut
it was initialized in the transaction, I guess it would not need to be specified as mut then?
Have you set royalty account to mut
<@!248066053161222144> question for you friend, for some reason this code here does not update the account properly. I dont get any errors, but the treasury_bump is left uninitialized (=0) after initialize() is executed - while the expected value would be 253.

pub fn initialize(ctx: Context<Initialize>, treasury_bump: u8) -> ProgramResult {
        let account = &mut ctx.accounts.royalty_account;
        account.treasury_bump = treasury_bump;
        Ok(())
    }
It seems like you need to read up on PDAs and also creating accounts via a system program call on chain
If you look how the accounts structure is defined you will see this is not a PDA (they have a seed and bump). This is just initializing regular data-holding account. Now why you need this account as a signer is so you can transfer the ownership of it to the program.
#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 8 + 8)]
    pub my_account: Account<'info, MyAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}
You don't need to specify the space of the account. Anchor will do it automatically unless you're using strings or vectors in your struct
Hi, this is really a beginner question, but I cannot understand quite a bit.

This code is a part of anchor basic example-1
```
await program.rpc.initialize(new anchor.BN(1234), {
      accounts: {
        myAccount: myAccount.publicKey,
        user: provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      },
      signers: [myAccount],
});
```

I believe above code is initializing an account in the way of PDA, since new account is derived from another program(deployed program on rust side), and systemProgram is making it.

But I cannot understand why signers field accepts myAccount.

Isn't that new account is derived from the program?

so why signer is [myAccount]? Isn't the PDA just needs publicKey of myAccount?

Isn't that just not a PDA?

Thank you.
Yes just copy that as is and import to phantom
the contents of that file—a list of ints—is my private key? what command do you use to map it to base58?
function sig of what is being interacted with 
```
pub fn initialize_user(
    ctx: Context<InitializeUser>,
    _user_nonce: u8,
    optional_accounts: InitializeUserOptionalAccounts,
)
``` so makes sense `CpiContext` cant interact w/ it but how can I access the `initialize_user` function with CPI then?
trying to interact with a contract on chain with CPI getting 
```
expected struct `anchor_lang::Context`, found struct `anchor_lang::CpiContext`
``` when I try to pass the context to call it? 

followed this https://github.com/project-serum/anchor/blob/master/examples/tutorial/basic-3/programs/puppet-master/src/lib.rs but substituted the function calls and programs for the one interacting with.
How can I use assert.rejects to check the custom error?
OK, got it
Thanks
Wherever you put your keypair. I keep mine in a diff output folder than the default
```

// The program to execute.
const program = anchor.workspace.Basic1;

// The Account to create.
const myAccount = anchor.web3.Keypair.generate();

// Create the new account and initialize it with the program.
await program.rpc.initialize(new anchor.BN(1234), {
  accounts: {
    myAccount: myAccount.publicKey,
    user: provider.wallet.publicKey,
    systemProgram: SystemProgram.programId,
  },
  signers: [myAccount],
});

```
As seen above, we pass both the accounts and signers for the Context.


```
pub fn initialize(ctx: Context<Initialize>, data: u64) -> ProgramResult {
        let my_account = &mut ctx.accounts.my_account;
        my_account.data = data;
        Ok(())
    }
```

initialize method accepts Context and its generic type is Initialize.

But Initialize struct has no fields for signers.

```
#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 8 + 8)]
    pub my_account: Account<'info, MyAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}

```

I believe we need a signer when making transactions which modify accounts data.

So I thought that's what the 'user' filed of Initialize struct for.

But why we pass signers: [myAccount] when calling initialize method?

Is it internally used by anchor?



Isn't something like below would make more sense?

```
#[derive(Accounts)]
pub struct Initialize<'info> {
    accounts: {
      #[account(init, payer = user, space = 8 + 8)]
      pub my_account: Account<'info, MyAccount>,
      #[account(mut)]
      pub user: Signer<'info>,
      pub system_program: Program<'info, System>,
    },
    signers: ...
}

```

What am I missing?

Is the Initialize struct a subset of Context<Initialize>? since Initialize has #[derive(Accounts)] macro?

Then where can I see the full description of Context?
0x1773 = 6003, and a program's custom error codes start at 6000 now. So that would be the 4th custom error code.
where's this file located? would it not be `Keypair Path: /Users/will/.config/solana/id.json`?
Hi <@!134416332509675520> 
`failed: custom program error: 0x1773`
Would you please explain this error detail?
Do I need to specify the exact size of my account here?

```#[derive(Accounts)]
pub struct InitializeMyAccount<'info> {
    #[account(init, space = MyAccount::LEN)]
    pub my_account: Account<'info, MyAccount>
}```

What about on the client side? I'm coming from Solana with no anchor and I'm very confused as to how I perform the client-side of this instruction. Normally I would create the empty/unintialized program account with the exact amount of space, and then in the same transaction create and provide it to this instruction. Example:

```
  const createMyAccountIx = SystemProgram.createAccount({
    programId: programId,
    space: My_ACCOUNT_SIZE,
    lamports: await connection.getMinimumBalanceForRentExemption(MY_ACCOUNT_SIZE, 'singleGossip'),
    fromPubkey: ownerAccountInfo.publicKey,
    newAccountPubkey: myAccount.publicKey});


  const instruction = new TransactionInstruction({
    programId,
    keys: [
      { pubkey: ownerAccountInfo.publicKey, isSigner: true, isWritable: false },
      { pubkey: myAccount, isSigner: false, isWritable: true },
    ],
    data: Buffer.from(Uint8Array.of(0))
  });
  await sendAndConfirmTransaction(
    connection,
    new Transaction().add(
      createMyAccountIx,
      instruction
      ),
    [ownerAccountInfo, myAccount],
  );
```

However, I can't seem to find code examples of real clients. Just tests. All of the tests use this `anchor.web3.Keypair.generate()` method of creating these accounts, but is that really the de-facto way of doing it? Does anchor automatically take care of creating the uninitialized/empty account and account sizing?
can we read our anchor.toml files into React? what is the preferred syntax?
vim into the file and just copy it including the brackets
hey all. how do i get my local wallet's private key, such that i can load it into my phantom wallet?
If I wanted to reverse engineer a staking contract for learning purposes. Would that project be pure rust or should I bootstrap with anchor
the keypair? or the account? The system program owns all standard wallet-type accounts if I'm not mistaken. Though of course the keypair is your own for signing, etc.
what program
who is the owner of the keypair
when i make a new account on phantom wallet
thank you!
https://github.com/metaplex-foundation/metaplex/blob/master/rust/nft-candy-machine-v2/src/lib.rs#L19
https://github.com/metaplex-foundation/metaplex/blob/master/rust/nft-candy-machine-v2/Cargo.toml#L23
is there such a thing as "anchor_spl" module?   I want to access the "Mint" struct through it but I can't seem to get the import right - probably doing something stupid
like, whatever the case, I imagine Anchor can and will adapt. But I was also kind of relying on the manual signing and sending approach to be able to add signatures to a transaction as a means of validation from an authoritative source. If I can no longer do that, and signature data sent as parameters can not be validated on-chain (my digging has come up with nothing to emulate ecrecover()-style signature validation on-chain in Solana), then I cannot see a way to perform any kind of signature-based validation of transactions or input data... but maybe I am missing something?
looking now
by any chance: https://discord.com/channels/889577356681945098/889702325231427584/921054837695713282 😄
I feel like the interfaces I've seen for the wallet adapters have the signTransaction() and signAllTransactions() methods though, which mirror those from the deprecated methods on Phantom wallet
error is :
```TypeError: src.toArrayLike is not a function
    at BNLayout.encode (/home/gilles/Documents/perso/nft/solana/tuto-nft/buildspace_tuto_solana_rust/myepicproject/node_modules/@project-serum/borsh/dist/lib/index.js:35:37)
    at Structure.encode (/home/gilles/Documents/perso/nft/solana/tuto-nft/buildspace_tuto_solana_rust/myepicproject/node_modules/buffer-layout/lib/Layout.js:1263:26)
    at InstructionCoder._encode (/home/gilles/Documents/perso/nft/solana/tuto-nft/buildspace_tuto_solana_rust/myepicproject/node_modules/@project-serum/anchor/dist/cjs/coder/instruction.js:85:28)
    at InstructionCoder.encode (/home/gilles/Documents/perso/nft/solana/tuto-nft/buildspace_tuto_solana_rust/myepicproject/node_modules/@project-serum/anchor/dist/cjs/coder/instruction.js:70:21)
    at /home/gilles/Documents/perso/nft/solana/tuto-nft/buildspace_tuto_solana_rust/myepicproject/node_modules/@project-serum/anchor/dist/cjs/program/namespace/index.js:32:97
    at ix (/home/gilles/Documents/perso/nft/solana/tuto-nft/buildspace_tuto_solana_rust/myepicproject/node_modules/@project-serum/anchor/dist/cjs/program/namespace/instruction.js:26:23)
    at txFn (/home/gilles/Documents/perso/nft/solana/tuto-nft/buildspace_tuto_solana_rust/myepicproject/node_modules/@project-serum/anchor/dist/cjs/program/namespace/transaction.js:12:20)
    at Object.rpc [as sendSol] (/home/gilles/Documents/perso/nft/solana/tuto-nft/buildspace_tuto_solana_rust/myepicproject/node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:8:24)
    at main (/home/gilles/Documents/perso/nft/solana/tuto-nft/buildspace_tuto_solana_rust/myepicproject/tests/myepicproject.js:83:21)
```
I'm not sure it would be disruptive for Anchor specifically. the wallet adapter widely used right now is from solana-labs I believe. (just a thought, I've not looked into this much)
Hello here, thanks for the great work. As a beginner, I was trying this code but I got into a JS error when testing with 
```// Now let us try to send some SOL to a newly created keypair
  const friendToSendAccount = anchor.web3.Keypair.generate();

  await program.rpc.sendSol(10000 /*in lamports*/, {
    accounts: {
      from: baseAccount.publicKey,
      to: friendToSendAccount.publicKey,
      systemProgram: SystemProgram.programId,
    },
  });

  console.log('Sent sols!');
```
I guess for multi-sig, the secondary signature could get signed first then the transaction can be handed off to the wallet to sign and send, but doesn't the first signer normally pay for the transaction? So I feel like that may not work
so I found this:
https://docs.phantom.app/integrating/sending-a-transaction

but this makes me wonder: the signTransaction() function is deprecated on Phantom wallet now, but all the wallet adapters that I've seen leverage that function for the rpc hooks (and the new supported function on phantom is signAndSendTransaction()). That makes me wonder how disruptive this will be to Anchor once that functionality is dropped, and also for things like potential for multi-sig too.  😬
Yeah Github is sorta Google for Solana right now haha
that's how I imagined it going. I wonder if there's any documentation about this process. It seems that everything is still so new in the ecosystem that many details are often not easily confirmed through a google search
All a guess, though
Now I am wondering why simulation does not require the user to sign. But in the end the Phantom extension has full control over your private key, so it probably does sign the tx -> simulates -> displays balance change -> waits for you to click to send the real deal.
Actually I believe these two things have nothing to do with each  other. I think phantom _simulates_ a transation to display the expected balance change
yeah, I'm pretty new to everything, so I haven't used phantom too much, but I assume phantom prompts for a signature for this kind of stuff. So I am wondering how they would know what amount to prompt the user to approve
Do you mean the phantom feature?
I was wondering about transferring SOL, if you perform this on-chain as a result of some calculation, but the signature has to be signed by the client's web3 wallet before submitting, how does this approval work? I assume the client signs for the amount of SOL that they will be transferring? How does the wallet know how much SOL is going to be transferred before this occurs?
How can I get the program_id inside lib.rs?
I'm also using this code as a example of how to use find_program_address, maybe can help you https://github.com/anatoliprodev/custom_auction/blob/008458453f4385fa806f249cae1d6506a8465b8e/src/instruction.rs
<@!134416332509675520> tagging u since u were part of that convo
trying this now, is there no need to specify that lamports left the escrow account to bob's account?
ty!
Perfect
https://docs.rs/anchor-lang/latest/anchor_lang/prelude/struct.Pubkey.html#method.find_program_address
Yes there is also a find_program_address. Let me see where it is
yeah
You mean derive a PDA address from seeds in a contract?
is there anyway to easily derive addresses in the function
Thank you very much
Just removed the baseAccount from signers and it worked
I ctrl + left click on the log and I was moved to a signer verification function
It's exactly this
You probably have another issue though, here. You are passing baseAccount (a PublicKey) as signer to the tx. However `signers` is an array of Keypair or Signer objects (those are the types which have a `.publicKey` field)
If you want to display a pretty version for instance, you can do `baseAccount.toString()`
Actually the first log shows you that baseAccount is itself an object of type PublicKey
I'm sure that is something really silly
Hi guys. I really don't understand what I'm doing wrong here. Console.log baseAccount show me he have a public key but when I try to console.log baseAccount.publicKey he returns me undefined.
ok yeah - that was it
b/c I see this: error: failed to download `solana-frozen-abi v1.9.1`
i'll try upgrading solana
i made a new anchor project and then got this on build
is there a usual cause when seeing this error:
consider adding `cargo-features = ["edition2021"]` to the manifest
Heh
this is gonna take a while lol
<@!134416332509675520> well, when i condense it into a seperate program and test it, it works, i have no clue what the issue is
o


//////////////////////////////////////////////////////////////////////////////////////////

Nevermind, I added an `if (wallet) {}` around the `provider` initialization. That should do I guess.
Just did that, got this error,

```
Argument of type 'AnchorWallet | undefined' is not assignable to parameter of type 'Wallet'.
  Type 'undefined' is not assignable to type 'Wallet'.
```
useAnchorWallet
Can someone help ? Trying to run anchor build

Things I have tried - Uninstalling solana and installing again but same response

anchor cli version - 0.19.0
solana cli version - 1.9.1

```
BPF SDK: /home/mship/.local/share/solana/install/releases/1.9.1/solana-release/bin/sdk/bpf
cargo-build-bpf child: rustup toolchain list -v
cargo-build-bpf child: rustup toolchain link bpf /home/mship/.local/share/solana/install/releases/1.9.1/solana-release/bin/sdk/bpf/dependencies/bpf-tools/rust
error: not a directory: '/home/mship/.local/share/solana/install/releases/1.9.1/solana-release/bin/sdk/bpf/dependencies/bpf-tools/rust/lib' ```
For this piece of code, 
```
const wallet = useWallet();

const getProvider = async () => {
   const connection = new Connection(
      "https://api.devnet.solana.com",
      "processed"
    );
    const provider = new Provider(connection, wallet, {
      preflightCommitment: "processed",
    });
    return provider;
};
```

The `wallet` is of type `WalletContextState` and the constructor for `Provider` expects a type of `Wallet`.

Hence I get this error, 
```
Argument of type 'WalletContextState' is not assignable to parameter of type 'Wallet'.
  Types of property 'signTransaction' are incompatible.
    Type '((transaction: Transaction) => Promise<Transaction>) | undefined' is not assignable to type '(tx: Transaction) => Promise<Transaction>'.
      Type 'undefined' is not assignable to type '(tx: Transaction) => Promise<Transaction>'.
```

**Any workarounds?? **I was thinking of using an older version of `@solana/wallet-adapter-react` so that it doesn't return a `WalletContextState` which I believe is something recently implemented.
basically someone will own the account at pda2 -- or will own a token associated to it - so want them to be able to point back to pda1 who is their "parent"
Ok thanks -- just checking that general its ok to store keys in data  -- but I guess that should have been obvious
Not sure one is better than the other, but I often use the seeds approach (just one less thing to store in an account). Guess it depends on what you're trying to do/how you want to remember your addresses.
will try with the data approach
Is it possible if I can have multiple anchor versions installed and switch them accordingly ?
If i want to tie a new accounts PDA (pda2) to another PDA (pda1) -- is better to make pda2 include pda1 in the seed?  or put pda1's address in pda2 account's data?
ahhhh 🤦‍♂️ I was missing that on the Program A (the one doing the cpi) thank you again. Do you guys have a tip jar? I feel like I should be giving back after all these silly questions 😂
Nope, you actually can't sign from the client for a PDA (only a PDA's deriving program can sign for it!). That error means you forgot to mark the account as `#[account(mut)]` in your rust program.
in this case, do you need to provide anything in the `signers` array on the client? Right now I just pass something like this;
```            {
                accounts: {                                
                    pdaAccount: pdaAddress,
                    otherAccounts..     
```
But I run into this error, where I see the `<pdaAddress> writeable privelege escalated`;
```
Cross-program invocation with unauthorized signer or writable account
```
which I guess means I am not signing properly
Got it. Did you get your earlier question answered then?
A multisig wallet is an account struct at an address that does the multisig magic (owner vec, signing, checking signers etc). But the actual address used during transactions isn’t the multisig itself then. It’s another key pair
Nope. In general in solana you always have to pass in any accounts your tx cares about (no exceptions).
Is it possible to init a PDA account in Program B via CPI from program A without the client having to pass in the PDA? 

I was hoping to generate seeds and do the findProgramAddress etc inside of Program A, but I don't think I really understand why that can't be done without the client passing in the pda
something like that: https://github.com/project-serum/anchor/blob/master/tests/chat/tests/chat.js#L7 would setup the wallet properly. Are you using something similar?
I suspect something it not right in `const provider = getProvider();`
can you print `provider.wallet.publicKey`
Can someone help me with this error?: "Wrong input type for account "user" in the instruction accounts object for instruction "startStuffOff". Expected PublicKey or string". More details: https://stackoverflow.com/questions/70403156/wrong-input-type-for-account-user-in-the-instruction-accounts-object-for-instr
You could of course store lamports on an account owned by your program though?
If I understand your question, no. What people usually mean by a wallet is an owned by the system program that just stores lamports.
Or rather, do all accounts from all programs, wallets, everything, take up space and are located on the system program
Can the pubkey of a walletkeypair also be an account struct on a program?
As a separate observation from a very new solana/anchor dev, I am surprised that (for a Metaplex NFT transfer) the developer has to handle the lamport transfers to pay each creator's cut themself before doing the token transfer.  I guess I figured the cut would be taken automatically when the token is transferred, but it does make more sense now.

Trying to piece it together, does that mean that this transaction would fail if the NFT creators are not credited the proper percentage of the rest of the lamports transferred in this instruction?
actually if it's causing one creator to not be sent it's fair share maybe it _is_ the reason, but I'm unfamiliar
I know this is 10 days old but you've got a bug in this code, ```else if y == 4 {
                        if i.address != *ctx.accounts.creator1.key {
                            return Err(ProgramError::Custom(0x1));
                        }

        
                        let temp =  sfb_cut as u64 * i.share as u64 / 100;
                        
                        **ctx.accounts.offer.to_account_info().try_borrow_mut_lamports()? -= temp;
                        **ctx.accounts.creator4.to_account_info().try_borrow_mut_lamports()? += temp;
                    }```
it's checking against `ctx.accounts.creator1` instead of `ctx.accounts.creator4`
Don't think it's related to your problem though
Hi, I'm bit confusing with the program account and the app account, and the managing of data, can any one explain. how that actually works? and in terms of accounts and its storing of data.
where can find the explanation for the best to understand.
No guarantees, just extremely (extremely) unlikely to have a collision
✨ math ✨ haha
how does solana ensure generated keypairs are new and never before used
``program.account.yourAccountType.subscribe(someAccountAddress).addListener("change", freshAccount => {
  // do stuff with the account
});``
Never mind, found it in Discord history
https://github.com/bonedaddy/event_test/blob/main/programs/event_test/src/lib.rs
Like how do you listen to an event such as the one in this repo?
Was reading the source code and came upon it and think it can solve some of my problems
Does someone have a good example of the #[event] macro in Anchor
On that version of anchor your custom errors would start at 300, so 311 would be the 12th one.
Why am I getting this error on localhost?
`Requesting airdrop of 1 SOL
Error: airdrop request failed. This can happen when the rate limit is reached.`
If I wanted to subscribe to web sockets to get updates on a Solana smart contract - any suggested resources?
I know the docs but would like to see an example implementation

I'm trying to get to the bottom of an error. Came up 0x137 which is 311. How far down an error code list is that?
It worked!  I made the PDA and could read back the data I put in it.
Are you on an M1 mac by any chance
Do you have SOL in the wallet you use to deploy?
sorry coop -- not ignoring you - but that error is pretty grim -- did deploying ever work?
Need help deploying project.  I keep getting "Error: Deploying program failed: Error processing Instruction 1: custom program error: 0x1
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }."
frgt to change lamports to sol. tysm
anchor --version
anchor-cli 0.19.0
fwiw
I thought i was going to take down devnet or something -- so I switched to localnet and had the same
Nope, if it's working you should be able to see the change
seems to be working ok - but when I deploy a program I see 
msg 7UsTL2sy9Fblahblahblah.... 
like 180 times --
when i invoke system_instruction::transfer on localnet, it does not reflect a change in lamport/sol balance in the localnet wallets. is this normal?
oh u know what, my fault!
yea with a struct
Is it an actual account, like with a struct etc.? How much space are you using?
maybe I'm doing something wrong, but when I init a PDA I expect that it'll be funded with a minRentExempt balance but instead it's being funded a little extra + minRentExempt
if u go with the latter then no need 2 sleep
or ` const provider = anchor.Provider.local( undefined,  { commitment: 'confirmed', preflightCommitment: 'confirmed' })`
sleep
yea so do exactly what was suggested to me haha
both commitments return null


//////////////////////////////////////////////////////////////////////////////////////////

eh shit. Upon startup i want to initialize the account if it hasn't been created before, and then i want to reset counter to 0. So i send those two instructions. Now ix 1 will fail, and then not do the reset. Any thoughts without using init_if_needed?
the takeaway
- one of the issues with using `init_if_needed` is that you could end up running initialization logic twice, and unintended bugs could slip in where the already initialized account is reinit with alternate values or changed somehow
in fact, thank you for giving me a great example to share with people in the future
thank you. deleted
it leads to exactly the kinds of bugs you already ran into
I don't 🙂
unless you have a really really compelling use case
yes
So is it better to just call init, and then let the tx fail if it's already 'init'ed?
there's something i've seen in code `cfg=test` but never actually used myself
please delete `init_if_needed`though, is there really ever any reason you need to call initialize twice
Is there a way to say... use this id for testing, and this other id for deploying?
Argh! It was correct, but 167 was referring to me leaving the wrong program-id at the top. annoying 🙂
That makes sense, didn't realize I needed to do that. I tried adding the authority like this:

```rust

#[derive(Accounts)]
#[instruction(bump: u8, sym: String)]
pub struct Initialize<'info> {
    #[account(init_if_needed,
        payer=authority, 
        seeds=[sym.as_bytes(), authority.key().as_ref()], bump=bump
    )]
    pub sequence_account: Account<'info, SequenceAccount>,
    pub authority: Signer<'info>,
    pub system_program: Program<'info, System>
}
```

and then when I call it, to get the address:
```ts
const [address, bump] = await anchor.web3.PublicKey.findProgramAddress([Buffer.from("ACCT_SEED_123"), program.provider.wallet.publicKey.toBuffer()], program.programId)
```

but it errors with:
```
Error: 167: The given account is not owned by the executing program
```
trying to run ido-pool example from anchor repo. Getting error -> Custom program error: 0xa7 . Does anyone knows how to resolve that ?
I think you mean program.account.escrowState
This is a `useWorkspace()` hook I implemented for my anchor + nextjs + **Typescript** project,
```
import { useAnchorWallet } from "@solana/wallet-adapter-react";
import { Connection } from "@solana/web3.js";
import { Provider, Program, Idl } from "@project-serum/anchor";
import { PublicKey } from "@solana/web3.js";

import idl from "../../target/idl/sol_pay.json";

const PROGRAM_ID = new PublicKey(idl.metadata.address);

const useWorkspace = () => {
  const wallet = useAnchorWallet();
  const connection = new Connection("https://api.devnet.solana.com");
  if (wallet) {
    const provider = new Provider(connection, wallet, {
      preflightCommitment: "processed",
    });
    const program = new Program(idl as Idl, PROGRAM_ID, provider);
    return {
      wallet,
      connection,
      provider,
      program,
    };
  }
  return undefined;
};

export default useWorkspace;
```

I believe my way of importing the `IDL` is wrong, because in the code below, 
```
const accounts = await workspace.program.escrowState.fetch()
```

I get this error, 
```
Property 'escrowState' does not exist on type 'Program<Idl>'.ts(2339)
```

Any help?? <@!134416332509675520>  🙌
Looks like the coding gods have already answered my prays : https://github.com/project-serum/anchor/pull/1160
Hey is there a way to do a rust expand on the `anchor build` process and see what code is generated?
Yeah, seems like you would definitely want to use `init` here, not `init_if_needed`.
you can also add the authority as a seed to the PDA for the counter
it should just fail
really, you shouldn't even be able to run init a second time with the same string name
Ah. That would make sense. There’s no test right now, but I will create one.
since you don't enforce a check that the authority is the one doing the initialization
my guess is that when you run the init function a second time it overwrites the first authority
Haha I think you even told me that.
ok, i see what's happening here and it's great because it's a good example of why no one should use `init_if_needed`
is this failing test in the tests file?
Hey so there seems to be a minor issue with my counter program. If i try to use a different wallet to initialize another account with the same name as my first sequence account, the first account gets messed up and no longer works. Would anyone mind taking a look? https://github.com/ljump12/sequence_enforcer
If i mint an NFT in my code and make a PDA for the metaplex token metadata program is it going to cost 0.01 SOL or just transactions fees? https://cdn.discordapp.com/attachments/895018937161510993/921856611021094912/Screen_Shot_2021-12-18_at_1.06.35_PM.png
It is definitely not a deprecated feature
https://github.com/project-serum/anchor/blob/master/tests/misc/programs/misc/src/context.rs#L75
https://github.com/project-serum/anchor/blob/master/tests/misc/programs/misc/src/lib.rs#L101
See for instance in this case all the arguments to this program call are exclusively used for account validation (so directly in the Context struct), which is why you can see `_arg_name` signifying those are unused.
I believe this is what you would use when you want to use one or more of the arguments you pass to the program call during accounts validation
Here's an example from project Serum / anchor tests: https://github.com/project-serum/anchor/blob/master/tests/misc/programs/misc/src/context.rs#L195-L204
Hey friends, sometimes I see an `instruction` macro, like this:

```
#[instruction(token_bump: u8, mint_bump: u8)]
```

Is this an old thing? Is it documented? Can I find it in docs.rs somewhere?


//////////////////////////////////////////////////////////////////////////////////////////

so the token account which I'm transferring the token(NFT) from user is a PDA token account whose seeds are (user key + token key + "token")
what is this PDA for then?
I thought you said the token account itself was the PDA?
Got it but after transferring the token to user how do I know which token id he transferred to program. Because my seeds are based on user addy + token addy + fixed string  (2 things I can get but the issue is token account which has been transferred to program)
just use ur own seeds of course
yeah, then in typescript you can query for that PDA like so
```
let [userPDA, userBump] = await anchor.web3.PublicKey.findProgramAddress(
  [Buffer.from("user"), signer.publicKey.toBuffer()], program.programId,
);
```
its derived based on token address and user address
[user.key().as_ref(), token.key().as_ref(), b"token".as_bytes()]
just a single string? or some accounts as well?
what is the seed?
yes
I'm a beginner myself, so my help is limited. I'll ask you this: the token account owned by the program is a PDA right? Derived based on some seed?
Let me give you some context what I'm trying to do. I have transferred NFT of user to token account owned by program  and now I want to show to the user that NFT are stored in the program account when he connects the wallet.
On that same topic, are any good resources for accomplishing the above? I've yet to see a concrete example for transaction fees on custom SPL tokens... which might be popular for the new wave of blockchain games popping up (which often have on-chain fees for transactions as part of the token economics).
All good 😌
Sorry about that!
Oh my bad
I'm not the original poster haha, not sure what they did (I'm just explaining what's possible)
Thanks, make sense. Is this what you ended up doing in the end?
with some modification
this might help you
https://spl.solana.com/token#finding-all-token-accounts-for-a-wallet
(You could of course just have the client pass in that hardcoded account though—that's fine)
There's no way around passing in that account, no (a pubkey in your program isn't enough unfortunately)
no normal program accounts.
are you talking about token program accounts? cause i have an example for that
I want to get all the program accounts owned by program  for a particular user. How can I do that ? I know getProgramAccounts gets all the accounts owned by program but when I pass user public key in memcmp filter to get the users accounts it does'nt shows any results. Do anyone know how to get users account ?
I'm in a similar predicament. How did you go about implementing this. The only approach I can muster up is using an escrow account to deduct a % of the transaction. Are there any other better approaches?
for anyone who comes searching for this error (`blockstore error`) in the future - the solution ended up being (and you're not gonna believe me) - turning off Dropbox app (my repo is in dropbox folder)

I don't know why/how but it works (at least for now)

For a more serious solution <@!417857235079790592> put a lot more brainpower into it and described steps here - https://github.com/solana-labs/solana/issues/21452

I'm not too sure how one would go about changing `MAX_GENESIS_ARCHIVE_UNPACKED_SIZE` within the context of anchor, but if someone knows pls comment
hi friends, I am having trouble understanding why users cant use program keys.

say in js on program init, we use the web3.keypair() function or generate them, we also have to serve the js to client right? as it is the client side of the rpc. cant users for apps write some malicious scripts in the chrome terminal, borrowing our generated program keypairs, and authorize commands they shouldnt be able to?
Nice, thank you guys
yes
huh... okay that makes sense lol, thanks alan ❤️
One more question: the_mint is mint pubkey?
return Err(ErrorCode::MyError.into())
If i do something like this
```
return Err(ErrorCode::MyError);
```
I get 
```
expected enum `anchor_lang::prelude::ProgramError`, found enum `ErrorCode`
```
Also, i know this is a weird question to ask, maybe it's a rust noob question, but for the life of me i cant figure out how to return a custom error code directly in the program handlers
yes, that is correct. i will give you mine too
```
match &ctx.accounts.many_faced_pda.current {
    Some(State::FirstState { first_hi1, first_hi2 }) => {
        msg!("it's a variant of FirstState");
        msg!("first hi1: {}", first_hi1);
        msg!("first hi2: {}", first_hi2);
    }
    Some(State::SecondState { second_hi1, second_hi2 }) => {
        msg!("it's a variant of SecondState");
        msg!("second hi1: {}", second_hi1);
        msg!("second hi2: {}", second_hi2);
    }
    _ => panic!("aaaaaaaa"),  // fallback
}
```
What are the most common causes of this type of error?
Im getting the following when trying to call my programs initialize function in an anchor test ```Translating error SendTransactionError: failed to send transaction: Transaction simulation failed: Attempt to load a program that does not exist````
will do, thanks
you could try search the solana tech discord, might get more hits in the history there
I'm sometimes getting this error from anchor:
```
Error: failed to start validator: Failed to create ledger at .anchor/test-ledger: blockstore error
```
and it seems to be non-determenistic, eg sometimes I'll comment some stuff out, then comment it back in and the error is gone

any ideas what might be causing this? (I fear the answer might be "absolute anything")
are there a way to get the sum of all extra fee in a transaction, e.g. transaction fee + account rent fee
Ty
You can try the `#[account(init, payer = whoever, associated_token_account::mint = the_mint, associated_token_account::authority = the_user)` annotation
How can I create a token associated account on anchor?
No idea what you mean haha
so to clarify, by aligning types with solana's 8 byte word you actually save on compute budget?
Hi <@!134416332509675520> 
How can I return `Err` on the `match` - None?
It's marked as mut in general because paying requires mutability
Yeah, it's just an account, that happens to be marked as the payer for some other account's initialization (have to pay for account rent)
Just bumpi g my question
Not via the npm package (you should uninstall that). You'll have to build from source: https://project-serum.github.io/anchor/getting-started/installation.html#build-from-source-for-other-operating-systems
anchor is not avaible forWindows 10 ?

Hello everyone, i have always a problem when i install anchor
You can create multiple accounts within a single tx, no problem 👍
A question, anyone have tried to create multiple account? So I'm thinking like I need to create a post with some tags. In my mind, I  think a user will have to pay for creating the post... and the tags related. Any recommendation about this? Why do I think the user will be popped up twice to say...creating a post? 😅
we do this for a couple different reasons in the main protocol on some of the state structs, but yes, the main reason is for more memory efficient access/storage with C-level alignment
<https://github.com/blockworks-foundation/ido-pool/blob/81d3b1972617afd3f246a22c04fd24909e2bbe4b/programs/ido-pool/src/lib.rs#L132-L133>
Is it possible someone can spoof this call and provide wrong amount in the RPC call  ? https://github.com/blockworks-foundation/ido-pool/blob/81d3b1972617afd3f246a22c04fd24909e2bbe4b/programs/ido-pool/src/lib.rs#L127
looking at jet's state struct - eg this one - https://github.com/jet-lab/jet-v1/blob/master/programs/jet/src/state/reserve.rs#L113

it seems they're using `zero_copy` for more efficient memory use

and I'm guessing the `repr(C)` that they have on the config just above is probably needed because it's passed in as parameters from the user - and maybe that prevents fields from being switched around (just a wild guess)
I know this has been asked before, but does anyone have a good example of parsing an optional account using `remaining_accounts`?
ok ok I think it all clicks together
Yep
okkk that makes a lot of sense. So it's a more efficient way to handle memory. 

Would I be right guessing that that has an impact on compute budget use?
Not many (just more typing), since in solana you actually aren't currently charged per compute unit lol. (Not sure how much more compute the boxing takes though)
but zero copy only loads the bits of the array you need at the times you request them
Are there any tradeoffs to using `Box` and pushing data onto the heap? Does this cost more gas or slow down transaction processing?
regular anchor deserialization all goes into memory
ok very interesting, so zero copy is like "dumb deserialization" if I can put it that way?

what's the benefit of using it? I'm guessing speed / space requirements?
https://discord.com/channels/889577356681945098/891724485177245717/915091416336707606
but i don't understand anything about it
there was a github issue recently about switching to repr(C)
Zero copy says nah, don't actually deserialize anything—just assume those raw bytes in the underlying AccountInfo *already* look like a Whatever would in memory (this is somewhat restrictive and doesn't work for all rust types, e.g. vecs or Strings, since they store their data in the heap)
The default behavior in anchor is `Account<'info, Whatever>`, which will read the raw bytes in the underlying account and use the borsh serialization library to deserialize those bytes into a nice `Whatever` struct. This struct will live on the stack (or maybe the heap if you did `Box<Account<'info, Whatever>>`).
I see - and just for someone totally new to this whole zero copy thing, what exactly does it do and why is it important?
I'm not sure why you would need to care about this unless you're doing some kind of zero copy thing
like in general should I be trying to align my state structs? or it doesn't matter and I'm overthining?
Ah, interesting. I'm not sure then!
I've seen the jet protocol specify C and transparent on top of its structs
E.g. `#[account(zero_copy)]` already uses repr(packed) for you
You ordinarily don't have to specify those manually—when are you thinking of doing so?
ok sounds like `packed` in particular is getting deprecated from rust. What about the other 2?
I've got a question about alignment. I don't come from a C background, but I googled around and understand that in certain scenarios (when variables not aligned) structs are padded to make them faster to read for the CPU.

When writing anchor programs, when if ever should I be using these 3?

`#[repr(C)]`
`#[repr(packed)]`
`#[repr(transparent)]`
yes my bad! that fixed it
make sure it's pub
const should work fine
Hello sirs. How would I wrap my SOL (to WSOL) in my javascript test file
I tried putting a `const` in there but it didn't work - maybe I messed up the imports
What kind of variable? In general yeah, you can put any expression there as long as it's in scope
when I'm doing `#[account(init, payer=user, space=8+X)]` - I'm guessing there currently is no way to insert a variable into X instead of typing out the number manually?
I wouldn't have thought about checking versionning before a while XD
that's true, I didn't have more at the time but <@!326107472098099201>  gave me a huge hint looking this direction.
I haven't upgraded all but solving the anchor versionning solved it, thanks a lot to both of you for answering!
use AccountLoader when I'm using zero copy, otherwise use Account
but ok I see the point
I've only checked the other way around - `Loader` works for accounts created with `init`
AccountLoader will *not* do that, and instead just pretend/hope that the `.data` already looks like a Whatever
Account<'info, Whatever> will deserialize a Whatever from the underlying AccountInfo's `.data` field
`AccountLoader` (`Loader` got deprecated I think) is what you need to use for `zero_copy` accounts (does `Account` work for them too? 🤔 Never thought about that before, would have guessed no)
when should I be using `Loader` vs using `Account`? Both seem to work?
oh interesting, yeah that's true
and it reduces the number of bytes in your transaction
in a sense that it simplifies client-side code?
it's actually kind of a big deal not to have to include the extra instruction to create an account
They use seeds and are signed for by the program
Init is for PDAs
ok got it! Thanks a ton 🙏
If you can get away with `init` you probably should (it's just easier). Sometimes you can't though, because `init` will run into the 10kb limit on CPI account initialization.
`#[account(zero)]` is for when you initialized the account in a separate instruction, so it's been allocated but doesn't have any data in it (in particular, it doesn't have anchor's 8 byte discriminator yet)
sorry could you clarify the connection between PDAs and the 2 macros above?
Add that trait
It is giving me error: 
```the trait anchor_lang::AccountSerialize is not implemented for `SetCharacter<'info>```
It simplifies things in multiple ways
My personal recommendation would be to always use PDAs unless you have a good reason not to
got it! Is there a recommended approach between `account(init)` and `account(zero)`? Sounds like both achieve the same result and the only difference is passing the extra instruction in js/ts
I just derive default on all structs, no reason not to
Ah maybe
I think, right? Maybe that changed somehow
If you've derived Default ^
So long as you're not using Vecs or Strings in your struct then anchor will automatically calculate the amount of bytes needed
try with sudo  ``last command``
I run "anchor deploy"
then got an error: "Error: Unable to write /Users/loris/.config/solana/id.json: Permission denied (os error 13)"
from your wording I'm guessing it's not necessary and if I omit it anchor will figure it out automatically?
Ah I see, thank you very much, <@!134416332509675520>
Otherwise you'll have to do some source-diving to see how they do it in their own program
Often times the other program will expose a lib that does it for you, e.g. with metaplex you can write something like `Metadata::from_account_info(the_account_info)`
Oh man, is there any sample I can refer to? I think it's not the rare case in the on-chain programs.
Use the `space` keyword in the constraints to manually specify the number of bytes to allocate to the account
Gonna have to do some manual deserialization of its `.data` field 💪
Anchor already does this for you. It adds a discriminator of 8 bytes to the start of the program account that indicates if it's been init. So long as you omit the init keyword in any future calls it will verify the account has data in it
thanks, and how to cast the ``ctx.accounts.the_account_in_question`` into custom struct used in the original program? 🙂
You would (in anchor anyway) declare `the_account_in_question: AccountInfo<'info>` in your `#[derive(Accounts)]` thing, and then you can look at `ctx.accounts.the_account_in_question.owner` etc. in your instruction function.
You should look into how project-serum/swap repo uses wrapped sol to transfer Solana maybe. Or you have to do it manually with by calling the system program `transfer` function
as I'm new to solana, could you give me the code example to do this?
Just take a look at its data and program owner—if there's data in there or the owner isn't the system_program, it has definitely been initialized.
No, has to have account info loaded in the transaction
Add the missing traits to the custom struct. Look in anchor/tests for some examples. 
It's like
```
#[derive(AnchorSerialize, AnchorDeserialize, Default, Clone)]
pub struct 
```
I have a vault program which stores the token in a pda account. 
My other programs need to check if there's a token in the vault. 
Since solana has no way of returning value from CPI, the other programs need to load the PDA account of a vault program.
I don't know how to do it, please let me know if there's any way.
and a related question - since we're not using `[account(init)]` with the zero copy approach, how does our program know how much space to allocate for the new account? Because we're not specifying it manually anymore?
How to check if PDA account exists(i.e inited and have data in it) from other program?
so is having a state that's > 10kb in size the only usecase for `#[account(zero)]` over `#[account(init)]`?

What if I was to only use the zero approach in my code? Is there any downside to it?
yes I think you can do that, just make sure the from account is passed in with `Signer` wrapped
I'm just trying to use a program to transfer lamports to a public key without no included account context
The from account is included in the transaction but does the receiving account has to as well? I know I could include a PDA and transfer it there and put it under the correct authority but that seems a bit much
if you need some account you or your program dont own to transfer you the fees, you will need to make sure that account get passed into the handler function with `Signer`
Very newbie question but I'm having trouble receiving sol, could someone help me with a template function to have the account receive sol from the user's wallet, and then have the account send sol to my wallet, if that's a thing?
Is there a good strategy for using `try_borrow_mut_lamports` when you only have a public key? My use case is that I want to charge a fee for a program I'm writing. Essentially that fee would be transferred upon initialization to a hard coded public address. All of the examples I've seen show using accounts but is there a way to get around it?
Can anyone help me with this?
How to get rid of this error. 
```the trait anchor_lang::AccountSerialize is not implemented for SetCharacter<'info>```
```the trait Clone is not implemented for SetCharacter<'info>```

Following is the program
```#[program]
pub mod my_game {
    use super::*;
    pub fn initialize(ctx: Context<InitializeCharacter>) -> ProgramResult {
        Ok(())
    }

    pub fn setCharacter(ctx: Context<SetCharacter>, lifeOrigin: LifeOrigin) -> ProgramResult {
        let character_life = &mut ctx.accounts.character_origin;
        let char_attrib = &mut ctx.accounts.character_attrib;

        character_life.lifeOrigin = LifeOrigin::lifeOrigin;
        char_attrib.character_attrib = CharacterAttributes::default();
        
        Ok(())
    }
}

#[derive(Accounts, AnchorSerialize, AnchorDeserialize)]
pub struct InitializeCharacter<'info> {
    // #[account(init, payer = user)]
    pub character: Account<'info, SetCharacter<'info>>,

    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct SetCharacter<'info> {
    #[account(mut)]
    pub character_origin: Account<'info, LifeOrigin>,
    pub character_attrib: Account<'info, CharacterAttributes>,
}
#[derive(AnchorSerialize, AnchorDeserialize)]
pub enum LifeOrigin {
    Corporate(String),
    Slums(String),
}
impl LifeOrigin {
    fn getLife(lifeOrigin: LifeOrigin) {
        match lifeOrigin {
            LifeOrigin::Corporate(_) => "Corporate Guy",
            LifeOrigin::Slums(_) => "Slums Survivor",
        };
    }
}

#[account]
pub struct CharacterAttributes {
    damage: u64,
    resistance: u64,
    throw_distance: u64,
}

impl Default for CharacterAttributes {
    fn default() -> CharacterAttributes {
        CharacterAttributes {
            damage: 100,
            resistance: 30,
            throw_distance: 5,
        }
    }
}
```
🤦‍♂️
Lol... https://github.com/dtolnay/cargo-expand
I'm just getting the error `Found argument '--expand' which wasn't expected, or isn't valid in this context` even though I opened a terminal in the directory with my `lib.rs` file. 🤔
anyone had issues with this?
the keypair file is there and it seems to be pointing to the correct one `target/deploy/program.json`
Random question - I keep on getting: `Error: failed to read keypair for program:`
however because its called from the frontend, cant clients do that transfer too? essentially draining the treasury account
like say I have a treasury account address, and users can spl_token::transfer into that, but to transfer out, I need the program to sign for the transaction/invocation instead
what is inhibiting the client to spoof authorized calls? because they have access to the program keys. cant they just edit some of our javascript and ruin our day?
but to invote rpc calls, it is client side, and we have to fetch our public program keypair client side
so say we have certain functions on the rust side that requires the signer to be the program (authorized)
i have a hypothetical question more like
To double check, I reinstalled global mocha and voila, the anchor (only version  I've installed) produces again 'test= yarn run mocha... ' . Again I uninstalled it, test again anchor init and it  produced still 'yarn run mocha', which is inconsistent, but after 10 minutes or so it started producing again test= mocha -t 100... so there is some latency to detect there is not global mocha but  in the end it generates mocha without 'yarn run', just when there is not global mocha to be picked up.  This held me back some time,  probing to find what the heck was going on, but at least now I can continue implementing, 👍
yea the way i understand it is that the derive Accounts macro basically validates stuff about transactions thru the #[account] attribute, you use the keys to pass stuff to the attribute like who should pay state rent, rejecting txs not sent by authority, etc
ok newb q. whats the `user` field in the `Initialize` struct? seems to be the account that is signing the init tx. what does it mean for the `user` to be marked mutable? why isnt this field included in other Context structs, only init ones? is it just a way to specify who the payer is?
Oh I see
The system program's programId is actually all zeros—which is maybe kind of surprising since it looks like all 1s in base58, but that's just cause base58 encodes digits that way (0 -> "1", 3 -> "4", etc.)
And that could be part of the issue for sure
It's possible the marinade program they're interacting with uses that version
Sirs why does this print 0 to my console:
`const anchor = require("@project-serum/anchor");`
`console.log(anchor.web3.SystemProgram.programId);`
Result:
`PublicKey { _bn: <BN: 0> }`
Update anchor, it looks like you are using 0.14.0 when the latest version is 0.18.2
The screenshot isn't helpful either because it seems incomplete / partial
Can you be more literal about what the error you're getting is
You're not really giving enough information in a clear enough way that we can help you troubleshoot
Another related thing that is maybe confusing: if some `Signer<'info>` is the provider.wallet, it doesn't need to be added to the `signers: [...]` array because it will already sign automatically, since it's the wallet paying to submit the tx (requires a signature no matter what)
The `signer: [...]` thing is for adding a keypair signature from the client. One situation where this is necessary even if there's no `Signer<'info>` is if you're creating an account that lives at a keypair address; solana forces the addresses of new accounts to sign, and the only way to do this for a keypair address is to sign from the client.
Hello peeps!
Hope you are doing good!
I have asked in the wrong chat maybe but I don't know how to handle this error as I'm not the creator of the full stuff for once.
Not sure if the error is mine or other.

I'm having a program that I turnt into an rust SDK to be callable by anyone and trigger marinade function.

Then when I import the SDK I get en error saying it can't compile anchor_lang because I haven't selected the good version of Solana (which is a crate of crate dependency and anchor_lang is imported in the one I use)

 a little help would be appreciated on how to deal with this :)
Thanks !
(I go to bed will check tmr morning)
Usually this is handled automatically by the `Account<'info, Whatever>` type, assuming you implemented Whatever with `#[account]`.
i been through a couple of examples, i sometimes see a ``signer: [account]`` param passed in a program call (``await program.rpc.anyFuction({})``) and sometimes not at all. 

I first thought that it was because the context passed didn't need any `` user: Signer<'info>`` but it seems like it's not that ?
b/c it looks like anchor implicitly defines an ID variable, not sure if this is correct tho
I ended up doing:
```rust
        let storage_info = &ctx.accounts.storage;
        if *storage_info.owner != ID {
            return Err(ErrorCode::StorageOwnerNotProgram.into());
        }
```
Is there a  explanation on how to do this
(Otherwise my program would not be able to mutate the external account)
How do I check if a given account can be mutated by my program's account?

For example: If I have a game, I might have a method in the program called `update_storage` that accepts a new external account to store data in.
However, I'd need to check that this new external account was owned by my program.
It depends from what you want to do. If just return `bool` then: `result.is_err()`.
Like return a false value rather than erroring out of the whole program
How do you do error handling in rust, i.e. I have a function that returns Result<usize, ()>. I want to do something if the function errors
it sounds like you used two different versions of the cli, one will generate the one with `yarn run` prefix
LOL that must be it, thanks man, I will try to do that
I did the Solana/Anchor project from _buildspace and succesfully implemented it
As I'm playing with the tool I hit some bumps so I better spun off a new ubuntu VM (21.10) to test anchor in isolation.

To avoid problems in such environment,   I added section ```[test] 

startup_wait = 30000```

 as it says somewhere in this discord to get rid of error Unable to start test validator

When I had installed mocha globally the anchor init myproject --javascript  command generates an Anchor.toml file with a  script entry  line like this:  `test = "yarn run mocha -t 1000000 tests/"`, which I guess should runs the local mocha module that anchor init installed at node_modules (?);  but when running anchor test I kept getting  error Command "mocha"  not found and asked me to check yarn webpage to know more about run command  (coundl't find answer, I have nvm to manage node and I tried also with NODE_PATH and simlinks to not avail).
So, I uninstalled global mocha, and generated new anchor init project but now that line on  script  is generated like  `test = "mocha -t 1000000 tests/"`, which won't run and again gave me the  error mocha not found. I don't get  why anchor  removed yarn and goes for global mocha, now that there is no global mocha?
So I manually edit the script to add yarn `test = "yarn run mocha -t 1000000 tests/"` and now it  works

Isn't it backwards?
I don't know if this help but I just change "declare_id!(...)" in lib.rs to actual program id when run "anchor deploy"  and the error gone
how (or where) does one find the idl for the SPL programs, specifically I'm looking for the name-service idl. thanks in advance
Good day! What is the go-to way of reading and parsing events written into logs with `emit!` macro?


//////////////////////////////////////////////////////////////////////////////////////////

Did you get this solved? I’m dealing with the same issue lol
Has anyone come across the case where when starting up an anchor project, building it successfully, trying to deploy it and seeing the msg output being printed repeatedly? Not sure what’s going on.
im getting the exact same error and i have seen others with the same issue but there's no solution. Can anyone help me with this pls. Any help is appreciated thanks
hey man did you manage to get this resolved?
OK
Then program.account.thatAccountType.all() will fetch all of them
Yeah
Thanks
Is the account owned by your program?
For ex:
The user_info is stored on the PDA - the seeds is the user's pubKey
I would like to get all users list
Any `Account<'info, OneOfYourAccounts>` will break
May I know a specific situation about  not work correctly here?
Your program will in general not work correctly if you use the wrong `declare_id!`, no.
Hello guys, a quick question about program_id, it seems the anchor can work even if I put others address to my program_id field. Will it generate any vulnerability?
Can you be more specific? You can fetch all accounts owned by a program, but that's not the same thing as all PDAs derived from a program
Hi <@!134416332509675520> 
Is there any way to fetch all of the PDA accounts from the program?
Is there anything I should know about devnet and how it differs from localnet before I start using it? Is there anything I should be wary of doing considering it's a public dev chain?
Might be using the wrong value, will check
That sounds like an actual error, right? 🤔
```     Error: 141: A has_one constraint was violated
```
Does it not work?
it works with ```Account<'info,TokenAccount>```
another question ```    pub pyth: AccountInfo<'info>,``` is it correct to do ```has_one = pyth```
Also don't need that `async` for what it's worth
weird
It works now after I put it inside the test
How are you calling it?
I still have 2 tests after the sleep, it just finishes and ignore them
```async function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}
```
it skips the rest
What happens when you try? This won't have anything to do with anchor, just JS/TS
doing regular ts await doesn't seem to work
how do you sleep in anchor ts ?
thank you
https://spl.solana.com/associated-token-account
> A user may own arbitrarily many token accounts belonging to the same mint which makes it difficult for other users to know which account they should send tokens to and introduces friction into many other aspects of token management. This program introduces a way to deterministically derive a token account key from a user's main System account address and a token mint address, allowing the user to create a main token account for each token they own. We call these accounts Associated Token Accounts.
Yup, I was unfamiliar with this. Makes way more sense now
Their address is program-derived based on the owner (the maker) and the mint (the taker token), so no need to guess it/remember it
Are you familiar with how associated token accounts work?
hey <@!134416332509675520> , I'm looking at ```    #[account(
        mut,
        associated_token::mint = taker_mint,
        associated_token::authority = offer_maker,
    )]
    pub offer_makers_taker_tokens: Box<Account<'info, TokenAccount>>,
```
(https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo/src/lib.rs#L219)  and don't understand what I'm seeing.
 
`offer_makers_taker_tokens` is the account which the taker's payment is sent to when an offer is taken, and it is provided when `accept` is called. 

I don't understand where the account comes from and how it would be accessed by the maker after the transfer is completed, though. There is verification that the `offer_maker` is the owner and that it's mint is the proper `mint`, but how would the person calling `accept` find this account's PubKey to provide it in the first place?

My best guess would have been that the offer maker would provide this address as part of the `offer` itself, but `offer_makers_taker_tokens` is not a field on an `Offer`
Ah thanks I will check that out.
There is a new and improved version of the IDO pool in the anchor tests directory
Is it safe to use old anchor version or better switch to new ones ... I see a lot of people forking mango ido pool code have to use 0.13.2 version. Is it better to upgrade that code to be compatible with new anchor version ?
gossip address and tpu address are different ports
the JSON RPC is on :8899
Ah. What port is it listening on?
interestingly, I have one running right now as root but when I run that command as both root and non-root, no hits
`lsof -i :8899`
Do you still have a validator running in the background? Need to make sure it's not already running
yea mine doesn't work out of the box like that lol - when I try to just run `anchor test` it will fail on `Transaction simulation failed: Attempt to load a program that does not exist `
But again, I think that's a me problem. Will have to look into fixing my permissions
ah
`anchor test` all by itself actually does a little genesis magic (I'm fuzzy on this tbh) to not have to literally deploy
`anchor test` is supposed to deploy right? You say it lets you skip deploying - but I though it technically launches the validator, deploys, then takes down the validator
oh yea, I think my workflow isn't ideal currently then. my `solana-test-validator` fails if I don't run it as root, and so when I run `anchor test` the validator doesn't actually spin up.  I should probably address that
This lets you skip deploying (annoying and, judging from questions in the discord, very error prone)
So I just run `anchor test` without any validator running in the background
I just hopped on for the morning and ran anchor deploy and anchor test, it actually deployed with the same programId (which I didn't expect)
I actually never use an actual live validator to test, I always let anchor spin one up for me
For all I know it's not expected behavior - did you just restart to test? Maybe it only happens to me 🙂
lmao
I guess I hardly ever restart my computer so haven't noticed 😅
is localnet chain data expected to persist?
Hmm, not sure why that would happen
so if I spin up a test-validator, deploy a program, kill the test validator and restart it - my program is still there when I run `solana program show <programid>`. But if I come back another day, restart my computer and kick off the test-validator, that same programId will no longer be found (`Unable to find the account <programid>`).

Seems like it's sticking around if I kill the validator and restart it, but lost either after some amount of time or in between full computer restarts. Is that expected?
yeah makes sense
Cuz we will call them from other places I guess
how come functions have to be public?
Oh ok, thanks
Ngmi (lol), that's too old, gonna have to update
1.8.0
What version of solana are you using?
where should I add it?
But now it asks this
Turning off hyper v helped
when I try to run solana-test-validator I get `Aborted (core dumped)`
Now I have another problem lel, I hate setting up env
oh ok that makes sense - i do remember upgrading anchor took like a half hour for me yeah 🙂
Rust package management basically leads to 1 black hole per project
If it was a fresh install, it was probably pulling a lot of crates, just not giving much feedback.
oh ok 😅
idk what was problem, but its fixed I guess
It was like that for 20 mins and after started building
Just nothing
do you have an anchor project? i.e. anchor init testanchor
no output at all?
Like anchor is installed and everything should be fine, but anchor build just does nothing, can anyone help?
Just installed anchor on ubuntu and anchor build still does nothing
What do you mean by get the same problem? You only need to use invoke_signed if you need your program to sign for a program-derived address (doesn't sound like the donator lives at one—seems like they're a regular keypair address that signs from the client)
the account is just an empty slate, you store any data you want on it. For example, who the account's owner is
that's something you have to store inside the account itself
i don't understand the question
so that links the owner (who initialised jt) to the account created?
you would just use `program.accounts.{accountName}.fetch(accountPubkey)` to check if the account exists or not
not sure if this is anchor or more javascript related
is there any way to have a program that creates an account for a player and saves it somehow so the next time the player tries to create an account, they are automatically logged in?
Got it thanks
some programs, like the SPL token program, enforce that their accounts are created rent exempt
don't think so
Is there any available attribute for checking if an account is rent exempted or not?
like `#[account(mut)]`
anchor build doesn't work
You're right about the error. It's showing that "writable privilege escalated"

When I try using invoke, I get the same problem:
```
let ix = anchor_lang::solana_program::system_instruction::transfer(
            &ctx.accounts.donater.key(),
            &ctx.accounts.receiver.key(),
            ORACLE_FEE,
        );

        anchor_lang::solana_program::program::invoke(
            &ix,
            &[
                ctx.accounts.donater.to_account_info(),
                ctx.accounts.receiver.to_account_info(),
                ctx.accounts.system_program.to_account_info()
            ]
        )?;
```

I'm guessing that I may have to use `invoke_signed` but I'm not sure how to get the the "donater"'s seeds. The "donater" is a signer of the request already.
check this
https://project-serum.github.io/anchor/ts/classes/AccountClient.html#createInstruction
you can create accounts from the client side too and the size can be dynamic
wait hold on
well yeah cuz it can be 32 bytes long
So even if ur string to send is 8 bytes long. You pay the fixed amount set in the account constraints?
you can declare the space in the account contraints
yes, you can't change the allocation afterwards, you need to declare it upfront
If I wanted 64 byte string after would I need to make another PDA?
Like a 32 byte string
When I init an PDA with data. do i need to specify the size of the data and I'm stuck with that size once the initial allocation
If you scroll up in your program logs you'll probably see a message saying some account's writable privileges were escalated.
And I think the actual issue (once you fix the token transfer thing) is that you haven't marked the `receiver` as `mut`.
So you're trying to do a lamport transfer? Why are you doing a `token::transfer` rather than a `system_instruction::transfer` + `invoke`?
I'm trying to implement a simple example and running into: "Cross-program invocation with unauthorized signer or writable account".

The goal is for a user who is a signer to send lamports to another user who is not a signer. 

```
pub fn donate(
        ctx: Context<Donate>,
    ) -> ProgramResult {
        let cpi_accounts = Transfer {
            from: ctx.accounts.donater.to_account_info().clone(),
            to: ctx.accounts.receiver.to_account_info().clone(),
            authority: ctx.accounts.donater.to_account_info().clone(),
        };
        let cpi_program = ctx.accounts.system_program.to_account_info().clone();
        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
        token::transfer(cpi_ctx, 10000)?;
        Ok(())
    }

#[derive(Accounts)]
pub struct Donate<'info> {
    #[account(mut)]
    pub donater: Signer<'info>,
    pub receiver: AccountInfo<'info>,
    pub system_program: Program<'info, System>,
}
```

The client code is pretty simple:
```
        await this.program.rpc.donate({
            accounts: {
                donater: this.keypair.publicKey,
                receiver: receiver.publicKey,
                // rent: anchor.web3.SYSVAR_RENT_PUBKEY,
                systemProgram: anchor.web3.SystemProgram.programId,
            },
            signers: [this.keypair],
        });
    }
```

I understand (I hope) that using `try_borrow_mut_lamports` requires that the program owns the account so that won't work. 

Does anyone have any simple examples for transfering lamports to an account where the receiver doesn't sign the transaction, only the sender does?
ah interesting, I'll keep that in mind thanks!
Not quite—it will *recalculate* the bump for you. The downside is that this costs compute.
if you provide no bump, like:

```rust
#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(signer, mut)]
    pub initializer: AccountInfo<'info>,
    #[account(
        init,
        seeds = [b”a".as_ref(), b”b".as_ref(), b”c".as_ref()],
        bump,
        payer = initializer,
        space = 8 + MinterState::LEN,
    )]
    pub state_account: Account<'info, MinterState>,
    pub system_program: Program<'info, System>,
}
```

Will it use the default bump?
Does your `declare_id!` use the program_id "9pkYv3S..." from that screenshot? If not, then you need to update it to match.
I realize this is prob a better place to ask

New to solana and anchor dev and going through the anchor tutorial examples. Kinda confused about one thing for now.. when you do a anchor init AppName and you ge the declare_id! - if I want to deploy this to devnet then that should be replaced. Is it with the public key of a keypair you gen locally or something else?
if you are having trouble with getting all of this working and learning solana, could you try working on something simpler first maybe?
I have just used ``AcountLoader`` and it shows this error when ``initialize`` call in ``client.js``.
```The given account is not owned by the executing program```
https://github.com/samuelvanderwaal/solana-whitelist/issues/1
It is splitting my head nowadays.
Please help me.
Hello
FYI - figured it out, and posting what I learned here for reference. Basically I had installed yarn not at the project level, but at the folder one level up. so it was looking for stuff to be installed there (my user folder) instead of where it actually was at the project level. The solve - delete yarn.lock and package.json from the user folder, and install yarn in the project folder
ah yes, i see. i was looking at the wrong instruction, makes more sense now. The init was failing, and then that was trying to access the account later. The init is failing because 'Cross-program invocation with unauthorized signer or writable account' But let me bang around on it for a bit, probably just have my instructions wrong 🙂
not always, it's officially the `account not owned by program` error right? This means that you might be trying to use an account that hasn't already been initialized and is still owned by the system program
Is error 167 always a declare_id error? I've redeployed to devnet, and my instructions to it are getting the 167 error. I've triple checked that I 'anchor build' then 'anchor deploy ...' with the correct declare_id, and now i'm stumped.
Think I've installed it correctly, but when I type 'mocha' in the command line I get a 'command not found issue
Can anyone help? I've been stuck on this for a while and not sure what to do! I think it may be an issue with mocha not working correctly, but not sure
created a new anchor project, and tried to run 'anchor test' and am getting this error

yup, thanks
and if it returns with NULL then add the init instruction
`program.accounts.this_counter.fetch(this_counter_pubkey)`
thats what i figured.
it's really quite simple, you just check if the account exists or not


//////////////////////////////////////////////////////////////////////////////////////////

Yeah that's sorted it. Thanks!

For anyone else looking for the `programId` parameter of `getParsedTokenAccountsByOwner()`, it is always: `TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA`
ahh ok I'll give that a go.. yeah makes a lot more sense
And the only other thing that makes sense to filter on is the mint
Because you're already specifying the owner of the token
I assume so (haven't actually tried, but I don't know what other program id could make sense)
oh what it is asking for the native one?
All token accounts are owned by the spl token program
What do you want that program id to mean?
Is it possible to get someone else's program ID?
Honestly not sure why it's a filter option at all
Ah, you need to use the actual SPL token program id
Mm, not sure, you can definitely just do it yourself with new PublicKey but you need to get it right 😛
So this app has a different program ID I guess
Oh no I'm doing it from a separate app.. cos I've just been following tutorials, I just copied the ID from the other app. Is that the issue?
Did you use the `@solana/spl-token`'s TOKEN_PROGRAM_ID as the value?
That's what I tried and I get this error 

The same as if I put any other address that isn't a program ID in there, but it's copied from the .cache folder of my uploaded collection
What about using `programId: theSplTokenProgram`
Ah, ok
but I've just started with solana so there's maybe just an entirely different way I should be doing it
I think it's required
Can you just leave off the filter entirely?
Then is there another way to target a whole collection, where the mint addresses are different for each one?
So just `{ mint: theMint }`
I think you would skip that `programId` filter and just use the mint one (I think)
The comment was from when I was using the mint parameter and is now a lie
Oh sorry it's inside the `filter` type. its defined as:

```
      const filter = {
        mint: PublicKey
      }
      |
      {
          programId: PublicKey
      };
```
But I'm currently working with my own program. got 2 tokens in my wallet from a standard (I think) metaplex collection... but when I use the mint parameter I can only see one, so need to use the program ID.. .but none of the keys I get from my JSON are working, so wondering if I need to do some extra formatting
getParsedTokenAccountsByOwner doesn't take one 🤔
Also, which programId parameter are you referring to?
No, whatever you're doing will only happen on a single network
dunno if it reads from mainnet too
but I'm on devnet
I have a program that I can read the accounts of, or just anyone else's
~~Which program are you trying to get parsed accounts for?~~
Trying to get all NFTs from user wallet, from either my own collection or someone else's.. doesn't particularly matter which
Anyone able to enlighten me about where to find the correct key for the `programId` parameter in `getParsedTokenAccountsByOwner()`?

I dunno if I just need to do more formatting than `new PublicKey("key_goes_here")`
can anyone please help me with this
i've built most of my app already but i'm just confused with this
could anyone give me some tips on how i might build something with built in reward? like based on certain requirements that need to be fulfilled from my backend
i airdroped more sols and deployed that contract , getting a different err
okay let me try that too
yeah yes, it was working fine untill last week, i have deployed it multiple times on devnet
Yeah, the first thing to try would be to get yourself more devnet sol.
When you say "deploying 4 contracts at once", is that literally in one command?
i have also tried deploying that specifc contract which throws err, but still getting the same
Any way to deploy only 1 to try?
Is 10 SOL enough though? I've seen programs deploy for 5 SOL easy, and they were not huge
yes , i have about 10 sols and deploying 4 contracts at once
Do you have lamports in the deploying wallet?
I'm having problems compiling with anchor:
BPF SDK: /Users/z/.local/share/solana/install/releases/1.8.3/solana-release/bin/sdk/bpf
Compiling solana-program v1.9.1
error[E0658]: use of unstable library feature 'debug_non_exhaustive'
/Users/z/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-program-1.9.1/src/account_info.rs:48:11
   |
48 |         f.finish_non_exhaustive()
   |           ^^^^^^^^^^^^^^^^^^^^^
   |
   = note: see issue #67364 <https://github.com/rust-lang/rust/issues/67364> for more information
   = help: add `#![feature(debug_non_exhaustive)]` to the crate attributes to enable
i am getting this error while deploying in devnet , but it is getting deployed in localnet
(difference being that my example uses `provider.wallet`, where the stackoverflow answer has stored the `wallet` property directly inside their `provider` variable)
In case anyone else comes here struggling... seems like the issue is that I was attempting to sign the transaction programatically, but I do not have the user's credentials stored programatically... this stack overflow answer shows how to restructure the transaction to request a signature from the user before it is sent: https://stackoverflow.com/a/69050522/2285440
ooh lol I see. Thanks I'll try there too
create grid isn't anything, it's just this person's custom function name
you could try asking this in solana tech discord as well, this looks like one of their examples
<https://docs.solana.com/developing/programming-model/accounts#rent>
ah I haven't seen that createGrid method. Guess I need to get reading. Thanks that helps a lot!
https://docs.solana.com/developing/runtime-facilities/sysvars#rent
```
 txn.add(
        await program.instruction.createGrid(
          GRID_SEED,
          newBump,
          {
            accounts: {
              signerAccount: provider.wallet.publicKey,
              gridAccount: newPda,
              systemProgram: SystemProgram.programId,
            },
            signers: [provider.wallet],
          }
        )
      );
```
im a noob too but i can show you my similar code when i provide provider.wallet in case that helps (im using anchor rpc call) <@!881052567747043369>
np urs is more important, mine just curious
bump ... sry for burying you 😛
GM all.

Just been working through the buildspace tutorial and now doing the independent tasks. Struggling to work out how to transfer SOL.

I was originally going to do it from within react's `App.js` file, using this example: https://github.com/solana-labs/solana-web3.js/blob/master/examples/send_sol.js

But I've realised that I can't create the `Signer` type without access to the user's private key. So now I am clueless as to how I would create the transaction. Any help would be greatly appreciated.

Here is my function (obv. `provider.wallet` doesn't work):

```
  const sendTip = async (payeeAddress) => {
    try {
      const provider = getProvider();
      const recipient = new PublicKey(payeeAddress);

      let connection = new web3.Connection(
        web3.clusterApiUrl('devnet'),
        'confirmed',
      );

      // Add transfer instruction to transaction
      let transaction = new web3.Transaction().add(
        web3.SystemProgram.transfer({
          fromPubkey: provider.wallet.publicKey,
          toPubkey: recipient,
          lamports: web3.LAMPORTS_PER_SOL / 100, // 0.01 SOL
        }),
      );

      // Sign transaction, broadcast, and confirm
      let signature = await web3.sendAndConfirmTransaction(
        connection,
        transaction,
        [provider.wallet],
      );
      console.log('SIGNATURE', signature);

    } catch(error) {
      console.error("function `sendTip` has reported an error:", error);
    }
  };
```
in anchor, what is specifying rent in your list of accounts used for?

like https://github.com/project-serum/anchor/pull/202/files#diff-9a9a1df604bb00f9ae5c845737bb0bad073f6617d3fa26550f9d812143687d6dR109

```
#[derive(Accounts)]
pub struct CreateLargeAccount<'info> {
    #[account(init)]
    event_q: Loader<'info, EventQ>,
    rent: Sysvar<'info, Rent>,
}
```
how do i setup a custom rpc node on anchor tests?
I believe `&ID` macro is what you're looking for
How do you access the program ID that was declared in declare_id inside a function?
Thanks <@!798837544640446494>
So that's the problem right there. Somewhere in the solana import, you're bringing in some dependency that's only supposed to run on node. 

Take a look here: https://github.com/evanmarshall/sol-rng-client/blob/main/src/index.js
This shows how you could make the connection from a browser.
hi no - its just kind of working but i haven't switched from localnet yet
So I imported to solana web3 package in my react app so my smart contract could render on my react site.
I'm pretty confused about what you're actually doing because that's not your file, that's from @solana/web3.js I believe. 

What are the steps to reproduce your problem? In particular, why do you have anything open in chrome and what made it? 

When you create an anchor project, it doesn't come with a react app so you created one inside. With your react app, it shouldn't import all of the solana web3 stuff by default, so you had to add it somewhere. I'm not seeing the file you edited to import the solana web3 stuff.

I'm pretty new to solana too so I could certainly be wrong.
<@!798837544640446494> sorry but here is my index.ts

export * from './account';
export * from './blockhash';
export * from './bpf-loader-deprecated';
export * from './bpf-loader';
export * from './connection';
export * from './epoch-schedule';
export * from './ed25519-program';
export * from './fee-calculator';
export * from './keypair';
export * from './loader';
export * from './message';
export * from './nonce-account';
export * from './publickey';
export * from './stake-program';
export * from './system-program';
export * from './secp256k1-program';
export * from './transaction';
export * from './validator-info';
export * from './vote-account';
export * from './sysvar';
export * from './errors';
export * from './util/borsh-schema';
export * from './util/send-and-confirm-transaction';
export * from './util/send-and-confirm-raw-transaction';
export * from './util/cluster';

/**
 * There are 1-billion lamports in one SOL
 */
export const LAMPORTS_PER_SOL = 1000000000;
I don't have those files in my folder structure
What does your client.ts & index.ts file look like?
<@!798837544640446494> its just a blank screen
I'm not totally sure this is the issue but it looks like you may be importing some of the node dependencies that shouldn't be served to the front end. You can't just copy the code from the tests.

What does your client code look like?
I have updated the node packages
I am having issues getting my react app to render
Thank you for explaining it. That makes a lot more sense than what I was thinking before (as more of an ownership statement).
Nothing about ownership—it's purely about giving solana information about how to schedule running transactions on the cluster. E.g. if two transactions both want to write to some account, solana has to run them in sequence (can't parallelize them)
Marking the receiver as mut tells solana "I'm gonna need exclusive access to this account!"
Right, that's what I was suggesting above—you need to mark the receiver as mut
It works if I add `#[account(mut)]` above the `pub receiver: AccountInfo<'info>,` I'm still confused though as the client doesn't pass in anything except the pubkey of the receiver. Also the donater doesn't own the receiver and both addresses are created with: `anchor.web3.Keypair.generate()` and then airdropped to fund.
Does anchor have support for VecDeque?
is there a way to do cpi without access to the idl or source code of the called program? it seems that for it to work, you need to serialize/encode the instruction data. thus, you somehow need access to the actual program that you want to cross invoke.

eg: you cant just say ```invoke(target_program_id, function_name([]accounts))``` excuse the pseudocode
Here's the full error:
```
Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account 
    Program Bty5iscY33GnVqzstci1gVNaikxt9aPFW4Q1FmyEqseR invoke [1]
    Program log: Is signer: true
    GjN4RMKJ7foi3ej1PaYiLBNscx62x2JWBMyMfapkFjFt's writable privilege escalated
    Program Bty5iscY33GnVqzstci1gVNaikxt9aPFW4Q1FmyEqseR consumed 200000 of 200000 compute units
    Program Bty5iscY33GnVqzstci1gVNaikxt9aPFW4Q1FmyEqseR failed: Cross-program invocation with unauthorized signer or writable account
Translating error SendTransactionError: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account
    at Connection.sendEncodedTransaction (/Users/evanmarshall/Documents/solana/sol-rng/top/node_modules/@solana/web3.js/lib/index.cjs.js:6591:13)
    at processTicksAndRejections (node:internal/process/task_queues:96:5)
    at async Connection.sendRawTransaction (/Users/evanmarshall/Documents/solana/sol-rng/top/node_modules/@solana/web3.js/lib/index.cjs.js:6550:20)
    at async sendAndConfirmRawTransaction (/Users/evanmarshall/Documents/solana/sol-rng/top/node_modules/@solana/web3.js/lib/index.cjs.js:8513:21)
    at async Provider.send (/Users/evanmarshall/Documents/solana/sol-rng/top/node_modules/@project-serum/anchor/dist/cjs/provider.js:85:22)
    at async Object.rpc [as donate] (/Users/evanmarshall/Documents/solana/sol-rng/top/node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:11:31)
    at async UserSession.donate (/Users/evanmarshall/Documents/solana/sol-rng/top/app/sessions.js:89:9)
    at async runClient (/Users/evanmarshall/Documents/solana/sol-rng/top/app/client.js:36:5) {
  logs: [
    'Program Bty5iscY33GnVqzstci1gVNaikxt9aPFW4Q1FmyEqseR invoke [1]',
    'Program log: Is signer: true',
    "GjN4RMKJ7foi3ej1PaYiLBNscx62x2JWBMyMfapkFjFt's writable privilege escalated",
    'Program Bty5iscY33GnVqzstci1gVNaikxt9aPFW4Q1FmyEqseR consumed 200000 of 200000 compute units',
    'Program Bty5iscY33GnVqzstci1gVNaikxt9aPFW4Q1FmyEqseR failed: Cross-program invocation with unauthorized signer or writable account'
  ]
}
```

The public key causing the problem is: "GjN4RMKJ7foi3ej1PaYiLBNscx62x2JWBMyMfapkFjFt" which is the public key of the "receiver" account.

Additional info:
anchor-cli 0.18.2
solana-cli 1.8.0
Absolutely and I really appreciate your help. 

Here's the program code:
```
pub fn donate(
        ctx: Context<Donate>,
    ) -> ProgramResult {
        msg!("Is signer: {}", ctx.accounts.donater.is_signer);

        let ix = anchor_lang::solana_program::system_instruction::transfer(
            &ctx.accounts.donater.key(),
            &ctx.accounts.receiver.key(),
            100000,
        );
    
        anchor_lang::solana_program::program::invoke(
            &ix,
            &[
                ctx.accounts.donater.to_account_info(),
                ctx.accounts.receiver.to_account_info(),
                ctx.accounts.system_program.to_account_info()
            ]
        )?;
        
        Ok(())
    }

#[derive(Accounts)]
pub struct Donate<'info> {
    #[account(signer, mut)]
    pub donater: AccountInfo<'info>,
    pub receiver: AccountInfo<'info>,
    pub system_program: Program<'info, System>,
}
```

Here's the client code:
```
await this.program.rpc.donate({
            accounts: {
                donater: this.keypair.publicKey,
                receiver: this.receiverPubkey,
                systemProgram: anchor.web3.SystemProgram.programId,
            },
            signers: [this.keypair],
        });
```
And can you post your code that's using the system_program transfer?
No need to sign for the recipient. Can you post the full program log?
I mean that I get the same issue if I just use invoke: "Cross-program invocation with unauthorized signer or writable account" with the public key of the recipient either using system_program & invoke or Transfer & token::transfer. 
Is it impossible to just send lamports to an account that isn't a signer? 

I know I can send lamports to a PDA and then the other user can withdraw from the PDA but this feels way more complicated than my use case.  I feel like I'm missing something simple.
Ahhhh okay that’s a relief, so I can just let it go until it actually deploys 😅
I think someone just forgot to delete a log line in solana lol
that's my experience when deploying, eventually it deploys though, after spamming `msg <address>`


//////////////////////////////////////////////////////////////////////////////////////////

can you also check `is_signer` when executing a CPI from one Program to another?

For example


```
let example_pda = ctx.accounts.example_pda.to_account_info();
    let seeds: &[&[u8]] = &[b"example"];
    let signer_seeds = &[&seeds[..]];
    let cpi_accounts = SetDataAuth {
      example_account: ctx.accounts.example_account.to_account_info(),
      authority: example_pda,
    };


    let cpi_ctx = CpiContext::new_with_signer(
      cpi_program,
      cpi_accounts,
      signer_seeds
    );
    
    programA::cpi::set_data_auth(cpi_ctx, data)
```
`CpiAccount` was replaced with `Account`, which also covers the old `ProgramAccount` use case, right?
Yep. You can then check programmatically with the `is_signer` property (solana itself sets it to true or false depending on whether the account signed)
so that is the only mechanism solana uses to ensure this account signed this transaction right ?
Yep. Solana will verify that that account really did sign.
<@!134416332509675520>  have a solana theory question sort of, in solana when you require a account be a signer is it because that account "is_signer" property is going to be checked on chain ?
thanks
Don't think there's any built-in command to do it, no. Not sure if it's literally impossible though
Is it possible ?
How can I close IDL account of a program ?
In general, yes.
so I have to save the address?
When you created the account you had to decide on which address to use (so don't forget it, lol)
So you just need to know the right address
There isn't necessarily just one address for the account (there could be an arbitrary number of  ClientData accounts)
here the "theAddressOfTheAccount" is the publicKey of client account right? what if I want to get that?
You would do `await program.account.clientData.fetch(theAddressOfTheAccount)`
#[derive(Accounts)]
pub struct Client<'info> {
    client: Account<'info, ClientData>,
}

#[account]
pub struct ClientData {
    active: bool,
    amount_raised: u64
}

I have this I want to get the PublicKey of the client account
What do you mean by a program account? I'm going to need way more information to help
I want to get the data of program account. how can I get that?
If it's one of your own account types then you can do `program.account.yourAccountTypeName.fetch(itsAddress)`
Yes
What do you mean by read? Do you mean parse/deserialize?
how can I read buffer data returned from getAccountInfo?
I think you might be mistaken, `my_account_info.lamports` gives you that refcell stuff, `.lamports()` gives you a u64
What does your `Anchor.toml` say?
otherwise you have to run BROWSER= everytime
`export BROWSER=` is more correct
Wht to do?
anchor test not switching to localnet even after doing config set localhost
With rust I find it's trial and error until the compiler stops complaining and gives me what I want
Probably need to Google how to use deref mut
It does, at least for CPI, not in the client
If I have AccountInfo how can i get the number of lamports in it as a u64? 
If example_acc_inf is an AccountInfo then 
example_acc_inf.lamports() returns a  Rc<RefCell<&'a mut u64>>.
Is there a good way to turn an address that is formated as a string into a PublicKey?
Serum was written in the before times
Anchor doesn't seem to have helper functions to interface with serum, but it was made by the serum team it seems like ?
ty!
Use `.lamports()` rather than `.lamports`
Good evening guys. Anyone knows how to fix this issue or another way to do this constraint? I want compare user sol balance with a pre-fixed amount
Yeah
Hey guys, quick question, does `Rent::minimum_balance` on Rust side does the same as `anchor.program.provider.connection.getMinimumBalanceForRentExemption` on TypeScrypt side? Just could not figure out from sources. Thanks in advance!
Assuming the source is owned by your program, you'd do something like this:
```.rs
fn transfer_from_account_we_own(
    src: &mut AccountInfo, // we better own this account though
    dst: &mut AccountInfo,
    amount: u64,
) -> ProgramResult {
    **src.try_borrow_mut_lamports()? = src
        .lamports()
        .checked_sub(amount)
        .ok_or(ProgramError::InvalidArgument)?;
    **dst.try_borrow_mut_lamports()? = dst
        .lamports()
        .checked_add(amount)
        .ok_or(ProgramError::InvalidArgument)?;
    Ok(())
}
```
So just to double check, the source account here is owned by your program? How you do a transfer depends on which program owns the source account
The idea is making a simple donation matching contract (Alice can put X lamports into the declaration and when Bob donates Y lamports in the future if Y<X then Y of the declaration's lamports and Y of Bob's lamports are sent on. Then the declaration has X-Y lamports. If Carol comes along and donates Z<X-Y lamports then Z of Carol's lamports and Z of the declaration's lamports are sent on)
My goal in the end is to have a function which creates a declaration account. I want the `author' who is calling the function to have their lamports decreased and the declaration account's lamports increased by the same amount. Then I want to make another function that allows someone else, Bob, to send lamports then both Bob and the declaration accounts lamports get dedecuted and sent off to a final unrelated public address
I just want to read it so I can decrement it as much as I am adding to the declaration account
author_account_info.lamports
but I am not sure how to access the the u64 inside of
but I am getting the error that unwrap isn't defined
and I am doing this: 

        let dest_starting_lamports = declaration_account_info.lamports();
        **declaration_account_info.lamports.borrow_mut() = 
            dest_starting_lamports.checked_add(donation_amount).ok_or(ErrorCode::InsufficientFunds)?;

        **author_account_info.lamports.borrow_mut() = author_account_info.lamports.unwrap()-donation_amount;
I am trying to move funds from one account to another
Easier to help too if you tell us what struggles you're having
Have you tried searching the discord? Lots of past discussions of this, not sure how easy they are to find though
I want to transfer lamports from one account to another and I am struggling.
Does anyone have examples of of the system program transfer function in use?


//////////////////////////////////////////////////////////////////////////////////////////

More random guesses, what does `gcc --version`, `cc --version` etc. say?
detail about my mac
i tried it , but same
Desperation move, but does `cargo clean` help at all?
this is the final message it gives me when the build failed: error: failed to compile `anchor-cli v0.19.0 (https://github.com/project-serum/anchor#51aeb08a)`, intermediate artifacts can be found at `/var/folders/lk/ln8l958s1w52xjm8p_49rmc00000gp/T/cargo-installdBLLSm`
I've been looking everywhere, form the github issues to the discord, nobody can tell me something about why i can't install anchor on my mac
I'm using nightly, which is at 1.59, so I figured 1.58 was the latest, but guess not
??
Ah, huh
this is what i have as outcome when i run rustup update: info: syncing channel updates for 'stable-x86_64-apple-darwin'
info: checking for self-updates

  stable-x86_64-apple-darwin unchanged - rustc 1.57.0 (f1edd0429 2021-11-29)

info: cleaning up downloads & tmp directories
Just for the heck of it, can you upgrade that? Latest is 1.58 (kind of skeptical it will fix anything, but worth a shot)
rustc 1.57.0 (f1edd0429 2021-11-29)
What does `rustc --version` say?
or this error: error: failed to run custom build command for `hidapi v1.2.7`
my rust is updated
Can maybe try searching the discord, I'm not sure off the top of my head how to fix this problem. Maybe make sure your rust is up to date, etc.?
installing anchor on a 2019 non m1 macbook pro
Hi, anyone can help with this: error: failed to run custom build command for `ring v0.16.20`
I found `provider.sendAll` always give u  a failed estimated balance change on Phantom, have anyone got the same experience?
```@solana/wallet-adapter-react'```
how to use adapter wallet for anchor provider ?
titteee
https://github.com/solana-labs/solana/blob/b8837c04ec3976c9c16d028fbee86f87823fb97f/cli/src/cluster_query.rs#L1742
awesome ty
basically they have been created by deriving the address from seed+bump, now they exist, owned by the program, and are "queryable" through that ownership
Yes. And I'm sure there is a rust version of this.
ah cool, yea this might be it then. so basically I'm able to query for all accounts owned by a program
What you get in response is this struct, so each account matching the query will be returned along with its address: https://github.com/project-serum/anchor/blob/af926876c57b90f4a54a4c10c21440f9c8dc0887/ts/src/program/namespace/account.ts#L370
(maybe I am misunderstanding the context)
through filtered queries like these for instance: https://github.com/project-serum/anchor/blob/master/tests/misc/tests/misc.js#L744
let's say I have a few PDAs initialized, how do I get the addresses after the fact?
I guess it is an option. What I am wondering though is if you need that. Isn't it possible for you to simply query all accounts of that type, and using client-side logic to do what you want to do on a specific one? You wouldn't care about the seed that way (having the addresses straight up), apart from creation time. And you wouldn't have to be careful about synchronizing your PDAs with an "address book" (vector of seeds) when you close one for instance.
If I store the seed in the account's data then I'd need to know the account address in order to fetch its seed, but need the seed to derive the address
I think I've misspoke. I mistook bump for seed. So basically store the seeds in a vector. That way, off-chain I can query a single account that returns the list of seeds, then derive the addresses using the list
Sounds reasonable to me, although I'm not the most nuanced in Anchor. Would storing the bump within each account's data, and making a filtered query for all these accounts be an alternative? That would make you fetch more data to retrieve the bumps list, but you'd also be able to more naturally access the bump within the `#[derive(Accounts)]` macro, when passing these accounts to the program.
lets say i wanted to init multiple pdas over time and to also have an easy way to derive them off chain. would storing the bumps in a vector and seed in some other pda “state” struct be reasonable approach?
Thanks, this fixed the problem.
Ah, sorry, you need to `use anchor_lang::AccountsClose;` I guess
Huh, interesting
Sorry, that was for my previous test. That code returns this error:
no method named `close` found for struct `std::boxed::Box<anchor_lang::Account<'_, structs::MyStruct>>` in the current scope
How did that produce the error above? There's no mutable reference etc.
ctx.accounts.my_struct_account.close(ctx.accounts.reciever.to_account_info())?;
Can you show me the code you're writing that produces that error?
anchor-lang = "0.19.0"
Hmm, what version of anchor_lang are you using?
The problem is that I have Box<Account<'info, MyStruct>>, and get the following error:
no method named `close` found for mutable reference `&mut std::boxed::Box<anchor_lang::Account<'_, structs::MyStruct>>` in the current scope
If you have an `Account<'info, Whatever>`, you can just do
```.rs
ctx.accounts.your_account.close(account_info_to_send_the_sol_to)?;
```
Sounds like you're signing incorrectly 😛 Unknown signer means you're signing with something that actually isn't supposed to sign.
I am constantly getting unknown signer: Something
even though i am signing correctly in anchor test
Hi, is there any way to call this function or do I have to copy it?
aren't we supposed to use seeds and bump in the context of initializing a PDA?
quick question guys; can someone tell what is the difference between these two usages of the seeds contraint?

```
#[derive(Accounts)]
#[instruction(nonce: u8)]
pub struct TestInstructionConstraint<'info> {
    #[account(
        seeds = [b"my-seed", my_account.key.as_ref()],
        bump = nonce,
    )]
    pub my_pda: AccountInfo<'info>,
    pub my_account: AccountInfo<'info>,
}
```

and 

```
#[derive(Accounts)]
#[instruction(domain: String, seed: Vec<u8>, bump: u8)]
pub struct TestPdaInit<'info> {
    #[account(
        init,
        seeds = [b"my-seed", domain.as_bytes(), foo.key.as_ref(), &seed],
        bump = bump,
        payer = my_payer,
    )]
    pub my_pda: Account<'info, DataU16>,
    pub my_payer: AccountInfo<'info>,
    pub foo: AccountInfo<'info>,
    pub system_program: AccountInfo<'info>,
}
```

These are all taken from the original repo https://github.com/project-serum/anchor/blob/master/tests/misc/programs/misc/src/context.rs#L65
Generate a custom keypair `solana-keygen new -o program-keypair.json`, or copy one generated via `anchor build` in `target/deploy/program-keypair.json` out of there, and track it somehow (usual security rules apply there, depending on whether it's a prod program or just for testing). Then specify that keypair file in your deploy command whenever you `deploy` / `upgrade`
a new program ID is output everytime I delete the target folder and run anchor build and anchor deploy, which files to save so that I always get the same program ID whichever machine I run the anchor deploy
This is my context struct,
```
#[account(
        mut,
        constraint = mint.supply == 0,
        constraint = mint.freeze_authority.unwrap() == mint_auth.key(),
        constraint = mint.mint_authority.unwrap() == mint_auth.key(),
)]
mint: Account<'info, token::Mint>,
#[account(
        init,
        seeds = [b"metadata".as_ref(), self::id().to_bytes(), <mint_address>],
        ...
        ...
)]
metadata_account: Account<'info, CommunityMetadata>,
```

How would I go about getting the `mint`'s address as one of the seeds for `metadata_account`?? 
And is `self::id().to_bytes()` the correct way for getting the Program ID??
Out of curiosity, does anyone know if lets say a program owned account's SOL balance goes to 0, what will happen to the mint accounts and token accounts it owns? Will the whole mint just disappear?
Fwiw: It was because I was checking transfer amount + token_account.lamports = the increase in lamports post close_instruction - but the token_account.lamports includes the `amount` of wrapped sol it contains.
sike i might just be stupid
I also transferred wrapped sol to a native token account, and saw the token account `amount` field incremented, but not the lamports field.. 🤔
It checks if native && amount != 0, then sets your amount to 0 and poof its gone
does anyone know how to unwrap a native token account onchain? - 

https://github.com/solana-labs/solana-program-library/blob/master/token/program/src/processor.rs#L623-L655

It looks like if you do a close instruction on a native account - your wrapped sol turns to ash
Yes I changed the devnet to localnet in the [provider] section and it worked
ok so it seems a PDA can't send sol to a system owned address, but can a PDA send sol to a PDA?
is there no anchor implementation of invoke_signed
+1 to that! Thank you so much <@!134416332509675520> . 

Just another query, I was going through this repo, and I also came across `#[account(zero_copy)] , which I wasn't able to find in the docs as well here https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html

What does that do?
thanks alan big fan btw <:hugheart:851872735700844575>
Actually not sure, but you can see them in `.anchor/program-logs` inside your project
tells anchor to expect `some_account` to *not* have its discriminator bytes yet.
`#[account(zero)]` is a somewhat specialized usecase: when you allocate an account in a separate instruction, anchor won't have had a chance yet to set those 8 discriminator bytes. Doing
```.rs
#[derive(Accounts)]
pub struct MyAccounts<'info> {
    #[account(zero)]
    pub some_account: Account<'info, Whatever>
}
```
Both of those accounts look the same as raw bytes (both take 4 bytes). But when anchor actually serializes them to an account, it uses an additional 8 bytes at the beginning that's (roughly) a hash of the struct name. This lets anchor make sure not to accidentally treat a OneAccountType account as a SomeOtherType account (without the discriminator bytes you could get confused, since they look similar as far as their content bytes go).
The account discriminator stuff is anchor's way of making sure you don't accidentally misinterpret the data in an account. When you say
```.rs
#[account]
pub struct OneAccountType {
  a: u8,
  b: u8,
  c: u8,
  d: u8
}

#[account]
pub struct SomeOtherType {
  x: u32
}
```
I think the easiest way to get a feel for the `#[derive(Accounts)]` stuff is by looking at anchor examples + the tests/ directory. The basic idea is that you're declaring "I expect to receive accounts that look like this"; you're asking anchor to deserialize stuff, check that this or that account signed, etc.
super noob question how can i get tests to print logs from tx
Any doc/article/tweet explaining the structure of Accounts?

Also, what is the use for the discriminator with reference to accounts? and what is the use-case for `#[account(zero)]`?
Hello, I want to test an error condition. The output looks like the following:
```Transaction simulation failed: Error processing Instruction 0: custom program error: 0x0 
    Program 8LxiqthNj9nBBLUWNZUNhAfBJYaUMY97TDzgPAFCq4TJ invoke [1]
    Program log: Instruction: RegisterMint
    Program 11111111111111111111111111111111 invoke [2]
    Program 11111111111111111111111111111111 success
    Program 11111111111111111111111111111111 invoke [2]
    Allocate: account Address { address: 6U12CLNmVk1wCKYFS7uNkPginAwB4mEnYpxHrrPnJFHG, base: None } already in use
    Program 11111111111111111111111111111111 failed: custom program error: 0x0
    Program 8LxiqthNj9nBBLUWNZUNhAfBJYaUMY97TDzgPAFCq4TJ consumed 200000 of 200000 compute units
    Program 8LxiqthNj9nBBLUWNZUNhAfBJYaUMY97TDzgPAFCq4TJ failed: custom program error: 0x0
```
Can someone show me how I can assert that my request fails with this "account address already in use" error? I understand I can run a  try/catch but after catching I don't even know what the object shape is
thank you
got it
The provider wallet, as far as I know
Oh. That's specified in your Anchor.toml I think
Understood, but is there a way to define/predict which account is the payer before deploying?
Thank you so much!
No, not possible like that. In solana you always have to pass any accounts you are about in from the client (not possible to dynamically look them up like that in your rust program)
I have a PubKey and I want to get the AccountInfo for the associated account. Is this possible? I have tried to do this:

  //get the account info
        let some_acct_info : AccountInfo = SOME_ADDRESS.to_account().to_account_info();

I also tried:
//get the account info
        let some_acct_info : AccountInfo = SOME_ADDRESS.to_account_info();
You can estimate how much you'll need to pay by noting that rent-exemption for the upgradeable deployment workflow costs 7*2 sol / mb (so e.g. a 500kb .so file would cost roughly 7 sol)
You're paying for storing your compiled code on-chain (the .so file in target/deploy)
how/where can we see which account will need funds before deployment?
```Error: Account 4RJZ2rNmTXrVZAgxYxSnjNPdwHxsDP14Tv1oK4LbQQLH has insufficient funds for spend (1.06374552 SOL) + fee (0.000775 SOL)
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.```
ran anchor deploy and got this error
You can do
```.rs
use std::str::FromStr;
let pk = Pubkey::from_str("asdfasdfsa").unwrap();
```
How can you go from a string to a PubKey?
Thank you so much!
@here help needed with anchor build
anyone know how to fix

```
({"Object.<anonymous>":function(module,exports,require,__dirname,__filename,global,jest){export * from './useWalletModal';
                                                                                             ^^^^^^

    SyntaxError: Unexpected token 'export'
```

when running tests in a project created using create-react-app

When trying to use `import { WalletModalButton } from "@solana/wallet-adapter-react-ui";`


//////////////////////////////////////////////////////////////////////////////////////////

`some_account_n`
just having to list out N accounts
What do you find unpleasing aesthetically about the above?
yea i guess it's not an anchor limitation, moreso how programming model was designed
there's no other way than manually writing the initialization code
what did you have in mind?
I want to init several PDAs within one tx but was wondering if there was a more aesthetically pleasing way then to just list out all the accounts in the instruction?
e.g.
```
#[account(
        init,
        seeds = [b"ACCOUNT_1"],
        payer = admin,
    )]
    pub some_account_1: Account<'info, SomeAccount>,
    #[account(
        init,
        seeds = [b"ACCOUNT_2"],
        payer = admin,
    )]
    pub some_account_2: Account<'info, SomeAccount>,
```
gm frens
What have you tried so far?
From the MintPubkey
<@!134416332509675520> 
How can I get the MintAccountInfo on the tests?
Does it mean there are no programs for Chainlink deployed at mainnet but only for devenet? https://docs.chain.link/docs/solana/data-feeds-solana/#Solana%20Devnet
About tokens/lamports etc., it just means that you can have an account that lives at the PDA address—any account you want (slight asterisk because there's a weird technical limitation on how big accounts can be if they live at PDAs, because all accounts that live at PDAs have to be allocated/init'd via a CPI—whatever)
Only the deriving program can sign for one of its derived addresses, so someone else knowing the seeds doesn't matter—what's relevant is making sure you're program isn't dumb and blindly signs for its PDAs without making sure it makes sense etc. But at the end of the day *only* the deriving program can sign, so it's just up to you to make sure your program isn't dumb/gullible.
A PDA is a program-derived address, so indeed, it's just an address, and an account may or may not live there.
https://twitter.com/pencilflip/status/1455948263853600768
Hi guys, i was wondering what is the idiomatic way to create PDA in Anchor and where to read about it?
Also you could discord search for it. We discussed it recently enough in the rust chat
I've seen this done in Mango's voter locking program
I mean unit testing it in rust.
How do I test anchor programs?
I have another PDA question, what if another person know our seed and create the PDA, can that PDA sign transaction?
I guess to put it another way, is a PDA an account itself? Can you get the account info and put lamports in it? I thought it was just an address. If it is just an address what does it mean for tokens/lamports to be on it?
hello , can someone explain to me the different between is_signer and is write-able? in AccountMeta? If something is writable, doesn't it always required to be signer as well?
can the address be used accross programs or no
eg i have a "StructA" in 2 diff program's code
if i 2 programs deserialize the same formatted struct, can they get the same info?
Your program can sign for one of its derived PDAs, but not sure what you mean above. Like, have a token account whose authority/owner is a PDA?
What do you mean by "allow a PDA to sign for it"?
I have a PDA question as well, but even more basic. Lets say I have an account and I want to allow a PDA to sign for it in the future, can I do that? If not, how do you create an account a PDA can sign for?
Ok, not sure what to suggest other than triple checking you can `create_program_address` with those seeds + bump and get the address you're expecting, hmm
i just need to get these message logs
no worries, you've been helpful
Ah
that's why i have the `.concat()`
Sorry, 50/50 chance I'm being dumb and tired right now
But the bump has multiple nestings
for pubkeys
i think `seeds.chunks(32).collect::<Vec<&[u8]>>().as_slice()` somehow gets you to that format
Maybe that doesn't matter somehow and I'm being dumb?
So note the different nesting from what you have
In general signing for one PDA looks like
```.rs
&[
  &[ b"some seed".as_ref(), b"whatever".as_ref(), &[the_bump] ]
]
```
just 1, but the seed format is dynamic
How many PDAs are you trying to sign for? Just 1?
To me the way you're using the bump there looks wrong (too nested)
Hmm, I'm suggesting a change that shouldn't change anything though, right?
but it's still kinda brutal
then your seeds are 
```
        seeds
            .iter()
            .map(|v| v.as_slice())
            .collect::<Vec<&[u8]>>()
            .as_ref()
```
you can first declare a `Vec<Vec<u8>>`
I figured out a "clean" way to do it
kinda hard to change it up as it switches based on input
It's funny how hard it is to read seeds in solana, lol
Have you tried that seeds change?
so i'm just really confused :/
yeah i figured that as well
Like, I can't think of anything
Hmm. Anchor itself shouldn't have almost anything to do with the code above, for what it's worth
yeah it's a weird way to do it for sure, but it does work. can confirm that the tests indeed passed on a pre-anchor version of the code on a different branch.
I'm maybe being dumb though
The way you're using the bump up there looks suspicious to me (I'm a little sleepy though), should it rather be
```.rs
&[
    [seeds.chunks(32).collect::<Vec<&[u8]>>().as_slice(), &[bump]],
]
```
yeah just like above, but it's possible that other stuff changed in the input/previous instructions. I did do a `create_program_address`  to match the keys and they appear to match (the unwrapped enum my test showed me didn't correspond to mismatched keys)
Anchor wouldn't have changed anything with what you wrote above, unless I'm totally missing something
Wait, how are you doing it in anchor though? Just like the above?
i'm talking to some solana internal guys about how to fix those...
really hard to do without logs
it says i'm getting some privilege escalation. I'm not even sure if this is where the error is, but it seemed like the most reasonable guess
No that's fine in anchor—so what's going wrong then?
can i not do this is anchor?
Oh the code is identical
Ok, cool, so that works? How are you doing it with anchor?
haha pretty sure i'm doing this the correct way as it was working pre-anchor:
```
    let new_order_instruction = agnostic_orderbook::instruction::new_order(
        *accts.aaob_program.key,
        *accts.orderbook.key,
        *accts.market_signer.key,
        *accts.event_queue.key,
        *accts.bids.key,
        *accts.asks.key,
        agnostic_orderbook::instruction::new_order::Params {
            max_base_qty: max_base_qty.m as u64,
            max_quote_qty: u64::max_value(),
            limit_price: limit_price_aob,
            side,
            match_limit,
            callback_info: callback_info.to_vec(),
            post_only,
            post_allowed,
            self_trade_behavior,
        },
    );
    invoke_signed_unchecked(
        &new_order_instruction,
        &[
            accts.aaob_program.clone(),
            accts.orderbook.clone(),
            accts.market_signer.clone(),
            accts.event_queue.clone(),
            accts.bids.clone(),
            accts.asks.clone(),
        ],
        &[[
            seeds.chunks(32).collect::<Vec<&[u8]>>().as_slice(),
            &[&[bump]],
        ]
        .concat()
        .as_slice()],
    )?;
```
How are you signing for the PDA?
I've given up on using anchor magic and reverted most of my structs back to AccountInfos because it's easier to control
and the CPI is failing for some unknown reason
but what i think is happening is that i'm trying to sign with a PDA
```
thread 'test_simple_trade' panicked at 'called `Result::unwrap()` on an `Err` value: TransactionError(InstructionError(0, PrivilegeEscalation))', 
```
this is all i have because no message logs 😦
What goes wrong? Like, what error etc?
How exactly does the `is_signer` field of `to_account_metas` work? The comment makes me think that setting it to `Some(true)` is sufficient to allow my PDA to sign, but it seems to break
yea found it. https://github.com/project-serum/anchor/blob/51aeb08ae1c93f9f759c6e244e3fa724c9a916a7/lang/attribute/account/src/lib.rs#L175 called inside `Account::exit`
I don't see why this can't be automated 🙂
but lots from the system program
none from the programs :/
So you don't get any msgs at all now?
It's just kind of annoying (easier to use `init`)
initializing accounts using  the system program directly and not cpi
though not sure if he's dealt with this particular issue before
i guess i can ask armani
sad
Hmm, no idea honestly
after the `msg` logs stopped working
Why isn't what done by default?
but the program itself is kind of a black box when it fails
so i can use this to (poorly) trace where in my test i'm reaching
why isn't this done by default ?
notice how it's tagged with `solana_runtime`
This is a snippet of what currently shows up:
```
[2021-12-23T23:59:06.278363000Z TRACE solana_runtime::system_instruction_processor] process_instruction: CreateAccount { lamports: 555352320, space: 79664, owner: DxLbvXdGt9JzdnQU4cFF4B42ExpqoPw29zs2zVQS6YHh }
[2021-12-23T23:59:06.278454000Z TRACE solana_runtime::system_instruction_processor] keyed_accounts: [KeyedAccount { is_signer: false, is_writable: false, key: 11111111111111111111111111111111, account: RefCell { value: Account { lamports: 1, data.len: 14, owner: NativeLoader1111111111111111111111111111111, executable: true, rent_epoch: 0, data: 73797374656d5f70726f6772616d } } }, KeyedAccount { is_signer: true, is_writable: true, key: 9uTF3Jo8C6LNKJJoWmmmru5A3VxsQ9Zm4j42mqd6X94B, account: RefCell { value: Account { lamports: 999996391455840, data.len: 0, owner: 11111111111111111111111111111111, executable: false, rent_epoch: 0 } } }, KeyedAccount { is_signer: true, is_writable: true, key: 4w3yYhLono52FoguhZD2ULsjxsM8C52obruEkqUVtT19, account: RefCell { value: Account { lamports: 0, data.len: 0, owner: 11111111111111111111111111111111, executable: false, rent_epoch: 0 } } }]
```
when it's a program log
it gets tagged with `solana::message_processor`
previously i was seeing logs with `msg!`
Can you see logs with `println!`?
Aha! Okay so it writes the discriminator in the end. Thought it's left like that
i think i compiles the code down to BPF and allows you to execute against the binary
I actually have no idea how that works now that I think about it, haha
What does cargo test-bpf even do?
stdout
Oh. Have never used that before—where were your logs getting printed when they were working? 🤔
So unless you go out of your way to do something dumb, you can only use `#[account(zero)]` when you're initializing the account (so there's nothing in its remaining bytes at all generally, just zeros)
By checking that the discriminator is zero (and then filling in the correct one at the end of the instruction), you can only have a zero discriminator in very specific circumstances (I can't think of any besides allocating the account in a separate instruction)
E.g. imagine you have two account types like this; they could get confused because their `.data` looks similar:
```.rs
#[account]
pub struct OneAccount {
  a: u8,
  b: u8,
  c: u8,
  d: u8
}

#[account]
pub struct OtherAccount {
  x: u32
}
```
So in this case, if I have a zero discriminator, how will anchor know that I'm passing the correct struct to the program ?
Yeah, pretty sure the regular AccountsExit stuff does it
```The discriminator is defined by the first 8 bytes of the Sha256 hash of the account's Rust identifier--i.e., the struct type name--and ensures no account can be substituted for another.``` just to make sure, does this mean that discriminator makes anchor know that the correct struct was passed to the program ?
i'm testing with `cargo test-bpf` still
actually, I cant find the code for this. But I think it has to be true
wait idk if i can
sounds good
and then the discriminator is still added at the end of the ix by anchor
Try looking in `.anchor/program-logs`
`msg!` doesn't seem to print
E.g. with `#[account(zero)]`, which does indeed skip using them (well, sort of—it asserts that the discriminator is zero, which is different from "skipping" it)
There is still the question of the program longs not showing up
You can't skip using discriminators unless you deliberately go out of your way not to
Hmm, not sure what you mean 🤔
awesome
appreciate it, thanks!
&account.data[..8] = [
    22,
    77,
    255,
    134,
    163,
    41,
    57,
    134,
]
thank god
cool
just zero
i guess not
no
```
    #[account(zero)]
    #[account(mut)]
```
does that work or no
```.rs
#[account(zero)]
pub the_account: AccountLoader<....>
```
the program won't verify the input, but more like deserializes into that struct. So I guess that won't be problematic. What's the need for discriminators if we can stop using them then ?
i think i'm dumb
wait 2 macros right?
Huh, had never noticed that before lol
ah just zero then
is what my compiler is telling me
`mut cannot be provided with zeroed`
and this
u need `mut` and `zero`
for sure let me try it
this I mean
yes you should add that
so didn't really need anchor
I implemented the zero copy from scratch before
could that be the problem?
back then i used `#[account(mut)]`
So no security risk unless you bypass using `Account<'info, Whatever>` aka do something dumb
when i used the AccountLoader
hm maybe it was because i didn't have the `#[account(zero)]`
the function
Right—a zero discriminator is still a (wrong) discriminator 🙂
you definitely need that if you want to use zero copy. send me the code that breaks
I had market_product_group: AccountLoader<'info, MarketProductGroup>,
isn't that what discriminators are for
yeah it was breaking when i had that
Passing an account that have maybe similar byte size but doesn't match the structure
I dont see an `AccountLoader` type in there
Can you say more? What risk do you have in mind?
wydm by instruction
<@!134416332509675520> in that case, the account won't have a discriminator. Wouldn't that cause a major risk ?
```
#[derive(Accounts)]
pub struct InitializeMarketProductGroup<'info> {
    authority: Signer<'info>,
    #[account(zero)]
    market_product_group: AccountInfo<'info>,
    #[account(mut)]
    vault: AccountInfo<'info>,
    vault_mint: Account<'info, Mint>,
    fee_collector: AccountInfo<'info>,
    fee_model_program: AccountInfo<'info>,
    fee_model_configuration_acct: AccountInfo<'info>,
    risk_engine_program: AccountInfo<'info>,
    sysvar_rent: AccountInfo<'info>,
    system_program: Program<'info, System>,
    token_program: Program<'info, Token>,
}
```
sure
Ok could you share your derive(Accounts) and your instruction?
Ah, could be a different tx, or just a separate instruction within the same tx
I know 🙂 I mean the case where we want bigger accounts
No, CPIs are all within the overall tx you started from the client
so in the latter case, there would be a seperate tx (invoke my program + allocate account)?
Not sure what you mean. Your anchor program cpi's to the system program
previously had the `mut` constraint
another unrelated program i have is that my `msg` logs in the program no longer show up in my tests. I added the `zero` constraint.
holy, never knew that init are done using a cpi, kinda weird thinking about it. what program invokes the init?
have you added the `mut` constraint to that account?
yeah outside the program
so not in the program?
After I await the tx that creates the Foo account and then anchor ix that populates it
It's currently just a weird quirk that accounts created via a cpi (e.g. any `init` you do in anchor) can only be 10kb in size, whereas issuing a direct instruction to the system program from the client (not via a CPI) can go all the way to 10mb
where do you check this?
CPI = solana thing where you invoke another program, discriminator = pure anchor thing where anchor writes 8 bytes into your accounts to make sure you don't mistake a Foo account for a Bar account
I see, and what's the relation between cpi and discriminator ?
you can create the account in a previous instruction with a normal system program instruction so it can be larger cause thats not a cpi
all of the fields on my struct are correct besides the first 8 bytes :/
and how does zero make you able to create accounts > 10kb ?
dont think so
Could be that `anchor` and `solana-program-test` just don't mesh well?
if you create the account in a previous instruction (e.g. cause it's >10KB and you cant use CPI) instead of using `init`, then you can use `zero` to make sure it's not used yet
hm for context, i'm migrating over a code base that didn't use anchor over to anchor. It's failing on test cases that previously worked and after the instruction supposedly succeeded, i see that the first 8 bytes are still 0's
```
[programs/foo/tests/common/utils.rs:82] &account.data[..8] = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
]
```
it doesnt write the discriminator but that doesnt matter. anchor writes the discriminator for you after your instruction.
nope, because I don't think that function actually writes the discriminator. It seems to do a check to make sure that the first 8 bytes are 0, but I don't see where it actually makes the copy. At least in my version of the code
```
let mut foo = ctx.accounts.foo.load_init()?;
```
so this doesn't work?
So it needs the discriminator to not fail, but I also have no other way to write the discriminator (which i assume works normally when you do `#[account(init, ...)]`)
I think it must have called `try_from` somewhere and failed on this block:
```
        if disc_bytes != &T::discriminator() {
            return Err(ErrorCode::AccountDiscriminatorMismatch.into());
        }
```
I was getting 3002's when trying to test my code
why are you creating the `AccountLoader` yourself?
why would I need to check that ?
I could try to just directly copy it, but I'm sure there must be a less dirty way to do this
```
    let loader: AccountLoader<'_, Foo> =
        AccountLoader::try_from_unchecked(ctx.program_id, accts.foo.as_ref())?;
    let mut foo = loader.load_init()?;
```
Lets me do stuff, but it doesn't actually set the 8 bytes
how do you set the discriminator of an account that was created in a separate instruction? I'm generating an account >10KB so I can't do it in a CPI
`zero` asserts that the account discriminator is zero. `init` creates an account
what's the difference between zero and init ? <@!134416332509675520>
It worked!
Thank you I will try that!
Ah, yeah, you forgot to mark the givewell account as mut
Can you post your actual program log? I wonder if you forgot to mark something as mut
the author is the provider.wallet for this test
I do this in the .ts file:

// Now lets use our new command!
    await program.rpc.matchIfSmaller(new anchor.BN(donation/2), {
        accounts: {
            // Accounts here...
            matching: matching.publicKey,
            author: program.provider.wallet.publicKey,
            systemProgram: anchor.web3.SystemProgram.programId,
            giveWellAcctInfo: giveWellpubkey,
        },
        signers: [matching],
    });
Has the author signed from the client?
// get the author
        let author: &Signer = &ctx.accounts.author;

        // get the give well account info
        let give_well_acct_info: &AccountInfo= &ctx.accounts.give_well_acct_info;
        //send lamports from the author to give well
        let my_tranfer_instruction = transfer(author_account_info.key, give_well_acct_info.key, matchable_donation);
        //Now we want to pass this instruction to invoke
        invoke(&my_tranfer_instruction, 
                &[author_account_info, give_well_acct_info.to_account_info()],
        )?;



Gives me the error: Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account

But, this has worked for me in another function with the same setup for author, but where the receiving entity is different. Any advice?
Is there a native way to sort on timestamps when fetching? When I fetch accounts they aren't always returned in the order that I created them. I am solving this now by just doing a `.sort` on the frontend.
I think what you need here is ``#[account(init)]`` if you are initializing the matching account. In that case, it's needed as signer. Otherwise you can do ``#[account(signer)]``
Cause you are passing matching as signer, yet you don't have it as a signer in the context
But i keep getting an error "unknown signer"
I am doing it this way:

//Get an account for a public key
    const addressbs58 = "Bazj7if5Gbf7VwEVQjGSfM4kyByrzuRrRoKeje7f2dwv"
    const giveWellpubkey = new PublicKey(addressbs58);

    // Now lets use our new command!
    await program.rpc.matchIfSmaller(new anchor.BN(donation/2), {
        accounts: {
            // Accounts here...
            matching: matching.publicKey,
            author: program.provider.wallet.publicKey,
            systemProgram: anchor.web3.SystemProgram.programId,
            giveWellAcctInfo: giveWellpubkey,
        },
        signers: [matching],
    });
I want to get the account for a given public key address and then pass in the account in a test
Those are the list of attributes that you can use. As far as I know if you do ```pub matching: Account<'info,MatchingDeclaration>``` anchor will check if the provided account follows the MatchingDeclaration Structure
https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html
I want to check in #[derive(Accounts)] if I was really handed a MatchingDeclaration, but I am not sure what to do in the #[account(...)] to do that. Any advice? 

#[derive(Accounts)]
pub struct MatchIfSmaller<'info>{
    pub matching: Account<'info, MatchingDeclaration>,
    #[account(mut)]
    pub author: Signer<'info>,
    #[account(address=system_program::ID)]
    pub system_program: AccountInfo<'info>,
    #[account(address=givewell::ID)]
    pub give_well_acct_info: AccountInfo<'info>,
}
`msg!("Log something {}", something);`
I want to log various values so I know what they are
How do you log things using anchor?
I know right, but thank you anyway, you made me look at the issue from a different approach
Wow, interesting
i tried it, run it back again, the it was installed, with anchor-cli --version : anchor-cli 0.19.0
Then i saw that one on Github as a lifesaver: sudo mv /usr/local/include /usr/local/include_old
because it was giving me a lot of warining
i start investigating this error instead from the log: "error Never include this file directly. Use <lzma.h> instead."
Oh shit, what did you change?
I get it running  and installed 🍾
As long as it's not like derived from some mutating variable is as good as constant. So it's possible per se but the community is going to update the rent exemption amount and give lots of warning ahead of time IF they do update the amount.
Yes fair point, without clear warning this would wreck the space haha
good enough as constant for me
Yeah thus far rent has never changed. You'll get lots of warning
I actually never considered this. I always assumed rent would be constant (or going down if anything, if sol price made it an accessibility issue like it is sorta becoming for program deployment)
When is the account minimum rent exemption updated? Like if it's the off chance that an epoch rolls over and rent exemption is raised right as we calculate rent, is it possible that it is not rent exempt?
account rent exemption. thanks for helping!
Actually this might have something to do with cc, because here's the first that was thrown at me:   error occurred: Command "cc" "-O3" "-ffunction-sections" "-fdata-sections" "-fPIC" "-m64" "-arch" "x86_64" "-I" "etc/hidapi/hidapi" "-Wall" "-Wextra" "-o" "/var/folders/lk/ln8l958s1w52xjm8p_49rmc00000gp/T/cargo-installjJ5iEj/release/build/hidapi-e4c2831a1597e2ad/out/etc/hidapi/mac/hid.o" "-c" "etc/hidapi/mac/hid.c" with args "cc" did not execute successfully (status code exit status: 1).
cc --version: Apple clang version 13.0.0 (clang-1300.0.29.30)
Target: x86_64-apple-darwin21.2.0
Thread model: posix
InstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin
gcc --version:Configured with: --prefix=/Applications/Xcode.app/Contents/Developer/usr --with-gxx-include-dir=/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/4.2.1
Apple clang version 13.0.0 (clang-1300.0.29.30)
Target: x86_64-apple-darwin21.2.0
I would like to help you but I'm not sure I understood the question. Are you talking about account rent exemption, or transaction fee?
Is there any chance that minimum rent will go up asynchronously before a contract is executed? I'm wondering if I should pad the lamport requirement like 5-10% for important transactions.


//////////////////////////////////////////////////////////////////////////////////////////

Gotcha, so if another struct has only a `Pubkey`, I can't use it as a destination address, right? I have a vector of structs, where which struct contains a `Pubkey` of a user that originally passed some data. I was thinking maybe I can use data from this vector to send tips to people who appended the vector.
<@!721030147871866881> is likely onto something. You just hit the next issue in your program so I guess your provider is fine now at least.
all `AccountInfo`s used in a program must be passed into the instruction at the beginning, i.e. must be specified in the Accounts struct (except for `remaining_accounts` which dont have to be specified in the Accounts struct but still need to be passed)
gm y'all,  can I go from `Pubkey` to `AccountInfo`? Trying to implement sending a tip here
workspace pascal cases program names, so it capitalizes first letter of program name. Try `const program = anchor.workspace.GmProgram;` assuming your program name is `gm_program` in rust
tried that
https://github.com/project-serum/anchor/blob/master/ts/src/provider.ts#L46
yeah try using `const provider = anchor.Provider.local();` instead
I believe this is due to how you initialize your provider through `const provider = anchor.Provider.env();`
This probably works in the context of `anchor test` because that command injects environment variables from `Anchor.toml` or some defaults to the shell, before actually running the `mocha` command (I did not check though, so speculating here for now).
There must be another way to instantiate it. `local()` or something like that. Let me see
p.s. im noob @ writing tests
the code.
`const anchor = require('@project-serum/anchor');
const { SystemProgram } = anchor.web3;

const main = async() => {
  const provider = anchor.Provider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.gmProgram;
  const myAccount = anchor.web3.Keypair.generate();
  await program.rpc.initialize({
    accounts: {
      myAccount: myAccount.publicKey,
      user: provider.wallet.publicKey,
      systemProgram: SystemProgram.programId,
    },
    signers: [myAccount],
  });

  account = await program.account.myAccount.fetch(myAccount.publicKey);
  console.log(account.message)
}

const runMain = async () => {
  try {
    await main();
    process.exit(0);
  } catch (error) {
    console.error(error);
    process.exit(1);
  }
};

runMain();`
hi. im trying to run a client.js file but it showing up this `ANCHOR_PROVIDER_URL`
Try this just to transpile and run: 
import {
  // @ts-ignore
  workspace,
  Program,
} from "@project-serum/anchor";
thanks! will have a look
```TSError: ⨯ Unable to compile TypeScript:
mush-sol.ts:10:26 - error TS2339: Property 'workspace' does not exist on type 'typeof import("/[...]/mush-sol/node_modules/@project-serum/anchor/dist/cjs/index")'.```
when I try to run I am getting a compilation error
I see - any known workaround?
Check out this issue https://github.com/project-serum/anchor/issues/1153. I just checked beta release on npm and issue still present as far as i can tell. You can import workspace directly and use // @ts-ignore on the import just to hold you over and run your tests.
Ah, my understanding is that this is a typescript bug in the current anchor version (your code should run fine I think)
<@!134416332509675520> ?
anyone know how to resolve this error in the test file?
```Property 'workspace' does not exist on type 'typeof import("/[...]/node_modules/@project-serum/anchor/dist/cjs/index")'```
```import * as anchor from '@project-serum/anchor';
import { Program } from '@project-serum/anchor';
import { MushSol } from '../target/types/mush_sol';

describe('mush-sol', () => {

  // Configure the client to use the local cluster.
  anchor.setProvider(anchor.Provider.env());

  const program = anchor.workspace.MushSol as Program<MushSol>;

  it('Is initialized!', async () => {
    // Add your test here.
    const tx = await program.rpc.initialize({});
    console.log("Your transaction signature", tx);
  });
});
```
I haven't used the loader a ton so i'll defer to others, but in general it seems unnecessary to perform the same computation of generating the ref more than once even if it's cheap today.
or nah
but wondering if that's important in any way
memory, i g
Do you explicitly trade off anything by storing the ref?
wondering if I should be storing an account or loading every time
is .load() expensive?
This is very helpful!
When testing this in Anchor - do you deploy testnet NFTs, then read the data?
Since it is read-only, I do not need any contract calls yet
It is a rust dependency, i 'use metaplex_token_metadata::{self, state::Metadata}' it at the beginning of lib.rs 
https://crates.io/crates/metaplex-token-metadata
Sure. Thank you! 
How do you have your account read metaplex_token_metadata - is the definition for metaplex_token_metadata taken from another smart contract (the metaplex one) copied to your project?
I'm trying to get something like that working, the project has preminted NFTs, I handle read-only metadata and NFT transfers inside the program. Reading metadata account requires the pubkey of it, and I just use metaplex_token_metadata::{self, state::Metadata} to deserialize it. The pubkey is found like 
    const [metadataPubkey, metadataPubkeyBump] = await PublicKey.findProgramAddress([METADATA, METADATA_PUBKEY.toBuffer(), nftMint.toBuffer()], METADATA_PUBKEY)

If you have specific questions about it, I can elaborate further
How would I interact with a Metaplex NFT from my own smart contract in Anchor? I want to use NFTs in a game
I know I need to have instructions that read the mint, token account, token account auth & metaplex metadata, but I don't know how to code that 
I'm guessing that involves CPI & PDAs, using structs I write that are patterned after the Metaplex ones & can read their data given their smart contract address


//////////////////////////////////////////////////////////////////////////////////////////

I think you could solve some of your problem by making each user account a PDA. This pattern creates a "virtual" or "distributed" hashmap that scales up/down as users enter/exit.  Separately, I'm not sure this is exactly related, but you could explore using a merkle tree as a concise data structure. Here's saber's implementation of uniswap/oz's merkle distributor https://github.com/saber-hq/merkle-distributor.
It might for instance help increase the probability that all NFTs would be claimed in a particular page, and allow rent recovery for it
Some kind of "pagination" might also be something to look into for these huge structures
I'm wondering if with these numbers you will hit compute budget issues
I will try to compute rent cost of a map where entries are `key[NftIdentifier]->Value[userPubKey]` with 30,000 entries and see how unreasonable that value is
Well the "simplest" solution right now seems to be create a map of a size that can fit the max possible entries based on total NFTs in the collection - I'd estimate it to max at 30,000 for my actual project (which is more complex than the example)
Idk how much a map of tokenId->userKey would cost of there was say, 40,000 entries..
As to an immediate solution with some sort of switch between account, I am not too sure, but it's worth exploring
And at that point instead of trying to scale up, maybe I just pay the rent for the maximum
I think there is change coming... sometime that allows resizing of accounts. At least I think I heard that. It would probably solve this issue
There would be a theoretical maximum, as there is a finite set of NFTs in my actual project. It may be a lot 5000 or 10000) but there is a max
Another option would be if I could use a single "resultMap" for all shuffles that is constantly modified and maintained after each shuffle, that would work too, but I'd need to be able to increase the allocated byte size of the map as it grows, since it would reasonably be expected to grow over time as users don't claim in reasonable time. Maybe that's possible...during shuffle, if the alloced bytes for the map is too small, create a new state account with a larger size. I don't know if that kind of code is really feasible though
And you might be able to find ways to incentivize people to claim
Then there might be a separate solution for this issue. A sort of time limit after which an archiver instruction can be run to store those unclaimed NFTs in a more cost effective structure, while claiming back the huge one. Granted this might still end up costing some upfront amount, but that's a general issue of scaling structures at the current price point
And if a shuffle is being done every day...hm
Well you may have to maintain the state of each shuffle for a long time (or forever) if even a single user does not claim their NFT
Yes. And I don't believe it would be too bad. The rent will be non-negligeable for thousands but even then it's feasible. Especially since it can be claimed back after the suffling, so in that sense not really a "cost"
Which, for a program of 100 not so bad, but if it's scaling up to 1000 or 10000 at potential max could maybe cost a lot of rent, but would potentially be a solution
yea maybe! I think that could require storing a large mapping of NFT to owner in state? Maybe you could get away with just NFT->newOwnerKey
(this claiming happening after the "shuffle" instruction has been called and has done its magic on a state account of the program)
Wouldn't there be way to decouple the shuffling from the actual re-assignment of ownership? I'm thinking the only moment you really need to do so is when the users actually come to claim their own shuffled NFT.
It wouldn't require all signatures, but since each escrow account is being mutated they would all need to be passed in the transaction instructions I believe
Why would the shuffle transaction require all signatures? Wouldn't it instead require only the PDA they have been delegated to to sign?
Is there anything I'm not thinking of that can be applied here to better work with the account number restraint?
This restraint on the number of accounts that can be touched in a single transaction feels very limiting to any more complicated programs working at scale. 

Creating an example to reference:
Say a program is being built such that owners of a given NFT collection can sign their NFT over to the program to hold on to. Once 100 owners have done so, the deposited NFTs have their owners shuffled, and afterwards, each owner can claim the NFT they now own.

This would require individual transactions for each owner to deposit their NFT, then one "giant" processing transaction to do the shuffle, then individual transactions as all owners claim whichever NFT they now own.


I am struggling to see a way to do this cleanly if limited to something like 30 accounts being touched per transaction. The "giant" transaction would need (at minimum) all 100 escrow accounts passed to transfer ownership. Breaking this up to multiple transactions creates a number of potential problems, especially WRT fair randomization and managing of state
Thanks!
Yes that raises a ton of problems to my initial design. Will need to think on it
Maintain a var somewhere to say it's mid-processing to lock other functionality while all transactions are being fed and executed
I take it I'd have to break it up into a bunch of transactions, woof
Very problematic, hm
Oh, that'd be problematic
But it's also just kind of awkard in general in solana, because the absolute max number of accounts you can touch in a single tx is ~30 (absolute absolute max) because the entire tx has to fit in 1232 bytes
Oh I've seen that
This is unfortunately kind of awkward in anchor, you'll have to use `remaining_accounts`
Perhaps you pass an array of accounts in the instruction?
Hmm...sort of. If I want a transaction to modify a set of accounts under the program's control and that is a dynamic number of accounts, that is at odds with the current code I've seen where you specific a static number of accounts for an instruction
Oh I see! That makes sense
Can't do it from within your program (you have to pass any accounts you care about into your program from the client)
Like during program transaction execution
What about from rust?
Yep, there's an rpc call for this: https://docs.solana.com/developing/clients/jsonrpc-api#getprogramaccounts
Try printing the actual serialization itself, `println!("{:?}", s.try_to_vec())`, and see if that clears it up
Yeah, can't think of any other reason to use it deliberately (boxing Accounts that is)
```rust
    let s= String::from("abcde");
    println!("{}", s.as_bytes().len()); // 5
    println!("{}", s.try_to_vec().unwrap().len()); // 9
```
Why do I get `9` as output with borsh's try_to_vec?
Can provide more context if needed
Hey all, got a question. 

 Is there a best practice way for a program to track all escrow accounts under it's control at a given time? Maintain a map? Is there a lookup function to get all accounts a program owns?
is the box pointer only used when you expect the stack size to exceed solana's stack limit?
Yeah, wallet accounts are owned by the system program.
this was very helpful, thank you. i remember reading about the 8 byte discriminator, but didn't make the connection it needed to go in the `data` field
Are all externally owned accounts (the ones controlled by people) owned by the System Program?
Key solana mental model thing: if you want to mutate an account's data (moving tokens mutates a token account's data, for example) you always have to go through the account's owning program (only an account's owning program is allowed to mutate it or spend its money). So it only makes sense to ask the system program to mutate/spend some money for an account owned by the system program (so, for example, the system program transfer function is *not* a general purpose sol transfer function—it only works if the source account is owned by the system program, since otherwise the system program wouldn't be able to spend its money)
About your last question, you wouldn't be able to use the system program for this, you'd have to use the spl token program to move/burn nfts (nfts are tokens).
Cool i think i am missing these signers
Yes, but you'll also have to sign for any accounts you're creating (if they live at keypair addresses, as opposed to PDAs)
Thanks for reply.
I have specified signers. But may be not the correct one. 
I should list all the keys which have #[account(signer)] in the Account defination right
Your best bet to figure out how to do the CPI is to read the candy-machine source: https://github.com/metaplex-foundation/metaplex/blob/master/rust/nft-candy-machine/src/lib.rs#L489
Check out the `signers: [...]` argument
You've probably forgotten to sign for an account (in your JS/TS code)
Hello, 
I am writing a smart contract in anchor. I am getting following error message while i am executing tests in typescript.
      Error: Signature verification failed
      at Transaction.serialize (node_modules/@solana/web3.js/src/transaction.ts:583:13)
      at Provider.send (node_modules/@project-serum/anchor/src/provider.ts:116:22)
Does it mean there are not correct signers or the function which i am calling does not have correct signature?
yes. yes
Yep, think so
hi everyone! simple question. is the cost to deploy to mainnet the same as devnet? couldn't find a definitive answer regarding this.
gm sers! I'm in the process of googling stuff about Solana, but I thought maybe I drop a question here because somebody may have already done what I want to implement. 

So, in short, I want to be able to call Metaplex candy machine mint function from another program via CPI (obv, lol). The problem is that I don't know how to set up the context properly. Metaplex docs aren't the best.

Also, my future program is supposed to take NFTs from accounts that invoke it. So, you interact with my program, your old NFT gets taken away and you receive a new one from Metaplex. As far as I understood, you can do this kind of thing via System Program. Is that so?
But the CPI callee can't really be rewritten to support that, since the callee program definitely doesn't own the PDA account that *you* own
What do you mean by works here? If your program owns the account, then yeah, you can yank its lamports—you could then, like, transfer them to a system account that you then pass to the CPI (it's actually a bit tricky to get that to work, unfortunately, b/c of a sorta-bug in solana, but it's possible)
trying to do that rn before asking the CPI guys to rewrite their program
would it work with `try_borrow_mut_lamports` by any chance?
That system program account could live at a PDA though
Right, that won't work unfortunately (you're going to have to find a system program account that can be the payer)
in my case (how I do it right now), the owner is a PDA owner by the caller. 

but the program requires this same PDA to also pay to initialize an account.
 
this is a contradiction as I see it?
So what you're saying might make sense, but I'm not sure yet
PDAness doesn't really have anything to do with ownership (program ownership of an account = program is allowed to mutate an account's data/spend its money)
"to be a PDA (because my caller should own it)" not sure I understand that either 🤔
thanks a lot again! 🙂
i think i was confused because the CPI callee requires this owner to be both the authority, and the payer. i require the authority to be a PDA (because my caller should own it). and i need the payer to be a system-program (for reasons outlined above). 

so both to be separate as I understand (but theyre not right now, leading to this error).
And it'll have to have some money in it 😛
got it. i think this dissolves a lot of confusion! 🙂
It can't be an account owned by any other program
At any rate, that `owner` needs to be a system program account, based on the way the callee is written
Not sure what that means 🤔
The error message above indicates that you're accidentally specifying a payer as a non-system account (won't work)
so I defined this owner as the caller' owned PDA
Right, how are you passing it in though, when you do the CPI? Who is that account when you do the CPI?
yet another account, who is completely unrelated lol
``` 
#[account(mut)]
pub owner: Signer<'info>,
```
That owner account will have to be owned by the system program
Ok, so who is the owner account you're passing in?
Oh, can't read lol
~~I'm confused by that snippet, why isn't there a payer?~~
but on a different account
``` 
#[account(init,
        seeds = [b"exampleSeed",
        owner.to_account_info().key.as_ref()],
        bump = bump, 
        payer = owner,
    )]
    pub position: AccountLoader<'info, Position>,
```
yes
Is the callee program doing an `init` with a `payer` somewhere?
That token account is definitely not owned by the system program (and the callee program isn't expecting it to be)
The error above is about the callee program trying to get an account to pay for something
Ah, that's not the account from the error above
this is the callee's context:
``` 
#[account(mut,
        constraint = &account_x.mint == token_x.to_account_info().key,
        constraint = &account_x.owner == owner.key,
    )]
    pub account_x: Box<Account<'info, TokenAccount>>,
```
(which is the "from" account)
So, not owned by the system program then? Sounds like the callee is expecting a system account
it is currently owned by the CPI callee
Not sure, can you show the `derive(Accounts)` block? Is the source account somehow owned by your program?
hmm. so something is off while generating the PDA probably?
(Or rather, the program you're calling is expecting to be passed an account owned by the system program)
No, that error is about doing a transfer (looks like you're doing a transfer with the system program, but the source account isn't actually owned by the system program—that won't work)
also as a (maybe) very specific example.
I specify an account in the CPI caller as 
```
pub position: AccountInfo<'info>,
```
 (as mentioned above). 
The CPI callee specifies this account to be a 
``` 
#[account(init,
        seeds = [b"positionv1",
        owner.to_account_info().key.as_ref(),
        &position_list.load()?.head.to_le_bytes()],
        bump = bump, payer = owner,
    )]
    pub position: AccountLoader<'info, Position>,
``` 
I get the following error:
```
'Program 3vTbhuwJwR5BadSH9wt29rLf91S57x31ynQZJpG9cf7E invoke [1]',
    'Program log: Depositing reserve to pools!',
    'Program 77yFpTqxesQNz7Styk6yTRBaEcW9LxDKPvA46HfuA77z invoke [2]',
    'Program 11111111111111111111111111111111 invoke [3]',
    'Transfer: `from` must not carry data',
    'Program 11111111111111111111111111111111 failed: invalid program argument',
    'Program 77yFpTqxesQNz7Styk6yTRBaEcW9LxDKPvA46HfuA77z consumed 15912 of 167139 compute units',
    'Program 77yFpTqxesQNz7Styk6yTRBaEcW9LxDKPvA46HfuA77z failed: invalid program argument',
    'Program 3vTbhuwJwR5BadSH9wt29rLf91S57x31ynQZJpG9cf7E consumed 48773 of 200000 compute units',
    'Program 3vTbhuwJwR5BadSH9wt29rLf91S57x31ynQZJpG9cf7E failed: invalid program argument' 
``` 
`Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: invalid program argument`

Is this anything specific to the `AccountLoader`, which requires to be initialized when passed on?(https://docs.rs/anchor-lang/latest/anchor_lang/struct.AccountLoader.html). It says `Namely, one must call load, load_mut, or load_init, before reading or writing to the account`
Right—it's up to the program you CPI to to figure out its own fancy anchor types, you just pass raw accounts
also just to make sure, the input to the CPI calle (the context of the calle) can be all "AccountInfo"s? doesn't have to be any fancy "AccountLoader<'info, CustomDatastructure>" or even "Account<'info, Token>"?
I would expect their own typescript to stay pretty up to date
also, alan, idk how I can thank you answering all these questions (and having worked on NLP before hahhaa). i wanna send you a gift at some point. lmk any of your addresses and i'll be sure to whitelist / send sth to it 🙂
yeah, orca's typescript (because we took the IDL from their typescript hahaha)
But yeah, upgradeable contracts are always a risk unfortunately 😬
For 3. do you mean the orca typescript? Or yours?
1. Nah, probably not super painful (well, depends on how comfy you are doing this kind of thing—it'll just be translating TS to rust basically)
2. You just have to pass the right addresses from the client (into your rust program), and then forward them along—no need to interact with fancy anchor types in any way (at the CPI level those types no longer exist/are relevant—you only use AccountInfo)
got it. for some followup questions xD 
(1) I assume this will be quite painful. Especially if they dont use anchor right? 
(2) if they use anchor, i won't be able to deconstruct the datatypes they're passing on (i.e. whether it is an AccountInfo, an Account<'info, CustomDataTye> or AccountLoader)
(3) whenever the orca contract changes, and the typescript files are not updated, this will introduce "smart contract" risk, right?
Eg. https://github.com/orca-so/typescript-sdk/blob/main/src/model/orca/farm/orca-farm.ts#L60
Ah, ok—no, your solana program can't interact with that frontend SDK. What you could do though is source-dive and see how the orca sdk builds instructions, and do that from within your solana program as CPIs.
so the issue im facing right now is the following:
I want to interact with let's say orca. Orca only has their frontend SDK public though (they don't have their rust code public, e.g.). 
Some logic requires running through a backend that we're writing. I.e. we're writing a solana program rust. 

Given Orca's frontend SDK, is there a way that our solana program (written in rust), can interact with it?

Does the question make more sense now? Sorry if this is a bit abstract and at times confusing.
Can you say more? Don't think I'm following your question. What do you mean by a CPI with just frontend APIs? You can definitely interact with contracts purely from the front end  (that's how you interact with your own program, of course)
You're getting that error because all anchor instructions use the first 8 bytes of the `TransactionInstruction` data as a "sighash" (in this case, pseudo-code = `sha256("global:<ix-name>")[..8]`). So that's what you're missing.
0x64 = 100, which means `InstructionMissing` if you look in anchor's error.rs file:
```.rs
    #[msg("8 byte instruction identifier not provided")]
    InstructionMissing = 100
```
or is there a way to make CPI calls by just having frontend APIs?
im facing the issue where I have access to a bunch of frontend APIs, but no way to interact with these contracts through a program
incredibly naive question: is it possible to make RCP calls on bhealf of a program? I would assume no, or is there some way to achieve this?
i'm trying to understand what Anchor JS is doing undert-the-hood by re-implementing the "minimal example" using  `solana/web3.js`

This is tutorial 0, i.e. the minimal program. there's only one tiny line of code:  `await program.rpc.initialize`. i'm using vanilla `solana/web3.js` to do the same effective call inside `basic-0.js`

it's the simplest possible program, but when i run `anchor test --skip-local-validator`

i get: `custom program error: 0x64`

```
    // anchor tutorial example
    await program.rpc.initialize();

    // me: using vanilla Solana
    await new Connection("http://localhost:8899", 'singleGossip')
        .sendTransaction(
            new Transaction().add(
                new TransactionInstruction({
                  programId: "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS",
                  keys: []
                })
            ),
            [new Account(privateKey)]
        )
```
i'm sure i'm just missing something. does anyone have any insights?

(`[new Account(privateKey)]` is the signer and i made sure it has SOL in my localnet)
thanks for chatting with me on this
yea that was my intuition also
something like that, yes. I have not worked on a use case like this at all, so I might be off, but in general I think it's best for you to avoid trying to scale ws account subscriptions.
for like channel posts
And then just have a channel subscription
Ah yea that seems totally sane
so basically just poll my friends on the frontend
That way you can handle the refreshing of the huge amount of accounts by slowly, periodically querying all accounts of this type (= 1 request, you filter as you wish client-side), and at the same time setup the subscriptions for the hanful of accounts in scope
I do not know if there is a way to listen to changes on a set of accounts using websockets (I'm assuming that's what you are using), but I would advise that (if it makes sense for your use case) you would maybe allow a slower "refresh" time for the data of entities that can reach a huge number (for instance the status of all the Discord users of this channel), and focus the "real-time" feel on more specific interactions (for instance this chat we participate in right now, and the status of users in scope)?
Yea i'm trying to get around an n + X somehow; maybe this is all handled by some caching integration
Have you worked with Message at all? I don't see any examples anywhere and it seems relevant
So I think you are somewhat conflating mutating and fetching data.
Yea that doesnt make sense
I'm trying to figure out a way to constrain the number of subscriptions on the users frontend
I don't really understand why you'd have to make that many requests actually. I you have N users, then their status should be contained in each user's account, and then only mutated by the users themselves 1 by 1, isn't it?
the set_online function is defined in the users metadata program
or not?
yh but the user should invoke those commands, they should pay for it xD otherwise you will run out of money very fast haha
I'm imagining running a loop in a set_online program method and calling a cpi to set_online status in each friends friend list. Would be great to send 100 of those instructions at once instead of one by one
what do you refer to when you say batching here actually? xD
Any good resources for batching for beginners?
good idea
also perhaps you can check if metaplex has some realtime functionality. or games actually, a lot of NFT-using games probably use realtime stuff and encountered the same problem I would assume. perhaps worth pinging or asking around some devs around those communities
but doing anything over n accounts is usually not a good idea, you wanna do hashing / O(1) operations etc. as much as possible (even if you call this one once for every user)
yh its tricky, but i think in reality many solutions are often like this. you can still store the full state on-chain, you would just have an extra "bit" that people can ping to understand if they should fetch their own state. and for each user you have have it fetch a select set of PDAs for example (this way he doesnt fetch everything). thinking out loud here, not fully sure if i understand your issue well
anyways thanks for the help
idk if that works either though cuz then they're getting subscribed to like every single state update across the whole app. And I'm trying to avoid anything thats not on chain to help me learn also it feels like cheating.
oooh something like an on-chain redux hash map state is interesting
my gut feeling wold be to have some logic off-chain. perhaps you could have a global state that keeps track of if stuff was updated or not, and accordingly lets people fetch from it (global state / hash instead of n accounts). idk enough about your accounts and needs tho to answer this properly
Or the friend account subscribed to the user metadata account and then could update state locally
I don't think theres a way around it either. I was hoping a user could just set their online status in their metadata and then it broadcasted that to all the friend accounts that somehow referenced it.
not sure if this is possible. you want to modify n accounts, this will require at least n calls (or you batch them together somehow, but if you have n accounts, it will scale linearly in any case)
tldr; trying to figure out how avoid n + 1000 calls for a friends list feature thats similar to discords
Thanks for the info, I really appreciate all the help I get here.

tldr; trying to figure out how avoid n  + 1000 calls for a friends list feature thats similar to discords

For context, I currently have a naive implementation of a friends list account which just contains an array that holds Pubkeys. My frontend fetches that then fetches the associated metadata to display the personas username, online status, etc.

This is not ideal because I end up making a bunch of network requests 1:1 for metadata, and I end up with a subscription to each of those metadata accounts 1:1 to see when they change their online status. This isn't scaleable because people can have hundreds and thousands of friends.

My next feature is friend requests. This gets more messy with the naive implementation guaranteeing both parties agreed to be friends.

So now I'm refactoring to use a friend program instead of a friends-list program, where I am either the requester or the requested. This cuts down to only two subscriptions for changes. I was hoping I could just reference the accounts metadata somehow and get that updated in real-time. If i have to store that status in the friend account I would have to call setOnlineStatus like 100+ calls to each friend account if I can't just reference their account metadata somehow.
So think my answer would be no
There is no special treatment of account field
I am not sure I understand the question exactly. If you want to make a CPI involving the friend account, you would necessarily have to pass it as part of the input accounts to the program call. That would be completely distinct from the fact that you have a "reference" to this other account in the ForAFriend account.
do those changes propagate?
And the friend definition was `pub friend: Pubkey,`
Hmm, I see, so if the account struct was defined in this program it would be stored in the program but what would happen if it was a seperate account referenced with cpi?
I don't have 100% certainty as I have not specifically tried that, but I would say yes, that would trigger a change event. Afaik these custom-typed fields are just that, structs within the account struct. Maybe your question comes from the idea that this code would lead to 2 **separate** accounts with a relationship between the 2, like for DB entities relationships?
Will changes in a cpi linked account also be broadcasted to subscribers?
Consider this friend account:

```
#[account]
pub struct ForaFriend {
    pub authority: Pubkey,
    pub friend: ForaPersona,
    pub requested: bool,
    pub accepted: bool,
    pub bump: u8,
}
```

If the `ForaPersona` account updates some data, say a boolean, and I am listening for program account changes with  `onProgramAccountChange`  on my `ForaFriend` account. Will it broadcast that change? Or does the data have to be stored directly on the ForaFriend account?
Understood, thank you sir
Just do `from.to_account_info()`, no star.
An AccountInfo is what solana gives you when you pass an account pubkey (address) in from the client. The issue is you can't go from Pubkey --> AccountInfo dynamically, within your rust program; you instead have to have your client tell solana ahead of time "I care about this account"
If I don't use `to_account_info()`, I'm getting the type err
I think I almost got it except for one thing, I'm passing `Signer` struct as a tip sender and I try to use `.to_account_info()` on it, but I get this error
Gotcha, since I don't know the difference between `AccountInfo` and `Pubkey`, I can't get my head around the process. Google mode on
correct, you cant use just the `Pubkey`


//////////////////////////////////////////////////////////////////////////////////////////

yes https://docs.rs/anchor-client/0.19.0/anchor_client/
I didn’t know that, so UIs can use program.rpc in browser?
Is there an anchor client for rust?
No, regular `program.rpc` also gets confirmation (it has to since the provider wallet is the user's phantom wallet, or whatever, and it has to at least pay the tx fees, which requires a signature)
I found the answer it is with package mocha-logger
how to do transaction batching in anchor??
interestingly I found it's from the `spl-token-metadata` lib, didnt go through any CPI execution
Hello,
 Is there a way to log messages in typescript tests file, apparently console.log does not work.
If youre using the newest anchor version, this cannot be an anchor error (they start at 100). So youre probably calling a program via CPI which returns that error.
Pubkey
For a program that doesnt get initialized by the creator. Is there a way to hard code an authority?
Does anyone know for this kind of custom error
```custom program error: 0x1b```
where can I find relevant info? Many thanks!!
also, if you'd like, when my project launches i can send you an NFT 
finished the anchor program and learning React/Typescript, surprisingly almost done with the MVP and dapp despite me asking these basic questions
thanks! appreciate the help
No, I believe only option for fe is manual ix -> sendTx
if i use `program.rpc` function instead of creating an instruction manually with `program.instruction` function, will it also make the browser extension wallet pop up for user to click confirm?

(i was looking on example code online that looks like it created an instruction manually and used solana web3.js lib to sign txn manually)
Yes and I didn't answer your question directly lol! For anchor instruction generator fn you don't pass in signers, just any rpc args and accounts obj.
oh cool yeah im on the frontend, so when user hits approve in browser it will fill in that array automatically 👍
If you're using a browser extension with an npm package, then that package should compute a signature for you with a special sendTx function (i.e. when the user hits approve in browser). On the other hand, if you're working server side, including integration tests, then you need to pass in all signers to sendTx fn or anchor rpc fn.
When instantiating an anchor instruction, do I have to populate the `signers` array right away? Or does it automatically get populated when I sign the transaction with the wallet?

```
return program.instruction.myInstruction(
         {
           accounts: {
             user: provider.wallet.publicKey,
             systemProgram: SystemProgram.programId,
           },
           signers: [], // <-- do I have to put the Keypair for the "user" here now? or does signing the whole instruction do this automatically 
         });
```
don't remember anymore, but my hunch, knowing a bit more about anchor, is that you can only collect current events. You'd need to parse the chain and store past events manually I think
Without seeing the code, it sounds like the issue is that the CPI to token program is missing a signature for a valid MintTo call. If you wrote the program making the MintTo CPI, then you can potentially add the fix at that call is my guess with proper signer seeds using a pda as mint authority. If you can send through the signature from the parent or outermost CPI, then that should work as well--I'd love to test that. I'm not sure implications of mint authority being the mint itself, I haven't seen that before.
mint::authority = mint // < this is the field name during init
however, it's not a signer, and its authority is set to itself via
I'm getting signer's priviledge escalated on the Mint struct/account
the rebase instruction calls MintTo, which is another cpi
im having the multisig program approve and execute a rebase instruction on another program
is it possible to call a cpi through a cpi?
Did you ever get an answer to this? I'd be curios to know what any alternatives are.
```
```
And you can type nicely-formatted code blocks by doing three backticks "`" + your code + three more backticks
No, this is something else (the error message is trying to tell you what, but that error can show up for some surprisingly non-intuitive reasons)
Can you show your whole instruction function?
I own the account I am trying to decrement, but not the one I am trying to increment. Is that the issue?

Or is the issue that the escrow is at a PDA address?

Or is the issue something else?
When I run this:


        //Declaring in this way to make readability easier
        let dest_account_info = give_well_acct_info;
        let source_account_info = escrow_account_info;

        let dest_starting_lamports = dest_account_info.lamports();
        **dest_account_info.lamports.borrow_mut() = dest_starting_lamports
            .checked_add(donation_amount)
            .ok_or(ErrorCode::OverflowError)?;

        let source_starting_lamports = source_account_info.lamports();
        **source_account_info.lamports.borrow_mut() = source_starting_lamports
                .checked_sub(donation_amount)
                .ok_or(ErrorCode::OverflowError)?;


I get the following error:

   Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: sum of account balances before and after instruction do not match
You'll have to do something like this:
```.rs
fn transfer_from_account_we_own(
    src: &mut AccountInfo, // we better own this account though
    dst: &mut AccountInfo,
    amount: u64,
) -> ProgramResult {
    **src.try_borrow_mut_lamports()? = src
        .lamports()
        .checked_sub(amount)
        .ok_or(ProgramError::InvalidArgument)?;
    **dst.try_borrow_mut_lamports()? = dst
        .lamports()
        .checked_add(amount)
        .ok_or(ProgramError::InvalidArgument)?;
    Ok(())
}
```
This is a key mental model thing to understand about solana: if you want to mutate an account's data or spend its money (<-- what you want to do now), you have to go through the program that owns the account. You're trying to use the system program's `transfer` instruction to transfer some money from one of your own program's accounts. That doesn't work in solana—because the account is owned by your program, *only your program* can spend the account's money (the system program can't do it for you because it doesn't own the account).
Hi I get the error:
"
    Transfer: `from` must not carry data"

When trying to transfer funds. I tried to solve this by createing a new empty kind of account:

#[account]
pub struct Escrow {}

But it still contains data. And I get the same error about from must not carry data. 

How can I create an account that can hold lamports such that it can be from the address in a transfer instruction?
in my programs/chainlink-pro/cargo.toml file
```
[dependencies]
anchor-lang = "0.18.2"
anchor-spl = {version = "0.18.2"}
spl-token = {version = "3.2.0", features = ["no-entrypoint"]}
solana-program = "=1.8.0"
borsh = "0.9.1"
borsh-derive = "0.9.1"
chainlink = { git = "https://github.com/smartcontractkit/chainlink-solana", package = "chainlink-solana", features = ["no-entrypoint"] }
```
what's the matter?
help me
```
Failed to obtain package metadata: Error during execution of `cargo metadata`:     Updating git repository `https://github.com/smartcontractkit/chainlink-solana`
error: no matching package named `chainlink-solana` found
location searched: https://github.com/smartcontractkit/chainlink-solana
```
when i run anchor build, error occurs
and i did the same in anchor project
i successfully built solana-chainlink-demo project on github
hello, i am having trouble with solana chainlink
I am getting the following error: 
"Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: invalid program argument"

I have determined it is coming from the following line:
        invoke_signed(&my_tranfer_instruction_1, 
                &[declaration_account_info, give_well_acct_info.to_account_info()],
                &[&seeds], 
        )?;

Where seeds and the transfer instruction are defined as follows:
let (_pda, bump_seed) = Pubkey::find_program_address(&[b"givewell"], program_id);

        //send lamports from the declaration to give well
        let my_tranfer_instruction_1 = transfer(declaration_account_info.key, give_well_acct_info.key, matchable_donation);

        let seeds = [&b"givewell"[..], &[bump_seed]];
        //Now we want to pass this instruction to invoke_signed
        invoke_signed(&my_tranfer_instruction_1, 
                &[declaration_account_info, give_well_acct_info.to_account_info()],
                &[&seeds], 
        )?;

I am having trouble figuring out what is wrong
Thanks! I was missing a signer
Take a look at the target/idl file for your program, it will list each account that needs to sign
(They can't sign from the client—only their deriving program can sign for them, not possible to do it on the client)
No
Can a PDA be passed in as a signer?
E.g. if you're init-ing an account that lives at a keypair address, the address of the new account needs to sign too
You likely forgot to sign the tx with a necessary signer
What generally causes a 
    " Error: Signature verification failed"
error?
About signing transactions for the account, that's not a question of program ownership—your program can sign for one of its program-derived address regardless of which program owns the *account* that lives there.
So you have to find the address on the client and pass it in as an account
You would then call this in JS like
```.js
const [theAccount, bump] = await PublicKey.findProgramAddress([Buffer.from("something")], program.programId);

await program.rpc.someInstruction({
  accounts: {
    theAccount: theAccount,
    somePayer: program.provider.wallet.publicKey,
    systemProgram: anchor.web3.SystemProgram.programId
  }
});
```
So you're trying to create an account that lives at a PDA? The easiest way to do it is with anchor's `init` attribute:
```.rs
#[derive(Accounts)]
pub struct SomeInstruction<'info> {
  #[account(
      init,
      payer = some_payer,
      seeds = [b"something"],
      bump,
      space = 8 + however_much_space_you_need
  )]
  pub the_account: Account<'info, Whatever>,
  #[account(mut)]
  pub some_payer: Signer<'info>,
  pub system_program: Program<'info, System>
}
```
I'm sorry I feel really lost with how to actually write something here. I think I get the PDA by doing this:

let program_id: &Pubkey = &ID;
let (pda, _bump_seed) = Pubkey::find_program_address(&[b"somthing"], program_id);

But now lets say I have some account passed in by the client:

let declaration: &mut Account<MatchingDeclaration> = &mut ctx.accounts.matching;

Can I do something so that later this program can sign transactions for this account? I tried doing this with assign:

  let owner_transfer_transaction = assign(&decl_acct_pubkey, &pda);
//Now we want to pass this instruction to invoke
            invoke(&owner_transfer_transaction, 
                &[declaration.to_account_info()],
            )?;

But this gave me the error "
     Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: instruction illegally modified the program id of an account".

If not, do I need to create a fresh account in Rust? I thought you needed the client to pass in all accounts?
No, no return values from calling your contract. You can fake it though by passing in an account where you want to write the return value
can you return values from the rpc? is it bi-directional? also how does pyth network work on the rust package, if you cant get return results on the rust side (akin to first question)
Accounts that live at PDAs are created in the same way as any other account (their only peculiarity is in how you sign for the address)
What is the CPI call to make an account at a specific (PDA) address?
Currently thinking the best solution I'll have is changing my overall program structure to limit the max number of entries in this state mapping to a more reasonable amount, reducing rent costs probably by a factor of 10x, and then just pay the rent cost at that point. We shall see.
fair enough 🙂
I would think it is, but I never really worked on interacting with these so I might be off.
ah, if the only way to access the IPFS data during program execution is passing as a TX arg, then yes, I likely would run into tx size limit
So the idea would be to make a hybrid client retrieving that structure from a storage oriented blockchain (Filecoin/Arweave) and passing it as argument to the program call? Cause I think you'd again hit tx size limits
LOL, I will try to avoid this, thank you so much!
ok one last question for now WRT the large amount of state I need to keep track of described above (a map of pubkeys that could be as large as 30,000 entries). 

I'm not familiar with IPFS, but is it worth exploring trying to store this map off-chain on IPFS to reduce costs?
Effectively creating a DOS attack
Fun fact: this (needlessly marking an account as mut) is what lead to one of the Solana slowdowns a while back. Some bot marking their accounts as mut for no reason and spamming like crazy.
Oh I see thank you!
It is not a vulnerability to your program per se, but is not a good thing as it will prevent parallelization of transactions accessing that account.
Will it be any vulnerability if I make one account `mut`, but actually not change data or lamports during the tx?
You only need stuff to be mut if the tx will modify its data or lamport balance
And thank you <@721030147871866881> as well of course. This convo is a huge help even if I'm still unsure of feasibility
I'll mark it down for looking into
Incentivize how?
Last thing i'd look at is something like serum's queue model as well. You can incentivize off-chain actors to do the churn of writing to many users' accounts.
Yea very good points. That would be hyper complex. I hope I can find a clearer way
Sorry, another question, should signer be mut? Because I saw some  source code they set signer to `mut`, but none actual data change on these account. Just curious if there are any vulnerability if list a account `mut`, but actually not necessary.
Thanks <@915682383905316864> for the help. Unfortunate realization that my project will have a far, far higher rent cost than I anticipated. Really hope rent reductions are on the horizon as I fear it could kill the project at current costs
The rent issue was initial gut thing which made me suggest pda-virtual hashmap. So even with pdas as keys for map, you'd have to do something batch together tx that mutate max accounts per remaining accounts array (including robust validation/checks of those accounts once on-chain) and then cache which accounts have already been mutated (if one-time, could use bool flag which would be nice).  Pattern is a little rough and requires a lot more client-side work with generating pdas and formatting remaining accounts array. Also on-chain validation of remaining accounts is crucial. You could also batch together user structs in PDAs and assign user indexes/nonces instead of using their wallet as a seed but that too requires more off-chain management.
I see, thank you so much!
There isn't much difference, though Signer is slightly nicer because it encodes the signing-ness in the type
May I ask another question about signer? I saw we can announce a signer in two ways in Anchor one is using #[account(signer)], another way is using `Signer<'info>`  do you know any difference between these two?
Thank you!
So I would say yes, mark it as mut
Sometimes you can get away with leaving it out (because the payer happens to be the provider wallet, which is automatically mut), but yeah, the payer does need to be mut at the end of the day
Hello guys, should we always make an account #[account(mut)] if it is a payer in struct?
You could try it in rust directly, maybe: https://stackoverflow.com/questions/68255026/how-to-get-memory-occupied-by-an-object-in-rust-from-the-code-itself
I easily could have made a mistake here though
assuming each map entry is 64 bytes total (unsure), a max of 30,000 entries would potentially calc to $8,000 rent
welp no idea if this is accurate but
https://bbodi.github.io/notecalc3/notecalc#eJx90MtKxTAQBuD9PMWAro7gqc2xuPENBBc-wJDWKQZzIxewb--kByRCNYuQMF_-STJvhTNFTuTXQnpZQvWFYp0_ecNnVCPMP6JmmfoSdEWnI7EvqZXm_0Lv8DARfHV7gOHc0gcZAOczThc0GQ8awQ3mYLXXmGQvrum23Fk7QBvrJGHDfUsb1OUJ315ffjGOYfnoyPR4NTvgL3axkDPeuOpECXpQalLjbgBiMgtTWEkuQsbTe7BWp3b_cRjwVkSfc9VrSLRWa9tDBB41whP2v3HCP_oAfAP-DplQ
Would bytes-per-entry of the map above be 32+32? (NFT escrow account key + user pub key)
Haha. Not sure if the merkle tree might be usable on the data structure part, though. Haven't looked into that.
You're totally right. Back to drawing board.
Yea that was my thought as well
Wouldn't this hit the issues initially mentioned, of capping how much NFTs can be shuffled to the amount of accounts that can be passed as inputs to the call?


//////////////////////////////////////////////////////////////////////////////////////////

Thanks gary and alan 🙂
A transaction can consist of multiple instructions that are executed atomically. Use `program.rpc` to run a transaction (and you can specify prerequisite instructions that will execute before the RPC , that will run before the actual RPC call). Use `program.instruction` to include it as a prerequisite instruction to another RPC call in a transaction.
That said, with a Keypair.generate() you *also* need to remember the address itself, since it's random (whereas for PDAs you get to pick memorable seeds)
You only need to worry about custody of that private key if you subsequently need someone to sign for it
program.instruction just builds the instruction, it doesn't actually run anything
What do you mean by "for a wallet account"? I'm assuming by a wallet account, you mean using the `Pubkey` of the user's address (of which the private key is stored in their hardware wallet / browser / etc).

The main thing I'm trying to avoid is using accounts generated through `anchor.web3.Keypair.generate();`, since that would require custody of the generated private key. So I'm assuming the implementation of the above statement would _not_ involve this line and instead just use an already existing `Pubkey` such as the user's address. Am I misunderstanding your intent?
What's the difference between using `program.instruction` and `program.rpc`?
But e.g. for a wallet account, it wouldn't make sense to use them
Yeah, that could be a reason to use PDAs
`simulate` might be handy if you don't actually want to run the tx for real, just see if it errors etc.
What if you don't want your end user to have to custody the private key of the created account though (which would be needed for signatures)? In that case, should you use a PDA? (Let me know if I'm misunderstanding something)
<@!134416332509675520> Why use `program.provider.simulate` instead of just `program.rpc.myInstruction`?
That's how I learned
💯  thanks
1. Check out this tutorial: https://hackmd.io/@ironaddicteddog/solana-anchor-escrow
2. Then go through all this code because it's way better and solves some of the problems of hackmd's version: https://github.com/cqfd/quidproquo/tree/main/programs/quidproquo
https://github.com/cqfd/quidproquo/tree/main/programs/quidproquo
hey can anyone tell me where i can get more anchor programs for learning 
i have read four examples
Basically anchor's `Account` type already checks this stuff for you, so not sure why you need to test it yourself
Sometimes you just can't think of any good seeds to use. Sometimes you really want the user/some human etc. to be able to sign, rather than your program itself
Why are you trying to test for this? Are you worried about seeing incorrect discriminator bytes?
If you use a side program then the account will have the wrong owner, so don't think that will work either
Super helpful. Thanks alan
As a rule of them, when should you not use a PDA for an account and instead use a regular account?
and then pass the account in to the actual program I'm trying to exploit <@!134416332509675520> ?
okay so have a side program just to allocate with a desrim
I think you could do e.g.
```.rs
#[derive(Accounts)]
pub struct BogusDiscriminator<'info> {
  #[account(init, payer = some_payer, space = 8)]
  pub account: AccountInfo<'info>,

  #[account(mut)]
  pub payer: Signer<'info>,

  pub system_program: Program<'info, System>
}

pub fn bogus_discriminator(ctx: Context<BogusDiscriminator>) -> ProgramResult {
  // go write those bytes
  Ok(())
}
```
This is my first time writing a Solana program and I'm not sure if I used the best style. Ideally I'd like the program to be top-notch before going to production (from a security perspective as well). Does anyone have any auditors they recommend (free and paid)?
hmm
With your own custom instruction
If you treat it as an `AccountInfo` then you can write whatever you want in there
You could have the account be owned by your program though, and just never interact with it as an `Account<'info, Whatever>` (that will auto-write the right discriminator bytes)
hm okay
While it's still owned by the system program? Don't think so, no
I want to test my program with bad accounts. so when I first create an account it's owned by the systemprogram, is there an instruction i can invoke to modify the data to include some rand 8 bytes desrim?
No, all writes have to go through the owning program
Figured that's the example you were referencing in this case! Thank you!
is it possible to set the 8 byte discriminator of some randomly created account using the web3 pkg?
But a good example to look at is associated token accounts: they're owned by the spl token program (like all token accounts) but their address is derived from the associated token program (totally different program).
You would find the address using `A`'s program_id, and then use program A to CPI to the system program when you create the account. A can sign for the address using `invoke_signed`, and the `system_instruction::create_account` instruction lets you set the owner.
Why use `program.provider.simulate` instead of just `program.rpc.myInstruction`?
Do you literally just use `findProgramAddress`, input program A's address, and then set the owner to program B?

Also sorry if this question is obvious, but how can you set an accounts owner?
Thanks for the detailed response!

One additional question, how would you derive a PDA from program A but set its owner to program B?
So to summarize: 1) basically can't change an account's owner (once it's owned by a non-system program it's too late); 2) being able to sign for an address isn't relevant for writing to the account that lives there—that's purely up to the owning program (it may ask for a signature but it doesn't need to); 3) accounts that live at PDAs are *not* necessarily owned by the program that derived the address (and program ownership is the only thing that's relevant to being able to write to the account's data or spend its money); and 4) being able to sign for a keypair account doesn't let you write to the account (again only program ownership lets you do that).
Knowing the private key for a keypair account doesn't let you mutate the account (only the owning program can do that, and it doesn't need a signature to do so—it might ask for one for program-specific reasons, but it doesn't need one)
For example, you can have a token account (owned by the spl token program) that lives at an address derived from your program—that means your program can sign for the address, but it doesn't mean your program can write to the account!
PDAness of an address is independent of which program owns the *account* that lives there
And *only* the owning program can ever write to an account's data or spend its money
You can only change an account's owning program once, from the system program to some other program (so, effectively you can't change the owner once it's owned by your program)
+1 ^
How do you change an accounts owner? Is it possible to write to an account as long as you have the private key for that account, or would you also need to be the owner (so you would need to be owner + have a signature on the account)?

One thing I'm confused about, is why would you want to use non PDA accounts in your programs? PDAs have clearly defined rules that they are owned and can only be modified by the program that created it, while it seems that user generated accounts could be modified by the private key at any time.
Thanks alan 🙌
wowwww i would have never known that
Usually `await program.account.yourAccountType.fetch(theAddress)`
Btw do you guys know if a program already exists to do staking / unstaking custom tokens in solana .. basically would like to lock the tokens when someone is staking
(My program owns the account)
In my tests, how do I deserialize this account's data and actually read it?
Got it
Mm, unfortunately no, you'll have to manually replace the declare_id! part *and then re-run anchor build before deploying*
It will replace that when I do anchor build ?
Aaah 😌 got it
Anchor just happens to hard-code an id when you generate a project, but it will generate a real one when you first run `anchor build`
No, the program id you'll deploy at is generated (amongst other ways) by `anchor build`
In anchor examples they have that declare_id! before we even deploy the program, trying to figure out how to get that
<@304790899785728000> thanks for the explanation but isn’t program-id generated after you deploy the program ?
Yeah that makes sense thanks, I'll dig around and see if I can find another example, maybe Jet
I don't think that example actually uses pyth itself, it's just an example of writing your own oracle
Im just starting to look at pyth, is the example on anchor github for consuming or publishing data, I can't tell what's going on hehe
that's straightforward 😛
gotcha XD
`mint::freeze_authority` 😛
```
#[account(
        init,
        payer = payer,
        seeds = [...],
        bump = bump,
        mint::decimals = 9,
        mint::authority = mint, 
    )]
    pub mint: Account<'info, Mint>,
```
How can I set the `freeze_authority` as well here?
What have you tried so far?
If you regenerate a new keypair then yeah, subsequent deploys will use it automatically (remember to update your declare_id! though!)
Thanks <@!134416332509675520>, is there a way for me to force Anchor to deploy it into a new programId?
No, the keypair file is a full keypair (public *and* private keys)
I'm trying to write a contract that does the following: 
* take some amount of SOL from an user account
* return either nothing or the double amount
Quite simple 😉 can anyone point in the right direction?
Can I infer the keypair file from the programId then?
I was trying to work on a different computer, I assumed the target folder would be deterministic and would rebuild anyways 😅
Why are you deleting the target folder?
`target/deploy/your_program-keypair.json` is the address at which you'll deploy your program, so don't delete that if you want to keep using that same address
After deleting the target folder and rebuilding it with anchor build, I think I gave lost the ability to upgrade the contract. I was able to call 'anchor deploy' repeatedly on devnet, to successfully upgrade the program. My filesystem wallet keypair did not change. Every time I rebuild the target folder, I get a different keypair file in the target/deploy folder. 

Is there a way for me to continue to be able to upgrade the program? Do I need to record this generated keypair as a secret for all my projects along with my wallet keypair?
yeah, the problem is in ensuring deterministic builds I guess - which this takes care of by using a docker image with pinned deps
wah ok there is the methodology
https://project-serum.github.io/anchor/getting-started/verification.html#verifying
yeah i believe this would work
<@!499334426828865547> Did you find the answer? I would think dumping the program from mainnet to a local binary, and computing the sha for comparison, somehow, but I'm not certain.
Q: do all the relevant accounts need to be passed into a solana program, or is there a way to do lookups inside of the code? in my case, I have hardcoded account ids and it would be nice to lookup that account info in the actual rust program instead of having a client look it up + pass it in as an instruction. is this an anti-pattern / not allowed? it would be nice to not have to trust the client to lookup/pass data in properly and to just do it all on the "backend" in the rust code for the actions that are read only
the declare_id! macros defines the public key of the program, aka the program id. a program is just a solana account that is executable, and like all accounts it has a public key (which is synonym for program id). when you call instructions on a program, that program_id is passed as context. when an account is created with an owner of that program id, only that program can write data to that account (anyone can read/credit it though) and that is enforced by the solana runtime. might be missing something so hopefully someone else can fill in any gaps; in fact, I am wondering myself if there is any use for the private key that accompanies the public key/program id for a program?
Is there any way to ensure that instructions can never be called alone- that is, ensure that multiple instructions bundled into a single transaction are never run independently of each other?

Or do I have to always assume that I need to design instruction calls such that the program can't be exploited and can recover from a mangled state where it runs one instruction but not another (in the case that, somehow, a user decides to call my program from their own client with their own manually bundled instructions into different transactions)

Is the best way to do it to just write multiple programs and then call CPIs to the other programs from within a larger, overarching, program? I assume this isn't the elegant way to do it
Is that just a pub key 🔑 for a main account ? I can’t seem to find a good explanation on that
Hi guys .. I am new to rust but I am still very confused about declare_id! Macro .. what id are we hardcoding there ?
Is there no way to *get* an existing mint of type `spl.Token`? We can *create* a mint of type `spl.Token` by using `createMint`
GM! Does anyone know of a repository or some example code that does a cpi call to a program deployed on devnet or mainnet? Something beyond the anchor tutorial :)
is there any reason not to have error come with a readable error as well?
i thought i was doing something wrong with anchor but `Err(JupiterError::SlippageToleranceExceeded.into())` not printing a human readable error is just normal
Is there no way to `getMint`? I know we can do `createMint`
given a tx address on localhost, how can i find out information about the transaction? (compute units used, cost, etc?)
Ooo interesting, good tip. Thanks alan 👍
One pro tip (since this came up on twitter): it's usually helpful to just jump right to the source, since the instruction handlers are usually not too bad to read: https://github.com/solana-labs/solana-program-library/blob/master/token/program/src/processor.rs#L488
My b. But I wish the error logs were more descriptive
I never actually created a token account for `depositorTokenAccount` .
Where is the bang head on table emoji?
My guess is that you're trying to send it to a token account whose mint is different (you make the mint right above the `mintTo` call, so how do you already have a `depositorTokenAccount` lying around with mint = `stablecointMint`?)


Can you show the whole program log?
mintTo
Which one fails?
<@!134416332509675520>  any idea?
I've tried changing all the data but nothing works
```
// Mint
stablecoinMint = await spl.Token.createMint(
  program.provider.connection,
  mintCreator,
  mintCreator.publicKey,
  mintCreator.publicKey,
  9,  // decimal places
  spl.TOKEN_PROGRAM_ID
);

// Mint To
await stablecoinMint.mintTo(
  depositorTokenAccount.publicKey, 
  mintCreator, 
  [], 
  1000,
);
```
This doesn't work. I get the error: `Transaction simulation failed: Error processing Instruction 0: invalid account data for instruction`
aah, I see. Good
ProgramAccount is actually deprecated now, you can just use Account!
<@!134416332509675520> , What's the difference between ProgramAccount and Account?
```
pub staker: Account<'info, Staker>
pub staker: ProgramAccount<'info, Staker>
``` 
staker is a PDA. I think they are same.
damn. not sure how I'm going to log all this data then
I don't think you'll be able to write anything directly during program execution (your rust/solana code, that is), since the only "writable media" your program itself has access to is account storage
So now that I understand how expensive storing data on-chain is, I'm trying to find alternative ways to preserve some data that I want to be able to fetch from my frontend, but don't actually need available for anything on-chain in the future (though having that as a possibility is a good thing).

I want to be able to write the data directly during program execution and have the user executing the transaction pay the cost. 

Is this the type of thing that Arweave is built for?

Every "run" of my program would generate data that could be roughly 20-120 kB. arweavefees.com says that would cost ~$.002 which seems incredibly good. Just unsure if I can apply it here.
Yep, that's the state of the art I think (just have to live with a little editor confusion about anchor sometimes)
You can do `Rent::default().minimum_balance(size_of_thing)`
Also any general advice on VScode extensions to add to rust? I have:
Rust v0.7.8 by "The Rust Programming Language" 
and
rust-analyzer v0.2.842 by "matklad"

Though the rust-analyzer seems confused by anchor and solana imports. Anyway, suggestions for nice extensions you have found would be awesome!
How can you in rust get the amount of lamports required to make something of size X rent-free?
also sounds like a bug
sounds right
Assuming I'm guessing the right issue (justin starry told me about it): https://discord.com/channels/889577356681945098/889584618372734977/915190505002921994
I'm still confused tbh
Yep! Bet the reason why switching the order fixes things is one of the "surprisingly non-intuitive reasons" I mentioned, solana can be weird
LOL LOL LOL with <@!501570363566587905> 's help the problem was that I was doing two transfers. One from an account my program owned by directly altering lamports, the other from an account my program didn't own (the "author" of the transaction).  

At the start I did the direct lamport edits first then the invoke transaction. This would error.

When you switch them (first you invoke a transfer then you directly alter lamports) it works.
Thanks Alan
7 SOL/mb sounds so crazy expensive lol, I know on-chain storage is always said to be expensive but damn
but at current prices this would cost me ~$1,600 which is a hell of a lot better than the $8,000 my last design would have cost. Chances are I'm missing some complexity I'll find out later but, hey, improvements are improvements
🤞 since I assume if it changes it will bring cost down
Nope (though it might)
Again I have heard rumblings it may be more efficient in the future but nothing concrete
That is a useful benchmark. That rent exemption cost hasn't changed like ever, right?
Sounds plausible (easy number to remember is rent exemption is about 7 sol / mb)
(back from my convos yesterday) Iterated on my design a bit, I'm attempting to estimate rent for a single large array, size of 5000, where each entry is essentially 5 pubkeys, some bools, and a u64.
I believe I've calculated it correctly here, estimating it to cost approx 7.97 SOL. 

Would appreciate anyone taking a look to tell me if anything seems off. Thanks!

https://bbodi.github.io/notecalc3/notecalc#eJx1kF1OwzAQhN99ipHgoZSK_NBQFYkTgASCA1hOsiGWHDvyj0o4PZsEpD6Ut7U8883sZhneyUY0yjTJqKidRec8lIXyXk1wHYL-JlR5nu9w6skTSDU92OUn9M60AbEndhnjTtp-olVRPYosQ4W3VD_TFHY81s4ZHpwlpIe9qKdIQY7k5ZIjV9wTyvIItm7uS2xR3eAWm-JvYptNwyLVFFg8lxK_qC4ZI-doGaJPTeRvXA7Z4owixBWCM8oq-PkQRbFfqPND0hcNY5SDtnpIAxMPd8cDPl5fhBCj1w1J10l2S21ly_srP7cq8xzXrDhHrGq-7NpzUCMLL2Vwu3_I4gfx0Y6s
gotcha, that makes sense. Thanks alan 🙂
u64
what size of unsigned int would be used for balances for something like USDT/USDC/UST?
Ok, cool (fwiw, knowing it within the program itself would either require you to just hardcode it, or look it up via the bpf upgradeable loader account)
I was trying to know the public key of the authority from within the program itself. No worries, I found another solution that avoids needing to know the authority all together 👌
hey everyone! I am trying to figure out how to use types from other libraries inside of my anchor program: example I want to use solana token lending program types (ex. `Reserve`) in my code. are there examples somewhere of how to do this?

I am a little stuck and am new to anchor/rust so would appreciate any resources/examples.
I think the upgrade authority by default is just your solana keypair (you can set it in Anchor.toml): https://docs.solana.com/cli/deploy-a-program#set-a-programs-upgrade-authority
i kinda just see that as the "owner" of the program
yeah ^ authority to deploy the program
Authority to deploy the program?
Sorry—what do you mean by "authority" though? Like, which address are you talking about?
By owner, I meant the authority of the program

I was trying to gate an instruction so it can only be called by the authority of the program. In the instruction, I would do something like: `if program.authority != payer.id { throw Error }`

But this kinda seems like an anti-pattern, because smart contracts should be fully usable by anyone in the world it seems
I think I asked this earlier, but what do you mean by owner? If *you* don't know the owner id then you're kind of in trouble (presumably *you* are the owner, or at least some keypair you control is, assuming you're able to deploy the program)
You could hardcode the address into the program, or if you really want, you can dynamically load who the current upgrade authority is (if there is one): https://github.com/solana-labs/solana/blob/master/sdk/program/src/bpf_loader_upgradeable.rs#L45
how do you know the owner ID tho?
with an account signed by an owner
You can store the owner's id inside a PDA account, pass this account inside your instruction and verify that pubkeys match?
Question: How do I make an instruction only callable by the program owner?
If you're not reading/writing them, you can store their keys in a program-owned account. Then, just pass in the program-owned account's public key into your instruction
Maybe this requires a redesign of your program architecture
Why pass all 12-13 accounts in? Are you read/writing them all?
oof yeah
It is just that with Anchor I started to hit limits with approximately 12-13 accounts (even though I `box`ed everything inside contexts)
Thank you! :3
<@!788122420765917184>  ^ that is what someone said in the Solana discord space
""it can vary based on what is passed in, but i recall around 30/ish atm has been able to fit, and the transaction size 1232 bytes, around 15+ I would start looking to see what your numbers and size are. this may be increasing in the not to distant future""
i gotchu 1 sec
Good day! In general, how many accounts can I pass into a single instruction?


//////////////////////////////////////////////////////////////////////////////////////////

i dont know typescript/javascript much, had a hard time finding it
ahhh there it is! thank you! it was really bugging me lol
This part maybe? https://github.com/project-serum/anchor/blob/master/ts/src/program/namespace/state.ts#L245
I'm trying to understand the what the generated code is doing in ctor(). The call to private::Ctor::try_accounts(prog_id, &mut remaining_accounts,....). I cant find where the in the client code the accountinfo argument is formed. Specifically the from, base, to, system_program, and program accountinfos.
But that intentional error is happening here: https://github.com/cqfd/quidproquo/blob/main/tests/quidproquo.ts#L182
Don't think there's an easy way to prevent that error from logging, at least as far as I know
Hi everyone . I'm so glad to be here. I have a question, I'm writing NFT staking pool. But I need more resources to write. can someone help me?
I think the code looks working well, where does the error come out?
expected error? is there any way to remove that errors?
Can it be that it's refetched too fast? How about a quick test adding a small `sleep` between the call and the refetch
do you actually refetch accounts after the RPC call?
Having trouble incrementing the state of "votes" . What could be the issue
I figured it was probably user error 😂
The accounts themselves will stay the same—whether that breaks your new *program* though depends on how you updated your code 😉
What is verified?
Does upgrading rust programs break/corrupt existing accounts
https://anchor.projectserum.com/build/92

I saw this on twitter but i dont know what im looking at XD
Thanks. That's clear now
Yep, that's a common pattern
So wouldn't be better to find that on the client side? I mean, you could always pass the bump as parameter
I see. I am checking that only. Thanks
Each choice of bump has ~1/2 chance of getting you off-curve (this is why it's slightly risky to use find_program_address within your contract, because it could take several iterations to find a suitably bumpy bump)
Yep, I think it's helpful to just read the source for find_program_address, it's actually super simple: just keep sha256 hashing seeds + bump + program_id (plus a fixed string, not important), starting with bump = 255. If you get something off-curve, great; otherwise, uh, try bump = 254, etc.
So normal accounts on solana uses ed25519 ECDSA algorithm and PDAs somehow are not on that elliptical curve I guess.
Yeah, think so
Okay so say programA has PDA address and there is another program called programB and it having chances of colliding with PDA address of programA are (1/2^255)
Because only ~half of the addresses are valid public keys—the other half is fair game for PDAs 🙂
Yeah but I don't get how could PDA be off that set if they still are stored as 32 bytes
I think the number is 2^255
Addresses are 32 bytes = 256 bits in solana, and about half of them are valid public keys—that's about 2^255, which is an impossibly large number
Off-topic but related to above: Is there any links you recommend or keywords to do some research on this topic? I am so curious to know the numbers of available PDA/publicKeys eccetera
Any other PDA (they're just sha256 hashes under the hood)
Other PDAs in the sense with other PDAs of the same program if ever collided?
You'd have to have pre-allocated some extra space, and then all new fields would have to go at the end
They could potentially collide with other PDAs (they're just a sha256 hash under the hood) but that's incredibly unlikely
They actually can't possibly collide with normal keypair accounts (they're deliberately constructed so that they're not actual public keys, in the cryptographic sense)
And is there any possibility of them colliding with normal accounts?
1. Paulx - this one is a good start
2. Hackmd - check this out next, with s grain of salt.
3. Quidproquo - check out this one last. Go really in-depth on it, line-by-line. The other two escrows arent as good, but they explain a lot of concepts from this one
okay
many, i'm sure there's an exact number tho
https://discord.com/channels/889577356681945098/889577399308656662/921103289750274068 maybe try searching?
How many PDA I can create with a program?
Adding a new field would increase the space requirements of the account, so wondering how that works with already existing accounts without the new field
what's the best way to handle backwards compatibility when adding a new field to some PDA account struct? Is it usually done by just creating new struct suffixed with Vn?
Creating a system where a program acts like a proxy for the user wallets, both for the solana and for any other mint. This is what I mean by virtual wallet. A second level wallet fully controlled by a program
Not sure what you mean by virtual wallet though
Mm, think so, if I'm understanding you correctly. You also don't *need* to use the associated token account machinery at all if you don't want to (it's just a special address to store a token account—you can use your own if you want).
<@!134416332509675520> So I could create a PDA for the user acting as the Solana virtual wallet, and then create associated token accounts using that pda as input for the associated token program?
So it's still a token account (owned by the spl token program), but the address is derived from the associated token program (different program entirely).
An associated token account does live at a program-derived address, just not one derived from *your* program: it's derived from the associated token program.
That's just logging an *expected* error.
But it showed error
I am running `anchor test` in https://github.com/cqfd/quidproquo
Hi community.
Got It thanks
it is, but it also Token prefix I believe
An associated token account is not generated by a seed like a pda correct?
hmm im not sure if i understand your question
Okay so I will need to also store the user publickey in that to verify if the program should sign on that wallet behalf? Cause with PDA I could just play with the seed without needing to store the user key
otherwise it might complain that its not a token account that you are interacting with
you need to create an (associated) token account for that as far as I know
Is a PDA able to just own Solana tokens or could a SPLToken Mint be set ?
hey guys, is there a quick and easy way to check if an account is a valid mint or not?
check your program id's and when in doubt slap a ```#[account(mut)]``` on everything
for this account in particular

im running into 0xbbf, program owner errors
glad I'm not the only one who feels that way haha
It’s anchor
We’re all struggling here
Nah
Yep never mind I just realized I completely misunderstood this and it was a simple js typo.

Guess I just needed to type it out to figure it out.
Sorry for wasting your time lmao
What’s ur js code looking like

gives me this error

Sorry I'm not wording this very well
I just meant I init'd a pda account for this struct like in the photo above
what do you mean by making the application state an account

So I'm trying to do something pretty basic (store some spl tokens in an anchor program).

If I generate an account for my programs state I can do this no problem bc I can create a pda spl-token account to store and send tokens to.

The problem arises when I don't want to generate a new account. aka I want everyone to be able to see the same application state.

Obviously my first thought was okay make the application state a pda so I can derive it back for everyone, but then I can't create a pda of a pda lmao. Aka now I can't create the pda spl-token account.

What's the actual correct way to approach this?

Broken code snippit for reference:
you can manually check addresses via
address = Pubkey::from_str(pool_owner.key).unwrap()

or the contraint macro
the pool can be a PDA derived from the creator/owner key against the program ID
theres a bunch of ways you can approach this
I am trying smart contract using quadratic funding but the thing is that I am not sure how to differentiate between pool owner and project registrars under the pool.  Can anyone help me with this.

```
#[program]
pub mod solqaud {
    use super::*;
    pub fn start_match_pool(ctx: Context<StartMatchPool>) -> ProgramResult {
        let match_pool = &mut ctx.accounts.match_pool;
        match_pool.pool_id = 0;
        Ok(())
    }

    pub fn create_match_pool(ctx: Context<CreateMatchPool>, p_name: String) -> ProgramResult {
        let match_pool = &mut ctx.accounts.match_pool;
        let creator = &mut ctx.accounts.creator;

        let p_id = 1;

        let my_project = MyProject {
            project_id: p_id,
            project_owner: *creator.to_account_info().key,
            project_name: p_name.to_string(),
        };

        match_pool.projects_in_pool.push(my_project);

        Ok(())
    }
}

#[derive(Accounts)]
pub struct StartMatchPool<'info> {
    #[account(mut)]
    pub match_pool: Account<'info, MatchPool>,
    pub creator: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct CreateMatchPool<'info> {
    #[account(mut)]
    pub match_pool: Account<'info, MatchPool>,
    pub creator: Signer<'info>,
    // pub system_program: Program<'info, System>,
}

#[derive(Debug, Clone, AnchorSerialize, AnchorDeserialize)]
pub struct MyProject {
    project_id: u16,
    project_owner: Pubkey,
    project_name: String,
}

#[account]
pub struct MatchPool {
    pool_id: u8,
    pool_owner: Pubkey,
    pool_amount: u64,
    projects_in_pool: Vec<MyProject>,
}
```
https://github.com/cqfd/quidproquo
Guys are there any examples of anchor programs that does escrow or staking tokens ?
try_accounts is a generated function, the main entry point that does account constraint checks for an Accounts derived struct. In the end it will return an Accounts that has passed validation, or an Error.
I'm trying to understand the what the generated code is doing in __ctor(). The call to __private::Ctor::try_accounts(prog_id, &mut remaining_accounts,....). I cant find where the in the client code the accountinfo argument is formed. Specifically the from, base, to, system_program, and program accountinfos.
Can someone please explain what `try_accounts` is doing here? https://github.com/jet-lab/jet-v1/blob/master/programs/jet/src/instructions/withdraw.rs#L77
I am actually confused on what the wrap SOL address I should be transferring to and the mintAuthhority of that wsol address. Are you awarer?
thanks much
heck, ok. Totally fine, I was just trying to be efficient with data stored on-chain by trying to forego it
You'd have to do that on the client
Alas, nope—you can't dynamically look up an AccountInfo just based off a pubkey like that (you always have to pass in any accounts you care about)
Is that feasible?
I'm storing some data in a vec, and the entries each include an escrow token account's Pubkey.  I'm looking to find the vec entry where this logged Pubkey matches a mint (`Account<'info, Mint>`) I'm passing in, something like: ```state_vec.position(|&x| tokenAccountFromPubKey(x.token_escrow_account).mint == ctx.accounts.token_mint);```
Or, sorry, if you have an Account<'info, TokenAccount>, then yeah, you can get its mint's pubkey, but not the mint account itself
Not directly within your solana program (you'd have to look up the right mint and pass it in from the client)
pda's dont need to sign
ok issue was that im blind
In rust, if I have the `Pubkey` of an escrow token account, I can get the token's mint from just that data right?
i did but i think i found out a discrepancy
yeahh me neither
"<string> - Transaction, as an encoded string. The transaction must have a valid blockhash, but is not required to be signed."
Have you posted the snippets anywhere?
Huh, interesting, had never noticed that: https://docs.solana.com/developing/clients/jsonrpc-api#simulatetransaction
1 sec igu
<@!171442868190314497> I'm a noob but noticed in your quick screenies you aren't using `Signer` for the `Accounts` which require signing. May be related
oops just realized rent is different than system_program
how come?
however, only 1 of them requires the new account to be a signer while the other does
I am in a situation where I have 2 very similar, nearly identical code snippets. which init new accounts
Ok <@!134416332509675520>  i think `simulate` doesn't check the signers
An Anchor conceptual question, it's ok to say that the struct below #[derivates(Accounts)] is an Accounts Deserializer or there is a better concept? Pd: is for an anchor section in the solanacookbook
And i'm overriding signers to be `[]`
I'm just toggling my `simulate` variable
here's the code im using

the signer is supposed to be paying for the new accounts to be created tho

Can you post the program logs from the simulation?
yeah but it fails when I use `send`
https://tenor.com/view/joey-sandwich-gif-20961585
The simulation actually works? That's definitely surprising to me
Idk why though. `simulate` should fail because i didnt pass any signers
When I run `program.provider.send` , I need to pass `vaultCreator` as the signer.
But when I run `program.provider.simulate`, it works without any signers?
makes sense thank you very much.
that is why all AMMs use wrapped SOL
but most programs want wrapped SOL so that they only handle tokens
you can directly transfer it
>?
Thank you. As theory clarification, bc SOL is not SPL token we need to wrap SOL in order to transfer it between different accounts, right>
last i checked the types were broken though so i had to do something like:
` (Token as any).createSyncNativeInstruction(TOKEN_PROGRAM_ID, toAccount)`
just like the CLI but in JS
sol transfer to the wSOL ATA (making sure it exists) + sync native
Question how to you wrap sol in the native_mint. Trying to write an instruction so that the sol deposited is wrapped in the native mint so I can send sol from one account to another? 

Wrapping 1 SOL into GJTxcnA5Sydy8YRhqvHxbQ5QNsPyRKvzguodQEaShJje This is how you do CLI..your able to wrap sol into some account. 

How do you do this via JS
ty tho
emphasis on baked
lol
Im a lil baked, so i was looking through the projects node modules, instead of ./app
im sure someone has ran into that before
google a tutorial for those errors
yep
TY 🙏
found*
I find it!
if your using create react app ur kinda out of luck
it would be in ur root folder
Gotcha. I'm having a hard time finding my webpack.config. I don't see it under node_modules
i'm just not sure how to structure things yet. lmao
u just need to follow the instructions
```

const webpack = require("webpack");
....
....
....
plugins: [
    new webpack.ProvidePlugin({
      Buffer: ["buffer", "Buffer"],
    }),
    new webpack.ProvidePlugin({
      process: "process/browser",
    }),
  ]
```
like the comment says
You need to polyfill those in webpack.config
create react app?
I think I'm sufficiently confused haha that you'd have to post a github repo of what you've tried so far lol

Like i'd just have to hard code an authority if I didnt want to have to pass in a program account
Hey sorry to bother again. I get this compile error, i think issue with webpack?
storing data like nickname, description, etc
like user storage
xD
the user account
So then what account are those seeds for?
Something like counter
What is that program_account?
`#[account(init, seeds = [program_account.key().as_ref(), user.key().as_ref()], bump]`
Just ran yarn install and it compiled this time!
But that's not an admin right?
Sure, that could work
And user is signer
Do you mean wrapped sol? Sol itself isn't a token
` #[account(init, seeds = [b" user.key().as_ref()], bump]`
I'm probably just not explaining things right
xD
Sorry, think I'm just totally misunderstanding
Or are you saying something different?
Clients *can't* sign for PDAs (only your program can)
No
Hi all, what is the mint_key and pub_key for sol on Devnet?
As in what is the devnet SOL address :))
they do if u verify they are the signer
PDA seeds don't have anything to do with security unfortunately
a pubkey u have key pair to
or maybe not a signer
🤔 what would that accomplish? Not sure what you mean
Yeah so you have to derive every PDA from a signer pubkey
Do you maybe need to `yarn` install something?
But they *can't* sign for arbitrary addresses
Yes, definitely true that clients can pass in arbitrary stuff
Like in candy machine v2 from metaplex. u can pass in any candy machine
I think you're over-focusing on that specific example 🤔
using ur functions
Or candy machine
like they init their own Counter
But they could pass in a authority account
https://tenor.com/view/dying-monkey-dying-gif-13123180
xD
If you set the admin yourself then of course the user themselves won't get to set it

Hi guys, very noob here so any help would be super appreciative. I'm working through this tutorial https://www.brianfriel.xyz/learning-how-to-build-on-solana/

however, my problem is when I'm trying to deploy my front end. Running npm start yields the following error
I think you should fiddle around with implementing this
No, you don't!
😛
but u have to trust the user to give the right account
I kept on receiving the error "Error: failed to send transaction: invalid transaction: Transaction failed to sanitize accounts offsets correctly" 

Solution: type in your Program ID into Anchor.toml (<directory> = "[Program ID]" and source/lib.rs (declare_id!)

I'd love to hear is anyone has a better way to find Program ID - I currently had to run anchor test once before it showing up
Accounts aren't stateless of course
You could store a blessed admin in an account
its all stateless
I dont understand how dynamic would work
And then verify that either I signed or that admin signed
You would just hardcode (or if you really want, dynamically set) their address into your program
signer
pubkey
a wallet
What is their address?
yea
Who is this authority though? Like an admin user?
An authority or you
Who do you want to be able to modify, say, my account?
but isn't that the case with any program
Who counts as a valid authority in your program?
You would have to just have fancier logic
The create function
In that example, yes
What do you mean by init a program?
I honestly don't understand what you're describing lol
with their own counter account
Like anyone can init a program
At the end of the day only your own program can write to its accounts, so you would just have to have some way to decide who counts as a valid authority (I think I'm not understanding what you're trying to do though 🤔)
basically you can only instance a program
like the user could set any authority
You would have to define that yourself 😛
yeah but what defines an authority if the user makes the account
https://project-serum.github.io/anchor/tutorials/tutorial-2.html#defining-a-program
Your program would need to verify that that authority signed the transaction that attempts to modify the user account
Like if I want an authority who can edit a user's account
Mm, don't think I understand what you're asking about 🤔
So I would do like (program_account.pubkey + user.pubkey) in the pda generation
So like I want to blacklist an PDA from being updated by a user.
and every PDA uses that account in PDA pubkey gen?
So do most programs have like a "metadata account"
Pretty much only by requiring a known address sign the transaction
In a smart contract how is there any way to set an authority for calling functions?
https://tenor.com/view/big-bite-nom-yum-tasty-delicious-gif-14275177
I'll provide unlimited support for early access to the jito sandwich press
gotcha
Those are just to help make the number more readable (apparently not always successfully lol): https://doc.rust-lang.org/rust-by-example/primitives/literals.html
<@!134416332509675520>
There actually isn't any anchor wrapper yet for the system program (actually not sure why though), so currently you need to do the `invoke`/`invoke_signed` stuff yourself I think
awesome!
But if you hop to source on TokenAccount you'll see it has its own impl of Owner
It's just that when you use `#[account]` to declare one of your own accounts, it automagically impls that trait and returns your current program's ID
ah okay
Nope! `Account<'info, TokenAccount>` checks that the account is owned by the spl token program (the struct you parameterize `Account` over has to impl anchor's `Owner` trait)
thx for the help on this. I think it makes sense. So ownership is checked at the account deserialization step. I assume the `TokenAccount` just skips program ownership check
Thank you
https://media3.giphy.com/media/3owypkSIpM8xw6p7W0/giphy.gif?cid=ecf05e47vsr89fvh4if4ip2bg4rg57x9v6mfuh3ii7rs4l28&rid=giphy.gif&ct=g
In other words, ctx.accounts.to gets passed zero times (bad)
You're passing `ctx.accounts.from` twice
This is a great resource I look back on frequently
https://github.com/cqfd/quidproquo/tree/main/programs/quidproquo
Thanks, I'll give that a shot
And way less bugs
Way simpler to use anchor
yeah u probably wanna do something like this instead:
```
// Transfer the maker's tokens to the escrow account.
        anchor_spl::token::transfer(
            CpiContext::new(
                ctx.accounts.token_program.to_account_info(),
                anchor_spl::token::Transfer {
                    from: ctx.accounts.offer_makers_maker_tokens.to_account_info(),
                    to: ctx.accounts.escrowed_maker_tokens.to_account_info(),
                    // The offer_maker had to sign from the client
                    authority: ctx.accounts.offer_maker.to_account_info(),
                },
            ),
            offer_maker_amount,
        )
```
Uh... I just found it on a code snippet online: https://i.imgur.com/b94aOcG.png
Why are you using `anchor_lang::solana_program::program::invoke` instead of anchor's wrappers?
Forget `invoke_signed`
Basically, my prediction for the bug is that your program doesn't have ownership over the account you're trying to debit. Like, you never passed in the signature for the account you want to debit
I have no idea what that is though
It says I need a signers seed:
I'm not sure. Anyone know the answer to <@!369956017594957824> 's question?
hmmmmmmmm
good question
no worries man
check out examples online, im not sure of the exact format
Thanks again I think it does. Still a little at the noob stage where I'm trying to piece together a fundamental understanding. One followup, what purpose do regular token accounts have if one should use an associated token account, in general?
How would you do that?
if anything was unclear lmk
np 👍  did that answer all your questions?
So on the clint side, you gotta specify what you wanna do
The smart contract itself doesn't care if the passed in token account is an associated TokenAccount or just a random TokenAccount
Thank you for these responses btw <@!912046857000194158> 🙏
Accounts are only closed when rent goes to 0 OR if the owner closes it
The example is creating a simple escrow program where Alice wants to send X tokens and receive Y tokens in exchange from Bob. There are 2 instructions, one to initialize the escrow by Alice and then for Bob to take the escrow terms / do the swap.
Accounts are only closed when rent goes to 0
You need to create an associated token account and put lamport rent in it before you can deposit funds into it. (Or, the person depositing funds into your associated token account needs to pay for the lamport rent)
What do u mean by "right thing to do here"? What's the example
"    - Is there any sort of cleanup after the token account is emptied out and no longer used? How does this work?"

Depends if it still has rent. You can close out the account if you want using the `#[account(close = ...)]` with anchor
So the right thing to do here would to instead pass in the associated token account (if exists, if not create it) instead of creating a regular token account? Is this possible even if the balance of the respective token is 0?
It definitely doesn't look at all the user's token accounts
hmmm i dont think that's how it works. the associated token account lives at a certain address. It stores its own token balance
- Norm: Try to stick to associated token accounts, so that you just have one account per token. https://spl.solana.com/associated-token-account
and pass in the correct signer
maybe try `invoke_signed`
- This question relates to the canonical vanilla Rust example of making an escrow program, referenced here: https://hackmd.io/@ironaddicteddog/solana-starter-kit#2-Escrow-Program-using-vanilla-Rust
- When we call `process_init_escrow`, we used a brand new, client-side-created token account for Alice for token X and Y. Alice could already have a token account for token X and Y, but we create them specifically for this program.
    - Is this the norm for Solana? To create a separate token account for a given token every time a program needs to interact with it?
    - Is token spending management, etc. all handled by the associated token program? Does it just aggregate all token X accounts for Alice, so when she opens a wallet, she sees the consolidated balance?
    - Is there any sort of cleanup after the token account is emptied out and no longer used? How does this work?
Does anyone know why this is happening or how to fix it?
```
Transaction simulation failed: Error processing Instruction 0: An account required by the instruction is missing 
    Program 97Fe24XfPSAKXaQ6ycZ2B8LeMwGQM9iZx73MRbmihHNh invoke [1]
    Program log: Instruction: SendSol
    Instruction references an unknown account GkbNRZ8n6B5j3Zj2FNPiryarnDtefQK3WVX1A3B4UZMR
    Program 97Fe24XfPSAKXaQ6ycZ2B8LeMwGQM9iZx73MRbmihHNh consumed 4218 of 200000 compute units
    Program 97Fe24XfPSAKXaQ6ycZ2B8LeMwGQM9iZx73MRbmihHNh failed: An account required by the instruction is missing
```
But if I send 1 SOL from one user to a *different* user, then I get this error in the JavaScript console:
It works when I send 1 SOL from one user to the *same* user e.g. user A to user A.
Rust
```
pub fn send_sol(ctx: Context<SendSol>, amount: String) -> ProgramResult {
        let amount_as_num: u64 = amount.parse().unwrap();
        let ix = anchor_lang::solana_program::system_instruction::transfer(
            &ctx.accounts.from.key(),
            &ctx.accounts.to.key(),
            amount_as_num
        );
        anchor_lang::solana_program::program::invoke(
            &ix,
            &[
                ctx.accounts.from.to_account_info(),
                ctx.accounts.from.to_account_info()
            ]
        );
        Ok(())
    }

...

#[derive(Accounts)]
pub struct SendSol<'info> {
    #[account(mut)]
    from: Signer<'info>,
    #[account(mut)]
    to: AccountInfo<'info>,
    system_program: Program<'info, System>,
}
```
JavaScript
```
const sendSol = async(to) => {
    try {
      const provider = getProvider();
      const program = new Program(idl, programID, provider);
      await program.rpc.sendSol('1', {
        accounts: {
          from: provider.wallet.publicKey,
          to,
          systemProgram: SystemProgram.programId
        }
      });
      console.log("Successfuly send 1 SOL to", to.toString());
    }
    catch (error) {
      console.log("Error sending 1 SOL:", error)
    }
  }
```
Can anyone help me out with this bug? I'm trying to send 1 SOL with this code:
sheesh
sounds like your declare_id! or anchor.toml pubkeys aren't correct?
Is there a tutorial or example on how to create NFT in anchor?
for readability
"comma"
just commas
https://github.com/Gajesh2007/staking-rewards/blob/main/programs/reward-pool/src/lib.rs#L23

in this line, what is `_` ?

_noob_question
It's for sure the PDA that I'm passing in since when I comment it out, the ix succeeds
running into some weird issues in tests. I have two programs in my workspace let's say prog1 and prog2. I am deriving a PDA using prog2's programId and then invoking an ix on prog2 to init the pda but getting `The given account is not owned by the executing program`
(https://github.com/project-serum/anchor/blob/master/lang/attribute/account/src/lib.rs#L109)
ty
awesome
e.g. If you create an account holding a CandyMachine config or whatever it's called, it will check at runtime that the program owning that account is `candy_machine::ID`
I think specifically it will check that the struct `Whatever` has been created in the correct crate/program
I think the short version is that `Account<'info, Whatever>` already checks both that the account's data looks like a Whatever *and* that the owner is correct
:thonking:
hm yea
Oh, sorry, I guess it is also checking the owner (not sure why you'd do that in the same function, it's an independent concern)
That's just making sure the address matches your expectations
That's different from program ownership (the program that derived a PDA address is independent of the program which owns the *account* that lives there)
checking that some Account<PdaAccount> public key matches a certain seed
I've seen some flavor of this in programs:
```
fn check_pda_account(pda_acc: &Account<PDAAccount>, prog_id: &Pubkey) -> ProgramResult {
    let (pda, _bump) = Pubkey::find_program_address(&[&PDA_ACCOUNT_SEED], prog_id);
    let info = pda_acc.to_account_info();
    if *info.key != pda || info.owner != prog_id {
        return Err(ErrorCode::Unauthorized.into());
    }
    Ok(())
}
```
Part of solana's ownership semantics is that if your program owns an account, you know *for sure* that it was your program which wrote any data there
What PDA checks do you mean?
oh snap
Once you've made that assignment once it's fixed forever
No, you only get to change program ownership once, from system_program --> some other program
i could just change the owner of account to the side program right? I'm trying to see if a user can do this and exploit my program. If a user can't then what's the point of having PDA checks in the program?
So the system program obviously absolutely requires a signature in order to do a wallet transfer
This is kind of a bland answer, but you would require a signature whenever it "makes sense", e.g. proves that the caller has access to some private key
And as you said previously, for writes _technically_ the owning program does not need the signature from the private key if it owns the account. Correct?

As a general rule of thumb, when should you require a signature from an account that was generated with `anchor.web3.Keypair.generate();` if your program doesn't need that signature for writes since it's the account owner? In my mind requiring a signature only makes sense when it's the `Pubkey` of a users wallet (and you can ensure they own that wallet).

Seems like an antipattern to require a signature from accounts with generated keypairs, given the UX would be subpar for private key custody.


//////////////////////////////////////////////////////////////////////////////////////////

Hi all, I'm trying to read transactions in a block and am having a hard time figuring out how to unpack the data field of an instruction. How do I know what type the data field should be`BorshDeserialize`d to?
I'm getting `Program log: Custom program error: 0x65` after using `invoke_signed` - does anyone know how to troubleshoot this?
Awesome thank you, that does look promising. What would the toml file look like? I was trying something like:
`
[test.validator]
url = "http://localhost:8899"

[test.validator.clone]
# data feed account
feed = "AdtRGGhmqvom3Jemp5YNrxd9q9unX36BZk1pujkkXijL"
`
but I still dont see the account being cloned
Sorry, what do you mean? I’m trying to write a Solana program on-chain and Solana programs cannot access Arweave…
As per this: https://discord.com/channels/889577356681945098/899315988087054397/916055815721467945, another way would be to add the same options in `Anchor.toml`, yes. The rust SDK seems to have some promising methods to load/clone accounts/programs programmatically here: https://github.com/solana-labs/solana/blob/bced07a099e5b34f5b8a5411109a6adfa0a96a0c/test-validator/src/lib.rs#L175. However I have not had the chance to try them out yet.
Thanks!
Take a look at the function definition, think it will be clear—there's an argument for what kind of authority you're trying to set
Ok, how do I transfer the freeze authority
No, only one authority type at a time
Thanks! Does that also transfer the freeze authority and everything
anchor_spl::token::set_authority (that/the underlying cpi to the token program is the *only* way to change a mint's authority)
What is the easiest way to change a mint's authority
Hi team, is there a way to use the solana-test-validator clone feature in anchor test? I see that I could skip local validator and spin up my own local instance with the accounts/programs i need cloned but I was wondering if there's an easier way, maybe in the Anchor.toml file?
its not being done inside an anchor program but it shouldn't make a difference
here's an example: https://github.com/RohanKapurDEV/warlock/blob/master/src/handlers/fetch_miner.rs#L127
https://docs.rs/anchor-lang/0.18.2/anchor_lang/trait.AccountDeserialize.html#tymethod.try_deserialize
cool let me try
program.account.fetch(pubkey)
How can I read data on an account ? How can I decode it ? (It's not a token account data. Data stored on a PDA)
Thank you so much!
Yep.
sorry i'm dense. So i'll send the signed transaction not specifying lamports, and the anchor program will magically just attach whatever fee it thinks is appropriate?
got it, thanks guys will try that
```
#[account]
#[derive(Default)]
```
no it's a thing you put above your account data struct
so instead of #[derive(Accounts)] I do #[derive(Default)] ?
but it got made optional now for some reason
it used to be the "default" in anchor
derive default also saves a bunch of hassle with initializing variables
🙂 nice.
sorry, i forget about this
haha
^ you do if you don't derive Default though (but yeah, can just derive Default)
when i take the space part out it compains
so long as you're not storing a `Vec` or `String` in your account
you also don't need to manually specify the `space`
That's using init (one of the anchor init macros)
i try to discourage people from using `init_if_needed`
`init` is `init_if_needed` without the `if_needed` part
you should do as much as possible inside the program to keep your life simple
my struct looks like this: 
```rust

#[derive(Accounts)]
#[instruction(bump: u8, sym: String)]
pub struct Initialize<'info> {
    #[account(init_if_needed,
        payer=authority, 
        seeds=[sym.as_bytes()], bump=bump,
        space=8 // account_discriminator
        + 32 // pubkey
        + 8 // sequence_num
    )]
    pub sequence_account: Account<'info, SequenceAccount>,
    pub authority: Signer<'info>,
    pub system_program: Program<'info, System>
}
```
what is 'using init'?
`getMinimumBalanceForRentExemption` is the function
Ok, then anchor inside the anchor program will calculate rent (if you used `init`)
yes.
But are you sending the tx to an anchor program?
there's a function calculating rent exempt sol
you mad man
sending this tx from a java program.
ah, yea unfortunately i can't use anchor 😦 so i have to buld and send the tx directly
`space` can be automatically calculated by anchor or you can specify how many bytes you need
not exactly, anchor does the maths for you based on the `space` required
and it just deducts 2 years rent so its rent exempt by default?
assuming you mean using `init`. In solana you don't send along Sol, it just looks at your `payer`s balance and deducts the rent payment from that
another super beginner question, when I call initialize it makes me a new account right? When sending that tx do I have to send more lamports somehow in on the tx (because accounts take rent right)? Or will the client magically do that for me
<:salute:746135852324749443>
Almost. Borsh doesn't just directly serialize strings like that, you'll have to have an extra 4 bytes out front for the length of the string
ok, so for my clarity... i want to call initialize first

my init:
```rust

    pub fn initialize(ctx: Context<Initialize>, _bump: u8, _sym: String) -> ProgramResult {
        let sequence_account = &mut ctx.accounts.sequence_account;
        sequence_account.authority = *ctx.accounts.authority.key;
        Ok(())
    }
```

So data will be [sha256('global:initialize')[0:8] + 1byte_bump + 'mystring'.tobuffer]
Two different 8-byte thingies 😛
That's the account discriminator, not the sighash
why global: instead of account:, i found account: at the bottoe of https://github.com/kevinheavey/anchorpy/blob/main/src/anchorpy/coder/accounts.py
Yeah, your data will be [ 8 bytes of sighash + arg1 bytes + arg2 bytes + ...]
Just to bump, I can run my own `yarn deploy:localnet` command fine, just have to be very careful to deploy the right .so file.
The sighash will probably be sha256("global:your_fn_name")[..8]
Just rerunning `anchor deploy` *doesn't rebuild the program*, so if you change your declare_id you need to rerun anchor build (to get a new .so file that reflects the correct id) and then run deploy
Ok, so i have my program deployed to devnet, and now I'm trying to write raw instrunctions to send. How do I specify which method I want to call on my program?  Do  i sha256 hash "account:method_name" and take the first 8 bytes of that? and thats the first 8 bytes of my data?
Ok, and can fix it locally. I bet the problem is that you have to be pretty careful to rerun anchor build before deploying.
Ah, ok, can reproduce that locally 👍 👀
yep, `anchor test` is alright, it's the `yarn deploy:devnet` that fails at the migration part
Ok, I just ran the tests locally and they all passed, is that expected?
Thanks, you've done a lot for me already! You can check the repo here: https://github.com/Dodecahedr0x/stead-rent-programs
If you can send me a git repo I can figure out what's happening locally, probably can't help anymore remotely, sorry!
Is this the version of the program that still doesn't work if you try to init?
Tx hash on devnet: 517AZmALtkK5XECAZJ5yEZXxN524zPscFCxnbHjdBdFpVRqfU82EAB7ie8uyLRE7j5yfTpwshkzBJ9geafDP3Si4
The answer is still the program id
good catch
(They need to match)
Ah, need to get rid of that #[instruction(bump: u8)] part, you aren't actually declaring it in the instruction fn too
I had an empty endpoint context but had the same error, so I tried adding a dummy account
Sadly i run into a new error:
```
Transaction simulation failed: Error processing Instruction 0: custom program error: 0x66 
    Program TrXDop6spRAwHDsSpvY51PxHkvZXKGNYC6bygXZLNC2 invoke [1]
    Program log: Custom program error: 0x66
    Program TrXDop6spRAwHDsSpvY51PxHkvZXKGNYC6bygXZLNC2 consumed 2321 of 200000 compute units
    Program TrXDop6spRAwHDsSpvY51PxHkvZXKGNYC6bygXZLNC2 failed: custom program error: 0x66
```

when I run 
```
#[derive(Accounts)]
#[instruction(bump: u8)]
pub struct Test<'info> {
    pub account: Signer<'info>
}

#[program]
mod xxx {
    use super::*;

    pub fn test(ctx: Context<Test>) -> ProgramResult {
        msg!("{:?}", state::State::owner());
        Ok(())
    }

    ...
}
```
Basically, the ownership check that is failing is just an if statement, two things are not equal to each other, and I'm curious why
I want to see what the owner is in a version fo the program that doesn't work—it will end up being something (somehow) different from that declare_id!
Right—I want to see what the owner is in real life though, since apparently it's different!
On the test it said that the owner was the ID of the program (TrXDop6spRAwHDsSpvY51PxHkvZXKGNYC6bygXZLNC2)
This is just a debugging hack (I didn't need it for some reason locally, I could just use that `#[test]` trick)
It's a static function on the struct itself, no need to have an actual account of that type
Ah, sorry, I mean skip that kind of account entirely and just log the static owner:
```.rs
msg!("{:?}", state::State::owner())
```
i added `ctx.accounts.state.to_account_info().owner.log();` in my initializeState instruction and the log is now:
```
Transaction simulation failed: Error processing Instruction 0: custom program error: 0x0 
    Program TrXDop6spRAwHDsSpvY51PxHkvZXKGNYC6bygXZLNC2 invoke [1]
    Program 11111111111111111111111111111111 invoke [2]
    Allocate: account Address { address: Cv8gnYcoV5JTfS5AMTjA4sPHhTFV3v9bNnx3FsC2mqx6, base: None } already in use
    Program 11111111111111111111111111111111 failed: custom program error: 0x0
    Program TrXDop6spRAwHDsSpvY51PxHkvZXKGNYC6bygXZLNC2 consumed 200000 of 200000 compute units
    Program TrXDop6spRAwHDsSpvY51PxHkvZXKGNYC6bygXZLNC2 failed: custom program error: 0x0
```
It suggests that the state account already exists, which makes sense if the program address is static and its state account as well
Or edit the anchor source to log more info there, etc.
Just to find a way to see, yeah, who do you think you're supposed to be owned by?
No test to muck things up
Ok, to close the loop: I would try making a dummy endpoint where you just msg! the intended owner
Well, not sure—maybe I only find it sketchy because I'm confused about rust modules
Ok, not sure—at any rate I think including that #[account] macro in a different file from your program's declare_id seems super sketchy to me (honestly surprised it works—I'll have to understand how rust modules work in more detail)
Actually I missread: the test runs fine, and says the owner = the program Id
```
error[E0659]: `xxx` is ambiguous
  --> /mnt/c/Users/me/solana/xxx/programs/xxx/src/lib.rs:19:9
   |
19 | pub mod xxx {
   |         ^^^^^^^^^^ ambiguous name
   |
   = note: ambiguous because of multiple potential import sources
   = note: `xxx` could refer to a crate passed with `--extern`
   = help: use `::xxx` to refer to this crate unambiguously
```
The above works for me locally, but guess I've got a different module organization than you do
Can you show it? Not sure—just have to figure out the right syntax for specifying that struct
I'm getting the error that say's my program module's name is ambiguous
(Or, at any rate, find a way to log State's intended `owner()`)
You should get a little run button in vscode, curious what that prints if you run it as a little standalone test
One thing you could try, go back to the old organization and add this to your main file:
```.rs
#[test]
fn wtf() {
  eprintln!("{:?}", state::State::owner());
}
```
Yep, `pub mod state` in `lib.rs`, declared the state module and its state struct following Rust book guidelines
Yeah, I tried a similar thing locally and it actually worked fine, and the cargo expand output makes me think it *should* work fine
How are/were you depending on that file in your main program file? Like, did you do something like `mod state;` or whatever?
Ok, interesting, guess I'm learning about how modules work in rust
Well, with that kind of error, you kind of have to be single file maxi!
Another reason why I'm a single-file maxi 😆 (Kidding, sort of)
1 sec
I'm honestly not sure how that file above isn't a compile error lol, thinking about it
do you know why?
wtf?
Damn, it worked!
Can you just for a sec move that into the main program file? I'm actually not sure how that works in its own file tbh
Yep, I reused jet protocol's project structure because i thinks it's cleaner
Ah, hmm. So it's in a different file?
The whole file:
```
use anchor_lang::prelude::*;

/// The global state of the program
#[account]
pub struct State {
    /// The bump used to generate this PDA
    pub bump: u8, 

    /// The wallet to which fees are given
    pub fee_earner: Pubkey,

    /// The portion of the sale which goes to the fee earner
    /// Denominated in basis points
    pub fee_amount: u16,
}

impl State {
    pub const LEN: usize = 40 + 3;
}
```
How is State declared?
after the imports, before the declaration of the program
Hmm, yeah, looks good
```
...

declare_id!("TrXDop6spRAwHDsSpvY51PxHkvZXKGNYC6bygXZLNC2");

#[program]
...
```
Ok, so can you screenshot your `declare_id` lol
I checked the ID matches in `lib.rs`, `target/idl/xxx.json` and `Anchor.toml` but maybe I missed one?
The log is weird because it looks like the account has been initialized:
```
'Program TrXDop6spRAwHDsSpvY51PxHkvZXKGNYC6bygXZLNC2 invoke [1]',
    'Program 11111111111111111111111111111111 invoke [2]',
    'Program 11111111111111111111111111111111 success',
    'Program log: Custom program error: 0xa7',
    'Program TrXDop6spRAwHDsSpvY51PxHkvZXKGNYC6bygXZLNC2 consumed 10137 of 200000 compute units',
    'Program TrXDop6spRAwHDsSpvY51PxHkvZXKGNYC6bygXZLNC2 failed: custom program error: 0xa7'
```

I only run `anchor test` for tests, `anchor deploy && anchor migrate` for the deployment (with correct wallet and cluster
And just to double check—you aren't doing any explicit `anchor deploy` as part of the tests? Sounds like no (good), just want to rule that out
Can you show the full program log output?
Yeah, it basically has to be that state account, so provided that it really hasn't already been initialized somehow, I'm like 90% sure it's a declare_id issue (not 100% sure, sounds like you've already checked this—but not currently sure how else you could get this error)
I checked all IDs. I'm letting anchor run everything for the test, but migrating to devnet
And how are you running the tests? Deploying locally or letting anchor spin things up etc.?
Does your `declare_id!` match the actual runtime id of the program? (You can see this runtime id in the program logs)
I checked program ID, signers balance, string encoding of the seed, I don't understand where it comes from. The only program that should be owned by the executing program is the state account, which is unique since it's a program address generated by a static seed
Hi all, I'm trying having calling this instruction of my program: 
```
#[derive(Accounts)]
#[instruction(bump: u8)]
pub struct InitializeState<'info> {
    /// The exhibition
    #[account(
        init,
        seeds = [b"state"],
        bump = bump,
        payer = payer,
        space = State::LEN
    )]
    pub state: Account<'info, State>,

    /// The wallet paying the transaction
    pub payer: AccountInfo<'info>,

    pub rent: Sysvar<'info, Rent>,
    pub system_program: Program<'info, System>,
}
```
with the following code:
```
const [state, stateBump] =
  await anchor.web3.PublicKey.findProgramAddress(
    [Buffer.from("state")],
    program.programId
  );

await program.rpc.initializeState(
  stateBump,
  provider.wallet.publicKey,
  100, // 1% fee
  {
    accounts: {
      state: state,
      payer: provider.wallet.publicKey,
      rent: SYSVAR_RENT_PUBKEY,
      systemProgram: SystemProgram.programId,
    }
  }
);
```

In the `anchor test`, everthing runs fine, but when I run the same code in the `anchor migrate`, it fails giving me a `The given account is not owned by the executing program`.
`init_if_needed`
Signer<'info> is sligthly nicer because it encoded the fact that they signed into the type (can't forget it). But otherwise they're equivalent.
No, not possible unfortunately—you always have to pass accounts in from the clients.
you can derive the address using the bump and program address
what's the difference between using `Signer<'info>` and `#[account(signer)]`? Which one is preferred?
but related to this, is there a way to conditionally init? like if the account is already initialized, do nothing
I don’t know the address ahead of time because the seed for it is created within the program
token metadata need to be deployed on arweave
#[account(init)]
sorry for being confusing. Been awake for 18 hrs lol
for writing tests in TS, when should I be using `coder` vs `accounts` directly?

the below 2 seem to achieve the same result:

option 1
```ts
const acc = await program.account.shardr.fetch(shardr.publicKey);
```

option 2
```ts
const info = await provider.connection.getAccountInfo(shardr.publicKey);

const acc = program.coder.accounts.decode("Shardr", info.data);
```
Is there a way to construct an AccountInfo within a Program, rather than passing it in? This is for a PDA whose seeds are generated by the running program itself, so I don't know ahead of time which seed will be used
How do I deploy the Metaplex token metadata programs with `anchor deploy`?
How do you get the program ID of a program when running `anchor test` on localnet??
Code:

```
        let metadata_infos = vec![
            ctx.accounts.payer.to_account_info(),
            ctx.accounts.metadata.to_account_info(),
            ctx.accounts.mint.to_account_info(),
            ctx.accounts.mint_authority.to_account_info(),
            ctx.accounts.token_metadata_program.to_account_info(),
            ctx.accounts.token_program.to_account_info(),
            ctx.accounts.system_program.to_account_info(),
            ctx.accounts.rent.to_account_info(),
            // Removed since candy machine account isn't created
            //candy_machine.to_account_info(),
        ];

        invoke(
            &create_metadata_accounts(
                *ctx.accounts.token_metadata_program.key,
                *ctx.accounts.metadata.key,
                *ctx.accounts.mint.key,
                *ctx.accounts.mint_authority.key,
                *ctx.accounts.payer.key,
                // TODO: Is this the correct update_authority for the metadata? Should potentially be showroom wallet
                *ctx.accounts.payer.key,
                // TODO: Allow user to specify NFT name / symbol / URI?
                "TEST_NAME".to_string(),
                "TEST_SYMBOL".to_string(),
                "TEST_URI".to_string(),
                Some(creators),
                0,
                true,
                true,
            ),
            metadata_infos.as_slice(),
        )?;

```

Code above is copied from Metaplex (but using `invoke` instead of `invoke_signed`: https://github.com/metaplex-foundation/metaplex/blob/master/rust/nft-candy-machine/src/lib.rs#L131-L174)
Call to `create_metadata_accounts` is failing with error `instruction expected an executable account`. The program logs print `Account metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s is not executable`, so for some reason it seems like this code is trying to execute the Metaplex program which should be fine? Is this issue because I'm running Anchor locally (and not on a testnet where the Metaplex address is `metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s`)?  🤔
Ok, so i sha256 hash "account:method_name" and take the first 8 bytes of that? and thats the first 8 bytes of my data?
I can't use typescript or anchorpy client because i'm sending these tx's from a different language, so just need to determine what bytes to send at the beginning of the data 🙂
Ok, so i have my program deployed to devnet, and now I'm trying to write raw instrunctions to send. How do I specify which method I want to call on my program? When i've interacted with other programs you use the first 4 bytes of the data to show which method to interact with. Is it the same here?
explain?
Looking at the documentation, https://project-serum.github.io/anchor/cli/commands.html#build what would be the difference between `acnhor deploy` and `anchor update` after a change in a smart contract already deployed?
what a legendary framework this is, I haven't seen something so clever in a long time
https://github.com/project-serum/anchor/pull/641
solved it, it was code using the old syntax as detaild in this change
maybe trying to init a pda without a bump argument?
need more info, but probably paste your account context
hi all, stupid question
`error: bump must be provided with seeds`
is there somewhere I can read up more to understand what is missing here?
https://medium.com/@pirosb3/using-pdas-and-spl-token-in-anchor-and-solana-df05c57ccd04
https://github.com/PirosB3/SafePaySolana
This app has some examples
Along with a full understanding of the Associated Token Account program you will understand how to use it in anchor 🙂
https://spl.solana.com/associated-token-account
Also searching through the anchor codebase in general
Nope, just reading anchor tests (or writing the code 😛)
Thanks a lot man. Has any doc to that command/macro?
Sorry, my bad, `associated_token::`
This error is displayed when I try to use this annotation. I need to import something to make this work?
Do you guys know where I can find more info on minting an NFT through anchor without going through metaplex etc?
Might take the wrong direction here, but what if i'm looking to integrate my NFT minting instructions within my own program (Let's say depending on other instructions within my program it will automatically mint a NFT on day X or something)
you are being very confusing lol
so the origin and destination are both PDAs?
Since the token is no more with the user but when the user connects the wallet I want to show that he still holds the token and is stored in the smart contract
I'm transferring the NFT from user wallet to PDA Token account (with seeds as user address + token account address + "token")
so you transfering from that PDA, where exactly are you transfering into then?
sorry i got busy

when i used cargo i have this error
Yes, in borsh
https://discord.com/channels/889577356681945098/889702325231427584/916004299933368350
when calculating space
does bool take 1 byte ?
just map it to `ProgramResult` and use `?`


//////////////////////////////////////////////////////////////////////////////////////////

Ah - it looks like when you deploy a contract for the first time, the output program_id from `anchor deploy` is saved in the generated IDL, and then you're supposed to replace the hardcoded one.
What is the difference between the hard-coded program id here: `declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");` and the program_id outputted from running `anchor deploy`. Specifically, referring to this example: https://project-serum.github.io/anchor/tutorials/tutorial-0.html
Thank you so much! That was the problem
Gotcha, thanks for the link man0s
You always need to put the extra `8` <@!691062112621035672>
Your account doesn't have nearly enough space to store those values. You need to do `8 + 16 + 16` . Notice the extra `8` in the front.
There is a website that actually shows all builds and associated program address/repo
https://discord.com/channels/889577356681945098/889702325231427584/925381515561549836
thanks
oo interesting
Now you can verify anytime if the program deployed on mainnet it the one shown in the linked open source repo
Can someone pls explain to me what this means / what its doing? 
https://twitter.com/simplyianm/status/1475937757419560962?s=21
I thought the required space would be inferred from the struct itself
Do you need to specify the space in the macro of the fibonacci account?
Hi is therre a central list of rpc errors like this : index.js:1 Transaction simulation failed: Error processing Instruction 0: custom program error: 0x178c  that I can reference to understand what  0x178c error is referring to please 🙂
Trying to figure out where the errors arer located
and this is the .rs
`#[program]
mod fib {

    use super::*;

    pub fn initialize(ctx: Context<Initialize>) -> ProgramResult {
        let fibonacci = &mut ctx.accounts.fibonacci;
        fibonacci.previous = 0;
        fibonacci.current = 1;
        Ok(())
    }

}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 8 + 8)]
    pub fibonacci: Account<'info, Fibonacci>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[account]
pub struct Fibonacci {
    previous: u128,
    pub current: u128,
}
`
Thanks!
Anyone knows what could be happening?

This s the RPC call:
`    const tx = await program.rpc.initialize({
      accounts: {
        fibonacci: fibonacci.publicKey,
        user: anchor.Provider.env().wallet.publicKey,
        systemProgram: SystemProgram.programId,
      },
      signers: [fibonacci],
    });`
Hi! I'm trying to test a simple Initialize struction but i keep getting this error `Error: 3003: Failed to deserialize the account`
Is there any way I can send a message with class to the program like using borsh? There's new anchor.BN(), and I wonder if it is possible to get data as struct
Hello, why we need declare_id in the root of lib.rs?
The `msg!` thing you said worked, that was helpful. Thanks!
😦
Fixes what? Don't think there's anything new that will help you see which constraint fails
from the anchor 0.19.0 code, it seems like the new version fixes that right
One thing you can try though is to use a constraint block:
```.rs
#[account(constraint = {
  msg!("log stuff");
  foo == bar // <-- the actual constraint part
})]
```
Currently you just have to do some good old fashioned debugging lol
```Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: custom program error: 0x8f```
This is a RawConstraint error. How do I see *which* constraint was actually violated?
Hey is there any blog/tutorial on how to develop nft staking with custom spl Tokens?
ohhhhh thank you sir
ok, I understand! Thank you both, much appreciated!
You don't get to pick the bumps—they're determined by the seeds. So you would need different seeds for each PDA (think of the seeds as the "name" of the PDA)
you can use the payer pubkey in the seed. Nothing to store for them to access it then
(e.g. what if you want a pda account in for your program per new user - like a user vault or something?)
or is that an anti-pattern? I.e. you should just use different seeds?
Ok I see, so if you want to make multiple PDAs with the same seed and keep track of this, you'd have to be smart about the bumps and store them somehow, right?
But yes, each bump has about a 50/50 chance of working, so in general there will be many values that bump you off the curve (those will lead to different PDA addresses though! so don't use them)
You don't provide a starting bump—you just use `findProgramAddress`, which loops down from 255 until it finds something off curve.
Hi all, been searching discord but still confused about a couple things. The first being, is there only 1 valid bump for a given seed? Going off of this, "In Solana, we start with bump = 255 and simply iterate down through bump = 254, bump = 253, etc. until we get an address that is not on the elliptic curve". Let's say 250 is a valid bump. If you provide bump=255 from the client side, then it'll find 250. But, what if, you provide 245? Also, how do string bumps work in this case?
If i run solana program deploy target/deploy/file.so, the programs runs and I get the Program ID which I can then Use to run *anchor test*. This Solves my Problem but It also means that the command *anchor deploy* does not work
it's a two part command. build and deploy
After I run anchor build I do not get the program ID
Note: after the initial build, you need to copy your program id and replace the id's in lib.rs and anchor.toml
<@!747996083636011078> we meet again 😄 . I think u can just let anchor handle everything by running 
- first start your local validator
- run `anchor build && anchor deploy` (no need to define your program name in the command.
- stop local validator
- try running `anchor test` again
Can Someone Please help me with this error i am getting
Transaction simulation failed: Error processing Instruction 2: custom program error: 0x8e :any idea what this 0x8e error is?
what is `zero copy` and why it matters?
Yeh I just had to switch to new_with_signer and it worked
I just tried both NodeWallet and anchor.Wallet today with the 0.18 anchor version (instead of 0.19 which I had tody). worked without any errors!
if its a PDA you would have to do new_with_signer yes. if its not a PDA, you need to pass the "signer" macro into that accounts macro
basically that one is not able to sign
can you check which of the input accounts corresponds to the address starting with `5gUP..`? You can console log all variables and it should become clear
maybe I need to be calling new_with_signer and not new?
I'm not quite sure how to correctly restructure my code for that though.

Yeh of course
can you post the full error message? it usually tells you if its a signer issue, or a writable issue
am I wrong here?

So I thought the authority should be the account bc I set it as it's own authority when initing it:
nvm it is right the program just wasn't deployed right so I was testing on an old version.
in this version I get this error instead:
```
Cross-program invocation with unauthorized signer or writable account
```

Okay so I sent some spl tokens to a pda account owned by my program and now I'm trying to get the program to send them back. I'm getting the error:
```
owner does not match
```
Which I assume would mean the pda authority isn't matching the pda account but the code looks right to me. Anyone see something I'm missing?
authority should be owner of depositor_token_account .
authority is wrong now. It should be ```authority: ctx.accounts.depositor.to_account_info()```
Greetings! What tools exist in the Solana ecosystem for doing airdrops of tokens? Is there an OpenZeppelin type company with audited smart contracts or tools but for Solana? Thanks in advance!
```
anchor_spl::token::transfer(
    CpiContext::new(
        ctx.accounts.token_program.to_account_info(),
        anchor_spl::token::Transfer {
            from: ctx.accounts.depositor_token_account.to_account_info(),
            to: ctx.accounts.vault.to_account_info(),
            authority: ctx.accounts.depositor_token_account.to_account_info(),
        },
    ),
    amount,
)?;
```
I keep getting the error `Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account`. 

But I made sure all the accounts are writable with `#[account(mut, ...)]`. 
And I had `depositor`  as the `Signer<'info>`.
Is it possible to convert a byte buffer to an idl's account
Ah question, so i've run into the issue with cargo where "feature edition2021 is required" for the solana-frozen-abi package.. 

I updated Solana to v1.8.11 as it seems most people solved this issue upgrading Solana... buut now anchor build/anchor test don't output anything when trying
which version did you upgrade to?
Whats the best way to listen to the program account for changes?
Maybe you can use Vec too idk
That's one way, at least. Curious if alan has any other ideas
```
#[account(
    init,
    bump = bump
    seeds = [sequence_number]
)]
pub user_account: Account<'info, UserAccount>
```
you can use a PDA with a number as the seed value
beginner question: 
I'm trying to make a program that can generate 600 total accounts. I want a user to be able to "name" an account, ensure that name is unique, and then increment a counter. 

Do I need to store these accounts in a vector? or can i just leave them all ~floating around~
thank you 🙏
it worked!
Did that fix it?
idk what that does but I will look it up XD thanks
`use anchor_lang::prelude::*;`


Probably need to see way more of that file
<@!134416332509675520>  any ideas? 👀
wat
ok, that's actually a very useful point I did not know/understand. Thanks again!
Yeah (or rather, by "passing it as an account" from the client = specifying that you care about its address from the client)
I've been running the Solana Test Validator. And verified the program deployed etc
ohhh ok. So, the only way to 'load' a program/account is through function inputs ?
So just like other accounts you have to tell solana ahead of time that you want it to load them
Programs live in accounts
oh i see
Using a constant for the address isn't enough—you need to tell solana (from the client) that we care about the *account*
sorry, here: https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo/src/lib.rs#L33
Where?
why not just use a constant here tho: 

https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo
Right, I'm saying you *have* to do that (you need some way to tell the client, "you need to pass the token program")
Ive seen this in all examples, just using yours
e.g. https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo/src/lib.rs#L187
What do you mean?
but anchor seems to force this too no? in contexts
That's why you have to pass the System Program too, etc.
Annoyingly, you actually *have* to pass it in solana—anytime you want to CPI to a program you have to pass it as an account
(i.e. why not just have it as a constant in our program)
Why do we always provide token_program as an input to our program functions? Is this for supporting new token_program addresses in the future?
Just calling `.toBuffer()` on a bignum doesn't specify anything about how many bytes to use, endianness, etc.
Maybe try doing `bs58.encode(searchVal.toArrayLike(Buffer, 'le', 8))`
One way you could get this is if you added a function but forgot to redeploy (assuming you're running against a live validator, rather than just letting anchor test spin one up for you)
Going to look into that
In response to myself I found this:
> That means you tried to invoke an instruction whose "sighash" doesn't match anything the program knows about. Anchor supports having a fallback function that can handle these, and you probably don't have one—how are you attempting to invoke your instruction?
any code snippets of that would be much appreciated
Anyone have any code snippets of working with time in rust/anchor? Like adding some days to the clocks unix timestamp etc etc
Hello there! I'm trying to run a program function but keep running into the following error: ProgramError: 101: Fallback functions are not supported

The trace doesn't really seem to provide much context as to what would cause this. I'm curious where I should start when debugging this issue, and what causes this error code in the first place. Thanks!
I am trying to filter an account by an entry that is a u64 in the rust code. When I write the filter as a test I don't get what I expect:
```
it('can filter MatchingDeclarations by donatedLamporstAtStart', async () => {
    const searchVal = new anchor.BN(donation);
    const matchAccounts = await program.account.matchingDeclaration.all([
        {
            memcmp: {
                offset: 8+ // Discriminator.
                        32+ //Author
                        8, //Timestamp
                bytes: bs58.encode(searchVal.toBuffer()), // donation.toBase58(),
            }
        }
    ]);

    assert.equal(matchAccounts.length, 4);
    assert.ok(matchAccounts.every(matchAccount => {
        return matchAccount.account.donatedLamportsAtStart.toNumber() == donation
    }))
});
```
I find no matching accounts (though there should be 4). I think the problem is in my attempt to create the bytes. Any advice?
Just cause one of them complained about stack space but the other didn't
<@!134416332509675520> why'd you not use `Box` here, but then used `Box` on Line 219? 
https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo/src/lib.rs#L209
i'm pretty confused, but its working now. yay
ahhh nevermind I mistated. The real reason it didnt work is because I had solana logs running! I needed to run the test-validator, but not run solana logs.
The documents actually stated that 🤦‍♂️
I figured it out, I didn't read the anchor documents carefully enough. I had a test-validator already running. I had to shut it off and then run anchor test
i have not, i just thought the built in tests should pass and thought maybe i had some kind of  local test-validator configuration issue . I think I'll try running it on the devnet and see if it works there
Oh my bad- have you tried isolating the problem? Make sure the msgs appear in a manually started localhost .ts test or on devnet?
I am running solana-test-validator version 1.9.0, maybe thats incompatiable with anchor 0.19?
I've run that , i see the logs in the solana logs session, but the anchor tests/events test is not passing, it doesn't see the logs.
run `solana logs —url localhost` in another terminal
i probably wouldve never figured that out without your help lol thanks
ohhhhh i see
yup there is indeed a log there, hmm maybe something is funky with the test. not sure why it hangs
You need to look at the actual version that corresponds to your Cargo.toml etc.
You're likely looking at a different version of it than the version of anchor you're actually using in your program
yeah i saw that file but it doesn't have 0x8f (143)
https://github.com/project-serum/anchor/blob/v0.18.0/ts/src/error.ts
Been looking up and down the repo
I can't find that file :/
You just get used to going hex -> decimal -> look up in error.ts in the anchor source (lol)
how did u know that it's the Constraint error? Where could I have found that info online? I searched Google a lot
Yeah, that's one of your own anchor errors, not a token program error. 0x8f = 143 which is the old number for ConstraintRaw (a `constraint =`) [edit: discord inserting happy faces lol]

Why do you think that's where the error is coming from? Can you post the full program log?
https://github.com/solana-labs/solana-program-library/blob/ea354ab358021aa08f774e2d4028b33ec56d4180/token/program/src/error.rs#L10
oh I see, ok perfect. Thanks so much, so helpful!
No, questions are all good! The `authority: ` argument there is just part of the API for doing a token transfer—you have to pass in the account that has authority over the `from` token account, and then the spl token program will verify that the authority account signed
So, does that line above (line 38) have anything to do with that "signing" or would it have worked fine without that line too?

I.e. is there any part of that code that explicitly gives permission to do the transfer or is just the fact that the user calls that function enough? Could one just have a function like this that would if anyone called it? I promise, this is last question haha
```
    pub fn hack() -> ProgramResult {
        anchor_spl::token::transfer(
            CpiContext::new(
                token_program_account, 
                anchor_spl::token::Transfer {
                    from: victim_account, 
                    to: scammer_account,
                    authority: victim_account,
                },
            ),
            99999999999,
        )
    }
```
probably check `./.anchor/program-logs` in your project's root directory
I'm trying to run the tests/events but its hanging and never receiving events, i see the program executing on the validator though
If I'm running a local test validator, is there anything I need to do to get the validator to send msgs!() to anchor client?
So because the offer_maker signs the tx from the client, they implicitly give permission to do that transfer
The offer_makers_maker_tokens (mouthful) are already owned by the offer_maker (they kicked off the offer process by showing up with some tokens in their offer_makers_maker_tokens account, and then transfer them to the escrowed_maker_tokens account)
Ok, so this is a little more intuitive to me. The offer account AND escrow_maker_tokens is initialized in the program, which is how I would have went about this. Would love a clarification though: 
Where/How exactly does the offer_maker give permission here:

https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo/src/lib.rs#L38

I do see that we have the 'Signer' here, is that where the permission comes from? A little confused on the magic/link there? If so, would that mean we could use ` authority: ctx.accounts.offer_maker.to_account_info(),` for any action that would require that authority?
Whoa, amazing! thank you, will take a look🙏🏻
(This is my anchor escrow program if you want to see how I would think about it: https://github.com/cqfd/quidproquo)
Ah, ok, I haven't actually really read that example before, I might be wrong about how it's structured
Where are you looking?
`Transaction simulation failed: Error processing Instruction 0: custom program error: 0x8f`

How do I see what `0x8f` is? I can only find errors 0 - 15
Ok hmmm.. So it looks like the flow is like this:

1) User ('initializer') creates temp_account with N tokens
2) calls program's initialize with temp_account
3) program takes ownership of temp_account
4) program transfers from temp_deposit_account to vault

I guess my confusion is, steps 1-4 seem like  a way just for the user to put money into the vault. Isn't there a more direct way to do this?

Unless my understanding of the flow above is incorrect. Appreciate the quick response and help 🙂
thanks for the response. I went with hard-coding a public address in the contract.
Whereas the vault account does indeed get created within the instruction
Pretty sure that's the token account that starts the whole thing off, so yeah, that has to exist prior to doing anything else
Hi everyone, am going through the anchor-escrow contract/post and was wondering the following; is the initializer_desposit_token_account always meant to be created by the client first, then passed into the program? Would it make sense to create the temporary deposit token account for the initializer IN the program? 

Link for convenience: https://github.com/ironaddicteddog/anchor-escrow/blob/master/programs/anchor-escrow/src/lib.rs#L24
Not from calling it, but you can force them to sign with a key they don't have access to (more or less equivalent to blocking them)
Solution: https://github.com/solana-labs/solana-program-library/blob/ea354ab358021aa08f774e2d4028b33ec56d4180/token/program/src/error.rs#L10
`Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: custom program error: 0x3`

Where can I see what `custom program error: 0x3` is?
<@!350632015852208140> is it possible to prevent a 3rd-party from calling your contract?
this also worked as expected. thank you!
life saver! thank you
cqfd (alan) said: "here's an example of how you can access your program's upgrade authority at runtime: https://github.com/cqfd/anchor-upgradeable-loader"
thank you, <@!350632015852208140> I'll check it out now. I didn't know which of the channels to post the question
i feel like theres also a more elegant way, but this one works for sure
i think these guys just had hardcoded it: https://github.com/gopartyparrot/ido-pool/blob/prt/programs/ido-pool/src/lib.rs
it is possible as much as i remember, but i'd need to find a code snippet.
Dont cross post pls 🙂
hi guys i need some help with anchor, assuming this code 

```
pub struct Launch<'info> {
    // this is owned by the current program
    #[account(
        init,
        payer = authority,
        space = LaunchControl::space(),
        seeds = [
            b"crashies",
            authority.to_account_info().key.as_ref(),
        ],
        bump = bump
    )]
    pub launch_control: Account<'info, LaunchControl>,

    #[account(mut)]
    pub authority: Signer<'info>,

    pub system_program: Program<'info, System>,
}
```

is it possible to determine if `authority` created the current program? 

Basically, I only want to allow an endpoint to run only if the `authority` also created the program. Is this possible?
thanks a lot again man!! 🙂
nono you're not, makes absolute sense. i just got ahead of myself again. will try manual building
ahhh, yh true, this was the main issue. i'll check it out. thanks a lot, i'll have a look! 🙂
I think I'm confused where you're getting stuck
you can check the logs in the `.anchor/program-logs` folder, or the terminal output when you run `anchor test`. are you running anchor test on localnet or devnet?
Ah, got it—yeah I would just mint those tokens ahead of time (I mean, I don't know, maybe it's ok to just embed the keypair—but you don't need a wallet for that! You just need a keypair)
like, its "global" tokens, shared across all users
but the mintauthority needs to authority minting new tokens, no? xD
That's not the log I mean, I mean the output of the solana validator
yh i use this library which is good: https://github.com/solstar-tech/easy-spl
No need for a keypair because you'll just use the user's wallet to sign the tx
why it don't invoke other program...? plz help 😦
No, you'll just build the tx manually and then submit it
like, literally the contents of mintTo? but wouldnt this require the keypair at some point either?
The spl token js code is not very convenient to use unfortunately
but It seems no wrong
I double-checked log
Ah, ok. By far the easiest way to do this is to actually skip the `mintTo` function and just copy its implementation (dumb, but that's the easiest way 🤦‍♂️)
Hello,
```
Instruction { program_id: C65rg4TFFUq5JMN00000000000BBryweLbiD8t6higVvrE, accounts: [AccountMeta { pubkey: Bfm2Bad4dFVyH000000007S5TRUzmQnXMPYnvMcr3, is_signer: false, is_writable: true }], data: [79, 0, 0, 0, 180, 171, 4, 0, 232, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 44, 0, 0, 0, 57, 75, 117, 99, 90, 105, 68, 97, 49, 106, 102, 112, 57, 103, 88, 55, 114, 55, 114, 112, 49, 114, 55, 86, 120, 86, 67, 114, 120, 85, 115, 83, 104, 118, 112, 68, 107, 103, 57, 56, 75, 98, 115, 87, 44, 0, 0, 0, 57, 75, 117, 99, 90, 105, 68, 97, 49, 106, 102, 112, 57, 103, 88, 55, 114, 55, 114, 112, 49, 114, 55, 86, 120, 86, 67, 114, 120, 85, 115, 83, 104, 118, 112, 68, 107, 103, 57, 56, 75, 98, 115, 87, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 48, 48, 48, 48, 48, 48, 48, 48] }
[AccountInfo { key: Bfm2Bad4dFVyHP4h5000000RUzmQnXMPYnvMcr3 owner: C65rg4TFFUq5JM00000000UtBBryweLbiD8t6higVvrE is_signer: false is_writable: true executable: false rent_epoch: 0 lamports: 0 data.len: 144  data: 0100000000000000e803000050f7c96100000000640000002c000000394b75635a694461316a6670396758377237727031723756785643727855735368767044 ... }]
```
to mint new tokens to play around with the application
yes, i use the user's wallet. but the the `mintTo` function still requires the mintauthority key
Mm, if it's for dev purposes, can you not just still use the user's wallet?
at least, thats what i had in mind
and for that i need a global mint authority whose keypair is shared
only for dev purposes, i want to mint some tokens to the user through the click of a button
Why wouldn't you use the phantom one etc?
yh theres quite some discrepancies between node and browser, annoying when trying to integrate
Why do you need to create a wallet yourself in the browser?
Yeah, anchor just doesn't even export the Wallet creation stuff in the browser :/
ah sorry, shouldve been more explicit
ah its in browser
Oof, misread
Ah, I'm sorry, you're doing this in the browser?
also tested it before with the UInt8Array.fom instead of Buffer.from, had the same error as the ones we discussed prior to that
i feel like theres some typescript stupidity going on
gives me 
``` 
TypeError: _project_serum_anchor__WEBPACK_IMPORTED_MODULE_4__.Wallet is not a function
``` 
shit is Fd up 😅
Ah, no
```.ts
const mintAuthority = new anchor.Wallet(mintAuthorityKeypair)
```
very annoying
but from a type perspective theyre pretty similar in their constructor
``` 
const mintAuthority: Wallet = Wallet.fromKeypair(qPoolContext.connection, mintAuthorityKeypair);
``` 
this doesnt
weird thing is, 
``` 
const mintAuthorityKeypair: Keypair = Keypair.fromSecretKey(uintarray);
``` 
this works fine
nope, doesnt do the trick
What if you do Buffer.from instead of Uint8Array from
im pretty sure its some typescript / babel stuff. but i have no idea about babel, so looking for another function to do the job
yeah
Where does stuff actually break then? The `.fromSecretKey` part?
and modified some numbers
no solana on that
yh its a dev keypair, no worries 🤣
Careful about posting that!
my god
lmao
the array is taken from the `.config/solana/id.json` file
very dirty
```
const uintarray: Uint8Array = Uint8Array.from([  149,226,18,86,166,52,2,141,172,220,209,227,65,253,79,35,131,85,164,23,25,8,248,223,90,167,172,144,133,236,229,146,188,230,180,3,5,118,190,238,157,122,51,60,83,186,124,199,151,67,175,226,211,199,1,115,172,75,72,51,82,16,255,4
        ]) 
        const mintAuthorityKeypair: Keypair = Keypair.fromSecretKey(uintarray);
```
Seems to work fine for me, how are you getting the keypair?
`ts-ignore` doesnt seem to do all the job. neither does `@ts-expect-error`
was trying that for a couple hours before, keep getting this one
``` 
Unhandled Runtime Error
TypeError: Class constructor Blob cannot be invoked without 'new'

Source
src/qpools-sdk/splpasta/tx/token-instructions.ts (37:21) @ new PublicKeyLayout

  35 | 
  36 | 
> 37 | class PublicKeyLayout extends BufferLayout.Blob {
     |                     ^
  38 |   constructor(property) {
  39 |     super(32, property);
  40 |   }
```
Kind of annoying, you can do
```.ts
// @ts-ignore
const wallet = new anchor.Wallet(theKeypair);
```
all right
Sorry, can you post the actual log output though?
```
pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();
    let account = next_account_info(accounts_iter)?;
    let mut account_data = ProgramAccountInfo::try_from_slice(&account.data.borrow())?;
    if account.owner != program_id {
        msg!("Account does not have the correct program id");
        return Err(ProgramError::IncorrectProgramId);
    }
    let data_from_client = InstructionInfo::try_from_slice(instruction_data).unwrap();
    let is_deposit = data_from_client.is_deposit;
    if is_deposit {
        account_data.region = "BASEMENT".to_string();
    } else {
        account_data.region="00000000".to_string();
    }
    let instruction = Instruction {
        program_id: *program_id,
        accounts: vec![AccountMeta::new(*account.key, false)],
        data: ProgramAccountInfo::try_to_vec(&account_data).unwrap()
    };

    invoke(&instruction, accounts)?;
    Ok(())
}
```
That's my entire program, and input program_id and accounts is other program B's program ID and program B's account. so invoke supposed to invoke program B I assume...
ah got it.. yeah actually it started complaining about the following..
``` 

Module parse failed: Unexpected token (8:32)
You may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders
|  * Node only wallet.
|  */
>
``` 
will dig a bit deeper, seems uncommon
Ah, hmm, I guess this doesn't really work currently with typescript very well (it *is* exported but not in a typescript friendly way)
of course!
Can you post your entire program log? Much easier to debug that way
also NodeWallet is part of @project-serum/anchor? my editor cant seem to import this
again, did you try msg! macro? xD it gives you really good insights to place some logs between all function calls to understand if the program even runs until there. maybe im overseeing something obvious too tho
I think it was just a 🤷‍♂️ kind of decision tbh lol
got it, thank you, I guess my question is why mocha is the default, a few of my friends thought it's implied they should use it and so they kept using it
It does, but you can switch it out with 1 line
got it, I was under impression that it runs mocha by default
You can actually use whatever you want for tests, anchor doesn't really dictate anything (just switch out the command to run in your Anchor.toml file)
I updated my question, it does not contain for loop 🙂
nice, cheers! 🙂
Going the other direction is provided by the `NodeWallet` class (you just pass it a keypair as its one constructor argument)
can you provide some more logs? did you try debugging using `msg!()` macro, if the for loop runs etc.?
ah yeah that makes sense. but what about the other way around? that should technically work, no?
You in general can't convert a Wallet to a Keypair (for example, your phantom wallet will never ever leak your actual keypair)
hey folks, I wonder what informed using mocha vs jest by default? Is there anything we need to know if we plan to migrate?
I made custom Instruction
```
 let instruction = Instruction {
        program_id: *program_id,
        accounts: vec![AccountMeta::new(*account.key, false)],
        data: ProgramAccountInfo::try_to_vec(&account_data).unwrap()
    };
```
for invoke
```
    invoke(&instruction, accounts)?;
```
but it didn't invoke target program. May I know why?
any idea if there is a way to convert the `Keypair` type to the `Wallet` type? (and vice versa)? Having lots of troubles with these as I am moving between tests and the web-app
nice :)
It tries to be, yeah (not 100% perfectly typed, but it tries)
is anchor typescript friendly?
btw is there any way to get the source code of a program by providing its address ? or we just have to trust them ?
Ah i see...
But there's no solana rule that says the owning program needs a signature in order to mutate an account's data/spend its money
E.g. system_instruction::transfer definitely requires a signature, but that's only because it wouldn't make any sense otherwise
Yes. Signatures are 100% optional/up to the program logic.
so the program can change the data without even a signature from owner ?
ya but that's the usual way that's why we're keeping the keypair in react at the first place...
You can't currently resize accounts, but you apparently will be able to soon, in an upcoming release
did you ever figure this out? I ended up creating a new keypair (i.e. new account) also. But would like to know how to avoid breaking my programs and actually upgrading them
At the end of the day *only* an account's owning program can mutate its data (whether this requires a signature is up to the program)
Knowing the keypair for an account address doesn't necessarily mean they can change the data there (that's up to your program)
i mean anyone with access to they keypair can change the account data like changing someone else's gif...
i'm kinda new to react so i thought the keypair in the server would be accessible to anyone while react can access it as its a frontend framework
ty sir, I completely forgot to refetch
If it is just providing access to the programs within the account, your frontend is just a UI for that right? but I am not sure of all the implications
not sure lol
is it secure to store the keypair in json at frontend ?
didn't participate it it `:(` can we check it now ?
buildspace went over that in section3, gotta generate the keypair as json and reuse it, so u dont always generate new 1
when running `anchor build` I'm getting an error ```dyld: lazy symbol binding failed: Symbol not found: ____chkstk_darwin
  Referenced from: /Users/Tom/.rustup/toolchains/bpf/bin/cargo
  Expected in: /usr/lib/libSystem.B.dylib```
Debian?
Are there any WSL distros that support npm anchor or do you always have to build it?
What have you tried so far? You would just need to decide on an address for it and create it the way you create any other account
how should i create the single account ?
You would just pick a single account to store it in
i don't see any example for that : (
i mean i don't wan't each user to initialize an account to store the gif i just want to store the list in one account owned by the program
https://github.com/project-serum/anchor/blob/master/examples/tutorial/basic-1/programs/basic-1/src/lib.rs
how do i store `gifList` in one program account instead of initializing it in each `baseAccount` ?
Beastttt
<@!912046857000194158> randomly, here's an example of how you can access your program's upgrade authority at runtime: https://github.com/cqfd/anchor-upgradeable-loader


//////////////////////////////////////////////////////////////////////////////////////////

best i can find is `program.idl.errors`
i know it's in my IDL 🤔
So I can do things in JS like `assert.ok(txnError == ErrorCode.Overflow)`
How do I pull my program-defined #[error] enum into my test file?
ohhh interesting. Woulda never known that lol. Thanks!
The first one is probably the index of the instruction that errored (you can submit multiple instructions in a single tx)
<@!134416332509675520>  I found a way to pull the error from `simulate`: `simulationResult.value.err.InstructionError`
That command outputs an array of two elements:
```
0:0
1:{Custom: 167}
[[Prototype]]:Object
length:2
```

But what do each of those two values represent? Second one is the error code, but idk about the first
You'd have to do something like `seeds = [..., &[master_account.supply as u8]]`
Ok nice, then 255 will do for now 😄
Yep, with a u8 there's only ever one byte, so don't have to decide how to interpret multiple bytes
So if I change to u8 I don't need to worry about the endians?
Great info, thanks a lot for the help 🙏
Way simpler if you can only ever have 0-255 for the total supply 😉
But you could just as easily have the opposite convention (little-endian): "123" = 1 x 10^0 + 2 x 10^1 + 3 x 10^2 = 321 in big-endian
spent like 2 hours yesterday transforming strings into like 8 different variations
E.g. decimal numbers are implicitly big-endian, 123 == 1 x 10^2 + 2 x 10^1 + 3 x 10^0
You suffer through it like the rest of us lmao
ok, back to CS 101 for me hehehe
Mm, not sure where to read about them, besides like wikipedia—the issue is just that as soon as a number would take up more than 1 byte you have to decide what order to write the bytes in
I'm a JS dev. Where do I learn about these concepts like endian bytes? Does Rust lang documentation cover whats relevant?
ah I see
You just have to be careful to serialize the 8 little-endian bytes in the same way as you do it on the rust side
And then from the JS side it's a tiny bit annoying,
```.js
const supply = new anchor.BN(1000); // or whatever
supply.toArrayLike(Buffer, 'le', 8)
```
Ok, could do e.g. `seeds = [..., master_account.supply..to_le_bytes().as_ref()]`
i.e. if supply is at 10, I can find PDA for each account 1 - 10 and get data for each.
Basically, I want to be able to check the supply of the "master" so that I can then query every "puppet" account
Yeah u64
`master_account.supply` is presumably a u64, so you need to decide on an endianness when converting to bytes
What datatype are you using for the edition?
Using numbers as seeds is actually slightly awkward, since you need to decide how to convert them to bytes
Not sure if that makes sense, or would I just increment bump?
Perhaps something like:
seeds = [b"puppet".as_ref(), master_account.key().as_ref(), master_account.supply]
Not sure how to pass the edition number
Something like:
seeds = [b"puppet".as_ref(), master_account.key().as_ref(), ...?]
I would like to derive a PDA with master account key + "puppet" + puppet number (i.e edition)
Great example thanks
I don't know of a tutorial off-hand, but this escrow program has a bunch of them: https://github.com/cqfd/quidproquo
Are there any tutorials you can recommend on doing CPI with PDAs?
as a short follow up, to use structs in other programs, you'd have to import it as a crate then from the crate?
ohh interesting
Or in examples/basic-3 in the anchor source
https://project-serum.github.io/anchor/tutorials/tutorial-3.html#defining-a-puppet-program
i cant find online
where is that tutorial?
But yeah, you often have accounts under your program's control and hence need to allocate/initalize/create them etc.
Nope, no standard methods in solana—everything is up to whatever your program is doing
Beginner question here 👋 
Is initialize some kind of standard method? Is it required? I see most of the examples implement this...
You would have one program depend on the other's source code, e.g. check out the basic-3 anchor tutorial
how would you deserialize it then?
Gotcha, I see. Thanks alan 👌
Mm, they would both be able to *deserialize* it, but both doing `Account<'info, Vault>` wouldn't work since that also checks for program ownership
<@!691933164909756466>
say I had a vault struct in program A,

```#[account]
pub struct Vault{
  pub storage: u64,
}```

and i copy and pasted that into program B. would both be able to read the storage field?
Mm... what do you mean? Deserialization is just deserialization, so I assume the answer is yes but I'm not quite sure what you're asking
can two programs deserialize the same Account struct if its defined in both programs?
And for 2. I often check for specific error codes.
At any rate for 1. I don't think switching test frameworks will help, you'd just have to do something where after each test you restart the validator with a fresh state
1. This is unfortunately more of an issue with the test validator itself (e.g. in a normal web backend testing situation you run each test in its own little transaction and then roll it back after test completion—I'm not sure the test validator exposes an easy way to do that)
2. Not sure, I never actually use the simulation feature in tests, I just run it for real
<@!134416332509675520> 
I have two concerns about the current testing framework that anchor is using:
**1. Unit tests aren't siloed.** Modifying state in one unit test also modifies the next. Are there any alternatives you recommend instead of mocha?
**2.  program.provider.simulate masks errors.** When I expect an error, I just do `assert.notEqual(res.value.err, null);`. But this doesn't actually check if the error was caused by what I expected it to be. Are there any altneratives?
kek 🙂
Honestly not sure how you could have done that though lol 😛
Sounds like you didn't do the associated token part correctly, hmm

Can you show the actual program log? Easier to look at than the js stack trace
```.rs
#[derive(Accounts)]
pub struct DoTheTransfer<'info> {
  #[account(mut)]
  pub source: Signer<'info>,

  #[account(mut)]
  pub destination: AccountInfo<'info>
}
```
<@!134416332509675520> sir, sorry to bother again. Does this have to do with the bump (I don't know what it is yet). Happens after I use the correct method to create an account
No, can't use that, you have to pass their address in as an account
If you already know B's address then it's not clear to me at all why you need your own program to do this

Just pass their address in as an account from the client
Ok, then you know their account info 🙂
i dont hv the struct
ik their address
If you don't know their address?
Then how will you later enforce that B and only B can withdraw it?
i dont hv their account info
Why not just send it directly to B?
withdraw function allows user B to claim the sol
.
like if i store the sol in system program
Which withdraw function?
i think i cn make it using the withdraw function
Not possible in solana—tbh I think you should probably downshift and work through the anchor tutorials, the task you're working on now will be tough until you understand solana/anchor a bit better
how do i send sol to account whose account info struct i dont hv
i presume its senders/signers account
Yeah, so that's just some account, not your program itself etc.
Thanks a bunch!
No IDL (it's not an anchor program), just use that instruction builder and have it run before your actual rpc call
Gotcha, thank you very much! Do you think I can get idl for AssociatedToken account and just do an rpc call? Rpc calls feel so straightforward
`spl.Token.createAssociatedTokenAccountInstruction`
```#[derive(Accounts)]
pub struct SenderContext<'info> {
    #[account(mut)]
    pub base_account: Account<'info, BaseAccount>,
    pub msg_sender: Signer<'info>,
}```
You'd have to look at the `SenderContext` struct to see what it means
Yeah, "base account" is just what you've happened to name one of the accounts, it doesn't mean anything by itself
```rust
pub fn send_sol(ctx: Context<SenderContext>, amount: u64) -> ProgramResult {
        let base_account = &mut ctx.accounts.base_account;
        let msg_sender = ctx.accounts.msg_sender.key();

        for split in base_account.splits.iter() {
            let split_percentage = Percentage::from(split.percentage);
            let split_amount = split_percentage.apply_to(amount);

            // let ix = anchor_lang::solana_program::system_instruction::transfer(
            //     &msg_sender,
            //     &split.address,
            //     split_amount,
            // );
            
           let ix = anchor_lang::solana_program::system_instruction::transfer(
                &msg_sender,
                &split.address,
                split_amount,
            );

            anchor_lang::solana_program::program::invoke(
                &ix,
                &[
                    ctx.accounts.from.to_account_info(),
                    ctx.accounts.to.to_account_info(),
            
                ]
            )
        }

        Ok(())
    }``` this is my code
Pretty sure there's already a helper function to do this for you though
You need to instead send an instruction to the associated token program asking it to create the account for you (you can't do it yourself)
Ok, yeah, that call to `createAccount` won't work, you can't sign for that PDA from the client (it's impossible to sign for PDAs from the client—only their deriving programs can sign for them)
so a bypass method is storing it in contract
like im trying to calculate sol value then send it from to person but i dont have Account info struct of that person who ive to send to
```
const nft = new Token(
        connection,
        mint,
        TOKEN_PROGRAM_ID,
        provider
      )

      const rent = await connection.getMinimumBalanceForRentExemption(
        MintLayout.span
      );

      const toTokenAccount = await Token.getAssociatedTokenAddress(
        ASSOCIATED_TOKEN_PROGRAM_ID, 
        TOKEN_PROGRAM_ID, 
        mint, 
        receiver
      )

      const toTokenAccountInfo = await provider.connection.getAccountInfo(toTokenAccount);

      if (toTokenAccountInfo == null) {
        const instruction = anchor.web3.SystemProgram.createAccount({
          fromPubkey: provider.wallet.publicKey,
          newAccountPubkey: toTokenAccount,
          space: MintLayout.span,
          lamports: rent,
          programId: TOKEN_PROGRAM_ID,
        })
        
        const trans = await setWalletTransaction(instruction)

        const signature = await signAndSend(provider, trans)
```
And the function to set instruction to the wallet is

```
const setWalletTransaction = async (instruction) => {
    const provider = getProvider();
    const transaction = new Transaction();
    transaction.add(instruction);
    transaction.feePayer = provider.wallet.publicKey;
    let hash = await provider.connection.getRecentBlockhash();
    console.log("blockhash", hash);
    transaction.recentBlockhash = hash.blockhash;
    return transaction;
  }
```
<@!134416332509675520>
Where did you get the term "base account" from though?
or is there a direct method to do this
user A send sol to contract, user B withdraws it from contract
Can you post some code?
im creating a withdraw function
"base account" isn't an independently meaningful term in solana as far as I know, you'll have to say more about what you're doing
is it the account of the contract
Guys what is base account
Yessir, blz gib me a second
Can you post the code you're running?
It's not enough to just find the address
But creating an associated token account requires invoking the associated token program
I think that might not be the actual error you're getting—are you also signing for the owner of the *source* tokens?
Yessir, I can’t understand how can a token acconunt sign, since I don’t have a key pair for it. So, I can derive the associated token address, but I don’t have any additional data to create the account. I know I should be able to crate an associatd account for someone else, but I don’t understand how that new account can sign.

In my mental model? The only available signer is my Keypair stored in phantom
Basically google 😬
in the IDL there are some error numbers but they only go from 300-310
and how can I try to find its source code?
It's raising an error but there's no way to tell why, it will depend on what that program is doing (just have to go source-diving)
Ok, you'll unfortunately have to go find that program's source and go see if you can find its custom error enum
I'm trying to understand how everything in this space works as I'm new
no it's not I'm trying to interact with
Ok, cool, is MEisE1HzehtrDpAAT8PnLHjpSSkRYakotTuJRPjTpo8 your program?
If it's an associated token account then you yourself don't need to sign for it (the associated token program will sign for it, since the address is one of its PDAs)
Here's the full output: 

```solana.rpc.core.RPCException: {'code': -32002, 'message': 'Transaction simulation failed: Error processing Instruction 0: custom program error: 0x3f', 'data': {'accounts': None, 'err': {'InstructionError': [0, {'Custom': 63}]}, 'logs': ['Program MEisE1HzehtrDpAAT8PnLHjpSSkRYakotTuJRPjTpo8 invoke [1]', 'Program log: Custom program error: 0x3f', 'Program MEisE1HzehtrDpAAT8PnLHjpSSkRYakotTuJRPjTpo8 consumed 17673 of 200000 compute units', 'Program MEisE1HzehtrDpAAT8PnLHjpSSkRYakotTuJRPjTpo8 failed: custom program error: 0x3f']}}```
So it's not the recipient that needs to sign, it's the token account's own address
What address does it live at? That address will need to sign
So you're creating a token account?
The issue here is that I don't have idl, I'm trying to send an SPL token and sign the tx with phantom. So, I need to create an account first. Logically, there's no one on the other end, so how can I sign for them?

Since associated accts are deterministic, I can't generate a keypair for a specific acct, right?
Usually people forget to sign with the keypair of an account they're about to create
You can see which one by opening up your idl file in `target/idl` and checking which accounts are ostensibly supposed to sign
You aren't signing the tx with some account that needs to sign
<@!134416332509675520> hello sir, happy NY! do you know why I get this all the time?
You may be able to see more information in the full program log
In general you'd have to think through the code you're invoking and see where it can return an error code
We would need to know way more about what you're doing—what program are you invoking? That error is just a number, so there's no way to tell what program it came from etc.
What do you mean with  type of program?
The program keypair itself is just used for deploying (the public half is the program's program_id)
No, it's your `~/.config/solana/id.json` probably
Who is `program.provider.wallet`? I thought it was the keypair of the program right
I don't think there's enough information there to tell—what kind of program are you invoking etc.?
Anyone?
There might be some testing api to initiate a fake account, not sure though
In this case, *only* your program can sign for that address ==> only your program can control the mint
Mint authority always works the same way: the mint authority needs to sign
I wish there was some testing framework that allowed some "superuser" to perform those types of actions
😦
Right, then you can't mintTo from the client, only from within your own program
```
#[account(
        init,
        payer = payer,
        seeds = [b"mint", mint.key().as_ref(), payer.key().as_ref()],
        bump = mint_bump,
        mint::decimals = 9,
        mint::authority = mint, 
        mint::freeze_authority = mint,  
    )]
    pub mint: Account<'info, Mint>,
```
This is the original mint I created through the program
You have to ask your program to please do it
If that address is a program-derived address derived from your program (~"your program owns the mint") then you can't do it from the client
Hello you all ! I am currently building a program using the Anchor framework. To test this program, I need to generate some NFTs. As the Metadata program doesn't exist in the local validator, I made a release build of it and used Amman to load the Metadata program. In my test, when I try to send the CreateMetadata transaction with sendAndConfirmTransaction, I've got these two errors:

Transaction simulation failed: Error processing Instruction 0: invalid account data for instruction
ELF error: Incompatible ELF: wrong machine

As I double checked from the data, I think that the issue has to be with the ELF error in the first case.
But I don't know how to solve this elf error. The program is deployed, I can see it with the explorer or with getAccountInfo.

Is it the right way to write js tests that deals with NFTs ?
What do you mean by your program owns? You need to specifically pass the keypair of the *address* that has authority over th eaccount
```
mint.mintTo(
   vault,
   owner: ????????,
   [],
   100,
)
```
My program owns `mint`. For the second parameter, I need to pass the program somehow. What should I put for the second parameter?
.
Hey, how can I know what is this error? 

`solana.rpc.core.RPCException: {'code': -32002, 'message': 'Transaction simulation failed: Error processing Instruction 0: custom program error: 0x3f', 'data': {'accounts': None, 'err': {'InstructionError': [0, {'Custom': 63}]}`

(this only happens when I use the anchorpy module, with the JS one everything goes through perfectly)
Could you unpack this please, sir? I'm trying to create an SPL token acct to transfer FNT, but I get `Error: Signature verification failed`
Would the following code be valid??
```
    // the token account of owner
    #[account(
        init,
        payer = owner,
        associated_token::mint = mint,
        associated_token::authority = owner,
    )]
    owner_token_account: Account<'info, token::TokenAccount>,
```

I'm trying to do this later in the instruction, 
```
let seeds = &[&AUTH_PDA_SEED[..], &[_auth_pda_bump]];
// cpi call to mint 1 token to owner
        let cpi_accounts = token::MintTo {
            mint: ctx.accounts.mint.to_account_info(),
            to: ctx.accounts.owner_token_account.to_account_info(),
            authority: ctx.accounts.auth_pda.to_account_info()
        };
        let cpi_program = ctx.accounts.token_program.to_account_info();
        token::mint_to(CpiContext::new_with_signer(cpi_program, cpi_accounts, &[&seeds[..]]), 1)?;
```

But I am getting this error, 
`'Program 2HHQPmSdaRfhb5vVragacdGhcXFbT3e6cS4ei56J3ZLa failed: Cross-program invocation with unauthorized signer or writable account'`
Hello guys, happy NY! Is there any straightforward way to send an SPL token using Anchor in conjunction with Phantom? I've spent 2 days googling, feel ded...

Trying to do it like this

```
const nft = new Token(
            connection,
            mint,
            TOKEN_PROGRAM_ID,
            wallet
        )
```
And then `const toTokenAccount = await nft.getOrCreateAssociatedAccountInfo(receiver);` to create an associated account first.

The issue with that is the `wallet` argument has to be of specific type. Otherwise, SPL library can't get public key. I tried many different ways of passing `wallet`, but I think I need to do something completely different, like first creating a tx and then signing it with Phantom. Am I right?

But if that's the case, then I'm breaking the original flow of `getOrCreateAssociatedAccountInfo()` function, which creates and associated acct if it doesn't exist, but returns an acc if it exists.

I could've rewritten all the functions from the lib to accomodate for my case, but it feels like I'm just moving in the wrong direction and the answer is much simpler.
theyre not derived
How are token accounts derived then?

I am aware that AssociatedTokenAccounts can be derived as follows, 
```
  const getAssociatedTokenAccountAddress = async (
    owner: PublicKey,
    mint: PublicKey
  ) => {
    return (
      await PublicKey.findProgramAddress(
        [owner.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mint.toBuffer()],
        ASSOCIATED_TOKEN_PROGRAM_ID
      )
    )[0];
  };
```
can be useful for programs
Why would we allow a user to have multiple token accounts then?
clarification: ONE associated token account per mint
yes. (a user can ofc have multiple wallets which can each have ONE associated token account)
Does this mean a user can have multiple Token Accounts and only ONE Associated Token Account?
I'm a little confused about the Account Constraints `token` and `associated_token`. What is the use case for each?
https://spl.solana.com/associated-token-account#motivation
Is there a difference between Token Accounts and Associated Token Accounts?
Okay, ill try it out
think you can omit the authorities, not 100% sure tho
Thanks!
```
#[account(init, payer = authority, mint::authority = authority, mint::decimals = 9, mint::freeze_authority = authority)
pub mint: Account<'info, Mint>
```
My use case is something like a social platform, where a user can create his/her own community token
Is there a way I could create an account and initialize it as a Mint through the Account Constraints? Or do I have to create it in a separate instruction? Or maybe a CPI?
dont think so. am currently writing some
Is there any documentation for Account Constraints such as,
```
token::mint = mint,
token::authority = owner,
```
Does it serialize and deserialize properly
Can they access the same data?
If I have the same struct/Account across two programs
how can I search it? do you remember any keywords?
tough question, I think it was asked in the discord before, but cant remember the answer
Hello, Is there any anchor web3 API which fetches all program's data account at once???
For those who want to test anchor with jest -> This is working example
```
ANCHOR_PROVIDER_URL=https://solana-api.projectserum.com ANCHOR_WALLET=~/.config/solana/id.json ./node_modules/.bin/jest -i tests/**.*
```
Thanks!
I found it, no need to answer it
I want to find default values when I run ```anchor test``` command
where can I find ANCHOR_PROVIDER_URL and other const variables?
it works
Thanks bro!
run the same command, but with `ANCHOR_WALLET=~/.config/solana/id.json npm run ...` . its probably not able to find your environment variables, which includes your local walllet
Can you guys tell me what caused this? I simply ran jest -i tests/**.*
Hello, I'm trying to test anchor project with jest.
and I'm facing this error:
```
TypeError [ERR_INVALID_ARG_TYPE]: The "path" argument must be of type string or an instance of Buffer or URL. Received undefined
```
I don't know why I'm getting this such a thing...
(i.e. when you execute a multisig transaction, can that only execute a single instruction)
can you only provide single instructions to the anchor multisig? seems like transaction only holds the info for a single `Instruction`
In this case, signers: [myAccount] but not [user]?

Does someone know why we usually pass the pubkey of created account instead of the one of Signer type at signers:[..] argument when we call the instruction?
SPLToken.NATIVE_MINT is SOLs mint right?
Is the "owner" of the TokenAccount the Token program, and the "authority" the user?
`Error: Signature verification failed`
```
await accrueMintToken.burn(
  userProgramTokenAccount,
  user.publicKey,
  [],
  10,
);
```
Hmm it still isn't working
The program has authority of the mint that created userProgramTokenAccount
But the account is an associated account from the address of the user
The authority over the token account has to sign off on getting some of their tokens burnt
Who is the authority over the userProgramTokenAccount?
```
await programToken.burn(
      userProgramTokenAccount,
      owner???,
      [],
      10,
    );
```
In my JS tests, how do I make my program sign for the txn to burn tokens?
You might be called `program.rpc. ..` 
Looks like `program` is undefined here.
Hey folks, beginner here trying to run `anchor test` but receive this error where the workspace can't find `.rpc`
ah I know why, I was looking in the wrong place https://docs.rs/solana-program/1.4.4/solana_program/pubkey/struct.Pubkey.html#method.from_str
ty
I had looked through docs for a `to_str` for too long, honestly I don't know how I missed it here https://docs.rs/anchor-lang/0.13.2/anchor_lang/prelude/struct.Pubkey.html but sure enough, `to_string` is there
`to_string().as_str()` works
Think you can just do `&ctx.accounts.provided_gear_mint.key().to_string()`
I'm trying to create an SPL token (https://openquest.xyz/quest/solana-my-money)
Is there a way to pass my own metadata to the token? e.g. mint a new Token, and pass an Arweave link to the Token as metadata?
Is there a cleaner way to write this conversion of Pubkey->str_array? I'm still quite new to rust and this seems heavy-handed, but I think it is valid

```
const GEAR_MINTS: [&str; 1] = ["kithbUj3JCAJYFU7A1vcMAhDdvQ8EheWSCkRwkhLj2s"];
...
if !crate::GEAR_MINTS.contains(
    &std::str::from_utf8(
        &ctx.accounts.provided_gear_mint.key().to_bytes()
    ).unwrap(),
) {
    return Err(ErrorCode::BadMintProvided.into());
}```
All good!
Damn. That worked! Thanks alan 😭 Such a noob mistake.
If you know it won't be null/undefined you can stick a `!` after it
That sounds like it's saying that the public key you're passing might (at least statically) be null/undefined for some reason, but at runtime it isn't (so it works fine)
` Type 'PublicKey | null | undefined' is not assignable to type 'Address | Accounts<never>'.` This is the error it throws
using the IDL from `target/types`
Using `// @ts-ignore` lets the instruction call pass and succeed as well in the frontend 
So looks like the type check is the only thing failing.
Trying to call some instruction say `program.rpc.instructionName()` with the correct args and accounts fails with type checks.
While the same call written as anchor test passess and it doesn't complain?
Does types work in anchor? I am trying to use `target/types` from the frontend.
Option three is the simplest (if you really want to change those mints you can always just redeploy)
(For really big integers, aka anything over 2^53, you need to use quotes like that since JS doubles can't necessarily represent them)
No, a BN is an arbitrarily big integer, e.g.
```.js
new anchor.BN("999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999")
```
not sure that's a good question
So like option 3 but I hardcode an enum into my program. Can an enum be referenced as a `constraint` (like option 1) or would I still do it during program execution like in option 2?
use an enum
Hey, another question regarding constraints and security.
I have an ix that passes the following: 
```    #[account(mut, constraint = provided_gear_pda.mint == provided_gear_mint.key())]
    pub provided_gear_pda: Box<Account<'info, TokenAccount>>,
    pub provided_gear_mint: Box<Account<'info, Mint>>,```
now, `provided_gear_mint` is allowed to be one of three specifically whitelisted mints. This will be the case for the entire lifetime of the program, but it can be any of those three types in any transaction being made.

What is the best way to enforce that? I have a few ideas. 

Option One involves storing the whitelisted mint Pubkeys in a state account array, and using that account like (pseudocode) `constraint = state_account.whitelisted_gear.contains(provided_gear_mint.key())`.  Not sure if that's feasible.

Option Two involves not using `constraint`, but then in my actual processing doing essentially the same check of `state_account.whitelisted_gear.contains(...)` and erroring out on a failure.

Option Three, I'm also aware that I could effectively hardcode the mint Pubkeys in my program itself rather than storing in state, and error out in the same way as Option Two. 

Any thoughts/better options?
- Is `anchor.BN` the equivalent of rust's `u64`?
- How can I get the maximum value of `anchor.BN`?
ah gotcha, nice! thank you 🙂
(which are implemented via msg!)
It listens to `emit!` statements
https://project-serum.github.io/anchor/ts/classes/Program.html#addEventListener
what does it listen to? msg!() statements?
anchor has an event listener api
what's the solana way to "subscribe" to events that is supported in EVM?
It`s alive, thank you very much!
Wow! I did not know about order. Thank you. Need to read doc carefully. Thank you I will try and write back!
You've accidentally flipped the order of your `#[instruction(...)]` arguments (they need to match the actual instruction function itself)
I'm a noob too but I think your system_program and token_program lines are wrong. Should be `Program<'info, System>` and `Program<'info, Token>` where Token comes from `anchor_spl::token::{Token}`
Hey, guys! I have such a code to create internal token vault but it is failed on step when creating token account. It fails with error  `Cross-program invocation with unauthorized signer or writable account` and I could not figure out what is wrong. Decided to ask here. Thanks in advance for answers!

```

// Just an empty method for now
pub fn deposit(ctx: Context<Deposit>, to_bump: u8, amount: u64) -> ProgramResult {
     Ok(())
}

//.....

#[derive(Accounts)]
#[instruction(amount: u64, to_bump: u8)]
pub struct Deposit<'info> {
    #[account(mut, constraint = from.amount < amount @ ErrorCode::DepositAmountToHigh)]
    pub from: Account<'info, TokenAccount>,
    #[account(init,
              seeds = [b"tokenkey".as_ref()],
              bump = to_bump,
              payer = authority,
              token::mint = mint,
              token::authority = authority)]
    pub to: Account<'info, TokenAccount>,
    #[account(mut, signer)]
    pub authority: AccountInfo<'info>,
    pub system_program: AccountInfo<'info>,
    pub token_program: AccountInfo<'info>,
    pub rent: Sysvar<'info, Rent>,
    #[account(mut)]
    pub mint: Account<'info, Mint>,
}
```
> (why use a PDA derived from some other program when you can use one of your own) 
Yea, my original mindset was "because that's the standard practice" - but it's standard for _users_ to use the associated_account program, not standard for programs to use it. Awesome.
yea that makes total sense to me now. Thanks!
Yeah, that's my suggestion. The purpose of associated token accounts in my mind is to give you an obvious address at which to store some tokens. For a program though, you might *already* have an obvious address to store those tokens (some PDA derived from your own program), in which case no need to use the associated token program (why use a PDA derived from some other program when you can use one of your own)
Not an identical instruction, no (so another hacky way around this is to just add an instruction argument that you change between calls, just so the instruction isn't identical)
so:
for a user that wants to hold `tokenA`, they need their own associated token account for `tokenA` to hold it. This is for standardization, so the user doesn't accidentally get multiple token accounts for `tokenA` by mistake. It's not technically necessary to use associated tokens here, but it's best practice.

for a program that wants to hold `tokenA`,  I figured it would be similar for similar reasons. But your suggestion is to instead make a PDA for `tokenA` (using e.g. `token::mint = tokenA_mint`), NOT making use of the associated account program, this way the program maintains the ability to "sign" for the account.

Do I have that right?
Can you send the same instruction call more than once on the same block and get a parallel procesing?
I'm actually not sure the cleanest way to wait for a fresh blockhash
Dumbest thing you can do is sleep for a bit 😛
Another begginers question, I'm running multiple rpc call with the same instruction and I'm getting this error. Is there a way to increase the nonce of the transaction for avoiding this error? I'm running this multiple times:
`  it("Creates a new Fibonacci term", async () => {

    await program.rpc.newTerm({
      accounts: {
        fibonacci: fibonacci.publicKey,
      },
    });

    const account = await program.account.fibonacci.fetch(fibonacci.publicKey);
    console.log(account.current)

    assert.ok(account.current.eq(new anchor.BN(3)))
  });`
They're useful for a particular situation that doesn't apply in this case
I would honestly suggest forgetting about associated token accounts for now
hm....trying to piece this together now
If you want a token account controlled by your own program, its authority will need to be a program-derived address derived from your own program
ah right, I recall reading how the associated token account itself is used to derive associated accounts
Hence your program can't sign for it
The address here is an associated token address, which is derived from a totally different program
That trick only works if the address is derived from *your* program
Ah, no
You can just have any old token account whose authority is a PDA derived from your program
`tokenA_account` was supposed to be `tokenA_associated_account` - which I believe is the standard way to assign authority for these (authority is set to the account itself since its a PDA)
If all you want is a token account controlled by your program, you don't need to use an associated token account
oh crap that was a typo
Mm, what is `tokenA_account` here? A PDA derived from your program?
so tokenA is some token that my program works with, the program would have an associated account  (_for_ `tokenA`) already initialized and likely holding some `tokenA`. The user may be receiving some `tokenA` from the program in this transaction
Why would the program have an associated token account? What do you mean by that?
the program's associated account for `tokenA`
I'm having a hard time parsing that
(That reads funny to me though—why is tokenA_account the owner of some associated tokens?)
That says this had better be tokenA_account's (associated) token account for holding tokenA_mint tokens.
What do you mean by the associated account of the program?
which it will fail _at that point_ if a user didn't provide the exact assoc. account required (the one derived from the program)
And defining it this way just means the transaction will fail if `tokenA_associated_account` isn't an associated account of the provided mint...it doesn't mean it's necessarily the associated account of the program. But that part comes into play when later do `CpiContext::new_with_signer` to transfer from/to that account
Yep
Just to clarify: the only thing special about an associated token account is its address (PDA derived from the associated token program); the account itself is just a token account.
Gotcha. So I can just do:
``` #[account( 
        mut,
        associated_token::mint = tokenA_mint,
        associated_token::authority = tokenA_account,
    )]
    pub tokenA_associated_account: Box<Account<'info, TokenAccount>>,
```
No, associated token accounts automatically live at program-derived addresses derived from the associated token program—you don't get to pick their seeds/bump, because they're automatically based on the token owner + mint.
I think I'm confusing myself. If I'm providing the account in an ix for an "associated token account" that my program owns, does that require seed/bump? I know normally PDAs require seeds and bumps, but what about a PDA that is of an associated token account for the program?
Can a PDA even be an associated token account?
```
    #[account( 
        mut,
        associated_token::mint = tokenA_mint,
        associated_token::authority = tokenA_account,
        seeds = [b"tokenA"],
        bump = tokenA_token_bump, 
    )]
    pub tokenA_associated_account: Box<Account<'info, TokenAccount>>,
```
I don't think seed/bump applies here
thank you
I would update it (1.8.0 is also kind of old now)
Something is wrong with your solana install unfortunately
Hello guys I pretty new I was using anchor fine on my mac when I switched to a windows laptop I keep getting this error i cant seem to know the issue pls help

Not sure why `msg!` wouldn't work (that's the normal way to log)
How can I log to stdout? Inside my program I log `msg!("hello world!");` but it does not show up in the Solana logs. My rust logs are set as, `export RUST_LOG=solana_runtime::system_instruction_processor=trace,solana_runtime::message_processor=info,solana_bpf_loader=debug,solana_rbpf=debug`


//////////////////////////////////////////////////////////////////////////////////////////

I don't have any examples off hand, but there are web3 helper functions for making the instructions, e.g. `anchor.web3.Ed25519Program.createInstructionWithPrivateKey`
REEEE
ahh
it is working now
Idk
<:room_temp_iq:797341877111095316>
What do you mean? declare_id! needs to be the address your program is deployed to 🤔
REEE REEE MCGEEE
I dummy, declare_id! needs the address of the wallet I using
classic response of any examples of how to do this?
Interestingly, no, seems you have to invoke it as a separate instruction: https://discord.com/channels/889577356681945098/889702325231427584/908493345079328799
I think that means you don't have yarn installed (npm install -g yarn)
Has anyone ever gotten this error "Error: failed to send transaction: invalid transaction: Transaction failed to sanitize accounts offsets correctly"? I'm literally just trying to run the out of the box example 😦
would appreciate any help
> anchor init testsolanaapp --javascript
Error: yarn install failed: The system cannot find the file specified. (os error 2)
> anchor --version
anchor-cli 0.18.2
> node --version
v12.14.1
> rustc --version
rustc 1.57.0 (f1edd0429 2021-11-29)
> yarn --version
1.22.17
hey guys trying to learn solana following these https://dev.to/dabit3/the-complete-guide-to-full-stack-solana-development-with-react-anchor-rust-and-phantom-3291 and i was able to install the dependencies correctly. however i keep running into this error when i try to run anchor init
hey, how did you use verify? can you just do a cpi call as here? https://github.com/project-serum/anchor/blob/master/examples/tutorial/basic-3/programs/puppet-master/src/lib.rs#L13-L18
Hey this is my idl: https://pastebin.com/aUqSRfFA

I haven't changed anything but I'm not too familiar with it, not sure if there's any issues with it
is `default()` instruction a way to catch any instruction calls that aren't mentioned above?

I've seen jet has it, but unsure if "default" actually means anything to anchor

https://github.com/jet-lab/jet-v1/blob/master/programs/jet/src/lib.rs#L168
the bot basically won't know which one is valid
yeah but let's say another program invokes my program while emitting a similar event that has same discriminator. In my bot how would I know which one is which ?
Not sure I follow, you should be fine. Even if it's CPI your program still follows the same rules?
You got the link in <#889577356681945101>
That's not an issue, but I'm worried about illicit program logs that might interfere, for example a user calls my program from their program and emit a program log with similar discriminator <@!248066053161222144>
On the ancho repo??
Just have to scrape the program logs after the fact by going through old transaction signatures
There is none
<@!248066053161222144> what's the best way to listen to events emitted by a program using program logs ?
But yeh, I dunno, just got to read a lot more
And you can pass in space via instructions
If onchain then you can use `init` but it has to be a PDA
If off chain, then you set the space in the client and use the `zero` constraint token
You can create an account on chain or off chain
You should try to look at the examples in anchor test repo
Yeh you're mixing up a lot of stuff here
My intention was to defined the space through client like this
```
await program.rpc.createPost({
account: {
post: post.publicKey,
        user: provider.wallet.publicKey,
      systemProgram: SystemProgram.programId,
space: 150 <-- defined 
}
})
```
the code IDE throws error like this
```
cannot find type `u256` in this scope
not found in this scope
```
eh sorry, I mean like this
```
#[derive(Accounts)]
pub struct CreatePost<'info> {
    #[account(init,payer=user,space=9000)]
    pub post: Account<'info, Post>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub space: u256,
    pub system_program: Program<'info, System>,
}
```
Because init is just for PDAs now
I think you need `zero` instead of init maybe
Oh
Assuming space is defined somewhere else
It all looks fine
Which part are you uncertain about?
Hi, wanted to ask. Can we do this?
```
#[derive(Accounts)]
pub struct CreateTag<'info> {
    #[account(init,payer = user, space = space)]
    pub tag: Account<'info, Tag>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```
There is an updated version of ido pool there already
Have you looked in anchor/tests
Lol, would love to know what actually ended up being the fix in terms of the validator code. Very weird error.
also if anyone has any better examples of liquidity pools programs
the only changes that i've made for this contract is the `CpiAccount` struct with the new `Account` struct that changed on the latest version, and the directive for the account that is `#[account(init)]` on the program and i just added the fee payer to be there...
Hey guys any one knows what is causing this issue i'm following this program over here
https://github.com/blockworks-foundation/ido-pool
and re-adding tests to the latest anchor version so i can build my program on top of it and when i'm initializing the pool i got this error over here:
```
Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 1: custom program error: 0x0
```
lol amazing - just git pull, rebuilding solana-test-validator fixed it 😅
I cant seam to find any examples of testing within the rust code?
ha nice I just found that one.
https://github.com/jet-lab/jet-v1
Hey guys, whats a great codebase to look at and get a feel for a full system built in anchor?
is there an instruction without a name? did you modify it manually maybe?
what does your idl look like?
Hey guys have been having this issue for a while now. Would appreciate any help I can get.
Hey guys i have a quick question about my tests with anchor i got this error from the solana library but idk how to track those:
```
Transaction simulation failed: Error processing Instruction 1: custom program error: 0xa2
logs: [
    'Program 11111111111111111111111111111111 invoke [1]',
    'Program 11111111111111111111111111111111 success',
    'Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS invoke [1]',
    'Program log: Custom program error: 0xa2',
    'Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS consumed 4694 of 200000 compute units',
    'Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS failed: custom program error: 0xa2'
  ]
Program Error: 8 byte discriminator did not match what was expected
error: {
  code: 162,
  msg: '8 byte discriminator did not match what was expected'
}
```
I'm updating the address in lib.rs and Anchor.toml
just tried to create a new solana keygen and a new keypair for the target/deploy
Hey guys, how you're doing?
I have a problem with my rust program....

I created a program after some tries with a test one... and now after `build and deploy` I have a error message saying  the bellow message when I run `anchor test`... can you please help me to solve that?

```
ProgramError: 167: The given account is not owned by the executing program
    at Function.parse (/Users/lucassilveira/Developer/SOLANA/PROGRAMS/gifs/node_modules/@project-serum/anchor/dist/cjs/error.js:40:20)
    at Object.rpc [as initialize] (/Users/lucassilveira/Developer/SOLANA/PROGRAMS/gifs/node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:16:58)
    at processTicksAndRejections (internal/process/task_queues.js:95:5)
    at async main (/Users/lucassilveira/Developer/SOLANA/PROGRAMS/gifs/tests/gifs.js:12:12)
    at async runMain (/Users/lucassilveira/Developer/SOLANA/PROGRAMS/gifs/tests/gifs.js:61:5) {
  code: 167,
  msg: 'The given account is not owned by the executing program'```
I saw this was asked before but there wasn't any solution: https://discord.com/channels/889577356681945098/889702325231427584/905091429376868362

Question. My localhost phantom wallet shows a spinning wheel, so I'm unable to view balances, etc. I'm able to approve transactions however which is weird. The validator is running. Any ideas ?
can you share that repository?
Dang I had just left my computer. Thanks for helping though that’s a good suggestion about adding logs. I think 1.9.0, is that what you’re on (on M1 I think I saw you say that earlier)
Well, if you're building solana from source you could always add some additional logs to the solana source: https://github.com/solana-labs/solana/blob/master/program-runtime/src/pre_account.rs#L58
What does the `--version` say? 1.9.0?
I tried reproducing that code locally and it ran with no problems.
Latest on M1 mac though  built from source
This is such an odd error to get that I wonder if it'll go away if you upgrade your validator.
What version of solana are you running?
hi everyone we run into this while building ido pool
No idea what it could mean
Yeh, the illegally modified program id is another weird error that's been popping up a lot more lately
weird
Nope, seems to be working for me (the website anyway)
github down for anyone else?
Yeah, definitely an interesting error message 🤔
no but i can try pushing it to github in a bit...just nuked the whole workspace and tried again and still same thing 🥴
Do you have your code in a repo anywhere?
Hmm
oh no it fails before that if i comment out the create associated token it still fails, thats also a function from `@solana/spl-token`
So I sort of think the actual mint part worked fine, and then for some reason the getOrCreateAssociated thing failed
Right, but the program log itself says the create mint part succeeded—your createMint function does multiple things
did it? stacktrace shows `      at Function.createMint (node_modules/@solana/spl-token/client/token.js:427:5)`
Looks like it actually did initalize the mint
Yeah, just to double check, are you sure this is the part of the code that's failing? Looks like the token program part actually succeeded (to some extent anyway), right?
looks like rent program throwing that error?
```
Transaction simulation failed: Error processing Instruction 1: instruction illegally modified the program id of an account
    Program 11111111111111111111111111111111 invoke [1]
    Program 11111111111111111111111111111111 success
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [1]
    Program log: Instruction: InitializeMint
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 2279 of 200000 compute units
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success
    failed to verify account SysvarRent111111111111111111111111111111111: instruction illegally modified the program id of an account
    1) Create certificate
    2) Use certificate
    3) Revoke certificate


  0 passing (613ms)
  3 failing

  1) certificates
       Create certificate:
     Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 1: instruction illegally modified the program id of an account
      at Connection.sendEncodedTransaction (node_modules/@solana/web3.js/src/connection.ts:3689:13)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at Connection.sendRawTransaction (node_modules/@solana/web3.js/src/connection.ts:3649:20)
      at Connection.sendTransaction (node_modules/@solana/web3.js/src/connection.ts:3637:12)
      at Object.sendAndConfirmTransaction (node_modules/@solana/web3.js/src/util/send-and-confirm-transaction.ts:29:21)
      at Function.createMint (node_modules/@solana/spl-token/client/token.js:427:5)
```
Can you show the full program log output?
the createMint call fails with that error...ive used this many times before i dont understand how it could give that error
just calling this function 
```
const createMint = async (
  connection
): Promise<[web3.Keypair, web3.PublicKey, splToken.Token]> => {
  // Generate a new wallet keypair and airdrop SOL
  var fromWallet = web3.Keypair.generate();
  var fromAirdropSignature = await connection.requestAirdrop(
    fromWallet.publicKey,
    web3.LAMPORTS_PER_SOL
  );
  // Wait for airdrop confirmation
  await connection.confirmTransaction(fromAirdropSignature);

  // Create new token mint
  const mint = await splToken.Token.createMint(
    connection,
    fromWallet,
    fromWallet.publicKey,
    null,
    1,
    splToken.TOKEN_PROGRAM_ID
  );

  // Get the token account of the fromWallet Solana address, if it does not exist, create it
  const fromTokenAccount = await mint.getOrCreateAssociatedAccountInfo(
    fromWallet.publicKey
  );
  return [fromWallet, fromTokenAccount.address, mint];
};
```
Can you post more of your code? Not sure why the payer thing would lead to that error 🤔
Hmm, you can get the `payer` in your TS tests be doing (silly-looking) `(program.provider.wallet as NodeWallet).payer`, lol
I think this also may be leading to me getting `instruction illegally modified the program id of an account` I just need to create a mint to use for my test and i copied the JS from https://github.com/solana-labs/solana-program-library/blob/master/token/js/examples/create_mint_and_transfer_tokens.js and its leading to that error
https://www.notion.so/Debugging-Custom-Anchor-Errors-b8540dd418c44a4e939ab17c56a3fd3b
in older versions of anchor you used to be able to get the keypair to execute other transactions like
```
    const mint = await spl.Token.createMint(
      provider.connection,
      provider.wallet.payer,
      provider.wallet.payer.publicKey,
      null,
      2,
      TOKEN_PROGRAM_ID
    );
```
like provider.wallet.payer...where did this go?
anyone? https://discord.com/channels/889577356681945098/889577356681945101/916145013916839946
oh snap very cool!
🙂
Yes it sucks, this is why many of us use Anchor
Yep.
some developers will use incrementing counters, others will use a hash-based approach
so it sounds like instruction serialization/deserialization is totally up to the program developer, there isn't a standardized way
Cool!
<@!134416332509675520> it passed! Thanks alan!
Yep. Arguments just get serialized into the rest of the ix data
just to confirm, arguments of the instruction do not affect the function signature?
WOW, so if my function is:
```
    pub fn foobar(ctx: Context<Bar>) -> ProgramResult {
        Ok(())
    }
```

Then `sha256("global:foobar")[..8]`?
It's not actually a sig-hash in the fn signature sense, but yeah, similar idea
Yeah, basically
wow ok that makes sense! so it's like of like Ethereum for smart contracts, the function signature is hashed
You'll likely need to do something like (pseudo code) `sha256("global:your_ix_name")[..8]` at the front of the data vec
is that not the case?
Nope
Every anchor instruction starts with 8 bytes for the "sighash", which identifies which ix function to invoke
oh.. I thought it uses an increental integer like `Token` and `SystemProgram`
huh?
(It doesn't uses indexes etc. to dispatch)
Looks like you're missing the 8 byte sighash that anchor uses
What's the instruction index?
the Anchor instruction function handler accepts no arguments
<@!134416332509675520> it's just this
```
let mut instruction_set: Vec<u8> = vec![SNOWBALL_TRADE_INSTRUCTION_IDX];
```
So just 1 byte, which is the instruction index
How are you building the `data` part of the instruction?
In addition to what Tom said, in terms of syntax you can specify as many:
```
[[test.clone]]
address = "XXX"
[[test.clone]]
address = "YYY"
...
```
as you need (Toml array syntax). However be aware that there currently seems to be a max size of 10Mb that'll get the validator to throw at genesis (which can easily be reached for complex programs). This is being addressed here: https://github.com/solana-labs/solana/pull/21596
Ah, ok, then that error does make sense haha 😛
<@!134416332509675520> I am using Anchor to call another Anchor program, but I'm intentionally not using the bindings because I wanted to treat the interface as opaque. 
```
let mut instruction_set: Vec<u8> = vec![SNOWBALL_TRADE_INSTRUCTION_IDX];
```
`SNOWBALL_TRADE_INSTRUCTION_IDX` is `1` because the instruction I want to call is the second one in the list of instructions defined in the IDL.

```
            let account_infos: Vec<AccountInfo> = vec![
                ctx.accounts.token_program.to_account_info(),
            ];
            let account_metas: Vec<AccountMeta> = account_infos.iter().map(|info| info.to_account_meta()).collect();

            let ix = solana_program::instruction::Instruction {
                program_id: *ctx.accounts.snowball_program.key,
                accounts: account_metas,
                data: instruction_set,
            };
            invoke(
                &ix,
                account_infos.as_slice(),
                // &outer
            )
```
You can't transfer to a program because a program can't sign any transactions, only a PDA could sign and become freeze authority
so, actually I am calling an Anchor program, but I'm not using the Anchor bindings intentionally
ah
100-300 is errors defined by anchor right?
So 0x64 isn't necessarily an anchor error (assuming you know that you're actually getting failing at that CPI, and not earlier in your program)
Which program are you invoking? In general custom errors are custom to the program you call
8 bytes == u64 right?
right, the error message says `8 byte instruction identifier not provided`
u64 is 64 bit
u8 means 8 bits 😛
is instruction u64 or u8?
Wait.. is instruction first 8 bytes or 1 byte (8 bit)?
Which is surprising because I thought that I added my instruction sob.
```
    #[msg("8 byte instruction identifier not provided")]
    InstructionMissing = 100,
```
I got error 0x64
Aha!
❤️ no worries brother. thats just so stupid that it's making u log in, idk why that doesnt happen to me
Thank you so uch
use together with this
https://github.com/project-serum/anchor/blob/master/lang/src/error.rs
one sec i got something for u i think
weird, i can view it publicly just fine

what does it say when you click on the link?
That's awesome man! I don't have a Notion account tho, is there any way to read this publicly? thanks!
if you are transferring freeze authority of a mint to a program, you need an AccountInfo of the currently executing program. Does this mean the program has to be passed into the ctx as an account? The ctx automatically has programId but not AccountInfo for the current program right
https://www.notion.so/Debugging-Custom-Anchor-Errors-b8540dd418c44a4e939ab17c56a3fd3b
did you try this yet?
example here https://github.com/project-serum/anchor/pull/834
`[[test.clone]]
address = "AdtRGGhmqvom3Jemp5YNrxd9q9unX36BZk1pujkkXijL"
`


//////////////////////////////////////////////////////////////////////////////////////////

sounds like a general linux issue not an anchor issue

the reason it doesn't work in root mode is because in root your PATH is different and anchor executable is not on it. Also you probably don't want to run as root:)

make sure both cargo and anchor are installed on whatever PATH you're using

For example in use mode
but when i  use in normal mode is work but it need permission each time. anyone know how to work it in admin mode ?

Hello when i use anchor test in root mod some command is unreconized
This has been showing up a lot lately and I'm really curious what newbies are doing to make it happen
Please post what you find if you figure out what's causing this error
oh i figured it out. The tests fail if I'm running the `solana-test-validator` at the same time
ok huge thanks, will check this out
Hi there, I'm just running through the Getting Started tutorial and have come to the end of the "Minimal Example" everything worked as expected until I ran the `anchor test`. This is my error: `Error: failed to send transaction: Transaction simulation failed: Attempt to load a program that does not exist`. Any suggestions ?
this prints out nices logs of each constraint as its checked
actually I just realized, we never got the original feature to work, or kind of extended it, you can see how we use it

our fork
https://github.com/microwavedcola1/anchor/commit/64f7baea8d0e2529a4659f3094694d657042bbd1
how-we-use
https://github.com/blockworks-foundation/voter-stake-registry/blob/master/programs/voter-stake-registry/Cargo.toml#L22
found this in the examples/tests

but there are no further infos in the logs

`[features]
anchor-debug = ["anchor-syn/anchor-debug"]`
sorry didnt found anything in the docs and github after a quick search, how does this work
You can use the anchor-debug feature
I know what this error means, but just for faster debugging
got the following error. Is there a way to debug which account of the many I pass to the program is the wrong one? 

`Error: 167: The given account is not owned by the executing program`
I ended up just closing the account and re-initiating it. not sure if there's a better way though
I have used `remainingAccounts` for this purpose.
How do you pass in an optional Pubkey from the javascript Anchor client?
if I've already initialized a program account of a certain size, is there a way to add another field to it? I'm getting a "Failed to deserialize this account" error
i would think so since the serde won't work on that account (most likely)
I guess the next time Anchor tries to read from that account it'll throw an exception?
but i've not changed the layout of the data
un-related follow-up, does anyone know how anchor deploys work? For example: I have this PDA account that has some existing data
yeah i was thinking the same... 2 years rent from exempt  used to calc per day
`getMinimumBalanceforRentExemption` for anyone else w/ this problem
yeah -- I ended up using the rent exempt amount & multiplying it by the right number
oh..you mean specifically for a certain number of days as opposed to the rent exempt amount
solanapy has something...i think it would be similar in web3.js
I looked through @solana/web3.js docs, but I didn't see anything on rent
i.e let's say I want to create an account that is 20kb in size & I want it to have enough rent for 5 days
Is there any way to use web3 to calculate the correct amount of Sol to give to a newly created account?
Were you able to get it working? I have the same issue.
if i include recent blockhashes account in the inputs, i keep getting "exceeded maximum number of instructions allowed"... it doesnt happen with clock or any other program...simply including it causes it to error out with that message....
ah found the answer to this at  https://docs.solana.com/developing/runtime-facilities/sysvars
Make sure the cluster is pointing to the right net (devnet, localnet) on the anchor.toml file
That was the bug for me.
Check out this issue on GH. There are some ideas on how to resolve this
https://github.com/project-serum/anchor/issues/168
(outside of passing it in)
how do i get the recent blockhash inside an anchor program?
perfect, yeah saw the release notes - just wanted to double check - appreciate it!
They're basically equivalent but the latter is slightly preferable (it encodes more in the types)
instead of: 
```
 #[account(signer)]
     user_authority: AccountInfo<'info>,    
```
should i do:
```
user_authority: Signer<'info>,    
```
hey guys how to set id type in a struct for a rust program?
did a little more research and figured out that solana setup for windows is mostly broken.. stuff works a lot smoother in WSL though


//////////////////////////////////////////////////////////////////////////////////////////

I'm an idiot thanks
Just as the string. `anchor.BN` is for Big Numbers, not strings.
How do I pass in a string instead of using an integer?

```
const tx = await program.rpc.create(provider.wallet.publicKey, new anchor.BN("My Username"), {
      accounts: {
        myAccount: myAccount.publicKey,
        user: provider.wallet.publicKey,
        systemProgram: anchor.web3.SystemProgram.programId,
      },
      signers: [myAccount],
    });


#[account]
pub struct MyAccount {
    pub username: String,
    pub authority: Pubkey,
}
```
`*ctx.program_id` gives the pubkey of the program. Thank you!
Mm, the address of your program is accessible as `ID` or `ctx.program_id` (not sure if this will actually give you what you want, but that's the current program's address)
Given a `Mint`, you can get its extant supply with `.supply`
okay.
I need to invoke another program on chain and send the current program address as the argument.
myapp::cpi::initialize_token(cpi_ctx, bumps, name, symbol, `this`);
`this` should be the address of the calling program.
How can I pass the right address?
Did you figure out how to get total supply of token within a program? I think trying to unpack the data field of an account may work?
You're going to have to be more specific (anchor/solana is quite different from solidity, so I doubt you can just port stuff—maybe take a look at https://github.com/hyperledger-labs/solang)
Hi everyone. 
I have some problem in writing anchor program. 
Need to get `this` on anchor. I'm exporting some solidity code and need to translate `address(this)` from solidity.
Any ideas for this? Thank you in advance.
hey all. i'm building a web app. when i invoke an anchor command in a react component, like so:

https://github.com/cavaunpeu/anchor-escrow-program/blob/a2e58c4338b17c73f9a4a49d1d546c71e856a9ca/src/client.tsx#L6

my app fails to build with the attached error.

this happens with and without `solana-test-validator` running.

using:

```
@project-serum/anchor@0.18.2
@solana/web3.js@1.31.0
```

Edit: this seems to have been a `vite` issue. I resolved it via the following thread:

https://github.com/vitejs/vite/issues/2618

Namely, i added `<script>window.global = window;</script>` to my index.html.
https://giphy.com/gifs/sorry-okay-nevermind-11EVpyEaQQvSVi
that's a whole lot of pasting code for nothing
bah! I checked `Anchor.toml` and my program id hadn't been updated
and when I say "very similar" I just mean not using `anchor.workspace` to generate my `program`
when I run `solana-test-validator` and run a very similar node client, I don't get any errors btw, I can `initialize` and `update`
full error : 
```
1) getting-started
       Is initialized!:
     Error: 167: The given account is not owned by the executing program
      at Function.parse (node_modules/@project-serum/anchor/src/error.ts:41:14)
      at Object.rpc [as initialize] (node_modules/@project-serum/anchor/src/program/namespace/rpc.ts:28:42)
      at processTicksAndRejections (internal/process/task_queues.js:95:5)
```
thanks in advance for any help. trying to learn anchor from first prinicples
```
use anchor_lang::prelude::*;

declare_id!("6HDC66Uu6rWrw2TtYw5vrwyKmzjArd1D68QeNXnhD5ZX");

#[program]
pub mod getting_started {
    use super::*;
    pub fn initialize(ctx: Context<Initialize>, data: u64) -> ProgramResult {
        let my_account = &mut ctx.accounts.my_account;
        my_account.data = data;
        msg!("Initialize!! {}", my_account.data);
        Ok(())
    }

    pub fn update(ctx: Context<Update>, data: u64) -> ProgramResult {
        let my_account = &mut ctx.accounts.my_account;
        my_account.data = data;
        msg!("Updated {}", my_account.data);
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 8 + 8)]
    pub my_account: Account<'info, MyAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct Update<'info> {
    #[account(mut)]
    pub my_account: Account<'info, MyAccount>,
}

#[account]
pub struct MyAccount {
    pub data: u64,
}
```
gm

I'm getting an error in my `anchor test` in my version of `basic_2` from the tutorial. The error is `Error: 167: The given account is not owned by the executing program` and I guess I just have to post all the code here to have any chance of figuring it out so here goes nothing... 

```
import * as anchor from '@project-serum/anchor';
import { Program } from '@project-serum/anchor';
import { GettingStarted } from '../target/types/getting_started';
const { SystemProgram } = anchor.web3;
describe('getting-started', () => {

  // Configure the client to use the local cluster.
  anchor.setProvider(anchor.Provider.env());

  const program = anchor.workspace.GettingStarted as Program<GettingStarted>;
  const myAccount = anchor.web3.Keypair.generate();

  it('Is initialized!', async () => {
    // Add your test here.
    const tx = await program.rpc.initialize(new anchor.BN(1234), {
      accounts: {
        myAccount: myAccount.publicKey,
        user: anchor.getProvider().wallet.publicKey,
        systemProgram: SystemProgram.programId,
      },
      signers: [myAccount],
    });
    console.log("Your transaction signature", tx);
  });
  
});
```
I'll post the program code in the next message
why is the ``metadata`` field not always part of the IDL, after ``anchor build`` ?
but implementing alan's changes now :)
hello that was actually the main issue
What does it do?
Ha, right, missed that 😆
Surprised no one mentioned this, you're using a generated keypair instead of findProgramAdress
```const Header = () => {
    let [ solBalance, setSolBalance ] = useState(0);

    const connection = new Connection(clusterApiUrl('devnet'), 'confirmed');
    const keypair = Keypair.generate();

    const getBalances = async () => {
        const solBalance = await connection.getBalance(keypair.publicKey);
        console.log('Balance: ' + solBalance);
    }

    useEffect(() => {
        getBalances();
    });```

Hi guys, I'm trying to get the connected wallet balance and add it to the components state... For some reason it is not working. Would appreciate if someone could help me out
That's pretty sweet. Can't wait to reach that level once I get past these basics. Thanks again!!
Yeah, the wallet will definitely not give you access to the secret key—it will only allow you to ask it to sign a tx (or look at its public key)
when I write actual front end stuff, I won't need the user's secret keys for these things, right? 
The solana wallet adapter handles all these?
Yeah, now I'm curious about why the encoding works that way (taking a look at the fromSecretKey source)
whoa, i thought they were just the secret key. Thanks alan!
You just skip specifying space at all (anchor knows how much space an spl mint takes), but you need to specify the `mint::` annotations I mentioned above
whats the proper way to init without space= macro for spl mint?
So it's just `bs58.encode(thoseBytes)`—is that what you're asking about?
Ok, had to double check, I think that secret string is just the base58 encoding of the bytes in that json file (I was a little confused, because the 64 bytes in the file are actually split between the secret 32 bytes + the pubkey's 32 bytes at the end)
I don't need it. Just saw it on the code, and was curious how people get that from the uin8 array.
I would have guessed a keypair was enough
Haha, ok—to your question, why do you need a string version of the private key? Trying to scan that link
Yes, that's what's is happening (and I agree on it being unusual 😅😅)
Just to double check I'm understanding, the source of the funds will presumably need to sign the tx (so, gonna presumably need an actual keypair for them, not just their public key). But the destination wallet doesn't need to pay. So, yeah, if the fee payer here is different from the source wallet, you'll need two signatures (a bit unusual)
Hi super beginner question again! 
I'm doing this web3js tutorial, but with my own wallets- https://yihau.github.io/solana-web3-demo/tour/transfer.html

This is just transferring 1 sol from one address to another, while another wallet is paying the fee. So, there are three wallets here in this code. I'm aware of the account model, where accounts can be credited but not debited from, and this is why I think they need the keypairs of the two wallets they're paying. 

My question is- how do I get that keypair in the string format? If I export the private key from solflare wallet, I'm getting a uint8 array, from which I can generate the public key (using fromSecretKey). 

Is there a way I can convert the uint8 array private key to a string private key? I know I can just use the uint8 array, but I'm just wondering if there's anything that makes this conversion possible
For example, that's part of what you're doing when you mark an account as `mut`: telling solana that it can't parallelize the tx with others that care about that account too
Solana handles all of that for you (well, in terms of sequencing operations/agreeing on the eventual state)
What are the best practices using web3 requests in your  react components?
Just a basic question on ownership if I have a global state (just a PDA with static seed) and storing some data on it and some users who access the RPC instruction does change the data on that global state. What will happen when mutiple users trying to change the data on same account. Would there would be error  ? From web2 perspective we have to handle the concurrency.   How does solana/ rust handles it ?
Generally no 😉 Best bet is to search the anchor codebase for examples
and thank you for the help, will likely make it programmatic rather than manually configuring it
is there documentation somewhere for these 2 macros?
But whatever, whether you want to make an instance of your own wrapper type or an actual mint, somebody still has to pay rent
I would say just make an actual mint (although possible I'm misunderstanding what you're trying to do), but then you'll have to decide who has authority to actually mint new coins etc.
You can make a mint programmatically, and nothing about it is tied to your program
That depends on who the mint authority is (which you'll need to specify above)
mint is my own type, its just a wrapper around the address and pubkeys associated with the real spl mint
no I think you are right. if I make a mint programatically, do I have to create the token as well in the program? and can they be accessed outside the scope of the program?
So is `Mint` one of your own types? Or the anchor_spl type?
my idea was to make a proper mint and account on the spl token program, this mint is more like an authentication struct holding pubkeys that approve minting functions within the program. my train of thought was
1, I potentially want the mint to outlive the program, if i ever take the program down.
2, I dont want to limit the token to the program, potentially making it cross chain (?), and I thought having the program init the spl mint may raise issues.

is the classic course of action to have program init spl token mint and is that applicable here?
As Tom said, the system_program won't pay for it (you'll likely need to make the user wallet pay rent, unless you've got some random account lying around for this kind of thing). Also, I would expect you to need to use the `mint::decimals` and `mint::authority` attributes in that init, and get rid of the space (you're initializing a mint account, which is presumably owned by the spl token program, not your program?)
unfortunately its a workaround, for some strange reason anchor-debug feature is not kicking in in the syn crate (when we explicitly enable it any anchor projects feature list in cargo.toml), and our workaround is to to basically always log wherever we see the `#[cfg(feature = "anchor-debug")]`, see https://github.com/microwavedcola1/anchor/commit/e34bd34cd08261b9d54290db2bcc84cbd168acb1
it's not creating or destroying directly from the signer, the program still calls it
pass in a signer and get them to pay
the chat room example has similar code from memory
like it truly is a program owned account, no one should have the ability to fund, destroy, do anything with it but the program itself
how do most people fund program owned accounts?
-.-
the system program isn't going to pay for your account 😁
check the payer = bit
im sure something in my syntax or logic is wrong but i do not know what it is
but in my mind, 1, i am not asking for a signer at all. how can i resolve this issue?
it gives an "unauthorized signer or writable account" error, or the signer is not expected, something along those lines
```rs
#[derive(Accounts)]
pub struct InitMint<'info>{
    #[account(
        init,
        payer = system_program,
        seeds = [
            "initmint".as_ref(),
            system_program.key.as_ref(),
        ],
        space = 8,
        bump,
    )]
    pub mint: Account<'info, Mint>,

    pub system_program: Program<'info, System>,
}```

```js
const mintAccount = anchor.web3.Keypair.generate();

    const tx = await program.rpc.initMint({
      accounts:{
        mint: mintAccount.publicKey,
        systemProgram: SystemProgram.programId,
      },
    });```
hello friends i have once again ran into an issue
But it doesn't work if your type has variable-length components, since the default instance will usually be too short
Ty for all the help btw, I will find some way to repay you
Yeah, the only thing anchor uses Default for is calculating space if you didn't specify it yourself
Fairly new to Rust, so with the line `#[derive(Default)]` it generates an impl of the `Default` trait automatically for me right? Where do I find documentation for the `Default` trait? Couldn't find it here: https://docs.rs/anchor-lang/0.5.0/anchor_lang/derive.Accounts.html . I guess all the `Default` trait does is calculate the size?
omg it all makes sense now
Or you can snag the final 32 bytes of that u8 array and manually base58 it
Ha, you can get the base58 string by doing `solana address`
mb if its like a really really dumb question
not like a string
yeah but it points to an id.json, and its just a [u8] array
That wallet is specified in tests by the ANCHOR_WALLET env var (which ends up being what your Anchor.toml says)
is it in a file somewhere or generated
ah
`program.provider.wallet.publicKey`
how do i get the wallet address or where do i find it during the anchor test process
Mm, I'm not sure, sorry!
So you mean your solana wallet? `solana address`
i have a part where #[account(address = Pubkey::from_str(xyz))]
how do you get the address from an config/id.json in testing?
Ah, also, you probably don't want to derive(Default) if you're going to have to calculate space yourself manually (definitely will considering that Option)
Just noticed my test passed when increasing size of the account... Ty very much
Option<Pubkey> will take 32 + 1 bytes
This is what my account looks like:

```
#[account]
#[derive(Default)]
pub struct ShowroomMetadata {
    pub wallet: Pubkey,
    pub showroom_dependency: Option<Pubkey>,
    pub price: u64,
    pub uuid: String,
}
```

And this is what my account struct looks like:

```
#[derive(Accounts)]
pub struct InitializeShowroom<'info> {
    // 8 byte discriminator + 32 bytes for Pubkey + 32 bytes for Option<Pubkey> + 8 bytes for price + 4 byte u32 len + 6 byte uuid
    #[account(init, payer = payer, space = 8 + 32 + 32 + 8 + 4 + 6)]
    pub showroom: ProgramAccount<'info, ShowroomMetadata>,
    #[account(mut)]
    pub payer: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```

This worked before I added in the `Option<Pubkey>` parameter. 🤔
so this means there is no native on-chain equivalent to the ecrecover function in Solidity? Could multisig perhaps be a good stand-in to replace that kind of functionality? (for instance, to have an authoritative server partial sign a transaction before the user submits it)
Failed to serialize the account I think will often be a space issue
Ah, k
Updated to pass in `null` instead of `undefined` to get to the last error (previously wasn't defining the parameter as Optional in my Solana program RPC correctly)
What are you changing?
How do you keep getting different errors, haha 🤔
That could actually trigger that specific error (`#[instruction(...)]` needs to exactly match the order of your actual args, at least left to right)
Yes I am, but not for this specific parameter. I also made sure to update the space that the account is taking to include the Optional value.

Getting this error now: `     Error: 164: Failed to serialize the account` . This is probably an issue within my Solana program since I'm hitting log statements within my RPC call
Or, are you using any `#[instruction(...)]` stuff?
That's a bit of an odd error to get—have you updated your IDL after making any changes to the program? (Ordinarily that would happen automatically by anchor build, but just checking)
That looks fine
You ought to be able to pass optional arguments as `null`, yeah.
When I pass in `null` / `undefined` for the optional parameter. Is there a different way to pass them in? Looking at the IDL and it looks like this:

```
            "type": {
               "option": "publicKey"
             }
```
How have you declared the rust instruction function?
Turns out the error is actually this: ` Error: 102: The program could not deserialize the given instruction`
Yeah this is for an anchor program, and it's for the instruction function parameters
Is this for an anchor program? Do you mean an optional account? (I think that specific error only shows up for accounts, not instruction function parameters)
<@!248066053161222144> downgrading and rebuilding source on m1 machine to 1.8.5 did the trick 🙂
legend
hhehe thank yu
ah!
Keep getting the error ` Error: Invalid arguments: <parameter name> not provided.` when I pass in `undefined` / `null` for that parameter
How do you pass in an optional parameter in `@solana/web3.js`?
And testnet is mostly 1.8.0 🤷
So I don't really know what's up with that
Although mainnet is running 1.8.5
So you can't directly use it on-chain from your own program, you have to do this weird thing where you submit a separate instruction asking the program to verify a signature
Right, I'm saying that you actually can't CPI to the ed25519 program (not sure why, it's just not allowed)
It looks like they're running 1.7.14
Through Solana beach
So one way to do it is to look at what the validators are running
going to test with stable 1.8.5 lets see
I see some interesting code here (https://github.com/hyperledger-labs/solang/blob/c898fb79a1d6370544172ad9eb88bb0ff715ad6a/tests/solana_tests/signature_verify.rs), but it is for a unit test, which might not be runnable in an on-chain program
this looks like this is for js code? Would you happen to have any code samples for rust that can be executed on-chain?
stupid question <@!248066053161222144> I have been looking where to find running version but I can't seem to find out what version `https://api.devnet.solana.com` is running
You can add that to a tx and submit it, and it will succeed if the signature works, otherwise it will abort the rest of the tx.
It's got a funny api, you have to send a separate instruction to that program (can't CPI to it, oddly). Something like:
```.js
    const ix = anchor.web3.Ed25519Program.createInstructionWithPublicKey({
      message: Buffer.from("Message we've ostensibly signed"),
      publicKey: thePublicKeyToVerifyAgainst,
      signature: theSignature
    })
```
ah yeah that would explain the method not found
It's likely not 1.9
Check the version running on devnet
I have this solana cli version
`solana-cli 1.9.0 (src:devbuild; feat:158695402)`
I have sufficient devnet sol on the account
hey peeps, I can deploy to localnet during test and separately running the test validator but when I try to deploy to devnet I keep getting this error

```bash
Error: RPC response error -32601: Method not found
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.
```
did you have any info around the usage for this program? I'm digging through threads, trying to get signature validation working, but running into issues with using the dalek crate for this, as mentioned by others. I'd like to find out how to use this program to validate signatures
yep that was the issue -- didn't account for the 8 byte discriminator
That means that you probably didn't allocate the right amount of space for the account
not sure if this is anchor bugor not
that's the method that is causing the issue
`anchor.setProvider(anchor.Provider.local())` sets the client provider to localnet, is there a similar way to connect to devnet?
```rust
    pub fn zero_game_storage(ctx: Context<ZeroGameStorage>) -> ProgramResult {
        let mut storage: RefMut<'_, GameStorage> = ctx.accounts.storage.load_init()?;
}
```
Hm, now I"m getting:
```rust
    'Program log: libstd rust_begin_panic',
    "Program log: panicked at 'from_bytes_mut>SizeMismatch', bytemuck-1.7.2/src/lib.rs:115:3",
```
Then it will have its discriminator set
So use `#[account(zero)]` the first time, and use load_init() in that ix function
oh I see
Look at the example I posted above, it uses `load_init()` (which writes the discriminator for you)
oh I guess I'll just use zero everywhere?
is complaining about missing the 8-byte discrim
ahh, & that's an issue I think:
```rust
    #[account(mut)]
    storage: AccountLoader<'info, GameStorage>,
```
At the end of the day you'll always have to go through whichever program owns that account (so not possible to just write data yourself—you'll always have to invoke the owning program)
is it through the id.json file and how would you do it
how can you change provider wallet address for testing on localnet in node?
Anyone know how to use @solana/web3.js to write raw data to an account?
every time someone gets a constraint error, i would love for the response to just be use `anchor-debug`
shout out <@!837011211795038260> - well done ser 👏
that'd be awesome
<@!837011211795038260> has fixed `anchor-debug` which is supposed to be an error checking thing that prints out all the details of the constraint checks which should make something like this easier to debug, hopefully they get a chance to make a pull request to the main anchor soon!
it seems like based on the frequency of this error, and also the incorrect account discriminator error, that it's quite often the people are passing in uninit / uncreated accounts and not realising it
oh sure - yeah I was trying to call "withdraw" fro an SPL token account that wasn't inited
yeh, just rephrasing for my own understanding
inlining worked
yup, figured out
so you're passing in a token account that isn't inited / actually owned by the SPL token program
is there any way to get around this? -- maybe my inlining the const?
oh the `BOARD_SIZE_USIZE`?
Hm, what do you mean when you say const?
Ah... it might not work with a const like that?
you were right - I was checking for a number of consecutive calls to fail, first being deposit, second withdraw. If deposit fails.. by definition there's no token account to withdraw from, and so withdraw fails for a different reason
it's trying to generate IDL & failing for the `GameStorage` struct??
I suspect
but this happens
when running `anchor test`
the program compiles
Oh, hmm I think there (*might*) be a bug in IDL generation:
```
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: ParseIntError { kind: InvalidDigit }', lang/syn/src/idl/mod.rs:143:76
```
Basically, is every token account etc. an actual token account? (Already initialized, etc.?)
Address type won't matter, could be any `Account<'info, Whatever>` (including Account<'info, TokenAccount>)
which account is it likely to be? a state-holding PDA or a token account?
So I would double check the owner of any Account<'info, Whatever> you're passing in (can always do this manually with `await program.provider.connection.getAccountInfo(thatAccount)`)
interesting... let me go check the dumb way first:D
There are only two known ways to get this 0xa7 error: the annoying/dumb way (incorrect declare_id!), and the non-annoying way, where you really are passing an account with the wrong owner
now I guess it's time to update code to use arrays instead of vecs
AccountLoader
ok, got it working -- I just had to update verywhere to use
hm also getting this error - in place of another one during an `expect().to.be.rejectedWith` statement

the code can't be wrongly handling any of the accounts because it works just fine two tests above (where I'm testing the positive, non-error case)
Ah, sorry, Loader is deprecated (use AccountLoader)
Account won't work with zero_copy
AccountLoader
Am I supposed to use `AccountLoader` or Loader (https://docs.rs/anchor-lang/latest/anchor_lang/struct.Loader.html)?
Looks like you're using AccountLoader (that's good), did you maybe forget to save the file or something?
That error message doesn't match what you posted just above
I'm pretty sure I need to manually implement serialization?
pub storage: Account<'info, GameStorage>,
    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `anchor_lang::AccountSerialize` is not implemented for `GameStorage`
Struct + context:
```rust
#[derive(Accounts)]
pub struct ZeroGameStorage<'info> {
    #[account(mut, seeds = [], bump = game_account.bump, has_one = storage)]
    game_account: Account<'info, GameState>,

    #[account(address = ADMIN_PUB_KEY)]
    pub admin: Signer<'info>,

    #[account(zero, rent_exempt = skip)]
    pub storage: AccountLoader<'info, GameStorage>,
}


#[account(zero_copy)]
pub struct GameStorage {
    states: [u8; BOARD_SIZE_USIZE],
    owners: [Pubkey; BOARD_SIZE_USIZE],
}
```
You need to use AccountLoader, not Account
No, zero_copy is for explicitly skipping deserialization entirely 😛
to update borsh version
oh damn, this might require a patch in Anchor
oh I think I'm running into this: https://github.com/near/borsh/issues/36#issuecomment-882934079
Oh, are you using AccountLoader instead of Account?
Can you post that struct?
maybe I need to manuallly implement serialize
oh interesting it is saying " the trait `anchor_lang::AccountSerialize` is not implemented for `GameStorage`" when I use `zero_copy`
Then finally:
```.rs
pub fn initialize(ctx: Context<Initializer>) -> ProgramResult {
  let huge = ctx.accounts.huge_account.load_init()?;
  ...
}
```
And then
```.rs
#[derive(Accounts)]
pub struct Initializer<'info> {
  #[account(zero)]
  // already allocated this thing in a previous instruction
  // because given huge size, not possible in a CPI
  pub huge_account: AccountLoader<'info, MyHugeAccount>
}
```
No (probably going to have to look through the anchor repo for examples), but basically:
```.rs
#[account(zero_copy)]
pub struct MyHugeAccount {
  owners: [Pubkey; 10000]
}
```
do you use `ZeroCopy` like `#[derive(Accounts, ZeroCopy)]`
It's a bit restrictive (no heap-allocated things like vecs, no strings, etc.), but you can go all the way up to 10mb
You should probably also look at `zero_copy`
You'd have to use an actual array
is there a way to just write to a raw buffer
Yeah, that vec won't work (way too big for the heap)
so the size is too big
yeah BOARD_SIZE_USIZE is 10_000
that makes sense now
```rust
    pub fn create_game_storage(ctx: Context<CreateGameStorage>) -> ProgramResult {
        ctx.accounts.storage.states = vec![0; BOARD_SIZE_USIZE];
        ctx.accounts.storage.owners = vec![Pubkey::default(); BOARD_SIZE_USIZE];
        Ok(())
    }
```
Can you post the actual error?
Mm, how are you doing the initialization? Each stack frame is only 4kb and the heap is only 32kb
and i'm getting memory allocation errors
that is about 0.32 mb in size
i'm trying to initialize this struct
is there a max limit for the amount of memory a solana program can use on-chain?
Think it's `rent_exempt = skip`
i think your solana config is set to local?
same, just less amount
`solana airdrop 5 <ADDR>`
alas I'm not sure what the real rust syntax here is ... will see if I can dig around in tests & find out
What was the full command you ran? I'm still getting an rpc error (I wonder if my solana install is too new locally?)
which I can avoid by using `#[account(rent_exempt = <skip>)]    `
this is an anchor check
oh, i see
Works now! Mayne i should read the error lines more carefully. Thanks though <@!134416332509675520>
5 is the Limit
```
Transaction executed in slot 98910460:
  Block Time: 2021-12-06T01:28:56+05:30
  Recent Blockhash: Gf421jdexMJcChN3XAUKy3XNUSYAb96P5ek15JMwRktA
  Signature 0: 2RNVGmekwGYPMiFcQkC5rTsGnRek2EveCK5g3pExPdewggbqvWyPqa2m9H8HnjRXPhU2LonjBn7cpSn7sHaHpffQ
  Account 0: srw- 9B5XszUGdMaxCZ7uSQhPzdks5ZQSmWxrmzCSvtJ6Ns6g (fee payer)
  Account 1: -r-x MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr
  Instruction 0
    Program:   MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr (1)
    Data: "request too large; req: ◎10, cap: ◎5"
  Status: Ok
    Fee: ◎0.000005
    Account 0 balance: ◎1547911.337579944 -> ◎1547911.337574944
    Account 1 balance: ◎0.52149888
  Log Messages:
    Program MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr invoke [1]
    Program log: Memo (len 40): "request too large; req: ◎10, cap: ◎5"
    Program MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr consumed 33081 of 200000 compute units
    Program MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr success
```
Is 10 Sol a huge amount ? I mean 2000 bucks is but cmon XD
Actually, hmm, when I try to do `solana airdrop` with my config set to devnet I get an rpc error 🤔
so it shouldn't need rent exemption, right?
this account is an external one (created by the process described above)
but now I get an error saying "a rent exempt constraint was violated" -- from my understanding of rent exemption, it only applies to program accounts themselves
ok, so I managed to use `zero` to get Anchor to not complain when I pass in the empty account
No, don't think you need a local validator (you need an rpc connection to devnet, so need you solana config get to say devnet stuff)
local validator is not needed in this case right? Should i generate a new keypair?
Yeah, think so (haven't used that either haha, but it's what I would use I guess)
`solana airdrop 10 <ADDR>`
Mm, not sure, I would just use the solana command line
How are you requesting the airdrop?
https://www.spl-token-ui.com/#/sol-airdrop this should work right?
no it says balance unchanged and asks me to confirm
Are you airdropping to the right network etc.?
Is your balance changing after doing the airdrop?
Please help. any ideas where i can look?
oh amazing, tysm 🙂
That says "I'm gonna make this a Foo, but it's currently zeroed out"
Ah, ok, sounds like you want `#[account(zero)]` then
and skip any deserialization check
I want to pass the account into anchor
so it's just an empty account
So initially I create the account using web3.js
Or is it totally zeroed out?
I'm think I'm confused about what you're trying to do—does the data in the account look like the type?
I am trying to Airdrop some SOL on devnet, in order to deploy a program on it. but its not working : 
```
Deploying workspace: https://api.devnet.solana.com
Upgrade authority: /home/powerconstruct/.config/solana/id.json
Deploying program "mysolapp"...
Program path: /home/powerconstruct/home/mysolapp/target/deploy/mysolapp.so...
==================================================================================
Recover the intermediate account's ephemeral keypair file with
`solana-keygen recover` and the following 12-word seed phrase:
==================================================================================
sock shield audit false problem dinner volcano card lunch question illness kitchen
==================================================================================
To resume a deploy, pass the recovered keypair as
the [PROGRAM_ADDRESS_SIGNER] argument to `solana deploy` or
as the [BUFFER_SIGNER] to `solana program deploy` or `solana write-buffer'.
Or to recover the account's lamports, pass it as the
[BUFFER_ACCOUNT_ADDRESS] argument to `solana program close`.
==================================================================================
Error: Account CiPN93qQT9yMe9dyJvdrojuYUK3W1MSun2zHdo3i1Eo5 has insufficient funds for spend (1.353894 SOL) + fee (0.004265 SOL)
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }.
```
I tried using https://www.spl-token-ui.com/#/sol-airdrop as well as CLI commands
I just want to ignore deserialization checks
And yeah, all `init`s happen via CPIs, so 10kb limit 😦
I want to pass it with the type, since I want to serialize data
Yeah, in this case it will be owned by your program
so I will be forced to create this account outside of Anchor
*limit
alas it looks like there's the 10KB limt
I think it does set the owner to the program

But anchor also knows how to `init` token accounts and mints, which will be owned by the spl token program.
Not always—if you `init` one of your own `#[account]` structs, then yes.
or wait, maybe it does -- time to experiment I guess
oh no, it seems like it doesn't 😦
when using the init property, does anchor automatically set the owner to the program?
Ah, well, that won't work if the account already stores data though
Yeah, probably
oh, I also guess the right thing to do is just use `init` inside Anchor & have Anchor create the acc
Can you pass the account as a raw `AccountInfo<'info>`? That will skip all anchor checks
since I created the account using web3.js
well right now, anchor will try to deserialize the account & it will fail since there's no 8-byte discrim
so basically I just want Anchor to write to that account
Is there a way to tell anchor to not do a deserialization check? for example; let's say I'm passing in an external account (that stores some data), and I want anchor to "reset" that account
That would be some other repo, yeah (not sure where, but definitely not in anchor itself)
Anchor doesn't have any react-specific code itself
maybe the react code is somewhere else?
but couldn't find it in the repo
since I figured that would do basically what I'm doing
and yeah, I grepped through anchor for `useCreateAccount` or whatever the hook is called
I see I see -- that makes sense
It needs to sign too because you're creating a new account there (the system program requires that the new account's address sign too)
Is that `storageKp` signing the tx too? (Doesn't look like it from the snippet above)
One trick to see how to do this kind of thing is to just search the anchor codebase for examples
here is the instruction that is being added to the transaction
I guess for context:
```
    const storageKp = anchor.web3.Keypair.generate();
    const txnInstruction = anchor.web3.SystemProgram.createAccount({
        fromPubkey: adminKp.publicKey,
        newAccountPubkey: storageKp.publicKey,
        lamports: rentPerGameLength,
        space: storageBytes,
        programId: program.programId,
    })
```
signature verification fails here
Specifically:
```
    const txn = new anchor.web3.Transaction({ feePayer: adminKp.publicKey })
    const { blockhash } = await provider.connection.getRecentBlockhash();
    txn.recentBlockhash = blockhash
    txn.add(txnInstruction)
    txn.sign(adminKp)
    assert.ok(txn.verifySignatures())
```
even when I  replace the empty array with `[adminKp]`
ok, I managed to get the recent blockhash but now it's complaining about failed signature verification
currently googling to see how I can get that using web3.js but maybe someone already has the answer here off the top of their head
but it is saying "recent blockash required"
Does anyone know how to send a transaction in Solana using web3.js? 

I'm trying:
```
    const txn = new anchor.web3.Transaction()
    txn.add(txnInstruction)
    txn.sign(adminKp)

    await anchor.web3.sendAndConfirmTransaction(provider.connection, txn, [])
```


//////////////////////////////////////////////////////////////////////////////////////////

Or how to use PreciseNumber
Hi, how can I use an U256 from spl_math in a Account struct field?
user error 🤦‍♂️ please ignore this one!
forgot to remove that
Ah!
Are you using an `#[instruction(...)]` annotation under the `#[derive(Accounts)]` part?
```     Error: 102: The program could not deserialize the given instruction
```
Mm, yeah, that seems plausible—does it seem to work?
<@!134416332509675520>
am I doing this correctly ?
```#[account(
        mut,
        close = authority,
        seeds = [pool.to_account_info().key.as_ref(),authority.key.as_ref()],
        bump,
    )]
    pub user_deposit: Account<'info, UserDeposit>,
    #[account(mut)]
    pub authority: Signer<'info>,```
instead of preflightCommitment
Try getting rid of that option and using `skipPreflight: true`
currently its set to finalized. Here I should set it to preflight ?

const provider = new anchor.Provider(solConnection, walletWrapper, {
    preflightCommitment: 'finalized',
  });
test_index is somehow always 0 from the logs in the program - is there any additional specification i have to do for this value to actually be known inside the program?
yet when i invoke with the following ```    let tx = await provider.send(
      (() => {
        const tx = new Transaction();
        tx.add(
          SystemProgram.transfer({
            fromPubkey: payer.publicKey,
            toPubkey: receiver.publicKey,
            lamports: 1000000000,
          })
        );
        tx.add(program.instruction.test({ accounts: {
          testProgram: systemSysVarKey
        }}))
        tx.add(program.instruction.test({ accounts: {
          testProgram: systemSysVarKey
        }}))
        console.dir(tx, { depth: 5 })
        return tx;
      })(),
      [
        // Signers
        payer
      ]
    );```
hi all, had a question around including multiple instructions in a single tx in anchor - i have a program function that simply logs out the current index like this ```    pub fn test(ctx: Context<Test>) -> ProgramResult {
        let index = sysvar::instructions::load_current_index_checked(&ctx.accounts.test_program)?;
        msg!("test index = {:}", 0);
        Ok(())
    }```
ah its private currently...
Haven't tried that
Out of curiosity, what happens if you skip preflight (aka transaction simulation—literally every name in solana is slightly confusing 😆)?
Got a repo? Sadly I suck at guessing
Ok I might be wrong about the blockhash thing. You are using anchor (duh) and it seems the rpc call gets a fresh one every call.
not quite sure ... I just loop around the above over a file which have mint public keys and call the instruction
Is it always the same tx you send, or does it update every iteration?
I am mostly guessing, don't take anything at heart yet haha. I'm thinking this could be a mix of the blockhash caching + the tx being dropped because detected as duplicate.
so I can't do anything other than re-running those failed ones again ?
Specifically I am looking at these bits:
https://github.com/solana-labs/solana-web3.js/blob/master/src/connection.ts#L3619
https://github.com/solana-labs/solana-web3.js/blob/8d18805b00d0a04084bcfaf9a52741201d743df6/src/connection.ts#L3463
I think you might be hitting an issue with the blockhash caching going on in the web3 lib
Calling this instruction over a loop for 1000 times but most of the time I get that blockhash not found error
```const [pda, bump] = await anchor.web3.PublicKey.findProgramAddress(
                [
                    Buffer.from(anchor.utils.bytes.utf8.encode(PREFIX)),
                    mint.toBuffer(),
                ],
                PROGRAM_ID
            );

            
            const txid = await anchorProgram.rpc.addMetadata(data, {
                accounts: {
                    authority: walletWrapper.publicKey,
                    mint: mint,
                    mintData: pda,
                    systemProgram: anchor.web3.SystemProgram.programId,
                }
            });```
is there a way to do this ?
Might need a bit more. Like the snippet containing the tx creation and sending
Transaction simulation failed: Blockhash not found 
    
```Translating error SendTransactionError: failed to send transaction: Transaction simulation failed: Blockhash not found
    at Connection.sendEncodedTransaction (/home/ship/Documents/scripts-test/node_modules/@solana/web3.js/lib/index.cjs.js:6591:13)
    at runMicrotasks (<anonymous>)
    at processTicksAndRejections (internal/process/task_queues.js:93:5)
    at async Connection.sendRawTransaction (/home/ship/Documents/scripts-test/node_modules/@solana/web3.js/lib/index.cjs.js:6550:20)
    at async sendAndConfirmRawTransaction (/home/ship/Documents/scripts-test/node_modules/@solana/web3.js/lib/index.cjs.js:8513:21)
    at async Provider.send (/home/ship/Documents/scripts-test/node_modules/@project-serum/anchor/dist/cjs/provider.js:85:22)
    at async Object.rpc [as addMetadata] (/home/ship/Documents/scripts-test/node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:11:31) {
  logs: []
}```
Way easier to debug if you post the exact stack trace 🙏
The error doesn't necessarily seem to match, but do you refresh your blockhash once in a while?
Getting a lot of blockhash not found error while calling an instruction inside the loop for most of the iteration . Does someone know what could be the issue ?
If it's one of your program's accounts, then you have to drain its lamports (try searching for try_borrow_mut_lamports)
It depends on which program owns the account, not really on whether it lives at a program-derived address.
I remember something like close, not exactly sure
how do I close a pda and get rent back ?
you can use anchor `await program.account.name.fetch(address);`
nice, thanks
how do i fetch a variable from my program's state account using web3js
then you can `await program.rpc.method()`
you can pass the wallet object to Provider

```
    const provider = new anchor.Provider(conn, wallet, {
      preflightCommitment: "recent",
    });

    const idl = await anchor.Program.fetchIdl(programId, provider);
    const program = new anchor.Program(idl, programId, provider);
```
how would I use anchor with solana's wallet adapter - https://github.com/solana-labs/wallet-adapter

it won't give me the private key ofc, is there a way to still call `program.rpc.methodName()`?
I can see the IDL in the `target/idl/pools.json`
Hey guys,  I am getting this with a new repo when I run `anchor test` : ```Error: Error loading workspace IDL for pools
``` Any ideas why this is failing?
Got it. I tried to get the program A accountinfo by passing it through the accounts, not thought I should sign it using Program A's keypair.
Then I'll switch to using PDA, which is pretty much more solana way.
Thank you <@!134416332509675520>  for detailed explanation!
You would then have program B verify that that A passed it the right program-derived address (anchor doesn't currently automate this kind of check, so will have to do it manually), and that it signed.
This is definitely a weird way to do what you want though, which is to enforce that it was program A that called program B. Another path would be to pass a program-derived address derived from A (say, with empty seeds), and then when A calls B, have A sign for that PDA (only A can do so).
In general in solana it's not possible to go from Pubkey to AccountInfo *within* your program; you have to pass *all* accounts you care about in from the client. So you technically could do what you suggest above if you pass the program_id as an account *and* somehow manage to sign for it (you'd have to use your program's keypair!).
I think you'll probably have to do this in a slightly different way in solana, using PDAs (I see you mention not doing that above).
Program A is the signer for the Program B, actually `#[account(signer)] pub signer: AccountInfo<'info>`
That is, only Program A can call the method of Program B. (kind of onlyOwner in solidity)
That won't work, at least not in any easy way (the program A itself can't sign for its own program_id—you would have to have signed for that program_id from the *client*, which I guess isn't strictly speaking impossible but would be weird)
When you say A needs to be the signer, you mean literally A as its program_id?
but @ cqfd is very generous in the level of engagement he offers and sometimes others too, it's not a given though!
ideally this channel is more for debugging errors and stuff
it's kind of hard to answer program design questions
Any ideas to this?
i'm just being lazy
also initing token accounts requires mints to be passed in as accounts too, so it's probably fine to leave it this way
or maybe it would be too easy for people to footgun by using a mint pubkey that is invalid / no a mint
however, i don't know what the security implications would be?
it would be preferable if it took a public key instead of an account
yeh, i was thinking that it required the account but was hoping that maybe there was a way around
Mm, for some reason I wrote them to require an actual account, but I guess that was dumb/could be changed 🤔
random question: do the ATA constraints require you to pass in the actual mint account and deserialize it or can you just use a public key?
*`anchor.toml`
give me a sec I need to check...
and you all have the same repo, same public key in `declare id` and in the `anchor.toml` file
and you run `anchor test` and it fails for some of you but not others?
yep
are you guys working off a common repo?
Doing an *actual* deploy (like, you start your `solana-test-validator` in the background and do an `anchor deploy`) will require a keypair, yes. But you can also just run `anchor test` and it will do some magic to run your tests against a validator without an actual deploy
what issue?
yeah we are like day one with anchor and having this issue
(It's annoying that they can get out of sync—anchor may automate this in the future)
Yes, the declare_id needs to match the actual program id at runtime
but if you create new acconts on a new deployment with a different programid it will fail
It just declares that that's your expected program id + embeds a static ID variable into your program (this is useful in various situations)
but it's mostly for checking that program accounts have the correct program owner
it is a security checking
I was under the impression that the `declare_id` did some sort of security checking?
it's a different case if you wanted to start doing devnet stuff but for local net, this stuff just works
yes, `anchor test` is local net by default
even if you deploy them to your localnet setup?
and there's no keypairs in there
anyone can pull them and run the programs in them with `anchor test`
it's the same with all `anchor/test` program directories
im still finding my training wheels here
there's nothing special about it
love to have a look
whats your repo?
i think anchor loads the program at genesis, so it doesn't even matter what the private key is
all i know is that other people regularly pull my repo, with the public key in declare id and they have no issue
So then each time a dev wants to build/deploy/test they have to update with there own progrmids
without needing the private key / keypair
you can just have the same public key in `declare id` on everyone's computer and it just works
what am i missing with this for team developemern?
i'll be honest, i don't think we even share keypairs amongst my team
mind you I am just fucking around with this now, but `anchor key list` seam to keep generating new programids even with the same keys
I am just wanting to setup a project that all the developers can just run with and not have to change the programids all the tiem
cause it's just local net, my team works that way
then there's no issue with just having a common keypair for all your team to use
Now that I wouldnt do
is the program id keypair you're working with the same as what's deployed on mainnet
nah, i'm just joking, it's ok
Is this  not a newbies corner?
lol
i feel like if you're asking that question, should you be doing smart contract development!
whats the security risk if I added the keypairs into the repo? Im not 100% how these programid keypairs work?
I think you would have to find some way to distribute a keypair to everyone on the team for local deployment (deploying requires an actual keypair, versus just doing `anchor test`, which doesn't require actually deploying—if that's good enough, you can just hardcode a suitable `declare_id!` + Anchor.toml value)
hey, how can I setup anchor so my programid are built the same for all the team memeber for a localnet deployment?
Yeah It did. Before when I was trying it was failing. Thanks a lot!
It will already show up as initialized to be empty.
Nvm. Passed the test
Thanks. And during Initialization, For example when A tweet is created it does not have comments. So how do I initialize the vector?
Not `#[account]`
Oh, sorry, misread your snippet. Do this instead:
```.rs
#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub struct Comment {
  ...
}
```
``` IdlError: Type not found:  ``` Gives this error
What goes wrong with this approach?
```
#[account]
pub struct Tweet<'info> {
    pub author: Pubkey,
    pub timestamp: i64,
    pub topic: String,
    pub content: String,
    pub likes: u64,
    pub comments: Vec<Account<Comment, 'info>>,
    pub image_url: String,
}

#[account]
pub struct Comment {
    pub commenter: String,
    pub comment: String,
}
```
I am having these structs. I tried using a hashmap instead of the ocmment struct but that also gave an error. Is there a workaround?
Any ideas for this?
Basically you'll have to do it manually—anchor doesn't have a slick way to express conditional inits yet.
Nor in Solana
No
Hey guys. Is there a way to serialize hashmaps in anchor?
How can we deploy a program to mainnet ? Just connect with mainnet on local and anchor deploy does this ? Or anything more needs to be taken care of ?
Well, I can see a workaround with init\_if\_needed, which may work in my case, but it's would still be a bad design decision
im wondering this too
How can i make PDAs without using the Account Contexts? like in the regular code inside the program handlers
Is there a way to create new PDA only under specific condition with anchor? 
I could make multiple functions for different situations, but it doesn't sound great.
anyway, it's not a big deal, just a quirk that had me scratching my head on an anchor error for a while
yeah it seems to just take the first argument after the Context argument, instead of matching the variable names
i think it occurs because `#[instruction(account_bump: u8)]` is just a raw decoding, not actually using the borsh struct fields
it is indeed a trap
the reason this is is because how the code is written?
Hi, <@!134416332509675520> 
I am working to build the `deposit` function to deposit the user's NFT to the contract but no idea how to build this Context
```
pub struct Deposit<'info> {
  pub token_mint: Box<Account<'info, Mint>>,

  pub token_metadata: UncheckedAccount<'info>,

  pub token_from_authority: Signer<'info>,

  #[account(mut)]
  pub token_from: Box<Account<'info, TokenAccount>>,

  #[account(
    init,
    payer = token_from_authority,
    token::mint = token_mint,
    token::authority = token_vault,
    seeds = [ token_mint.key().as_ref() ],
    bump = _nonce_vault,
    )]
  pub token_vault: Box<Account<'info, TokenAccount>>,

  pub system_program: Program<'info, System>,
  pub token_program: Program<'info, Token>,
  pub rent: Sysvar<'info, Rent>,
}
```
so, im really confused on something. It seems that the order of your arguments in your program handlers matters in how this line is processed
`#[instruction(account_bump: u8)]`
So if I have a handler like this:
`pub fn doing_stuff(ctx: Context<DoingStuff>, cool_object:MyObject, account_bump:u8) -> ProgramResult {`
it doesnt work and i get a seed constraints error. But if I do this:
`pub fn doing_stuff(ctx: Context<DoingStuff>, account_bump:u8, cool_object:MyObject) -> ProgramResult {`
then suddenly it works.

Any reason why this is and what i can do to have the bump seeds at the end of the arguments instead of the beginning?
I have two programs A and B.
Program A needs to call B::method1 and in the B::method1's context accounts, A should be `signer`. (not PDA and method1 checks for authority that Program A's account info should be present as the `signer`)
In this case, how to define the signer in the cpi_accounts  of B::method1 ?  
I can have the Pubkey of A as `ctx.program_id` but can't get the account info of A.
Thanks in advance.
I think I am confused on the link between the actual token and where that metadata lives, in a different account? How does the token know about this account?
When I mint a token, how do I decorate that token with metadata, like how metaplex does it? Do I add the accounts to the same struct as the mint pubkey:
`

#[derive(Accounts)]
pub struct Mint<'info> {
    #[account(mut)]
    pub mint: Account<'info, token::Mint>,
    pub mint_authority: AccountInfo<'info>,

    // wallet token account where the minted tokens will be sent
    #[account(init_if_needed, payer = wallet, associated_token::mint = mint, associated_token::authority = wallet)]
    pub destination: Account<'info, token::TokenAccount>,

    #[account(mut, has_one = mint, has_one = mint_authority)]
    pub config: Account<'info, Config>,

    #[account(mut)]
    pub wallet: Signer<'info>,

    pub system_program: Program<'info, System>,
    pub token_program: Program<'info, token::Token>,
    pub associated_token_program: Program<'info, associated_token::AssociatedToken>,
    pub rent: Sysvar<'info, Rent>,
}
`
like "config" in this example? or am I misunderstanding
The exact same thing happened to me yesterday.  😆
Oh my...I think that's it. 🤦‍♂️
Try to update the cargo.toml file from your program’s folder, you may be updating the toml in your project root
hmmmm 🤔
Seems fine to me.
Here's my `/etc/hosts` - anything look weird to you?
think maybe it's an issue with not being able to resolve localhost to 127.0.0.1?
I'm on a mac - no weird firewall settings I can think of which would prevent me from accessing that port in my local
yup!
when you run the local ledger, do you see `JSON RPC URL: http://127.0.0.1:8899` in the output?
can't remember whether I had set it to `localhost` or `devnet` last...but in either case: I just ran ^ and retried but got the same error
mmm, I'm not sure. I assume you've already set solana to use localhost via `solana config set --url localhost`?
yup I'm running `solana-test-validator` in a separate terminal. Is there more I need to do? 🤔
I could be wrong here, but you might need to have your local ledger running via `solana-test-validator`.
Heyo! Just trying to go through the anchor basic tutorial right now and hitting an error:

```
Translating error Error: failed to get recent blockhash: FetchError: request to http://localhost:8899/ failed, reason: connect ECONNREFUSED ::1:8899
at Connection.getRecentBlockhash
```

^ happens when I run `ANCHOR_WALLET=... node client.js`

Any help is appreciated! 🙏
How do you add crates to cargo? I've added the package I want under `[dependencies]` followed by `cargo build`, but I run into this error: ```
Failed to obtain package metadata: Error during execution of `cargo metadata`: error: failed to parse manifest at `/Users/user/projects/solana/sol-vod/Cargo.toml`

Caused by:
  this virtual manifest specifies a [dependencies] section, which is not allowed
```. I feel like I'm missing some simple step.
Hi!, in case that a `solana airdrop` in localhost is not working, try deleting the test-ledger directory, and run`solana-test-validator` again.
lmk if u end up finding anything tho <@!134416332509675520>
if i were to track marketplaces, it looks like https://github.com/milktoastlab/SolanaNFTBot has a good solution of parsing token transfers?
only have been interacting with them, not actually writing and compiling them
im not sure, havent delve into the smart contracts part of anchor too far
Presumably not that bad?
Now I'm curious how hard it is to decompile the magic eden source from their uploaded .so file
yup looking into it
There's also `anchor idl --help`
ty! will look into it... i was also confused because i had to my example idls from json on my own, but for candymachine, i could use the fetch function...
ohhh
`anchor idl init` I think
is that an anchor command?
Mm, not sure, I haven't looked at magiceden much—if they don't have anything open sourced then it'll probably be tricky? Not sure though
how do you explicitly upload the IDL?
ahh, im currently looking at the magic eden program. Does this mean that I wont be able to easily decode instructions?
Not necessarily, you have to explicitly upload the IDL (so possible it's an anchor program but they just didn't upload the IDL)
assuming it to be true, but i want to clarify
if `anchor.Program.fetchIdl` returns null, does that mean that that program wasnt not made with anchor?
When in doubt about which token account to send the tokens to, yeah, you'd use an associated token address
No—that's why you actually have to `transfer` to a *token* account, not a wallet directly
If I spl_token::transfer a token to a wallet, does it automatically find the ATA for that token type owned by the wallet? Or does the receiver field need to be the ATA
hi everyone,
are there any way in anchor to get the total fee of SOL gonna pay for a transaction including account rent fee + transaction fee.
Like if u hv a pending transaction, Phatom would able to preview total fee required and break down the instructions involved. 
Is it possible to get that figure with anchor?


//////////////////////////////////////////////////////////////////////////////////////////

I believe its sha256("account:accountName")[..8] (first 8 bytes of the sha hash)
`pub struct Fanout {
    alice_share: u16,
    bob_share: u16,
    bump: u8,
}`

For this struct, would the size of the account be 8+2+2+1=13 bytes to calculate rent exemption/size at initialization?
But instead of "global", it's "account:"
https://discord.com/channels/889577356681945098/889577356681945101/896294171667730492
how does anchor generate the first 8 bytes to store in a data account? if i want to generate them myself manually
Trying that as well
Ah, actually, one thing you could try doing real quick is to just move the token transfer *above* the sol transfer part
Ok Taking a look at it
So it's fixable (if my guess is right), but you'll have to do some discord-diving in that thread (look above a bit) to see how to sneak around it
My guess is that you're running into a quite annoying solana thing: https://discord.com/channels/889577356681945098/889584618372734977/915190505002921994 😬
Another update I i just keep the SPL Token transfer and comment everything else it works
But If I include it its failing
AS per the transaction
https://explorer.solana.com/tx/4cvwh2jpTXEfwv6LAG7XBZ9BAcy3RA2SmyhMYfrUqumCJbj7NAXrExuozKqosH7BnM2MRroqVBe27iV9nWB2rjZk?cluster=devnet
because if I comment out the SPL Token Transfer in the end of ix function  it consumes only 28k units
It seems like I am running out of compute units very strange

<@!134416332509675520> 
This is my IX function

```


```
It fails write at the end when I doing the Token Transfer i.e If I comment that out everything works but If I include it I get the following error
wow ok!! A lot I learned from this thread!! Thanks <@!134416332509675520>
That's one use-case, yeah
ah so the fact that we use PDA, is a bit like an identifier to some underlying account owned by some other program, and then if we want to do something about that account, we just sign with seed with the PDA so the owner program will perform the operation accordingly
Whether or not a program asks you/something to sign before it mutates or spends one of its owned account's money is purely a politeness thing (/ program correctness/not being dumb)
Account ownership == the right to mutate the account's data or spend its money
(In fact, if you own an account, *only you* can move its lamports—asking the system program to do it would fail!)
Nope—if you own an account you can also just yoink its lamports
I think Im getting there ~~ so this means the dex program and update the data inside that account, but cannot transfer lamports in it as it cannot sign am I right?
But that doesn't mean the dex needs to sign for that address—if your program owns an account, it can do whatever it wants with it (no need to sign anything, at least not necessarily)
Ok, the dex is storing stuff in the account, so the account itself needs to be owned by the dex (otherwise the dex can't store stuff there)
yes I think its storing some data
Mm, isn't the dex like storing stuff in this account? What is this account for?
I guess reason why Im not understanding the whole thing well is that, if the program wont need to sign for an account, then why not just let it be owned by a system account?
Why does it need to sign for it? I'm not super familiar with the dex
as in, the program wont be able to sign for it right?
Why wouldn't the program be able to access it?
understood, but the question would then be does the code here https://github.com/armaniferrante/serum-quickstart/blob/master/tests/utils/index.js#L293 effectively just create an account, paid by the wallet, and the account will reside under the program, but program cannot access it cuz its no PDA? or maybe Im missing some context?
Just like how you make a token account that lives at one of your program's PDAs
So, if you want to make it a PDA, then you'd have to do this stuff from within your own program, via a cross-program invocation to the serum dex (plus the system program I guess, to allocate the account)
That account there must live at a keypair address
Yeah, that client-side call won't work for a PDA (you can't sign for the address client-side)
reason Im asking is cuz Im going through the serum dex test case (more like a demo I suppose) https://github.com/armaniferrante/serum-quickstart/blob/master/tests/utils/index.js#L293 I dont see any special handling when the code is creating account under the dexProgram. So how can the dexProgram later on sign for these accounts?
e.g.
```
    SystemProgram.createAccount({
      fromPubkey: wallet.publicKey,
      newAccountPubkey: <...>,
      lamports: await connection.getMinimumBalanceForRentExemption(165),
      space: 165,
      programId: TOKEN_PROGRAM_ID,
    }),
```
if I want to make this a PDA account, I guess I try to derive the pubicKey using seed and bump and put it in `newAccountPubkey`
ugh ok lol.... ok I will ignore the 3rd type for now. So another question,  for `createAccount` how will be seed, and bump be passed into the API call?
Extra weirdly, the createAccountWithSeed addresses *can't sign at all*, lol.
createAccountWithSeed is a weird other API (it's a *third* type of solana address: keypair addresses, program-derived addresses, and these weird with-seed addresses)
Confusingly, no—the createAccountWithSeed instruction actually isn't for PDAs at all (for PDAs you just continue to use the createAccount instruction, just like with keypair addresses, but with the caveat that only the deriving program can use it—won't work from the client because the client can't sign for that PDA, only the deriving program can)
Hi alan, one follow-up question on this, Im looking at some of the solana web3 apis 
- https://solana-labs.github.io/solana-web3.js/modules.html#CreateAccountParams
- https://solana-labs.github.io/solana-web3.js/modules.html#CreateAccountWithSeedParams
so I guess for the param with seed, does it mean the owning program will be able to sign right? But how about the param without seed tho?
Check out the anchor tests/ directory!
Is there any more complex example of anchor than the tutorials on github?
Your program can sign for one of its derived addresses with `invoke_signed` if it knows the right seeds+bump
Yep, but only the deriving program can sign for a PDA (that's part of what they're for—they're funny addresses that are *not* actual public keys, designed so that their deriving program can "sign" for them)
Noob question: Is it possible to sign using a PDA in Solana? 
Context: I want a PDA to own a token account which can then transfer to other accounts.
That was it! Thanks!
ahh! I don't think I was updating my IDL! Let me try that.
Are you somehow not updating your IDL when you make those changes? The `#[account(mut)]` attribute ought to update the IDL to make sure the JS asks for mutable/exclusive access to that account
What does it mean to pass an account as mutable from the frontend's perspective (e.g, making an RPC call)? For example, this is how is passed (second account on the list): 

```rust
    try {
        const tx = new Transaction();
        tx.add(
            program.transaction.acceptOffer(
                {
                    accounts: {
                        offer: new PublicKey(openOffer.offer),
                        whoMadeTheOffer: new PublicKey(openOffer.whoMadeTheOffer),
                        whoIsTakingTheOffer: wallet.publicKey,
                        escrowedTokensOfOfferMaker: new PublicKey(openOffer.escrowedTokensOfOfferMaker),
                        accountHoldingWhatMakerWillGet: new PublicKey(openOffer.whereToSendWhatsWanted), // account where the wanted pigs will be sent 
                        accountHoldingWhatReceiverWillGive: new PublicKey(tokenAssociatedAccount), // where to put the cows I'm receiving
                        accountHoldingWhatReceiverWillGet: new PublicKey(openOffer.accountHoldingWhatReceiverWillGet), // where i'm I getting my cows
                        kindOfTokenWantedInReturn: new PublicKey(openOffer.kindOfTokenWantedInReturn),
                        tokenProgram: spl.TOKEN_PROGRAM_ID,
                    }
                }
            )
        );
        const signature = await sendTransaction(tx, program.provider.connection);
        await program.provider.connection.confirmTransaction(signature, 'processed');

```
and the second error means you're passing in an account as readonly that needs to be mutable (or an incorrect signer)
a mut constraint being violated means you're not passing in an account as mutable
Question.  I have the following field that triggers a `mut` violation: `Program log: Custom program error: 0x8c`

```rust
    #[account(mut)]
    pub who_made_the_offer: AccountInfo<'info>,
```

When I remove the `#[account(mut)]` attribute, I get:

```rust
CRC1NoRZbBFeZsAxd6oVnp8UBAukG28dTrH7s3nXmGRG's writable privilege escalated
    Program 6iHfHR4e2KusjUQMoqEgjNqaxw4Cgg5R3xgKrCorxEHN consumed 200000 of 200000 compute units
    Program 6iHfHR4e2KusjUQMoqEgjNqaxw4Cgg5R3xgKrCorxEHN failed: Cross-program invocation with unauthorized signer or writable account
```

Where `CRC1NoRZbBFeZsAxd6oVnp8UBAukG28dTrH7s3nXmGRG` is 

```rust
pub who_made_the_offer: AccountInfo<'info>,
```

Any hints on what I should be looking for?
I don't think rust will let you impl AnchorSerialize for it directly, because of the trait "orphan rule": https://doc.rust-lang.org/book/ch10-02-traits.html#implementing-a-trait-on-a-type
solana 🤷
yes, my bad
Would it be possible to use PreciseNumber directly instead of U256?
And then added simple integrational tests to check that everything else is working
I rewrote my logic to not use `Clock` sysvar or anything else Anchor related, tested those functions in pure Rust code
more computation = more fees similar to ethereum
still tho, why limit to 1million or 200k just leave it pay as you go
but yeah
you mean 1 million x)
<https://jstarry.notion.site/Transaction-Fees-f09387e6a8d84287aa16a34ecb58e239#6c4bae9a910641028cc4f3a747be7a6d>
i dunno, i'm looking for it now
DISCORD SEARCH or google
where can I find that ?
WOW!
they're introducing a 100k limit soon, check out jstarry's blog post about it
would love to see someone doing this
<@!248066053161222144> what's the best way to increase the 200k unit limit ? in a hacky way
and the more people who ask for the time feature, the faster they will likely implement it
we're limited by what solana itself can do
we're all built on top of the solana test validator, the solana sdk
it's a solana thing though
I am using anchor for my test framework though, every module I import comes from Anchor aswell
they might implement something if people keep asking about it there
try checking in the solana tech discord
did you find any solution ? Would like to mock time aswell
This might work, let me try
(Might be better ways to implement those functions, haven't checked)
Mm, can you try doing something annoying like this?
```.rs
#[derive(Clone)]
pub struct U256(spl_math::uint::U256);

impl AnchorSerialize for U256 {
    fn serialize<W: std::io::Write>(&self, writer: &mut W) -> std::io::Result<()> {
        let mut buf = [0u8; 32];
        self.0.to_little_endian(&mut buf[..]);
        writer.write_all(&buf)
    }
}

impl AnchorDeserialize for U256 {
    fn deserialize(buf: &mut &[u8]) -> Result<Self, std::io::Error> {
        Ok(Self(spl_math::uint::U256::from_little_endian(buf)))
    }
}

impl Deref for U256 {
    type Target = spl_math::uint::U256;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
```
use spl_math::precise_number::*;
use anchor_lang::prelude::*;
    #[derive(Accounts)]
    pub struct Adjust {
        pub rate: PreciseNumber,
       
    }
thanks!
ok
Mm, not sure, I haven't looked at serum much yet.
Did you do any sol transfers earlier in the function?
<@!134416332509675520> are there any examples you've come across of using anchor to call serum-dex (`placeOrder`, `cancelOrder` etc.)?
Can you show the rest of your instruction function? I wonder if you're running into some bizarre solana weirdness
If the phantom wallet is how you set up your `program.provider`, then you don't have to do anything, it will sign every transaction automatically. The reason why you can't get access to a `wallet.payer` property is because in phantom will never ever reveal your secret key to JS.
What does it mean
/// Program's instruction lamport balance does not equal the balance after the instruction
FPr the above pice of code, both the offer_tkaers_nft_token and offer_makers_nft_Account have been init
```        anchor_spl::token::transfer(
            CpiContext::new(
                ctx.accounts.token_program.to_account_info(),
                anchor_spl::token::Transfer {
                    from: ctx.accounts.offer_takers_nft_token.to_account_info(),
                    to: ctx.accounts.offer_makers_nft_account.to_account_info(),
                    // Cute trick: the escrowed_maker_tokens is its own
                    // authority/owner (and a PDA, so our program can sign for
                    // it just below)
                    authority: ctx.accounts.offer_taker.to_account_info(),
                },
            ),
            1,
        )?;
```
I get the above error while doing a CPI to do a NFT transfer
```failed: sum of account balances before and after instruction do not match
```
Question. What's the correct way to make the current signed user (phantom wallet) sign a transaction. For some reason, the `payer` object in the provider wallet is undefined (which seems to be the only object that provides a Keypair for the current user):

```go
program.provider.wallet.payer
undefined
```

I'm currently getting:

```rust
6tCkKrMgUBvxiQi5nFuxujG758142fWb11hTeUv4eeqy's writable privilege escalated
    Program 6iHfHR4e2KusjUQMoqEgjNqaxw4Cgg5R3xgKrCorxEHN consumed 200000 of 200000 compute units
    Program 6iHfHR4e2KusjUQMoqEgjNqaxw4Cgg5R3xgKrCorxEHN failed: Cross-program invocation with unauthorized signer or writable account
```

The error above doesn't happen on my test-cases, only while testing from the frontend I created for the app.
yeah, there's gunna be a lot less support for it
okay thanks that make sense. I was thinking if I was just poking around I would prefer to use python but that seems to have fewer examples
but js and ts have become the languags for web dev pretty much
i think there's a python version too
pretty much that, the web3 js library is pretty much the most built up so far
random question--why does it seem standard to interact with Solana using TS/JS instead of another language? I am not familiar enough to understand the tradeoffs here, is it just easier to integrate into websites?
should just be `use anchor_lang::prelude::*;`
this is because of this `use anchor_lang::{prelude::*, solana_program::account_info::Account};`
what errors are you getting?
i'll play around with it, thanks for the tip
you can handle those parts if you want
there are `anchor test` flags like `--skip-deploy` and `--skip-local-validator`
yea you don't need it
interesting i think i'm not supposed to have a validator running already then?
`anchor test` should start a local test validator and deploy (i.e. do all the setup for you)
ya that tut is pretty good
this tutorial i'm following has me run `anchor test` before deploying but the tests fail unless it's deployed
ill check it out, but yeah i mean real toys 😉
nvm
oh you meant real apps
I found this tutorial really good, working through it now https://lorisleiva.com/create-a-solana-dapp-from-scratch/
Hey guys, other than jet protocol what are some other good codebase examples of anchor for us keen newbies in the house?
Hi Anchor people.  I'm looking at a tutorial and it says `#[account(init, payer = author, space = Tweet::LEN)]` will make `author` pay for the rent-exempt money for the Tweet account.  Does this mean anchor makes rent rent-exempt by default, or is there some syntax i'm missing that marks it as rent-exempt?
rosetta is the number 1 emulator
i think i had to build from source for anchor on m1 too which was super weird
theres so many rando issues you will get atm
i would really not recommend using non rosetta for like another 6 months lol
i have the lifetime on the struct ;s
just implementing a simple blog program
```
use anchor_lang::{prelude::*, solana_program::account_info::Account};

use std::str::from_utf8;



declare_id!("GCEkHsFut3ceGvAsixoB3DtF32YxhoMXhkRKJf73Ueb1");

#[program]
pub mod solana_blog {
    use super::*;
    pub fn initialize(ctx: Context<Initialize>) -> ProgramResult {

        let blog_acc = &mut ctx.accounts.blog_account;
        blog_acc.authority = *ctx.accounts.authority.key;
        Ok(())
    }

        pub fn make_post(
            ctx: Context<MakePost>,
            new_post: Vec<u8>

        )-> ProgramResult{
            // post detail

            let post = from_utf8(&new_post).map_err(|err| {
                msg!("Invalid UTF-8, from byte {}", err.valid_up_to());
                ProgramError::InvalidInstructionData
            })?;
            msg!(post);

            let blog_acc = &mut ctx.accounts.blog_account;
            blog_acc.latest_post = new_post;

            Ok(())
        }
            
        
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(
        init, 
        payer = authority,
        space = 8 // account discriminator
        + 32      // pubkey
        + 566     // make the posts max 566 bytes long
    )]
    pub blog_account: Account<'info, BlogAccount>,
    // #[account(mut)]
    pub authority: Signer<'info>,
    pub system_program: Program<'info, System>


}

#[derive(Accounts)]
pub struct MakePost<'info> {
    #[account(
        mut,
        has_one = authority
    )]
    pub blog_account: Account<'info, BlogAccount>,
    pub authority: Signer<'info>,
}

#[account]
pub struct BlogAccount {
    pub latest_post: Vec<u8>,
    pub authority: Pubkey
}
```
Not sure I like the fact I cant use cargo test...
hmm
try `anchor test` not `cargo test`
yep, just tested again using `anchor init hello_anchor && cd hello_anchor && cargo test` and same result.
all I did here was `anchor init anchor_vanilla && cd anchor_vanillia && cargo test` and it fails no matter the name of the parent
Seeing the whole thing would make it clearer
I'm terrible with lifetimes but probably you are missing the lifetime on the struct the account is part of
`anchor init` again but use a name different from that parent folder 😬
Hey guys, when running `cargo test` on a vanilla project I am getting this error: ```
running 1 test
test test_id ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests anchor_vanilla
error[E0659]: `anchor_vanilla` is ambiguous (name vs any other name during import resolution)
  --> /home/utx0/Code/poc/anchor_vanilla/programs/anchor_vanilla/src/lib.rs:6:9
   |
6  | pub mod anchor_vanilla {
   |         ^^^^^^^^^^^^^^ ambiguous name
   |
   = note: `anchor_vanilla` could refer to a crate passed with `--extern`
   = help: use `::anchor_vanilla` to refer to this crate unambiguously
note: `anchor_vanilla` could also refer to the module defined here
  --> /home/utx0/Code/poc/anchor_vanilla/programs/anchor_vanilla/src/lib.rs:6:1
   |
6  | / pub mod anchor_vanilla {
7  | |     use super::*;
8  | |     pub fn initialize(ctx: Context<Initialize>) -> ProgramResult {
9  | |         Ok(())
10 | |     }
11 | | }
   | |_^
   = help: use `crate::anchor_vanilla` to refer to this module unambiguously

error: aborting due to previous error

For more information about this error, try `rustc --explain E0659`.
``` But if i change the naming anchor then fails to generate the IDL files.
dafuq....
even though, obviously, Account takes in these 2 parameters
for:
```
Account<'lifetime, arg>
```
getting:
```
this trait takes 0 lifetime arguments but 1 lifetime argument was supplied
expected 0 lifetime arguments
```
thanks
legend
default is 5000
in Anchor.toml
```
[test]
startup_wait = 30000
```
hey guys, I got an issue when i run `anchor test` its failing as the due to the validator still `Initializing...` is there anyway to increase the timeout for this?
Great thanks for the added context. I don't have a mac but am trying to help a friend get setup on one. 😅
I think most of the M1 issues on github are not M1 problems or not anchor problems
Beyond needing to build solana-test-validator from source i never had any issues with M1 and anchor
I can't imagine there being issues caused by Anchor specifically.
<@!867369388608061470> are there addittional problems with the M1 and Anchor after setting up via your tutorial?
tysm <@!134416332509675520> i owe you a coffee

damn you really know your stuff
But yeah, that's in hex, not base58 like solana expects
And use that instead
Do `console.log(provider.wallet.publiKey.toString())`
```console.log(provider.wallet.publicKey);```
```PublicKey {
  _bn: <BN: 5a5750b02434f935a9c7d5d0cfb657f86cd2a901d6c3472276ace0c6xxxxxxxx>
}```
Maybe you're using hex?
Where are you getting a len 64 string? In base58 pubkeys are ~44-ish digits
its for a cpi transfer, because we have to send the receiver as an account from the frontend, i want to make sure the receiver is one I own, or else the client can plug in two random accounts and still run my functions, which shouldnt happen
but it gives an WrongSize value error
I am trying to check
``` address = Pubkey::from_str("len 64 from js side").unwrap()```
here
What have you tried so far? Do you have access to an `Account<'info, TokenAccount>` or what?
whats the syntax to verify an ATA owner is a specific address?
cool, thanks!
E.g. `new anchor.BN("1000000000000000000000000000000000000000000000")`
It gives you a way to represent arbitrarily big integers
so in short it's a converter/helper utility?
E.g. `Math.pow(2, 53) === Math.pow(2, 53) + 1`
The issue is that numbers in JS are doubles under the hood, so they annoyingly can only represent integers up to 2^53 (not quite big enough for a u64 type in rust).
Big Number
Hi, https://project-serum.github.io/anchor/ts/classes/bn.html what acronym is BN?
I think it is an illustrative example and not meant to be a production escrow program
Bookmarked 👍
Fwiw I wrote up an escrow repo here if you want to see my take: https://github.com/cqfd/quidproquo (not having read the other ones super carefully)
wow this tutorial sucks then 😂
Or, well, I guess you sort of get to pick them—but you generally don't
Ah, haven't read that tutorial—if they're using a single seed though then they'll only have *one* account (bumps are deterministic! you don't get to pick them)
I'm doing this escrow tutorial: https://hackmd.io/@ironaddicteddog/solana-anchor-escrow
We create this `vault_account` to temporarily hold the initiator's funds. But the way it's written right now, I think it would only support the creation of a few vault addresses at a time because there are a finite number of PDAs we can generate with 0 < bump < 255 and a constant seed
Yep!
What is this PDA used for? Is it the ADDRESS of the new token wallet we create?
But find_program_address starts at 255 and just tries sequentially downwards until it finds one that works.
Every bump has about a 50/50 chance of "working".
Sort of—there's the bump that you would get by calling find_program_address (always deterministic), but it's true that lots of other bumps could push the address off the curve (they would lead to different addresses though!)
Under the hood it constructs some cross-program invocations for you.
That says we want to `init` a token account with mint `mint_a` and authority (the "owner" of the tokens) equal to `initiator`. The token account will live at one of our program's derived addresses, with those seeds + bump. The `initiator` will also pay for the token account's rent.
I think a given seed can have multiple valid bumps
So if you want different addresses, you have to pick different seeds (you don't get a choice for the bump—it's a function of the seeds)
alan! my friend
Program-derived addresses are deterministic: given the same seeds you'll always get the same bump plus same resulting address.
<@!501570363566587905>  can u please help
I have 4 questions about the `#[account(...)` macro i posted above. Would really appreciate help
i want to verify a certain TokenAccount owner is a specific hardcoded address
what should the string input to pubkey::from_str be? is the way i pulled it wrong?
Soon. 😉
Would love this as well
I think documentation would be most helpful, so hundreds of developers can use it
I am trying to find documentation online but i see any about the things I posted
Maybe we should do some type of office hours.
^ +1... Would be really great if we could have more community helpers to help us understand anchor 🙏
please
but https://www.youtube.com/watch?v=mR3Ipaju-ec will work for installing solana on rosetta
```
#[account(
        init,  // TODO: Why is this initializing a token account? how does that work?
        seeds = [b"token-seed".as_ref()],  // TODO: wtf
        bump = vault_account_bump,  // TODO: wtf
        payer = initiator,
        token::mint = mint_a,  // automatically initializes a TokenAccount
        token::authority = initiator,  // TODO: shouldn't this be the PDA?
    )]
    pub vault_account: Account<'info, TokenAccount>,
```

Can someone please explain what is going on here? I understand how the seeds + bump are used to generate the PDA
for anchor? my audio broke and i have been too lazy to rerecord it
Do you have a setup video?
theres prolly some more rando bugs i havent encountered, but for ver ybasic stuff yeah you wont notice
😂
lol it works until you want to use anchor / do anything on localnet
did u ever find an example 🙂
Ok I now understand that the bump is the value where the public address falls off the Ed25519 curve. But what if one user arrives at the same bump as another user, and they both try to use that bump to create accounts? Then both the `vault_account`s will have the same address, no?
im getting a ```value: WrongSize``` for pubkey::from_str("a string of len 64")

i got the public key using provider.wallet.publicKey in the clientside js
it returned:
```PublicKey {
  _bn: <BN: a string of len 64>
}```
Check out the Paulx tutorial
You just find the first bump that takes it off the curve
That's not how bumps work
Am I the only person who uses WSL
```
    #[account(
        init,
        seeds = [b"token-seed".as_ref()],
        bump = vault_account_bump,
        payer = initializer,
        token::mint = mint,
        token::authority = initializer,
    )]
    pub vault_account: Account<'info, TokenAccount>,
```

If vault_acount_bump is u8, then can't we only create 255 different possible PDAs here?
Tag <@!917870235497938974>
<@867369388608061470> did a video
Haha yeah, I'm still using rosetta 😛
Great news, though I'm skeptical!
No rosetta etc.
I think it's possible you don't even need to do anything special now—not 100% sure about that but I did a setup with someone last week and as far as I know it just worked 🤔
What is the best setup guide for M1?
oki
Oh, sorry, I misremembered the context of that question, one sec
Pubkey::find_program_address
how to make PDAs manually
ahh thank you, it didnt show up in google search index
Yes. https://project-serum.github.io/anchor/ts/index.html
does anchor have api documentation like solana/web3  does?
like https://solana-labs.github.io/solana-web3.js/modules.html#TransactionSignature
i want to know for example what are `new anchor.Provider()` doing and what argument options and the types
gm
what issue are you facing? can you post a code snippet?


//////////////////////////////////////////////////////////////////////////////////////////

the output file does have them but would be useful to confirm some things in an automated fashion
is it possible to get tx logs in the unit test environment? i've tried getConfirmedTransaction but the provider commitment level doesn't seem to match the expected level?
Ah, do `associated_token::mint` and `associated_token::authority` instead
Any example how to create associated account would be helpful!
```error: expected `=`
   --> programs/airdrop/src/lib.rs:118:64
    |
118 | ...   #[account(init, payer = taker, associated_token_account** >>> :: <<<** mint = airdrop_token_account.mint, associated_token_account::authority = t...
    |```
Does someone know how to create associated token account if it's not existing?

I tried:
```
        #[account(init, payer = taker, associated_token_account::mint = airdrop_token_account.mint, associated_token_account::authority = taker)]
        pub taker_receive_token_account: Account<'info, TokenAccount>
```
But im getting following error:
would you happen to have any list of links related to Solana learning resources, etc? Something similar to those "Awesome SomeLibrary" repos that are sometimes created? I think it could be a great resource! I'd probably read just about every link on it
ahhh, great! Thanks for the link! I'll dig in. 👍
Slightly more complicated than that (transaction fees are about how many signatures have to be verified) but yeah, basically! https://jstarry.notion.site/Transaction-Fees-f09387e6a8d84287aa16a34ecb58e239
hmm, so compute resources, strictly speaking, are basically free? You just gotta be within the allocated compute budget? interesting. And so the only thing you actually pay for in each transaction is the rent incurred?
Solana doesn't really have gas fees (just a compute budget)—the only thing you pay for is the rent cost (which is actually fairly expensive, currently around $1/kb)
that would be my guess anyways, from seeing the publicKey/address and the error number
`0xc` is 12 in decimal, so I imagine it would be error 13. The address you posted pulls up the "Token Metadata Program" here: https://explorer.solana.com/address/metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s

That name implies the relevant source code would be here: https://github.com/metaplex-foundation/metaplex/blob/626d15d82be241931425cf0b11105dbf25bc9ef8/rust/token-metadata/program/src/error.rs

Error number 12 (actually 13 because of a zero start-index on enums), in that file would be: 
```/// Symbol too long
    #[error("Symbol too long")]
    SymbolTooLong,```
I always wondered some of the details around this as well... I assume that the amount of space you put into the parameter will also affect the gas amount, correct? So, even if you are not using it all right away (like having some of the space allocated for the empty Vec, as an example), you still need to pay the rent exemption gas fees up front, correct? So you have to find a balance between sufficient capacity for growth and lower gas fees?
I am having some problems with the IDL generation for TS types, namely
IdlError: Type not found: {"name":"terms","type":{"defined":"Terms"}}
Terms is a struct, that is embeeded in another like:
#[account]
pub struct Terms {
    pub fee: u128,
}

#[account]
pub struct MainStruct {
    pub terms: Terms,
}
Did you make any progress on this gary? Thanks for the pda idea btw
Ahhh, ok! 😕  Thank you! I think, that I just misunderstand something, but no.
Yep, gotta just think of an ok max amount of space (it's annoying)
Hey, one more stupid question about storing `Vec` of things in account. So we need always specify `space` in `account` macro, but if I do not know upfront how many things will be in my `Vec`, I should anyway have some `MAX`limit for it to calculate space? Or how best to do this, maybe somebody could share some best practice example? Thanks in advance.
Thanks
push is working
Did it work?
store the pubKeys in an array
What have you tried so far?
how can I add a new data to this one?
Yep
```
pub struct UserAccount {
  pub keys: Vec<Pubkey>,
}
```
Like this
Yeah can remove the Option
Do you definitely want an *optional* vec? What difference do you want to maintain between a None vs a Some(empty vec)? Could you just have your account store a Vec, no Option part?
You'll have to check if the Option part is None
Hi <@!134416332509675520> 
How are you doing?

Could you let me know how I can push the `Pubkey` to the `Option<Vec<Pubkey>>`?
```
pub struct UserAccount {
  pub keys: Option<Vec<Pubkey>>,
}

pub fn stake(ctx: Context<Data>) {  
  ctx.accounts.user_account.keys.push(*ctx.accounts.initializer.key);
}
```
hi. i have some experience with evm and was going to write a liquidation bot. are there any protocols on solana that offer flash loans?
Doing a CPI to the Metaplex program and getting this error: `    'Program metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s failed: custom program error: 0xc'`

How do I check what Metaplex error this is?
Creating a program that interacts with the Metaplex NFT contracts and want to test it out
Can I run `anchor test` on devnet and have it deploy a program before the tests start?
https://pencilflip.medium.com/learning-solana-3-what-is-a-program-derived-address-732b06def7c1
How can I use the Metaplex NFT programs on localnet?
PDA?
Use a PDA?
you can use `msg!("{:?}", my_object)` to print out what a value looks like at any point
How would y’all enforce uniqueness of a username on a ProgramAccount? I want to add a username field and have it be unique across the application.
if i dont have the idl of a program, i cant decode the transactions yeah?
is there an easy swap to swap the build from ts target to js
if playerdata.blue_player == PubKey(0) {
            playerdata.blue_player = *ctx.accounts.new_user.key;
        }
anyone know a good way to check if an address is a null address?
when i initialise an account without giving blue_player a value, it's initialised to PublicKey { _bn: <BN: 0> }
pub struct PlayerData {
    pub red_player : Pubkey,
    pub blue_player : Pubkey,
}
but i'm not sure how to check if it's a zero address in the program
playerdata.blue_player == 0??
something like that
in your program handler you can do `ctx.accounts.user.to_info()`
is there anyway to access Signer info from a transaction?
eg. #[derive(Accounts)]
pub struct Create<'info> {
    #[account(init, payer = user, space = 10)]
    pub base_account : Account<'info, Board>,
    #[account(mut)]
    pub user : Signer<'info>,
    pub system_program : Program<'info,System>,
}
from user
is there a reason why "a seeds constraint was violated" only appears on some tests? even without touching the code
stuck on spinner, txns fail
anyone ever have issues with phantom localnet not loading?
Hmm I would test that, and let me know if it works!
so if i just want the user as a signer i don't need it to be mutable?
So it needs to change the state of the account
Because anchor is deducting lamports from `user` under the hood
gm
to create an account like this:
#[derive(Accounts)]
pub struct Create<'info> {
    #[account(init, payer = user, space = 10)]
    pub base_account : Account<'info, Board>,
    #[account(mut)]
    pub user : Signer<'info>,
    pub system_program : Program<'info,System>,
}
how come the user account needs to be mutable?
Cool thanks for that tip
ohhhhhh
By the way, I would suggest setting up your editor so you can mouse over variables and see their types
You always need to pass something of type PublicKey for those addresses/accounts. Here offer is a Keypair, so gotta pass its `.publicKey`. Whereas escrowedMakerTokens is a PDA, so it's *already* a PublicKey instance, no need to dot anything.
gotcha
so technically this instruction needs 2 total signatures
i guess to initialize it needs a signature of the account as well since it's initializing it on the blockchain. i havent worked with using `init` beyond PDAs so this is an educated guess
https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo/src/lib.rs#L162
What does this mean and how do i get a more specific error? 
(Trying to run `anchor test`)
can you post the struct in that defines all the accounts?
`offerMaker` is the signer
it is,
But what about `offer`? That's an account we initialize
is that account defined as a Signer in the program? if so, that's why
Why do we pass just the publicKey for non-TokenAccounts, but then pass the keypair for `offerMakersMakerTokens`?
I'm having trouble updating my version of anchor. Right now I'm on 0.9.0 and when I upgrade to 0.19.0 using yarn my tests start failing with `Error: Error loading workspace IDL for project`
that is ctx.accounts.from(), instead of going through the inference
Alright! thanks! I wonder why not just call .from() if that is where it will end up anyways :S
Rust is relying on type inference here: `token::set_authority` needs a CpiContext argument, so rust is smart enough to go find that `from` impl (`.into()` uses a standard rust trait, From, under the hood)
But I do not understand how ctx.accounts.into() calls the from implementation defined in the escrow program. I assume that this is something Rust-language specific but I can not figure out what

Because that is the only ways the params makes sense when looking at the set_authority implementation by anchor:

And I assume that the ctx.accounts.into(), in some way calls this function which is defined below

In the anchor/test/escrow example project, inside the initialize_escrow function the call to set_authority looks like this:
I see, thank you!
If the escrowed tokens lived at a keypair address (not a PDA), then yeah, the keypair would have to go in that `signers` array
Any time you create an account in solana (teensy asterisk here) the address needs to sign
Right. The issue is that PDAs *can't* sign from the client (not physically possible, because they're not actual public keys with corresponding private keys), so the program has to sign for it
Hmm but `signers: [offer]`  instead of `signers: [offer, escrowedMakerTokens]`
https://github.com/cqfd/quidproquo/blob/main/tests/quidproquo.ts#L100
No, here we're init-ing the escrowed tokens accounts, so it needs to sign too!
Only the `offer` signs this transaction though, so we don't need `escrowedMakerTokens` to sign
The client actually isn't passing in the seeds—its passing in the derived *address*, which is different (given just the address you can't guess the seeds necessarily)
The `seeds = [...]` annotation tells anchor how to sign for that address (necessary because we're initializing an account there—that requires a signature)

What's the point of giving `seeds` parameter if we're going to just pass the value in anyways during tests?

code: https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo/src/lib.rs#L170
test: https://github.com/cqfd/quidproquo/blob/main/tests/quidproquo.ts#L79

<@!134416332509675520>
perfect tysm
Not sure what you mean. They're PDAs derived from the associated token program: https://github.com/project-serum/anchor/blob/master/ts/src/utils/token.ts#L18
There's a lot of stuff coming in 1.9
are ata accounts derived the same way normal addresses are? eg: the seed constraints can be used interchangeably
this is to calculate the current rent stats, how much sol you need to store data and such
it's like a number but big
BN = BigNum: https://discord.com/channels/889577356681945098/889702325231427584/917910080010211328
`new anchor.BN(1234)`

What the heck is this LOL
gotcha, thanks
Don't think there's any way to do this currently, no—I think anchor would have to add a special method to Account for this
Anchor question, but maybe a rust question:
is there a one-liner i can to assign an entire account data struct to an `Account<>`
So for example:
```
let new_user:User = User { // init my 8 or 9 fields }
ctx.accounts.user = new_user; // error: expected struct `anchor_lang::Account`, found struct `User`
```
Something sorta like that i guess
That way i dont have to access each field on the ctx account to update it
Why do we need to pass this into context?:

`pub rent: Sysvar<'info, Rent>`
probably not for at least 4 more months tho
gotcha
Soon™️
the answer is soonTM
so the answer is no basically
hey, thanks
i had a discussion on the main solana discord about this:
https://discord.com/channels/428295358100013066/517163444747894795/917940076275707904
looks like solana supports it
Hi :) Can you resize solana accounts? If so, how?
I'm gonna look to the code and try to find something
Ok, i fixed the typo and the error changed: TypeError: (0 , common_1.translateAddress)(...).toBuffer is not a function. I don't know if there is more silly typos like that
🤦‍♂️
You have a caps error: PublicKey --> publicKey

lol sorry
Heh, can't seen any line numbers in there 😛
I'm testing this. I dont know why but when I remove from line 29 to 44 the error stops..
Ok, so probably the error is happening somewhere else?
I really did not expect this output

What about `console.log(dataAccount.publicKey.toBuffer())`?
sure
Can you do `console.log(dataAccount.publicKey)` real quick?
node tests
Is this in the browser? Or in your node tests
I'm trying to use my public key to generate a seed but i get this error "TypeError: Cannot read properties of undefined (reading 'buffer')". I'm sure that dataAccount.publicKey exists
ohhh interesting
It's not possible within your program to dynamically look up an account based on its pubkey—you have to have the client declare its interest ahead of time
So no way to avoid passing the account in from the client
Yeah, solana just doesn't work that way—you have to pass in *all* accounts you care about.
and then fetch the details when we need them
Why can't we just store the Pubkey of that account though?
ok yeah confirmed
testing now
`the_account.to_account_info().data_len();` might be it
To say that more clearly, the escrowed_maker_tokens needs to be a token account, which is a whole separate account unto itself, so no, it can't be part of the Offer.
Alas, the nature of solana is that you need to pass stuff every time
https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo/src/lib.rs#L169

<@!134416332509675520> : Why didn't you make `escrowed_maker_tokens` a field of the account `Offer` ? This way, users don't need to pass it in every time
oh sick ty
Ohhh. Got it. Yeah, you can do `the_account.to_account_info().data.len()` probably
ah this is less for the derive and more for if i'm interacting with the pda later on (specifically, transfering lamports from that pda to another address while ensuring the pda remains rent exempt)
im reading ur erscrow program cqfd. It's a lot better than the hackmd one, which is poorly explained and not written well
amazing
Yep
In general there's no way to automatically get a good static size, but there are workarounds—you can have your struct derive Default and then skip the `space` attribute
```
    #[account(
        init,
        payer = offer_maker,
        seeds = ["apple"],
        bump = _bump,
    )]
```
To be clear -- this initializes a new account that is located at the address of the PDA in memory... right?
any instance of a struct (like the Fanout struct specified above)
Do you mean a static size for any instance of the type?
Not totally sure what you mean—how would the account know its size at that point?
ty <@!134416332509675520> is there a way to pass in something like account.size() instead of the sum to calculate the rent exemption elsewhere in a program? so like instead of

`rent.minimum_balance(8+2+2+1).max(1)`
`rent.minimum_balance(account.size()).max(1)`


//////////////////////////////////////////////////////////////////////////////////////////

=======
>>>>>>> 20bea11087240cc616c020a0810cf4b960b99b41
