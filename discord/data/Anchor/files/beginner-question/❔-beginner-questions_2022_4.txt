I think what I can do is 

1. Read counter state in the client
2. Pre generate PDAs for next three accounts with seeds being: counter, counter + 1 ,counter + 2 
3. Pass the PDAs and args to the program
4. Program checks if PDA1 has any money or if any fields aren't defaults
5. If it exists (due to delay between  client reading counter state and program invocation) go to PDA2 and so on
6. Eventually use PDA with unique seed from the counter account that has not been used yet

Ta-Da hacky way to make a list that is accessible by index rather than by public key.
I'm just saying that if you want to use an account at some PDA, the client itself needs to specify that PDA
I mean seeds constraint in #account
What do you mean by pda correction?
can he read the state offchain and send to the instruction and checked with account constraint for pda correction?
But this is just part of how solana's performance model works: you have to pre-specify all accounts you need, which lets the runtime figure out how to run things in parallel etc.
Mm, I'm actually not sure‚Äîit must be somewhere in the solana docs but it's been a while since I've looked at them
Thanks. I wasn't sure about it. What would be good resource to read up on that, is it just from code?
There just isn't any possible way to dynamically go from Pubkey to AccountInfo
*All* accounts of interest need to be pre-specified by the client
Nope, not possible, sorry üò¨
Could you work around with CPI, where generated PDA is passed to the receipeint which will actually create it? 

Surely accounts can be created autonomously without involving client.
I think you can solve it with CPI but feels very hacky:

1. Program A checks the state of the counter account
2. Program A constructs an argument list including derived account
3. CPI from Program A to Program B
4. Pprogram B creates PDA that it was told to do and sealevel is happy


What I'm trying to do is create a list like structure but using PDAs where seed is counter.
No, any account you want to actually interact with needs to be passed in from the client
<@875698957513289789> I think instruction that update the counter cannot run concurrently because it have to write some data to the account so this should work without worry. But that's my opinion might be wrong üòì
Is it possible with anchor to derive PDA on chain rather than passing it via ctx?

I want PDA that's based on a state of another account, generating it of chain and passing the account to the program might mean that the account is not valid due to concurrent access by others. State of the account changes based on every PDA invocaiton.

I'd like to do something like this

```let (pda, _bump_seed) = Pubkey::find_program_address(&[&[counter.count as u8]], ctx.program_id);

let mut submission: Account<Submission> = borsh::try_from_slice_unchecked::<Submission>(&pda.data.borrow())?;```


So the account PDA address could not be known in advance, only after reading the other account state.
Does PDA uses public key to sign transaction? 
if yess then anyone can sign transaction on behalf of PDA, because Public key is visible to everyone. <@!134416332509675520>
I thought it was the safest way... but obviously I could have used a local keypar and then transfer the upgrade authority ü§¶
I may spend the night confirming transactions üòÖ
So unless there's some way to tell the ledger thing to just go ahead and autosign them, it's gonna be a pain
Mm, I've never tried doing that, but solana deploys take hundreds of individual transactions, each of which requires a signature
Every time I sign, it prints another ‚†§ Setting up.. line in the cli and immediately asks again for signature in the ledger
Hey guys, I'm trying to anchor deploy to mainnet using a ledger nano. It keep asking for signature of "unrecognized format" again and again. And the cli shows "‚†§ Setting up.." 

Should I keep on signing? It looks like an inifinite loop... I've accepted like 30 times already. Or should I just wait?
Can do something like this: https://discord.com/channels/889577356681945098/889702325231427584/946565378685956126
The address give belongs to that of the metadata program
Anyone know how to deploy the metaplex metadata program locally? I keep getting the error ‚Äúinstruction expected executable account‚Äù. Assuming it‚Äôs because there is not a local metadata program deployed?
any advice on just clearing paths and restarting installatin
Oh ok I see. I found some code online that never showed the passing of the account. Thanks.
does anybody have any idea why this error is happening?
Any time you CPI to a program in solana, you need to pass in the program account from the client
You need to *also* pass in that account from the client
Hi Everyone. I am trying to write a function that mints an nft, and am using metaplex to create a metadata account for it. However, I keep getting this error: "Instruction references an unknown account metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s". I know this refers to the metaplex metadata program, but have no idea how to solve this.
please can anyone help me fix this?
``` error: Invalid value for '--program-id <PROGRAM_ID>': unrecognized signer source
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }. ``` guys im getting this error when im running ` anchor test `
Hey I'm installing avm with the following command `cargo install --git https://github.com/project-serum/anchor avm --locked --force` and i'm running into this error. Any ideas on how to resolve it?
```
error: could not find `avm` in https://github.com/project-serum/anchor with version `*`
```
Cargo will fetch the specific version for you and use it building the crate
very noob question but if I specify a package with a certain version in the `cargo.toml`, do I need to have that package preinstalled or cargo build takes care of using that exact version when running build?
When is the appropriate time to use `require_key_eq` instead of  just checked in account constraint?
yh it was, but didn't work on a previous version. copy-pasting the code worked tho. thanks üôÇ
So this is the thing you want? https://github.com/solana-labs/solana-program-library/blob/master/token/js/src/instructions/syncNative.ts#L28 If you're on the latest version it should just work
Anyone who has used anchor events can explain to me how does anchor events work on Solana and how are they different from the Ethereum events, what are some of the limitations of anchor events.
Could someone explain why some instructions have the three underscores in Context?
I found an explanation for Context in a Soteria article, but still don't understand why its left blank.
Trying to understand the swap program example from anchor repo  

``` 
 pub fn swap<'info>(
        ctx: Context<'_, '_, '_, 'info, Swap<'info>>,
        side: Side,
        amount: u64,
        min_expected_swap_amount: u64,
    ) -> Result<()> {
```

https://github.com/project-serum/anchor/blob/master/tests/swap/programs/swap/src/lib.rs
https://www.soteria.dev/post/how-to-audit-solana-smart-contracts-part-4-the-anchor-framework
the spl-library is pretty bad :/
ok I fixed it, I copy-pasted the source into my source now it works
it basically translates your native sol into wrapped sol. the name is bcs it syncronizes your wrapped-sol account information with the sol lamports information as I understand
What does createSyncNativeInstruction even mean?
also how do I do this on anchor 0.20? the function doesn't seem to be exported
I just sent some SOL to the associated token account, but I can't seem to find `createSyncNativeInstruction` in the node package anymore. How do I call this function?
hey guys, I'm trying to figure out. how to convert SOL to wrapped SOL? any ideas on how to do this?
Hello, 
Can we save and use a private key in a Solana program (smart-contract) ?
I mean saving in an init transaction for example and then using it without signing (or using provider for it) in other transactions.
Time for sleep
Ok nevermind....I was using an outdated crate
I initially tried to put my payer in the `accounts` array and that didn't work.
```  let accounts = [
        ctx.accounts.mango_group_ai.clone(),
        ctx.accounts.unverified_mango_account_pda.clone(),
        ctx.accounts.unverified_mango_owner_pda.clone(),
        ctx.accounts.system_program.to_account_info().clone(),
    ];
    let result = mango::instruction::create_mango_account(
        &ctx.accounts.mango_program_id.key().clone(),
        &ctx.accounts.mango_group_ai.key().clone(),
        &ctx.accounts.unverified_mango_account_pda.key().clone(),
        &ctx.accounts.unverified_mango_owner_pda.key().clone(),
        &ctx.accounts.system_program.key().clone(),
        1 as u64,
    );
    let instruction = match result {
        Ok(is) => {
            msg!("instruction was created successfully");
            is
        }
        Err(error) => panic!("failed to create mango account: {:?}", error),
    };
    invoke_signed(
        &instruction,
        &accounts,
        &[&[
            MANGO_OWNER_PDA_SEED,
            ctx.accounts.vault.name.as_ref(),
            &[_mango_owner_bump],
        ]],
    )?;
    Ok(())```
Hey all, getting a `Transfer: insufficient lamports 0, need 30791040` error from my CPI program. I am using localnet and have confirmed my payer has sufficient SOL.
wow that is smooth, thank you
Wow, that's awesome! Never knew about this, thanks!
So `const SEED_AUTHORITY: Pubkey = pubkey!("AqH29mZfQFgRpfwaPoTMWSKJ5kqauoc1FwVBRksZyQrt");`
Way easier way actually, there's the `anchor_lang::solana_program::pubkey!` macro
wow thanks man!
You could use this https://www.better-converter.com/Encoders-Decoders/Base58Check-to-Hexadecimal-Decoder
How do we generate a Pubkey from a string literal?
For example: `Pubkey::new("PubkeyIdeallyHere")`

I found this example which is pretty much what I want to do:
```rust
const SEED_AUTHORITY: Pubkey = Pubkey::new_from_array([
    0x92, 0x17, 0x2c, 0xc4, 0x72, 0x5d, 0xc0, 0x41, 0xf9, 0xdd, 0x8c, 0x51, 0x52, 0x60, 0x04, 0x26,
    0x00, 0x93, 0xa3, 0x0b, 0x02, 0x73, 0xdc, 0xfa, 0x74, 0x92, 0x17, 0xfc, 0x94, 0xa2, 0x40, 0x49,
]);
```
And they stated above that this array is equivalent to: `AqH29mZfQFgRpfwaPoTMWSKJ5kqauoc1FwVBRksZyQrt`, but I am not seeing how this conversion was made.
If you've actually installed solana then it's going to be a path issue
Does anything solana related show up in your $PATH ?
macro
brilliant, thank you!
hey all! i'm trying to download solana cli again on my mac and I can't figure out why I keep getting this error after install
command not found: solana
I went through the whole process of updating my path in the ~/.profile and ~/.bash_profile files, but nothing seems to work
Getting a case of 3004 when trying to set new IDL buffer for my program:

```
Error: Error processing Instruction 0: custom program error: 0xbbc
```

Is it because the IDL is too large?
Anchor init/upgrade both don't work
Or do I not need to specify the signer, I just say 'mut'
this doesn't wor
```rs
#[acount(signer,mut)]
pub  initializer_account:SystemAccount<'info>,
```
How do I specify a systemAccount as both mutable and a signer?
'''
const keypair = anchor.web3.Keypair.generate();
  await program.rpc.initialize('Matlefebvre1234', {
    accounts: {
      profile: keypair.publicKey,
      author: program.provider.wallet.publicKey,
      systemProgram: anchor.web3.SystemProgram.programId,
    },
    signers: [keypair],
});
'''
   I have another newbies question haha when we use the signers keypair what are we giving exaclty? The private key or a signature ? Because i don't understand how we prove the ownership of the public key with no message to sign ?
<:SadPengu:676207925508964352>
Yeah, if you need access to a ton of accounts then maybe devnet (ew) is the right way to go üòî
so i assume it wouldn't recursively copy all the accounts the program owns too
thing is a candy machine program also has all the accounts in the config for each nft
I think you'd have to clone the program - Deploy it on localhost? I image the local validator only has the baked in Solana Library Programs
wouldn't i have to clone all the accounts of it too? or just the candy machine config
Thanks! I'm coming from an embedded C background - love the little hints! (I'm learning Rust is much better :))
You may be able to clone the account from devnet
i thought so too but im trying to replicate a candy machine in localhost but dunno how to do it each run üò¶
localnet - sooo much faster

...---...
You can experiment with this using rust's `{:p}` format syntax for printing a pointer address:
```.rs
msg!(
            "Address of random_account data {:p}",
            *ctx.accounts.random_account.try_borrow_data()?
        );
```
do you guys usually test on devnet or localhost when devving?
Okay thank for all ! ‚ù§Ô∏è
Nope, the client still has to pass in the account, so it needs to at least know the address
cqfd would know better than I. But a PDA should be able to sign an outgoing sol transaction from its own account.
Ohhhh okay ! But im very new to PDA and my understanding is that the program can sign the transaction with the seed and bump. So i taught it can sign by itself without the client knowing the seed and bump ?
You have to pass it in as an account from the client
Okay thanks ! But ma last problem is that the from keypair is a PDA . Do you know how i can transform a PDA into a  account_info ?
Yep
Dope! `Program input parameters start at 0x400000000` I take it?
Neither stack nor heap
Yeah, good question! In a totally separate part of the memory map: https://docs.solana.com/developing/on-chain-programs/overview#memory-map
Interesting! Thanks a million man! 

Last thing, the account loader, this allows us to use up to the 10MB. If I understand correctly, it just give us access to the pointer of the account.  If this is the case, where is the actual data account located?
No, it costs extra compute üòõ
Can you free up compute this way?
Which means that, yeah, sometimes you can relieve stack pressure just by wrapping some code up into a helper function and invoking it‚Äîdoing so gives you a fresh 4kb of stack to play with
The way you get a new stack frame is by invoking a new function (each frame is per-function call)
AccountLoader would also work though, but usually only necessary for really big accounts
Puts stuff on the heap, releaving stack pressure
What's the box do? I was thinking about converting things into an Account_Loader
Can often use `Box<Account<'info, TheAccountType>>`
But yeah, if you're `await`ing everything, then you'll get more throughput by using multiple processes
I would really be surprised if that happened‚Äîyou can throw a ton of requests from a single node thread if you use promises correctly
Here is a code snippet from one of my projects - hope it helps!

imports -> `use anchor_lang::prelude::*;`

Passed in -> `pub system_program: Program <'info, System>,`
The from account needs to be a signer

Function -> 
```
            let instruction = anchor_lang::solana_program::system_instruction::transfer(
                &ctx.accounts.from.key(),
                &ctx.accounts.to.key(),
                lamports,
            );
    
            let response = anchor_lang::solana_program::program::invoke(
                &instruction,
                &[
                    ctx.accounts.from.to_account_info(),
                    ctx.accounts.to.to_account_info(),
                ],
            );
```
Hey guys ! I want to use the transfer function of anchor to send Sol but i can't import the Transfer struct to use for the CpiContext  anchor_lang::system_program::Transfer  it said that Transfer don't exist and that System program is private ? https://docs.rs/anchor-lang/latest/anchor_lang/system_program/struct.Transfer.html
'''
Would an account loader help?

 `pub big_data_account: AccountLoader<'info, BigDataAccount>`
Is there a good way to align memory in the stack? Like if I needed a lot of accounts to be passed into a function?
i'd imagine when doing it this way, the tps output would be multiplied by the number of cores your cpu has.
Thanks for letting me know man! (And hey, you got 2x speed!)
yea this is what i did got 4 TPS on a heavy method and 10 TPS on a quick method. Old computer :\
Basically since you can already throw a ton of requests at a validator from a single JS thread
I wouldn't expect much speed up versus just running your ts stuff in parallel (so, not synchronizing everything await over and over again)
Any thoughts on this? <@!134416332509675520>
I'd be interested to see if you can get some speed improvement by spinning up the validator and running multiple test scrips at once.

typescript is single threaded.

What I think you'd have to do to try:
1. You'll have to spin up your local validator w/o anchor
2. setup you tests.ts to load up a provider that is not anchor.Provider.env()
3. run the ts-node tests.ts on several terminals
Just don't do `await thing1; await thing2; await thing3` etc.
No threads probably (it's js) but you can do async things in parallel
its not the validator that is slowing it down, its the javascript/ts tests that are done synchronously. even a local validator can theoretically support hundreds of tps
Sure, but I don't think your local validator is going to work any faster this way.
can i spawn multiple threads on it? its all synchronous right now
Also, could someone point me in the direction of some reading? I want to understand the stack better. It seems I get errors like this when I pass in too many accounts to a function. Am I passing in too much? Or do I have to align the memory and somehow request another stack frame?

`Program failed to complete: Access violation in stack frame 3 at address 0x200003fa0 of size 8 by instruction #34761`
Yeah, they're going as fast as they can lol
From what I know, using localnet is the fastest way to test a Solana function
is there any way in anchor to run the anchor ts tests faster? (like a stress test?)
Lol, that's genuinely a pretty fun hack, nice one üòõ
getLowComputeAddress()  ... 100% success rate lol hax
When using `connection.getParsedAccountInfo` is there a way I can parse the data that I get into some layout/class? For example, I know that I am fetching info about a mint, but typescript doesn't know that
You can use `Pubkey::default()` if you want
bc obviously "0" can't be Pubkey and it says me this. But how do I validate then?
hey. How to check that in my struct Pubkey field is not empty? Doing like this gives me an Error
No worries, appreciate the framing
Although again I'm just guessing there
Oh interesting
Ah, yeah, I think explorers must have to do something fancier where they have like a local postgres etc. that they stuff things into, I don't think they're looking directly on-chain per-se
But like, solscan can lookup full transactions an arbitrarily long time ago, so it is accessible on chain s o m e h o w
Thought I have no idea if that's actually what real validators do
Mm, yeah, good question, I'm pretty fuzzy on this too. I think the idea is that at any given moment a validator doesn't need to store that whole history‚Äîall you can access "right now" is the current-ish state of the chain (I think it's like a couple days worth), not whatever it looked like at some arbitrary point in the past.
(Also no need to walk me through a 101 on this, but if you have a useful primer link you know, would be appreciated <:bulba:747166770250514452>)
(What's prompting this for me is looking into arweave and going 'how can blockweave guarantee true data permanence, it's like a giant RAID but how does this possibly scale indefinitely', and then looking back at blockchain itself and being like 'wait a minute how does this simpler version work too)
Related, does each validator know the totality of current on-chain state (essentially), or is that also distributed where processing/validating a transaction requires fetching data from various nodes?
(Not actually anchor related at all, but this place is just so friendly to blockchain newbs...<:bulba:747166770250514452>)

Where is blockchain history 'stored'?
- Assumption(?): The amount of data required to reference the entirety of a blockchain's history grows without limit over time, scaling on activity
- Assumption: On a chain with Solana's activity, we (already have/will <:SoonTM:836971196674211901>) surpassed the amount of space reasonably available to a validator node, even with their beefy specs
- If both of the above, we must have some distributed answer to this.

Am I wrong on Assumption 2 or what does the answer here look like?
Ha, that's pretty good (/ brutal lol, sorry you're in this spot)
i guess i could write a client side hack that would pre-check for chain of pdas with high bumps before deciding on the deriving key
Yea, i see what you're saying. The PDAs that i'm creating via a CPI allow the bump to be set using the anchor account specification, so I should probably change those back to be sure
we have created an issue to just remove bumps btw but it currently looks like it wont get implemented https://github.com/solana-labs/solana/issues/23613
but even if not necessarily insecure, it would make the programming model weirder. rn if you e.g. have a user and a user stats account in a game, there can only ever be one user stats account for the user. If we remove this, there can be multiple
it actually doesn't necessarily mean that it's insecure as long as you save the bump in state. But as long as anchor doesn't do it automatically, it's a footgun
accepting PDAs without checking that they use the canonical bump means that incoming PDAs are no longer deterministic as two PDAs with the same seeds but different bumps will be accepted by a `seeds = ` check
it is
unless its for security reasons?
i'm creating 3 accounts in my ix, (2 are CPI'd and init'd), and passing in two bumps from client and those are saving compute. Why wouldn't I be able to send in the bump for my anchor init'd account too ? Could this be reverted or made optional? https://github.com/project-serum/anchor/pull/1380/commits/92baf8bec124671e35b5e39e5959212c0957bf16
yea you could do that but as you said thats not efficient on the client. You could probably build a way to make it reasonably fast by building a custom index if you run your own nodes but idk whether thats a good idea when PDAs just do it for you so easily
I think the issue above is that they're so close to the compute limit that even that init canonical check is too much
the best practice is to not ever send them from the client but save them in the state on init instead. and then read from state. Anchor will do this for you in the future and hide bumps from users completely
You mean new instruction arguments? Yeah that's the only way
Is there a best practice way of sending the bumps from the client? right now I'm just adding new variables
No, though tbh I'm not totally sure why anchor doesn't let you do this‚Äîusually it's not a big deal but, yeah, sometimes it might be important
is it possible to set the bump of an init account? (calculated client side like the others)
Ah, ok, yeah, you want to use real bumps when not-init'ing (it does save compute)
Yes. 1 of the 4 is init (so i can't pass that bump in), 2 of the 4 are init via a CPI to metaplex but are annotated as mut in my program so i can set the bump manually, and the last is an existing PDA account that i just set manually.


//////////////////////////////////////////////////////////////////////////////////////////

how can I print a more detailed error-message of the program-call (`provider.send`) on the browser-side?
mb
oh okay nice ^^ i updated everything excepted solana x)
You need to update your version of solana, that's super old
someone already had this error: ```BPF SDK: /root/.local/share/solana/install/releases/1.5.7/solana-release/bin/sdk/bpf
Running: /root/.local/share/solana/install/releases/1.5.7/solana-release/bin/sdk/bpf/rust/xargo-build.sh
error: failed to parse manifest at `/root/wtcrpc/backend/programs/backend/Cargo.toml`

Caused by:
  failed to parse the `edition` key

Caused by:
  supported edition values are `2015` or `2018`, but `2021` is unknown``` ? thanks for answers ^^
hey
can u tell me why im getting this error?
ok cool
Yes, that tutorial is too old at this point to be a good source of anchor info, just read the anchor book/docs
so i shouldnt follow the tutorial and instead go through the docs?
So old that I hadn't even started looking at anchor yet so I wasn't aware that used to be valid anchor syntax!
Ah, ok, yeah, that tutorial is very old: https://github.com/Henry-E/dog-money/blob/main/programs/dog-money/Cargo.toml#L18
is it because the tutorial is old, and the syntax might be updated?
and he has done pretty much the same thing
this is his github repo
https://github.com/Henry-E/dog-money/blob/main/programs/dog-money/src/lib.rs
So yeah, I would suggest just carefully going through a tutorial, typing literally exactly what they have, etc.‚Äîyou have enough things in that snippet that just aren't valid anchor that I think you should step back and be extra careful about what you're typing in
#[associated] isn't an anchor attribute, not sure where you got that from
`#[account(associated = authority, ...)]` isn't valid anchor syntax for example‚Äîyou'd have to use `associated_token::authority = authority, associated_token::mint = usdc_mint`
https://www.youtube.com/watch?v=i6Ycr5nhjH8&t=153s im following this
Mm, you have quite a few things wrong here, I would suggest that you work through some anchor tutorials
and im getting a ton of errors, can anybody tell me how to solve this?
and this is my lib.rs program ```rust
use anchor_lang::prelude::*;
use anchor_spl::token::{Mint};
use anchor_lang::solana_program::entrypoint::ProgramResult;
use anchor_lang::accounts::program_account::ProgramAccount;

declare_id!("3C1Kfk1iB4cPXDRNHXck11X8V5c6n4wCJdxDvW8Zfmmb");

#[program]
pub mod dog_money {
    use super::*;

    pub fn initialize_user(ctx: Context<InitializeUser>) -> ProgramResult {
        Ok(())
    }
}

#[derive(Accounts)]
pub struct InitializeUser<'info> {
    program_signer: AccountInfo<'info>,
    #[account(associated = authority, with = usdc_mint)]
    user_data: ProgramAccount<'info, UserData>,
    #[account(signer)]
    authority: AccountInfo<'info>,
    usdc_mint: CpiAccount<'info, Mint>,
    rent: Sysvar<'info, Rent>,  
    system_program: AccountInfo<'info>,

}


#[associated]
pub struct UserData {
    pub first_deposit: i64,
}



 ```
guys im getting this
#[derive(Accounts)]
#[instruction(bump: u8)]
pub struct CreateRaffle<'info>{
  
    #[account(mut)]
    pub owner: AccountInfo<'info>,
    #[account(init_if_needed, payer = wallet, space = 8+4+650)]
    pub raffle_account: Account<'info, RaffleAccount>,
    #[account(init_if_needed, seeds = [b"winneraccount8".as_ref(), wallet.key().as_ref()], bump = bump, payer = wallet, space=8 + 2 + 4 + 200 + 1 + 96)]
    pub winner_account: Account<'info, WinnerAccount>,
    #[account(mut)]
    pub wallet: Signer<'info>,
    pub system_program: Program<'info, System>,
    pub rent: Sysvar<'info, Rent>,
}
So this is my create_raffle func and the context is:
pub fn create_raffle(ctx: Context<CreateRaffle>, bump: u8) -> ProgramResult{
        let payer = &mut ctx.accounts.wallet;
    
            let winner_account = &mut ctx.accounts.winner_account;
            let participants_account = &mut ctx.accounts.raffle_account; 
        }
        Ok(())
    }
also how do you define the context?
can you do code-formatting like this ``` code ```
My winner account is a pda
pub fn get_winner(ctx: Context<GetWinner>) -> ProgramResult{
        let mut contestants: [i16; 7] = ctx.accounts.raffle_account.contestants;
        ctx.accounts.winner_account.winners[0] = contestants[1];
        ctx.accounts.winner_account.winners[1] = contestants[3];
        ctx.accounts.winner_account.winners[2] = contestants[4];
Ok(())
    }
The accounts are:

#[account] 
pub struct WinnerAccount{
    pub winners: [i16; 3],
    pub length: u8,
}

#[account] 
pub struct RaffleAccount{
    pub contestants: [i16; 7],
    pub length: u8,
}
can you post some code?
what do you mean you assign values inside the array?
Could somebody please answer? I'm really stuck..
No
Hey, Ive cloned anchor/tests/escrow and I lunched the tests, first I needed to add "///CHECK" above every AccountInfo property in struckts. Now, they are still failiing and I wonder is it something wrong with tests or with my local environment. Thanks in advance
Hey!
Is it possible to initialize a new account without a discriminator?
Thanks!
Hello, I am creating a pda which has an array.. But I am not able to assign values inside the array.. Why is that?
Error: RPC request error: cluster version query failed: error sending request for url (https://api.devnet.solana.com/): operation timed out
got it -  pub token_program : Program<'info,Token>
The spl token program. You need to ask it to please transfer the tokens
I can't seem to link to it but the `constraint = ` form is discussed on that page
btw what is cpi_program in context of token transferring - 
```rs
    let cpi_program = ctx.accounts.token_program.clone();
```
it does mention about owner being the program owner but not this one  : constraint=<expr>
I see. i was looking at this page its not documented here -https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html#normal-constraints.
The `owner` constraint is for the program owner
`#[account(constraint = token_account.owner == token_account_owner.key())]` instead
not working for me
has anyone tried owner constraint on a tokenAccount - 
```rs
   #[account(owner=token_account_owner.key())]
   pub token_account: Account<'info, TokenAccount>,
   pub token_account_owner : AccountInfo<'info>,
```
And take a look at the Anchor.toml to see if anything looks out of place
Try adding some `console.log`s in there etc. to see if that file is even running
Are you sure? If the workspace failed to load it would do so silently.
It fails to do anything, it jusyt quits. 

workspace fails to load.
What do you mean by it fails every time on that line, if you don't see an error?
Moved all my anchor code to a new directory. Nothing else and now unable to run any tests.

Commented out all the files except one and that program has nothing in it.

It fails every time on this line:

```  const program = anchor.workspace.Example1;```

But it doesn't display any error, just this.

```0 passing (0ms)```


Any idea why?
okay
It's still needed
in such case the authority field is no longer needed I'd assume
E.g. with `CpiContext::new_with_signer`
Yep. You would need your program to sign for that PDA though using its seed + bump
```rs
{
  let ata = await createAssociatedTokenAccount(
    connection, // connection
    feePayer, // fee payer
    mintPubkey, // mint
    alice.publicKey // owner,
  );
}
```
so in this case if i provide a pda in place of "alice.publicKey", the owner or authority will be the pda and only the program could transfer the tokens to other token account. Correct?
ok
Depends on what you set the authority to be when you created the token account
if i want to transfer tokens that is in a PDA account, the authority is the program itself?
So if I want to transfer you some of my tokens, I need to sign the tx (otherwise the spl token program will refuse to decrement my token balance)
It's whoever owns the tokens (like, a person or whatever‚Äîthe program owner of the token account is the spl token program, as usual)
what's the authority in this case - 
```rs
      Transfer { 
        from: token_account.to_account_info(), 
        to: account.to_account_info(), 
        authority: token_account.to_account_info(),
      }
```
Hello, i'm trying to do `anchor verify` and this is my tail output
```Copying out the build artifacts
Cleaning up the docker target directory
Removing the docker container
anchor-program
Extracting the IDL
Writing the IDL file
Writing the .ts file
Build success
Error: package section not provided```

Any insight on what package section is?
thanks both!
ah it was the wildcard
yus, 
for an eg, like this 
```
mod context;
use context::*;
```
how are you importing your file
your problem is likely that youre not using wildcard imports
see https://book.anchor-lang.com/chapter_3/milestone_project_tic-tac-toe.html#program-directory-organization
it is working perfectly fine for me


//////////////////////////////////////////////////////////////////////////////////////////

üëã  Hi everyone, 
I am confused with the difference between  `#[derive(Accounts)]` and `#[account]`  
Any easy explanation on this ??..thnx!!
Ok, at any rate, that version of anchor requires you to not use bumps when doing `init`
0.21.0
What does `anchor --version` say at the terminal
The Cargo.toml inside the `programs/your-prog-name` directory
As anchor version is 0.21.0, Two machines are same.
where do i add the compilation settings , so as to optimize them such that `anchor build` uses that ?
that did the trick! thank you üôÇ
ahh ok thank you
you might be using an outdated rust version
anyone run into this error when trying to install anchor?
I was going through tictactoe program on project-serum/anchor, i want to know why we are using  asterisks with dashboard.to_account_info().key, i am getting same result without it
``` pub fn initialize_dashboard(ctx: Context<Initializedashboard>) -> Result<()> {
        let dashboard = &mut ctx.accounts.dashboard;
        dashboard.game_count = 0;
        dashboard.address = *dashboard.to_account_info().key;
        Ok(())
    }```
I found the issue HAHAHA, turns out I had a duplicate of the struct somewhere else in my code. When i deleted the duplicate, the idl generated successfully!
That's because different versions of the anchor cli behave differently here
I will try to figure this out, thanks so much for the help!!
I had done building this contract on my machine, but I failed to try  on AWS ubuntu vps.
In your contract, whenever you use `init` you now need to *not* use an explicit `bump = the_bump`, but rather just do `bump,`
I tried to run command `anchor keys list`
this is error image.

I get errors to use anchor
please help me using anchor
Hello.
Not sure, is there anything weird in your Anchor.toml maybe?
Is there a config that could cause that?
Unless you have a setting or something someplace that is turning off checks
Mmmm that shouldn't happen
My machine is weird
Usually the lack of a CHECK comment fails only when i run anchor test, anchor build will run fine
I'm skeptical since you're going to need a CHECK comment, so I would have expected anchor build to fail
Yeah pretty sure I did
And you'll need a CHECK comment too
And they would need to be `#[account(mut)]` since you're changing their balance
Sounds like you're not building the IDL correctly (I don't know, did you forget to save the file?)
Yes, you'd need to pass the recipient in as another account
But how should I pass the `who_to_send_the_lamports_to` into the instruction? Should I define it as an AccountInfo?
```
#[derive(Accounts)]
pub struct TransferToken<'info> {
    #[account(mut)]
    sender: Signer<'info>,
    #[account(mut, close=receiving_lamport)]
    receiver: Account<'info, ReceiverDetails>,
    #[account(mut)]
    receiver_token_account: Account<'info, TokenAccount>,
    #[account(mut)]
    sender_token_account: Account<'info, TokenAccount>,
    receiving_lamport: AccountInfo<'info>,
    /// CHECK: This is not dangerous because we don't read or write from this account
    token_program: AccountInfo<'info>
}
```
I run anchor build on this, but `receiving_lamport` does not appear in the idl. Not sure if im doing this correctly ü•≤
<@134416332509675520>  I am trying to call the anchor program from server side
This is the Code where i am getting error
`   const idl = Idl as anchor.Idl;
      const programId = "EoBG2VasooF76AX25K6Bsm8BMnimMKQi6JcFj6CMCSA1";
      console.log("ERROR");
      const pId = new anchor.web3.PublicKey(programId);
      const program = new anchor.Program(idl, pId);`
I am getting this `TypeError [ERR_INVALID_ARG_TYPE]: The "path" argument must be of type string or an instance of Buffer or URL. Received undefined`
Yep, the `close = who_to_send_the_lamports_to` can send the lamports to whoever you want
Hi guys! Is it possible to close an account, and refund the rent back to a SystemProgram account/wallet which is not a signer of the transaction?
ytoken metadata crate got updated to 1.2.6 , which now use solana 1.9.5 does that mean we can use it with anchor now ? how do i check what solana version is anchor using ?
Looking at https://github.com/project-serum/anchor/blob/master/tests/tictactoe/tests/tictactoe.js#L3
`dashboard` is just generated, and there's no explicit funding for that account. I'm doing the same
<@717956950737813594> What I'm saying is, so that the anchor deploy can be successful
otherwise, anatoly will kill you, xD
you can airdrop max 2 sol ser
too much ser, do reduce it lol
` Program log: Memo (len 40): "request too large; req: ‚óé45, cap: ‚óé2"`
```ningfei@192 solbd % solana confirm -v 3CteDeEnwjhL7JXiTZAxDpxXKqgeAfic3hPNq3VSEatvxqKzGughtUpreSBxiZUb2RHY93VdLitBbzt4rtaL7jco
RPC URL: https://api.devnet.solana.com
Default Signer Path: /Users/ningfei/.config/solana/devnet.json
Commitment: confirmed

Transaction executed in slot 127327217:
  Block Time: 2022-04-11T21:59:22+08:00
  Version: legacy
  Recent Blockhash: 5q7wqTQn8XxU5seKXfYA53UefnWkn1FKJH22BNeJj4SE
  Signature 0: 3CteDeEnwjhL7JXiTZAxDpxXKqgeAfic3hPNq3VSEatvxqKzGughtUpreSBxiZUb2RHY93VdLitBbzt4rtaL7jco
  Account 0: srw- 9B5XszUGdMaxCZ7uSQhPzdks5ZQSmWxrmzCSvtJ6Ns6g (fee payer)
  Account 1: -r-x MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr
  Instruction 0
    Program:   MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr (1)
    Data: "request too large; req: ‚óé45, cap: ‚óé2"
  Status: Ok
    Fee: ‚óé0.000005
    Account 0 balance: ‚óé19337719.982879944 -> ‚óé19337719.982874945
    Account 1 balance: ‚óé0.52149888
  Log Messages:
    Program MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr invoke [1]
    Program log: Memo (len 40): "request too large; req: ‚óé45, cap: ‚óé2"
    Program MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr consumed 33081 of 200000 compute units
    Program MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr success

Finalized```
<@717956950737813594> 
What should i do now
thanks!
lol
0x1 generally mean insufficient fund
do you have enough sol
```rs
const JOB_SETTINGS: &'static [u8] = b"JOB_SETTINGS";

#[program]
pub mod staking {

    use super::*;

    pub fn initialize(ctx: Context<InitializeJobFactory>) -> Result<()> {
        Ok(())
    }
}

#[derive(Accounts)]
pub struct InitializeJobFactory<'info> {
    #[account(init,
        seeds = [JOB_SETTINGS],
        bump,
        payer = authority,
        space = 8,
    )]
    pub job_factory_settings: Account<'info, JobFactorySettings>,
    #[account(mut)]
    pub authority: Signer<'info>,

    pub system_program: Program<'info, System>,
}

#[account]
pub struct JobFactorySettings {}
```
```ts
describe("staking", () => {
  // Configure the client to use the local cluster.
  const provider = anchor.Provider.env();
  anchor.setProvider(provider);

  // const wallet = provider.wallet;
  const keyPair = anchor.web3.Keypair.generate();

  const program = anchor.workspace.Staking as Program<Staking>;

  it("Is initialized!", async () => {
    let jobAdId = "JOB_SETTINGS";

    const [jobFactorySettingsAccount] = await anchor.web3.PublicKey.findProgramAddress(
      [Buffer.from(jobAdId)],
      program.programId
    );
    // Add your test here.
    const tx = await program.rpc.initialize(
      {
      accounts: {
        jobFactorySettings: jobFactorySettingsAccount,
        authority: keyPair.publicKey,
        systemProgram: SystemProgram.programId,
      },
      signers: [keyPair],
    },
    );
    console.log("Your transaction signature", tx);
  });
});
```
Hi! 

I'm getting: 
```
  staking
    1) Is initialized!


  0 passing (92ms)
  1 failing

  1) staking
       Is initialized!:
     Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: custom program error: 0x1
      at Connection.sendEncodedTransaction (node_modules/@solana/web3.js/src/connection.ts:4052:13)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at Connection.sendRawTransaction (node_modules/@solana/web3.js/src/connection.ts:4014:20)
      at sendAndConfirmRawTransaction (node_modules/@project-serum/anchor/src/provider.ts:286:21)
      at Provider.send (node_modules/@project-serum/anchor/src/provider.ts:120:14)
      at Object.rpc [as initialize] (node_modules/@project-serum/anchor/src/program/namespace/rpc.ts:24:16)
```
`G362mMEcApxKNyoC7y52gM9bpkrhyxU4oFNsxKyYzvvo` this is your program adderss.
`HAkyg4bdnvmhjFDQDfD1JTRtwp6tEPaqhS57ErFQFy12` this is the address which deployed the program in first place.
`3DD8Hkx7Jj5xRVXcBHsooigpFQgipCfouQvWsUJacvqg` this is the address trying to upgrade `G362mMEcApxKNyoC7y52gM9bpkrhyxU4oFNsxKyYzvvo` but because he is not the authority he can't hence error
and There is no G362mMEcApxKNyoC7y52gM9bpkrhyxU4oFNsxKyYzvvo in app/src/idl.json
```ningfei@192 solbd % solana program deploy /Users/ningfei/solbd/target/deploy/solbd.so

Program Id: G362mMEcApxKNyoC7y52gM9bpkrhyxU4oFNsxKyYzvvo

ningfei@192 solbd % 
ningfei@192 solbd % anchor test

BPF SDK: /Users/ningfei/.local/share/solana/install/releases/1.10.7/solana-release/bin/sdk/bpf
cargo-build-bpf child: rustup toolchain list -v
cargo-build-bpf child: cargo +bpf build --target bpfel-unknown-unknown --release
    Finished release [optimized] target(s) in 0.73s
cargo-build-bpf child: /Users/ningfei/.local/share/solana/install/releases/1.10.7/solana-release/bin/sdk/bpf/dependencies/bpf-tools/llvm/bin/llvm-readelf --dyn-symbols /Users/ningfei/solbd/target/deploy/solbd.so

To deploy this program:
  $ solana program deploy /Users/ningfei/solbd/target/deploy/solbd.so
The program address will default to this keypair (override with --program-id):
  /Users/ningfei/solbd/target/deploy/solbd-keypair.json
Deploying workspace: https://api.devnet.solana.com
Upgrade authority: /Users/ningfei/.config/solana/id.json
Deploying program "solbd"...
Program path: /Users/ningfei/solbd/target/deploy/solbd.so...
Error: Program's authority Some(HAkyg4bdnvmhjFDQDfD1JTRtwp6tEPaqhS57ErFQFy12) does not match authority provided 3DD8Hkx7Jj5xRVXcBHsooigpFQgipCfouQvWsUJacvqg
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), st```
if it's super urgent, lmk your sol address I'll give you some
do try again :))
ser `operation timed out`
why can't airdrop?
Or maybe you could on different rpc
Again & again
Not a issue ser, just try again
<@717956950737813594>
referencing here https://book.anchor-lang.com/chapter_5/space.html
what's the size of an enum with no types attached eg. ``` enum  Status { On, Off, Broken }``` 1 + largest variant size, do this variants have any size?
Account is easier to use but uses serialization (borsh); AccountLoader is a little bit harder but doesn't use any serialization at all (it's for zero_copy accounts), so it's more efficient and can support much larger account sizes‚Äîbut it's harder to use, so usually your life will be simpler if you just use Account.
How can I check how much space is needed ? (Here I have hardcoded to 24 bytes)

```#[account(init, seeds = [pool.mint.as_ref()] , bump, payer=payer, space = 24)]
    pub signer: AccountInfo<'info>```
What are the use cases of Account<'info, Struct> and AccountLoader<'info, Struct>? When should we use what??
do one quick dirty hack, delete the whole `target` folder and run anchor build once again. and then replace declare_id with the new one you got from `anchor keys list`, and also change it on Anchor.toml file
tho, this is not possible, you can't change it on runtime
afaik, `declare_id!(....)` is only meant for declaring program address a.k.a smart contract address.
need help

Some more context, I have an `update_authority` hardcoded in the program. And then in tests, I wanna change that dynamically to a test environment specific `update_authority` cause I'll be testing with the corresponding Keypair.
Is there any way I can change the addresses that were hardcoded using `declare_id` while running tests?
1.58.1
What version do you got?
try to upgrade latest one
What version of rust are you using? `rustc --version`
Legit cannot find a solution anywhere somebody please help
getting this issue and i dont know what to do. Have tried running it again with WSL2 but still the same error
What are the best practices of auditing before releasing a program publicly? My programs include vault accounts that hold onto users NFTs and the ability to mint a token so these things have to be airtight.  Is there anywhere I can go to find people offering this service? or even discord servers where people cross audit eachothers programs multiple times over?
`catch (err) { expect(err.error.errorMessage).is.equal("test") }`
like this `err.error.errorMessage`
ok so you need to access the parent variable here first

I think the syntax is right
can you console log the `error` once
error.errorMessage is undefined, maybe not the right syntax to get the errorMessage?
it should suppose to work, tho you can also try this
`expect(error.errorMessage).is.equal("test")`
that produces this
`assert.equal(error.errorMessage, 'test'),`
trying to do something like
assert.equal(error, 'test'), where error is the errorMessage
how can I get just the errorMessage from a test? 
console.log(error) shows a lot of information
Hi, Is it possible to find an associate token address like the javascript method `getAssociatedTokenAddress` in anchor rust?
https://docs.solana.com/developing/plugins/geyser-plugins "overview"
can anyone give a tldr on the recently introduced geyser plugins on solana ?
https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html

last transaction before it seem to have deployed was this
It produced a program id which I assume means it compiled and deployed to test net. I was wondering if since this is an open source escrow program I cloned if it was building out test transactions or something, or if it's programmatically creating new accounts for escrow and paying the rent ahead of time and thats what's eating the large amount of solana in the end?

So I'm still super new to rust and programming in general but I've been stuffing my brain for a few months and tried to deploy this program. https://github.com/tomoima525/escrow-program. I got it deployed on test net, but the thing ate like 2 solana in the process and was wondering if these were test transactions or if solana programs depending on what they're doing cost a lot to deploy? https://solanabeach.io/address/AwEP3csHURUFi9cSpdCDxyxgLxwbY6Nye9m37UpemGNw?cluster=testnet
what does info mean and whats the tick syntax

whats with all the 'info
Account<'info, Whatever>
Have you tried removing it and seeing what kind of error message you get?
`to_account_info(),` why we use this ? <@134416332509675520>


//////////////////////////////////////////////////////////////////////////////////////////

Hi, can I somehow get hold of transaction ID in an executing program?
I'm getting an error `Error: Transaction was not confirmed in 30.00 seconds. It is unknown if it succeeded or failed. Check signature <SIGNATURE> using the Solana Explorer or CLI tools.` does any one know why this is happening when running `anchor test`?
Hi everyone, 
I am confused with the difference between  #[derive(Accounts)] and #[account]
Any easy explanation on this ??..thnx!
thanks! it should automatically run `cargo fmt` in background on save or I need to do some tuning?
rust-analyzer 100%
also how does the 'was not confirmed in 30 seconds' error work with the retries specified in the provider connection?  if ive specified 20 maxRetries in the Provider constructor, will the aforementioned error indicate that 30 seconds has passed after 20 retries or after the first try?
gotcha.thanks!
with newer anchor version you need to use:
```
program.methods
        .yourMethod(parameters)
        .accounts({
          // accounts...
          authority: userWallet.publicKey,
          systemProgram: anchor.web3.SystemProgram.programId,
          tokenProgram: TOKEN_PROGRAM_ID,
          rent: anchor.web3.SYSVAR_RENT_PUBKEY,
        })
        .signers([additionalSigners])
        .rpc();
```
the tutorials show to use the program.rpc.method() for sending transactions, but the documentation and warnings I get say that is deprecated.  Is there a guide for the alternative / updated means?
anybody can give advice on a good vscode setup for rust+anchor? I've used for months `rust-lang.rust` extension but I'm trying to move to `rust-analyzer` as it seems more maintained. I'm having also some problem with `fmt` onSave, maybe some conflict with prettier... any advice?
Thanks
https://docs.rs/anchor-spl/latest/anchor_spl/ this might help
If anybody could point me to some docs
Hello!!! I am having trouble understanding how to work with NFT's in anchor.. How to create them? And how to send them from on wallet to another using anchor
thanks!
https://book.anchor-lang.com/chapter_5/avm.html
use `avm`
I guess I Can go into ~/.cargo/bin/anchor and rename stuff and do it the ghetto way
Do you guys know how to cargo install specific anchor-cli with specific alias so I can have multiple? For example: `cargo install --git https://github.com/project-serum/anchor --tag v0.20.1 anchor-cli --locked` that I can use like `anchor-v0.20.1 build`
that's you would do it in solidity
how can i test for emits? eg. `expect(some rpc).to.emit({a:1, b : "hello"})`
Nope!
hey, do i still need to init PDA to sign transactions with that PDA?
you need to change the address of the program to whatever your local keypair has deployed
what's the best way to decrease the size of the smart contract? I just checked the bytes of the contract, about half of it seems to be zero bytes. any guides on what things to possible check?
When I run 'anchor test' after cloning step-staking, the test isn't running and not sure why

https://github.com/step-finance/step-staking
help
hlep
need hlep

Funding wallet with enough sol should this issue for me
```ningfei@192 solbd % anchor deploy
Deploying workspace: https://api.devnet.solana.com
Upgrade authority: /Users/ningfei/.config/solana/id.json
Deploying program "solbd"...
Program path: /Users/ningfei/solbd/target/deploy/solbd.so...
===============================================================================
Recover the intermediate account's ephemeral keypair file with
`solana-keygen recover` and the following 12-word seed phrase:
===============================================================================
desert receive ritual cart time bonus youth decrease coyote pledge craft barely
===============================================================================
To resume a deploy, pass the recovered keypair as the
[BUFFER_SIGNER] to `solana program deploy` or `solana write-buffer'.
Or to recover the account's lamports, pass it as the
[BUFFER_ACCOUNT_ADDRESS] argument to `solana program close`.
===============================================================================
Error: Deploying program failed: Error processing Instruction 1: custom program error: 0x1
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.
ningfei@192 solbd % ```
had to use the solana_program crate for the pubkey! macro,
same dsnt work for me either üò¶
how do you resume a failed anchor deployment?  i see the docs for using 'solana deploy program' to recover, just wondering if anchor has something to do it?
You can then update that metadata until you set updateAuthority to null on that metadata account
Part of step 3 is passing in the data.
Generic NFT 101:
- Create mint account
- Mint a token to an SPL token account (possibly an ATA).
- Create token metadata acccount (this has to be done before or in the same tx as the next step or that will fail btw)
- Set mintAuthority to null
https://docs.metaplex.com/architecture/basic_flow does a pretty decent job of explaining the flow
Is there any purpose to holding onto the secretkey of a mint account after you've set mintAuthority to null (I know that creating a metadata account is one particular use case - any others?)
how is data attached to tokens? I'm thinking in the case of someone attaching their website to a token.
my guess thus far is you would `initialize_mint` with the anchor_spl library, and then `create_metadata` from anchor_spl_token_metadata, but i'm wondering how these get tied together under the hood (or if i'm completely off track, how this works to begin with).
Yea it is a bug, I think there is a PR in progress to fix it
I dont fucking understand why I can't even run something as simple as anchor build
I have been stuck on this for days
somebody please

Oh, seems linked to https://github.com/project-serum/anchor/issues/1628
In Cargo.toml of `lala` I put:
```toml
[dependencies]
anchor-lang = "0.23.0"
lala-puppet = {path = "../lala-puppet", features = ["cpi"]}
```
Hi! Trying to create two programs, where one is a dependency of the other one. Similar pattern to the `puppet` crate.
I am getting:
```
error[E0107]: this struct takes 0 lifetime arguments but 1 lifetime argument was supplied
  --> programs/lala-puppet/src/lib.rs:5:1
   |
5  | #[program]
   | ^^^^^^^^^^- help: remove these generics
   | |
   | expected 0 lifetime arguments
   |
note: struct defined here, with 0 lifetime parameters
  --> programs/lala-puppet/src/lib.rs:15:12
   |
15 | pub struct Initialize {}
   |            ^^^^^^^^^^
   = note: this error originates in the attribute macro `program` (in Nightly builds, run with -Z macro-backtrace for more info)
```

I creted `lala` using `anchor init lala` and then `anchor new lala-puppet`
Oh, whoops, maybe I'm misremembering
Weird , the few repos I saw, use the compilation settings in the root cargo toml file.


//////////////////////////////////////////////////////////////////////////////////////////

Thanks anyway, I figured it out
Hello ! Why is it that when deriving a `PDA`, `space` is required with `init`, but not when creating a spl`PDA`?
thank you kind sir
what's supposed to be the difference between the recommended and secure examples?
in the seas level attacks repo
Nice. paulx has been telling us what's up in the TS channel.   He already has a fix in master.
https://discord.com/channels/889577356681945098/899315988087054397
I was able to recreate the same issue using anchor 0.24 with one of their code examples from the anchor book (game program from this part of docs https://book.anchor-lang.com/chapter_3/PDAs.html#how-to-build-pda-hashmaps-in-anchor)

Rolled the project's cargo.toml & package.json rust & typescript anchor libs from 0.24 -> 0.23 and it began working again
I am trying to make a basic escrow program 
```
#[derive(Accounts)]
#[instruction(application_idx: u64, state_bump: u8, wallet_bump: u8)]
pub struct InitializeNewGrant<'info> {
  #[account(
        init, 
        payer = sender, 
        seeds = [b"state".as_ref(), sender.key().as_ref(), reciever.key().as_ref(), mint_of_token_being_sent.key().as_ref(), application_idx.to_le_bytes().as_ref()], 
        bump = state_bump)]
    application_state: Account<'info, State>,
```
I have been getting the following error that `bump targets should not be provided with init. Please use bump without a target.`. 
I have found the following breaking change regarding the issue :-
```
lang: Providing bump = <target> targets with init will now error. On init only, it is required to use bump without a target and access the seed inside function handlers via ctx.bumps.get("<pda-account-name"). For subsequent seeds constraints (without init), it is recommended to store the bump on your account and use it as a bump = <target> target to minimize compute units used (#1380).
```
But then what I am supposed to do with `state_bump`?? I guess it is useless now right?
like you described
yeah i'm also having issues
Glad to hear I'm not the only one.  Been trying to figure this out for a while.
I ran into this same undefined issue with one project. Swapped over to a template/empty project with an empty IDL (just a blank program definition) and that worked fine. Trying to determine what I have that is causing the issue
Hey, after processing through my first smart contract's creation i had a bunch of "beginner questions" i hope it's the right place there ^^ ```md
#Accounts
First of all is it possible creating accounts for every single user and global account(for the program/smart contract)?

Accounts can hold sol's ?

#Transactions
How are the transactions working ? i mean is it actually like in solidity transfering eth from contract's bank to someone's bank ?

Are any payable modifier or something like that in sol ?

#HashMaps
Since HashMaps doesn't work on-chain atm how can i proceed to create something like a global variable where i can store data array that should be seen by everyone talking to my contract?``` i've got a lot more questions but main questions are there ^^ thanks answering üôÇ
Anyone else upgrade to 0.24 and get IDL working?
Interestingly, this IDL in the source does not have a `returns` field... 
https://github.dev/project-serum/anchor/blob/2544f1f2e4fcaa9be612934bf4b2ab311d6db60e/ts/src/spl/token.ts#L21-L22
What should the IDL types be here?
thanks... that makes sense
i have checked and redeploy latest program but error still exist
hm, it's only instruction of my program or any invoked from my program too?
This can often happen if you've made a mistake while deploying, e.g. accidentally deploying an old .so file
You're somehow sending an unknown instruction to the anchor program (it's saying "... wtf is this")
or maybe someon know what means:  Program log: AnchorError occurred. Error Code: InstructionFallbackNotFound. Error Number: 101. Error Message: Fallback functions are not supported.
your rust version is outdated
how i can run execute rpc call in anchor  without simulation? want see a program logs
Anyone else having TypeScript IDL problems from 0.24?  Using `Program<MyProgram>` yields the following:
```
  Types of property 'instructions' are incompatible.
    Type '[{ name: "createGame"; accounts: [{ name: "gameAccount"; isMut: true; isSigner: false; }, { name: "allocationTracker"; isMut: true; isSigner: false; }, { name: "adminSettings"; isMut: false; isSigner: false; }, { ...; }, { ...; }]; args: [...]; returns: null; }, ... 4 more ..., { ...; }]' is not assignable to type 'IdlInstruction[]'.
      Type '{ name: "createGame"; accounts: [{ name: "gameAccount"; isMut: true; isSigner: false; }, { name: "allocationTracker"; isMut: true; isSigner: false; }, { name: "adminSettings"; isMut: false; isSigner: false; }, { ...; }, { ...; }]; args: [...]; returns: null; } | ... 4 more ... | { ...; }' is not assignable to type 'IdlInstruction'.
        Type '{ name: "createGame"; accounts: [{ name: "gameAccount"; isMut: true; isSigner: false; }, { name: "allocationTracker"; isMut: true; isSigner: false; }, { name: "adminSettings"; isMut: false; isSigner: false; }, { ...; }, { ...; }]; args: [...]; returns: null; }' is not assignable to type 'IdlInstruction'.
          Types of property 'returns' are incompatible.
            Type 'null' is not assignable to type 'IdlType | undefined'.
```
(You could write that yourself though)
Where's that from? Yeah, it's implemented in the metaplex code itself, but I'm not sure if there's an open-source way to just say `Account<'info, MetadataThing>`
oh wait, i think It is implemented
No, not my first install.  And yeah the other versions are good - ging back and forth on those at will
Though I've heard folks want to move towards everyone just only accepting the first valid bump seed as a canonical bump seed. Not sure how feasible that is (how would you know? <:thonk:711735996726640652>)
So what happens is the findProgramAddress takes the other seeds, tries a starting bump_seed, and has a 50% chance of getting a success (finding a PDA that lies off curve). If it fails it iterates the bump seed and keeps trying til it succeeds. Then it returns the address _and_ the bump seed that resulted in that address. If you're just going to be using findProgramAddress again in the future, you can discard the bump seed. If you're doing this calculation in a smart contract though (where CPU is precious), you probably want to store the returned bump seed so you can just immediately derive it next time. I guess because storing the address itself is more expensive than the cpu to derive it, but the stored bump seed isn't? /shrug
Seeds ultimately include the bump seed, but colloquially we aren't referring to such usually. E.g. if you want the seed for a metadata account, it's 'metadata', TOKEN_METADATA_PROGRAM_ID (i.e. 'metasomethingsomethingsomething'), and the mint id. Hidden and implicit is the first valid bump seed.
.23 is hopefully fine for you üò¶
Is this your first anchor install?
np, thank you
Sorry, out of my expertise ;(. But I'm also running ubuntu and can't repro ;_;
Unsurprising ye
the cargo command also fails <:7183pepeshock:871703844374069258>
Hello !! Wanted to know what is the difference between a `seed` and a `bump seed` while deriving a `PDA`. It seems that a `bump seed` is used to make sure that the generated address does not have a corresponding private key.?
Hm. I'm also on ubuntu, I'm trying to repro myself rn but I think I'm past the point you failed at
ubuntu
<@801445539245719552> if that also fails, what os distribution are you running out of curiosity?
trying the other one now
the avm command is what fails
(...which one xD)
yeah
You getting this from an `avm install latest` or an explicit `cargo install --git https://github.com/project-serum/anchor --tag v0.24.0 anchor-cli --locked`?
Ngl that looks like a package issue. Since it just came out today maybe wait on a fix?
<@588910687397609482> Starting a necro thread a month later may not be the best way to get an answer. I'm a newb so take everything with a grain of salt.
- If your transaction is timing out, the network could be congested. Try again?
- Or you could just have a long ass transaction. You may be able to set your timeout on awaiting confirmation longer, or you may just need to await confirmation of the transaction (connection.confirmTransaction(txId)) or w.e
You'd have to write a wrapper struct, same idea as how anchor has the TokenAccount thing to deserialize a token account
It's unfortunately not quite that easy (surprised there's no open source impl of this yet?)
Anchor says he can't serialise Metadata Account
```
error: there is no argument named `rpc_port`
    --> cli/src/lib.rs:2208:40
     |
2208 |             "Your configured rpc port: {rpc_port} is already in use"
     |                                        ^^^^^^^^^^

error: there is no argument named `faucet_port`
    --> cli/src/lib.rs:2218:43
     |
2218 |             "Your configured faucet port: {faucet_port} is already in use"
     |                                           ^^^^^^^^^^^^^

error: could not compile `anchor-cli` due to 2 previous errors
warning: build failed, waiting for other jobs to finish...
error: failed to compile `anchor-cli v0.24.0 (https://github.com/project-serum/anchor?tag=v0.24.0#b0f26321)`, intermediate artifacts can be found at `/tmp/cargo-installdDSMtX`

Caused by:
  build failed
Error: Failed to install 0.24.0, is it a valid version?
```

getting ^^ when trying to upgrade to 0.24.0

anyone with an idea of how to get around this?
that makes sense.. Thanks!!
E.g. my tokens have my wallet's pubkey written on them, so the spl-token program knows not to give my tokens away unless specifically *I* sign the tx
The authority over a token account is its "logical owner", the person/thing that need to sign in order to move those tokens/burn them/etc.
Hello!! If I am not wrong a `Signer` is an account which signs a transaction and thus authorizes it. Then what is an `authority`.  `solana-spl` has the following `account` constraint :-
```
#[account(token::mint = <target_account>, token::authority = <target_account>)]
```
What is `token::authority` here? Any different from a normal `Signer`
hey, how to read NFT metadata in rust program?
Did you manage to fix this?
Transaction Confirmation error


//////////////////////////////////////////////////////////////////////////////////////////

Trying to deploy my program with anchor deploy and getting a really weird error (have previously deployed the program before, but just upgraded to anchor v0.23).

```
Deploying workspace: https://api.devnet.solana.com
Upgrade authority: /Users/xxx/.config/solana/devnet.json
Deploying program "nft-candy-machine"...
Program path: /Users/xxx/Documents/personal/solana/metaplex/rust/target/deploy/nft_candy_machine.so...
Error: Unable to open program file: No such file or directory (os error 2)
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.
```

I think it's looking in the wrong directory for the so file, given that the so file exists in `/Users/xxx/Documents/personal/solana/metaplex/rust/nft-candy-machine/target/deploy/nft_candy_machine.so` and not in the directory it's looking for (not looking within the `nft-candy-machine` directory). How can I fix this?
Got the same error for node version 16 and 17
Looks like there is a dependency graph conflict.
Has anyone else gotten the following error after running ```anchor init hello-anchor``` in ch. 3 of the Anchor Book, and then running ```npm install``` : ```npm ERR! code ERESOLVE
npm ERR! ERESOLVE unable to resolve dependency tree
npm ERR! 
npm ERR! While resolving: undefined@undefined
npm ERR! Found: mocha@9.2.2
npm ERR! node_modules/mocha
npm ERR!   dev mocha@"^9.0.3" from the root project
npm ERR! 
npm ERR! Could not resolve dependency:
npm ERR! peer mocha@"^3.X.X || ^4.X.X || ^5.X.X || ^6.X.X || ^7.X.X || ^8.X.X" from ts-mocha@8.0.0
npm ERR! node_modules/ts-mocha
npm ERR!   dev ts-mocha@"^8.0.0" from the root project
npm ERR! 
npm ERR! Fix the upstream dependency conflict, or retry
npm ERR! this command with --force, or --legacy-peer-deps
npm ERR! to accept an incorrect (and potentially broken) dependency resolution.
npm ERR! 
npm ERR! See /Users/thomasvarner/.npm/eresolve-report.txt for a full report.

npm ERR! A complete log of this run can be found in:
npm ERR!     /Users/thomasvarner/.npm/_logs/2022-04-02T17_56_54_170Z-debug.log```
Got it, thanks a lot üôå
Yep‚Äîyou can think of it as the address saying "yep, I'm ok with someone sticking an account here"
Ah so as  its being initialized, its need itself as well to sign for the creation of itself ?
Hi. I wanna implement upvote function for gif.
I code the function and successfully compiled, but test throw error like this.
```
     TypeError: src.toArrayLike is not a function
      at BNLayout.encode (/Users/myusername/ghq/github.com/maguroid/gif-portal/node_modules/@project-serum/borsh/dist/lib/index.js:37:37)
      at Structure.encode (/Users/myusername/ghq/github.com/maguroid/gif-portal/node_modules/buffer-layout/lib/Layout.js:1263:26)
      at BorshInstructionCoder._encode (/Users/myusername/ghq/github.com/maguroid/gif-portal/node_modules/@project-serum/anchor/dist/cjs/coder/borsh/instruction.js:87:28)
      at BorshInstructionCoder.encode (/Users/ryamaguchi/ghq/github.com/maguroid/gif-portal/node_modules/@project-serum/anchor/dist/cjs/coder/borsh/instruction.js:72:21)
      at /Users/ryamaguchi/ghq/github.com/maguroid/gif-portal/node_modules/@project-serum/anchor/dist/cjs/program/namespace/index.js:39:100
      at ix (/Users/myusername/ghq/github.com/maguroid/gif-portal/node_modules/@project-serum/anchor/dist/cjs/program/namespace/instruction.js:46:23)
      at txFn (/Users/myusername/ghq/github.com/maguroid/gif-portal/node_modules/@project-serum/anchor/dist/cjs/program/namespace/transaction.js:16:20)
      at Object.rpc [as vote] (/Users/myusername/ghq/github.com/maguroid/gif-portal/node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:8:24)
      at Context.<anonymous> (tests/myepicproject.js:41:23)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
```

Where my code has mistake ?

My codes here.

function
https://github.com/maguroid/gif-portal/blob/main/packages/myepicproject/programs/myepicproject/src/lib.rs#L32

test
https://github.com/maguroid/gif-portal/blob/main/packages/myepicproject/tests/myepicproject.js#L41
Good q, in solana when you create an account you ultimately need to sign for its address
Also in this above example, why does the signer list contain `myAccount` then? Shouldnt it be just an empty list as Im not using the myAccount to sign transactions?
This particular feature specifically, like as the payer is the provider keypair, it does not need to be added in the list of signers.
wdym this stuff?
Ah got it thanks a lot , if available, is there some docs where I can read more on this stuff
yes the user has to sign as well but youre using the ptovider keypair as the user and anchor will use the provider keypair as a signer automatically so no need to add it to the signers array again
Hi, what does the signer mean when making a RPC call in the client side code? From the docs: 
> Here, we specify the accounts field, an object of all the addresses the transaction needs to touch, and the signers array of all Signer objects needed to sign the transaction
```
    await program.rpc.initialize(new anchor.BN(1234), {
        accounts: {
            myAccount: myAccount.publicKey,
            user: provider.wallet.publicKey,
            systemProgram: SystemProgram.programId,
        },
        signers: [myAccount],
    });
```
In this case, we are creating a new account myAccount and paying for the creation from the User account, so shouldn't the signer be the User account ?
I figured it out :)) using program.account...getAccountInfo(). This function return false if account not existed
thank you so much
https://github.com/project-serum/anchor/blob/master/lang/src/system_program.rs#L298
is there sol transfer function in anchor ?
In rust or on the client? From the client you'd just try fetching the account and see if anything is there
how can I check if a pda account exist?
Ahh now it makes sense, thanks a lot üôå
The connection to anchor test is actually the Anchor.toml file‚Äîyou can put whatever pubkey you want in Anchor.toml and then anchor test can automagically run a validator with your code living at that address
I think my main confusion arose from the original program id generated when use call `anchor-init` which is always equal to`Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS` which needs to remain when we run anchor test , and then when we actually deploy it , it needs to be changed to the output program id we get when we run anchor-build
hello, i am new here, i have some questions about anchor and rust, if anyone is free, i appreciate
Okay, so https://project-serum.github.io/anchor/tutorials/tutorial-1.html#initialize-instruction if you see program 0 and program 1, both have the same declare-ids, Is it bcoz its just meant as a refrence and it's exprected for us to change it ? 
Also when I use the `anchor keys list` output value as my declare id, the anchor test fails with output `The given account is owned by a different program than expected` , when I use the declare id same as what is mentioned in the blog, it works and all tests passes
you need to build the program in order to get the address
do 
1. anchor build
2. anchor keys list
Hi yup, sorry I made a mistake in my message, I had to use a particular declare id while running via Anchor Test as well. Ive been following this https://book.anchor-lang.com/chapter_3/the_accounts_struct.html 
Now Im confused as to, how do I know while writing the program itself, what would be my program account address  ?  
Sorry if Im missing something obvious here üòÖ
well it's not supposed to work, `declare_id!()` should contain the program address.
Should the `!declare_id` value  in the rust code always match the program address generated when we build the code using anchor-build? When I was trying to run using my own client code, I needed to do this, when I test using `anchor test` command I can put in any `declare_id` and it works.
Like this right? Use my program instead of token program right

In nodejs instead of sending the tx you can create that as an instruction and create a tx object and send the tx manually
Is there any example? In react app I create provider via AnchorWallet (which imported from wallet adapter). How to archieve this in node app
Hi Im trying basic-1 example from getting started, here is my client.js, where Im creating a new account address and calling the program
```    const programId = new anchor.web3.PublicKey("F9anHuD3aJTuKgjohVKgT5e5Vya95ZFv47224vWzVzwk");  // <YOUR-PROGRAM-ID>");
    const program = new anchor.Program(idl, programId);

    // The Account to create.
    const myAccount = anchor.web3.Keypair.generate();

    // Create the new account and initialize it with the program.
    await program.rpc.initialize(new anchor.BN(1234), {
        accounts: {
            myAccount: myAccount.publicKey,
            user: provider.wallet.publicKey,
            systemProgram: SystemProgram.programId,
        },
        signers: [myAccount],
    });
```
While running, I use the command `ANCHOR_WALLET=/Users/.config/solana/id.json node client.js` 
This gives me the error `ProgramError: 3007: The given account is owned by a different program than expected` 
What is mistake here? Is it because Im passing a different account as a  env variable and my client code is creatign another new account?
use the anchor ts library to do so
how to interact with program in nodejs backend?
Hi, I wrote a program with a simple function to transfer sol token and wrote the test. When I am using anchor test, it is giving this error:
```
Transfer: insufficient lamports 0, need 1000
Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: custom program error: 0x1```
I have airdropped lamports and even checked the balance and it has enough lamports. So what is the issue?
```
describe("example", () => {
  // Configure the client to use the devnet cluster.
  const connection = new anchor.web3.Connection(
    web3.clusterApiUrl('devnet'),
    'confirmed',
  );

  //console.log(connection);
  const fromWallet = web3.Keypair.generate();
  const toWallet = web3.Keypair.generate();

  before(async () => {
    let airdropSignature = await connection.requestAirdrop(
      fromWallet.publicKey,
      web3.LAMPORTS_PER_SOL, // 10000000 Lamports in 1 SOL
    );
    await connection.confirmTransaction(airdropSignature);
  });

  const program = anchor.workspace.Example as Program<Example>;

  it("Sol token is transferred!", async () => {
    // Add your test here.
    const tx = await program.rpc.transferNativeTokens(new anchor.BN(1000), {
      accounts: {
        from: fromWallet.publicKey,
        to: toWallet.publicKey,
        systemProgram: web3.SystemProgram.programId,
      },
      signers: [fromWallet],
    });
    await connection.confirmTransaction(tx);
  });
})
```
would you like to share the function?
using da latest anchor version
any idea why im suddenly getting errors when running ``anchor build`` on a new ``anchor init`` project?
<:thumbsUp:932661832102051971>
forgot to update here, but <@!134416332509675520> helped me out, the issue was my IDL for my frontend was out of date
did you convert BN -> toNumber?
<@!134416332509675520> sent a dm
Yeah, can you post the rust struct?
address 8xUKTzxM8BakwYpeYucPVedgGPPQtXJw1UY8zXakEMmZ  on devnet ( the fields are not actullay A and B)
Can you post the account address?
I'm having an odd issue with BN types. In my frontend when pointing to devnet I get the following values for my account
```A: 17323731990913122121 B: 6605859977062577180```

But when fetching the exact same account in a test file pointing to devnet I get
```A: 0 B: 0```

In this scenario the test file output is the one I expect; super confused on why my frontend values are weird. There are other values in that account which are publickeys, and those all look the same as the values I see in the test, its just the BN types that are weird.
ah ok, that's super interesting. thank you!!
doesn't seem that way. deployed program and ids seem alright. hm
`0xa7` error seems owner mismatch, is that right? it's mismatching deployed program vs. declare_id isn't it...checking
got to the next error. turns out I was referencing the metaplex token metadata program on my localnet but didn't clone it to local validator. but thank you
Check if your Anchor.toml matches maybe?
Here's the call that's failing:
```
    program_client
        .request()
        .accounts(draffle::accounts::AddPrize {
            raffle,
            creator: program_client.payer(),
            from: creator_prize_token_account,
            prize,
            prize_mint,
            system_program: system_program::id(),
            token_program: spl_token::id(),
            rent: sysvar::rent::ID,
        })
        .args(draffle::instruction::AddPrize {
            prize_index,
            amount: prize_amount,
        })
        .send()?;
```
how can I debug this error? can't find any info on it...the target program id in my code seems alright
`RPC response error -32002: Transaction simulation failed: Attempt to load a program that does not exist`
The ? in rust does a little `.map_err(Into::into)`internally anyway
Yeah (not sure what the upgrade instructions say, but it's fine)
yeah, works great without .map_err() but I was a little leery of leaving it out given the instructions said it was part of the upgrade path. You think it's ok to omit?
anybody generating api with solita know when code gen uses `beet.FixableBeetStruct` instead of `beet.BeetStruct`? running into an error with an enum struct property that seems to be related:
```
Type 'FixedSizeBeet<MarketState, MarketState>' is not assignable to type 'FixedSizeBeet<any, Partial<any>>'.
```
Yep (good q, that was initially a bug in an old anchor version)
Mm, you shouldn't need both the `?` and `.map_err`. Can you just get rid of the `.map_err` line?
hey guys, when I have init_init_if_needed account do I need to make constraints for it in case it is innited? Or those rules (associated_token::mint = lair_mint) will be treated as constraints?
hi guys, anchor/rust newb here. I'm trying to upgrade from anchor 0.21.0 to 0.22.0. The upgrade instructions are here: https://github.com/project-serum/anchor/blob/master/CHANGELOG.md#0220---2022-02-20

It says to convert invoke() to invoke.map_err() but I can't seem to get the rust types to work.

```
            invoke(
                &transfer(&user_key, txn.to_account_info().key, amount),
                &[
                    ctx.accounts.user.to_account_info(),
                    txn.to_account_info(),
                    ctx.accounts.system_program.to_account_info(),
                ],
            )?
            .map_err(Into::into);
```

I get this error: no method named `map_err` found for unit type `()` in the current scope
method not found in `()`

If I remove the question mark, I get: type annotations needed
cannot infer type for type parameter `F` declared on the associated function `map_err`

I've tried supplying types (::<(), ProgramError>) but no dice. Any ideas?
```anchor build```
how can I create the `types` folder with the .ts IDL? had it, then cleaned the target folder and now can't figure out how to have it created. tried build and deploy but no luck


//////////////////////////////////////////////////////////////////////////////////////////

tx doesn't return a sig
```js
    let tx = await program.methods.initialize({
          accounts : {
            stakeAccount : stakeAccountKey.publicKey,
            counterAccount : counterAccountKey.publicKey,
            genesisAdmin : genesisAdminKey.publicKey,
            systemProgram : anchor.web3.SystemProgram.programId
          },
          signers : [genesisAdminKey]
        
      })
      await program.provider.connection.confirmTransaction()
      
    }
```
how do i get the sig?
Or just chuck in a sleep
```.rs
const sleep = ms => new Promise(awaken => setTimeout(awaken, ms));
await sleep(2000)
```
You may need to wait for additional confirmation, `await program.provider.connection.confirmTransaction`
Error: Account does not exist 8KBtxPNeab2AUmXswx1ATK5YUiBYSnkaVoasefvbYNvs
```js
    async function fetchData(){
      await preprocessor()

      console.log(genesisAdminKey.publicKey.toString())

       const account = await program.account.stakeAccount.fetch(stakeAccountKey.publicKey)
       console.log(account)
       // console.log(utfDecoder.decode(account.hasInit))
    }
```
How are you checking that? What error do you get? Etc.
unfortunately still no account creation
Ah cool
<@875698957513289789>
likely more efficient: `the_account.as_ref().lamports()`
Nice. Thanks!
`the_account.to_account_info().lamports()`
Is there an anchor specific way to check SOL balance for an account you pass?
I can't get past this error. Everything seems to be setup correctly

I'm just saying that you can type that account as whatever seems relevant
You can't‚Äîthat Account<'info, Whatever> would only make sense if you want to additionally assert that it's one of your Whatever accounts
Ok so this compiles:

```pub to: UncheckedAccount<'info>,```


But for the first method how would you not supply anything to the second field of the account?


```pub to2: Account<'info, TheAccountTypeIfApplicable>,        ```
So e.g. `Account<'info, TheAccountTypeIfApplicable>`, or just `UncheckedAccount<'info>` (with a `/// CHECK` comment above it), etc.
You can actually use whatever you want there (just not Signer if they're not going to sign)
How do you pass an account to a program that you can't sign for?

This would be the recepient of lamports and i signed it would look like this:

``` pub player: Signer<'info>,```

But how would this look like for an unsigned account?
thanks ser
You changed those space calculations, 8 + 8 isn't enough for the StakeAccount; you'd need 8 + 32.
idl - 
```json
{
"version": "0.1.0",
  "name": "solanaire_stake",
  "instructions": [
    {
      "name": "initialize",
      "accounts": [
        {
          "name": "stakeAccount",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "counterAccount",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "genesisAdmin",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": []
    },
    {
      "name": "stake",
      "accounts": [
        {
          "name": "stakeAccount",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenAccount",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "staker",
          "isMut": false,
          "isSigner": true
        }
      ],
      "args": [
        {
          "name": "amount",
          "type": "u32"
        }
      ]
    },
    {
      "name": "increment",
      "accounts": [
        {
          "name": "counterAccount",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "count",
          "type": "u8"
        }
      ]
    }
  ],
  "accounts": [
    {
      "name": "StakeAccount",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "amount",
            "type": "u32"
          }
        ]
      }
    },
    {
      "name": "CounterAccount",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "count",
            "type": "u8"
        }
        ]
      }
    }
  ],
  "errors": [
    {
      "code": 6000,
      "name": "AmountTooSmall",
      "msg": "Minimum stake amount violation"
    }
],
  "metadata": {
    "address": "CMWv5sfuqwttiURdvh76XaJHextGvAKsbSFTtLS6ESzN"
  }
}```
client -
```rs
use anchor_lang::prelude::*;
use anchor_spl::token::TokenAccount;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod solanaire_stake {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {

        Ok(())
    }

    pub fn stake(ctx : Context<Stake>,amount : u32) -> Result<()>{
        let stake_account = &mut ctx.accounts.stake_account;
        if ctx.accounts.token_account.amount>1111{
            stake_account.amount = amount;
        }else{
          return err!(StakeError::AmountTooSmall)
        }
        Ok(())
    }

    pub fn increment(ctx : Context<Increment>,count : u8) -> Result<()>{
        let counter_account = &mut ctx.accounts.counter_account;
        counter_account.count = count;
        Ok(())
    }    

}

#[account]
#[derive(Default)]
pub struct StakeAccount{
    amount : u32,
}


#[account]
pub struct CounterAccount{
    count : u8,    
}


#[derive(Accounts)]
pub struct Initialize<'info>{

    #[account(init,payer = genesis_admin,space= 8 + 8)]
    pub stake_account : Account<'info,StakeAccount>,

    #[account(init,payer = genesis_admin,space= 8 + 8)]
    pub counter_account : Account<'info,CounterAccount>,

    #[account(mut)]
    pub genesis_admin : Signer<'info>,
    pub system_program : Program<'info,System>
}

#[derive(Accounts)]
pub struct Stake<'info>{
   pub stake_account : Account<'info,StakeAccount>,
   pub token_account: Account<'info, TokenAccount>,
   pub staker : Signer<'info>,

   
}

#[derive(Accounts)]
pub struct Increment<'info>{
   pub counter_account : Account<'info,CounterAccount>
}



//error def

#[error_code]
pub enum StakeError {
    #[msg("Minimum stake amount violation")]
    AmountTooSmall
}
```
rust -
But the Initialize invocation doesn't create the accounts üò≠
Yep, that looks about right
is this the right way of creating multiple accounts with 1 signer - 
```rs
#[derive(Accounts)]
pub struct Initialize<'info>{

    #[account(init,payer = genesis_admin,space=48)]
    pub stake_account : Account<'info,StakeAccount>,

    #[account(init,payer = genesis_admin,space=48)]
    pub counter_account : Account<'info,CounterAccount>,

    #[account(mut)]
    pub genesis_admin : Signer<'info>,
    pub system_program : Program<'info,System>
}
```
when you are trying to update data from the account that is owned by d/f program. you'll get something like this
```
Error: AnchorError caused by account: counter. Error Code: AccountOwnedByWrongProgram. Error Number: 3007. Error Message: The given account is owned by a different program than expected.
Program log: Left:
Program log: CR7XiGZHEu588YMkg2RPtyokwhawwEczcHHznXM6NwG7
Program log: Right:
Program log: 7BeXBXWYR9Q1jkL9RBkxEJEeUiRXUJFbvajsCg8CcsZf
```
yes, you are right, the owner of the account is itself the program a.k.a smart contract
runtime policy:

> Only the owner may change account data.
> - And if the account is writable.
> - And if the account is not executable.
is this because the owner of counter is the program itself rather than systemProgram?
But I assume ethereum actually works similarly? https://ethereum.stackexchange.com/questions/1302/where-do-contract-event-logs-get-stored-in-the-ethereum-architecture
I actually don't know how you retrieve them in general‚Äîthat's handled by the rpc infrastructure, but I'm not sure exactly how they do it
They're just logs: https://github.com/project-serum/anchor/blob/master/lang/attribute/event/src/lib.rs#L77
Any luck on this <@134416332509675520> , any relevant resources on how events work in Solana, as there is no native support for it, so trying to understand in what way is it similar to eth events, i.e, can they be retrieved later on, or are these events o. Retrieved when they happen, I e I set up a listener and it catches this event, but on a later date is there a way to get past events ? If so where are these events stored ?
Creating an account *does* require a signature though.
No need to sign when you want to modify data (at least not in general‚Äîyou could write your program to act that way, but it's not the default in solana).
why don't we need to pass `counter` as a signer? since we would be modifying the data of `counter` account
hi guys! I'm having trouble trying to understand the anchor example basic 2 (https://project-serum.github.io/anchor/tutorials/tutorial-2.html) where we increment a `Counter` account. On the client end we can increment a `Counter` account with:

`   await program.rpc.increment({
      accounts: {
        counter: counter.publicKey,
        authority: provider.wallet.publicKey,
      },
    })`
I fix this issue. the code already changed.
I can do a staking program that takes and holds an NFT which earns the person a token over time right?
Cause if so, I need to build one tonight. Who's excited
cool, thanks
Nope
Yep
<@!134416332509675520>
is it a vulnerability not to initialized PDAs?
are all accounts SystemAccounts before being initialized?
i see
What you have there doesn't really make sense in anchor: you're allocating a custom (maybe empty, but still custom) struct, and you're not using any space to do so, but anchor always uses at least 8 bytes for your own custom account types, so it can store the "account discriminator"
You'd want to instead just use AccountInfo (with a /// CHECK comment), or SystemAccount<'info> maybe
https://discord.com/channels/889577356681945098/889702325231427584/959926463862296576
<@!134416332509675520>
```rust

#[account(seeds=[b"redeemable_authority"], space = 0, bump)]
pub redeemable_authority: Account<'info, Empty>,
```
How are you using it in the derive(Accounts) struct?
my instruction takes a PDA as an argument, anchor complains that it is not initialized. why would this be? why would it need to be initialized? it doesnt hold any data, i just use it as a mint authority.


//////////////////////////////////////////////////////////////////////////////////////////

If I have account like this in which there is vector
```
#[account]
pub struct PoolAccount {
    pub pool_id: u32,
    pub pool_owner_key: Pubkey,
    pub pool_token: Pubkey,
    pub pool_amount: u64,
    pub projects: Vec<ProjectAccount>,
    pub start_time: i64,
    pub end_time: i64,
}
``` 

then how am I supposed to access that key of single project in function ?

```
pub fn add_projects_to_pool(ctx: Context<AddProjectsToPoolAccount>, project: ProjectAccount) -> Result<()> {
        ctx.accounts.pool_account.pool_owner_key = *ctx.accounts.pool_owner.key;
        ctx.accounts.pool_account.projects.project_owner_key = &ctx.accounts.project_owner.key;
        Ok(())
    }
```
sweet, thanks for explaining
`init` creates rent-exempt accs. Generally, all accounts need to be rent-exempt on mainnet now. the rent is payed by whoever you specified as `payer = ` in your `init` constraint
<@!134416332509675520>
can anyone help me, i need to deserialize SlotHashes data in to Vec<SlotHash>
how can i do this?
when I create an new keypair via `web3.Keypair.generate` and then use it to create an account of my program I see that this account owns some SOL. Are these funds taken from the payer of the transaction and passed to the account so it is rent-exempt? Would be really cool if this is the case since I find the concept of rent kind of annoying and would be really pleased if I do not have to take care of account balances in order to keep them alive.
I'm actually not sure lol, as far as I can tell you'd need to close the wrapped sol token account, but that seems weird since that would unwrap *all* of the sol
how do I create a "unwrap SOL" instruction in typescript?
this is the hacky way i did it in the end  (i'm using anchor 0.21 and stuck on it for dependency reasons ) . this example is using the struct defn from https://twitter.com/anchorlang/status/1491906353560006662

```
import { Test, IDL } from "../target/types/nft";

const program = anchor.workspace.Test as Program<Test>;
const idlIxs = IDL[instructions"];
const initIx = idlIxs.find(ix => ix.name === "initMyAccount");
const pdaAcctIdx = initIx["accounts"].findIndex( x => x.name == "account");

// we need to call this._accountsResolver.resolve() within MethodsBuilder 
// for the PDAs to be calculated and this is only called in rpc(), simulate(), instruction() or transaction()
const ix: TransactionInstruction = await program.methods
    .initMyAccount(seedA)
    .accounts({
        base: base.publicKey,
        base2: base2.publicKey,
    })
        .instruction(); 
const acct_calculated_PDA = ix.keys[pdaAcctIdx].pubkey;

const txn = new Transaction();
txn.add(ix);
await program.provider.send(txn);

await program.accounts.MyAccount.fetch(acct_calculated_PDA);

```

it would be nice to have a built-in way to do this something like 
```
const prepared = await program.methods
    .initMyAccount(seedA)
    .accounts({
        base: base.publicKey,
        base2: base2.publicKey,
    })
    .prepare(); //pretty much just calls the this._accountsResolver.resolve() but now it should be locked in some immutable state.
const acctPDA = prepared.accountMetaForIx("initMyAccount", "account").pubkey;
const txn: Transaction = prepared.transaction(); // or rpc(), instruction(), simulate()
```
That error is coming from someplace else‚Äîthe error message from rust is just confusing unfortunately
What is this error? why do I need lifetime parameter?
The max size limit is 10mb, so it's mainly a question of whether you want to spend the money
I guess it depends on what your alternatives are
thanks üò¶
because of the max size limit.
is it good idea to store user data like - accountAddress,authId in a data account?
The dapp itself would need to keep checking if the transaction succeeded
Can't, the program itself can't communicate with the outside world in any way
How to send messasge from program to dapp with anchor? Eg: message to notify their transaction is successfully
was from following the tictactoe example
num-traits = "0.2"
num-derive = "0.3"
added the
in the cargo.toml outside src

all the #[account] etc also getting
error[E0432]: unresolved import `crate`
 --> programs/tic-tac-toe/src/lib.rs:8:1
  |
8 | #[program]

keep this error when trying to anchor build
thx a lot! üôÇ
the .toNumber is giving me errors, that's why im asking xD
This is probably smarter: https://stackoverflow.com/questions/54409854/how-to-divide-two-native-javascript-bigints-and-get-a-decimal-result
Won't work in general though because BNs can be too big to convert back to a regular JS number
Mm, this won't work in general but you can maybe get away with doing `a.toNumber() / b.toNumber()`
given two big numbers how can I divide to get a fraction? (in typescript)
or you can do this also ig,
```pub fn xyz(build_account: &Account<BuildAccount>) -> {....}```
``` xyz(&ctx.account.build_account)```
You either can implement the accounts struct (Initialize, Update, the ones which has the derive accounts macro) as the following


impl<‚Äòa> Initialize<‚Äòa> {
    pub fn do_stuff(&self) {
        // access accounts using self.whatever
    }
}
how ?)
you need to pass the reference of ctx here
hey, how to call function that is outside of instructions from instructions? This gives me an error
what <@!185307556032413697> stated, it the only reason here <@!744612713811935404>
`stake_account` and `counter_account` are not the PDAs, hence their keypair required for signature.
```json
  "instructions": [
    {
      "name": "initialize",
      "accounts": [
        {
          "name": "stakeAccount",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "counterAccount",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "genesisAdmin",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": []
    },
```
besides the idl also mention ```"isSigner": true
``` for all three accounts
when i only put the genesis_admin in the signers it produces - ```Error: Signature verification failed```
I have created an account, airdropped sol in localhost (Verified its airdropped properly from explorer too) and passed it to a sol transfer function. And getting this error
```Transaction simulation failed: Attempt to debit an account but found no record of a prior credit.```
What's causing it?
Hi, ```Instruction 0: custom program error: 0xa3 ``` what is this error in anchor i just could figure it out?
https://github.com/solana-labs/solana/blob/37497657c6636bcc6c85bde9f798bebad2332a78/sdk/program/src/program.rs#L29-L94
you can read more about it here, incase you want
Solana's runtime has an explicit check for PDAs, that whenever anyone invoke cpi with the signer and passes the correct seed, the account will be marked as a signer automatically
......
Most of the time PrivateKey's are used to sign transaction but PDA's donot have private keys so how and who will sign transaction? <@!717956950737813594>
sorry didn't get you
so do PDA's use Publickey for transaction signing? <@!717956950737813594>
Yus, PDAs sign the txns. Solana runtime mark them as `is_signer = true` whenever you invoke cpi with the signer, and pass the correct seed
Does PDA signs transaction? if yess then How? <@!134416332509675520>
Ty
https://github.com/project-serum/anchor/blob/v0.18.2/ts/src/error.ts#L83
how would tally those error in anchor ??
might go through the code that already does that for references
Hi just wondering where can i check this error for anchor `` Program log: Custom program error: 0xa3``??
Any resources for staking nfts from a collection? And in turn then earning the token
will do that. Thank you once again saviour.
yes so i guess vanilla transfer it is üòÑ
Ok maybe close doesn't work on AccountInfo (it's not a common thing to try to do)
You'll just have to manually do the lamport transfer, with `.try_borrow_mut_lamports()` etc.
Ok maybe close doesn't work on AccountInfo (it's not a common thing to try to do)
```error[E0599]: no function or associated item named `try_accounts` found for struct `CloseTrove` in the current scope```
0.18.0
Can you show them?
ProgramAccount is also super outdated, what version of anchor are you on?
```39  | #[program]
    | ^^^^^^^^^^ function or associated item not found in `CloseTrove<'_>`
...
916 | pub struct CloseTrove<'info> {
    | ---------------------------- function or associated item `try_accounts` not found for this
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `try_accounts`, perhaps you need to implement it:
            candidate #1: `anchor_lang::Accounts`
    = note: this error originates in the attribute macro `program` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the trait bound `CloseTrove<'_>: anchor_lang::Accounts<'_>` is not satisfied
```
well AccountInfo gave me other werid errors
Why are you using ProgramAccount<'info> there rather than just like AccountInfo<'info>?
for pda yes
on this
after 'info
It tells me to add the missing generic argument
let me show you the error
ü•¥
Ok, at any rate, what doesn't work about `close =`?
It has a bunch of space
i just randomly gave the space
That doesn't look like an empty account to me
```rust
#[account(init_if_needed, seeds = [b"solTrove".as_ref(),authority.key().to_bytes().as_ref()], bump = sol_account_bump, payer = authority, space =  8 + 2 + 4 + 200 + 1)]
    pub sol_trove: AccountInfo<'info>,```
no i didnt
Did you use like `space = 0` or something?
How did you do that?
coz im making account for each wallet user
(Not impossible, just not sure why you'd do that)
If the account doesn't have any data, why is it owned by the program?
that also has the instruction to transfer those sol
like my farm program
no the same program
If you you just need to do a vanilla sol transfer
Which program owns the account? The system program?
You'll probably need to just transfer the sol yourself, `close =` only works for accounts that are owned by the program (not the same thing as being a PDA)
but seem it doesnt work that way
i was trying to use single account of storing sol and handle data
so close should pretty much do the thing for me
i need to  transfer all the sol from there
if it has no data and has no SOL, it's just an address, right?
Are you sure you need to close it?
Hi,  i have an pda account, that doesnt hold any data. And i wanna close that account in anchor
```rust
 #[account(mut, close = authority, seeds = [b"solTrove".as_ref(),authority.key().to_bytes().as_ref()], bump = trove.sol_bump)]
 pub sol_trove: ProgramAccount<'info>, //// what generic argument should i passing here along with info???
```
wonderful - thank you!
Yeah
Ok - that's what I thought. So basically as long as I don't introduce anything that would interfere with what the older accounts were built to do, then all should be fine?
Deploying has zero effect on any other accounts‚Äîfor better or worse, since you have to be careful to make sure your changes to the program are backwards-compatible with all of the old accounts out there
Hello all - when it comes to deploying changes to a program that is being actively used, are there any precautions one needs to take to ensure the safety of any open accounts? 

For instance, an escrow program that has several PDAs actively storing tokens for various pending swaps, as well as "esrowAccounts" that act as references for those PDAs. 

If a developer needs to make some addition to the program, such as adding a new function and/or context, can it be safely deployed without jeopardizing the persistence of these open accounts? What about adding new properties to the escrowAccount model in order to phase in a new piece of functionality (i.e. suddenly we want to start tracking the date these were created)?

My impulse is that there is no inherent danger in upgrading a program in this situation, so long as the changes are carefully reviewed to not introduce vulnerabilities, nor alter the previously-expected behavior of the contract in regard to those accounts. However, I could see there being a potential issue at least with the direct modification of an account model. 

Anyways - it's difficult to find any resources that directly address this, so I'd greatly appreciate any feedback. Thank you!
right i get that but i thought the whole concept of having the methods builder api for these complex PDA initalizations was so i didn't have to re-write the findProgramAddress on the client side
Hi, so when i try to transfer sol from the data account? why is it not possible??
do i need to actually create another account to handle that ??
check solana cookbook
findprogramaddress function or something i reckon
<@!652573044375552024>
use the value that u used to create those pda for the program id
yes
i'm using the methods builder to iniitalize a PDA similarly to the example from this tweet - https://twitter.com/anchorlang/status/1491906353560006662
is there a way for me to get the resulting publicKey for the `account` on the client side?
btw thank you for your time guys.
this was my cargo toml tho ahha
```[workspace]
members = [
    "programs/*",
]```
and i didnt change anything like ...
Any advice on this one?
its working now suddenly hmm...
if its not sensitive
can you paste the `Cargo.toml` for the failing program
thats like my full log
```
Deploying workspace: https://api.devnet.solana.com
Upgrade authority: /home/sexpistol/new-keypair.json
Error: expected square brackets
```
hmm
same error
ye replaced it
mb
sorry `--program-name` instead of `--project`
it says no argument called project..
let me try that tho
isnt it retrieving from the anchor toml file ?
but it would give me error about there is program thats not in the workspace
if you do `anchor deploy --project farm --provider.cluster devnet` does that fix?
i was thinking of like adding only one program to the workspace instead of doing programs/*
nope, they build fine
thats my full anchor toml ahaha
is there a naming conflict between any two?
Can you post the full Anchor.toml or is that classified
Mm, interesting
when i delete my other programs i can successfully deploy that program
Ok at any rate think that looks fine
mybad haha
omg haha
Haha
You're killin us üòÇ
so i missed it
i just typed it
Lol
yes its on programs
should be `programs.devnet` not `program.devnet`
i didnt copy that bit hahah
Ah ok
ye its on devnet
Yeah can't just say `farm =`
oh
or whatever deployment net
`[programs.localnet]` to the top
yep, add
i have added only the program that i want there tho
```
[program.devnet]
farm = "HPwvr8B9KtM3CZwQg7V8pevfgsZfZBLiR3gL1HcEsGiD"

[registry]
url = "https://anchor.projectserum.com"

[provider]
cluster = "devnet"
wallet = "/home/sexpistol/new-keypair.json"

[scripts]
test = "ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"
```
Can you post your Anchor.toml?
but when i just try anchor build, it builds all the program fine
it gives me the same error saying the expected bracket
but its weird like when i try anchor build -p progam
definitely a repo/crate configuration issue
rippoo
hmm nah seems like both dont work lool
It's only specifically when you use the `-p` option?
And this doesn't happen if you just do `anchor deploy`?
I'm not too sure, I would need to see the crate metadata files and the actual code to be able to help
but i want to do it with the `` anchor deploy -p program ``
i can go to the target folder and run that specific program .so file
well nah thats not the issue
well i dont think so, but i willcheck it again.
maybe messed brackets in there?
ye  i deployed it several times
should be just a json serialized number array
the content of the keypair file valid json?

that all the log there is
can you please post the entire terminal log
but i wanna deploy those program individually after build
it  successfully builds all the programs
when i try to anchor build
there are multiple programs in that workspace
so i just had anchor deploy -p farm
no target name is farm
might help to see the actual thing
is your target _actually_ `my_program` and you're just missing the underscore in the command?
just this
Error: expected square brackets
<@!242234529396424704> can you paste the full error
where should i be putting those square brackets ??
gives me error saying ``expected square brackets``
Hi, when I try to deploy specific program using anchor , suppose ``anchor deploy -p my program``
there is likely something else going wrong but can't tell from what's posted
this shouldn't be the case. `genesis_admin` is the only account that is designated as a signer for the instruction and thus should be the only required keypair provided for the rpc call.

if `stake_account` and `counter_account` are PDAs, then they aren't even keypairs at all, they're a public key and bump nonce associated coupling that point to an off-curve key and would have no effect when adding the public keys to the signers array.
I am finding a few resources on staking a token for a token. However I want to stake an nft for a token. I know an nft is a token, however it's a supply of 1 so I want to be able to take in any from a collection.
oh I see thanks
The reason is because of the following reasons

1. Any account that is initialized with a Keypair account (PDA's an exception), is required their signature (kinda like an approval), so you gotta pass the stake_account's keypair
2. The same applies for counter_account as well, as that's initialized
3. Usually if the payer is your wallet, you don't need to supply additional actors' private key. But since here it's mentioned as genesis_admin being the payer, it's secret key is also required (A Payer has to be a signer, hence marking that account as a signature required account)
```rs
#[derive(Accounts)]
pub struct Initialize<'info>{

    #[account(init,payer = genesis_admin,space= 8 + 32)]
    pub stake_account : Account<'info,StakeAccount>,

    #[account(init,payer = genesis_admin,space= 8 + 32)]
    pub counter_account : Account<'info,CounterAccount>,

    #[account(mut)]
    pub genesis_admin : Signer<'info>,
    pub system_program : Program<'info,System>
}
```
btw I had to put all accounts in the signers. Don't know why but worked -
```js
    let x = await program.methods.initialize().accounts({
      stakeAccount : stakeAccountKey.publicKey,
      counterAccount : counterAccountKey.publicKey,
      genesisAdmin : genesisAdminKey.publicKey,
      systemProgram : anchor.web3.SystemProgram.programId
    }).signers([genesisAdminKey,counterAccountKey,stakeAccountKey]).rpc()
```
finally  !!  üéä üî•  thanks <@!134416332509675520> , <@!185307556032413697>
Same ^, update your declare_id to be that 2XPxee address
Yeah, it's annoying, but you need to update declare_id! to reflect whatever the actual runtime id is
same here
you get the declareId once running anchor init. And after running anchor deploy you get a different programId in the log as you can see in the screenshot. Which one to use ?

That is‚Äîyou need to change the declare_id! in your lib.rs file to match it
the programId I get after deployed is not the required programId?
Your declare_id! in your rust code needs to match
matches with idl - 
```json
  "errors": [
    {
      "code": 6000,
      "name": "AmountTooSmall",
      "msg": "Minimum stake amount violation"
    }
  ],
  "metadata": {
    "address": "DNYXQEkferiGdxJjpq3Qo781r8mJwiN1EUcJfssAqiAw"
  }
```
this is the program Id - DNYXQEkferiGdxJjpq3Qo781r8mJwiN1EUcJfssAqiAw
what's causing that? any idea
that seems to work. However I got - ```Error Code: DeclaredProgramIdMismatch. Error Number: 4100. Error Message: The declared program id does not match the actual program id.```
okay let me try that
You'd want to make a `new NodeWallet(genesisAdminKey)`
Looking into how you're supposed to make a wallet just from a keypair, 1sec
```json
module.exports = {
    programId : "DNYXQEkferiGdxJjpq3Qo781r8mJwiN1EUcJfssAqiAw",
    networkEndpoint : "https://api.devnet.solana.com",
}
```
The second argument is meant to be a Wallet rather than a keypair
```js
const connection = new anchor.web3.Connection(configs.networkEndpoint)
```
```js
 provider = new anchor.Provider(connection,genesisAdminKey,anchor.Provider.defaultOptions())
```
That would mean you're somehow not setting up your provider correctly
removed "confirmed" from connection constructor
What part did you have to change though to fix the preflight issue? I wasn't sure from reading your code why that happened
docs are all over the place. Even the official doc contains outdated info smh
And yes, lol, lots of people have built clients üòõ
What fixed the preflight issue?
has anybody has ever successfully build a client?
solved the preflight issue. Now showing ```TypeError: this.wallet.signTransaction is not a function```
please dont crosspost
What development env do people use? I'm on windows and running into so many issues.
any help would be appreciated üôè
```#[derive(Clone, AnchorSerialize, AnchorDeserialize)]
pub struct Decimal {
   pub value: i128,
   pub decimals: u32,
}

impl Decimal {
   pub fn new(value: i128, decimals: u32) -> Self {
       Decimal { value, decimals }
   }
}

#[account]
pub struct Data {
    pub sol_data: Decimal,
    pub eth_data: Decimal,
}
‚Ä®#[derive(Accounts)]
pub struct Execute<'info> { 
   #[account(init, payer = user, space = 8 + 20 + 20)]
   pub data: Account<'info, Data>,
   #[account(mut)]
   pub user: Signer<'info>,
   pub chainlink_sol_feed: AccountInfo<'info>,
   pub chainlink_eth_feed: AccountInfo<'info>,
   pub chainlink_program: AccountInfo<'info>,
   #[account()]
   pub system_program: Program<'info, System>,
}```
hey there! I've been scratching my head over this error - Error: 2012: An address constraint was violated‚Ä®I suspect its how I‚Äôm initialising the account?
oh wow cool, thanks!
It will be a bit of a pain, but `connection.simulateTransaction` returns all of the accounts you passed in
My own fault for using windows I guess, thanks anyway!
You could check here though to learn the basics: https://book.anchor-lang.com/
id really like to simulate a transaction and then look at the changes in the struct.

does anyone know how to do that?
Sorry, I haven't actually looked at any docs in a while, so I'm not sure where they are‚Äîgenerally speaking though the type annotations should tell you what to do
entrypoint invocations are not working. Can you link me up to the latest doc?
I followed this youtube tutorial - https://www.youtube.com/watch?v=joT1xAuU0hI&t=2735s&ab_channel=DougAnderson
That snippet has a mix of old and new syntax, so I'm kind of surprised any of it would work
Are you able to run any of your functions?
Unfortunately none of us work on windows, so not sure üò¨ But this looks like a general cargo thing, not an anchor thing
Just bumping this, still stuck.
this literally is the client
i think so. But don't really know why preflightCommitment is undefined
What does? I would expect what <@!185307556032413697> suggested would work
that returns an obj def not base58 string
It's that `tx` variable
```UnhandledPromiseRejectionWarning: TypeError: Cannot read property 'preflightCommitment' of undefined```
```
await program.methods.initialize().accounts({
  stakeAccount : stakeAccountKey.publicKey,
  counterAccount : counterAccountKey.publicKey,
  genesisAdmin : genesisAdminKey.publicKey,
  systemProgram : anchor.web3.SystemProgram.programId
}).signers([genesisAdminKey]).rpc()
```
can you direct me to a doc or something?
```json
  "instructions": [
    {
      "name": "initialize",
      "accounts": [
        {
          "name": "stakeAccount",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "counterAccount",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "genesisAdmin",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": []
    },
```
Ahh, I guess you are using the new CLI version, in that case you gotta split up accounts and signers (just like .rpc())
```js
     await program.methods.initialize({
          accounts : {
            stakeAccount : stakeAccountKey.publicKey,
            counterAccount : counterAccountKey.publicKey,
            genesisAdmin : genesisAdminKey.publicKey,
            systemProgram : anchor.web3.SystemProgram.programId
          },
          signers : [genesisAdminKey]
        
      }).rpc()
```
```js
Error: provided too many arguments [object Object],[object Object] to instruction initialize expecting:
```
It's coz you haven't invoked it. Chain with an `.rpc()` at the end. So it should look like this
```
const txHash = await program.methods.initialize(
  // all the required stuff
).rpc()
```
That's how the transaction is actually sent.
Hey! <@!134416332509675520>  I'm trying the escrow program and I'm based on your quidproquo project, I'm having problems with the method of canceling the offer and returning the tokens to the maker, I don't get any errors in the instruction, just checking the status of the vault (PDA) keeps the tokens and does not close the PDA account


//////////////////////////////////////////////////////////////////////////////////////////

```rs
    pub fn stake(ctx : Context<Stake>,amount : u32) -> Result<()>{
        let token_account = &mut ctx.accounts.token_account;

        Ok(())
    }
```
error! already adds source information for custom and anchor internal errors
how to check for a token accounts delegate?
no, you don't
Or do I still need to add a `.source()` method call
so does `Err(error!(...))` generate something with a source?
how do you install anchor on cmd
still unclear without a program log tbh, but that's a lot better than just a number, or a panic lol
thank you so much, ye this one was clear
i was looking at master branch like ;-;
The latest version of anchor has way, way nicer errors
https://github.com/project-serum/anchor/blob/v0.18.2/ts/src/error.ts#L71
these errors are so vague like ü§ï
what is 0x92 error in anchor??
ü•≤
Hmm thank you for your time tho.
I wouldn't expect that to make a difference, so not sure off the top of my head what would cause the problem ü§î
Does this make difference?
with confirmed commitment
and connection is devnet
its pretty same
```js
export const setup = (connection, wallet) => {
    const provider = new anchor.Provider(connection, wallet);
    anchor.setProvider(provider);

    // Address of the deployed program
    const escrowProgramId = new anchor.web3.PublicKey(myapp.metadata.address);

    // Generate program client from IDL
    const escrowProgram = new anchor.Program(myapp, escrowProgramId);

    return escrowProgram;
}
```
i have wallet passed instead of the new account
but on front end
so this is on backend
```js
const setup = (connection) => {
    const provider = new anchor.Provider(connection, new Account(require("../rootDir/my_wallet.json")));
    anchor.setProvider(provider);

    // Address of the deployed program
    const escrowProgramId = new anchor.web3.PublicKey(myapp.metadata.address);

    // Generate program client from IDL
    const escrowProgram = new anchor.Program(myapp, escrowProgramId);

    return escrowProgram;
}```
on front end im using wallet account
on backend i have admin account (this one works after some delay...)
Lol
Heh
slight variation
Like, same connection settings etc.?
yes
Mm... hmm. Literally the same?
error
on backend im geting account doesnt exist
same
Ok, and how are you doing it on the backend?
```js
let result;
try {
  result = (await program.account.trove.fetch(data.troveAccountPubkey));
  console.log(result, "result is this");

} catch (err) {
  console.error(err)
}
```
How are you fetching it on the frontend to check that?
But when i called backend, I made sure that the data fetch has value ..
Ye it work like if I have delay
Ye true.. most of the time there is simple solution.. I have different wallet connection but that shouldn't be any issue.
Etc.
Meaning, is it just a confirmation issue?
E.g. what happens if you sleep for 10 seconds and then *then* do the backend fetch?
(That might be incorrect, but it's probably true)
I'm just saying, assume that there will be some simple explanation for the behavior you're seeing
Same network as in
Anchor itself doesn't really do anything when you fetch, it's all just web3.js stuff
Are you 100% sure you're fetching from the same network etc.?
ü•≤
Oh yes. It works that way .. I just didn't wanted to do that haha
yeah, you can
Im passing the data that I get in front end to the backend instead ..
Just when I make call on vackend
Yes but its not coz of that. Im able to recieve the data on front end
you can use it like this `.rpc(confirmOptions);`
Solana cookbook
do you have an example?
Yes
hey guys is it possible to pass in an account's pubKey as seed to find PDA
Havent used that function for any of me txs
Lack of anchor knowledge ..
After I migrated to anchor, everythings a mess ü•≤
When I wasn't using anchor, it used to work just fine..
Web3 connection with confirmed commitment
Im not using provider for connection
ü•≤
Ye its on confirmed
you can do something like this, 
```
    let t = await provider.connection.getTransaction(tx, {
      commitment: "confirmed",
    });
```
It's generally happens, btw what's your commitment level?
üò∂
Just try to fetch data after the tx is completed.then i make a backend request to fetch the account data. And it gives me saying account doesnt exist like wtf..
Hi, I got this anchor fetch in client issue  and its bugging the shit out of me...
U r missing the correct signer for that transaction to proceed.
is there more in-depth documentation for `#[interface]` ? the things I'm wondering about:

1) the docs mention implementing the trait for a struct marked as `#[state]`, but this attribute is deprecated, what can be used instead? I tried `impl MyTrait for program::MyProgram` but then no arm was generated in the dispatch for the instruction... (I still used it and it seems to work just fine tho, and I checked code generation and there doesn't seem to be any extra stuff that I don't want)
2) in the example the trait is declared generic over an `T: Accounts + ...` but can't we specify a concrete type instead? I mean I was able to, but the generated `trait::method` doesn't make use of the concrete type...
also, the method enforces the `Accounts` bound again, which is stricter than the bound of `CpiContext`, so it's not possible to use the generated structs (more on that later)
3) having specified a concrete type for MyTrait's `Accounts` (`MyAccounts`), it seems that `MyAccounts` is present in the crate, but no other "helper" structs are, like the ones present normally in `cpi::accounts`.
I dug around and these structs are generated but simply not re-exported in any modules:
`__cpi_client_accounts_my_accounts::MyAccounts` for example... the generated docs mention it being re-exported but it's not really...

---
now that I think about it, I'm not quite sure this is appropriate for this channel üòÜ
ah nvm just passing in signer seeds wrong lol
the account whos signer priveldge has been escalated is the account which I am trying to create, which is passed into the program from client, it cant be passed as a signer since its a PDA, so I it makes sense this error is trigerring, is there a way around this?

getting this log
yes is that hahah ty
https://docs.rs/anchor-lang/latest/anchor_lang/prelude/derive.Accounts.html#instruction-attribute
Ah, one issue I see is that you aren't using the #[instruction(...)] macro correctly‚Äîit needs to match the order of the arguments to the instruction function!
tyty!
Yep, and you have to get the space exactly right (can jump to source to see how big its supposed to be, but it happens to be https://github.com/solana-labs/solana-program-library/blob/master/token/program/src/state.rs#L129
and setting owner to token program id
this is achieved by  anchor_lang::solana_program::system_instruction::create_account right?
And then, yeah, cpi to the token program with the initialize_account instruction
ah okok great
And then you'd need to first talk to the system program to allocate an account with program owner = the spl token program + space = 165
yup i am passing in the accountInfo struct for the dersired new accountfrom remaining_accounts
all the logic?
where is the program log? üòÖ
(That's a weird other type of address, neither keypair nor PDA‚Äînot what you want)
Nope, you'd need to pass in the desired address from the client
hey all I am trying to create a token account that lives at the current programs PDA, but I want it to be derived using some seeds that I assign. I am also using remaining accounts so cant use anchors beautiful macros, is ``` anchor_lang::solana_program::system_instruction::create_account_with_seed ```  followed by ``` &spl_token::instruction::initialize_account``` the right way to do this?
Ah, no, the program log, not the stack trace from JS
1) escrow send to vault:
     Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account
      at Connection.sendEncodedTransaction (node_modules/@solana/web3.js/src/connection.ts:4052:13)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at Connection.sendRawTransaction (node_modules/@solana/web3.js/src/connection.ts:4014:20)
      at sendAndConfirmRawTransaction (node_modules/@project-serum/anchor/src/provider.ts:286:21)
      at Provider.send (node_modules/@project-serum/anchor/src/provider.ts:120:14)
      at MethodsBuilder.rpc [as _rpcFn] (node_modules/@project-serum/anchor/src/program/namespace/rpc.ts:24:16)
Can you post the full program log? (lol)
running build anchor returned
```
Failed to install bpf-tools: A required privilege is not held by the client. (os error 1314)
```
Can't find the solution to: Cross invocation of programs with unauthorized signer or writable account
<@!134416332509675520>  <@!347689664855015424>   

So I've found what breaks my anchor test suite for all the programs.

When I mean break importing programs from workspace fails test/client without any error messages for all programs.

Compiles and deploys but breaks everything:
```#[account]
pub struct Proposal { 
    pub question: String,  // 
    pub answers: Vec<(String, u32)>, 
    pub deadline: u64,
    pub winner_idx: u8,
}```

Works as expected and other tests work:
```#[account]
pub struct Proposal { 
    pub question: String,  // 
    pub deadline: u64,
    pub winner_idx: u8,
}```

Is this desired behaviour or are vectors not allowed, but I missed it somehwere? 

Either way took me a while to debug it as it was breaking all my other tests, if vectors aren't supported I'd maybe have an error message.

If they are would love to see the correct implementation.
The idea though is that closing accounts is unfortunately a bit tricky in solana. You would think all you need to do is have your program drain the account's lamports, but that's unfortunately not the case: a sneaky client could include an extra instruction in the transaction that *re-funds* the account's rent after you thought you had drained it. So, in addition to trying to drain the lamports, you also need to somehow mark the account's data in such a way that you know you tried to close it, in case a sneaky client zombiefies one of your accounts. The way anchor does this is by swapping out the account's original discriminator bytes for 0xffffffff.
No, it's an anchor specific thing
interesting, what is the close account discriminator is this value universall across all solana programs, so a check is included when these are accounts are passed and it is checked if the account is closed or not ?
any idea what oracles are in use in the solana defi space and what is the process to your token listed on there oracle if anyone has gone through a similar process and can share here, would really appreciate it
sorry for the bother
ok, fixed it. Had to add `mod account;` in lib.rs
sure thanks:
```rust
use crate::account::*;
use anchor_lang::prelude::*;
use anchor_spl::associated_token::AssociatedToken;
use anchor_spl::token::{Mint, Token, TokenAccount};
```
can you share all imports / use from the context.rs file please?
what am I missing?
I have a `context.rs` file and an `account.rs` file. At the top of  `context.rs` I have `use crate::account::*;` just like in the misc example. However I get an `unresolved import` error
I have a feeling it's because of a `RefMut` account I'm passing into my CPI. I tried calling `to_owned()` on it but that just caused other errors.
Running into this error, anyone know offhand what causes it? `solana.rpc.core.RPCException: {'code': -32002, 'message': 'Transaction simulation failed: Error processing Instruction 0: instruction tries to borrow reference for an account which is already borrowed', 'data': {'accounts': None, 'err': {'InstructionError': [0, 'AccountBorrowFailed']}, 'logs': ['Program AQPDVpAsDtd8cfXVjrUEKrhchF4cYwST2wyq3tJa82ci invoke [1]', 'Program log: Debugging', 'Program log: 3', 'Program log: Failed to borrow a reference to account data, already borrowed', 'Program AQPDVpAsDtd8cfXVjrUEKrhchF4cYwST2wyq3tJa82ci consumed 13081 of 200000 compute units', 'Program AQPDVpAsDtd8cfXVjrUEKrhchF4cYwST2wyq3tJa82ci failed: instruction tries to borrow reference for an account which is already borrowed'], 'unitsConsumed': 0}}`
Yeah, it's just a dummy id
every time I run `anchor init`, it initializes a project with the same program ID. is that supposed to happen?
from rust itself (anchor lang?), can call all the accounts from react and use filters with anchor web3, im just new to rust and need to edit a program
```program.account.state.all(filter)```
Hi, i was wondering how i could do something like this
what would the "length of string in bytes" be?
don't forget the account discriminator as well (8 bytes)
https://book.anchor-lang.com/chapter_5/space.html
is there a doc somewhere that shows the space requirements for creating PDAs with init?
Hey is there any equivalent of the Python `eval` function in Rust / Solana? Right now, I'm trying to pass in a String representing a function name of a program and its respective program ID into my function `run_program_function` along with some parameters for the function. I want to invoke the function of the program with something like this:

`eval(passed_in_program_id, passed_in_function_string, [param1, param2, ...., paramN])`

Is there any way to do this?
Hi, what could be some reasons I'm getting a Other(Failed to get account)? If I check explorer on devnet I can see the account, and I know it's an anchor account because if I try to call load_account instead it gives me expects account size x, actual account size x+8
These days with Solana/Anchor it fells like the holy ghost itself is punishing me..

Is there an anchor limit to how many subprograms you can have?

This is my ```Anchor.toml```

```
[features]
seeds = false

[provider]
cluster = "localnet"
wallet = "/Users/chavka/.config/solana/id.json"

[programs.localnet]
example1 = "GbQktab2MXL8JzCYbp7zafGCCF6e9jopoy31bfECZWpP" 
example2 = "CCqjVaJ2P5rPtwwH3p6Bg18DG5Whmj5TQSCHRiCezTon"
example3 = "DTkZgGrsNqC34o38M4Kq4KHzzuh2aZu9CBjbNkpwhPBi"

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"
test1 = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/test_example1.ts"
test2 = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/test_example2.ts"
test3 = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/test_example3.ts"
c2 = "yarn run ts-node  app/client2.ts"
c1 = "yarn run ts-node app/client1.ts"

```
If I compile, deploy and test this, any test will give me for   ```console.log("anchor: ",anchor)```:



```  anchor:  {
  BN: [Getter],
  web3: {
    Account: [class Account],
  ...

  Spl: [Getter],
  workspace: {},            // EMPTY
  Wallet: [class NodeWallet]
}```


If I nuke the whole directory that contains ```/example3``` and remove ```example3 = "DTkZgGrsNqC34o38M4Kq4KHzzuh2aZu9CBjbNkpwhPBi"```  I will be able to compile, deploy and crucially test without any problems with nothing being changed for example1 and example2 in Anchor.toml and respective directories (besides new program IDs after redeployment).  


There being some cap on program seems possible, but kind limiting and not documented. Otherwise it could be something in my ```/example3``` directory that is somehow making anchor unable to fetch the workspace data, but nothing obvious springs to mind. Not sure, but will debug further tomorrow.
What would be the best practice to mock popular tokens (raydium, wETH, usdt, etc.) locally? Would you just create token accounts/mints and call them when needed?
Don't worry, doubt it's a ghost lol. Hmm
There isn't an error!

Just running

```  console.log("anchor: ",anchor)```

Gives

```
  anchor:  {
  BN: [Getter],
  web3: {
    Account: [class Account],
  ...

  Spl: [Getter],
  workspace: {},            // EMPTY
  Wallet: [class NodeWallet]
}
```

So test quite with workspace being empty

#[program] is also correct accross .rs files.

Everything was fine until it wasn't and I didn't modify Anchor.toml or lib.rs.
And make sure your `#[program]` module has the same name etc.
Can you post the actual error you get?
Yeah it is, I posted it from mismatched commits...

This is how in file import look slike:

```const provider = anchor.Provider.local();
anchor.setProvider(provider);
const program = anchor.workspace.Example1;  // or Example2

```
Those program names will have to match, so here `example1` != ex1
```[features]
seeds = false

[provider]
cluster = "localnet"
wallet = "...<USERNAME>/.config/solana/id.json"

[programs.localnet]
example1 = "6LjetdJE2k9T5eoi25jEqw2qWma9aXWQSgcwYb9gB17p"
example2 = "CwWmug2yQwcNFGNtBkLj6Ex2CpXbeqE3WU2ntw8BYe55"

[scripts]
test1 = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/test1.ts"
test2 = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/test2.ts"
c1 = "yarn run ts-node app/client1.ts"
c2 = "yarn run ts-node  app/client2.ts"
```
What does your Anchor.toml look like?
My workspace seems to disappeared or is unable be able to be loaded again when running any of the anchor scripts.

I reverted to a previous commit in case it's code additions that did it, but issue still persists.

This is how I load the environment in the test.ts:

```const provider = anchor.Provider.local();
anchor.setProvider(provider);
const program = anchor.workspace.Ex1;```

I have run ```anchor clean``` and deleted rust cache at:

``` rm -rf ~/.cargo/registry/index/*
rm -rf ~/.cargo/.package-cache```

Any ideas how to debug further or what could have caused it?
https://solana-labs.github.io/solana-program-library/token/js/modules.html#closeAccount
also i just realize I don't want to close the full account haha. this stuff is really funky
but in typescript xD
Yeah, that would be the one
unwrapping all of the SOL is ok, i'm just having trouble finding an appropriate instruction in typescript... only found this in rust so far: https://docs.rs/anchor-spl/latest/anchor_spl/token/struct.CloseAccount.html
as long as you use `UncheckedAccount`, you can copy the `close` function from our repo. `lang/src/common.rs`
It gets insane when gas price is high (>$300). The burden is on the end user tho who runs the tx
Actually, damn, eth storage is pretty expensive! Wow, I had never run the numbers before‚Äîaccording to that post, storing 1kb currently costs about $100 üòØ On solana it's more like $1.
but what about the code to manually close the account, that is what is not clear to me üò¶
`pub token_trade_account: Account<'info, TokenTradeAccount>`
so instead of this i use UncheckedAccount.
that would be awesome üôè  well then i was not wrong in not finding any solution online.
youll be able to just do account.close() once https://github.com/project-serum/anchor/issues/1703 is merged
`pub fn token_trade(
        ctx: Context<TokenTrade>,
        trade_quantity: u32,
    ) -> ProgramResult {

        let token_trade_account = &mut ctx.accounts.token_trade_account;
        token_trade_account.trade_quantity -= trade_quantity;

        if token_trade_account.trade_quantity == 0 {
            /// Close account here
        }
        Ok(())
    }

#[derive(Accounts)]
#[instruction(trade_quantity: u32)]
pub struct TokenTrade<'info> {
    #[account(mut)]
    pub initializer_main_account: AccountInfo<'info>,
    #[account(
        mut,
        constraint = token_trade_account.initializer_key == *initializer_main_account.key,
    )]
    pub token_trade_account: Account<'info, TokenTradeAccount>,
}

#[account]
pub struct TradeAccount {
    pub initializer_key: Pubkey,
    pub trade_quantity: u32,
}`
üòÆ everything what you say here is just beyond me üò¢ let me give a code sample. Would be really great if you could show how to do it üôè
if you want to close conditionally, you have to close manually and make sure *not* to use a type that sets the discriminator at the end (because it will set the discriminator to the non-closed one again). TLDR: use `UncheckedAccount`, not `Account<'info, T>` and if it's an anchor acc of your program, set the discriminator to the CLOSED one yourself
true
If it's one of your own accounts, you'll have to manually drain its lamports yourself, plus zero out the account's data. <@!347689664855015424> what's the state-of-the-art way to do this now?
<@!134416332509675520> could you please help me out here?? I am really stuck, can‚Äôt find any good answer on internet üòì
At the end of the day, storing large amounts of data on a blockchain is going to cost you a lot of money regardless of where you store it
It might not strictly speaking have any rent, but it definitely costs money to store stuff on ethereum https://ethereum.stackexchange.com/questions/872/what-is-the-cost-to-store-1kb-10kb-100kb-worth-of-data-into-the-ethereum-block
an eth smart contract can store 2^256 bytes of data without any rent. If the same contract be implemented in sol with 10mb data storage, the rent is like 0.199817492 SOL per epoch, how to get around it without sacrificing the decentralization?
Hey guys, I really need some help, been trying to figure this one out for past few days.
So I have a custom struct Account, which saves some data.. I use this account few times to read and write data to it. Now I want to close this account, I know that we could use #[account(mut, close=beneficiary)] can close the account. But I want to close the account only when a condition is met. How can I do this?

I am generating the key for the account from frontend and then use #[account(zero)] to initialize it.

I tried using token::CloseAccount but not sure who is the authority/signer for this account. Any help would be really great üôè thanks a lot in advance.
Alright, is it possible to retrieve logs of a solana instruction then ? if event is just a log and logs are retrievable i could make that work.


//////////////////////////////////////////////////////////////////////////////////////////

so i was trying to understand how pyth should be used and got referred to drift protocol, can anyone who has used oracles explain why is drift doing this scaling ? 
```    pub fn get_pyth_price(
        &self,
        price_oracle: &AccountInfo,
        clock_slot: u64,
    ) -> ClearingHouseResult<OraclePriceData> {
        let pyth_price_data = price_oracle
            .try_borrow_data()
            .or(Err(ErrorCode::UnableToLoadOracle))?;
        let price_data = pyth_client::cast::<pyth_client::Price>(&pyth_price_data);

        let oracle_price = cast_to_i128(price_data.agg.price)?;
        let oracle_conf = cast_to_u128(price_data.agg.conf)?;

        let oracle_precision = 10_u128.pow(price_data.expo.unsigned_abs());

        let mut oracle_scale_mult = 1;
        let mut oracle_scale_div = 1;

        if oracle_precision > MARK_PRICE_PRECISION {
            oracle_scale_div = oracle_precision
                .checked_div(MARK_PRICE_PRECISION)
                .ok_or_else(math_error!())?;
        } else {
            oracle_scale_mult = MARK_PRICE_PRECISION
                .checked_div(oracle_precision)
                .ok_or_else(math_error!())?;
        }

        let oracle_price_scaled = (oracle_price)
            .checked_mul(cast(oracle_scale_mult)?)
            .ok_or_else(math_error!())?
            .checked_div(cast(oracle_scale_div)?)
            .ok_or_else(math_error!())?;

        let oracle_conf_scaled = (oracle_conf)
            .checked_mul(oracle_scale_mult)
            .ok_or_else(math_error!())?
            .checked_div(oracle_scale_div)
            .ok_or_else(math_error!())?;

        let oracle_delay: i64 = cast_to_i64(clock_slot)?
        .checked_sub(cast(price_data.valid_slot)?)
       .ok_or_else(math_error!())?;

        Ok(OraclePriceData {
            price: oracle_price_scaled,
            confidence: oracle_conf_scaled,
            delay: oracle_delay,
            has_sufficient_number_of_data_points: true,
        })
    }
```
what a weird issues, any guess why it occurs?
but need to install the same version as anchor(0.23.0) have `solana-program = "1.8.16"`
though it solves the problem, xD
No NFTs, but drift uses oracles: https://github.com/drift-labs/protocol-v1
Hmm not sure what's up with that, the pubkey macro definitely exists: https://docs.rs/solana-program/1.8.14/solana_program/macro.pubkey.html
are there any open source apps that uses anchor? I'm looking for 

1. programs used to Mint NFTs
2. Anything that uses an oracle
but `solana-program` is in the mod scope, it's just macro is not
And then do `solana_program::pubkey!`
Oh, hmm, maybe that's a bug‚Äîyou can probably also just add a dependency to your programs/<prog-name>/Cargo.toml on `solana-program`
You're right, I can't find it too.
or am i missing something here?
In the latest version of anchor "0.23.0". It is not working, right?
```
failed to resolve: could not find `solana_program` in the list of imported crates
not found in `solana_program::pubkey`rustc(E0433)
lib.rs(36, 35): not found in `solana_program::pubkey`
```
You can use the `pubkey!` macro:
```.rs
const THE_ADDRESS: Pubkey = anchor_lang::solana_program::pubkey!("adsfasdfasdf");
```
What's the standard way to hardcode some account addresses in a program? There's a way to do it using creating a file and then `declaring_id` inside it, but that's semantically declaring ID of a program right? So any more "semantic" way to do it?
Not in general, only if you really are going to mutate it
one of them should have the resource on it.
https://solana.com/riptide/resources <@445019022338031618> check this one out
but there are heaps of other resources
somewhat helpful..
try the anchor book
any good resources on the anchor client for rust ?
thats the only reason i can think for making it mutable
and it will change the sol balance in the account ..
coz you paying transaction fees from it
u do actually need to have it on mut
oh yes
I saw somewhere that Signer type need to mark as mut (cannot remember where maybe in changelog)
yea i vaguely recall having to mark them as mutable
although i have it on mut.
unless u are changing something in that account
dont think so tbh
pumping new changes like flies.. ü•≤ . Ye true there will always be new improvements, just hassle while upgrading haha..
is a signer required by solana to be a mutable account?
If it aint broke, you can always just use a fixed package.json dependency (though the new api is nice/easy to use)
Lol
oh shitt...
I assume no
oh i see. thank you so much. will it be supported in all the new versions later ??
It's fine, you can still use it lol, but the new way is `program.methods.yourInstruction(arg1, arg2).accounts({ ... } ).instruction();`
the instruction bit?
why is program.instruction is deprecated.???
ü•¥
my brain is lagging, i had it like that on my other import, idk y i did it that way in my reward import ...
ü•≤
it worked, was about to post it haha
ye just tried that
`const anchor = require("@project-serum/anchor");`
```const {anchor} = require("@project-serum/anchor");
```
ü§ï ü•≤
y is it showing me anchor undefined..
tried to import that module..
i had anchor installed with ``npm install @project-serum/anchor``
`ctx.program_id`
How do I access the current program ID the anchor way?
üò∂‚Äçüå´Ô∏è
hmm seems like my anchor import is showing undefined lool like dafaq...
That's it, thanks.
More like
```.rs
let hmm: Account<Thing> = Account::try_from(&acct)?;
```
How to unpack accounts in a loop and use them?

``` let acct_vec: Vec<AccountInfo> = ctx.remaining_accounts.to_vec();        
    for (idx, acct) in acct_vec.iter().enumerate() {
       let tmp: Account<Acct> = // SOEMTHING HERE
    }```

I know I  need some sort of a cast from `AccountInfo` into an instance `Account<Acct> ` but not sure how to do it.
ok sorry
Hey, please don't cross-post üôè
error log :
```
server          | TypeError: Cannot read property 'BN' of undefined
server          |     at createAddRewardIx (/app/server/services/program.js:151:89)
server          |     at processTicksAndRejections (node:internal/process/task_queues:96:5)
server          |     at async claimReward (/app/server/commands/claimReward.js:50:21)
server          |     at async addReward (/app/server/controllers/rewardController.js:31:13)
```
passing the argument for the instruction ...
Hi, when i try to pass the ```new anchor.BN(value) // where the value is 0``` , it gives me undefined error..
OMG thanks so much for the help! <@!242234529396424704>
https://solanacookbook.com/references/programs.html#how-to-transfer-sol-in-a-program for transferring sol
<@165098054792249344>
use the solana way to do that
you dont need that
```let ix = anchor_lang::solana_program::system_instruction::transfer(
        sender,
        receiver,
        amount,
    );
    
    anchor_lang::solana_program::program::invoke(
        &ix,
        &[
            ctx.accounts.sender.to_account_info(),
        ]
    );```
Hi guys, I am trying to store an account with the pubkey of a SystemProgram, and attempt to transfer lamports to it later on. 
This is what I am trying to do when sending over the lamports.
```
pub fn transfer_to_lamport_receiver(ctx: Context<TransferLamports>, avail_amount: u64) -> Result<()> {
    let sender = &mut ctx.accounts.sender.key.clone();
    let receiver = &mut ctx.accounts.receiver.receiver_pubkey.clone();
    let amount = ctx.accounts.receiver.amount.clone();
    if amount > avail_amount {
        panic!()
    }
    let ix = anchor_lang::solana_program::system_instruction::transfer(
        sender,
        receiver,
        amount,
    );
    
    anchor_lang::solana_program::program::invoke(
        &ix,
        &[
            ctx.accounts.sender.to_account_info(),
        ]
    );
    Ok(())
}

#[derive(Accounts)]
pub struct TransferLamports<'info> {
    #[account(mut)]
    sender: Signer<'info>,
    #[account(mut)]
    receiver: Account<'info, ReceiverLamportDetails>,
    pub system_program: Program<'info, System>,
}

#[account()]
pub struct ReceiverLamportDetails {
    pub amount: u64,
    pub receiver_pubkey:Pubkey,
}
```

This is the error logs I am thrown, GMb5CVKKUgZPbbn1AusrtGgKvpQwwsFgSXzrtLzy1dwH is the account I want to send lamports to
```
Transaction simulation failed: Error processing Instruction 0: An account required by the instruction is missing 
    Program HS59oAVB73bP2gnrU3eeaUfGkpQwoBLsByMH7AAwsCwe invoke [1]
    Program log: Instruction: TransferLamports
    Program log: 7dojGo6ykwwPEAdiX3DNc758kFj8qCeSuskxrraLHWCH
    Program log: GMb5CVKKUgZPbbn1AusrtGgKvpQwwsFgSXzrtLzy1dwH
    Instruction references an unknown account GMb5CVKKUgZPbbn1AusrtGgKvpQwwsFgSXzrtLzy1dwH
```

Could someone help, thanks for reading!
Tanks for the clarification, so solana added this at some point. Good to know.
Solana lets you just do `Clock::get()?` now, but some older contracts still require you to explicitly pass in the clock sysvar account
Hello everyone,  I see on some contracts that they send clock account from the client I have never done it but I'm still be able to use `Clock::get()?.unix_timestamp` and work so far.
Does anchor handle this or how can both work now? I will inquire but wanted ask here if there is a quick answer here.
or other way: how should I retrieve a value of a struct's field in typescript if using `program.accounts.pool.fetch(poolAddress)` gives me corrupted data?
In a given context, will accounts be only initiated if all all the constraints are satsified for all of the accounts or would an account be initialised, but then transaction be reverted on the second account macro where conditions weren't met?
maybe you could know another approach to implement it?
Hey.... Since an nft in Ethereum is pretty much a smart contract that inherits the ERC721 contract, we can add custom attributes to our nft. Is it possible to do similar stuff in solana?
Found an interesting resource 

https://husobee.github.io/money/float/2016/09/23/never-use-floats-for-currency.html

Mentioned in one of Soteria‚Äôs blog
Yeah got it.
zero_copy unfortunately doesn't work well with js deserialization, I'm actually not sure what the recommended fix is though
The non-float alternative there is to upcast to u128, multiply by 3 and then divide by 10, then downcast back to u64 (I think)
<@!134416332509675520> or what about using the methodology Metaplex uses to compute royalties in terms of basis points?
So I want to implement a functionality taking % of variables. 

For example: 

User_balance: 1mil

Multiplier: 0.3 (30%)

Amount: 0.3*user_balance = 300k

Something like this

I was thinking to set the variables multiplier and amount as f64 so that multiplication is possible
Is something going wrong currently? Solana just doesn't have much float support, so you may have to find another way
Hi all! I have a problem prob with serialization. I have such struct:
```
#[account(zero_copy)]
#[repr(packed)]
#[derive(PartialEq, Default, Debug)]
pub struct Pool {
    pub token_x: Pubkey,
    pub token_y: Pubkey,
    pub pool_x_account: Pubkey,
    pub pool_y_account: Pubkey,
    pub admin: Pubkey,
    pub project_owner: Pubkey,
    pub token_x_reserve: TokenAmount,
    pub token_y_reserve: TokenAmount,
    pub self_shares: TokenAmount,
    pub all_shares: TokenAmount,
    pub buyback_amount_x: TokenAmount,
    pub buyback_amount_y: TokenAmount,
    pub project_amount_x: TokenAmount,
    pub project_amount_y: TokenAmount,
    pub lp_accumulator_x: TokenAmount,
    pub lp_accumulator_y: TokenAmount,
    pub const_k: Decimal,
    pub lp_fee: Decimal,
    pub buyback_fee: Decimal,
    pub project_fee: Decimal,
    pub bump: u8,
}
```
I set value of `2_000_000_000` for `lp_fee` field, however after fetching the structure in typescript using `program.account.pool.fetch(poolAddress) I get a fixed, but random value for this field. I think it's about serialization.
I would appreciate any help
Hey guys! How do I perform math safe function calls like checked_mul on type f64? Any idea? Thanks üôÇ
the name itself does nothing at all, info is just the name of the lifetime, it could be a, b, c ,d...
Hi guys, am working on a buildspace project allows users to add gifs and vote on their favourite ones. I have deployed and tested on devnet with a test script, but now have issues when pointing my frontend (repl.it) to the updated contract (I have uploaded the new idl data). What am I doing wrong? My test script is in firstproject.js, my rust contract is lib.rs. The key differences between the old working contract and this one is the addition of the vote function and updated custom struct with "votes" to store the votes. The createGifAccount function looks like this:
```const createGifAccount = async () => {
    try {
      const provider = getProvider();
      const program = new Program(idl, programID, provider);
      console.log("pinged");
      await program.rpc.startStuffOff({
        accounts: {
          baseAccount: baseAccount.publicKey,
          user: provider.wallet.publicKey,
          systemProgram: SystemProgram.programId,
        },
        signers: [baseAccount]
      });
      console.log("Created new BaseAccount w/ address: ", baseAccount.publicKey.toString());
      await getGifList();
    } catch (err) {
      console.log("Error creating BaseAccount: ", err)
    }
  }```
ok. dm it works. was doing something else stupid
What is the template for asserting within typescript tests that an invalid transactions gets rejected?

I've tried it with try/catch as a hacky way but it still marks the test failure despite failure being desired.
yeah figured it out, I thought there was a way to specify arguments so you dont mess up the order just like with accounts but apparently not. thanks
It's just not coming over right
I think it is too. I'm simply just trying to print a `msg!` of data from the non-anchor account and I am still getting the same error.
has anyone ever seen this during cargo run? only thing I can think of is I got this after running rustup update, but I reverted my update, cargo clean+run and this still occurs
https://docs.rs/solana-program/latest/solana_program/macro.entrypoint.html
it's the lifetime that comes from the entrypoint, https://docs.rs/solana-program/latest/solana_program/account_info/struct.AccountInfo.html
Right, I see it everywhere and I wanted to know the significance.
Maybe it doesn't need to though
hmm good question, I assume because in anchor everything that has `Account` has that lifetime so I just assumed it went there.
Digging through the code I'm thinking something to do with serialization, but want to make sure
Right, info is defined as the rust lifetime, but what does info itself do
I'd say more but I'm a rust beginner so I don't want to give misinformation üôÇ
https://doc.rust-lang.org/rust-by-example/scope/lifetime.html
Defines the rust lifetime
What does `<'info>` do on `AccountInfo<'info>`?
I was then going to do something like `Box<Account<'info, NonAnchorAccount>>`
General question about integrating Anchor programs with non-anchor programs. Here is my situation:

1. I am writing an Anchor program that is constructing a CPI call to a non-anchor program.
2. This Anchor program I am writing has to read an account from the non-anchor program first, to read information from it.
3. This information is then used to pass in to the CPI call from Anchor to the non-anchor.

I am getting access violations using the non-anchor account. Does this mean I need to implement `AccountSerialize`, `AccountDeserialize`, `Owner`, and `Copy` traits on the non-anchor account so I can read them in? I am beginning to think so but wanted to ask before I start doing all the work to implement that.
Basically I'm planning to switch my client repos from native jest to anchor (running mocha or jest, idc really) and wondering if there's any pitfalls I should be aware of ahead of time
I haven't hooked this up yet but like I assume the client can have easy access to the localnet anchor spins up for the duration of the test if I test via `anchor test` and such.
Are there best practices on leveraging anchor when testing client-side only code? I.e., not in a repo that holds smart contracts (though it can have access to any IDLs from such as needed)
hi fam,
its there an anchor resource(repro code) for creating daos?
https://github.com/project-serum/anchor/blob/master/cli/src/config.rs#L285-L288
is there a list somewhere of Anchor.toml [features] ?
Hey all, have a question related to CPI calls to Serum. Currently trying to place a NewOrderV3 CPI instruction but getting this error: `Program failed to complete: Instruction passed to inner instruction is too large (1342 > 1280)`
ya that's what the resolution here was. to check size of byte array not length of string
another option is `string.as_bytes().len()`
it's actually undefined behavior to have a non-utf8 `str`  in Rust üòõ
tysm <@!134416332509675520>
sick
instead of length of string
Right, the constraint is on the underlying raw bytes
I realized I can actually just put a constraint on byte size of string, right?
https://stackoverflow.com/questions/61909723/how-many-bytes-does-a-char-take-up-when-stored-in-a-string-slice
Ah, yeah, those still work in utf-8 üòõ
and other chars which use 3 bytes a pop
well in plain rust u can def use greek letters etc, no?
Thank You so much <@!347689664855015424> & <@!134416332509675520> I was able to successfully close my custom account with a condition. You guys are amazing <a:giphyraisedhands:909177775699681321> keep up the good work <a:rainbowlove:909177777041834006>
Strings in general in rust use utf-8.
Yeah, it would be utf-8
and it's limited to UTF-8 or something?
You can just store a String, yeah, plus make sure you give it enough space
What is the cleanest or most idiomatic way to store a `String` in an account? Is it to turn it into a zero-padded byte array? Or can I just store the `String` so long as the account has enough space?
or should I use test.genesis?
I want to have a different program available in the local validator anchor uses (token-metadata program specifically), do I just need to do this?
```
Anchor.toml:
[test.validator]
url = "https://api.mainnet-beta.solana.com"
[[test.validator.clone]]
address = "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"
```
just do 
```
await program.rpc.function(      
          arg1,arg2,arg3
        ,        
        {  
          accounts: {  // key name in IDL
            acc1: pda_1,         
            acc2: player.publicKey,       
            SystemProgram.programId,
          },
          signers: [player],      
      })
    );    
```
When calling method via rpc call with multiple arguments what is the syntax for passing those arguments in the client?

This doesn't quite work:
```
 await provider.connection.confirmTransaction( 
      await program.rpc.function(      
        args: {     // key name in IDL
          arg1: Buffer.alloc(1,4),
          arg2: false
        }
        ,        
        {  
          accounts: {  // key name in IDL
            acc1: pda_1,         
            acc2: player.publicKey,       
            SystemProgram.programId,
          },
          signers: [player],      
      })
    );    ```
bro can someone send a link to a anchor download tutorial because i get errors all the time
cheers
yus, you can `constraint=Clock::get()?.unix_timestamp > someXYZ`
don't see why not, you might need to specify the trait tho... `<Clock as solana_program::sysvar::Sysvar>::get().unwrap()`
thanks man
hey guys, is it possible to bring in clock (`Clock::get().unwrap();`) into anchor constraint?
```rust
use anchor_lang::solana_program::pubkey;
...
pubkey!("")
```
works also
yus
sick ty
correct?
and to verify the delegate pubKey is same as a particular pubKey 
```rs
ctx.accounts.token_account.delegate == anchor_lang::prelude::Pubkey::from_str("pubkey_string")
```
install WSL2, follow ubuntu install instructions
thanks
and for delegate amount `ctx.accounts.token_account.delegated_amount`
you can use `ctx.accounts.token_account.delegate`


//////////////////////////////////////////////////////////////////////////////////////////

i will try that then. thanks!
Yeah, can definitely imagine a slicker version of that but it's not implemented yet
You just call set_return_value in the one program and then subsequently retrieve it in the caller
get return value and set return value use the newly introduced solana syscalls which anchor does not have a abstraction for yet, if am not wrong.
I don't think there would be anything anchor specific
so how does this translate into a workflow for get_return_value with programs built with anchor? just looking for examples of that, if there are any?
see the memoy map used by solana, https://docs.solana.com/de/developing/on-chain-programs/overview
the deserialized account is at the stack which starts at 0x2000 , the input parameters passed by the runtime start at 0x4000 so what you actually is a deserialized version stored on the stack, you need to again look at the account at address 0x4000 and deserialize it again.
when you deserialize you create a copy on the stack , when u do a cpi and some state changes happen into the account, it happens in the account passed to you, in solana all these accounts reside at different memory addresses, so you need to again deserialize the account passed in the runtime to see the reflected changes, please feel free to correct me if am wrong <@134416332509675520>
is the reload pattern using the shared memory for return values?
i see.  what i am trying to create is a program that can consume an onchain data feed. each returned value should be a few hundred bytes max
as the return and set data is limited 1024 bytes , the reload pattern does not come under this restriction
Why better?
Ah, yeah, when you burn tokens you reduce the mint's `.supply` field (how many tokens are outstanding)
isnt the reload pattern better, but sure an example regarding this  new feature would be good too.
Do you know of any examples of `get_return_data` feature of solana when making CPI's in a program using anchor?
yeah the problem was that `mint` was not writable, not sure why we need it but making it mutable solved.
something like
```rust
#[account]
pub struct SomeAccount {

    pub data: u8,

    pub my_struct: MyStruct,
}

pub struct MyStruct {
  pub counter: u16,
  pub bytes: [u8, 32]
}
```
Yeah, I don't think anchor has a way to do that yet (the IDL generation in general is not super smart yet)
I assumed, since I have that crate as a dependency, that the type would be automatically included (or that anchor would provide a way to explicitly tell the compiler that I want that type)
not exactly clean code, and will have to keep track of any update
problem is I have to be recursive with this
(So, tedious but not super hard)
yeah, exactly
Ah, well, you may have to convert between your own MyDataV2 to the actual DataV2 type before serializing the instruction
How so?
I thought the same, but it's possibly gonna give me problems with CPI
Same fields etc., but your own struct
Mm, yeah, this will be kind of annoying but I think you're going to have to write your own little version of it üò¨
my struct that I'm passing as an instruction parameter
the type in question, I cannot touch this
How are you typing the rust side?
Hey, is it possible to use types from non-anchor programs as intructions parameters? I'm getting an IDL error saying it cannot find the type
User-defined how?
Sure, just need to sign with whoever has authority over the token account
Hi everyone,  is it possible to burn tokens in pda account (pda itself is not mint auth but only holds tokens, we want to burn the token it holds)
Is there an example somewhere of someone storing a user-defined struct in an account?
thanks will update! recommend using the book instead of the project-serum.github.io docs because we are sunsetting those
on both of these pages it states that CPI cannot return values: https://project-serum.github.io/anchor/tutorials/tutorial-3.html#signer-seeds

https://docs.rs/anchor-lang/0.2.1/anchor_lang/attr.interface.html
Nice thank you!
that should do it
```toml
[dependencies]
anchor-lang = {version="<version>", features=["init-if-needed"]}
```
how to enable `init_if_needed` feature on cargo? it says init_if_needed requires that anchor-lang be imported with the init-if-needed cargo feature enabled.
okay, thank you!
`my_thing.exit(ctx.program_id)?` I think
I remember reading about this some time ago
oh, right, how was that done? persisting the changes I mean
It's unfortunately a little trickier than that though, since if you want to subsequently write to the account (guess not in the stuff you're doing above) you have to manually persist the changes
If you want to get an `Account<'info, Thing>` out of the raw AccountInfo though you'd need to do something like
```.rs
let my_thing: Account<Thing> = Account::try_from(&the_account_info)?;
```
so, I should just be able to deserialize the account manually, no?
okay, true, only deserialized accounts need to be reloaded
AccountInfo's don't need to be reloaded, since they just point to their data (which gets updated by the CPI)
I read in the book about AccountInfo::reload(), but I can't find what to import in order to use it
oi, how can I reload an account after a CPI call and also update its type? For instance, I have an UncheckedAccount that I send to system program and the token program to create a mint. Then I want the type to be updated to Account<Mint> and the data to be reloaded
yus you can, it make sense for me
Hey guys!

If I‚Äôd want that only a particular address can update the field of a PDA account, 

Should it be okay if instead of having the update_auth field in the PDA struct,

I hardcode the address of update_auth in a separate file and then just add a constraint in the update func. whether the signer address is same as the hardcoded one? 



Because, I only want one particular address to be the update_auth over all the PDA instances, so hard coding helps save rent for that field throughout all the PDA instances
can anyone try this and let me know if it is work or not it might be an issue with my system thanks
https://github.com/Aurory-Game/comptoir.git
Hey it is possible for a wallet own by a solana program to refuse transaction "transfer"?
Could you elaborate on this how does this lterbative to float work nd when should it be used
time before jan 1970 will be negative value
btw any resources on how normalization work for example why are they converting i64 to i128 and ?
Hey guys, I am trying to run anchor on M1, I am getting below issue -
Hey guys!

Rust‚Äôs Unix timestamp returns an i64‚Ä¶ was wondering why would that be.. and if it‚Äôd be okay to cast it as u64 explicitly
https://book.anchor-lang.com/chapter_5/avm.html
any resources/documentation ?
use avm
Is it possible to run two different anchor version on a system ? If yes how to switch b/w them ?
emitting seeds for PDA in the IDL
what is the seeds feature used for ?
The transfer_authority function is the Solrand program
```
/**
     * Used by PDAs in CPIs to lock an Oracle request
     */
    pub fn transfer_authority(
        ctx: Context<TransferAuthority>
    ) -> ProgramResult {
        msg!("Before load_mut");
        let requester = &mut ctx.accounts.requester.load_mut()?;
        msg!("Requester ok");

        if requester.authority != ctx.accounts.authority.key() {
            return Err(ErrorCode::Unauthorized.into());
        }

        msg!("Unauthed");

        if requester.active_request {
            return Err(ErrorCode::RequesterLocked.into());
        }
        msg!("locked");

        requester.authority = ctx.accounts.new_authority.key();
msg!("Ok!");
     
        Ok(())
    }```
```#[program]
pub mod cross_pile {
    use super::*;

    pub fn create_coin(
        ctx: Context<CreateCoin>,
        coin_bump: u8,
        _req_bump: u8,
        vault_bump: u8,
        amount: u64,
    ) -> ProgramResult {
        let authority_key = ctx.accounts.initiator.key();
        msg!("Authority key {:?}", &authority_key);
        // Set data for PDAs
        { 
            let coin = &mut ctx.accounts.coin.load_init()?;
            let clock: Clock = Clock::get().unwrap();
            
            coin.initiator = authority_key;
            coin.acceptor = ctx.accounts.acceptor.key();
            coin.is_flipping = false;
            coin.created_at = clock.unix_timestamp;
            coin.bump = coin_bump;

            let vault = &mut ctx.accounts.vault;
            vault.amount = amount;
            vault.bump = vault_bump;
        }

        msg!("Requester {:?}", ctx.accounts.requester.to_account_info());
        msg!("initiator {:?}", ctx.accounts.initiator.to_account_info());
        msg!("Coin acc {:?}", ctx.accounts.coin.to_account_info());
        msg!("system_program {:?}", ctx.accounts.system_program.to_account_info());

        msg!("Solrand {:?}", ctx.accounts.solrand_program);
        // Transfer authority for the oracle requester to the Coin PDA
        let cpi_accounts = solrand::cpi::accounts::TransferAuthority {
            requester: ctx.accounts.requester.to_account_info(),
            authority: ctx.accounts.initiator.to_account_info(),
            new_authority: ctx.accounts.coin.to_account_info(),
            system_program: ctx.accounts.system_program.to_account_info()
        };

        let cpi_context = CpiContext::new(
            ctx.accounts.solrand_program.clone(),
            cpi_accounts
        );

        msg!("Before transfer authority");
        solrand::cpi::transfer_authority(cpi_context)?;

        msg!("After transfer authority");
        // Transfer sol from Initiator to Vault PDA
        let ix = anchor_lang::solana_program::system_instruction::transfer(
            &ctx.accounts.initiator.key(),
            &ctx.accounts.vault.key(),
            amount,
        );
        msg!("created ix");
        anchor_lang::solana_program::program::invoke(
            &ix,
            &[
                ctx.accounts.initiator.to_account_info(),
                ctx.accounts.vault.to_account_info(),
                ctx.accounts.system_program.to_account_info(),
            ],
        )?;

        Ok(())
    }```
It seems like the account that's being used belongs to Program that's on it's Github repo. For reference I'm trying to run https://github.com/evanmarshall/cross-pile, which has a dependency on https://github.com/evanmarshall/solrand

Here is the function that makes the CPI to Solrand::transfer_authority
I'm trying to understand why "An account required by the instruction is missing" is happening
Does anyone know how I should make the msg! outputs appear?
I'm trying to make a CIP call but I can't see any outputs from the msg! calls in the CIP when I run `anchor test`, or in `solana logs`
I could've sworn there was an `unwrap`-esque method somewhere that returns a custom error if program panics. Am I misremembering?
As they have the same format than a public key, type `Pubkey`is fine, if you try to call `key()`function of the account, it will return a `Pubkey`
okay since PDA are not public keys which Type should a PDA be assigned to?
100%, PDAs are deterministic, the way to generate  different ones is by providing different seeds only
the PDA being made in the frontend is because you need to pass all the accounts that need to be interacted with to the solana runtime, but the anchor will actually invoke the systemprogram account to create the account on chain and store the data for you. 
If you didn't use anchor, you could do it manually, or you could do like SPL Token does and have you create the account manually and then initializing it with the initializeXYZ instruction
okay what are the chances of two entity generating the same PDA for the same program ID?
in the backend, the seeds parameter is just a constraint that allow only the account with the same computed PDA. If u give a different PDA in the frontend, the constraint will fail in the backend and ur instruction will fail
why the pda is being created by the both frontend and backend for the user_stats account?
createUserStats entrypoint already providing a PDA for the user_stats account
in the frontend - 
```rs
    const [userStatsPDA, _] = await PublicKey
      .findProgramAddress(
        [
          anchor.utils.bytes.utf8.encode("user-stats"),
          anchor.getProvider().wallet.publicKey.toBuffer()
        ],
        program.programId
      );

    await program.rpc.createUserStats("brian", {
      accounts: {
        user: anchor.getProvider().wallet.publicKey,
        userStats: userStatsPDA,
        systemProgram: SystemProgram.programId
      }
    });
```
its creating user_stats account by generating a PDA
from the anchor book example - 
```rs
// validation struct
#[derive(Accounts)]
pub struct CreateUserStats<'info> {
    #[account(mut)]
    pub user: Signer<'info>,
    // space: 8 discriminator + 2 level + 4 name length + 200 name + 1 bump
    #[account(
        init,
        payer = user,
        space = 8 + 2 + 4 + 200 + 1, seeds = [b"user-stats", user.key().as_ref()], bump
    )]
    pub user_stats: Account<'info, UserStats>,
    pub system_program: Program<'info, System>,
}
```
not sure about that, not that am aware of
yeah I see, alright. thought perhaps it was possible to have it show up in the `accounts` in the IDL, so you could see it was optional there
so it should be send in the context like 
```
{
  accounts:{ mandatory ones }
  remainingAccounts: [ optional ones like this obj = {pubkey: account, isSigner: false, isWritable: false},
                         ]
}
```
you can send it in `remainingAccounts` fron js and handle it in `ctx.remaining_accounts` and see if there is any account passed there or not.
I tried `account: Option<UncheckedAccount<'info>>` but I even got an ICE üòÜ
is it possible to mark an account optional in the `#[derive(Accounts)]` ?
More specifically -
1. Can we delegate an ATA to a program? 
2. If so how the program transfer the spl tokens to another ATA using anchor_lang?
could u share a link for the outdated anchor docs?
you can return values in a CPI now
youre reading outdated docs
I see it stated in solana and anchor docs that CPI cannot return values...just wondering how chainlink is able to this with their pricefeeds?

The demo program requesting /receiving the price feed data is here:
https://github.com/smartcontractkit/solana-starter-kit/blob/875b23102605e4e9f8968dca520d41026138dfa9/programs/chainlink_solana_demo/src/lib.rs#L40

With the called function in the chainlink program returning data being here:
https://github.com/smartcontractkit/chainlink-solana/blob/ba505cd5055f1d96b8efc1000234a2f851aa2819/contracts/crates/chainlink-solana/src/lib.rs#L42

I see some examples shared memory for returning values in CPI, maybe this is an example of that?

If someone can explain what is going on here that would be great...or if there is a guide somewhere for this.  Thanks!
how to transfer tokens to another ata using  anchor_lang. Any resources ?
Ah, maybe you want `connection.getParsedTokenAccountsByOwner`
This is janky, but you can just pass in a fake wallet (like, whatever you want)
how can i deserialize an account given just a connection from the js side?
I want to fetch data, even before a user connects their wallet. I have the idl, and connection can be made easy.
we can create the account client object with just the idl, and fetch the raw data with connection, but there doesnt seem to be a way to put 2 and 2 together without a wallet
<@!134416332509675520>  can you give me a hint how can i make sense of the result:
```
 value: [
    value: [
    { account: [Object], pubkey: [PublicKey] },
    { account: [Object], pubkey: [PublicKey] },
    { account: [Object], pubkey: [PublicKey] },
    { account: [Object], pubkey: [PublicKey] },
    { account: [Object], pubkey: [PublicKey] },
    { account: [Object], pubkey: [PublicKey] },
    { account: [Object], pubkey: [PublicKey] },```
The account is `AccountInfo` type, but how can i find out which of these is the `usdc` for example?
thanx
it looks that it works
where `import * as spl from "@solana/spl-token"`
You can grab all of them by passing in the other kind of filter (seems dumb, but I think this is how you do it):
```.ts
program.provider.connection.getTokenAccountsByOwner(program.programId, {
      programId: spl.TOKEN_PROGRAM_ID
    })
```
is that the correct way to get all wallet token balances? üòÑ
That could probably work
`getTokenAcountsByOwner` requires a `tokenFilter` lets say i want to see my `usdc` balance, i should give the public key of my wallet and the `usdc` token mint?
You can do `program.provider.connection.getTokenAccountsByOwner`
Hey guys. Can someone point me where should i search for API to get all tokens in given wallet address?
You don't have to do that in general, they're just normalizing what they get from pyth with some of their other internal expectations


//////////////////////////////////////////////////////////////////////////////////////////

which version,are you using? anchor's latest one is preeety good at telling the errors
thx it worked, if it could help someone in the future : i installed avm with ```cargo install --git https://github.com/project-serum/anchor avm --locked --force``` then updated it with ur command
Is it possible to get more detailed transaction failure messages? I just get:

```
  1) drawtest
       Can manually create an account to associate:
     Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Program failed to complete
```

I am initializing the data in my Vec

```
    pub fn create_map(ctx: Context<CreateMap>) -> Result<()> {
        ctx.accounts.createMap.data = Vec::with_capacity(524288);
        Ok(())
    }

pub struct MapAccount {
    data: Vec<u8>
}
```

Which was already created at this size +1000 (525288)
okay
I think you need to install avm
im kinda new to linux ngl

yeah, use `avm use latest`
okay

try to upgard to the latest one
aah, asking about anchor ser
ubuntu 18.04 LTS
which version you are using?

it is working fine for me
do u know why i got this error?

```anchor init myepicproject --javascript```
This is more of a Rust question, but I'll ask anyway as it would be important to know in SmartContracts.

I want to access pointer to specific index of an array like so:
```
        let index: u32 = row * mapStride + xOffset;
        let pixel: &u8 = (&ctx.accounts.map.data) + index;
        *pixel = (color << 4) | *pixel;

pub struct MapAccount {
    data: Vec<u8>
}
```

By getting a reference to the byte at location index, I can both retrive and update it's value. Normally I would expect this to function, referencing the appropriate memory cell, however I get a compiler error because index is u32?

```
error[E0369]: cannot add `u32` to `&Vec<u8>`
  --> programs/drawtest/src/lib.rs:35:51
   |
35 |         let pixel: &u8 = (&ctx.accounts.map.data) + index;
   |                          ------------------------ ^ ----- u32
   |                          |
   |                          &Vec<u8>
```

It either doesnt understand what I want, or I have misunderstood what Vec is.
Then the rest of my calls can properly validate the input
Thank you - seems like best practice in that case would be have that on a separate Initialize call to set up the Data on a User created Account.
In the derive(Accounts) struct it tells anchor to not freak out about missing discriminator bytes
Yep, that's what `#[account(zero)]` is for
Super - refactored to:

```
  it("Can manually create an account to associate", async () => {

    var spaceAllocate = 1000;
    var rentRequiredForSpace = await provider.connection.getMinimumBalanceForRentExemption(spaceAllocate);
    var sig = await provider.send(
      new Transaction().add(
          anchor.web3.SystemProgram.createAccount({
            fromPubkey: provider.wallet.publicKey,
            lamports: rentRequiredForSpace,
            space: spaceAllocate,
            newAccountPubkey: MapAccount.publicKey,
            programId: program.programId
      })),
      [MapAccount]
    );
    console.log("Create Account Signature: ", sig);
```

Is there a way I can get Anchor to ignore deserialization errors? This newly created account is uninitialized (empty data) and so I get `AccountDiscriminatorMismatch`, because I assume there is that check on deserialization.
Thank you so much, complaining about rent so I'll go lookup how to calculate that. Thank you for your quick help.
Ah I see, I had thought that was not requried seeing as we are allocating it to that PubKey.
In solana when you create an account you need to sign with its address (think of it as the address saying "I'm cool with an account living here")
Ah, you *do* need to sign with `MapAccount` here (the keypair)
I tried not sending anything but it gives me `Error: Signature verification failed`
`provider.send` will actually automatically sign with the provider.wallet, no need to pass it in there like that
Hello - Just getting started with Anchor, due to PDA max size of 10KB, I want to create an Account manually and assign it to a Program.
I'm starting from a basic anchor init, and want to do the following:

```
  it("Can manually create an account to associate", async () => {
    var createAccountTx = anchor.web3.SystemProgram.createAccount({
      fromPubkey: provider.wallet.publicKey,
      lamports: 10000,
      space: 1000,
      newAccountPubkey: MapAccount.publicKey,
      programId: program.programId
    });
    var cTx = new Transaction().add(createAccountTx);
    var sig = await provider.send(cTx, [provider.wallet]);
    console.log("Create Account Signature: ", sig);
```

I cannot pass provider.wallet as a SIgner to provider.send as it is a Waller. Where can I find the private key for the wallet that can fund these tests?
Could try https://www.cronos.so/
Nope, not out of the box (you would need a whole separate service/whatever running off-chain to do that)
does anchor support cronjob like periodic function invocation ?
bump targets should not be provided with init. Please use bump without a target.
Been a while since I've touched an Anchor program. How come bump is now depricated and what does that error mean
the counter already has a mutable reference?
Oh nevermind I forgot to put "mut"
why my counter not increased üò¶

also token account can't be created using program other than the SPL program correct?
no you cant, all accounts need to be passed in from the client
can we load account from a public key without getting it from any client ?
Hey, I am really really new and I am really looking for resources to lean Development on Solana. I know Json rpc api, @solana/web3.js. I have thoretical knowledge about anchor but, I am still learning. I have read at many places on stack overflow that people recommending anchor wallet library. Could someone please explain the use of it and from where can i learn more about it?
all right imma go through the solana cookbook
E.g. your program will be the program owner of any of its
```.rs
#[account]
pub struct Something  {
  ...
}
```
oh
Nope
yeah user-level ownership i mean. else system program is the owner of all accounts
The idea of a payer "owning" some account is the latter, a user-level ownership idea‚Äîtotally distinct from program ownership
Program ownership vs. "user-level ownership", for lack of a better term
Right‚Äîbut I'm saying there are two totally distinct notions of ownership floating around
i know payer is not necessarily the owner btw
Higher-level ideas of ownership (like *who* owns a token account) are a separate thing
I think you might be confused about what "ownership" means in solana. Every account has a "program owner", which is the program that's allowed to mutate the account's data or spend the account's lamports
```rs
#[derive(Accounts)]
pub struct Initialize<'info>{

    #[account(init_if_needed,payer = genesis_admin,space= 8 + 32)]
    pub name_db_account : Account<'info,data_accounts::stake::NameDbAccount>,

    #[account(mut)]
    pub genesis_admin : Signer<'info>,
    pub system_program : Program<'info,System>
}
```
in this case. Who's the owner of the name_db_account ? the program itself or the the genesis admin or the private key of name db account which also signed the tx?
oh ok
Whether it requires a signature or not is purely up to the program's logic
The program that owns an account can write to it whenever it wants
for example - there is a data account to store users name. I want others to enter their names in it. Is it possible?
No, no need to sign in general
like I created a data account during initialization. Now if I want to write data to it I'll have to sign with the private key of the data account right? But if i want to put user data on that account by end users they don't have the private keys to sign
Can you say more? If I'm understanding your question right, *all* data accounts are like that (for some program)
can we have a data account that the program owns and can read/write?
I'm having this error `TypeError: Cannot read properties of undefined (reading 'fromBuffer')` using `createTokenAccount` and `getMintInfo` from `"@project-serum/common": "^0.0.1-beta.3",` anybody know why?
Is there anyway to mark instructions as deprecated using Anchor?
any idea why the cloned accounts aren't reflecting properly on solana-test-validator? Using this command
```
solana-test-validator --clone 6qnhRSRB1BjfqtVQHzRkwz6mUsf9JDjB2mTd78iL3WPG --clone FB9GjPA2XqnGunRXRQv7fasSvqqcxoh85D3gZsfS7wGC --url devnet
``` to clone both mint + token account
has mainnet solana been flakely lately? had a program that worked no problem before but trying it out now and seeing a lot of inconsistency + long load times - any one else experiencing this?
should be in <#899315988087054397> my b
may be related to this? 
https://github.com/project-serum/anchor/pull/1608
Thanks!
You'll get the same value, but calling `.to_account_info()` is a bit less efficient
Hello, is there any difference between
```rust
ctx.accounts.signer.key
```
and
```rust
ctx.accounts.signer.to_account_info().key
```
?

the `signer` account is of type `Signer`
I don't see this change in the logs, but was the printing of logs for failed tx removed during `anchor test` in 0.23.0? I've noticed they're gone. they were v helpful
I believe so. I've never needed to xfer authority but it seems that you can do that
I guess in this case, I guess in the front end, I can make the user perform the transaction of moving the NFT to a non-ATA account, and then transfer the authority of the non-ATA account to the program correct?
I see thanks
https://github.com/solana-labs/solana-program-library/issues/2640
I suppose you could ask the user to create a non ATA token account, and transfer the NFT there. Then, since it is not an ATA, authority can be changed
So `SetAuthority` won't work?
I don't think that's possible because typically the token account holding the NFT will be an associated token account which, due to it's design of being an address derived from a particular user wallet address, does not allow for ownership transfer.
Is either one of the approach definitively better?
Hey guys, I'm trying to implement a NFT gambling app, and I'm wondering how to transfer the ownership of a token account from the user to the app.

I want to take this approach because it avoids the program needing to create a corresponding NFT token account for the user to transfer the ownership of the NFT to.
yes its more informative
and so it's a binary tree map that uses strings as keys, and stores u8s
you can also go to the docs.rs page and see this
hmm
sure but you could just see in the signature that it's expecting a `key` which idiomatically is some sort of string.
i mean it could be the immutable reference to the actual PDA but it's string. without proper documentation I'll always have to rely on people that have dealt with it before
so if you are going to get a bump, it's going to be the bump of a PDA
because only PDA's have bumps
is there any doc or something. How am i supposed to know the parameter is the account name in string format instead any other string
ya so you'd still pass that into `get()` even if you used a different seed just bc that's the account name
okay now it makes sense
so that's just the name of the account in the context
user_stats is a PDA and it is stored in `ctx.bumps`
oh that's wrong my bad
the seed was that string + the public key of signer. How can the bump be found from the string alone?
btw its from the anchor book pda example - 
```rs
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod game {
    use super::*;
    // handler function
    pub fn create_user_stats(ctx: Context<CreateUserStats>, name: String) -> Result<()> {
        let user_stats = &mut ctx.accounts.user_stats;
        user_stats.level = 0;
        if name.as_bytes().len() > 200 {
            // proper error handling omitted for brevity
            panic!();
        }
        user_stats.name = name;
        user_stats.bump = *ctx.bumps.get("user_stats").unwrap();
        Ok(())
    }
}

#[account]
pub struct UserStats {
    level: u16,
    name: String,
    bump: u8,
}

// validation struct
#[derive(Accounts)]
pub struct CreateUserStats<'info> {
    #[account(mut)]
    pub user: Signer<'info>,
    // space: 8 discriminator + 2 level + 4 name length + 200 name + 1 bump
    #[account(
        init,
        payer = user,
        space = 8 + 2 + 4 + 200 + 1, seeds = [b"user-stats", user.key().as_ref()], bump
    )]
    pub user_stats: Account<'info, UserStats>,
    pub system_program: Program<'info, System>,
}
```
I'm only using primitives. u64, u8, and usizes
I'm getting an error which is not super helpful. Rust code is compiling but I'm getting

```
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: ParseIntError { kind: InvalidDigit }', lang/syn/src/idl/mod.rs:202:76
```
when testing because the IDL can't be built
it's just the string that was used as the seed
full code - 
```rs
#[program]
pub mod game {
    use super::*;
    // handler function
    pub fn create_user_stats(ctx: Context<CreateUserStats>, name: String) -> Result<()> {
        let user_stats = &mut ctx.accounts.user_stats;
        user_stats.level = 0;
        if name.as_bytes().len() > 200 {
            // proper error handling omitted for brevity
            panic!();
        }
        user_stats.name = name;
        user_stats.bump = *ctx.bumps.get("user_stats").unwrap();
        Ok(())
    }
}
```
i see thanks. anyways what's the argument is being passed to the bumps.get function. Is it just a string or what?
```rs
user_stats.name = name;
        user_stats.bump = *ctx.bumps.get("user_stats").unwrap();
        Ok(())
```

nvm i'll just share ss <@!744612713811935404>
are links allowed here?
it means you are casting the string to the bytes array that represents it (utf-8)
Hello,
I'm getting an account info from `remainingAccounts` and I managed to convert this into `AccountInfo<MyStruct>` but I probably copied it because I can't see data I chaned on-chain.
What is the best way of getting account from `remainingAccounts` (mutable) and edit/save it?
how do i solve the runtime error `Invalid public key input` when im trying to fetch an account from the chain and rendering it on the frontend and the pubkey im using to fetch is from the url params. What im trying to do is if an account is not found, i want to render some html if there is no account fetched `await program!.account.creator.fetch(pubKey)`
im new to rust as well
```rs
#[account(
        init,
        payer = user,
        space = 8 + 2 + 4 + 200 + 1, seeds = [b"user-stats", user.key().as_ref()], bump
    )]
```
what does b"user-stats" mean here? I know its a seed but it's not exactly a string right because b doesn't have quotes
ping me if u get to it
If you don't get around to it I may have time to look thru code this weekend and submit a PR
okay cool this works now (the string thing, not the workspace/program issue)
this program is called ProgramID because I named one sha256test and something was breaking internally bc and `const program = anchor.workspace.Sha256test as Program<Sha256test>;` (which came stock during `anchor init`) was failing. couldn't access the idl or the programId
haha
okay so while we're on this topic
Yeah, not sure why yet
ah so I just can't name it that thing?
Ughhhhhhhhhhhhhhhhhhhhhh, anchor gets confused about something with the name ü§¶‚Äç‚ôÇÔ∏è
however, when I uncomment sha256hash and pass in 
```typescript
let sha256hash: string =
      "8AEF9B5DDEDE4F620D83D8D6E48B7C9809B49811E4A46F9D48021376ADBB59D0";
```
into the method, it fails to deserialize
yep
```rust
pub fn initialize_file(
        ctx: Context<Initialize>,
        data: u8,
        //sha256hash: String,
    ) -> Result<()> {

        Ok(())
    }
```
with 
```typescript
  const tx = await program.methods
      .initializeFile(data) //, sha256hash)
      .accounts({})
      .signers([])
      .rpc();
```
produces
```
 ‚úî Is initialized! (152ms)


  1 passing (154ms)

‚ú®  Done in 5.67s.
```
And just run `anchor test`, no other arguments
Did you try the version where you turn off all validators?
i literally have other things where I do this, haha
(Tried just now)
I usually can too
I can run the same kind of code just fine
Yeah, I'm 99% sure you're messing something up with a deployment etc.
a short string doesn't work either tho, haha
I'm just trying to pass in a len 64 string
There is a max size though, since the whole tx has to fit in 1232 bytes
What happens if you just use a short string then?
is there like a max size string we can pass in or something? That may be what's going on here bc if I comment out the string being passed in the program can deserialize the ix
dang, that's good to know haha
all successful tx's have their logs printed there, while all failed ones get printed to console
in .anchor/program-logs/
I've always kept the validator spinning and looked up my logs in the explorer üòÇ
in the target folder or what?
üëÄ
well the logs are saved so you can just run `anchor test` and look at logs
If you're trying to look at logs, I use `anchor test --detach` which keeps the validator spinning after tests finish without the required step of starting your local validator and purging your test validator directory between tests
correct. If yo'ure running a local validator in another shell, you can run anchor test with the --skip-local-validator flag
that's bc it deploys it out the box
with `anchor test --skip-local-validator`
```
Error: RPC request error: cluster version query failed: error sending request for url (http://localhost:8899/): error trying to connect: tcp connect error: Connection refused (os error 61)
```
Tbh not sure why lol, but I never ever run a local validator and anchor test works fine
You also don't need to do that though
anchor test starts up a validator when no flag is provided
that's the one
--skip-local-validator
Without a validator running
anchor test is what i've been doing, no?
Just anchor test
oops that's not the flag I meant to add. which one skips the validator startup?
Can you just run `anchor test`?
with `anchor test --skip-deploy`
```
Error: failed to send transaction: Transaction simulation failed: Attempt to load a program that does not exist
```
is jump-to-source an IntelliJ feature? I've been stepping through my code manually to debug üòÇ
Just to double check, can you turn off the validator?
the tx call in the ts test is
```typescript
    let data = 8;
    let sha256hash =
      "8AEF9B5DDEDE4F620D83D8D6E48B7C9809B49811E4A46F9D48021376ADBB59D0";

    // get file pda
    let [file, fileBump] = await anchor.web3.PublicKey.findProgramAddress(
      [Buffer.from("file")],
      program.programId
    );

    const tx = await program.methods
      .initialize(data, sha256hash)
      .accounts({
        file: file,
        payer: admin.publicKey,
        systemProgram: anchor.web3.SystemProgram.programId,
      })
      .signers([admin])
      .rpc();
```

Actually maybe that shouldn't matter
But are you running a live validator in the background?
just `anchor test`
How did you deploy it?
I also impl'd a single method for `File` (which turns a length 64 string containing only hexdecimals chars into a 32 byte array) but I don't think that's the problem as I've commented it out
```rust
#[program]
pub mod program_id {
    use super::*;

    pub fn initialize(
        ctx: Context<Initialize>,
        data: u8,
        sha256hash: String,
    ) -> Result<()> {

        msg!("Initializing File");
        {
            let file = &mut ctx.accounts.file;

            // Store data and hash
            file.data = data;
            file.store_sha256(&sha256hash);
        }

        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {

    #[account(
        init,
        payer = payer,
        space = 8 + 1 + 32,
        seeds = ["file".as_bytes()],
        bump,
    )]
    pub file: Box<Account<'info, File>>,

    #[account(mut)]
    pub payer: Signer<'info>,

    pub system_program: Program<'info, System>,
}

#[account]
pub struct File {

    pub data: u8,

    pub sha256: [u8; 32],
}
```
I can paste some code here
this was meant to be a very simple test on a fresh anchor program
Basically it's hard to get that error unless you've goofed lol
Are you maybe trying to talk to a stale deploy?
nope, not using it anywhere
Are you using `#[instruction(...)]` incorrectly maybe?
quite a simple ix as well
I don't seem to have much more info
Is there a place I should start when I run into
```
Error: AnchorError occurred. Error Code: InstructionDidNotDeserialize. Error Number: 102. Error Message: The program could not deserialize the given instruction.
```
Depending on what you're doing you may need to "reload" the account after doing any CPI that might mutate it
Yep, that's correct üëç
each data point for the feed is written to a specific account, for which the address can be determined from the seed (and will be documented addresses).  i assumed I would need to call the program that is creating/writing to the data accounts in order to fetch the data.  for building the context for the call in the program that will request the data, i have to provide the account where the data is stored.  just by including it in the context, i am able to access the values in that account from the calling program, without making any calls to the data aggregator which wrote the data.  does this sound reasonable?
hmmm, it seems like i can succeed without shared memory or CPI return values


//////////////////////////////////////////////////////////////////////////////////////////

where im trying to use this `pub update_position: UpdatePosition<'info>,`  but `UpdatePosition` is in a different file
```
error[E0432]: unresolved import `__client_accounts_update_position`
   --> programs/drift_vault/src/instructions/withdraw.rs:175:10
    |
175 | #[derive(Accounts)]
    |          ^^^^^^^^ help: a similar path exists: `crate::__client_accounts_update_position`
    |
    = note: `use` statements changed in Rust 2018; read more at <https://doc.rust-lang.org/edition-guide/rust-2018/module-system/path-clarity.html>
    = note: this error originates in the derive macro `Accounts` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0433]: failed to resolve: use of undeclared crate or module `__client_accounts_update_position`
   --> programs/drift_vault/src/instructions/withdraw.rs:175:10
    |
175 | #[derive(Accounts)]
    |          ^^^^^^^^ use of undeclared crate or module `__client_accounts_update_position`
    |
    = note: this error originates in the derive macro `Accounts` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0433]: failed to resolve: use of undeclared crate or module `__cpi_client_accounts_update_position`
   --> programs/drift_vault/src/instructions/withdraw.rs:175:10
    |
175 | #[derive(Accounts)]
    |          ^^^^^^^^ use of undeclared crate or module `__cpi_client_accounts_update_position`
    |
    = note: this error originates in the derive macro `Accounts` (in Nightly builds, run with -Z macro-backtrace for more info)
```
show the full error log
something like `struct Tmp {}` in fileA and `struct Tmp2 { tmp1: Tmp }` in fileB? im getting strange errors
is it possible to import a \#[derive(Accounts)]  struct across files and use it in other \#[derive(Accounts)]  structs?
you should make PDA an authority, It'll make your life more easier and try to use explorer more instead solscan
Any idea about this friends?
Ok, so basically if we let Anchor do it, it does in program. If we want to save CU and calc in client, we will need to pass by ourselves right?
yes
Generally yes, but if you do ask anchor to do it for you (with the `bump,` syntax) then anchor will remember it at `ctx.bumps.get("the_account_name")`
to save CU?
Shouldn't we avoid calculating bump in program?
in program
calculated in client or in program?
no probs manüëç
Ah yes I was wrapping it in { accounts: { - my fault - thank you <@744612713811935404>. I still unfortunately get just the same error message "Program failed to complete" but <@134416332509675520> gave me the solution for that in the Solana discord. Appreciate your time both of you.
<@329649777824497669> that actually looks about right to me based on your idl ^
Thank you for your help but the publicKey doesnt really go there, I'll do some more digging in the docs and see what I can find.
Just use `Account<'info, Whatever>`
okay
Nah, it's deprecated
<@134416332509675520> ??
this should work. Else idk man 
```rs
    var res = await program.methods.createMap().accounts(
         {
           createMap: MapAccount.publicKey
         }
      ).rpc();
```
Yeah the object expected by the autogenerated createMap function on methods is a different type to that expected by program.rpc.MyMethod
Then you can access the bump that anchor calculated for you via `ctx.bumps.get("some_account_name").unwrap()`
try this <@329649777824497669>
If you have
```.rs
#[account(..., seeds = [...], bump, ...)]
pub some_account_name: ...
```
IDL:```
    {
      "name": "createMap",
      "accounts": [
        {
          "name": "createMap",
          "isMut": true,
          "isSigner": false
        }
      ],
      "args": []
    },
```
```rs
    var res = await program.methods.createMap().accounts(
         {
           createMap: MapAccount.publicKey
         }
      ).rpc();
```
can you post your IDL?
Yeah I only need to supply an Account to that function, but it complains about types, expecting args instead
```
    var res = await program.methods.createMap(
      {
         accounts: {
           createMap: MapAccount.publicKey
         },
      }).rpc();
```
`Argument of type '[{ accounts: { createMap: PublicKey; }; }]' is not assignable to parameter of type 'ArgsTuple<[], IdlTypes<Drawtest>>'.`
post the code here
https://project-serum.github.io/anchor/ts/classes/Program.html
you have to provide the function arguments like you did previously
`var methodResult = await program.methods.createMap().rpc();`
`Error: Invalid arguments: createMap not provided.`
Where can I find docs on program.methods? Can't see what to supply to this...
Is there a clear documentation how we handle ctx.bumps in new way? not sure I understand
is cpiAccount is still valid account type? <@134416332509675520>
also 
```rs
program.methods.createMap({}).signers([...,signer]).rpc()
```
program.methods.method() instead program.rpc.method()
Is it possible to get more information out of an Anchor test? Just getting Program failed to complete. Is there more logs available elsewhere?
yeah, as always, a sneaky typo, lol
pretty sure it is initialized and has 1 holder (minted some for test) , will doublecheck if am sending wrong parameters
Mm, doesn't sound like it's actually initialized, I would triple check that
```AnchorError caused by account: base_mint. Error Code: AccountNotInitialized. Error Number: 3012. Error Message: The program expected this account to be already initialized```

any idea why I'm getting this error for a mint? it exists and am sending pubkey in accountcontext
do you know how to fix this?
```anchor test
BPF SDK: /home/anon/.local/share/solana/install/releases/1.10.6/solana-release/bin/sdk/bpf
cargo-build-bpf child: rustup toolchain list -v
cargo-build-bpf child: cargo +bpf build --target bpfel-unknown-unknown --release
warning: unused variable: `ctx`
 --> programs/myepicproject/src/lib.rs:9:23
  |
9 |     pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
  |                       ^^^ help: if this is intentional, prefix it with an underscore: `_ctx`
  |
  = note: `#[warn(unused_variables)]` on by default

warning: `myepicproject` (lib) generated 1 warning
    Finished release [optimized] target(s) in 0.33s
cargo-build-bpf child: /home/anon/.local/share/solana/install/releases/1.10.6/solana-release/bin/sdk/bpf/dependencies/bpf-tools/llvm/bin/llvm-readelf --dyn-symbols /home/anon/myepicproject/target/deploy/myepicproject.so
Failed to execute /home/anon/.local/share/solana/install/releases/1.10.6/solana-release/bin/sdk/bpf/dependencies/bpf-tools/llvm/bin/llvm-readelf: No such file or directory (os error 2)```
when i run ```anchor test``` this is the error i get ```Failed to execute /home/anon/.local/share/solana/install/releases/1.10.6/solana-release/bin/sdk/bpf/dependencies/bpf-tools/llvm/bin/llvm-readelf: No such file or directory (os error 2)```
When simply use json with all fieldnames I have used, I'm getting ` Error Message: The program could not deserialize the given instruction.`  this is beacuse I think I'm not sure about type mapping, so need a typed class to build that object I want to serialize and send to program.
Another question;
When I look from solscan to some program accounts, they looks like both a wallet and a program. They have a list of SPL token account for example.
When I create PDA (as ATA) to store some tokens inside, I never see that in my program page. I have to know the address and usually the owner is itself (because I set authority=itself) .
Never tried but, should authority=program_id (not sure how to get it tho) solve it or?
Hello everyone, 
What is the best way of building custom struct in client? Just use json or does Anchor have some typed way of it?
I mean, I have a custom struct, it is serializible and now I need to pass it using Anchor client. How do we do that?

Thanks/
tried it all, still getting the same results. im going to go through the entire setup again just to make sure i didn't miss anything
thank you!
https://book.anchor-lang.com/chapter_2/installation.html
do reinstall first, then install the latest version of anchor
umm to reinstall anchor, i just run the same command that i used before to install it? or are there any other things i need to do?
thanks
yup i think i will try that
I'm not sure what is going wrong then ser. one dirty thing you can do it re-install anchor & solana
hmm ok, it make complete sense
this is what happens, local port already in use
yeah it totally fine ser
btw this is day 2 of me using ubuntu üòÖ
sure
gimme a sec lemme do that and pull up the screenshot
what is it?
ah okay. but if i do that, there will be a different error.
and then type `anchor test`
ser, open new terminal, lol
if i don't ctrl + c after `solana-test-validator` i am not able to type anything
Now don't this and see what will happen.
run  `solana-test-validator` and then do anchor test
yup i just did this
you just did this right?
just wanna make sure i'm doing this right. after running `solana-test-validator` i should ctrl +c to stop the test validator, only then i should do `anchor test` right?
nope still the same error message
now try do `anchor test`
yup `solana-test-validator` ran successfully.
is `solana-test-validator` running successfully?
just read the error log carefully. you just need to install anchor v0.23.0
the log just ends at `Initializing...` 
Yup local test validator is not running elsewhere.
what can i do?
Only x86_64 / Linux distributed in NPM package right now.
Trying globally installed anchor.
Globally installed anchor version is not correct. Expected "anchor-cli 0.23.0", found "anchor-cli 0.22.0".

anchor test by default spins one up brand new just for that test run, if you have one running locally it'll conflict unless you configure it to use that long running one
Also - sanity check that you _don't_ have a local test validator already started
What's the log say?
i'm trying to run `anchor test` but i can't seem to get it to work. 

i keep getting ```Unable to get latest blockhash. Test validator does not look started. Check .anchor/test-ledger/test-ledger-log.txt for errors. Consider increasing [test.startup_wait] in Anchor.toml.```
I'm using ubuntu (wsl)

It's upto you
Bundling up a transaction entirely backend server-side <_<
Ngl I'm not even using a smart contract for this particular use case :p
you can store a bump in the account to save CU &then use it for finding the account later on on-chain.
Thank you!

...do I need to hold onto the bump it returns for any reason?
or you can try to build form source,
https://book.anchor-lang.com/chapter_2/installation.html#build-from-source-for-other-operating-systems-without-avm
you need to specify `--tag` args here
findProgramAddress, uses createProgramAddress under-the-hood.
findProgramAddress is used to find `valid` PDA. This function iterates a nonce until it finds a valid PDA. While createProgramAddress, is just directly checking if the PDA is on the curve or not. If PDA is not on the curve, it'll throw an error like this `Invalid seeds, address must fall off the curve`
Btw fei: stick with anchor. I bounced off it from a poor first impression of the doc and tried to go it alone, it ain't worth it. Anchor's actually the best maintained tool in the solana ecosystem üòî (that I've found so far)
Mmm past my knowledge. Hopefully 0xDeep or cqfd can help ‚ù§Ô∏è
i used macos
Also maybe `sudo apt-get update && sudo apt-get upgrade && sudo apt-get install -y pkg-config build-essential libudev-dev`. I remember getting errors at this step myself but they might've been different (was a few months ago)
Sanity check, `rustup update`?

Ah, 3 months ago, ancient history by now going by these parts ^^
I followed this article https://github.com/buildspace/buildspace-projects/blob/main/Solana_And_Web3/en/Section_2/Resources/m1_setup.md to install anchor
<@808672825585172531> it appears outdated to me (a newb) based on https://book.anchor-lang.com/chapter_2/installation.html. What are you attempting to do?
Where'd you get that command from out of curiosity?

Atm I'm using find and throwing away the # that comes with it, I assume that'll bite me at some point :p
When getting the PDA for my token metadata account, what's the diff between createProgramAddress and findProgramAddress?
It just a package, from metaplex to De/Serialized Borsh.
https://github.com/metaplex-foundation/beet
What's a 'beet'? (https://metaplex-foundation.github.io/metaplex-program-library/docs/token-metadata/index.html#DataV2)
```anchor test
BPF SDK: /home/anon/.local/share/solana/install/releases/1.10.6/solana-release/bin/sdk/bpf
cargo-build-bpf child: rustup toolchain list -v
cargo-build-bpf child: cargo +bpf build --target bpfel-unknown-unknown --release
warning: unused variable: `ctx`
 --> programs/myepicproject/src/lib.rs:9:23
  |
9 |     pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
  |                       ^^^ help: if this is intentional, prefix it with an underscore: `_ctx`
  |
  = note: `#[warn(unused_variables)]` on by default

warning: `myepicproject` (lib) generated 1 warning
    Finished release [optimized] target(s) in 0.33s
cargo-build-bpf child: /home/anon/.local/share/solana/install/releases/1.10.6/solana-release/bin/sdk/bpf/dependencies/bpf-tools/llvm/bin/llvm-readelf --dyn-symbols /home/anon/myepicproject/target/deploy/myepicproject.so
Failed to execute /home/anon/.local/share/solana/install/releases/1.10.6/solana-release/bin/sdk/bpf/dependencies/bpf-tools/llvm/bin/llvm-readelf: No such file or directory (os error 2)``` do you know why i get this errror?
Sorry, `PublicKey`
im getting `Property 'Pubkey' does not exist on type 'typeof import("@solana/web3.js")` from that
`new anchor.web3.Pubkey(theBase58String)`
js
In js or rust?
how do i get a publickey object from a string given that the string is in base58?
Oh, weird, where did the examples go ü§î Could have sworn there were a few
Do I add remaining_accounts as a field in the derive accounts struct?  I couldnt see from the examples in the repo. maybe you are are refering to something other than the main anchor repo?
Via `remaining_accounts`
i see.  how do i add more accounts that wont be automatically deserialized?
Ah, no, totally separate from anything about how many accounts‚Äîyou can ignore it unless/until rust complains about some lifetime stuff üòå
is this going to specify that there are 3 additional accounts?  Im having trouble getting the context to have a remaining_accounts.len() > 0
there's a way to run tests from a folder which name is not `tests`  using `anchor test` + some flag or something?
how do i buffer a pubkey that i get from the url params in react?
thanks!
gotcha. okay.  i will search in the repo
You can find a bunch of examples by searching the anchor repo
That's just how anchor gives you access to any other/extra accounts that came in (beyond the fixed ones in the derive(Accounts) block)
And just a heads up, you may find you also need to help rust's lifetime inference a bit
```.rs
pub fn do_something<'info>(ctx: Context<'_, '_, '_, 'info, Initialize<'info>>)
```
what would remaining_accounts refer to?
Not yet unfortunately‚Äîif you want a variable number you'll have to use the `remaining_accounts` feature, and then if you want to deserialize them etc. you'll have to do that manually
```.rs
let my_account: Account<Thing> = Account::try_from(&the_account_info)?;
```
would something liek this be used: 

```
pub fn do_something(ctx: Context<Initialize>) -> ProgramResult {
    let vec: Vec<AccountInfo> = ctx.remaining_accounts.into_vec();

    // do something with the accounts

    Ok(())
}
```
anyone know if its possible to define / use a context for instructions with a variable number of accounts?  for instance, provide an array of accounts for a given account type?
Hi! I would like to have two different test folders (i.e tests and tests2). There's a way to run `anchor test` but run the tests in tests2 folder? Something like `anchor test tests2`...


//////////////////////////////////////////////////////////////////////////////////////////

<<<<<<< HEAD
I think what I can do is 

1. Read counter state in the client
2. Pre generate PDAs for next three accounts with seeds being: counter, counter + 1 ,counter + 2 
3. Pass the PDAs and args to the program
4. Program checks if PDA1 has any money or if any fields aren't defaults
5. If it exists (due to delay between  client reading counter state and program invocation) go to PDA2 and so on
6. Eventually use PDA with unique seed from the counter account that has not been used yet

Ta-Da hacky way to make a list that is accessible by index rather than by public key.
I'm just saying that if you want to use an account at some PDA, the client itself needs to specify that PDA
I mean seeds constraint in #account
What do you mean by pda correction?
can he read the state offchain and send to the instruction and checked with account constraint for pda correction?
But this is just part of how solana's performance model works: you have to pre-specify all accounts you need, which lets the runtime figure out how to run things in parallel etc.
Mm, I'm actually not sure‚Äîit must be somewhere in the solana docs but it's been a while since I've looked at them
Thanks. I wasn't sure about it. What would be good resource to read up on that, is it just from code?
There just isn't any possible way to dynamically go from Pubkey to AccountInfo
*All* accounts of interest need to be pre-specified by the client
Nope, not possible, sorry üò¨
Could you work around with CPI, where generated PDA is passed to the receipeint which will actually create it? 

Surely accounts can be created autonomously without involving client.
I think you can solve it with CPI but feels very hacky:

1. Program A checks the state of the counter account
2. Program A constructs an argument list including derived account
3. CPI from Program A to Program B
4. Pprogram B creates PDA that it was told to do and sealevel is happy


What I'm trying to do is create a list like structure but using PDAs where seed is counter.
No, any account you want to actually interact with needs to be passed in from the client
<@875698957513289789> I think instruction that update the counter cannot run concurrently because it have to write some data to the account so this should work without worry. But that's my opinion might be wrong üòì
Is it possible with anchor to derive PDA on chain rather than passing it via ctx?

I want PDA that's based on a state of another account, generating it of chain and passing the account to the program might mean that the account is not valid due to concurrent access by others. State of the account changes based on every PDA invocaiton.

I'd like to do something like this

```let (pda, _bump_seed) = Pubkey::find_program_address(&[&[counter.count as u8]], ctx.program_id);

let mut submission: Account<Submission> = borsh::try_from_slice_unchecked::<Submission>(&pda.data.borrow())?;```


So the account PDA address could not be known in advance, only after reading the other account state.
Does PDA uses public key to sign transaction? 
if yess then anyone can sign transaction on behalf of PDA, because Public key is visible to everyone. <@!134416332509675520>
I thought it was the safest way... but obviously I could have used a local keypar and then transfer the upgrade authority ü§¶
I may spend the night confirming transactions üòÖ
So unless there's some way to tell the ledger thing to just go ahead and autosign them, it's gonna be a pain
Mm, I've never tried doing that, but solana deploys take hundreds of individual transactions, each of which requires a signature
Every time I sign, it prints another ‚†§ Setting up.. line in the cli and immediately asks again for signature in the ledger
Hey guys, I'm trying to anchor deploy to mainnet using a ledger nano. It keep asking for signature of "unrecognized format" again and again. And the cli shows "‚†§ Setting up.." 

Should I keep on signing? It looks like an inifinite loop... I've accepted like 30 times already. Or should I just wait?
Can do something like this: https://discord.com/channels/889577356681945098/889702325231427584/946565378685956126
The address give belongs to that of the metadata program
Anyone know how to deploy the metaplex metadata program locally? I keep getting the error ‚Äúinstruction expected executable account‚Äù. Assuming it‚Äôs because there is not a local metadata program deployed?
any advice on just clearing paths and restarting installatin
Oh ok I see. I found some code online that never showed the passing of the account. Thanks.
does anybody have any idea why this error is happening?
Any time you CPI to a program in solana, you need to pass in the program account from the client
You need to *also* pass in that account from the client
Hi Everyone. I am trying to write a function that mints an nft, and am using metaplex to create a metadata account for it. However, I keep getting this error: "Instruction references an unknown account metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s". I know this refers to the metaplex metadata program, but have no idea how to solve this.
please can anyone help me fix this?
``` error: Invalid value for '--program-id <PROGRAM_ID>': unrecognized signer source
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }. ``` guys im getting this error when im running ` anchor test `
Hey I'm installing avm with the following command `cargo install --git https://github.com/project-serum/anchor avm --locked --force` and i'm running into this error. Any ideas on how to resolve it?
```
error: could not find `avm` in https://github.com/project-serum/anchor with version `*`
```
Cargo will fetch the specific version for you and use it building the crate
very noob question but if I specify a package with a certain version in the `cargo.toml`, do I need to have that package preinstalled or cargo build takes care of using that exact version when running build?
When is the appropriate time to use `require_key_eq` instead of  just checked in account constraint?
yh it was, but didn't work on a previous version. copy-pasting the code worked tho. thanks üôÇ
So this is the thing you want? https://github.com/solana-labs/solana-program-library/blob/master/token/js/src/instructions/syncNative.ts#L28 If you're on the latest version it should just work
Anyone who has used anchor events can explain to me how does anchor events work on Solana and how are they different from the Ethereum events, what are some of the limitations of anchor events.
Could someone explain why some instructions have the three underscores in Context?
I found an explanation for Context in a Soteria article, but still don't understand why its left blank.
Trying to understand the swap program example from anchor repo  

``` 
 pub fn swap<'info>(
        ctx: Context<'_, '_, '_, 'info, Swap<'info>>,
        side: Side,
        amount: u64,
        min_expected_swap_amount: u64,
    ) -> Result<()> {
```

https://github.com/project-serum/anchor/blob/master/tests/swap/programs/swap/src/lib.rs
https://www.soteria.dev/post/how-to-audit-solana-smart-contracts-part-4-the-anchor-framework
the spl-library is pretty bad :/
ok I fixed it, I copy-pasted the source into my source now it works
it basically translates your native sol into wrapped sol. the name is bcs it syncronizes your wrapped-sol account information with the sol lamports information as I understand
What does createSyncNativeInstruction even mean?
also how do I do this on anchor 0.20? the function doesn't seem to be exported
I just sent some SOL to the associated token account, but I can't seem to find `createSyncNativeInstruction` in the node package anymore. How do I call this function?
hey guys, I'm trying to figure out. how to convert SOL to wrapped SOL? any ideas on how to do this?
Hello, 
Can we save and use a private key in a Solana program (smart-contract) ?
I mean saving in an init transaction for example and then using it without signing (or using provider for it) in other transactions.
Time for sleep
Ok nevermind....I was using an outdated crate
I initially tried to put my payer in the `accounts` array and that didn't work.
```  let accounts = [
        ctx.accounts.mango_group_ai.clone(),
        ctx.accounts.unverified_mango_account_pda.clone(),
        ctx.accounts.unverified_mango_owner_pda.clone(),
        ctx.accounts.system_program.to_account_info().clone(),
    ];
    let result = mango::instruction::create_mango_account(
        &ctx.accounts.mango_program_id.key().clone(),
        &ctx.accounts.mango_group_ai.key().clone(),
        &ctx.accounts.unverified_mango_account_pda.key().clone(),
        &ctx.accounts.unverified_mango_owner_pda.key().clone(),
        &ctx.accounts.system_program.key().clone(),
        1 as u64,
    );
    let instruction = match result {
        Ok(is) => {
            msg!("instruction was created successfully");
            is
        }
        Err(error) => panic!("failed to create mango account: {:?}", error),
    };
    invoke_signed(
        &instruction,
        &accounts,
        &[&[
            MANGO_OWNER_PDA_SEED,
            ctx.accounts.vault.name.as_ref(),
            &[_mango_owner_bump],
        ]],
    )?;
    Ok(())```
Hey all, getting a `Transfer: insufficient lamports 0, need 30791040` error from my CPI program. I am using localnet and have confirmed my payer has sufficient SOL.
wow that is smooth, thank you
Wow, that's awesome! Never knew about this, thanks!
So `const SEED_AUTHORITY: Pubkey = pubkey!("AqH29mZfQFgRpfwaPoTMWSKJ5kqauoc1FwVBRksZyQrt");`
Way easier way actually, there's the `anchor_lang::solana_program::pubkey!` macro
wow thanks man!
You could use this https://www.better-converter.com/Encoders-Decoders/Base58Check-to-Hexadecimal-Decoder
How do we generate a Pubkey from a string literal?
For example: `Pubkey::new("PubkeyIdeallyHere")`

I found this example which is pretty much what I want to do:
```rust
const SEED_AUTHORITY: Pubkey = Pubkey::new_from_array([
    0x92, 0x17, 0x2c, 0xc4, 0x72, 0x5d, 0xc0, 0x41, 0xf9, 0xdd, 0x8c, 0x51, 0x52, 0x60, 0x04, 0x26,
    0x00, 0x93, 0xa3, 0x0b, 0x02, 0x73, 0xdc, 0xfa, 0x74, 0x92, 0x17, 0xfc, 0x94, 0xa2, 0x40, 0x49,
]);
```
And they stated above that this array is equivalent to: `AqH29mZfQFgRpfwaPoTMWSKJ5kqauoc1FwVBRksZyQrt`, but I am not seeing how this conversion was made.
If you've actually installed solana then it's going to be a path issue
Does anything solana related show up in your $PATH ?
macro
brilliant, thank you!
hey all! i'm trying to download solana cli again on my mac and I can't figure out why I keep getting this error after install
command not found: solana
I went through the whole process of updating my path in the ~/.profile and ~/.bash_profile files, but nothing seems to work
Getting a case of 3004 when trying to set new IDL buffer for my program:

```
Error: Error processing Instruction 0: custom program error: 0xbbc
```

Is it because the IDL is too large?
Anchor init/upgrade both don't work
Or do I not need to specify the signer, I just say 'mut'
this doesn't wor
```rs
#[acount(signer,mut)]
pub  initializer_account:SystemAccount<'info>,
```
How do I specify a systemAccount as both mutable and a signer?
'''
const keypair = anchor.web3.Keypair.generate();
  await program.rpc.initialize('Matlefebvre1234', {
    accounts: {
      profile: keypair.publicKey,
      author: program.provider.wallet.publicKey,
      systemProgram: anchor.web3.SystemProgram.programId,
    },
    signers: [keypair],
});
'''
   I have another newbies question haha when we use the signers keypair what are we giving exaclty? The private key or a signature ? Because i don't understand how we prove the ownership of the public key with no message to sign ?
<:SadPengu:676207925508964352>
Yeah, if you need access to a ton of accounts then maybe devnet (ew) is the right way to go üòî
so i assume it wouldn't recursively copy all the accounts the program owns too
thing is a candy machine program also has all the accounts in the config for each nft
I think you'd have to clone the program - Deploy it on localhost? I image the local validator only has the baked in Solana Library Programs
wouldn't i have to clone all the accounts of it too? or just the candy machine config
Thanks! I'm coming from an embedded C background - love the little hints! (I'm learning Rust is much better :))
You may be able to clone the account from devnet
i thought so too but im trying to replicate a candy machine in localhost but dunno how to do it each run üò¶
localnet - sooo much faster

...---...
You can experiment with this using rust's `{:p}` format syntax for printing a pointer address:
```.rs
msg!(
            "Address of random_account data {:p}",
            *ctx.accounts.random_account.try_borrow_data()?
        );
```
do you guys usually test on devnet or localhost when devving?
Okay thank for all ! ‚ù§Ô∏è
Nope, the client still has to pass in the account, so it needs to at least know the address
cqfd would know better than I. But a PDA should be able to sign an outgoing sol transaction from its own account.
Ohhhh okay ! But im very new to PDA and my understanding is that the program can sign the transaction with the seed and bump. So i taught it can sign by itself without the client knowing the seed and bump ?
You have to pass it in as an account from the client
Okay thanks ! But ma last problem is that the from keypair is a PDA . Do you know how i can transform a PDA into a  account_info ?
Yep
Dope! `Program input parameters start at 0x400000000` I take it?
Neither stack nor heap
Yeah, good question! In a totally separate part of the memory map: https://docs.solana.com/developing/on-chain-programs/overview#memory-map
Interesting! Thanks a million man! 

Last thing, the account loader, this allows us to use up to the 10MB. If I understand correctly, it just give us access to the pointer of the account.  If this is the case, where is the actual data account located?
No, it costs extra compute üòõ
Can you free up compute this way?
Which means that, yeah, sometimes you can relieve stack pressure just by wrapping some code up into a helper function and invoking it‚Äîdoing so gives you a fresh 4kb of stack to play with
The way you get a new stack frame is by invoking a new function (each frame is per-function call)
AccountLoader would also work though, but usually only necessary for really big accounts
Puts stuff on the heap, releaving stack pressure
What's the box do? I was thinking about converting things into an Account_Loader
Can often use `Box<Account<'info, TheAccountType>>`
But yeah, if you're `await`ing everything, then you'll get more throughput by using multiple processes
I would really be surprised if that happened‚Äîyou can throw a ton of requests from a single node thread if you use promises correctly
Here is a code snippet from one of my projects - hope it helps!

imports -> `use anchor_lang::prelude::*;`

Passed in -> `pub system_program: Program <'info, System>,`
The from account needs to be a signer

Function -> 
```
            let instruction = anchor_lang::solana_program::system_instruction::transfer(
                &ctx.accounts.from.key(),
                &ctx.accounts.to.key(),
                lamports,
            );
    
            let response = anchor_lang::solana_program::program::invoke(
                &instruction,
                &[
                    ctx.accounts.from.to_account_info(),
                    ctx.accounts.to.to_account_info(),
                ],
            );
```
Hey guys ! I want to use the transfer function of anchor to send Sol but i can't import the Transfer struct to use for the CpiContext  anchor_lang::system_program::Transfer  it said that Transfer don't exist and that System program is private ? https://docs.rs/anchor-lang/latest/anchor_lang/system_program/struct.Transfer.html
'''
Would an account loader help?

 `pub big_data_account: AccountLoader<'info, BigDataAccount>`
Is there a good way to align memory in the stack? Like if I needed a lot of accounts to be passed into a function?
i'd imagine when doing it this way, the tps output would be multiplied by the number of cores your cpu has.
Thanks for letting me know man! (And hey, you got 2x speed!)
yea this is what i did got 4 TPS on a heavy method and 10 TPS on a quick method. Old computer :\
Basically since you can already throw a ton of requests at a validator from a single JS thread
I wouldn't expect much speed up versus just running your ts stuff in parallel (so, not synchronizing everything await over and over again)
Any thoughts on this? <@!134416332509675520>
I'd be interested to see if you can get some speed improvement by spinning up the validator and running multiple test scrips at once.

typescript is single threaded.

What I think you'd have to do to try:
1. You'll have to spin up your local validator w/o anchor
2. setup you tests.ts to load up a provider that is not anchor.Provider.env()
3. run the ts-node tests.ts on several terminals
Just don't do `await thing1; await thing2; await thing3` etc.
No threads probably (it's js) but you can do async things in parallel
its not the validator that is slowing it down, its the javascript/ts tests that are done synchronously. even a local validator can theoretically support hundreds of tps
Sure, but I don't think your local validator is going to work any faster this way.
can i spawn multiple threads on it? its all synchronous right now
Also, could someone point me in the direction of some reading? I want to understand the stack better. It seems I get errors like this when I pass in too many accounts to a function. Am I passing in too much? Or do I have to align the memory and somehow request another stack frame?

`Program failed to complete: Access violation in stack frame 3 at address 0x200003fa0 of size 8 by instruction #34761`
Yeah, they're going as fast as they can lol
From what I know, using localnet is the fastest way to test a Solana function
is there any way in anchor to run the anchor ts tests faster? (like a stress test?)
Lol, that's genuinely a pretty fun hack, nice one üòõ
getLowComputeAddress()  ... 100% success rate lol hax
When using `connection.getParsedAccountInfo` is there a way I can parse the data that I get into some layout/class? For example, I know that I am fetching info about a mint, but typescript doesn't know that
You can use `Pubkey::default()` if you want
bc obviously "0" can't be Pubkey and it says me this. But how do I validate then?
hey. How to check that in my struct Pubkey field is not empty? Doing like this gives me an Error
No worries, appreciate the framing
Although again I'm just guessing there
Oh interesting
Ah, yeah, I think explorers must have to do something fancier where they have like a local postgres etc. that they stuff things into, I don't think they're looking directly on-chain per-se
But like, solscan can lookup full transactions an arbitrarily long time ago, so it is accessible on chain s o m e h o w
Thought I have no idea if that's actually what real validators do
Mm, yeah, good question, I'm pretty fuzzy on this too. I think the idea is that at any given moment a validator doesn't need to store that whole history‚Äîall you can access "right now" is the current-ish state of the chain (I think it's like a couple days worth), not whatever it looked like at some arbitrary point in the past.
(Also no need to walk me through a 101 on this, but if you have a useful primer link you know, would be appreciated <:bulba:747166770250514452>)
(What's prompting this for me is looking into arweave and going 'how can blockweave guarantee true data permanence, it's like a giant RAID but how does this possibly scale indefinitely', and then looking back at blockchain itself and being like 'wait a minute how does this simpler version work too)
Related, does each validator know the totality of current on-chain state (essentially), or is that also distributed where processing/validating a transaction requires fetching data from various nodes?
(Not actually anchor related at all, but this place is just so friendly to blockchain newbs...<:bulba:747166770250514452>)

Where is blockchain history 'stored'?
- Assumption(?): The amount of data required to reference the entirety of a blockchain's history grows without limit over time, scaling on activity
- Assumption: On a chain with Solana's activity, we (already have/will <:SoonTM:836971196674211901>) surpassed the amount of space reasonably available to a validator node, even with their beefy specs
- If both of the above, we must have some distributed answer to this.

Am I wrong on Assumption 2 or what does the answer here look like?
Ha, that's pretty good (/ brutal lol, sorry you're in this spot)
i guess i could write a client side hack that would pre-check for chain of pdas with high bumps before deciding on the deriving key
Yea, i see what you're saying. The PDAs that i'm creating via a CPI allow the bump to be set using the anchor account specification, so I should probably change those back to be sure
we have created an issue to just remove bumps btw but it currently looks like it wont get implemented https://github.com/solana-labs/solana/issues/23613
but even if not necessarily insecure, it would make the programming model weirder. rn if you e.g. have a user and a user stats account in a game, there can only ever be one user stats account for the user. If we remove this, there can be multiple
it actually doesn't necessarily mean that it's insecure as long as you save the bump in state. But as long as anchor doesn't do it automatically, it's a footgun
accepting PDAs without checking that they use the canonical bump means that incoming PDAs are no longer deterministic as two PDAs with the same seeds but different bumps will be accepted by a `seeds = ` check
it is
unless its for security reasons?
i'm creating 3 accounts in my ix, (2 are CPI'd and init'd), and passing in two bumps from client and those are saving compute. Why wouldn't I be able to send in the bump for my anchor init'd account too ? Could this be reverted or made optional? https://github.com/project-serum/anchor/pull/1380/commits/92baf8bec124671e35b5e39e5959212c0957bf16
yea you could do that but as you said thats not efficient on the client. You could probably build a way to make it reasonably fast by building a custom index if you run your own nodes but idk whether thats a good idea when PDAs just do it for you so easily
I think the issue above is that they're so close to the compute limit that even that init canonical check is too much
the best practice is to not ever send them from the client but save them in the state on init instead. and then read from state. Anchor will do this for you in the future and hide bumps from users completely
You mean new instruction arguments? Yeah that's the only way
Is there a best practice way of sending the bumps from the client? right now I'm just adding new variables
No, though tbh I'm not totally sure why anchor doesn't let you do this‚Äîusually it's not a big deal but, yeah, sometimes it might be important
is it possible to set the bump of an init account? (calculated client side like the others)
Ah, ok, yeah, you want to use real bumps when not-init'ing (it does save compute)
Yes. 1 of the 4 is init (so i can't pass that bump in), 2 of the 4 are init via a CPI to metaplex but are annotated as mut in my program so i can set the bump manually, and the last is an existing PDA account that i just set manually.


//////////////////////////////////////////////////////////////////////////////////////////

how can I print a more detailed error-message of the program-call (`provider.send`) on the browser-side?
mb
oh okay nice ^^ i updated everything excepted solana x)
You need to update your version of solana, that's super old
someone already had this error: ```BPF SDK: /root/.local/share/solana/install/releases/1.5.7/solana-release/bin/sdk/bpf
Running: /root/.local/share/solana/install/releases/1.5.7/solana-release/bin/sdk/bpf/rust/xargo-build.sh
error: failed to parse manifest at `/root/wtcrpc/backend/programs/backend/Cargo.toml`

Caused by:
  failed to parse the `edition` key

Caused by:
  supported edition values are `2015` or `2018`, but `2021` is unknown``` ? thanks for answers ^^
hey
can u tell me why im getting this error?
ok cool
Yes, that tutorial is too old at this point to be a good source of anchor info, just read the anchor book/docs
so i shouldnt follow the tutorial and instead go through the docs?
So old that I hadn't even started looking at anchor yet so I wasn't aware that used to be valid anchor syntax!
Ah, ok, yeah, that tutorial is very old: https://github.com/Henry-E/dog-money/blob/main/programs/dog-money/Cargo.toml#L18
is it because the tutorial is old, and the syntax might be updated?
and he has done pretty much the same thing
this is his github repo
https://github.com/Henry-E/dog-money/blob/main/programs/dog-money/src/lib.rs
So yeah, I would suggest just carefully going through a tutorial, typing literally exactly what they have, etc.‚Äîyou have enough things in that snippet that just aren't valid anchor that I think you should step back and be extra careful about what you're typing in
#[associated] isn't an anchor attribute, not sure where you got that from
`#[account(associated = authority, ...)]` isn't valid anchor syntax for example‚Äîyou'd have to use `associated_token::authority = authority, associated_token::mint = usdc_mint`
https://www.youtube.com/watch?v=i6Ycr5nhjH8&t=153s im following this
Mm, you have quite a few things wrong here, I would suggest that you work through some anchor tutorials
and im getting a ton of errors, can anybody tell me how to solve this?
and this is my lib.rs program ```rust
use anchor_lang::prelude::*;
use anchor_spl::token::{Mint};
use anchor_lang::solana_program::entrypoint::ProgramResult;
use anchor_lang::accounts::program_account::ProgramAccount;

declare_id!("3C1Kfk1iB4cPXDRNHXck11X8V5c6n4wCJdxDvW8Zfmmb");

#[program]
pub mod dog_money {
    use super::*;

    pub fn initialize_user(ctx: Context<InitializeUser>) -> ProgramResult {
        Ok(())
    }
}

#[derive(Accounts)]
pub struct InitializeUser<'info> {
    program_signer: AccountInfo<'info>,
    #[account(associated = authority, with = usdc_mint)]
    user_data: ProgramAccount<'info, UserData>,
    #[account(signer)]
    authority: AccountInfo<'info>,
    usdc_mint: CpiAccount<'info, Mint>,
    rent: Sysvar<'info, Rent>,  
    system_program: AccountInfo<'info>,

}


#[associated]
pub struct UserData {
    pub first_deposit: i64,
}



 ```
guys im getting this
#[derive(Accounts)]
#[instruction(bump: u8)]
pub struct CreateRaffle<'info>{
  
    #[account(mut)]
    pub owner: AccountInfo<'info>,
    #[account(init_if_needed, payer = wallet, space = 8+4+650)]
    pub raffle_account: Account<'info, RaffleAccount>,
    #[account(init_if_needed, seeds = [b"winneraccount8".as_ref(), wallet.key().as_ref()], bump = bump, payer = wallet, space=8 + 2 + 4 + 200 + 1 + 96)]
    pub winner_account: Account<'info, WinnerAccount>,
    #[account(mut)]
    pub wallet: Signer<'info>,
    pub system_program: Program<'info, System>,
    pub rent: Sysvar<'info, Rent>,
}
So this is my create_raffle func and the context is:
pub fn create_raffle(ctx: Context<CreateRaffle>, bump: u8) -> ProgramResult{
        let payer = &mut ctx.accounts.wallet;
    
            let winner_account = &mut ctx.accounts.winner_account;
            let participants_account = &mut ctx.accounts.raffle_account; 
        }
        Ok(())
    }
also how do you define the context?
can you do code-formatting like this ``` code ```
My winner account is a pda
pub fn get_winner(ctx: Context<GetWinner>) -> ProgramResult{
        let mut contestants: [i16; 7] = ctx.accounts.raffle_account.contestants;
        ctx.accounts.winner_account.winners[0] = contestants[1];
        ctx.accounts.winner_account.winners[1] = contestants[3];
        ctx.accounts.winner_account.winners[2] = contestants[4];
Ok(())
    }
The accounts are:

#[account] 
pub struct WinnerAccount{
    pub winners: [i16; 3],
    pub length: u8,
}

#[account] 
pub struct RaffleAccount{
    pub contestants: [i16; 7],
    pub length: u8,
}
can you post some code?
what do you mean you assign values inside the array?
Could somebody please answer? I'm really stuck..
No
Hey, Ive cloned anchor/tests/escrow and I lunched the tests, first I needed to add "///CHECK" above every AccountInfo property in struckts. Now, they are still failiing and I wonder is it something wrong with tests or with my local environment. Thanks in advance
Hey!
Is it possible to initialize a new account without a discriminator?
Thanks!
Hello, I am creating a pda which has an array.. But I am not able to assign values inside the array.. Why is that?
Error: RPC request error: cluster version query failed: error sending request for url (https://api.devnet.solana.com/): operation timed out
got it -  pub token_program : Program<'info,Token>
The spl token program. You need to ask it to please transfer the tokens
I can't seem to link to it but the `constraint = ` form is discussed on that page
btw what is cpi_program in context of token transferring - 
```rs
    let cpi_program = ctx.accounts.token_program.clone();
```
it does mention about owner being the program owner but not this one  : constraint=<expr>
I see. i was looking at this page its not documented here -https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html#normal-constraints.
The `owner` constraint is for the program owner
`#[account(constraint = token_account.owner == token_account_owner.key())]` instead
not working for me
has anyone tried owner constraint on a tokenAccount - 
```rs
   #[account(owner=token_account_owner.key())]
   pub token_account: Account<'info, TokenAccount>,
   pub token_account_owner : AccountInfo<'info>,
```
And take a look at the Anchor.toml to see if anything looks out of place
Try adding some `console.log`s in there etc. to see if that file is even running
Are you sure? If the workspace failed to load it would do so silently.
It fails to do anything, it jusyt quits. 

workspace fails to load.
What do you mean by it fails every time on that line, if you don't see an error?
Moved all my anchor code to a new directory. Nothing else and now unable to run any tests.

Commented out all the files except one and that program has nothing in it.

It fails every time on this line:

```  const program = anchor.workspace.Example1;```

But it doesn't display any error, just this.

```0 passing (0ms)```


Any idea why?
okay
It's still needed
in such case the authority field is no longer needed I'd assume
E.g. with `CpiContext::new_with_signer`
Yep. You would need your program to sign for that PDA though using its seed + bump
```rs
{
  let ata = await createAssociatedTokenAccount(
    connection, // connection
    feePayer, // fee payer
    mintPubkey, // mint
    alice.publicKey // owner,
  );
}
```
so in this case if i provide a pda in place of "alice.publicKey", the owner or authority will be the pda and only the program could transfer the tokens to other token account. Correct?
ok
Depends on what you set the authority to be when you created the token account
if i want to transfer tokens that is in a PDA account, the authority is the program itself?
So if I want to transfer you some of my tokens, I need to sign the tx (otherwise the spl token program will refuse to decrement my token balance)
It's whoever owns the tokens (like, a person or whatever‚Äîthe program owner of the token account is the spl token program, as usual)
what's the authority in this case - 
```rs
      Transfer { 
        from: token_account.to_account_info(), 
        to: account.to_account_info(), 
        authority: token_account.to_account_info(),
      }
```
Hello, i'm trying to do `anchor verify` and this is my tail output
```Copying out the build artifacts
Cleaning up the docker target directory
Removing the docker container
anchor-program
Extracting the IDL
Writing the IDL file
Writing the .ts file
Build success
Error: package section not provided```

Any insight on what package section is?
thanks both!
ah it was the wildcard
yus, 
for an eg, like this 
```
mod context;
use context::*;
```
how are you importing your file
your problem is likely that youre not using wildcard imports
see https://book.anchor-lang.com/chapter_3/milestone_project_tic-tac-toe.html#program-directory-organization
it is working perfectly fine for me


//////////////////////////////////////////////////////////////////////////////////////////

üëã  Hi everyone, 
I am confused with the difference between  `#[derive(Accounts)]` and `#[account]`  
Any easy explanation on this ??..thnx!!
Ok, at any rate, that version of anchor requires you to not use bumps when doing `init`
0.21.0
What does `anchor --version` say at the terminal
The Cargo.toml inside the `programs/your-prog-name` directory
As anchor version is 0.21.0, Two machines are same.
where do i add the compilation settings , so as to optimize them such that `anchor build` uses that ?
that did the trick! thank you üôÇ
ahh ok thank you
you might be using an outdated rust version
anyone run into this error when trying to install anchor?
I was going through tictactoe program on project-serum/anchor, i want to know why we are using  asterisks with dashboard.to_account_info().key, i am getting same result without it
``` pub fn initialize_dashboard(ctx: Context<Initializedashboard>) -> Result<()> {
        let dashboard = &mut ctx.accounts.dashboard;
        dashboard.game_count = 0;
        dashboard.address = *dashboard.to_account_info().key;
        Ok(())
    }```
I found the issue HAHAHA, turns out I had a duplicate of the struct somewhere else in my code. When i deleted the duplicate, the idl generated successfully!
That's because different versions of the anchor cli behave differently here
I will try to figure this out, thanks so much for the help!!
I had done building this contract on my machine, but I failed to try  on AWS ubuntu vps.
In your contract, whenever you use `init` you now need to *not* use an explicit `bump = the_bump`, but rather just do `bump,`
I tried to run command `anchor keys list`
this is error image.

I get errors to use anchor
please help me using anchor
Hello.
Not sure, is there anything weird in your Anchor.toml maybe?
Is there a config that could cause that?
Unless you have a setting or something someplace that is turning off checks
Mmmm that shouldn't happen
My machine is weird
Usually the lack of a CHECK comment fails only when i run anchor test, anchor build will run fine
I'm skeptical since you're going to need a CHECK comment, so I would have expected anchor build to fail
Yeah pretty sure I did
And you'll need a CHECK comment too
And they would need to be `#[account(mut)]` since you're changing their balance
Sounds like you're not building the IDL correctly (I don't know, did you forget to save the file?)
Yes, you'd need to pass the recipient in as another account
But how should I pass the `who_to_send_the_lamports_to` into the instruction? Should I define it as an AccountInfo?
```
#[derive(Accounts)]
pub struct TransferToken<'info> {
    #[account(mut)]
    sender: Signer<'info>,
    #[account(mut, close=receiving_lamport)]
    receiver: Account<'info, ReceiverDetails>,
    #[account(mut)]
    receiver_token_account: Account<'info, TokenAccount>,
    #[account(mut)]
    sender_token_account: Account<'info, TokenAccount>,
    receiving_lamport: AccountInfo<'info>,
    /// CHECK: This is not dangerous because we don't read or write from this account
    token_program: AccountInfo<'info>
}
```
I run anchor build on this, but `receiving_lamport` does not appear in the idl. Not sure if im doing this correctly ü•≤
<@134416332509675520>  I am trying to call the anchor program from server side
This is the Code where i am getting error
`   const idl = Idl as anchor.Idl;
      const programId = "EoBG2VasooF76AX25K6Bsm8BMnimMKQi6JcFj6CMCSA1";
      console.log("ERROR");
      const pId = new anchor.web3.PublicKey(programId);
      const program = new anchor.Program(idl, pId);`
I am getting this `TypeError [ERR_INVALID_ARG_TYPE]: The "path" argument must be of type string or an instance of Buffer or URL. Received undefined`
Yep, the `close = who_to_send_the_lamports_to` can send the lamports to whoever you want
Hi guys! Is it possible to close an account, and refund the rent back to a SystemProgram account/wallet which is not a signer of the transaction?
ytoken metadata crate got updated to 1.2.6 , which now use solana 1.9.5 does that mean we can use it with anchor now ? how do i check what solana version is anchor using ?
Looking at https://github.com/project-serum/anchor/blob/master/tests/tictactoe/tests/tictactoe.js#L3
`dashboard` is just generated, and there's no explicit funding for that account. I'm doing the same
<@717956950737813594> What I'm saying is, so that the anchor deploy can be successful
otherwise, anatoly will kill you, xD
you can airdrop max 2 sol ser
too much ser, do reduce it lol
` Program log: Memo (len 40): "request too large; req: ‚óé45, cap: ‚óé2"`
```ningfei@192 solbd % solana confirm -v 3CteDeEnwjhL7JXiTZAxDpxXKqgeAfic3hPNq3VSEatvxqKzGughtUpreSBxiZUb2RHY93VdLitBbzt4rtaL7jco
RPC URL: https://api.devnet.solana.com
Default Signer Path: /Users/ningfei/.config/solana/devnet.json
Commitment: confirmed

Transaction executed in slot 127327217:
  Block Time: 2022-04-11T21:59:22+08:00
  Version: legacy
  Recent Blockhash: 5q7wqTQn8XxU5seKXfYA53UefnWkn1FKJH22BNeJj4SE
  Signature 0: 3CteDeEnwjhL7JXiTZAxDpxXKqgeAfic3hPNq3VSEatvxqKzGughtUpreSBxiZUb2RHY93VdLitBbzt4rtaL7jco
  Account 0: srw- 9B5XszUGdMaxCZ7uSQhPzdks5ZQSmWxrmzCSvtJ6Ns6g (fee payer)
  Account 1: -r-x MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr
  Instruction 0
    Program:   MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr (1)
    Data: "request too large; req: ‚óé45, cap: ‚óé2"
  Status: Ok
    Fee: ‚óé0.000005
    Account 0 balance: ‚óé19337719.982879944 -> ‚óé19337719.982874945
    Account 1 balance: ‚óé0.52149888
  Log Messages:
    Program MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr invoke [1]
    Program log: Memo (len 40): "request too large; req: ‚óé45, cap: ‚óé2"
    Program MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr consumed 33081 of 200000 compute units
    Program MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr success

Finalized```
<@717956950737813594> 
What should i do now
thanks!
lol
0x1 generally mean insufficient fund
do you have enough sol
```rs
const JOB_SETTINGS: &'static [u8] = b"JOB_SETTINGS";

#[program]
pub mod staking {

    use super::*;

    pub fn initialize(ctx: Context<InitializeJobFactory>) -> Result<()> {
        Ok(())
    }
}

#[derive(Accounts)]
pub struct InitializeJobFactory<'info> {
    #[account(init,
        seeds = [JOB_SETTINGS],
        bump,
        payer = authority,
        space = 8,
    )]
    pub job_factory_settings: Account<'info, JobFactorySettings>,
    #[account(mut)]
    pub authority: Signer<'info>,

    pub system_program: Program<'info, System>,
}

#[account]
pub struct JobFactorySettings {}
```
```ts
describe("staking", () => {
  // Configure the client to use the local cluster.
  const provider = anchor.Provider.env();
  anchor.setProvider(provider);

  // const wallet = provider.wallet;
  const keyPair = anchor.web3.Keypair.generate();

  const program = anchor.workspace.Staking as Program<Staking>;

  it("Is initialized!", async () => {
    let jobAdId = "JOB_SETTINGS";

    const [jobFactorySettingsAccount] = await anchor.web3.PublicKey.findProgramAddress(
      [Buffer.from(jobAdId)],
      program.programId
    );
    // Add your test here.
    const tx = await program.rpc.initialize(
      {
      accounts: {
        jobFactorySettings: jobFactorySettingsAccount,
        authority: keyPair.publicKey,
        systemProgram: SystemProgram.programId,
      },
      signers: [keyPair],
    },
    );
    console.log("Your transaction signature", tx);
  });
});
```
Hi! 

I'm getting: 
```
  staking
    1) Is initialized!


  0 passing (92ms)
  1 failing

  1) staking
       Is initialized!:
     Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: custom program error: 0x1
      at Connection.sendEncodedTransaction (node_modules/@solana/web3.js/src/connection.ts:4052:13)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at Connection.sendRawTransaction (node_modules/@solana/web3.js/src/connection.ts:4014:20)
      at sendAndConfirmRawTransaction (node_modules/@project-serum/anchor/src/provider.ts:286:21)
      at Provider.send (node_modules/@project-serum/anchor/src/provider.ts:120:14)
      at Object.rpc [as initialize] (node_modules/@project-serum/anchor/src/program/namespace/rpc.ts:24:16)
```
`G362mMEcApxKNyoC7y52gM9bpkrhyxU4oFNsxKyYzvvo` this is your program adderss.
`HAkyg4bdnvmhjFDQDfD1JTRtwp6tEPaqhS57ErFQFy12` this is the address which deployed the program in first place.
`3DD8Hkx7Jj5xRVXcBHsooigpFQgipCfouQvWsUJacvqg` this is the address trying to upgrade `G362mMEcApxKNyoC7y52gM9bpkrhyxU4oFNsxKyYzvvo` but because he is not the authority he can't hence error
and There is no G362mMEcApxKNyoC7y52gM9bpkrhyxU4oFNsxKyYzvvo in app/src/idl.json
```ningfei@192 solbd % solana program deploy /Users/ningfei/solbd/target/deploy/solbd.so

Program Id: G362mMEcApxKNyoC7y52gM9bpkrhyxU4oFNsxKyYzvvo

ningfei@192 solbd % 
ningfei@192 solbd % anchor test

BPF SDK: /Users/ningfei/.local/share/solana/install/releases/1.10.7/solana-release/bin/sdk/bpf
cargo-build-bpf child: rustup toolchain list -v
cargo-build-bpf child: cargo +bpf build --target bpfel-unknown-unknown --release
    Finished release [optimized] target(s) in 0.73s
cargo-build-bpf child: /Users/ningfei/.local/share/solana/install/releases/1.10.7/solana-release/bin/sdk/bpf/dependencies/bpf-tools/llvm/bin/llvm-readelf --dyn-symbols /Users/ningfei/solbd/target/deploy/solbd.so

To deploy this program:
  $ solana program deploy /Users/ningfei/solbd/target/deploy/solbd.so
The program address will default to this keypair (override with --program-id):
  /Users/ningfei/solbd/target/deploy/solbd-keypair.json
Deploying workspace: https://api.devnet.solana.com
Upgrade authority: /Users/ningfei/.config/solana/id.json
Deploying program "solbd"...
Program path: /Users/ningfei/solbd/target/deploy/solbd.so...
Error: Program's authority Some(HAkyg4bdnvmhjFDQDfD1JTRtwp6tEPaqhS57ErFQFy12) does not match authority provided 3DD8Hkx7Jj5xRVXcBHsooigpFQgipCfouQvWsUJacvqg
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), st```
if it's super urgent, lmk your sol address I'll give you some
do try again :))
ser `operation timed out`
why can't airdrop?
Or maybe you could on different rpc
Again & again
Not a issue ser, just try again
<@717956950737813594>
referencing here https://book.anchor-lang.com/chapter_5/space.html
what's the size of an enum with no types attached eg. ``` enum  Status { On, Off, Broken }``` 1 + largest variant size, do this variants have any size?
Account is easier to use but uses serialization (borsh); AccountLoader is a little bit harder but doesn't use any serialization at all (it's for zero_copy accounts), so it's more efficient and can support much larger account sizes‚Äîbut it's harder to use, so usually your life will be simpler if you just use Account.
How can I check how much space is needed ? (Here I have hardcoded to 24 bytes)

```#[account(init, seeds = [pool.mint.as_ref()] , bump, payer=payer, space = 24)]
    pub signer: AccountInfo<'info>```
What are the use cases of Account<'info, Struct> and AccountLoader<'info, Struct>? When should we use what??
do one quick dirty hack, delete the whole `target` folder and run anchor build once again. and then replace declare_id with the new one you got from `anchor keys list`, and also change it on Anchor.toml file
tho, this is not possible, you can't change it on runtime
afaik, `declare_id!(....)` is only meant for declaring program address a.k.a smart contract address.
need help

Some more context, I have an `update_authority` hardcoded in the program. And then in tests, I wanna change that dynamically to a test environment specific `update_authority` cause I'll be testing with the corresponding Keypair.
Is there any way I can change the addresses that were hardcoded using `declare_id` while running tests?
1.58.1
What version do you got?
try to upgrade latest one
What version of rust are you using? `rustc --version`
Legit cannot find a solution anywhere somebody please help
getting this issue and i dont know what to do. Have tried running it again with WSL2 but still the same error
What are the best practices of auditing before releasing a program publicly? My programs include vault accounts that hold onto users NFTs and the ability to mint a token so these things have to be airtight.  Is there anywhere I can go to find people offering this service? or even discord servers where people cross audit eachothers programs multiple times over?
`catch (err) { expect(err.error.errorMessage).is.equal("test") }`
like this `err.error.errorMessage`
ok so you need to access the parent variable here first

I think the syntax is right
can you console log the `error` once
error.errorMessage is undefined, maybe not the right syntax to get the errorMessage?
it should suppose to work, tho you can also try this
`expect(error.errorMessage).is.equal("test")`
that produces this
`assert.equal(error.errorMessage, 'test'),`
trying to do something like
assert.equal(error, 'test'), where error is the errorMessage
how can I get just the errorMessage from a test? 
console.log(error) shows a lot of information
Hi, Is it possible to find an associate token address like the javascript method `getAssociatedTokenAddress` in anchor rust?
https://docs.solana.com/developing/plugins/geyser-plugins "overview"
can anyone give a tldr on the recently introduced geyser plugins on solana ?
https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html

last transaction before it seem to have deployed was this
It produced a program id which I assume means it compiled and deployed to test net. I was wondering if since this is an open source escrow program I cloned if it was building out test transactions or something, or if it's programmatically creating new accounts for escrow and paying the rent ahead of time and thats what's eating the large amount of solana in the end?

So I'm still super new to rust and programming in general but I've been stuffing my brain for a few months and tried to deploy this program. https://github.com/tomoima525/escrow-program. I got it deployed on test net, but the thing ate like 2 solana in the process and was wondering if these were test transactions or if solana programs depending on what they're doing cost a lot to deploy? https://solanabeach.io/address/AwEP3csHURUFi9cSpdCDxyxgLxwbY6Nye9m37UpemGNw?cluster=testnet
what does info mean and whats the tick syntax

whats with all the 'info
Account<'info, Whatever>
Have you tried removing it and seeing what kind of error message you get?
`to_account_info(),` why we use this ? <@134416332509675520>


//////////////////////////////////////////////////////////////////////////////////////////

Hi, can I somehow get hold of transaction ID in an executing program?
I'm getting an error `Error: Transaction was not confirmed in 30.00 seconds. It is unknown if it succeeded or failed. Check signature <SIGNATURE> using the Solana Explorer or CLI tools.` does any one know why this is happening when running `anchor test`?
Hi everyone, 
I am confused with the difference between  #[derive(Accounts)] and #[account]
Any easy explanation on this ??..thnx!
thanks! it should automatically run `cargo fmt` in background on save or I need to do some tuning?
rust-analyzer 100%
also how does the 'was not confirmed in 30 seconds' error work with the retries specified in the provider connection?  if ive specified 20 maxRetries in the Provider constructor, will the aforementioned error indicate that 30 seconds has passed after 20 retries or after the first try?
gotcha.thanks!
with newer anchor version you need to use:
```
program.methods
        .yourMethod(parameters)
        .accounts({
          // accounts...
          authority: userWallet.publicKey,
          systemProgram: anchor.web3.SystemProgram.programId,
          tokenProgram: TOKEN_PROGRAM_ID,
          rent: anchor.web3.SYSVAR_RENT_PUBKEY,
        })
        .signers([additionalSigners])
        .rpc();
```
the tutorials show to use the program.rpc.method() for sending transactions, but the documentation and warnings I get say that is deprecated.  Is there a guide for the alternative / updated means?
anybody can give advice on a good vscode setup for rust+anchor? I've used for months `rust-lang.rust` extension but I'm trying to move to `rust-analyzer` as it seems more maintained. I'm having also some problem with `fmt` onSave, maybe some conflict with prettier... any advice?
Thanks
https://docs.rs/anchor-spl/latest/anchor_spl/ this might help
If anybody could point me to some docs
Hello!!! I am having trouble understanding how to work with NFT's in anchor.. How to create them? And how to send them from on wallet to another using anchor
thanks!
https://book.anchor-lang.com/chapter_5/avm.html
use `avm`
I guess I Can go into ~/.cargo/bin/anchor and rename stuff and do it the ghetto way
Do you guys know how to cargo install specific anchor-cli with specific alias so I can have multiple? For example: `cargo install --git https://github.com/project-serum/anchor --tag v0.20.1 anchor-cli --locked` that I can use like `anchor-v0.20.1 build`
that's you would do it in solidity
how can i test for emits? eg. `expect(some rpc).to.emit({a:1, b : "hello"})`
Nope!
hey, do i still need to init PDA to sign transactions with that PDA?
you need to change the address of the program to whatever your local keypair has deployed
what's the best way to decrease the size of the smart contract? I just checked the bytes of the contract, about half of it seems to be zero bytes. any guides on what things to possible check?
When I run 'anchor test' after cloning step-staking, the test isn't running and not sure why

https://github.com/step-finance/step-staking
help
hlep
need hlep

Funding wallet with enough sol should this issue for me
```ningfei@192 solbd % anchor deploy
Deploying workspace: https://api.devnet.solana.com
Upgrade authority: /Users/ningfei/.config/solana/id.json
Deploying program "solbd"...
Program path: /Users/ningfei/solbd/target/deploy/solbd.so...
===============================================================================
Recover the intermediate account's ephemeral keypair file with
`solana-keygen recover` and the following 12-word seed phrase:
===============================================================================
desert receive ritual cart time bonus youth decrease coyote pledge craft barely
===============================================================================
To resume a deploy, pass the recovered keypair as the
[BUFFER_SIGNER] to `solana program deploy` or `solana write-buffer'.
Or to recover the account's lamports, pass it as the
[BUFFER_ACCOUNT_ADDRESS] argument to `solana program close`.
===============================================================================
Error: Deploying program failed: Error processing Instruction 1: custom program error: 0x1
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.
ningfei@192 solbd % ```
had to use the solana_program crate for the pubkey! macro,
same dsnt work for me either üò¶
how do you resume a failed anchor deployment?  i see the docs for using 'solana deploy program' to recover, just wondering if anchor has something to do it?
You can then update that metadata until you set updateAuthority to null on that metadata account
Part of step 3 is passing in the data.
Generic NFT 101:
- Create mint account
- Mint a token to an SPL token account (possibly an ATA).
- Create token metadata acccount (this has to be done before or in the same tx as the next step or that will fail btw)
- Set mintAuthority to null
https://docs.metaplex.com/architecture/basic_flow does a pretty decent job of explaining the flow
Is there any purpose to holding onto the secretkey of a mint account after you've set mintAuthority to null (I know that creating a metadata account is one particular use case - any others?)
how is data attached to tokens? I'm thinking in the case of someone attaching their website to a token.
my guess thus far is you would `initialize_mint` with the anchor_spl library, and then `create_metadata` from anchor_spl_token_metadata, but i'm wondering how these get tied together under the hood (or if i'm completely off track, how this works to begin with).
Yea it is a bug, I think there is a PR in progress to fix it
I dont fucking understand why I can't even run something as simple as anchor build
I have been stuck on this for days
somebody please

Oh, seems linked to https://github.com/project-serum/anchor/issues/1628
In Cargo.toml of `lala` I put:
```toml
[dependencies]
anchor-lang = "0.23.0"
lala-puppet = {path = "../lala-puppet", features = ["cpi"]}
```
Hi! Trying to create two programs, where one is a dependency of the other one. Similar pattern to the `puppet` crate.
I am getting:
```
error[E0107]: this struct takes 0 lifetime arguments but 1 lifetime argument was supplied
  --> programs/lala-puppet/src/lib.rs:5:1
   |
5  | #[program]
   | ^^^^^^^^^^- help: remove these generics
   | |
   | expected 0 lifetime arguments
   |
note: struct defined here, with 0 lifetime parameters
  --> programs/lala-puppet/src/lib.rs:15:12
   |
15 | pub struct Initialize {}
   |            ^^^^^^^^^^
   = note: this error originates in the attribute macro `program` (in Nightly builds, run with -Z macro-backtrace for more info)
```

I creted `lala` using `anchor init lala` and then `anchor new lala-puppet`
Oh, whoops, maybe I'm misremembering
Weird , the few repos I saw, use the compilation settings in the root cargo toml file.


//////////////////////////////////////////////////////////////////////////////////////////

Thanks anyway, I figured it out
Hello ! Why is it that when deriving a `PDA`, `space` is required with `init`, but not when creating a spl`PDA`?
thank you kind sir
what's supposed to be the difference between the recommended and secure examples?
in the seas level attacks repo
Nice. paulx has been telling us what's up in the TS channel.   He already has a fix in master.
https://discord.com/channels/889577356681945098/899315988087054397
I was able to recreate the same issue using anchor 0.24 with one of their code examples from the anchor book (game program from this part of docs https://book.anchor-lang.com/chapter_3/PDAs.html#how-to-build-pda-hashmaps-in-anchor)

Rolled the project's cargo.toml & package.json rust & typescript anchor libs from 0.24 -> 0.23 and it began working again
I am trying to make a basic escrow program 
```
#[derive(Accounts)]
#[instruction(application_idx: u64, state_bump: u8, wallet_bump: u8)]
pub struct InitializeNewGrant<'info> {
  #[account(
        init, 
        payer = sender, 
        seeds = [b"state".as_ref(), sender.key().as_ref(), reciever.key().as_ref(), mint_of_token_being_sent.key().as_ref(), application_idx.to_le_bytes().as_ref()], 
        bump = state_bump)]
    application_state: Account<'info, State>,
```
I have been getting the following error that `bump targets should not be provided with init. Please use bump without a target.`. 
I have found the following breaking change regarding the issue :-
```
lang: Providing bump = <target> targets with init will now error. On init only, it is required to use bump without a target and access the seed inside function handlers via ctx.bumps.get("<pda-account-name"). For subsequent seeds constraints (without init), it is recommended to store the bump on your account and use it as a bump = <target> target to minimize compute units used (#1380).
```
But then what I am supposed to do with `state_bump`?? I guess it is useless now right?
like you described
yeah i'm also having issues
Glad to hear I'm not the only one.  Been trying to figure this out for a while.
I ran into this same undefined issue with one project. Swapped over to a template/empty project with an empty IDL (just a blank program definition) and that worked fine. Trying to determine what I have that is causing the issue
Hey, after processing through my first smart contract's creation i had a bunch of "beginner questions" i hope it's the right place there ^^ ```md
#Accounts
First of all is it possible creating accounts for every single user and global account(for the program/smart contract)?

Accounts can hold sol's ?

#Transactions
How are the transactions working ? i mean is it actually like in solidity transfering eth from contract's bank to someone's bank ?

Are any payable modifier or something like that in sol ?

#HashMaps
Since HashMaps doesn't work on-chain atm how can i proceed to create something like a global variable where i can store data array that should be seen by everyone talking to my contract?``` i've got a lot more questions but main questions are there ^^ thanks answering üôÇ
Anyone else upgrade to 0.24 and get IDL working?
Interestingly, this IDL in the source does not have a `returns` field... 
https://github.dev/project-serum/anchor/blob/2544f1f2e4fcaa9be612934bf4b2ab311d6db60e/ts/src/spl/token.ts#L21-L22
What should the IDL types be here?
thanks... that makes sense
i have checked and redeploy latest program but error still exist
hm, it's only instruction of my program or any invoked from my program too?
This can often happen if you've made a mistake while deploying, e.g. accidentally deploying an old .so file
You're somehow sending an unknown instruction to the anchor program (it's saying "... wtf is this")
or maybe someon know what means:  Program log: AnchorError occurred. Error Code: InstructionFallbackNotFound. Error Number: 101. Error Message: Fallback functions are not supported.
your rust version is outdated
how i can run execute rpc call in anchor  without simulation? want see a program logs
Anyone else having TypeScript IDL problems from 0.24?  Using `Program<MyProgram>` yields the following:
```
  Types of property 'instructions' are incompatible.
    Type '[{ name: "createGame"; accounts: [{ name: "gameAccount"; isMut: true; isSigner: false; }, { name: "allocationTracker"; isMut: true; isSigner: false; }, { name: "adminSettings"; isMut: false; isSigner: false; }, { ...; }, { ...; }]; args: [...]; returns: null; }, ... 4 more ..., { ...; }]' is not assignable to type 'IdlInstruction[]'.
      Type '{ name: "createGame"; accounts: [{ name: "gameAccount"; isMut: true; isSigner: false; }, { name: "allocationTracker"; isMut: true; isSigner: false; }, { name: "adminSettings"; isMut: false; isSigner: false; }, { ...; }, { ...; }]; args: [...]; returns: null; } | ... 4 more ... | { ...; }' is not assignable to type 'IdlInstruction'.
        Type '{ name: "createGame"; accounts: [{ name: "gameAccount"; isMut: true; isSigner: false; }, { name: "allocationTracker"; isMut: true; isSigner: false; }, { name: "adminSettings"; isMut: false; isSigner: false; }, { ...; }, { ...; }]; args: [...]; returns: null; }' is not assignable to type 'IdlInstruction'.
          Types of property 'returns' are incompatible.
            Type 'null' is not assignable to type 'IdlType | undefined'.
```
(You could write that yourself though)
Where's that from? Yeah, it's implemented in the metaplex code itself, but I'm not sure if there's an open-source way to just say `Account<'info, MetadataThing>`
oh wait, i think It is implemented
No, not my first install.  And yeah the other versions are good - ging back and forth on those at will
Though I've heard folks want to move towards everyone just only accepting the first valid bump seed as a canonical bump seed. Not sure how feasible that is (how would you know? <:thonk:711735996726640652>)
So what happens is the findProgramAddress takes the other seeds, tries a starting bump_seed, and has a 50% chance of getting a success (finding a PDA that lies off curve). If it fails it iterates the bump seed and keeps trying til it succeeds. Then it returns the address _and_ the bump seed that resulted in that address. If you're just going to be using findProgramAddress again in the future, you can discard the bump seed. If you're doing this calculation in a smart contract though (where CPU is precious), you probably want to store the returned bump seed so you can just immediately derive it next time. I guess because storing the address itself is more expensive than the cpu to derive it, but the stored bump seed isn't? /shrug
Seeds ultimately include the bump seed, but colloquially we aren't referring to such usually. E.g. if you want the seed for a metadata account, it's 'metadata', TOKEN_METADATA_PROGRAM_ID (i.e. 'metasomethingsomethingsomething'), and the mint id. Hidden and implicit is the first valid bump seed.
.23 is hopefully fine for you üò¶
Is this your first anchor install?
np, thank you
Sorry, out of my expertise ;(. But I'm also running ubuntu and can't repro ;_;
Unsurprising ye
the cargo command also fails <:7183pepeshock:871703844374069258>
Hello !! Wanted to know what is the difference between a `seed` and a `bump seed` while deriving a `PDA`. It seems that a `bump seed` is used to make sure that the generated address does not have a corresponding private key.?
Hm. I'm also on ubuntu, I'm trying to repro myself rn but I think I'm past the point you failed at
ubuntu
<@801445539245719552> if that also fails, what os distribution are you running out of curiosity?
trying the other one now
the avm command is what fails
(...which one xD)
yeah
You getting this from an `avm install latest` or an explicit `cargo install --git https://github.com/project-serum/anchor --tag v0.24.0 anchor-cli --locked`?
Ngl that looks like a package issue. Since it just came out today maybe wait on a fix?
<@588910687397609482> Starting a necro thread a month later may not be the best way to get an answer. I'm a newb so take everything with a grain of salt.
- If your transaction is timing out, the network could be congested. Try again?
- Or you could just have a long ass transaction. You may be able to set your timeout on awaiting confirmation longer, or you may just need to await confirmation of the transaction (connection.confirmTransaction(txId)) or w.e
You'd have to write a wrapper struct, same idea as how anchor has the TokenAccount thing to deserialize a token account
It's unfortunately not quite that easy (surprised there's no open source impl of this yet?)
Anchor says he can't serialise Metadata Account
```
error: there is no argument named `rpc_port`
    --> cli/src/lib.rs:2208:40
     |
2208 |             "Your configured rpc port: {rpc_port} is already in use"
     |                                        ^^^^^^^^^^

error: there is no argument named `faucet_port`
    --> cli/src/lib.rs:2218:43
     |
2218 |             "Your configured faucet port: {faucet_port} is already in use"
     |                                           ^^^^^^^^^^^^^

error: could not compile `anchor-cli` due to 2 previous errors
warning: build failed, waiting for other jobs to finish...
error: failed to compile `anchor-cli v0.24.0 (https://github.com/project-serum/anchor?tag=v0.24.0#b0f26321)`, intermediate artifacts can be found at `/tmp/cargo-installdDSMtX`

Caused by:
  build failed
Error: Failed to install 0.24.0, is it a valid version?
```

getting ^^ when trying to upgrade to 0.24.0

anyone with an idea of how to get around this?
that makes sense.. Thanks!!
E.g. my tokens have my wallet's pubkey written on them, so the spl-token program knows not to give my tokens away unless specifically *I* sign the tx
The authority over a token account is its "logical owner", the person/thing that need to sign in order to move those tokens/burn them/etc.
Hello!! If I am not wrong a `Signer` is an account which signs a transaction and thus authorizes it. Then what is an `authority`.  `solana-spl` has the following `account` constraint :-
```
#[account(token::mint = <target_account>, token::authority = <target_account>)]
```
What is `token::authority` here? Any different from a normal `Signer`
hey, how to read NFT metadata in rust program?
Did you manage to fix this?
Transaction Confirmation error


//////////////////////////////////////////////////////////////////////////////////////////

Trying to deploy my program with anchor deploy and getting a really weird error (have previously deployed the program before, but just upgraded to anchor v0.23).

```
Deploying workspace: https://api.devnet.solana.com
Upgrade authority: /Users/xxx/.config/solana/devnet.json
Deploying program "nft-candy-machine"...
Program path: /Users/xxx/Documents/personal/solana/metaplex/rust/target/deploy/nft_candy_machine.so...
Error: Unable to open program file: No such file or directory (os error 2)
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.
```

I think it's looking in the wrong directory for the so file, given that the so file exists in `/Users/xxx/Documents/personal/solana/metaplex/rust/nft-candy-machine/target/deploy/nft_candy_machine.so` and not in the directory it's looking for (not looking within the `nft-candy-machine` directory). How can I fix this?
Got the same error for node version 16 and 17
Looks like there is a dependency graph conflict.
Has anyone else gotten the following error after running ```anchor init hello-anchor``` in ch. 3 of the Anchor Book, and then running ```npm install``` : ```npm ERR! code ERESOLVE
npm ERR! ERESOLVE unable to resolve dependency tree
npm ERR! 
npm ERR! While resolving: undefined@undefined
npm ERR! Found: mocha@9.2.2
npm ERR! node_modules/mocha
npm ERR!   dev mocha@"^9.0.3" from the root project
npm ERR! 
npm ERR! Could not resolve dependency:
npm ERR! peer mocha@"^3.X.X || ^4.X.X || ^5.X.X || ^6.X.X || ^7.X.X || ^8.X.X" from ts-mocha@8.0.0
npm ERR! node_modules/ts-mocha
npm ERR!   dev ts-mocha@"^8.0.0" from the root project
npm ERR! 
npm ERR! Fix the upstream dependency conflict, or retry
npm ERR! this command with --force, or --legacy-peer-deps
npm ERR! to accept an incorrect (and potentially broken) dependency resolution.
npm ERR! 
npm ERR! See /Users/thomasvarner/.npm/eresolve-report.txt for a full report.

npm ERR! A complete log of this run can be found in:
npm ERR!     /Users/thomasvarner/.npm/_logs/2022-04-02T17_56_54_170Z-debug.log```
Got it, thanks a lot üôå
Yep‚Äîyou can think of it as the address saying "yep, I'm ok with someone sticking an account here"
Ah so as  its being initialized, its need itself as well to sign for the creation of itself ?
Hi. I wanna implement upvote function for gif.
I code the function and successfully compiled, but test throw error like this.
```
     TypeError: src.toArrayLike is not a function
      at BNLayout.encode (/Users/myusername/ghq/github.com/maguroid/gif-portal/node_modules/@project-serum/borsh/dist/lib/index.js:37:37)
      at Structure.encode (/Users/myusername/ghq/github.com/maguroid/gif-portal/node_modules/buffer-layout/lib/Layout.js:1263:26)
      at BorshInstructionCoder._encode (/Users/myusername/ghq/github.com/maguroid/gif-portal/node_modules/@project-serum/anchor/dist/cjs/coder/borsh/instruction.js:87:28)
      at BorshInstructionCoder.encode (/Users/ryamaguchi/ghq/github.com/maguroid/gif-portal/node_modules/@project-serum/anchor/dist/cjs/coder/borsh/instruction.js:72:21)
      at /Users/ryamaguchi/ghq/github.com/maguroid/gif-portal/node_modules/@project-serum/anchor/dist/cjs/program/namespace/index.js:39:100
      at ix (/Users/myusername/ghq/github.com/maguroid/gif-portal/node_modules/@project-serum/anchor/dist/cjs/program/namespace/instruction.js:46:23)
      at txFn (/Users/myusername/ghq/github.com/maguroid/gif-portal/node_modules/@project-serum/anchor/dist/cjs/program/namespace/transaction.js:16:20)
      at Object.rpc [as vote] (/Users/myusername/ghq/github.com/maguroid/gif-portal/node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:8:24)
      at Context.<anonymous> (tests/myepicproject.js:41:23)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
```

Where my code has mistake ?

My codes here.

function
https://github.com/maguroid/gif-portal/blob/main/packages/myepicproject/programs/myepicproject/src/lib.rs#L32

test
https://github.com/maguroid/gif-portal/blob/main/packages/myepicproject/tests/myepicproject.js#L41
Good q, in solana when you create an account you ultimately need to sign for its address
Also in this above example, why does the signer list contain `myAccount` then? Shouldnt it be just an empty list as Im not using the myAccount to sign transactions?
This particular feature specifically, like as the payer is the provider keypair, it does not need to be added in the list of signers.
wdym this stuff?
Ah got it thanks a lot , if available, is there some docs where I can read more on this stuff
yes the user has to sign as well but youre using the ptovider keypair as the user and anchor will use the provider keypair as a signer automatically so no need to add it to the signers array again
Hi, what does the signer mean when making a RPC call in the client side code? From the docs: 
> Here, we specify the accounts field, an object of all the addresses the transaction needs to touch, and the signers array of all Signer objects needed to sign the transaction
```
    await program.rpc.initialize(new anchor.BN(1234), {
        accounts: {
            myAccount: myAccount.publicKey,
            user: provider.wallet.publicKey,
            systemProgram: SystemProgram.programId,
        },
        signers: [myAccount],
    });
```
In this case, we are creating a new account myAccount and paying for the creation from the User account, so shouldn't the signer be the User account ?
I figured it out :)) using program.account...getAccountInfo(). This function return false if account not existed
thank you so much
https://github.com/project-serum/anchor/blob/master/lang/src/system_program.rs#L298
is there sol transfer function in anchor ?
In rust or on the client? From the client you'd just try fetching the account and see if anything is there
how can I check if a pda account exist?
Ahh now it makes sense, thanks a lot üôå
The connection to anchor test is actually the Anchor.toml file‚Äîyou can put whatever pubkey you want in Anchor.toml and then anchor test can automagically run a validator with your code living at that address
I think my main confusion arose from the original program id generated when use call `anchor-init` which is always equal to`Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS` which needs to remain when we run anchor test , and then when we actually deploy it , it needs to be changed to the output program id we get when we run anchor-build
hello, i am new here, i have some questions about anchor and rust, if anyone is free, i appreciate
Okay, so https://project-serum.github.io/anchor/tutorials/tutorial-1.html#initialize-instruction if you see program 0 and program 1, both have the same declare-ids, Is it bcoz its just meant as a refrence and it's exprected for us to change it ? 
Also when I use the `anchor keys list` output value as my declare id, the anchor test fails with output `The given account is owned by a different program than expected` , when I use the declare id same as what is mentioned in the blog, it works and all tests passes
you need to build the program in order to get the address
do 
1. anchor build
2. anchor keys list
Hi yup, sorry I made a mistake in my message, I had to use a particular declare id while running via Anchor Test as well. Ive been following this https://book.anchor-lang.com/chapter_3/the_accounts_struct.html 
Now Im confused as to, how do I know while writing the program itself, what would be my program account address  ?  
Sorry if Im missing something obvious here üòÖ
well it's not supposed to work, `declare_id!()` should contain the program address.
Should the `!declare_id` value  in the rust code always match the program address generated when we build the code using anchor-build? When I was trying to run using my own client code, I needed to do this, when I test using `anchor test` command I can put in any `declare_id` and it works.
Like this right? Use my program instead of token program right

In nodejs instead of sending the tx you can create that as an instruction and create a tx object and send the tx manually
Is there any example? In react app I create provider via AnchorWallet (which imported from wallet adapter). How to archieve this in node app
Hi Im trying basic-1 example from getting started, here is my client.js, where Im creating a new account address and calling the program
```    const programId = new anchor.web3.PublicKey("F9anHuD3aJTuKgjohVKgT5e5Vya95ZFv47224vWzVzwk");  // <YOUR-PROGRAM-ID>");
    const program = new anchor.Program(idl, programId);

    // The Account to create.
    const myAccount = anchor.web3.Keypair.generate();

    // Create the new account and initialize it with the program.
    await program.rpc.initialize(new anchor.BN(1234), {
        accounts: {
            myAccount: myAccount.publicKey,
            user: provider.wallet.publicKey,
            systemProgram: SystemProgram.programId,
        },
        signers: [myAccount],
    });
```
While running, I use the command `ANCHOR_WALLET=/Users/.config/solana/id.json node client.js` 
This gives me the error `ProgramError: 3007: The given account is owned by a different program than expected` 
What is mistake here? Is it because Im passing a different account as a  env variable and my client code is creatign another new account?
use the anchor ts library to do so
how to interact with program in nodejs backend?
Hi, I wrote a program with a simple function to transfer sol token and wrote the test. When I am using anchor test, it is giving this error:
```
Transfer: insufficient lamports 0, need 1000
Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: custom program error: 0x1```
I have airdropped lamports and even checked the balance and it has enough lamports. So what is the issue?
```
describe("example", () => {
  // Configure the client to use the devnet cluster.
  const connection = new anchor.web3.Connection(
    web3.clusterApiUrl('devnet'),
    'confirmed',
  );

  //console.log(connection);
  const fromWallet = web3.Keypair.generate();
  const toWallet = web3.Keypair.generate();

  before(async () => {
    let airdropSignature = await connection.requestAirdrop(
      fromWallet.publicKey,
      web3.LAMPORTS_PER_SOL, // 10000000 Lamports in 1 SOL
    );
    await connection.confirmTransaction(airdropSignature);
  });

  const program = anchor.workspace.Example as Program<Example>;

  it("Sol token is transferred!", async () => {
    // Add your test here.
    const tx = await program.rpc.transferNativeTokens(new anchor.BN(1000), {
      accounts: {
        from: fromWallet.publicKey,
        to: toWallet.publicKey,
        systemProgram: web3.SystemProgram.programId,
      },
      signers: [fromWallet],
    });
    await connection.confirmTransaction(tx);
  });
})
```
would you like to share the function?
using da latest anchor version
any idea why im suddenly getting errors when running ``anchor build`` on a new ``anchor init`` project?
<:thumbsUp:932661832102051971>
forgot to update here, but <@!134416332509675520> helped me out, the issue was my IDL for my frontend was out of date
did you convert BN -> toNumber?
<@!134416332509675520> sent a dm
Yeah, can you post the rust struct?
address 8xUKTzxM8BakwYpeYucPVedgGPPQtXJw1UY8zXakEMmZ  on devnet ( the fields are not actullay A and B)
Can you post the account address?
I'm having an odd issue with BN types. In my frontend when pointing to devnet I get the following values for my account
```A: 17323731990913122121 B: 6605859977062577180```

But when fetching the exact same account in a test file pointing to devnet I get
```A: 0 B: 0```

In this scenario the test file output is the one I expect; super confused on why my frontend values are weird. There are other values in that account which are publickeys, and those all look the same as the values I see in the test, its just the BN types that are weird.
ah ok, that's super interesting. thank you!!
doesn't seem that way. deployed program and ids seem alright. hm
`0xa7` error seems owner mismatch, is that right? it's mismatching deployed program vs. declare_id isn't it...checking
got to the next error. turns out I was referencing the metaplex token metadata program on my localnet but didn't clone it to local validator. but thank you
Check if your Anchor.toml matches maybe?
Here's the call that's failing:
```
    program_client
        .request()
        .accounts(draffle::accounts::AddPrize {
            raffle,
            creator: program_client.payer(),
            from: creator_prize_token_account,
            prize,
            prize_mint,
            system_program: system_program::id(),
            token_program: spl_token::id(),
            rent: sysvar::rent::ID,
        })
        .args(draffle::instruction::AddPrize {
            prize_index,
            amount: prize_amount,
        })
        .send()?;
```
how can I debug this error? can't find any info on it...the target program id in my code seems alright
`RPC response error -32002: Transaction simulation failed: Attempt to load a program that does not exist`
The ? in rust does a little `.map_err(Into::into)`internally anyway
Yeah (not sure what the upgrade instructions say, but it's fine)
yeah, works great without .map_err() but I was a little leery of leaving it out given the instructions said it was part of the upgrade path. You think it's ok to omit?
anybody generating api with solita know when code gen uses `beet.FixableBeetStruct` instead of `beet.BeetStruct`? running into an error with an enum struct property that seems to be related:
```
Type 'FixedSizeBeet<MarketState, MarketState>' is not assignable to type 'FixedSizeBeet<any, Partial<any>>'.
```
Yep (good q, that was initially a bug in an old anchor version)
Mm, you shouldn't need both the `?` and `.map_err`. Can you just get rid of the `.map_err` line?
hey guys, when I have init_init_if_needed account do I need to make constraints for it in case it is innited? Or those rules (associated_token::mint = lair_mint) will be treated as constraints?
hi guys, anchor/rust newb here. I'm trying to upgrade from anchor 0.21.0 to 0.22.0. The upgrade instructions are here: https://github.com/project-serum/anchor/blob/master/CHANGELOG.md#0220---2022-02-20

It says to convert invoke() to invoke.map_err() but I can't seem to get the rust types to work.

```
            invoke(
                &transfer(&user_key, txn.to_account_info().key, amount),
                &[
                    ctx.accounts.user.to_account_info(),
                    txn.to_account_info(),
                    ctx.accounts.system_program.to_account_info(),
                ],
            )?
            .map_err(Into::into);
```

I get this error: no method named `map_err` found for unit type `()` in the current scope
method not found in `()`

If I remove the question mark, I get: type annotations needed
cannot infer type for type parameter `F` declared on the associated function `map_err`

I've tried supplying types (::<(), ProgramError>) but no dice. Any ideas?
```anchor build```
how can I create the `types` folder with the .ts IDL? had it, then cleaned the target folder and now can't figure out how to have it created. tried build and deploy but no luck


//////////////////////////////////////////////////////////////////////////////////////////

tx doesn't return a sig
```js
    let tx = await program.methods.initialize({
          accounts : {
            stakeAccount : stakeAccountKey.publicKey,
            counterAccount : counterAccountKey.publicKey,
            genesisAdmin : genesisAdminKey.publicKey,
            systemProgram : anchor.web3.SystemProgram.programId
          },
          signers : [genesisAdminKey]
        
      })
      await program.provider.connection.confirmTransaction()
      
    }
```
how do i get the sig?
Or just chuck in a sleep
```.rs
const sleep = ms => new Promise(awaken => setTimeout(awaken, ms));
await sleep(2000)
```
You may need to wait for additional confirmation, `await program.provider.connection.confirmTransaction`
Error: Account does not exist 8KBtxPNeab2AUmXswx1ATK5YUiBYSnkaVoasefvbYNvs
```js
    async function fetchData(){
      await preprocessor()

      console.log(genesisAdminKey.publicKey.toString())

       const account = await program.account.stakeAccount.fetch(stakeAccountKey.publicKey)
       console.log(account)
       // console.log(utfDecoder.decode(account.hasInit))
    }
```
How are you checking that? What error do you get? Etc.
unfortunately still no account creation
Ah cool
<@875698957513289789>
likely more efficient: `the_account.as_ref().lamports()`
Nice. Thanks!
`the_account.to_account_info().lamports()`
Is there an anchor specific way to check SOL balance for an account you pass?
I can't get past this error. Everything seems to be setup correctly

I'm just saying that you can type that account as whatever seems relevant
You can't‚Äîthat Account<'info, Whatever> would only make sense if you want to additionally assert that it's one of your Whatever accounts
Ok so this compiles:

```pub to: UncheckedAccount<'info>,```


But for the first method how would you not supply anything to the second field of the account?


```pub to2: Account<'info, TheAccountTypeIfApplicable>,        ```
So e.g. `Account<'info, TheAccountTypeIfApplicable>`, or just `UncheckedAccount<'info>` (with a `/// CHECK` comment above it), etc.
You can actually use whatever you want there (just not Signer if they're not going to sign)
How do you pass an account to a program that you can't sign for?

This would be the recepient of lamports and i signed it would look like this:

``` pub player: Signer<'info>,```

But how would this look like for an unsigned account?
thanks ser
You changed those space calculations, 8 + 8 isn't enough for the StakeAccount; you'd need 8 + 32.
idl - 
```json
{
"version": "0.1.0",
  "name": "solanaire_stake",
  "instructions": [
    {
      "name": "initialize",
      "accounts": [
        {
          "name": "stakeAccount",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "counterAccount",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "genesisAdmin",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": []
    },
    {
      "name": "stake",
      "accounts": [
        {
          "name": "stakeAccount",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenAccount",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "staker",
          "isMut": false,
          "isSigner": true
        }
      ],
      "args": [
        {
          "name": "amount",
          "type": "u32"
        }
      ]
    },
    {
      "name": "increment",
      "accounts": [
        {
          "name": "counterAccount",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "count",
          "type": "u8"
        }
      ]
    }
  ],
  "accounts": [
    {
      "name": "StakeAccount",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "amount",
            "type": "u32"
          }
        ]
      }
    },
    {
      "name": "CounterAccount",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "count",
            "type": "u8"
        }
        ]
      }
    }
  ],
  "errors": [
    {
      "code": 6000,
      "name": "AmountTooSmall",
      "msg": "Minimum stake amount violation"
    }
],
  "metadata": {
    "address": "CMWv5sfuqwttiURdvh76XaJHextGvAKsbSFTtLS6ESzN"
  }
}```
client -
```rs
use anchor_lang::prelude::*;
use anchor_spl::token::TokenAccount;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod solanaire_stake {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {

        Ok(())
    }

    pub fn stake(ctx : Context<Stake>,amount : u32) -> Result<()>{
        let stake_account = &mut ctx.accounts.stake_account;
        if ctx.accounts.token_account.amount>1111{
            stake_account.amount = amount;
        }else{
          return err!(StakeError::AmountTooSmall)
        }
        Ok(())
    }

    pub fn increment(ctx : Context<Increment>,count : u8) -> Result<()>{
        let counter_account = &mut ctx.accounts.counter_account;
        counter_account.count = count;
        Ok(())
    }    

}

#[account]
#[derive(Default)]
pub struct StakeAccount{
    amount : u32,
}


#[account]
pub struct CounterAccount{
    count : u8,    
}


#[derive(Accounts)]
pub struct Initialize<'info>{

    #[account(init,payer = genesis_admin,space= 8 + 8)]
    pub stake_account : Account<'info,StakeAccount>,

    #[account(init,payer = genesis_admin,space= 8 + 8)]
    pub counter_account : Account<'info,CounterAccount>,

    #[account(mut)]
    pub genesis_admin : Signer<'info>,
    pub system_program : Program<'info,System>
}

#[derive(Accounts)]
pub struct Stake<'info>{
   pub stake_account : Account<'info,StakeAccount>,
   pub token_account: Account<'info, TokenAccount>,
   pub staker : Signer<'info>,

   
}

#[derive(Accounts)]
pub struct Increment<'info>{
   pub counter_account : Account<'info,CounterAccount>
}



//error def

#[error_code]
pub enum StakeError {
    #[msg("Minimum stake amount violation")]
    AmountTooSmall
}
```
rust -
But the Initialize invocation doesn't create the accounts üò≠
Yep, that looks about right
is this the right way of creating multiple accounts with 1 signer - 
```rs
#[derive(Accounts)]
pub struct Initialize<'info>{

    #[account(init,payer = genesis_admin,space=48)]
    pub stake_account : Account<'info,StakeAccount>,

    #[account(init,payer = genesis_admin,space=48)]
    pub counter_account : Account<'info,CounterAccount>,

    #[account(mut)]
    pub genesis_admin : Signer<'info>,
    pub system_program : Program<'info,System>
}
```
when you are trying to update data from the account that is owned by d/f program. you'll get something like this
```
Error: AnchorError caused by account: counter. Error Code: AccountOwnedByWrongProgram. Error Number: 3007. Error Message: The given account is owned by a different program than expected.
Program log: Left:
Program log: CR7XiGZHEu588YMkg2RPtyokwhawwEczcHHznXM6NwG7
Program log: Right:
Program log: 7BeXBXWYR9Q1jkL9RBkxEJEeUiRXUJFbvajsCg8CcsZf
```
yes, you are right, the owner of the account is itself the program a.k.a smart contract
runtime policy:

> Only the owner may change account data.
> - And if the account is writable.
> - And if the account is not executable.
is this because the owner of counter is the program itself rather than systemProgram?
But I assume ethereum actually works similarly? https://ethereum.stackexchange.com/questions/1302/where-do-contract-event-logs-get-stored-in-the-ethereum-architecture
I actually don't know how you retrieve them in general‚Äîthat's handled by the rpc infrastructure, but I'm not sure exactly how they do it
They're just logs: https://github.com/project-serum/anchor/blob/master/lang/attribute/event/src/lib.rs#L77
Any luck on this <@134416332509675520> , any relevant resources on how events work in Solana, as there is no native support for it, so trying to understand in what way is it similar to eth events, i.e, can they be retrieved later on, or are these events o. Retrieved when they happen, I e I set up a listener and it catches this event, but on a later date is there a way to get past events ? If so where are these events stored ?
Creating an account *does* require a signature though.
No need to sign when you want to modify data (at least not in general‚Äîyou could write your program to act that way, but it's not the default in solana).
why don't we need to pass `counter` as a signer? since we would be modifying the data of `counter` account
hi guys! I'm having trouble trying to understand the anchor example basic 2 (https://project-serum.github.io/anchor/tutorials/tutorial-2.html) where we increment a `Counter` account. On the client end we can increment a `Counter` account with:

`   await program.rpc.increment({
      accounts: {
        counter: counter.publicKey,
        authority: provider.wallet.publicKey,
      },
    })`
I fix this issue. the code already changed.
I can do a staking program that takes and holds an NFT which earns the person a token over time right?
Cause if so, I need to build one tonight. Who's excited
cool, thanks
Nope
Yep
<@!134416332509675520>
is it a vulnerability not to initialized PDAs?
are all accounts SystemAccounts before being initialized?
i see
What you have there doesn't really make sense in anchor: you're allocating a custom (maybe empty, but still custom) struct, and you're not using any space to do so, but anchor always uses at least 8 bytes for your own custom account types, so it can store the "account discriminator"
You'd want to instead just use AccountInfo (with a /// CHECK comment), or SystemAccount<'info> maybe
https://discord.com/channels/889577356681945098/889702325231427584/959926463862296576
<@!134416332509675520>
```rust

#[account(seeds=[b"redeemable_authority"], space = 0, bump)]
pub redeemable_authority: Account<'info, Empty>,
```
How are you using it in the derive(Accounts) struct?
my instruction takes a PDA as an argument, anchor complains that it is not initialized. why would this be? why would it need to be initialized? it doesnt hold any data, i just use it as a mint authority.


//////////////////////////////////////////////////////////////////////////////////////////

If I have account like this in which there is vector
```
#[account]
pub struct PoolAccount {
    pub pool_id: u32,
    pub pool_owner_key: Pubkey,
    pub pool_token: Pubkey,
    pub pool_amount: u64,
    pub projects: Vec<ProjectAccount>,
    pub start_time: i64,
    pub end_time: i64,
}
``` 

then how am I supposed to access that key of single project in function ?

```
pub fn add_projects_to_pool(ctx: Context<AddProjectsToPoolAccount>, project: ProjectAccount) -> Result<()> {
        ctx.accounts.pool_account.pool_owner_key = *ctx.accounts.pool_owner.key;
        ctx.accounts.pool_account.projects.project_owner_key = &ctx.accounts.project_owner.key;
        Ok(())
    }
```
sweet, thanks for explaining
`init` creates rent-exempt accs. Generally, all accounts need to be rent-exempt on mainnet now. the rent is payed by whoever you specified as `payer = ` in your `init` constraint
<@!134416332509675520>
can anyone help me, i need to deserialize SlotHashes data in to Vec<SlotHash>
how can i do this?
when I create an new keypair via `web3.Keypair.generate` and then use it to create an account of my program I see that this account owns some SOL. Are these funds taken from the payer of the transaction and passed to the account so it is rent-exempt? Would be really cool if this is the case since I find the concept of rent kind of annoying and would be really pleased if I do not have to take care of account balances in order to keep them alive.
I'm actually not sure lol, as far as I can tell you'd need to close the wrapped sol token account, but that seems weird since that would unwrap *all* of the sol
how do I create a "unwrap SOL" instruction in typescript?
this is the hacky way i did it in the end  (i'm using anchor 0.21 and stuck on it for dependency reasons ) . this example is using the struct defn from https://twitter.com/anchorlang/status/1491906353560006662

```
import { Test, IDL } from "../target/types/nft";

const program = anchor.workspace.Test as Program<Test>;
const idlIxs = IDL[instructions"];
const initIx = idlIxs.find(ix => ix.name === "initMyAccount");
const pdaAcctIdx = initIx["accounts"].findIndex( x => x.name == "account");

// we need to call this._accountsResolver.resolve() within MethodsBuilder 
// for the PDAs to be calculated and this is only called in rpc(), simulate(), instruction() or transaction()
const ix: TransactionInstruction = await program.methods
    .initMyAccount(seedA)
    .accounts({
        base: base.publicKey,
        base2: base2.publicKey,
    })
        .instruction(); 
const acct_calculated_PDA = ix.keys[pdaAcctIdx].pubkey;

const txn = new Transaction();
txn.add(ix);
await program.provider.send(txn);

await program.accounts.MyAccount.fetch(acct_calculated_PDA);

```

it would be nice to have a built-in way to do this something like 
```
const prepared = await program.methods
    .initMyAccount(seedA)
    .accounts({
        base: base.publicKey,
        base2: base2.publicKey,
    })
    .prepare(); //pretty much just calls the this._accountsResolver.resolve() but now it should be locked in some immutable state.
const acctPDA = prepared.accountMetaForIx("initMyAccount", "account").pubkey;
const txn: Transaction = prepared.transaction(); // or rpc(), instruction(), simulate()
```
That error is coming from someplace else‚Äîthe error message from rust is just confusing unfortunately
What is this error? why do I need lifetime parameter?
The max size limit is 10mb, so it's mainly a question of whether you want to spend the money
I guess it depends on what your alternatives are
thanks üò¶
because of the max size limit.
is it good idea to store user data like - accountAddress,authId in a data account?
The dapp itself would need to keep checking if the transaction succeeded
Can't, the program itself can't communicate with the outside world in any way
How to send messasge from program to dapp with anchor? Eg: message to notify their transaction is successfully
was from following the tictactoe example
num-traits = "0.2"
num-derive = "0.3"
added the
in the cargo.toml outside src

all the #[account] etc also getting
error[E0432]: unresolved import `crate`
 --> programs/tic-tac-toe/src/lib.rs:8:1
  |
8 | #[program]

keep this error when trying to anchor build
thx a lot! üôÇ
the .toNumber is giving me errors, that's why im asking xD
This is probably smarter: https://stackoverflow.com/questions/54409854/how-to-divide-two-native-javascript-bigints-and-get-a-decimal-result
Won't work in general though because BNs can be too big to convert back to a regular JS number
Mm, this won't work in general but you can maybe get away with doing `a.toNumber() / b.toNumber()`
given two big numbers how can I divide to get a fraction? (in typescript)
or you can do this also ig,
```pub fn xyz(build_account: &Account<BuildAccount>) -> {....}```
``` xyz(&ctx.account.build_account)```
You either can implement the accounts struct (Initialize, Update, the ones which has the derive accounts macro) as the following


impl<‚Äòa> Initialize<‚Äòa> {
    pub fn do_stuff(&self) {
        // access accounts using self.whatever
    }
}
how ?)
you need to pass the reference of ctx here
hey, how to call function that is outside of instructions from instructions? This gives me an error
what <@!185307556032413697> stated, it the only reason here <@!744612713811935404>
`stake_account` and `counter_account` are not the PDAs, hence their keypair required for signature.
```json
  "instructions": [
    {
      "name": "initialize",
      "accounts": [
        {
          "name": "stakeAccount",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "counterAccount",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "genesisAdmin",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": []
    },
```
besides the idl also mention ```"isSigner": true
``` for all three accounts
when i only put the genesis_admin in the signers it produces - ```Error: Signature verification failed```
I have created an account, airdropped sol in localhost (Verified its airdropped properly from explorer too) and passed it to a sol transfer function. And getting this error
```Transaction simulation failed: Attempt to debit an account but found no record of a prior credit.```
What's causing it?
Hi, ```Instruction 0: custom program error: 0xa3 ``` what is this error in anchor i just could figure it out?
https://github.com/solana-labs/solana/blob/37497657c6636bcc6c85bde9f798bebad2332a78/sdk/program/src/program.rs#L29-L94
you can read more about it here, incase you want
Solana's runtime has an explicit check for PDAs, that whenever anyone invoke cpi with the signer and passes the correct seed, the account will be marked as a signer automatically
......
Most of the time PrivateKey's are used to sign transaction but PDA's donot have private keys so how and who will sign transaction? <@!717956950737813594>
sorry didn't get you
so do PDA's use Publickey for transaction signing? <@!717956950737813594>
Yus, PDAs sign the txns. Solana runtime mark them as `is_signer = true` whenever you invoke cpi with the signer, and pass the correct seed
Does PDA signs transaction? if yess then How? <@!134416332509675520>
Ty
https://github.com/project-serum/anchor/blob/v0.18.2/ts/src/error.ts#L83
how would tally those error in anchor ??
might go through the code that already does that for references
Hi just wondering where can i check this error for anchor `` Program log: Custom program error: 0xa3``??
Any resources for staking nfts from a collection? And in turn then earning the token
will do that. Thank you once again saviour.
yes so i guess vanilla transfer it is üòÑ
Ok maybe close doesn't work on AccountInfo (it's not a common thing to try to do)
You'll just have to manually do the lamport transfer, with `.try_borrow_mut_lamports()` etc.
Ok maybe close doesn't work on AccountInfo (it's not a common thing to try to do)
```error[E0599]: no function or associated item named `try_accounts` found for struct `CloseTrove` in the current scope```
0.18.0
Can you show them?
ProgramAccount is also super outdated, what version of anchor are you on?
```39  | #[program]
    | ^^^^^^^^^^ function or associated item not found in `CloseTrove<'_>`
...
916 | pub struct CloseTrove<'info> {
    | ---------------------------- function or associated item `try_accounts` not found for this
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `try_accounts`, perhaps you need to implement it:
            candidate #1: `anchor_lang::Accounts`
    = note: this error originates in the attribute macro `program` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the trait bound `CloseTrove<'_>: anchor_lang::Accounts<'_>` is not satisfied
```
well AccountInfo gave me other werid errors
Why are you using ProgramAccount<'info> there rather than just like AccountInfo<'info>?
for pda yes
on this
after 'info
It tells me to add the missing generic argument
let me show you the error
ü•¥
Ok, at any rate, what doesn't work about `close =`?
It has a bunch of space
i just randomly gave the space
That doesn't look like an empty account to me
```rust
#[account(init_if_needed, seeds = [b"solTrove".as_ref(),authority.key().to_bytes().as_ref()], bump = sol_account_bump, payer = authority, space =  8 + 2 + 4 + 200 + 1)]
    pub sol_trove: AccountInfo<'info>,```
no i didnt
Did you use like `space = 0` or something?
How did you do that?
coz im making account for each wallet user
(Not impossible, just not sure why you'd do that)
If the account doesn't have any data, why is it owned by the program?
that also has the instruction to transfer those sol
like my farm program
no the same program
If you you just need to do a vanilla sol transfer
Which program owns the account? The system program?
You'll probably need to just transfer the sol yourself, `close =` only works for accounts that are owned by the program (not the same thing as being a PDA)
but seem it doesnt work that way
i was trying to use single account of storing sol and handle data
so close should pretty much do the thing for me
i need to  transfer all the sol from there
if it has no data and has no SOL, it's just an address, right?
Are you sure you need to close it?
Hi,  i have an pda account, that doesnt hold any data. And i wanna close that account in anchor
```rust
 #[account(mut, close = authority, seeds = [b"solTrove".as_ref(),authority.key().to_bytes().as_ref()], bump = trove.sol_bump)]
 pub sol_trove: ProgramAccount<'info>, //// what generic argument should i passing here along with info???
```
wonderful - thank you!
Yeah
Ok - that's what I thought. So basically as long as I don't introduce anything that would interfere with what the older accounts were built to do, then all should be fine?
Deploying has zero effect on any other accounts‚Äîfor better or worse, since you have to be careful to make sure your changes to the program are backwards-compatible with all of the old accounts out there
Hello all - when it comes to deploying changes to a program that is being actively used, are there any precautions one needs to take to ensure the safety of any open accounts? 

For instance, an escrow program that has several PDAs actively storing tokens for various pending swaps, as well as "esrowAccounts" that act as references for those PDAs. 

If a developer needs to make some addition to the program, such as adding a new function and/or context, can it be safely deployed without jeopardizing the persistence of these open accounts? What about adding new properties to the escrowAccount model in order to phase in a new piece of functionality (i.e. suddenly we want to start tracking the date these were created)?

My impulse is that there is no inherent danger in upgrading a program in this situation, so long as the changes are carefully reviewed to not introduce vulnerabilities, nor alter the previously-expected behavior of the contract in regard to those accounts. However, I could see there being a potential issue at least with the direct modification of an account model. 

Anyways - it's difficult to find any resources that directly address this, so I'd greatly appreciate any feedback. Thank you!
right i get that but i thought the whole concept of having the methods builder api for these complex PDA initalizations was so i didn't have to re-write the findProgramAddress on the client side
Hi, so when i try to transfer sol from the data account? why is it not possible??
do i need to actually create another account to handle that ??
check solana cookbook
findprogramaddress function or something i reckon
<@!652573044375552024>
use the value that u used to create those pda for the program id
yes
i'm using the methods builder to iniitalize a PDA similarly to the example from this tweet - https://twitter.com/anchorlang/status/1491906353560006662
is there a way for me to get the resulting publicKey for the `account` on the client side?
btw thank you for your time guys.
this was my cargo toml tho ahha
```[workspace]
members = [
    "programs/*",
]```
and i didnt change anything like ...
Any advice on this one?
its working now suddenly hmm...
if its not sensitive
can you paste the `Cargo.toml` for the failing program
thats like my full log
```
Deploying workspace: https://api.devnet.solana.com
Upgrade authority: /home/sexpistol/new-keypair.json
Error: expected square brackets
```
hmm
same error
ye replaced it
mb
sorry `--program-name` instead of `--project`
it says no argument called project..
let me try that tho
isnt it retrieving from the anchor toml file ?
but it would give me error about there is program thats not in the workspace
if you do `anchor deploy --project farm --provider.cluster devnet` does that fix?
i was thinking of like adding only one program to the workspace instead of doing programs/*
nope, they build fine
thats my full anchor toml ahaha
is there a naming conflict between any two?
Can you post the full Anchor.toml or is that classified
Mm, interesting
when i delete my other programs i can successfully deploy that program
Ok at any rate think that looks fine
mybad haha
omg haha
Haha
You're killin us üòÇ
so i missed it
i just typed it
Lol
yes its on programs
should be `programs.devnet` not `program.devnet`
i didnt copy that bit hahah
Ah ok
ye its on devnet
Yeah can't just say `farm =`
oh
or whatever deployment net
`[programs.localnet]` to the top
yep, add
i have added only the program that i want there tho
```
[program.devnet]
farm = "HPwvr8B9KtM3CZwQg7V8pevfgsZfZBLiR3gL1HcEsGiD"

[registry]
url = "https://anchor.projectserum.com"

[provider]
cluster = "devnet"
wallet = "/home/sexpistol/new-keypair.json"

[scripts]
test = "ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"
```
Can you post your Anchor.toml?
but when i just try anchor build, it builds all the program fine
it gives me the same error saying the expected bracket
but its weird like when i try anchor build -p progam
definitely a repo/crate configuration issue
rippoo
hmm nah seems like both dont work lool
It's only specifically when you use the `-p` option?
And this doesn't happen if you just do `anchor deploy`?
I'm not too sure, I would need to see the crate metadata files and the actual code to be able to help
but i want to do it with the `` anchor deploy -p program ``
i can go to the target folder and run that specific program .so file
well nah thats not the issue
well i dont think so, but i willcheck it again.
maybe messed brackets in there?
ye  i deployed it several times
should be just a json serialized number array
the content of the keypair file valid json?

that all the log there is
can you please post the entire terminal log
but i wanna deploy those program individually after build
it  successfully builds all the programs
when i try to anchor build
there are multiple programs in that workspace
so i just had anchor deploy -p farm
no target name is farm
might help to see the actual thing
is your target _actually_ `my_program` and you're just missing the underscore in the command?
just this
Error: expected square brackets
<@!242234529396424704> can you paste the full error
where should i be putting those square brackets ??
gives me error saying ``expected square brackets``
Hi, when I try to deploy specific program using anchor , suppose ``anchor deploy -p my program``
there is likely something else going wrong but can't tell from what's posted
this shouldn't be the case. `genesis_admin` is the only account that is designated as a signer for the instruction and thus should be the only required keypair provided for the rpc call.

if `stake_account` and `counter_account` are PDAs, then they aren't even keypairs at all, they're a public key and bump nonce associated coupling that point to an off-curve key and would have no effect when adding the public keys to the signers array.
I am finding a few resources on staking a token for a token. However I want to stake an nft for a token. I know an nft is a token, however it's a supply of 1 so I want to be able to take in any from a collection.
oh I see thanks
The reason is because of the following reasons

1. Any account that is initialized with a Keypair account (PDA's an exception), is required their signature (kinda like an approval), so you gotta pass the stake_account's keypair
2. The same applies for counter_account as well, as that's initialized
3. Usually if the payer is your wallet, you don't need to supply additional actors' private key. But since here it's mentioned as genesis_admin being the payer, it's secret key is also required (A Payer has to be a signer, hence marking that account as a signature required account)
```rs
#[derive(Accounts)]
pub struct Initialize<'info>{

    #[account(init,payer = genesis_admin,space= 8 + 32)]
    pub stake_account : Account<'info,StakeAccount>,

    #[account(init,payer = genesis_admin,space= 8 + 32)]
    pub counter_account : Account<'info,CounterAccount>,

    #[account(mut)]
    pub genesis_admin : Signer<'info>,
    pub system_program : Program<'info,System>
}
```
btw I had to put all accounts in the signers. Don't know why but worked -
```js
    let x = await program.methods.initialize().accounts({
      stakeAccount : stakeAccountKey.publicKey,
      counterAccount : counterAccountKey.publicKey,
      genesisAdmin : genesisAdminKey.publicKey,
      systemProgram : anchor.web3.SystemProgram.programId
    }).signers([genesisAdminKey,counterAccountKey,stakeAccountKey]).rpc()
```
finally  !!  üéä üî•  thanks <@!134416332509675520> , <@!185307556032413697>
Same ^, update your declare_id to be that 2XPxee address
Yeah, it's annoying, but you need to update declare_id! to reflect whatever the actual runtime id is
same here
you get the declareId once running anchor init. And after running anchor deploy you get a different programId in the log as you can see in the screenshot. Which one to use ?

That is‚Äîyou need to change the declare_id! in your lib.rs file to match it
the programId I get after deployed is not the required programId?
Your declare_id! in your rust code needs to match
matches with idl - 
```json
  "errors": [
    {
      "code": 6000,
      "name": "AmountTooSmall",
      "msg": "Minimum stake amount violation"
    }
  ],
  "metadata": {
    "address": "DNYXQEkferiGdxJjpq3Qo781r8mJwiN1EUcJfssAqiAw"
  }
```
this is the program Id - DNYXQEkferiGdxJjpq3Qo781r8mJwiN1EUcJfssAqiAw
what's causing that? any idea
that seems to work. However I got - ```Error Code: DeclaredProgramIdMismatch. Error Number: 4100. Error Message: The declared program id does not match the actual program id.```
okay let me try that
You'd want to make a `new NodeWallet(genesisAdminKey)`
Looking into how you're supposed to make a wallet just from a keypair, 1sec
```json
module.exports = {
    programId : "DNYXQEkferiGdxJjpq3Qo781r8mJwiN1EUcJfssAqiAw",
    networkEndpoint : "https://api.devnet.solana.com",
}
```
The second argument is meant to be a Wallet rather than a keypair
```js
const connection = new anchor.web3.Connection(configs.networkEndpoint)
```
```js
 provider = new anchor.Provider(connection,genesisAdminKey,anchor.Provider.defaultOptions())
```
That would mean you're somehow not setting up your provider correctly
removed "confirmed" from connection constructor
What part did you have to change though to fix the preflight issue? I wasn't sure from reading your code why that happened
docs are all over the place. Even the official doc contains outdated info smh
And yes, lol, lots of people have built clients üòõ
What fixed the preflight issue?
has anybody has ever successfully build a client?
solved the preflight issue. Now showing ```TypeError: this.wallet.signTransaction is not a function```
please dont crosspost
What development env do people use? I'm on windows and running into so many issues.
any help would be appreciated üôè
```#[derive(Clone, AnchorSerialize, AnchorDeserialize)]
pub struct Decimal {
   pub value: i128,
   pub decimals: u32,
}

impl Decimal {
   pub fn new(value: i128, decimals: u32) -> Self {
       Decimal { value, decimals }
   }
}

#[account]
pub struct Data {
    pub sol_data: Decimal,
    pub eth_data: Decimal,
}
‚Ä®#[derive(Accounts)]
pub struct Execute<'info> { 
   #[account(init, payer = user, space = 8 + 20 + 20)]
   pub data: Account<'info, Data>,
   #[account(mut)]
   pub user: Signer<'info>,
   pub chainlink_sol_feed: AccountInfo<'info>,
   pub chainlink_eth_feed: AccountInfo<'info>,
   pub chainlink_program: AccountInfo<'info>,
   #[account()]
   pub system_program: Program<'info, System>,
}```
hey there! I've been scratching my head over this error - Error: 2012: An address constraint was violated‚Ä®I suspect its how I‚Äôm initialising the account?
oh wow cool, thanks!
It will be a bit of a pain, but `connection.simulateTransaction` returns all of the accounts you passed in
My own fault for using windows I guess, thanks anyway!
You could check here though to learn the basics: https://book.anchor-lang.com/
id really like to simulate a transaction and then look at the changes in the struct.

does anyone know how to do that?
Sorry, I haven't actually looked at any docs in a while, so I'm not sure where they are‚Äîgenerally speaking though the type annotations should tell you what to do
entrypoint invocations are not working. Can you link me up to the latest doc?
I followed this youtube tutorial - https://www.youtube.com/watch?v=joT1xAuU0hI&t=2735s&ab_channel=DougAnderson
That snippet has a mix of old and new syntax, so I'm kind of surprised any of it would work
Are you able to run any of your functions?
Unfortunately none of us work on windows, so not sure üò¨ But this looks like a general cargo thing, not an anchor thing
Just bumping this, still stuck.
this literally is the client
i think so. But don't really know why preflightCommitment is undefined
What does? I would expect what <@!185307556032413697> suggested would work
that returns an obj def not base58 string
It's that `tx` variable
```UnhandledPromiseRejectionWarning: TypeError: Cannot read property 'preflightCommitment' of undefined```
```
await program.methods.initialize().accounts({
  stakeAccount : stakeAccountKey.publicKey,
  counterAccount : counterAccountKey.publicKey,
  genesisAdmin : genesisAdminKey.publicKey,
  systemProgram : anchor.web3.SystemProgram.programId
}).signers([genesisAdminKey]).rpc()
```
can you direct me to a doc or something?
```json
  "instructions": [
    {
      "name": "initialize",
      "accounts": [
        {
          "name": "stakeAccount",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "counterAccount",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "genesisAdmin",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": []
    },
```
Ahh, I guess you are using the new CLI version, in that case you gotta split up accounts and signers (just like .rpc())
```js
     await program.methods.initialize({
          accounts : {
            stakeAccount : stakeAccountKey.publicKey,
            counterAccount : counterAccountKey.publicKey,
            genesisAdmin : genesisAdminKey.publicKey,
            systemProgram : anchor.web3.SystemProgram.programId
          },
          signers : [genesisAdminKey]
        
      }).rpc()
```
```js
Error: provided too many arguments [object Object],[object Object] to instruction initialize expecting:
```
It's coz you haven't invoked it. Chain with an `.rpc()` at the end. So it should look like this
```
const txHash = await program.methods.initialize(
  // all the required stuff
).rpc()
```
That's how the transaction is actually sent.
Hey! <@!134416332509675520>  I'm trying the escrow program and I'm based on your quidproquo project, I'm having problems with the method of canceling the offer and returning the tokens to the maker, I don't get any errors in the instruction, just checking the status of the vault (PDA) keeps the tokens and does not close the PDA account


//////////////////////////////////////////////////////////////////////////////////////////

```rs
    pub fn stake(ctx : Context<Stake>,amount : u32) -> Result<()>{
        let token_account = &mut ctx.accounts.token_account;

        Ok(())
    }
```
error! already adds source information for custom and anchor internal errors
how to check for a token accounts delegate?
no, you don't
Or do I still need to add a `.source()` method call
so does `Err(error!(...))` generate something with a source?
how do you install anchor on cmd
still unclear without a program log tbh, but that's a lot better than just a number, or a panic lol
thank you so much, ye this one was clear
i was looking at master branch like ;-;
The latest version of anchor has way, way nicer errors
https://github.com/project-serum/anchor/blob/v0.18.2/ts/src/error.ts#L71
these errors are so vague like ü§ï
what is 0x92 error in anchor??
ü•≤
Hmm thank you for your time tho.
I wouldn't expect that to make a difference, so not sure off the top of my head what would cause the problem ü§î
Does this make difference?
with confirmed commitment
and connection is devnet
its pretty same
```js
export const setup = (connection, wallet) => {
    const provider = new anchor.Provider(connection, wallet);
    anchor.setProvider(provider);

    // Address of the deployed program
    const escrowProgramId = new anchor.web3.PublicKey(myapp.metadata.address);

    // Generate program client from IDL
    const escrowProgram = new anchor.Program(myapp, escrowProgramId);

    return escrowProgram;
}
```
i have wallet passed instead of the new account
but on front end
so this is on backend
```js
const setup = (connection) => {
    const provider = new anchor.Provider(connection, new Account(require("../rootDir/my_wallet.json")));
    anchor.setProvider(provider);

    // Address of the deployed program
    const escrowProgramId = new anchor.web3.PublicKey(myapp.metadata.address);

    // Generate program client from IDL
    const escrowProgram = new anchor.Program(myapp, escrowProgramId);

    return escrowProgram;
}```
on front end im using wallet account
on backend i have admin account (this one works after some delay...)
Lol
Heh
slight variation
Like, same connection settings etc.?
yes
Mm... hmm. Literally the same?
error
on backend im geting account doesnt exist
same
Ok, and how are you doing it on the backend?
```js
let result;
try {
  result = (await program.account.trove.fetch(data.troveAccountPubkey));
  console.log(result, "result is this");

} catch (err) {
  console.error(err)
}
```
How are you fetching it on the frontend to check that?
But when i called backend, I made sure that the data fetch has value ..
Ye it work like if I have delay
Ye true.. most of the time there is simple solution.. I have different wallet connection but that shouldn't be any issue.
Etc.
Meaning, is it just a confirmation issue?
E.g. what happens if you sleep for 10 seconds and then *then* do the backend fetch?
(That might be incorrect, but it's probably true)
I'm just saying, assume that there will be some simple explanation for the behavior you're seeing
Same network as in
Anchor itself doesn't really do anything when you fetch, it's all just web3.js stuff
Are you 100% sure you're fetching from the same network etc.?
ü•≤
Oh yes. It works that way .. I just didn't wanted to do that haha
yeah, you can
Im passing the data that I get in front end to the backend instead ..
Just when I make call on vackend
Yes but its not coz of that. Im able to recieve the data on front end
you can use it like this `.rpc(confirmOptions);`
Solana cookbook
do you have an example?
Yes
hey guys is it possible to pass in an account's pubKey as seed to find PDA
Havent used that function for any of me txs
Lack of anchor knowledge ..
After I migrated to anchor, everythings a mess ü•≤
When I wasn't using anchor, it used to work just fine..
Web3 connection with confirmed commitment
Im not using provider for connection
ü•≤
Ye its on confirmed
you can do something like this, 
```
    let t = await provider.connection.getTransaction(tx, {
      commitment: "confirmed",
    });
```
It's generally happens, btw what's your commitment level?
üò∂
Just try to fetch data after the tx is completed.then i make a backend request to fetch the account data. And it gives me saying account doesnt exist like wtf..
Hi, I got this anchor fetch in client issue  and its bugging the shit out of me...
U r missing the correct signer for that transaction to proceed.
is there more in-depth documentation for `#[interface]` ? the things I'm wondering about:

1) the docs mention implementing the trait for a struct marked as `#[state]`, but this attribute is deprecated, what can be used instead? I tried `impl MyTrait for program::MyProgram` but then no arm was generated in the dispatch for the instruction... (I still used it and it seems to work just fine tho, and I checked code generation and there doesn't seem to be any extra stuff that I don't want)
2) in the example the trait is declared generic over an `T: Accounts + ...` but can't we specify a concrete type instead? I mean I was able to, but the generated `trait::method` doesn't make use of the concrete type...
also, the method enforces the `Accounts` bound again, which is stricter than the bound of `CpiContext`, so it's not possible to use the generated structs (more on that later)
3) having specified a concrete type for MyTrait's `Accounts` (`MyAccounts`), it seems that `MyAccounts` is present in the crate, but no other "helper" structs are, like the ones present normally in `cpi::accounts`.
I dug around and these structs are generated but simply not re-exported in any modules:
`__cpi_client_accounts_my_accounts::MyAccounts` for example... the generated docs mention it being re-exported but it's not really...

---
now that I think about it, I'm not quite sure this is appropriate for this channel üòÜ
ah nvm just passing in signer seeds wrong lol
the account whos signer priveldge has been escalated is the account which I am trying to create, which is passed into the program from client, it cant be passed as a signer since its a PDA, so I it makes sense this error is trigerring, is there a way around this?

getting this log
yes is that hahah ty
https://docs.rs/anchor-lang/latest/anchor_lang/prelude/derive.Accounts.html#instruction-attribute
Ah, one issue I see is that you aren't using the #[instruction(...)] macro correctly‚Äîit needs to match the order of the arguments to the instruction function!
tyty!
Yep, and you have to get the space exactly right (can jump to source to see how big its supposed to be, but it happens to be https://github.com/solana-labs/solana-program-library/blob/master/token/program/src/state.rs#L129
and setting owner to token program id
this is achieved by  anchor_lang::solana_program::system_instruction::create_account right?
And then, yeah, cpi to the token program with the initialize_account instruction
ah okok great
And then you'd need to first talk to the system program to allocate an account with program owner = the spl token program + space = 165
yup i am passing in the accountInfo struct for the dersired new accountfrom remaining_accounts
all the logic?
where is the program log? üòÖ
(That's a weird other type of address, neither keypair nor PDA‚Äînot what you want)
Nope, you'd need to pass in the desired address from the client
hey all I am trying to create a token account that lives at the current programs PDA, but I want it to be derived using some seeds that I assign. I am also using remaining accounts so cant use anchors beautiful macros, is ``` anchor_lang::solana_program::system_instruction::create_account_with_seed ```  followed by ``` &spl_token::instruction::initialize_account``` the right way to do this?
Ah, no, the program log, not the stack trace from JS
1) escrow send to vault:
     Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account
      at Connection.sendEncodedTransaction (node_modules/@solana/web3.js/src/connection.ts:4052:13)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at Connection.sendRawTransaction (node_modules/@solana/web3.js/src/connection.ts:4014:20)
      at sendAndConfirmRawTransaction (node_modules/@project-serum/anchor/src/provider.ts:286:21)
      at Provider.send (node_modules/@project-serum/anchor/src/provider.ts:120:14)
      at MethodsBuilder.rpc [as _rpcFn] (node_modules/@project-serum/anchor/src/program/namespace/rpc.ts:24:16)
Can you post the full program log? (lol)
running build anchor returned
```
Failed to install bpf-tools: A required privilege is not held by the client. (os error 1314)
```
Can't find the solution to: Cross invocation of programs with unauthorized signer or writable account
<@!134416332509675520>  <@!347689664855015424>   

So I've found what breaks my anchor test suite for all the programs.

When I mean break importing programs from workspace fails test/client without any error messages for all programs.

Compiles and deploys but breaks everything:
```#[account]
pub struct Proposal { 
    pub question: String,  // 
    pub answers: Vec<(String, u32)>, 
    pub deadline: u64,
    pub winner_idx: u8,
}```

Works as expected and other tests work:
```#[account]
pub struct Proposal { 
    pub question: String,  // 
    pub deadline: u64,
    pub winner_idx: u8,
}```

Is this desired behaviour or are vectors not allowed, but I missed it somehwere? 

Either way took me a while to debug it as it was breaking all my other tests, if vectors aren't supported I'd maybe have an error message.

If they are would love to see the correct implementation.
The idea though is that closing accounts is unfortunately a bit tricky in solana. You would think all you need to do is have your program drain the account's lamports, but that's unfortunately not the case: a sneaky client could include an extra instruction in the transaction that *re-funds* the account's rent after you thought you had drained it. So, in addition to trying to drain the lamports, you also need to somehow mark the account's data in such a way that you know you tried to close it, in case a sneaky client zombiefies one of your accounts. The way anchor does this is by swapping out the account's original discriminator bytes for 0xffffffff.
No, it's an anchor specific thing
interesting, what is the close account discriminator is this value universall across all solana programs, so a check is included when these are accounts are passed and it is checked if the account is closed or not ?
any idea what oracles are in use in the solana defi space and what is the process to your token listed on there oracle if anyone has gone through a similar process and can share here, would really appreciate it
sorry for the bother
ok, fixed it. Had to add `mod account;` in lib.rs
sure thanks:
```rust
use crate::account::*;
use anchor_lang::prelude::*;
use anchor_spl::associated_token::AssociatedToken;
use anchor_spl::token::{Mint, Token, TokenAccount};
```
can you share all imports / use from the context.rs file please?
what am I missing?
I have a `context.rs` file and an `account.rs` file. At the top of  `context.rs` I have `use crate::account::*;` just like in the misc example. However I get an `unresolved import` error
I have a feeling it's because of a `RefMut` account I'm passing into my CPI. I tried calling `to_owned()` on it but that just caused other errors.
Running into this error, anyone know offhand what causes it? `solana.rpc.core.RPCException: {'code': -32002, 'message': 'Transaction simulation failed: Error processing Instruction 0: instruction tries to borrow reference for an account which is already borrowed', 'data': {'accounts': None, 'err': {'InstructionError': [0, 'AccountBorrowFailed']}, 'logs': ['Program AQPDVpAsDtd8cfXVjrUEKrhchF4cYwST2wyq3tJa82ci invoke [1]', 'Program log: Debugging', 'Program log: 3', 'Program log: Failed to borrow a reference to account data, already borrowed', 'Program AQPDVpAsDtd8cfXVjrUEKrhchF4cYwST2wyq3tJa82ci consumed 13081 of 200000 compute units', 'Program AQPDVpAsDtd8cfXVjrUEKrhchF4cYwST2wyq3tJa82ci failed: instruction tries to borrow reference for an account which is already borrowed'], 'unitsConsumed': 0}}`
Yeah, it's just a dummy id
every time I run `anchor init`, it initializes a project with the same program ID. is that supposed to happen?
from rust itself (anchor lang?), can call all the accounts from react and use filters with anchor web3, im just new to rust and need to edit a program
```program.account.state.all(filter)```
Hi, i was wondering how i could do something like this
what would the "length of string in bytes" be?
don't forget the account discriminator as well (8 bytes)
https://book.anchor-lang.com/chapter_5/space.html
is there a doc somewhere that shows the space requirements for creating PDAs with init?
Hey is there any equivalent of the Python `eval` function in Rust / Solana? Right now, I'm trying to pass in a String representing a function name of a program and its respective program ID into my function `run_program_function` along with some parameters for the function. I want to invoke the function of the program with something like this:

`eval(passed_in_program_id, passed_in_function_string, [param1, param2, ...., paramN])`

Is there any way to do this?
Hi, what could be some reasons I'm getting a Other(Failed to get account)? If I check explorer on devnet I can see the account, and I know it's an anchor account because if I try to call load_account instead it gives me expects account size x, actual account size x+8
These days with Solana/Anchor it fells like the holy ghost itself is punishing me..

Is there an anchor limit to how many subprograms you can have?

This is my ```Anchor.toml```

```
[features]
seeds = false

[provider]
cluster = "localnet"
wallet = "/Users/chavka/.config/solana/id.json"

[programs.localnet]
example1 = "GbQktab2MXL8JzCYbp7zafGCCF6e9jopoy31bfECZWpP" 
example2 = "CCqjVaJ2P5rPtwwH3p6Bg18DG5Whmj5TQSCHRiCezTon"
example3 = "DTkZgGrsNqC34o38M4Kq4KHzzuh2aZu9CBjbNkpwhPBi"

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"
test1 = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/test_example1.ts"
test2 = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/test_example2.ts"
test3 = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/test_example3.ts"
c2 = "yarn run ts-node  app/client2.ts"
c1 = "yarn run ts-node app/client1.ts"

```
If I compile, deploy and test this, any test will give me for   ```console.log("anchor: ",anchor)```:



```  anchor:  {
  BN: [Getter],
  web3: {
    Account: [class Account],
  ...

  Spl: [Getter],
  workspace: {},            // EMPTY
  Wallet: [class NodeWallet]
}```


If I nuke the whole directory that contains ```/example3``` and remove ```example3 = "DTkZgGrsNqC34o38M4Kq4KHzzuh2aZu9CBjbNkpwhPBi"```  I will be able to compile, deploy and crucially test without any problems with nothing being changed for example1 and example2 in Anchor.toml and respective directories (besides new program IDs after redeployment).  


There being some cap on program seems possible, but kind limiting and not documented. Otherwise it could be something in my ```/example3``` directory that is somehow making anchor unable to fetch the workspace data, but nothing obvious springs to mind. Not sure, but will debug further tomorrow.
What would be the best practice to mock popular tokens (raydium, wETH, usdt, etc.) locally? Would you just create token accounts/mints and call them when needed?
Don't worry, doubt it's a ghost lol. Hmm
There isn't an error!

Just running

```  console.log("anchor: ",anchor)```

Gives

```
  anchor:  {
  BN: [Getter],
  web3: {
    Account: [class Account],
  ...

  Spl: [Getter],
  workspace: {},            // EMPTY
  Wallet: [class NodeWallet]
}
```

So test quite with workspace being empty

#[program] is also correct accross .rs files.

Everything was fine until it wasn't and I didn't modify Anchor.toml or lib.rs.
And make sure your `#[program]` module has the same name etc.
Can you post the actual error you get?
Yeah it is, I posted it from mismatched commits...

This is how in file import look slike:

```const provider = anchor.Provider.local();
anchor.setProvider(provider);
const program = anchor.workspace.Example1;  // or Example2

```
Those program names will have to match, so here `example1` != ex1
```[features]
seeds = false

[provider]
cluster = "localnet"
wallet = "...<USERNAME>/.config/solana/id.json"

[programs.localnet]
example1 = "6LjetdJE2k9T5eoi25jEqw2qWma9aXWQSgcwYb9gB17p"
example2 = "CwWmug2yQwcNFGNtBkLj6Ex2CpXbeqE3WU2ntw8BYe55"

[scripts]
test1 = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/test1.ts"
test2 = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/test2.ts"
c1 = "yarn run ts-node app/client1.ts"
c2 = "yarn run ts-node  app/client2.ts"
```
What does your Anchor.toml look like?
My workspace seems to disappeared or is unable be able to be loaded again when running any of the anchor scripts.

I reverted to a previous commit in case it's code additions that did it, but issue still persists.

This is how I load the environment in the test.ts:

```const provider = anchor.Provider.local();
anchor.setProvider(provider);
const program = anchor.workspace.Ex1;```

I have run ```anchor clean``` and deleted rust cache at:

``` rm -rf ~/.cargo/registry/index/*
rm -rf ~/.cargo/.package-cache```

Any ideas how to debug further or what could have caused it?
https://solana-labs.github.io/solana-program-library/token/js/modules.html#closeAccount
also i just realize I don't want to close the full account haha. this stuff is really funky
but in typescript xD
Yeah, that would be the one
unwrapping all of the SOL is ok, i'm just having trouble finding an appropriate instruction in typescript... only found this in rust so far: https://docs.rs/anchor-spl/latest/anchor_spl/token/struct.CloseAccount.html
as long as you use `UncheckedAccount`, you can copy the `close` function from our repo. `lang/src/common.rs`
It gets insane when gas price is high (>$300). The burden is on the end user tho who runs the tx
Actually, damn, eth storage is pretty expensive! Wow, I had never run the numbers before‚Äîaccording to that post, storing 1kb currently costs about $100 üòØ On solana it's more like $1.
but what about the code to manually close the account, that is what is not clear to me üò¶
`pub token_trade_account: Account<'info, TokenTradeAccount>`
so instead of this i use UncheckedAccount.
that would be awesome üôè  well then i was not wrong in not finding any solution online.
youll be able to just do account.close() once https://github.com/project-serum/anchor/issues/1703 is merged
`pub fn token_trade(
        ctx: Context<TokenTrade>,
        trade_quantity: u32,
    ) -> ProgramResult {

        let token_trade_account = &mut ctx.accounts.token_trade_account;
        token_trade_account.trade_quantity -= trade_quantity;

        if token_trade_account.trade_quantity == 0 {
            /// Close account here
        }
        Ok(())
    }

#[derive(Accounts)]
#[instruction(trade_quantity: u32)]
pub struct TokenTrade<'info> {
    #[account(mut)]
    pub initializer_main_account: AccountInfo<'info>,
    #[account(
        mut,
        constraint = token_trade_account.initializer_key == *initializer_main_account.key,
    )]
    pub token_trade_account: Account<'info, TokenTradeAccount>,
}

#[account]
pub struct TradeAccount {
    pub initializer_key: Pubkey,
    pub trade_quantity: u32,
}`
üòÆ everything what you say here is just beyond me üò¢ let me give a code sample. Would be really great if you could show how to do it üôè
if you want to close conditionally, you have to close manually and make sure *not* to use a type that sets the discriminator at the end (because it will set the discriminator to the non-closed one again). TLDR: use `UncheckedAccount`, not `Account<'info, T>` and if it's an anchor acc of your program, set the discriminator to the CLOSED one yourself
true
If it's one of your own accounts, you'll have to manually drain its lamports yourself, plus zero out the account's data. <@!347689664855015424> what's the state-of-the-art way to do this now?
<@!134416332509675520> could you please help me out here?? I am really stuck, can‚Äôt find any good answer on internet üòì
At the end of the day, storing large amounts of data on a blockchain is going to cost you a lot of money regardless of where you store it
It might not strictly speaking have any rent, but it definitely costs money to store stuff on ethereum https://ethereum.stackexchange.com/questions/872/what-is-the-cost-to-store-1kb-10kb-100kb-worth-of-data-into-the-ethereum-block
an eth smart contract can store 2^256 bytes of data without any rent. If the same contract be implemented in sol with 10mb data storage, the rent is like 0.199817492 SOL per epoch, how to get around it without sacrificing the decentralization?
Hey guys, I really need some help, been trying to figure this one out for past few days.
So I have a custom struct Account, which saves some data.. I use this account few times to read and write data to it. Now I want to close this account, I know that we could use #[account(mut, close=beneficiary)] can close the account. But I want to close the account only when a condition is met. How can I do this?

I am generating the key for the account from frontend and then use #[account(zero)] to initialize it.

I tried using token::CloseAccount but not sure who is the authority/signer for this account. Any help would be really great üôè thanks a lot in advance.
Alright, is it possible to retrieve logs of a solana instruction then ? if event is just a log and logs are retrievable i could make that work.


//////////////////////////////////////////////////////////////////////////////////////////

so i was trying to understand how pyth should be used and got referred to drift protocol, can anyone who has used oracles explain why is drift doing this scaling ? 
```    pub fn get_pyth_price(
        &self,
        price_oracle: &AccountInfo,
        clock_slot: u64,
    ) -> ClearingHouseResult<OraclePriceData> {
        let pyth_price_data = price_oracle
            .try_borrow_data()
            .or(Err(ErrorCode::UnableToLoadOracle))?;
        let price_data = pyth_client::cast::<pyth_client::Price>(&pyth_price_data);

        let oracle_price = cast_to_i128(price_data.agg.price)?;
        let oracle_conf = cast_to_u128(price_data.agg.conf)?;

        let oracle_precision = 10_u128.pow(price_data.expo.unsigned_abs());

        let mut oracle_scale_mult = 1;
        let mut oracle_scale_div = 1;

        if oracle_precision > MARK_PRICE_PRECISION {
            oracle_scale_div = oracle_precision
                .checked_div(MARK_PRICE_PRECISION)
                .ok_or_else(math_error!())?;
        } else {
            oracle_scale_mult = MARK_PRICE_PRECISION
                .checked_div(oracle_precision)
                .ok_or_else(math_error!())?;
        }

        let oracle_price_scaled = (oracle_price)
            .checked_mul(cast(oracle_scale_mult)?)
            .ok_or_else(math_error!())?
            .checked_div(cast(oracle_scale_div)?)
            .ok_or_else(math_error!())?;

        let oracle_conf_scaled = (oracle_conf)
            .checked_mul(oracle_scale_mult)
            .ok_or_else(math_error!())?
            .checked_div(oracle_scale_div)
            .ok_or_else(math_error!())?;

        let oracle_delay: i64 = cast_to_i64(clock_slot)?
        .checked_sub(cast(price_data.valid_slot)?)
       .ok_or_else(math_error!())?;

        Ok(OraclePriceData {
            price: oracle_price_scaled,
            confidence: oracle_conf_scaled,
            delay: oracle_delay,
            has_sufficient_number_of_data_points: true,
        })
    }
```
what a weird issues, any guess why it occurs?
but need to install the same version as anchor(0.23.0) have `solana-program = "1.8.16"`
though it solves the problem, xD
No NFTs, but drift uses oracles: https://github.com/drift-labs/protocol-v1
Hmm not sure what's up with that, the pubkey macro definitely exists: https://docs.rs/solana-program/1.8.14/solana_program/macro.pubkey.html
are there any open source apps that uses anchor? I'm looking for 

1. programs used to Mint NFTs
2. Anything that uses an oracle
but `solana-program` is in the mod scope, it's just macro is not
And then do `solana_program::pubkey!`
Oh, hmm, maybe that's a bug‚Äîyou can probably also just add a dependency to your programs/<prog-name>/Cargo.toml on `solana-program`
You're right, I can't find it too.
or am i missing something here?
In the latest version of anchor "0.23.0". It is not working, right?
```
failed to resolve: could not find `solana_program` in the list of imported crates
not found in `solana_program::pubkey`rustc(E0433)
lib.rs(36, 35): not found in `solana_program::pubkey`
```
You can use the `pubkey!` macro:
```.rs
const THE_ADDRESS: Pubkey = anchor_lang::solana_program::pubkey!("adsfasdfasdf");
```
What's the standard way to hardcode some account addresses in a program? There's a way to do it using creating a file and then `declaring_id` inside it, but that's semantically declaring ID of a program right? So any more "semantic" way to do it?
Not in general, only if you really are going to mutate it
one of them should have the resource on it.
https://solana.com/riptide/resources <@445019022338031618> check this one out
but there are heaps of other resources
somewhat helpful..
try the anchor book
any good resources on the anchor client for rust ?
thats the only reason i can think for making it mutable
and it will change the sol balance in the account ..
coz you paying transaction fees from it
u do actually need to have it on mut
oh yes
I saw somewhere that Signer type need to mark as mut (cannot remember where maybe in changelog)
yea i vaguely recall having to mark them as mutable
although i have it on mut.
unless u are changing something in that account
dont think so tbh
pumping new changes like flies.. ü•≤ . Ye true there will always be new improvements, just hassle while upgrading haha..
is a signer required by solana to be a mutable account?
If it aint broke, you can always just use a fixed package.json dependency (though the new api is nice/easy to use)
Lol
oh shitt...
I assume no
oh i see. thank you so much. will it be supported in all the new versions later ??
It's fine, you can still use it lol, but the new way is `program.methods.yourInstruction(arg1, arg2).accounts({ ... } ).instruction();`
the instruction bit?
why is program.instruction is deprecated.???
ü•¥
my brain is lagging, i had it like that on my other import, idk y i did it that way in my reward import ...
ü•≤
it worked, was about to post it haha
ye just tried that
`const anchor = require("@project-serum/anchor");`
```const {anchor} = require("@project-serum/anchor");
```
ü§ï ü•≤
y is it showing me anchor undefined..
tried to import that module..
i had anchor installed with ``npm install @project-serum/anchor``
`ctx.program_id`
How do I access the current program ID the anchor way?
üò∂‚Äçüå´Ô∏è
hmm seems like my anchor import is showing undefined lool like dafaq...
That's it, thanks.
More like
```.rs
let hmm: Account<Thing> = Account::try_from(&acct)?;
```
How to unpack accounts in a loop and use them?

``` let acct_vec: Vec<AccountInfo> = ctx.remaining_accounts.to_vec();        
    for (idx, acct) in acct_vec.iter().enumerate() {
       let tmp: Account<Acct> = // SOEMTHING HERE
    }```

I know I  need some sort of a cast from `AccountInfo` into an instance `Account<Acct> ` but not sure how to do it.
ok sorry
Hey, please don't cross-post üôè
error log :
```
server          | TypeError: Cannot read property 'BN' of undefined
server          |     at createAddRewardIx (/app/server/services/program.js:151:89)
server          |     at processTicksAndRejections (node:internal/process/task_queues:96:5)
server          |     at async claimReward (/app/server/commands/claimReward.js:50:21)
server          |     at async addReward (/app/server/controllers/rewardController.js:31:13)
```
passing the argument for the instruction ...
Hi, when i try to pass the ```new anchor.BN(value) // where the value is 0``` , it gives me undefined error..
OMG thanks so much for the help! <@!242234529396424704>
https://solanacookbook.com/references/programs.html#how-to-transfer-sol-in-a-program for transferring sol
<@165098054792249344>
use the solana way to do that
you dont need that
```let ix = anchor_lang::solana_program::system_instruction::transfer(
        sender,
        receiver,
        amount,
    );
    
    anchor_lang::solana_program::program::invoke(
        &ix,
        &[
            ctx.accounts.sender.to_account_info(),
        ]
    );```
Hi guys, I am trying to store an account with the pubkey of a SystemProgram, and attempt to transfer lamports to it later on. 
This is what I am trying to do when sending over the lamports.
```
pub fn transfer_to_lamport_receiver(ctx: Context<TransferLamports>, avail_amount: u64) -> Result<()> {
    let sender = &mut ctx.accounts.sender.key.clone();
    let receiver = &mut ctx.accounts.receiver.receiver_pubkey.clone();
    let amount = ctx.accounts.receiver.amount.clone();
    if amount > avail_amount {
        panic!()
    }
    let ix = anchor_lang::solana_program::system_instruction::transfer(
        sender,
        receiver,
        amount,
    );
    
    anchor_lang::solana_program::program::invoke(
        &ix,
        &[
            ctx.accounts.sender.to_account_info(),
        ]
    );
    Ok(())
}

#[derive(Accounts)]
pub struct TransferLamports<'info> {
    #[account(mut)]
    sender: Signer<'info>,
    #[account(mut)]
    receiver: Account<'info, ReceiverLamportDetails>,
    pub system_program: Program<'info, System>,
}

#[account()]
pub struct ReceiverLamportDetails {
    pub amount: u64,
    pub receiver_pubkey:Pubkey,
}
```

This is the error logs I am thrown, GMb5CVKKUgZPbbn1AusrtGgKvpQwwsFgSXzrtLzy1dwH is the account I want to send lamports to
```
Transaction simulation failed: Error processing Instruction 0: An account required by the instruction is missing 
    Program HS59oAVB73bP2gnrU3eeaUfGkpQwoBLsByMH7AAwsCwe invoke [1]
    Program log: Instruction: TransferLamports
    Program log: 7dojGo6ykwwPEAdiX3DNc758kFj8qCeSuskxrraLHWCH
    Program log: GMb5CVKKUgZPbbn1AusrtGgKvpQwwsFgSXzrtLzy1dwH
    Instruction references an unknown account GMb5CVKKUgZPbbn1AusrtGgKvpQwwsFgSXzrtLzy1dwH
```

Could someone help, thanks for reading!
Tanks for the clarification, so solana added this at some point. Good to know.
Solana lets you just do `Clock::get()?` now, but some older contracts still require you to explicitly pass in the clock sysvar account
Hello everyone,  I see on some contracts that they send clock account from the client I have never done it but I'm still be able to use `Clock::get()?.unix_timestamp` and work so far.
Does anchor handle this or how can both work now? I will inquire but wanted ask here if there is a quick answer here.
or other way: how should I retrieve a value of a struct's field in typescript if using `program.accounts.pool.fetch(poolAddress)` gives me corrupted data?
In a given context, will accounts be only initiated if all all the constraints are satsified for all of the accounts or would an account be initialised, but then transaction be reverted on the second account macro where conditions weren't met?
maybe you could know another approach to implement it?
Hey.... Since an nft in Ethereum is pretty much a smart contract that inherits the ERC721 contract, we can add custom attributes to our nft. Is it possible to do similar stuff in solana?
Found an interesting resource 

https://husobee.github.io/money/float/2016/09/23/never-use-floats-for-currency.html

Mentioned in one of Soteria‚Äôs blog
Yeah got it.
zero_copy unfortunately doesn't work well with js deserialization, I'm actually not sure what the recommended fix is though
The non-float alternative there is to upcast to u128, multiply by 3 and then divide by 10, then downcast back to u64 (I think)
<@!134416332509675520> or what about using the methodology Metaplex uses to compute royalties in terms of basis points?
So I want to implement a functionality taking % of variables. 

For example: 

User_balance: 1mil

Multiplier: 0.3 (30%)

Amount: 0.3*user_balance = 300k

Something like this

I was thinking to set the variables multiplier and amount as f64 so that multiplication is possible
Is something going wrong currently? Solana just doesn't have much float support, so you may have to find another way
Hi all! I have a problem prob with serialization. I have such struct:
```
#[account(zero_copy)]
#[repr(packed)]
#[derive(PartialEq, Default, Debug)]
pub struct Pool {
    pub token_x: Pubkey,
    pub token_y: Pubkey,
    pub pool_x_account: Pubkey,
    pub pool_y_account: Pubkey,
    pub admin: Pubkey,
    pub project_owner: Pubkey,
    pub token_x_reserve: TokenAmount,
    pub token_y_reserve: TokenAmount,
    pub self_shares: TokenAmount,
    pub all_shares: TokenAmount,
    pub buyback_amount_x: TokenAmount,
    pub buyback_amount_y: TokenAmount,
    pub project_amount_x: TokenAmount,
    pub project_amount_y: TokenAmount,
    pub lp_accumulator_x: TokenAmount,
    pub lp_accumulator_y: TokenAmount,
    pub const_k: Decimal,
    pub lp_fee: Decimal,
    pub buyback_fee: Decimal,
    pub project_fee: Decimal,
    pub bump: u8,
}
```
I set value of `2_000_000_000` for `lp_fee` field, however after fetching the structure in typescript using `program.account.pool.fetch(poolAddress) I get a fixed, but random value for this field. I think it's about serialization.
I would appreciate any help
Hey guys! How do I perform math safe function calls like checked_mul on type f64? Any idea? Thanks üôÇ
the name itself does nothing at all, info is just the name of the lifetime, it could be a, b, c ,d...
Hi guys, am working on a buildspace project allows users to add gifs and vote on their favourite ones. I have deployed and tested on devnet with a test script, but now have issues when pointing my frontend (repl.it) to the updated contract (I have uploaded the new idl data). What am I doing wrong? My test script is in firstproject.js, my rust contract is lib.rs. The key differences between the old working contract and this one is the addition of the vote function and updated custom struct with "votes" to store the votes. The createGifAccount function looks like this:
```const createGifAccount = async () => {
    try {
      const provider = getProvider();
      const program = new Program(idl, programID, provider);
      console.log("pinged");
      await program.rpc.startStuffOff({
        accounts: {
          baseAccount: baseAccount.publicKey,
          user: provider.wallet.publicKey,
          systemProgram: SystemProgram.programId,
        },
        signers: [baseAccount]
      });
      console.log("Created new BaseAccount w/ address: ", baseAccount.publicKey.toString());
      await getGifList();
    } catch (err) {
      console.log("Error creating BaseAccount: ", err)
    }
  }```
ok. dm it works. was doing something else stupid
What is the template for asserting within typescript tests that an invalid transactions gets rejected?

I've tried it with try/catch as a hacky way but it still marks the test failure despite failure being desired.
yeah figured it out, I thought there was a way to specify arguments so you dont mess up the order just like with accounts but apparently not. thanks
It's just not coming over right
I think it is too. I'm simply just trying to print a `msg!` of data from the non-anchor account and I am still getting the same error.
has anyone ever seen this during cargo run? only thing I can think of is I got this after running rustup update, but I reverted my update, cargo clean+run and this still occurs
https://docs.rs/solana-program/latest/solana_program/macro.entrypoint.html
it's the lifetime that comes from the entrypoint, https://docs.rs/solana-program/latest/solana_program/account_info/struct.AccountInfo.html
Right, I see it everywhere and I wanted to know the significance.
Maybe it doesn't need to though
hmm good question, I assume because in anchor everything that has `Account` has that lifetime so I just assumed it went there.
Digging through the code I'm thinking something to do with serialization, but want to make sure
Right, info is defined as the rust lifetime, but what does info itself do
I'd say more but I'm a rust beginner so I don't want to give misinformation üôÇ
https://doc.rust-lang.org/rust-by-example/scope/lifetime.html
Defines the rust lifetime
What does `<'info>` do on `AccountInfo<'info>`?
I was then going to do something like `Box<Account<'info, NonAnchorAccount>>`
General question about integrating Anchor programs with non-anchor programs. Here is my situation:

1. I am writing an Anchor program that is constructing a CPI call to a non-anchor program.
2. This Anchor program I am writing has to read an account from the non-anchor program first, to read information from it.
3. This information is then used to pass in to the CPI call from Anchor to the non-anchor.

I am getting access violations using the non-anchor account. Does this mean I need to implement `AccountSerialize`, `AccountDeserialize`, `Owner`, and `Copy` traits on the non-anchor account so I can read them in? I am beginning to think so but wanted to ask before I start doing all the work to implement that.
Basically I'm planning to switch my client repos from native jest to anchor (running mocha or jest, idc really) and wondering if there's any pitfalls I should be aware of ahead of time
I haven't hooked this up yet but like I assume the client can have easy access to the localnet anchor spins up for the duration of the test if I test via `anchor test` and such.
Are there best practices on leveraging anchor when testing client-side only code? I.e., not in a repo that holds smart contracts (though it can have access to any IDLs from such as needed)
hi fam,
its there an anchor resource(repro code) for creating daos?
https://github.com/project-serum/anchor/blob/master/cli/src/config.rs#L285-L288
is there a list somewhere of Anchor.toml [features] ?
Hey all, have a question related to CPI calls to Serum. Currently trying to place a NewOrderV3 CPI instruction but getting this error: `Program failed to complete: Instruction passed to inner instruction is too large (1342 > 1280)`
ya that's what the resolution here was. to check size of byte array not length of string
another option is `string.as_bytes().len()`
it's actually undefined behavior to have a non-utf8 `str`  in Rust üòõ
tysm <@!134416332509675520>
sick
instead of length of string
Right, the constraint is on the underlying raw bytes
I realized I can actually just put a constraint on byte size of string, right?
https://stackoverflow.com/questions/61909723/how-many-bytes-does-a-char-take-up-when-stored-in-a-string-slice
Ah, yeah, those still work in utf-8 üòõ
and other chars which use 3 bytes a pop
well in plain rust u can def use greek letters etc, no?
Thank You so much <@!347689664855015424> & <@!134416332509675520> I was able to successfully close my custom account with a condition. You guys are amazing <a:giphyraisedhands:909177775699681321> keep up the good work <a:rainbowlove:909177777041834006>
Strings in general in rust use utf-8.
Yeah, it would be utf-8
and it's limited to UTF-8 or something?
You can just store a String, yeah, plus make sure you give it enough space
What is the cleanest or most idiomatic way to store a `String` in an account? Is it to turn it into a zero-padded byte array? Or can I just store the `String` so long as the account has enough space?
or should I use test.genesis?
I want to have a different program available in the local validator anchor uses (token-metadata program specifically), do I just need to do this?
```
Anchor.toml:
[test.validator]
url = "https://api.mainnet-beta.solana.com"
[[test.validator.clone]]
address = "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"
```
just do 
```
await program.rpc.function(      
          arg1,arg2,arg3
        ,        
        {  
          accounts: {  // key name in IDL
            acc1: pda_1,         
            acc2: player.publicKey,       
            SystemProgram.programId,
          },
          signers: [player],      
      })
    );    
```
When calling method via rpc call with multiple arguments what is the syntax for passing those arguments in the client?

This doesn't quite work:
```
 await provider.connection.confirmTransaction( 
      await program.rpc.function(      
        args: {     // key name in IDL
          arg1: Buffer.alloc(1,4),
          arg2: false
        }
        ,        
        {  
          accounts: {  // key name in IDL
            acc1: pda_1,         
            acc2: player.publicKey,       
            SystemProgram.programId,
          },
          signers: [player],      
      })
    );    ```
bro can someone send a link to a anchor download tutorial because i get errors all the time
cheers
yus, you can `constraint=Clock::get()?.unix_timestamp > someXYZ`
don't see why not, you might need to specify the trait tho... `<Clock as solana_program::sysvar::Sysvar>::get().unwrap()`
thanks man
hey guys, is it possible to bring in clock (`Clock::get().unwrap();`) into anchor constraint?
```rust
use anchor_lang::solana_program::pubkey;
...
pubkey!("")
```
works also
yus
sick ty
correct?
and to verify the delegate pubKey is same as a particular pubKey 
```rs
ctx.accounts.token_account.delegate == anchor_lang::prelude::Pubkey::from_str("pubkey_string")
```
install WSL2, follow ubuntu install instructions
thanks
and for delegate amount `ctx.accounts.token_account.delegated_amount`
you can use `ctx.accounts.token_account.delegate`


//////////////////////////////////////////////////////////////////////////////////////////

i will try that then. thanks!
Yeah, can definitely imagine a slicker version of that but it's not implemented yet
You just call set_return_value in the one program and then subsequently retrieve it in the caller
get return value and set return value use the newly introduced solana syscalls which anchor does not have a abstraction for yet, if am not wrong.
I don't think there would be anything anchor specific
so how does this translate into a workflow for get_return_value with programs built with anchor? just looking for examples of that, if there are any?
see the memoy map used by solana, https://docs.solana.com/de/developing/on-chain-programs/overview
the deserialized account is at the stack which starts at 0x2000 , the input parameters passed by the runtime start at 0x4000 so what you actually is a deserialized version stored on the stack, you need to again look at the account at address 0x4000 and deserialize it again.
when you deserialize you create a copy on the stack , when u do a cpi and some state changes happen into the account, it happens in the account passed to you, in solana all these accounts reside at different memory addresses, so you need to again deserialize the account passed in the runtime to see the reflected changes, please feel free to correct me if am wrong <@134416332509675520>
is the reload pattern using the shared memory for return values?
i see.  what i am trying to create is a program that can consume an onchain data feed. each returned value should be a few hundred bytes max
as the return and set data is limited 1024 bytes , the reload pattern does not come under this restriction
Why better?
Ah, yeah, when you burn tokens you reduce the mint's `.supply` field (how many tokens are outstanding)
isnt the reload pattern better, but sure an example regarding this  new feature would be good too.
Do you know of any examples of `get_return_data` feature of solana when making CPI's in a program using anchor?
yeah the problem was that `mint` was not writable, not sure why we need it but making it mutable solved.
something like
```rust
#[account]
pub struct SomeAccount {

    pub data: u8,

    pub my_struct: MyStruct,
}

pub struct MyStruct {
  pub counter: u16,
  pub bytes: [u8, 32]
}
```
Yeah, I don't think anchor has a way to do that yet (the IDL generation in general is not super smart yet)
I assumed, since I have that crate as a dependency, that the type would be automatically included (or that anchor would provide a way to explicitly tell the compiler that I want that type)
not exactly clean code, and will have to keep track of any update
problem is I have to be recursive with this
(So, tedious but not super hard)
yeah, exactly
Ah, well, you may have to convert between your own MyDataV2 to the actual DataV2 type before serializing the instruction
How so?
I thought the same, but it's possibly gonna give me problems with CPI
Same fields etc., but your own struct
Mm, yeah, this will be kind of annoying but I think you're going to have to write your own little version of it üò¨
my struct that I'm passing as an instruction parameter
the type in question, I cannot touch this
How are you typing the rust side?
Hey, is it possible to use types from non-anchor programs as intructions parameters? I'm getting an IDL error saying it cannot find the type
User-defined how?
Sure, just need to sign with whoever has authority over the token account
Hi everyone,  is it possible to burn tokens in pda account (pda itself is not mint auth but only holds tokens, we want to burn the token it holds)
Is there an example somewhere of someone storing a user-defined struct in an account?
thanks will update! recommend using the book instead of the project-serum.github.io docs because we are sunsetting those
on both of these pages it states that CPI cannot return values: https://project-serum.github.io/anchor/tutorials/tutorial-3.html#signer-seeds

https://docs.rs/anchor-lang/0.2.1/anchor_lang/attr.interface.html
Nice thank you!
that should do it
```toml
[dependencies]
anchor-lang = {version="<version>", features=["init-if-needed"]}
```
how to enable `init_if_needed` feature on cargo? it says init_if_needed requires that anchor-lang be imported with the init-if-needed cargo feature enabled.
okay, thank you!
`my_thing.exit(ctx.program_id)?` I think
I remember reading about this some time ago
oh, right, how was that done? persisting the changes I mean
It's unfortunately a little trickier than that though, since if you want to subsequently write to the account (guess not in the stuff you're doing above) you have to manually persist the changes
If you want to get an `Account<'info, Thing>` out of the raw AccountInfo though you'd need to do something like
```.rs
let my_thing: Account<Thing> = Account::try_from(&the_account_info)?;
```
so, I should just be able to deserialize the account manually, no?
okay, true, only deserialized accounts need to be reloaded
AccountInfo's don't need to be reloaded, since they just point to their data (which gets updated by the CPI)
I read in the book about AccountInfo::reload(), but I can't find what to import in order to use it
oi, how can I reload an account after a CPI call and also update its type? For instance, I have an UncheckedAccount that I send to system program and the token program to create a mint. Then I want the type to be updated to Account<Mint> and the data to be reloaded
yus you can, it make sense for me
Hey guys!

If I‚Äôd want that only a particular address can update the field of a PDA account, 

Should it be okay if instead of having the update_auth field in the PDA struct,

I hardcode the address of update_auth in a separate file and then just add a constraint in the update func. whether the signer address is same as the hardcoded one? 



Because, I only want one particular address to be the update_auth over all the PDA instances, so hard coding helps save rent for that field throughout all the PDA instances
can anyone try this and let me know if it is work or not it might be an issue with my system thanks
https://github.com/Aurory-Game/comptoir.git
Hey it is possible for a wallet own by a solana program to refuse transaction "transfer"?
Could you elaborate on this how does this lterbative to float work nd when should it be used
time before jan 1970 will be negative value
btw any resources on how normalization work for example why are they converting i64 to i128 and ?
Hey guys, I am trying to run anchor on M1, I am getting below issue -
Hey guys!

Rust‚Äôs Unix timestamp returns an i64‚Ä¶ was wondering why would that be.. and if it‚Äôd be okay to cast it as u64 explicitly
https://book.anchor-lang.com/chapter_5/avm.html
any resources/documentation ?
use avm
Is it possible to run two different anchor version on a system ? If yes how to switch b/w them ?
emitting seeds for PDA in the IDL
what is the seeds feature used for ?
The transfer_authority function is the Solrand program
```
/**
     * Used by PDAs in CPIs to lock an Oracle request
     */
    pub fn transfer_authority(
        ctx: Context<TransferAuthority>
    ) -> ProgramResult {
        msg!("Before load_mut");
        let requester = &mut ctx.accounts.requester.load_mut()?;
        msg!("Requester ok");

        if requester.authority != ctx.accounts.authority.key() {
            return Err(ErrorCode::Unauthorized.into());
        }

        msg!("Unauthed");

        if requester.active_request {
            return Err(ErrorCode::RequesterLocked.into());
        }
        msg!("locked");

        requester.authority = ctx.accounts.new_authority.key();
msg!("Ok!");
     
        Ok(())
    }```
```#[program]
pub mod cross_pile {
    use super::*;

    pub fn create_coin(
        ctx: Context<CreateCoin>,
        coin_bump: u8,
        _req_bump: u8,
        vault_bump: u8,
        amount: u64,
    ) -> ProgramResult {
        let authority_key = ctx.accounts.initiator.key();
        msg!("Authority key {:?}", &authority_key);
        // Set data for PDAs
        { 
            let coin = &mut ctx.accounts.coin.load_init()?;
            let clock: Clock = Clock::get().unwrap();
            
            coin.initiator = authority_key;
            coin.acceptor = ctx.accounts.acceptor.key();
            coin.is_flipping = false;
            coin.created_at = clock.unix_timestamp;
            coin.bump = coin_bump;

            let vault = &mut ctx.accounts.vault;
            vault.amount = amount;
            vault.bump = vault_bump;
        }

        msg!("Requester {:?}", ctx.accounts.requester.to_account_info());
        msg!("initiator {:?}", ctx.accounts.initiator.to_account_info());
        msg!("Coin acc {:?}", ctx.accounts.coin.to_account_info());
        msg!("system_program {:?}", ctx.accounts.system_program.to_account_info());

        msg!("Solrand {:?}", ctx.accounts.solrand_program);
        // Transfer authority for the oracle requester to the Coin PDA
        let cpi_accounts = solrand::cpi::accounts::TransferAuthority {
            requester: ctx.accounts.requester.to_account_info(),
            authority: ctx.accounts.initiator.to_account_info(),
            new_authority: ctx.accounts.coin.to_account_info(),
            system_program: ctx.accounts.system_program.to_account_info()
        };

        let cpi_context = CpiContext::new(
            ctx.accounts.solrand_program.clone(),
            cpi_accounts
        );

        msg!("Before transfer authority");
        solrand::cpi::transfer_authority(cpi_context)?;

        msg!("After transfer authority");
        // Transfer sol from Initiator to Vault PDA
        let ix = anchor_lang::solana_program::system_instruction::transfer(
            &ctx.accounts.initiator.key(),
            &ctx.accounts.vault.key(),
            amount,
        );
        msg!("created ix");
        anchor_lang::solana_program::program::invoke(
            &ix,
            &[
                ctx.accounts.initiator.to_account_info(),
                ctx.accounts.vault.to_account_info(),
                ctx.accounts.system_program.to_account_info(),
            ],
        )?;

        Ok(())
    }```
It seems like the account that's being used belongs to Program that's on it's Github repo. For reference I'm trying to run https://github.com/evanmarshall/cross-pile, which has a dependency on https://github.com/evanmarshall/solrand

Here is the function that makes the CPI to Solrand::transfer_authority
I'm trying to understand why "An account required by the instruction is missing" is happening
Does anyone know how I should make the msg! outputs appear?
I'm trying to make a CIP call but I can't see any outputs from the msg! calls in the CIP when I run `anchor test`, or in `solana logs`
I could've sworn there was an `unwrap`-esque method somewhere that returns a custom error if program panics. Am I misremembering?
As they have the same format than a public key, type `Pubkey`is fine, if you try to call `key()`function of the account, it will return a `Pubkey`
okay since PDA are not public keys which Type should a PDA be assigned to?
100%, PDAs are deterministic, the way to generate  different ones is by providing different seeds only
the PDA being made in the frontend is because you need to pass all the accounts that need to be interacted with to the solana runtime, but the anchor will actually invoke the systemprogram account to create the account on chain and store the data for you. 
If you didn't use anchor, you could do it manually, or you could do like SPL Token does and have you create the account manually and then initializing it with the initializeXYZ instruction
okay what are the chances of two entity generating the same PDA for the same program ID?
in the backend, the seeds parameter is just a constraint that allow only the account with the same computed PDA. If u give a different PDA in the frontend, the constraint will fail in the backend and ur instruction will fail
why the pda is being created by the both frontend and backend for the user_stats account?
createUserStats entrypoint already providing a PDA for the user_stats account
in the frontend - 
```rs
    const [userStatsPDA, _] = await PublicKey
      .findProgramAddress(
        [
          anchor.utils.bytes.utf8.encode("user-stats"),
          anchor.getProvider().wallet.publicKey.toBuffer()
        ],
        program.programId
      );

    await program.rpc.createUserStats("brian", {
      accounts: {
        user: anchor.getProvider().wallet.publicKey,
        userStats: userStatsPDA,
        systemProgram: SystemProgram.programId
      }
    });
```
its creating user_stats account by generating a PDA
from the anchor book example - 
```rs
// validation struct
#[derive(Accounts)]
pub struct CreateUserStats<'info> {
    #[account(mut)]
    pub user: Signer<'info>,
    // space: 8 discriminator + 2 level + 4 name length + 200 name + 1 bump
    #[account(
        init,
        payer = user,
        space = 8 + 2 + 4 + 200 + 1, seeds = [b"user-stats", user.key().as_ref()], bump
    )]
    pub user_stats: Account<'info, UserStats>,
    pub system_program: Program<'info, System>,
}
```
not sure about that, not that am aware of
yeah I see, alright. thought perhaps it was possible to have it show up in the `accounts` in the IDL, so you could see it was optional there
so it should be send in the context like 
```
{
  accounts:{ mandatory ones }
  remainingAccounts: [ optional ones like this obj = {pubkey: account, isSigner: false, isWritable: false},
                         ]
}
```
you can send it in `remainingAccounts` fron js and handle it in `ctx.remaining_accounts` and see if there is any account passed there or not.
I tried `account: Option<UncheckedAccount<'info>>` but I even got an ICE üòÜ
is it possible to mark an account optional in the `#[derive(Accounts)]` ?
More specifically -
1. Can we delegate an ATA to a program? 
2. If so how the program transfer the spl tokens to another ATA using anchor_lang?
could u share a link for the outdated anchor docs?
you can return values in a CPI now
youre reading outdated docs
I see it stated in solana and anchor docs that CPI cannot return values...just wondering how chainlink is able to this with their pricefeeds?

The demo program requesting /receiving the price feed data is here:
https://github.com/smartcontractkit/solana-starter-kit/blob/875b23102605e4e9f8968dca520d41026138dfa9/programs/chainlink_solana_demo/src/lib.rs#L40

With the called function in the chainlink program returning data being here:
https://github.com/smartcontractkit/chainlink-solana/blob/ba505cd5055f1d96b8efc1000234a2f851aa2819/contracts/crates/chainlink-solana/src/lib.rs#L42

I see some examples shared memory for returning values in CPI, maybe this is an example of that?

If someone can explain what is going on here that would be great...or if there is a guide somewhere for this.  Thanks!
how to transfer tokens to another ata using  anchor_lang. Any resources ?
Ah, maybe you want `connection.getParsedTokenAccountsByOwner`
This is janky, but you can just pass in a fake wallet (like, whatever you want)
how can i deserialize an account given just a connection from the js side?
I want to fetch data, even before a user connects their wallet. I have the idl, and connection can be made easy.
we can create the account client object with just the idl, and fetch the raw data with connection, but there doesnt seem to be a way to put 2 and 2 together without a wallet
<@!134416332509675520>  can you give me a hint how can i make sense of the result:
```
 value: [
    value: [
    { account: [Object], pubkey: [PublicKey] },
    { account: [Object], pubkey: [PublicKey] },
    { account: [Object], pubkey: [PublicKey] },
    { account: [Object], pubkey: [PublicKey] },
    { account: [Object], pubkey: [PublicKey] },
    { account: [Object], pubkey: [PublicKey] },
    { account: [Object], pubkey: [PublicKey] },```
The account is `AccountInfo` type, but how can i find out which of these is the `usdc` for example?
thanx
it looks that it works
where `import * as spl from "@solana/spl-token"`
You can grab all of them by passing in the other kind of filter (seems dumb, but I think this is how you do it):
```.ts
program.provider.connection.getTokenAccountsByOwner(program.programId, {
      programId: spl.TOKEN_PROGRAM_ID
    })
```
is that the correct way to get all wallet token balances? üòÑ
That could probably work
`getTokenAcountsByOwner` requires a `tokenFilter` lets say i want to see my `usdc` balance, i should give the public key of my wallet and the `usdc` token mint?
You can do `program.provider.connection.getTokenAccountsByOwner`
Hey guys. Can someone point me where should i search for API to get all tokens in given wallet address?
You don't have to do that in general, they're just normalizing what they get from pyth with some of their other internal expectations


//////////////////////////////////////////////////////////////////////////////////////////

which version,are you using? anchor's latest one is preeety good at telling the errors
thx it worked, if it could help someone in the future : i installed avm with ```cargo install --git https://github.com/project-serum/anchor avm --locked --force``` then updated it with ur command
Is it possible to get more detailed transaction failure messages? I just get:

```
  1) drawtest
       Can manually create an account to associate:
     Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Program failed to complete
```

I am initializing the data in my Vec

```
    pub fn create_map(ctx: Context<CreateMap>) -> Result<()> {
        ctx.accounts.createMap.data = Vec::with_capacity(524288);
        Ok(())
    }

pub struct MapAccount {
    data: Vec<u8>
}
```

Which was already created at this size +1000 (525288)
okay
I think you need to install avm
im kinda new to linux ngl

yeah, use `avm use latest`
okay

try to upgard to the latest one
aah, asking about anchor ser
ubuntu 18.04 LTS
which version you are using?

it is working fine for me
do u know why i got this error?

```anchor init myepicproject --javascript```
This is more of a Rust question, but I'll ask anyway as it would be important to know in SmartContracts.

I want to access pointer to specific index of an array like so:
```
        let index: u32 = row * mapStride + xOffset;
        let pixel: &u8 = (&ctx.accounts.map.data) + index;
        *pixel = (color << 4) | *pixel;

pub struct MapAccount {
    data: Vec<u8>
}
```

By getting a reference to the byte at location index, I can both retrive and update it's value. Normally I would expect this to function, referencing the appropriate memory cell, however I get a compiler error because index is u32?

```
error[E0369]: cannot add `u32` to `&Vec<u8>`
  --> programs/drawtest/src/lib.rs:35:51
   |
35 |         let pixel: &u8 = (&ctx.accounts.map.data) + index;
   |                          ------------------------ ^ ----- u32
   |                          |
   |                          &Vec<u8>
```

It either doesnt understand what I want, or I have misunderstood what Vec is.
Then the rest of my calls can properly validate the input
Thank you - seems like best practice in that case would be have that on a separate Initialize call to set up the Data on a User created Account.
In the derive(Accounts) struct it tells anchor to not freak out about missing discriminator bytes
Yep, that's what `#[account(zero)]` is for
Super - refactored to:

```
  it("Can manually create an account to associate", async () => {

    var spaceAllocate = 1000;
    var rentRequiredForSpace = await provider.connection.getMinimumBalanceForRentExemption(spaceAllocate);
    var sig = await provider.send(
      new Transaction().add(
          anchor.web3.SystemProgram.createAccount({
            fromPubkey: provider.wallet.publicKey,
            lamports: rentRequiredForSpace,
            space: spaceAllocate,
            newAccountPubkey: MapAccount.publicKey,
            programId: program.programId
      })),
      [MapAccount]
    );
    console.log("Create Account Signature: ", sig);
```

Is there a way I can get Anchor to ignore deserialization errors? This newly created account is uninitialized (empty data) and so I get `AccountDiscriminatorMismatch`, because I assume there is that check on deserialization.
Thank you so much, complaining about rent so I'll go lookup how to calculate that. Thank you for your quick help.
Ah I see, I had thought that was not requried seeing as we are allocating it to that PubKey.
In solana when you create an account you need to sign with its address (think of it as the address saying "I'm cool with an account living here")
Ah, you *do* need to sign with `MapAccount` here (the keypair)
I tried not sending anything but it gives me `Error: Signature verification failed`
`provider.send` will actually automatically sign with the provider.wallet, no need to pass it in there like that
Hello - Just getting started with Anchor, due to PDA max size of 10KB, I want to create an Account manually and assign it to a Program.
I'm starting from a basic anchor init, and want to do the following:

```
  it("Can manually create an account to associate", async () => {
    var createAccountTx = anchor.web3.SystemProgram.createAccount({
      fromPubkey: provider.wallet.publicKey,
      lamports: 10000,
      space: 1000,
      newAccountPubkey: MapAccount.publicKey,
      programId: program.programId
    });
    var cTx = new Transaction().add(createAccountTx);
    var sig = await provider.send(cTx, [provider.wallet]);
    console.log("Create Account Signature: ", sig);
```

I cannot pass provider.wallet as a SIgner to provider.send as it is a Waller. Where can I find the private key for the wallet that can fund these tests?
Could try https://www.cronos.so/
Nope, not out of the box (you would need a whole separate service/whatever running off-chain to do that)
does anchor support cronjob like periodic function invocation ?
bump targets should not be provided with init. Please use bump without a target.
Been a while since I've touched an Anchor program. How come bump is now depricated and what does that error mean
the counter already has a mutable reference?
Oh nevermind I forgot to put "mut"
why my counter not increased üò¶

also token account can't be created using program other than the SPL program correct?
no you cant, all accounts need to be passed in from the client
can we load account from a public key without getting it from any client ?
Hey, I am really really new and I am really looking for resources to lean Development on Solana. I know Json rpc api, @solana/web3.js. I have thoretical knowledge about anchor but, I am still learning. I have read at many places on stack overflow that people recommending anchor wallet library. Could someone please explain the use of it and from where can i learn more about it?
all right imma go through the solana cookbook
E.g. your program will be the program owner of any of its
```.rs
#[account]
pub struct Something  {
  ...
}
```
oh
Nope
yeah user-level ownership i mean. else system program is the owner of all accounts
The idea of a payer "owning" some account is the latter, a user-level ownership idea‚Äîtotally distinct from program ownership
Program ownership vs. "user-level ownership", for lack of a better term
Right‚Äîbut I'm saying there are two totally distinct notions of ownership floating around
i know payer is not necessarily the owner btw
Higher-level ideas of ownership (like *who* owns a token account) are a separate thing
I think you might be confused about what "ownership" means in solana. Every account has a "program owner", which is the program that's allowed to mutate the account's data or spend the account's lamports
```rs
#[derive(Accounts)]
pub struct Initialize<'info>{

    #[account(init_if_needed,payer = genesis_admin,space= 8 + 32)]
    pub name_db_account : Account<'info,data_accounts::stake::NameDbAccount>,

    #[account(mut)]
    pub genesis_admin : Signer<'info>,
    pub system_program : Program<'info,System>
}
```
in this case. Who's the owner of the name_db_account ? the program itself or the the genesis admin or the private key of name db account which also signed the tx?
oh ok
Whether it requires a signature or not is purely up to the program's logic
The program that owns an account can write to it whenever it wants
for example - there is a data account to store users name. I want others to enter their names in it. Is it possible?
No, no need to sign in general
like I created a data account during initialization. Now if I want to write data to it I'll have to sign with the private key of the data account right? But if i want to put user data on that account by end users they don't have the private keys to sign
Can you say more? If I'm understanding your question right, *all* data accounts are like that (for some program)
can we have a data account that the program owns and can read/write?
I'm having this error `TypeError: Cannot read properties of undefined (reading 'fromBuffer')` using `createTokenAccount` and `getMintInfo` from `"@project-serum/common": "^0.0.1-beta.3",` anybody know why?
Is there anyway to mark instructions as deprecated using Anchor?
any idea why the cloned accounts aren't reflecting properly on solana-test-validator? Using this command
```
solana-test-validator --clone 6qnhRSRB1BjfqtVQHzRkwz6mUsf9JDjB2mTd78iL3WPG --clone FB9GjPA2XqnGunRXRQv7fasSvqqcxoh85D3gZsfS7wGC --url devnet
``` to clone both mint + token account
has mainnet solana been flakely lately? had a program that worked no problem before but trying it out now and seeing a lot of inconsistency + long load times - any one else experiencing this?
should be in <#899315988087054397> my b
may be related to this? 
https://github.com/project-serum/anchor/pull/1608
Thanks!
You'll get the same value, but calling `.to_account_info()` is a bit less efficient
Hello, is there any difference between
```rust
ctx.accounts.signer.key
```
and
```rust
ctx.accounts.signer.to_account_info().key
```
?

the `signer` account is of type `Signer`
I don't see this change in the logs, but was the printing of logs for failed tx removed during `anchor test` in 0.23.0? I've noticed they're gone. they were v helpful
I believe so. I've never needed to xfer authority but it seems that you can do that
I guess in this case, I guess in the front end, I can make the user perform the transaction of moving the NFT to a non-ATA account, and then transfer the authority of the non-ATA account to the program correct?
I see thanks
https://github.com/solana-labs/solana-program-library/issues/2640
I suppose you could ask the user to create a non ATA token account, and transfer the NFT there. Then, since it is not an ATA, authority can be changed
So `SetAuthority` won't work?
I don't think that's possible because typically the token account holding the NFT will be an associated token account which, due to it's design of being an address derived from a particular user wallet address, does not allow for ownership transfer.
Is either one of the approach definitively better?
Hey guys, I'm trying to implement a NFT gambling app, and I'm wondering how to transfer the ownership of a token account from the user to the app.

I want to take this approach because it avoids the program needing to create a corresponding NFT token account for the user to transfer the ownership of the NFT to.
yes its more informative
and so it's a binary tree map that uses strings as keys, and stores u8s
you can also go to the docs.rs page and see this
hmm
sure but you could just see in the signature that it's expecting a `key` which idiomatically is some sort of string.
i mean it could be the immutable reference to the actual PDA but it's string. without proper documentation I'll always have to rely on people that have dealt with it before
so if you are going to get a bump, it's going to be the bump of a PDA
because only PDA's have bumps
is there any doc or something. How am i supposed to know the parameter is the account name in string format instead any other string
ya so you'd still pass that into `get()` even if you used a different seed just bc that's the account name
okay now it makes sense
so that's just the name of the account in the context
user_stats is a PDA and it is stored in `ctx.bumps`
oh that's wrong my bad
the seed was that string + the public key of signer. How can the bump be found from the string alone?
btw its from the anchor book pda example - 
```rs
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod game {
    use super::*;
    // handler function
    pub fn create_user_stats(ctx: Context<CreateUserStats>, name: String) -> Result<()> {
        let user_stats = &mut ctx.accounts.user_stats;
        user_stats.level = 0;
        if name.as_bytes().len() > 200 {
            // proper error handling omitted for brevity
            panic!();
        }
        user_stats.name = name;
        user_stats.bump = *ctx.bumps.get("user_stats").unwrap();
        Ok(())
    }
}

#[account]
pub struct UserStats {
    level: u16,
    name: String,
    bump: u8,
}

// validation struct
#[derive(Accounts)]
pub struct CreateUserStats<'info> {
    #[account(mut)]
    pub user: Signer<'info>,
    // space: 8 discriminator + 2 level + 4 name length + 200 name + 1 bump
    #[account(
        init,
        payer = user,
        space = 8 + 2 + 4 + 200 + 1, seeds = [b"user-stats", user.key().as_ref()], bump
    )]
    pub user_stats: Account<'info, UserStats>,
    pub system_program: Program<'info, System>,
}
```
I'm only using primitives. u64, u8, and usizes
I'm getting an error which is not super helpful. Rust code is compiling but I'm getting

```
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: ParseIntError { kind: InvalidDigit }', lang/syn/src/idl/mod.rs:202:76
```
when testing because the IDL can't be built
it's just the string that was used as the seed
full code - 
```rs
#[program]
pub mod game {
    use super::*;
    // handler function
    pub fn create_user_stats(ctx: Context<CreateUserStats>, name: String) -> Result<()> {
        let user_stats = &mut ctx.accounts.user_stats;
        user_stats.level = 0;
        if name.as_bytes().len() > 200 {
            // proper error handling omitted for brevity
            panic!();
        }
        user_stats.name = name;
        user_stats.bump = *ctx.bumps.get("user_stats").unwrap();
        Ok(())
    }
}
```
i see thanks. anyways what's the argument is being passed to the bumps.get function. Is it just a string or what?
```rs
user_stats.name = name;
        user_stats.bump = *ctx.bumps.get("user_stats").unwrap();
        Ok(())
```

nvm i'll just share ss <@!744612713811935404>
are links allowed here?
it means you are casting the string to the bytes array that represents it (utf-8)
Hello,
I'm getting an account info from `remainingAccounts` and I managed to convert this into `AccountInfo<MyStruct>` but I probably copied it because I can't see data I chaned on-chain.
What is the best way of getting account from `remainingAccounts` (mutable) and edit/save it?
how do i solve the runtime error `Invalid public key input` when im trying to fetch an account from the chain and rendering it on the frontend and the pubkey im using to fetch is from the url params. What im trying to do is if an account is not found, i want to render some html if there is no account fetched `await program!.account.creator.fetch(pubKey)`
im new to rust as well
```rs
#[account(
        init,
        payer = user,
        space = 8 + 2 + 4 + 200 + 1, seeds = [b"user-stats", user.key().as_ref()], bump
    )]
```
what does b"user-stats" mean here? I know its a seed but it's not exactly a string right because b doesn't have quotes
ping me if u get to it
If you don't get around to it I may have time to look thru code this weekend and submit a PR
okay cool this works now (the string thing, not the workspace/program issue)
this program is called ProgramID because I named one sha256test and something was breaking internally bc and `const program = anchor.workspace.Sha256test as Program<Sha256test>;` (which came stock during `anchor init`) was failing. couldn't access the idl or the programId
haha
okay so while we're on this topic
Yeah, not sure why yet
ah so I just can't name it that thing?
Ughhhhhhhhhhhhhhhhhhhhhh, anchor gets confused about something with the name ü§¶‚Äç‚ôÇÔ∏è
however, when I uncomment sha256hash and pass in 
```typescript
let sha256hash: string =
      "8AEF9B5DDEDE4F620D83D8D6E48B7C9809B49811E4A46F9D48021376ADBB59D0";
```
into the method, it fails to deserialize
yep
```rust
pub fn initialize_file(
        ctx: Context<Initialize>,
        data: u8,
        //sha256hash: String,
    ) -> Result<()> {

        Ok(())
    }
```
with 
```typescript
  const tx = await program.methods
      .initializeFile(data) //, sha256hash)
      .accounts({})
      .signers([])
      .rpc();
```
produces
```
 ‚úî Is initialized! (152ms)


  1 passing (154ms)

‚ú®  Done in 5.67s.
```
And just run `anchor test`, no other arguments
Did you try the version where you turn off all validators?
i literally have other things where I do this, haha
(Tried just now)
I usually can too
I can run the same kind of code just fine
Yeah, I'm 99% sure you're messing something up with a deployment etc.
a short string doesn't work either tho, haha
I'm just trying to pass in a len 64 string
There is a max size though, since the whole tx has to fit in 1232 bytes
What happens if you just use a short string then?
is there like a max size string we can pass in or something? That may be what's going on here bc if I comment out the string being passed in the program can deserialize the ix
dang, that's good to know haha
all successful tx's have their logs printed there, while all failed ones get printed to console
in .anchor/program-logs/
I've always kept the validator spinning and looked up my logs in the explorer üòÇ
in the target folder or what?
üëÄ
well the logs are saved so you can just run `anchor test` and look at logs
If you're trying to look at logs, I use `anchor test --detach` which keeps the validator spinning after tests finish without the required step of starting your local validator and purging your test validator directory between tests
correct. If yo'ure running a local validator in another shell, you can run anchor test with the --skip-local-validator flag
that's bc it deploys it out the box
with `anchor test --skip-local-validator`
```
Error: RPC request error: cluster version query failed: error sending request for url (http://localhost:8899/): error trying to connect: tcp connect error: Connection refused (os error 61)
```
Tbh not sure why lol, but I never ever run a local validator and anchor test works fine
You also don't need to do that though
anchor test starts up a validator when no flag is provided
that's the one
--skip-local-validator
Without a validator running
anchor test is what i've been doing, no?
Just anchor test
oops that's not the flag I meant to add. which one skips the validator startup?
Can you just run `anchor test`?
with `anchor test --skip-deploy`
```
Error: failed to send transaction: Transaction simulation failed: Attempt to load a program that does not exist
```
is jump-to-source an IntelliJ feature? I've been stepping through my code manually to debug üòÇ
Just to double check, can you turn off the validator?
the tx call in the ts test is
```typescript
    let data = 8;
    let sha256hash =
      "8AEF9B5DDEDE4F620D83D8D6E48B7C9809B49811E4A46F9D48021376ADBB59D0";

    // get file pda
    let [file, fileBump] = await anchor.web3.PublicKey.findProgramAddress(
      [Buffer.from("file")],
      program.programId
    );

    const tx = await program.methods
      .initialize(data, sha256hash)
      .accounts({
        file: file,
        payer: admin.publicKey,
        systemProgram: anchor.web3.SystemProgram.programId,
      })
      .signers([admin])
      .rpc();
```

Actually maybe that shouldn't matter
But are you running a live validator in the background?
just `anchor test`
How did you deploy it?
I also impl'd a single method for `File` (which turns a length 64 string containing only hexdecimals chars into a 32 byte array) but I don't think that's the problem as I've commented it out
```rust
#[program]
pub mod program_id {
    use super::*;

    pub fn initialize(
        ctx: Context<Initialize>,
        data: u8,
        sha256hash: String,
    ) -> Result<()> {

        msg!("Initializing File");
        {
            let file = &mut ctx.accounts.file;

            // Store data and hash
            file.data = data;
            file.store_sha256(&sha256hash);
        }

        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {

    #[account(
        init,
        payer = payer,
        space = 8 + 1 + 32,
        seeds = ["file".as_bytes()],
        bump,
    )]
    pub file: Box<Account<'info, File>>,

    #[account(mut)]
    pub payer: Signer<'info>,

    pub system_program: Program<'info, System>,
}

#[account]
pub struct File {

    pub data: u8,

    pub sha256: [u8; 32],
}
```
I can paste some code here
this was meant to be a very simple test on a fresh anchor program
Basically it's hard to get that error unless you've goofed lol
Are you maybe trying to talk to a stale deploy?
nope, not using it anywhere
Are you using `#[instruction(...)]` incorrectly maybe?
quite a simple ix as well
I don't seem to have much more info
Is there a place I should start when I run into
```
Error: AnchorError occurred. Error Code: InstructionDidNotDeserialize. Error Number: 102. Error Message: The program could not deserialize the given instruction.
```
Depending on what you're doing you may need to "reload" the account after doing any CPI that might mutate it
Yep, that's correct üëç
each data point for the feed is written to a specific account, for which the address can be determined from the seed (and will be documented addresses).  i assumed I would need to call the program that is creating/writing to the data accounts in order to fetch the data.  for building the context for the call in the program that will request the data, i have to provide the account where the data is stored.  just by including it in the context, i am able to access the values in that account from the calling program, without making any calls to the data aggregator which wrote the data.  does this sound reasonable?
hmmm, it seems like i can succeed without shared memory or CPI return values


//////////////////////////////////////////////////////////////////////////////////////////

where im trying to use this `pub update_position: UpdatePosition<'info>,`  but `UpdatePosition` is in a different file
```
error[E0432]: unresolved import `__client_accounts_update_position`
   --> programs/drift_vault/src/instructions/withdraw.rs:175:10
    |
175 | #[derive(Accounts)]
    |          ^^^^^^^^ help: a similar path exists: `crate::__client_accounts_update_position`
    |
    = note: `use` statements changed in Rust 2018; read more at <https://doc.rust-lang.org/edition-guide/rust-2018/module-system/path-clarity.html>
    = note: this error originates in the derive macro `Accounts` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0433]: failed to resolve: use of undeclared crate or module `__client_accounts_update_position`
   --> programs/drift_vault/src/instructions/withdraw.rs:175:10
    |
175 | #[derive(Accounts)]
    |          ^^^^^^^^ use of undeclared crate or module `__client_accounts_update_position`
    |
    = note: this error originates in the derive macro `Accounts` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0433]: failed to resolve: use of undeclared crate or module `__cpi_client_accounts_update_position`
   --> programs/drift_vault/src/instructions/withdraw.rs:175:10
    |
175 | #[derive(Accounts)]
    |          ^^^^^^^^ use of undeclared crate or module `__cpi_client_accounts_update_position`
    |
    = note: this error originates in the derive macro `Accounts` (in Nightly builds, run with -Z macro-backtrace for more info)
```
show the full error log
something like `struct Tmp {}` in fileA and `struct Tmp2 { tmp1: Tmp }` in fileB? im getting strange errors
is it possible to import a \#[derive(Accounts)]  struct across files and use it in other \#[derive(Accounts)]  structs?
you should make PDA an authority, It'll make your life more easier and try to use explorer more instead solscan
Any idea about this friends?
Ok, so basically if we let Anchor do it, it does in program. If we want to save CU and calc in client, we will need to pass by ourselves right?
yes
Generally yes, but if you do ask anchor to do it for you (with the `bump,` syntax) then anchor will remember it at `ctx.bumps.get("the_account_name")`
to save CU?
Shouldn't we avoid calculating bump in program?
in program
calculated in client or in program?
no probs manüëç
Ah yes I was wrapping it in { accounts: { - my fault - thank you <@744612713811935404>. I still unfortunately get just the same error message "Program failed to complete" but <@134416332509675520> gave me the solution for that in the Solana discord. Appreciate your time both of you.
<@329649777824497669> that actually looks about right to me based on your idl ^
Thank you for your help but the publicKey doesnt really go there, I'll do some more digging in the docs and see what I can find.
Just use `Account<'info, Whatever>`
okay
Nah, it's deprecated
<@134416332509675520> ??
this should work. Else idk man 
```rs
    var res = await program.methods.createMap().accounts(
         {
           createMap: MapAccount.publicKey
         }
      ).rpc();
```
Yeah the object expected by the autogenerated createMap function on methods is a different type to that expected by program.rpc.MyMethod
Then you can access the bump that anchor calculated for you via `ctx.bumps.get("some_account_name").unwrap()`
try this <@329649777824497669>
If you have
```.rs
#[account(..., seeds = [...], bump, ...)]
pub some_account_name: ...
```
IDL:```
    {
      "name": "createMap",
      "accounts": [
        {
          "name": "createMap",
          "isMut": true,
          "isSigner": false
        }
      ],
      "args": []
    },
```
```rs
    var res = await program.methods.createMap().accounts(
         {
           createMap: MapAccount.publicKey
         }
      ).rpc();
```
can you post your IDL?
Yeah I only need to supply an Account to that function, but it complains about types, expecting args instead
```
    var res = await program.methods.createMap(
      {
         accounts: {
           createMap: MapAccount.publicKey
         },
      }).rpc();
```
`Argument of type '[{ accounts: { createMap: PublicKey; }; }]' is not assignable to parameter of type 'ArgsTuple<[], IdlTypes<Drawtest>>'.`
post the code here
https://project-serum.github.io/anchor/ts/classes/Program.html
you have to provide the function arguments like you did previously
`var methodResult = await program.methods.createMap().rpc();`
`Error: Invalid arguments: createMap not provided.`
Where can I find docs on program.methods? Can't see what to supply to this...
Is there a clear documentation how we handle ctx.bumps in new way? not sure I understand
is cpiAccount is still valid account type? <@134416332509675520>
also 
```rs
program.methods.createMap({}).signers([...,signer]).rpc()
```
program.methods.method() instead program.rpc.method()
Is it possible to get more information out of an Anchor test? Just getting Program failed to complete. Is there more logs available elsewhere?
yeah, as always, a sneaky typo, lol
pretty sure it is initialized and has 1 holder (minted some for test) , will doublecheck if am sending wrong parameters
Mm, doesn't sound like it's actually initialized, I would triple check that
```AnchorError caused by account: base_mint. Error Code: AccountNotInitialized. Error Number: 3012. Error Message: The program expected this account to be already initialized```

any idea why I'm getting this error for a mint? it exists and am sending pubkey in accountcontext
do you know how to fix this?
```anchor test
BPF SDK: /home/anon/.local/share/solana/install/releases/1.10.6/solana-release/bin/sdk/bpf
cargo-build-bpf child: rustup toolchain list -v
cargo-build-bpf child: cargo +bpf build --target bpfel-unknown-unknown --release
warning: unused variable: `ctx`
 --> programs/myepicproject/src/lib.rs:9:23
  |
9 |     pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
  |                       ^^^ help: if this is intentional, prefix it with an underscore: `_ctx`
  |
  = note: `#[warn(unused_variables)]` on by default

warning: `myepicproject` (lib) generated 1 warning
    Finished release [optimized] target(s) in 0.33s
cargo-build-bpf child: /home/anon/.local/share/solana/install/releases/1.10.6/solana-release/bin/sdk/bpf/dependencies/bpf-tools/llvm/bin/llvm-readelf --dyn-symbols /home/anon/myepicproject/target/deploy/myepicproject.so
Failed to execute /home/anon/.local/share/solana/install/releases/1.10.6/solana-release/bin/sdk/bpf/dependencies/bpf-tools/llvm/bin/llvm-readelf: No such file or directory (os error 2)```
when i run ```anchor test``` this is the error i get ```Failed to execute /home/anon/.local/share/solana/install/releases/1.10.6/solana-release/bin/sdk/bpf/dependencies/bpf-tools/llvm/bin/llvm-readelf: No such file or directory (os error 2)```
When simply use json with all fieldnames I have used, I'm getting ` Error Message: The program could not deserialize the given instruction.`  this is beacuse I think I'm not sure about type mapping, so need a typed class to build that object I want to serialize and send to program.
Another question;
When I look from solscan to some program accounts, they looks like both a wallet and a program. They have a list of SPL token account for example.
When I create PDA (as ATA) to store some tokens inside, I never see that in my program page. I have to know the address and usually the owner is itself (because I set authority=itself) .
Never tried but, should authority=program_id (not sure how to get it tho) solve it or?
Hello everyone, 
What is the best way of building custom struct in client? Just use json or does Anchor have some typed way of it?
I mean, I have a custom struct, it is serializible and now I need to pass it using Anchor client. How do we do that?

Thanks/
tried it all, still getting the same results. im going to go through the entire setup again just to make sure i didn't miss anything
thank you!
https://book.anchor-lang.com/chapter_2/installation.html
do reinstall first, then install the latest version of anchor
umm to reinstall anchor, i just run the same command that i used before to install it? or are there any other things i need to do?
thanks
yup i think i will try that
I'm not sure what is going wrong then ser. one dirty thing you can do it re-install anchor & solana
hmm ok, it make complete sense
this is what happens, local port already in use
yeah it totally fine ser
btw this is day 2 of me using ubuntu üòÖ
sure
gimme a sec lemme do that and pull up the screenshot
what is it?
ah okay. but if i do that, there will be a different error.
and then type `anchor test`
ser, open new terminal, lol
if i don't ctrl + c after `solana-test-validator` i am not able to type anything
Now don't this and see what will happen.
run  `solana-test-validator` and then do anchor test
yup i just did this
you just did this right?
just wanna make sure i'm doing this right. after running `solana-test-validator` i should ctrl +c to stop the test validator, only then i should do `anchor test` right?
nope still the same error message
now try do `anchor test`
yup `solana-test-validator` ran successfully.
is `solana-test-validator` running successfully?
just read the error log carefully. you just need to install anchor v0.23.0
the log just ends at `Initializing...` 
Yup local test validator is not running elsewhere.
what can i do?
Only x86_64 / Linux distributed in NPM package right now.
Trying globally installed anchor.
Globally installed anchor version is not correct. Expected "anchor-cli 0.23.0", found "anchor-cli 0.22.0".

anchor test by default spins one up brand new just for that test run, if you have one running locally it'll conflict unless you configure it to use that long running one
Also - sanity check that you _don't_ have a local test validator already started
What's the log say?
i'm trying to run `anchor test` but i can't seem to get it to work. 

i keep getting ```Unable to get latest blockhash. Test validator does not look started. Check .anchor/test-ledger/test-ledger-log.txt for errors. Consider increasing [test.startup_wait] in Anchor.toml.```
I'm using ubuntu (wsl)

It's upto you
Bundling up a transaction entirely backend server-side <_<
Ngl I'm not even using a smart contract for this particular use case :p
you can store a bump in the account to save CU &then use it for finding the account later on on-chain.
Thank you!

...do I need to hold onto the bump it returns for any reason?
or you can try to build form source,
https://book.anchor-lang.com/chapter_2/installation.html#build-from-source-for-other-operating-systems-without-avm
you need to specify `--tag` args here
findProgramAddress, uses createProgramAddress under-the-hood.
findProgramAddress is used to find `valid` PDA. This function iterates a nonce until it finds a valid PDA. While createProgramAddress, is just directly checking if the PDA is on the curve or not. If PDA is not on the curve, it'll throw an error like this `Invalid seeds, address must fall off the curve`
Btw fei: stick with anchor. I bounced off it from a poor first impression of the doc and tried to go it alone, it ain't worth it. Anchor's actually the best maintained tool in the solana ecosystem üòî (that I've found so far)
Mmm past my knowledge. Hopefully 0xDeep or cqfd can help ‚ù§Ô∏è
i used macos
Also maybe `sudo apt-get update && sudo apt-get upgrade && sudo apt-get install -y pkg-config build-essential libudev-dev`. I remember getting errors at this step myself but they might've been different (was a few months ago)
Sanity check, `rustup update`?

Ah, 3 months ago, ancient history by now going by these parts ^^
I followed this article https://github.com/buildspace/buildspace-projects/blob/main/Solana_And_Web3/en/Section_2/Resources/m1_setup.md to install anchor
<@808672825585172531> it appears outdated to me (a newb) based on https://book.anchor-lang.com/chapter_2/installation.html. What are you attempting to do?
Where'd you get that command from out of curiosity?

Atm I'm using find and throwing away the # that comes with it, I assume that'll bite me at some point :p
When getting the PDA for my token metadata account, what's the diff between createProgramAddress and findProgramAddress?
It just a package, from metaplex to De/Serialized Borsh.
https://github.com/metaplex-foundation/beet
What's a 'beet'? (https://metaplex-foundation.github.io/metaplex-program-library/docs/token-metadata/index.html#DataV2)
```anchor test
BPF SDK: /home/anon/.local/share/solana/install/releases/1.10.6/solana-release/bin/sdk/bpf
cargo-build-bpf child: rustup toolchain list -v
cargo-build-bpf child: cargo +bpf build --target bpfel-unknown-unknown --release
warning: unused variable: `ctx`
 --> programs/myepicproject/src/lib.rs:9:23
  |
9 |     pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
  |                       ^^^ help: if this is intentional, prefix it with an underscore: `_ctx`
  |
  = note: `#[warn(unused_variables)]` on by default

warning: `myepicproject` (lib) generated 1 warning
    Finished release [optimized] target(s) in 0.33s
cargo-build-bpf child: /home/anon/.local/share/solana/install/releases/1.10.6/solana-release/bin/sdk/bpf/dependencies/bpf-tools/llvm/bin/llvm-readelf --dyn-symbols /home/anon/myepicproject/target/deploy/myepicproject.so
Failed to execute /home/anon/.local/share/solana/install/releases/1.10.6/solana-release/bin/sdk/bpf/dependencies/bpf-tools/llvm/bin/llvm-readelf: No such file or directory (os error 2)``` do you know why i get this errror?
Sorry, `PublicKey`
im getting `Property 'Pubkey' does not exist on type 'typeof import("@solana/web3.js")` from that
`new anchor.web3.Pubkey(theBase58String)`
js
In js or rust?
how do i get a publickey object from a string given that the string is in base58?
Oh, weird, where did the examples go ü§î Could have sworn there were a few
Do I add remaining_accounts as a field in the derive accounts struct?  I couldnt see from the examples in the repo. maybe you are are refering to something other than the main anchor repo?
Via `remaining_accounts`
i see.  how do i add more accounts that wont be automatically deserialized?
Ah, no, totally separate from anything about how many accounts‚Äîyou can ignore it unless/until rust complains about some lifetime stuff üòå
is this going to specify that there are 3 additional accounts?  Im having trouble getting the context to have a remaining_accounts.len() > 0
there's a way to run tests from a folder which name is not `tests`  using `anchor test` + some flag or something?
how do i buffer a pubkey that i get from the url params in react?
thanks!
gotcha. okay.  i will search in the repo
You can find a bunch of examples by searching the anchor repo
That's just how anchor gives you access to any other/extra accounts that came in (beyond the fixed ones in the derive(Accounts) block)
And just a heads up, you may find you also need to help rust's lifetime inference a bit
```.rs
pub fn do_something<'info>(ctx: Context<'_, '_, '_, 'info, Initialize<'info>>)
```
what would remaining_accounts refer to?
Not yet unfortunately‚Äîif you want a variable number you'll have to use the `remaining_accounts` feature, and then if you want to deserialize them etc. you'll have to do that manually
```.rs
let my_account: Account<Thing> = Account::try_from(&the_account_info)?;
```
would something liek this be used: 

```
pub fn do_something(ctx: Context<Initialize>) -> ProgramResult {
    let vec: Vec<AccountInfo> = ctx.remaining_accounts.into_vec();

    // do something with the accounts

    Ok(())
}
```
anyone know if its possible to define / use a context for instructions with a variable number of accounts?  for instance, provide an array of accounts for a given account type?
Hi! I would like to have two different test folders (i.e tests and tests2). There's a way to run `anchor test` but run the tests in tests2 folder? Something like `anchor test tests2`...


//////////////////////////////////////////////////////////////////////////////////////////

=======
>>>>>>> 20bea11087240cc616c020a0810cf4b960b99b41
