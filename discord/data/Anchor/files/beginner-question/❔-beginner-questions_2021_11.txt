```
let account_data = await program.account.MyAccountType.fetch(
        account_address
    );
```
Haha, with hindsight that was a dumb question... <@!501570363566587905>  you are the best for answering dumb questions!
Thanks!
fetch the account
How do I check in JS if a PDA has been initialized yet?
Hmmm thanks!
Make sure it's `pub` and derives `AnchorSerialize, AnchorDeserialize`
How do I fix that???? Do i need to re-init the idl
The `Data` type is not in the IDL
I checked the idl, and it exists and is correct

IdlError: Type not found: {"type":{"defined":"Data"}}
Has anyone seen this before?
you can also do 
solana logs
in the terminal to stream logs
./anchor/program-logs/...
ohh got it
how do I check the program logs when running `anchor test`?
Got it, thanks!  I realize one can also get around this by creating a dummy wallet.
a true maybe that was relaxed, i forgot
in my experience you can leave wallet undefined and you can still `fetch` with your program
is there a way to get the total supply of an spl-token via `anchor_spl::token` or otherwise?
my workaround is to make a provider with a stub wallet, so it can be used even when the user isn't connected. By stub i mean an object with the same interface
Hey I am wondering what is a good way to create a JS client that is used to only to read the on chain state.

I understand that there is  Program class, however it requires us to pass in a Provider. It will be difficult for us when the the users are not connected to their wallet. 

Is there a way to create a JS client from IDL that is only going to read the onchain state?
ah i have had this happen as well except when changing the program name!
This ended up being a sneaky missed step, surprisingly hard to spot while debugging: we weren't rerunning `anchor build` before `anchor deploy`, after having propagated the new program id everywhere. This meant the `anchor deploy` step was still using the old `.so` with the now-stale id embedded in it.
Not that I know of. Currently you need to take that hex code, turn it into decimal (e.g. 0xa7 = 167), and then go look it up in `error.ts` lol. Then start source-diving through anchor 🤿
it builds, just doesn't actually run
another question: is there a good tutorial on debugging the rust portion of my program? i'm getting errors but i'm not sure which line is causing them (e.g. in the macros, in the function, whatever)
Hmm. Sent you a dm in case you want to try screensharing
thanks
Or a fixed PDA you use as a program authority thing, with e.g. `seeds = [b"im-the-program".as_ref()]`
I thought this as well, but my `App.js` file is a whole different directory. I actually copy paste the `idl.json` file into the React App manually.
You'd use some program-derived address (it could even be the token account's address!). It just needs to be something the program can sign for (aka a PDA, not the program id itself)
I think that trace must mean that your program id is somehow wrong (the call to the system program succeeds!). So I wonder if something is weird about your idl? And it's somehow getting fixed by running anchor test?
if i want to create a PDA token account (i.e. the program itself can spend what's in the token account), what do I use as token::authority? the program_id?
Hmm... interesting, that's pretty weird/definitely not expected. Trying to think how that could happen.
So, I'll run `anchor test` right after this and bam I'm able to run that `create` counter function properly.
It's the `program.rpc.create` line.
Huh. Which part gives you the 167 error? Creating the account? That's pretty surprising to me 🤔
(rlly appreciate the help here!!)
Same way as in the test, just on a React App :).

https://gist.github.com/farzaa/621d146ed1a3a8820644b9fd05624321#file-app-js-L91
And how are you interacting with the program? Outside of a test that is
Ahhh that would make good sense!! Just added my program and test on a gist.

https://gist.github.com/farzaa/2e9d23f9bc7abe2345e9d8ff0e53df64
Ok, then it would be interesting to see what your tests are doing/what accounts they set up. If you just do `anchor deploy` and then try to interact with the program, it's definitely possible that some account hasn't been set up yet (as a side effect of the tests), in which case you could get that 167 error.
Super weird yah, just triple checked just now. Just gives me 167 if I don't do an `anchor test` on a fresh program.

Also, looks like `anchor test` is actually running on devnet, since that's what my config is set to 😄 

Confirmed on Solana Explorer that the tests run on devnet.
Hmm... I'm actually not sure what would cause that. Running `anchor test` against your local validator I think just, like, runs the tests, so not sure why it would have an effect on that error.
Mm, if you really want a whole new program you'd have to generate a whole new keypair etc.
Ah got it -- and what if I wanted to run `anchor deploy` with a fresh state -- where its essentially deployed to devnet as a whole new program account.
Hmmm -- super weird, I've done this a few times now. And doing exactly this. But, whenever I don't run `anchor test` before deploying, Error 167 pops on up :o.
No, shouldn't be necessary—the error you're getting, 167, is often because your `declare_id!` doesn't match the address your program is actually deployed to (kind of annoying, but for the moment you have to manually get this right)
If you want to run anchor test with a fresh state, you'd ordinarily not run a local validator in the background—you'd just let anchor test spin one up for you
Haha interesting, every time I follow the steps below without `anchor test` I end up getting that error above!

```
anchor build

solana address -k target/deploy/mysolanaapp-keypair.json

// Update Anchor.toml (make sure on devnet), lib.rs

anchor test

anchor deploy

// Update idl.json on web app.
```
Is it needed to run `anchor test` before running `anchor deploy`? Noticing that if I don't do this, I get this error upon trying to interact w/ my program on **devnet**: `Error: 167: The given account is not owned by the executing program`.
W/ Anchor, as I re-deploy my updated program -- it seems to keep the same address which means data I had stored on that program account sticks around as well which is a bit odd no?

When I redeploy, how can I make sure it's deployed as a brand new program?
ohhhh okay, will dig into those two files, thank you very much for the fast reply, greatly appreciated, i am happy to get anything working !!
Tbh I'm not sure why you're running into this issue though, so quite possible there's another way to fix it—but I think this will probably work for now?
There's probably a line `anchor_lang = 0.18.2` in one of the Cargo.toml files in your project (I think, guessing), and a similar stray 2 in package.json
thank you so much for the reply, i am a super noob, so when you say change all of those to be 0.18.0 are you referring to the error about the candidate versions? does that imply i have these versions locally stored and would go in and adjust them in my file system or?
Ah, hmm, can you try changing all of those to just be 0.18.0?
Which should be similar to how `spl-token` does things
For signing I simply put an account's creator public key inside, so they need to sign only with their own account
hello, i asked this question in solana dev and was directed here,

i am following a beginner's guide by Nader on solana dev, and at the anchor build step i am getting this error:

``` Failed to obtain package metadata: Error during execution of `cargo metadata`:     Updating crates.io index
error: failed to select a version for the requirement `anchor-lang = "^0.18.2"`
candidate versions found which didn't match: 0.18.0, 0.17.0, 0.16.2, ...
location searched: crates.io index
required by package `mysolanaapp v0.1.0` ```

im wondering if its caused by the anchor init command as that prints the following:

```Couldn't find any versions for "@project-serum/anchor" that matches "^0.18.2"
? Please choose a version of "@project-serum/anchor" from this list: (Use arrow keys)
```
but it doesnt let me choose a version it just completes, then the next command to build fails out, i didnt find anything in google so if anyone has any suggestions i am all ears
Yep, thank you!
Mm, what do you mean by useless? You can definitely still sign with it (it's the only way to sign for that address), but whether or not that matters depends on what you're doing
As you can't sign with it anything anymore, at least for transfering lamports
To reiterate, after transfering ownership the private key becomes completely useless
This was the question
Ah, yes, thank you
Yeah, but can an owner of a signature transfer lamports from it
And if your program owns the account, only it can drain those lamports (no one else, human or program or otherwise)
If your program owns the account, it can transfer/drain those lamports without any signature (maybe it asks for a signature just to be polite, but it doesn't need to!)
But this signing can be used for transferring lamports from it and thereby closing it
Hi, I'm trying to learn anchor framework but could not run the `basic-0`. I am currently using `kali-linux` on `wsl`. Solana, and anchor are successfully running. I am now confused with `solana-test-validator`. Up to when it continues the test. it processed almost 17000 slots and it is still running. How can I get the program ID for my `basic-0` tutorial?
No, don't think there are any nefarious use cases (just signing for the address, which your own program may or may not care about)
It seems like it can't because of an ownership change
But can its private key still be used by the creator for some nefarious purposes
Usually, yes (unless you specify other attributes, like `token::mint = some_mint` etc.)
Say I create an account with `init` attribute. Now it should be owned by my program, right?
Ah, sorry, misread
I used it as an example
No, I'm not talking about `spl-token` here
A token account's "owner" is kind of confusingly named—it's not the same thing as a general solana account's owner :/ In anchor terminology, it's the token's "authority"
I think it is obvious from hindsight. Though I still want to see solana's source to be completely sure
Well, I think I found an answer in that paulx's useful blogpost 
> The account owner is an internal Solana attribute that will always be a program. The new token owner attribute is something the token program declares in user space (i.e. in the program they are building). It's encoded inside a token account's data, in addition to other properties (opens new window) such as the balance of tokens the account holds. What this also means is that once a token account has been set up, its private key is useless, only its token owner attribute matters.
Which, if I understand correctly, says that when an ownership of an account is changed to some program, its private key becomes useless, and now only a program which owns an account should be able to fiddle with its funds
And what users would still be able to do with those accounts, as it is still possible for them to sign transactions with private key for this account
I'm mostly asking this to be aware whether I can use user supplied addresses instead of PDA's, as I need to have more than a single data account for each user
Also I remember I read somewhere that ownership can be changed only once, but I don't see it mentioned in the docs here
https://docs.rs/solana-program/1.8.2/src/solana_program/system_instruction.rs.html#157
Which would mean the private key becomes useless after an ownership change, right?
Yeah, in general closing an account just requires draining its lamports. Whether that requires signing depends on which program owns the account (if your own program owns the account, then it doesn't require a signature)
Also another relevant question with `close`ing accounts. Shouldn't accounts be signed to be able to close them? I think I used them with `close` attribute but they weren't signed by anyone, even though the program did own them, or is it enough?
I guess I would at least need to add a `bool` to cover this case, `Option<T>` should be better, but it doesn't work right now iirc
It would be painful
Oh, which would mean I could close an account, and in the next instruction someone might resupply it and use again?
and https://discord.com/channels/889577356681945098/889577399308656662/904457662387871836
I had the same doubt and ran into the same bug. Check out: https://discord.com/channels/889577356681945098/889577399308656662/904456667809341470
it's working <a:party_parrot:899093647033782292>


//////////////////////////////////////////////////////////////////////////////////////////

Only thing I know of is the pyth example in the tests/ folder.
I have an "Error: 162: 8 byte discriminator did not match what was expected"  And saw responses to <@!847130012879814668> 's question on this earlier - I'm using anchor v0.18 and am initializing the account passed in so not sure what's going wrong. My account validation logic is below. Thank you very much!

#[account]
pub struct OfferAccount{
    pub offeror_key: Pubkey,
    pub offeror_deposit_token_account: Pubkey,
    pub offeror_receive_token_account: Pubkey,
    pub offeror_amount: u64,
    pub acceptor_amount: u64,
}

#[derive(Accounts)]
#[instruction(offer_vault_account_bump:u8, offeror_amount:u64)]
pub struct OfferEscrow<'info> {
    #[account(mut, signer)]
    pub offeror: AccountInfo<'info>,
    pub mint: Account<'info, Mint>,
    #[account(
        init,
        seeds = [b"offer-seed".as_ref()],
        bump = offer_vault_account_bump,
        payer = offeror,
        token::mint = mint,
        token::authority = offeror,
    )]
    pub offer_vault_account: Account<'info, TokenAccount>,
    #[account(
        mut,
        constraint = offeror_deposit_token_account.amount >= offeror_amount
    )]
    pub offeror_deposit_token_account: Account<'info, TokenAccount>,
    pub offeror_receive_token_account: Account<'info, TokenAccount>,
    pub offer_account: ProgramAccount<'info, OfferAccount>,
    pub system_program: AccountInfo<'info>,
    pub rent: Sysvar<'info, Rent>,
    pub token_program: AccountInfo<'info>,
} 

And the JS for the offer_vault_account which I suspect is causing the issue:

  const [
      _offer_vault_account_pda,
      _offer_vault_account_bump,
    ] = await web3.PublicKey.findProgramAddress(
      [Buffer.from(anchor.utils.bytes.utf8.encode("offer-seed"))],
      program.programId
    );
```To resume a deploy, pass the recovered keypair as the
[BUFFER_SIGNER] to `solana program deploy` or `solana write-buffer'.
Or to recover the account's lamports, pass it as the
[BUFFER_ACCOUNT_ADDRESS] argument to `solana program close`.
=====================================================================
Error: RPC response error -32601: Method not found 
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "",```
Looks like I can't deploy to devnet, any idea please ? Thanks a lot!
This question if for C# #anchor devs.
I'm stuck of how to make a call to an anchor function from a solnet wallet client.
Did any of u figure it out before?
Thanks.
Great, I'll have a look 🙂
look at the anchor tests. I know there are plenty examples in the various programs
https://docs.pyth.network/#consumers
check the test directory for references to pyth. I'm pretty sure they aren't any. edit: I stand corrected
I tried specifying some constraints `constraint = token_mint_account.mint_authority == COption::Some(*bond_authority.key),`
 `constraint = token_mint_account.supply == 0` and also the `owner` field but to no avail. Any help would be much appreciated.
Hi there, I just started getting my hands dirty with solana developement using anchor today and I'm loving it. It is however tough to resolve issues :). My question is about using Mint from the anchor_spl crate. When I try to define a mint account such as `token_mint_account: Account<'info,Mint>` I get an error stating that the trait `anchor_lang::AccountSerialize` is not implemented for `Mint`  and the analogous error about deserialization. I also get the error stating that the Owner field wasn't specified.
<@!477913575726383125> it should be similar to this https://blog.chain.link/how-to-build-and-deploy-a-solana-smart-contract/ similar to solidity, it shouldn't be possible to make API calls  from a solana program... it wouldn't be deterministic if you could directly make external calls...with an oracle, it would make an API call on your behalf and update the state... alternately you can do the same thing by having an external program/script update an account state on chain... (i'm assuming here that solana works similar to eth in terms of requirements, but someone can correct me if im wrong)
<@!501570363566587905>  are there any examples of oracle interactions through anchor ^^^
Yeah, agreed, figured that was why 👍
Debatable
The thinking is that it’s easier to read with the object at the end of the function since you can just have the object hanging off the end.
What do you mean?
No, `new Anchor.BN(1234)` corresponds to `data: u64`
That's just the order that the anchor js stuff uses, regular args first followed by the context stuff (not totally sure why the order is switched from the rust side)
why is `my_account` != `myAccount`?
is ctx == `new Anchor.BN(1234)`?
If the initialize function looks like this:
```
 pub fn initialize(ctx: Context<Initialize>, data: u64) -> ProgramResult {
        let my_account = &mut ctx.accounts.my_account;
        my_account.data = data;
        Ok(())
    }

```
how is it able to be called with this: 
```
await program.rpc.initialize(new anchor.BN(1234), {
  accounts: {
    myAccount: myAccount.publicKey,
    user: provider.wallet.publicKey,
    systemProgram: SystemProgram.programId,
  },
  signers: [myAccount],
});
```
I use it for verifying that `update` instruction was called in the same transaction in all other instructions, however there are instructions where I want to add additional checks as well
are these 2 the same thing: `provider.wallet.publicKey` and `solana config get keypair`
ill avoid 🙂
Hi! Can I use `access_control` more than once?
many lifetimes have been spent in the pursuit of `'info`
It's a lifetime
What is `'info`?
Hi Friends. Any idea how can I get the balance of a token account inside an anchor program?I am parsing it as token_account: Account<'info, TokenAccount> but not sure now I can access token account data.
I don't know, I come from ethereum world where in solidity their are no ways to make contact with web2.0(other than chainlink) but in rust their are packages to make API calls.
hmm...that would be odd...no... you;d have to interact with an oracle program for that
Hi guys, can I make API calls inside an instruction?
or pretty much any spl thing
for a token account init for instance
if you create an account it might be used somewhere in that macro
What's the point of including `rent: Sysvar<'info, Rent>` in accounts? I don't see it directly used by instruction handlers, and don't really see how it's used when macros are expanded either
And solana-test-validator is working perfectly
I've also set:
[test]
startup_wait = 10000
Here are logs
Hey, I'm having problems running "anchor test" on wsl, I got an error message "Unable to start test validator. Check .anchor/test-ledger/test-ledger-log.txt for errors."
Hi, where can I change the keypair in target/deploy/projectname-keypair.json? I'm trying to change my program address to something new
I get an error when importing solana-sdk to the anchor project. Any hints? Seems to originate from the socket library
Going through tutorial. First program was build and deployed successfully. But then I turn on client and get this error:
```
➜  basic-0 git:(master) ✗ ANCHOR_WALLET="/Users/Home/.config/solana/id.json" node client.js
Running client.
Transaction simulation failed: Error processing Instruction 0: custom program error: 0x65 
    Program Ddd2ahTD47Yb7HYs1PyZrNzmQP9atd3vzyMj7nzc1cLB invoke [1]
    Program log: Custom program error: 0x65
    Program Ddd2ahTD47Yb7HYs1PyZrNzmQP9atd3vzyMj7nzc1cLB consumed 1336 of 200000 compute units
    Program 11111111111111111111111111111111 failed: custom program error: 0x65
Translating error SendTransactionError: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: custom program error: 0x65
    at Connection.sendEncodedTransaction (/Users/Home/src/deltaone/node_modules/@solana/web3.js/lib/index.cjs.js:4964:13)
    at processTicksAndRejections (node:internal/process/task_queues:96:5)
    at async Connection.sendRawTransaction (/Users/Home/src/deltaone/node_modules/@solana/web3.js/lib/index.cjs.js:4923:20)
    at async Object.sendAndConfirmRawTransaction (/Users/Home/src/deltaone/node_modules/@solana/web3.js/lib/index.cjs.js:6907:21)
    at async Provider.send (/Users/Home/src/deltaone/node_modules/@project-serum/anchor/dist/cjs/provider.js:81:22)
    at async Object.rpc [as initialize] (/Users/Home/src/deltaone/node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:12:31)
    at async main (/Users/Home/src/deltaone/anchor/examples/tutorial/basic-0/client.js:22:3) {
  logs: [
    'Program Ddd2ahTD47Yb7HYs1PyZrNzmQP9atd3vzyMj7nzc1cLB invoke [1]',
    'Program log: Custom program error: 0x65',
    'Program Ddd2ahTD47Yb7HYs1PyZrNzmQP9atd3vzyMj7nzc1cLB consumed 1336 of 200000 compute units',
    'Program 11111111111111111111111111111111 failed: custom program error: 0x65'
  ]
}
node:internal/process/promises:246
          triggerUncaughtException(err, true /* fromPromise */)

```
https://github.com/project-serum/anchor/blob/master/tests/escrow/programs/escrow/src/lib.rs ?
You are the best! Thank you so much 🙂
(So you'll have to find the right metadata account to pass in from the client, it's a program-derived address derived from the metaplex metadata program)
You'll have to add the `metaplex-token-metadata` library as a dependency, and then you can do `Metadata::from_account_info(the_metadata_account_you_passed_in)`
<@!832140329301311488>  you can look at the escrow example in the repository
Are there any examples for transferring Spl token to program and program then handles the distribution ?
also, do you have any examples of staking programs on Solana to share?
guys these are example programs? https://github.com/project-serum/anchor/tree/5d8b4765f2c5a2d0c5a26c639b10719e7b6f2fd1/tests the lockup one is meant to be a staking one?


//////////////////////////////////////////////////////////////////////////////////////////

I don't actually know how you could specify your String length up front another way but there could be one
Maybe
Is there any performance cost of using Anchor vs Solana Native?
so you suggest that i should declare an array of u8's for every string variable i want to store in accounts data?
Think donderper was responding to someone else, you can just pass it as the base58 string (I think), or if you want, `new anchor.web3.PublicKey("asdfasdf")`
ok cool. whats the desired way to hardcode a pubkey then?
Strings are arrays of u8s that you need to over allocate size for
thanks guys i appreciate it
You also shouldn't use strings
honestly i probably dont even need to do that since i just need the pubkey
If all you need is the mint's address (from the snippet above, seems like it) then you can just pass it as a string I think, `mint: "asdfasdf"`
im working on localhost
On which network did you create that mint?
Is there a better way to do this?
```
const token = new splToken.Token(provider.connection, "5T7CRNt6maYsBjb6tHTLHX6AYNGG9D6DduVHAcDQQj7d", program.programId, provider.wallet.publicKey);
```
okay great thanks
A `Mint` will never be program-owned, since it'll always be owned by the spl token program. So I'm actually not sure why you're getting that error yet 🤔 (Saying `Account<'info, Mint>` will actually verify that the account is owned by the spl token program, *not* your own program)
Interesting issue here. I'm writing an instruction that tries to init a token account, but the program does not own the mint. I created the mint via the command line a few hours ago. I'm getting an "account not owned by the program" error which makes sense since the mint Account I'm sending to the instruction is not owned by the program.
```
#[derive(Accounts)]
#[instruction(pool_vault_account_bump: u8, pool_shared_account_bump: u8)]
pub struct Initialize<'info> {
    #[account(mut)]
    pub initializer: Signer<'info>,
    pub mint: Account<'info, Mint>, // this account isn't owned by the program
    #[account(
        init,
        seeds = [b"pool_vault_account".as_ref()],
        bump = pool_vault_account_bump,
        payer = initializer,
        token::mint = mint,
        token::authority = initializer,
    )]
    pub pool_vault_account: Account<'info, TokenAccount>,
}
```

front end code:
```
let [poolVaultAccountPda, poolVaultAccountBump] = await PublicKey.findProgramAddress(
      [Buffer.from(anchor.utils.bytes.utf8.encode("pool_vault_account"))],
      program.programId
    );

const token = new splToken.Token(provider.connection, "5T7CRNt6maYsBjb6tHTLHX6AYNGG9D6DduVHAcDQQj7d", program.programId, provider.wallet.publicKey);

    await program.rpc.initialize(
      {
        accounts: {
          initializer: provider.wallet.publicKey,
          mint: token.publicKey,
          poolVaultAccount: poolVaultAccountPda,
        }
      });
```
Is there a cleaner way to get a Token instance of a previously created mint? Or a cleaner way to create a token account with a non program owned mint?
some of the examples/tests are using older solutions on purpose to ensure they still operate correctly until (potentially) being removed
is it safe to say that the example here is sort of outdated? https://docs.rs/anchor-lang/0.18.0/anchor_lang/derive.Accounts.html
yes, that's what I was thinking
its equivalent to:
```rs
{
    // ...
    pub abc: ...,
    
    #[account(constraint = abc.key() == xyz.abc)]
    pub xyz: Account<'info, MyAccountType>,
}
```
thank you <@!168868665456984065>!
awesome, that makes sense
so if you have `has_one = abc`, it will also check the `abc.key()` value from the context against the `.abc` property value of the data struct on the account configured with the `has_one`
You can see the literal code the macro expands to by searching the anchor codebase for `generate_constraint_has_one`: https://github.com/project-serum/anchor/blob/master/lang/syn/src/codegen/accounts/constraints.rs#L196
`has_one` checked the `.key()` value against the matching name _property_ of the data struct
how does it decide which struct will be called with .key() and which one with .owner?
because its a public key match assertion
`MyAccountType.owner == MyContext.owner.key()`
realize that this is a wrong model, but not sure how to phrase a question
so the macro checks that `MyAccountType{}.owner == MyContext{}.owner.owner`?
`MyAccountType` is an account data structure definition so it _does_ use the `#[account]` attribute
while this one `pub struct MyAccountType {` doesn't have `#[account]` (because it's custom)?
yes
`pub struct MyContext<'info> {`  has a `#[derive(Accounts)]` before, right?
`has_one` does a public key match assertion on the names under the hood
so if you have a custom account data struct like:
```rs
#[account]
pub struct MyAccountType {
    pub owner: Pubkey,
}
```
and instruction context like...
```rs
#[derive(Accounts)]
pub struct MyContext<'info> {
    pub owner: Signer<'info>,

    #[account(has_one = owner)]
    pub acc: Box<Account<'info, MyAccountType>>,
}
```
anchor asserts that the account data `owner` pubkey is the same as the `owner` pubkey in the context for the iinstruction
got it, thanks! what is also confusing to me is how `#[account(has_one=field)]` checks the equality under the hood, via public key of the field below the macro and the key of the target `field`?
hi guys, i am stroring this in an account:
```
let name = "new hot collection";
    let artist = "picasso";
    let symbol = "NHC";
    let description = "buy it or miss it";
    let tile_image_url = "http://test/0.png";
    let author_image_url = "http://test/1.png";
    let mint_price = "3.50";
    let total_supply= 5;
    let total_minted= 0;
```
but when i retrieve the values, it shows:
```
name: new hot collection

                artist: picasso

                symbol: NHC

                description: buy it or miss it

                tile_image_url: undefined

                author_image_url: undefined

                mint_price: undefined

                totalSupply: 5

                total_minted: 0
```
`Account` is for accounts with typed or structured data
`AccountInfo` is also more or less deprecated (there are better options for the same purpose), but `AccountInfo` is for untyped or generic accounts like wallet addresses
right, and `AccountInfo` vs `Account`? 😅
`#[account]` is a macro that does a lot of trait derivation and implementations for custom account data struct types to make them (de)serializable with borsh
no. `Account` is generic struct used in the context definition for an instruction on individual accounts...for instance `pub counter: Box<Account<'info, CounterType>>`
I mean this one https://docs.rs/anchor-lang/0.18.0/anchor_lang/prelude/struct.Account.html
hey perhaps you could clarify this one too: is `struct Account` the same as `#[account]`?
ok cool, thank you 🙂
for `#[account(signer)]` vs `Signer<'info>`, personally i would consider the former to be deprecated, but that would be a big breaking change to a lot of existing programs so i assume that's why its still there as an option.
ok, are there any use cases for the other approach? or can it be considered deprecated
(imo)
internal to the anchor code base, constraints and account types are implemented _very_ differently. custom account types like `Signer` are used as more verbose logical wrappers around a constraint or set of constraints but also leaves room for additional security and ownership checks to be more easily implemented in future versions of anchor
thanks, why?
yes, but the use of account types (`Signer`) over constraints is preferable
Also I am trying to store a url as string in a variable, but it shows undefined when it's value is retrieved
Is this
```
#[account(signer)]
pub user: AccountInfo<'info>
``` 
the same as
```
pub user: Signer<'info>
```
Use unsigned ints and track the number of decimal places in another variable
Should I store them as string?
What can I do to store floating point numbers?
Can't use floating point numbers
nvm, this answered my question
can i declare any amount of space for a string in a new account?
oh right🤦
32 bits = 4 bytes
hi guys, qq how much space does `f32` take?(while creating a new account)
So if you want to do some checks using these with the #[account] macro you can
<@!800894271737561121> It allows you to user these args (bump & data) in the struct below
what does specifying the instruction macro there do? and also could anyone point to where in the anchor rust docs it speaks about specifically that? ty so much!

That fixed it, thanks a lot!
Updating solana-cli solved the problem for me `sh -c "$(curl -sSfL https://release.solana.com/v1.8.2/install)"`
Does anybody have any idea about this?
hi devs, quick question, I want to start creating solana programs, but I'm wondering if it's best to just write raw Rust using solana doc to start with or go ahead and use anchor framework
Tried to follow this issue https://github.com/project-serum/anchor/issues/987#issuecomment-963041266 but also didnt work
Does anyone know how to get around this?
```
    Updating git repository `https://github.com/project-serum/anchor`
  Installing anchor-cli v0.18.0 (https://github.com/project-serum/anchor#ac3fbe8d)
    Updating crates.io index
error: failed to select a version for the requirement `anyhow = "=1.0.43"`
candidate versions found which didn't match: 1.0.38, 1.0.37, 1.0.36, ...
location searched: crates.io index
required by package `anchor-cli v0.18.0 (/Users/peter/.cargo/git/checkouts/anchor-bf03d42499b9267c/ac3fbe8/cli)```
is the command I am running on my m1 mac and get the following error
Hey here from _buildspace. I havent been able to get the anchor-cli installed
```cargo install --git https://github.com/project-serum/anchor anchor-cli --locked````
hey y'all, total noob question (here from buildspace), but I can't get bpf to load, or it's not in the path ... I'm just a bit confused ... any direction would be appreciated (I'm running Manjaro Arch)
Can't seem to fix this, cluster is "devnet", recreated new keypairs, nothing works hmmm
Answered my own questions `solana program dump <address> <output path>`
Is there a simple way to download the .so for a program from dev/test/mainnet so I can deploy it to devnet?
Can zero copy be implemented with Vec types?


//////////////////////////////////////////////////////////////////////////////////////////

okay thanks. i can share whatever code necessary. i'm a total noob with this, so im thankful for any help
brb but i'll see if i can take a look in a bit
but when i change that `useAnchorWallet` to just `useWallet` it works fine.
```
TypeError: Cannot read properties of undefined (reading 'publicKey')

> 89 |   const { publicKey, signTransaction } = useAnchorWallet();

```
but I get an error that looks like the app is trying to access thos propertied before the user connects a wallet
```
export default function Home() {
  const { publicKey, signTransaction } = useAnchorWallet();

  other code...    
  }
```
in my page component I'm trying:```

```
i'm trying to use the `useAnchorWallet` hook in my function in order to send a transaction with the connected wallet
not sure about example links (pls chime in if anyone else's got some), but we've set up anchor + nextjs before. can you be more specific about where you're getting this issue?
i keep getting an undefined error when trying trying `useAnchorWallet`
i am running into a ton of issues getting Anchor working in NextJS, does anyone have an example they could link me?
Is this the only way which people uses generally to store large amount of data ? Are there any examples of it
Not 100% sure about this, but I wouldn't be surprised if you also have to be kind of careful about checking membership in the list, because of compute budget (not sure, would be curious to know if looping over all 10k is possible—probably safer to store them in sorted order + use binary search, etc.)
It's possible, but it will be kind of a pain—you'll have to create the account in a separate instruction (doing the usual `init` stuff won't work, that account is too big), you'll have to use #[account(zero_copy)] and AccountLoader etc. And 10k addresses ~ 320kb, so it'll cost you something like $500 to store the account's space.
I have around 10k addresses that I want to store in a program ... Would it be possible ? I want to check in my another program if the passed account exists from those or not ?
Hello!

After doing an anchor init, when trying to do anchor test after changing anchor.toml to 
```test = "npx mocha -t 1000000 tests/"```
 I'm getting:

```Translating error Error: Transaction was not confirmed in 30.01 seconds. It is unknown if it succeeded or failed. Check signature 2R4L1qejw5RmvJARoD8PQKY94T7nZEWRkyUhEfrPYy1kAGWFu2mr5nkT62tGgszjXzTHH4FWjrUUhp4DhBHJ9i37 using the Solana Explorer or CLI tools.
    at Connection.confirmTransaction (/Users/simplex/workspace/solana_project/myepicproject/node_modules/@solana/web3.js/lib/index.cjs.js:5631:13)
    at async sendAndConfirmRawTransaction (/Users/simplex/workspace/solana_project/myepicproject/node_modules/@solana/web3.js/lib/index.cjs.js:8514:19)
    at async Provider.send (/Users/simplex/workspace/solana_project/myepicproject/node_modules/@project-serum/anchor/dist/cjs/provider.js:85:22)
    at async Object.rpc [as initialize] (/Users/simplex/workspace/solana_project/myepicproject/node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:11:31)
    at async Context.<anonymous> (/Users/simplex/workspace/solana_project/myepicproject/tests/myepicproject.js:11:16```


Any idea what's happening?
Would be shocked if someone has beaten you to it lol.
That would be pretty cool if you wrote one!
Speaking of illegible runtime type errors, has anyone written a purescript translator for Anchor IDL?
Right, those aren't initialized during deployment (no accounts are besides the accounts that hold the program's own code). You'll need to run some specific instruction to `init` that account.
hey folks, I've got some dumb questions, but I can't find answers myself, hopefully someone could help.
so, I'm trying to invoke a program. I'm confused by Accounts. a few of accounts that my program uses were initialized by something like this: `#[account(init, seeds = [b"some-seed".as_ref()], bump = bump, payer = someAccount)]`
I would assume this would initialize the account during the deployment phase, but if my assumption is correct I can't find a way to get a correct address to pass in.
Yeah, I was able to figure it out over in the <#889577399308656662>  thread. I think it was just my lack of experience with Rust that was throwing me. I wasn’t calling the Ok(()) function after my transactions.
i think you can simply invoke such transfers back-to-back, no? not exactly the same example, but the rent transfer during account init in anchor is called consecutively with other `invoke_signed`s. you could take that transfer `invoke` & simply repeat it with different amounts and receivers https://github.com/project-serum/anchor/blob/468fe79473328bf08ff293cfe85181cfb1ddd2d1/lang/syn/src/codegen/accounts/constraints.rs#L612
Thank you very much that has sorted it.
It's declared as a u64, which is too big (or could be) for a JS number, since JS numbers are doubles and can only represent integers up to 2^53.
Gotta pass that 98 as a `new anchor.BN(98)`
Hi Guys, 
I developing a Solana program and getting an error I can't figure out when I run anchor test. 
It comes from this function in my program. 
```
pub fn add_gif(ctx: Context<AddGif>, image_link: String, pool_name: String, pool_desc: String, win_opt:String, close: u64, verify:String) -> ProgramResult {
        let base_account = &mut ctx.accounts.base_account;
        let wins: Vec<String> = win_opt.split(';').map(|s| s.to_string()).collect();
        let pool = PoolStruct{
            pool_id: base_account.total_pools,
            image_link: image_link.to_string(),
            user_address: *base_account.to_account_info().key,
            pool_name: pool_name.to_string(), 
            pool_balance: 0,
            pool_description: pool_desc.to_string(),
            win_options: wins, 
            close_date_time: close,
            verify_url:verify.to_string(),
        };
        base_account.pool_list.push(pool);
        base_account.total_pools += 1;
        Ok(())
    }
```
And from this test run. 
```
await program.rpc.addGif("insert image linke here", "Test Pool","This is a test Pool", "option1; option2",98, "Verify here",{
    accounts: {
      baseAccount: baseAccount.publicKey,
    }
  });
```
I get the error  ```TypeError: src.toArrayLike is not a function ```
stupid question, is there someone who can tell me how to sing up The Anchor Program Registry?
<@!134416332509675520> thank you so much. That seems to do the trick.
You'll need to `cd programs/<your-prog-name>` and edit the Cargo.toml file in there
How would I change anchor-lang's version? Reinstalling anchor to 0.18.0 doesn't seem to do the trick.
I keep getting this error. This is my first time trying solana. 

Thanks in advance.
Looks like from the source they do the same thing in terms of `solana deploy`, it's just that `anchor deploy` does some extra stuff with the IDL
can I just use anchor deploy to upgrade my program
is there a difference between anchor deploy vs anchor upgrade?
i have a project with a couple of programs, some of which are deployed already. when i run anchor test, the target/idl removes the program ID from these deployed programs. what do i have to fix to prevent the loss of these program id's?
security thing
a team that I am working with only share part of their anchor idl
i see, thank you!
So if `takerMainAccount` is the user's wallet, you don't need to add it to `signers`
You won't be able to get a keypair from the user's wallet (that would mean the wallet leaked their secret key to you! definitely won't let you have that). You'll instead  have to ask the wallet to sign the transaction (this usually happens implicitly because it's the wallet used by the `program.provider` and already automatically signs the tx)
hi there, for a function call like this one in React, how do you get the signers KeyPair (i.e. takerMainAccount) from a users' wallet? (I have access to the wallet through @solana/wallet-adapter-react)
```
    await program.rpc.exchange({
      accounts: {
        taker: takerMainAccount.publicKey,
        takerDepositTokenAccount: takerTokenAccountB,
        takerReceiveTokenAccount: takerTokenAccountA,
        initializerDepositTokenAccount: initializerTokenAccountA,
        initializerReceiveTokenAccount: initializerTokenAccountB,
        initializer: initializerMainAccount.publicKey,
        escrowAccount: escrowAccount.publicKey,
        vaultAccount: vault_account_pda,
        vaultAuthority: vault_authority_pda,
        tokenProgram: TOKEN_PROGRAM_ID,
      },
      signers: [takerMainAccount]
    });
```
ah awesome ty! guessed that but wanted to confirm 🙂
Yeah, if you don't specify it then anchor has to calculate it using `Pubkey::find_program_address`. This takes a variable amount of compute (each bump has about a 50/50 chance of working, so might have to try multiple bumps) so might not be a good idea if you're near the limit.
just to make it easier to derive the pda or something?
```
    #[account(
        mut,
        has_one = config,
        has_one = wallet,
        seeds = [PREFIX.as_bytes(), config.key().as_ref(), candy_machine.data.uuid.as_bytes()],
        bump = candy_machine.bump,
    )]
```
whats the "bump" for here
I'm curious, how do you only have a partial idl?
Ok, best bet is probably to just read the anchor source and copy whatever you can
It works now using `@project-serum/borsh` but a little tedius
oh I only have partial incomplete idl , try that method and doesn't work
So you don't want to/can't do this via a `Program` instance? You can also do `let coder = new anchor.AccountsCoder(theIdl)` and then (I think) do `coder.decode("MyAccountType", someBuffer)`
from '@project-serum/borsh'
or do I need to write my own Buffer.Layout from scratch
stupid question but if I have IDL json file, Is there a helper class to help generate Layout in javascript so that I can decode the account data?
If there is a good use for this, might be a good excuse for me to learn
This is fascinating… I want to learn more about the Ed25519 curve
Ok, well, I figured out how to use that Ed25519SigVerify111111111111111111111111111 program, now have to figure out what to actually use it for 🤔
but it looks like this program doesn't provide such low-level functionality, but also I could just copy it and expose that I suppose
Ah, ok (yeah, I'm just getting nerd-sniped by a separate thing).
oh, and invert scalars
In my case, I'm not using it for authentication. I need to be able to add and multiply points by scalars and check for equality
Ah, I guess you're supposed to invoke it as a separate instruction—if sig verification fails it will abort the rest of the tx. Ok, hmm, will see if I can get that working.
I don't know haha, solana just won't let me 😛
Why can't you invoke it from within your program?

I'm curious about this too, e.g. I tried just now messing around with https://github.com/solana-labs/solana/blob/2400e86d136f5c151eb447bd7fbda6fed4068f49/docs/src/developing/runtime-facilities/programs.md#ed25519-program but you can't even invoke it from within your program lol, so I'm unclear on what the purpose is
that'd be awesome
thanks!
Ah, bummer—if you don't get a response I met a few of the devs at breakpoint, could try pinging them directly
(although it was only a couple minutes ago)
no response
Have you tried asking in the solana discord?
My guess is that even if you manage to get it compiling, you'll probably hit the compute limit :/ Not 100% sure about that but wouldn't be surprised.
Actually, I just noticed that if I remove a couple functions, I can entirely get rid of the dependencies on random_core and then cargo build-bpf completes with exit-code 0 (albeit with some error-messages. I'm not sure whether they're important): https://github.com/davidspies/curve25519-dalek/commit/2c270a2da313b1a2f1a6df7c506ec2448a1ff7e8
If you search the discord for ed25519 you can find some prior discussion of similar things, seems like there maybe aren't great workarounds yet though I'm not sure.
I think this unfortunately doesn't work (as you found)—when the solana sdk uses curve25519-dalek its not running within a solana program/via bpf 😦
I want to write a dApp that depends on `curve25519-dalek`. I tried putting it under `[dependencies]`, but when I run `anchor build`, I get
`error: target is not supported`

It seems like it should be possible considering that `solana-program`  makes use of it.
How can I do this?
<@!902276723251490836> that's correct, when you batch instructions together they are executed together in the transaction. running them separately, you can inspect the program logs to see how much of the compute budget each uses
Hello, 

I have a very noob question and would really appeciate if someone can help me with this. 

I am trying to chain my transaction like this: 
```
      const txn = new anchor.web3.Transaction();
const instructionOne = program.instruction.instructionOne({....})
const instructionTwo =  program.instruction.InstructionTwo({....})

txn.add(instructionOne)
txn.add(instructionTwo)

await provider.send(txn);

```


When I run this it reaches computation limit during transaction simulation however, if I run the instruction as individual RPC calls it works fine without reaching computation limit. Is the computation shared for the entire transaction and not independent of the instruction?

Is there a way I could accomplish this without reaching the computation limit?
okay onto my next beginner question. I'm trying to write a program that takes a transaction amount and sends a certain percentage to one account, and the rest to another. i think i have all of the pieces working individually, but I'm not sure how to call two separate `anchor_lang::solana_program::program::invoke` functions in my singular program. Anyone have pointers to resources where I could learn how to achieve this?
wait, disregard i think. i was running on localhost instead of devnet which is where my balance discrepancy was coming from (i think)
i keep getting a number that is not correct for my account balance. I though i needed to use `anchor.BN()` in order to parse it, but that throws a `this._init is not a function` error. What am I doing wrong here?
hey guys! super new to this framework, but loving it so far. quick question - I'm just trying to read account balance in my js test file, but I think i'm doing something wrong


//////////////////////////////////////////////////////////////////////////////////////////

Via the metaplex UI ? No idea but if you CPI then you can set the authority you want
https://discord.gg/cDa7J7Yn
if this is getting too much into metaplex np i'll ask elsewhere
one more question, when minting with metaplex, what account is set for the mint authority and update authority. Are they both set to the current wallet?
thanks Afro and cqfd
So I advise to build on metaplex and extend with your own program pda if you need to have additional values for your nft
No idea but it is the de facto solution nowadays I think, it's supported by most marketplaces etc... Doing a custom solution wouldn't be recommended
okay very cool. does anyone really NOT use metaplex for nfts?
Metaplex gives us the foundation for the NFT schema and anyone can extend upon it
A nft is basically a spl token with a metaplex pda that holds the NFT data
ah okay thats why. so its stored in the user data of the token then?
The mint authority is global to the spl token
Update authority is only for metaplex
It's not actually an spl token thing, it's a metaplex thing
Thanks. Strangely in the spl token solana docs i dont see update authority mentioned anywhere.
Funny, I had never noticed the mint authority was optional, good to know! 🙏
Mint authority = The authority that can create more of the token (mint), not mandatory, if not specified during the spl token creation the supply will be fixed & final I think,  as for the update authority, it is the authority that can update the nft metadata
Hi all, can anyone briefly explain the difference between the mint authority and the update authority on an NFT SLP token?
Heh, also not sure what you mean here
Hmm, not sure what you mean 🤔 You pass those seeds + bump to solana's machinery for making a cross-program invocation, and if they look good then the receiving side of the CPI will see that that account (address, technically) signed the call.
The purpose of the bump is to make sure you *don't* lie on the curve, so not sure what you mean (`mint_bump` can't just be anything, it has the be the *right* bump)
do you have an example of exactly this? with the usdc or some other token?
i understand the seed is being used to generate the signature. but how do you find the signature to be used later? / where is it being used?
https://github.com/cqfd/anchor-token-studies/blob/main/programs/token-studies/src/lib.rs
<@!134416332509675520> what if mint_bump lies on the ed25519?

https://github.com/cqfd/anchor-token-studies/blob/8c203ec85487c79dc1088c2fdeda1039235bec4f/programs/token-studies/src/lib.rs#L22
You might want to install v16.x
What's the node.js version ?
thx.  Do you know if there any working examples of this?  This  

`from node:17
WORKDIR /usr/src/app
copy package*.json ./
RUN npm install
COPY . .
EXPOSE 3000
CMD ["npm", "run", "start"]]
`
blows up:

`Starting the development server...

Error: error:0308010C:digital envelope routines::unsupported
    at new Hash (node:internal/crypto/hash:67:19)
    at Object.createHash (node:crypto:130:10)
    at module.exports (/usr/src/app/node_modules/webpack/lib/util/createHash.js:135:53)
    at NormalModule._initBuildHash (/usr/src/app/node_modules/webpack/lib/NormalModule.js:417:16)
    at handleParseError (/usr/src/app/node_modules/webpack/lib/NormalModule.js:471:10)
    at /usr/src/app/node_modules/webpack/lib/NormalModule.js:503:5
    at /usr/src/app/node_modules/webpack/lib/NormalModule.js:358:12
    at /usr/src/app/node_modules/loader-runner/lib/LoaderRunner.js:373:3
    at iterateNormalLoaders (/usr/src/app/node_modules/loader-runner/lib/LoaderRunner.js:214:10)
    at iterateNormalLoaders (/usr/src/app/node_modules/loader-runner/lib/LoaderRunner.js:221:10)
/usr/src/app/node_modules/react-scripts/scripts/start.js:19
  throw err;`
But you need to have it setup in your package.json file.
npm run start
npm / node nube question:  I'm trying to create a dockerfile to package my completed anchor created test app to deploy.  I'm very familiar with docker but not at all with node.js.  For development I've been using `npm start run`, for deployment i was trying to `node app.js`  but that doesn't work.  What's the "production" version of `npm start run` to use as the entrypoint in docker for an anchor created app?
See here: https://discord.com/channels/889577356681945098/889702325231427584/898235903540080650
Think of the seeds as the program's "name" for a given program-derived address (an empty name is fine)
what is the bump for?
It just happens to be empty (seeds can be whatever you want, including empty)
And it happens to have an empty seed (the &[], you can actually just get rid of it)
why is the first seed an empty array?
As for what they're for, this is just solana's kind of odd api for letting a program "sign" for a program-derived address
in this case: &[&[&[], &[mint_bump]]],
there is only 1 PDA's seeds + bump
So you've got an array (slice, whatever), each of whose elements is a collection of individual seeds (plus a bump, usually). Each seed is a slice of bytes.
Try to mentally ignore the ampersands (they're just a rust thing). The default rust formatter indentation doesn't help either, think of it as:
```.rs
&[
  // first pda's seeds + bump
  &[ seed1, seed1, b"for example".as_ref(), &[bump] ],
  // second pda's seeds + bump
  &[ some_other_pdas_seed, &[its_bump] ],
  // etc.
]
```
can someone explain what the heck signer seeds are: `&[&[&[], &[mint_bump]]],`

I dont understand all of these `&`
Hey all, this might be a super noob question but i haven't really seen it addressed anywhere? I've got some code which looks like this:

```javascript
import kp from 'lib/keypair.json';

const arr = Object.values(kp._keypair.secretKey)
const secret = new Uint8Array(arr)
let baseAccount = web3.Keypair.fromSecretKey(secret);
```

now i want to deploy the project but assume the `keypair.json` shouldn't be stored in git? I've seen env variables being mentioned but isn't that also not ideal? As you'd be storing the secret key with the hosting provider? I guess i'm just wondering how others handle keypairs/deployment
In other words, when some address derived from your program needs to sign the CPI call
`::new_with_signer` is for when you need to add in signatures for PDA addresses
when should you use CpiContext::new_with_signer vs. CpiContext::new?
got it
My guess is that there isn't any yet, you'll have to just read the source (it's not doing anything super complicated, just constructing some `invoke_signed` calls to the spl token program).
where is the documentation for anchor_spl?
this just seems v raw
https://docs.rs/anchor-spl/0.18.0/anchor_spl/token/index.html
I guess that's good enough
In the end I decided to go with this implementation ```
#[derive(Accounts)]
#[instruction(_mint_bump: u8)]
pub struct StartSession<'info> {
    #[account(mut, seeds=[PREFIX.as_bytes(), &token_account.mint.to_bytes()], bump = _mint_bump)]
    ows_metadata: Account<'info, NftData>,
    #[account(
        constraint = mint_account.mint_authority.unwrap() == Pubkey::from_str(AUTHORITY).unwrap(),
    )]
    mint_account: Account<'info, Mint>,
    #[account(
        constraint = token_account.mint == mint_account.key(),
        constraint = token_account.owner == *user.key
    )]
    token_account: Account<'info, TokenAccount>,
    user: Signer<'info>,
}
```
Yeah, as <@!194280119710253068>  said, couple things going wrong here: 1) solana doesn't really support hashmaps (can search the discord—you can actually sort of make it work but, yeah), and 2) the anchor cli itself doesn't know how to turn them into IDL. For now your easiest bet is to just use a sequence of key-value pairs unfortunately.
could be wrong
I don't think you can serialize hashmap's yet
Might sound stupid but by passing a token account I know I can access its mint pubkey but would it be possible to also do a check on the Mint data ? LIke ```token::mint::mint_authority === XYZ``` ? Thanks!
Nope still trying to get it solved too. I ended up uninstalling everything and trying to build solana from source but having problems there too now 😢
I am new to anchor and to rust, i am getting the following error when i try to test with `anchor test` 
```IdlError: Type not found: {"name":"seedIndex","type":{"defined":"HashMap<String,usize>"}}
    at Function.fieldLayout (/Users/srao13/Code/Personal/crypto/buildspace/solana-avatar-app/pixel-art-solana-app/node_modules/@project-serum/anchor/dist/cjs/coder/idl.js:97:31)
    at /Users/srao13/Code/Personal/crypto/buildspace/solana-avatar-app/pixel-art-solana-app/node_modules/@project-serum/anchor/dist/cjs/coder/idl.js:119:36
    at Array.map (<anonymous>)
    at Function.typeDefLayout (/Users/srao13/Code/Personal/crypto/buildspace/solana-avatar-app/pixel-art-solana-app/node_modules/@project-serum/anchor/dist/cjs/coder/idl.js:118:54)
```

i have the struct defined as follows 

```#[account]
pub struct BaseAccount {
    // list of the pixel arts stored in the account
    pub pixel_art_list: Vec<PixelArtStruct>,

    pub seed_index: HashMap<String, usize>,
}```

This compiles fine, but anchor deployment to local is failing
state is deprecated but the tutoirials are fine
hey guys, I'm wondering whether the tutorials are incomplete?
At the end of Cross Program Invocations ( https://project-serum.github.io/anchor/tutorials/tutorial-3.html ) it says:
> Up until now, we've treated programs on Solana as stateless. In the next tutorial we will learn how to add a global state to our program.
However the next section is on errors and e.g. the #[state] directive is never explained.
So it seems like the state section of the tutorials is missing...
Hey guys! When I’m calling program.rpc.ix-handler, I’m not able to catch the custom error even though I place it inside try catch block. The console prints: Uncaught exception … and so on. Am I missing anything?
Oh I see 👍
actually im just calling the candymachine contract using anchorpy haha.. thats from the IDL
Ah ok got it, because you're doing a CPI?
oh i need to pass the clock account to the program though
Cause `anchor init --help` doesn't specify any way to use npm instead of yarn
Should I maybe create a GH issue or did I miss something in the docs?
Not really a question, more of a suggestion; there should be some kind of fallback for anchor to use npm instead of yarn if it's not installed...
You can now also just do `Clock::get()?` in your program, no need to pass the sysvar account
anchor.web3.SYSVAR_CLOCK_PUBKEY,
i found
ah nvm sorry
see this as part of the IDL
```
        IdlAccount(name="tokenMetadataProgram", is_mut=False, is_signer=False),
        IdlAccount(name="tokenProgram", is_mut=False, is_signer=False),
        IdlAccount(name="systemProgram", is_mut=False, is_signer=False),
        IdlAccount(name="rent", is_mut=False, is_signer=False),
        IdlAccount(name="clock", is_mut=False, is_signer=False),
```
is there a standard clock program on solana?
Hi there, I am trying to install Anchor from the buildspace class and am getting the following error message. Any ideas where I should look to debug? ```➜  ~ cargo install --git https://github.com/project-serum/anchor anchor-cli --locked
    Updating git repository `https://github.com/project-serum/anchor`
  Installing anchor-cli v0.18.0 (https://github.com/project-serum/anchor#468fe794)
    Updating crates.io index
warning: package `cargo_toml v0.9.3` in Cargo.lock is yanked in registry `crates-io`, consider running without --locked
warning: package `zeroize_derive v1.1.0` in Cargo.lock is yanked in registry `crates-io`, consider running without --locked
   Compiling proc-macro2 v1.0.29
   Compiling libc v0.2.101
   Compiling syn v1.0.75
   Compiling unicode-xid v0.2.2
   Compiling serde_derive v1.0.130
   Compiling serde v1.0.130
   Compiling version_check v0.9.3
   Compiling cfg-if v1.0.0
   Compiling autocfg v1.0.1
   Compiling typenum v1.13.0
error: linking with `cc` failed: exit status: 1```
Did you ever find a solution to this?
epic knowledge download, thanks
Just exactly what I was seeing, great reading, thank you again
I guess it is the same for mainnet
I though I was doing something wrong
thanks for the info very very much
oh man
https://jstarry.notion.site/Program-deploys-29780c48794c47308d5f138074dd9838
You have to do a bazillion transactions while deploying because deploying uploads your compiled contract into an account, and even for a simple contract it will be ~100kb at least, and a given solana transaction can only be 1232 bytes 😬 So deploying has to chop your code up into little pieces and deploy them all in separate transactions.
maybe thousands, not sure why lol it's just a simple Initialize() program
So it seems that after doing anchor init and funding wallet on devnet, when I do anchor test and I look my transactions on devnet there's hundred of consecutive transactions marked as: "Bpf-Upgradeable-Loader: Write" 😐
It's just slightly too restrictive when they're together
Ughhhh
too late I already reimplemented it ⚓ ⚓ ⚓ ⚓ ⚓
You can split them out into separate functions easy enough. It's not a fun function by itself
is `createMintAndVault` in `@project-serum/common` still the recommended way to do the thing?
Thanks!
gotcha
Nano is a super simple editor, can ignore it and use vscode or whatever
I am going off this
https://swaroopmaddu.medium.com/solana-installation-in-macbook-m1-b08582d50db1
the nano thing I do not know what is going on... never seen it before
nano ~/.cargo/config
[target.x86_64-apple-darwin]
rustflags = [
  "-C", "link-arg=-undefined",
  "-C", "link-arg=dynamic_lookup",
]

[target.aarch64-apple-darwin]
rustflags = [
  "-C", "link-arg=-undefined",
  "-C", "link-arg=dynamic_lookup",
]
Yea... there is something with this comman
Think you'll have to post more of the error, but I can maybe spot an openssl in there 👀 You'll need to brew install openssl and maybe link it or something
any help....
this when I run cargo build on solana
I am currently downloading Anchor/Solana on an M1 mac and I keep running into the issue of
alright, thank you so much nonetheless 🙂 very much appreciated
you might want to reach out in the solana discord. Seems like this is a local validator issue.. thats the only thing i can think 😦 im not so smart about all this stuff yet lol
this didn't do the trick unfortunately :/
exactly the same way as before... just fetching it from .env like so: `const provider = anchor.Provider.env();
    anchor.setProvider(provider);`
Are you setting up your provider in a weird way?
only thing i can think is to delete the `test-ledger` folder and restart the validator
looking for help here 🙂
thank you so much!! 🙂
Did someone come across this here at some point?
``` 
Error: Account allocation failed: RPC response error -32002: Transaction simulation failed: This account may not be used to pay transaction fees 
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.
```  
I am running a code snippet that just worked, but I get this now. I have spammed my localhost with RPC calls quite a bit, is there a rate limit, or is it only my code?
Not sure it’s the right way and I think we had a bit of cruft in it but it’s been a perfectly decent abstraction for our use cases
I’m also out so not a rush by any means
thanks a ton!
might save me an hour or two plus show me the “right” way
Out atm but I’ll see what I can do!
any chance of you sharing that context/provider example?
There might be multiple ways to do this but with react (& ofc next) + anchor I prefer to make a context for the fully configured anchor provider, and then use a hook for that in any component where I might need to sign txns. Never had to use window.solana
also this
https://discord.com/channels/889577356681945098/889702325231427584/904857067888734298
cause I’m accessing the user wallet by calling useWallet then just passing window.solana into getProvider in order to sign transactions with the connected wallet. is that how I should be doing this?
like where would that hook be used in a “typical” anchor app
Can you elaborate on this q?
so would that hook just get passed into getProvider instead of window.solana?
there's also this, but they are not clear at all lol
https://docs.solana.com/developing/on-chain-programs/debugging
msg is to write to the Program Logs. if you are running `solana-test-validator`, you can open another terminal and run `solana logs -u localhost` to stream the program logs
so how can i use `msg!` to debug my program? i.e. where can i find what is printed?
not positive, but only difference i see in the implementation is this return value when connected vs not connected. i wouldn't be surprised if it's that anchor requires the wallet to be `undefined` if not connected. curious if other folks know
but now that i forged ahead without the anchor specific hook, and i haven’t noticed a difference. do you know what the reason for using the specific anchor hook would be?
meaning, `useAnchorWallet` doesn't support destructuring safely the way `useWallet` does. looking at the source here https://github.com/solana-labs/wallet-adapter/blob/7f907db42b5a6e2c7937830be12c6f3006a8682c/packages/core/react/src/useAnchorWallet.ts#L17, if `publicKey`, `signTransaction` or `signAllTransactions` are falsy, it returns `undefined` for the wallet instance, so destructing will break the way you found
yeah that’s what i found too. publicKey is undefined instead of null
so this looks like an api difference between `useAnchorWallet` & `useWallet` specific to whether or not the wallet is connected
If I need to deploy some token mints or anything else I'll need to do that using a [scripts].
but does this get extended to localnet as well?
So I'm trying to figure out the workflow to go from writing unit tests to deploying on localnet. Right now the only access to workspaces is via tests, so it looks like otherwise I need to run anchor localnet in a window, then anchor deploy to deploy my program. The issue I'm having is that I need to deploy some dependencies before I can start messing with my front-end. I have a couple non-anchor program dependencies. It looks like to do the tests we add something like 
```
[[test.genesis]]
address = "9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin"
program = "deps/spl_token_swap.so"
```
the program works in my tests properly, now im trying to implement it using a NextJS frontend
What im trying to accomplish is having a user connect with their wallet using `@solana/wallet-adapter` and using that wallet to send SOL via my program


//////////////////////////////////////////////////////////////////////////////////////////

Thank you!
or if you just have the raw bytes then something like:
`program.account.treasuryData.coder.accounts.decode("treasuryData", x.account.data) as TreasuryData`
totally
```
let treasuryData = await program.account.treasuryData.fetch(
  treasuryAddress
);
```
I see that the account's type is present in `idl`
Good day! Are there any convenience functions in idl to deserialize an account's state? Similar to `getAccountInfo` for `spl-token`?
Yes spent too much time in the hotel room working on last minute things... And also too shy to come say hi to the Solana Heroes, next time <:blushhug:894787824342167573>
Hope to meet with everybody on next conf 🤗
Yes me neither, I'm just still stupid from the drinking in Lisboa, not a real issue I'm just passing unexpected input
Never though about seed len 🤔 https://docs.rs/solana-program/1.8.3/src/solana_program/pubkey.rs.html#209-216
```
    const [_metadata, metadata_bump] = await anchor.web3.PublicKey.findProgramAddress(
      [
        Buffer.from(anchor.utils.bytes.utf8.encode("metadata")),
        METAPLEX_PROGRAM_ID.toBuffer(),
        makerTokenAccountA.toBuffer(),
      ],
      METAPLEX_PROGRAM_ID
    );
```

Works. Thanks!
Ok
Think you need to turn that pubkey into a buffer too
I still have the issue now that I use the right bump seed `TypeError: Max seed length exceeded`

Seed is supposed to include the program ID to for metaplex

```Typescript
    const [_metadata, metadata_bump] = await anchor.web3.PublicKey.findProgramAddress(
      [
        Buffer.from(anchor.utils.bytes.utf8.encode("metadata")),
        Buffer.from(anchor.utils.bytes.utf8.encode("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")),
        makerTokenAccountA.toBuffer(),
      ],
      new PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")
    );
```

Is that why it's too long? Did I got equivocated with tobuffer/tobytes? (this is the typescript code)
My q is, does this have to be a custom rust program or can I just execute these functions in a sequence in a typescript frontend using the token programs inbuilt js burn functions etc.
Hey all so I am building a script  to 'upgrade' an NFT, this basically means the user clicks to upgrade in the frontend, it burns some NFTs from their collection (they sign for each txn) and a new one is minted to their wallet
Oh I see. thanks Alan that's probably it ❤️
Yeah, you'd have to deploy (I tend to just let anchor test spin up its own validator)
I think the problem you'll have there is that `seeds = ` will verify the address against *your* program_id, not the metadata program's id. Not sure anchor supports verifying a PDA derived from a different program (using attributes, can still do it manually)
nft_mint() returns a `Pubkey`, the others two are `str`
using something like :
```Rust
    #[account(
        seeds = [
            PREFIX.as_bytes(),
            METAPLEX.as_bytes(),
            &escrow_account.nft_mint().as_ref()
        ],
        bump
    )]
    pub metadata_account: AccountInfo<'info>,
```

Am I doing something stupid <:thinkingpepe:746135853386039376>
I have having the same issue, I'm doing this in the IDL in the anchor context
Whenever you run `anchor test` and call `init_mint` does it create a new mint account? 
How do you preserve it between runs? Only when its deployed?
```
  $ solana program deploy /Users/moo/Downloads/experiements/deltaone-protocol/target/deploy/deltaone_protocol.so
The program address will default to this keypair (override with --program-id):
  /Users/moo/Downloads/experiements/deltaone-protocol/target/deploy/deltaone_protocol-keypair.json
Error: Unable to read keypair file
```
why is it going to this path to find keypair when the keypair lives here:
```
/Users/moo/.config/solana/id.json
```
I notice that `InitMint` and `Airdrop` are two different types/structs. and `mint` in InitMint has a different decorator. Am i getting warmer?
It doesn't 😉 Probably a good exercise to see how it's different
but init_mint does the same exact thing as airdrop. why do we need to run it?
Yep, you need to init the mint (otherwise there's no mint to do the airdrop)
below is code from a program test case. as workspaces are not available in the browser, how do you access chat.name from a react app?
```
# in program test
const program = anchor.workspace.Chat;
const chat = await program.account.chatRoom.fetch(chatRoom.publicKey);
const name = new TextDecoder("utf-8").decode(new Uint8Array(chat.name));
```
yes
i did not run init_mint. do i need to?
i just ran airdrop directly.
So you're also using https://github.com/cqfd/anchor-token-studies ? Tests run fine for me, so will depend on what you changed
And no, the mint's address is the PDA, not the program's own address.
The mint stuff is stored in an account owned by the spl token program (so not one of our own accounts).
Ah sorry just red your reply, the authority is a PDA
I understand, and where will this mint info be stored (authority?), will it be in an #[account] struct in the program ? Also, will the mint address be the program's address, or it will generate one and store it alongside the authority ?
I'm getting this: ` Error: 167: The given account is not owned by the executing program`
When I run: 
```
const accounts = {
      mint: mint,
      destination: ourAssociatedTokens, //your wallet.
      payer: program.provider.wallet.publicKey,
      systemProgram: anchor.web3.SystemProgram.programId,
      tokenProgram: spl.TOKEN_PROGRAM_ID,
      associatedTokenProgram: spl.ASSOCIATED_TOKEN_PROGRAM_ID,
      rent: anchor.web3.SYSVAR_RENT_PUBKEY
    }

    console.log("Starting airdrop", accounts);
    await program.rpc.airdrop(mintBump, {
      accounts: accounts
    });
```
In this case the authority over the mint is a program-derived address so that the program itself has authority (only the program can sign for its own derived addresses). Weirdly/just for fun, that specific authority address is the mint's own address 🤳
Not quite sure if I'm understanding your question, but a mint is the "type" or "brand" of tokens (e.g. AlanCoin). That instruction's main purpose to create the mint itself (AlanCoin didn't exist until that function got called) and set who has authority over the mint (who has to sign in order to make new AlanCoins)
Thanks, so a mint is not that origin program (or account?) from which all tokens of that type are created? trying to settle the mint concept in my head
Ah, I forgot I left that code in a funny mid-stream state—the purpose of the instruction is to initialize the mint that the program will control. It *also* happens to randomly send 1 token to the `destination` account, but that's kind of random/just an example from the stream.
In the token studies program.. When we have init_mint as an instruction, does that mean that we can use that instruction to mint a new token, create a new mint, OR that we use that instruction to make a new account for the payer from a specific token mint (eg: creating a $SRM account for the payer if he doesnt have one?)
I really get the feeling that this is the issue now that you bring it up though🤦‍♂️
serum_dex::instruction::new_order is the instruction that's ultimately called
And if you're talking to the serum dex, could 0x22 = 34 = InsufficientFunds? https://github.com/project-serum/serum-dex/blob/master/dex/src/error.rs
What's the actual instruction you're invoking? In general you need to do some source-diving to see which accounts need to sign and/or be mutable, unfortunately
Does anyone have an example of placing an order on serum via cpi? I've been using the swap example as inspiration, but I'm a bit stuck on some of the differences due to using PDA/CPI.

I've created a PDA and open orders account for the PDA, but when I try to use CPI to have the PDA place an order, I keep getting: custom program error: 0x22. afaik, this error maps to "Invalid number of provided signers" based on the error.rs in the solana token program. I would have expected that the only signer I need for this is "the PDA" (I'm using CpiContext::new_with_signer to place the order). Am I missing something?
Hahaha! XD
I'm almost wondering if you're like somehow using the ethereum version of web3.js lol, I have no idea where those types are even coming from.
Probably since I'm yet to clean my code. Let me check if I'm doing something wrong and I'll get back. Thanks 🙂
At any rate something is super weird with your setup since this is definitely not the expected behavior.
Can you post more of your code? I honestly have no idea what's going on
program.rpc.ix doesn't use websockets though, it just does an rcp call
One of my friend who's a Solana dev too told that it maybe because anchor uses websockets and sometimes they're a bit slow. So the program.rpc.ix() itself can take upto 30secs for confirmation.
I honestly have no idea where those types are from 🤔 I can't find them in either the anchor *or* the solana codebases.
<@!134416332509675520> Found a hack:

conn.getSignatureStatuses() expects a tx_sign string and the var we have is PendingTx type. When that is passed, the error thrown is related to circularJSON. What I did is: converted PendingTx to string via JSON.stringify with a circularJSON replacer, and passed the signature field from the new JSON I get. It worked well then.

Just wondering if this should be the right way to do or not. Any faulty implications that you see when such code is pushed to prod?
<@!134416332509675520> Here's how it looks. Due to this being a PendingTransaction type and not a string, the conn.getSignatureStatuses() fails coz it expects the tx_sign to be string.
Can you post a screenshot? Never seen that type before
When I'm storing the returned value of "await program.rpc.ix_handler( )", the value is of type PendingTransaction and not a string representing the tx signature. Am I missing anything? <@!134416332509675520>
but no output
I run solana logs - u localhost

and in rust I show msg!("I am here")
ahhhh turns out I had mixed up `god` and `mint` when initializing the `Token` client
the above is Python but the `create_account` and `get_account_info` workflow works fine in the solana-py tests
already learned that one the hard way this morning 😅
this doesn't error
```market_maker_token_a = await mint_a_client.create_account(
            market_maker_account.public_key,
        )
  ```
but `get_account_info` doesn't think the account got created 🤔 
`await mint_a_client.get_account_info(market_maker_token_a, Processed)`
How much space are you giving that account? I've made that mistake before
but I think perhaps something is going wrong when creating the account to transfer the token to
running TransferChecked
Not sure on the exact causes but usually it's often misformed transaction instructions
this is good info
Ah, ok, another way in general is if you're creating a token program account (a mint, or a token account, etc.) but allocate the wrong amount of space.
What token instruction is running when you get the error? You could probably spot potential causes just by source-diving in the token program's `processor.rs` file
I think you could maybe get that (not 100% sure) by passing a token account where a mint was expected?
and yeah this isn't actually an Anchor question 🤷‍♂️
those words mean as much to me as `Error: something went wrong`
what are some common causes of `InvalidAccountData` when using the Token program?
Why are you doing that additional `createInstruction`? I'm guessing that's how you're creating the account twice
So I created an account for `basic-1` and tried creating it in a new program with `anchor init` and it gave me error? is this possible?
You are trying to create an account where one already exists
```ts
import * as anchor from '@project-serum/anchor';
import {Program} from '@project-serum/anchor';
import {BoltFactory} from '../target/types/bolt_factory';
import assert from 'assert';

describe('bolt-factory', () => {

    // Configure the client to use the local cluster.
    const provider = anchor.Provider.local();
    // const provider = anchor.Provider.env();
    anchor.setProvider(provider);

    const program = anchor.workspace.BoltFactory as Program<BoltFactory>;

    it('Creates and initializes an account in a single atomic transaction', async () => {
        // Add your test here.
        const boltAccount = anchor.web3.Keypair.generate();

        // create a new account and initialize it with the program
        const tx = await program.rpc.initialize({
            accounts: {
                boltAccounts: boltAccount.publicKey,
                systemProgram: anchor.web3.SystemProgram.programId,
                user: provider.wallet.publicKey
            },
            signers: [boltAccount],
            instructions: [
                await program.account.bolt.createInstruction(boltAccount),
            ]
        });

        // fetching the new account
        const account = await program.account.bolt.fetch(boltAccount.publicKey);

        // assert.ok(account.data.eq(new anchor.BN(1234)));
        assert.ok(account.diameter.eq(new anchor.BN(2)))

        const _boltAccount = boltAccount;
        console.log("Your transaction signature", tx);

    });
});

```
This is what I wrote in the test script
I am trying to run a basic anchor project taking reference from `basic-1` example.
The program builds but testing fails. is there anything I need to do before I test the project?
```bash
Transaction simulation failed: Error processing Instruction 1: custom program error: 0x0
    Program 11111111111111111111111111111111 invoke [1]
    Program 11111111111111111111111111111111 success
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS invoke [1]
    Program 11111111111111111111111111111111 invoke [2]
    Allocate: account Address { address: 732h63wwuNsgWANuCr2NDUR5q4wFkrZhT5zKMHHcfRuc, base: None } already in use
    Program 11111111111111111111111111111111 failed: custom program error: 0x0
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS consumed 200000 of 200000 compute units
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS failed: custom program error: 0x0
Translating error SendTransactionError: failed to send transaction: Transaction simulation failed: Error processing Instruction 1: custom program error: 0x0
    at Connection.sendEncodedTransaction (/home/sdp/dev/bolt-factory/node_modules/@solana/web3.js/src/connection.ts:3689:13)
    at processTicksAndRejections (node:internal/process/task_queues:96:5)
    at Connection.sendRawTransaction (/home/sdp/dev/bolt-factory/node_modules/@solana/web3.js/src/connection.ts:3649:20)
    at sendAndConfirmRawTransaction (/home/sdp/dev/bolt-factory/node_modules/@solana/web3.js/src/util/send-and-confirm-raw-transaction.ts:27:21)
    at Provider.send (/home/sdp/dev/bolt-factory/node_modules/@project-serum/anchor/src/provider.ts:114:18)
    at Object.rpc [as initialize] (/home/sdp/dev/bolt-factory/node_modules/@project-serum/anchor/src/program/namespace/rpc.ts:24:23) {
  logs: 
```
What might be the reason for transaction simulation failed error.
In Anchor is there an easy way to verify if the tokens being passed in are USDC or do I need to manually verify the USDC pubkey in the program
thanks, running that command 🙂
but all good if you have a working setup now
`anchor init` now generates a `yarn run ts-mocha...` for the test command in Anchor.toml, and a package.json with the required dependencies, `cargo install --git https://github.com/project-serum/anchor anchor-cli --force --locked` would get you up to date with that version
anyways, thank you!
makes sense but its created by `anchor init`
yea if it is your own repo you are on your own managing the js dependencies
it seems this is happening for others as well, if you search: `Failed to run test: ts-mocha` on the discord. i got it to work by install ts-mocha globally, but thinking it should install automatically
just my protocol's repo
ahh and what are you running that `anchor test` on?
i did this to install anchor: `cargo install --git https://github.com/project-serum/anchor --tag v0.18.0 anchor-cli --locked
`
just run `git pull` on the repo, you don't need to update the binary or anything
how do i update anchor?
i see
yea it is done in latest master, and the instructions have changed a bit in the documentation
will try that
shouldnt that be done for me
but why do i need to manually install mocha
nvm, i fixed it. 
` npm install -g ts-mocha`
if you upgrade to latest master and run `yarn install` in `tests/` it should work
is that the `tests/typescript` test?
thank you!
It's just buried in there, https://github.com/solana-labs/solana-program-library/blob/master/token/js/client/token.js
i see the rust lib: https://github.com/solana-labs/solana-program-library
<@!134416332509675520> where is the github repo for the `@solana/spl-token` javascript library?
forsure, ill try that more then! thank you!
Solana is currently at the stage where it's generally way easier to understand things by just reading the code.
Honestly I just really enjoy source-diving lol 🤿
where did you learn all of this? are there any resources that we should read other than the solana docs?
This requires a whole extra program because in order to initialize an account at an address, the address itself has to sign—and for program-derived addresses, only their deriving program can sign for them. (I guess they could have added this functionality to the toke program itself though.)
`spl.ASSOCIATED_TOKEN_PROGRAM_ID` is for a helper program, the associated token program, which is the de-facto standard way to come up with an "obvious" address at which to store person P's tokens for some mint M (those tokens will need to live in an account owned by the spl token program, but the question is at what address they should live at—the associated token program will store them at one of its own program-derived addresses with seeds based on P and M's public keys)
`spl.TOKEN_PROGRAM_ID` is for the spl token program itself; it's the program that transfers tokens, mints them, etc. So every TokenAccount or Mint in anchor is ultimately owned by the spl token program.
what are these two for: 
```
spl.ASSOCIATED_TOKEN_PROGRAM_ID,
      spl.TOKEN_PROGRAM_ID,
```
got it
makes sense
I dropped back to node 16 and it is working
```
  --- stderr
  running "gcc-4.8" "-O0" "-ffunction-sections" "-fdata-sections" "-fPIC" "-g" "-fno-omit-frame-pointer" "-arch" "arm64" "-I" "include" "-Wall" "-Wextra" "-pedantic" "-pedantic-errors" "-Wall" "-Wextra" "-Wcast-align" "-Wcast-qual" "-Wconversion" "-Wenum-compare" "-Wfloat-equal" "-Wformat=2" "-Winline" "-Winvalid-pch" "-Wmissing-field-initializers" "-Wmissing-include-dirs" "-Wredundant-decls" "-Wshadow" "-Wsign-compare" "-Wsign-conversion" "-Wundef" "-Wuninitialized" "-Wwrite-strings" "-fno-strict-aliasing" "-fvisibility=hidden" "-fstack-protector" "-gfull" "-DNDEBUG" "-c" "-o/Users/peter/.cargo/registry/src/github.com-1ecc6299db9ec823/ring-0.16.20/target/debug/build/ring-74807bcb8634aeca/out/aesv8-armx-ios64.o" "/Users/peter/.cargo/registry/src/github.com-1ecc6299db9ec823/ring-0.16.20/pregenerated/aesv8-armx-ios64.S"
  thread 'main' panicked at 'failed to execute ["gcc-4.8" "-O0" "-ffunction-sections" "-fdata-sections" "-fPIC" "-g" "-fno-omit-frame-pointer" "-arch" "arm64" "-I" "include" "-Wall" "-Wextra" "-pedantic" "-pedantic-errors" "-Wall" "-Wextra" "-Wcast-align" "-Wcast-qual" "-Wconversion" "-Wenum-compare" "-Wfloat-equal" "-Wformat=2" "-Winline" "-Winvalid-pch" "-Wmissing-field-initializers" "-Wmissing-include-dirs" "-Wredundant-decls" "-Wshadow" "-Wsign-compare" "-Wsign-conversion" "-Wundef" "-Wuninitialized" "-Wwrite-strings" "-fno-strict-aliasing" "-fvisibility=hidden" "-fstack-protector" "-gfull" "-DNDEBUG" "-c" "-o/Users/peter/.cargo/registry/src/github.com-1ecc6299db9ec823/ring-0.16.20/target/debug/build/ring-74807bcb8634aeca/out/aesv8-armx-ios64.o" "/Users/peter/.cargo/registry/src/github.com-1ecc6299db9ec823/ring-0.16.20/pregenerated/aesv8-armx-ios64.S"]: No such file or directory (os error 2)', build.rs:653:9
  note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```
Hey has anyone any idea why when I try to install solana on my M1 I get a build error with ring
```
 ring-0.16.20 cargo build   
    Updating crates.io index
  Downloaded cc v1.0.72
  Downloaded 1 crate (57.5 KB) in 0.99s
   Compiling cc v1.0.72
   Compiling untrusted v0.7.1
   Compiling ring v0.16.20 (/Users/peter/.cargo/registry/src/github.com-1ecc6299db9ec823/ring-0.16.20)
error: failed to run custom build command for `ring v0.16.20 (/Users/peter/.cargo/registry/src/github.com-1ecc6299db9ec823/ring-0.16.20)`

Caused by:
  process didn't exit successfully: `/Users/peter/.cargo/registry/src/github.com-1ecc6299db9ec823/ring-0.16.20/target/debug/build/ring-ca804ade3e843aca/build-script-build` (exit status: 101)
  --- stdout
  OPT_LEVEL = Some("0")
  TARGET = Some("aarch64-apple-darwin")
  HOST = Some("aarch64-apple-darwin")
  CC_aarch64-apple-darwin = None
  CC_aarch64_apple_darwin = None
  HOST_CC = None
  CC = Some("gcc-4.8")
  CFLAGS_aarch64-apple-darwin = None
  CFLAGS_aarch64_apple_darwin = None
  HOST_CFLAGS = None
  CFLAGS = None
  CRATE_CC_NO_DEFAULTS = None
  DEBUG = Some("true")
  CARGO_CFG_TARGET_FEATURE = None
```
that looks like the correct http response, you aren't running `solana-test-validator` with any unusual flags?
Hey all, I'm trying to run the example-0  on anchor version `0.18.0` on an M1 Mac.
I'm running `solana-test-validator` but when I run `ANCHOR_WALLET=/Users/jon/.config/solana/id.json node client.js`
I get:
```
Running client.
Translating error Error: failed to get recent blockhash: FetchError: request to http://localhost:8899/ failed, reason: connect ECONNREFUSED ::1:8899
    at Connection.getRecentBlockhash (/Users/jon/Developer/anchor/examples/tutorial/node_modules/@solana/web3.js/lib/index.cjs.js:5965:13)
    at processTicksAndRejections (node:internal/process/task_queues:96:5)
    at async Provider.send (/Users/jon/Developer/anchor/examples/tutorial/node_modules/@project-serum/anchor/dist/cjs/provider.js:77:31)
    at async Object.rpc [as initialize] (/Users/jon/Developer/anchor/examples/tutorial/node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:11:31)
    at async main (/Users/jon/Developer/anchor/examples/tutorial/basic-0/client.js:22:3)
node:internal/process/promises:246
          triggerUncaughtException(err, true /* fromPromise */);
          ^

Error: failed to get recent blockhash: FetchError: request to http://localhost:8899/ failed, reason: connect ECONNREFUSED ::1:8899
    at Connection.getRecentBlockhash (/Users/jon/Developer/anchor/examples/tutorial/node_modules/@solana/web3.js/lib/index.cjs.js:5965:13)
    at processTicksAndRejections (node:internal/process/task_queues:96:5)
    at async Provider.send (/Users/jon/Developer/anchor/examples/tutorial/node_modules/@project-serum/anchor/dist/cjs/provider.js:77:31)
    at async Object.rpc [as initialize] (/Users/jon/Developer/anchor/examples/tutorial/node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:11:31)
    at async main (/Users/jon/Developer/anchor/examples/tutorial/basic-0/client.js:22:3)

Node.js v17.0.1
```

If I run `curl localhost:8899` I get `Used HTTP Method is not allowed. POST or OPTIONS is required`. Any suggestions?
Correct, total supply will be capped to one for a master edition mint
You can't mint again
For master edition mint authority is generated


//////////////////////////////////////////////////////////////////////////////////////////

Thanks!
there is one in the anchor repo. it also deals with watermelons 😉
but essentially - dealing with USDC is no different than dealing with any other SPL Token
Also what is the difference between testnet and devnet
tokens
Does someone have a good example of a program working with USDC?
```
test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 1.20s

   Doc-tests my_program
error[E0659]: `my_program` is ambiguous (name vs any other name during import resolution)
  --> /Users/mc/work/my_program/programs/my_program/src/lib.rs:15:9
   |
15 | pub mod my_program {
   |         ^^^^^^^^ ambiguous name
   |
   = note: `my_program` could refer to a crate passed with `--extern`
   = help: use `::my_program` to refer to this crate unambiguously
note: `my_program` could also refer to the module defined here
  --> /Users/mc/work/my_program/programs/my_program/src/lib.rs:15:1
   |
15 | / pub mod my_program {
16 | |     use super::*;
17 | |
18 | |     pub fn initialize_market(
...  |
70 | |     }
71 | | }
   | |_^
   = help: use `crate::my_program` to refer to this module unambiguously

error: aborting due to previous error

For more information about this error, try `rustc --explain E0659`.
error: test failed, to rerun pass '--doc'
```
rust tests are green, but the cargo command fails with this annoying doctest issue, any workarounds?
I guess this is for `Discriminator`: https://docs.rs/anchor-lang/0.18.0/anchor_lang/trait.Discriminator.html
in the basic-1 tutorial we have 
`#[account(init, payer = user, space = 8 + 8)]`
but MyAccount only has 1x 8-bit field (`u64`), so why does one have to allocate 16 bytes total?
Hey guys, what's the best way to maintain the `Anchor.toml` file across multiple environment (many local machines, devnet, mainnet, etc.) Should it just be listed in `.gitignore` or is there a better way to handle this?
namely that it's pinned to solana program 1.7.4 and anchor is on 1.8.0
i'm running into problems using this repo `https://github.com/smartcontractkit/chainlink-solana` to access the chainlink package
does anyone have an example project that gets chainlink working with anchor?
A `Instruction` builder
Probably not iwthout changing the program test api
but i saw that one during the hackathon
https://github.com/draffle-io/draffle/blob/master/programs/draffle/tests/functional.rs <@!367907046177112064> 

I wonder if there should be or if there is a way to build the instruction without having to to_account_metas() and .data()
I can't find what the guy shared here or any of my repos with something nice. Might have been a transient gist
Would be nice to have something like that in the repo.
Using the program_test framework.
You had some pretty good examples <@!831450660146642974>.
someone shared an example some days ago
But yeah, could maybe ask in the anchor-py channel about why your original approach didn't work?
For that specific data structure the schema will be so simple that you could honestly just skip borsh if you really wanted to—the first 4 bytes will be the length of the string (that's just how borsh does it), then that many bytes for the string itself, then 8 for the price, 8 for the items available, and then 1 byte for whether the option exists or not, etc.
Does anyone have an example of writing program tests is Rust rather than JS/TS? Would love to get a code coverage report over our entire Anchor program
do you have `anchor-spl` installed as dependency?
Hello, I am looking for some guidance and potential resources on the borsh encoding. Currently I am messing around with the solana-py/anchor-py libraries and am trying to decode the transaction data from a candy machine initialize. Here I am attempting to retrieve the price, items available etc.

I used the borsh library to attempt decoding it and followed the schema from here: https://github.com/metaplex-foundation/metaplex/blob/master/rust/nft-candy-machine/src/lib.rs#L525-L531

So far it has given results that are super funky and not correct. Would anyone have any advice on how to approach decoding borsh with the correct schema in python?
```
pub fn init_treasury(ctx: Context<InitTreasury>) -> ProgramResult {
        Ok(())
    }
```
<@!787242451240222732> ```
#[derive(Accounts)]
#[instruction(mint_bump: u8)]
pub struct InitTreasury<'info> {
    #[account(
        init,
        payer = payer,
        seeds = [],
        bump = mint_bump,
    )]
    pub treasury: Account<'info, TokenAccount>,

    #[account(mut)]
    pub usdcMint: Account<'info, Mint>,

    #[account(mut)]
    pub payer: Signer<'info>,

    #[account(
        init_if_needed,
        payer = payer,
        associated_token::mint = usdcMint,
        associated_token::authority = payer
    )]
    pub depositer: Program<'info, Token>,

    pub system_program: Program<'info, System>,
    pub token_program: Program<'info, Token>,
    pub associated_token_program: Program<'info, AssociatedToken>,
    pub rent: Sysvar<'info, Rent>,
}
```
can you post more code? Not sure what you are trying to do here
any guidance for this compile error:
```
error[E0599]: no function or associated item named `default` found for struct `TokenAccount` in the current scope
   --> programs/deltaone-protocol/src/lib.rs:116:10
    |
116 | #[derive(Accounts)]
    |          ^^^^^^^^ function or associated item not found in `TokenAccount`
    |
    = note: this error originates in the derive macro `Accounts` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: no function or associated item named `try_from_unchecked` found for struct `anchor_lang::Program<'_, _>` in the current scope
   --> programs/deltaone-protocol/src/lib.rs:116:10
    |
116 | #[derive(Accounts)]
    |          ^^^^^^^^ function or associated item not found in `anchor_lang::Program<'_, _>`
    |
    = note: this error originates in the derive macro `Accounts` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 2 previous errors
```
`from` has to be an account that `authority` has control over. In the ido example, I think the `ido_account` is owned by the program itself (PDA), and `ido_authority_watermelon` is owned by `ido_account`. It doesnt necessarily needs to be from your wallet, it can be owned by the program as I just illustrated
and so is the from?
so if i am sending usdc from my wallet to an account, is the authority my wallet?
the `authority` is the account that would authorize the transfer instruction. Since `ido_authority` owns `ido_authority_watermelon`, you will need `ido_authority` in `authority` field to make the transfer happen
Hi I’m trying to transfer funds from one user to another in a contract and when I’m trying to test it it says no lamperts in account. I used the airdrop call to airdrop lamperts to it and that tx seems to have went through. Anyone else have this issue? In general, I’m trying to test out a simple program that transfers sol from one account to another
what does authority do here: 
```
Transfer {
            from: ctx.accounts.ido_authority_watermelon.to_account_info(),
            to: ctx.accounts.pool_watermelon.to_account_info(),
            authority: ctx.accounts.ido_authority.to_account_info(),
        };

```
Hi there, does anyone know if there is a way to check in program whether the invoker is the program deployer?
Just trying to get started and when I 'anchor init test' I get 
00h00m00s 0/0: : ERROR: There are no scenarios; must have at least one.
Failed yarn install will attempt to npm install
Thank you!
cool cool
Mm, you can kind of see where they start here, but it's probably not going to be super easy to read: https://github.com/project-serum/anchor/blob/master/lang/syn/src/parser/accounts/constraints.rs That will at least give you a sense for what attributes exist, then it's probably easier to just search for examples in the tests/ folder
Is there an example of a sane way to reset the state of the program in between tests? For example, I'm testing a few scenarios and am ending up with a ton of boilerplate code just to initialize everything. I'd love to be able to implement a beforeEach/afterEach hook that handles the reset
does anyone have an example of a function that deposits USDC into a token account?
is there some source code or documentation i can take a look at?
<@!134416332509675520> i dont see where in the docs the `account` attribute (https://docs.rs/anchor-lang/0.18.2/anchor_lang/attr.account.html) can take all of these other params ```#[account(
        init,
        payer = payer,
        seeds = [],
        bump = mint_bump,
        mint::decimals = 0,
        mint::authority = mint
    )]
```
how do i see the full list of things account takes in and what `init` does?
this is a full example:
https://github.com/dobleuber/solana-web3/blob/main/gif-portal-starter/src/App.js
using the same code in the tests.
```
let counterAccount = await program.account.counter.fetch(counter.publicKey)
```
Hey guys, how do you access variables stored in a program account from react app? Any example code you’ve come across?
Hey! another question:
I defined an enum in my lib, but I don't know how to use it in my javascript code:
```#[derive(AnchorSerialize, AnchorDeserialize, Debug, Clone)]
pub enum LanguageLevel {
    Elementary,
}
```
I am getting this error: `Error: unable to infer src variant`
```
const languages = [{
      language: 'English',
      level: 'Elementary',
    }]
```
Let me test, thanks in advance!
Then
```.js
await program.rpc.createCv(initData, {
  accounts: {
    ...
  },
  ...
});
```
```.rs
pub fn your_ix_handler(ctx: Context<TheContext>, init_data: Pubkey) -> ProgramResult {
  ...
}
```
If you want to pass non-account data (data that doesn't already live in an account on-chain) you'll have to use instruction arguments
Ah, you can only pass actual accounts (= addresses, from the client's perspective) in there.
I was trying to call my method ```
const tx = await program.rpc.createCv({
      accounts: {
        initData: {data: myData},
        user: provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
        basicProfile,
      },
      signers: [myAccount],
    });
```
But initial data should be a public key.
"But the only valid value for init data is my account pubKey." What do you mean? Not sure I follow
Hey folks, I am trying to send initialization params for my program account, but I have no idea about how to do it.
any help pls?
I am trying this:
```
    #[account(init, payer = user, space = 4096)]
    pub init_data: Account<'info, CurriculumVitae>,
```
But the only valid value for init data is my account pubKey.
Hmm, I'll have to take a closer look at candymachine I guess, I haven't actually used it yet
Yeah I am not sure, most just use levi korg's code for minting from CM 🙂
so either I implement a whitelisting mechanism along with this or I dont specify the date and somehow reference a private key
well I am not sure how I would even store a private key securely server side. But the reason candy machine cares about mint auth in this case is because only the creator wallet can mint before the start date of CM has been specified. I dont want to specify start date because it will allow anyone to mint from it, only people who have burned can mint
Oh, well, I guess candymachine doesn't care about the mint authority (the nfts have already been minted, it just hands them out in exchange for sol)
Mm, doubt it. Do most places that use candymachine use an actual backend?
Ah, right
actually, how would I reference a keypair that has authority over a mint from the frontend? is there any secure way to store and reference a private key in web3js?
I do, you mean authority over the candy machine for the mint right?
Sounds like you can probably do that all from the front end. Who has authority over the mint?
hey all seems my q got lost in da sauce would appreciate any input 🙂 (the q is what im replying to)
Yep. Synthetify has a good code base for this. https://github.com/Synthetify/synthetify-protocol/blob/master/programs/exchange/src/decimal.rs
But for now I think I can emulate floats with `u128` and some high decimal power as I did in Solidity before
I think I found it
https://github.com/project-serum/anchor/pull/993
Someone mentioned maybe making a PR for this, not sure if they have already or not
It seems like `f64` is not supported, right?
```     
IdlError: Type not found: {"name":"perTokenReward","type":{"defined":"f64"}}
```


//////////////////////////////////////////////////////////////////////////////////////////

any insights on this one?
`Clock::get()?.unixtimestamp` will get the timestamp
does anyone know how (or if it is possible) to grab the block # or timestamp in a program?
Not sure I know what I mean either 😂, just the rest of the code is not working as it did before. I'll try dig back in and figure it out.
Thanks so much for reviewing my stupid code.
What do you mean? How is it not the baseAccount you need? Not sure what that means.
Heh, yep, those both sound like problems 😛
i think i should be passing bump (now that i see the code ) will try with that :/ Also the seed has to be same in client and Rust (currently they are different)
Actually, although I do get the account returned with. ``` await program.provider.connection.getAccountInfo(baseAccount.publicKey)``` I don't get the baseAccount I need.
Hi, super noob question, does it makes sense to start coding programs in Anchor or just plain Rust?
Ok, so why are you passing [greetedPubSeed] as the argument, not just `initialize(greetedPubBump, { ... })`?
Meaning I'm not sure what the `[AccountSeed]` thing is (it should be the bump, not an array etc.)
Ok, and can you post the code from the client? The stuff you posted above looked like pseudo-code
basically trying to recreate a hello world program where messages are written in a PDA
What does the instruction function look like? (Basically just paste everything, way easier for us to help that way)
#[derive(Accounts)]
#[instruction(base_account_bump: u8)]
pub struct Initialize<'info> {

    #[account(init, seeds = [b"registry".as_ref()], bump = base_account_bump, payer = user, space = 2048)]
    base_account: Account<'info, BaseAccount>,
    user: Signer<'info>,
    system_program: Program<'info, System>,
}
Can you post that `#[derive(Accounts)]` code?
yes doing those
Ok, so you're trying to initialize an account at that PDA? Are you using the `init` attribute on the rust side? If so you'll need to specify `seeds = [whatever they are]` and `bump = the_bump`
This is what i have done -> 1. client finds a PDA (findAddress). 2. uses it to invoke Rust function (smart contract)    await  program.rpc.initialize([AccountSeed], {
      accounts: {
        baseAccount: AccountSeed,
        user: provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      },
What cross-program invocation are you doing?
What are you trying to write into it? Which program owns the account there?
Trying to write into PDA account. i am stuck at this error -> "#[error("Cross-program invocation with unauthorized signer or writable account")]".  Any help would be appreciated
I will look into that, thanks
should i use rust/js or python can suffice?
if i wanna get candlesticks from raydium what should i try
oops. didn't check libs.rs
they structured the project in a "Solana-ish" way but it's still Anchor
Nope, they are!
they are not using anchor ⚓
hmm
That would mean you're somehow passing an account to the token program that isn't actually owned by the token program (could be the token account or the mint).
I'm getting the following error when trying to burn token from an account:
```
Transaction simulation failed: Error processing Instruction 0: custom program error: 0x4 Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS invoke [1] Program log: Spending collection tokens Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [2] Program log: Instruction: Burn Program log: Error: owner does not match Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 2451 of 186738 compute units Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA failed: custom program error: 0x4 Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS consumed 200000 of 200000 compute units Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS failed: custom program error: 0x4
```
The `Burn` instruction is created by giving the mint of the token, the account whose token will be burnt and the mint_authority. Signers of this transaction are the owner of the account and the mint_authority (PDA).
Anybody ever encountered this error?
Looking at Jet protocol is a good learning experience: https://github.com/jet-lab/jet-v1/tree/master/programs/jet/src/instructions
would appreciate any help
only had experience interacting with solidity smart contract on evm
having the same question!
hi. is solfarm code public to understand how they've used anchor to interact with raydium?

or are there any repos to understand interacting with defi projects like solend or raydium? (using anchor)
when use anchor migrate?
```await program.rpc.addData(new anchor.BN(20) , { Common: {} }, {
      accounts: {
        authority: provider.wallet.publicKey,
        mint:mint,
        data: pda,
        systemProgram: SystemProgram.programId,
      }
    })```
Trying to pass enum from js and getting the error :
 Error: unable to infer src variant
Hey folks, a basic ques, what's the difference b/w verifier nodes and validator nodes in SOLANA?
That seems to work thanks
What does it look like if you fetch it as `await program.provider.connection.getAccountInfo(baseAccount.publicKey)` instead?
Does that `baseAccount` actually  have data in it?
Heys guys, not really an Anchor question, but has anyone come across this error with the phantom wallet? 
```
Error in getGifList:  RangeError: Trying to access beyond buffer length
    at checkOffset (index.js:1098)
    at Uint8Array.readUIntLE (index.js:1104)
    at UInt.decode (Layout.js:570)
    at Structure.decode (Layout.js:1234)
    at WrappedLayout.decode (index.ts:92)
    at WrappedLayout.decode (index.ts:92)
    at Structure.decode (Layout.js:1234)
    at Sequence.decode (Layout.js:1090)
    at Structure.decode (Layout.js:1234)
    at WrappedLayout.decode (index.ts:92)
    at Structure.decode (Layout.js:1234)
    at Sequence.decode (Layout.js:1090)
    at Structure.decode (Layout.js:1234)
    at WrappedLayout.decode (index.ts:92)
    at Structure.decode (Layout.js:1234)
    at AccountsCoder.decode (accounts.ts:52)
    at AccountClient.fetchNullable (account.ts:154)
    at async AccountClient.fetch (account.ts:166)
```
It comes when I run this function.  
```
const getGifList = async() => {
    try {
      const provider = getProvider();
      const program = new Program(idl, programID, provider);
      const account = await program.account.baseAccount.fetch(baseAccount.publicKey);
      console.log("Got the account", account)
      setGifList(account.poolList)
    }catch(error){
      console.log("Error in getGifList: ", error)
      setGifList(null);
    }
  }
```
yeah I will definitely have the UI app totally seperate, just wondering if others create client code sort of like the examples in the tutorials; https://github.com/project-serum/anchor/blob/master/examples/tutorial/basic-0/client.js#L13-L22

which they keep in the same repo as their anchor programs, so you could publish the client code at the same time as the program is deployed. It maybe doesn't matter too much, it's either in one place or the other really... 🤷‍♂️
i think nothing prevents you to have a separate repo for your ui (and i did that for my ui app, because it's easier and even makes more sense to me). you can just copy your idl to the ui repo. i don't think there is any point to store the idl on chain
maybe there is a token account data parser that i missed
not sure if this is a dumb question, but just starting out with Anchor. Once I have built my program, and generated the IDL, is it more common to:
  1.  create a TS client alongside (in same repo) the program which can then be published and used/imported in some separate react web app 
  2. generate and publish the IDL somewhere (on chain?), and then creating the clients in my "frontend" app - which I suppose means it's easier for others to build their own apps off of my IDL too

Or maybe you’d want to do both..

I see in a lot of tutorials/examples people are building react apps in the same repo with their program, but in the real world you’d probably be creating and deploying several anchor programs. Each of those would have their own client code, and then have a separate frontend app which would then use those clients.
surely i can, but i wonder what the anchor way to do it is
you can use axios.post and define your own request message using jsonParsed
I have also tried putting the idl in a .ts file and get the same result.  As per the documents it uses "const idl = JSON.parse(require('fs').readFileSync('./target/idl/basic_0.json', 'utf8'));" which cannot be used in react
Question about using the idl with react app. I have the following when try to define the program
import idl from "data/idl.json";
is there a method to parse token account data without making another request? getTokenAccountsByOwner has `encoding` hardcoded to `base64` https://github.com/solana-labs/solana-web3.js/blob/b45f065/src/connection.ts#L2298 even though RPC allows `jsonParsed` too https://docs.solana.com/developing/clients/jsonrpc-api#gettokenaccountsbyowner
https://github.com/vicyyn/MetaplexMetadata-js
I literally have this same question! Can you let me know what options you find? I tend to try to find all the ways that I could do something before determining what tools (i.e. npm modules) to use.
https://www.npmjs.com/package/@metaplex/js might be useful for that.
Get the SPL tokens hold by the wallet -> Map through each and get the associated mint address -> get the metaplex mint pda & decode the mint data
So yes in too many words. how do i query nfts
From my understanding the idea is to unpack the serialized data of an account to yeah query what nfts the wallet holds from holding one of my NFT's. Essentially Im trying to make a nft viewer and would like to ensure that im looking at the right code. Thanks
What is the question exactly? How to query NFTs?
How do i view the nfts in a wallet through having  json mint list, thanks im looking through the solana program library and just need to know what to look at. My dev environment is fully working otherwise. Figure its late for you guys so ill check in the morning to see if anyone has answered
Downgrade to solana 1.8.3
If CPI cannot return values, why does Anchor allow adding values in function return type?

```rs
pub fn mint(ctx: Context<MintCtx>) -> Result<u8, ProgramError> -> { Ok(5) }
```

Also what about the PR adding return types? https://github.com/solana-labs/solana/pull/19548
not sure there is enough info here to debug -- the findProgramAddress should get you the derived public key that the program can sign transactions with. Are you trying to make a CPI signed by the program? using invoke_signed?
I'm getting: `Cross-program invocation with unauthorized signer or writable account`

Am I doing something wrong here:
```
let seeds = &[ctx.accounts.usdc_mint.to_account_info().key.as_ref(), &[nonce], ];    
        let signer = &[&seeds[..]];
```

Here is my PDA:
```
// program signer PDA - sign transactions for the program.
    const [_programSigner, nonce] = await anchor.web3.PublicKey.findProgramAddress(
      [usdcMint.toBuffer()],
      program.programId
    );
```
the client generates the keypair then once the mint is created there is nothing that can be done with it, since the token program will own the account
<@!831450660146642974> makes sense. Is it possible for the program to own the mint instead of the user calling the function? I understand why the end user needs a token account, but I'm not sure I grok why they need the mint itself
This is to "prove" that you "own" it, as in you have the private key
when you allocate data on an account, that isn't a program derived address
Yep, that was it. How do I know when I need to include a new account as a signer?
you need to create a keypair and sign with it if you want to create the mint through MintNft
Can anyone help me understand why I'm getting a "Signature verification failed" error when I'm using the `init` macro for a Mint?  If I remove the init statement and replace the `Account` with an `AccountInfo`, it behaves as expected. I'm guessing it's because init is trying to initialize the mint and it's already happened. If that's the case, I'd be curious how to pass an uninitialized account via JS

```rust
#[derive(Accounts)]
pub struct MintNFT<'info> {
    // ...
    #[account(init, payer = buyer, mint::decimals = 0, mint::authority = buyer)]
    mint: Account<'info, Mint>,
}
```

```javascript
const mint = await splToken.Token.createMint(
  provider.connection,
  recipient,
  recipient.publicKey,
  null,
  0,
  splToken.TOKEN_PROGRAM_ID
);

await program.rpc.mint({
  accounts: {
    // ...
    buyer: recipient.publicKey,
    mint: mint.publicKey,
    rent: anchor.web3.SYSVAR_RENT_PUBKEY,
    tokenProgram: splToken.TOKEN_PROGRAM_ID,
    systemProgram: anchor.web3.SystemProgram.programId,
  },
  signers: [recipient],
});
```
Yeah and IIRC he also mentioned FlatBuffers to better handle data scheme migrations/upgrades
makes sense for sure. however, i suppose it would make more sense that anchor would automatically allocate this in the anchor code? that way the developer doesnt have to add the extra 8 all the time
interesting
Every anchor account gets one of these, to prevent you from accidentally deserializing a Foo account when someone actually meant to pass a Bar account (to prevent some interesting potential security issues...)
The first 8 is for anchor's "account discriminator", it's 8 bytes indicating which account struct this thing is supposed to be
btw why do we have to have at least 8 + 8 if we only have one `u8`?
ok gotcha, thanks alan
Yeah, you'll just have to be kind of careful since the *old* account will now have zero values for the new stuff
let me see if i have this straight. so lets say i define 1 field, `my_data:u8`, and so i make my space as 8 + 8 + 64. I compile this, deploy, blah blah, then later i update the contract's struct to have another 2 fields, `more_data1:u32` and `more_data2:u32`. It can still deserialize the older accounts and also update them?
so adding new fields to the tail shouldn't break stuff, but changing something in the middle currently does
gotcha, makes sense
I remember briefly talking to Ian Macalinao at breakpoint about how he wanted to use protobufs I think instead
(Not actually sure how easy that would be within anchor, since it defaults to borsh and I don't think borsh supports this)
I'm not sure in general how you would do this (not even specifically with solana)—you'll have old accounts lying around with the old format, so you'll have to support them ~forever. You could definitely have a custom deserialization strategy I guess that say "ok yep that's an old one" or "ok that's a new one"
oh okay so you can do the thing where you add new fields. but can you change existing fields? im guessing not?
im guessing for a dynamic account structure system, you could define a new structure, but you would first have to overwrite the existing data
You can definitely pre-allocate some extra space, and add new fields onto the end that way
i did this shit on ethereum machine code before and it sucks but thats the only reason ik basically how it works
what anchor does is takes that byte array and splices it up and gives it to you in chunks/fields, or when you give chunks to it, it mashes them together
so on solana native, account data is very simple, it's store in a field inside the account info called `data` and all it is, is an 8-bit byte array
bookmarked
everyone who does anchor should first do paulx's blog post on solana native coding
https://paulx.dev/blog/2021/01/14/programming-on-solana-an-introduction/
maybe there's a better way
sounds heavy for simple structure updates
I'm just wondering then how people do it currently - create new accounts, migrate data from old ones?
I've done zero, but it's something I would be interested in for sure
im guessing it could be, but ive only done a bit of solana native coding myself
yeah that would be amazing actually
maybe even some sort of "upgrade account" feature
so in theory it would be possible to override the deserialization and implement a backport?
idk much about the low-level of anchor's serial/deserial method
<@!134416332509675520> sorry to ping, but would something like this be possible for anchor?
im sure if you did your own serialization/deserialization tho, you could probably accomplish it
well, yeah, thats the issue then, you cant change your structures after your original deployment
would be something for the team to think about
however, i am wondering if it wouldn't be possible to have anchor be coded in such a way that you could add fields onto the tail end of data structures?
but then how do we update the contract without breaking everything?
if you initialize an account with a certain structure and then change the smart contract to deserialize in another manner (because different structure) then you can no longer deserialize
exactly
so I suppose that the existing account structure (which already had data in) no longer could be deserialized?
removed the total_gifs attribute at first
Hm possibly. I changed this structure here.
lol
anyway yeah ik for myself i will not rest until ik exactly why stuff is failing, even if i fix it.
do you by chance change the code that specified the structure of the data on the account/keypair that you are passing in?
Yeah, it's not a big deal at this stage but for production cases this would be akin to a database drop. I only have a couple hours / day to build so I'll investigate this later, I need to figure out a safe way of updating the state of the account without accidentally breaking stuff
will do so!
hmm, maybe so, when in doubt always regen everything haha
no worries. recommend to go through the <#889606719829835816>
Thanks for the info about the high-level error lookup
I'll dig this further in case it happens again.
I generated a new account Keypair for my frontend app and everything's working now, even the new functions. Maybe I broke something when I changed a structure in the Rust backend.
i am running on an M1 mac, but i havent had any issues up until now. i can run `cnahor test` and `solana-test-validator` just fine
```
Error: Account allocation failed: RPC response error -32002: Transaction simulation failed: Attempt to load a program that does not exist 
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }.
```
hey guys getting an anchor error when trying to deploy to localnet, hoping someone here can help:
I'll keep digging
but looks like an AccountDidNotDeserialize error
this happens in both functions that I changed and others I didn't
https://www.notion.so/Debugging-Custom-Anchor-Errors-b8540dd418c44a4e939ab17c56a3fd3b
this is a good article to debugging errors
sounsd like you wrote new code that has errors in it 🙂
am I forgetting something that needs to be taken care of when updating a program already in the blockchain?
when I do a test script with a new generated Keypair it runs fine
and copied the new idl to the frontend
in the backend I did build + deploy

hey, I'm trying to call a function in my Solana program but since my latest changes I only get errors when calling it
Hi all, I'm a Serum newbie. Want to build an trading bot using the serum-ts library. Does anyone have any experience doing this? Looking for someone who can help, and have a budget to build. Thanks.
Solved, I had to update XCode 👍
is there more output than that? seems like there should be another error somewhere
👋  I am trying to install anchor with `~ cargo install --git https://github.com/project-serum/anchor anchor-cli --locked`. Unfortunately I receive: ```
error: failed to compile `anchor-cli v0.18.2 (https://github.com/project-serum/anchor#7b86aed6)`, intermediate artifacts can be found at `/var/folders/v0/0n7nhm2n2k5c6l543hnrn6cr0000gn/T/cargo-installU1NXEK`
```
For sure this seems like what I need
If it is built on metaplex, you can use that https://www.npmjs.com/package/@metaplex/js
You could do it in ts/js
Can anyone point me to an implementation of verifying a wallet contains an NFT?
You could type it as <@!134416332509675520> said, and use unwrap_or in the body of your function
i'll look into the Option option
okay thats what i thought from my googling too, just figured i'd make sure
Yes not really supported in rust
Not exactly in rust, you'd have to type it as an `Option<u64>`
like can i default that commission number to something if its not passed in?
yes, sorry
In arguments ?
is there a way to set a default value for a vairable in rust?
one more basic rust question for you
Mr Alan do you know the answer 🙂
man i really gotta buckle down and learn rust faster 😅
Awesome 👍
okay perfect that did the trick for sure
Correct
so just multiply by 100 in TS and divide by 100 in rust?
You might want to avoid dealing with floats directly
is there anyway to pass an f64 in via ts?
ahhhh that makes total sense
+1
0.01 will be just 0 as a u64 (or a bignum)
i have a feeling its because im passing commission in as `0.01` and rust is parsing that differently since im telling it that its a u64?
i tried just passing the `commission` in as an f64 too but i get an IdlError Type not found
for both
yeah i did
Did you use new BN(your number) ? I see you are dealing with u64
ts -> rust
It can also be mismatching version of anchor cli and TS package
```
pub fn send_sol_and_commission(
        ctx: Context<SendSolAndComm>,
        amount: u64,
        commission: u64,
    ) -> ProgramResult {
        let commission_amount: f64 = amount as f64 * commission as f64;
        let trans_amount: f64 = amount as f64 * (1.0 - commission as f64);
... }
```
Were you passing it as an argument from within your rust code or ts -> rust ?
relevent code:
im super new to the rust (and its type system) so i suspect im just overlooking something simple
it was working fine when i had the commission amount hard-coded but now that im trying to accept that as an argument it seems to be not completing the same math for some reason
okay so im trying to write a program that takes in an amount and commission argument then sends solana to addresses based on those amounts
Ask away!
anyone got a second to help with a (probably super simple) rust question?
I'm on that too fwiw (using rosetta)
https://dev.to/nickgarfield/how-to-install-solana-dev-tools-on-an-m1-mac-kfn
But the best would be to use Rosetta
1.8.3
1.8.3 or 1.8.2?
oh snap, I didn't specify version when I built from source. Let me do that.
Or 1.8.3
Ok, downgrade to 1.8.2
`solana-cli 1.9.0 (src:devbuild; feat:2420900513)`
What's the version of solana you have ?
thanks, that's what I thought. appreciate you checking.
If I were you I would try to just step through things in the node debugger and see what's going on here: https://github.com/project-serum/anchor/blob/master/ts/src/provider.ts#L105 You can just check what the transaction looks like
Hmm, not sure, seems to run fine for me as far as I can tell.
something else strange is I when I run anchor test on this new setup I get text like this before the tests run
```
To deploy this program:
  $ solana program deploy /Users/whatever/workspace/level-up/target/deploy/level_up.so
The program address will default to this keypair (override with --program-id):
```
`Anchor.toml`
```
[programs.localnet]
level_up = "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"

[registry]
url = "https://anchor.projectserum.com"

[provider]
cluster = "localnet"
wallet = "/Users/whatever/.config/solana/id.json"

[scripts]
test = "node tests/test.js"
```
https://pastebin.com/ntcGbuf9
Or maybe I can just copy the above
Can you put this in a repo somewhere?
Yeah, never saw it before. I've tested a simple example on old computer and it's fine.

recreate
1.) new macbook m1
2.) build solana from source
3.) anchor init
4.) simple example w/ init (totally fine)
5.) simple example w/ init & a counter function (this error)
Trying to think how that could happen (your example seems fine to me)
Weird, that's a strange error to get (anchor only raises it when you somehow manage to invoke your program with < 8 bytes of instruction data, which should generally never happen based on how anchor works)
workaround https://stackoverflow.com/a/66759106
oh.. interesting. at least I have a place to look. It looks like account is being initialized, no?
thanks
That wouldn't be anchor. Check out the solana wallet adapter: https://solana-labs.github.io/wallet-adapter/
this error usually occurs if you haven't initialized the account
don't use any of the devent USDCs, they have the wrong number of decimals. Just use something with 6 decimal places
Hi can someone point me in the right direction of an example where a wallet is connected to a client and the wallet data is fetched? similar to step finance. thanks!
rly basic test

```
#[program]
pub mod level_up {
    use super::*;
    pub fn initialize(ctx: Context<Initialize>) -> ProgramResult {
        let base_account = &mut ctx.accounts.base_account;
        base_account.level = 0;
        Ok(())
    }

    pub fn add_level(ctx: Context<AddLevel>) -> ProgramResult {
        let base_account = &mut ctx.accounts.base_account;
        base_account.level += 1;
        Ok(())
    }

}


#[derive(Accounts)]
pub struct Initialize<'info>{
    #[account(init, payer = user, space = 9000)]
    pub base_account: Account<'info, BaseAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct AddLevel<'info> {
  #[account(mut)]
  pub base_account: Account<'info, BaseAccount>,
}


#[account]
pub struct BaseAccount {
    pub level: u64,
}
```

fails when frontend calls addLevel

```   await program.rpc.addLevel({
        accounts: {
            baseAccount: baseAccount.publicKey,
        },
    });
```
hey all, new macbook m1.

`Transaction simulation failed: Error processing Instruction 0: custom program error: 0x64`

getting issue when running anchor test. simple example runs fine, but now i'm getting this.

is this a known issue? or just missing something obvious?
For some reason USDC is only on Testnet... I'll just make up my own token in testing and call it USDC
Gotcha. Thanks!
devnet is for developers, testnet is for validator testing (don't use it)


//////////////////////////////////////////////////////////////////////////////////////////

But that costs compute.
Mm, it's only *necessary* to pass bumps to `invoke_signed`. You can always recalculate them within your program using `Pubkey::find_program_address` if you know the seeds.
I am checking this .. Was it necessary to store bump - https://github.com/cqfd/anchor-visitors/blob/58972af564867155b2e6f236227bf0178c5d8314/programs/visitors/src/lib.rs#L9
To instructions
To what?
Is is necessary to pass bump ?
Thanks
you can use this function:
```

pub fn close<'info>(
    info: AccountInfo<'info>,
    sol_destination: AccountInfo<'info>,
) -> ProgramResult {
    // Transfer tokens from the account to the sol_destination.
    let dest_starting_lamports = sol_destination.lamports();
    **sol_destination.lamports.borrow_mut() =
        dest_starting_lamports.checked_add(info.lamports()).unwrap();
    **info.lamports.borrow_mut() = 0;

    // Mark the account discriminator as closed.
    let mut data = info.try_borrow_mut_data()?;
    let dst: &mut [u8] = &mut data;
    let mut cursor = std::io::Cursor::new(dst);
    cursor
        .write_all(&CLOSED_ACCOUNT_DISCRIMINATOR)
        .map_err(|_| ErrorCode::AccountDidNotSerialize)?;
    Ok(())
}

```
Hi <@!134416332509675520> 
Can I implement the `conditional close` on the `#[account()]`?
<@!712332112128376885> thanks
<@!609739117600833554> , it would be useful for the timestamp and sender
`let now_ts = Clock::get().unwrap().unix_timestamp;`
And `*ctx.accounts.initializer.key`
Is there a way to get msg sender and block.timestamp in the solana programs?
Just one more question:
Should I add 8 to calculate the space like this:
`space = 8 + UserStakingAccount::default().try_to_vec().unwrap().len()`
It's working
Thanks <@!134416332509675520> 👍
anchor_version = "0.18.0" on the Anchor.toml
anchor_lang = "0.18.0", anchor_spl = "0.18.0" on the Cargo.toml

like this?
Haha, sure!
Can't I update the anchor version?
Ah, ok, those are pretty out of date and `init_if_needed` won't work with them. You'll have to handle the init-ing part yourself, manually
Well.. anchor_version = "0.16.2" on the Anchor.toml
and anchor_lang = "0.16.2", anchor_spl = "0.16.2" on the Cargo.toml
hmm, okay, didnt see those, will look and let u know if i still dont understand :/
There are also lots of examples in the tests directory if you search the anchor repo
Probably not, easiest to just ask specific question here I'm guessing
is there really no documentation for this? 😅
yeah i tried searching but couldnt find anything. another guy said it was for accessing your main instruction handler params for your program but that didnt seem to line up with the code i was looking at
Sorry, what's the actual error?
Probably easiest to search the discord, there are a lot of discussions of it (briefly, it just lets you refer to instruction arguments in your `derive(Accounts)` struct, which is often useful)
or at least a detailed explanation
oops wrong message
or at least a detailed explanation
```
#[account(
        init_if_needed,
        payer = token_from_authority,
        seeds = [ token_from_authority.key().as_ref() ],
        bump = nonce,
        space = 1234,
    )]
    pub user_staking_account: ProgramAccount<'info, UserStakingAccount>,
```
Gonna need more information than that lol
<@!134416332509675520> , `init_if_needed` is error 😦
Yep, `seeds = [the_signer.key().as_ref()]`
One more question: can I generate the seeds from the signer's key?
Thanks 👍
Can you use
```.rs
#[account(init_if_needed, seeds = [...], bump = the_bump, payer = the_payer, space = 1234)]
```
If there's any PDA initialized, and use that one to update the data
And if there's nothing, then create a PDA to initialize the data

To do this one, I can't use the `#[account(init)]`
Can you say more? Not sure what you mean.
anyone know how to get USDC on devnet?
Hi,
I would like to ask one question
`Create a PDA on the function, not on the context`
Really appreciate if you can share any piece of code for it
is there any documentation for the `#[instruction]` attribute?
yay ! Thank you!
Can try looking in `.anchor/program-logs`
hey how do you see the msg logs of your smart contract when you run `anchor test` is there an option for turning those on?
I had to convert it to the a string like following
```    pub fn initialize(
        _ctx: Context<Initialize>,
        target: Pubkey,
    ) -> ProgramResult {
        msg!("target: {}", target.to_string());
        Ok(())
    }```
You have to pass a string to `msg!` I think, so you'd do `msg!("{}", target_account.key())`
Anybody know how to get the public_key for a passed in account?
Let's say I have ```let target_account = &mut ctx.accounts.target_account;```
How do I get it's public key?
Edit: tryingt to ` msg!(target_account.key());` but getting `expected `&str`, found struct 'anchor_lang::prelude::Pubkey'`
My accounts want to store a `fixed::I80F48`. I've gone in and implemented `BorshSerialize/Deserialize` for the type in the `fixed` crate (storage is just a i128). However, the IDL json now just contains `"type": {"defined": "I80F48"}` without a definition for the type. Is there a way I can inject a custom class in the typescript client to handle the type? Should I be doing this differently?
got it working again by doing an uninstall and re-install, on my mac as follows
`cargo uninstall anchor-cli`
`rm -rf ~/.cargo/registry/index ` // re-install failed unless I included this step
`cargo install --git https://github.com/project-serum/anchor --tag v0.18.2 anchor-cli --locked`
error: failed to run custom build command for `ring v0.16.20`

Caused by:
  process didn't exit successfully: `C:\Users\HP\AppData\Local\Temp\cargo-installbwIL4P\release\build\ring-2ff300b39f35f0ff\build-script-build` (exit code: 101)
  --- stdout
  OPT_LEVEL = Some("3")
  TARGET = Some("x86_64-pc-windows-gnu")
  HOST = Some("x86_64-pc-windows-gnu")
  CC_x86_64-pc-windows-gnu = None
  CC_x86_64_pc_windows_gnu = None
  HOST_CC = None
  CC = None
  CFLAGS_x86_64-pc-windows-gnu = None
  CFLAGS_x86_64_pc_windows_gnu = None
  HOST_CFLAGS = None
  CFLAGS = None
  CRATE_CC_NO_DEFAULTS = None
  DEBUG = Some("false")
  CARGO_CFG_TARGET_FEATURE = Some("fxsr,sse,sse2")

  Skipped Some Part!
The part involving stderr

C:\Users\HP\.cargo\registry\src\github.com-1ecc6299db9ec823\ring-0.16.20\build.rs:653:9
  note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
warning: build failed, waiting for other jobs to finish...
error: failed to compile `anchor-cli v0.18.2 (https://github.com/project-serum/anchor?tag=v0.18.2#1319dc65)`, intermediate artifacts can be found at `C:\Users\HP\AppData\Local\Temp\cargo-installbwIL4P`

Caused by:
  build failed
ok thanks i got it
Yes, the input is the seed, the outputs are [address, bump]
Ahhh my bad i thought it returned [address, bump] instead of seed?
I'm not sure i understand the question. `findProgramAddress` takes the seed and creates a new address until it find one that has no private key. Each new address is generated by using a different seed. Both the address found and the seed are returned by the program
thanks! but i mean that's the call where it happens, since it returns the address and the bump ?
It's best to do it off chain because it's compute heavy and only verify that the address has been generated correctly in the program
So when exactly does the search for an offcurve bump happens? Is it from the client side after calling anchor.web3.PublicKey.findProgramAddress ?
`zsh: exec format error: anchor` when I try to run any anchor command
installed anchor yesterday and it was working, came back today after restarting and it's givng this error
Correct!
If there's another way to do it I'd be curious to know
so I need to store a pubkey in program somewhere which is owner of program and check the signer is same as that ?
This was asked about recently (yesterday I think), can try searching. The basic idea is you'll need to check that some known/preordained public key signed the tx (I'm not aware of any other way to do it)
How can we ensure that the person who deployed the program can execute the instruction inside of that and no other person can call that program ?
any help with this? I have the same issue
Yeah this will be way nicer when you can just stick an `n` at the end of the literal 🙇‍♂️
Thank you again!
Oh, yes! I had `_` in my number, sorry
Which is about 240 bits there 😛
This seems to work fine for me:
```.js
let huge = new anchor.BN("1111111111111111111111111111111111111111111111111111111111111111111111111");
```
Thank you very much!! 
I also looked at the source code for `BN` and it actually does support numbers higher than that, they just need to be passed as an array (sadly, it seems you can't just pass a `String` into a constructor). And for converting from `BN` it will also work with `toString`
any tutorial using anchor_spl, can't find any good explanations on how to use it?
(So, to some extent the syntax `new anchor.BN(123)` is kind of inherently goofy, since you're using a vanilla number and turning it into a BN. Will be nice to transition to JS's built-in BigInt and just write `123n`)
The point of that assertion is that js numbers are doubles and can only represent (all) integers up to 2^53, so it's a bit funky to try to use them for integers bigger than that.
That assertion is for if you pass a literal js number to the BN constructor. You can instead pass the number as a string literal if you want?
Or instead pass it as a byte array ? <@!788122420765917184>
https://tenor.com/view/destory-eexplode-nuke-gif-6073338
Why not divide before & restore it in the program ? Not the best solution I guess hey but if that works....
Also it might become a problem for `u64` as well, if it contains number higher than 2^53
And when I try to return `u128` I usually get an error saying 
```
     Error: Number can only safely store up to 53 bits
```
Good day! What would be the way to pass `u128` into a contract? `BN` wouldn't work as it has this assertion inside:
```
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
```
nevermind. I figured it out. I think I had multiple versions of rustc installed
and I'm not really sure how to add bpfel-unknown-unknown
it seems like the correct compiler didn't install into rustc
greg@greg-Z390-GAMING-X:~/anchor1/examples/tutorial/basic-0/programs/basic-0$ anchor build
BPF SDK: /home/greg/.local/share/solana/install/releases/1.8.2/solana-release/bin/sdk/bpf
Running: rustup toolchain list -v
Running: cargo +bpf build --target bpfel-unknown-unknown --release
error: failed to run `rustc` to learn about target-specific information

Caused by:
  process didn't exit successfully: `rustc - --crate-name ___ --print=file-names -C lto=no -C opt-level=2 --target bpfel-unknown-unknown --crate-type bin --crate-type rlib --crate-type dylib --crate-type cdylib --crate-type staticlib --crate-type proc-macro --print=sysroot --print=cfg` (exit status: 1)
  --- stderr
  error: Error loading target specification: Could not find specification for target "bpfel-unknown-unknown". Run `rustc --print target-list` for a list of built-in targets
I've been having an issue that might be pretty simple but after using the search function for some reason I don't find anything on here
This existing code is a photo generator. I want the contract to work as a mint button
My anchor friends I have a question. Say I have existing code like something written in JavaScript. How do I integrate a smart contract into this existing framework
any idea whats happening?
I keep on having issues deploying IDL

`anchor(62808,0x203607600) malloc: *** error for object 0x600002834230: pointer being freed was not allocated
anchor(62808,0x203607600) malloc: *** set a breakpoint in malloc_error_break to debug`
hey all just getting started w anchor whats the equivalent of forking the mainnet so you can test interact with contracts? Is it `anchor idl init -f <target/idl/program.json> <program-id>` and then deploy into your local cluster?
got more error? a complete log as a gist might help
is there any documentation for this?
ahh that makes so much sense - tyvm <@!168868665456984065>
I have tried multiple times I’m still having this error
or just do `npm i -g ts-mocha`
thats what i do
you don't have `ts-mocha` installed globally. you can install locally and change it to `npx ts-mocha ... `
this is my Anchor.toml file btw
```toml
#Anchor.toml
[programs.localnet]
wtia_auction = "program_id"

[registry]
url = "https://anchor.projectserum.com"

[provider]
cluster = "localnet"
wallet = "/home/dunnis/.config/solana/id.json"

[scripts]
test = "ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"
```
hi, i'm very new to anchor, and i'm trying to run `anchor test`, but as you can see, i'm getting this error...
can anybody see what the problem is?
its an anchor feature. it allows you to pull handler function parameters into the scope of the accounts context struct for constraint validation or other attributes that may need them
Trying to install anchor on Windows using this command; 

cargo install --git https://github.com/project-serum/anchor --tag v0.18.2 anchor-cli --locked

I’m having this error; 

error: failed to compile `anchor-cli v0.18.2 (https://github.com/project-serum/anchor?tag=v0.18.2#1319dc65)`, intermediate artifacts can be found at `C:\Users\HP\AppData\Local\Temp\cargo-installbwIL4P`

Build failed
i see this line and similar a lot in Daniel's new blog post
`#[instruction(instance_bump: u8, wallet_bump: u8)]`
is this attribute a solana thing or anchor thing? either way i cant seem to find the documentation for it
Obviously be careful 🙂
So if the CLI needs the keypair, then you need to export the phantom keypair as an array and place it on your filesystme.
ah nvm this is an ahcor error, declare id
eg `ProgramError: 167: The given account is not owned by the executing program`
best place to read about solana error codes? how to find in teh source?
Got it, whats the path from Phantom -> getting the keypair as a JSON for Anchor to work with 😮
Path to the keypair.json.
Wait a sec -- is `--provider.wallet` a private key or what exactly 🤔
Appreciate you Alan!!!
❤️
cool. thanks <@!134416332509675520> !
Ah ok, you can get other options with `anchor deploy --help`, there's an additional `--provider.wallet` arg
solana and phantom wallet use two different types of encryption methods afaik
Yup -- so that I have down, now tryna see how I tell anchor "hey, i wanna use my mainnet account w/ sol in it to fund this deploy".
I think you can deploy with `anchor deploy --provider.cluster mainnet-beta`
Exactly haha -- would need to use the phantom wallet in the CLI somehow 🤔
My sense from the source is that when you generate a keypair, it's not not doing any derivation path stuff like in the phantom example (so I guess you're right, if you generate a wallet from the cli it won't work in the browser, since it just isn't a path derivation from the seeds? Not sure)
Hmm, ok, reading through solana-keygen source for a bit, I'm not sure!
Hey everyone -- whats the workflow to deploy to mainnet w/ Anchor? I have SOL in a Phantom wallet, what would I do from here :o?
Just want to know why the first one isn't, and if it's not, does that mean any wallet that I create using cli, I won't be able to sign into using the browser wallets?
Also, I should clarify that the second snippet gives the right result (i.e, public key of the wallet that I lifted the seed phrase out of)
No, just made them to mess around 😅
(Just double checking those aren't important seed phrases...)
I'm following the web3.js examples. 

This- 
`{
    var seedFromSolanaCli =
      "design forward flee wage vast host cigar fly able wool element upset near leopard attitude initial basic scene raccoon route glue crucial hunt diagram";
    let seedBuffer = bip39.mnemonicToSeedSync(seedFromSolanaCli, "");
    let fromSolanaCliTool = Keypair.fromSeed(seedBuffer.slice(0, 32));
    // 9PoRykHqeLD9dLJZTL9UZ6t9TpKGYaoY7Lu7C1TaTXHZ
    console.log(
      `from solana cli tool seed: ${fromSolanaCliTool.publicKey.toBase58()}`
    );

    console.log(`raw prikey: [${Array.from(fromSolanaCliTool.secretKey)}]`);

  }`

and this- 
`
{
    let seedFromPhantomWallet =
    "design forward flee wage vast host cigar fly able wool element upset near leopard attitude initial basic scene raccoon route glue crucial hunt diagram";
    let path = `m/44'/501'/0'/0'`;
    var seedBuffer = bip39.mnemonicToSeedSync(seedFromPhantomWallet, "");
    let fromPhantomSeed = Keypair.fromSeed(
      derivePath(path, seedBuffer.toString("hex")).key
    );
    // AWqdASzbwfJ2AbhvLmE2LHQy2ya3JP3vTkWdZWXWim3
    console.log(
      `from phantom wallet seed: ${fromPhantomSeed.publicKey.toBase58()}`
    );
    console.log(`raw prikey: [${Array.from(fromPhantomSeed.secretKey)}]`);
  }
})();
`

give different results, even though I put the same seed phrase that I got from my wallet in both code snippets
So you're using `anchor.web3.Keypair.fromSeed`?
Makes sense, thanks for your help! 🙂
Ah, got it—I'm not sure if there's a way to set the balance ahead of time during deploy like that, I think you'd have to do it separately
Thanks, that makes sense! I think I'm missing where the program would get the balance from though that it'd pay into the account it owns, is that something I can set when I do an `anchor deploy` for example?
Or even in an account owned by the system program I guess, if the account lives at a PDA (since then your program can sign for it)
Storing the money in the program's own account wouldn't work I don't think because the program itself is owned by the bpf loader, so to retrieve that stached money you'd have to go ask the bpf loader to do the transfer for you (since it owns the program), and I don't know if it supports that kind of instruction
You could definitely have your program stash money in an account it owns, yeah (and then it can transfer it back to winners).
Is it possible to deploy a program (or I'm guessing more likely an account owned by one?) with a balance, and then have payments between callers and that account? I'm thinking about eg. games where you'd pay to enter (transaction paid to the contract balance) and can be paid from the contract balance if you win. Just a bit unclear if this is possible/where the balance would actually reside and how it gets set. 

If it helps the equivalent in ethers would be something like `await Token.deploy({ value: ethers.utils.parseEther("0.1") })` with a payable constructor
Noob question. Does the cli wallet differ from phantom wallet?  Aren't they supposed to be the same?
I'm passing fromSeed() and getting different public keys using the web3js library
I myself have retardness with color
color blind?
BUT WHAT ABOUT THE BLUE COLOR 🤪
lmao
rip
There's litterally 2 pixel difference between the "t" and the "f" ^^...
XD peak software dev moment, ive had them too haha
there is `getParsedTokenAccountsByOwner` i don't know how i missed that one 🤦
Aha, right: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comma_Operator
facepalm, thanks
No idea how that's not a syntax error lol
u______u omg
That says "if" not "it" 🙃
But i have two

I dont see any errors just the first "it" ran
Ok, that looks fine
this part of anchor.toml ?
It ought to just run them all automatically—do you have a funny test command in your Anchor.toml? You don't just see a bunch of errors when you run the tests? Think we need more info
Hey guys, when running anchor test how do you make it test the next "it" after the first one? For some reason it tests the first and then stops instead of executing the second... : /
thats super cool that you can do that
Thanks <@!832140329301311488> 
It works by setting my enum value as a key:
```
  const languages = [{
    language: 'English',
    level: {
      elementary: {}
    },
  }]
```
Thanks, i get clone error but resolved by adding Clone to the derive, thanks 🙂
Stick a `#[derive(AnchorSerialize, AnchorDeserialize)]` above the struct definition
Hello,

It's possible to use a custom Struct in a account ?


#[account]
pub struct BaseAccount {
    pub president_prediction_list: Vec<PresidentPrediction>,
}

pub struct PresidentPrediction {
    pub prediction: String,
    pub amount: u64,
    pub buy_datetime: i64,
}

the trait bound PresidentPrediction: anchor_lang::AnchorSerialize is not satisfied

the trait anchor_lang::AnchorSerialize is not implemented for PresidentPrediction
It is the same account, but the runtime allows accessing those sysvar accounts without passing them
sounds like i need to read up on how programs are run
ok, so, sorry I don't mean to harp on this but would like to understand, i'm assuming there is a difference between calling a rust utility type function and calling a clock supported by the solana framework, and calling `Clock::get()?.unixtimestamp` will effectively grab the solana clock (i.e. is "safe" from a security perspective), maybe the distinction here is just in my head since i'm not clear on what exactly is under the hood
answering my own question here, looks like this does it https://github.com/project-serum/anchor/blob/ab3e1294d93b4173feeffda048c08feff09511eb/ts/src/program/event.ts#L70
does Anchor support subscribing to events? it's mentioned here: https://github.com/project-serum/anchor/blob/master/tests/events/programs/events/src/lib.rs but I haven't seen any examples of how a client can subscribe
Another trick to dedupe the transaction is to add some bullshit instruction to it, like transferring lamports to yourself
thanks it worked
The syntax is `{ yourVariantName: { ... } }`
I see one in tests/lockup, in the "Drops an unlocked reward" test
Is there any examples of how to pass enum from js instruction to anchor ? Tried a couple of things but it did'nt worked getting the error -  unable to infer src variant
sleeping is good enough for now haha. Thank you for your help!
Besides just like sleeping for a second (not great, but just as a proof of concept)
So you need each subsequent "identical" tx to get a fresh blockhash—trying to remember the best way to do that 🤔
thats so interesting
The issue under the hood is that solana won't let you run two identical transactions—identical including their `recentBlockhash`
But then I ran it again and it failed
weird so passed this time
just trying to build a simple counter that increments when the increment instruction is called. But calling it multiple times doesn't see to work
I'm trying to call a `increment` instruction multiple times in my test. It passes the first time the instruction is called but fails the 2nd time  I get the error that `This transaction has already been processed`   

`pub fn increment(ctx: Context<Increment>) -> ProgramResult {
        let my_account = &mut ctx.accounts.my_account;
        my_account.counter += 1;
        Ok(())
    }`

`let account = await program.account.myAccount.fetch(wallet.publicKey)
    console.log(account.counter)

    await program.rpc.increment({
      accounts: {
        myAccount: wallet.publicKey,
      }
    })
    account = await program.account.myAccount.fetch(wallet.publicKey)
    console.log(account.counter)
    
    await program.rpc.increment({
      accounts: {
        myAccount: wallet.publicKey,
      }
    })
    account = await program.account.myAccount.fetch(wallet.publicKey)
    console.log(account.counter)


    await program.rpc.increment({
      accounts: {
        myAccount: wallet.publicKey,
      }
    })
    
    account = await program.account.myAccount.fetch(wallet.publicKey)
    console.log(account.counter)`
Oh great. I'll check this out. Thanks!
You can currently skip the sysvar passing actually, assuming you don't need it for a CPI (you can just do `Clock::get()?` dynamically)
Awesome, ok, thanks
Pass clock as one of the accounts. I got the slot, can explore more of clock to get other stuff.
```rust
#[derive(Accounts)]
pub struct Initialize<'info> {
     ..... // other code
    pub clock: Sysvar<'info, Clock>
}
```
Read it inside the program as 
```rust
 msg!("{:#?}", ctx.accounts.clock.slot);
```
a simple question.. if you deploy the dex-ui ( adding the referal accounts ) i'm able to trade, BUT not able to settle the funds and retrieve them to my wallet
eerror says InitializeAccount.. but the referal account and my account is above 0.1 sol
steps on the serum docs to host a UI a pretty simple, but something additional might be missing
Hello


//////////////////////////////////////////////////////////////////////////////////////////

Found the answer sharing here if other find it useful.To generate vanity token address : 

1. Generate a keypair - using solana keygen create a vanity address
2. spl-token create-account <Path_To_That_Keypair>
Amazing. This was all super helpful, I really appreciate it!
It's not just one of the signers, hmm.
I'm not sure what you actually pass for the `owner` argument 🤔
I've never actually tried doing that multisig thing though and am confused how it actually works tbh
Mm, I think I'm misunderstanding your question—yeah, I think the extra signers are for a multisig thing https://github.com/solana-labs/solana-program-library/blob/master/token/program/src/instruction.rs#L169
ah, yeah - I guess that's implicit. I guess the scenario for those extra signers would be if multiple parties were needed to authorize a mint_to?
Why would the mint itself need to sign?
so if the mint was a pda address I would have to include it in both the mint_to call and the invoke_signed call to let solana know to expect that behavior?
ah, ha
They also affect who has to sign—if you don't pass any, then the `owner` argument has to, otherwise it doesn't
Just telling the program "hey, you might need these accounts"
Reading the source of `mint_to`, it looks like they're just being pushed to the accounts list that's passed to the instruction. I guess that makes sense on some level
That's just how solana signs for them (wouldn't be enough to pass the account info, or its address—you need the seeds + bump)
And at any rate, you'll definitely need to provide seeds + bump for any PDA you want to sign with
I'm not actually sure what the point of the additional signers are, but you can see the effect by jumping to source
Huzzah! That was it. Can you explain the difference between the `signer_pubkeys` param in mint_to vs the  `signer_seeds` in `invoke_signed`? It seems like I should have been able to replace `&[&ctx.accounts.mint.key()]` with `&[&ctx.accounts.generator.key()]` and just called invoke, no?
You don't need the mint to sign here, just the generator
Replace that with `&[]`
Ah, it's because you're doing `&[&ctx.accounts.mint.key()]`
It's definitely failing on the MintTo instruction
Sure. Here's the log from the failing test: https://gist.github.com/theycallmeswift/ffc33df90b9200a41b5c0d9a33892558
Can you post more of the program log?
Yes, it gets initialized successfully. I'm able to do things like ` await program.account.generator.fetch(generatorPda);` in my tests and get valid data back
Was the pda init ?
The PDAness of the address doesn't change anything—it's whoever paid for the account creation
<@!134416332509675520> still getting a missing required signature. Here's my updated code. Bump is stored on the generator (it's the bump the PDA gets initialized with):

```rust
use anchor_lang::solana_program::{
    program::{invoke, invoke_signed},
    system_instruction,
};
use anchor_spl::token::{Mint, Token, TokenAccount};

pub fn mint(ctx: Context<Mint>) -> ProgramResult {
    let generator = &mut ctx.accounts.generator;

    let mint_to_ix = spl_token::instruction::mint_to(
        &ctx.accounts.token_program.key(),
        &ctx.accounts.mint.key(),
        &ctx.accounts.token.key(),
        &generator.key(),
        &[&ctx.accounts.mint.key()],
        1,
    )?;

    invoke_signed(
        &mint_to_ix,
        &[
            ctx.accounts.mint.to_account_info(),
            ctx.accounts.token.to_account_info(),
            generator.to_account_info(),
            ctx.accounts.token_program.to_account_info(),
        ],
        &[&[b"generator".as_ref(), &[generator.bump]]],
    )?;

    Ok(())
}

#[derive(Accounts)]
pub struct Mint<'info> {
    #[account(mut, seeds = [b"generator"], bump = generator.bump)]
    generator: ProgramAccount<'info, Generator>,

    #[account(mut)]
    buyer: Signer<'info>,
    #[account(init, payer = buyer, mint::decimals = 0, mint::authority = generator)]
    mint: Account<'info, Mint>,
    #[account(init, payer = buyer, token::mint = mint, token::authority = generator)]
    token: Account<'info, TokenAccount>,

    rent: Sysvar<'info, Rent>,
    token_program: Program<'info, Token>,
    system_program: Program<'info, System>,
}
```
who pays rent for PDAs?
I don't know of any way to use lldb or breakpoints etc. 😦
Maybe stupid question, how are people debugging their anchor based programs? For example is it possible to put a breakpoint in vscode and use codeLLDB?
Not quite, the entire seeds + bump for that address. So e.g. if you had `seeds = [b"the-seed".as_ref()]`, you'd do
```.rs
&[ &[ b"the-seed".as_ref(), &[the_bump] ] ]
```
Let me update it to use a PDA for generator. From there the `signer_seed` should be the generator's bump? Like `&[&[&[bump]]]`?
And pass nothing additional to invoke_signed (could maybe just use `invoke`, which is invoke_signed but without passing any seeds+bumps)
Then you're gonna have to get its private key to sign, from the client 😬
No, but it probably should now that I'm thinking about it
Think of `invoke_signed` as instead being called `invoke_with_additional_pda_signatures`
So the generator account doesn't live at a program-derived address?
The `CpiContext` version of this can be found here if that's easier to digest: https://discord.com/channels/889577356681945098/889702325231427584/910739880022278146
Can someone help me understand what the signer_seeds for this `mint_to` call should be? All the examples I can find are using seeds and bumps, but I'm not in this case right now. It still needs to be signed since the generator account is the authority on the mint from my understanding.

```rust
use anchor_lang::solana_program::{
    program::{invoke, invoke_signed},
    system_instruction,
};
use anchor_spl::token::{Mint, Token, TokenAccount};

pub fn mint(ctx: Context<Mint>) -> ProgramResult {
    let mint_to_ix = spl_token::instruction::mint_to(
        &ctx.accounts.token_program.key(),
        &ctx.accounts.mint.key(),
        &ctx.accounts.token.key(),
        &ctx.accounts.generator.key(),
        &[&ctx.accounts.mint.key()],
        1,
    )?;

    invoke_signed(
        &mint_to_ix,
        &[
            ctx.accounts.mint.to_account_info(),
            ctx.accounts.token.to_account_info(),
            ctx.accounts.generator.to_account_info(),
            ctx.accounts.token_program.to_account_info(),
        ],
        what_should_this_be,
    )?;
}

#[derive(Accounts)]
pub struct Mint<'info> {
    #[account(mut)]
    generator: ProgramAccount<'info, Generator>,
    #[account(mut)]
    buyer: Signer<'info>,

    #[account(init, payer = buyer, mint::decimals = 0, mint::authority = generator)]
    mint: Account<'info, Mint>,
    #[account(init, payer = buyer, token::mint = mint, token::authority = generator)]
    token: Account<'info, TokenAccount>,

    rent: Sysvar<'info, Rent>,
    token_program: Program<'info, Token>,
    system_program: Program<'info, System>,
}
```
This allows you to pass your function arguments to the struct and use them inside, you can see mint_bump used as the bump value.
It's all about computing budget, if you can pass the bump calculation to the client it will be better as it will use less resources on the program
ah cool, cheers
Yeah, not sure why doc test gets annoyed (it just does). You can tell cargo to turn it off: https://stackoverflow.com/a/66759106/238624
everything compiles and tests pass, but looks like it is the Doc-tests that fail, just wondering if this is an Anchor thing or a something-i-have-fucked-up-in-rust thing
has anyone ever ran into these errors when running `cargo test` ? 
```
error[E0659]: `my_mod` is ambiguous (name vs any other name during import resolution)
```
makes sense, thank you 🙂
Right
and I assume that there is no other more low level API that would allow to circumvent this process
yes, that makes sense
Right, which means that *only* your program can sign for one of its derived PDAs (if any other program tried to, `invoke_signed` would use *that* program's program_id, which would break the address derivation part)
so the main security check that ensures safety is that invoke_signed doesn't allow to pass arbitrary program_ids, right?
I tried to explain that above, about invoke_signed—did that explanation make sense? Can try explaining a different way maybe
yes I understand that
PDAs are deliberately constructed so that they're *not* public keys in the cryptography sense (there's simply no private key)
so what prevents malicious programs from signing
Right, the trick is that they "sign" for it, but there's no private key
this implies that the valid program can sign
> They can indeed derive the same address, but they can't sign for it.
Discord bugging, sorry
Mm, no—PDAs don't have private keys (they're not program addresses)
Mm, no—PDAs don't have private keys (they're not program addresses)
but isn't the private key only used for deploy?
so in order to use PDA I have to sign with the corresponding private key (which only the program knows)
yes, that makes perfect sense
I think the private key for that address is used to sign the deploy.
I mean the account that holds the executable of my program
this is the public key of my program account, right?
```
declare_id!("6Xb6fjoBbs4zsh3zmJmVJZ3urB5T8Ln3un6D58vnvFJV");
```
Which addresses are you referring to here?
If you look at the api for signing for a PDA, `invoke_signed`, note that you have to pass the seeds + bump in—but crucially you *don't even have the option* to set the program_id that was used to derive the address.
oh that's another question I had: if each program has a public key of an address, I assume that there should be a private key somewhere?
They can indeed derive the same address, but they can't sign for it.
how is using a PDA approach secure? Wouldn't it be possible for random programs to derive the same account by passing the program_id which created the account?
Ok thanks
search for PDAs and also `seeds` in the examples
cool thanks I got it
How would I create an account (controlled by the program) for my program to hold SOL using anchor?
like use the source code for create-token and wherever they generate a new Keypair, instead load up the keypair linked to your vanity address
it's doable you just need to hack the system a bit
Can it be used to generate token address as well -> I want to create a token which starts with specific characters. In spl-token create-token  ?
the solana CLI might have changed slightly since then but probably not by much
https://smith-mcf.medium.com/solana-vanity-address-using-gpus-5a68ad94d1d4
Does someone know how one can generate vanity token address like orca has  : orcaEKTdK7LKz57vaAYr9QeNsVEPfiu6QeMU1kektZE  ?
you are absolutely right.. and I am using Intellij feeling like an 👴  my bad
Have you maybe messed up the imports at the top of the file? Works fine for me (rust-analyzer does get confused about the imports, since they're macro-generated, but anchor build etc. works fine)
It's always possible to recalculate the bump from scratch (given the seeds), but that costs compute, so might not be a good idea on-chain (the compute budget isn't super high)
In the `account(seeds = [<seeds>], bump? = <target>)` attribute, how to decide if it's useful or not to precise the bump?
not sure if i'm being dumb, but does the basic-3 tutorial not compile for anyone else? It's missing an import for `SetData` and then it will fail to compile here; https://github.com/project-serum/anchor/blob/master/examples/tutorial/basic-3/programs/puppet-master/src/lib.rs#L15

because:
```mismatched types [E0308] expected `Account<Data>`, found `AccountInfo
```
#[derive(Accounts)]
#[instruction(token_bump: u8, mint_bump: u8)]
pub struct TestTokenSeedsInit<'info> {
    #[account(
        init,
        seeds = [b"my-mint-seed".as_ref()],
        bump = mint_bump,
        payer = authority,
        mint::decimals = 6,
        mint::authority = authority,
    )]
    pub mint: Account<'info, Mint>,
    pub authority: AccountInfo<'info>,
```
who can help me  about the init a mint account use anchor ~ . i have 2 questions:
#[instruction(token_bump: u8, mint_bump: u8)]  here what is used for?

seeds = [b"my-mint-seed".as_ref()] ,  what is the seeds used for? i guess is generate the mint address from the seeds, can you show me little about this way. thanks.
in case there are multiple signers
it's because you might want to add more than 1 set of seeds
Thank you
Hi there https://paulx.dev/blog/2021/01/14/programming-on-solana-an-introduction/ this example explains
Hi guys can anyone point me to some resources that can help me figure out PDA's, so that users of my program can pay SOL to the program and the Program can pay out SOL to users?
`[..]` - I am not sure why this operator is necessary
For signer of the PDA, why should I use the `[&seeds[..]]` rather than `[&seeds]`
they are implicitly mutable, but to mint with generator you need the program to sign, so invoke_signed not invoke
Is that what is happening inside `mint_to` ?
Are accounts that were initialized with `init` implicitly mutable? I'm getting an "unauthorized signer or writable account" error when I'm trying to issue a MintTo instruction via a CpiContext. Could just be misunderstanding that I needed to sign something though

```rust
use anchor_spl::token::{mint_to, Mint, MintTo, Token, TokenAccount};

pub fn mint(ctx: Context<Mint>) -> ProgramResult {
    let cpi_accounts = MintTo {
        mint: ctx.accounts.mint.to_account_info(),
        to: ctx.accounts.token.to_account_info(),
        authority: ctx.accounts.generator.to_account_info(),
    };
    let cpi_program = ctx.accounts.token_program.to_account_info();
    let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
    mint_to(cpi_ctx, 1)?;
}

#[derive(Accounts)]
pub struct Mint<'info> {
    #[account(mut)]
    generator: ProgramAccount<'info, Generator>,
    #[account(mut)]
    buyer: Signer<'info>,

    #[account(init, payer = buyer, mint::decimals = 0, mint::authority = generator)]
    mint: Account<'info, Mint>,
    #[account(init, payer = buyer, token::mint = mint, token::authority = generator)]
    token: Account<'info, TokenAccount>,

    rent: Sysvar<'info, Rent>,
    token_program: Program<'info, Token>,
    system_program: Program<'info, System>,
}
```

Error:
```
Translating error SendTransactionError: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account
```
Generating an account programmatically doesn't require it to be a PDA (PDAness is just about the address). At any rate, you'd still need to pass the address in from the client (solana just forces you to do that—if you try the above it won't work unless you also pass that address from the client)
I am pretty sure that you can do `init` on `Accounts` without bump and seed, then it will be a regular account rather than a pda
<@!831450660146642974> maybe I'm missing something here. Isn't creating the mint inside the program the same as generating an account programmatically (PDA) and initializing it as a mint? My pseudo code is something like:

```
mint_id = Pubkey::find_program_address(...)
solana_program::create_account(buyer, mint_id, min_rent, mint_len, calling_program_id);
spl_token::initialize_mint(token_program_id, mint_id, calling_program_id, None, 0)
```

What would the pseduo code look like for signing with the keypair and create the mint inside the program?
what would be the unique seed for the PDA? Another way is to sign with the keypair and create the mint inside the program, more ergonomic
Can someone help me understand the value of letting the end user supply their own mint/token accounts when creating an NFT? Every example I find, it's being passed in to the function, but I'm assuming we could just create those accounts via a PDA. Example can be seen in the Metaplex candy_machine code: https://github.com/metaplex-foundation/metaplex/blob/master/rust/nft-candy-machine/src/lib.rs#L487-L493
Appreciate it!!
I'm not aware of anything other than what's in the metaplex repo https://github.com/metaplex-foundation/metaplex
AH makes sense and this is exactly what I wanna do. LMK if you have like a basic example out there I can look at that accomplishes this.

Happy to work backwards from there.
Though issues would be awesome on anything you think would be helpful
It's just that there's no syntactic anchor sugar for this specifically
Well you can do it in the same way you would do it for any other solana program. That is, create and set the metadata and all that jazz.
Ooooo okay so pretty much — no simple way for people to creates NFTs w/ Anchor rn.

Context: I wanna build a project with Solana + Anchor around NFTs for buildspace!!
There's  an open PR for constants.
Not sure, I assumed some internals or proc macro stuff. Will be fixed later or by us, enjoyooorss of anchors, if we get the time to look into it!
If you're ever blocked please shout at me. 😄
No stress 🙂
Sorry for the delay on this. Will review it soon.
there is a PR to handle consts here https://github.com/project-serum/anchor/pull/968
the parser idl parser attempts to parse it as usize as it assumes it will be usize
Thanks! are there explanations why it can't use a constant?
Great question. We probably need to add some new types and instructions to `anchor_spl`.
Anyone have a basic example of how to build NFTs w/ Solana + Anchor :)?
https://project-serum.github.io/anchor/ts/classes/web3.connection.html#getaccountinfo
well it is exposed by anchor
I have to create a connection the vanilla web3 way
ty
ah right I think this is where I'm going wrong
oh, so it's not a anchor function
see https://solana-labs.github.io/solana-web3.js/modules.html#AccountInfo
oh yes that works
if you call for instance `getAccountInfo`  then it's `owner`
which program
what do you mean "who"? do you mean which program? or do you mean user space ownership?
thanks, will give it a go
installing from source should work
Hey guys, got the M1 today, followed a tutorial to get the solana CLI working. Is there also some special steps to get anchor working or I can just go ahead and install the classic way?
is there a way to view who owns a specific address?
understood
AFAIK there is no such thing as "program derived accounts", there are "program derived addresses"
is there a getAccountInfo function for program derived accounts?
https://docs.phantom.app/integrating/signing-a-message
Like how does this work in Phantom?
Not an anchor question, but how do I have my client sign a transaction (not a phantom wallet) and then verify that they signed it
ohh oki
lets u run ubuntu on windows and when ur using vscode the entire backend is in linux
wsl2?
and this is one of them :|
and i run into weird intractable problems every now and then with wsl2
yeah ive always liked zsh more but last year or so ive been using wsl2 for dev instead of a mac
or something
yeah bash is the... cash
awesome >:)
switched back to bash and everything is working again
well, kind of. there's something weird going on in my zsh environment
figured it out
ah thanks for help
wheres that folder ?
`.anchor` folder might have some logs?
idk man :/ only thing i can think is uninstall anchor and solana completely, restart computer, and reinstall. if that doesnt work it's probably some little issue with your environment
same thing
make sure to restart your terminal
and `anchor-cli` too
`npm install -g @project-serum/anchor`
i suppose i could reinstall the global one but it should use the local copy
yarn is local
do a global npm install
did a yarn install
did you reinstall the npm anchor package? im a newbie myself so im just going through what i can think of :/
just builds an exits quietly
same thing happens whether its open or closed
if so, you need to turn it off while you're running anchor tests
do you have that running while you're trying to test anchor?
```
Version: 1.8.2
Shred Version: 57600
Gossip Address: 127.0.0.1:1024
TPU Address: 127.0.0.1:1027
JSON RPC URL: http://127.0.0.1:8899
⠁ 00:26:49 | Processed Slot: 3926 | Confirmed Slot: 3926 | Finalized Slot: 3894
```
ya that works
type `solana-test-validator` just to see if it spins up
if i change the test to be invalid still does it
does this in basic-0 and basic-1
never invokes node to run the tests
which one are you testing? basic-0?
looks like it builds and exits
yeah
then it just exits?
```sh
❯ anchor test
BPF SDK: /home/clifton/.local/share/solana/install/releases/1.8.2/solana-release/bin/sdk/bpf
Running: rustup toolchain list -v
Running: cargo +bpf build --target bpfel-unknown-unknown --release
    Finished release [optimized] target(s) in 0.16s
Running: /home/clifton/.local/share/solana/install/releases/1.8.2/solana-release/bin/sdk/bpf/scripts/strip.sh /home/clifton/code/sol/anchor/examples/tutorial/basic-0/target/bpfel-unknown-unknown/release/basic_0.so /home/clifton/code/sol/anchor/examples/tutorial/basic-0/target/deploy/basic_0.so
```
no output and exit code 0
also if it stalled how long did you wait
does the terminal just stall? what is the output?
(as in, it does not run any of the tests)
it builds then does nothing
and `anchor test` is a noop for me
i was trying to go thru the examples from the gitbook
But one would need to recalculate seeds anyway while getting pda for `invoke_signed`, no?


//////////////////////////////////////////////////////////////////////////////////////////

hi guys
Do you have enough sol ?
They do I believe.
Marinade finance might use Anchor. You could see if their source code is public?
Hi, are there any examples for staking SOL from inside an anchor program that I could look at? Any help/pointers would be much appreciated 😄
Hi Friends. I am facing some problem while deploying anchor program on mainnet. Its working perfectly fine on Devnet. Any ideas?
yes, when it can anchor uses the `--bpf-program` option on solana-test-validator to start the localnet with all programs already deployed
ah cool, thanks for the info, i'll try actually deploying and poking about 🙇‍♂️
Or at least I think that's how the tests do things, I should dig into that further 🤔
About deploying, in general, yeah, you need to pay for them. When running the tests by default anchor does something funny to skip an explicit deploy, but you can try deploying them yourself by running a local validator, `solana-test-validator`.
No, the program account is owned by the bpf loader program.
In the tutorial basic-3 the `puppet_master` program doesn't do any Initialization for itself, I suppose because it doesn't have any state that it needs to manage for itself? In this case is the program owned by the system program by default?

My understanding though was that when we deploy any program, we would still need to provide some account which pays for the program to be deployed and the rent.
Yep, this sounds like exactly what PDAs are for. They're addresses where only their deriving program can sign for them.
No. Not totally sure I understand your question—why would it? When you redeploy you're reusing the same program_id, so all those old program-derived addresses are still valid.
Ah, right! Hmm I should think through that more, I never think about that option
Or you could just wrap your sol!
Can probably find some by searching the discord for `try_borrow_mut_lamports`. At any rate, transferring lamports depends (as always) on which program owns the account. I think people get the idea that its always the system_program that's responsible for transferring lamports, but this is wrong—the system_program can only transfer lamports from accounts owned by the system_program! If the source account is owned by your own program then it's up to your program to move the lamports, manually, with e.g. `try_borrow_mut_lamports`.
No, there are separate `associated_token::` attributes you'll have to use
```
rpc response error: {"code":-32002,"message":"Transaction simulation failed: Error processing Instruction 0: custom program error: 0x64","data":{"accounts":null,"err":{"InstructionError":[0,{"Custom":100}]},"logs":["Program Hvo42XYHzroj5jeFE5XzuXxLRwYUKeEagoiLQwc1CvEu invoke [1]","Program Hvo42XYHzroj5jeFE5XzuXxLRwYUKeEagoiLQwc1CvEu consumed 1353 of 200000 compute units","Program Hvo42XYHzroj5jeFE5XzuXxLRwYUKeEagoiLQwc1CvEu failed: custom program error: 0x64"]}}
```
hi, i got this error, 0x64 is 100, is it meaning the error is below Enum ErrorCode num 100?
```
# anchor/lang/src/error.rs

#[error(offset = 0)]
pub enum ErrorCode {
    // Instructions.
    #[msg("8 byte instruction identifier not provided")]
    InstructionMissing = 100,
......
```
or any simple hello world examples of invoke(
            &system_instruction::transfer(

?
yoooo we're trying to send solana from one account to another in anchor - any ideas?
Long winded way of making sure that the use case I am describing is indeed program signed accounts right? I have to make sure the authority on the token vault is my program through a program signed account?
Hey all, I am looking into Metaplex's token vault contract and I just have a general question about calling programs. The token vault allows you to specify a authority that has special privileges like transferring tokens out of the vault. This authority is a public key. My q is, if I call the token vault program in another program that is doing smth different, through a cpi, what's the best way to ensure that only my program can call the token vault program, and only if I call the token vault program I have authority to mutate data
hi, anchor initialize the token address this way ,is it a associated token account? if not ,i want to use anchor to initialize a assocaated token account , is this way work below, just not use seeds and bump?
```
#[account(
        init,
        payer = user_sending,
        token::mint=mint_of_token_being_sent, 
        token::authority=application_state, 
    )]
```
hey all, when redeploying a program that has already been deployed with the same program ID, does it remove the PDAs associated with it?
Yes, I can.
Good day! It seems like a very simple question, but can I pass a vector as an argument of an instruction?
very very interesting.. thank you Alan
I think not specifying space is a little sketchy because it's not guaranteed to work correctly (if you have any dynamically sized stuff in that struct). But up to the programmer.
If you don't specify space, then Anchor will expect `StateAccount` to implement the `Default` trait. Then at runtime it will make a default instance of the struct with `StateAccount::default()`, try serializing it with borsh, check how many bytes it ended up using, and use that for space.
Another noob question heh
```
#[account(
        init,
        payer = user_sending,
        seeds=[b"state".as_ref()],
        bump = state_bump,
)]
application_state: Account<'info, StateAccount>
```
from the same app
isn't it an issue that `space` isn't defined? Does Anchor auto-calculate that or something if u don't provide it?
i gotcha 😛 ive actually been keeping a list of stuff that needs documented for anchor. ill try to contribute once i feel more comfortable with the framework. If you guys keep your own list that might be helpful too
Haha, docs will be great some day, just not quite yet (still really early)
*slowly turns to Anchor...*
You'll almost always be better off looking at source + examples in the tests directory (or even better, writing little example programs yourself! that's what I do): https://twitter.com/NikhilChatu/status/1461103366726160385
gotcha, thanks. i was looking in here for answers to this confusement
https://docs.rs/anchor-derive-accounts/0.18.2/anchor_derive_accounts/derive.Accounts.html
am i looking in the wrong place?
Right (most operations on that token account will require application_state to sign)
oh okay, makes sense i think. btw `token::authority=application_state` means only application_state can transfer tokens out and close the account right?
The token account itself will live at that program-derived address.
when you say "account" in this sentence you mean that the token account address itself will be a PDA of those seeds?
 or it will create a main account first of those seeds and then create a token account from that main account and then set the owner/authority of that token account as `application_state`?
In this case the account will live at the program-derived address based on the program's program_id + those seeds + bump.
That's saying initialize a token account, whose mint is mint_of_token_being_sent and whose authority (the "owner" of the tokens, in the logical/human sense, not the which-program-can-mutate-the-account sense) is application_state.
Hi, how do you decode data from an account into an object?
```
  let results = await connection.getParsedProgramAccounts(programId);
  // results[0].account.data contains a buffer of the account data. how do I decode this?
```
i have one other i keep seeing in Daniel's safe pay app
https://github.com/PirosB3/SafePaySolana/blob/master/programs/safe_pay/src/lib.rs#L326-L327
```
#[account(
        init,
        payer = user_sending,
        seeds=[b"wallet".as_ref()],
        bump = wallet_bump,
        token::mint=mint_of_token_being_sent, // THIS
        token::authority=application_state, // AND THIS
    )]
```
what are those last 2 lines doing??
hmm, i see. and `Something` is the struct that references that account's data structure
Yeah, more or less—given an `Account<'info, Something>` you can call `.to_account_info()` on it
oh okay, i think that covers when i should use it lol. So can I just use `Account` and never use AccountInfo? Can anchor use either/or in places that just need raw account information?
`Account` is way, way fancier/more powerful (it does deserialization for you, checks ownership, etc.), whereas AccountInfo does absolutely nothing—it just gives you the raw account that the solana runtime handed us.
What is the tl;dr for when to use `Account` and when to use `AccountInfo`? Only thing i can understand right now is that the first is anchor's and the second is solana native..
Only by passing that public key as an account from the client (this is just a funny part of how solana works, it's not possible to dynamically fetch an AccountInfo from within your program—you have to pass it as an account from the client)
How can I convert a public key to AccountInfo type?


//////////////////////////////////////////////////////////////////////////////////////////

```

    const createCrc32Hash = () => {
        return Uint8Array.from(CRC32.str(Date.now().toString()).toString()).slice(
          0,
          8
        );
      };
      
    const crc32Hash = createCrc32Hash();

    const [accountAddress, accountNonce] =
      await anchor.web3.PublicKey.findProgramAddress(
        [authority.publicKey.toBuffer(), crc32Hash],
        program.programId
      );

    await program.rpc.createZeroCopyAccount(accountNonce, crc32Hash, {
        accounts: {
          host: authority.publicKey,
          zeroCopyAccount: accountAddress,
          pda: pdaAddress,
          systemProgram: SystemProgram.programId,
          rent: anchor.web3.SYSVAR_RENT_PUBKEY,
        },
        signers: [authority],
      });
```
```
    pub fn create_zero_copy_account(
        ctx: Context<InitZeroCopyAccount>,
        _bump: u8,
        _crc_32_hash: [u8; 8],
    ) -> ProgramResult {
        let zero_copy_account_key = *ctx.accounts.zero_copy_account.to_account_info().key;
        msg!("key: {}", zero_copy_account_key);
        let zero_copy_account = &mut ctx.accounts.zero_copy_account.load_init()?;
        let authority = &mut ctx.accounts.authority;

        zero_copy_account.authority = *authority.to_account_info().key;

        Ok(())
    }
```
Sure , one sec
what's the instruction handler code?
I have a quick question, I have something like this: 

```
#[derive(Accounts)]
#[instruction(_bump: u8, _crc_32_hash: [u8; 8])]
pub struct InitZeroCopyAccount<'info> {
    #[account(mut, signer)]
    pub authority: AccountInfo<'info>,
    #[account(init, seeds =[authority.key.as_ref(), _crc_32_hash.as_ref()], bump=_bump, payer = authority, owner = *program_id)]
    pub zero_copy_account: AccountLoader<'info, ZeroCopyAccountState>,
    #[account(mut)]
    pub pda: ProgramAccount<'info, PdaState>,
    pub system_program: Program<'info, System>,
    pub rent: Sysvar<'info, Rent>,
}
```
However, I get the following when calling the RPC from the tests: 

"Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account"
Because it will be weird for the users to connect wallet just to check data.
yeah like checking data
by readonly calls you mean calls like balance check?
But personally, i don't like the fact that you have to pass in the Wallet object because what if you only want to make read-only calls? The current walk around for that is to make empty wallet object and pass that in....
got it makes sense now , thank you REGO350 🙂
Yes
that is why we passin connection (like devner or mainnet) parameter too?
Basically, the provider object gives you connection to the blockchain AND wallet/signer object that lets you send/sign transactions.
If you are not familiar then you shouldn't check because ethes.js is first of all ethereum thing and it's a little complicated to understand first
not so familiar with it but will check, thank you 🙂
yea, everwhere i go i see it. you are right.
ill do :). thank you Alan.
it's community maintained, PRs get auto merged i think once checks are green
If you are familiar with Ethers.js, it's like Signer object
Agreed, or just doing stuff in JS.... you will realize quickly how much you need it
I think it will probably be easiest to understand what a provider is by just reading its source code, honestly
Thank you, got it (still a little confused).
That is why you pass it in a wallet and a connection
So a combo of a wallet and a connection.
It's a thing that can send + sign/pay for transactions.
Like everything in JS
what do we use it for?
Haha, don't really know, just know how to use it
what is a provider
ah sorry, i mean generally
`const provider = new anchor.Provider(connection, wallet, {
    preflightCommitment: "confirmed",
  });`
what is provider?
Never mind, it's the size of the unint8 array
I want this account only
In this, how do I know how big I should set the datasize filter?
`const accounts = await provider.connection.getProgramAccounts(
    program.programId,
    { filters: [{ dataSize: 10000 }] }
  );`
Or `Math.pow(2, 53) + 1 + 1 !== Math.pow(2, 53) + 2`
Just ran the test, and precision is good enough! Thanks Alan... hopefully we can link up in Lisbon
So e.g. `Math.pow(2, 53) === Math.pow(2, 53) + 1` 😱
Big nums exist because JS numbers are doubles, and can only represent integers exactly up to 2^53 if I remember right
hahaha, ok
I am dealing with lat/long
Big nums 🙂
Is there a way not to lose precision? Precision is very important for me here
Ok...
But you can of course lose precision doing so, so might have to be careful
Thanks!
`.toNumber()`
How do I decode a BN back to a JS number?
Is this also true for devnet and testnet? Because i'm thinking about deploying my program + token to live network.
Interesting
Hmmm....
It's so centralized LOL
It looks like you have to create pull request to this repo?
https://github.com/solana-labs/token-list
I am source diving right now... kind of curious how you do it now
Do you create like metadata account from mint token?

Good question, it looks like it has metadata like a MEtaplex NFT
spl-token.
If you are familiar with ERC20, you can easily set token name and token symbol. How do you do this in solana?
Like NFTs
How do you set token name and token symbol for mint tokens?
It is latitude and longitude
I want to get as many decimal points as possible....
ah ok
instead of doing assetions with BN
Yea.... I think it is because the number I was using was too big... 10^14, when I brought it down to 10^13 it worked
maybe convert that to number by using .toNumber() method?
when I try and pass a negative number into anchor.BN
It says "assertion failed"
Can I not send negative numbers into Anchor from JS???
My understanding at the time was that yeah, this kind of renders that testing library kind of useless :/
So you think there is no way of fixing this ATM?
Doesn't seem so. I pass the pubkey to the instruction with the bump seed from `find_program_address`.
I think I actually ran into this too, and it just doesn't let you initialize accounts via CPI or something silly (kind of an oversight lol)
Ohh, you're using the solana rust test library?
Is it possible you already initialized an account there with zero length?
So many scammers lol

dont ask in solana server
Why is account data length is not initialized to the correct value?
Trying to init a PDA in an integration test (solana-program-test) I get this error:
```
thread 'solana-bank-forks-client' panicked at 'Account data resizing not supported yet: 0 -> 87. Consider making this test conditional on `#[cfg(feature = "test-bpf")]`', ~/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-program-test-1.8.1/src/lib.rs:369:25
```
Interestingly, when I inspect the phantom popup it looks like the network traffic to the localhost rpc server is normal.
Ah, actually—not sure what happened, but now my localhost phantom is spinning too.
Guess i'll have to ask in solana channel 
(but i usually dont get response, thats why I always ask here lol)
Hmm, not sure what's wrong then 🤔
I can send/approve transactions but cannot view tokens
yes
Yep, works fine for me. Is your local validator running?
Always like this when I connect to localhost. Does phantom wallet support localhost?
Yep, thank you!
unfortunately the other program is already deployed, but ill find a way to make it work 😅
So you ought to be safe for now-ish timestamps.
Funny, I had never thought about that before. I think negative timestamps just mean before Jan 1 1970 (there are only like 2^25 seconds in a year so you can go pretty far into the future with 64 bits)
Is it safe to cast `unix_timestamp`s i64 to u64? Are there any cases when it can be negative?
Hey all, are there any program examples of staking one could look at as a reference? Just a simple one eg stake x token and get new x tokens
if you remove it you will have to reimplement that part
The 8 bytes is a good abstraction for the account to be valid
I see, you could make the other program read with the 8 bytes then?
I would like to know how to implement the magic used for initialising TokenAccount and Mint for my own custom type 🤔
I'm basically just trying to write data to an account in the program I'm writing with anchor without having the 8 byte discriminator at the beginning
the other program is only reading from the data, but it requires it to be a certain way (which doesn't allow 8 unrecognised bytes at the start of the data)
think about accounts like a database that belong to the program, no other db should be allowed to write anything to it as it wouldn't be valid
this would break every single thing in existence
you cannot write data then give it to another program
Essentially I'm trying to initialise a new account's data and then send it of to an existing on-chain program (which wasn't written with anchor) and unfortunately won't work with those extra 8 discriminator bytes at the start of the data
Hi guys, I noticed in the anchor_spl source code they  make it possible to play nice with the 'Mint' and 'TokenAccount' types from spl_token. It seem like these accounts don't have the 8-byte discriminator prepended to their data. I'm wonder how I can implement this myself for a different struct.
Using existing account data structs without 8-byte discriminator
Thanks <@!438874996614365185> the {accountFromIDL}.fetch(pubkey) is just what I was looking for. Appreciate the explanation : )
`connection.getAccountInfo(pubkey)` to just get the raw acount data or u can use anchor to deserialize with something like `program.account.{accountFromIDL}.fetch(pubkey)` where the {accountFormIDL} is something from your anchor generated IDL that represents a specific type of account data in your program 

and program is from something like `new anchor.Program(idl: Idl, programId: Address, provider?: Provider)`
But there is a button to unwrap all potentially wrapped SOL
Yes, some dapp don't unwrap, like saber.
What jupiter aggregator is doing is warning about unwrap SOL, but only SOL balance is considered
Whats the typical way to fetch account data via the typescript client?
Maybe some dapps doesn't include unwrap instruction so user's solana is still in wsol state.
I want to check for user's solana balance before transaction and make sure that user has enough balance. However i thought that some of their solana could also be in wrapped sol.
What is the question, what are you trying to do
Sorry what do you mean by that sir?
what is the exact context here?
When we check for user's solana balance, do we also check for their wsol balance? Or can we be sure that their wsol is already unwrapped?
appreciate the above. The helped me the most. It's tutorials 3&4 which im focusing on now to get a better idea. I will play around with things for a few days, and then things will click,. as that has been the case to date.
just ran that check and it has a length of 9744 so right on there for the limit.
ya i would say think about the program as stateless executable code, and then accounts as things where the data is stored. Every time you run a transaction u give it a program and instruction, and list of accounts to operate on. It loads these specific accounts and then operates on them and writes them back. So for every transaction that modified or reads an account, it needs to be passed into the instruction. the term "account" is very overloaded since it basically refers to everything 🙂

for examples, definitely all of the examples in anchor (basic1-4) https://github.com/project-serum/anchor/tree/master/examples/tutorial are great easy ones to go through

then i would say looking at escrow is a real use case of some of the concepts that is pretty straightforward to understand
https://github.com/project-serum/anchor/tree/master/tests/escrow

and then anything else in `misc`. I would also maybe recommended comparing this non-anchor version of escrow (https://github.com/paul-schaaf/solana-escrow/tree/master/program) to the anchor version. And maybe even trying to play around without anchor to fully understand what its doing this should help show the power of anchor ⚓ and also help u understand solana programming model
and thank u for the tip on the account !
i was thinking of writing a puppet program that woudl initialise a PDA account and write data to it until full. To me that makes the most sense. One thing/concept im hazy on is how the account called each time will be new, butr for that i woudl initialise with a different seed each time. I havent fully understood all the docs yet, and i need more work on the cpi/pda aspect. excited to dive in. Any examples of what you suggested would be amazing!
depending on what youre doing you may want to have a new derived account for each of those pubkeys so they are smaller and stored separaretly.

regarding checking how much is used, if you used just the command line tool looking up the account `solana account {pubkey}` you can kind of see how much is in use though there is probably a better way to get the exact number of bytes left
is there a way to check how much of an accounts data limit is populated. I'm writing Pubkeys to an account, and the limit is 172 pubkeys for an account initialised with 10K space. 

If there is a way to initialise a new account i wold appreciate any direction! COmpletely new and learning, so apologies if its a basic questions. Suggestions on what to google/read for more info welcome as well !
Hi friends. In my contract, I am using invoke. Sometimes this invoke trough the error. I am just wondering how I can invoke the custom error on invoke()? . At the moment it is automatically through  the solana error.
check that it comes from the right seeds **
what do you mean by check? you can look up the data in any account via its publicKey, or pass it in as an instruction to a program invocation
Are we able to check a PDA account which is derived from another program with #[account(seeds=[...], bump=..., ...)]?
Oh great thanks. How do you/we know to use these extra things in the account macro like mint::decimals, mint::authority or token::mint without seeing them in an example?
Yes. See `tests/misc` for an example.
Is it possible to create a Mint account via #[account(init, owner = token_program, ...) ?
Got it -- ty fam :).
Almost. It doesn't specify who the owner of the program is. It specifies the address of the program. That address--the program--is the *owner* of all accounts created and modified by the program.
So if I had to recite it back to you, is this any good? (just trying to make it settle in!)

```
basically it's an id initially generated by anchor init that specifies our program's id. When we run a function, it'll essentially look at this id and know who the owner of this program is. That's important because the owner specifies how to load and execute the program and contains info on how the Solana runtime should execute the program. 
```
Similarly, a hard coded address is used for the generated CPI client and `Program<T>` type.
This is used for security. It allows us to assert that all acounts declared in the program are owned by that ID.
Statically embeds the address of the program into the binary.
Could someone sorta ELI5 what `declare_id!("4NxrkrWwJX29WrJuKEMWZChhgYZJT5irSGVrpvVqtabo")` does and why we need to change it to a new address output by `anchor build` before deploying via `anchor deploy`?
Just figured it out...
Thanks!!!
`splToken.ASSOCIATED_TOKEN_PROGRAM_ID`

what is the assoicatedProgramId
Found it

Where does associatedTokenAddress live?

Yes… I know that too!
You can use an "associated token" address for this.
Presumably you also know the intended recipient? (Whoever will "own" those tokens)
How do I create the token account to send a token to if all I know is the mint pubkey??
Perfect, I think I get it 🙂 Thank you
You'd basically just have to come up with different seeds. Think of the seeds as the program's "name" for that address; you'll just have to pick a unique name for each account.
Got it, do you know of a way where I can create multiple PDAs that derive different addresses? If I pass in another variable from client as an instruction and use that to derive the PDA, does it make an impact on the security of the application?
Yep, given the same seeds + same program_id, you'll always get the same address.
How do you guys recommend creating seed / bumps for PDAs? 

If I use the public key of the signer as the seed, and if the signer has multiple accounts, wouldn't it derive the same address everytime? Or if I use a static seed like b"hello_world", it would also derive the same address, correct?
Thank you ! 😊
This is mine 🙂

https://github.com/farzaa/test-for-anchor
Awesome! Thank you, I was looking at this but was hoping for a more comprehensive example if there are any. Maybe like a github repo
Lots of little examples here:

https://dev.to/dabit3/the-complete-guide-to-full-stack-solana-development-with-react-anchor-rust-and-phantom-3291
Epic, ty!
Hi, are there any good examples of connecting anchor to the frontend with React and sending signed transactions with a wallet?
https://github.com/solana-labs/solana-web3.js/blob/master/src/connection.ts#L4036
you could also setup a `Connection#onLogs` listener at the start of all tests and just redirect to stdout if you want to see them there
You can see logs in `./.anchor/program-logs/`
Ah so is there a way to see it upon `anchor test`?
`msg!` prints to the program log onchain
Trying to get basic print statements working in my Anchor program, but, looks like a a `println!` or `msg!` doesn't seem to do the trick upon running `anchor test`.
Hello! Question about IDLs/dynamic traits. I wasn't able to add `derive(AnchorDeserialize, AnchorSerialize)` on one of my structs `Foo` because it has a `Box<dyn BarTrait>` field in it. 

I was able to manually `impl AnchorSerialize for Foo` and `impl AnchorDeserialize for Foo` to get past the compiler errors, but `Foo` doesn't show up in the IDL when i run `anchor build`, I guess since I'm not calling `derive` directly?

Any suggestions for how to work with structs with a dynamic boxed trait in anchor? I can paste a code snippet too if it's clearer
ty friend
thanks
unless you wanted to deploy your program locally to test a front end/client integration or something of the sorts
so no, you don't need it running separately if you don't have a real reason to
by default `anchor test` will stand up a local validator behind the scenes to deploy and test against unless you explicitly add `--skip-local-validator`
Do we ever need the local validator running when building, testing, and deploying w/ Anchor?

`solana-test-validator`
GM Anchor friends :).
need to change`&AccountInfo` to `&AccountInfo<'info>`
not totally sure, have attempted to finagle it, but i think there's something that just isn't clear to me about how this is supposed to (or not supposed to) work, any suggestions would be appreciated
running into some rust-noob issues, i'm trying to use `remaining_accounts` (which should be a fixed size based on my use-case)
and then pass a single account into a cpi context, like so:
```
impl<'info> Distribute<'info> {
    fn into_distribute_context(&self, to: &AccountInfo) -> CpiContext<'_, '_, '_, 'info, Transfer<'info>> {
        let cpi_accounts = Transfer {
            from: self.vault.to_account_info().clone(),
            to: to.to_account_info().clone(),
            authority: self.system_program.to_account_info().clone(),
        };
        let cpi_program = self.system_program.to_account_info();
        CpiContext::new(cpi_program, cpi_accounts)
    }
}
```
but it's giving me this error:
```
error[E0621]: explicit lifetime required in the type of `to`
   --> programs/router/src/lib.rs:178:38
    |
171 |     fn into_distribute_context(&self, to: &AccountInfo) -> CpiContext<'_, '_, '_, 'info, Transfer<'info>> {
    |                                           ------------ help: add explicit lifetime `'info` to the type of `to`: `&anchor_lang::prelude::AccountInfo<'info>`
...
178 |         CpiContext::new(cpi_program, cpi_accounts)
    |                                      ^^^^^^^^^^^^ lifetime `'info` required
```
ah no need, it is written on the link
totally! it was really helpful for me! sorry should have referenced you for credit
it feels nice to see my repo used as an example 😄
this file is straight from metaplex
i don't think there is a magic anchor way, since this isn't an anchor program
Thanks!
yeah, there's some code here that gets at it, but i think there's a much easier way with some of the anchor utilities, though i can't find them offhand
https://github.com/random-access-memories-so/ram-app/blob/98227d8fb470305e4828de3e113d9e10bf8da53b/src/tools/metadata.ts
I am getting the token accounts by owner and now want to do stuff with them, but can't without also having the mint pubkey
JS
in JS or solana/rust?
How do I fetch an SPL token's mint if I have it's pubkey???


//////////////////////////////////////////////////////////////////////////////////////////

Ssh to a remote Linux machine
any work arounds bois
Solana Rust BPF toolchain is not available on Windows
guys need some clarity on NodeWallet. what is that class for? when should i use it
Could have been... I'm still using Anchor v0.17.0
I sort of thought floats got added recently but I guess not yet 🤔
Yeah, you can see the current list here: https://github.com/project-serum/anchor/blob/master/lang/syn/src/idl/mod.rs#L164
Hey <@!134416332509675520> , can you perhaps help with this? 😅
No problem... glad I could be helpful.... that's why I like to post the answers to my problems... figure someone else will have them haha.
thanks!
Is there a way of adding an rpc call in the set of instructions that are executed when a program is deployed? I am writing a program that sets an admin (external PubKey) within a PDA during the initialize call and want the initialize call to be executed right after the program is deployed. Else anyone can call this function and become the admin
`init` means anchor is going to write a bunch of code to create an account (could be an account your program will own, or a few other kinds: a token account, a mint, an associated_token account)
Ah, ok. I think you're maybe a little confused about what authority means here. If you just want your program to be able to mutate an account, you don't need to set an authority or anything like that—you just need to make sure your program is the program that owns the account. When you use `#[account]` in anchor + `init`, this all happens automatically, no need to do anything else.
what's the difference between init and zero
Hey can you interact with another program ?
how can I check if the given TokenAccount is owned by the anchor programm
the following doesnt work?

`#[account(mut, owner = *program_id)]
  pub stake_token_account: Account<'info, TokenAccount>`
I know decimals aren't used in Ethereum and other EVM compatible chains, but since Solana has a different architecture, just wanted to ask you guys this
Hey can anyone tell me what are the valid data types(i64, u64, u32, etc.) in  the Anchor Rust IDL?

Because I was writing a program where I had to handle some decimals so I decided to use the data type `f64` since it is a valid Rust data type, but looks like it isn't in Anchor. Am I getting this right? And if yes, how do we handle decimals in Solana development (like suppose we are diving 10 by 3 and we want to persist the result in an account). 

Thanks.
really just going for an example of a program that owns it's own mutable state account... super basic 😅
I asked the system_program to set an authority for it instead for that reason, does that make sense?
I just want the StateAccount to be owned by PDA... don't need it to be a token account since it only holds data right?
Ah, your StateAccount isn't a token account, so it doesn't make sense to ask the token program to set an authority for it 🤔 I'm unclear what you're trying to do though.
Ok, I'll look at the IDO pool example.
In the meantime my whole code is here (very short): https://github.com/AlphaPrime8/chain_mail/blob/use_pda_for_state/programs/chain_mail/src/lib.rs
and the client side: https://github.com/AlphaPrime8/chain_mail/blob/use_pda_for_state/tests/chain_mail.ts
perhaps you could glance at it and quickly see where I'm going wrong. Really appreciate your guidance.
IDO pool example has a PDA with a data account on it
Setting token account authority and moving around accounts this way is very non standard
I dunno if I'd really follow along with escrow example in anchor. It's kind of odd
Yeah, I can't really tell from your snippet, but you'd definitely need to specify the token program when setting a token's authority
So i guess there are two issues then: 1) why is token_program argument invalid, and 2) should I be using the token_program somewhere in the set_authority call?
Thanks
Pro-formatting-tip: can do three backticks, `, to do big code blocks
but i get: `Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: invalid program argument
`
and updated the Context with: `    pub token_program: Program<'info, Token>,`
I tried passing it like this:
`
    const tx0 = await program.rpc.initialize({
      accounts: {
        stateAccount: stateAccount.publicKey,
        user: provider.wallet.publicKey,
        systemProgram: anchor.web3.SystemProgram.programId,
        tokenProgram: TOKEN_PROGRAM_ID,
      },
      signers: [stateAccount],
    });`
Are you passing the token_program as one of your accounts?
(forgive the formatting i'll work on that...)
I've been looking at the escrow program in /tests and it calls token::set_authority to transfer ownership of a TokenAccount from initializer to PDA...
I tried adapting the logic for transferring ownership of an account with the CpiContext constructed like so:

`impl<'info> From<&mut Initialize<'info>>
for CpiContext<'_, '_, '_, 'info, SetAuthority<'info>>
{
    fn from(accounts: &mut Initialize<'info>) -> Self {
        let cpi_accounts = SetAuthority {
            account_or_mint: accounts
                .state_account
                .to_account_info()
                .clone(),
            current_authority: accounts.state_account.to_account_info().clone(),
        };
        let cpi_program = accounts.system_program.to_account_info();
        CpiContext::new(cpi_program, cpi_accounts)
    }
}`

Also the Context struct looks like this:
`#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 8 + 1)]
    pub state_account: Account<'info, StateAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}`

But I get this error: Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: An account required by the instruction is missing`
What am I missing?
cool thanks
Ah, sorry, you're trying to—the order is flipped, `addPool(x, y, z, { accounts: { .... } })`
You're not passing a bunch of arguments to the JS rpc call (the error is confusing but that's the issue)
Getting `Error: Invalid arguments: baseAccount not provided.` error when calling add_pool function in client. How to fix this?
you should look at `/tests` in anchor repo
that account is the PDA
can you point me to an example of creating an account to store a program's mutable state and transferring ownership of said account to pda?
Depends on if the data is static or not. If it's static you could just embed it into the program itself. Otherwise you'll need to store it in some account (solana doesn't support mutable static variables).
how do I store arbitrary data my program needs to reference to do account validation in a program? does it need to be initialized as its own account?
Self explanatory. Not enough accounts public keys passed into the function
Any idea what causes: `insufficient account keys for instruction`?
Hey guys! <@!134416332509675520> What’s the point of using tx.partialSign() if we’re able to just successfully call RPC functions using tx.sign()?
okay, so if i don't have any custom errors, i should just go with `ProgramResult`
The `Result<()>` thing works if you've defined an `#[error]` enum for your program, and is a slightly different alias that lets you use your custom error types too
ahh okay, that makes a lot of sense - tyvm!
ProgramResult is the basic solana return type, it's an alias for `std::result::Result<(), ProgramError>`
okay i see my question might be too broad - can someone atleast explain what the difference is between using `ProgramResult` and `Result<()>`?
Hi, i'm very new to developing smart contracts, and i'm currently trying to solve a task, involving building a smart contract for a dutch/descending auction.
I've been researching and trying to get a better understanding to solve the task, but i'm not really getting anywhere...
Can anyone guide me in the right direction, with some usefull links/articles? Anything would be a huge help!
haha no worries, thanks for the info 🙇‍♂️
I can't think of any other way to do it—I say "hack" since I'm not 100% sure about the overall goal (maybe it's fine, not sure)
cool yeah, makes sense. When you say hack together, does this mean it isn't really best practice? I'm just thinking of cases where you have a "child" program like `puppet` that might create some data that doesn't make sense on it's own. Maybe it depends on context tho
You can hack this together with program-derived addresses. You would have Program2 require Program1 to call it and pass one of Program1's PDAs (and sign for it).
Might need to update your `space =` thing?
not sure if this question is too vague.. but what is the best way to ensure that instructions in Program2 can only be invoked (successfully) by Program1? e.g. in the basic-3 example, is there an easy way for the `puppet` program to only execute transactions signed(?) by the `puppet_master`
Hey all quick question - what's the main difference between using `Loader` and `AccountLoader`?
Yes
yeah it works
am i misunderstanding pubkeys?
but I'm getting error 163, account did not deserialize
I'm trying to add a Pubkey as an argument to basic-1 example program
That's all anchor init was trying to do
I don't have a windows machine so don't know why the original thing didn't work (something with the path though)—does running yarn manually end up working?
I can, is that a workaround for the anchor init issue?
Hmm, not sure. Can you just cd into the new project directory and run `yarn` from there?
yeah i can run yarn -version in the terminal and havee had no issue with yarn on any other project I've worked on. Error only appears when using anchor init. 

currently using version 1.22.17 of yarn.
Is it accessible in your path? Not sure what the equivalent of `which yarn` is for windows
Anyone know how  to fix this error on Windows 10:

commad: `anchor init myepicproject --javascript`


Error: `Yarn install failed: No such file or directory (os error 2)`

I have yarn installed


//////////////////////////////////////////////////////////////////////////////////////////

Anyone have any thoughts. this signer key refers to the initializerMainAccount which should be the main account interacting with the endpoint
Ohh when I get rid of he insturctions array from this endpointt, I get this error:      Error: unknown signer: 2NF8ahsqHKZyFb1V17pg5FPuEts8aco51KHE5jxoJznr <@!771049362658426910> Are you aware 🙂 Following your awesome tutorial a
Any ideas <@!134416332509675520>
```
await program.rpc.initializeEscrow(
      vault_account_bump,
      new anchor.BN(initialAmount),
      new anchor.BN(takerAmount),
      { 
        accounts: {
          initializer: initializerMainAccount.publicKey,
          vaultAccount: vault_account_pda,
          mint: MintA.publicKey,
          initializerDepositTokenAccount: initializerTokenAccountA,
          initializerReceiveTokenAccount: initializerTokenAccountB,
          escrowAccount: escrowAccount.publicKey,
          systemProgram: anchor.web3.SystemProgram.programId,
          rent: anchor.web3.SYSVAR_RENT_PUBKEY,
          tokenProgram: TOKEN_PROGRAM_ID,
        },
        instructions: [
          await program.account.escrowAccount.createInstruction(escrowAccount)
        ],
        signers: [initializerMainAccount, escrowAccount ]
      }
    );
```
Hi all, I am writing tests to interact with. my instructions for my online program. I am recieving this error when interacting with Anchor Escrow program:

  Error: failed to send transaction: Transaction simulation failed: Attempt to debit an account but found no record of a prior credit.
Yeah that would be a great feature, Stack Overflow and discord were started by the same person so I would guess there is a way to link the 2 of them.
i'm a big fan of stackoverflow generally
i wonder if there is a discord bot that will post questions with certain tags in a channel
Yeah I went for solana in the end, not sure I have enough rep to make new tag but i'll try add solana-anchor to my question.
maybe we can make one that is `solana-anchor` or something
good question, it doesn't look like there is, i see people coopting html `anchor`, and also using `rust` and `solana`
Is there a specific tag for anchor on Stack Overflow ?
box is necessary to stop from blowing out the memory with too many accounts
yes
```#[account(init,
        token::mint = watermelon_mint,
        token::authority = ido_account,
        seeds = [ido_name.as_bytes(), b"pool_watermelon"],
        bump = bumps.pool_watermelon,
        payer = ido_authority)]
    pub pool_watermelon: Box<Account<'info, TokenAccount>>```

Looking at the ido-pool code. Trying to understand what it does from what I can see is that it creates a PDA account with seed as name+ "pool_watermelon" of TokenAccount type which gets stored on heap(not sure why we need to store this on heap) with authority as ido_account and mint it stores is of type watermelon_mint. Makes sense ?
ty
Ayee it looks like that solved that problem.
okay ill try that
Mm, what if you do `cargo clean` and then try `anchor build` again 🤔

What does `rustup toolchain list` say?
so i completly uninstalled rust and anchor and reinstalled them but its still saying rustc 1.52 somehow its using an older version despite when i run rustc --version it says rustc 1.56.1 is installed
okay thanks ill check into that
I think you'll want to use a newer version of rustc (you seem to be using 1.52 which is kind of old).
Pass an account constraint checking if the Signer = the admin pubkey
How to create a function which can only be accessed by the owner?
Hi to reiterate my problem when i type anchor build i get an internal compliation error. Is this something i can fix. Becuase if i type anchor build -- -Verbose it seems to work
One use case for this (is it the only one? not sure 🤔) is if you want a really big account. Accounts that you directly `init` with anchor get set up via a CPI to the system_program, and solana has a weird limitation where accounts set up like that can only be 10kb in size. If you want something bigger you have to allocate space for them in a separate instruction.
Whoops sorry lol, got distracted and forgot to write up `zero`: it asserts that the account doesn't yet have any discriminator bytes (the first 8 bytes of the account storage are used by anchor to specify which kind of account struct is supposed to go there). This is kind of a specialized use case for when you allocate the account's storage in a separate instruction and then finish the initialization (including writing the discriminator bytes) in a different ix (the one with the #[account(zero)] in it).
what's the difference between this and zero ?
Not sure how to use cli command during the creation process
But this binded to a UI interface
other than SOL
I try to modify this to let candy machine accept spl token
Mm, still not totally sure what you're asking about—do you want to change that `parsePrice` function? I basically have no idea what you're trying to do haha.
This is the definition of the function 

export function parsePrice(price: string, mantissa: number = LAMPORTS_PER_SOL) {
  return Math.ceil(parseFloat(price) * mantissa);
This is how it's done in the create.js
export async function create(
    keypairPath,
    env,
    price,
    configState,
    log,
) {

    let parsedPrice = parsePrice(price);
That function doesn't seem to have anything specific to do with SOL to me (the default is set to 10^9, but it's just a default argument).
Hi all, maybe a dumb q. I deployed a program to devnet successfully. Then I closed the program (which in reality closes the executable data account) with `solana program close {programId}`. Is there a way to re-deploy the program to the same exact programID?
let parsedPrice = parsePrice(price);
export function parsePrice(price: string, mantissa: number = LAMPORTS_PER_SOL) {
  return Math.ceil(parseFloat(price) * mantissa);
How do I modified this line from SOL to other spl token
export function parsePrice(price: string, mantissa: number = LAMPORTS_PER_SOL) {
  return Math.ceil(parseFloat(price) * mantissa);
Friends
Is this correct? I am struggling to get the tests working but I think is due to error in the js test code. 
So I just want to make sure this is correct on the rust side.
Finally the function which adds the pool to the list. 
```
// old name which I don't want to change as used in other places function is add_pool 
    pub fn add_gif(ctx: Context<AddGif>, image_link: String, pool_name: String, pool_desc: String, win_opt:String, close: u32, verify:String, fee:u8) -> ProgramResult {
        let base_account = &mut ctx.accounts.base_account;
        let wins: Vec<String> = win_opt.split(';').map(|s| s.trim().to_string()).collect(); //chars().filter(|c| !c.is_whitespace()).collect()
        // make a program address which will hold the SOL for this pool 
        let pool_wallet = &ctx.accounts.pool_wallet;
        let pool = PoolStruct{
            pool_wallet: pool_wallet.to_account_info().key.to_string(),
            pool_id: base_account.total_pools,
            image_link: image_link.to_string(),
            user_address: *base_account.to_account_info().key,
            pool_name: pool_name.to_string(), 
            pool_balance: 0,
            pool_description: pool_desc.to_string(),
            win_options: wins, 
            close_date_time: close, 
            verify_url:verify.to_string(),
            owner_fee: fee,
            result: "".to_string(), 
            closed: false, 
            entries: Vec::new()
        };
        base_account.pool_list.push(pool);
        base_account.total_pools += 1;
        Ok(())
    } 
```
Hey guys I am building a program where the main baseAccount holds a list of pools I want each pool to be able to receive Sol and pay it out. So I created the following. 
The pool struct. 
```
#[derive(Debug, Clone, AnchorSerialize, AnchorDeserialize)]
pub struct PoolStruct{
    pub pool_wallet: String,
    pub pool_id: u32,
    pub image_link: String,
    pub user_address: Pubkey,
    pub pool_name: String, 
    pub pool_balance: u64, 
    pub pool_description: String,
    pub win_options: Vec<String>,
    pub close_date_time: u32, 
    pub verify_url: String, 
    pub owner_fee: u8,
    // TODO: to allow for pools with more then 1 winning result perhaps result should be an array?
    pub result: String,
    pub closed: bool,
    pub entries: Vec<EntryStruct>
}
```
the pool_wallet and base accounts structs. 
```
#[account]
pub struct BaseAccount {
    pub total_pools: u32,
    pub pool_list: Vec<PoolStruct>,
}

#[account]
pub struct PoolWallet{
    pub balance: u64 
} 
```
then the struct which creates the new pools and adds them to the base account.
```
#[derive(Accounts)]
pub struct AddGif<'info> {
    #[account(mut)]
    pub base_account: Account<'info, BaseAccount>,
    #[account(init, payer = user, space=9000)]
    pub pool_wallet: Account<'info, PoolWallet>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>
}
```
ah
WSL2


//////////////////////////////////////////////////////////////////////////////////////////

Just realized I posted msg in wrong channel will move it to development ☺️
Nope! Try giving it a shot and we'll be happy to help though
do you know any code example of this?
I am trying right now to initialize them outside of accounts context because it's an unknown amount of mint addresses and I don't know how to dynamically initialize in the accounts ctx
When I receive addresses for mint accounts as parameters for instructions, do I have to initialize all of them in the accounts context, if so what are the correct constraints is it #[account (zero)] I am not mutating account data just sending burn instructions
I think that's spoofable from the client though (so, probably not gonna get spoofed lol but maybe)
Or at least that's how I would think to do it.
That's how you would force the caller to prove they own the nft.
Ok. You'll have to do that a bit differently: you'll need to submit a token account holding the nft, and then you'll also need the owner of that token account to sign the transaction.
I have to check if msg sender is the NFT owner.
Wait he has `msg_sender` defined in his context
Well, what do you want to do with the msg sender? Maybe there's something similar you could do that's easier
Yeah, hmm
Not sure if anchor exposes that though
The first account in the tx is the payer: https://jstarry.notion.site/Transaction-Fees-f09387e6a8d84287aa16a34ecb58e239
Versus checking whoever signed as above, which might just be some random signer
I was trying to think, is there an easy way to figure out who paid for the tx? I think in general the answer is no but not sure
A `signer` might be what you have in mind when you think of the msg sender?
Your instruction context defines `Signer` accounts
then what's the best way to get msg sender?
Thanks! That looks like it was the issue. This appears to work now...```
  const result = await program.rpc.sendSol(new anchor.BN(0.01), {
    accounts: {
      from: provider.wallet.publicKey,
      to: secondAccount.publicKey,
      systemProgram: SystemProgram.programId,
    },
  });

  console.log("📝 Your transaction signature", result);
```
The accounts need to match 1-1 with your #[derive(Accounts)] struct
Mm, think you also need to pass the systemProgram, but that would be a different error
It's actually fine for the secondAccount to be a random keypair (that's actually basically what a wallet is)
```
  await program.rpc.sendSol(new anchor.BN(0.01), {
    accounts: {
      from: provider.wallet.publicKey,
      to: secondAccount.publicKey
    },
  });
```
Can you post a bigger snippet?
So, if I change it to ```
    accounts: {
      from: provider.wallet.publicKey,
      to: secondAccount.publicKey
    },
```
I get `Signature verification failed` which I am guessing is something to do with the fact that the `secondAccount` isn't any sort of wallet, it's just a random key pair I generated.
As for verifying that the send worked, you could so something like `await program.provider.connection.getAccountInfo(theRecipientPubkey)` and check how many lamports are in there
ah ok
Few things wrong: first, I think you'll need to do `new anchor.BN(1)` (annoying). Second, those account names don't match what your `SendSol` struct expects (you've got `baseAccount` and `user` rather than `from`, `to`, and `systemProgram`)
I'm not sure if I am doing this correctly, or if I am miles off, but I then wanted to write a test, but can't work out how to have 2 wallets to send the SOL between and then verify that it did something.
```
  const provider = anchor.Provider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.Tipme;
  const baseAccount = anchor.web3.Keypair.generate();
  const secondAccount = anchor.web3.Keypair.generate();
  await program.rpc.sendSol(1, {
    accounts: {
      baseAccount: baseAccount.publicKey,
      user: provider.wallet.publicKey,
    },
    signers: [secondAccount.publicKey]
  });
```
Not in general, no (I'm not sure if solana actually gives you easy access to the sender of the transaction 🤔)
I am trying to write a function that will send sol from the wallet executing it, to another wallet, specified in the function. So far I have something like this (edited for brevity)
```
#[program]
pub mod tipme {
  use super::*;
  pub fn send_sol(ctx: Context<SendSOL>, amount: u64) -> ProgramResult {
    let ix = anchor_lang::solana_program::system_instruction::transfer(&ctx.accounts.from.key(), &ctx.accounts.to.key(), amount);
    anchor_lang::solana_program::program::invoke(&ix, &[
      ctx.accounts.from.to_account_info(),
      ctx.accounts.to.to_account_info(),
    ]).unwrap();

    Ok(())
  }
}

#[derive(Accounts)]
pub struct SendSOL<'info> {
  #[account(mut)]
  pub from: Signer<'info>,
  #[account(mut)]
  pub to: AccountInfo<'info>,
  system_program: Program<'info, System>,
}
```
Is this the correct way of getting msg sender?
It holds a list of prediction pools, but now I understand it can hold lamports as well it makes things a lot easier. 
Thank you very much for your help, you've solved the problem i've been wrestling with for days now.
Accounts have data (potentially empty) and lamports (plus some other stuff)
Yeah, it's just an account (not sure what kind of data it's holding, whatever the BaseAccount struct has in it)
Ahh. ok so it is just holding the program data, but could also hold SOL
Mm, there's no program in that base account (the program is the program_id, not the base account)
No, I though I read that I could not a hold SOL and a program in the same account which sent me down the PDA rabbit hole.
Have you tried using that approach? I think your best bet is to just start trying stuff
Well when start the program I create a baseAccount with the following struct.
```
#[derive(Accounts)]
pub struct StartStuffOff<'info> {
    #[account(init, payer = user, space= 10240)]
    pub base_account: Account<'info, BaseAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}```
and function 
```
pub fn start_stuff_off(ctx: Context<StartStuffOff>) -> ProgramResult {
        // get a referance to the account 
        let base_account = &mut ctx.accounts.base_account;
        // initliase total_count. 
        base_account.total_pools = 0;
        Ok(())
    }
```
Could that be the only account I need?
Basically you can send money to whatever account you want, just gotta make sure you can get it back 😛
What do you mean by "holds the program"?
Can I just send lamports to the baseAccount which holds the program?
You could also sort of get away with not initializing an account at all, and just sending lamports to that PDA's address. This is slightly risky because some of the lamports actually go to rent exemption etc.
That would be the approach where you initialize an account (owned by your program) that lives at the pda with empty seeds. You'd then be able to send it money (somehow), and transfer money from it by doing something like `**ctx.accounts.that_account.to_account_info().try_borrow_mut_lamports()? -= amount_to_send` (plus correspondingly incrementing the recipient's lamports)
Ok  then I just save the publicKey to use as the to and from address for transferring lamberts as required? 
Using this approach do I still need the ```#[account(init, seeds=[], space=9000,bump = bump, payer=user)]``` macro inside the program code.
That just uses empty seeds, no need to remember anything.
I would personally probably use a PDA because then I wouldn't need to remember the address of the account storing the money (a keypair address is random, so you need to remember it). E.g.
```.js
const [address, bump] = await anchor.web3.PublicKey.findProgrammAddrss([], program.programId);
```
The private key might not really matter here once you've initialized the account (you might never need to sign for it again)
I think this makes sense for my use case, and using a PDA seems to be safer in terms of protecting the private key and therefore who can transact with the account? 
Although I am not sure how to implement it.
Makes sense to me.
Maybe for NFTs they're almost the same, but e.g. transferring authority over someone's associated token account for some random token feels super weird to me (what if someone sends them some more of that token?).
My first guess is that transferring the tokens directly to an escrow account (the second option above) feels cleaner to me, but not totally sure.
When you transfer authority of a token account, do you have authority over the entire account, or just some designated amount of its tokens?
what is the right way to hold off token for certain time period. Transfer authority to program and later on again transfer to same sender or create a PDA of mint and sender address and transfer token to that address and when time period ends return that to sender address ? trying to create a staking program for nfts
But alternatively, you could have the account be owned by *your* program, not the system_program, in which case whether it lives at a PDA or a keypair address doesn't matter (your program can just decrement the lamports itself, no need or even possibility of asking the system_program to do it)
That would indeed require a PDA, because otherwise you won't have a good way for the program to sign when asking the system_program to `transfer` the funds.
If you want to store money in an account that your program can distribute, one way to do it would be for it to live at a program-derived address and have the account itself be owned by the system_program.
PDA-ness vs keypair-ness is purely about who can *sign* for the address (PDAs can only be signed for by their deriving program, keypairs can only be signed for with their secret key)
No, the PDA-ness vs keypair-ness doesn't matter (well, it might, but it doesn't necessarily)
Yeah I was just generating a keypair but it should be a PDA. As i understand it a PDA can hold funds for a program and the program can distribute them as required?
What makes you think it's a program-derived address?
Aha. Where is the account's address coming from then? Is it a keypair address or something?
Ahh i think thats where I am going wrong I am not running that on the client side.
The bump is whatever you got when you did `const [address, bump] = await anchor.web3.PublicKey.findProgramAddress(...)` on the client, when you figured out the PDA's address
What do you set the bump to be?
something like this? 
```
#[derive(Accounts)]
#[instruction(pool_name: String, bump: u8)]
pub struct AddGif<'info> {
    #[account(mut, signer)]
    pub base_account: Account<'info, BaseAccount>,
    #[account(init, seeds=[pool_name.as_bytes(),b"pool_wallet"], space=9000,bump = bump, payer=user)]
    pub pool_wallet: Account<'info, PoolWallet>,
    // #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>
}
```
So if you're using `init`, you'll need to also use `seeds = [the, seeds], bump = the_bump`
My guess is that if you're trying to initialize an account at a PDA, you haven't specified its seeds + bump correctly (they need to be specified in order to sign for the address when you or anchor inits the account there—just part of how solana works)
I thought I had se them to mut? https://github.com/jobyid/solana_pred_pools
PDA so yeah mutable account is a necessity
Ok thanks I am trying to create an account controlled by the program which can hold SOL, struggling a bit to get my head around it.
Depends on what you're doing (that error is meant to be somewhat self-explanatory—you're doing some kind of cross-program invocation and you either aren't signing with some account that needs to, or you forgot to mark some account as `mut`)
`init` is the keyword
`/tests` in anchor repo
Hey guys do any of you know why I am receiving this error in my js tests? 
```
Program Cq1TSA1obVQZzw2YYxvFN6Q5ia5TYxSbwyZQ9JwQCbBL failed: Cross-program invocation with unauthorized signer or writable account'
```
does anyone have any code examples of initializing account via cpi?
I don' t think there is any way to do that. 
You can store the seed in the PDA's  data when PDA  is created.
If you know how to receive source of sha256 hash than yes 🤪
Is it possible to find seeds if we have a PDA account public key ?
no way to get it work...
hi devs,

any eta to fix example in readme?
Try searching the discord for further info (there have been many many discussions of declare_id! in the past haha)
It embeds a static variable in your program with its expected program_id. This is useful for a few reasons/currently something you just need to do (it's possible anchor will automate this in the future).
> declare_id! is program id
smh I am dumb: To anyone forking serum-dex, and missing the do.sh file->It has been depreceated. 
Instead of: "./do.sh test dex"
use: "cargo build-bpf"
 
In the root directory of dex
"Convenience macro to declare a static public key and functions to interact with it" still don't get what this means
https://docs.rs/solana-program/1.8.5/solana_program/macro.declare_id.html
what is `declare_id!` in a solana program?
nevermind had to replace `<YOUR-PROGRAM-ID>`
Can someone tell me how to deploy a dex to configured cluster: DEX_PROGRAM_ID="$(solana deploy dex/target/bpfel-unknown-unknown/release/serum_dex.so | jq .programId -r)"

Like what the specific steps
client.js is the same as in the tutorial:
```
// client.js is used to introduce the reader to generating clients from IDLs.
// It is not expected users directly test with this example. For a more
// ergonomic example, see `tests/basic-0.js` in this workspace.

const anchor = require('@project-serum/anchor');

// Configure the local cluster.
anchor.setProvider(anchor.Provider.local());

async function main() {
  // #region main
  // Read the generated IDL.
  const idl = JSON.parse(require('fs').readFileSync('./target/idl/basic_0.json', 'utf8'));

  // Address of the deployed program.
  const programId = new anchor.web3.PublicKey('<YOUR-PROGRAM-ID>');

  // Generate the program client from IDL.
  const program = new anchor.Program(idl, programId);

  // Execute the RPC.
  await program.rpc.initialize();
  // #endregion main
}

console.log('Running client.');
main().then(() => console.log('Success'));
```
I'm just following this tutorial:

https://project-serum.github.io/anchor/tutorials/tutorial-0.html#building-and-emitting-an-idl
Please provide some code to go along with the error message. It's hard to debug like this.
What have you tried so far?
Anyway, running the following:
```
% ANCHOR_WALLET=/Users/prikshetsharma/my-solana-wallet/my-keypair.json node client.js

Running client.
(node:13261) UnhandledPromiseRejectionWarning: Error: Non-base58 character
    at Object.decode (/Users/prikshetsharma/Desktop/anchor/examples/tutorial/node_modules/base-x/src/index.js:111:11)
    at new PublicKey (/Users/prikshetsharma/Desktop/anchor/examples/tutorial/node_modules/@solana/web3.js/lib/index.cjs.js:1808:50)
    at main (/Users/prikshetsharma/Desktop/anchor/examples/tutorial/basic-0/client.js:16:21)
    at Object.<anonymous> (/Users/prikshetsharma/Desktop/anchor/examples/tutorial/basic-0/client.js:27:1)
    at Module._compile (internal/modules/cjs/loader.js:1085:14)
    at Object.Module._extensions..js (internal/modules/cjs/loader.js:1114:10)
    at Module.load (internal/modules/cjs/loader.js:950:32)
    at Function.Module._load (internal/modules/cjs/loader.js:790:12)
    at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:76:12)
    at internal/main/run_main_module.js:17:47
(Use `node --trace-warnings ...` to show where the warning was created)
(node:13261) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). To terminate the node process on unhandled promise rejection, use the CLI flag `--unhandled-rejections=strict` (see https://nodejs.org/api/cli.html#cli_unhandled_rejections_mode). (rejection id: 2)
(node:13261) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.
```

How to fix this?
Because I'm left with 2.9 sol from 5 sol
Is it really true that the basic-0 program costs 2.1 sol to deploy? Isn't that ethereum level cost?
that worked
So yeah the account that is used to run this is at `~/.config/solana/id.json`
Maybe try changing that to match your solana config wallet
```
[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[programs.localnet]
basic_0 = "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"

[scripts]
test = "yarn run mocha -t 1000000 tests/"
```
Lol yes a much better question.
What does your Anchor.toml wallet say?
`/Users/prikshetsharma/my-solana-wallet/my-keypair.json` looks like this is the local account that is set for you. 
Idk where anchor picks up the local config from. But I have mine setup at `~/.config/solana/id.json`
<@!519222880840450059> I did follow the steps in the anchor docs, but still getting this error
```
Config File: /Users/prikshetsharma/.config/solana/cli/config.yml
RPC URL: http://localhost:8899
WebSocket URL: ws://localhost:8900/ (computed)
Keypair Path: /Users/prikshetsharma/my-solana-wallet/my-keypair.json
Commitment: confirmed
```
Your local config seems off. Can you go through the steps given in the docs. That should fix this.
but 
```
% solana address
FP589iXyfXdJMZ7bvd8nueonu95RAgHc4syP7hZ3yzpF
```
```
% solana address -k id.json
3bKCACPSRLHMxBpKnuaTwAm77Wi4fUzAHKyxCCozv3AD
```
that explains your error I guess, Did you follow the steps given in the docs?
That gives:
```
% solana address -k id.json
Error: No default signer found, run "solana-keygen new -o id.json" to create a new one
```
`solana address -k id.json` returns the address for the key in `id.json`
But `anchor deploy` is giving error
`solana balance` is returning the correct amount after `solana airdrop x`
id.json is a bunch of numbers. It's not a string <@!519222880840450059>
Can check if `id.json` resolves to the account that is mentioned in the error message. i.e `5psUuqF3YeCGcAD6zQm5KgE5ZQ17VWkhqVN8fYiAmENP` that way you will know if airdrop works or not
Guys I have some problems with installation
Not sure how to do that off the top of my head, think you'll have to search discord
```
Config File: /Users/prikshetsharma/.config/solana/cli/config.yml
RPC URL: https://api.devnet.solana.com
WebSocket URL: wss://api.devnet.solana.com/ (computed)
Keypair Path: /Users/prikshetsharma/new-keypair.json
Commitment: confirmed
```
You'll have to set you solana cli to point to the right wallet etc.
What does `solana config get` say?
I did but still getting the same error. I don't think it's dropping in the correct address
Try `solana airdrop 5`
<@!134416332509675520> yes
Where are you deploying? To your local network?
how do I add more funds? <@!134416332509675520>
Have you tried adding more funds? "has insufficient funds for spend"
```
% anchor deploy
Deploying workspace: http://localhost:8899
Upgrade authority: /Users/prikshetsharma/.config/solana/id.json
Deploying program "basic-0"...
Program path: /Users/prikshetsharma/Desktop/anchor/examples/tutorial/basic-0/target/deploy/basic_0.so...
=====================================================================
Recover the intermediate account's ephemeral keypair file with
`solana-keygen recover` and the following 12-word seed phrase:
=====================================================================
rigid can bargain swarm donor student few moral hill dose hero define
=====================================================================
To resume a deploy, pass the recovered keypair as
the [PROGRAM_ADDRESS_SIGNER] argument to `solana deploy` or
as the [BUFFER_SIGNER] to `solana program deploy` or `solana write-buffer'.
Or to recover the account's lamports, pass it as the
[BUFFER_ACCOUNT_ADDRESS] argument to `solana program close`.
=====================================================================
Error: Account 5psUuqF3YeCGcAD6zQm5KgE5ZQ17VWkhqVN8fYiAmENP has insufficient funds for spend (1.05283224 SOL) + fee (0.00077 SOL)
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }.
```
How to fix this?
when running anchor deploy, I'm getting the following error:
I think you would use it in your crate's Cargo.toml file, where you add your dependency on anchor_lang
oh thanks! I was using to_string().as_bytes() which looks obviously stupid now 😅
How do I use the `anchor-debug` feature? Where do I need to include this?
You can do `123u64.to_be_bytes()` (or .to_le_bytes(), will need to decide on an endianness to use)
yeah, it seems good option. thank you
Got to use PDA's for that instead.
In rust, Is there any mapping variable like mapping() in solidity?
How to use a u64 as one of the seeds in the PDA? It doesn't have a to_bytes or as_ref obviously and can't use as is.. Do I need to typecast?
Check the network you are connecting to in your Anchor.toml file. I think you are looking at your local for the 500004 Sol and 2.04 Sol is on devnet
<@!326107472098099201> I believe the next big issue is the account the anchor deploy is referencing to upload is 0... however when I run solana balance it says 500004. Which means tthere are two different accounts on my computer: one anchor is referencing and one solana is refernecing
is there anyway to airdrop funds to a specific accountt if I only know the account address and not the address of the program that owns the account via cli
or more similar errors
Thanks for the help so far. The update occured and when I build the target folder now has a types folderr as a child. 

However, when I anchor deploy I gett this error

```
Recover the intermediate account's ephemeral keypair file with
`solana-keygen recover` and the following 12-word seed phrase:
========================================================================
NA: I copied it to a form
========================================================================
To resume a deploy, pass the recovered keypair as
the [PROGRAM_ADDRESS_SIGNER] argument to `solana deploy` or
as the [BUFFER_SIGNER] to `solana program deploy` or `solana write-buffer'.
Or to recover the account's lamports, pass it as the
[BUFFER_ACCOUNT_ADDRESS] argument to `solana program close`.
========================================================================
Error: Account 34UnFK2Pxpjzhc777fsNn31Y3o3ekYZzNdV6qWmTqtej has insufficient funds for spend (2.04610776 SOL) + fee (0.001475 SOL)
```
So the account says it has insufficientt funds. I  typed in solana balance and got a balance back of 50000 Sol. 

Howeverr, I ran Solana-keygen new to set up another key with funds, I ran this with anchor deploy and I come across similar problems
This command is taking some time: cargo install --git https://github.com/project-serum/anchor --tag v0.18.2 anchor-cli --locked
Thank you updating now
Meaning just rerun that command
Just reinstall from scratch
https://project-serum.github.io/anchor/getting-started/installation.html#install-rust I dont see update command
Lol, sounds like you might have some networking issues to still fix 😛
what do you mean by one problem ? 🙂ohh nvm i get it
Instructions are in the docs
what is the command
Or one problem
There's your problem, go upgrade to 0.18.2 please
anchor-cli 0.16.2
What is your `anchor --version`?
Dont see target/types

This is all I see
there isntt
Yep and there should be an escrow.ts in `target/types` and the import should work
That is what I got ^
Running: /Users/admin/.local/share/solana/install/releases/1.7.14/solana-release/bin/sdk/bpf/dependencies/bpf-tools/llvm/bin/llvm-readelf --dyn-symbols /Users/admin/Desktop/Defi/anchor-escrow/target/deploy/escrow.so

To deploy this program:
  $ solana program deploy /Users/admin/Desktop/Defi/anchor-escrow/target/deploy/escrow.so
BPF SDK: /Users/admin/.local/share/solana/install/releases/1.7.14/solana-release/bin/sdk/bpf
Running: rustup toolchain list -v
Running: cargo +bpf build --target bpfel-unknown-unknown --release
Run `anchor build` and you'll get that file
What do you mean what am I running 🙂
^ I am sorry I am not sure what that tmeans
Yeah, that's unrelated to localhost stuff
That is because the typescript hasn't been output, what are you running?
Because the import {Escrow} path doesntt exist
I think my progrram rpc is not working
How come?
OKay I thought it not being on localhost is causing this problem 

so for my tests I see this import { Escrow } from "../target/types/escrow" red bc the area patth doesnt existt 

.Can you explain what this points to?
So I took this out which means bmy program statement looks like this
  const program = anchor.workspace.AnchorEscrow


insttead of tthis

  const program = anchor.workspace.AnchorEscrow as Program<Escrow>;


Given the path doesnt exist, I thought it was bc whhere my solana testt validator was point tot
I don't think it needs to, 127.0.0.1 and localhost are almost the same thing right? https://stackoverflow.com/questions/7382602/what-is-the-difference-between-127-0-0-1-and-localhost
same thing
How do I get my JSON RPC URL to say  http://localhost:8899
127.0.0.1 is localhost though 🤔
`git checkout tags/v0.18.2`, you might need `git fetch --all --tags` first
I am trying to change it to local host
Yea so this is a local cluster... this isnt localhost
how do you mean? that is local
how do you change the solana-test-validator from  http://127.0.0.1:8899 to local
On https://project-serum.github.io/anchor/tutorials/tutorial-0.html#clone-the-repo it says "Next, checkout the tagged branch of the same version of the anchor cli you have installed."  What format do I follow for this?  It says run `git checkout tags/<version>` but my version from `anchor --version` is `anchor-cli 0.18.2`, and `git checkout tags/0.18.2` doesn't work.
So I took this out which means bmy program statement looks like this
```
  const program = anchor.workspace.AnchorEscrow
```

insttead of tthis

```
  const program = anchor.workspace.AnchorEscrow as Program<Escrow>;
```
so
```
import { Escrow } from "../target/types/escrow";
```
There is code on the top that has this in tthe escrow example. Tthe issue is tthe path doesnt exist.Can you explain what this points to?
Maybe the issue is how I am creating my program
yup
Are you doing confirmTransaction on requestAirdrop like in the escrow test?
My RPC calls are failing with error  Error: failed to send transaction: Transaction simulation failed: Attempt to debit an account but found no record of a prior credit.

```
    await program.rpc.initializeEscrow(
      new BN(initializerAmount),
      new BN(takerAmount),
      {
        accounts: {
          initializer: initializerMainAccount.publicKey,
          initializerDepositTokenAccount: initializerTokenAccountA,
          initializerReceiveTokenAccount: initializerTokenAccountB,
          escrowAccount: escrowAccount.publicKey,
          systemProgram: SystemProgram.programId,
          tokenProgram: TOKEN_PROGRAM_ID,
        },
        signers: [initializerMainAccount, escrowAccount],
      }
    );
```

However, unlike the example, I had airdrop plenty of sol to initializerMainAccount. Despite this, my rpc call fails saying the account cannot be debited.


The actual escrow account example has it as 

```
it("Initialize escrow", async () => {
    await program.rpc.initializeEscrow(
      new BN(initializerAmount),
      new BN(takerAmount),
      {
        accounts: {
          initializer: provider.wallet.publicKey,
          initializerDepositTokenAccount: initializerTokenAccountA,
          initializerReceiveTokenAccount: initializerTokenAccountB,
          escrowAccount: escrowAccount.publicKey,
          systemProgram: SystemProgram.programId,
          tokenProgram: TOKEN_PROGRAM_ID,
        },
        signers: [escrowAccount],
      }
    );

```

Any thoughhts on why I may be getting this errorr?
Will post here as well
I do have a followup question
Alright that makes so much more sense. I appreciate the assistance. Sorry for tagging you
`mintA.createAccount` creates an account on-chain and returns its pubkey
```    initializerTokenAccountA = await mintA.createAccount(
      provider.wallet.publicKey
    );
```
then `mintA.getAccountInfo` just fetches an account's data from the chain:
```    let _initializerTokenAccountA = await mintA.getAccountInfo(
      initializerTokenAccountA
    );
```
we just use `_initializerTokenAccountA` in the test to check that `createAccount` and `mintTo` worked as expected
`_initializerTokenAccountA` is a different variable
Maybe I have this backwards
hmm then I thoughht
```
    let _initializerTokenAccountA = await MintA.getAccountInfo(initializerTokenAccountA);
```

returns the pubkey from the initializerTokenAccountA account
the variable names in the escrow test are confusing
because we have 
```initializerTokenAccountA = await mintA.createAccount(
      provider.wallet.publicKey
    );```
and we can see from the IDE or from looking at the `createAccount` method that `initializerTokenAccountA ` is a public key
how can you tell, initializerTokenAccountA for instance is an accounts object.. I would need to do initializerTokenAccountA.publicKey to reference the pubkey
everything in that `accounts` object is a public key actually
it's ok
sorry
I tthought thatt was how you ask questions...
My bad I was following othhers patterns
but as for your actual question
Removed
not for general help questions no
ohh I thought you do @ tagging my abd
we don't do the @ tagging here, please delete the tag first as it sets a bad example for the children
Instruction request
```
await program.rpc.initializeEscrow(
      vault_account_bump,
      new anchor.BN(initialAmount),
      new anchor.BN(takerAmount),
      {
        accounts: {
          initializer: initializerMainAccount.publicKey,
          vaultAccount: vault_account_pda,
          mint: MintA.publicKey,
          initializerDepositTokenAccount: initializerTokenAccountA,
          initializerReceiveTokenAccount: initializerTokenAccountB,
          escrowAccount: escrowAccount.publicKey,
          systemProgram: anchor.web3.SystemProgram.programId,
          rent: anchor.web3.SYSVAR_RENT_PUBKEY,
          tokenProgram: TOKEN_PROGRAM_ID,
        },
        instructions: [
          await program.account.escrowAccount.createInstruction(escrowAccount),
        ],
        signers: [escrowAccount, initializerMainAccount],
      }
    );

```

How do you know your suppose to provide escrowAccount.publickey rather than the Account of escrowAccount for instance> 


Any tthoughhts
When looking at an IDL, how do you know if you should pass a publickey for an account or an actual account reference. For instance: 

IDL
```
"instructions": [
    {
      "name": "initializeEscrow",
      "accounts": [
        {
          "name": "initializer",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "mint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "vaultAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "initializerDepositTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "initializerReceiveTokenAccount",
          "isMut": false,
          "isSigner": false
        },
        
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rent",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
```
<@!134416332509675520> okay does that mean that solana native functionalities can be used directly in anchor?
Instead of `size_of<Vec<ty>>` I had to use `8` but all in all it seems to work out just fine
What is the difference between doing a fork on the serum-dex vs just a GUI?
Coming back to this tomorrow but is there anything in specific I need to do to compile `v1.9.0`? At the moment I just get
```
➜ solana --version
[1]    40427 killed     solana --version
```
Or are there any gotchas?
Can I use `size_of` instead, maybe? And add 8 bytes for Anchor and `size_of::<T>` in Vector multiplied by the max amount of elements?
Writing its size out manually seems like a bad solution
Good day! What would be the best way to specify `space` constraint for a huge struct with a couple of `enums` and a `Vec`
okay does that mean that solana native functionalities can be used directly in anchor?
There are docs on the Solana website about it
<@!134416332509675520> could you please tell me how an associated token account is created and what the use case looks like
So `--program-id` is being passed the correct file path for the keypair and that exists. Given that there is a difference in the Solana version I'm going to try reinstalling `v1.9.0` and see if that fixes it. I think that the problem is probably coming from the solana CLI given where the error is being thrown
``#[instruction()]``
can anyone point me to where i can find this macro?
`msg!`
In the anchor cli you can just use println! if you want
Stupid question but what's the best way to log in Rust? Trying to use `log::debug!` macro but I think the compiler is upset. I assume I need to import it somewhere?
Yep!
Grand. And that's just from the root directory of the repo?
I do `cargo install --path cli --locked --debug` (--debug since otherwise it builds a release build --> super slow)
I've only built it from source with `cargo install --git https://github.com/project-serum/anchor anchor-cli --locked
` and I've not picked up much rust yet. What do I need to do to build from a local source instead of form a remote Github url
If you're comfy installing anchor from source you could just stick in a print there and poke around
It would be nice to try adding some extra logging to the anchor cli, just to see what value it's trying to pass for `--program-id` https://github.com/project-serum/anchor/blob/master/cli/src/lib.rs#L1893
Ah I wonder if I need to bump Solana then
anchor-cli is 0.18.2 (I build from source fairly frequently), solana-cli is 1.9.0
I've got 
```blockchain/solana/myepicproject via ⬢ v16.3.0 via 🦀 v1.56.1 took 33m 52s
➜ anchor --version
anchor-cli 0.18.2

blockchain/solana/myepicproject via ⬢ v16.3.0 via 🦀 v1.56.1
➜ solana --version
solana-cli 1.8.5 (src:devbuild; feat:52865992)
```
From what I understand it's used to target a different validator. In this case I've got the solana validator running with the `--no-bpf-jit` flag.

What version of anchor and Solana have you got?
I actually don't know what it does though lol, I never use it.
Ok at any rate, using the skip-local-validator flag works fine for me
Oh sorry, did you mean the same as what you have in Anchor.toml etc—my bad
`myepicproject: FCf77eTschrz7hP9uaD21RiCHeCg2qQB7ZcBTUY8oW5L`
What does `anchor keys list` say though?
I get the name and ID as set in the `Anchor.toml` file
<@!134416332509675520> Are you running tests with the `--skip-local-validator` flag?
What happens if you run `anchor keys list`?
Huh, weird, I'm on an M1 and haven't seen that problem yet 🤔
ye, stuck on that m1 problem too
I posted on the Github but I've been having some problems when trying to run `anchor test` on an M1 Mac. Full details in the comment: https://github.com/project-serum/anchor/issues/1000#issuecomment-974870730
I’m having this error when running this command “cargo install --git https://github.com/project-serum/anchor --tag v0.18.2 anchor-cli --locked”

The error message 👇

error: failed to run custom build command for `ring v0.16.20`

Caused by:
  process didn't exit successfully: `C:\Users\HP\AppData\Local\Temp\cargo-installbwIL4P\release\build\ring-2ff300b39f35f0ff\build-script-build` (exit code: 101)
  note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
warning: build failed, waiting for other jobs to finish...
error: failed to compile `anchor-cli v0.18.2 (https://github.com/project-serum/anchor?tag=v0.18.2#1319dc65)`, intermediate artifacts can be found at `C:\Users\HP\AppData\Local\Temp\cargo-installbwIL4P`

Caused by:
 build failed


//////////////////////////////////////////////////////////////////////////////////////////

changing this worked. Thanks
that was the issue
So sounds like you might need to change that solana_fun to stake?
You might even need to rename it in the Cargo.toml file in programs/prog-name
```[programs.localnet]
solana_fun = "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"

[registry]
url = "https://anchor.projectserum.com"

[provider]
cluster = "localnet"
wallet = "/home/jjj/.config/solana/id.json"

[scripts]
test = "npx ts-mocha -p ./tsconfig.json -t 1000000 tests/*.ts"
```
Ah, have you renamed things in Anchor.toml?
I assume
which is the issue
Can post the whole test file. Contract module is actually called stake
... so what are you doing? Gotta give me some more info lol
no
Are you not doing `anchor.workspace.solana_fun` someplace?
```const provider = anchor.Provider.env()
  anchor.setProvider(provider)`` is returning {} for anchor.workspace
```
Where would I make this name replacement?
Try replacing `solana_fun` in your js/ts with `solanaFun` when you load the workspace
That error has been resolved. I am now getting ```Error: Error loading workspace IDL for solana_fun```
Thank you ser.
do `npm i -g ts-mocha` or install it locally and add `npx` prefix to the command
this is because the test is relying on you having `ts-mocha` installed globally and you probably don't
<@!495764464604413972>
The error is so vague I have no clue what to do
I created a anchor project that is able to build and deploy to a solana-test-validator. When I run anchor test I get the following error: Failed to run test: ts-mocha -p ./tsconfig.json -t 1000000 tests/*.ts: No such file or directory (os error 2)
Thank you, once again you helped me loads. 
One day I get it all figured out. 😂
Because you're invoking the system_program with that transfer call.
Yes 🙂
No i don't think I am, should i be?
is there a way to mock the on-chain block to advance time to have integration tests for cases that are time restricted?
Are you passing the system_program as an account from the client?
If the tokens are "owned" by the program (some PDA has authority over them), then you can still transfer from them in the usual way, but you'll need that authority PDA to sign the transaction (that's what `invoke_signed` is for)
but what if user is program not wallet?
ok so I am now getting this error, 
```
'Program Cq1TSA1obVQZzw2YYxvFN6Q5ia5TYxSbwyZQ9JwQCbBL failed: An account required by the instruction is missing' 
```
when the program tries to run. 
```
let ix = anchor_lang::solana_program::system_instruction::transfer(&player.key(), &base_account.key(), sb);
anchor_lang::solana_program::program::invoke(&ix, &[
                player.to_account_info(),
                base_account.to_account_info(),
              ]).unwrap();
```
Any ideas?
Yes you can use the   token::transfer to transfer the tokens ... Authority gonna be the user who is holding the token
how does a program transfer tokens to another program? can you use `token::transfer`?
what is the authority? is it the program sender's signature?
Ok cool it looks like it gets as far as this line. 
``` let transfer_amount = sb.checked_sub(account_lamports).ok_or(0)?; ```
Yeah, stuff like `msg!("Do we get here?")`
Ok so if I add print statements in the rust function will they show in the log?
So, trying to rule out that you're somehow using the wrong wallet and it doesn't have any funds, etc.
I don't see anything that would obviously give a 0x0 error, and it doesn't seem like you're getting to the system program invocation (it would show up in the log)
I'm saying it would be nice to know how far you get in this function, given that it's not clear yet what would give you that 0x0 error
Well the tests are doing a few more things before they get to this point, which all go through but fail at this function
But you consumed a decent amount of compute units, so maybe you are executing your function up to a certain point
I would have guessed that would show up in the logs you posted above
Hmm, not sure, have you tried adding extra logs? Do you get to the `transfer` call?
The user is depositing lamports to the baseAccount controlled by the program. With this function. 
```
pub fn place_bet(ctx: Context<PlaceBet>, pred: String, pool_id:u32, stake_bal:u32) -> ProgramResult {
        let base_account = &mut ctx.accounts.base_account;
        let player = &mut ctx.accounts.player;
        
        let bet = EntryStruct{
            user: player.to_account_info().key.to_string(),
            prediction: pred,
            stake_bal: stake_bal
        };
        let mut i = 0;
        let mut found = false;
        for p in &base_account.pool_list{
            if p.pool_id == pool_id {
                found = true;
                break;
            }
            i += 1;
        };
        if found{
            let sb = stake_bal as u64;
            let account_lamports = **base_account.to_account_info().lamports.borrow();
            let transfer_amount = sb.checked_sub(account_lamports).ok_or(0)?;
            let ix = anchor_lang::solana_program::system_instruction::transfer(&player.key(), &base_account.key(), transfer_amount);
            anchor_lang::solana_program::program::invoke(&ix, &[
                player.to_account_info(),
                base_account.to_account_info(),
              ]).unwrap();
            base_account.pool_list[i].pool_balance += stake_bal as u64;
            base_account.pool_list[i].entries.push(bet);
        }
        Ok(())
    }
```
What is your program doing? Not sure (in general I guess it depends on if you're doing any cross-program invocations etc.)
Looks like something else, the test wallet has Lamports, any other reason for this kind of error?
You can check this by doing `await program.provider.connection.getAccountInfo(theProviderWalletsPubkey)` and checking its lamports
Hey guys, I am getting this error. 
```
Transaction simulation failed: Error processing Instruction 0: custom program error: 0x0 
    Program Cq1TSA1obVQZzw2YYxvFN6Q5ia5TYxSbwyZQ9JwQCbBL invoke [1]
    Program log: Custom program error: 0x0
    Program Cq1TSA1obVQZzw2YYxvFN6Q5ia5TYxSbwyZQ9JwQCbBL consumed 23043 of 200000 compute units
    Program Cq1TSA1obVQZzw2YYxvFN6Q5ia5TYxSbwyZQ9JwQCbBL failed: custom program error: 0x0 
```
Could it potentially be caused by lack of funds in the test wallets created in anchor test ?
OK, thanks
`preflightCommitment` is for when simulating the tx (so you want `commitment` here)
Should I set the commitment or preflightCommitment to the `finalized` for a higher-level of tx confirmations?
Could you explain me about the `commitment` and `preflightCommitment`?
I can’t even take credit for picking up on that! But that’s good to know thanks for sharing!
Is it possible to run custom scripts as defined in the Anchor.toml? I'm trying to run something like https://github.com/project-serum/anchor/blob/master/tests/cfo/Anchor.toml#L21, but anchor build-dex/anchor build -dex both give me "subcommand not recognized"
You can specify confirmation level like this: 

`await provider.send(transaction, [signer], {
    commitment: "finalized",
  });`

Sources:
https://github.com/project-serum/anchor/blob/master/ts/src/provider.ts#L91
and
https://docs.solana.com/developing/clients/jsonrpc-api#configuring-state-commitment
I'm actually not totally sure (I'm a bit fuzzy on when you need to wait for more confirmation)
`await provider!.send(transaction)`
It's not right to wait for a higher level of tx confirmation?
But I'll use `u64` instead, right
Well, I can, it is just that I prefer `from`casts instead of `as`, and those aren't implemented for `usize`
Mm, not sure actually—can you just pick an actual fixed size, like a u64?
```
            "type": {
              "defined": "usize"
            }

```
Good day! Sorry for pestering with more questions, but do I understand correctly that `usize` is not implemented for idl? 
Is is because it is platform dependent?
Hello. Maybe you need to wait for a higher level of tx confirmation?
Yep, those work too—for whatever reason there's a whole separate trait in Rust, FromStr, specifically for string conversions 🤷‍♂️ but you can also do `Pubkey::try_from("asdfasd")`
Hi <@!134416332509675520> 

#1. await staking or unstaking
#2. then fetching the balance online.

#2 should return new balance after a staking/unstaking but sometimes, it returns the old balance on the app
<@!134416332509675520>, could you comment on that and tell me if I'm wrong please ?
or implement the `TryFrom<x>` (x being &str) in your case, so you could do `address = "asd".try_into().unwrap()` or just even `Pubkey::try_from("asd").unwrap()`
It's actually not even your fault, in idiomatic Rust, any "fallible" conversion should be named "try_from_x" to induce it returns a Result, otherwise if it is named "from_x" you _should_ be able to assume it cannot fail
Hey guys in JS test how to airdrop funds to a test account?
I second you and would love to start seeing more and contributing more open source work. In order for anything to claim decentralization, it must be open sourced. Lots of FUD and “moating” going on at the moment during quick cash grab stage of the network
Still learning rust. Makes sense!
The address needs to be an actual Pubkey. Doing `Pubkey::from_str("asdfasd")` doesn't quite return a Pubkey, it returns a Result<Pubkey, some kind of error>. You'd need to do `Pubkey::from_str("....").unwrap()`
Okay, thanks a lot mate!
- programs are upgradeable unless specifically set to non-upgradeable
- not many programs are open source
- similarly not many are actively verified
you've pretty much got all the major key points
<https://project-serum.github.io/anchor/getting-started/verification.html#images>
Sure sure, I'm not part of the "Solana is owned and governed by Anatoly blahblah" type, I'm just wondering about what is possible atm and how to think my programs, nothing else
we can only lead by example
if the public wanted it, it would happen
the issue with lack of open source code is known in solana, but it's a community issue not an issue for the "ceo of solana" to deal with
it's possible to disable upgradability
I mean, just the ability to upgrade is nice, but it introduces issues
in anchor, we push people to use anchor verifiable builds
it's a community decision
again, it's the same thing
Sure, but this is a different project, Solana might decide not to follow this path, which is why I'm asking 😉
until people kept getting rugged on ethereum, program builds were equally opaque and unverified
do you know the history of EVM?
Bruh... Do you think it will reach a stage where we can interact with programs with the same transparency and level of confidence as with the EVM ?
yes, of course
it says it expects `value` not `Pubkey` so i guess you could try to figure out how to convert pubkey to value?
Hi!
Since Solana Programs are upgradable and, at the time, rarely have verified builds, isn't the idea of "trustless" a bit biased ? Like, the owner of the program could make a change and do things with an account it owns on your behalf (e.g. a PDA), right?
Ok. Thanks anyway.
not sure how to solve your other problem, but that's what's causing the `resolver` issue
yeh, that's way out of date
solana-cli 1.7.1 
If the older version is an issue then It appears I'm in deadlock. I installed v1.7.1 to avoid another issue : "avx2 not supported by cpu"
how to print logs in anchor ?
yeh, <https://discord.com/channels/428295358100013066/517163444747894795/905125717807865976> your solana cli tools are out of date
errors from both trries
also it helps if you can post the code itself rather than a screenshot
what solana CLI version are you running?
i think resolver might be one of these weird errors from running an older version of solana
Just a syntax question now. I've tried a few combinations and can't get rust-analyzer to stop complainging

```rs

    #[account(mut, address = Pubkey.from_str("asd"))]
    pub slab_treasury: AccountInfo<'info>,
```

I've tried that and just putting the plain string and both complain. Any thouhgts?
hold on
actually
I see that. But not sure how to edit that .toml file.
Nice! I also built anchor from source but it did not solve the problem for me.
i would also try googling the error
I also don't get the correct `idl` json file. This file is generated during `anchor build` , which runs without throwing an error
the error message would suggest you need resolver
ah, i realised what i was doing wrong here. I forgot to include the mint and token constraint tokens e.g. `mint::` and `token::`
I'm trying to run $anchor test the very first time. Any ideas why I might be seeing this error?
still rusty with anchor, haven't coded in a while
```#[instruction(seed: u64)]``` forgot to remove this
LOL
oh shit
```anchor-lang = "0.18.2"
anchor-spl = "0.18.2"
```
```anchor-cli 0.18.2
```
```        "@project-serum/anchor": "^0.18.2"```
you could try changing things as part of your debugging to figure out what might be the root of the error, your program looks simple enough. That's why it looks like it might be a version error
still same error
it's not clear why `mut` would cause a serialization error
oh, might be the mut
and that it doesn't fit the expected format
this suggest something is wrong with the transaction bytes that are being passed into your program
your error is about not being able to deserialize instructions
no, if your program.provider.wallet is the signer that will be included
I didn't have to do that before, maybe it got updated ?
should I also add it to signers : [] ?
I have the user as signer
0.18.2
I'm using similar version
I see
maybe you have different version of anchor in the client vs. the program
I don't have any code inside the instruction
oh, it could also be a version thing
you could try printing out your transaction bytes, to see if anything weird is happening inside the instructions
```pub struct CreatePool<'info> {
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
    pub clock: Sysvar<'info, Clock>,
}```
```ts
const tx = await program.rpc.createPool({
      accounts: {
        user: program.provider.wallet.publicKey,
        systemProgram : anchor.web3.SystemProgram.programId,
        clock : anchor.web3.SYSVAR_CLOCK_PUBKEY,
      },
    });
    console.log("Your transaction signature", tx);```
any reason why this might happen ?
```The program could not deserialize the given instruction```
maybe there's something wrong with the local version of anchor I'm using
ran into a weird error with trying to init a token account
```rust
no function or associated item named `default` found for struct `TokenAccount` in the current scope
function or associated item not found in `TokenAccount`
```
Hi, I need to ensure that data in account A on a program X is greater than 0, to be able to call function B in my program Y.
So I have done it this way. I have stored program X pubkey in my main program account at initialize (so that it can be updated if needed later)
Now I have set conditions on the account in my function B context as below. I have also defined the full struct of Account A in my Program Y for serializing data.
#[account(seeds = [user_authority.key().as_ref(),main_account.x_program_name.as_ref().trim_ascii_whitespace(),b"x_generate",],
        bump = x_bump,
        owner = main_account.x_program
    )]
    pub a_account: Box<Account<'info, AAccount>>,

However, this fails with the message "The given account is not owned by the executing program". I was not modifying any data here, just reading it. What is the correct way to do it?
PDA with hardcoded seeds: https://github.com/drift-labs/protocol-v1/blob/master/programs/clearing_house/src/context.rs#L23
<@!812755783405797376> what can i use as an alternative to the programstate implemenation for creating a singleton?
I solved this issue today by rebuilding anchor from source.
i'll give that a bash 🕵️
This is exactly what I needed thank you Alan
What do you mean by include it in the rust program?
You can enforce a known address with the `address = ` constraint.
Is there an anchor macro for “make sure the account passed in is equal to some given account”?
Or is there maybe a less donkey brained idea to do this. I’m trying to build a program with a treasury wallet and don’t want that to change, but don’t know if I can just include it in the rust program.
So if you actually want to initialize it within that function, you'd have to declare it as `pub puppet: AccountInfo<'info>` (or even `Signer<'info>` because it will need to sign from the client in this case, given that it seems to be a keypair address)
I think the problem is that `pub puppet: Account<'info, Data>` says this puppet account needs to look like a `Data` *before* you start executing your pull_strings function.
hey there 👋 I've been playing around with the basic-3 tutorial trying to get the `puppet_master` to do the `initialize` call via cpi rather than making a seperate call to the `puppet` to initialize first. I run into this issue: ` Error: 167: The given account is not owned by the executing program`.

My code is here, is there something else I am missing: https://github.com/project-serum/anchor/compare/master...obi-ewan:make-master-do-init?expand=1

Would I have to do some pda-ness here to the `Data` account to allow it to be created by another program?
```#[derive(Accounts)]
#[instruction(bump: u8, bump1:u8)]
pub struct Vault<'info> {
    #[account(signer)]
    pub authority: AccountInfo<'info>,
    #[account(init_if_needed,payer = authority,seeds = [authority.key().as_ref(), mint.key().as_ref(), "vault".as_bytes()],bump = bump,token::mint = mint,token::authority = vault_account_data)]
    pub vault_account: Account<'info, TokenAccount>,
    #[account(  
        init_if_needed,
        payer = authority,
        seeds = [authority.key().as_ref(), mint.key().as_ref(), "vault_metadata".as_bytes()],
        bump = bump1,
        space = 8+ std::mem::size_of::<VaultMetadataAccount>()
    )]
    pub vault_account_data: Account<'info, VaultMetadataAccount>,
    #[account(mut)]
    pub mint: Account<'info, Mint>,
    #[account(mut,  constraint = token.amount == 1, constraint = token.owner == authority.key())]
    pub token: Account<'info, TokenAccount>,
    pub token_program: Program<'info, Token>,
    pub system_program: Program<'info, System>,
    pub rent: Sysvar<'info, Rent>
}```
I think I got the issue .... checking something ...
What does the `#[derive(Accounts)]` struct look like?
```
I think I'm passing it correctly in JS

await program.rpc.addVault(
      new anchor.BN(vaultAccountBump),
      new anchor.BN(vaultMetadataAccountBump),
      {
        accounts: {
          authority: provider.wallet.publicKey,
          vaultAccount: vaultAccount,
          vaultAccountData: vaultAccountData,
          mint: mint,
          token: token,
          tokenProgram: TOKEN_PROGRAM_ID,
          systemProgram: anchor.web3.SystemProgram.programId,
          rent: anchor.web3.SYSVAR_RENT_PUBKEY,
        },
      }
    );```
In the JS script.
In rust or test JS script ?
You're (I think) passing a Foo account someplace where you declared a `Account<'info, Bar>`
can't seem to understand meaning of this ? How to make sure its setted correctly
Anchor checks the first 8 bytes of account data (for accounts owned by your program, that is—not for random other accounts like token accounts etc.) and makes sure they make sense.
That means you're passing some wrong kinds of accounts somewhere. Do you understand what the error means, in terms of the discriminator stuff?
Thanks Alan !!! that worked but getting a fixed error -   Error: Invalid account discriminator for each method call but the instructions are executing fine
Its owned by another PDA ... will try to sign from that PDA seeds
I don't know who owns your PDAs tokens in this case, but they will need to sign somehow.
That's the point of signing there—the "owner" of the tokens needs to sign whenever they want to transfer them
Yes.
so the signer seeds will be whoever has the authority over that token ?
The token account itself doesn't need to sign when it transfers, its authority/owner does.
So just gotta think through why those seeds + bump aren't correct (they need to match the *authority* over the token account, not the token account itself necessarily)
This is PDA account means seeds are not right ?
So however you're signing isn't quite right, but I can't tell from here
Ah, sorry, ignore that, the error message tells you the problem: 3qGuE8k7F8Ueo4GwSPrRqry11BmpRMYzxws9hvx1v9nV's didn't sign correctly
Ok, and are all of the accounts that need to be mutable actually mutable?
yes
 ```&[&[
                    ctx.accounts.user.key().as_ref(),
                    ctx.accounts.vault_account_data.user_mint_account.key().as_ref(),
                    "token".as_bytes(), 
                    &[ctx.accounts.vault_account_data.bump]
                 ]]```
Are you signing with the PDAs seeds + bump?
Getting this error while transferring token from PDA to user token account 
```Cross-program invocation with unauthorized signer or writable account

Logs :  ["3qGuE8k7F8Ueo4GwSPrRqry11BmpRMYzxws9hvx1v9nV's signer privilege escalated",
    'Program FfNTAJ4wWv6idUUDWcswEXGFr4N2tw8ZHHjfsxAtdJ5 consumed 200000 of 200000 compute units',
    'Program FfNTAJ4wWv6idUUDWcswEXGFr4N2tw8ZHHjfsxAtdJ5 failed: Cross-program invocation with unauthorized signer or writable account']

trying to transfer token from vault to user account ```
thanks
`.fetch`
How to read data sitting inside PDA in JS ?
I also dont get the correct `idl` json file, I dont see a `metadata.address` field. Im assuming its because of the error 🤔 ?
If I want to store data on PDA and same time use that PDA to get the transferred token from user do I have to add that PDA account two times in my initialize struct or create two seperate PDAs one which store data and other which store token and link both by having authority of 2nd over 1st (2nd option makes sense to me ... just wanna confirm things) ?  One with TokenAccount and another with my data struct ?
```let cpi_accounts = Transfer {
            from: ctx.accounts.tokenAccountA.to_account_info(),
            to: ctx.accounts.vault_account.to_account_info(),
            authority: ctx.accounts.authority.to_account_info(),
        };

        let cpi_program = ctx.accounts.token_program.to_account_info();
        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
        token::transfer(cpi_ctx, 1)?;
        Ok(())```

Trying to transfer SPL token (NFT) from a token account of user to a vault account getting error - Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA failed: invalid account data for instruction

here tokenAccountA -> token account of token owned by user
         authority -  User (signer) who holds the authority over token
         vault_account - PDA of program which is trying to hold the token

```#[account(
        init_if_needed,
        payer = authority,
        space = 300,
        seeds = [authority.key().as_ref(),"token".as_bytes()],
        bump = bump
    )]
    pub vault_account: Box<Account<'info, VaultAccount>>```
Unless there is another setting some where I'm missing
```[provider]
cluster = "devnet"```
Ah, the cluster? Forgot that but it still doesn't work
```anchor deploy
Deploying workspace: https://api.devnet.solana.com
Upgrade authority: /root/.config/solana/id.json
Deploying program "theopetraapp"...
Program path: /workspace/backend/target/deploy/theopetraapp.so...
error: Invalid value for '--program-id <PROGRAM_ID>': unrecognized signer source
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }.```
`Deploying workspace: http://localhost:8899` makes it look like its not
Is it set to devnet in Anchor.toml?
Local works
devnet
Are you trying a devnet deploy or local validator?
It was, it’s just the fix didn’t help
Nope looks like cargo wasn't lying about the version
```anchor deploy
Deploying workspace: http://localhost:8899
Upgrade authority: /root/.config/solana/id.json
Deploying program "theopetraapp"...
Program path: /workspace/backend/target/deploy/theopetraapp.so...
error: Invalid value for '--program-id <PROGRAM_ID>': unrecognized signer source
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }.```
```Replaced package `anchor-cli v0.18.2 (https://github.com/project-serum/anchor#92c6d4c3)` with `anchor-cli v0.18.2 (https://github.com/project-serum/anchor#92c6d4c3)` (executable `anchor`)```
That is a very misleading message if this fixes it. Sure reads like that commit is installed
Ok I'll try forcring it
It prints the hash which is a bit confusing
Yes, it reads the latest master and looks at the commit and the version an decides it has nothing to do because the version matches
That hash matches the last commit
`Ignored package anchor-cli v0.18.2 (https://github.com/project-serum/anchor#92c6d4c3) is already installed`
the version hasn't been bumped in the repo so it won't actually install anything without the `--force`
add a `--force` to the cargo install command
```anchor deploy
Deploying workspace: http://localhost:8899
Upgrade authority: /root/.config/solana/id.json
Deploying program "theopetraapp"...
Program path: /workspace/backend/target/deploy/theopetraapp.so...
error: Invalid value for '--program-id <PROGRAM_ID>': unrecognized signer source
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }.```
```Config File: /root/.config/solana/cli/config.yml
RPC URL: https://api.devnet.solana.com 
WebSocket URL: wss://api.devnet.solana.com/ (computed)
Keypair Path: /root/.config/solana/id.json 
Commitment: confirmed
```
```cargo install --git https://github.com/project-serum/anchor anchor-cli --locked
    Updating git repository `https://github.com/project-serum/anchor`
     Ignored package `anchor-cli v0.18.2 (https://github.com/project-serum/anchor#92c6d4c3)` is already installed```
No the version commit matches
Maybe that wasn't master, trying again
oh bummer... did you comment there about it not working?  <@!501570363566587905>  seems to believe that the PR fixes it, hence why he closed it
<@!725800026760020099>
```cargo install --git https://github.com/project-serum/anchor anchor-cli --locked```
Yes, and it didn't fix it.
Hopefully this will fix it: https://github.com/project-serum/anchor/pull/1046

Anyone know how to try anchor on master???
I was able to deploy using `anchor deploy --program-name <program_id>` as <@!269047172509597697> mentioned above, but I have been unable to get `anchor test` to run without generating the 'unrecognized signer source' error
I'm also experiencing this issue. How can I make sure that solana-test-validator and cluster are devnet?
Both anchor deploy and test give that signer source error.
I've been able to deploy it directly with ```solana program deploy```
Been having the same issue while doing the buildspace project  for solana. Everything worked fine with the placeholder ID.
my cluster is "devnet", i got my id by using  `solana address -k target/deploy/myepicproject-keypair.json` and then copied this into `Anchor.toml` and `lib.rs`
Are you certain that the programId provided is valid and you didnt copy an incorrect one. Are you certain that your solana-test-validator is pointing to devnet? Are you also positive cluster is devnet too?
I am getting a `error: Invalid value for '--program-id <PROGRAM_ID>': unrecognized signer source` when I am using `anchor deploy` or `anchor test`. 

This has come after trying to deploy to devnet and trying to upgrade my program ID in the `Anchor.toml` and `lib.rs`. I can get it to deploy with the solana cli commands, but was wondering if anyone has run into this?
solana changes airdrop params all the time, so im not sure. You usually need to create a wallet and seed it money but if it already has money then great
I'm working through https://dev.to/dabit3/the-complete-guide-to-full-stack-solana-development-with-react-anchor-rust-and-phantom-3291 and there's a part where it tells you to airdrop tokens, `solana airdrop 100`.  But my account already had 500 million SOL.  Any idea why?  On localnet
no, https://buildspace.so/
is buildspace an IDE you are using?
`anchor-cli 0.18.2`
I guess so, installed everything yesterday
Lol
a real coder
<:pepekek:827565146221707308>
are you using latest cli and js lib?
Not sure (tbh I don't really look at the docs ever, I just read the source)
yes, both in lib and toml
did you update the `declare_id` macro
no idea whats the issue
no, test also stopped working. getting the same error
thank you! i see there is some documentation nested in source https://github.com/project-serum/anchor/blob/master/lang/derive/accounts/src/lib.rs#L43 do you know if theres anything like this for the `derive` macro?
Did you find a solution to this? I am running into the same issue when I am running `anchor test`
Not sure about documentation (kind of doubt it, but maybe). I would just give it a shot and see!
if I change Loader to Account, are there additional `derive` traits i need to implement? 
is there any documentation on these two?
Loader is ordinarily for big (huge) accounts. You'd generally use `Account<'info, State>` for normal uses
if i try using the `zero` annotation i get an error around the payer
is `Loader` only used if i have previously allocated account? misunderstanding on my part of how `Loader` works
So ordinarily if you're initializing a Loader account you'd use the `zero` annotation and then fill in the discriminator bytes when you do `.load_init()` in your ix handler
Loader usually expects you to allocate storage for the account in a separate instruction
And just to double check, why are you doing the `Loader` part?
```#[account(
        init_if_needed, 
        seeds = [b"fstate1".as_ref()], 
        bump = bump, 
        payer = admin_account
    )]
    pub state_account: Loader<'info, State>,```
i think the problem was i had a validator running manually so on each run of `anchor test` the ledger was not being cleared
Can you post the full `#[account(...)]` annotation?
and if i reset to `init` only i get an error around the account address `already in use`
No, but it is close
hey im using `init_if_needed` on an account but an `The account discriminator was already set on this account` error is being thrown
I guess it is this issue
https://github.com/project-serum/anchor/issues/22
But generally you need to be careful about overflow—usually you'd want to use the `checked` family of functions, the *do* check for overflow
And a huge stack trace
I had a few contracts implementing similar logic, so I split it into a new crate. To my dismay things stop work with
```
IdlError: Type not found: {"name":"veccy","type":{"defined":"Decimal"}}
```
Aren't overflow checks already turned off? 🤔
Henlo! Is it possible to use types, implementing `AnchorSerialize` and `AnchorDeserialize` from different crates?
hello, I am doing the Solana project on buildspace and I am at the point where I need to deploy using `anchor deploy`. WHen I do this it gives me the following error
```
error: Invalid value for '--program-id <PROGRAM_ID>': unrecognized signer source
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.
```
I actually needed to run `anchor deploy --program-name <program_id>` even tho the error says `program-id`
Thanks alan
The PDAness of the address doesn't really change anything about closing the account, you still just need to drain its lamports. And yes, the data will get cleared.
You mean within your rust program? Not possible, you'll need to pass it as an account from the client.
One more noob q -> can we close a PDA account ? will it erase old data right if we close it ?
How to read data of some other PDA which is not in current program ?
ah obviously im missing a declaration of the lifetime param, i.e. `pub struct InitialiseContract<'info> {`
any ideas?
hitting a weird error `error[E0261]: use of undeclared lifetime name 'info`


//////////////////////////////////////////////////////////////////////////////////////////

Mm, not sure, works for me!
still compiler throwing this error :

no function or associated item named `try_from_unchecked` found for struct `anchor_lang::Program<'_, _>` in the current scope function or associated item not found in `anchor_lang::Program<'_, _>`
ohoo...
`associated_token_program: Program<'info, AssociatedToken>`
So the `user_ata: Account<'info, TokenAccount>` (edit: sorry, typo again 🤦‍♂️)
Sorry, you need to name it literally `associated_token_program` (my bad, I typo'd above)
using this but still getting the error 
```
no function or associated item named `try_from_unchecked` found for struct `anchor_lang::Program<'_, _>` in the current scope
function or associated item not found in `anchor_lang::Program<'_, _>```
```#[account(
        init_if_needed,
        associated_token::mint = mint,
        associated_token::authority = authority,
        payer = authority
    )]
    pub user_ata: Program<'info, AssociatedToken>```
That means you need to be passing the associated_token_program as an account, `associated_token_program: Program<'info, AssociatedToken>` (edit: sorry, typo!)
Not able to compile the code  getting error :

Cannot find value `associated_token_program` in this scope  on #[derive(Accounts)]
Currently no easy way to get rid of that log, as far as I know. Just have to live with it (or make a PR!)
assert.rejects to check the errors and it's passing
But transaction simulation failed error log is there
im actually editing the metaplex candymachine programs themselves -- trying to make a custom NFT but that still adheres to the metaplex standard
It will be quite hard to read at first but it's all there.
Yep.
so i could use cargo expand to see what anchor is abstracting over ?
You can also use `cargo expand` to expand the macros that anchor uses, and get a sense for what kind of code it generates (that's what I did)
i wanted to understand solana fundamentals and understand what anchor abstracts over before starting with anchor
I think your best bet is to work through anchor examples / just start experimenting.
You generally do something like `Pubkey::create_program_address(&[ b"one seed".as_ref(), b"some_other_seed".as_ref(), a_pubkey.as_ref(), &[the_bump] ], some_program_id)`
trying to understand solana fundamentals , just read the docs and still have a lot of questions...
on this
hmm is there any good resource i could take a look at to get more indepth knowledge
Or sort of—it gets appended to the list of other seeds.
off chain and this result is what u pass in as seed to create_program_address
Yeah.
oh mb, but the bump gets appended to the seed right ?
For example, about half of all bumps end up being 255. This isn't a valid utf-8 character—it only makes sense as a byte.
Sort of/no.  Have you looked at examples of using `Pubkey::create_program_address`? The seeds aren't just strings (mentioned a few times above), they're in general a bunch of bytes (not the same thing as a string slice!).
?
does this mean we append the bump seed to the seed for example add  a character to a string "escrow" and pass the resulting "escrowa" as seed to the create_program_address
hey <@!248066053161222144>  "To reduce the compute cost, use find_program_address off-chain and pass the resulting bump seed to the program."
You can also turn off transaction simulation. But that will still result in an error
If you don't want to see them you can turn off your monitor
What's wrong with error logs
I don't understand the question
Hi <@!248066053161222144> 
Could you explain me about it?
poor alan lol
Hi <@!134416332509675520>
`anchor test` - it logs the transaction error 
Is there any way to not show the error logs?
so it needs to be wrapped in an extra array
this is just because there could be multiple `seeds` being passed
then your signer that gets passed into CpiContext is 
```
let signer = &[seeds[..]]
```
`bump: u8 = 255`
so your seeds really look like
```
seeds = [b"escrow2".as_ref(), &[bump]]
```
even if it's the default u8 value (which for seeds is 255)
aha
in practice it's always added
technically speaking the bump is just a single u8 that gets added to the end of the seed array
to find a valid program address
when the seed is not enough a bump is required
yes
do you know about the bump?
e.g.
```
        seeds = [PC_VAULT_SEED, event_list.name.as_ref(), market.name.as_ref(), &[bracket.idx]],```
thanks got it
and those are your seeds
`&[ &[u8] ]`
you have an ref array of ref u8 arrays
that's basically it
carry on
aha alright
like pubkey for example
it's better to think in terms of u8s because you can have other things in your seeds that are not string slices
i mean array of u8's...
u8s are bytes
but u8's are string slices
you need to think of seeds in terms of u8s
no
right ?
so it becomes &[&str]
yeh it's `&[ &[u8; 7] ]`
" seeds: &[&[u8]]"
and a signer is an array of seeds (in case there's more than one PDA signing)
lets just call "escrow2" a &str so its verbose
seeds are just an array of referenced u8s
but i can keep helping
😦
😛
hahahahaha
lol, maybe this actually a <#889584618372734977> thing after all sorry
an array of string slice will be &[&[u8]]
yeh
cause a string slice is &[u8]
nvm it would be &&[u8]]
something like that
and then the second `&[   ]` which wraps is just an array of seeds
&["escrow2"] is basically &[u8]
so lets break it down
yeh, i think so
so a string slice is an array of u8's right ?
&[&["escrow2"]]
this was the code
or a reference to them
it's an array of u8s
so `&[b"escrow2".as_ref()]` is the seed
just learned rust so just a beginner
seems weird
yes i just wanted to understand the syntax
this looks like a seed signer to me
`"&[&["escrow2"]]"`
Ahh okay, thanks!
your `testAccount` is already a public key so just do 
```
    const account = await program.account.testAccount.fetch(
      testAccount
    );
```
Hey guys, I had a doubt as I was learning.

I was trying to fetch the data from an account, using this piece of code: 
```
const deposit = await program.rpc.deposit(new anchor.BN(69), {
      accounts: {
        testAccount: testAccount,
      },
    });

    console.log("Deposit tx: ", deposit);

    const account = await program.account.testAccount.fetch(
      testAccount.publicKey
    );
    console.log("Balance: ", account.balance.toString());
```

But it was giving this error, 

```
1) anchorlearn
       Is initialized!:
     TypeError: Cannot read property 'toBase58' of undefined
      at Connection.getAccountInfo (node_modules/@solana/web3.js/lib/index.cjs.js:5459:71)
      at processTicksAndRejections (internal/process/task_queues.js:95:5)
      at async AccountClient.fetchNullable (node_modules/@project-serum/anchor/dist/cjs/program/namespace/account.js:87:29)
      at async AccountClient.fetch (node_modules/@project-serum/anchor/dist/cjs/program/namespace/account.js:104:22)
      at async Context.<anonymous> (tests/anchorlearn.js:36:21)
```

-----------

Whereas, if I used this piece of code, my tests run successfully
```
const deposit = await program.rpc.deposit(new anchor.BN(69), {
      accounts: {
        testAccount: testAccount,
      },
    });

    console.log("Deposit tx: ", deposit);

    const account = await program.account.testAccount.fetch(
      testAccount.toString() // CHANGED, and works with testAccount.toBase58() also
    );
    console.log("Balance: ", account.balance.toString());
```

----------

I've seen tutorials where they used the first piece of code and got it to work. So I was wondering why is it not the case here?
it was implemented by someone random
it's supposed to be
I was going to say, would have been pretty surprising if this bug hadn't surfaced earlier
Oh interesting! So preInstructions isn't just like an alias for `instructions`?
yeh, i tried switching back to `instructions` and everything worked fine
hmm, alternatively maybe `preInstructions` is incorrect
but this seems like a poor workaround
gets rid of the error
well, changing to
```rust
    #[account(mut)]
    pub event_queue: Signer<'info>,
```
but it seems like others had this issue and they solved it somehow
ok, i'll make a github issue
Oh, interesting—that sounds like a bug in anchor I guess? 🤔
have to figure out how though lol
there's probably some way to specify signers for just the preinstructions and not the whole transaction?
i think i know what i could probably do differently
ah
```rust
   #[account(mut)]
    pub event_queue: UncheckedAccount<'info>,
```
```typescript
        await program.rpc.initBracketStepTwo(serumBumps, {
            accounts: {
                eventListAuthority: program.provider.wallet.publicKey,
                eventList,
                market,
                bracket,
                yesMint,
                fUsdcMint,
                serumMarket,
                requestQueue,
                coinVault,
                pcVault,
                vaultSigner,
                eventQueue: eventQueueKeypair.publicKey,
                bids: bidsKeypair.publicKey,
                asks: asksKeypair.publicKey,
                systemProgram: anchor.web3.SystemProgram.programId,
                tokenProgram: TOKEN_PROGRAM_ID,
                dexProgram: DEX_PID,
                rent: anchor.web3.SYSVAR_RENT_PUBKEY,
            },
            preInstructions: [
                anchor.web3.SystemProgram.createAccount({
                    fromPubkey: provider.wallet.publicKey,
                    newAccountPubkey: eventQueueKeypair.publicKey,
                    lamports: await program.provider.connection.getMinimumBalanceForRentExemption(262144 + 12),
                    space: 262144 + 12,
                    programId: DEX_PID,
                }),
            ],
            signers: [
                eventQueueKeypair,
            ],
        });
```
but because we're creating the account in the same transaction with a separate instructions, of course it needs to be a signer
the issue seems to be that the program doesn't expect X account to be a signer
it's almost too much effort to share so much code
do you mind sharing the code or is it private?
i solved it with <@!134416332509675520> that time. don't remember why it happened back then since it was a while ago but i've had it since then as well and the error was always a fault in my own code
Looking at all the past discussion about the error `Error: unknown signer: `
i've started getting this error too. It's quite odd
Hi <@!134416332509675520> 
How can I build a `view function` like the solidity smart contract?
It says: "custom program error: 0xa7'". Couldn't find anything on google
In my case will need all the lamports in the account later, so I can't play much with it
<@!637707515328725002> with your strategy (if it's acceptable) it's inefficient to leave the unnecessary lamports in the account - you could transfer them out and use them to earn rewards (eg. staking or something), keeping enough in a program-owned account to cover any upcoming doubling fees. Basically it gives you an interest free loan, you should use it 😄
and also how to query all the posts
Would still have to see how much running post() costs
That's not bad at all
I think new account per post is good. That would be 128 lamport/year per post right?
Ok. What have you tried so far for debugging?

In solana, whenever you create an account, you always have to sign with that new account's address (no matter what)
You need to also add a `signers: [postAccount]` to that rpc call
still get "Translating error Error: Signature verification failed" with user: program.provider.wallet.publicKey
I see what you mean - they are always paying twice as much as they really need to, so that when doubling happens they have already paid for it. It's clever, and if that's acceptable then great 🙂 - depends what you want to optimise for though. Maybe they would prefer to pay a small amount every now and then, but overall cheaper?
Lol
I would be kind of amazed if that worked, but maybe?
nvmd it doesn't work
Like, you ran a test and it actually passed?
It didn't give an error so I presumed that it worked
That actually works?
<@!134416332509675520> I just did user: anchor.Provider.local()
how do we remember all the posts?
Probably `user: program.provider.wallet.publicKey`
This is my program:
```
#[program]
pub mod mibexy {
    use super::*;

    pub fn post(ctx: Context<Initialize>, data: String) -> ProgramResult {
        let post_account = &mut ctx.accounts.post_account; 
        post_account.post = data;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 128)]
    pub post_account: Account<'info, Post>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program <'info, System>,
}

#[account]
pub struct Post {
    pub post: String
}
```
The doubling strategy in standard libraries is designed to minimise the number of times you will need to reallocate memory, given that you have no idea how the array will be used by the program. In this case, minimising the number of account reallocations is probably not the best choice of what to optimise for
No, this works for all resize. Imagine, initial capacity is for two posts, when that's filled you already have 2 * 2 * sizeofpost lamports, which is sufficient to create 4 capacity account. Once that 4 capacity gets full, you will have 2 * 4 * sizeofpost lamports, which is sufficient to create a 8 capacity account; and so on. You cannot forget to close the older accounts, obviously.
I do have: anchor.setProvider(anchor.Provider.local());
quick question. I'm making this call:
```
await program.rpc.post("Hello World!", {
        accounts: {
            postAccount: postAccount.publicKey,
            user: ???,
            systemProgram: SystemProgram.programId
        }
    });
```
What do I put for user?
My point is that only pays for the first doubling - at the second one they would have to pay twice as much, next time 4x as much, etc. so it would be better to have a fixed size-increase each time you need more data.
That cost I defined is exactly so that they all pay the same when adding a post. Does not matter whether the accounts is going to be resized or not, the cost is fixed. That's why each pay 2*size_of_post() instead of just size_of_post()
That is presumably way more economical, yes. You'll still presumably have to have some way to remember which accounts store your user's posts though
each account is a single post that stores the ipfs
this way we don't need to double
```

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 128)]
    pub posts_account: Account<'info, Post>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program <'info, System>,
}

#[account]
pub struct Post {
    pub post: String
}
```
The doubling strategy is fairly common and sensible for re-sizing arrays in many standard libraries - since you don't know the intended usage. In this case I think doubling isn't a great strategy because eventually they will have to pay a large amount to increase their data size. It should probably increase by a fixed/acceptable amount instead.
Each person should pay cost(128 + 8 + 4 + 2 * size_of_each_post()). With this you will have enough lamports to double the account size when necessary. (128 for account metadata, 8 for anchor discriminator, 4 for vec length). With this, you will actually have more than enough to handle accounts. If you can pay the 128 + 8 + 4 yourself, then the cost could be just cost(2 * size_of_each_post())
Would that still be cost prohibitive?
which stores the ipfs?
what if I do it so that each post is one tiny account of 128 bytes?
Yep.
How do I set it up so that the signer is the one that pays for the account? Like this?:
```
#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 9000)]
    pub posts_account: Account<'info, Posts>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program <'info, System>,
}

#[account]
pub struct Posts {
    pub posts: Vec<String>
}
```
Poor people need to deal with nightmares
I can confirm this. But possible
Thanks
I see 🙂
Because e.g. when you do something with your phantom wallet, the simulation runs before you approve the tx—yet you don't pay anything, obviously, if you cancel doing the tx.
No, as far as I know (like 99% sure) no simulations ever take a transaction fee
Its simulate takes the transaction fee?
the instruction doesn't update the data, just read and emit the event
What about it?
Don't think so, no.
program.simulate doesn't take the transaction fee, right?
Yeah lol, this will be a nightmare 😛
Yeah you could have them pay something to initially create the account with a smallish amount of data, then every now and then, as they post more things, they would have to pay some more to increase the allocated size (copying the data into a new bigger account as <@!637707515328725002> mentioned)... then eventually chaining multiple accounts together once it goes over the 10MB limit. All sounds theoretically possible, but hugely impractical to me.
You could have the poster be the one that pays for the account's rent, yeah
Not exactly like that - their account is owned by the system program, so you can't store data there. You can only modify accounts owned by you (your program). Have you read the programming model: <https://docs.solana.com/developing/programming-model/overview> ? In particular relation to this is the Accounts section and the Runtime section, which explains what programs can and cannot do.
So whoever posts to the network is the one responsible for paying the rent?
hi guys, would it be possible if the signer could be the account that stored the posts?
<@!134416332509675520> 
`program.simulate` - this also takes the transaction fee like the `program.rpc`?
Also more incentive for people with large accounts they're not using to close them?
Right, but more people, more demand, more accounts, more competition for validator memory... doesn't that mean it's fine/correct for the rent-prices to "go up" this way?
I think part of the reason why rent is currently so expensive is that the rent rate is denominated in sol and was originally set back when sol was ~2 dollars 😛 (That doesn't say why they haven't changed it yet, but rent is 100x more expensive now than it was originally)
I'm still learning most of this stuff myself, so probably missing big gaps of knowledge.
It may come down in the future, I'm not sure - my guess is that it would require some very clever strategies to be developed for paging account data into memory only when needed, and I don't know if there's a plan for this, or a better/different strategy.
If you learn how validators work, this will make a lot more sense.
so basically on ethereum storage and compute are bunched together and have astronomical cost, but in solana storage is astronomical and compute is very low cost
I would say it is equivalent to serialization/deserialization steps
OK, thanks for your explanation
If you don't specify what the bump should be, anchor will recompute it for you (but this costs compute, so might not always be a good idea)
Could you let me know how it is working?
Hi <@!134416332509675520> 

```
#[account(
        mut,
        seeds = [ token_mint.key().as_ref() ],
        bump,
    )]
```
It is working with no instruction for the bump
Does copying all that data around use lots of compute budget?
amazing thanks
<@!337555205681971203> solana config get
Hi guys what's the CLI command to know where our local wallet keys .json file is ?
I am designing something where accounts are "resizable". Basically when I need more space, I create an account with double size, copy the contents from the older, and remove the lamports from the other all in the same transaction (actually I even remove the lamports of the older before to help pay the new). This is kind of shit to do and then  "this account does not have a fixed address", which is complicated for the clients. But I don't know, I am just a noob
No I wasn't alive then
wow, how old are you?
The reddit founder is giving $100 million to solana startups and I'm sure he wants to see social startups too
There's gotta be a way to do this more feasibly
That's like $1400/mb. Reminds me of the 1950s
Maybe <@!637707515328725002> sees it differently - not sure?
What we are talking about is how you could do it in theory - in practice I don't think it's practical.
wow that's a lot
Step 1. Pay LOTS of money. Each 10MB chunk will cost you about 70 SOL and you'll have to allocate the entire 10MB up front I think
```
#[account]
pub struct Posts {
    pub posts: Vec<String>
}
```
Hrm - yeah, I guess indexing would be tricky without knowing what you want to index on, such as dates, or just volume of posts...
I thought you had to manually specify each account in the program?
how do you implement this?
Not necessary if using PDAs, I think
I don't think (edit: there is one but it is very high). The limit would be 2^128, if no other program had accounts
Not directly - but you'd need another account to store the list of accounts, so there's that limit.
is there a limit on how many accounts a program can have?
you would need multiple accounts. No sure what would be the best way to design that but your program can have many many accounts
Not on the platform directly - the data limit is 10MB and you'd have to fund the account to store that amount. However it would be possible to write a program that stores that data and creates new accounts to keep adding to it as the current one gets full. You'd have to fund it in 10MB-worth-of-rent increments though, I think.
So there's no way to create a social network contract where people can post indefinitely? <@!637707515328725002>
10 mb is the current maximum solana allows
Let's say I want to create an account that holds a vector of strings. Is it possible to have that vector grow to an unlimited size in an account?
is it possible to create an account with unlimited storage?
Hey guys what's the CLI command to know where our local wallet keys .json file is ?
cool, thought so. I'm still kind of figuring out how my governance program will work, and including signed instruction to init large accounts is just extra work i'd prefer to avoid. But so be it
Yeah, 10kb is the limit whenever you do a CPI (so even just any `init` in anchor, regardless of whether it's a PDA). But you can use zero + AccountLoader etc. to go the full 10mb if you use a separate instruction for it!
(e.g. i know PDAs are limited to 10kb, but i assume the same is probably true for zero'd out regular accounts too)
or is 10kb just the limit they have for all non-instruction based `createAccount` cpi calls
Random question, if you pass in a `zero`'d account, with the keypair signature, can you initialize with more data than 10kb?
there is a pyth example in `anchor/tests`
Thanks !!!
As far as I know
The authority will have to be the `associated_token::authority` you specify (they won't necessarily need to sign though!)
ok so we can create associated token address from program and use this. Authority gonna be signer right ?
Anchor has the `associated_token::mint` and `associated_token::authority` attributes you can use with `init_if_needed` if you want
The convention is that if you don't already know where to send the user's tokens to, then yeah, you would send them to their appropriate associated token account.
When debugging Solidity, Remix support call function of smartcontract. In Anchor, how to call fn of program except from web client?
Do I need to make a ATA for a user if I want to transfer SPL token from  vault (holds by program) to user account ? If yes how do people approach it ... Do they create it in program or from JS we create and pass in instruction set ?
So you're trying to update the candymachine account within your own program? Don't think that will work—in solana, the only way to mutate an account's data is by asking the program that owns that account to do it for you (in this case, the candymachine program).

But I'm getting the following error:
```
ANCHOR_WALLET=/Users/prikshetsharma/Desktop/mibexy/target/deploy/mibexy-keypair.json node client.js
```
and I'm running like so:
And here's my client.js:
```
const anchor = require('@project-serum/anchor');

// Configure the local cluster.
anchor.setProvider(anchor.Provider.local());

async function main() {
  // #region main

  // Read the generated IDL.
  const idl = JSON.parse(require('fs').readFileSync('./target/idl/mibexy.json', 'utf8'));
  
  // Address of the deployed program.
  const programId = new anchor.web3.PublicKey('DHKddS4uotUwyEybCDrkyYunb8ZevsKedG2V7Ae5dXYG');
  
  // Generate the program client from IDL.
  const program = new anchor.Program(idl, programId);
  
  // Execute the RPC.
  await program.rpc.initialize();
  // #endregion main
}

console.log('Running client.');
main().then(() => console.log('Success'));
```
```
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod mibexy {
    use super::*;
    pub fn initialize(ctx: Context<Initialize>) -> ProgramResult {
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize {}
```
here's my lib.rs:
Hi I'm getting an error on anchor
BAN HIM
got this at build time as warning as well.
the following functions are undefined and not known syscalls ["ceil", "floor"].
hi seems like ceil and floor float functions are not available on solana runtime? Am I correct in this? How to achieve a similar effect?
'Program failed to complete: ELF error: Unresolved symbol (ceil) at instruction #18506 (ELF file offset 0x24168)',
ok weird, it seems that any new data i add won't update..
yo im trying to keep track of a list of addresses who have minted a metaplex NFT in candy machine, im using the line ```        candy_machine.minters.push(*ctx.accounts.wallet.key);
```
where minters is the vector (in CandyMachine), though the vector is not updating, where am I going wrong?
Is there any good anchor tutorial to build an SPL token (code wise, without using the cli) ?
I see, thank you!
Even if nothign existed there
So no matter what address you pass in you'll still get an AccountInfo
Ah, ok, the interesting thing is that if you pass a fresh keypair address you'll still get an AccountInfo for it, it'll just be empty/have no money + be owned by the SystemProgram
Oh, this is bad, I tried using `Option` but I was getting some confusing errors, so I hoped I could at least do it this way
By valid I mean pointing to an-actually-existing account
Pubkey::default() is actually the system_program's address, so that might be confusing 😛
And I think all addresses are valid—what kind of checks are you seeing?
Anchor doesn't do anything at all for AccountInfos (that's just the raw low-level solana account type).
I want to pass `Pubkey::default()` when an account doesn't need to be specified
It looks like it does, then is there a way to disable those checks?
Does Anchor verify that `AccountInfo` accounts point to valid addresses?
Yeah, not sure, it definitely works for me!
yeah, I tried the mentioned stuff
Not sure—have you saved the file? 😛 Not sure what else would explain it
Not sure why yours is behaving different from my local version
Mm, dumb q, if you jump to source on the `Pool` in that `Account<'info, Pool>` type, does it go to the right place?
pool = &mut ctx.accounts.pool
````anchor_lang::Account<'_, Pool>` doesn't implement `Debug`
the trait `Debug` is not implemented for `anchor_lang::Account<'_, Pool>`
required because of the requirements on the impl of `Debug` for `&mut anchor_lang::Account<'_, Pool>`
required by `std::fmt::Debug::fmt````
Huh, my first suggestion seems to work fine for me 🤔
```field `account` of struct `anchor_lang::Account` is private
```
You derived Debug on Pool, not the wrapping `Account` stuff.
Ah, try doing `msg!("{:?}", pool.account)`
````anchor_lang::Account<'_, Pool>` doesn't implement `Debug`
```
```        msg!("{:?}", pool);```
```#[account]
#[derive(Debug)]
pub struct Pool {
    pub authority: Pubkey,
}```
still doesn't work
`msg!("{:?}", the_struct)`, if you derive Debug
how to print account struct ? added derive(Debug) but still giving me an error ?
okay, it seems it works again. but it's kinda worrying if the same happened in production 😕
or maybe i'm just unlucky and share an IP on Vercel with some bad guy 😕 has anyone got any experience with that?
I think there is `AccountSerialize` for it, I saw it used when trying to find about `AnchorSerialize`
Thank you!
Oh, yes, I found it. It _just_ renames Borsh traits.
```
pub use borsh::{BorshDeserialize as AnchorDeserialize, BorshSerialize as AnchorSerialize};
```
Nope, I was right 😛 I think for `#[account]` style structs anchor just derives the borsh stuff, no fancyness (the discriminator stuff is handled elsewhere)
Nope, I'm wrong, sorry
I think, hmm 🤔
Ah, ok, I think generally anchor doesn't do anything fancy with borsh, it just does `derive` under the hood
i've been experimenting on devnet a little bit, and after a while i got the following error
> `"error":{"code": 403, "message":"Your IP or provider is banned."}`
i wonder what i could do to earn it and if it's permanent or i can redeem myself 🙄
Yes, I know, but I wonder how Anchor uses Borsh and maybe I need to be wary of some internal logic as well
I don't think there's any fancy way to do it, you just need to go implement those traits:
```.rs
impl AnchorSerialize for YourThing {
  ...
}
```
Ah, so not just with `#[derive(AnchorSerialize)]` etc.
To verify that a certain field can't be zero, etc.
Yes, I want to add a bit of a custom logic inside
For one of your own custom structs?
I tried grepping it but so far with no results
Good day! Where can I find code for implementing `AnchorDeserialize` and `AnchorSerialize` traits using proc macros?
you can also add this line below the imports before running just `node client.js`
```
process.env.ANCHOR_WALLET="~/.config/solana/id.json";
```
gotcha. thanks
Can just type that in your shell
`ANCHOR_WALLET=~/.config/solana/id.json node client.js`
Ah, you can run that exact line of code in the snippet 🙂
<@!134416332509675520> i meant how do i run the client with setting the environmental variable. where is that line of code
Ah, interesting. Hmm, my mac doesn't like the quotes for some reason 😦
Usually in `~/.config/solana/id.json` by default
where is "anchor_wallet" located?
It was for arguments with spaces
<@!448034961652449283> do you know what those extra quotes were for? Saw a PR for it recently I think
I had to edit the anchor cli source and rebuild locally 😬
I don't understand much of this yet... I know what i tried didn't work so far 😂
If I get rid of the extra quotes I can deploy fine, so not totally sure what they're for.
Ok, well, for me this is related to how we pass extra quotes around arguments to `solana program deploy`.
I've tried a few things like a clean install of anchor and then even a 
```
anchor deploy --program-name <KEYPAIR JSONADDRESS HERE>
```
This gives me a deploy successful but can't find on the solana chain
Looks like there was a PR to fix this but I'm on the latest anchor + solana and still getting it 🤔 So doing some solana source-diving.
I've actually just started getting that error too lol, I'm investigating 😛
```
error: Invalid value for '--program-id <PROGRAM_ID>': unrecognized signer source
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }.
```
Can anyone help me with the error message that I am getting?
i got this error afterwards `node: --dns-result-order= is not allowed in NODE_OPTIONS` but fixed it by using node v16.13.0
This worked for me too! Thanks!
`cargo install --git https://github.com/project-serum/anchor --tag v0.18.0 anchor-cli --locked`
<@!744592612073406525>  <@!344663059614138388>  use anchor v 0.18.0. it works for me now


//////////////////////////////////////////////////////////////////////////////////////////

Are you using `anchor deploy`? This might be a bug with the latest anchor (I run into this too)
HI all, I am trying to anchor deploy my program to begin ttesting. Tthis is the error I am getting

```
Error: Dynamic program error: No default signer found, run "solana-keygen new -o /root/.config/solana/id.json" to create a new one
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }.

```
nvm that was a stupid question. Jet lagged af <a:aPES_CryLaptop:746135860415824093>
awesome thanks
but given the new anchor keywords it's probably better to use `Signer<'info>` anyway
Sorry, yeah
Oh!
he already has `signer` in the account constraints
~~Could you repeat that? Not sure what you mean 🤔~~
Does'nt the signer attribute on account does'nt make sure the account signs it ?
Almost, you would also need that address to sign (so change `AccountInfo` to `Signer`).
```#[account(mut, signer, address =Pubkey::from_str("....").unwrap())]
    pub authority: AccountInfo<'info>```

Can I use this way to restrict certain method call by specific pubkey ? like some functions which can be called by admin.
It worked, thank you man!
What do you mean? I thought you were referring to the one you declared with `declare_id!`
And that can be any pubkey correct?
The `declare_id!` macro declares a static variable, `ID`, that you can use, as well as a top-level function, `id()`
How would one reference a declare_id? Or use it to pre-load authority?
Thanks
For example: 
```
abc_account: ProgramAccount<'info, ABCAccount>
```

abc_account should be closed when abc_account.amount == 0
You could just copy some of that code
Well, here's how anchor does it: https://github.com/project-serum/anchor/blob/master/lang/src/common.rs
But the account should be closed if it meets a condition
I know it
yes
the main program
Are these accounts owned by your program? (If so, why don't you want to use the `close` attribute? Don't have to, but might be easier)
Whether the account lives at a PDA is actually not relevant—the question is which program *owns* the account (this is not the same thing as saying from which program the address was derived)
PDA
ah I see. Thanks!
What kind of account are you trying to close? It depends on which program owns the account. But the idea is that you need to drain the account of lamports.
Hi <@!134416332509675520> 
Could you share a piece of code to close the program account, not using the `close` on context?
but what you're probably missing in your calculation is the 8 byte discriminator that anchor adds to the start of all program accounts
anchor will just calculate it automatically for you
honestly, unless you're using variables with unspecified space (strings or vecs) i wouldn't bother with specifying the `space`
or is the `space` related to the amount of data sent in the RPC call (e.g related to the size of the instructions sent) ?
Hello frens, question. I have 2 errors:

`Error: 163: Failed to deserialize the account`
`Error: 167: The given account is not owned by the executing program`

Both go away by increasing the space on the Account  I'm operating on (from 64 + 64 to 128 + 128): 

```
#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 64 + 64)]
    pub ticketing_system: Account<'info, TicketingSystem>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```

The question is, how do I calculate the total amount space I should be allocating? 

I initially assumed it was just adding up the space accupied by adding all the individual fields to be allocated (e.g  fields in the Ticket (64 + 32 + 8 + 32) * amount of tickets (3) which is 408  ) 


In the example above, the TicketingSystem account looks like this:

```
#[account]
pub struct TicketingSystem {
    pub tickets: [Ticket; 3],
}

#[derive(AnchorSerialize, AnchorDeserialize, Default, Clone, Copy)]
pub struct Ticket {
    pub owner: Pubkey,
    pub id: u32,
    pub available: bool,
    pub idx: u32,
}
```
This shows an example of a token account that the program has authority over: https://github.com/cqfd/quidproquo
<@!134416332509675520> are there any good example for that, just want to make the token account owned by PDA? Because lots of the examples in the anchor repo for that, look really complicated with a lot of different accounts. Sorry maybe for stupidy, but coming from web2 and I am really used to typescript with great dev experience.
v0.18.0 works I will wait for fix on v0.18.3
Actually, sorry, let me think about your q some more (rushing, sorry)
Ah, no, you would store the token account at the PDA, rather than using an associated token account
<@!134416332509675520> thank you for your answer!!!!

but when I try to get make the tokenAccount from an PDA (the saving of the PDA acount already works on chain), I get an error

how can I create a tokenAccount from a PDA? I need to add the bump at the Instructions somehow right?

`Error: Owner cannot sign: 8vN4E6hqD2timmqHrXSGQoyeqTJaR97kuYHcVoH8croE`

`let [userStakeAccount, bump] = await web3.PublicKey.findProgramAddress(
      [provider.wallet.publicKey.toBuffer()],
      program.programId,
    )

    const stakeTokenAccount = await token.getOrCreateAssociatedAccountInfo(userStakeAccount)`
Yea I started with the --locked but that still errors too.
Ah, I've actually seen that too—how are you upgrading? Are you passing the `--locked` cargo arg?
https://discord.com/channels/889577356681945098/889889146087301151/903082738846949406
Can you say more? Not sure what that means—what goes wrong?
Anyone having issues upgrading to 0.18.2? Having some issues with clap. Tried some of the previous mentions of the issue but stuck.
I admit that I'm surprised your `Decimal: ` version didn't error, that seems like a bug
If you don't pass that argument at all I'd expect you to get a JS error
Aren't you passing a veccy above?
But it wouldn't explain why an rpc is called when no `veccy` is provided.
Or at least I don't think it does
Anchor doesn't default any of the args—it just deserializes them from the raw bytes that came in as ix data
What do you mean by passing default() here?
What you wrote above won't work because you won't be able to sign for your own `programId` (but your program *can* sign for one of the PDAs derived from your program)
Still, can I somehow make the code above fail? Instead of passing `Default::default()` into a handler instead?
The way you have to do this is to make the authority/"owner" of the token account be some program-derived address derived from your program.
Found a solution
```
      {
        mantissa: new anchor.BN(2)
      }, 
```
Say I have a type 
```
pub struct Decimal {
    pub mantissa: u128,
}
```
Which is passed into instructions like so
```
    pub fn initialize(ctx: Context<Initialize>, veccy: Decimal) -> ProgramResult {
```
But then when I pass it inside in this way
```
    const tx = await program.rpc.initialize(
      {
          Decimal: {
            mantissa: new anchor.BN(2)
          }
      }, 
      {
--snip--
```
I get `veccy` to be zero initialized, which is not what I want
Good day! How can I pass custom types in `.ts` code into instructions?
hi want to create a token account which is owned by my program? Is this even possible? I am able to transfer token to this account, but when I want to transfer it back I get the following error. I need to sign it with the pda seeds right?


`const stakeTokenAccount = await token.getOrCreateAssociatedAccountInfo(program.programId)`

`Program log: Instruction: Transfer
Program log: Error: owner does not match`
What's the format on memcmp?
Something like this?
`let myBlogAccount = await provider.connection.getProgramAccounts(
             program.programId,
             memcmp: {
                      offset: 1,                        
                      bytes: <MYPUBKEY>
            }
);` ?

What does the offset value does?
❤️
Thanks ! that's what i was looking for, will try it now
and fill the memcmp filter with that public key
you could use - https://docs.solana.com/developing/clients/jsonrpc-api#getprogramaccounts
I need to send the account as a value from the client, but how do I get the right Blog account's address?

I want to edit the right Blog account, which has my Pubkey saved as a value in it... But i guess the way is not to pull all the program's Blog accounts and cycle through them until I find the one that has my PubKey as a value ( and that I can edit )
you want to show the connected user blog's on frontend ?
Hey guys ! Let's say I have a program to create blog posts into a Blog account, and I store along the blog text the pubKey of the blog's creator so only him can edit the blog content.

**how do I find my account as a user when doing a call on the program's rpc? I know my pubKey and the program's Id, but not the program's Blog account which has my PubKey as a value in it..**
whats with the leading 0?
when i go to deserialize it on the frontend i get this ``0100000000000000`` via ``new BN(initializerAmount).toJSON()``
i have a value of 1 SOL cast as a u64
i run this project on local it oke
hi all,
how can i run project below on solana dev net 
https://github.com/project-serum/anchor.git?
Hello, is there a way in anchor I can throw an error if an argument is not of a certain set of values? I have a function that accepts a vote weight, and I only want `-2,-1,0,1,2` as valid options.

``` pub fn vote_general_sentiment(ctx: Context<Vote>, vote_weight: u64) -> ProgramResult {```
how can i deserialize a custom program
Do all the `#[derive(Accounts)]` structs have to be in the root module? I tried moving them into submodules and it wouldn't compile
That "Party1New Party2New", but that should be right as I'm not passing anything into the initialize function now, I was passing in names beforehand, but I rebuilt the program and redeployed it as well without using any names as parameters to the instruction
I get some really weird data back
So yeah, not obvious to me yet what would cause your issue, so best bet is probably to just see what data is in the account
Default should be fine for that specific type
is derive(Default) a good general practice or just used in specific cases?
yeah I think it has something to do with the bool type being initialized, not sure what it initializes to when I attach the derive(Default) macro, might not work well for bools
That might shed some light, Ill give it a go
Interesting, well, you can always `await program.provider.connection.getAccountInfo(thatAccountsPubkey)` and take a look at its `.data`. Maybe one of those bools is somehow not 0/1?
Ah, sorry, failed to *de*serialize the account
Ah, ok, so probably not space then.
Currently just testing the initialization of this
I pretty much always specify space myself
Are there any variable-sized types in there? Maybe something else is going on
I see, so adding space to the account macro for the instruction would most likely solve this? Still wrapping my head around when to specify space and when not to, is it a good practice to always do this even when the struct just has primitive types inside?
Very often it's because you haven't allocated enough space (anchor tried to write the account back out to storage and failed)
Currently working on a test, and I'm receiving this error: Error: 163: Failed to deserialize the account. I can post relevant code snippets as well, but are there any frequently used troubleshooting techniques for this error?
^ How are you passing the treasury_authority's address from the client?
yeah
How are you determining the treasury_authority's address on the client?
What's stake here? Is that the instruction handler above?
Are you sure the seeds are the same then?
do i need to include a signer when i call stake?
i verified bump is exact same in test and smart contract. i logged both as well to double check.
That would mean you're somehow not using the right bump, I think
Are you sure you're using the right bump there?
Should be equivalent (basically)
I am getting: "Provided seeds do not result in a valid address". Any help would be appreciated.
Implementing a "freeze program" to freeze the program from new staking / unstaking.
Does it mater which implementation we choose between the following ones:
 `staking_account.freeze_program == false` at the beginning of these functions vs 
```
#[account(
        mut,
        seeds = [...],
        bump = ...,
        constraint = !staking_account.freeze_program,
    )]
    pub staking_account: ProgramAccount<'info, StakingAccount>
```
ahhhh that worked ❤️ ty
the declare_id stuff should be added to the docs lol
What you're doing there looks fine, so I'm guessing the issue is a declare_id! issue.
Nope, 0xa7 = 167 = AccountNotProgramOwned. Is it possible you've got the wrong pubkey in your `declare_id!` in your program file?
there is a lot of random little snippets of code and things that can fuck stuff up. I didn't realize it until I went deep on the examples and tried to rebuild one from scratch like that
under examples
like the anchor project folder should have this fully done for you already
and compare your code and the supporting files to that example
I would say the best way to figure it out is download the anchor examples directly
I've done the exact same thing over the last few days
any ideas?
👋 hey i'm trying to get basic-2 to work basically just copy-pasted that code, deployed to local chain

however when running
```
const myAccount = anchor.web3.Keypair.generate();
  await program.rpc.create({
    accounts: {
      counter: myAccount.publicKey,
      user: provider.wallet.publicKey,
      systemProgram: anchor.web3.SystemProgram.programId,
    },
    signers: [myAccount],
  });
``` 
keeps giving me back error code 0xa7
`The given account is not owned by the executing program`
which i looked in the anchor github is error `AccountNotMutable`

but as far as I can tell, I'm signing with the account to create and the payer is the owner of the program


//////////////////////////////////////////////////////////////////////////////////////////

Basically I feel like it must be some weirdness with solana's rpc stuff on your M1, since your anchor stuff looks fine. I would try reinstalling solana from scratch maybe (hopefully with a fresher version)
Ok, when I run the tests locally I don't get any errors, so I wonder if something is weird with your install of solana? Not sure what could cause the error you're getting 🤔
thanks a lot  🥺
K taking a look 👀
target/idl/myepicproject.json
```
{
  "version": "0.0.0",
  "name": "myepicproject",
  "instructions": [
    {
      "name": "startStuffOff",
      "accounts": [
        {
          "name": "baseAccount",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "user",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": []
    },
    {
      "name": "addGif",
      "accounts": [
        {
          "name": "baseAccount",
          "isMut": true,
          "isSigner": false
        }
      ],
      "args": []
    }
  ],
  "accounts": [
    {
      "name": "BaseAccount",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "totalGifs",
            "type": "u64"
          }
        ]
      }
    }
  ],
  "metadata": {
    "address": "7YsY7NnkANmSDLLF1ae4f8zTRxWaLpARa3jGiGFapHPr"
  }
}
```
here 🙏
https://github.com/MatthewTang/myepicproject
sure
Can you also post what your `target/idl/<progname>.json` looks like?
hmm , i currently don't , let me create a git repo real quick
Do you have your code in a repo somewhere? I'm not sure why you'd get that just by eyeballing but would be pretty easy to debug with a reproducible example
like without just running anchor test
and how can I test  a project entirely
hi, sorry to bother you, I ran into a very similar issue that you mentioned here, how did you solve it in the end ? 
my issue is listed here -> https://github.com/project-serum/anchor/issues/1062
thanks a lot ! 🙏
Hey how can I test with NFT tokens and not just airdropping dev sol
I'm testing a NFT staking program and I need to test using NFTs not SOL tokens
You always have to pass accounts in from the client too, so not possible to do it in a sneaky way on-chain
No, because seeds are ultimately public—don't store anything secret in them!
that way users can't see how their addresses are derived
and do the lookup on chain
can you use the program's private key as a seed
depends what seeds are used, but yeah
yep
and in general you can find the PDA for any wallet public key + program?
correct, anything on chain is totally public
or store private information
but in general, we can't rely on PDAs as a way to hide information, right?
but again i'm just spit-balling
ya
it wouldn't be storing an unencrypted message in a PDA whose address is seeded with a hidden key, right?
to be clear, the encryption would be for the message stored on chain, which is then decrypted on the client side, right?
there might be a better way to do this with more elegant encryption, im not sure
haven't looked at jabber
yeah what i'm suggesting would be to create a new keypair, but then the user would have to save that somehow (idk what that would look like) and associate it with their solana account, but then they couldn't read the messages if they signed in from a different device unless they also typed in the additional keypair info
so is it possible to build a webapp like this without exposing your private key to the page
just a thought
Ah, it's a mobile app!
i think you'd be better off adding something like gpg into the client and telling the user to save their private key, and associate it with their solana address, rather than requiring them to sign each message with their solana private key
Does jabber work with phantom, or only with like sollet?
The thing I'm not sure about is that if you e.g. try to send a message to my phantom wallet's public key (possible if I tell you my wallet's public key), I don't actually have a great way using phantom's API to subsequently decrypt with my private key (I can snag my private key manually of course, but phantom doesn't expose a `decryptWithPrivateKey` method etc.)
this is interesting. i don't think any of the tutorials i've viewed for similar projects have addressed this
Asymmetric key encryption lets you encrypt a message using the recipient's public key, in such a way that they can only decrypt it with their private key.
how do you encrypt it in a way that the sender and receiver can both read them
Nothing—I haven't looked at how jabber works but I assume you'd have to encrypt the messages before storing them.
what stops someone from fetching the account for someone else's inbox if they can derive the PDA address
how would we go about building a private messaging app like this with anchor? https://github.com/Bonfida/jabber
ah I see. Thank you!
I am getting 
`Program log: Custom program error: 0x65`
     Error: 101: Fallback functions are not supported
on line 77. any suggestions?
If that's not there, one could inject a different type pretending to be that account.
It's more about security.
Question:

Would it be correct to say that the 8 bytes discriminator that's added by the `#[account]` attribute is both a sanity and security check because it ensures the correct account is being accessed. Without this, you might be using the wrong account and not notice until the behaviour you get is unexpected ? Is it more about sanity than security ? I'm I thinking about this correctly ?

I'm trying to make sure I really understand.
i have question
how can i extend the storage of the contract ?
and after the transactions, i wish have 0 sols
hi dev
if i want to send all my sols from one account to another, how much should i send such that the gas fee will be taken accounted for?
It worked with this salad.

```
let info = my_account.to_account_info();
let mut data = info.try_borrow_mut_data()?;
let dst: &mut [u8] = &mut data;
let mut cursor = std::io::Cursor::new(dst);

my_account_struct.try_serialize(&mut cursor)?
```

Thanks 🙏
I have: "Error: Error loading workspace IDL for project-name".  Have found some comments about this but still couldn't managed to solve it.
thanks for your help
I'll try the cursor, bang my head against the wall, have a beer and get back to you
I've used the low-level writer stuff before
That would work too (the low-level stuff above should work too though)
perhaps I need to create a cursor
looking at the anchor source, it does this in exit()
```let mut data = info.try_borrow_mut_data()?;
            let dst: &mut [u8] = &mut data;
            let mut cursor = std::io::Cursor::new(dst);
self.account.try_serialize(&mut cursor)?;
```
Yeah, not sure how a similar line on my compute typechecks fine.
That's the thing I'm confused about, you've already got a `*` in that snippet above.
do I need to deref the Rc<RefCell> then?
I just broke the line to make sure it was saving correctly
I'll look further - just checking there wasnt some other function to use
What's the other error?
Yes definitely - If I change it the error changes
This is the impl of std::io::Write you want to ultimately end up using: https://doc.rust-lang.org/std/io/trait.Write.html#impl-Write-6
Just to double check... are you sure you've like saved your file? That specific error doesn't make sense to me given the code you pasted above.
super simple 🙂
This is my struct definition:

```#[account]
#[derive(Default)]
pub struct MyAccount {
  pub amount: u8,
}```
Yeah, think so.
so try_serialize is what I "should" be using for structs defined with #[account]?
for me too - but it's webstorm so I never trust the IDE type checker
Or at least it typechecks
Huh, typing that equivalent line seems to work fine for me, and no, you shouldn't need to implement your own writer
Hey - I think am 90% there with this - just having trouble getting this line to compile:

```
my_account_struct.try_serialize(&mut *ctx.accounts.my_account.data.borrow_mut())?
```

the trait `std::io::Write` is not implemented for `Rc<RefCell<&mut [u8]>>`

In the past I have done this either with borsh or "standard" anchor.

Do I have to create my own writer here?
Hey there, I have 2 programs, where one defines this enum;
```
#[derive(AnchorSerialize, AnchorDeserialize, Debug, Clone)]
pub enum MyEnum {
    VALUE,
    ANOTHER_VALUE,
}
```
And the other program uses that enum as an argument;
```
pub fn do_thing(
    ctx: Context<MyInstruction>,
    my_enum: MyEnum,
)
``` 
but I run into his when trying to test/generate the idl;
```
 IdlError: Type not found: {"name”:”myEnum”,”type":{"defined":"MyEnum"}} ``` 
is there anything extra I need to do? I see a few open issues like https://github.com/project-serum/anchor/issues/22. I have a workaround for this, just wasn't sure if it was supported or not atm
The most common example of this is what I'm doing in that repo, a token account (they're always owned by the spl token program) that lives at a program-derived address derived from my own program. Associated token accounts are another example: they're token accounts (owned by the spl token program), but they live at an address derived from the associated token program.
ok I thought that also, but I read there is a difference between which program owns the PDA account and from which Programm the address is derived and what is the sense then for owning a pda account derived from another account?
Yeah, you'll have to use a raw `AccountInfo` here (even if the boolean thing above worked you'd have to do the same thing, since sometimes you wouldn't initialize the account and it wouldn't have a MyAccount in it)
would anchor not complain if my_account is an empty account? I should just use AccountInfo instead of ProgramAccount then I guess
Think so, yeah.
OK . so in that case, I would just remove the  init, payer and space from the macro and initialise the account in my handler in the "old fashioned way"?
Not currently, no. You'll have to do the conditional-ing manually in your instruction handler
Hi all, is it possible to make initialisation of an account conditional on some boolean? 

I am looking for something like this

```#[account(
    init = someBoolean,
    payer = payer,
    space = 8 + 1
  )]
  my_account: ProgramAccount<'info, MyAccount>,```

Use case: I want to have an option in my program to create an account during an instruction, if some boolean property of another account is set. If it is not set, I want to save the rent cost of creating the account.
And only the deriving program can sign for a PDA (no other program/person can).
Yep, it's safe. Knowing the seeds isn't enough (their security doesn't come from secrecy), someone would need to convince the program to actually sign for them (so, don't write a dumb program 😛)
thanks
Much thanks, it works.
an not any user who know the seed can do sth with this account?
is this trick safe that the pda account has the authority of itself, so that only the program can do actions with the account?
And then in your JS it will look like
```.js
await program.rpc.initialize(123, {
  accounts: {
    ...
  }
});
```
You'll need to change your ix function to have the bump too: `pub fn initialize(ctx: Context<Initialize>, mint_bump: u8) -> ...`
```
#[program]
pub mod test_anchor {
    use super::*;
    pub fn initialize(ctx: Context<Initialize>) -> ProgramResult {
       msg!("mint: {:?}", ctx.accounts.mint.to_account_info());
        Ok(())
    }
}

#[derive(Accounts)]
#[instruction(mint_bump: u8)]
pub struct Initialize<'info> {
    #[account(
        init,
        seeds = [b"my-mint-seed".as_ref()],
        bump = mint_bump,
        payer = authority,
        mint::decimals = 6,
        mint::authority = authority,
    )]
    pub mint: Account<'info, Mint>,
    pub authority: Signer<'info>,
    pub system_program: AccountInfo<'info>,
    pub rent: Sysvar<'info, Rent>,
    pub token_program: AccountInfo<'info>,
}
```
hi, this is my instruction, on the client side how to construct the request instruction(how to input the bump i don't know)?
#[instruction(mint_bump: u8)]
https://docs.rs/solana-client/1.8.5/solana_client/rpc_client/struct.RpcClient.html#method.get_recent_blockhash
```
.and_then(|slice| slice.try_into().ok())
```
https://doc.rust-lang.org/std/result/enum.Result.html
https://doc.rust-lang.org/std/option/enum.Option.html
`and_then` applied to Option which should return Option, `try_into` return `Result` and `ok` convert it to `Option`
Morning people ☕ <a:vibe:827622201925697606>  is it possible to get the most recent block hash on chain on the rust side?
slices the data structure into an array afaik
Hi, not necessarily an Anchor query, but I was going through this [tutorial](https://paulx.dev/blog/2021/01/14/programming-on-solana-an-introduction/#further-reading) by Paul and came across this piece of code,
```
let amount = input
            .get(..8)
            .and_then(|slice| slice.try_into().ok())
            .map(u64::from_le_bytes)
            .ok_or(InvalidInstruction)?;
```

Being a beginner in Rust, I was confused about what `|slice| slice.try_into().ok()` was doing. 

Any help?
https://github.com/project-serum/anchor
hi we are trying to raise liquidity for our token. is this the right repo?
we just have to put ui and run it?
Sure!
That totally fixed it. THANK YOU <@!134416332509675520>! 🙂
Which would totally explain why it's looking for constructors, etc too.
Yup, you do.
🤦‍♂️
I didn't think you could invoke it like a function, only as a constructor
Do you not need to do `new BN(...)`?
All the other examples I've looked at seem to assume that the JS is running in node, but I'm trying to pass in a JS number as an arg to an unstruction that expects a u64 number.

It's a weird one. I've stepped through the BN.js source and I'm not sure what to make of it. Here's a screenshot that should give some context....
What error do you get?
Ok, one more problem I could use help with... When running my JS in node I can call `anchor.BN(0)` and that works like in the examples in Anchor. For example, this is how u64 numbers seem to be passed in as arguments to an instruction.

If I try the same in Chrome then the same `BN(0)` call fails and I can't assemble the arugments to my instruction. What is the right way to pass in u64 integers to an instruction from the browser?
ok ok, ty, lets type some more code then haha
Not totally sure I understand the issue, but I'll focus on the bits I do for now. Thanks again <@!134416332509675520>! 🙂
Currently yes, as far as I know 😬
So generating a new keypar seemed to make everything happy! 🙂
if i have a variable number of accounts does it mean i must use remaining_accounts to access them and do all the is Signer etc verification by hand ?
Thanks for the help <@!134416332509675520>, I'm sorry I couldn't give you more to work with.
Ok, I'm going to try that then kick this around a bit more. Will come back once I'm better able to express the issue.
You would need to re-initialize it, but yeah
If I regenerate my keypair that the JS client is using, that should get me a fresh account correct? I'm thinking I should try that and see where I'm at with a fresh account.
That seems like a different error, 0xa7 = 167 = AccountNotProgramOwned

Hmm... I just started seeing an error about space. Could this be that?
So given that you're re-using that account over and over again, my guess is that you allocated enough space for the original struct, not the new version
If you didn't allocate enough space to handle that new field you added, you won't be able to serialize the new structure
Do you have enough space for that account on the JS side?
But when I copied the IDL over to my JS app things just started to blow up and I'm now seeing messages about serialization.
I tried to add a `vote_count` to that struct and was able to do that and get my tests passing in Anchor.
So really the problem is this. I've got a struct that I was storing a bunch of links to gifs and addresses of the users who posted them in.
I lost track
What qs did you have about the rust side?
I'm going to bang at it a little longer.
Probably all of them 😛
ha ha
Depends on what other questions you have 😛
I've got my Anchor program in one project and a seperate JS one for the front end that I'm just cutting and pasting the IDL into for now.
(Do you want me to paste the `lib.rs` here? It's about 112 lines.)
Yeah, you'll be referring to a totally different account then
Ok, on the actual JS client I've generated a keypair once and saved it in JSON so I use it everytime. I assume changing that will also generate a new account.
Yes, you specify the address of the account you want to use on the client, and solana makes it show up in your program as an account
yes
This looks like its generating a fresh baseAccount on every test run (you're making a fresh keypair)
It's my understanding that the account used by the program is tied to the public key I pass in as the `baseAccount`?
I truncated out a bit of the code.
So without pasting too much text in here.. this is what I'm using to test in anchor...

```

const main = async () => {
  console.log("🚀 Starting test...");

  const provider = anchor.Provider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.Myepicproject;
  const baseAccount = anchor.web3.Keypair.generate();
  let tx = await program.rpc.startStuffOff({
    accounts: {
      baseAccount: baseAccount.publicKey,
      user: provider.wallet.publicKey,
      systemProgram: SystemProgram.programId,
    },
    signers: [baseAccount],
  });
  console.log("📝 Your transaction signature", tx);

  let account = await program.account.baseAccount.fetch(baseAccount.publicKey);
  console.log("👀 GIF Count", account.totalGifs.toString());

  // You'll need to now pass a GIF link to the function! You'll also need to pass in the user submitting the GIF!
  await program.rpc.addGif("insert_a_giphy_link_here", {
    accounts: {
      baseAccount: baseAccount.publicKey,
      user: provider.wallet.publicKey,
    },
  });

  await displayGifs(account, program, baseAccount);

  // You'll need to now pass a GIF link to the function! You'll also need to pass in the user submitting the GIF!
  await program.rpc.upvoteGif(new anchor.BN(0), {
    accounts: {
      baseAccount: baseAccount.publicKey,
      user: provider.wallet.publicKey,
    },
  });

  await displayGifs(account, program, baseAccount);

  // Clear all the GIFs!
  await program.rpc.clearGifs({
    accounts: {
      baseAccount: baseAccount.publicKey,
      user: provider.wallet.publicKey,
    },
  });

  await displayGifs(account, program, baseAccount);
};
```
What do you mean by tied to your base account? What's the base account here?
Sorry for all the dumb questions, I'm at that point where it's all so new I'm not really sure how to Google it yet. 😛
Is the account my program is accessing tied to my base account?
Like somehow corrupted the account?
It's running on devnet for that, so I'm thinking I've done something wrong there.
Ah, ok, for that I guess you may need a real validator.
I think the only way you could see invalid data like that is from a previous write you made, yeah. Fresh accounts are all zero-initialized.
It's when I copy the IDL json to a JS project when things seem to go sideways.
I've been running tests with `anchor test` and that seems to work as expected.
I'll try that right now.
You can also nuke your actual validator state with `solana-test-validator -r`
I almost exclusively test things by letting anchor spin up its own solana validator, so I start with a clean state every time.
(I can share some actual code if that would make this clearer...)
So basically in this case, it seems to be breaking because I'm getting back bad data and not neccesarily panicing (at least not until I try to add to the vector, then it does)
So the issue I've got is that I'm seeing invalid data when I deserialize the account. For the app I'm building I'm recording the number of votes for a GIF. When I added the vote field to the data structure there was a seemingly random large number for the number of votes even though I'd never initialized it. I'm assuming this is because it's deserializing from memory that's beyond the end of the original object, but I'm new to all this so that's just a guess.
Quick question... I've made some changes to my structs and things are no longer serializing / deserializing properly. This is just test data so I'd like to start a fresh account for the program.

Is changing the program id the best way to do that, or is there a proper way to flush a program's account?
is it possible to do warp_to_slot in pure anchor ts tests?
yea I am using the recent Anchor... I figured out the issue herer... you need to change /root/ to ~./.config/solana...etc


//////////////////////////////////////////////////////////////////////////////////////////

ah nvm, I guess when I run something like this
``` 
[bondPoolAccount, bumpBondPoolAccount] = await PublicKey.findProgramAddress(
            [payer.publicKey.toBuffer(), Buffer.from(anchor.utils.bytes.utf8.encode("bondPoolAccount"))],
            program.programId
        );
``` 
then the PDA is owned by `program.programId`, right? so no need to do `Keypair.generate()` (which feels like bad practice anyways)
you can probably create an iterator, and include it as part of the seed, and then maybe store the max-count of the iterator somewhere
I was wondering if you can create a Mint that is owned purely by the program. I have often seen the approach that one would generate a keypair `owner = Keypair.generate()`, but the fact that it has a private key seems flawed. Maybe I'm wrong though. That's why I was thinking of PDAs, but not sure how it works if you generate the PDA also in the frontend. Would the PDA need to be generated by the program (i.e. in Rust, instead of Typescript for example)?
ah I see
`Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account `
but getting this error

no complain in build time
so i changed to this
```
#[derive(Accounts)]
#[instruction(proposal_account_bump: u8, proposal_id: u64)]
pub struct AddProposal<'info> {
    #[account(mut)]
    pub base_account: Account<'info, BaseAccount>, 
    #[account(init, seeds = [b"proposal_account".as_ref(), proposal_id.to_be_bytes().as_ref()], bump = proposal_account_bump, payer = user, space = 10240)]
    pub proposal_account: Account<'info, ProposalAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program <'info, System>,
}
```
No quotes (not a literal string)
Not quite, you're still hard-coding the "proposal_id" part, you would need to do `proposal_id.to_bytes()` or something like that
Can anyone point me in the right debug direction?
```
Program failed to complete: exceeded maximum number of instructions allowed (1718) at instruction #9794
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA failed: Program failed to complete
    Program QMMD16kjauP5knBwxNUJRZ1Z5o3deBuFrqVjBVmmqto consumed 14938 of 14938 compute units
    Program QMMD16kjauP5knBwxNUJRZ1Z5o3deBuFrqVjBVmmqto failed: Program failed to complete
Transaction simulation failed: Error processing Instruction 0: custom program error: 0xa7 
```
Hi, i'm a newbie here. Can somebody give me some context on how/when to use TokenAccount constraints like the following
#[account(mut, token::mint = ...
or
#[account(mut, associated_token::mint =
something like this then

E.g. pass the name of the proposal as an instruction argument
Which part? You'll have to have some way to use the correct seeds there (or just not use PDAs for the proposal, not sure)
then, https://github.com/Necmttn/anchor-voting/blob/becdbe69106718d2a8021a68d2170f0d397bae19/anchor-voting/programs/anchor-voting/src/lib.rs#L101
can you help explain me this bit please
You'll have to come up with different seeds or use a fresh keypair address, etc.
Reusing the same seeds will always give you the same address back.
Did you give the second proposal a different address? [Edit after looking: nope 😛]
how can i create more PDA account 😅 
sorry if i'm spamming.
https://github.com/Necmttn/anchor-voting/blob/becdbe69106718d2a8021a68d2170f0d397bae19/anchor-voting/tests/anchor-voting.ts#L58-L62 when i try to create second proposal, i get
```
 'Allocate: account Address { address: 4x76D7BnE9ifqxnfDJ2Jxnd5AinfKEjiMnD4nwziTvY1, base: None } already in use',`
``` 
error as expected.
testing this right now.
Likewise, each vote would go at a PDA with seeds something like [proposal, voter_pubkey]. That lets you record the fact that someone has already voted for the given proposal.
You would need to store each proposal you want to vote on in a separate account most likely.
What do you mean by a decentralized token?
If the owner/authority of a mint is a PDA, that means the only way to mint new tokens is to convince that PDA's deriving program to sign a cross-program invocation to the token program asking it to mint more tokens.
is it comon that a PDA owns a Mint? 
if yes, what prevents some random guy to just mint more tokens? 
if not, how can a "decentralized" token be created?
How can  I make new proposal caller to create a new account and pay for a rent ?

Hello, been checking the examples out there but haven't figure out how to; 
Currently i'm building a tutorial for how to build simple voting app via anchor framework.
following example is working 👇🏻
https://github.com/Necmttn/anchor-voting/blob/master/anchor-voting/programs/anchor-voting/src/lib.rs 

but after certain amount of proposals & votes the rented space from `baseAccount` will run out and program will not update anymore. 

so how can i make this scalable ?
<https://github.com/solana-labs/solana-program-library/blob/master/associated-token-account/program/src/tools/account.rs#L13> there's like manual calling of transfer, allocate and assign here. I just have to start thinking in these terms if I want to create a non-system program account creation function for any other program. Although it really doesn't seem worth the hassle
will do ty for the headsup
they pay their tech support staff!
if no one answers you here the solana tech discord is also good for answers
kind of like the associated token program
you know, just thinking about it, it's actually not really that much of a hack. You're  replicating exactly what the system program does. Just making your own version of that function for creating accounts using your program's own "createAccount" function
so i was looking at  one of the spl examples, can any one explain the rust project architechture for example it had 3 files
entrypoint.rs, instruction.rs , processor.rs
what does each file represent
and what does this macro do and why is "#![cfg(not(feature = "no-entrypoint"))]
" it was present in the entrypoint.rs file
when i change the PDAs owner to the system program i can use it to pay for new accounts and use the PDA to sign transactions
well, at least your solution works
gah
You can send them to whoever you want, no ownership issues—only the source presents an ownership issue
Right, exactly
so yeh, only the program that owns an account has the ability to reduce lamports but solana doesn't care where they go
Because only the token program has the right to drain a token account's lamport balance
That's why in general you need to ask the program owner to close its accounts for you, e.g. the token program has a whole extra instruction to close accounts
because surely when accounts are closed lamports are transferred out
no i'm still annoyed at it
i think i fundamentally get it now
ok
i'm going to keep source diving
i'm not giving up just yet
that is funny
wow
Yeah
Yep, that's the thing I was worried about I think—are you using the system program but the pda account is owned by your program?
or maybe this is the error you were warning me about
```
    Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: instruction spent from the balance of an account it does not own
```
never seen this one before, more debugging is needed
Lol
now for the big reveal if it totally breaks
thanks!
yeh, that works fine
But not 100% sure
I think it's often just a dumb type inference issue, so annoying :/
i will try that
ah
What if you do `let seeds: &[&[&[u8]]] = ....`
do they need to be joined together somehow?
Heh, yeah, type inference here is brutal 😦
that's the error i get with something like that
```
mismatched types
expected reference `&[&[&[u8]]]`
   found reference `&[&[&[u8]; 2]; 2]
```
Rust-wise you need to do something like
```.rs
&[
    &[ b"first thing's seed".as_ref(), &[first_things_bump] ],
    &[ b"other thing's seed".as_ref(), "other thing's second seed".as_ref(), &[other_things_bump] ]
]
```
ah right
Ah, sorry, that hack is to let a non-system account pay for another account's creation
so i already have creating a PDA owned by a program with 0 space working. Which i think is what your hack here is supposed to get working?

However, I'm slightly stuck on combining two seeds in an array
usually it's 
`let signer = &[&payer_pda_seeds[..]];`
but i need to combine multiple in an array somehow
`let two_signers = &[payer_pda_seeds, created_pda_seeds];` this gives a compile error, i'm going to play around with different solutions but mentioning it in case you know off hand already
aside from that it's not possible to have optional accounts
search for `remaining_accounts`
common methodology is to write a javasript / tyescript test for end-to-end functionality. you can assert account balance etc. within here as well. there's also rust tests, but i guess these are more for testing individual functions. i think what you need is `anchor test` , and setup multiple user accounts, and check if the balances are correct at each stage
Hello! Is it possible to have `Option ` account in my instruction?
or does anchor have these functionalities already implemented?
etc
I mean anchor test is one option but what if I want to test my staking program by test staking et
hey how can I correctly test my program ?
Ah ok
I would expect the solana dumbness-check to happen after the CPI
Not beforehand
And it failed the transfer check for having data on the account
Someone else told me they tried it with a PDA with Solana in it
But yeah worth trying!
Yeah, I think what will happen is that solana itself double checks CPIs didn't do something dumb, and that check will fail here (so nothing in the system processor code itself necessarily)
Yeh, I'm out at the moment but I will try this morning for sure
It calls allocate and assign and transfer
Worth trying (I think I already did try this, but now not 100% sure)
Yeah, I mean solana itself will prevent this (I think)
https://github.com/solana-labs/solana/blob/e540b1cf3c329c51de60a183529d0c39ee3d86d9/runtime/src/system_instruction_processor.rs#L150
Transfer is called by create_account
Maybe there is a higher level check that happens which prevents it
https://github.com/solana-labs/solana/blob/e540b1cf3c329c51de60a183529d0c39ee3d86d9/runtime/src/system_instruction_processor.rs#L202
If the account is owned by the system program then yeah, just need a signature (PDA or otherwise), but I'm pretty sure it won't work if the account isn't owned by the system program, since solana just doesn't allow that kind of non-owner mutation.
I was like 99% sure that doesn't work (people keep trying it in the discord and they have to use `try_borrow_mut_lamports` instead)
Really? Even if the from account is owned by your program?
And transfer works fine so long as the from account is a signer and doesn't have any data in it
Since in the create account source it's just calling transfer
I feel like it's probably ok if the PDA signs
Interesting, I will have to investigate
The issue is that solana itself won't let the system program debit an account it doesn't own.
Thanks for the example. It should be possible to create an account owned by a program with 0 space and to have that pay so long as the payer is a signer. There's nothing in the source that would suggest otherwise but maybe it breaks in practice somehow. I'll have to try putting some minimal example together to test it out
hi there, on frontend, how do you create a persistently connected wallet, until user decides to disconnect? right now, whenever user returns to site, getAnchorWallet prompts a re-connect
Is there anyway to see what you can use inside of #[account], eg [account(init)], etc. I've been traversing the rust docs but can't seem to find anything
big num
hi anyone we are getting this error. any insight would be appreciated. first time to run anchor. thank you
what does "BN" stand for? 
```import { web3, BN } from '@project-serum/anchor';
```
But what you actually can do (horrible hack) is have your program account send money to the fresh account via `try_borrow_mut_lamports` stuff, then allocate the new account some space, then transfer ownership from the system program to your program 😬 There's also a sort of bug in solana that makes this even dumber than it ought to be: https://gist.github.com/cqfd/ffbdebbbcd3460ec822c3e63572cc282
This is indeed pretty tricky to do—basic answer is "no", but the less basic answer is "sort of" lol. Basic answer is no because at the end of the day the system program is going to debit the payer account, which can only work if the account is owned by the system program (so not going to work as-is if the account is actually owned by your program)
```
    if !from.data_is_empty()? {
        ic_msg!(invoke_context, "Transfer: `from` must not carry data");
```
<https://github.com/solana-labs/solana/blob/e540b1cf3c329c51de60a183529d0c39ee3d86d9/runtime/src/system_instruction_processor.rs#L184>
wow, i found it
even still, this sounds wrong
the person who mentioned this said more specifically that it was program accounts with data in them that couldn't have solana transferred from
but this can't be right because then PDAs couldn't be used to transfer solana around
i've heard rumours that they cannot
can non-system program accounts be payers when creating account?
hmmmm
Whoops, missed this already got answered, my bad!
`constraint = something @ YourCustomError` (make sure you've got an up to date anchor + anchor-cli)
you were right: Installed solana again by building it from scratch and the problem is gone.
Had version 1.8.2 before, now 1.8.5. Will submit a pull request to buildspace's tutorial to update it.
-> Wasn't an anchor bug
https://github.com/project-serum/anchor/blob/384f143f77e8dd611e48be75072e47a860c462a0/tests/errors/programs/errors/src/lib.rs#L74
how can we attach custom error code on constraint validation in anchor ?
i see :0 i have been working on setting up a linux vm .. arm ubuntu seems problematic as well... I guess I will just move on to ubuntu x64 on cloud 🤣 thanks a lot !!! appreciate you checking my issue 🙏


//////////////////////////////////////////////////////////////////////////////////////////

Finished reading this article -- the voting app example was helpful !
thank you, this makes a lot more sense now 🙂
https://www.brianfriel.xyz/understanding-program-derived-addresses/
highly recommend this read
They're just a sha256(seeds + bump + programId + some fixed string, can't remember)
Yep, exactly
I think you understood my question -- I was confused as to whether seeds + bump were global, but after some googling it looks like a PDA is derived from (programId + seed + bump), which means the derived address will never conflict w/ another program
The point of the seeds is to be human-understandable, the point of the bump is purely to make sure the result sha256 hash isn't a valid ed25519 public key
Or, hmm, maybe I'm misreading your question 🤔
Also bumps are only a single byte
So you and I can use the same seeds, but for different programs, and will get totally different addresses
No, because PDAs are always specific to a specific program!
one wonders why seeds + a bump is necessary, since couldn't everyone just use an empty seed array & just have different bump values?
Yep
I see, this makes sense. So I could just use an empty seed array b/c the bump value will result in (eventually) a valid address being found, right?
Because you've already created an account at that address
It will fail on subsequent calls
whereas true global state should only be created once
Can use whatever hardcoded seeds you want by the way (even [])
Actually -- even the above example doesn't seem correct, since `create_game_state` can be called more than once
Yep, hardcoded seeds will act like global state
https://gist.github.com/vedantroy/bbc23a19a5e5126198590cd7fd4f9d09
I think I finally figured out how to have global program state:
Thanks for the responses -- I also reached the same conclusion once I dug into the Rust.
use `Account` instead
Nope, it's deprecated 😉
Is there a tutorial on how to use the `ProgramAccount` struct in Anchor?
that's good! you will have an easier time of it than i did at least 🙂 i had to learn rust just so i could learn solana
sounds good haha -- yeah, I'm experienced with Rust but not with Solana
you can do this through PDAs. Sounds like you should dig deep into Solana Programming basics first 🙂 dont worry too much about anchor for now
I will continue looking through tutorials (I think I see something w/ a counter that might be useful for what I'm doing)
And since the state must be global --  I can't allow multiple users to each create their own global state
thanks for the quick response -- basically, what I'm trying to accomplish is letting my program have some global state. Imagine a struct with a few integers.
but if you pass one thats already been initialized on the blockchain it will fail because it's trying to create an account thats already been created
depends on the account you pass into the program. if you pass an account that hasnt been initialized, it will initialize it
Or will there only ever be a single `my_account`?
Quick beginner question here:

Will `my_account` be created for every user that calls `initialize` on the program?
sure thing
thanks <@!350632015852208140> let me try this, and I'll make sure of that😅
No @ core devs
<@!889831471748108328> when you post questions here people will naturally answer these probably (irrespectible of the core dev) 😅  i would guess it's most likely an issue with some of your SSL certificates. can you check if you can pull from github normally, this looks more like a github issue rather than an anchor issue
I've googled this and found that many have faced this same issue, yet I'm unable to find solutions
hey [edited] can you guide me through this error?
https://docs.rs/anchor-derive-accounts/0.18.2/anchor_derive_accounts/derive.Accounts.html
Is there any place where I can read about the different **attributes** such as `#[derive(Account)]` etc
Does close account attribute and close account cpi call in token does that ? Any examples ?
That's much easier than what I've been doing thanks. I foolishly went straight to Uint8array(0)
I mean `Buffer.from([0])` etc.
just dropping this in case someone else would need it.
```
/**
 * BYTE   8-bit unsigned                          buf.writeUInt8()
 * SBYTE  8-bit signed                            buf.writeInt8()
 * BOOL   8-bit boolean (0x00=False, 0xFF=True)   buf.fill(0x00) || buf.fill(0xFF)
 * CHAR   8-bit single ASCII character            buf.from('Text', 'ascii') - Make 8-bit?
 * UNI    16-bit single unicode character         buf.from('A', 'utf16le') - Correct?
 * SHORT  16-bit signed                           buf.writeInt16BE() - @see https://www.reddit.com/r/node/comments/9hob2u/buffer_endianness_little_endian_or_big_endian_how/
 * USHORT 16-bit unsigned                         buf.writeUInt16BE() - @see https://www.reddit.com/r/node/comments/9hob2u/buffer_endianness_little_endian_or_big_endian_how/
 * INT    32-bit signed                           buf.writeInt32BE - @see https://www.reddit.com/r/node/comments/9hob2u/buffer_endianness_little_endian_or_big_endian_how/
 * UINT   32-bit unsigned                         buf.writeUInt32BE - @see https://www.reddit.com/r/node/comments/9hob2u/buffer_endianness_little_endian_or_big_endian_how/
 */
```
i'm surprised that the api is kind a sucks,
yeap doesn't like that 😅
`TypeError [ERR_INVALID_ARG_TYPE]: The first argument must be of type string or an instance of Buffer, ArrayBuffer, or Array or an Array-like Object. Received type number (0)`
Have you tried using just 0 for false, 1 for true?
trying to filter votes base on mecmp,

how can i encode boolean value in JS ?
Another query I had was, what is the difference between `<Account>`, `<AccountInfo>`, etc ? And are there any docs regarding these?
What does `#[derive(Debug, Clone, AnchorSerialize, AnchorDeserialize)]` do exactly here? Are there any docs I can refer??
```
#[derive(Debug, Clone, AnchorSerialize, AnchorDeserialize)]
pub struct ItemStruct {
    pub gif_link: String,
    pub user_address: Pubkey,
}
```
Ah okay, thank you so much!
that's cool I did'nt knew that. Thanks
If the account that lives at that PDA stores one of your `#[account]` structs, then doing `Account<'info, YourStruct>` checks this ownership automatically. Otherwise you could use the `owner = id()` attribute, or just check ownership manually in your instruction function (e.g. `.to_account_info().owner`)
Have to be slightly careful—who can change the data at a PDA depends on which program *owns the account that lives there*, not on which program *derived the address*.
It's the sum of the lamports that has to remain the same
Edited the response for clarity
So by same, you mean the runtime checks for the net difference to be zero right? Because technically we are changing the lamports of individual accounts
Solana run time enforces that the total lamports across all accounts is the same at the end of a transaction as at the start. So you would get an error and a failed transaction
thanks
yeah if you add the seeds array it is a pda
https://docs.rs/anchor-derive-accounts/0.18.2/anchor_derive_accounts/derive.Accounts.html
so ya I'm doing that but on program side I'm not adding the seeds attribute on top of that account ... does adding seeds ensure its a PDA ? (Talking in general case not the case of initing where we need to pass the seeds )
yeah you have to calculate the PDA with the seeds outside of the program, then pass that into the program along with the bump seed
Another not-so-anchor doubt, hope you guys don't mind 😅 \
I was following a tutorial by Paulx, and I came across this piece of code,
```
**initializers_main_account.try_borrow_mut_lamports()? = initializers_main_account
            .lamports()
            .checked_add(escrow_account.lamports())
            .ok_or(EscrowError::AmountOverflow)?;

        **escrow_account.try_borrow_mut_lamports()? = 0;
        *escrow_account.try_borrow_mut_data()? = &mut [];
```


and I was wondering what would happen if I didn't zero the `escrow_account`??
That wouldn't add up as we're only increasing one account's balance right?
so everytime I need to do something (apart from init the PDA) I need to have seeds attribute on top of account ?
in anchor afaik when you list out the accounts, for the PDA accounts you define the seeds and the bump, and when you pass the list of accounts in to the program, it will compare the one you pass in with the expected one
How can we check if PDA(account) passed inside the call is owned by current program ? Inside the program ?
the program can change the data via function calls, but its your job to make sure that only the intended users can call the function (based on whatever you decide)
Thanks. so if I write a function to change the data on PDA inside the program. The authority on PDA can call that function and change that right ? what's  permission constraints (authority) ?
just the program, so it can be changed via function calls according to the logic that you (or anyone, depending on the permission constraints) can call
Basic q  - can anyone can change the data on a PDA ?
if I'm trying to see if an account on the blockchain is initialized, and I have an `AccountInfo` object, is `data_is_empty()` sufficient for checking this?
what's the maximum seed length for PDA's ?
```
user.to_account_info().key.to_bytes().as_ref()
``` did the trick
coming back to this, 
how can i correctly refer to `PubKey` of the user in PDA account seed ?
sir can we ask help with this?
<@!134416332509675520>  <@!350632015852208140>  thank you so much guys 😅
```
[registry]
url = "https://anchor.projectserum.com"
```
what functionality in `Anchor.toml` does this provide?
```
seed: [
    <Buffer 70 72 6f 70 6f 73 61 6c 5f 61 63 63 6f 75 6e 74>,
    <Buffer 00 00 00 00 00 00 00 00>
  ]
``` 
does look like this btw ☝️

what a roller coster 😅

thanks! ❤️
Not 100% sure you can rely on this working if you only use 6 bytes tbh, I would try to use the full 8
To get the full 8 bytes
Yuck, the alternative in node is something dumb looking like `buf.writeBigInt64LE(BigInt(123))`
What the hell, what what a weird api 🤔
Oh, wtf, that api is way weirder than I thought
changed to `0, 6` worked 🎉
```
     RangeError [ERR_OUT_OF_RANGE]: The value of "byteLength" is out of range. It must be >= 1 and <= 6. Received 8
```
new error
Look in the program logs and see if the id that gets printed matches your declare_id
Given that struct probably because your `declare_id` doesn't match the running program's actual id
```let pool = anchor.web3.Keypair.generate()

  it('Is initialized!', async () => {
    // Add your test here.
    console.log(pool.publicKey)
    const tx = await program.rpc.initializePool({
      accounts: {
        pool: pool.publicKey,
        payer: program.provider.wallet.publicKey,
        systemProgram: anchor.web3.SystemProgram.programId,
      },
      signers:[pool]
    });
    console.log("Your transaction signature", tx);
  });```
```#[account]
#[derive(Default)]
pub struct Pool {
    pub total_deposited: u64,
    pub synth1: u64,
    pub synth2: u64,
    pub price1: u64,
    pub price2: u64,
}```
```#[derive(Accounts)]
pub struct InitializePool<'info> {
    #[account(init, payer = payer, space = 8 + 40)]
    pub pool: Account<'info, Pool>,
    #[account(mut)]
    pub payer: Signer<'info>,
    pub system_program: Program<'info, System>,
}```
Assuming you're still using `.to_le_bytes` (change if using to_be_bytes, endianness needs to match)
anyone know why I get this error ? ```     Error: 167: The given account is not owned by the executing program
```
And then use that buffer in the findProgramAddress part.
Try doing something annoying like
```.rs
let totalProposalAccountBuf = Buffer.alloc(8);
totalProposalAccountBuf.writeUIntLE(theTotalCount, 0, 8);
```
The client is using `toBuffer`, but that doesn't return 8 bytes like you're doing in the program when you explicitly use a u64
I think the way you're specifying the proposal_id seed is wrong (it's different between the client and program)

bump seems like correct,
you might wanna print out the bump btw
``` 
#[account(
        init,
        payer = purchaser,
        space = 64 + 64 + 64 + 64 + 64 + 64 + 64 + 64 + 8 + 8 + 8,
        seeds = [purchaser.key.as_ref(), b"bondInstanceAccount"],
        bump = {msg!("bump be {}", _bump_bond_instance_account); _bump_bond_instance_account}
    )]
``` 
you can do it like this. then you can double check that the bump is read correctly. if it is read correctly, it should be the rest of the seeds for sure
it's failing at adding the proposal test.
but its not relevant for the issue we're discussing, separate function anyways..
i actually haven't got the part testing voting though
yh thats true, but here it doesn't, no?
But not sure I'm reading the right thing 🤔 and my internet is trash right now 😦
I think if I'm reading it right that part is ok (instructions just have to match left to right up until you don't care anymore—don't need to match exactly)
Did you ever find a solution to this? I'm having the same issue.
that could lead to the bump being mis-read (serialzation could be off). not sure if this is it, but also sth that i think could cause it (at least does so for me sometimes)
also I think you have a small bug here:
``` 
proposal_id: u64, vote: bool
```

``` 
#[derive(Accounts)]
#[instruction(proposal_account_bump: u8, proposal_id: u64)]
pub struct VoteForProposal<'info> {
    #[account(mut)]
    pub base_account: Account<'info, BaseAccount>,
    #[account(mut, seeds = [b"proposal_account".as_ref(), proposal_id.to_be_bytes().as_ref()], bump = proposal_account.bump)]
    pub proposal_account: Account<'info, ProposalAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
}
``` 
the instructions dont match the arguments of the function, if im not wrong
```
#[derive(Accounts)]
#[instruction(proposal_account_bump: u8, proposal_id: u64)]
pub struct AddProposal<'info> {
    //...
    #[account(init, seeds = [b"proposal_account".as_ref(), proposal_id.to_le_bytes().as_ref()], bump = proposal_account_bump, payer = user, space = 10240)]
    pub proposal_account: ProgramAccount<'info, ProposalAccount>,
    //
}
```
To match how you're calculating the seeds on the rust side
Ok, I think the issue is actually that `.toBuffer()` just doesn't do the right thing, you need to explicitly make it be length 8 somehow
can you print what console.log prints, and what you have as the rust constraints?
it's matches
You can verify this by printing out that pda's address (use `.toString()` on it) and seeing if it matches the error message about signer privilege escalated
That's the part that is likely failing, because you're mismatching the seeds between client and server (that's my guess)
You're signing implicitly within the program with you say `init, seeds = [...], bump` etc.
```
await program.rpc.addProposal(
      new anchor.BN(accountBump),
      account.totalProposalCount,
      "Test Title",
      "Test Description",
      {
        accounts: {
          baseAccount: baseAccount.publicKey,
          proposalAccount: proposalAccountPublicKey,
          user: provider.wallet.publicKey,
          systemProgram: SystemProgram.programId,
        },
      }
    );
``` 
at the stage i'm not signing at all 😅 but when i put baseAccount it it says incorrect signer, and don't have signer account for PDA
Not sure what doing bignum.toBuffer() actually does
Maybe you need to use `to_le_bytes()` (little-endian versus big-endian)?
`    GRSuXzC9hJeyQnPbpzVFLVDX6ZcZp6tgk2CgtMD7VEc2's signer privilege escalated
` means you're not signing correctly somehow
the full error is like this,
```
Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account 
    Program HRNkDCeaArkBn2mM3pMa1JwAMmgaNgWpXnPYeNq5eFvg invoke [1]
    GRSuXzC9hJeyQnPbpzVFLVDX6ZcZp6tgk2CgtMD7VEc2's signer privilege escalated
    Program HRNkDCeaArkBn2mM3pMa1JwAMmgaNgWpXnPYeNq5eFvg consumed 200000 of 200000 compute units
    Program HRNkDCeaArkBn2mM3pMa1JwAMmgaNgWpXnPYeNq5eFvg failed: Cross-program invocation with unauthorized signer or writable account
Translating error SendTransactionError: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account
    ......

 {
  logs: [
    'Program HRNkDCeaArkBn2mM3pMa1JwAMmgaNgWpXnPYeNq5eFvg invoke [1]',
    "GRSuXzC9hJeyQnPbpzVFLVDX6ZcZp6tgk2CgtMD7VEc2's signer privilege escalated",
    'Program HRNkDCeaArkBn2mM3pMa1JwAMmgaNgWpXnPYeNq5eFvg consumed 200000 of 200000 compute units',
    'Program HRNkDCeaArkBn2mM3pMa1JwAMmgaNgWpXnPYeNq5eFvg failed: Cross-program invocation with unauthorized signer or writable account'
  ]
}
```
the extended error code usually tells u if its a signer-, or write-issue
is there more to the error code? either some account is not mutable, or youre not passing the relevant account as a signer, would be my guess
Think your best bet to learn this stuff is to run the code!
and was curious
i wasnt running the code was just looking a example on spl program
Try removing the clones and see what error message you get 😉
any idea as to why do we clone the accounts refrence inside invoke even though the parameters are already a refrence ?
🥲 <@!134416332509675520>  can you help me to debug this ? 
https://github.com/Necmttn/anchor-voting/blob/pda_cpi/anchor-voting/programs/anchor-voting/src/lib.rs
https://github.com/Necmttn/anchor-voting/blob/pda_cpi/anchor-voting/tests/anchor-voting.ts
i have no idea wth is wrong with it 😅
i still got the 
```
Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account
``` 
error.

```
    const [proposalAccountPublicKey, accountBump] =
      await anchor.web3.PublicKey.findProgramAddress(
        [
          Buffer.from("proposal_account"),
          account.totalProposalCount.toBuffer(),
        ],
        anchor.workspace.AnchorVoting.programId
      );
    await program.rpc.addProposal(
      new anchor.BN(accountBump),
      account.totalProposalCount,
      "Test Title",
      "Test Description",
      {
        accounts: {
          baseAccount: baseAccount.publicKey,
          proposalAccount: proposalAccountPublicKey,
          user: provider.wallet.publicKey,
          systemProgram: SystemProgram.programId,
        },
      }
    );
```
and  this is how i call it
works like a charm!
alright, thx! 🙂 will play around with Box
So yeah, your program itself is fine, just gotta be a little more careful with the stack
That means you're running out of stack space 😮‍💨 (Each stack frame in solana is only 4kb, so you can run out of space pretty easily.) Easiest trick to fix this is to just stick a Box around some of your Accounts: `the_account: Box<Account<'info, TheStructType>>`
ahhh missed that. thank you so much!
dafuq 😅  also, how do you know all this man xD
I guess it's the accounts then actually.

```
Transaction simulation failed: Error processing Instruction 0: Program failed to complete 
    Program Bqv9hG1f9e3V4w5BfQu6Sqf2Su8dH8Y7ZJcy7XyZyk4A invoke [1]
    Program Bqv9hG1f9e3V4w5BfQu6Sqf2Su8dH8Y7ZJcy7XyZyk4A consumed 2320 of 200000 compute units
    Program failed to complete: Access violation in stack frame 3 at address 0x200003fe0 of size 8 by instruction #14251
    Program Bqv9hG1f9e3V4w5BfQu6Sqf2Su8dH8Y7ZJcy7XyZyk4A failed: Program failed to complete
``` 
this error, and also the fact that this error goes away when i remove a single account from the context
The size limit for an individual program is pretty big, like 10mb 🤔 What makes you think you're running out of space?
The size limit for your program? Or an individual account?
also, is there any good resources / guide / tutorial or page on how to split up a solana program into multiple solana programs? I think I am hitting the size-limit for my program
You want to derive it from your own program's id, so that your own program can sign for that address when you initialize an account there (creating an account at an address requires that that address sign—in this case because it's a program-derived address, it's up to your program to sign for it)
Ah, your problem is that you derived that address on the client using the *system program*'s id, not your own program's id (you need to use your own program's id)
The actual literal type of `b"foo"` is `[u8; 3]` (the length goes right in the type)
yeah that worked, thanks. i wonder why that happens though
Rust type inference isn't always super smart, that's because you didn't add a `.as_ref()` to the first hard-coded string
Nope. That finds an address that is *derived* from that program id. It's just an address, and addresses don't have owners (accounts have owners). Whether an account that lives there is owned by the program is independent from whether the address is derived from the program.
Hi all, I'm trying to understand how to use PDAs in an Anchor Program, and wrote a barebones Program to test. When I try to initialize from client though, I get a CPI error: `Cross-program invocation with unauthorized signer or writable account`. I posted more details at https://stackoverflow.com/questions/70138221/proper-way-to-initialize-pdas-within-the-solana-anchor-framework
thanks, ill do that
anchor docs are a good place to start learning
just start something. anything works. write a simple contract and see if you can write some tests for it and run them on localnet
sorry if i sound noobish 😐
what type of project would cover most of the base knowledge?
depends on your goals. if you want to build frontends, sure. you can, however, just stick to writing only smart contracts/backends services too though
Hi, is front-end knowledge really required to get the hang of web3 development? (e.g. react/js) My goal is working on web3 related projects, but im a system programming enjoyoor
im unsure why it expects 13 bytes as opposed to 32. any thoughts?
Hello how do you connect anchor to phantom wallet?


//////////////////////////////////////////////////////////////////////////////////////////

and then set the owner to the program
I see, so I'd use https://solana-labs.github.io/solana-web3.js/modules.html#CreateAccountParams
Regardless of address type
Mutating an account is *only* possible for the owning program
b/c this account is not a PDA
Yes, but you'd have to do the same ownership-setting for a PDA too
I see, so I would have to create this external account & then set its owner to my program?
You need the signature when you create the account, but not necessarily ever again
It's up to your program whether it requires the signature (it's free to mutate accounts it owns whenever it wants—any signature is purely a matter of politeness etc.)
That's what I'm asking about—nothing actually requires that signature
so the user must have the external account's keypair
but this means the user must have the ability to provide the external account's signature
*give the external account's signature
if the game data is stored in an external account and I want to mutate the data in the external account, then I need to sign the data
I would suggest just trying it/do some source-diving
Mm, don't have an example off hand but you can see some by searching the anchor codebase
thanks. yeah if you have example in mind feel free to send
`anchor_lang::solana_program::system_instruction`
where is `system_instruction` imported from>
i suppose initializing an account is the one im thinking of off the top of my head
The most common one you'll see is `system_instruction::transfer`, does that count? What are you wondering about more specifically?
Why do you need to keep signing? Not sure I'm following what you're trying to do
Does anchor support optional arguments for instruction calls?
I feel like this is a stupid question but is there an example that shows a CPI for the system program? like for initializing an account or somesuch
Hopefully, this works
- the PDA stores a public key under `storage_account`
- `DoGameAction` account policy checks that `storage_account` is signed
Hmmm .. so how would I implement this pointer strategy?

Current plan looks like:

```
#[account]
pub struct GameState {
    bump: u8,
    storage_account: Pubkey
}

impl GameState {
    fn space() -> usize {
        // Ident
        8 +
        // bump
        1 +
        // Pubkey
        std::mem::size_of::<Pubkey>()
    }
}

#[derive(Accounts)]
pub struct DoGameAction<'info> {
    #[account(seeds = [], bump = game_account.bump, has_one = storage_account)]
    game_account: Account<'info, GameState>,

    #[account(mut)]
    storage_account: Account<'info, Storage>,

    #[account(mut)]
    from: Signer<'info>,

    #[account(mut)]
    to: AccountInfo<'info>,


    system_program: Program<'info, System>,
}
```
& thus could submit a malicious transaction that is signed by this keypair, which would mutate the account data
but if the game runs in users browsers, then every user will have access to this keypair
that means on every transaction I need to sign using the keypair for this external account
for example, let's say this external account is the game storage
<@!739012341588557895>  <@!134416332509675520>  -- one problem with using an external account is that theoretically any malicious attacker could modify it right?
Deploying to testnet takes 1.47 sol right now, that's pretty expensive for deploying to prod
(also, are there docs I can find on this -- I only find a mention of the 10MB rent limit)
oh, that's unfortunate! Is this a limitation of Anchor or just a limitation of Solana in general
how to get program id of current program?
gotcha! Thanks a lot <@!134416332509675520> !!
And will error if the account didn't sign
Yeah, that's what `Signer` does under the hood: it just checks that the account signed the tx
so to clarify further, with `Signer` in place, even tho the instructions in the handler dont need that signer's signature (lets say on transfer and stuff) , the program will still require signer to sign to pass
Don't leak that key lol
Yep 🙂
You're asserting the address has to be the admin pubkey, *and* checking that they signed
ofc as long as admin doesnt leak private key
Yep
ohh so actually this is already safe enough
Ah, you're already doing that signature check when you say `Signer<'info>` (anchor will do it for you)
how do I impose signature check in the handler tho?
You'll need that signature to verify that it really is the admin
Yep!
is it possible that attack somehow gets the admin's publickey and try to access that handler?
Yeah, there will still be a pop-up no matter what
I guess my question is
Ah, ok
in fact it looks something like 
```
#[account(mut, address = Pubkey::from_str(constants::ADMIN_PUBKEY).unwrap())]
pub manager: Signer<'info>,
```
Also not totally sure what you're asking though 🤔
If the user is submitting the transaction you'll get the phantom popup no matter what (they have to pay for to submit the tx regardless of whether anything else needs to sign)
my usecase here is that I'd like to define n admin handler, whereby only admin can access, and therefore the `Signer`, but in the handler it's just some program state change, not really requiring the admin's signature over there
Hi got a question,  if in a `#[derive(Accounts)]` struct, I define a Signer, but in the whole instruction there is no signer's signature needed, in this case will the sign pop up still show with the browser wallets?
 ```
pub signer: Signer<'info>,
```
I imagine you could also use the `solana-keygen` command
i litereally init new project to get a fresh one 😅
that could work forme
Not sure if there's an easier way, but you could delete the old one (inside target/deploy). Running anchor build again will generate a fresh one.
how can i generate a new programId ?
Take a look! I think the source will explain itself
Not yet, just found it on the Metaplex's code
Have you tried looking at its source code?
it's the same as AccountInfo but more explicit in that anchor doesn't check if the account is owned by the program
Hi <@!134416332509675520> 
Could you explain me about the `UncheckedAccount`?
✨ Hello hello ! What would be the best way to fetch the balance of an associated token account? I tried .getBalance but obv it's giving me the accounts' SOL balance
ok thanks
If you want to close an account that's owned by a different program, you'll have to look up how that program lets you close accounts (you won't be able to do it yourself, you'll need to ask that program to do it for you)
Yep, the issue is about ownership, *not* PDAness.
So I tried it out and it was giving me this error -> Error processing Instruction 0: instruction spent from the balance of an account it does not own
That attribute will work whenever the *account* is owned by your program (as usual, the PDAness is irrelevant, it's all about which program owns the account)
Have you tried it?
Yep, that's my understanding
Is it because Solana required those accounts to be specified prior to 1.7.0? And it is a relic of that?
Oh, why do we need to pass `rent` sysvar for initializing `TokenAccount`, but for anything else we are allowed to not specify it.
Does this attribute works on PDA to close it  -> #[account(close = <target>)] ?
the PDA is kind of acting like a pointer I guess
yeah just storing the larger accounts public key so that later, when someone sends the PDA and the larger account to your program in an instruction, you can verify they belong together, essentially just preventing someone from sending in some malicious game data that doesn't actually correspond to the PDA
Thanks for your explanation
Yup 🙂
And then verify that they really are creators in the instruction handler
Ok, then yes, you'll need to pass them in as accounts
The tokens will be distributed to the nft creators like the royalites
Depends on what you're doing
But the data etc. is stored that one metadata account
So I don't have to add the creators accounts on the context?
If you need to pass a creator account for some other reason, then yeah, you'll need to pass it in
Not sure what you mean?
But on the Solana program, the `accounts` array should contain all accounts
No, they're stored in the metadata account itself.
These `creators` should be listed on the context as well?
Thanks 🙏
I'm depending on metaplex via git since their cargo lib seems out of date:
```.toml
metaplex-token-metadata = { git = "https://github.com/metaplex-foundation/metaplex", features = [
    "no-entrypoint",
] }
```
Not sure, I don't use metaplex, but something like this will probably work:
```.rs
        let metadata = metaplex_token_metadata::state::Metadata::try_from_slice(
            *ctx.accounts
                .the_metadata_account
                // .to_account_info()
                .try_borrow_data()?,
        )
        .map_err(|_| ProgramError::InvalidAccountData)?;

        let creators = metadata.data.creators;
```
So, if you want a really big account, > 10kb, it currently has to live at a keypair address.
This particularly effects accounts that live at PDAs because they *have* to be created via CPI (it's not possible to issue a separate instruction from the client, because the PDA address can't sign from there—only the program can sign for it, hence the need to CPI)
I'm catching up on your thread, but sounds like you're running into an annoying limitation: when you create an account via CPI (so, anytime you use `init` in anchor), you're limited to 10kb accounts, not 10 mb 😦
Thank you! It is just that it was named `owner` in original `spl_token`, so it got me a little confused
token::authority is who is supposed to "own" the tokens in that account (the account itself is owned by the spl token program)
yeah, authority is the owner
https://docs.rs/anchor-spl/latest/src/anchor_spl/token.rs.html#116
Sorry for asking again, but what exactly `auhtority` means in this context? Is it an `owner` of initialized `TokenAccount`? Or is it a `mint`s authority? Why would I need to pass it though, I thought it isn't needed in `InitializeAccount` instruction here? https://docs.rs/spl-token/3.2.0/src/spl_token/instruction.rs.html#63
Hi <@!134416332509675520> 
How's your weekend?
Could you share the piece of code to read the metaplex nft's metadata? (especially creators array)
which is not amazing
although, if we want to mutate data in it -- we'll need it to sign every transaction
and also, to clarify, when we store the (larger) account in the PDA -- that just means storing its public key
oh these docs are good, I'll read them over - thanks !
There's also one for fetching spl token balances in that section somewhere
Should be this https://solana-labs.github.io/solana-web3.js/classes/Connection.html#getBalance
from an account
yeah, for example in a test I might want to see that in-fact some money was deducted
sol balance?
a slightly unrelated question: Do you know how to get the balance of a public address (user or program) w/ web3.js?
no worries man, good luck haha
thanks for the help ❤️
as you are right that no one else will even know I've deployed a program
I think I'll take the risk of running the code first
Instead, if this works for your usecase, you can create the game state account, then use its public key as one of the seeds for the PDA, that way it wouldn't be a race for first to init the one global PDA, because the pda for each game state account would be unique
yeah I'm not entirely sure the best way to deal with that, usually if I'm writing a program I don't want anyone else to use, then I put in an init_program instruction where i set the owner of the program, who then is the only one allowed to use the other owner instructions. Of course you run the risk of someone beating you to calling this function, but then when you first deploy a program no one even knows you have, so I feel like that can usually be prevented
but I think it's the right direction; probably the best thing to do is to hard-code in an address into the contract
this is pretty reasonable -- I think it leaves the hole that if someone who is not you initializes the PDA first then they'll have control
similar to here:  https://project-serum.github.io/anchor/tutorials/tutorial-2.html#defining-a-program
If you also store the public key of the person who initialised the PDA in its own account data, then in your anchor program endpoints, only allow changes to the game state account public key, if the signer is the person who initialised the PDA
Thanks fayd I finally understand
if you put some access control on the initialisation endpoint in your anchor program, that could maybe fix that issue, i.e. make yourself the only one who can init the PDA and assign the game state account
if you can create another one, then anyone else can also create another one & screw you over
I think you only want the initialization to be done once though
I think you could store data in a wallet account as you've got the private key, correct me if I'm wrong anyone
Ahh I see. But what I dont get about createAccountFromSeed is that it doesnt give you a key pair but a public key
yeah you could generate an account to store data in using the createAccountFromSeed or you could use a PDA account where one of the seeds is the user's publickey
Are user wallets also accounts?
Yeah I want to be able to store user data based on the wallet pubkey they pass in
Solana leaves a bit of flexibility here, which I know can feel a bit arduous coming from solidity. It kind of depends on your use-case and how you want to do it. You're wanting to store data for each user, like you would in a mapping in solidity?
If someone were to create the account with the wrong size you could just create another one
I mean you would initialise the account (*) and then pass it into your program with your pda, where your pda would get initialised and set the account (*) as it's corresponding game data account.
I promise Ill help once I learn all this shit Lmaoo
(with, for example, a smaller size)
and if someone initializes before me, then I'm screwed
I guess a downside of the workaround is now I need to initialize a game data account w/ a certain size
thanks; I might have to try this -- I wonder why the limitation exists in the 1st place
then you just check that the correct data account is being passed in by checking if its publickey is the same as the one stored in your pda
you could break your game state data up into 2 accounts. In the PDA's account data you could store the public key of the other account that holds your game data
I remember trying it before a while ago, and I think creating account data for a PDA address can only be done inside the program
actually, it's entirely possible I can -- I'm just not sure
Thanks. This does seem like a good idea -- alas, I need to create a PDA specifically, & I'm not sure if I can create that using web3.js
Is createAccountFromSeed what I want or could I create the account in the solana program?
In solidity it would just be a key/value map basically
Im having a hard time wrapping my head around creating an account based on a user’s wallet and being able to find and modifying that account later
https://solana-labs.github.io/solana-web3.js/classes/SystemProgram.html#createAccount
Based on "SystemProgram::CreateAccount data size limited to 10240 in inner instructions" it just sounds like the anchor devs have capped the size to 10kB when creating an account inside your anchor program
as a work-around you could create the account outside of the program
oh touche, I was thinking in kB
I agree, but I'm still confused since 10240 bytes is less than 10MB
ah right yeah that size is in bytes rather than bits I'm pretty sure. For example a u64 takes up 8 units of space in an account, so it must be bytes
https://docs.solana.com/developing/programming-model/accounts#creating
that's what I was thinking but an account can hold 10MB in Solana
I think this is because 10240 exceeds the maximum accounts size limit, as you said 10MB
Thank you!
```
impl GameState {
    fn space() -> usize {
        10240
    }
}
```
And when I exceed the number 10240, Solana throws an error -- even though I know accounts can be up to 10mb in size
I have the following account policy (not sure what to call it): 

```
pub struct CreateGameState<'info> {
    #[account(init, payer=user,
      space=GameState::space(),
      seeds=[],
      bump=bump)]
    pub game_account: Account<'info, GameState>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```
More context:
could that be the issue?
i did put the wallet in my store, and am getting this using it on another component
when i log the wallet i see the functions
i keep getting ``this.wallet.signTransaction is not a function``
How do I update my anchor version within my project?
Does anyone know what "SystemProgram::CreateAccount data size limited to 10240 in inner instructions" error means?
Hmm yep it looks like the current anchor version I'm using is 0.17.0, and tutorial uses 0.18.2
Might be because tutorial is using a different anchor version 🤔
I have the following function, essentially copied from the basic-1 Anchor tutorial:

```
    pub fn init(
        ctx: Context<InitializeShowroom>,
        uuid: String,
    ) -> ProgramResult {
        let showroom= &mut ctx.accounts.showroom;
        showroom.uuid = uuid;
        Ok(())
    }
}
```

Accounts for this endpoint:
```
#[derive(Accounts)]
pub struct InitializeShowroom<'info> {
    #[account(init, payer = payer, space = 8 + 6)]
    pub showroom: Account<'info, ShowroomMetadata>,
    #[account(mut)]
    pub payer: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```

When calling this function with the following code in tests:

```
  const showroom = anchor.web3.Keypair.generate();
  const uuid = anchor.web3.Keypair.generate().publicKey.toBase58().slice(0, 6);
  const payer = provider.wallet.publicKey;

  const res = await program.rpc.init(
    uuid,
    {
      accounts: {
        showroom: showroom.publicKey,
        payer,
        systemProgram: SystemProgram.programId,
      },
      signers: [showroom],
    },
  );
```

And I get the following error: ` Error: 167: The given account is not owned by the executing program`

It seems like the showroom account isn't owned by the current program (which I thought would be the expected output). Changing the type of the `showroom` account from `Account<'info, ShowroomMetadata>` to `ProgramAccount<'info, ShowroomMetadata>` worked though.. Any ideas why?
```
Can Anchor handle vectors with structs / tuples inside of them?
```
#[account]
pub struct GameState {
    bump: u8,
    pixels: Vec<PixelState>,
}

#[derive(Clone, BorshSerialize, BorshDeserialize)]
pub struct PixelState {
    owner: Pubkey,
    color: u8,
    k: u8,
}
```

I'm getting a 

```
IdlError: Type not found: {"type":{"defined":"PixelState"}}
    at Function.fieldLayout (/home/vedantroy/Desktop/solana-pixels/contracts/pixels/node_modules/@project-serum/anchor/src/coder/idl.ts:89:19)
    at Function.fieldLayout (/home/vedantroy/Desktop/solana-pixels/contracts/pixels/node_modules/@project-serum/anchor/src/coder/idl.ts:60:22)
    at /home/vedantroy/Desktop/solana-pixels/contracts/pixels/node_modules/@project-serum/anchor/src/coder/idl.ts:117:28
    at Array.map (<anonymous>)
```
I ended up changing the file extension from js to ts and it worked.. I probably missed the underlying error but thank you for the response
Does `#[account]` work with struct that contains a `Vec<Foo>` where `Foo` is another simple struct?
is there a way to return a bool from an anchor function? rather than just Ok(())
Do anyone knows an example to close a PDA ?
try `[Buffer.from([bump])]`
no. to set it to limited you need to remove the mint authority. once the mint authority is removed there is no way to set it back
Hi everyone! Is there any way of setting mint supply from limited to unlimited with web3 ? Sorry about this unrelated question. Thank you
sure can initialize at least
```
#[account(mut)]
    pub signer: Signer<'info>,
pub mint: Account<'info, Mint>,
#[account(
        init,
        seeds = [b"YOUR_SEED".as_ref(), mint.key().as_ref()],
        bump = bump,
        payer = signer,
        token::mint = mint,
        token::authority = initializer,
    )]
    pub token_account: Account<'info, TokenAccount>,
```
I keep on trying to deploy a program to devnet using `anchor deploy` (and modifying my Anchor.toml), but the deployment gets stuck at 4.2%. Is there anything I can do on my end to fix this?
You can use the programId as a seed, but you can also just have no seeds & that's fine since the programId is included by default when creating a PDA.
But I thought there were some problems when one tried to assign None to Some or the other way around?
Good day! Can I initialize and close `TokenAccount`s inside `#[derive(Accounts)]` structure
is it possible to use the programId as a seed for a pda with anchor? not sure how to access the programId when using anchor
strange - i was trying from the root of an anchor initialized directory and calling a program defined in the lib.rs file created by anchor init
Workspaces are available in an anchor workspace. So, if you have a cli folder with your command line scripts, that gets access to it.
ahh, i think i just figured this out - workspaces are only available in tests. sorry
i'm setting ANCHOR_WALLET and ANCHOR_PROVIDER_URL the same in both invocations
when i try to use `const program = anchor.workspace.<workspace_name>` and then call `program.rpc.<function>`, rpc is undefined... but if i hardcode the reading and parsing of the IDL JSON for the same program, manually set the program ID and call new `anchor.Program(...)`, the same function works fine. is there something simple i should be checking to make the workspace discovery work correctly?
Oh woah, i didn't realize that would be the thread title 🙂
Are there docs on how to calculate the sizes for an Option?
Yes.
I guess a follow up question here is: Does Anchor have the ability to serialize types like `Option`?
Is there a way to return a value from a solana method -- for example a boolean, using anchor?
maybe Anchor can auto-derive it?
I'm sure this calculation is incorrect b/c I need to consider that I have an `Option<Pubkey>` instead of just a `Pubkey`

I.e.
Does anyone know how to calculate the space required for an Anchor account?
so I do think that `createProgramAddress` is not designed to take the bump

<@!134416332509675520>  -- I tried re-deriving program key using the bump but it complains with the type error:
is transaction simulation how wallets like phantom give a preview of how much a transaction will cost before you do it?
I guess this is one reason for transaction simulation
Yep 😬 Be careful out there!
one interesting thing I'm noticing about Solana is that it seems like if you sign a transaction where your account is marked as mutable (the program can deduct Sol), the program is allowed to deduct any amount of Sol from your account. I.e: there's no fine-grained method to say "I only want to let this program deduct 5 sol from my account instead of all 10" ... or maybe there is, but it's not as straight forward as ethereum I think?
I'm not sure how you'd be able to do that, since if the program knew some private key to do the decryption with, then that private key would eventually leak (the program compiled code is public/anyone can download it)
cool cool -- thanks 🙂 , I guess it doesn't matter too much since `findProgramAddress` isn't checking if the program address is already an existing address in Solana (if that's even possible), so if I call it w/ the same seed array it will always return the same bump
Yep 🙂
It's the last value in the seeds array
*last value
oh, should the bump be the values value in the seeds array?
You can actually see this by looking at the implementation of findProgramAddress—it calls that function successively with different bumps, 255, 254, etc.
That signature is just a little misleading, it takes the bump too
Maybe I'm looking at the wrong type signature?

Hi, some idea in how to store something encrypted in an account and decrypted it (on-chain) in the next invocation?  For example: someone uploads a number, and it is saved encrypted in an account, a second user invoke the program and get the number. The second user can't get the number only by fetching (he has to call the program)
If you just pass your seeds you'll get a different address
Nope, gotta pass the bump nestled along with the seeds
that function does not take the bump
Though tbh from the client I would just probably be lazy and re-find it
That takes the seeds *and* the bump, no looping
Then I guess you could use `anchor.web3.PublicKey.createProgramAddress`
Ah, sorry, you already know the bump
I see, so we just re-do the iteration to find the bump each time
I.e, let's say the user is visiting a page for a 2nd time -- I'd need to reconstruct the public key
await anchor.web3.PublicKey.findProgramAddress([], program.programId)
Does anyone know how to create a Program Address in anchor, if I already have the bump (& my seeds array is empty).
You're passing the system program correctly 👍
Oh got it -- the issue was that I needed to mark the account I was deducting lamports from as mutable
Hello everyone! I have this error while running an anchor test (0.18.2) with solana-cli 1.9.0: 
`failed to verify account 58qkGKGgUKo31qyWnL3oCeYaUZEM9KnUxMaDYZxEmTnw: instruction illegally modified the program id of an account`. 
I discovered with  a lot of luck that I can solve it if I put 6000 or 8000 or 10000 in space instead of 9000 here:

`#[derive(Accounts)]
pub struct StartStuffOff<'info> {
  #[account(init, payer = user, space = 9000)]
  pub base_account: Account<'info, BaseAccount>,
  #[account(mut)]
  pub user: Signer<'info>,
  pub system_program: Program <'info, System>,
}`

Any ideas why and how I could have discovered this by myself? The error is quite difficult to understand.

Thank you!!!!
which hmm ... I'll look into this
And now anchor is complaining with: " Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account"
<@!163857206721249280>
the user has to be a `Signer`, not sure what that looks like from the JS side
Hmm, maybe the issue is that I'm passing in something incorrect for the `user`
if I'm not mistaken, your approach is correct. The programId is of type PublicKey, so I think that is what you're looking for
my code looks like this -- but I'm pretty sure passing in the `programId` is incorrect
For context:
I think it's expected to be an `anchor.Address` in JS/TS, but not sure how to generate one of those for the system program
Here, I need to pass something in from JS but it's unclear what
I.e.
Does anyone know how to pass the system program as an input to anchor?
yep doing that for now 🙂
a buffer of bytes is generally used to store strings.
hello, is there a way to generate typescript type definitions from an idl file? all I have is a bunch of `IdlTypeDef` and `IdlTypes` stuff but that's not telling me which fields are in an account
What's the best way to implement string size limits (in account data) ?
A remaining question is how to pass in the address of the system program but I think I can figure that out !
This may be a noobie question, but I've seen references to "permissionless cranks" - what exactly does this mean? Is it just a program that's on-chain running in an infinite loop and calling a contract's function each iteration?
Got it -- this all makes sense, I was confused because the generated typescript types are IDL, whereas the actual typescript types are created through some complex higher order types that accept the IDL as input
Every account you declare in the `#[derive(Accounts)]` struct has to be correspondingly passed in from the client in that rpc call
The general rule is that *any* account your program needs access to has to be passed in from the client.
Just to double check I'm reading that right, you need to make sure your actual instruction handler function matches whatever is in `#[instruction(...)]` (or at least `instruction(...)` needs to mach left-to-right up to whatever arguments you care about)
You need to `findProgramAddress` on your end and pass it as an account, so `gameAccount: theGameAccountFindProgramAddressResult`
I'm assuming the only things I need to pass in are actual accounts & stuff mentioned in `#[instruction(...)]`
<@134416332509675520> -- I guess my question is for PDAs, do I still need to generate the pub key on my end , or should I just pass in the seeds + bump into anchor
(You need to declare those `#[instruction(...)]` args to match your actual instruction functions arguments exactly, at least going left to right)
In this case it looks like you're expecting the first arg to the instruction to be the bump for the global game state (so that 0 you're passing is nearly guaranteed to be wrong)
u64 and up requires a bignum (js numbers are doubles under the hood, so they can only represent integers up to 2^53—afterwards the floating point gap is too big)
For a u8 up to u32, you can use a regular old javascript number
Accounts are always passed as pubkeys (so either a keypair's public half or a PDA, etc.)
the first argument must be a number
for example, I presume that since there's an `#[instruction(bump: u8)]`
instructions & accounts both
Which ones? The instruction function arguments?
<@!134416332509675520>  -- do you know how to determine what the types of the frontend should look like given the anchor code?
Mm, not sure, are you positive that's where the error is happening?
Ah, need to cd programs/your-prog-name and run it in there
Cargo expand doesn't seem to work on Anchor programs b/c of a virtual manifest issue?
Trying to run the tests on an Anchor program with the following code:

```
import * as anchor from "@project-serum/anchor";
const { SystemProgram } = anchor.web3;

describe("basic tests", () => {
  // Use a local provider.
  const provider = anchor.Provider.local();
```

Getting the error `TypeError: Cannot read property 'local' of undefined`. However, when I print out `anchor` variable it has the `Provider` attribute as well... Any ideas here?

Anchor.toml for reference:

```
[registry]
url = "https://anchor.projectserum.com"

[provider]
cluster = "localnet"
wallet = "~/.config/solana/localnet.json"

[programs.mainnet]
nft_candy_machine = "cndyAnrLdpjq1Ssp1z8xxDsB8dxe7u4HL5Nxi2K5WXZ"

[scripts]
test = "yarn run mocha -t 1000000 tests/"

[workspace]
members = ["nft-candy-machine"]
```
You can get pretty far by `cargo expand`-ing tiny anchor programs too, and seeing if you can follow the generated output
Yeah, that's basically what I did 😬
maybe I just need to read through the Solana rust crate?
thanks! this is really helpful -- if there's an original source where you got all your info from, i'd be happy to take a look, so I can stop sending so many questions
Haven't actually tried running that but think it should be ok 🤞
You can try doing something like this:
```.rs
// the instruction function
    pub fn transfer(ctx: Context<Transfer>, amount: u64) -> ProgramResult {
        let ix = anchor_lang::solana_program::system_instruction::transfer(
            &ctx.accounts.from.key(),
            &ctx.accounts.to.key(),
            amount,
        );

        anchor_lang::solana_program::program::invoke(
            &ix,
            &[ctx.accounts.from.to_account_info(), ctx.accounts.to.clone()],
        )
    }

// The Transfer accounts struct
#[derive(Accounts)]
pub struct Transfer<'info> {
    #[account(mut)] // mut b/c we're gonna take their money
    from: Signer<'info>, // signer b/c gonna take their money
    #[account(mut)] // mut b/c gonna give them money
    to: AccountInfo<'info>, // doesn't need to sign though
    // need to pass the system_program because we're invoking it
    // and solana is just annoying like that
    system_program: Program<'info, System>,
}
```
(thanks for all the responses by the way)
Ahh -- this does make sense. I was wondering if there's any demo code / post explaining this?
If the source account is a user, then presumably the owning program for their account is the system_program, so you have to ask the system_program to do the transfer for you, with `system_instruction::transfer` (and the source account will need to sign)
Yeah, this is slightly funny in solana because it depends on which program owns the account that needs to send you sol, because in general whenever you want to mutate an account's data or spend its money, you have to ask its owning program to do it for you.
I see a lot of things in Anchor about how to mutate data; but not how to move Sol
Thanks; another quick question: How do I actually get the user to send Sol to me? I.e in a bidding, we want the person who calls the method `bid` to place of a bid, of let's say "1 sol", and if the bid is higher than the current value, 1 sol will be debited from their account
As far as I understand it, this isn't as accessible to you in solana as it is in ethereum (would love to be corrected though). Usually what you'd do instead is have some designated `Signer<'info>` account that is the intended "do-er" of the transaction (the fact that they signed indicates they weren't just randomly passed in by the client)
I think the specific question is: How can I get the account address of whatever is calling my program? (For example, in a bidding program we might need the account address so we can store who the bidder is)
https://ethereum.stackexchange.com/questions/1891/whats-the-difference-between-msg-sender-and-tx-origin/1892
For example, Ethereum has `tx.origin` and `msg.sender` which can be used to determine who called a particular contract
Does anyone know how to get the address of the user that initiated a transaction?


//////////////////////////////////////////////////////////////////////////////////////////

What is the line I need???
How do you do an "init if not initialized before" for a PDA?
I'm executing that within a folder of a hello world anchor project I created that is not related to the mentioned program id.
No I'm just using the command line. This one is an account of the program AMM55ShdkoGRB5jVYPjWziwk8m5MpwyDgsMWHaMSQWH6

anchor idl fetch 3iHYdMqmfb9rgnUgNYNQ4WXpKT6unoGwXa1uqmghP2Am
Error: Unexpected length of input
are you doing `program.account.{accountTypeFromIDL}.fetch()`?
Hi! I'm trying to get the Layout of a on chain program I don't own. anchor idl fetch <program-id> fails with Account not found
Does anyone know if goosefx or bitsol is real or a scam I already lost on the other ones I ain tryna buy a fake token again
Can the missing IDL type definition be fixed by using bytemuck instead of borsh?
Doesn't seem to work if the struct is defined in a separate crate in the same workspace. I had it `pub` and `AnchorSerialize/AnchorDeserialize`.
I literally just had this issue. I got around it by running `cargo clean` and then building again
Has anybody seen a similar error?
```
22 | #[program]
   | ^^^^^^^^^^ could not find `panic` in `core`
```
where `core` is the name of a `pub` submodule.
```
thread 'rustc' panicked at 'Failed to get crate data for crate11', compiler/rustc_metadata/src/creader.rs:136:32
```
when compiling that dependent crate by `anchor build`.
I'm trying to use structs defined in a different crate. `cargo build` succeeds but `anchor build` fails with a Rust compiler panic when I try deriving `AnchorSerialize` and `AnchorDeserialize`. How to include type definitions from dependent crates into the IDL?
I think each team mint their own test USDC token. You can just mint anything with decimal to 6
Is there any faucet?
Anyone knows how to get USDC for testnet?
 I wanna use USDC for test but I have no idea to get it.
need help installing anchor on x64 macbook
ah, there you go, good catch
🙂
dumb me
<@!886273867293802556> you are right, I did `wallet.pubicKey.toBuffer()` and was comparing it to sollet, should have done `wallet.publicKey.toBase58()`.
hmmm weird, thank you tho 🙂
not sure what the issue could be
at a glance it looks ok to me
``` 
const web3 = require("@solana/web3.js");
const anchor = require("@project-serum/anchor");
const connection = new web3.Connection("https://api.devnet.solana.com");

const bs58 = require("bs58");

let wallet = web3.Keypair.fromSecretKey(new Uint8Array(private_key));

const provider = new anchor.Provider(connection, wallet);

console.log(wallet.publicKey);
```
hmm, yeah it should match
ennn.. <@!886273867293802556> i did it and it worked but the public key in node `console.log(wallet.publicKey)` does not match what i have in sollet ?
Thank you joebuild!
Noiceee!
```
import * as web3 from '@solana/web3.js';
const bs58 = require('bs58')

let keyIntArray = bs58.decode('MY_SECRET_KEY');
let wallet = web3.Keypair.fromSecretKey(new Uint8Array(keyIntArray));
```
edgar says ty <@!501570363566587905> we are together hehe
what an idiot
andddddd the wallet had no sol
one sec..
Im writing a script to do a tx from
are you trying to build an app or just run a quick script for something?
wallet connector for node?
oh and `fromSeed` to import a existing?
otherwise you'd either need to read from your solana config key, in your file system, or integrate a wallet connector
are you trying to import an existing wallet or just any wallet, you can create one with `const authority = Keypair.generate();`
im trying to do a tx from node
how to do import a wallet in a node script?
or would that be a different eerror
so like would this fall under that explanation? #[account(has_one=authority)]
i'm thinking maybe somehow i'm not using the wallet i'm intending to use on mainnet
hmm ya these are my two cases there then
#[account(constraint= wallet.owner == &spl_token::id() || (wallet.data_is_empty() && wallet.lamports() > 0) )]
    #[account(signer, constraint= authority.data_is_empty() && authority.lamports() > 0)]
When a `#[account(constraint = <>)]` fails
anyone know how that occurs
hitting a ConstraintRaw error
hey all
so the other programs read data from this program that isn't prod yet?
Yay ty.
Yes you can see whoever has a non zero balance for the mint.
Not if you use the localnet for testing.
hey everyone. i was wondering if there is a way to know the current holder/holders of an NFT 🤔
Or if it does some logic there itself.
Trying to see if its required to airdrop sol to myself locally before doing anchor test.
Got it :).

On a different note, do we ever need to airdrop sol to our local wallets when using `anchor test`?
If you deploy the program to devnet your friend could use it
Does program id we use w/ Anchor matter?

Like -- if I give my friend this program could he just use my id if we're working locally?

I know it needs to change upon a deploy.

```
declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");
```
Any thoughts on this? Basically this won't compile

```
pub trait BarTrait {}

#[derive(AnchorDeserialize, AnchorSerialize, Debug)]
pub struct Foo {
    pub test_field: Box<dyn BarTrait>,
}
```

but removing the `derive` and manually implementing won't include Foo in the IDL (since I guess anchor doesn't know how to serialize it in the js)

```
impl AnchorSerialize for Foo {
    fn serialize<W: borsh::maybestd::io::Write>(&self, writer: &mut W) -> borsh::maybestd::io::Result<()> {
        ...
    }
}
impl AnchorDeserialize for Foo {
    fn deserialize(buf: &mut &[u8]) -> borsh::maybestd::io::Result<Self> {
        ...
    }
}
```

I can always just split the use of `Foo` into multiple different instructions (one per possible implementation of the trait) but just wanted to see if there are alternatives to get the above to work
testing on devnet failing
Runs fines on localnet


Thank you so much!
Ahaha yes i feel you, lots of head bashing to find how to do things right now
Here 
https://project-serum.github.io/anchor/ts/classes/provider.html#send
Though about `provider.send`... I think it is documented somewhere, 1 sec
There aren't many docs around, just examples in `tests` directory and source code
I got the last line by asking right here, was bashing my head at this problem for quite some time as well.
Hi all, I'm running through the tutorial here: https://project-serum.github.io/anchor/tutorials/tutorial-0.html#clone-the-repo

I'm running the test validator in a separate container, and the tutorial code is in its own container.

When I try to deploy, it seems to send transactions, but nothing ever happens. It says the transactions are still pending and ultimately the blockhash expires and it hits the max retry limit.

Does anyone know what might be wrong?
This is great, where did you find this by the way? Are there any specific docs? Trying to find the best way to get my head around all the resources
Thank you! 🙂
Ouu thank you!
```
const txn = new anchor.web3.Transaction();
const ix = program.instruction.NAME(..);
const ix2 = program.instruction.NAME(..);
txn.add(ix);
txn.add(ix2);
 await provider.send(txn, signers);
```
Though the error message wouldn't be as nice
Do I understand correctly that this account is initialized at `pda`s address with given seeds?
https://github.com/project-serum/anchor/blob/master/tests/ido-pool/programs/ido-pool/src/lib.rs#L294
sort of, you can add instructions which happen before the content of your call
https://github.com/project-serum/anchor/blob/5d8b4765f2c5a2d0c5a26c639b10719e7b6f2fd1/tests/cfo/tests/utils/stake.js#L79-L82
Is it possible to chain multiple RPCs into one transaction?
oh maybe because i was running solana test validator at the same time in the background
Whaaa, i just did :

anchor build && anchor deploy again 

and then anchor test 

And it worked 😂 this confuses me more now lol
Yep i was thinking that and then I get this: 
mut cannot be provided with initrustc

😕
https://github.com/solana-labs/solana/blob/master/program-runtime/src/instruction_processor.rs#L442-L462 should be one of these two reasons
hm, does zero_copy_account need to be marked with `mut`?


//////////////////////////////////////////////////////////////////////////////////////////

check above, you may find this interesting. havent tested it in practice but will let u know if it works
btw this was it, i forgot to set the `space` 🙄
seems to compile at least 😄
which i only figured out because i had actually saved some messages from armani in this channel several days ago
btw i updated it to this.
```
#[account]
#[derive(Default)]
struct ManyFacedAccount {
    current: Option<State>
}
#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
enum State {
    FirstState { hi:u64 },
    SecondState { hi3:u32 }
}
```
definitely gonna take advantage of this >:)
Lol, not dum, this stuff is tricky and I happen to have a lot of free time at the moment so can study a lot 😆
so i dont forget, cause i have bad memory
thank you for talking with me about this stuff, if you cant tell im very newb and dum lol, i have this giant log of ever thing you say
not really trying to do anything, just wondering in case i did lol
So not sure what you're trying to do
You can only set the owner once I think in solana, and if your program can write data to that account then it has *already* been set to be the owner (*only* the owning program can ever write to an account)
hm, i gotcha, i guess im just thinking, how would one then go about having your anchor program create a PDA then set the owner to someone else
No, I think it's just implicit in what you're doing (one of your `#[account]` things basically has to be owned by the current program, whereas a token account has to be owned by the token program, etc.)
is there an flag to set the owner to someone else then?
It's the `#[account]` thing that says that your program should be the owner
If you do a regular `init` then yeah, but not necessarily—if you do an `init` for a token account, then the program owner is the spl token program
ohhhh yeah i forgot about this, ok. It seems then that Anchor automatically sets the owner as the derived program?
Not necessarily! https://twitter.com/pencilflip/status/1455678830262173697 Which program derived the PDA is independent of which program owns the underlying account
hmm, just thinking, i guess using the example you posted, one would set the `current` to None(), and then subsequently set it to Some(SecondState), that would accomplish what i want ig
sorry i thought thats what you meant since u said not the deriving program, but yeah the pda is owned by the derived program isnt it?
I answered my own question here kinda as you can include a new `[scripts]` script to do that
What account here is owned by the system program? I'm not even sure if its possible to store data at a system program account 🤔
What do you mean? If the account is owned by your own program, then your program can just change its data
would that mean the system program? I guess this goes back to my question of doing CPIs to the system program :/
is there a way to change the default idl location on `anchor build` ? (other than running the `--idl` flag each time I mean)
FirstState would have all its own data fields i mean, etc
(sorry i just woke up lol) so basically the enum would hold all the data fields sorta do the serialization for me, and anchor itself would just see a single `current` field?
Then you could encode three states: Some(FirstState) -> None (empty-ish) -> Some(SecondState)
Could maybe do something like
```.rs
enum State {
  FirstState { ... },
  SecondState { ... }
}
#[account]
struct ManyFacedAccount {
  current: Option<State>
}
```
Changing the data in a PDA would be the same as in any other kind of address—you'd have to have some way to ask the owning program (not the deriving program) to do the wiping.
Fwiw that error is almost always related to space in my experience
i think i might just be dumb and its something else. i actually had a serious question, it's a high level question. 
Is there a way to completely clear out the data from a PDA? What im wanting to do is have a data structure with several fields in an account, and then later use that same account for a completely different data structure
Can you post more code? No idea how references could led to that kind of error
anywhere i try to pass a reference to an account, like to a function, so i can access its data fields
`&ctx.accounts.user_account`
I get this error 😦
`164 Failed to serialize the account`
Is there something about anchor's serialization im not getting?
Thanks <@!134416332509675520> its working fine now . No need to pass the ATA from client
hmm I think I got the error... I was passing the wrong mint while initing the ATA inside the program -   associated_token::mint = mint
It should definitely work, not sure what account could be missing
Could you show the whole `rpc` invocation when you try the `associated_token::` approach?
associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID
Ah, sorry, when you tried doing that `associated_token::` stuff above, were you separately passing the ASSOCIATED_TOKEN_PROGRAM_ID as an account to your own instruction?
This is the account passing here from client

```const userTokenAccount = await Token.getAssociatedTokenAddress(
      ASSOCIATED_TOKEN_PROGRAM_ID,
      TOKEN_PROGRAM_ID,
      mint,
      payer.publicKey
    );```
yes passing that account as well
Interesting... are you passing the associated_token_program as an account? I thought anchor would error if you weren't 🤔
Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: An account required by the instruction is missing
hmm this is odd ... was trying to do the same but it was throwing the error that's why I added instruction to create ATA.
```
 #[account(
        init_if_needed,
        payer = payer,
        associated_token::mint = mint,
        associated_token::authority = payer
    )]
    pub user_token_account : Account<'info, TokenAccount>,```
You could also create the ATA within your own program and use `init_if_needed` I guess
Mm, not sure, but that would be the basic idea
so refetch and then if and else block contains the same RPC call. one with  createAssociatedTokenAccountInstruction  as instruction if it does'nt exists and other one with no instruction. Is there a better way ?
You would probably need to try fetching that account and check whether it already has an account there.
So , when I try to create ATA on a wallet it creates first time when I send the Token.createAssociatedTokenAccountInstruction as instruction but when I run again it again tries to create same which throws error of account already exists . How can I handle it ? Can I pass empty instruction if ATA exists ?
In the anchor repo
You can find a list in error.ts
Currently you have to do something kind of annoying, convert to decimal 0xa7 = 167 and then search for the decimal lol
Thanks you! I searched, but I searched for 0xa7
you can also discord search for errors you get to see what other people did
```
 Error: 167: The given account is not owned by the executing program
```
167 is an anchor error
in my case the errors are in a Enum at the end of the file, but there are 14 possible errors ... how can i identify which one is with id 167 ?
but not sure how
ok, I've patched Solana & am compiling it from source
I'm running 1.8.3
oh Mainnet - v1.8.5 Latest I think
is there a way to find out what version of solana mainnet is running on?
hmm .. maybe
then some kind of solana version mismatch could be the cause
it just sounds like if you practiced uploading on testnet and it worked, and then you tried doing it on mainnet
Is it possible to configure the number of retries?
you think I compiled my program locally w/ a different version of solana?
what seems odd is that even if this is the case, why can't I upload to mainnet?
my problem is when I do `cargo install --git https://github.com/project-serum/anchor --tag v0.18.2 anchor-cli --locked`

I have the following error
 Updating git repository `https://github.com/project-serum/anchor`
error: the given reference name 'refs/heads/' is not valid; class=Reference (4)
my guess would be that you've tried uploading with a newer or different version of solana on testnet than is currently running on mainnet
that's unlikely
no
but maybe the transactions are being out-competed?
the confusing part is it's only 200 transactions, and I know solana has massive throughput
it's usually on different versions of solana
you shouldn't use testnet for development
never tried deploying it on devnet
It deploys on testnet w/o issue
have you got it working on devnet first?
That's why I stick to answering questions in discord 😌
when you still have transactions left
& hitting retry limit exceeded  / whatever the error is
i'm very confused as to how people deploy on Solana -- I spent 2 hours last night trying to deploy
judging by the progress -- I don't think it's gonna work 😦
Haha, sick, that's definitely the nuclear option 😆 Good luck!
Update: I've tried using a dedicated Solana RPC node for the deployment, hoping that will solve the issue
Ask away (more info the better)
Hello i have a problem for installing Anchor if anyone can help me plz?
is there a way to increase the number of retries?
Hmm .. no matter what I do, I can't deploy to mainnet -- I just keep on getting "run out of retries" error
can you ask a more specific question
look at error.rs
Anyone who has a good understanding of anchor escrow program ?
Hello, I'm getting this error when calling an anchor program. Does anyone know what error 167 means ?

this is the program code: https://github.com/Moonlet/metaplex/blob/master/rust/nft-candy-machine/src/lib.rs it's a fork from metaplex, and did a change on mint_nft method.
Thank you!
Pass only this from JS  ->  { simple: {} }
```
enum Type {
  Simple,
  Interval,
}
```

And I try to pass it as 
```
      { Type: { simple: {} } },
```
Now I'm getting `unable to infer src variant` errors
Good day! How to pass a enum into an instruction handler?
I'm trying to create a new account using him
I find this import in a repository :
`const serumCmn = require("@project-serum/common");`
Does this package have any documentation?
https://github.com/solana-labs/solana/issues/19357
did you try updating your cli?
I think that's an issue with the old version
where NEW_BUFF.json is the recovered buffer
doesn't seem to do the trick
but using a command like `solana -k admin_key.json -u mainnet-beta program deploy --buffer NEW_BUFF.json target/deploy/pixels.so`
I recover the keypair
do you understand how resuming  a failed deploy works?
Ah, interesting 🤔
it will just run out of retries
What goes wrong?
& you can't really control whether the deploy suceeds
i've been trying to deploy to mainnet
on an unrelated note -- it seems like Solana deploys are hellish
i'll see if I can dig up some old code
What do you mean by program account?
Ah, sorry—the PDA wouldn't be the programId account itself (think I misunderstood what you wrote above)
well, the reason this all came about was b/c in the smart contract I had people essentially depositing money into the PDA account
And then the account gets marked is immutable I think
You deposited once when you deployed
Are you sure? I'm pretty sure you can't actually
hmm, how does that work then -- b/c I know I can deposit money to the program account
oh but you mean with not rerunning the test every time, if you're running on devnet or something
you can also init variables using `let varOne` outside the `it()` blocks and assign values to them inside the tests
thanks
Mocha has a
```.js
before(async () => {
  // do stuff once before you start running tests (only runs once)
});
```
what's the way to write test cases in mocha . I want to run certain section of script only one time (like initializing a vault) and not with every anchor test. What's the best way ?
No built-in support for JSON yet, no
I think 0x1 seems to usually be that you don't have enough money, so try airdropping yourself like 10 sol just to double check
Ah, if the key you were using was the program id, that will always point to an immutable account (not possible to request write access to it)
Has anyone run into the above error? It's when a deploy seems to succeed but the txn isn't finalized
```
Error: Deploying program failed: Error processing Instruction 1: custom program error: 0x1
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }.
```
this is ur brain on solana
https://tenor.com/view/egg-fried-egg-this-is-your-brain-on-drugs-gif-17947595
my brain
😭
that has a field called owner
the data stored in the account
but not the owner owner as in
its the account owner
god damnit
oh
`constraint = feeble_token_account.owner == user.key()`
afaik the owner would be token program not ur user key
i did your constraint and it works
its totes the owner
When I look at the transaction history
I'm getting NotOwner error code
```
pub user: Signer<'info>,
#[account(owner = user.key() @ErrorCode::NotOwner, constraint = token_account.amount == 1u64 @ErrorCode::AmountZero)]
pub token_account: Account<'info, TokenAccount>,
```
What about if there is a null in the JSON format? say struct has pub name:String, but in JSOn only has...other than the name
You can pass a struct as a parameter, which is effectively in JSON format
Nvm, all I needed was `&mint.key.to_bytes()`
Can we receive a JSON arguments? from exampe it seems only u64 or String?
https://tenor.com/view/dying-monkey-dying-gif-13123180
🙂
u are a king
thank you
ahhh
If u don't want to send , it automatically finds it and does that while creating a PDA.If you want to store the bump somewhere for later use you can do so by above approach.

 ```#[account(
        init,
        payer = owner,
        seeds = [owner.key().as_ref(), "test".as_bytes()],
        bump
    )]```
(automagically appends to the seed)
and the bump attribute is automatic?
add that as function argument for initialize call in program and to pass from client side do something like this 

If u want to pass bump you can do so by 

 ```await program.rpc.initialize(bump,"hello", {
        accounts: { 
          ...
        },
      });


 pub fn initialize(ctx: Context<Initialize>, bump: u8 ,name: string) -> ProgramResult {
   Ok(())
}
```
cus i dont see my idl generate a arg for bump
This is what it looked like before
```
      await program.rpc.initialize("hello", {
        accounts: { 
          ...
        },
      });
```
or is it in the object?
Do I do something like `program.rpc.initialize("hello", bump, ...)`
With `#[instruction(bump: u8)]`?
Yes, I believe you need to generate it on the client
if you want to store it inside the struct you can pass alongwith the function call
Do I need to generate a bump clientside?
Do you know how the bump works?
yup
<@!739012341588557895> like this?
```
base_account.posts.remove(id)
```
is the same?
Something like this?
`#[account(owner = user.key(), constraint = token_account.amount == 1)]`
but ya
jk
THEY
to check if he holds that token or not
I gotta do token.amount == 1?
xD
Or `#[account(owner = user.key())]`?
```constraint = token.amount == 1, 
constraint = token.owner == signer.key()```
whats ur account struct look like
welcome to my world
lol
which is at least better to deal with than the previous error
And I got: `     Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account`
(so I changed the hard-coded key in my Rust program)
<@!739012341588557895> : ok, I tried using a key that was not generated by Anchor
```
#[derive(Accounts)]
#[instruction(bump: u8)]
pub struct Initialize<'info> {
    #[account(init, seeds=[PREFIX.as_bytes(), mint], payer=payer, bump=bump)]
    state: Account<'info, State>,
    #[account(mut, signer)]
    payer: AccountInfo<'info>,
    // With the following accounts we aren't using anchor macros because they are CPI'd
    // through to token-metadata which will do all the validations we need on them.
    #[account(mut)]
    metadata: UncheckedAccount<'info>,
    #[account(mut)]
    mint: UncheckedAccount<'info>,
    mint_authority: Signer<'info>,
    update_authority: Signer<'info>,
    #[account(mut)]
    master_edition: UncheckedAccount<'info>,
    #[account(address = metaplex_token_metadata::id())]
    token_metadata_program: UncheckedAccount<'info>,
    #[account(address = system_program::ID)]
    system_program: AccountInfo<'info>,
    rent: Sysvar<'info, Rent>,
}
```

I want to generate a PDA off an NFT mint address, and I'm using code similar to the candy machine (https://github.com/metaplex-foundation/metaplex/blob/master/rust/nft-candy-machine/src/lib.rs). Given the `mint` attribute is of type `UncheckedAccount<'info>`, how do I pass it into the `seeds` for the PDA? Do I have to use a different account type instead of `UncheckedAccount`?
If I want to make sure a token account is owned by signer what constraint do i use?
maybe the key that Anchor generates for is not possible for withdrawing funds
the public key of `adminKp` is equal to my programId
but I have a suspicion
hmm thanks for working through this w/ me, that doesn't solve the issue
const keypairPath = 'xxx/xxx';
const data = fs.readFileSync(keypairPath, 'utf8');
const secretKey = Uint8Array.from(JSON.parse(data));
return web3.Keypair.fromSecretKey(secretKey);
I guess something did  not install according to plan. But what and how do I fix that
try passing ```signers: [bidder5]```
I use:
maybe the there was something going wrong with decoding the keypair
I get this error when running 'anchor build'
`BPF SDK: /Users/alexanderlupatsiy/.local/share/solana/install/releases/1.8.5/solana-release/bin/sdk/bpf
cargo-build-bpf child: rustup toolchain list -v
cargo-build-bpf child: rustup toolchain link bpf /Users/alexanderlupatsiy/.local/share/solana/install/releases/1.8.5/solana-release/bin/sdk/bpf/dependencies/bpf-tools/rust
error: not a directory: '/Users/alexanderlupatsiy/.local/share/solana/install/releases/1.8.5/solana-release/bin/sdk/bpf/dependencies/bpf-tools/rust/bin'`
But it does mean that the function code inside the contract is running at least
This returns "invalid admin key", which is exactly what I expect since `bidder5` is not the hardcoded admin
Yeah:
where `bidder2` is generated by the above function


Now I'm doing this:
did you switch to any specific keypair or just a newly generated one?
of course it fails since I'm using a different keypair, so the check for whether the signer is equal to the admin key goes wrong
then the code runs
to a different signer
if I switch from using `adminKp`
ok this is interesting ...
fine
commenting out the Signer makes it fi
if you comment out the signer account and the contents of the withdraw function, you dont get the mut violation right?
so I don't think it's an issue with `GameState`
work fine

the other instructions like:
yes, it is
is your GameState struct annotated with #[account]?
yeah, I do. it doesn't matter even if I comment out the entire withdraw function
and right now with that code you get the 'mut constraint violated'?
If so, we transfer money from the PDA (game account) to that signer
Basically:
- The key used to deploy the program is hard-coded into the program, only that key can be used to withdraw from the program to an external account
- Inside `withdraw`, we check that the given signer is the same as the key used to deploy the program

And lastly, the client code:

Here's the withdrawal func:
^ that's the account policy (will post client side code in a sec)
yep, give me one second
could you show the client side code?
as a u64
The data you're storing, you can essentially delete yes
Hi, want to ask if solana can delete a post from array? or due to blockchain nature every data is bount to be append only?
I'm pretty sure the issue must be in `try_accounts`, but I'm not sure what it could be
From looking at the expanded code in with `cargo --expand`:

```rust
        #[inline(never)]
        pub fn withdraw(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> ProgramResult {
            let ix = instruction::Withdraw::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::__private::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::Withdraw { lamports } = ix;
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts =
                WithdrawPot::try_accounts(program_id, &mut remaining_accounts, ix_data)?;
            pixels::withdraw(
                Context::new(program_id, &mut accounts, remaining_accounts),
                lamports,
            )?;
            accounts.exit(program_id)
        }
```
I'm running into an interesting dilemma:

```rust
#[derive(Accounts)]
#[instruction(lamports: u64)]
pub struct WithdrawPot<'info> {
    #[account(mut, seeds = [], bump = game_account.bump)]
    game_account: Account<'info, GameState>,

    //#[account(mut)]
    //to: Signer<'info>,

    //#[account(mut)]
    //to2: AccountInfo<'info>,

    system_program: Program<'info, System>,
}
```

For some reason, if I uncomment either of the commented fields -- I get a "mut constraint" violated at runtime.
(The method itself is a stub -- all the code is commented)
It said that BorshSerialize is not satisfied
Hi, how can I add timestamp into a struct?
maybe i should use the mint address instead of the associated token account?
so
when i remove the token stuff it all works
Have you tried to send the bump with the function call?
```
> Program returned error: Cross-program invocation with unauthorized signer or writable account
> Runtime error: Cross-program invocation with unauthorized signer or writable account
```
https://explorer.solana.com/tx/5nbiTnMnEe2Fi2d7L2kFhMR8jbhx5i6TqP6Nq85ScJvngF2BPxH62i4JWVxDRfb6m7mrvfw3kC53rRsTawyQ3Gvi?cluster=devnet
What error are you getting?
Also I feel like Im missing what to do with the bump
Want to make a keymap for ("token" + token_acount.key + user.key) -> storage
lol
send help pls
```
    #[account(init, seeds = [b"token".as_ref(), token.key().as_ref(), user.key().as_ref(), ], bump, payer = user, space = 64 + 64)]
    pub storage: Account<'info, StorageAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
    #[account(constraint = user.key() == token.owner)]
    pub token: Account<'info, TokenAccount>,
````
xD
now i'm getting privilege elevation errors
god bless
Yeah I got it figured out
Did you get your wallet adapter issues sorted out? I saw some sample code for adapting between anchor and phantom wallets that I can dig up if you need
and if so, I transfer funds to the signer
(that is hard-coded into the contract)
all I do inside the actual call is check if the signer is equal to a given public key
not sure why though as it's a fairly normal account policy?

for some reason I'm getting "mut constraint violated" when I try to transfer SOL from a PDA to a non-PDA
(money = sol)
Can PDAs transfer money to other accounts?
what the hell
omg i have two different version of anchor-lang
```
The trait bound `anchor_spl::token::TokenAccount: anchor_lang::AccountDeserialize` is not satisfied

the trait `anchor_lang::AccountDeserialize` is not implemented for `anchor_spl::token::TokenAccount`
```
Give me
pub nft: Account<'info, TokenAccount>,
I thought public / private keys were both 32 bytes
When generating a keypair with `  const kp = anchor.web3.Keypair.generate()` does anyone know why `kp.publicKey.toBytes().length` is `64` instead of `32`?
basically the most basic rust shit
i add it to cargo.toml
ahh
xD
jk i tried cargo install anchor_spl and nothing
my apologies folks
nvm
lol
or whatever
do i need to cargo get it
how do i import anchor_spl lol?
i tried that i must have used the wrong shit
lmao
`new PublicKey(<string>)`
in web3 js
lol
confused how i take a string and convert it to pubkey
Is this the way to do it?
`const state = program.coder.accounts.decode('<accountName>', accountInfo.data);`?
How do I deserialize a state account on the client?
Hey frens
Hi ! I am getting this error when i run if anyone have a solution for me its like 3 days that I can't find the solution 😭 : 
cargo install --git https://github.com/project-serum/anchor --tag v0.18.0 anchor-cli --locked

Updating git repository https://github.com/project-serum/anchor
error: the given reference name 'refs/heads/' is not valid; class=Reference (4)
Any recommendation why anchor doesnt properly run further
CLI just freezes
Only x86_64 / Linux distributed in NPM package right now.
Trying globally installed anchor.
Hi all, I am trying to run anchor build on my mac and I get stuck at this portion:
I changed those lines because when I ran the test alone, it gave me a "    Error: failed to send transaction: Transaction simulation failed: Attempt to load a program that does not exist"
thank u
Hello there! Is there an example using anchor to do NFT staking (eg freeze NFT in exchange for rewards) or SPL-token staking? Thanks in advance.
I am running the tests for basic-2 tutorial and I swapped out the program line 

const program = anchor.workspace.Basic2

for the programID public key when I upload the built program to my local cluster and idl from the built json file. when I run the test, I get the following error. 

What am I doing wrong?
yep! https://cofre.so
EDIT: You can mint a sample NFT, not make one per se, would that work? or do you want to make a custom NFT?
Is there a devnet nft market place where i can quickly make an nft?
Indeed. Try it out!
https://docs.rs/solana-program/1.8.5/solana_program/pubkey/struct.Pubkey.html#method.new_from_array
Does anyone know how `pubkey::new_from_array` works. I'm assuming it takes 32 bytes of a public key (and not a private key -- i.e., it's not returning a keypair)
All accounts are rent exempt by default.
Does it happen when u init a pda
Does that get done by sending sol directly to an account?
In anchor how do I set the rent to be 2 years for an account?
Is there a way inside Rust to get the balance of a program account?
ideally if I test this on test-net, it should also be applicable on devnet & mainnet
for example: I want to code a function in my smart contract that only allows money to be withdrawn to a specific account
Is there any way to use the same address on test net & main net
Hi All,

I have a program with an associated token account that can transfer tokens to any given address. How do you enforce a payment for the transfer? For example, the user sends 1 SOL and receives 100 XYZ token. I can send 100 XYZ tokens using the code below, but how do I add a payment to the transaction. Thanks.

```
token::transfer(
  CpiContext::new(
    ctx.accounts.token_program.to_account_info(),
    token::Transfer {
      from: ctx.accounts.from_token.to_account_info(),
      to: ctx.accounts.to_token.to_account_info(),
      authority: ctx.accounts.from.to_account_info(),
    },
  ),
  100,
)?;
```
I first encountered the problem when doing https://discord.com/channels/428295358100013066/517163444747894795/915003343825408000 but then I just tried running it on a completely newly created project, created via anchor init, but there it had the same problem
I guess something did not install according to how it should have
I get this error when running 'anchor build'
`BPF SDK: /Users/alexanderlupatsiy/.local/share/solana/install/releases/1.8.5/solana-release/bin/sdk/bpf
cargo-build-bpf child: rustup toolchain list -v
cargo-build-bpf child: rustup toolchain link bpf /Users/alexanderlupatsiy/.local/share/solana/install/releases/1.8.5/solana-release/bin/sdk/bpf/dependencies/bpf-tools/rust
error: not a directory: '/Users/alexanderlupatsiy/.local/share/solana/install/releases/1.8.5/solana-release/bin/sdk/bpf/dependencies/bpf-tools/rust/bin'`
It's in the directory you call anchor test from
i'm searching for it -- can't find it
is `.anchor` in the home directory, the target directory?
If you're using `anchor test` then logs are in `.anchor/program-logs/`
Is there a way to view the log in Anchor? I.e -- if I'm using the `msg!` macro in Solana
thanks -- and when an account runs out of rent is it just made inaccessible right (not deleted off of the chain?)
3 days per epoch on average
but it's unclear how many epochs per day
you can use `solana rent <size>` to get the rent per epoch
Let's say I want to keep an account alive for e.g. 5 days. Is there a good way to determine how much Sol that account needs?
looks like it, thanks for your time
`pub fn bytes_are_curve_point<T: AsRef<[u8]>>(_bytes: T) -> bool {
    #[cfg(not(target_arch = "bpf"))]
    {
        curve25519_dalek::edwards::CompressedEdwardsY::from_slice(_bytes.as_ref())
            .decompress()
            .is_some()
    }
    #[cfg(target_arch = "bpf")]
    unimplemented!();
}`
Hmm, interesting, guess you might have to implement that logic yourself 🤔
yes
Meaning you want to specifically check that it's an actual public key, not a PDA etc.?
is there a way to check if a publickey is valid? https://docs.rs/solana-program/latest/solana_program/pubkey/struct.Pubkey.html#method.is_on_curve says not implemented when I try to use it
200k units is the default max
https://tenor.com/view/liban-jareer-monkey-monkey-dance-liban-monkey-gif-22730016
its working on devnet
my god it was local host
Just curious, why do instruction logs always say ` consumed X of Y compute units` (where X < Y) - Where is Y defined? afaik, when you call CPI, you don't specify how many compute units are available
Thank you
They might have a more satisfactory answer
You could ask in the Solana tech discord in dev support
Thanks <@!248066053161222144>, I still "use" the signer because it is the fee payer and because it needs to create some accounts. But when my program calls another program, I'd like to ensure that the program cannot use my user's signature
Unused signers are silently ignored by Solana for now
I'm not sure what happens if the AccountMeta for that account doesn't specify it as a signer
oh I see
Mm, good question—I think the answer is no but I'm actually not sure 🤔
<@!134416332509675520> Alan is it possible to "drop" the signer attribute on an account when performing CPI?
thanks for trying cqfd
~~Hey guys, I'm trying to load my idl in my nextjs app, however there is no "metadata" key in the json file. The rest is present though. Am I missing something?~~ Nevermind that. Rerunning `anchor build` fixed it.
im just going to move to devnet i guess
solana logs didnt report shizz tho
it seems to be chugging away lol
Ah, interesting. Is your local validator working ok?
```
Transaction was not confirmed in 47.26 seconds. It is unknown if it succeeded or failed. Check signature 2WRnNLgnGmKoCjsiZZeBUpARcgyKQq5JfrgvcmEwsjdDngafg6bDgMC8LcBcTvHZWWs3fm9G4eHHzfyBxdFrbsnp using the Solana Explorer or CLI tools.
```
https://tenor.com/view/dying-monkey-dying-gif-13123180
Imma try skipPreflight
unable to fetch balance changes?


Can you still not look at the balance in phantom itself?
I'm so cursed
xD
solana account XiBSBfqqwfNCHYZFnJ4Wnu2UAxqc8T3eRJpddcX4niS gets the balance
The expected one? Lol
When I do `console.log(provider.wallet.publicKey.toString());` I get an address
Basically I'm almost positive the issue is that the account you end up using as the provider.wallet doesn't have any money, but not sure why yet
What does `provider.wallet` look like after that line?
Actually I guess that should be ok
What does it actually return?
Ah, interesting, that looks a little sketchy to me the way you're calling `useAnchorWallet` 🤔
```
  <ConnectionProvider endpoint="http://127.0.0.1:8899">
    <WalletProvider wallets={wallets} autoConnect>
      <WalletModalProvider>
        <App />
      </WalletModalProvider>
    </WalletProvider>
  </ConnectionProvider>
```
```
    const provider = new Provider(
      useConnection().connection, useAnchorWallet()!, { preflightCommitment: 'processed' },
    );
```
No, you aren't even getting to that point I don't think
Is something wrong with my accounts?
```
#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, seeds = [b"seed".as_ref(), user.key().as_ref()], bump, payer = user, space = 64 + 64)]
    pub storage: Account<'info, BaseAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```
Yep
But the balance is correct?
hahahahaha
xD
and still not working
ahh its loading now
It like processes transactions but never has show the account information lol
That sounds like a problem lol
Ah. Why won't phantom load?
lol
phantom won't load
localhost
what does `solana config get` say
lol
cli
How did you check it? Like, in your phantom wallet itself?
Ok, cool, how did you decide you have that particular balance?
😛
its just localhost
Yeah, I would double check you're talking to the network you think you are (e.g. maybe the right address but the wrong cluster). If that's not the problem, then not sure what's going on
maybe the simulator thinks my balance is empty
hmm its the correct pubkey
thats a good idea mao
Can you console.log your wallet's publicKey, just to check?
On the network you're trying to use? Is that in a phantom wallet?
`Balance: 10999.99730736 SOL`
Yeah, you'd just need a base58 version of the final 32 bytes in that file
Got it -- & presumably what you need to do is take the keypair & find the  address (same thing as public key) using web3, and that's what you stick inside of `declare_id`
Mm, do you have any money in that account?
In typescript
But anchor provider doesnt accept phantom wallet.
Ever since I started trying to use useAnchorWallet
yo alan my boy you know anything bout this stuff?
Actually not sure how to do that now that I think about it
Ah, yeah, you need to edit declare_id!, but you'll also need to tell anchor where to find the keypair when you deploy
If I want Anchor to use that keypair file, I assume I need to edit `declare_id!` and do something else as well
more concretely: I do `solana-keygen new -o /some/location/on/computer`
Anyone know how to disable the transaction simulation for dev?
Well the generated key is stored in a file, right? Even if you edit `declare_id!`, (from my understanding) Anchor will not know where new generated keypair file is (for example: what if I stored it in some random location)
Oh, I was going to rephrase that. Will try smth, thx.
https://github.com/Necmttn/anchor-voting/blob/master/solana/index.ts#L19
Yeah, currently gotta edit your declare_id! :/ Anchor may automate this in the future though
I guess the question is how to tell anchor to use the generated keypair
Hmm, not sure, sorry!
But when I use `usePhantomWallet` typescript breaks for anchor
```
      let [ pdaKey ] = await web3.PublicKey.findProgramAddress([
        Buffer.from('seed', 'utf8'),
        provider.wallet.publicKey.toBuffer()
      ], programID);

      await program.rpc.initialize("Hello World", {
        accounts: {
          storage: pdaKey,
          user: provider.wallet.publicKey,
          systemProgram: SystemProgram.programId,
        },
      });
```
I keep getting `index.js:1 Transaction simulation failed: This account may not be used to pay transaction fees `
I'm confused by the difference of `useAnchorWallet` `usePhantomWallet` in the wall adapter for react.
<@166989184513343488> 
i have script to generate new keypair in my repo.
which i write in a json file. 
where i initialize the account the app. 
check 
`yarn new_deploy`
I guess if you generate a new keypair, then you can't deploy at the same program id though
oh wait, nevermind, I didn't -- but still good to know
Is there a way to either regenerate the keypair or have anchor use an existing keypair file (maybe I can just run `solana-keygen new -o target/pixels/pixels-keypair.json`), since I accidentally checked the keypair file into git ...
Hey guys last couple days,  i been spamming here. heres the give back to learners a bit.

https://anchor-voting.dapp.necmttn.com/
and open source code 
https://github.com/Necmttn/anchor-voting

i have extensive amount of test cases for things are not documented. 

Planning to add a tutorial on top of it as well. 

so let me know if is there any  other way to improve the code quality and practices. 

specially i'm looking to improve type generation bit in client side.
Just based on the rules solana has for creating accounts at addresses
So you need to be able to sign for that new address (your program id)
is there a place where we can airdrop you sol <@!134416332509675520> ? lol
Because deploying a program creates an account at your program id, which requires a signature
I see, & the reason Anchor needs to generate a keypair (instead of using the keypair at `~/.config/solana.yml) is b/c ... ?
https://tenor.com/view/monkey-dance-swag-gif-14656700
^^^
😮
ur a king cqfd
So not a PDA, because PDAs *can't* come from a keypair (they're specifically constructed to *not* be actual public keys etc., so they don't have corresponding secret keys)
The file contains a keypair (first 32 bytes are the secret key, remaining 32 are the public key)
😮
```
#[account(init, seeds = [b"some-seed".as_ref(), user.key().as_ref()], bump, payer = user, space = 64 + 64)]
```
This look right?
yes
well it can't be a PDA presumably, so I guess it's just a normal Solana address?
or is it an address that is off the curve (PDA)?
Is it just a normal Solana address?
What exactly is the keypair file generated by Anchor?
If you open up your `target/idl/` file for your program, does it know about that PoolAccount type?
Sorry, not actually sure why that's not working for you (analogous code seems to work fine for me). Are you sure you're updating your IDL etc.?
😮
Thats wacky
<@!134416332509675520>
But yeah, you could use `seeds = [ some_other_account.key().as_ref() ]` to use another account's public key (so sort of naming an auxiliary PDA after that other account)
They can be whatever you want (ultimately bytes under the hood), even an empty list []
Think of the seeds as like an array of "names" for the address, from the perspective of the program
Is seeds like an array of public keys or strings?
(How its used)?
Is there an example of that?
Anchor says, well, I need that info in order to produce a program-side signature, but you didn't provide it, so must have been a keypair address that will sign from the client
aaaa
The fact that you didn't declare `seeds = [...], bump = the_bump`
What makes it a keypair account?
If it were a PDA, then yep, the signature *can't* come from the client, so it won't be required anymore 🙂
I want it to be a PDA
In this case, because it's a keypair account, that signature has to come from the client
When you create an account in solana, the new account's address has to sign
In the idl
What makes this account a signer?
```
    #[account(init, payer = user, space = 64 + 64)]
    pub storage: Account<'info, BaseAccount>,
```
<@!609739117600833554>  -- thank you, this makes sense
<@!166989184513343488> this has steps of deployment, you can try this
(which I can find with `anchor keys list`)
I should then replace the default program id with whatever the generated one is
& it should generate a programId
I run `anchor build` for the first time
so I create my project with `anchor init`
Hmm ... let me try to get this straight
Although I suppose you could use different ones if you want
Usually you'd just use the same id for all of them, once you've got one
So if you're being careful you wouldn't need to redeploy, you'd just anchor build, see your new keypair with `anchor keys list`, correct it, then *rebuild*, then actually deploy
so presumably the program id will change depending on devnet/testnnet/localnnet as well
But yeah, this is a bit of a gotcha: you need to make sure yo *rebuild* with the correct declare_id! before you try to deploy.
The program id is generally created when you run `anchor build`, or you could create your own keypair etc.
https://github.com/buildspace/buildspace-projects/blob/main/Solana_And_Web3/en/Section_3/Lesson_1_Deploy_Program_To_Devnet.md
after I change it, do I deploy again?
Yep, gotta go change those lol 😬
presumably the program id is generated *after* you deploy though
I'm using the default `declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");`
but inside my lib.rs
hmm, when I run anchor deploy for the testnet, I get a program id like "8oRxXtj2Cd7gV3hHMb99xkKoQt9tb39qvwHncYAvjARP"
So is that because all account data is loaded when the program is executed?
D:
Can't, you actually have to pass any accounts you care about in from the client (not possible in solana to look them up dynamically in your rust program based on their address)
how do I use one of the anchor account structs with it
Like when I create a pda
How do I cast a pubkey in rust to one of the accounts?
^

How did you define `PoolAccount` in your rust program?
followed this.

But getting `TypeError: Cannot read property 'createInstruction' of undefined` error
makes sense tysm
It just won't be supported unfortunately—if you think about what you'd be storing on chain, it would be a bunch of addresses that point... to where? To the last time your rust program ran?
a bit new to functional programming to, apologies if its a rhetorical question
is there a solution to this? using Box<> somehow or its just not supported
Nope, they're addresses (exactly what they point at is slightly tricky but they're still just addresses)
Ah, no, that won't work for other reasons too (can't store a vec of references on chain, since you haven't said where the actual UserVaults are supposed to go!)
or are those the same thing
I'll do that, hehe. Another follow-up here is: Are program Ids different from addresses?
Hmm, probably, haven't run into that one before (when in doubt, can always grep the solana source 😛)
this is my code, stripped
```#[account]
pub struct ProtocolDataAccount {


    /// Vec storing user accounts
    pub user_accounts: Vec<&mut UserVault>,
}


pub fn handler(ctx: Context<InitUserVault>) -> ProgramResult {
    let user_vault = &mut ctx.accounts.user_account;

    let protocol_data_account = &mut ctx.accounts.protocol_data_account;
    protocol_data_account.user_accounts.push(user_vault);

    msg!("New User Account Created");

    Ok(())
}
```
it says that clone is not implemented for &mut UserAccount
Hmm now I'm getting "Translating error SendTransactionError: failed to send transaction: Transaction simulation failed: This program may not be used for executing instructions" -- Is this a fancy of saying I passed an invalid program id or something?
You can have a vec of references, yep
My guess is that that `user` account is paying for the initialization of your PDA, but it doesn't have any money
well in my mind, the vector would have to be Vec<&mut UserAccounts>
What do you mean by keep references alive? What goes wrong when you try?
both of these are accounts
is there a way to keep references alive on the rust side? say i make a UserAccount struct, and want to store it in a vec of Vec<UserAccounts> in another struct. is that possible?
Insufficient funds error on testnet. It gives the same outcome, although much quicker.
But the bottom version gives "Error: Simulate error: AccountNotFound"
on the bottom is basically the same thing except using a local keypair (it's a deploy script meant for prod)
on the top, is code that I run using `anchor test` to initialize my program's PDA it runs fine
Does simulation work differently than actual transactions?

Prob because "Testnet typically runs a newer software release than both Devnet and Mainnet Beta." Lemme try
I found deploying to testnet worked better generally
Hi, I'm trying to deploy a program to devnet using anchor deploy; it throws the error:
Data writes to account failed: There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }.
Any idea?
thanks, glad it's simple
Yep, it's just an account, you can even take a look at it in explorer.solana.com
Yeah, it's 10mb in general, but annoyingly if you create an account via CPI (e.g. any time you use `init` in anchor) it's only 10kb 😦
😮
an account
What exactly is a Solana wallet?
Is it like getting a reference to a account to put stuff in it?
What is the point of try_borrow_mut_data?
oh sorry ur talking about something else
isn't it 10mb?
thanks
Take a look at the chat example in the anchor tests
Do you know any example of this?
If you need a bigger account you unfortuntely need to create it in a separate instruction from the client, and it can't live at a PDA.
A single account you create via a cross-program invocation (which includes all accounts that live at PDAs) can only have that 10kb max size.
Nope
Can we create 2 `#[account(init, payer = user, space = 10240)]` in one PDA?
Why I'm doing this, because I'm getting the same `SystemProgram::CreateAccount data size limited to 10240 in inner instructions` error. So i'm trying to create 2 accounts.
You'll have to figure out some way to have an actual PoolAccount.
Nope, you're passing a fresh keypair address, so it definitely won't be a PoolAccount once it arrives in the program.
don't know if this is the correct way to pass
(Or at least, it doesn't belong to whatever program PoolAccounts are supposed to belong to)
Is that `PoolAccount` you're passing in from the client actually a PoolAccount? The error says that the account you're passing in doesn't actually belong to the program
try https://spl.solana.com/token
Getting  `Transaction simulation failed: Error processing Instruction 0: custom program error: 0xa7 ` error. 
```
#[account(mut)]
pub pool_account: Account<'info, PoolAccount>,
```
On commenting these^, everything works fine
Hello guys. What can I use to transfer an NFT in anchor?
ok -- this makes sense


//////////////////////////////////////////////////////////////////////////////////////////

ah brilliant, thank you
Yep. (Armani mentioned this in another channel https://discord.com/channels/889577356681945098/889577356681945101/905881423775412235)
`This commit does not belong to any branch on this repository, and may belong to a fork outside of the repository.`
I think I have found the issue:

https://github.com/project-serum/stake/commit/a72e59a9b263b7e083af737669f12f5e3ee1997c
thank you. let me try
Not sure why the submodule thing fails (fails for me too), but one thing you can maybe do to work around (also not sure why, but it seems to work for me): `git checkout tags/v0.13.2` and then `cargo install --path cli --locked`
Sorry if this has been asked already, but did anyone recently start running into this error when running `anchor build`? 
```
$ cargo build-bpf
BPF SDK: /Users/garfield/Developer/solana/bin/sdk/bpf
cargo-build-bpf child: rustup toolchain list -v
cargo-build-bpf child: rustup toolchain link bpf /Users/garfield/Developer/solana/bin/sdk/bpf/dependencies/bpf-tools/rust
error: not a directory: '/Users/garfield/Developer/solana/bin/sdk/bpf/dependencies/bpf-tools/rust/lib'
```

I can see there's a tar ball in the `bpf-tools/` directory, but keep getting errors when trying to unzip it. Any ideas on how to get around this?
i just forgot it's `provider.wallet.publickey` not just `provider.publickey`
can't think of any other solutions.  Maybe 0.13.2 is using an outdated JS library? The examples on Anchor is using v0.18.0
oh nevermind
I've tried `anchor.Provider.local()` and `.env()` but neither of them have a public key
weird issue, has something changed with how `provider` works?
yes, I tried but it`s same
have you tried the command from the docs with 0.13.2? That is if you are building from source.  https://project-serum.github.io/anchor/getting-started/installation.html#build-from-source-for-other-operating-systems
```
cargo install --git https://github.com/project-serum/anchor --tag v0.13.2 anchor-cli --locked
```

Hello everyone
When I install anchor 0.13.2, I got some error
Plz help me
yeah, thank you. remaining_accounts seems the right approch but I am having difficutty deserialise the data..
Or `remaining_accounts` if it's actually genuinely optional (meaning you might not even pass it at all from the client)
Not 100% this is the best path, but if an account that comes in may or may not be owned by the program, you'll have to declare it as an `AccountInfo<'info>`, not an `Account<'info, Something>`. Bit annoying since you'll then have to do all the anchor deserialization stuff yourself.
not really sure i understand your use case. what is causing the 167 error
but for public accounts, I don't want to load those PDAs because there is no restrections
I am trying to create white list functions so all the config is stored in PDAs.
<@!168868665456984065> can you please help me?
is there a way to do optional pda accounts?
to avoid  code: 167,
  msg: 'The given account is not owned by the executing program'
that struct needs to be the Accounts derived one
ah, ok, so there's no problem with a PDA containing a vec of other PDA then? Using the above example:
```
#[account]
pub struct FooBar<'info> {
    #[account(mut)]
    pub dummy_a: Account<'info, DummyA>,
    #[account(mut)]
    pub dummy_b: Account<'info, DummyB>,
}
```
(not sure if the lifetimes are needed here...)
`#[derive(Accounts)]` is used on the struct that represents the account context structure for an instruction, and `#[account]` is used on structs that represent custom data deserializations for individual PDAs
so as long as my account/struct only uses basic rust primatives, it's just `#[account]`, but when I start composing them I have to use derive?
I have a question about `#[account]` and `#[derive(Accounts)]`. The former is used for the most basic of data structure accounts, anything that includes one of these basic accounts needs to use the latter? 

from tests/composite/programs/composite/src/lib.rs
```
#[derive(Accounts)]
pub struct Foo<'info> {
    #[account(mut)]
    pub dummy_a: Account<'info, DummyA>,
}

#[derive(Accounts)]
pub struct Bar<'info> {
    #[account(mut)]
    pub dummy_b: Account<'info, DummyB>,
}

#[account]
pub struct DummyA {
    pub data: u64,
}

#[account]
pub struct DummyB {
    pub data: u64,
}
```
thanks
Ah, interesting, I tried installing with 1.54 (not nightly, just the regular 1.54 one) and it worked fine. Was about to try 1.53 😛
let me try upgrading rust
found it..It was caused by using rustc 1.54.0-nightly (f94942d84 2021-05-19) which was from before https://github.com/rust-lang/rust/pull/84717 was merged. Update your rustc.
yeh, i dunno, have you googled the error yet
right, macs
I can try with Homebrew , don't have apt-get on my mac
rustc 1.54.0-nightly (5c0292654 2021-05-11)
Also, what version of the rust toolchain are you using? `rustc --version`
```
On Linux systems you may need to install additional dependencies if cargo install fails. On Ubuntu,

sudo apt-get update && sudo apt-get upgrade && sudo apt-get install -y pkg-config build-essential libudev-dev
```
my guess is that you're missing cargo dependencies
well i would still google your error
so you got the error while trying to install anchor
ok
**** cargo install --git https://github.com/project-serum/anchor --tag v0.18.0 anchor-cli --locked
***
cargo install --git https://github.com/project-serum/anchor --tag v0.18.0 anchor-cli --locked
I didn't do anything ..lol. I only run this command on the terminal from the docs
in general just don't use strings
i would investigate why you're getting `no function or associated item named from_str found for struct proc_macro::Literal in the current scope` this error
error[E0599]: no function or associated item named `from_str` found for struct `proc_macro::Literal` in the current scope
   --> /Users/kobe/.cargo/registry/src/github.com-1ecc6299db9ec823/proc-macro2-1.0.29/src/wrapper.rs:926:38
    |
926 |                 proc_macro::Literal::from_str(repr)
    |                                      ^^^^^^^^ function or associated item not found in `proc_macro::Literal`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0599`.
error: could not compile `proc-macro2`

To learn more, run the command again with --verbose.
warning: build failed, waiting for other jobs to finish...
error: failed to compile `anchor-cli v0.18.0 (https://github.com/project-serum/anchor?tag=v0.18.0#229e335d)`, intermediate artifacts can be found at `/var/folders/9f/gl233ql12t38njn6189_5f4m0000gn/T/cargo-installg7pphp`

Caused by:
  build failed
Getting this error trying to build anchor from source so I can use it on my mac
if anything its better that the compute is larger from a dev perspective because you dont have to test two transactions
variable compute is unavoidable if you were going to init with a seperate instruction anyways and both cases have to work
also i work with don so i might be biased
https://discord.com/channels/889577356681945098/889577399308656662/900664796884639826 i think i agree with don on everything he says (not just this part but all of it lol)
Because of the variable compute?
just read up on it and I really dont recommend using init_if_needed, but maybe i am misunderstanding hwo it works lol
waow powerful
This does exist in anchor now though 😛 (`init_if_needed`)
you can write that logic and abstract it out as an endpoint if you want, but you shouldnt put it in your smart contract even if its possible lol
I was hoping to have an endpoint where the user can update information, the first time they hit the endpoint I wanted to init the account, then every other time they hit the endpoint, it just takes it as mutable
Ah ok so I have to handle that logic outside of the program?
yes you can check if the account exists by trying to fetch data related to the pub key and then init it only if the data returns nothing
Hey guys, is there a way to only init an account if it's not already initialised with #[account(init, ...)]?
Hello. I have a problem interacting on live network. 
When I try to interact with the program I deployed, I get this:
```
Translating error Error: Raw transaction j9585MCiCgGh5dKLKdKUmvyR3GV4eM5Cj1TMrtFnSR6J4wfPmGexcxFNbhGQHQCR9tREd6a6eq3EGds7cTJgHtJ failed ({"err":{"InstructionError":[0,{"Custom":167}]}})
```
I have declare_id! matched with programId and the pubkey of keypair in the target folder. 
I had no issue when I was doing this on localhost. 

This is the transaction log:
https://explorer.solana.com/tx/j9585MCiCgGh5dKLKdKUmvyR3GV4eM5Cj1TMrtFnSR6J4wfPmGexcxFNbhGQHQCR9tREd6a6eq3EGds7cTJgHtJ?cluster=devnet

Source code (fails at L72): 
https://github.com/REGO350/macroswap/blob/feature/frontend/migrations/script.ts#L72

Any help would be appreciated! 🙏

Edit: solved
<@!501570363566587905> is it possible to fund an unfunded recipient with Anchor's SPL token CPI wrapper?
I shall spread the good word to others!!!
Ty so much for taking a moment to write that out.
But fyi, rent-exempting 10mb will cost you 70 sol lol 💸 [edit: typo! not 7 sol, 70!]
The max value for `#[account(init, ...)]` stuff is currently only 10kb in solana. For accounts that you set up with a keypair in a separate instruction from the client, you can actually go all the way up to 10mb.
Setting space is basically required, yeah, especially for values that don't have any known size at compile time (no way for anchor to guess for you even in principle)
It unfortunately doesn't grow dynamically—you (currently, solana might change this) only get 1 shot to pick an ok size
Ty for trying it out locally on your end -- I was deep in string encoding stuff lol.
Yup -- you are 100% right it's a space issue. I have 320 bytes allocated.

` #[account(init, payer = user, space = 320)]`

Is it required to set `space`? Ideally it grows dynamically?

And if not, is there like a max value? 🙂
Hmm, I tried doing this locally and can store that string just fine fwiw!
Ahh yeah true 😅 . Seems like it makes sense to always pass in the bump when possible then, unless the client already has the PDA without needing to derive it.
The client actually might still have to calculate the bump, since they probably had to call `PublicKey.findProgramAddress` too 🙃
Gotcha okay. So in this case the client doesn't do any bump calculation and it just gets shifted over to the contract. Thanks you 🙂
Thanks! I tried that by also adding `#[instruction(owner: Pubkey)` and it's unable to assign Pubkey to `token::authority` because it's expecting an `AccountInfo`. I noticed that `token::authority` on a TokenAccount just sets the owner field though. Do I need to do some type of conversion here?
Yup -- so it's funny this works:

`media2.giphy.com/media/2y98KScHKeaQM/giphy.gif?cid=ecf05e47vokqn7k3kac4ybmftxejk041go4dwpit98s0fvvp&rid=giphy.gif&ct=g`

This breaks:

`https://media2.giphy.com/media/2y98KScHKeaQM/giphy.gif?cid=ecf05e47vokqn7k3kac4ybmftxejk041go4dwpit98s0fvvp&rid=giphy.gif&ct=g`
It does a lot for you, including making some choices. You have more control if you do everything yourself.
The version there tells anchor to figure out the bump on the fly. More convenient but more computationally expensive (requires calling `Pubkey::find_program_address`)
Yep, you can use e.g. `#[instruction(the_pub_key: Pubkey)]` and then access it in the `#[derive(Accounts)]` part.
Do you definitely have enough space for the string? Not sure off the top of my head why else it would fail
Also one more question - when creating a TokenAccount via `init`, is there a way to set the `token::authority` via a public key passed in through the instruction arguments as opposed to an Account?
Update -- looks like stuff i working when I lose the `//` from the `https://` lol. No idea whats going on -- some weird escape stuff?
QQ - When initializing a PDA, what's the difference between passing a `bump` through the instruction and then setting it in the constraints versus just having a bump constraint like the following?

```
    #[account(
        init,
        seeds = [b"testing123".as_ref(), test_mint.key().as_ref()],
        bump,
        payer = payer,
    )]
    pub test_account: Loader<'info, TestStruct>,
```
Not using anchor, i.e. just rust with the solana crates
Hey y'all!!

Currently trying to store a plain ole `url`  in a string on the account, but, getting a "failed to serialize account" error.

Is there something in a string like the one below that would cause such an error?

`https://media2.giphy.com/media/2y98KScHKeaQM/giphy.gif?cid=ecf05e470iwpche2qxg35om4rcssmwimn8x0zxeldb51jpd5&rid=giphy.gif&ct=g`.

I tested w/ just a string like `wow_this_is_a_string` and all was well.
compared to what?
Are there any downsides to using anchor?
Perfect. Thanks!
Anchor has a `init_if_needed` attribute, does that work?


//////////////////////////////////////////////////////////////////////////////////////////

I might check it out tomorrow (night time in my timezone) and maybe will update here
not sure how they'd define production ready but they just released a new stable version
I’m curious how it’s possible to convert to solana. Because solana is fundamentally different.
Is solang production ready? I'm not super familiar with it.
hi guys! i've been enjoying using anchor and have followed the usual tutorials for beginning solana development, but what do you guys think of solang and compiling solidity code to be used for solana? what would i be giving up using solang?
At any rate one thing you could always do is just take a look at its bytes, `await program.provider.connection.getAccountInfo(itsPubkey)`, and see what's weird about them.
Hmm, weird. I guess one way you could get that is if you made the account with one version of your program, then upgraded it/changed the structure of that account.
I'm getting a `0xa3` and haven't run into that before. Do any of you have experience with accounts failing to deserialize?
Does this help?
https://github.com/REGO350/macroswap/blob/main/programs/macroswap/src/lib.rs#L37-L73
Hi Team. I am trying to throw some errors from the Anchor contract. I have seen the sample error contract but I am not able to find a contract that can throw both ok and error for different conditions. Any samples or suggestions would be helpful.
This worked ! Thank you <@!194280119710253068>
you can use `web3.SystemProgram.transfer` for SOL
check this out https://github.com/solana-labs/solana-web3.js/blob/master/examples/send_sol.js
```async function main() {
  let tx = new web3.Transaction();
  tx.add(
    splToken.Token.createTransferInstruction(
      splToken.TOKEN_PROGRAM_ID,
      wallet.publicKey,
      to,
      wallet.publicKey,
      [],
      10
    )
  );
  tx.feePayer = FEE_PAYER.publicKey;
  await connection.sendTransaction(tx, [FEE_PAYER]);
}
```
SOL transfer should be simple, no need for token account
what's your code?
oh how do i make one? Thank you 🙏 . im trying to send sol
target wallet does not have token account
hello good devs :), im trying to transfer tokens from a node script but I'm getting this error `Transaction simulation failed: Error processing Instruction 0: invalid account data for instruction`
Here I was thinking I'd never actually use that struct
That appears to fix my problem, thank you sir 🎩
Box<Account> ?
hmm, if I comment out the Accounts struct for the instructions it's complaining about, the errors go away. I've got about 8 accounts that I'm passing to these endpoints, most with 1 or 2 constraints, surely that's not too much
:.:
but it can even be beacuse your using the wrong version of solana
this is usualyl due to local varialbes / arrays
https://brson.github.io/2021/06/08/rust-on-solana there is a lot of reasons why this could be happening
The compiling finishes fine and the program also appears to be working fine, or at least my test cases are passing, though these messages are slightly concerning. Has anyone seen this before / know what to do to get rid of them?
On another note, when I compile the program I'm working on, I'm starting to get some of these errors: 

Error: Function ZN16presale9private8_global20init_account17h30bf23b0e45e3b89E Stack offset of -4288 exceeded max offset of -4096 by 192 bytes, please minimize large stack variables
Error: Function ZN111$LT$presale..instructions..purchase..Purchase$u20$as$u20$anchor_lang..Accounts$GT$12try_accounts17he5935ce1c81ab19aE Stack offset of -4328 exceeded max offset of -4096 by 232 bytes, please minimize large stack variables
so i cant fault you
but look, if iwas a contractor and i knew this existed lmao i would use the laziest thing possible
and check before initing. I would rec doing that
we have a flag that we load up
It's hard for me to not want to use init_if_needed for my usecase, because at the moment I've just got an instruction which inits an account and doesn't trigger any other logic. So I check outside the program if it's been initialised, if it hasn't, I hit the aforementioned endpoint, otherwise I continue with the next instruction. But what you're saying makes sense to me
on the positive side it will make testing your app easier tho so if your trying to code as fast as possible maybe its a good tradeoff
the primiary use case is a security feature for when two people try to create an account on the same blockhash
yeah you are mixing init logic with transaction lgoic its kind of insane and will lead to a lot of bloat and confusion ocne your app gets bigger
Exactly what I was hoping for! <@!867369388608061470> would you not recommend using this functionality though?
Did you already tried custom errors for constraints? With custom errors it's even possible return line in code where error is happened.
I'm gonna stop using `has_one` and start manually verifying the account. The time I spent on figuring out the error is >50% of my dev time. Not worth it
hardest thing about solana is not knowing what the error is
and do some deduction once a token issued to payer
I'd like to access some data. e.g. balance
haha, yeah my rust isn't great either, do you need to do something like:
`ctx.remaining_accounts[3].to_account_info()`?
feel like something wrong with that load fun. but I have only 2 days of rust exp.



what type is your `load` function expecting
this code painiced ..
I am trying to do some type casting
ye
`ctx.remaining_accounts`
hey all, how to access an account from remaining accounts?
Program ID. Aka program address, pubkey of program..

You can first anchor build, then do
`solana-keygen pubkey ./target/deploy/{name}-keypair.json`
And put that pubkey in declare id and Anchor.toml file. Finally, rebuild the program.
what is id in `declare_id!()` ?

try `which anchor` and see if it matches that path in the screenshot

I did, but after installation the anchor version is still 0.18.2
You need the `--locked` on cargo install
I got this error
I put in the program id into the js as well
https://project-serum.github.io/anchor/tutorials/tutorial-0.html#generating-a-client
I'm following this exactly and I get this error when i run the command to execute the client
```
Running client.
Translating error Error: Transaction instruction index 0 has undefined program id
    at Transaction.compileMessage (/usr/lib/node_modules/@project-serum/anchor/node_modules/@solana/web3.js/lib/index.cjs.js:2455:15)
    at Transaction._compile (/usr/lib/node_modules/@project-serum/anchor/node_modules/@solana/web3.js/lib/index.cjs.js:2593:26)
    at Transaction.partialSign (/usr/lib/node_modules/@project-serum/anchor/node_modules/@solana/web3.js/lib/index.cjs.js:2725:26)
    at NodeWallet.signTransaction (/usr/lib/node_modules/@project-serum/anchor/dist/cjs/provider.js:160:12)
    at Provider.send (/usr/lib/node_modules/@project-serum/anchor/dist/cjs/provider.js:78:27)
    at processTicksAndRejections (node:internal/process/task_queues:96:5)
    at async Object.rpc [as initialize] (/usr/lib/node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:11:31)
    at async main (/home/gentle/code/solana/anchor/examples/tutorial/basic-0/client.js:22:3)
node:internal/process/promises:246
          triggerUncaughtException(err, true /* fromPromise */);
```
yea
The anchor folder is the repo of anchor-0.13.2 from git tag
so do you mean cargo install --path ./anchor/anchor/cli?
how come there is nested `anchor` directories like that? that looks like `anchor/anchor/cli`, in which case you'd need `--path ./anchor/anchor/cli` for the cargo install

yes
do you have the right tag checked out?
it succeed to build, but the anchor version is still 0.18.2
let me try
`--path ./anchor/cli` i think you want, if you are trying to build the cli (and that path is correct)
how could i resolve this issue?

Hello everyone
Thanks guys!
Interesting…
I’m using v 0.17 for this
<@!220983109573804032> how did you write a command?
I got this error again

this sometimes pops up when you pass in an uninited account
what version of anchor are you using
Error: 162: 8 byte discriminator did not match what was expected
Has anyone seen this error before/ knows what it means?
thank you
got it
yep
so the --path is local path?
it was mentioned here: https://discord.com/channels/889577356681945098/889702325231427584/905879244507344956
how can i build from source?
would you like to tell me more detail?
yes by checkout out the tag branch and building from source
Yea... it took me 30 mins of experimenting, but I figured it out
sounds like a rust issue. maybe cast them and use floor/ceiling
It keeps erroring at the line I try to divide two i64s as f64s, then round them into an i64 again...
Why does Anchor really not want me to divide two i64s and round them into an i64??????
Alan telepathically caught the error
Yes... I miswrote one of my account constraints
referring to these, I believe, innit? https://project-serum.github.io/anchor/tutorials/tutorial-2.html#clone-the-repo
That was the problem...
Thanks!
There's some `constraint = ...` that failed
What does it mean that a raw constraint was violated??? Am I trying to make Solana do too much?
<@!220983109573804032> have you resolved your issue?
<@!220983109573804032> hello


//////////////////////////////////////////////////////////////////////////////////////////

thanks
sorry guys 😫
Thanks <@!134416332509675520> , it works now! 🙌
Not sure why this happens (I don't use the npm anchor-cli package), but I think you'll have to go change those dependencies in you Cargo.toml to be `0.18.0`, don't think there's actually any 0.18.2 version yet :/
Time to disable @core dev usage?
while running anchor test
my system is x86_64 linux getting this error pls help <@&889579250720575488>
Hmm, not sure if anyone on the core team develops with windows :/ Not sure what's happening there. Will have to wait and see if any windows users on the discord can help out!
Hi, i was following building solana with _buildspace, i run this command 
cargo install --git https://github.com/project-serum/anchor --tag v0.18.0 anchor-cli --locked

but it throw me this error
If you're on mac, you should actually uninstall that npm package (`npm uninstall -g @project-serum/anchor-cli` I think), and instead install things directly with cargo: https://project-serum.github.io/anchor/getting-started/installation.html#build-from-source-for-other-operating-systems
Hey folks, would really appreciate some help with this:
```❯ anchor --version
Only x86_64 / Linux distributed in NPM package right now.
Trying globally installed anchor.
Globally installed anchor version is not correct. Expected "anchor-cli 0.18.2", found "anchor-cli 0.18.0".```
I found this issue, not sure what the fix is: https://github.com/project-serum/anchor/issues/972
OS: MacOS Catalina
Is there a way to fetch all the events emitted using emit! by a program similar to web3 fetchEvents?
is there a more in depth docs around Anchor macros, etc?
Not really sure how it worked. But I'm happy 🥳
And when I plugged that new programID into the Anchor.toml file, the `anchor test --skip-local-validator` thing passed
That command generated a new programID
I ran `anchor test --skip-local-validator` while running `solana-test-validator` in a separate tab
Sorry for bothering you again
Should change Anchor.toml to match it.
Can also run `anchor keys list`, which will tell you what id the program would get deployed at
Is that the ID you expect to be running the program at? When you deployed, what did it say?
Oh, derp, sorry haven't had enough coffee yet—right, that's expected, it gets set by the Anchor.toml file 😛
Hmm this is returning the same programID that is in the Anchor.toml file 🥲
Whoops, sorry, `console.log(program.programId.toString())`
Should I change the ID in the program and Anchor.toml to the ID i received using `program.programID`?
And my Anchor.toml is configured as such:
Ok, `console.log(program.programId) is giving me this image
Ok, let me check that and get back to you.
One possibility is that the id in your `Anchor.toml` file doesn't match the actual deployed program id (you unfortunately have to make these match manually, it's annoying for the moment)
One thing you can do to debug is to `console.log(program.programId)`, just to double check what id you're trying to talk to
It's weird because I haven't written a single line of code yet and running the default test case on the default anchor code 😦
Even when I use the skip local validator flag such as `anchor test --skip-local-validator`, I am getting this error
Hey folks, I was trying out Nader Dabit's beginner Anchor guide (https://dev.to/dabit3/the-complete-guide-to-full-stack-solana-development-with-react-anchor-rust-and-phantom-3291) and I have installed anchor, solana cli, node etc, run the local validator (using solana-test-validator) and run `anchor init mysolanaapp` (the --javascript flag was throwing an error) after that I ran anchor build for the default project that I got and then running `anchor test` is giving me the error show in the image
`anchor build` runs `cargo build-bpf`, plus generates the IDL/typescript stuff. There's also the optional verifiable build stuff that I don't know much about yet.
what is the difference between doing cargo build and anchor build? What all additional sugar does anchor build bring?
Roger that, ty so much for the snippet :). 

And yes, send SOL from one user to another! Appreciate yah ❤️
If the source account is owned by the program itself though, then the program has to send the lamports itself (can't ask the system_program to do it, because the system_program doesn't own the account!): https://discord.com/channels/889577356681945098/889702325231427584/896907918727868476
```.rs
#[derive(Accounts)]
pub struct SendSol<'info> {
    #[account(mut)]
    from: Signer<'info>,
    #[account(mut)]
    to: AccountInfo<'info>,
    system_program: Program<'info, System>,
}
```
How you send sol depends on which program owns the source account. If the account is a user's wallet, it's presumably owned by the system_program, so you have to ask the system_program to do the transfer for you:
```.rs
    pub fn send_sol(ctx: Context<SendSol>, amount: u64) -> ProgramResult {
        let ix = anchor_lang::solana_program::system_instruction::transfer(
            &ctx.accounts.from.key(),
            &ctx.accounts.to.key(),
            amount,
        );
        anchor_lang::solana_program::program::invoke(
            &ix,
            &[
                ctx.accounts.from.to_account_info(),
                ctx.accounts.to.to_account_info(),
            ],
        )
    }
```
Do you mean send sol from one user to another, via a program? Or have a program send some sol to a user? (So, sol that is managed by the program itself.)
Would anyone perhaps have a snippet from the docs of how to send SOL to another user via a program :)? I see a bunch of examples of diff programs in the github repo -- but, tryna find a basic way to implement sending SOL!


//////////////////////////////////////////////////////////////////////////////////////////

Not what I prefer
It works.
Yes, I did. For now I just created a new "baseaccount" keypair so I'm restating with a new account.
Also curious though. if you find the answer let me know!
Did you update the IDL for the client application?
Do I have to take special care when I upgrade a program that is redeployed with the same ProgramId ?
Ok. Stuck again a bit further 🙂
I changed the `ItemStruct` structure in my Solana program to add a "vote" member (i64)
I redeployed my program to the devnet
And now this is what I see in my frontend console.
Got it (after searching the Discord) : 
```javascript
  it('Updates a GIF', async() => {
    // Vote { Up, Down } is mapped using { up: {} } or { down: {} }
    await program.rpc.updateItem(new anchor.BN(0), { up: {} }, {
      accounts: {
        baseAccount: baseAccount.publicKey,
      }
    });

    let account = await program.account.baseAccount.fetch(baseAccount.publicKey);
    let gifs = account.gifList;
    assert.ok(gifs[0].votes.eq(new anchor.BN(2)));
  });
```
Hi. Do you know how to access program enums from Javascript ?
```rust
...
  pub fn update_item(ctx: Context<UpdateItem>, index: u64, vote: Vote) -> ProgramResult {
    let base_account = &mut ctx.accounts.base_account;

    let i = index as usize;
    if i < base_account.gif_list.len() {
      let mut item = &mut base_account.gif_list[i];
      item.votes += vote as i64;
    }

    Ok(())
  }
...
#[derive(Debug, Copy, Clone, AnchorSerialize, AnchorDeserialize)]
pub enum Vote {
  Down = -1,
  Up   =  1,
}

```
How to call this update_item() function from Javascript ?
can anyone take a look at this whenever possible? Trying to follow the Anchor docs' example but it's not working
want my program to have a vanity program id, so it's easy to spot 🙂
how do you deploy an anchor project to a pre-grinded account?
What am I doing wrong?
Hello, I setup a new project via anchor init and ran anchor test which gives me this error:
deploying first doesn't change things. i am on an m1 mac, pretty sure i'm having this issue but unsure how to solve it: https://github.com/project-serum/anchor/issues/876
you might wanna try to change everything to devnet, and try again. also for the M1 chip i need to deploy the program first, change the address in anchor.toml and then run the tests. not sure if this is sth you need to do too
are you using an M1 chip?
yup it's all set to localnet. the program id i left unchanged from anchor init as this is a fresh repo (i've made no changes to code, just trying to get anchor working)
have you checked if youre delpoying to the right testnet / devnet cluster? also have you double checked that you input the right program id into anchor.toml?
trying anchor init and anchor test on a brand new repo i am getting:
```     Error: failed to send transaction: Transaction simulation failed: Attempt to load a program that does not exist
```
thoughts?
does anyone have any good userguides on writing solana program with multiple contracts? i.e. cross-program invocation? I wonder about best-practices, and about things like (1) whether I would have multiple projects spun out, or (2) if I would have multiple files next to each other and (3) if there is a way to deploy them all together. would appreciate any pointers a lot! 🙂
try running solana-test-validator in another terminal
Hi folks, i am come from buildspace course "Build a Web3 app on Solana with React and Rust" section 2. and when i try to "anchor test" in anchor test part. it gives me this error? try to google this thing but no luck. any tips?
I’ll try this and report back
That is EXACTLY what I'm after thank you so much!
https://www.brianfriel.xyz/understanding-program-derived-addresses/
create a PDA with the seed being the user's wallet address
Hello! Not sure if this question fits here or not:

I'm trying to recreate the concept of a user-profile. A user connects their wallet and initialises an account with some details.  'Signing in' from this point forwards just requires the same wallet that was used to create the account.

Creating accounts is pretty straight-forward, but I am struggling with retrieving the account that was created using a specific keypair. My current thought is that I need to generate a new keypair and pass this in along with the wallet signature somehow, but then how would I retrieve the account the next time the user comes back to the site?

Banging my head against a wall with this one. Any help is appreciated 🤦‍♂️
i had this problem earlier, symlinking form brew install location to /usr/local/lib fixed it for me
yea do you have openssl 1.1 installed?
Getting this error when trying to run anchor test: Unable to start test validator. Check .anchor/test-ledger/test-ledger-log.txt for errors.

When I open the log it shows:
dyld: Library not loaded: /usr/local/opt/openssl@1.1/lib/libssl.1.1.dylib
  Referenced from: /Users/GJ/.local/share/solana/install/active_release/bin/solana-test-validator
  Reason: image not found

Any help on how to get this sorted?
That did the trick! Thank you and <@!393352704644087811> for the help!
The default timeout is 5000ms, which might be slightly too small if your computer is struggling or something? Have seen this be an issue once before.
One thing you can also try is to increase the timeout used by `anchor test`. In your Anchor.toml file, try adding a `[test]` section:
```.toml
[test]
startup_wait = 10000
```
This issue might be useful: https://github.com/project-serum/anchor/issues/945
Checking with `lsof -i :9900` doesn't show anything (it does when I'm intentionally running `solana-test-validator`)
I am trying to create a contract where user comes to my website and if he has sepcific NFT he can mint some SPL token but he can only claim 100 at max for 1 day. Does somebody know how to approach this ?or any sample examples which I can look at
I think you'll have to stop the `solana-test-validator` if you have it running already.
Hello! I'm having some trouble with `anchor test` in Ubuntu WSL

Running `solana-test-validator` works fine, but when running `anchor test` it says `Unable to start test validator. Check .anchor/test-ledger/test-ledger-log.txt for errors.`

And the logs are just this:
```
Ledger location: .anchor/test-ledger
Log: .anchor/test-ledger/validator.log
Initializing...
```
Hmm it's already disabled in settings.
Good idea.


//////////////////////////////////////////////////////////////////////////////////////////

mainly because im not sure what exactly declare_id() does in the background
my brain is tired rn so idk the exact technical details
and so it errors out
because if you dont then the program is deployed at the new address but the placeholder one is in the lib.rs
oh, yeah, i was doing camdens and i figured out you have to do that
no the buildspaces one
camden's?
I'm following a tutorial right now that suggests running `solana address -k target/deploy/projname-keypair.json` to get the program id and then updating `Anchor.toml` and `lib.rs` with the new keypair. Anchor's terminal output/documentation implies to me that it automatically makes this switch on deploy, so that step is unnecessary. Is that correct?
so you can only pass 1000 bytes into the data byte array?
Here's some information that might be helpful for learning about how stack frames/the heap work in solana: https://docs.solana.com/developing/on-chain-programs/overview
Box is rust's way of putting something on the heap, as opposed to directly on the stack.
<@!867369388608061470> "boxing" accounts did the trick, but i still don't know what it does. can you please tell me where i can read up on it?
Let me know if showing me Cargo.toml will help at all
I've been stuck here fro quite some time. I tried adding `resolver = "2"` to my Cargo.toml, but same issue. I'm a beginner on managing cargo files, and apparently need to change something with my versions. But my Rustc, rustup, and cargo are all up to date. Haven't been able to find a solution for this. 

Came in through the Buildspace.so Solana project.
```tayyab@tayyabs-MacBook-Pro arsenalGIFBoard % anchor test     
BPF SDK: /Users/tayyab/.local/share/solana/install/releases/1.7.3/solana-release/bin/sdk/bpf
Running: rustup toolchain list -v
Running: cargo +bpf build --target bpfel-unknown-unknown --release
error: failed to download `solana-frozen-abi v1.8.2`

Caused by:
  unable to get packages from source

Caused by:
  failed to parse manifest at `/Users/tayyab/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-frozen-abi-1.8.2/Cargo.toml`

Caused by:
  feature `resolver` is required

  consider adding `cargo-features = ["resolver"]` to the manifest```
what does boxing an account do? how can it help with fixing the issue with stake frames?
it seems i have too many accounts in my context 😕  if i remove even one, it works fine... but there are only 8 accounts in the context, i wonder why it should be a problem 😕
if you want to store 10K items the way to go is probably split the data into 10K accounts 🤔
it's the first time i hear about stack frames. where can i read about it?
Thank you for that answer! Looks like I may have to do some off-chain magic to get that working the way I like! 🙂
My understanding is you get all of the accounts, no pagination (kind of surprising...)
Hello, when using ```program.account.someAccountType.all()``` does it limit how many accounts that will be fetched? If so, how do I adjust this limit so that I can do pagination?
How to do that manually? I have idl.json and want to decode buffer in web3?
Not sure anchor exposes this directly, hmm.
One way to more-or-less make a map (more-or-less) is to use program-derived addresses. A map with keys K and values V would be a bunch of program-derived addresses with seeds K and accounts V.
Hi community, does any one know how to use map with anchor on Solana program?
hi, is it possible to get layout from idl?
Hope y'all are doing well!

Im trying to store state (for about 1000-10k) items. Should I use solana Vectors / Arrays within an account struct, or is there another better way to proceed?

Any thoughts and pointers welcome! 🙂
Yeah, in general that means you blew solana's 4kb stackframe budget. You can potentially sneak around it by using some extra `#[inline(never)]` functions (to get a fresh 4kb stackframe to mess around in—the `#[inline(never)]` annotation says, no, seriously, give me a fresh stackframe).
not 100% sure but i think this error happens a bunch when you blow the stack by using a vec  /unboxed account
hi, i'm trying to transfer tokens via cpi and i get a cryptic error
`    'Program failed to complete: Access violation in stack frame 3 at address 0x200003f08 of size 8 by instruction #11953',`
is there a way i can debug it?
That worked, thanks!
Yes, just did the same!
Upgrade your nodejs
any one else facing this?
I see the same issue which was closed 12 hours ago, https://github.com/project-serum/anchor/issues/988
Hi, any one else facing "ReferenceError: TextEncoder is not defined" issue when running anchor test in basics-0?
ty!
ahh so the provider wallet automatically signs, and since we've specified `user = wallet.publicKey` solana makes the connection between those two.
the signer is handled at the start when you create an anchor Provider  at the beginning
Quick q about the "Arguments and Accounts" tutorial, we initialize ```#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 8 + 8)]
    pub my_account: Account<'info, MyAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}```
But when  we call the `rpc.initialize` instruction we only sign with `signers: [myAccount],` where ```const myAccount = anchor.web3.Keypair.generate();
```
Since the `user` is the payer don't we also need to sign with the `user`? Or is this something handled for us by anchor?
Thank you soooo muchhh !!!!!!!!!!!!
As cqfd said seems like transactions are limited in size. Read this: https://docs.solana.com/proposals/transactions-v2#other-proposals (it's an accepted but not implemented proposal I believe). I thought about splitting my base64 string into multiple parts and creating multiple transactions from the frontend to later on union them in the program. The only problem with this is that it would be annoying for the user to approve multiple transactions 😦 I don't know if there is a way to approve multiple transactions in one single time 🤔
You can get the connected wallet's address with `window.solana.publicKey`, and then can go fetch its account info with a solana web3 connection, `await connection.getAccountInfo(window.solana.publicKey)`. This includes their balance.
I would also like to know about this
hi is there a way to get the balance of the connected wallet through the window.solana or wallet object, (talking about frontend)
thanks for the reply <@!134416332509675520>
Thanks for the reply!
Only by passing the user b as one of the accounts (it's not possible in solana to have your program dynamically look up an account info based on its address—you have to pass that address in from the client so that it shows up in your program as an account)
One issue you'll run into is that transactions in solana have to be quite small, only 1232 bytes! This means that you won't be able to fit that 80kb image into a single transaction; you'll presumably have to do something like what solana program deploys do, which is carve up your program's code into lots of little ~1kb chunks and glue them together into a single account on-chain.
hey guys! nice to meet you all! I'm trying to use a program to send sol from user a to user b, I saw an example above that you can do a method that will use the signer wallet and you need the user b account info, is there a way to get the user b account info from his pubkey?
Hey people 👋  I am trying to send a base64 string image to my Solana program and I am getting "**RangeError: encoding overruns Buffer**". The string is really long (80kb or maybe more). I think this is related to buffer-layout. I am kinda new to this stuff so I was wondering if there is something from anchor that might be limiting my buffer? I see for example that here https://github.com/project-serum/anchor/blob/ec26966340729c7ce3d22509355254c7d9ee5b2a/ts/src/coder/accounts.ts#L34 there is a line which allocates only 1000 bytes and maybe this is my problem. Or maybe there is another way to send the image and my approach is entirely wrong 😅
https://www.brianfriel.xyz/understanding-program-derived-addresses/
this might help
Where is the documentation for the Anchor.toml? full description of each property and options, etc ?
i think it lists all tokens, not sure if it only takes from a specific whitelist tho..
pretty sure you can just use the solana explorer
No. On the devnet. anchor test works
hey guys, how can i check wether an account holds a particular token or not from my custom contract?
what is the `bump` variable that I always see when generating a PDA?
when tryin to build stake program using anchor getting this error
C:\Users\varun\stake>anchor build --verifiable
Error: Unable to deserialize config: missing field provider at line 1 column 1


//////////////////////////////////////////////////////////////////////////////////////////

Hello, does anyone know the best approach or have an example to deserialize a metaplex meta account in your program?
so there's no way to make a game like this on chain?
Also, I think the general approach here won't work (solana accounts are public/anyone can see the transactions your program does)
i see
but you're saying if someone knows the public key of a player, they can derive the address
the client can know his/her own key
You'll almost certainly need to be able to calculate those same PDAs from the client too, which will mean the client needs to know those secret keys
so i think i need a PDA for each player, and i want the seed to be something only the program has access to
well i'd like to make a game where everyone places a bid, but i don't want the other players to be able to see what anyone else has bid
Can you say more about why you want to do that? At first glance it sounds like a bad idea haha, but I may be misunderstanding you
is there a way to access the private key of the program itself from the runtime? i want to use it as the seed for a PDA
I want it to be like how orca/raydium show how much user/account have accumulated till that time period to harvest.
thanks Alan ^^
2 alphas in 1 answer
But at any rate, by default programs in solana are upgradeable, so you can just change the declare_id! and deploy again if you want 😛
So it's not deploying so much as `anchor build` that makes that key
`anchor build` will generate the key if it doesn't already exist, and then you can run `anchor keys list` to snag it
Something i haven't been able to figure out:
Anchor build doesn't give me a public key to use as program_id on top of my lib.. It only gives me the public key after anchor deploy, which, as I understand, makes it too late since "it's deployed" ? What am I doing wrong that i'm not getting the key after build ?
Hi if I want to write a program which talks to another program, how can I mock/use the other program in a setup with `anchor test`?
thank you very much!
So like you could calculate the space on the client, or so something like
```.rs
#[deriveA(ccounts)]
#[instruction(the_data: String)]
pub struct MyAccount {
  #[account(init, space = the_data.len() * 2, ...)]
  ...
}
```
alright, thanks for the tip, i'll try it! 👍
So yeah, technically you could do dynamic allocations
aha
Ohh, sorry, I misunderstood—you can actually specify whatever expression you want for the right-hand side of `space = `, and you can use instruction arguments too with the `#[instruction(...)]` macro
okay, so if i got it right, there is no way you can allocate space for a being initialized account on the fly, each account of the same type needs to be exactly the same length, or is there?
E.g. if you're ok with up to 100 ascii characters, then you'd need 104 bytes of room for those strings
Ah, no—I'm saying you'll have to pick an appropriate amount of space (whatever seems reasonable to you). If you try to `Default` your way out of specifying space, you'll only allocate enough for an empty string.
so just reserve 4 bytes for the length? but what about space for the data itself? does it just magically get allocated?
If you use a `String` type, you will necessarily have to specify `space`. If you try to do the `Default` approach you'll end up allocating too little. The default string is empty, and will get 4 bytes in Borsh's encoding scheme (every String gets 4 bytes at the front for its length).
so if i were to use a `String` instead of a byte array, would there be a way to allocate the space for an account on the fly (given it's being initialized by the instruction)? unfortunately i couldn't find any code examples, though i've been searching for a few hours 😕
thank you!!
ah actually i just realised i have two json files in the `./target/idl` directory with two different names, i think that could have contributed to the error somehow? 
let me try to rectify that and see if i still get this error
Right file, just higher up
No, I'm curious about the instruction part (it will have data about those accounts, which ones need to be mutable, which need to sign, etc.)
so its this you were referring to? 
`"metadata": {
    "address": "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"
  }`
0.18.0
What anchor cli version are you using? `anchor --version`
`anchor build` will stick it in the root of your project, in the `./target/idl` directory
K, yep, that looks fine too
sorry, where can i find this?
this is it: 
` #[derive(Accounts)]
pub struct StartStuffOff<'info> {
  #[account(init, payer = user, space = 9000)]
  pub base_account: Account<'info, BaseAccount>,
  #[account(mut)]
  pub user: Signer<'info>,
  pub system_program: Program <'info, System>,
}`
You can also look directly at the idl, in `target/idl`, and see which of those accounts was expected to sign
Hmm, that snippet looks fine. Can you show me the corresponding `#[derive(Accounts)]` struct?
haven't been able to find any solutions online so far and trying to ask around
is there any reason why i would have signed a tx with a 'wrong' address?
hmm i see. for context, im new to solana dev but have some experience in eth, am currently doing the buildspace project and this is how i declared my signer: 
` let tx = await program.rpc.startStuffOff({
    accounts: {
      baseAccount: baseAccount.publicKey,
      user: provider.wallet.publicKey,
      systemProgram: SystemProgram.programId,
    },
    signers: [baseAccount],
  });`
That means that you accidentally signed the tx with an address that wasn't meant to sign (maybe surprising that this would be an error, but it is)
hi all, first ping here. 
just wondering if anyone has run into an `unknown signer` error when running `anchor test`?
check the escrow example in `anchor/tests`
Would anyone have a snippet on how to send SPL token from one user to another user via program? I couldn't find any good examples on the docs
What kind of applications are you guys developing?
It can be used for anything, it makes it easy to develop programs on Solana
Is it only used for voting systems?
What are the different possibilities of anchor?
Yes you can!
Also check if the creators array has been signed
Hey GM guys! I have a beginner question. Am planning to do a mini hackathon with one of my peers this weekend. I was looking up voting systems and anchor came up. Can I use anchor to build a voting system for users who minted my tokens & allow them to vote on different projects (or parties as mentioned on the reade.me)?
What do you mean by fake here? If you know the mint its supposed to be from, you can just verify that the user is the owner of a token account with that mint, with amount = 1.
Working 👌
17, let me update it
Seems to work for me, are you on 0.18.0 for anchor?
`#[account(init, payer = user, space = 1024, constraint = false @ ProgramError::Custom(1234))]` fails to compile during macro parsing. Why?
I have tested and I know the answer for the second question (no).
How can I verify the NFT the owner holds is not fake in program ? I guess by checking the metadata on it and check the creators array ?
Asking in general.I have started writing the program so far I have achieved is transfer of SPL token from x account to y account.
(2 different questions)
Could someone point me to some examples of how to use custom error? What am I supposed to put after the '@'? Also, I have an account with `init`; if I add a `constraint` to that account and the constraint fails will the account be initialized/created?
Showing that the user owns a specific NFT amounts to submitting that token account and having the user sign with the token account's owner (that proves they own it).
What have you tried so far? Are you mainly asking about how to implement the 100/day max part, or general stuff about writing a program that interacts with the spl-token program?
I am trying to create a program where user comes to my website and if he has sepcific NFT he can claim my token which I created using spl-token create token but he can only claim 100 at max for 1 day. Does somebody know how to approach this ? or any sample examples which I can look at.
thank you!
This repo has an example of a program-controlled mint: https://github.com/cqfd/anchor-token-studies/blob/main/programs/token-studies/src/lib.rs#L34 No USDC, but you could tweak the `airdrop` instruction to first take some USDC from the user (they'd have to submit a USDC token account with the transaction and sign the tx with its authority/owner).
im looking to create a smart contract that mints a token for every usdc token given to it. anybody can point me in any direction to help with this?
There is no 0.18.2 tag, `anchor-cli` was not bumped in the repo.
my anchor cli version is latest 0.18.2 but there's no corresponding tag so???
I am trying to use solana-sdk. I put `solana-sdk = "1.8 .1"` in my cargo.toml but that causes an error with crate::sys
works, thanks. will have to learn to use search function in this discord👍
on the other end this
```
lang: Language::Rust,
```
turns into this
 ```
"lang": {
  "rust": {}
}
```
can I pass something from JS anchor as an enum to an anchor rust program? cannot seem to find a datatype for that in the JS API 
 or should i pass as a string and match it?
# showcase https://dennyssolissv.github.io/dragongif/
#showcase   https://dennyssolissv.github.io/dragongif/
Hello all, how can I write a rust function to send sol from one account to the other? Please help me with the resources.
hello all, on renaming a module, my tests start to fail because the workspace seems to be the old name. is there way to change the name of an anchor workspace?
So the enum syntax is just a little funky
It would look like
```.js
    let ix = program.instruction.whatever(new anchor.BN(123), new anchor.BN(10), { name: 'Bid'}, {
      accounts: { ... }
    });
```
unfortunately I can't at this particular example..
like
```
onst dataLayout = struct([nu64('tokens'), nu64('minTokens'), ???]);

  const data = Buffer.alloc(dataLayout.span);
  dataLayout.encode(
    {
      tokens,
      mintokens,
      side,
    },
    data,
  );

```
Can you use anchor to do so? `program.instruction.someInstruction`?
I am trying to build TransactionInstruction using JS
Hmm, not sure what you mean. Are you asking what the struct would look like in rust? I think I'm just not sure what you're trying to do
I mean, I am trying to encode/decode it using buffer layout.
yes
Do you mean how do you call it from JS?
I would appreciate if someone can tell what struct looks like when idl args are:
```
"args": [{
        "name": "tokens",
        "type": "u64"
    }, {
        "name": "minTokens",
        "type": "u64"
    }, {
        "name": "side",
        "type": {
            "defined": "Side"
        }
    }
]
```
```
{
    "name": "Side",
    "type": {
        "kind": "enum",
        "variants": [{
                "name": "Bid"
            }, {
                "name": "Ask"
            }
        ]
    }
}
```
Yeah
only place i've needed to use it is to validate the existence of a mint authority on a mint address which uses coption
and option just add 1 byte to the byte size of the generic correct?
Not actually sure when you need to use COption 🤔
Borsh handles regular Options fine as far as I know?
if an account needs to have an `Option<T>` in the data is it better to use the solana `COption` and or standard one?
Yeah. Though in fact, using the `Default` approach above amounts to calculating the space dynamically 😛 since under the hood anchor will construct an instance of your struct via `MyAccount::default()`, try serializing it with borsh, and just check how many bytes it ended up taking.
by "calculating the space manually" i meant adding `space = 8 + 32 + 32 + 256 + 8 + 8` in the account declaration, not calculating it dynamically 🙂
Right, your example above could be done statically, I just mean it's not possible in general.
i reserved 256 bytes, it ought to be enough for my needs
In general you might have to specify space manually, since for some types it's not possible to calculate a value statically (e.g. for a String—you need to pick how much space to use).
Thank you serr, yeh, hope I get to ask A f2f tmr
Anyone know where the documentation is for `Anchor.toml` and all the options?
easy peasy
```
#[account]
#[derive(Derivative)]
#[derivative(Default)]
pub struct MyAccount {
    ...
    #[derivative(Default(value = "[0u8; 256]"))]
    title: [u8; 256],
    ...
}
```
why should i bother? and by the way, i got it working with use of `derivative` crate
https://paulx.dev/blog/2021/01/14/programming-on-solana-an-introduction/
this talks about how to do it from Solana's JS client library, not sure about Anchor :/
I have idl with args for instruction data (one is enum). How to build struct in web3 (I can give example)?
sorry for bothering again, i've stumbled on another issue. i want to add a byte array to my account data, but avoid calculating space for the account manually.

after i removed `space`, i got `the trait Default is not implemented for [u8; 256]`, so i added a new struct

```
#[derive(BorshSerialize, BorshDeserialize, Clone)]
pub struct Title([u8; 256]);

impl Default for Title {
    fn default() -> Self { Title([0; 256]) }
}
```

the program code now compiles, but i get the following error `IdlError: Type not found: {"name":"title","type":{"defined":"Title"}}`

could you please give me a hint how i can proceed?
Probably stupid question

I have two RPC calls from two signers, how can I group the instructions and put them into the same call?


//////////////////////////////////////////////////////////////////////////////////////////

<<<<<<< HEAD
```
let account_data = await program.account.MyAccountType.fetch(
        account_address
    );
```
Haha, with hindsight that was a dumb question... <@!501570363566587905>  you are the best for answering dumb questions!
Thanks!
fetch the account
How do I check in JS if a PDA has been initialized yet?
Hmmm thanks!
Make sure it's `pub` and derives `AnchorSerialize, AnchorDeserialize`
How do I fix that???? Do i need to re-init the idl
The `Data` type is not in the IDL
I checked the idl, and it exists and is correct

IdlError: Type not found: {"type":{"defined":"Data"}}
Has anyone seen this before?
you can also do 
solana logs
in the terminal to stream logs
./anchor/program-logs/...
ohh got it
how do I check the program logs when running `anchor test`?
Got it, thanks!  I realize one can also get around this by creating a dummy wallet.
a true maybe that was relaxed, i forgot
in my experience you can leave wallet undefined and you can still `fetch` with your program
is there a way to get the total supply of an spl-token via `anchor_spl::token` or otherwise?
my workaround is to make a provider with a stub wallet, so it can be used even when the user isn't connected. By stub i mean an object with the same interface
Hey I am wondering what is a good way to create a JS client that is used to only to read the on chain state.

I understand that there is  Program class, however it requires us to pass in a Provider. It will be difficult for us when the the users are not connected to their wallet. 

Is there a way to create a JS client from IDL that is only going to read the onchain state?
ah i have had this happen as well except when changing the program name!
This ended up being a sneaky missed step, surprisingly hard to spot while debugging: we weren't rerunning `anchor build` before `anchor deploy`, after having propagated the new program id everywhere. This meant the `anchor deploy` step was still using the old `.so` with the now-stale id embedded in it.
Not that I know of. Currently you need to take that hex code, turn it into decimal (e.g. 0xa7 = 167), and then go look it up in `error.ts` lol. Then start source-diving through anchor 🤿
it builds, just doesn't actually run
another question: is there a good tutorial on debugging the rust portion of my program? i'm getting errors but i'm not sure which line is causing them (e.g. in the macros, in the function, whatever)
Hmm. Sent you a dm in case you want to try screensharing
thanks
Or a fixed PDA you use as a program authority thing, with e.g. `seeds = [b"im-the-program".as_ref()]`
I thought this as well, but my `App.js` file is a whole different directory. I actually copy paste the `idl.json` file into the React App manually.
You'd use some program-derived address (it could even be the token account's address!). It just needs to be something the program can sign for (aka a PDA, not the program id itself)
I think that trace must mean that your program id is somehow wrong (the call to the system program succeeds!). So I wonder if something is weird about your idl? And it's somehow getting fixed by running anchor test?
if i want to create a PDA token account (i.e. the program itself can spend what's in the token account), what do I use as token::authority? the program_id?
Hmm... interesting, that's pretty weird/definitely not expected. Trying to think how that could happen.
So, I'll run `anchor test` right after this and bam I'm able to run that `create` counter function properly.
It's the `program.rpc.create` line.
Huh. Which part gives you the 167 error? Creating the account? That's pretty surprising to me 🤔
(rlly appreciate the help here!!)
Same way as in the test, just on a React App :).

https://gist.github.com/farzaa/621d146ed1a3a8820644b9fd05624321#file-app-js-L91
And how are you interacting with the program? Outside of a test that is
Ahhh that would make good sense!! Just added my program and test on a gist.

https://gist.github.com/farzaa/2e9d23f9bc7abe2345e9d8ff0e53df64
Ok, then it would be interesting to see what your tests are doing/what accounts they set up. If you just do `anchor deploy` and then try to interact with the program, it's definitely possible that some account hasn't been set up yet (as a side effect of the tests), in which case you could get that 167 error.
Super weird yah, just triple checked just now. Just gives me 167 if I don't do an `anchor test` on a fresh program.

Also, looks like `anchor test` is actually running on devnet, since that's what my config is set to 😄 

Confirmed on Solana Explorer that the tests run on devnet.
Hmm... I'm actually not sure what would cause that. Running `anchor test` against your local validator I think just, like, runs the tests, so not sure why it would have an effect on that error.
Mm, if you really want a whole new program you'd have to generate a whole new keypair etc.
Ah got it -- and what if I wanted to run `anchor deploy` with a fresh state -- where its essentially deployed to devnet as a whole new program account.
Hmmm -- super weird, I've done this a few times now. And doing exactly this. But, whenever I don't run `anchor test` before deploying, Error 167 pops on up :o.
No, shouldn't be necessary—the error you're getting, 167, is often because your `declare_id!` doesn't match the address your program is actually deployed to (kind of annoying, but for the moment you have to manually get this right)
If you want to run anchor test with a fresh state, you'd ordinarily not run a local validator in the background—you'd just let anchor test spin one up for you
Haha interesting, every time I follow the steps below without `anchor test` I end up getting that error above!

```
anchor build

solana address -k target/deploy/mysolanaapp-keypair.json

// Update Anchor.toml (make sure on devnet), lib.rs

anchor test

anchor deploy

// Update idl.json on web app.
```
Is it needed to run `anchor test` before running `anchor deploy`? Noticing that if I don't do this, I get this error upon trying to interact w/ my program on **devnet**: `Error: 167: The given account is not owned by the executing program`.
W/ Anchor, as I re-deploy my updated program -- it seems to keep the same address which means data I had stored on that program account sticks around as well which is a bit odd no?

When I redeploy, how can I make sure it's deployed as a brand new program?
ohhhh okay, will dig into those two files, thank you very much for the fast reply, greatly appreciated, i am happy to get anything working !!
Tbh I'm not sure why you're running into this issue though, so quite possible there's another way to fix it—but I think this will probably work for now?
There's probably a line `anchor_lang = 0.18.2` in one of the Cargo.toml files in your project (I think, guessing), and a similar stray 2 in package.json
thank you so much for the reply, i am a super noob, so when you say change all of those to be 0.18.0 are you referring to the error about the candidate versions? does that imply i have these versions locally stored and would go in and adjust them in my file system or?
Ah, hmm, can you try changing all of those to just be 0.18.0?
Which should be similar to how `spl-token` does things
For signing I simply put an account's creator public key inside, so they need to sign only with their own account
hello, i asked this question in solana dev and was directed here,

i am following a beginner's guide by Nader on solana dev, and at the anchor build step i am getting this error:

``` Failed to obtain package metadata: Error during execution of `cargo metadata`:     Updating crates.io index
error: failed to select a version for the requirement `anchor-lang = "^0.18.2"`
candidate versions found which didn't match: 0.18.0, 0.17.0, 0.16.2, ...
location searched: crates.io index
required by package `mysolanaapp v0.1.0` ```

im wondering if its caused by the anchor init command as that prints the following:

```Couldn't find any versions for "@project-serum/anchor" that matches "^0.18.2"
? Please choose a version of "@project-serum/anchor" from this list: (Use arrow keys)
```
but it doesnt let me choose a version it just completes, then the next command to build fails out, i didnt find anything in google so if anyone has any suggestions i am all ears
Yep, thank you!
Mm, what do you mean by useless? You can definitely still sign with it (it's the only way to sign for that address), but whether or not that matters depends on what you're doing
As you can't sign with it anything anymore, at least for transfering lamports
To reiterate, after transfering ownership the private key becomes completely useless
This was the question
Ah, yes, thank you
Yeah, but can an owner of a signature transfer lamports from it
And if your program owns the account, only it can drain those lamports (no one else, human or program or otherwise)
If your program owns the account, it can transfer/drain those lamports without any signature (maybe it asks for a signature just to be polite, but it doesn't need to!)
But this signing can be used for transferring lamports from it and thereby closing it
Hi, I'm trying to learn anchor framework but could not run the `basic-0`. I am currently using `kali-linux` on `wsl`. Solana, and anchor are successfully running. I am now confused with `solana-test-validator`. Up to when it continues the test. it processed almost 17000 slots and it is still running. How can I get the program ID for my `basic-0` tutorial?
No, don't think there are any nefarious use cases (just signing for the address, which your own program may or may not care about)
It seems like it can't because of an ownership change
But can its private key still be used by the creator for some nefarious purposes
Usually, yes (unless you specify other attributes, like `token::mint = some_mint` etc.)
Say I create an account with `init` attribute. Now it should be owned by my program, right?
Ah, sorry, misread
I used it as an example
No, I'm not talking about `spl-token` here
A token account's "owner" is kind of confusingly named—it's not the same thing as a general solana account's owner :/ In anchor terminology, it's the token's "authority"
I think it is obvious from hindsight. Though I still want to see solana's source to be completely sure
Well, I think I found an answer in that paulx's useful blogpost 
> The account owner is an internal Solana attribute that will always be a program. The new token owner attribute is something the token program declares in user space (i.e. in the program they are building). It's encoded inside a token account's data, in addition to other properties (opens new window) such as the balance of tokens the account holds. What this also means is that once a token account has been set up, its private key is useless, only its token owner attribute matters.
Which, if I understand correctly, says that when an ownership of an account is changed to some program, its private key becomes useless, and now only a program which owns an account should be able to fiddle with its funds
And what users would still be able to do with those accounts, as it is still possible for them to sign transactions with private key for this account
I'm mostly asking this to be aware whether I can use user supplied addresses instead of PDA's, as I need to have more than a single data account for each user
Also I remember I read somewhere that ownership can be changed only once, but I don't see it mentioned in the docs here
https://docs.rs/solana-program/1.8.2/src/solana_program/system_instruction.rs.html#157
Which would mean the private key becomes useless after an ownership change, right?
Yeah, in general closing an account just requires draining its lamports. Whether that requires signing depends on which program owns the account (if your own program owns the account, then it doesn't require a signature)
Also another relevant question with `close`ing accounts. Shouldn't accounts be signed to be able to close them? I think I used them with `close` attribute but they weren't signed by anyone, even though the program did own them, or is it enough?
I guess I would at least need to add a `bool` to cover this case, `Option<T>` should be better, but it doesn't work right now iirc
It would be painful
Oh, which would mean I could close an account, and in the next instruction someone might resupply it and use again?
and https://discord.com/channels/889577356681945098/889577399308656662/904457662387871836
I had the same doubt and ran into the same bug. Check out: https://discord.com/channels/889577356681945098/889577399308656662/904456667809341470
it's working <a:party_parrot:899093647033782292>


//////////////////////////////////////////////////////////////////////////////////////////

Only thing I know of is the pyth example in the tests/ folder.
I have an "Error: 162: 8 byte discriminator did not match what was expected"  And saw responses to <@!847130012879814668> 's question on this earlier - I'm using anchor v0.18 and am initializing the account passed in so not sure what's going wrong. My account validation logic is below. Thank you very much!

#[account]
pub struct OfferAccount{
    pub offeror_key: Pubkey,
    pub offeror_deposit_token_account: Pubkey,
    pub offeror_receive_token_account: Pubkey,
    pub offeror_amount: u64,
    pub acceptor_amount: u64,
}

#[derive(Accounts)]
#[instruction(offer_vault_account_bump:u8, offeror_amount:u64)]
pub struct OfferEscrow<'info> {
    #[account(mut, signer)]
    pub offeror: AccountInfo<'info>,
    pub mint: Account<'info, Mint>,
    #[account(
        init,
        seeds = [b"offer-seed".as_ref()],
        bump = offer_vault_account_bump,
        payer = offeror,
        token::mint = mint,
        token::authority = offeror,
    )]
    pub offer_vault_account: Account<'info, TokenAccount>,
    #[account(
        mut,
        constraint = offeror_deposit_token_account.amount >= offeror_amount
    )]
    pub offeror_deposit_token_account: Account<'info, TokenAccount>,
    pub offeror_receive_token_account: Account<'info, TokenAccount>,
    pub offer_account: ProgramAccount<'info, OfferAccount>,
    pub system_program: AccountInfo<'info>,
    pub rent: Sysvar<'info, Rent>,
    pub token_program: AccountInfo<'info>,
} 

And the JS for the offer_vault_account which I suspect is causing the issue:

  const [
      _offer_vault_account_pda,
      _offer_vault_account_bump,
    ] = await web3.PublicKey.findProgramAddress(
      [Buffer.from(anchor.utils.bytes.utf8.encode("offer-seed"))],
      program.programId
    );
```To resume a deploy, pass the recovered keypair as the
[BUFFER_SIGNER] to `solana program deploy` or `solana write-buffer'.
Or to recover the account's lamports, pass it as the
[BUFFER_ACCOUNT_ADDRESS] argument to `solana program close`.
=====================================================================
Error: RPC response error -32601: Method not found 
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "",```
Looks like I can't deploy to devnet, any idea please ? Thanks a lot!
This question if for C# #anchor devs.
I'm stuck of how to make a call to an anchor function from a solnet wallet client.
Did any of u figure it out before?
Thanks.
Great, I'll have a look 🙂
look at the anchor tests. I know there are plenty examples in the various programs
https://docs.pyth.network/#consumers
check the test directory for references to pyth. I'm pretty sure they aren't any. edit: I stand corrected
I tried specifying some constraints `constraint = token_mint_account.mint_authority == COption::Some(*bond_authority.key),`
 `constraint = token_mint_account.supply == 0` and also the `owner` field but to no avail. Any help would be much appreciated.
Hi there, I just started getting my hands dirty with solana developement using anchor today and I'm loving it. It is however tough to resolve issues :). My question is about using Mint from the anchor_spl crate. When I try to define a mint account such as `token_mint_account: Account<'info,Mint>` I get an error stating that the trait `anchor_lang::AccountSerialize` is not implemented for `Mint`  and the analogous error about deserialization. I also get the error stating that the Owner field wasn't specified.
<@!477913575726383125> it should be similar to this https://blog.chain.link/how-to-build-and-deploy-a-solana-smart-contract/ similar to solidity, it shouldn't be possible to make API calls  from a solana program... it wouldn't be deterministic if you could directly make external calls...with an oracle, it would make an API call on your behalf and update the state... alternately you can do the same thing by having an external program/script update an account state on chain... (i'm assuming here that solana works similar to eth in terms of requirements, but someone can correct me if im wrong)
<@!501570363566587905>  are there any examples of oracle interactions through anchor ^^^
Yeah, agreed, figured that was why 👍
Debatable
The thinking is that it’s easier to read with the object at the end of the function since you can just have the object hanging off the end.
What do you mean?
No, `new Anchor.BN(1234)` corresponds to `data: u64`
That's just the order that the anchor js stuff uses, regular args first followed by the context stuff (not totally sure why the order is switched from the rust side)
why is `my_account` != `myAccount`?
is ctx == `new Anchor.BN(1234)`?
If the initialize function looks like this:
```
 pub fn initialize(ctx: Context<Initialize>, data: u64) -> ProgramResult {
        let my_account = &mut ctx.accounts.my_account;
        my_account.data = data;
        Ok(())
    }

```
how is it able to be called with this: 
```
await program.rpc.initialize(new anchor.BN(1234), {
  accounts: {
    myAccount: myAccount.publicKey,
    user: provider.wallet.publicKey,
    systemProgram: SystemProgram.programId,
  },
  signers: [myAccount],
});
```
I use it for verifying that `update` instruction was called in the same transaction in all other instructions, however there are instructions where I want to add additional checks as well
are these 2 the same thing: `provider.wallet.publicKey` and `solana config get keypair`
ill avoid 🙂
Hi! Can I use `access_control` more than once?
many lifetimes have been spent in the pursuit of `'info`
It's a lifetime
What is `'info`?
Hi Friends. Any idea how can I get the balance of a token account inside an anchor program?I am parsing it as token_account: Account<'info, TokenAccount> but not sure now I can access token account data.
I don't know, I come from ethereum world where in solidity their are no ways to make contact with web2.0(other than chainlink) but in rust their are packages to make API calls.
hmm...that would be odd...no... you;d have to interact with an oracle program for that
Hi guys, can I make API calls inside an instruction?
or pretty much any spl thing
for a token account init for instance
if you create an account it might be used somewhere in that macro
What's the point of including `rent: Sysvar<'info, Rent>` in accounts? I don't see it directly used by instruction handlers, and don't really see how it's used when macros are expanded either
And solana-test-validator is working perfectly
I've also set:
[test]
startup_wait = 10000
Here are logs
Hey, I'm having problems running "anchor test" on wsl, I got an error message "Unable to start test validator. Check .anchor/test-ledger/test-ledger-log.txt for errors."
Hi, where can I change the keypair in target/deploy/projectname-keypair.json? I'm trying to change my program address to something new
I get an error when importing solana-sdk to the anchor project. Any hints? Seems to originate from the socket library
Going through tutorial. First program was build and deployed successfully. But then I turn on client and get this error:
```
➜  basic-0 git:(master) ✗ ANCHOR_WALLET="/Users/Home/.config/solana/id.json" node client.js
Running client.
Transaction simulation failed: Error processing Instruction 0: custom program error: 0x65 
    Program Ddd2ahTD47Yb7HYs1PyZrNzmQP9atd3vzyMj7nzc1cLB invoke [1]
    Program log: Custom program error: 0x65
    Program Ddd2ahTD47Yb7HYs1PyZrNzmQP9atd3vzyMj7nzc1cLB consumed 1336 of 200000 compute units
    Program 11111111111111111111111111111111 failed: custom program error: 0x65
Translating error SendTransactionError: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: custom program error: 0x65
    at Connection.sendEncodedTransaction (/Users/Home/src/deltaone/node_modules/@solana/web3.js/lib/index.cjs.js:4964:13)
    at processTicksAndRejections (node:internal/process/task_queues:96:5)
    at async Connection.sendRawTransaction (/Users/Home/src/deltaone/node_modules/@solana/web3.js/lib/index.cjs.js:4923:20)
    at async Object.sendAndConfirmRawTransaction (/Users/Home/src/deltaone/node_modules/@solana/web3.js/lib/index.cjs.js:6907:21)
    at async Provider.send (/Users/Home/src/deltaone/node_modules/@project-serum/anchor/dist/cjs/provider.js:81:22)
    at async Object.rpc [as initialize] (/Users/Home/src/deltaone/node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:12:31)
    at async main (/Users/Home/src/deltaone/anchor/examples/tutorial/basic-0/client.js:22:3) {
  logs: [
    'Program Ddd2ahTD47Yb7HYs1PyZrNzmQP9atd3vzyMj7nzc1cLB invoke [1]',
    'Program log: Custom program error: 0x65',
    'Program Ddd2ahTD47Yb7HYs1PyZrNzmQP9atd3vzyMj7nzc1cLB consumed 1336 of 200000 compute units',
    'Program 11111111111111111111111111111111 failed: custom program error: 0x65'
  ]
}
node:internal/process/promises:246
          triggerUncaughtException(err, true /* fromPromise */)

```
https://github.com/project-serum/anchor/blob/master/tests/escrow/programs/escrow/src/lib.rs ?
You are the best! Thank you so much 🙂
(So you'll have to find the right metadata account to pass in from the client, it's a program-derived address derived from the metaplex metadata program)
You'll have to add the `metaplex-token-metadata` library as a dependency, and then you can do `Metadata::from_account_info(the_metadata_account_you_passed_in)`
<@!832140329301311488>  you can look at the escrow example in the repository
Are there any examples for transferring Spl token to program and program then handles the distribution ?
also, do you have any examples of staking programs on Solana to share?
guys these are example programs? https://github.com/project-serum/anchor/tree/5d8b4765f2c5a2d0c5a26c639b10719e7b6f2fd1/tests the lockup one is meant to be a staking one?


//////////////////////////////////////////////////////////////////////////////////////////

I don't actually know how you could specify your String length up front another way but there could be one
Maybe
Is there any performance cost of using Anchor vs Solana Native?
so you suggest that i should declare an array of u8's for every string variable i want to store in accounts data?
Think donderper was responding to someone else, you can just pass it as the base58 string (I think), or if you want, `new anchor.web3.PublicKey("asdfasdf")`
ok cool. whats the desired way to hardcode a pubkey then?
Strings are arrays of u8s that you need to over allocate size for
thanks guys i appreciate it
You also shouldn't use strings
honestly i probably dont even need to do that since i just need the pubkey
If all you need is the mint's address (from the snippet above, seems like it) then you can just pass it as a string I think, `mint: "asdfasdf"`
im working on localhost
On which network did you create that mint?
Is there a better way to do this?
```
const token = new splToken.Token(provider.connection, "5T7CRNt6maYsBjb6tHTLHX6AYNGG9D6DduVHAcDQQj7d", program.programId, provider.wallet.publicKey);
```
okay great thanks
A `Mint` will never be program-owned, since it'll always be owned by the spl token program. So I'm actually not sure why you're getting that error yet 🤔 (Saying `Account<'info, Mint>` will actually verify that the account is owned by the spl token program, *not* your own program)
Interesting issue here. I'm writing an instruction that tries to init a token account, but the program does not own the mint. I created the mint via the command line a few hours ago. I'm getting an "account not owned by the program" error which makes sense since the mint Account I'm sending to the instruction is not owned by the program.
```
#[derive(Accounts)]
#[instruction(pool_vault_account_bump: u8, pool_shared_account_bump: u8)]
pub struct Initialize<'info> {
    #[account(mut)]
    pub initializer: Signer<'info>,
    pub mint: Account<'info, Mint>, // this account isn't owned by the program
    #[account(
        init,
        seeds = [b"pool_vault_account".as_ref()],
        bump = pool_vault_account_bump,
        payer = initializer,
        token::mint = mint,
        token::authority = initializer,
    )]
    pub pool_vault_account: Account<'info, TokenAccount>,
}
```

front end code:
```
let [poolVaultAccountPda, poolVaultAccountBump] = await PublicKey.findProgramAddress(
      [Buffer.from(anchor.utils.bytes.utf8.encode("pool_vault_account"))],
      program.programId
    );

const token = new splToken.Token(provider.connection, "5T7CRNt6maYsBjb6tHTLHX6AYNGG9D6DduVHAcDQQj7d", program.programId, provider.wallet.publicKey);

    await program.rpc.initialize(
      {
        accounts: {
          initializer: provider.wallet.publicKey,
          mint: token.publicKey,
          poolVaultAccount: poolVaultAccountPda,
        }
      });
```
Is there a cleaner way to get a Token instance of a previously created mint? Or a cleaner way to create a token account with a non program owned mint?
some of the examples/tests are using older solutions on purpose to ensure they still operate correctly until (potentially) being removed
is it safe to say that the example here is sort of outdated? https://docs.rs/anchor-lang/0.18.0/anchor_lang/derive.Accounts.html
yes, that's what I was thinking
its equivalent to:
```rs
{
    // ...
    pub abc: ...,
    
    #[account(constraint = abc.key() == xyz.abc)]
    pub xyz: Account<'info, MyAccountType>,
}
```
thank you <@!168868665456984065>!
awesome, that makes sense
so if you have `has_one = abc`, it will also check the `abc.key()` value from the context against the `.abc` property value of the data struct on the account configured with the `has_one`
You can see the literal code the macro expands to by searching the anchor codebase for `generate_constraint_has_one`: https://github.com/project-serum/anchor/blob/master/lang/syn/src/codegen/accounts/constraints.rs#L196
`has_one` checked the `.key()` value against the matching name _property_ of the data struct
how does it decide which struct will be called with .key() and which one with .owner?
because its a public key match assertion
`MyAccountType.owner == MyContext.owner.key()`
realize that this is a wrong model, but not sure how to phrase a question
so the macro checks that `MyAccountType{}.owner == MyContext{}.owner.owner`?
`MyAccountType` is an account data structure definition so it _does_ use the `#[account]` attribute
while this one `pub struct MyAccountType {` doesn't have `#[account]` (because it's custom)?
yes
`pub struct MyContext<'info> {`  has a `#[derive(Accounts)]` before, right?
`has_one` does a public key match assertion on the names under the hood
so if you have a custom account data struct like:
```rs
#[account]
pub struct MyAccountType {
    pub owner: Pubkey,
}
```
and instruction context like...
```rs
#[derive(Accounts)]
pub struct MyContext<'info> {
    pub owner: Signer<'info>,

    #[account(has_one = owner)]
    pub acc: Box<Account<'info, MyAccountType>>,
}
```
anchor asserts that the account data `owner` pubkey is the same as the `owner` pubkey in the context for the iinstruction
got it, thanks! what is also confusing to me is how `#[account(has_one=field)]` checks the equality under the hood, via public key of the field below the macro and the key of the target `field`?
hi guys, i am stroring this in an account:
```
let name = "new hot collection";
    let artist = "picasso";
    let symbol = "NHC";
    let description = "buy it or miss it";
    let tile_image_url = "http://test/0.png";
    let author_image_url = "http://test/1.png";
    let mint_price = "3.50";
    let total_supply= 5;
    let total_minted= 0;
```
but when i retrieve the values, it shows:
```
name: new hot collection

                artist: picasso

                symbol: NHC

                description: buy it or miss it

                tile_image_url: undefined

                author_image_url: undefined

                mint_price: undefined

                totalSupply: 5

                total_minted: 0
```
`Account` is for accounts with typed or structured data
`AccountInfo` is also more or less deprecated (there are better options for the same purpose), but `AccountInfo` is for untyped or generic accounts like wallet addresses
right, and `AccountInfo` vs `Account`? 😅
`#[account]` is a macro that does a lot of trait derivation and implementations for custom account data struct types to make them (de)serializable with borsh
no. `Account` is generic struct used in the context definition for an instruction on individual accounts...for instance `pub counter: Box<Account<'info, CounterType>>`
I mean this one https://docs.rs/anchor-lang/0.18.0/anchor_lang/prelude/struct.Account.html
hey perhaps you could clarify this one too: is `struct Account` the same as `#[account]`?
ok cool, thank you 🙂
for `#[account(signer)]` vs `Signer<'info>`, personally i would consider the former to be deprecated, but that would be a big breaking change to a lot of existing programs so i assume that's why its still there as an option.
ok, are there any use cases for the other approach? or can it be considered deprecated
(imo)
internal to the anchor code base, constraints and account types are implemented _very_ differently. custom account types like `Signer` are used as more verbose logical wrappers around a constraint or set of constraints but also leaves room for additional security and ownership checks to be more easily implemented in future versions of anchor
thanks, why?
yes, but the use of account types (`Signer`) over constraints is preferable
Also I am trying to store a url as string in a variable, but it shows undefined when it's value is retrieved
Is this
```
#[account(signer)]
pub user: AccountInfo<'info>
``` 
the same as
```
pub user: Signer<'info>
```
Use unsigned ints and track the number of decimal places in another variable
Should I store them as string?
What can I do to store floating point numbers?
Can't use floating point numbers
nvm, this answered my question
can i declare any amount of space for a string in a new account?
oh right🤦
32 bits = 4 bytes
hi guys, qq how much space does `f32` take?(while creating a new account)
So if you want to do some checks using these with the #[account] macro you can
<@!800894271737561121> It allows you to user these args (bump & data) in the struct below
what does specifying the instruction macro there do? and also could anyone point to where in the anchor rust docs it speaks about specifically that? ty so much!

That fixed it, thanks a lot!
Updating solana-cli solved the problem for me `sh -c "$(curl -sSfL https://release.solana.com/v1.8.2/install)"`
Does anybody have any idea about this?
hi devs, quick question, I want to start creating solana programs, but I'm wondering if it's best to just write raw Rust using solana doc to start with or go ahead and use anchor framework
Tried to follow this issue https://github.com/project-serum/anchor/issues/987#issuecomment-963041266 but also didnt work
Does anyone know how to get around this?
```
    Updating git repository `https://github.com/project-serum/anchor`
  Installing anchor-cli v0.18.0 (https://github.com/project-serum/anchor#ac3fbe8d)
    Updating crates.io index
error: failed to select a version for the requirement `anyhow = "=1.0.43"`
candidate versions found which didn't match: 1.0.38, 1.0.37, 1.0.36, ...
location searched: crates.io index
required by package `anchor-cli v0.18.0 (/Users/peter/.cargo/git/checkouts/anchor-bf03d42499b9267c/ac3fbe8/cli)```
is the command I am running on my m1 mac and get the following error
Hey here from _buildspace. I havent been able to get the anchor-cli installed
```cargo install --git https://github.com/project-serum/anchor anchor-cli --locked````
hey y'all, total noob question (here from buildspace), but I can't get bpf to load, or it's not in the path ... I'm just a bit confused ... any direction would be appreciated (I'm running Manjaro Arch)
Can't seem to fix this, cluster is "devnet", recreated new keypairs, nothing works hmmm
Answered my own questions `solana program dump <address> <output path>`
Is there a simple way to download the .so for a program from dev/test/mainnet so I can deploy it to devnet?
Can zero copy be implemented with Vec types?


//////////////////////////////////////////////////////////////////////////////////////////

okay thanks. i can share whatever code necessary. i'm a total noob with this, so im thankful for any help
brb but i'll see if i can take a look in a bit
but when i change that `useAnchorWallet` to just `useWallet` it works fine.
```
TypeError: Cannot read properties of undefined (reading 'publicKey')

> 89 |   const { publicKey, signTransaction } = useAnchorWallet();

```
but I get an error that looks like the app is trying to access thos propertied before the user connects a wallet
```
export default function Home() {
  const { publicKey, signTransaction } = useAnchorWallet();

  other code...    
  }
```
in my page component I'm trying:```

```
i'm trying to use the `useAnchorWallet` hook in my function in order to send a transaction with the connected wallet
not sure about example links (pls chime in if anyone else's got some), but we've set up anchor + nextjs before. can you be more specific about where you're getting this issue?
i keep getting an undefined error when trying trying `useAnchorWallet`
i am running into a ton of issues getting Anchor working in NextJS, does anyone have an example they could link me?
Is this the only way which people uses generally to store large amount of data ? Are there any examples of it
Not 100% sure about this, but I wouldn't be surprised if you also have to be kind of careful about checking membership in the list, because of compute budget (not sure, would be curious to know if looping over all 10k is possible—probably safer to store them in sorted order + use binary search, etc.)
It's possible, but it will be kind of a pain—you'll have to create the account in a separate instruction (doing the usual `init` stuff won't work, that account is too big), you'll have to use #[account(zero_copy)] and AccountLoader etc. And 10k addresses ~ 320kb, so it'll cost you something like $500 to store the account's space.
I have around 10k addresses that I want to store in a program ... Would it be possible ? I want to check in my another program if the passed account exists from those or not ?
Hello!

After doing an anchor init, when trying to do anchor test after changing anchor.toml to 
```test = "npx mocha -t 1000000 tests/"```
 I'm getting:

```Translating error Error: Transaction was not confirmed in 30.01 seconds. It is unknown if it succeeded or failed. Check signature 2R4L1qejw5RmvJARoD8PQKY94T7nZEWRkyUhEfrPYy1kAGWFu2mr5nkT62tGgszjXzTHH4FWjrUUhp4DhBHJ9i37 using the Solana Explorer or CLI tools.
    at Connection.confirmTransaction (/Users/simplex/workspace/solana_project/myepicproject/node_modules/@solana/web3.js/lib/index.cjs.js:5631:13)
    at async sendAndConfirmRawTransaction (/Users/simplex/workspace/solana_project/myepicproject/node_modules/@solana/web3.js/lib/index.cjs.js:8514:19)
    at async Provider.send (/Users/simplex/workspace/solana_project/myepicproject/node_modules/@project-serum/anchor/dist/cjs/provider.js:85:22)
    at async Object.rpc [as initialize] (/Users/simplex/workspace/solana_project/myepicproject/node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:11:31)
    at async Context.<anonymous> (/Users/simplex/workspace/solana_project/myepicproject/tests/myepicproject.js:11:16```


Any idea what's happening?
Would be shocked if someone has beaten you to it lol.
That would be pretty cool if you wrote one!
Speaking of illegible runtime type errors, has anyone written a purescript translator for Anchor IDL?
Right, those aren't initialized during deployment (no accounts are besides the accounts that hold the program's own code). You'll need to run some specific instruction to `init` that account.
hey folks, I've got some dumb questions, but I can't find answers myself, hopefully someone could help.
so, I'm trying to invoke a program. I'm confused by Accounts. a few of accounts that my program uses were initialized by something like this: `#[account(init, seeds = [b"some-seed".as_ref()], bump = bump, payer = someAccount)]`
I would assume this would initialize the account during the deployment phase, but if my assumption is correct I can't find a way to get a correct address to pass in.
Yeah, I was able to figure it out over in the <#889577399308656662>  thread. I think it was just my lack of experience with Rust that was throwing me. I wasn’t calling the Ok(()) function after my transactions.
i think you can simply invoke such transfers back-to-back, no? not exactly the same example, but the rent transfer during account init in anchor is called consecutively with other `invoke_signed`s. you could take that transfer `invoke` & simply repeat it with different amounts and receivers https://github.com/project-serum/anchor/blob/468fe79473328bf08ff293cfe85181cfb1ddd2d1/lang/syn/src/codegen/accounts/constraints.rs#L612
Thank you very much that has sorted it.
It's declared as a u64, which is too big (or could be) for a JS number, since JS numbers are doubles and can only represent integers up to 2^53.
Gotta pass that 98 as a `new anchor.BN(98)`
Hi Guys, 
I developing a Solana program and getting an error I can't figure out when I run anchor test. 
It comes from this function in my program. 
```
pub fn add_gif(ctx: Context<AddGif>, image_link: String, pool_name: String, pool_desc: String, win_opt:String, close: u64, verify:String) -> ProgramResult {
        let base_account = &mut ctx.accounts.base_account;
        let wins: Vec<String> = win_opt.split(';').map(|s| s.to_string()).collect();
        let pool = PoolStruct{
            pool_id: base_account.total_pools,
            image_link: image_link.to_string(),
            user_address: *base_account.to_account_info().key,
            pool_name: pool_name.to_string(), 
            pool_balance: 0,
            pool_description: pool_desc.to_string(),
            win_options: wins, 
            close_date_time: close,
            verify_url:verify.to_string(),
        };
        base_account.pool_list.push(pool);
        base_account.total_pools += 1;
        Ok(())
    }
```
And from this test run. 
```
await program.rpc.addGif("insert image linke here", "Test Pool","This is a test Pool", "option1; option2",98, "Verify here",{
    accounts: {
      baseAccount: baseAccount.publicKey,
    }
  });
```
I get the error  ```TypeError: src.toArrayLike is not a function ```
stupid question, is there someone who can tell me how to sing up The Anchor Program Registry?
<@!134416332509675520> thank you so much. That seems to do the trick.
You'll need to `cd programs/<your-prog-name>` and edit the Cargo.toml file in there
How would I change anchor-lang's version? Reinstalling anchor to 0.18.0 doesn't seem to do the trick.
I keep getting this error. This is my first time trying solana. 

Thanks in advance.
Looks like from the source they do the same thing in terms of `solana deploy`, it's just that `anchor deploy` does some extra stuff with the IDL
can I just use anchor deploy to upgrade my program
is there a difference between anchor deploy vs anchor upgrade?
i have a project with a couple of programs, some of which are deployed already. when i run anchor test, the target/idl removes the program ID from these deployed programs. what do i have to fix to prevent the loss of these program id's?
security thing
a team that I am working with only share part of their anchor idl
i see, thank you!
So if `takerMainAccount` is the user's wallet, you don't need to add it to `signers`
You won't be able to get a keypair from the user's wallet (that would mean the wallet leaked their secret key to you! definitely won't let you have that). You'll instead  have to ask the wallet to sign the transaction (this usually happens implicitly because it's the wallet used by the `program.provider` and already automatically signs the tx)
hi there, for a function call like this one in React, how do you get the signers KeyPair (i.e. takerMainAccount) from a users' wallet? (I have access to the wallet through @solana/wallet-adapter-react)
```
    await program.rpc.exchange({
      accounts: {
        taker: takerMainAccount.publicKey,
        takerDepositTokenAccount: takerTokenAccountB,
        takerReceiveTokenAccount: takerTokenAccountA,
        initializerDepositTokenAccount: initializerTokenAccountA,
        initializerReceiveTokenAccount: initializerTokenAccountB,
        initializer: initializerMainAccount.publicKey,
        escrowAccount: escrowAccount.publicKey,
        vaultAccount: vault_account_pda,
        vaultAuthority: vault_authority_pda,
        tokenProgram: TOKEN_PROGRAM_ID,
      },
      signers: [takerMainAccount]
    });
```
ah awesome ty! guessed that but wanted to confirm 🙂
Yeah, if you don't specify it then anchor has to calculate it using `Pubkey::find_program_address`. This takes a variable amount of compute (each bump has about a 50/50 chance of working, so might have to try multiple bumps) so might not be a good idea if you're near the limit.
just to make it easier to derive the pda or something?
```
    #[account(
        mut,
        has_one = config,
        has_one = wallet,
        seeds = [PREFIX.as_bytes(), config.key().as_ref(), candy_machine.data.uuid.as_bytes()],
        bump = candy_machine.bump,
    )]
```
whats the "bump" for here
I'm curious, how do you only have a partial idl?
Ok, best bet is probably to just read the anchor source and copy whatever you can
It works now using `@project-serum/borsh` but a little tedius
oh I only have partial incomplete idl , try that method and doesn't work
So you don't want to/can't do this via a `Program` instance? You can also do `let coder = new anchor.AccountsCoder(theIdl)` and then (I think) do `coder.decode("MyAccountType", someBuffer)`
from '@project-serum/borsh'
or do I need to write my own Buffer.Layout from scratch
stupid question but if I have IDL json file, Is there a helper class to help generate Layout in javascript so that I can decode the account data?
If there is a good use for this, might be a good excuse for me to learn
This is fascinating… I want to learn more about the Ed25519 curve
Ok, well, I figured out how to use that Ed25519SigVerify111111111111111111111111111 program, now have to figure out what to actually use it for 🤔
but it looks like this program doesn't provide such low-level functionality, but also I could just copy it and expose that I suppose
Ah, ok (yeah, I'm just getting nerd-sniped by a separate thing).
oh, and invert scalars
In my case, I'm not using it for authentication. I need to be able to add and multiply points by scalars and check for equality
Ah, I guess you're supposed to invoke it as a separate instruction—if sig verification fails it will abort the rest of the tx. Ok, hmm, will see if I can get that working.
I don't know haha, solana just won't let me 😛
Why can't you invoke it from within your program?

I'm curious about this too, e.g. I tried just now messing around with https://github.com/solana-labs/solana/blob/2400e86d136f5c151eb447bd7fbda6fed4068f49/docs/src/developing/runtime-facilities/programs.md#ed25519-program but you can't even invoke it from within your program lol, so I'm unclear on what the purpose is
that'd be awesome
thanks!
Ah, bummer—if you don't get a response I met a few of the devs at breakpoint, could try pinging them directly
(although it was only a couple minutes ago)
no response
Have you tried asking in the solana discord?
My guess is that even if you manage to get it compiling, you'll probably hit the compute limit :/ Not 100% sure about that but wouldn't be surprised.
Actually, I just noticed that if I remove a couple functions, I can entirely get rid of the dependencies on random_core and then cargo build-bpf completes with exit-code 0 (albeit with some error-messages. I'm not sure whether they're important): https://github.com/davidspies/curve25519-dalek/commit/2c270a2da313b1a2f1a6df7c506ec2448a1ff7e8
If you search the discord for ed25519 you can find some prior discussion of similar things, seems like there maybe aren't great workarounds yet though I'm not sure.
I think this unfortunately doesn't work (as you found)—when the solana sdk uses curve25519-dalek its not running within a solana program/via bpf 😦
I want to write a dApp that depends on `curve25519-dalek`. I tried putting it under `[dependencies]`, but when I run `anchor build`, I get
`error: target is not supported`

It seems like it should be possible considering that `solana-program`  makes use of it.
How can I do this?
<@!902276723251490836> that's correct, when you batch instructions together they are executed together in the transaction. running them separately, you can inspect the program logs to see how much of the compute budget each uses
Hello, 

I have a very noob question and would really appeciate if someone can help me with this. 

I am trying to chain my transaction like this: 
```
      const txn = new anchor.web3.Transaction();
const instructionOne = program.instruction.instructionOne({....})
const instructionTwo =  program.instruction.InstructionTwo({....})

txn.add(instructionOne)
txn.add(instructionTwo)

await provider.send(txn);

```


When I run this it reaches computation limit during transaction simulation however, if I run the instruction as individual RPC calls it works fine without reaching computation limit. Is the computation shared for the entire transaction and not independent of the instruction?

Is there a way I could accomplish this without reaching the computation limit?
okay onto my next beginner question. I'm trying to write a program that takes a transaction amount and sends a certain percentage to one account, and the rest to another. i think i have all of the pieces working individually, but I'm not sure how to call two separate `anchor_lang::solana_program::program::invoke` functions in my singular program. Anyone have pointers to resources where I could learn how to achieve this?
wait, disregard i think. i was running on localhost instead of devnet which is where my balance discrepancy was coming from (i think)
i keep getting a number that is not correct for my account balance. I though i needed to use `anchor.BN()` in order to parse it, but that throws a `this._init is not a function` error. What am I doing wrong here?
hey guys! super new to this framework, but loving it so far. quick question - I'm just trying to read account balance in my js test file, but I think i'm doing something wrong


//////////////////////////////////////////////////////////////////////////////////////////

Via the metaplex UI ? No idea but if you CPI then you can set the authority you want
https://discord.gg/cDa7J7Yn
if this is getting too much into metaplex np i'll ask elsewhere
one more question, when minting with metaplex, what account is set for the mint authority and update authority. Are they both set to the current wallet?
thanks Afro and cqfd
So I advise to build on metaplex and extend with your own program pda if you need to have additional values for your nft
No idea but it is the de facto solution nowadays I think, it's supported by most marketplaces etc... Doing a custom solution wouldn't be recommended
okay very cool. does anyone really NOT use metaplex for nfts?
Metaplex gives us the foundation for the NFT schema and anyone can extend upon it
A nft is basically a spl token with a metaplex pda that holds the NFT data
ah okay thats why. so its stored in the user data of the token then?
The mint authority is global to the spl token
Update authority is only for metaplex
It's not actually an spl token thing, it's a metaplex thing
Thanks. Strangely in the spl token solana docs i dont see update authority mentioned anywhere.
Funny, I had never noticed the mint authority was optional, good to know! 🙏
Mint authority = The authority that can create more of the token (mint), not mandatory, if not specified during the spl token creation the supply will be fixed & final I think,  as for the update authority, it is the authority that can update the nft metadata
Hi all, can anyone briefly explain the difference between the mint authority and the update authority on an NFT SLP token?
Heh, also not sure what you mean here
Hmm, not sure what you mean 🤔 You pass those seeds + bump to solana's machinery for making a cross-program invocation, and if they look good then the receiving side of the CPI will see that that account (address, technically) signed the call.
The purpose of the bump is to make sure you *don't* lie on the curve, so not sure what you mean (`mint_bump` can't just be anything, it has the be the *right* bump)
do you have an example of exactly this? with the usdc or some other token?
i understand the seed is being used to generate the signature. but how do you find the signature to be used later? / where is it being used?
https://github.com/cqfd/anchor-token-studies/blob/main/programs/token-studies/src/lib.rs
<@!134416332509675520> what if mint_bump lies on the ed25519?

https://github.com/cqfd/anchor-token-studies/blob/8c203ec85487c79dc1088c2fdeda1039235bec4f/programs/token-studies/src/lib.rs#L22
You might want to install v16.x
What's the node.js version ?
thx.  Do you know if there any working examples of this?  This  

`from node:17
WORKDIR /usr/src/app
copy package*.json ./
RUN npm install
COPY . .
EXPOSE 3000
CMD ["npm", "run", "start"]]
`
blows up:

`Starting the development server...

Error: error:0308010C:digital envelope routines::unsupported
    at new Hash (node:internal/crypto/hash:67:19)
    at Object.createHash (node:crypto:130:10)
    at module.exports (/usr/src/app/node_modules/webpack/lib/util/createHash.js:135:53)
    at NormalModule._initBuildHash (/usr/src/app/node_modules/webpack/lib/NormalModule.js:417:16)
    at handleParseError (/usr/src/app/node_modules/webpack/lib/NormalModule.js:471:10)
    at /usr/src/app/node_modules/webpack/lib/NormalModule.js:503:5
    at /usr/src/app/node_modules/webpack/lib/NormalModule.js:358:12
    at /usr/src/app/node_modules/loader-runner/lib/LoaderRunner.js:373:3
    at iterateNormalLoaders (/usr/src/app/node_modules/loader-runner/lib/LoaderRunner.js:214:10)
    at iterateNormalLoaders (/usr/src/app/node_modules/loader-runner/lib/LoaderRunner.js:221:10)
/usr/src/app/node_modules/react-scripts/scripts/start.js:19
  throw err;`
But you need to have it setup in your package.json file.
npm run start
npm / node nube question:  I'm trying to create a dockerfile to package my completed anchor created test app to deploy.  I'm very familiar with docker but not at all with node.js.  For development I've been using `npm start run`, for deployment i was trying to `node app.js`  but that doesn't work.  What's the "production" version of `npm start run` to use as the entrypoint in docker for an anchor created app?
See here: https://discord.com/channels/889577356681945098/889702325231427584/898235903540080650
Think of the seeds as the program's "name" for a given program-derived address (an empty name is fine)
what is the bump for?
It just happens to be empty (seeds can be whatever you want, including empty)
And it happens to have an empty seed (the &[], you can actually just get rid of it)
why is the first seed an empty array?
As for what they're for, this is just solana's kind of odd api for letting a program "sign" for a program-derived address
in this case: &[&[&[], &[mint_bump]]],
there is only 1 PDA's seeds + bump
So you've got an array (slice, whatever), each of whose elements is a collection of individual seeds (plus a bump, usually). Each seed is a slice of bytes.
Try to mentally ignore the ampersands (they're just a rust thing). The default rust formatter indentation doesn't help either, think of it as:
```.rs
&[
  // first pda's seeds + bump
  &[ seed1, seed1, b"for example".as_ref(), &[bump] ],
  // second pda's seeds + bump
  &[ some_other_pdas_seed, &[its_bump] ],
  // etc.
]
```
can someone explain what the heck signer seeds are: `&[&[&[], &[mint_bump]]],`

I dont understand all of these `&`
Hey all, this might be a super noob question but i haven't really seen it addressed anywhere? I've got some code which looks like this:

```javascript
import kp from 'lib/keypair.json';

const arr = Object.values(kp._keypair.secretKey)
const secret = new Uint8Array(arr)
let baseAccount = web3.Keypair.fromSecretKey(secret);
```

now i want to deploy the project but assume the `keypair.json` shouldn't be stored in git? I've seen env variables being mentioned but isn't that also not ideal? As you'd be storing the secret key with the hosting provider? I guess i'm just wondering how others handle keypairs/deployment
In other words, when some address derived from your program needs to sign the CPI call
`::new_with_signer` is for when you need to add in signatures for PDA addresses
when should you use CpiContext::new_with_signer vs. CpiContext::new?
got it
My guess is that there isn't any yet, you'll have to just read the source (it's not doing anything super complicated, just constructing some `invoke_signed` calls to the spl token program).
where is the documentation for anchor_spl?
this just seems v raw
https://docs.rs/anchor-spl/0.18.0/anchor_spl/token/index.html
I guess that's good enough
In the end I decided to go with this implementation ```
#[derive(Accounts)]
#[instruction(_mint_bump: u8)]
pub struct StartSession<'info> {
    #[account(mut, seeds=[PREFIX.as_bytes(), &token_account.mint.to_bytes()], bump = _mint_bump)]
    ows_metadata: Account<'info, NftData>,
    #[account(
        constraint = mint_account.mint_authority.unwrap() == Pubkey::from_str(AUTHORITY).unwrap(),
    )]
    mint_account: Account<'info, Mint>,
    #[account(
        constraint = token_account.mint == mint_account.key(),
        constraint = token_account.owner == *user.key
    )]
    token_account: Account<'info, TokenAccount>,
    user: Signer<'info>,
}
```
Yeah, as <@!194280119710253068>  said, couple things going wrong here: 1) solana doesn't really support hashmaps (can search the discord—you can actually sort of make it work but, yeah), and 2) the anchor cli itself doesn't know how to turn them into IDL. For now your easiest bet is to just use a sequence of key-value pairs unfortunately.
could be wrong
I don't think you can serialize hashmap's yet
Might sound stupid but by passing a token account I know I can access its mint pubkey but would it be possible to also do a check on the Mint data ? LIke ```token::mint::mint_authority === XYZ``` ? Thanks!
Nope still trying to get it solved too. I ended up uninstalling everything and trying to build solana from source but having problems there too now 😢
I am new to anchor and to rust, i am getting the following error when i try to test with `anchor test` 
```IdlError: Type not found: {"name":"seedIndex","type":{"defined":"HashMap<String,usize>"}}
    at Function.fieldLayout (/Users/srao13/Code/Personal/crypto/buildspace/solana-avatar-app/pixel-art-solana-app/node_modules/@project-serum/anchor/dist/cjs/coder/idl.js:97:31)
    at /Users/srao13/Code/Personal/crypto/buildspace/solana-avatar-app/pixel-art-solana-app/node_modules/@project-serum/anchor/dist/cjs/coder/idl.js:119:36
    at Array.map (<anonymous>)
    at Function.typeDefLayout (/Users/srao13/Code/Personal/crypto/buildspace/solana-avatar-app/pixel-art-solana-app/node_modules/@project-serum/anchor/dist/cjs/coder/idl.js:118:54)
```

i have the struct defined as follows 

```#[account]
pub struct BaseAccount {
    // list of the pixel arts stored in the account
    pub pixel_art_list: Vec<PixelArtStruct>,

    pub seed_index: HashMap<String, usize>,
}```

This compiles fine, but anchor deployment to local is failing
state is deprecated but the tutoirials are fine
hey guys, I'm wondering whether the tutorials are incomplete?
At the end of Cross Program Invocations ( https://project-serum.github.io/anchor/tutorials/tutorial-3.html ) it says:
> Up until now, we've treated programs on Solana as stateless. In the next tutorial we will learn how to add a global state to our program.
However the next section is on errors and e.g. the #[state] directive is never explained.
So it seems like the state section of the tutorials is missing...
Hey guys! When I’m calling program.rpc.ix-handler, I’m not able to catch the custom error even though I place it inside try catch block. The console prints: Uncaught exception … and so on. Am I missing anything?
Oh I see 👍
actually im just calling the candymachine contract using anchorpy haha.. thats from the IDL
Ah ok got it, because you're doing a CPI?
oh i need to pass the clock account to the program though
Cause `anchor init --help` doesn't specify any way to use npm instead of yarn
Should I maybe create a GH issue or did I miss something in the docs?
Not really a question, more of a suggestion; there should be some kind of fallback for anchor to use npm instead of yarn if it's not installed...
You can now also just do `Clock::get()?` in your program, no need to pass the sysvar account
anchor.web3.SYSVAR_CLOCK_PUBKEY,
i found
ah nvm sorry
see this as part of the IDL
```
        IdlAccount(name="tokenMetadataProgram", is_mut=False, is_signer=False),
        IdlAccount(name="tokenProgram", is_mut=False, is_signer=False),
        IdlAccount(name="systemProgram", is_mut=False, is_signer=False),
        IdlAccount(name="rent", is_mut=False, is_signer=False),
        IdlAccount(name="clock", is_mut=False, is_signer=False),
```
is there a standard clock program on solana?
Hi there, I am trying to install Anchor from the buildspace class and am getting the following error message. Any ideas where I should look to debug? ```➜  ~ cargo install --git https://github.com/project-serum/anchor anchor-cli --locked
    Updating git repository `https://github.com/project-serum/anchor`
  Installing anchor-cli v0.18.0 (https://github.com/project-serum/anchor#468fe794)
    Updating crates.io index
warning: package `cargo_toml v0.9.3` in Cargo.lock is yanked in registry `crates-io`, consider running without --locked
warning: package `zeroize_derive v1.1.0` in Cargo.lock is yanked in registry `crates-io`, consider running without --locked
   Compiling proc-macro2 v1.0.29
   Compiling libc v0.2.101
   Compiling syn v1.0.75
   Compiling unicode-xid v0.2.2
   Compiling serde_derive v1.0.130
   Compiling serde v1.0.130
   Compiling version_check v0.9.3
   Compiling cfg-if v1.0.0
   Compiling autocfg v1.0.1
   Compiling typenum v1.13.0
error: linking with `cc` failed: exit status: 1```
Did you ever find a solution to this?
epic knowledge download, thanks
Just exactly what I was seeing, great reading, thank you again
I guess it is the same for mainnet
I though I was doing something wrong
thanks for the info very very much
oh man
https://jstarry.notion.site/Program-deploys-29780c48794c47308d5f138074dd9838
You have to do a bazillion transactions while deploying because deploying uploads your compiled contract into an account, and even for a simple contract it will be ~100kb at least, and a given solana transaction can only be 1232 bytes 😬 So deploying has to chop your code up into little pieces and deploy them all in separate transactions.
maybe thousands, not sure why lol it's just a simple Initialize() program
So it seems that after doing anchor init and funding wallet on devnet, when I do anchor test and I look my transactions on devnet there's hundred of consecutive transactions marked as: "Bpf-Upgradeable-Loader: Write" 😐
It's just slightly too restrictive when they're together
Ughhhh
too late I already reimplemented it ⚓ ⚓ ⚓ ⚓ ⚓
You can split them out into separate functions easy enough. It's not a fun function by itself
is `createMintAndVault` in `@project-serum/common` still the recommended way to do the thing?
Thanks!
gotcha
Nano is a super simple editor, can ignore it and use vscode or whatever
I am going off this
https://swaroopmaddu.medium.com/solana-installation-in-macbook-m1-b08582d50db1
the nano thing I do not know what is going on... never seen it before
nano ~/.cargo/config
[target.x86_64-apple-darwin]
rustflags = [
  "-C", "link-arg=-undefined",
  "-C", "link-arg=dynamic_lookup",
]

[target.aarch64-apple-darwin]
rustflags = [
  "-C", "link-arg=-undefined",
  "-C", "link-arg=dynamic_lookup",
]
Yea... there is something with this comman
Think you'll have to post more of the error, but I can maybe spot an openssl in there 👀 You'll need to brew install openssl and maybe link it or something
any help....
this when I run cargo build on solana
I am currently downloading Anchor/Solana on an M1 mac and I keep running into the issue of
alright, thank you so much nonetheless 🙂 very much appreciated
you might want to reach out in the solana discord. Seems like this is a local validator issue.. thats the only thing i can think 😦 im not so smart about all this stuff yet lol
this didn't do the trick unfortunately :/
exactly the same way as before... just fetching it from .env like so: `const provider = anchor.Provider.env();
    anchor.setProvider(provider);`
Are you setting up your provider in a weird way?
only thing i can think is to delete the `test-ledger` folder and restart the validator
looking for help here 🙂
thank you so much!! 🙂
Did someone come across this here at some point?
``` 
Error: Account allocation failed: RPC response error -32002: Transaction simulation failed: This account may not be used to pay transaction fees 
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.
```  
I am running a code snippet that just worked, but I get this now. I have spammed my localhost with RPC calls quite a bit, is there a rate limit, or is it only my code?
Not sure it’s the right way and I think we had a bit of cruft in it but it’s been a perfectly decent abstraction for our use cases
I’m also out so not a rush by any means
thanks a ton!
might save me an hour or two plus show me the “right” way
Out atm but I’ll see what I can do!
any chance of you sharing that context/provider example?
There might be multiple ways to do this but with react (& ofc next) + anchor I prefer to make a context for the fully configured anchor provider, and then use a hook for that in any component where I might need to sign txns. Never had to use window.solana
also this
https://discord.com/channels/889577356681945098/889702325231427584/904857067888734298
cause I’m accessing the user wallet by calling useWallet then just passing window.solana into getProvider in order to sign transactions with the connected wallet. is that how I should be doing this?
like where would that hook be used in a “typical” anchor app
Can you elaborate on this q?
so would that hook just get passed into getProvider instead of window.solana?
there's also this, but they are not clear at all lol
https://docs.solana.com/developing/on-chain-programs/debugging
msg is to write to the Program Logs. if you are running `solana-test-validator`, you can open another terminal and run `solana logs -u localhost` to stream the program logs
so how can i use `msg!` to debug my program? i.e. where can i find what is printed?
not positive, but only difference i see in the implementation is this return value when connected vs not connected. i wouldn't be surprised if it's that anchor requires the wallet to be `undefined` if not connected. curious if other folks know
but now that i forged ahead without the anchor specific hook, and i haven’t noticed a difference. do you know what the reason for using the specific anchor hook would be?
meaning, `useAnchorWallet` doesn't support destructuring safely the way `useWallet` does. looking at the source here https://github.com/solana-labs/wallet-adapter/blob/7f907db42b5a6e2c7937830be12c6f3006a8682c/packages/core/react/src/useAnchorWallet.ts#L17, if `publicKey`, `signTransaction` or `signAllTransactions` are falsy, it returns `undefined` for the wallet instance, so destructing will break the way you found
yeah that’s what i found too. publicKey is undefined instead of null
so this looks like an api difference between `useAnchorWallet` & `useWallet` specific to whether or not the wallet is connected
If I need to deploy some token mints or anything else I'll need to do that using a [scripts].
but does this get extended to localnet as well?
So I'm trying to figure out the workflow to go from writing unit tests to deploying on localnet. Right now the only access to workspaces is via tests, so it looks like otherwise I need to run anchor localnet in a window, then anchor deploy to deploy my program. The issue I'm having is that I need to deploy some dependencies before I can start messing with my front-end. I have a couple non-anchor program dependencies. It looks like to do the tests we add something like 
```
[[test.genesis]]
address = "9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin"
program = "deps/spl_token_swap.so"
```
the program works in my tests properly, now im trying to implement it using a NextJS frontend
What im trying to accomplish is having a user connect with their wallet using `@solana/wallet-adapter` and using that wallet to send SOL via my program


//////////////////////////////////////////////////////////////////////////////////////////

Thank you!
or if you just have the raw bytes then something like:
`program.account.treasuryData.coder.accounts.decode("treasuryData", x.account.data) as TreasuryData`
totally
```
let treasuryData = await program.account.treasuryData.fetch(
  treasuryAddress
);
```
I see that the account's type is present in `idl`
Good day! Are there any convenience functions in idl to deserialize an account's state? Similar to `getAccountInfo` for `spl-token`?
Yes spent too much time in the hotel room working on last minute things... And also too shy to come say hi to the Solana Heroes, next time <:blushhug:894787824342167573>
Hope to meet with everybody on next conf 🤗
Yes me neither, I'm just still stupid from the drinking in Lisboa, not a real issue I'm just passing unexpected input
Never though about seed len 🤔 https://docs.rs/solana-program/1.8.3/src/solana_program/pubkey.rs.html#209-216
```
    const [_metadata, metadata_bump] = await anchor.web3.PublicKey.findProgramAddress(
      [
        Buffer.from(anchor.utils.bytes.utf8.encode("metadata")),
        METAPLEX_PROGRAM_ID.toBuffer(),
        makerTokenAccountA.toBuffer(),
      ],
      METAPLEX_PROGRAM_ID
    );
```

Works. Thanks!
Ok
Think you need to turn that pubkey into a buffer too
I still have the issue now that I use the right bump seed `TypeError: Max seed length exceeded`

Seed is supposed to include the program ID to for metaplex

```Typescript
    const [_metadata, metadata_bump] = await anchor.web3.PublicKey.findProgramAddress(
      [
        Buffer.from(anchor.utils.bytes.utf8.encode("metadata")),
        Buffer.from(anchor.utils.bytes.utf8.encode("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")),
        makerTokenAccountA.toBuffer(),
      ],
      new PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")
    );
```

Is that why it's too long? Did I got equivocated with tobuffer/tobytes? (this is the typescript code)
My q is, does this have to be a custom rust program or can I just execute these functions in a sequence in a typescript frontend using the token programs inbuilt js burn functions etc.
Hey all so I am building a script  to 'upgrade' an NFT, this basically means the user clicks to upgrade in the frontend, it burns some NFTs from their collection (they sign for each txn) and a new one is minted to their wallet
Oh I see. thanks Alan that's probably it ❤️
Yeah, you'd have to deploy (I tend to just let anchor test spin up its own validator)
I think the problem you'll have there is that `seeds = ` will verify the address against *your* program_id, not the metadata program's id. Not sure anchor supports verifying a PDA derived from a different program (using attributes, can still do it manually)
nft_mint() returns a `Pubkey`, the others two are `str`
using something like :
```Rust
    #[account(
        seeds = [
            PREFIX.as_bytes(),
            METAPLEX.as_bytes(),
            &escrow_account.nft_mint().as_ref()
        ],
        bump
    )]
    pub metadata_account: AccountInfo<'info>,
```

Am I doing something stupid <:thinkingpepe:746135853386039376>
I have having the same issue, I'm doing this in the IDL in the anchor context
Whenever you run `anchor test` and call `init_mint` does it create a new mint account? 
How do you preserve it between runs? Only when its deployed?
```
  $ solana program deploy /Users/moo/Downloads/experiements/deltaone-protocol/target/deploy/deltaone_protocol.so
The program address will default to this keypair (override with --program-id):
  /Users/moo/Downloads/experiements/deltaone-protocol/target/deploy/deltaone_protocol-keypair.json
Error: Unable to read keypair file
```
why is it going to this path to find keypair when the keypair lives here:
```
/Users/moo/.config/solana/id.json
```
I notice that `InitMint` and `Airdrop` are two different types/structs. and `mint` in InitMint has a different decorator. Am i getting warmer?
It doesn't 😉 Probably a good exercise to see how it's different
but init_mint does the same exact thing as airdrop. why do we need to run it?
Yep, you need to init the mint (otherwise there's no mint to do the airdrop)
below is code from a program test case. as workspaces are not available in the browser, how do you access chat.name from a react app?
```
# in program test
const program = anchor.workspace.Chat;
const chat = await program.account.chatRoom.fetch(chatRoom.publicKey);
const name = new TextDecoder("utf-8").decode(new Uint8Array(chat.name));
```
yes
i did not run init_mint. do i need to?
i just ran airdrop directly.
So you're also using https://github.com/cqfd/anchor-token-studies ? Tests run fine for me, so will depend on what you changed
And no, the mint's address is the PDA, not the program's own address.
The mint stuff is stored in an account owned by the spl token program (so not one of our own accounts).
Ah sorry just red your reply, the authority is a PDA
I understand, and where will this mint info be stored (authority?), will it be in an #[account] struct in the program ? Also, will the mint address be the program's address, or it will generate one and store it alongside the authority ?
I'm getting this: ` Error: 167: The given account is not owned by the executing program`
When I run: 
```
const accounts = {
      mint: mint,
      destination: ourAssociatedTokens, //your wallet.
      payer: program.provider.wallet.publicKey,
      systemProgram: anchor.web3.SystemProgram.programId,
      tokenProgram: spl.TOKEN_PROGRAM_ID,
      associatedTokenProgram: spl.ASSOCIATED_TOKEN_PROGRAM_ID,
      rent: anchor.web3.SYSVAR_RENT_PUBKEY
    }

    console.log("Starting airdrop", accounts);
    await program.rpc.airdrop(mintBump, {
      accounts: accounts
    });
```
In this case the authority over the mint is a program-derived address so that the program itself has authority (only the program can sign for its own derived addresses). Weirdly/just for fun, that specific authority address is the mint's own address 🤳
Not quite sure if I'm understanding your question, but a mint is the "type" or "brand" of tokens (e.g. AlanCoin). That instruction's main purpose to create the mint itself (AlanCoin didn't exist until that function got called) and set who has authority over the mint (who has to sign in order to make new AlanCoins)
Thanks, so a mint is not that origin program (or account?) from which all tokens of that type are created? trying to settle the mint concept in my head
Ah, I forgot I left that code in a funny mid-stream state—the purpose of the instruction is to initialize the mint that the program will control. It *also* happens to randomly send 1 token to the `destination` account, but that's kind of random/just an example from the stream.
In the token studies program.. When we have init_mint as an instruction, does that mean that we can use that instruction to mint a new token, create a new mint, OR that we use that instruction to make a new account for the payer from a specific token mint (eg: creating a $SRM account for the payer if he doesnt have one?)
I really get the feeling that this is the issue now that you bring it up though🤦‍♂️
serum_dex::instruction::new_order is the instruction that's ultimately called
And if you're talking to the serum dex, could 0x22 = 34 = InsufficientFunds? https://github.com/project-serum/serum-dex/blob/master/dex/src/error.rs
What's the actual instruction you're invoking? In general you need to do some source-diving to see which accounts need to sign and/or be mutable, unfortunately
Does anyone have an example of placing an order on serum via cpi? I've been using the swap example as inspiration, but I'm a bit stuck on some of the differences due to using PDA/CPI.

I've created a PDA and open orders account for the PDA, but when I try to use CPI to have the PDA place an order, I keep getting: custom program error: 0x22. afaik, this error maps to "Invalid number of provided signers" based on the error.rs in the solana token program. I would have expected that the only signer I need for this is "the PDA" (I'm using CpiContext::new_with_signer to place the order). Am I missing something?
Hahaha! XD
I'm almost wondering if you're like somehow using the ethereum version of web3.js lol, I have no idea where those types are even coming from.
Probably since I'm yet to clean my code. Let me check if I'm doing something wrong and I'll get back. Thanks 🙂
At any rate something is super weird with your setup since this is definitely not the expected behavior.
Can you post more of your code? I honestly have no idea what's going on
program.rpc.ix doesn't use websockets though, it just does an rcp call
One of my friend who's a Solana dev too told that it maybe because anchor uses websockets and sometimes they're a bit slow. So the program.rpc.ix() itself can take upto 30secs for confirmation.
I honestly have no idea where those types are from 🤔 I can't find them in either the anchor *or* the solana codebases.
<@!134416332509675520> Found a hack:

conn.getSignatureStatuses() expects a tx_sign string and the var we have is PendingTx type. When that is passed, the error thrown is related to circularJSON. What I did is: converted PendingTx to string via JSON.stringify with a circularJSON replacer, and passed the signature field from the new JSON I get. It worked well then.

Just wondering if this should be the right way to do or not. Any faulty implications that you see when such code is pushed to prod?
<@!134416332509675520> Here's how it looks. Due to this being a PendingTransaction type and not a string, the conn.getSignatureStatuses() fails coz it expects the tx_sign to be string.
Can you post a screenshot? Never seen that type before
When I'm storing the returned value of "await program.rpc.ix_handler( )", the value is of type PendingTransaction and not a string representing the tx signature. Am I missing anything? <@!134416332509675520>
but no output
I run solana logs - u localhost

and in rust I show msg!("I am here")
ahhhh turns out I had mixed up `god` and `mint` when initializing the `Token` client
the above is Python but the `create_account` and `get_account_info` workflow works fine in the solana-py tests
already learned that one the hard way this morning 😅
this doesn't error
```market_maker_token_a = await mint_a_client.create_account(
            market_maker_account.public_key,
        )
  ```
but `get_account_info` doesn't think the account got created 🤔 
`await mint_a_client.get_account_info(market_maker_token_a, Processed)`
How much space are you giving that account? I've made that mistake before
but I think perhaps something is going wrong when creating the account to transfer the token to
running TransferChecked
Not sure on the exact causes but usually it's often misformed transaction instructions
this is good info
Ah, ok, another way in general is if you're creating a token program account (a mint, or a token account, etc.) but allocate the wrong amount of space.
What token instruction is running when you get the error? You could probably spot potential causes just by source-diving in the token program's `processor.rs` file
I think you could maybe get that (not 100% sure) by passing a token account where a mint was expected?
and yeah this isn't actually an Anchor question 🤷‍♂️
those words mean as much to me as `Error: something went wrong`
what are some common causes of `InvalidAccountData` when using the Token program?
Why are you doing that additional `createInstruction`? I'm guessing that's how you're creating the account twice
So I created an account for `basic-1` and tried creating it in a new program with `anchor init` and it gave me error? is this possible?
You are trying to create an account where one already exists
```ts
import * as anchor from '@project-serum/anchor';
import {Program} from '@project-serum/anchor';
import {BoltFactory} from '../target/types/bolt_factory';
import assert from 'assert';

describe('bolt-factory', () => {

    // Configure the client to use the local cluster.
    const provider = anchor.Provider.local();
    // const provider = anchor.Provider.env();
    anchor.setProvider(provider);

    const program = anchor.workspace.BoltFactory as Program<BoltFactory>;

    it('Creates and initializes an account in a single atomic transaction', async () => {
        // Add your test here.
        const boltAccount = anchor.web3.Keypair.generate();

        // create a new account and initialize it with the program
        const tx = await program.rpc.initialize({
            accounts: {
                boltAccounts: boltAccount.publicKey,
                systemProgram: anchor.web3.SystemProgram.programId,
                user: provider.wallet.publicKey
            },
            signers: [boltAccount],
            instructions: [
                await program.account.bolt.createInstruction(boltAccount),
            ]
        });

        // fetching the new account
        const account = await program.account.bolt.fetch(boltAccount.publicKey);

        // assert.ok(account.data.eq(new anchor.BN(1234)));
        assert.ok(account.diameter.eq(new anchor.BN(2)))

        const _boltAccount = boltAccount;
        console.log("Your transaction signature", tx);

    });
});

```
This is what I wrote in the test script
I am trying to run a basic anchor project taking reference from `basic-1` example.
The program builds but testing fails. is there anything I need to do before I test the project?
```bash
Transaction simulation failed: Error processing Instruction 1: custom program error: 0x0
    Program 11111111111111111111111111111111 invoke [1]
    Program 11111111111111111111111111111111 success
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS invoke [1]
    Program 11111111111111111111111111111111 invoke [2]
    Allocate: account Address { address: 732h63wwuNsgWANuCr2NDUR5q4wFkrZhT5zKMHHcfRuc, base: None } already in use
    Program 11111111111111111111111111111111 failed: custom program error: 0x0
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS consumed 200000 of 200000 compute units
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS failed: custom program error: 0x0
Translating error SendTransactionError: failed to send transaction: Transaction simulation failed: Error processing Instruction 1: custom program error: 0x0
    at Connection.sendEncodedTransaction (/home/sdp/dev/bolt-factory/node_modules/@solana/web3.js/src/connection.ts:3689:13)
    at processTicksAndRejections (node:internal/process/task_queues:96:5)
    at Connection.sendRawTransaction (/home/sdp/dev/bolt-factory/node_modules/@solana/web3.js/src/connection.ts:3649:20)
    at sendAndConfirmRawTransaction (/home/sdp/dev/bolt-factory/node_modules/@solana/web3.js/src/util/send-and-confirm-raw-transaction.ts:27:21)
    at Provider.send (/home/sdp/dev/bolt-factory/node_modules/@project-serum/anchor/src/provider.ts:114:18)
    at Object.rpc [as initialize] (/home/sdp/dev/bolt-factory/node_modules/@project-serum/anchor/src/program/namespace/rpc.ts:24:23) {
  logs: 
```
What might be the reason for transaction simulation failed error.
In Anchor is there an easy way to verify if the tokens being passed in are USDC or do I need to manually verify the USDC pubkey in the program
thanks, running that command 🙂
but all good if you have a working setup now
`anchor init` now generates a `yarn run ts-mocha...` for the test command in Anchor.toml, and a package.json with the required dependencies, `cargo install --git https://github.com/project-serum/anchor anchor-cli --force --locked` would get you up to date with that version
anyways, thank you!
makes sense but its created by `anchor init`
yea if it is your own repo you are on your own managing the js dependencies
it seems this is happening for others as well, if you search: `Failed to run test: ts-mocha` on the discord. i got it to work by install ts-mocha globally, but thinking it should install automatically
just my protocol's repo
ahh and what are you running that `anchor test` on?
i did this to install anchor: `cargo install --git https://github.com/project-serum/anchor --tag v0.18.0 anchor-cli --locked
`
just run `git pull` on the repo, you don't need to update the binary or anything
how do i update anchor?
i see
yea it is done in latest master, and the instructions have changed a bit in the documentation
will try that
shouldnt that be done for me
but why do i need to manually install mocha
nvm, i fixed it. 
` npm install -g ts-mocha`
if you upgrade to latest master and run `yarn install` in `tests/` it should work
is that the `tests/typescript` test?
thank you!
It's just buried in there, https://github.com/solana-labs/solana-program-library/blob/master/token/js/client/token.js
i see the rust lib: https://github.com/solana-labs/solana-program-library
<@!134416332509675520> where is the github repo for the `@solana/spl-token` javascript library?
forsure, ill try that more then! thank you!
Solana is currently at the stage where it's generally way easier to understand things by just reading the code.
Honestly I just really enjoy source-diving lol 🤿
where did you learn all of this? are there any resources that we should read other than the solana docs?
This requires a whole extra program because in order to initialize an account at an address, the address itself has to sign—and for program-derived addresses, only their deriving program can sign for them. (I guess they could have added this functionality to the toke program itself though.)
`spl.ASSOCIATED_TOKEN_PROGRAM_ID` is for a helper program, the associated token program, which is the de-facto standard way to come up with an "obvious" address at which to store person P's tokens for some mint M (those tokens will need to live in an account owned by the spl token program, but the question is at what address they should live at—the associated token program will store them at one of its own program-derived addresses with seeds based on P and M's public keys)
`spl.TOKEN_PROGRAM_ID` is for the spl token program itself; it's the program that transfers tokens, mints them, etc. So every TokenAccount or Mint in anchor is ultimately owned by the spl token program.
what are these two for: 
```
spl.ASSOCIATED_TOKEN_PROGRAM_ID,
      spl.TOKEN_PROGRAM_ID,
```
got it
makes sense
I dropped back to node 16 and it is working
```
  --- stderr
  running "gcc-4.8" "-O0" "-ffunction-sections" "-fdata-sections" "-fPIC" "-g" "-fno-omit-frame-pointer" "-arch" "arm64" "-I" "include" "-Wall" "-Wextra" "-pedantic" "-pedantic-errors" "-Wall" "-Wextra" "-Wcast-align" "-Wcast-qual" "-Wconversion" "-Wenum-compare" "-Wfloat-equal" "-Wformat=2" "-Winline" "-Winvalid-pch" "-Wmissing-field-initializers" "-Wmissing-include-dirs" "-Wredundant-decls" "-Wshadow" "-Wsign-compare" "-Wsign-conversion" "-Wundef" "-Wuninitialized" "-Wwrite-strings" "-fno-strict-aliasing" "-fvisibility=hidden" "-fstack-protector" "-gfull" "-DNDEBUG" "-c" "-o/Users/peter/.cargo/registry/src/github.com-1ecc6299db9ec823/ring-0.16.20/target/debug/build/ring-74807bcb8634aeca/out/aesv8-armx-ios64.o" "/Users/peter/.cargo/registry/src/github.com-1ecc6299db9ec823/ring-0.16.20/pregenerated/aesv8-armx-ios64.S"
  thread 'main' panicked at 'failed to execute ["gcc-4.8" "-O0" "-ffunction-sections" "-fdata-sections" "-fPIC" "-g" "-fno-omit-frame-pointer" "-arch" "arm64" "-I" "include" "-Wall" "-Wextra" "-pedantic" "-pedantic-errors" "-Wall" "-Wextra" "-Wcast-align" "-Wcast-qual" "-Wconversion" "-Wenum-compare" "-Wfloat-equal" "-Wformat=2" "-Winline" "-Winvalid-pch" "-Wmissing-field-initializers" "-Wmissing-include-dirs" "-Wredundant-decls" "-Wshadow" "-Wsign-compare" "-Wsign-conversion" "-Wundef" "-Wuninitialized" "-Wwrite-strings" "-fno-strict-aliasing" "-fvisibility=hidden" "-fstack-protector" "-gfull" "-DNDEBUG" "-c" "-o/Users/peter/.cargo/registry/src/github.com-1ecc6299db9ec823/ring-0.16.20/target/debug/build/ring-74807bcb8634aeca/out/aesv8-armx-ios64.o" "/Users/peter/.cargo/registry/src/github.com-1ecc6299db9ec823/ring-0.16.20/pregenerated/aesv8-armx-ios64.S"]: No such file or directory (os error 2)', build.rs:653:9
  note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```
Hey has anyone any idea why when I try to install solana on my M1 I get a build error with ring
```
 ring-0.16.20 cargo build   
    Updating crates.io index
  Downloaded cc v1.0.72
  Downloaded 1 crate (57.5 KB) in 0.99s
   Compiling cc v1.0.72
   Compiling untrusted v0.7.1
   Compiling ring v0.16.20 (/Users/peter/.cargo/registry/src/github.com-1ecc6299db9ec823/ring-0.16.20)
error: failed to run custom build command for `ring v0.16.20 (/Users/peter/.cargo/registry/src/github.com-1ecc6299db9ec823/ring-0.16.20)`

Caused by:
  process didn't exit successfully: `/Users/peter/.cargo/registry/src/github.com-1ecc6299db9ec823/ring-0.16.20/target/debug/build/ring-ca804ade3e843aca/build-script-build` (exit status: 101)
  --- stdout
  OPT_LEVEL = Some("0")
  TARGET = Some("aarch64-apple-darwin")
  HOST = Some("aarch64-apple-darwin")
  CC_aarch64-apple-darwin = None
  CC_aarch64_apple_darwin = None
  HOST_CC = None
  CC = Some("gcc-4.8")
  CFLAGS_aarch64-apple-darwin = None
  CFLAGS_aarch64_apple_darwin = None
  HOST_CFLAGS = None
  CFLAGS = None
  CRATE_CC_NO_DEFAULTS = None
  DEBUG = Some("true")
  CARGO_CFG_TARGET_FEATURE = None
```
that looks like the correct http response, you aren't running `solana-test-validator` with any unusual flags?
Hey all, I'm trying to run the example-0  on anchor version `0.18.0` on an M1 Mac.
I'm running `solana-test-validator` but when I run `ANCHOR_WALLET=/Users/jon/.config/solana/id.json node client.js`
I get:
```
Running client.
Translating error Error: failed to get recent blockhash: FetchError: request to http://localhost:8899/ failed, reason: connect ECONNREFUSED ::1:8899
    at Connection.getRecentBlockhash (/Users/jon/Developer/anchor/examples/tutorial/node_modules/@solana/web3.js/lib/index.cjs.js:5965:13)
    at processTicksAndRejections (node:internal/process/task_queues:96:5)
    at async Provider.send (/Users/jon/Developer/anchor/examples/tutorial/node_modules/@project-serum/anchor/dist/cjs/provider.js:77:31)
    at async Object.rpc [as initialize] (/Users/jon/Developer/anchor/examples/tutorial/node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:11:31)
    at async main (/Users/jon/Developer/anchor/examples/tutorial/basic-0/client.js:22:3)
node:internal/process/promises:246
          triggerUncaughtException(err, true /* fromPromise */);
          ^

Error: failed to get recent blockhash: FetchError: request to http://localhost:8899/ failed, reason: connect ECONNREFUSED ::1:8899
    at Connection.getRecentBlockhash (/Users/jon/Developer/anchor/examples/tutorial/node_modules/@solana/web3.js/lib/index.cjs.js:5965:13)
    at processTicksAndRejections (node:internal/process/task_queues:96:5)
    at async Provider.send (/Users/jon/Developer/anchor/examples/tutorial/node_modules/@project-serum/anchor/dist/cjs/provider.js:77:31)
    at async Object.rpc [as initialize] (/Users/jon/Developer/anchor/examples/tutorial/node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:11:31)
    at async main (/Users/jon/Developer/anchor/examples/tutorial/basic-0/client.js:22:3)

Node.js v17.0.1
```

If I run `curl localhost:8899` I get `Used HTTP Method is not allowed. POST or OPTIONS is required`. Any suggestions?
Correct, total supply will be capped to one for a master edition mint
You can't mint again
For master edition mint authority is generated


//////////////////////////////////////////////////////////////////////////////////////////

Thanks!
there is one in the anchor repo. it also deals with watermelons 😉
but essentially - dealing with USDC is no different than dealing with any other SPL Token
Also what is the difference between testnet and devnet
tokens
Does someone have a good example of a program working with USDC?
```
test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 1.20s

   Doc-tests my_program
error[E0659]: `my_program` is ambiguous (name vs any other name during import resolution)
  --> /Users/mc/work/my_program/programs/my_program/src/lib.rs:15:9
   |
15 | pub mod my_program {
   |         ^^^^^^^^ ambiguous name
   |
   = note: `my_program` could refer to a crate passed with `--extern`
   = help: use `::my_program` to refer to this crate unambiguously
note: `my_program` could also refer to the module defined here
  --> /Users/mc/work/my_program/programs/my_program/src/lib.rs:15:1
   |
15 | / pub mod my_program {
16 | |     use super::*;
17 | |
18 | |     pub fn initialize_market(
...  |
70 | |     }
71 | | }
   | |_^
   = help: use `crate::my_program` to refer to this module unambiguously

error: aborting due to previous error

For more information about this error, try `rustc --explain E0659`.
error: test failed, to rerun pass '--doc'
```
rust tests are green, but the cargo command fails with this annoying doctest issue, any workarounds?
I guess this is for `Discriminator`: https://docs.rs/anchor-lang/0.18.0/anchor_lang/trait.Discriminator.html
in the basic-1 tutorial we have 
`#[account(init, payer = user, space = 8 + 8)]`
but MyAccount only has 1x 8-bit field (`u64`), so why does one have to allocate 16 bytes total?
Hey guys, what's the best way to maintain the `Anchor.toml` file across multiple environment (many local machines, devnet, mainnet, etc.) Should it just be listed in `.gitignore` or is there a better way to handle this?
namely that it's pinned to solana program 1.7.4 and anchor is on 1.8.0
i'm running into problems using this repo `https://github.com/smartcontractkit/chainlink-solana` to access the chainlink package
does anyone have an example project that gets chainlink working with anchor?
A `Instruction` builder
Probably not iwthout changing the program test api
but i saw that one during the hackathon
https://github.com/draffle-io/draffle/blob/master/programs/draffle/tests/functional.rs <@!367907046177112064> 

I wonder if there should be or if there is a way to build the instruction without having to to_account_metas() and .data()
I can't find what the guy shared here or any of my repos with something nice. Might have been a transient gist
Would be nice to have something like that in the repo.
Using the program_test framework.
You had some pretty good examples <@!831450660146642974>.
someone shared an example some days ago
But yeah, could maybe ask in the anchor-py channel about why your original approach didn't work?
For that specific data structure the schema will be so simple that you could honestly just skip borsh if you really wanted to—the first 4 bytes will be the length of the string (that's just how borsh does it), then that many bytes for the string itself, then 8 for the price, 8 for the items available, and then 1 byte for whether the option exists or not, etc.
Does anyone have an example of writing program tests is Rust rather than JS/TS? Would love to get a code coverage report over our entire Anchor program
do you have `anchor-spl` installed as dependency?
Hello, I am looking for some guidance and potential resources on the borsh encoding. Currently I am messing around with the solana-py/anchor-py libraries and am trying to decode the transaction data from a candy machine initialize. Here I am attempting to retrieve the price, items available etc.

I used the borsh library to attempt decoding it and followed the schema from here: https://github.com/metaplex-foundation/metaplex/blob/master/rust/nft-candy-machine/src/lib.rs#L525-L531

So far it has given results that are super funky and not correct. Would anyone have any advice on how to approach decoding borsh with the correct schema in python?
```
pub fn init_treasury(ctx: Context<InitTreasury>) -> ProgramResult {
        Ok(())
    }
```
<@!787242451240222732> ```
#[derive(Accounts)]
#[instruction(mint_bump: u8)]
pub struct InitTreasury<'info> {
    #[account(
        init,
        payer = payer,
        seeds = [],
        bump = mint_bump,
    )]
    pub treasury: Account<'info, TokenAccount>,

    #[account(mut)]
    pub usdcMint: Account<'info, Mint>,

    #[account(mut)]
    pub payer: Signer<'info>,

    #[account(
        init_if_needed,
        payer = payer,
        associated_token::mint = usdcMint,
        associated_token::authority = payer
    )]
    pub depositer: Program<'info, Token>,

    pub system_program: Program<'info, System>,
    pub token_program: Program<'info, Token>,
    pub associated_token_program: Program<'info, AssociatedToken>,
    pub rent: Sysvar<'info, Rent>,
}
```
can you post more code? Not sure what you are trying to do here
any guidance for this compile error:
```
error[E0599]: no function or associated item named `default` found for struct `TokenAccount` in the current scope
   --> programs/deltaone-protocol/src/lib.rs:116:10
    |
116 | #[derive(Accounts)]
    |          ^^^^^^^^ function or associated item not found in `TokenAccount`
    |
    = note: this error originates in the derive macro `Accounts` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: no function or associated item named `try_from_unchecked` found for struct `anchor_lang::Program<'_, _>` in the current scope
   --> programs/deltaone-protocol/src/lib.rs:116:10
    |
116 | #[derive(Accounts)]
    |          ^^^^^^^^ function or associated item not found in `anchor_lang::Program<'_, _>`
    |
    = note: this error originates in the derive macro `Accounts` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to 2 previous errors
```
`from` has to be an account that `authority` has control over. In the ido example, I think the `ido_account` is owned by the program itself (PDA), and `ido_authority_watermelon` is owned by `ido_account`. It doesnt necessarily needs to be from your wallet, it can be owned by the program as I just illustrated
and so is the from?
so if i am sending usdc from my wallet to an account, is the authority my wallet?
the `authority` is the account that would authorize the transfer instruction. Since `ido_authority` owns `ido_authority_watermelon`, you will need `ido_authority` in `authority` field to make the transfer happen
Hi I’m trying to transfer funds from one user to another in a contract and when I’m trying to test it it says no lamperts in account. I used the airdrop call to airdrop lamperts to it and that tx seems to have went through. Anyone else have this issue? In general, I’m trying to test out a simple program that transfers sol from one account to another
what does authority do here: 
```
Transfer {
            from: ctx.accounts.ido_authority_watermelon.to_account_info(),
            to: ctx.accounts.pool_watermelon.to_account_info(),
            authority: ctx.accounts.ido_authority.to_account_info(),
        };

```
Hi there, does anyone know if there is a way to check in program whether the invoker is the program deployer?
Just trying to get started and when I 'anchor init test' I get 
00h00m00s 0/0: : ERROR: There are no scenarios; must have at least one.
Failed yarn install will attempt to npm install
Thank you!
cool cool
Mm, you can kind of see where they start here, but it's probably not going to be super easy to read: https://github.com/project-serum/anchor/blob/master/lang/syn/src/parser/accounts/constraints.rs That will at least give you a sense for what attributes exist, then it's probably easier to just search for examples in the tests/ folder
Is there an example of a sane way to reset the state of the program in between tests? For example, I'm testing a few scenarios and am ending up with a ton of boilerplate code just to initialize everything. I'd love to be able to implement a beforeEach/afterEach hook that handles the reset
does anyone have an example of a function that deposits USDC into a token account?
is there some source code or documentation i can take a look at?
<@!134416332509675520> i dont see where in the docs the `account` attribute (https://docs.rs/anchor-lang/0.18.2/anchor_lang/attr.account.html) can take all of these other params ```#[account(
        init,
        payer = payer,
        seeds = [],
        bump = mint_bump,
        mint::decimals = 0,
        mint::authority = mint
    )]
```
how do i see the full list of things account takes in and what `init` does?
this is a full example:
https://github.com/dobleuber/solana-web3/blob/main/gif-portal-starter/src/App.js
using the same code in the tests.
```
let counterAccount = await program.account.counter.fetch(counter.publicKey)
```
Hey guys, how do you access variables stored in a program account from react app? Any example code you’ve come across?
Hey! another question:
I defined an enum in my lib, but I don't know how to use it in my javascript code:
```#[derive(AnchorSerialize, AnchorDeserialize, Debug, Clone)]
pub enum LanguageLevel {
    Elementary,
}
```
I am getting this error: `Error: unable to infer src variant`
```
const languages = [{
      language: 'English',
      level: 'Elementary',
    }]
```
Let me test, thanks in advance!
Then
```.js
await program.rpc.createCv(initData, {
  accounts: {
    ...
  },
  ...
});
```
```.rs
pub fn your_ix_handler(ctx: Context<TheContext>, init_data: Pubkey) -> ProgramResult {
  ...
}
```
If you want to pass non-account data (data that doesn't already live in an account on-chain) you'll have to use instruction arguments
Ah, you can only pass actual accounts (= addresses, from the client's perspective) in there.
I was trying to call my method ```
const tx = await program.rpc.createCv({
      accounts: {
        initData: {data: myData},
        user: provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
        basicProfile,
      },
      signers: [myAccount],
    });
```
But initial data should be a public key.
"But the only valid value for init data is my account pubKey." What do you mean? Not sure I follow
Hey folks, I am trying to send initialization params for my program account, but I have no idea about how to do it.
any help pls?
I am trying this:
```
    #[account(init, payer = user, space = 4096)]
    pub init_data: Account<'info, CurriculumVitae>,
```
But the only valid value for init data is my account pubKey.
Hmm, I'll have to take a closer look at candymachine I guess, I haven't actually used it yet
Yeah I am not sure, most just use levi korg's code for minting from CM 🙂
so either I implement a whitelisting mechanism along with this or I dont specify the date and somehow reference a private key
well I am not sure how I would even store a private key securely server side. But the reason candy machine cares about mint auth in this case is because only the creator wallet can mint before the start date of CM has been specified. I dont want to specify start date because it will allow anyone to mint from it, only people who have burned can mint
Oh, well, I guess candymachine doesn't care about the mint authority (the nfts have already been minted, it just hands them out in exchange for sol)
Mm, doubt it. Do most places that use candymachine use an actual backend?
Ah, right
actually, how would I reference a keypair that has authority over a mint from the frontend? is there any secure way to store and reference a private key in web3js?
I do, you mean authority over the candy machine for the mint right?
Sounds like you can probably do that all from the front end. Who has authority over the mint?
hey all seems my q got lost in da sauce would appreciate any input 🙂 (the q is what im replying to)
Yep. Synthetify has a good code base for this. https://github.com/Synthetify/synthetify-protocol/blob/master/programs/exchange/src/decimal.rs
But for now I think I can emulate floats with `u128` and some high decimal power as I did in Solidity before
I think I found it
https://github.com/project-serum/anchor/pull/993
Someone mentioned maybe making a PR for this, not sure if they have already or not
It seems like `f64` is not supported, right?
```     
IdlError: Type not found: {"name":"perTokenReward","type":{"defined":"f64"}}
```


//////////////////////////////////////////////////////////////////////////////////////////

any insights on this one?
`Clock::get()?.unixtimestamp` will get the timestamp
does anyone know how (or if it is possible) to grab the block # or timestamp in a program?
Not sure I know what I mean either 😂, just the rest of the code is not working as it did before. I'll try dig back in and figure it out.
Thanks so much for reviewing my stupid code.
What do you mean? How is it not the baseAccount you need? Not sure what that means.
Heh, yep, those both sound like problems 😛
i think i should be passing bump (now that i see the code ) will try with that :/ Also the seed has to be same in client and Rust (currently they are different)
Actually, although I do get the account returned with. ``` await program.provider.connection.getAccountInfo(baseAccount.publicKey)``` I don't get the baseAccount I need.
Hi, super noob question, does it makes sense to start coding programs in Anchor or just plain Rust?
Ok, so why are you passing [greetedPubSeed] as the argument, not just `initialize(greetedPubBump, { ... })`?
Meaning I'm not sure what the `[AccountSeed]` thing is (it should be the bump, not an array etc.)
Ok, and can you post the code from the client? The stuff you posted above looked like pseudo-code
basically trying to recreate a hello world program where messages are written in a PDA
What does the instruction function look like? (Basically just paste everything, way easier for us to help that way)
#[derive(Accounts)]
#[instruction(base_account_bump: u8)]
pub struct Initialize<'info> {

    #[account(init, seeds = [b"registry".as_ref()], bump = base_account_bump, payer = user, space = 2048)]
    base_account: Account<'info, BaseAccount>,
    user: Signer<'info>,
    system_program: Program<'info, System>,
}
Can you post that `#[derive(Accounts)]` code?
yes doing those
Ok, so you're trying to initialize an account at that PDA? Are you using the `init` attribute on the rust side? If so you'll need to specify `seeds = [whatever they are]` and `bump = the_bump`
This is what i have done -> 1. client finds a PDA (findAddress). 2. uses it to invoke Rust function (smart contract)    await  program.rpc.initialize([AccountSeed], {
      accounts: {
        baseAccount: AccountSeed,
        user: provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      },
What cross-program invocation are you doing?
What are you trying to write into it? Which program owns the account there?
Trying to write into PDA account. i am stuck at this error -> "#[error("Cross-program invocation with unauthorized signer or writable account")]".  Any help would be appreciated
I will look into that, thanks
should i use rust/js or python can suffice?
if i wanna get candlesticks from raydium what should i try
oops. didn't check libs.rs
they structured the project in a "Solana-ish" way but it's still Anchor
Nope, they are!
they are not using anchor ⚓
hmm
That would mean you're somehow passing an account to the token program that isn't actually owned by the token program (could be the token account or the mint).
I'm getting the following error when trying to burn token from an account:
```
Transaction simulation failed: Error processing Instruction 0: custom program error: 0x4 Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS invoke [1] Program log: Spending collection tokens Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [2] Program log: Instruction: Burn Program log: Error: owner does not match Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 2451 of 186738 compute units Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA failed: custom program error: 0x4 Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS consumed 200000 of 200000 compute units Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS failed: custom program error: 0x4
```
The `Burn` instruction is created by giving the mint of the token, the account whose token will be burnt and the mint_authority. Signers of this transaction are the owner of the account and the mint_authority (PDA).
Anybody ever encountered this error?
Looking at Jet protocol is a good learning experience: https://github.com/jet-lab/jet-v1/tree/master/programs/jet/src/instructions
would appreciate any help
only had experience interacting with solidity smart contract on evm
having the same question!
hi. is solfarm code public to understand how they've used anchor to interact with raydium?

or are there any repos to understand interacting with defi projects like solend or raydium? (using anchor)
when use anchor migrate?
```await program.rpc.addData(new anchor.BN(20) , { Common: {} }, {
      accounts: {
        authority: provider.wallet.publicKey,
        mint:mint,
        data: pda,
        systemProgram: SystemProgram.programId,
      }
    })```
Trying to pass enum from js and getting the error :
 Error: unable to infer src variant
Hey folks, a basic ques, what's the difference b/w verifier nodes and validator nodes in SOLANA?
That seems to work thanks
What does it look like if you fetch it as `await program.provider.connection.getAccountInfo(baseAccount.publicKey)` instead?
Does that `baseAccount` actually  have data in it?
Heys guys, not really an Anchor question, but has anyone come across this error with the phantom wallet? 
```
Error in getGifList:  RangeError: Trying to access beyond buffer length
    at checkOffset (index.js:1098)
    at Uint8Array.readUIntLE (index.js:1104)
    at UInt.decode (Layout.js:570)
    at Structure.decode (Layout.js:1234)
    at WrappedLayout.decode (index.ts:92)
    at WrappedLayout.decode (index.ts:92)
    at Structure.decode (Layout.js:1234)
    at Sequence.decode (Layout.js:1090)
    at Structure.decode (Layout.js:1234)
    at WrappedLayout.decode (index.ts:92)
    at Structure.decode (Layout.js:1234)
    at Sequence.decode (Layout.js:1090)
    at Structure.decode (Layout.js:1234)
    at WrappedLayout.decode (index.ts:92)
    at Structure.decode (Layout.js:1234)
    at AccountsCoder.decode (accounts.ts:52)
    at AccountClient.fetchNullable (account.ts:154)
    at async AccountClient.fetch (account.ts:166)
```
It comes when I run this function.  
```
const getGifList = async() => {
    try {
      const provider = getProvider();
      const program = new Program(idl, programID, provider);
      const account = await program.account.baseAccount.fetch(baseAccount.publicKey);
      console.log("Got the account", account)
      setGifList(account.poolList)
    }catch(error){
      console.log("Error in getGifList: ", error)
      setGifList(null);
    }
  }
```
yeah I will definitely have the UI app totally seperate, just wondering if others create client code sort of like the examples in the tutorials; https://github.com/project-serum/anchor/blob/master/examples/tutorial/basic-0/client.js#L13-L22

which they keep in the same repo as their anchor programs, so you could publish the client code at the same time as the program is deployed. It maybe doesn't matter too much, it's either in one place or the other really... 🤷‍♂️
i think nothing prevents you to have a separate repo for your ui (and i did that for my ui app, because it's easier and even makes more sense to me). you can just copy your idl to the ui repo. i don't think there is any point to store the idl on chain
maybe there is a token account data parser that i missed
not sure if this is a dumb question, but just starting out with Anchor. Once I have built my program, and generated the IDL, is it more common to:
  1.  create a TS client alongside (in same repo) the program which can then be published and used/imported in some separate react web app 
  2. generate and publish the IDL somewhere (on chain?), and then creating the clients in my "frontend" app - which I suppose means it's easier for others to build their own apps off of my IDL too

Or maybe you’d want to do both..

I see in a lot of tutorials/examples people are building react apps in the same repo with their program, but in the real world you’d probably be creating and deploying several anchor programs. Each of those would have their own client code, and then have a separate frontend app which would then use those clients.
surely i can, but i wonder what the anchor way to do it is
you can use axios.post and define your own request message using jsonParsed
I have also tried putting the idl in a .ts file and get the same result.  As per the documents it uses "const idl = JSON.parse(require('fs').readFileSync('./target/idl/basic_0.json', 'utf8'));" which cannot be used in react
Question about using the idl with react app. I have the following when try to define the program
import idl from "data/idl.json";
is there a method to parse token account data without making another request? getTokenAccountsByOwner has `encoding` hardcoded to `base64` https://github.com/solana-labs/solana-web3.js/blob/b45f065/src/connection.ts#L2298 even though RPC allows `jsonParsed` too https://docs.solana.com/developing/clients/jsonrpc-api#gettokenaccountsbyowner
https://github.com/vicyyn/MetaplexMetadata-js
I literally have this same question! Can you let me know what options you find? I tend to try to find all the ways that I could do something before determining what tools (i.e. npm modules) to use.
https://www.npmjs.com/package/@metaplex/js might be useful for that.
Get the SPL tokens hold by the wallet -> Map through each and get the associated mint address -> get the metaplex mint pda & decode the mint data
So yes in too many words. how do i query nfts
From my understanding the idea is to unpack the serialized data of an account to yeah query what nfts the wallet holds from holding one of my NFT's. Essentially Im trying to make a nft viewer and would like to ensure that im looking at the right code. Thanks
What is the question exactly? How to query NFTs?
How do i view the nfts in a wallet through having  json mint list, thanks im looking through the solana program library and just need to know what to look at. My dev environment is fully working otherwise. Figure its late for you guys so ill check in the morning to see if anyone has answered
Downgrade to solana 1.8.3
If CPI cannot return values, why does Anchor allow adding values in function return type?

```rs
pub fn mint(ctx: Context<MintCtx>) -> Result<u8, ProgramError> -> { Ok(5) }
```

Also what about the PR adding return types? https://github.com/solana-labs/solana/pull/19548
not sure there is enough info here to debug -- the findProgramAddress should get you the derived public key that the program can sign transactions with. Are you trying to make a CPI signed by the program? using invoke_signed?
I'm getting: `Cross-program invocation with unauthorized signer or writable account`

Am I doing something wrong here:
```
let seeds = &[ctx.accounts.usdc_mint.to_account_info().key.as_ref(), &[nonce], ];    
        let signer = &[&seeds[..]];
```

Here is my PDA:
```
// program signer PDA - sign transactions for the program.
    const [_programSigner, nonce] = await anchor.web3.PublicKey.findProgramAddress(
      [usdcMint.toBuffer()],
      program.programId
    );
```
the client generates the keypair then once the mint is created there is nothing that can be done with it, since the token program will own the account
<@!831450660146642974> makes sense. Is it possible for the program to own the mint instead of the user calling the function? I understand why the end user needs a token account, but I'm not sure I grok why they need the mint itself
This is to "prove" that you "own" it, as in you have the private key
when you allocate data on an account, that isn't a program derived address
Yep, that was it. How do I know when I need to include a new account as a signer?
you need to create a keypair and sign with it if you want to create the mint through MintNft
Can anyone help me understand why I'm getting a "Signature verification failed" error when I'm using the `init` macro for a Mint?  If I remove the init statement and replace the `Account` with an `AccountInfo`, it behaves as expected. I'm guessing it's because init is trying to initialize the mint and it's already happened. If that's the case, I'd be curious how to pass an uninitialized account via JS

```rust
#[derive(Accounts)]
pub struct MintNFT<'info> {
    // ...
    #[account(init, payer = buyer, mint::decimals = 0, mint::authority = buyer)]
    mint: Account<'info, Mint>,
}
```

```javascript
const mint = await splToken.Token.createMint(
  provider.connection,
  recipient,
  recipient.publicKey,
  null,
  0,
  splToken.TOKEN_PROGRAM_ID
);

await program.rpc.mint({
  accounts: {
    // ...
    buyer: recipient.publicKey,
    mint: mint.publicKey,
    rent: anchor.web3.SYSVAR_RENT_PUBKEY,
    tokenProgram: splToken.TOKEN_PROGRAM_ID,
    systemProgram: anchor.web3.SystemProgram.programId,
  },
  signers: [recipient],
});
```
Yeah and IIRC he also mentioned FlatBuffers to better handle data scheme migrations/upgrades
makes sense for sure. however, i suppose it would make more sense that anchor would automatically allocate this in the anchor code? that way the developer doesnt have to add the extra 8 all the time
interesting
Every anchor account gets one of these, to prevent you from accidentally deserializing a Foo account when someone actually meant to pass a Bar account (to prevent some interesting potential security issues...)
The first 8 is for anchor's "account discriminator", it's 8 bytes indicating which account struct this thing is supposed to be
btw why do we have to have at least 8 + 8 if we only have one `u8`?
ok gotcha, thanks alan
Yeah, you'll just have to be kind of careful since the *old* account will now have zero values for the new stuff
let me see if i have this straight. so lets say i define 1 field, `my_data:u8`, and so i make my space as 8 + 8 + 64. I compile this, deploy, blah blah, then later i update the contract's struct to have another 2 fields, `more_data1:u32` and `more_data2:u32`. It can still deserialize the older accounts and also update them?
so adding new fields to the tail shouldn't break stuff, but changing something in the middle currently does
gotcha, makes sense
I remember briefly talking to Ian Macalinao at breakpoint about how he wanted to use protobufs I think instead
(Not actually sure how easy that would be within anchor, since it defaults to borsh and I don't think borsh supports this)
I'm not sure in general how you would do this (not even specifically with solana)—you'll have old accounts lying around with the old format, so you'll have to support them ~forever. You could definitely have a custom deserialization strategy I guess that say "ok yep that's an old one" or "ok that's a new one"
oh okay so you can do the thing where you add new fields. but can you change existing fields? im guessing not?
im guessing for a dynamic account structure system, you could define a new structure, but you would first have to overwrite the existing data
You can definitely pre-allocate some extra space, and add new fields onto the end that way
i did this shit on ethereum machine code before and it sucks but thats the only reason ik basically how it works
what anchor does is takes that byte array and splices it up and gives it to you in chunks/fields, or when you give chunks to it, it mashes them together
so on solana native, account data is very simple, it's store in a field inside the account info called `data` and all it is, is an 8-bit byte array
bookmarked
everyone who does anchor should first do paulx's blog post on solana native coding
https://paulx.dev/blog/2021/01/14/programming-on-solana-an-introduction/
maybe there's a better way
sounds heavy for simple structure updates
I'm just wondering then how people do it currently - create new accounts, migrate data from old ones?
I've done zero, but it's something I would be interested in for sure
im guessing it could be, but ive only done a bit of solana native coding myself
yeah that would be amazing actually
maybe even some sort of "upgrade account" feature
so in theory it would be possible to override the deserialization and implement a backport?
idk much about the low-level of anchor's serial/deserial method
<@!134416332509675520> sorry to ping, but would something like this be possible for anchor?
im sure if you did your own serialization/deserialization tho, you could probably accomplish it
well, yeah, thats the issue then, you cant change your structures after your original deployment
would be something for the team to think about
however, i am wondering if it wouldn't be possible to have anchor be coded in such a way that you could add fields onto the tail end of data structures?
but then how do we update the contract without breaking everything?
if you initialize an account with a certain structure and then change the smart contract to deserialize in another manner (because different structure) then you can no longer deserialize
exactly
so I suppose that the existing account structure (which already had data in) no longer could be deserialized?
removed the total_gifs attribute at first
Hm possibly. I changed this structure here.
lol
anyway yeah ik for myself i will not rest until ik exactly why stuff is failing, even if i fix it.
do you by chance change the code that specified the structure of the data on the account/keypair that you are passing in?
Yeah, it's not a big deal at this stage but for production cases this would be akin to a database drop. I only have a couple hours / day to build so I'll investigate this later, I need to figure out a safe way of updating the state of the account without accidentally breaking stuff
will do so!
hmm, maybe so, when in doubt always regen everything haha
no worries. recommend to go through the <#889606719829835816>
Thanks for the info about the high-level error lookup
I'll dig this further in case it happens again.
I generated a new account Keypair for my frontend app and everything's working now, even the new functions. Maybe I broke something when I changed a structure in the Rust backend.
i am running on an M1 mac, but i havent had any issues up until now. i can run `cnahor test` and `solana-test-validator` just fine
```
Error: Account allocation failed: RPC response error -32002: Transaction simulation failed: Attempt to load a program that does not exist 
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }.
```
hey guys getting an anchor error when trying to deploy to localnet, hoping someone here can help:
I'll keep digging
but looks like an AccountDidNotDeserialize error
this happens in both functions that I changed and others I didn't
https://www.notion.so/Debugging-Custom-Anchor-Errors-b8540dd418c44a4e939ab17c56a3fd3b
this is a good article to debugging errors
sounsd like you wrote new code that has errors in it 🙂
am I forgetting something that needs to be taken care of when updating a program already in the blockchain?
when I do a test script with a new generated Keypair it runs fine
and copied the new idl to the frontend
in the backend I did build + deploy

hey, I'm trying to call a function in my Solana program but since my latest changes I only get errors when calling it
Hi all, I'm a Serum newbie. Want to build an trading bot using the serum-ts library. Does anyone have any experience doing this? Looking for someone who can help, and have a budget to build. Thanks.
Solved, I had to update XCode 👍
is there more output than that? seems like there should be another error somewhere
👋  I am trying to install anchor with `~ cargo install --git https://github.com/project-serum/anchor anchor-cli --locked`. Unfortunately I receive: ```
error: failed to compile `anchor-cli v0.18.2 (https://github.com/project-serum/anchor#7b86aed6)`, intermediate artifacts can be found at `/var/folders/v0/0n7nhm2n2k5c6l543hnrn6cr0000gn/T/cargo-installU1NXEK`
```
For sure this seems like what I need
If it is built on metaplex, you can use that https://www.npmjs.com/package/@metaplex/js
You could do it in ts/js
Can anyone point me to an implementation of verifying a wallet contains an NFT?
You could type it as <@!134416332509675520> said, and use unwrap_or in the body of your function
i'll look into the Option option
okay thats what i thought from my googling too, just figured i'd make sure
Yes not really supported in rust
Not exactly in rust, you'd have to type it as an `Option<u64>`
like can i default that commission number to something if its not passed in?
yes, sorry
In arguments ?
is there a way to set a default value for a vairable in rust?
one more basic rust question for you
Mr Alan do you know the answer 🙂
man i really gotta buckle down and learn rust faster 😅
Awesome 👍
okay perfect that did the trick for sure
Correct
so just multiply by 100 in TS and divide by 100 in rust?
You might want to avoid dealing with floats directly
is there anyway to pass an f64 in via ts?
ahhhh that makes total sense
+1
0.01 will be just 0 as a u64 (or a bignum)
i have a feeling its because im passing commission in as `0.01` and rust is parsing that differently since im telling it that its a u64?
i tried just passing the `commission` in as an f64 too but i get an IdlError Type not found
for both
yeah i did
Did you use new BN(your number) ? I see you are dealing with u64
ts -> rust
It can also be mismatching version of anchor cli and TS package
```
pub fn send_sol_and_commission(
        ctx: Context<SendSolAndComm>,
        amount: u64,
        commission: u64,
    ) -> ProgramResult {
        let commission_amount: f64 = amount as f64 * commission as f64;
        let trans_amount: f64 = amount as f64 * (1.0 - commission as f64);
... }
```
Were you passing it as an argument from within your rust code or ts -> rust ?
relevent code:
im super new to the rust (and its type system) so i suspect im just overlooking something simple
it was working fine when i had the commission amount hard-coded but now that im trying to accept that as an argument it seems to be not completing the same math for some reason
okay so im trying to write a program that takes in an amount and commission argument then sends solana to addresses based on those amounts
Ask away!
anyone got a second to help with a (probably super simple) rust question?
I'm on that too fwiw (using rosetta)
https://dev.to/nickgarfield/how-to-install-solana-dev-tools-on-an-m1-mac-kfn
But the best would be to use Rosetta
1.8.3
1.8.3 or 1.8.2?
oh snap, I didn't specify version when I built from source. Let me do that.
Or 1.8.3
Ok, downgrade to 1.8.2
`solana-cli 1.9.0 (src:devbuild; feat:2420900513)`
What's the version of solana you have ?
thanks, that's what I thought. appreciate you checking.
If I were you I would try to just step through things in the node debugger and see what's going on here: https://github.com/project-serum/anchor/blob/master/ts/src/provider.ts#L105 You can just check what the transaction looks like
Hmm, not sure, seems to run fine for me as far as I can tell.
something else strange is I when I run anchor test on this new setup I get text like this before the tests run
```
To deploy this program:
  $ solana program deploy /Users/whatever/workspace/level-up/target/deploy/level_up.so
The program address will default to this keypair (override with --program-id):
```
`Anchor.toml`
```
[programs.localnet]
level_up = "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"

[registry]
url = "https://anchor.projectserum.com"

[provider]
cluster = "localnet"
wallet = "/Users/whatever/.config/solana/id.json"

[scripts]
test = "node tests/test.js"
```
https://pastebin.com/ntcGbuf9
Or maybe I can just copy the above
Can you put this in a repo somewhere?
Yeah, never saw it before. I've tested a simple example on old computer and it's fine.

recreate
1.) new macbook m1
2.) build solana from source
3.) anchor init
4.) simple example w/ init (totally fine)
5.) simple example w/ init & a counter function (this error)
Trying to think how that could happen (your example seems fine to me)
Weird, that's a strange error to get (anchor only raises it when you somehow manage to invoke your program with < 8 bytes of instruction data, which should generally never happen based on how anchor works)
workaround https://stackoverflow.com/a/66759106
oh.. interesting. at least I have a place to look. It looks like account is being initialized, no?
thanks
That wouldn't be anchor. Check out the solana wallet adapter: https://solana-labs.github.io/wallet-adapter/
this error usually occurs if you haven't initialized the account
don't use any of the devent USDCs, they have the wrong number of decimals. Just use something with 6 decimal places
Hi can someone point me in the right direction of an example where a wallet is connected to a client and the wallet data is fetched? similar to step finance. thanks!
rly basic test

```
#[program]
pub mod level_up {
    use super::*;
    pub fn initialize(ctx: Context<Initialize>) -> ProgramResult {
        let base_account = &mut ctx.accounts.base_account;
        base_account.level = 0;
        Ok(())
    }

    pub fn add_level(ctx: Context<AddLevel>) -> ProgramResult {
        let base_account = &mut ctx.accounts.base_account;
        base_account.level += 1;
        Ok(())
    }

}


#[derive(Accounts)]
pub struct Initialize<'info>{
    #[account(init, payer = user, space = 9000)]
    pub base_account: Account<'info, BaseAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct AddLevel<'info> {
  #[account(mut)]
  pub base_account: Account<'info, BaseAccount>,
}


#[account]
pub struct BaseAccount {
    pub level: u64,
}
```

fails when frontend calls addLevel

```   await program.rpc.addLevel({
        accounts: {
            baseAccount: baseAccount.publicKey,
        },
    });
```
hey all, new macbook m1.

`Transaction simulation failed: Error processing Instruction 0: custom program error: 0x64`

getting issue when running anchor test. simple example runs fine, but now i'm getting this.

is this a known issue? or just missing something obvious?
For some reason USDC is only on Testnet... I'll just make up my own token in testing and call it USDC
Gotcha. Thanks!
devnet is for developers, testnet is for validator testing (don't use it)


//////////////////////////////////////////////////////////////////////////////////////////

But that costs compute.
Mm, it's only *necessary* to pass bumps to `invoke_signed`. You can always recalculate them within your program using `Pubkey::find_program_address` if you know the seeds.
I am checking this .. Was it necessary to store bump - https://github.com/cqfd/anchor-visitors/blob/58972af564867155b2e6f236227bf0178c5d8314/programs/visitors/src/lib.rs#L9
To instructions
To what?
Is is necessary to pass bump ?
Thanks
you can use this function:
```

pub fn close<'info>(
    info: AccountInfo<'info>,
    sol_destination: AccountInfo<'info>,
) -> ProgramResult {
    // Transfer tokens from the account to the sol_destination.
    let dest_starting_lamports = sol_destination.lamports();
    **sol_destination.lamports.borrow_mut() =
        dest_starting_lamports.checked_add(info.lamports()).unwrap();
    **info.lamports.borrow_mut() = 0;

    // Mark the account discriminator as closed.
    let mut data = info.try_borrow_mut_data()?;
    let dst: &mut [u8] = &mut data;
    let mut cursor = std::io::Cursor::new(dst);
    cursor
        .write_all(&CLOSED_ACCOUNT_DISCRIMINATOR)
        .map_err(|_| ErrorCode::AccountDidNotSerialize)?;
    Ok(())
}

```
Hi <@!134416332509675520> 
Can I implement the `conditional close` on the `#[account()]`?
<@!712332112128376885> thanks
<@!609739117600833554> , it would be useful for the timestamp and sender
`let now_ts = Clock::get().unwrap().unix_timestamp;`
And `*ctx.accounts.initializer.key`
Is there a way to get msg sender and block.timestamp in the solana programs?
Just one more question:
Should I add 8 to calculate the space like this:
`space = 8 + UserStakingAccount::default().try_to_vec().unwrap().len()`
It's working
Thanks <@!134416332509675520> 👍
anchor_version = "0.18.0" on the Anchor.toml
anchor_lang = "0.18.0", anchor_spl = "0.18.0" on the Cargo.toml

like this?
Haha, sure!
Can't I update the anchor version?
Ah, ok, those are pretty out of date and `init_if_needed` won't work with them. You'll have to handle the init-ing part yourself, manually
Well.. anchor_version = "0.16.2" on the Anchor.toml
and anchor_lang = "0.16.2", anchor_spl = "0.16.2" on the Cargo.toml
hmm, okay, didnt see those, will look and let u know if i still dont understand :/
There are also lots of examples in the tests directory if you search the anchor repo
Probably not, easiest to just ask specific question here I'm guessing
is there really no documentation for this? 😅
yeah i tried searching but couldnt find anything. another guy said it was for accessing your main instruction handler params for your program but that didnt seem to line up with the code i was looking at
Sorry, what's the actual error?
Probably easiest to search the discord, there are a lot of discussions of it (briefly, it just lets you refer to instruction arguments in your `derive(Accounts)` struct, which is often useful)
or at least a detailed explanation
oops wrong message
or at least a detailed explanation
```
#[account(
        init_if_needed,
        payer = token_from_authority,
        seeds = [ token_from_authority.key().as_ref() ],
        bump = nonce,
        space = 1234,
    )]
    pub user_staking_account: ProgramAccount<'info, UserStakingAccount>,
```
Gonna need more information than that lol
<@!134416332509675520> , `init_if_needed` is error 😦
Yep, `seeds = [the_signer.key().as_ref()]`
One more question: can I generate the seeds from the signer's key?
Thanks 👍
Can you use
```.rs
#[account(init_if_needed, seeds = [...], bump = the_bump, payer = the_payer, space = 1234)]
```
If there's any PDA initialized, and use that one to update the data
And if there's nothing, then create a PDA to initialize the data

To do this one, I can't use the `#[account(init)]`
Can you say more? Not sure what you mean.
anyone know how to get USDC on devnet?
Hi,
I would like to ask one question
`Create a PDA on the function, not on the context`
Really appreciate if you can share any piece of code for it
is there any documentation for the `#[instruction]` attribute?
yay ! Thank you!
Can try looking in `.anchor/program-logs`
hey how do you see the msg logs of your smart contract when you run `anchor test` is there an option for turning those on?
I had to convert it to the a string like following
```    pub fn initialize(
        _ctx: Context<Initialize>,
        target: Pubkey,
    ) -> ProgramResult {
        msg!("target: {}", target.to_string());
        Ok(())
    }```
You have to pass a string to `msg!` I think, so you'd do `msg!("{}", target_account.key())`
Anybody know how to get the public_key for a passed in account?
Let's say I have ```let target_account = &mut ctx.accounts.target_account;```
How do I get it's public key?
Edit: tryingt to ` msg!(target_account.key());` but getting `expected `&str`, found struct 'anchor_lang::prelude::Pubkey'`
My accounts want to store a `fixed::I80F48`. I've gone in and implemented `BorshSerialize/Deserialize` for the type in the `fixed` crate (storage is just a i128). However, the IDL json now just contains `"type": {"defined": "I80F48"}` without a definition for the type. Is there a way I can inject a custom class in the typescript client to handle the type? Should I be doing this differently?
got it working again by doing an uninstall and re-install, on my mac as follows
`cargo uninstall anchor-cli`
`rm -rf ~/.cargo/registry/index ` // re-install failed unless I included this step
`cargo install --git https://github.com/project-serum/anchor --tag v0.18.2 anchor-cli --locked`
error: failed to run custom build command for `ring v0.16.20`

Caused by:
  process didn't exit successfully: `C:\Users\HP\AppData\Local\Temp\cargo-installbwIL4P\release\build\ring-2ff300b39f35f0ff\build-script-build` (exit code: 101)
  --- stdout
  OPT_LEVEL = Some("3")
  TARGET = Some("x86_64-pc-windows-gnu")
  HOST = Some("x86_64-pc-windows-gnu")
  CC_x86_64-pc-windows-gnu = None
  CC_x86_64_pc_windows_gnu = None
  HOST_CC = None
  CC = None
  CFLAGS_x86_64-pc-windows-gnu = None
  CFLAGS_x86_64_pc_windows_gnu = None
  HOST_CFLAGS = None
  CFLAGS = None
  CRATE_CC_NO_DEFAULTS = None
  DEBUG = Some("false")
  CARGO_CFG_TARGET_FEATURE = Some("fxsr,sse,sse2")

  Skipped Some Part!
The part involving stderr

C:\Users\HP\.cargo\registry\src\github.com-1ecc6299db9ec823\ring-0.16.20\build.rs:653:9
  note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
warning: build failed, waiting for other jobs to finish...
error: failed to compile `anchor-cli v0.18.2 (https://github.com/project-serum/anchor?tag=v0.18.2#1319dc65)`, intermediate artifacts can be found at `C:\Users\HP\AppData\Local\Temp\cargo-installbwIL4P`

Caused by:
  build failed
ok thanks i got it
Yes, the input is the seed, the outputs are [address, bump]
Ahhh my bad i thought it returned [address, bump] instead of seed?
I'm not sure i understand the question. `findProgramAddress` takes the seed and creates a new address until it find one that has no private key. Each new address is generated by using a different seed. Both the address found and the seed are returned by the program
thanks! but i mean that's the call where it happens, since it returns the address and the bump ?
It's best to do it off chain because it's compute heavy and only verify that the address has been generated correctly in the program
So when exactly does the search for an offcurve bump happens? Is it from the client side after calling anchor.web3.PublicKey.findProgramAddress ?
`zsh: exec format error: anchor` when I try to run any anchor command
installed anchor yesterday and it was working, came back today after restarting and it's givng this error
Correct!
If there's another way to do it I'd be curious to know
so I need to store a pubkey in program somewhere which is owner of program and check the signer is same as that ?
This was asked about recently (yesterday I think), can try searching. The basic idea is you'll need to check that some known/preordained public key signed the tx (I'm not aware of any other way to do it)
How can we ensure that the person who deployed the program can execute the instruction inside of that and no other person can call that program ?
any help with this? I have the same issue
Yeah this will be way nicer when you can just stick an `n` at the end of the literal 🙇‍♂️
Thank you again!
Oh, yes! I had `_` in my number, sorry
Which is about 240 bits there 😛
This seems to work fine for me:
```.js
let huge = new anchor.BN("1111111111111111111111111111111111111111111111111111111111111111111111111");
```
Thank you very much!! 
I also looked at the source code for `BN` and it actually does support numbers higher than that, they just need to be passed as an array (sadly, it seems you can't just pass a `String` into a constructor). And for converting from `BN` it will also work with `toString`
any tutorial using anchor_spl, can't find any good explanations on how to use it?
(So, to some extent the syntax `new anchor.BN(123)` is kind of inherently goofy, since you're using a vanilla number and turning it into a BN. Will be nice to transition to JS's built-in BigInt and just write `123n`)
The point of that assertion is that js numbers are doubles and can only represent (all) integers up to 2^53, so it's a bit funky to try to use them for integers bigger than that.
That assertion is for if you pass a literal js number to the BN constructor. You can instead pass the number as a string literal if you want?
Or instead pass it as a byte array ? <@!788122420765917184>
https://tenor.com/view/destory-eexplode-nuke-gif-6073338
Why not divide before & restore it in the program ? Not the best solution I guess hey but if that works....
Also it might become a problem for `u64` as well, if it contains number higher than 2^53
And when I try to return `u128` I usually get an error saying 
```
     Error: Number can only safely store up to 53 bits
```
Good day! What would be the way to pass `u128` into a contract? `BN` wouldn't work as it has this assertion inside:
```
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
```
nevermind. I figured it out. I think I had multiple versions of rustc installed
and I'm not really sure how to add bpfel-unknown-unknown
it seems like the correct compiler didn't install into rustc
greg@greg-Z390-GAMING-X:~/anchor1/examples/tutorial/basic-0/programs/basic-0$ anchor build
BPF SDK: /home/greg/.local/share/solana/install/releases/1.8.2/solana-release/bin/sdk/bpf
Running: rustup toolchain list -v
Running: cargo +bpf build --target bpfel-unknown-unknown --release
error: failed to run `rustc` to learn about target-specific information

Caused by:
  process didn't exit successfully: `rustc - --crate-name ___ --print=file-names -C lto=no -C opt-level=2 --target bpfel-unknown-unknown --crate-type bin --crate-type rlib --crate-type dylib --crate-type cdylib --crate-type staticlib --crate-type proc-macro --print=sysroot --print=cfg` (exit status: 1)
  --- stderr
  error: Error loading target specification: Could not find specification for target "bpfel-unknown-unknown". Run `rustc --print target-list` for a list of built-in targets
I've been having an issue that might be pretty simple but after using the search function for some reason I don't find anything on here
This existing code is a photo generator. I want the contract to work as a mint button
My anchor friends I have a question. Say I have existing code like something written in JavaScript. How do I integrate a smart contract into this existing framework
any idea whats happening?
I keep on having issues deploying IDL

`anchor(62808,0x203607600) malloc: *** error for object 0x600002834230: pointer being freed was not allocated
anchor(62808,0x203607600) malloc: *** set a breakpoint in malloc_error_break to debug`
hey all just getting started w anchor whats the equivalent of forking the mainnet so you can test interact with contracts? Is it `anchor idl init -f <target/idl/program.json> <program-id>` and then deploy into your local cluster?
got more error? a complete log as a gist might help
is there any documentation for this?
ahh that makes so much sense - tyvm <@!168868665456984065>
I have tried multiple times I’m still having this error
or just do `npm i -g ts-mocha`
thats what i do
you don't have `ts-mocha` installed globally. you can install locally and change it to `npx ts-mocha ... `
this is my Anchor.toml file btw
```toml
#Anchor.toml
[programs.localnet]
wtia_auction = "program_id"

[registry]
url = "https://anchor.projectserum.com"

[provider]
cluster = "localnet"
wallet = "/home/dunnis/.config/solana/id.json"

[scripts]
test = "ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"
```
hi, i'm very new to anchor, and i'm trying to run `anchor test`, but as you can see, i'm getting this error...
can anybody see what the problem is?
its an anchor feature. it allows you to pull handler function parameters into the scope of the accounts context struct for constraint validation or other attributes that may need them
Trying to install anchor on Windows using this command; 

cargo install --git https://github.com/project-serum/anchor --tag v0.18.2 anchor-cli --locked

I’m having this error; 

error: failed to compile `anchor-cli v0.18.2 (https://github.com/project-serum/anchor?tag=v0.18.2#1319dc65)`, intermediate artifacts can be found at `C:\Users\HP\AppData\Local\Temp\cargo-installbwIL4P`

Build failed
i see this line and similar a lot in Daniel's new blog post
`#[instruction(instance_bump: u8, wallet_bump: u8)]`
is this attribute a solana thing or anchor thing? either way i cant seem to find the documentation for it
Obviously be careful 🙂
So if the CLI needs the keypair, then you need to export the phantom keypair as an array and place it on your filesystme.
ah nvm this is an ahcor error, declare id
eg `ProgramError: 167: The given account is not owned by the executing program`
best place to read about solana error codes? how to find in teh source?
Got it, whats the path from Phantom -> getting the keypair as a JSON for Anchor to work with 😮
Path to the keypair.json.
Wait a sec -- is `--provider.wallet` a private key or what exactly 🤔
Appreciate you Alan!!!
❤️
cool. thanks <@!134416332509675520> !
Ah ok, you can get other options with `anchor deploy --help`, there's an additional `--provider.wallet` arg
solana and phantom wallet use two different types of encryption methods afaik
Yup -- so that I have down, now tryna see how I tell anchor "hey, i wanna use my mainnet account w/ sol in it to fund this deploy".
I think you can deploy with `anchor deploy --provider.cluster mainnet-beta`
Exactly haha -- would need to use the phantom wallet in the CLI somehow 🤔
My sense from the source is that when you generate a keypair, it's not not doing any derivation path stuff like in the phantom example (so I guess you're right, if you generate a wallet from the cli it won't work in the browser, since it just isn't a path derivation from the seeds? Not sure)
Hmm, ok, reading through solana-keygen source for a bit, I'm not sure!
Hey everyone -- whats the workflow to deploy to mainnet w/ Anchor? I have SOL in a Phantom wallet, what would I do from here :o?
Just want to know why the first one isn't, and if it's not, does that mean any wallet that I create using cli, I won't be able to sign into using the browser wallets?
Also, I should clarify that the second snippet gives the right result (i.e, public key of the wallet that I lifted the seed phrase out of)
No, just made them to mess around 😅
(Just double checking those aren't important seed phrases...)
I'm following the web3.js examples. 

This- 
`{
    var seedFromSolanaCli =
      "design forward flee wage vast host cigar fly able wool element upset near leopard attitude initial basic scene raccoon route glue crucial hunt diagram";
    let seedBuffer = bip39.mnemonicToSeedSync(seedFromSolanaCli, "");
    let fromSolanaCliTool = Keypair.fromSeed(seedBuffer.slice(0, 32));
    // 9PoRykHqeLD9dLJZTL9UZ6t9TpKGYaoY7Lu7C1TaTXHZ
    console.log(
      `from solana cli tool seed: ${fromSolanaCliTool.publicKey.toBase58()}`
    );

    console.log(`raw prikey: [${Array.from(fromSolanaCliTool.secretKey)}]`);

  }`

and this- 
`
{
    let seedFromPhantomWallet =
    "design forward flee wage vast host cigar fly able wool element upset near leopard attitude initial basic scene raccoon route glue crucial hunt diagram";
    let path = `m/44'/501'/0'/0'`;
    var seedBuffer = bip39.mnemonicToSeedSync(seedFromPhantomWallet, "");
    let fromPhantomSeed = Keypair.fromSeed(
      derivePath(path, seedBuffer.toString("hex")).key
    );
    // AWqdASzbwfJ2AbhvLmE2LHQy2ya3JP3vTkWdZWXWim3
    console.log(
      `from phantom wallet seed: ${fromPhantomSeed.publicKey.toBase58()}`
    );
    console.log(`raw prikey: [${Array.from(fromPhantomSeed.secretKey)}]`);
  }
})();
`

give different results, even though I put the same seed phrase that I got from my wallet in both code snippets
So you're using `anchor.web3.Keypair.fromSeed`?
Makes sense, thanks for your help! 🙂
Ah, got it—I'm not sure if there's a way to set the balance ahead of time during deploy like that, I think you'd have to do it separately
Thanks, that makes sense! I think I'm missing where the program would get the balance from though that it'd pay into the account it owns, is that something I can set when I do an `anchor deploy` for example?
Or even in an account owned by the system program I guess, if the account lives at a PDA (since then your program can sign for it)
Storing the money in the program's own account wouldn't work I don't think because the program itself is owned by the bpf loader, so to retrieve that stached money you'd have to go ask the bpf loader to do the transfer for you (since it owns the program), and I don't know if it supports that kind of instruction
You could definitely have your program stash money in an account it owns, yeah (and then it can transfer it back to winners).
Is it possible to deploy a program (or I'm guessing more likely an account owned by one?) with a balance, and then have payments between callers and that account? I'm thinking about eg. games where you'd pay to enter (transaction paid to the contract balance) and can be paid from the contract balance if you win. Just a bit unclear if this is possible/where the balance would actually reside and how it gets set. 

If it helps the equivalent in ethers would be something like `await Token.deploy({ value: ethers.utils.parseEther("0.1") })` with a payable constructor
Noob question. Does the cli wallet differ from phantom wallet?  Aren't they supposed to be the same?
I'm passing fromSeed() and getting different public keys using the web3js library
I myself have retardness with color
color blind?
BUT WHAT ABOUT THE BLUE COLOR 🤪
lmao
rip
There's litterally 2 pixel difference between the "t" and the "f" ^^...
XD peak software dev moment, ive had them too haha
there is `getParsedTokenAccountsByOwner` i don't know how i missed that one 🤦
Aha, right: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comma_Operator
facepalm, thanks
No idea how that's not a syntax error lol
u______u omg
That says "if" not "it" 🙃
But i have two

I dont see any errors just the first "it" ran
Ok, that looks fine
this part of anchor.toml ?
It ought to just run them all automatically—do you have a funny test command in your Anchor.toml? You don't just see a bunch of errors when you run the tests? Think we need more info
Hey guys, when running anchor test how do you make it test the next "it" after the first one? For some reason it tests the first and then stops instead of executing the second... : /
thats super cool that you can do that
Thanks <@!832140329301311488> 
It works by setting my enum value as a key:
```
  const languages = [{
    language: 'English',
    level: {
      elementary: {}
    },
  }]
```
Thanks, i get clone error but resolved by adding Clone to the derive, thanks 🙂
Stick a `#[derive(AnchorSerialize, AnchorDeserialize)]` above the struct definition
Hello,

It's possible to use a custom Struct in a account ?


#[account]
pub struct BaseAccount {
    pub president_prediction_list: Vec<PresidentPrediction>,
}

pub struct PresidentPrediction {
    pub prediction: String,
    pub amount: u64,
    pub buy_datetime: i64,
}

the trait bound PresidentPrediction: anchor_lang::AnchorSerialize is not satisfied

the trait anchor_lang::AnchorSerialize is not implemented for PresidentPrediction
It is the same account, but the runtime allows accessing those sysvar accounts without passing them
sounds like i need to read up on how programs are run
ok, so, sorry I don't mean to harp on this but would like to understand, i'm assuming there is a difference between calling a rust utility type function and calling a clock supported by the solana framework, and calling `Clock::get()?.unixtimestamp` will effectively grab the solana clock (i.e. is "safe" from a security perspective), maybe the distinction here is just in my head since i'm not clear on what exactly is under the hood
answering my own question here, looks like this does it https://github.com/project-serum/anchor/blob/ab3e1294d93b4173feeffda048c08feff09511eb/ts/src/program/event.ts#L70
does Anchor support subscribing to events? it's mentioned here: https://github.com/project-serum/anchor/blob/master/tests/events/programs/events/src/lib.rs but I haven't seen any examples of how a client can subscribe
Another trick to dedupe the transaction is to add some bullshit instruction to it, like transferring lamports to yourself
thanks it worked
The syntax is `{ yourVariantName: { ... } }`
I see one in tests/lockup, in the "Drops an unlocked reward" test
Is there any examples of how to pass enum from js instruction to anchor ? Tried a couple of things but it did'nt worked getting the error -  unable to infer src variant
sleeping is good enough for now haha. Thank you for your help!
Besides just like sleeping for a second (not great, but just as a proof of concept)
So you need each subsequent "identical" tx to get a fresh blockhash—trying to remember the best way to do that 🤔
thats so interesting
The issue under the hood is that solana won't let you run two identical transactions—identical including their `recentBlockhash`
But then I ran it again and it failed
weird so passed this time
just trying to build a simple counter that increments when the increment instruction is called. But calling it multiple times doesn't see to work
I'm trying to call a `increment` instruction multiple times in my test. It passes the first time the instruction is called but fails the 2nd time  I get the error that `This transaction has already been processed`   

`pub fn increment(ctx: Context<Increment>) -> ProgramResult {
        let my_account = &mut ctx.accounts.my_account;
        my_account.counter += 1;
        Ok(())
    }`

`let account = await program.account.myAccount.fetch(wallet.publicKey)
    console.log(account.counter)

    await program.rpc.increment({
      accounts: {
        myAccount: wallet.publicKey,
      }
    })
    account = await program.account.myAccount.fetch(wallet.publicKey)
    console.log(account.counter)
    
    await program.rpc.increment({
      accounts: {
        myAccount: wallet.publicKey,
      }
    })
    account = await program.account.myAccount.fetch(wallet.publicKey)
    console.log(account.counter)


    await program.rpc.increment({
      accounts: {
        myAccount: wallet.publicKey,
      }
    })
    
    account = await program.account.myAccount.fetch(wallet.publicKey)
    console.log(account.counter)`
Oh great. I'll check this out. Thanks!
You can currently skip the sysvar passing actually, assuming you don't need it for a CPI (you can just do `Clock::get()?` dynamically)
Awesome, ok, thanks
Pass clock as one of the accounts. I got the slot, can explore more of clock to get other stuff.
```rust
#[derive(Accounts)]
pub struct Initialize<'info> {
     ..... // other code
    pub clock: Sysvar<'info, Clock>
}
```
Read it inside the program as 
```rust
 msg!("{:#?}", ctx.accounts.clock.slot);
```
a simple question.. if you deploy the dex-ui ( adding the referal accounts ) i'm able to trade, BUT not able to settle the funds and retrieve them to my wallet
eerror says InitializeAccount.. but the referal account and my account is above 0.1 sol
steps on the serum docs to host a UI a pretty simple, but something additional might be missing
Hello


//////////////////////////////////////////////////////////////////////////////////////////

Found the answer sharing here if other find it useful.To generate vanity token address : 

1. Generate a keypair - using solana keygen create a vanity address
2. spl-token create-account <Path_To_That_Keypair>
Amazing. This was all super helpful, I really appreciate it!
It's not just one of the signers, hmm.
I'm not sure what you actually pass for the `owner` argument 🤔
I've never actually tried doing that multisig thing though and am confused how it actually works tbh
Mm, I think I'm misunderstanding your question—yeah, I think the extra signers are for a multisig thing https://github.com/solana-labs/solana-program-library/blob/master/token/program/src/instruction.rs#L169
ah, yeah - I guess that's implicit. I guess the scenario for those extra signers would be if multiple parties were needed to authorize a mint_to?
Why would the mint itself need to sign?
so if the mint was a pda address I would have to include it in both the mint_to call and the invoke_signed call to let solana know to expect that behavior?
ah, ha
They also affect who has to sign—if you don't pass any, then the `owner` argument has to, otherwise it doesn't
Just telling the program "hey, you might need these accounts"
Reading the source of `mint_to`, it looks like they're just being pushed to the accounts list that's passed to the instruction. I guess that makes sense on some level
That's just how solana signs for them (wouldn't be enough to pass the account info, or its address—you need the seeds + bump)
And at any rate, you'll definitely need to provide seeds + bump for any PDA you want to sign with
I'm not actually sure what the point of the additional signers are, but you can see the effect by jumping to source
Huzzah! That was it. Can you explain the difference between the `signer_pubkeys` param in mint_to vs the  `signer_seeds` in `invoke_signed`? It seems like I should have been able to replace `&[&ctx.accounts.mint.key()]` with `&[&ctx.accounts.generator.key()]` and just called invoke, no?
You don't need the mint to sign here, just the generator
Replace that with `&[]`
Ah, it's because you're doing `&[&ctx.accounts.mint.key()]`
It's definitely failing on the MintTo instruction
Sure. Here's the log from the failing test: https://gist.github.com/theycallmeswift/ffc33df90b9200a41b5c0d9a33892558
Can you post more of the program log?
Yes, it gets initialized successfully. I'm able to do things like ` await program.account.generator.fetch(generatorPda);` in my tests and get valid data back
Was the pda init ?
The PDAness of the address doesn't change anything—it's whoever paid for the account creation
<@!134416332509675520> still getting a missing required signature. Here's my updated code. Bump is stored on the generator (it's the bump the PDA gets initialized with):

```rust
use anchor_lang::solana_program::{
    program::{invoke, invoke_signed},
    system_instruction,
};
use anchor_spl::token::{Mint, Token, TokenAccount};

pub fn mint(ctx: Context<Mint>) -> ProgramResult {
    let generator = &mut ctx.accounts.generator;

    let mint_to_ix = spl_token::instruction::mint_to(
        &ctx.accounts.token_program.key(),
        &ctx.accounts.mint.key(),
        &ctx.accounts.token.key(),
        &generator.key(),
        &[&ctx.accounts.mint.key()],
        1,
    )?;

    invoke_signed(
        &mint_to_ix,
        &[
            ctx.accounts.mint.to_account_info(),
            ctx.accounts.token.to_account_info(),
            generator.to_account_info(),
            ctx.accounts.token_program.to_account_info(),
        ],
        &[&[b"generator".as_ref(), &[generator.bump]]],
    )?;

    Ok(())
}

#[derive(Accounts)]
pub struct Mint<'info> {
    #[account(mut, seeds = [b"generator"], bump = generator.bump)]
    generator: ProgramAccount<'info, Generator>,

    #[account(mut)]
    buyer: Signer<'info>,
    #[account(init, payer = buyer, mint::decimals = 0, mint::authority = generator)]
    mint: Account<'info, Mint>,
    #[account(init, payer = buyer, token::mint = mint, token::authority = generator)]
    token: Account<'info, TokenAccount>,

    rent: Sysvar<'info, Rent>,
    token_program: Program<'info, Token>,
    system_program: Program<'info, System>,
}
```
who pays rent for PDAs?
I don't know of any way to use lldb or breakpoints etc. 😦
Maybe stupid question, how are people debugging their anchor based programs? For example is it possible to put a breakpoint in vscode and use codeLLDB?
Not quite, the entire seeds + bump for that address. So e.g. if you had `seeds = [b"the-seed".as_ref()]`, you'd do
```.rs
&[ &[ b"the-seed".as_ref(), &[the_bump] ] ]
```
Let me update it to use a PDA for generator. From there the `signer_seed` should be the generator's bump? Like `&[&[&[bump]]]`?
And pass nothing additional to invoke_signed (could maybe just use `invoke`, which is invoke_signed but without passing any seeds+bumps)
Then you're gonna have to get its private key to sign, from the client 😬
No, but it probably should now that I'm thinking about it
Think of `invoke_signed` as instead being called `invoke_with_additional_pda_signatures`
So the generator account doesn't live at a program-derived address?
The `CpiContext` version of this can be found here if that's easier to digest: https://discord.com/channels/889577356681945098/889702325231427584/910739880022278146
Can someone help me understand what the signer_seeds for this `mint_to` call should be? All the examples I can find are using seeds and bumps, but I'm not in this case right now. It still needs to be signed since the generator account is the authority on the mint from my understanding.

```rust
use anchor_lang::solana_program::{
    program::{invoke, invoke_signed},
    system_instruction,
};
use anchor_spl::token::{Mint, Token, TokenAccount};

pub fn mint(ctx: Context<Mint>) -> ProgramResult {
    let mint_to_ix = spl_token::instruction::mint_to(
        &ctx.accounts.token_program.key(),
        &ctx.accounts.mint.key(),
        &ctx.accounts.token.key(),
        &ctx.accounts.generator.key(),
        &[&ctx.accounts.mint.key()],
        1,
    )?;

    invoke_signed(
        &mint_to_ix,
        &[
            ctx.accounts.mint.to_account_info(),
            ctx.accounts.token.to_account_info(),
            ctx.accounts.generator.to_account_info(),
            ctx.accounts.token_program.to_account_info(),
        ],
        what_should_this_be,
    )?;
}

#[derive(Accounts)]
pub struct Mint<'info> {
    #[account(mut)]
    generator: ProgramAccount<'info, Generator>,
    #[account(mut)]
    buyer: Signer<'info>,

    #[account(init, payer = buyer, mint::decimals = 0, mint::authority = generator)]
    mint: Account<'info, Mint>,
    #[account(init, payer = buyer, token::mint = mint, token::authority = generator)]
    token: Account<'info, TokenAccount>,

    rent: Sysvar<'info, Rent>,
    token_program: Program<'info, Token>,
    system_program: Program<'info, System>,
}
```
This allows you to pass your function arguments to the struct and use them inside, you can see mint_bump used as the bump value.
It's all about computing budget, if you can pass the bump calculation to the client it will be better as it will use less resources on the program
ah cool, cheers
Yeah, not sure why doc test gets annoyed (it just does). You can tell cargo to turn it off: https://stackoverflow.com/a/66759106/238624
everything compiles and tests pass, but looks like it is the Doc-tests that fail, just wondering if this is an Anchor thing or a something-i-have-fucked-up-in-rust thing
has anyone ever ran into these errors when running `cargo test` ? 
```
error[E0659]: `my_mod` is ambiguous (name vs any other name during import resolution)
```
makes sense, thank you 🙂
Right
and I assume that there is no other more low level API that would allow to circumvent this process
yes, that makes sense
Right, which means that *only* your program can sign for one of its derived PDAs (if any other program tried to, `invoke_signed` would use *that* program's program_id, which would break the address derivation part)
so the main security check that ensures safety is that invoke_signed doesn't allow to pass arbitrary program_ids, right?
I tried to explain that above, about invoke_signed—did that explanation make sense? Can try explaining a different way maybe
yes I understand that
PDAs are deliberately constructed so that they're *not* public keys in the cryptography sense (there's simply no private key)
so what prevents malicious programs from signing
Right, the trick is that they "sign" for it, but there's no private key
this implies that the valid program can sign
> They can indeed derive the same address, but they can't sign for it.
Discord bugging, sorry
Mm, no—PDAs don't have private keys (they're not program addresses)
Mm, no—PDAs don't have private keys (they're not program addresses)
but isn't the private key only used for deploy?
so in order to use PDA I have to sign with the corresponding private key (which only the program knows)
yes, that makes perfect sense
I think the private key for that address is used to sign the deploy.
I mean the account that holds the executable of my program
this is the public key of my program account, right?
```
declare_id!("6Xb6fjoBbs4zsh3zmJmVJZ3urB5T8Ln3un6D58vnvFJV");
```
Which addresses are you referring to here?
If you look at the api for signing for a PDA, `invoke_signed`, note that you have to pass the seeds + bump in—but crucially you *don't even have the option* to set the program_id that was used to derive the address.
oh that's another question I had: if each program has a public key of an address, I assume that there should be a private key somewhere?
They can indeed derive the same address, but they can't sign for it.
how is using a PDA approach secure? Wouldn't it be possible for random programs to derive the same account by passing the program_id which created the account?
Ok thanks
search for PDAs and also `seeds` in the examples
cool thanks I got it
How would I create an account (controlled by the program) for my program to hold SOL using anchor?
like use the source code for create-token and wherever they generate a new Keypair, instead load up the keypair linked to your vanity address
it's doable you just need to hack the system a bit
Can it be used to generate token address as well -> I want to create a token which starts with specific characters. In spl-token create-token  ?
the solana CLI might have changed slightly since then but probably not by much
https://smith-mcf.medium.com/solana-vanity-address-using-gpus-5a68ad94d1d4
Does someone know how one can generate vanity token address like orca has  : orcaEKTdK7LKz57vaAYr9QeNsVEPfiu6QeMU1kektZE  ?
you are absolutely right.. and I am using Intellij feeling like an 👴  my bad
Have you maybe messed up the imports at the top of the file? Works fine for me (rust-analyzer does get confused about the imports, since they're macro-generated, but anchor build etc. works fine)
It's always possible to recalculate the bump from scratch (given the seeds), but that costs compute, so might not be a good idea on-chain (the compute budget isn't super high)
In the `account(seeds = [<seeds>], bump? = <target>)` attribute, how to decide if it's useful or not to precise the bump?
not sure if i'm being dumb, but does the basic-3 tutorial not compile for anyone else? It's missing an import for `SetData` and then it will fail to compile here; https://github.com/project-serum/anchor/blob/master/examples/tutorial/basic-3/programs/puppet-master/src/lib.rs#L15

because:
```mismatched types [E0308] expected `Account<Data>`, found `AccountInfo
```
#[derive(Accounts)]
#[instruction(token_bump: u8, mint_bump: u8)]
pub struct TestTokenSeedsInit<'info> {
    #[account(
        init,
        seeds = [b"my-mint-seed".as_ref()],
        bump = mint_bump,
        payer = authority,
        mint::decimals = 6,
        mint::authority = authority,
    )]
    pub mint: Account<'info, Mint>,
    pub authority: AccountInfo<'info>,
```
who can help me  about the init a mint account use anchor ~ . i have 2 questions:
#[instruction(token_bump: u8, mint_bump: u8)]  here what is used for?

seeds = [b"my-mint-seed".as_ref()] ,  what is the seeds used for? i guess is generate the mint address from the seeds, can you show me little about this way. thanks.
in case there are multiple signers
it's because you might want to add more than 1 set of seeds
Thank you
Hi there https://paulx.dev/blog/2021/01/14/programming-on-solana-an-introduction/ this example explains
Hi guys can anyone point me to some resources that can help me figure out PDA's, so that users of my program can pay SOL to the program and the Program can pay out SOL to users?
`[..]` - I am not sure why this operator is necessary
For signer of the PDA, why should I use the `[&seeds[..]]` rather than `[&seeds]`
they are implicitly mutable, but to mint with generator you need the program to sign, so invoke_signed not invoke
Is that what is happening inside `mint_to` ?
Are accounts that were initialized with `init` implicitly mutable? I'm getting an "unauthorized signer or writable account" error when I'm trying to issue a MintTo instruction via a CpiContext. Could just be misunderstanding that I needed to sign something though

```rust
use anchor_spl::token::{mint_to, Mint, MintTo, Token, TokenAccount};

pub fn mint(ctx: Context<Mint>) -> ProgramResult {
    let cpi_accounts = MintTo {
        mint: ctx.accounts.mint.to_account_info(),
        to: ctx.accounts.token.to_account_info(),
        authority: ctx.accounts.generator.to_account_info(),
    };
    let cpi_program = ctx.accounts.token_program.to_account_info();
    let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
    mint_to(cpi_ctx, 1)?;
}

#[derive(Accounts)]
pub struct Mint<'info> {
    #[account(mut)]
    generator: ProgramAccount<'info, Generator>,
    #[account(mut)]
    buyer: Signer<'info>,

    #[account(init, payer = buyer, mint::decimals = 0, mint::authority = generator)]
    mint: Account<'info, Mint>,
    #[account(init, payer = buyer, token::mint = mint, token::authority = generator)]
    token: Account<'info, TokenAccount>,

    rent: Sysvar<'info, Rent>,
    token_program: Program<'info, Token>,
    system_program: Program<'info, System>,
}
```

Error:
```
Translating error SendTransactionError: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account
```
Generating an account programmatically doesn't require it to be a PDA (PDAness is just about the address). At any rate, you'd still need to pass the address in from the client (solana just forces you to do that—if you try the above it won't work unless you also pass that address from the client)
I am pretty sure that you can do `init` on `Accounts` without bump and seed, then it will be a regular account rather than a pda
<@!831450660146642974> maybe I'm missing something here. Isn't creating the mint inside the program the same as generating an account programmatically (PDA) and initializing it as a mint? My pseudo code is something like:

```
mint_id = Pubkey::find_program_address(...)
solana_program::create_account(buyer, mint_id, min_rent, mint_len, calling_program_id);
spl_token::initialize_mint(token_program_id, mint_id, calling_program_id, None, 0)
```

What would the pseduo code look like for signing with the keypair and create the mint inside the program?
what would be the unique seed for the PDA? Another way is to sign with the keypair and create the mint inside the program, more ergonomic
Can someone help me understand the value of letting the end user supply their own mint/token accounts when creating an NFT? Every example I find, it's being passed in to the function, but I'm assuming we could just create those accounts via a PDA. Example can be seen in the Metaplex candy_machine code: https://github.com/metaplex-foundation/metaplex/blob/master/rust/nft-candy-machine/src/lib.rs#L487-L493
Appreciate it!!
I'm not aware of anything other than what's in the metaplex repo https://github.com/metaplex-foundation/metaplex
AH makes sense and this is exactly what I wanna do. LMK if you have like a basic example out there I can look at that accomplishes this.

Happy to work backwards from there.
Though issues would be awesome on anything you think would be helpful
It's just that there's no syntactic anchor sugar for this specifically
Well you can do it in the same way you would do it for any other solana program. That is, create and set the metadata and all that jazz.
Ooooo okay so pretty much — no simple way for people to creates NFTs w/ Anchor rn.

Context: I wanna build a project with Solana + Anchor around NFTs for buildspace!!
There's  an open PR for constants.
Not sure, I assumed some internals or proc macro stuff. Will be fixed later or by us, enjoyooorss of anchors, if we get the time to look into it!
If you're ever blocked please shout at me. 😄
No stress 🙂
Sorry for the delay on this. Will review it soon.
there is a PR to handle consts here https://github.com/project-serum/anchor/pull/968
the parser idl parser attempts to parse it as usize as it assumes it will be usize
Thanks! are there explanations why it can't use a constant?
Great question. We probably need to add some new types and instructions to `anchor_spl`.
Anyone have a basic example of how to build NFTs w/ Solana + Anchor :)?
https://project-serum.github.io/anchor/ts/classes/web3.connection.html#getaccountinfo
well it is exposed by anchor
I have to create a connection the vanilla web3 way
ty
ah right I think this is where I'm going wrong
oh, so it's not a anchor function
see https://solana-labs.github.io/solana-web3.js/modules.html#AccountInfo
oh yes that works
if you call for instance `getAccountInfo`  then it's `owner`
which program
what do you mean "who"? do you mean which program? or do you mean user space ownership?
thanks, will give it a go
installing from source should work
Hey guys, got the M1 today, followed a tutorial to get the solana CLI working. Is there also some special steps to get anchor working or I can just go ahead and install the classic way?
is there a way to view who owns a specific address?
understood
AFAIK there is no such thing as "program derived accounts", there are "program derived addresses"
is there a getAccountInfo function for program derived accounts?
https://docs.phantom.app/integrating/signing-a-message
Like how does this work in Phantom?
Not an anchor question, but how do I have my client sign a transaction (not a phantom wallet) and then verify that they signed it
ohh oki
lets u run ubuntu on windows and when ur using vscode the entire backend is in linux
wsl2?
and this is one of them :|
and i run into weird intractable problems every now and then with wsl2
yeah ive always liked zsh more but last year or so ive been using wsl2 for dev instead of a mac
or something
yeah bash is the... cash
awesome >:)
switched back to bash and everything is working again
well, kind of. there's something weird going on in my zsh environment
figured it out
ah thanks for help
wheres that folder ?
`.anchor` folder might have some logs?
idk man :/ only thing i can think is uninstall anchor and solana completely, restart computer, and reinstall. if that doesnt work it's probably some little issue with your environment
same thing
make sure to restart your terminal
and `anchor-cli` too
`npm install -g @project-serum/anchor`
i suppose i could reinstall the global one but it should use the local copy
yarn is local
do a global npm install
did a yarn install
did you reinstall the npm anchor package? im a newbie myself so im just going through what i can think of :/
just builds an exits quietly
same thing happens whether its open or closed
if so, you need to turn it off while you're running anchor tests
do you have that running while you're trying to test anchor?
```
Version: 1.8.2
Shred Version: 57600
Gossip Address: 127.0.0.1:1024
TPU Address: 127.0.0.1:1027
JSON RPC URL: http://127.0.0.1:8899
⠁ 00:26:49 | Processed Slot: 3926 | Confirmed Slot: 3926 | Finalized Slot: 3894
```
ya that works
type `solana-test-validator` just to see if it spins up
if i change the test to be invalid still does it
does this in basic-0 and basic-1
never invokes node to run the tests
which one are you testing? basic-0?
looks like it builds and exits
yeah
then it just exits?
```sh
❯ anchor test
BPF SDK: /home/clifton/.local/share/solana/install/releases/1.8.2/solana-release/bin/sdk/bpf
Running: rustup toolchain list -v
Running: cargo +bpf build --target bpfel-unknown-unknown --release
    Finished release [optimized] target(s) in 0.16s
Running: /home/clifton/.local/share/solana/install/releases/1.8.2/solana-release/bin/sdk/bpf/scripts/strip.sh /home/clifton/code/sol/anchor/examples/tutorial/basic-0/target/bpfel-unknown-unknown/release/basic_0.so /home/clifton/code/sol/anchor/examples/tutorial/basic-0/target/deploy/basic_0.so
```
no output and exit code 0
also if it stalled how long did you wait
does the terminal just stall? what is the output?
(as in, it does not run any of the tests)
it builds then does nothing
and `anchor test` is a noop for me
i was trying to go thru the examples from the gitbook
But one would need to recalculate seeds anyway while getting pda for `invoke_signed`, no?


//////////////////////////////////////////////////////////////////////////////////////////

hi guys
Do you have enough sol ?
They do I believe.
Marinade finance might use Anchor. You could see if their source code is public?
Hi, are there any examples for staking SOL from inside an anchor program that I could look at? Any help/pointers would be much appreciated 😄
Hi Friends. I am facing some problem while deploying anchor program on mainnet. Its working perfectly fine on Devnet. Any ideas?
yes, when it can anchor uses the `--bpf-program` option on solana-test-validator to start the localnet with all programs already deployed
ah cool, thanks for the info, i'll try actually deploying and poking about 🙇‍♂️
Or at least I think that's how the tests do things, I should dig into that further 🤔
About deploying, in general, yeah, you need to pay for them. When running the tests by default anchor does something funny to skip an explicit deploy, but you can try deploying them yourself by running a local validator, `solana-test-validator`.
No, the program account is owned by the bpf loader program.
In the tutorial basic-3 the `puppet_master` program doesn't do any Initialization for itself, I suppose because it doesn't have any state that it needs to manage for itself? In this case is the program owned by the system program by default?

My understanding though was that when we deploy any program, we would still need to provide some account which pays for the program to be deployed and the rent.
Yep, this sounds like exactly what PDAs are for. They're addresses where only their deriving program can sign for them.
No. Not totally sure I understand your question—why would it? When you redeploy you're reusing the same program_id, so all those old program-derived addresses are still valid.
Ah, right! Hmm I should think through that more, I never think about that option
Or you could just wrap your sol!
Can probably find some by searching the discord for `try_borrow_mut_lamports`. At any rate, transferring lamports depends (as always) on which program owns the account. I think people get the idea that its always the system_program that's responsible for transferring lamports, but this is wrong—the system_program can only transfer lamports from accounts owned by the system_program! If the source account is owned by your own program then it's up to your program to move the lamports, manually, with e.g. `try_borrow_mut_lamports`.
No, there are separate `associated_token::` attributes you'll have to use
```
rpc response error: {"code":-32002,"message":"Transaction simulation failed: Error processing Instruction 0: custom program error: 0x64","data":{"accounts":null,"err":{"InstructionError":[0,{"Custom":100}]},"logs":["Program Hvo42XYHzroj5jeFE5XzuXxLRwYUKeEagoiLQwc1CvEu invoke [1]","Program Hvo42XYHzroj5jeFE5XzuXxLRwYUKeEagoiLQwc1CvEu consumed 1353 of 200000 compute units","Program Hvo42XYHzroj5jeFE5XzuXxLRwYUKeEagoiLQwc1CvEu failed: custom program error: 0x64"]}}
```
hi, i got this error, 0x64 is 100, is it meaning the error is below Enum ErrorCode num 100?
```
# anchor/lang/src/error.rs

#[error(offset = 0)]
pub enum ErrorCode {
    // Instructions.
    #[msg("8 byte instruction identifier not provided")]
    InstructionMissing = 100,
......
```
or any simple hello world examples of invoke(
            &system_instruction::transfer(

?
yoooo we're trying to send solana from one account to another in anchor - any ideas?
Long winded way of making sure that the use case I am describing is indeed program signed accounts right? I have to make sure the authority on the token vault is my program through a program signed account?
Hey all, I am looking into Metaplex's token vault contract and I just have a general question about calling programs. The token vault allows you to specify a authority that has special privileges like transferring tokens out of the vault. This authority is a public key. My q is, if I call the token vault program in another program that is doing smth different, through a cpi, what's the best way to ensure that only my program can call the token vault program, and only if I call the token vault program I have authority to mutate data
hi, anchor initialize the token address this way ,is it a associated token account? if not ,i want to use anchor to initialize a assocaated token account , is this way work below, just not use seeds and bump?
```
#[account(
        init,
        payer = user_sending,
        token::mint=mint_of_token_being_sent, 
        token::authority=application_state, 
    )]
```
hey all, when redeploying a program that has already been deployed with the same program ID, does it remove the PDAs associated with it?
Yes, I can.
Good day! It seems like a very simple question, but can I pass a vector as an argument of an instruction?
very very interesting.. thank you Alan
I think not specifying space is a little sketchy because it's not guaranteed to work correctly (if you have any dynamically sized stuff in that struct). But up to the programmer.
If you don't specify space, then Anchor will expect `StateAccount` to implement the `Default` trait. Then at runtime it will make a default instance of the struct with `StateAccount::default()`, try serializing it with borsh, check how many bytes it ended up using, and use that for space.
Another noob question heh
```
#[account(
        init,
        payer = user_sending,
        seeds=[b"state".as_ref()],
        bump = state_bump,
)]
application_state: Account<'info, StateAccount>
```
from the same app
isn't it an issue that `space` isn't defined? Does Anchor auto-calculate that or something if u don't provide it?
i gotcha 😛 ive actually been keeping a list of stuff that needs documented for anchor. ill try to contribute once i feel more comfortable with the framework. If you guys keep your own list that might be helpful too
Haha, docs will be great some day, just not quite yet (still really early)
*slowly turns to Anchor...*
You'll almost always be better off looking at source + examples in the tests directory (or even better, writing little example programs yourself! that's what I do): https://twitter.com/NikhilChatu/status/1461103366726160385
gotcha, thanks. i was looking in here for answers to this confusement
https://docs.rs/anchor-derive-accounts/0.18.2/anchor_derive_accounts/derive.Accounts.html
am i looking in the wrong place?
Right (most operations on that token account will require application_state to sign)
oh okay, makes sense i think. btw `token::authority=application_state` means only application_state can transfer tokens out and close the account right?
The token account itself will live at that program-derived address.
when you say "account" in this sentence you mean that the token account address itself will be a PDA of those seeds?
 or it will create a main account first of those seeds and then create a token account from that main account and then set the owner/authority of that token account as `application_state`?
In this case the account will live at the program-derived address based on the program's program_id + those seeds + bump.
That's saying initialize a token account, whose mint is mint_of_token_being_sent and whose authority (the "owner" of the tokens, in the logical/human sense, not the which-program-can-mutate-the-account sense) is application_state.
Hi, how do you decode data from an account into an object?
```
  let results = await connection.getParsedProgramAccounts(programId);
  // results[0].account.data contains a buffer of the account data. how do I decode this?
```
i have one other i keep seeing in Daniel's safe pay app
https://github.com/PirosB3/SafePaySolana/blob/master/programs/safe_pay/src/lib.rs#L326-L327
```
#[account(
        init,
        payer = user_sending,
        seeds=[b"wallet".as_ref()],
        bump = wallet_bump,
        token::mint=mint_of_token_being_sent, // THIS
        token::authority=application_state, // AND THIS
    )]
```
what are those last 2 lines doing??
hmm, i see. and `Something` is the struct that references that account's data structure
Yeah, more or less—given an `Account<'info, Something>` you can call `.to_account_info()` on it
oh okay, i think that covers when i should use it lol. So can I just use `Account` and never use AccountInfo? Can anchor use either/or in places that just need raw account information?
`Account` is way, way fancier/more powerful (it does deserialization for you, checks ownership, etc.), whereas AccountInfo does absolutely nothing—it just gives you the raw account that the solana runtime handed us.
What is the tl;dr for when to use `Account` and when to use `AccountInfo`? Only thing i can understand right now is that the first is anchor's and the second is solana native..
Only by passing that public key as an account from the client (this is just a funny part of how solana works, it's not possible to dynamically fetch an AccountInfo from within your program—you have to pass it as an account from the client)
How can I convert a public key to AccountInfo type?


//////////////////////////////////////////////////////////////////////////////////////////

```

    const createCrc32Hash = () => {
        return Uint8Array.from(CRC32.str(Date.now().toString()).toString()).slice(
          0,
          8
        );
      };
      
    const crc32Hash = createCrc32Hash();

    const [accountAddress, accountNonce] =
      await anchor.web3.PublicKey.findProgramAddress(
        [authority.publicKey.toBuffer(), crc32Hash],
        program.programId
      );

    await program.rpc.createZeroCopyAccount(accountNonce, crc32Hash, {
        accounts: {
          host: authority.publicKey,
          zeroCopyAccount: accountAddress,
          pda: pdaAddress,
          systemProgram: SystemProgram.programId,
          rent: anchor.web3.SYSVAR_RENT_PUBKEY,
        },
        signers: [authority],
      });
```
```
    pub fn create_zero_copy_account(
        ctx: Context<InitZeroCopyAccount>,
        _bump: u8,
        _crc_32_hash: [u8; 8],
    ) -> ProgramResult {
        let zero_copy_account_key = *ctx.accounts.zero_copy_account.to_account_info().key;
        msg!("key: {}", zero_copy_account_key);
        let zero_copy_account = &mut ctx.accounts.zero_copy_account.load_init()?;
        let authority = &mut ctx.accounts.authority;

        zero_copy_account.authority = *authority.to_account_info().key;

        Ok(())
    }
```
Sure , one sec
what's the instruction handler code?
I have a quick question, I have something like this: 

```
#[derive(Accounts)]
#[instruction(_bump: u8, _crc_32_hash: [u8; 8])]
pub struct InitZeroCopyAccount<'info> {
    #[account(mut, signer)]
    pub authority: AccountInfo<'info>,
    #[account(init, seeds =[authority.key.as_ref(), _crc_32_hash.as_ref()], bump=_bump, payer = authority, owner = *program_id)]
    pub zero_copy_account: AccountLoader<'info, ZeroCopyAccountState>,
    #[account(mut)]
    pub pda: ProgramAccount<'info, PdaState>,
    pub system_program: Program<'info, System>,
    pub rent: Sysvar<'info, Rent>,
}
```
However, I get the following when calling the RPC from the tests: 

"Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account"
Because it will be weird for the users to connect wallet just to check data.
yeah like checking data
by readonly calls you mean calls like balance check?
But personally, i don't like the fact that you have to pass in the Wallet object because what if you only want to make read-only calls? The current walk around for that is to make empty wallet object and pass that in....
got it makes sense now , thank you REGO350 🙂
Yes
that is why we passin connection (like devner or mainnet) parameter too?
Basically, the provider object gives you connection to the blockchain AND wallet/signer object that lets you send/sign transactions.
If you are not familiar then you shouldn't check because ethes.js is first of all ethereum thing and it's a little complicated to understand first
not so familiar with it but will check, thank you 🙂
yea, everwhere i go i see it. you are right.
ill do :). thank you Alan.
it's community maintained, PRs get auto merged i think once checks are green
If you are familiar with Ethers.js, it's like Signer object
Agreed, or just doing stuff in JS.... you will realize quickly how much you need it
I think it will probably be easiest to understand what a provider is by just reading its source code, honestly
Thank you, got it (still a little confused).
That is why you pass it in a wallet and a connection
So a combo of a wallet and a connection.
It's a thing that can send + sign/pay for transactions.
Like everything in JS
what do we use it for?
Haha, don't really know, just know how to use it
what is a provider
ah sorry, i mean generally
`const provider = new anchor.Provider(connection, wallet, {
    preflightCommitment: "confirmed",
  });`
what is provider?
Never mind, it's the size of the unint8 array
I want this account only
In this, how do I know how big I should set the datasize filter?
`const accounts = await provider.connection.getProgramAccounts(
    program.programId,
    { filters: [{ dataSize: 10000 }] }
  );`
Or `Math.pow(2, 53) + 1 + 1 !== Math.pow(2, 53) + 2`
Just ran the test, and precision is good enough! Thanks Alan... hopefully we can link up in Lisbon
So e.g. `Math.pow(2, 53) === Math.pow(2, 53) + 1` 😱
Big nums exist because JS numbers are doubles, and can only represent integers exactly up to 2^53 if I remember right
hahaha, ok
I am dealing with lat/long
Big nums 🙂
Is there a way not to lose precision? Precision is very important for me here
Ok...
But you can of course lose precision doing so, so might have to be careful
Thanks!
`.toNumber()`
How do I decode a BN back to a JS number?
Is this also true for devnet and testnet? Because i'm thinking about deploying my program + token to live network.
Interesting
Hmmm....
It's so centralized LOL
It looks like you have to create pull request to this repo?
https://github.com/solana-labs/token-list
I am source diving right now... kind of curious how you do it now
Do you create like metadata account from mint token?

Good question, it looks like it has metadata like a MEtaplex NFT
spl-token.
If you are familiar with ERC20, you can easily set token name and token symbol. How do you do this in solana?
Like NFTs
How do you set token name and token symbol for mint tokens?
It is latitude and longitude
I want to get as many decimal points as possible....
ah ok
instead of doing assetions with BN
Yea.... I think it is because the number I was using was too big... 10^14, when I brought it down to 10^13 it worked
maybe convert that to number by using .toNumber() method?
when I try and pass a negative number into anchor.BN
It says "assertion failed"
Can I not send negative numbers into Anchor from JS???
My understanding at the time was that yeah, this kind of renders that testing library kind of useless :/
So you think there is no way of fixing this ATM?
Doesn't seem so. I pass the pubkey to the instruction with the bump seed from `find_program_address`.
I think I actually ran into this too, and it just doesn't let you initialize accounts via CPI or something silly (kind of an oversight lol)
Ohh, you're using the solana rust test library?
Is it possible you already initialized an account there with zero length?
So many scammers lol

dont ask in solana server
Why is account data length is not initialized to the correct value?
Trying to init a PDA in an integration test (solana-program-test) I get this error:
```
thread 'solana-bank-forks-client' panicked at 'Account data resizing not supported yet: 0 -> 87. Consider making this test conditional on `#[cfg(feature = "test-bpf")]`', ~/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-program-test-1.8.1/src/lib.rs:369:25
```
Interestingly, when I inspect the phantom popup it looks like the network traffic to the localhost rpc server is normal.
Ah, actually—not sure what happened, but now my localhost phantom is spinning too.
Guess i'll have to ask in solana channel 
(but i usually dont get response, thats why I always ask here lol)
Hmm, not sure what's wrong then 🤔
I can send/approve transactions but cannot view tokens
yes
Yep, works fine for me. Is your local validator running?
Always like this when I connect to localhost. Does phantom wallet support localhost?
Yep, thank you!
unfortunately the other program is already deployed, but ill find a way to make it work 😅
So you ought to be safe for now-ish timestamps.
Funny, I had never thought about that before. I think negative timestamps just mean before Jan 1 1970 (there are only like 2^25 seconds in a year so you can go pretty far into the future with 64 bits)
Is it safe to cast `unix_timestamp`s i64 to u64? Are there any cases when it can be negative?
Hey all, are there any program examples of staking one could look at as a reference? Just a simple one eg stake x token and get new x tokens
if you remove it you will have to reimplement that part
The 8 bytes is a good abstraction for the account to be valid
I see, you could make the other program read with the 8 bytes then?
I would like to know how to implement the magic used for initialising TokenAccount and Mint for my own custom type 🤔
I'm basically just trying to write data to an account in the program I'm writing with anchor without having the 8 byte discriminator at the beginning
the other program is only reading from the data, but it requires it to be a certain way (which doesn't allow 8 unrecognised bytes at the start of the data)
think about accounts like a database that belong to the program, no other db should be allowed to write anything to it as it wouldn't be valid
this would break every single thing in existence
you cannot write data then give it to another program
Essentially I'm trying to initialise a new account's data and then send it of to an existing on-chain program (which wasn't written with anchor) and unfortunately won't work with those extra 8 discriminator bytes at the start of the data
Hi guys, I noticed in the anchor_spl source code they  make it possible to play nice with the 'Mint' and 'TokenAccount' types from spl_token. It seem like these accounts don't have the 8-byte discriminator prepended to their data. I'm wonder how I can implement this myself for a different struct.
Using existing account data structs without 8-byte discriminator
Thanks <@!438874996614365185> the {accountFromIDL}.fetch(pubkey) is just what I was looking for. Appreciate the explanation : )
`connection.getAccountInfo(pubkey)` to just get the raw acount data or u can use anchor to deserialize with something like `program.account.{accountFromIDL}.fetch(pubkey)` where the {accountFormIDL} is something from your anchor generated IDL that represents a specific type of account data in your program 

and program is from something like `new anchor.Program(idl: Idl, programId: Address, provider?: Provider)`
But there is a button to unwrap all potentially wrapped SOL
Yes, some dapp don't unwrap, like saber.
What jupiter aggregator is doing is warning about unwrap SOL, but only SOL balance is considered
Whats the typical way to fetch account data via the typescript client?
Maybe some dapps doesn't include unwrap instruction so user's solana is still in wsol state.
I want to check for user's solana balance before transaction and make sure that user has enough balance. However i thought that some of their solana could also be in wrapped sol.
What is the question, what are you trying to do
Sorry what do you mean by that sir?
what is the exact context here?
When we check for user's solana balance, do we also check for their wsol balance? Or can we be sure that their wsol is already unwrapped?
appreciate the above. The helped me the most. It's tutorials 3&4 which im focusing on now to get a better idea. I will play around with things for a few days, and then things will click,. as that has been the case to date.
just ran that check and it has a length of 9744 so right on there for the limit.
ya i would say think about the program as stateless executable code, and then accounts as things where the data is stored. Every time you run a transaction u give it a program and instruction, and list of accounts to operate on. It loads these specific accounts and then operates on them and writes them back. So for every transaction that modified or reads an account, it needs to be passed into the instruction. the term "account" is very overloaded since it basically refers to everything 🙂

for examples, definitely all of the examples in anchor (basic1-4) https://github.com/project-serum/anchor/tree/master/examples/tutorial are great easy ones to go through

then i would say looking at escrow is a real use case of some of the concepts that is pretty straightforward to understand
https://github.com/project-serum/anchor/tree/master/tests/escrow

and then anything else in `misc`. I would also maybe recommended comparing this non-anchor version of escrow (https://github.com/paul-schaaf/solana-escrow/tree/master/program) to the anchor version. And maybe even trying to play around without anchor to fully understand what its doing this should help show the power of anchor ⚓ and also help u understand solana programming model
and thank u for the tip on the account !
i was thinking of writing a puppet program that woudl initialise a PDA account and write data to it until full. To me that makes the most sense. One thing/concept im hazy on is how the account called each time will be new, butr for that i woudl initialise with a different seed each time. I havent fully understood all the docs yet, and i need more work on the cpi/pda aspect. excited to dive in. Any examples of what you suggested would be amazing!
depending on what youre doing you may want to have a new derived account for each of those pubkeys so they are smaller and stored separaretly.

regarding checking how much is used, if you used just the command line tool looking up the account `solana account {pubkey}` you can kind of see how much is in use though there is probably a better way to get the exact number of bytes left
is there a way to check how much of an accounts data limit is populated. I'm writing Pubkeys to an account, and the limit is 172 pubkeys for an account initialised with 10K space. 

If there is a way to initialise a new account i wold appreciate any direction! COmpletely new and learning, so apologies if its a basic questions. Suggestions on what to google/read for more info welcome as well !
Hi friends. In my contract, I am using invoke. Sometimes this invoke trough the error. I am just wondering how I can invoke the custom error on invoke()? . At the moment it is automatically through  the solana error.
check that it comes from the right seeds **
what do you mean by check? you can look up the data in any account via its publicKey, or pass it in as an instruction to a program invocation
Are we able to check a PDA account which is derived from another program with #[account(seeds=[...], bump=..., ...)]?
Oh great thanks. How do you/we know to use these extra things in the account macro like mint::decimals, mint::authority or token::mint without seeing them in an example?
Yes. See `tests/misc` for an example.
Is it possible to create a Mint account via #[account(init, owner = token_program, ...) ?
Got it -- ty fam :).
Almost. It doesn't specify who the owner of the program is. It specifies the address of the program. That address--the program--is the *owner* of all accounts created and modified by the program.
So if I had to recite it back to you, is this any good? (just trying to make it settle in!)

```
basically it's an id initially generated by anchor init that specifies our program's id. When we run a function, it'll essentially look at this id and know who the owner of this program is. That's important because the owner specifies how to load and execute the program and contains info on how the Solana runtime should execute the program. 
```
Similarly, a hard coded address is used for the generated CPI client and `Program<T>` type.
This is used for security. It allows us to assert that all acounts declared in the program are owned by that ID.
Statically embeds the address of the program into the binary.
Could someone sorta ELI5 what `declare_id!("4NxrkrWwJX29WrJuKEMWZChhgYZJT5irSGVrpvVqtabo")` does and why we need to change it to a new address output by `anchor build` before deploying via `anchor deploy`?
Just figured it out...
Thanks!!!
`splToken.ASSOCIATED_TOKEN_PROGRAM_ID`

what is the assoicatedProgramId
Found it

Where does associatedTokenAddress live?

Yes… I know that too!
You can use an "associated token" address for this.
Presumably you also know the intended recipient? (Whoever will "own" those tokens)
How do I create the token account to send a token to if all I know is the mint pubkey??
Perfect, I think I get it 🙂 Thank you
You'd basically just have to come up with different seeds. Think of the seeds as the program's "name" for that address; you'll just have to pick a unique name for each account.
Got it, do you know of a way where I can create multiple PDAs that derive different addresses? If I pass in another variable from client as an instruction and use that to derive the PDA, does it make an impact on the security of the application?
Yep, given the same seeds + same program_id, you'll always get the same address.
How do you guys recommend creating seed / bumps for PDAs? 

If I use the public key of the signer as the seed, and if the signer has multiple accounts, wouldn't it derive the same address everytime? Or if I use a static seed like b"hello_world", it would also derive the same address, correct?
Thank you ! 😊
This is mine 🙂

https://github.com/farzaa/test-for-anchor
Awesome! Thank you, I was looking at this but was hoping for a more comprehensive example if there are any. Maybe like a github repo
Lots of little examples here:

https://dev.to/dabit3/the-complete-guide-to-full-stack-solana-development-with-react-anchor-rust-and-phantom-3291
Epic, ty!
Hi, are there any good examples of connecting anchor to the frontend with React and sending signed transactions with a wallet?
https://github.com/solana-labs/solana-web3.js/blob/master/src/connection.ts#L4036
you could also setup a `Connection#onLogs` listener at the start of all tests and just redirect to stdout if you want to see them there
You can see logs in `./.anchor/program-logs/`
Ah so is there a way to see it upon `anchor test`?
`msg!` prints to the program log onchain
Trying to get basic print statements working in my Anchor program, but, looks like a a `println!` or `msg!` doesn't seem to do the trick upon running `anchor test`.
Hello! Question about IDLs/dynamic traits. I wasn't able to add `derive(AnchorDeserialize, AnchorSerialize)` on one of my structs `Foo` because it has a `Box<dyn BarTrait>` field in it. 

I was able to manually `impl AnchorSerialize for Foo` and `impl AnchorDeserialize for Foo` to get past the compiler errors, but `Foo` doesn't show up in the IDL when i run `anchor build`, I guess since I'm not calling `derive` directly?

Any suggestions for how to work with structs with a dynamic boxed trait in anchor? I can paste a code snippet too if it's clearer
ty friend
thanks
unless you wanted to deploy your program locally to test a front end/client integration or something of the sorts
so no, you don't need it running separately if you don't have a real reason to
by default `anchor test` will stand up a local validator behind the scenes to deploy and test against unless you explicitly add `--skip-local-validator`
Do we ever need the local validator running when building, testing, and deploying w/ Anchor?

`solana-test-validator`
GM Anchor friends :).
need to change`&AccountInfo` to `&AccountInfo<'info>`
not totally sure, have attempted to finagle it, but i think there's something that just isn't clear to me about how this is supposed to (or not supposed to) work, any suggestions would be appreciated
running into some rust-noob issues, i'm trying to use `remaining_accounts` (which should be a fixed size based on my use-case)
and then pass a single account into a cpi context, like so:
```
impl<'info> Distribute<'info> {
    fn into_distribute_context(&self, to: &AccountInfo) -> CpiContext<'_, '_, '_, 'info, Transfer<'info>> {
        let cpi_accounts = Transfer {
            from: self.vault.to_account_info().clone(),
            to: to.to_account_info().clone(),
            authority: self.system_program.to_account_info().clone(),
        };
        let cpi_program = self.system_program.to_account_info();
        CpiContext::new(cpi_program, cpi_accounts)
    }
}
```
but it's giving me this error:
```
error[E0621]: explicit lifetime required in the type of `to`
   --> programs/router/src/lib.rs:178:38
    |
171 |     fn into_distribute_context(&self, to: &AccountInfo) -> CpiContext<'_, '_, '_, 'info, Transfer<'info>> {
    |                                           ------------ help: add explicit lifetime `'info` to the type of `to`: `&anchor_lang::prelude::AccountInfo<'info>`
...
178 |         CpiContext::new(cpi_program, cpi_accounts)
    |                                      ^^^^^^^^^^^^ lifetime `'info` required
```
ah no need, it is written on the link
totally! it was really helpful for me! sorry should have referenced you for credit
it feels nice to see my repo used as an example 😄
this file is straight from metaplex
i don't think there is a magic anchor way, since this isn't an anchor program
Thanks!
yeah, there's some code here that gets at it, but i think there's a much easier way with some of the anchor utilities, though i can't find them offhand
https://github.com/random-access-memories-so/ram-app/blob/98227d8fb470305e4828de3e113d9e10bf8da53b/src/tools/metadata.ts
I am getting the token accounts by owner and now want to do stuff with them, but can't without also having the mint pubkey
JS
in JS or solana/rust?
How do I fetch an SPL token's mint if I have it's pubkey???


//////////////////////////////////////////////////////////////////////////////////////////

Ssh to a remote Linux machine
any work arounds bois
Solana Rust BPF toolchain is not available on Windows
guys need some clarity on NodeWallet. what is that class for? when should i use it
Could have been... I'm still using Anchor v0.17.0
I sort of thought floats got added recently but I guess not yet 🤔
Yeah, you can see the current list here: https://github.com/project-serum/anchor/blob/master/lang/syn/src/idl/mod.rs#L164
Hey <@!134416332509675520> , can you perhaps help with this? 😅
No problem... glad I could be helpful.... that's why I like to post the answers to my problems... figure someone else will have them haha.
thanks!
Is there a way of adding an rpc call in the set of instructions that are executed when a program is deployed? I am writing a program that sets an admin (external PubKey) within a PDA during the initialize call and want the initialize call to be executed right after the program is deployed. Else anyone can call this function and become the admin
`init` means anchor is going to write a bunch of code to create an account (could be an account your program will own, or a few other kinds: a token account, a mint, an associated_token account)
Ah, ok. I think you're maybe a little confused about what authority means here. If you just want your program to be able to mutate an account, you don't need to set an authority or anything like that—you just need to make sure your program is the program that owns the account. When you use `#[account]` in anchor + `init`, this all happens automatically, no need to do anything else.
what's the difference between init and zero
Hey can you interact with another program ?
how can I check if the given TokenAccount is owned by the anchor programm
the following doesnt work?

`#[account(mut, owner = *program_id)]
  pub stake_token_account: Account<'info, TokenAccount>`
I know decimals aren't used in Ethereum and other EVM compatible chains, but since Solana has a different architecture, just wanted to ask you guys this
Hey can anyone tell me what are the valid data types(i64, u64, u32, etc.) in  the Anchor Rust IDL?

Because I was writing a program where I had to handle some decimals so I decided to use the data type `f64` since it is a valid Rust data type, but looks like it isn't in Anchor. Am I getting this right? And if yes, how do we handle decimals in Solana development (like suppose we are diving 10 by 3 and we want to persist the result in an account). 

Thanks.
really just going for an example of a program that owns it's own mutable state account... super basic 😅
I asked the system_program to set an authority for it instead for that reason, does that make sense?
I just want the StateAccount to be owned by PDA... don't need it to be a token account since it only holds data right?
Ah, your StateAccount isn't a token account, so it doesn't make sense to ask the token program to set an authority for it 🤔 I'm unclear what you're trying to do though.
Ok, I'll look at the IDO pool example.
In the meantime my whole code is here (very short): https://github.com/AlphaPrime8/chain_mail/blob/use_pda_for_state/programs/chain_mail/src/lib.rs
and the client side: https://github.com/AlphaPrime8/chain_mail/blob/use_pda_for_state/tests/chain_mail.ts
perhaps you could glance at it and quickly see where I'm going wrong. Really appreciate your guidance.
IDO pool example has a PDA with a data account on it
Setting token account authority and moving around accounts this way is very non standard
I dunno if I'd really follow along with escrow example in anchor. It's kind of odd
Yeah, I can't really tell from your snippet, but you'd definitely need to specify the token program when setting a token's authority
So i guess there are two issues then: 1) why is token_program argument invalid, and 2) should I be using the token_program somewhere in the set_authority call?
Thanks
Pro-formatting-tip: can do three backticks, `, to do big code blocks
but i get: `Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: invalid program argument
`
and updated the Context with: `    pub token_program: Program<'info, Token>,`
I tried passing it like this:
`
    const tx0 = await program.rpc.initialize({
      accounts: {
        stateAccount: stateAccount.publicKey,
        user: provider.wallet.publicKey,
        systemProgram: anchor.web3.SystemProgram.programId,
        tokenProgram: TOKEN_PROGRAM_ID,
      },
      signers: [stateAccount],
    });`
Are you passing the token_program as one of your accounts?
(forgive the formatting i'll work on that...)
I've been looking at the escrow program in /tests and it calls token::set_authority to transfer ownership of a TokenAccount from initializer to PDA...
I tried adapting the logic for transferring ownership of an account with the CpiContext constructed like so:

`impl<'info> From<&mut Initialize<'info>>
for CpiContext<'_, '_, '_, 'info, SetAuthority<'info>>
{
    fn from(accounts: &mut Initialize<'info>) -> Self {
        let cpi_accounts = SetAuthority {
            account_or_mint: accounts
                .state_account
                .to_account_info()
                .clone(),
            current_authority: accounts.state_account.to_account_info().clone(),
        };
        let cpi_program = accounts.system_program.to_account_info();
        CpiContext::new(cpi_program, cpi_accounts)
    }
}`

Also the Context struct looks like this:
`#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 8 + 1)]
    pub state_account: Account<'info, StateAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}`

But I get this error: Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: An account required by the instruction is missing`
What am I missing?
cool thanks
Ah, sorry, you're trying to—the order is flipped, `addPool(x, y, z, { accounts: { .... } })`
You're not passing a bunch of arguments to the JS rpc call (the error is confusing but that's the issue)
Getting `Error: Invalid arguments: baseAccount not provided.` error when calling add_pool function in client. How to fix this?
you should look at `/tests` in anchor repo
that account is the PDA
can you point me to an example of creating an account to store a program's mutable state and transferring ownership of said account to pda?
Depends on if the data is static or not. If it's static you could just embed it into the program itself. Otherwise you'll need to store it in some account (solana doesn't support mutable static variables).
how do I store arbitrary data my program needs to reference to do account validation in a program? does it need to be initialized as its own account?
Self explanatory. Not enough accounts public keys passed into the function
Any idea what causes: `insufficient account keys for instruction`?
Hey guys! <@!134416332509675520> What’s the point of using tx.partialSign() if we’re able to just successfully call RPC functions using tx.sign()?
okay, so if i don't have any custom errors, i should just go with `ProgramResult`
The `Result<()>` thing works if you've defined an `#[error]` enum for your program, and is a slightly different alias that lets you use your custom error types too
ahh okay, that makes a lot of sense - tyvm!
ProgramResult is the basic solana return type, it's an alias for `std::result::Result<(), ProgramError>`
okay i see my question might be too broad - can someone atleast explain what the difference is between using `ProgramResult` and `Result<()>`?
Hi, i'm very new to developing smart contracts, and i'm currently trying to solve a task, involving building a smart contract for a dutch/descending auction.
I've been researching and trying to get a better understanding to solve the task, but i'm not really getting anywhere...
Can anyone guide me in the right direction, with some usefull links/articles? Anything would be a huge help!
haha no worries, thanks for the info 🙇‍♂️
I can't think of any other way to do it—I say "hack" since I'm not 100% sure about the overall goal (maybe it's fine, not sure)
cool yeah, makes sense. When you say hack together, does this mean it isn't really best practice? I'm just thinking of cases where you have a "child" program like `puppet` that might create some data that doesn't make sense on it's own. Maybe it depends on context tho
You can hack this together with program-derived addresses. You would have Program2 require Program1 to call it and pass one of Program1's PDAs (and sign for it).
Might need to update your `space =` thing?
not sure if this question is too vague.. but what is the best way to ensure that instructions in Program2 can only be invoked (successfully) by Program1? e.g. in the basic-3 example, is there an easy way for the `puppet` program to only execute transactions signed(?) by the `puppet_master`
Hey all quick question - what's the main difference between using `Loader` and `AccountLoader`?
Yes
yeah it works
am i misunderstanding pubkeys?
but I'm getting error 163, account did not deserialize
I'm trying to add a Pubkey as an argument to basic-1 example program
That's all anchor init was trying to do
I don't have a windows machine so don't know why the original thing didn't work (something with the path though)—does running yarn manually end up working?
I can, is that a workaround for the anchor init issue?
Hmm, not sure. Can you just cd into the new project directory and run `yarn` from there?
yeah i can run yarn -version in the terminal and havee had no issue with yarn on any other project I've worked on. Error only appears when using anchor init. 

currently using version 1.22.17 of yarn.
Is it accessible in your path? Not sure what the equivalent of `which yarn` is for windows
Anyone know how  to fix this error on Windows 10:

commad: `anchor init myepicproject --javascript`


Error: `Yarn install failed: No such file or directory (os error 2)`

I have yarn installed


//////////////////////////////////////////////////////////////////////////////////////////

Anyone have any thoughts. this signer key refers to the initializerMainAccount which should be the main account interacting with the endpoint
Ohh when I get rid of he insturctions array from this endpointt, I get this error:      Error: unknown signer: 2NF8ahsqHKZyFb1V17pg5FPuEts8aco51KHE5jxoJznr <@!771049362658426910> Are you aware 🙂 Following your awesome tutorial a
Any ideas <@!134416332509675520>
```
await program.rpc.initializeEscrow(
      vault_account_bump,
      new anchor.BN(initialAmount),
      new anchor.BN(takerAmount),
      { 
        accounts: {
          initializer: initializerMainAccount.publicKey,
          vaultAccount: vault_account_pda,
          mint: MintA.publicKey,
          initializerDepositTokenAccount: initializerTokenAccountA,
          initializerReceiveTokenAccount: initializerTokenAccountB,
          escrowAccount: escrowAccount.publicKey,
          systemProgram: anchor.web3.SystemProgram.programId,
          rent: anchor.web3.SYSVAR_RENT_PUBKEY,
          tokenProgram: TOKEN_PROGRAM_ID,
        },
        instructions: [
          await program.account.escrowAccount.createInstruction(escrowAccount)
        ],
        signers: [initializerMainAccount, escrowAccount ]
      }
    );
```
Hi all, I am writing tests to interact with. my instructions for my online program. I am recieving this error when interacting with Anchor Escrow program:

  Error: failed to send transaction: Transaction simulation failed: Attempt to debit an account but found no record of a prior credit.
Yeah that would be a great feature, Stack Overflow and discord were started by the same person so I would guess there is a way to link the 2 of them.
i'm a big fan of stackoverflow generally
i wonder if there is a discord bot that will post questions with certain tags in a channel
Yeah I went for solana in the end, not sure I have enough rep to make new tag but i'll try add solana-anchor to my question.
maybe we can make one that is `solana-anchor` or something
good question, it doesn't look like there is, i see people coopting html `anchor`, and also using `rust` and `solana`
Is there a specific tag for anchor on Stack Overflow ?
box is necessary to stop from blowing out the memory with too many accounts
yes
```#[account(init,
        token::mint = watermelon_mint,
        token::authority = ido_account,
        seeds = [ido_name.as_bytes(), b"pool_watermelon"],
        bump = bumps.pool_watermelon,
        payer = ido_authority)]
    pub pool_watermelon: Box<Account<'info, TokenAccount>>```

Looking at the ido-pool code. Trying to understand what it does from what I can see is that it creates a PDA account with seed as name+ "pool_watermelon" of TokenAccount type which gets stored on heap(not sure why we need to store this on heap) with authority as ido_account and mint it stores is of type watermelon_mint. Makes sense ?
ty
Ayee it looks like that solved that problem.
okay ill try that
Mm, what if you do `cargo clean` and then try `anchor build` again 🤔

What does `rustup toolchain list` say?
so i completly uninstalled rust and anchor and reinstalled them but its still saying rustc 1.52 somehow its using an older version despite when i run rustc --version it says rustc 1.56.1 is installed
okay thanks ill check into that
I think you'll want to use a newer version of rustc (you seem to be using 1.52 which is kind of old).
Pass an account constraint checking if the Signer = the admin pubkey
How to create a function which can only be accessed by the owner?
Hi to reiterate my problem when i type anchor build i get an internal compliation error. Is this something i can fix. Becuase if i type anchor build -- -Verbose it seems to work
One use case for this (is it the only one? not sure 🤔) is if you want a really big account. Accounts that you directly `init` with anchor get set up via a CPI to the system_program, and solana has a weird limitation where accounts set up like that can only be 10kb in size. If you want something bigger you have to allocate space for them in a separate instruction.
Whoops sorry lol, got distracted and forgot to write up `zero`: it asserts that the account doesn't yet have any discriminator bytes (the first 8 bytes of the account storage are used by anchor to specify which kind of account struct is supposed to go there). This is kind of a specialized use case for when you allocate the account's storage in a separate instruction and then finish the initialization (including writing the discriminator bytes) in a different ix (the one with the #[account(zero)] in it).
what's the difference between this and zero ?
Not sure how to use cli command during the creation process
But this binded to a UI interface
other than SOL
I try to modify this to let candy machine accept spl token
Mm, still not totally sure what you're asking about—do you want to change that `parsePrice` function? I basically have no idea what you're trying to do haha.
This is the definition of the function 

export function parsePrice(price: string, mantissa: number = LAMPORTS_PER_SOL) {
  return Math.ceil(parseFloat(price) * mantissa);
This is how it's done in the create.js
export async function create(
    keypairPath,
    env,
    price,
    configState,
    log,
) {

    let parsedPrice = parsePrice(price);
That function doesn't seem to have anything specific to do with SOL to me (the default is set to 10^9, but it's just a default argument).
Hi all, maybe a dumb q. I deployed a program to devnet successfully. Then I closed the program (which in reality closes the executable data account) with `solana program close {programId}`. Is there a way to re-deploy the program to the same exact programID?
let parsedPrice = parsePrice(price);
export function parsePrice(price: string, mantissa: number = LAMPORTS_PER_SOL) {
  return Math.ceil(parseFloat(price) * mantissa);
How do I modified this line from SOL to other spl token
export function parsePrice(price: string, mantissa: number = LAMPORTS_PER_SOL) {
  return Math.ceil(parseFloat(price) * mantissa);
Friends
Is this correct? I am struggling to get the tests working but I think is due to error in the js test code. 
So I just want to make sure this is correct on the rust side.
Finally the function which adds the pool to the list. 
```
// old name which I don't want to change as used in other places function is add_pool 
    pub fn add_gif(ctx: Context<AddGif>, image_link: String, pool_name: String, pool_desc: String, win_opt:String, close: u32, verify:String, fee:u8) -> ProgramResult {
        let base_account = &mut ctx.accounts.base_account;
        let wins: Vec<String> = win_opt.split(';').map(|s| s.trim().to_string()).collect(); //chars().filter(|c| !c.is_whitespace()).collect()
        // make a program address which will hold the SOL for this pool 
        let pool_wallet = &ctx.accounts.pool_wallet;
        let pool = PoolStruct{
            pool_wallet: pool_wallet.to_account_info().key.to_string(),
            pool_id: base_account.total_pools,
            image_link: image_link.to_string(),
            user_address: *base_account.to_account_info().key,
            pool_name: pool_name.to_string(), 
            pool_balance: 0,
            pool_description: pool_desc.to_string(),
            win_options: wins, 
            close_date_time: close, 
            verify_url:verify.to_string(),
            owner_fee: fee,
            result: "".to_string(), 
            closed: false, 
            entries: Vec::new()
        };
        base_account.pool_list.push(pool);
        base_account.total_pools += 1;
        Ok(())
    } 
```
Hey guys I am building a program where the main baseAccount holds a list of pools I want each pool to be able to receive Sol and pay it out. So I created the following. 
The pool struct. 
```
#[derive(Debug, Clone, AnchorSerialize, AnchorDeserialize)]
pub struct PoolStruct{
    pub pool_wallet: String,
    pub pool_id: u32,
    pub image_link: String,
    pub user_address: Pubkey,
    pub pool_name: String, 
    pub pool_balance: u64, 
    pub pool_description: String,
    pub win_options: Vec<String>,
    pub close_date_time: u32, 
    pub verify_url: String, 
    pub owner_fee: u8,
    // TODO: to allow for pools with more then 1 winning result perhaps result should be an array?
    pub result: String,
    pub closed: bool,
    pub entries: Vec<EntryStruct>
}
```
the pool_wallet and base accounts structs. 
```
#[account]
pub struct BaseAccount {
    pub total_pools: u32,
    pub pool_list: Vec<PoolStruct>,
}

#[account]
pub struct PoolWallet{
    pub balance: u64 
} 
```
then the struct which creates the new pools and adds them to the base account.
```
#[derive(Accounts)]
pub struct AddGif<'info> {
    #[account(mut)]
    pub base_account: Account<'info, BaseAccount>,
    #[account(init, payer = user, space=9000)]
    pub pool_wallet: Account<'info, PoolWallet>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>
}
```
ah
WSL2


//////////////////////////////////////////////////////////////////////////////////////////

Just realized I posted msg in wrong channel will move it to development ☺️
Nope! Try giving it a shot and we'll be happy to help though
do you know any code example of this?
I am trying right now to initialize them outside of accounts context because it's an unknown amount of mint addresses and I don't know how to dynamically initialize in the accounts ctx
When I receive addresses for mint accounts as parameters for instructions, do I have to initialize all of them in the accounts context, if so what are the correct constraints is it #[account (zero)] I am not mutating account data just sending burn instructions
I think that's spoofable from the client though (so, probably not gonna get spoofed lol but maybe)
Or at least that's how I would think to do it.
That's how you would force the caller to prove they own the nft.
Ok. You'll have to do that a bit differently: you'll need to submit a token account holding the nft, and then you'll also need the owner of that token account to sign the transaction.
I have to check if msg sender is the NFT owner.
Wait he has `msg_sender` defined in his context
Well, what do you want to do with the msg sender? Maybe there's something similar you could do that's easier
Yeah, hmm
Not sure if anchor exposes that though
The first account in the tx is the payer: https://jstarry.notion.site/Transaction-Fees-f09387e6a8d84287aa16a34ecb58e239
Versus checking whoever signed as above, which might just be some random signer
I was trying to think, is there an easy way to figure out who paid for the tx? I think in general the answer is no but not sure
A `signer` might be what you have in mind when you think of the msg sender?
Your instruction context defines `Signer` accounts
then what's the best way to get msg sender?
Thanks! That looks like it was the issue. This appears to work now...```
  const result = await program.rpc.sendSol(new anchor.BN(0.01), {
    accounts: {
      from: provider.wallet.publicKey,
      to: secondAccount.publicKey,
      systemProgram: SystemProgram.programId,
    },
  });

  console.log("📝 Your transaction signature", result);
```
The accounts need to match 1-1 with your #[derive(Accounts)] struct
Mm, think you also need to pass the systemProgram, but that would be a different error
It's actually fine for the secondAccount to be a random keypair (that's actually basically what a wallet is)
```
  await program.rpc.sendSol(new anchor.BN(0.01), {
    accounts: {
      from: provider.wallet.publicKey,
      to: secondAccount.publicKey
    },
  });
```
Can you post a bigger snippet?
So, if I change it to ```
    accounts: {
      from: provider.wallet.publicKey,
      to: secondAccount.publicKey
    },
```
I get `Signature verification failed` which I am guessing is something to do with the fact that the `secondAccount` isn't any sort of wallet, it's just a random key pair I generated.
As for verifying that the send worked, you could so something like `await program.provider.connection.getAccountInfo(theRecipientPubkey)` and check how many lamports are in there
ah ok
Few things wrong: first, I think you'll need to do `new anchor.BN(1)` (annoying). Second, those account names don't match what your `SendSol` struct expects (you've got `baseAccount` and `user` rather than `from`, `to`, and `systemProgram`)
I'm not sure if I am doing this correctly, or if I am miles off, but I then wanted to write a test, but can't work out how to have 2 wallets to send the SOL between and then verify that it did something.
```
  const provider = anchor.Provider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.Tipme;
  const baseAccount = anchor.web3.Keypair.generate();
  const secondAccount = anchor.web3.Keypair.generate();
  await program.rpc.sendSol(1, {
    accounts: {
      baseAccount: baseAccount.publicKey,
      user: provider.wallet.publicKey,
    },
    signers: [secondAccount.publicKey]
  });
```
Not in general, no (I'm not sure if solana actually gives you easy access to the sender of the transaction 🤔)
I am trying to write a function that will send sol from the wallet executing it, to another wallet, specified in the function. So far I have something like this (edited for brevity)
```
#[program]
pub mod tipme {
  use super::*;
  pub fn send_sol(ctx: Context<SendSOL>, amount: u64) -> ProgramResult {
    let ix = anchor_lang::solana_program::system_instruction::transfer(&ctx.accounts.from.key(), &ctx.accounts.to.key(), amount);
    anchor_lang::solana_program::program::invoke(&ix, &[
      ctx.accounts.from.to_account_info(),
      ctx.accounts.to.to_account_info(),
    ]).unwrap();

    Ok(())
  }
}

#[derive(Accounts)]
pub struct SendSOL<'info> {
  #[account(mut)]
  pub from: Signer<'info>,
  #[account(mut)]
  pub to: AccountInfo<'info>,
  system_program: Program<'info, System>,
}
```
Is this the correct way of getting msg sender?
It holds a list of prediction pools, but now I understand it can hold lamports as well it makes things a lot easier. 
Thank you very much for your help, you've solved the problem i've been wrestling with for days now.
Accounts have data (potentially empty) and lamports (plus some other stuff)
Yeah, it's just an account (not sure what kind of data it's holding, whatever the BaseAccount struct has in it)
Ahh. ok so it is just holding the program data, but could also hold SOL
Mm, there's no program in that base account (the program is the program_id, not the base account)
No, I though I read that I could not a hold SOL and a program in the same account which sent me down the PDA rabbit hole.
Have you tried using that approach? I think your best bet is to just start trying stuff
Well when start the program I create a baseAccount with the following struct.
```
#[derive(Accounts)]
pub struct StartStuffOff<'info> {
    #[account(init, payer = user, space= 10240)]
    pub base_account: Account<'info, BaseAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}```
and function 
```
pub fn start_stuff_off(ctx: Context<StartStuffOff>) -> ProgramResult {
        // get a referance to the account 
        let base_account = &mut ctx.accounts.base_account;
        // initliase total_count. 
        base_account.total_pools = 0;
        Ok(())
    }
```
Could that be the only account I need?
Basically you can send money to whatever account you want, just gotta make sure you can get it back 😛
What do you mean by "holds the program"?
Can I just send lamports to the baseAccount which holds the program?
You could also sort of get away with not initializing an account at all, and just sending lamports to that PDA's address. This is slightly risky because some of the lamports actually go to rent exemption etc.
That would be the approach where you initialize an account (owned by your program) that lives at the pda with empty seeds. You'd then be able to send it money (somehow), and transfer money from it by doing something like `**ctx.accounts.that_account.to_account_info().try_borrow_mut_lamports()? -= amount_to_send` (plus correspondingly incrementing the recipient's lamports)
Ok  then I just save the publicKey to use as the to and from address for transferring lamberts as required? 
Using this approach do I still need the ```#[account(init, seeds=[], space=9000,bump = bump, payer=user)]``` macro inside the program code.
That just uses empty seeds, no need to remember anything.
I would personally probably use a PDA because then I wouldn't need to remember the address of the account storing the money (a keypair address is random, so you need to remember it). E.g.
```.js
const [address, bump] = await anchor.web3.PublicKey.findProgrammAddrss([], program.programId);
```
The private key might not really matter here once you've initialized the account (you might never need to sign for it again)
I think this makes sense for my use case, and using a PDA seems to be safer in terms of protecting the private key and therefore who can transact with the account? 
Although I am not sure how to implement it.
Makes sense to me.
Maybe for NFTs they're almost the same, but e.g. transferring authority over someone's associated token account for some random token feels super weird to me (what if someone sends them some more of that token?).
My first guess is that transferring the tokens directly to an escrow account (the second option above) feels cleaner to me, but not totally sure.
When you transfer authority of a token account, do you have authority over the entire account, or just some designated amount of its tokens?
what is the right way to hold off token for certain time period. Transfer authority to program and later on again transfer to same sender or create a PDA of mint and sender address and transfer token to that address and when time period ends return that to sender address ? trying to create a staking program for nfts
But alternatively, you could have the account be owned by *your* program, not the system_program, in which case whether it lives at a PDA or a keypair address doesn't matter (your program can just decrement the lamports itself, no need or even possibility of asking the system_program to do it)
That would indeed require a PDA, because otherwise you won't have a good way for the program to sign when asking the system_program to `transfer` the funds.
If you want to store money in an account that your program can distribute, one way to do it would be for it to live at a program-derived address and have the account itself be owned by the system_program.
PDA-ness vs keypair-ness is purely about who can *sign* for the address (PDAs can only be signed for by their deriving program, keypairs can only be signed for with their secret key)
No, the PDA-ness vs keypair-ness doesn't matter (well, it might, but it doesn't necessarily)
Yeah I was just generating a keypair but it should be a PDA. As i understand it a PDA can hold funds for a program and the program can distribute them as required?
What makes you think it's a program-derived address?
Aha. Where is the account's address coming from then? Is it a keypair address or something?
Ahh i think thats where I am going wrong I am not running that on the client side.
The bump is whatever you got when you did `const [address, bump] = await anchor.web3.PublicKey.findProgramAddress(...)` on the client, when you figured out the PDA's address
What do you set the bump to be?
something like this? 
```
#[derive(Accounts)]
#[instruction(pool_name: String, bump: u8)]
pub struct AddGif<'info> {
    #[account(mut, signer)]
    pub base_account: Account<'info, BaseAccount>,
    #[account(init, seeds=[pool_name.as_bytes(),b"pool_wallet"], space=9000,bump = bump, payer=user)]
    pub pool_wallet: Account<'info, PoolWallet>,
    // #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>
}
```
So if you're using `init`, you'll need to also use `seeds = [the, seeds], bump = the_bump`
My guess is that if you're trying to initialize an account at a PDA, you haven't specified its seeds + bump correctly (they need to be specified in order to sign for the address when you or anchor inits the account there—just part of how solana works)
I thought I had se them to mut? https://github.com/jobyid/solana_pred_pools
PDA so yeah mutable account is a necessity
Ok thanks I am trying to create an account controlled by the program which can hold SOL, struggling a bit to get my head around it.
Depends on what you're doing (that error is meant to be somewhat self-explanatory—you're doing some kind of cross-program invocation and you either aren't signing with some account that needs to, or you forgot to mark some account as `mut`)
`init` is the keyword
`/tests` in anchor repo
Hey guys do any of you know why I am receiving this error in my js tests? 
```
Program Cq1TSA1obVQZzw2YYxvFN6Q5ia5TYxSbwyZQ9JwQCbBL failed: Cross-program invocation with unauthorized signer or writable account'
```
does anyone have any code examples of initializing account via cpi?
I don' t think there is any way to do that. 
You can store the seed in the PDA's  data when PDA  is created.
If you know how to receive source of sha256 hash than yes 🤪
Is it possible to find seeds if we have a PDA account public key ?
no way to get it work...
hi devs,

any eta to fix example in readme?
Try searching the discord for further info (there have been many many discussions of declare_id! in the past haha)
It embeds a static variable in your program with its expected program_id. This is useful for a few reasons/currently something you just need to do (it's possible anchor will automate this in the future).
> declare_id! is program id
smh I am dumb: To anyone forking serum-dex, and missing the do.sh file->It has been depreceated. 
Instead of: "./do.sh test dex"
use: "cargo build-bpf"
 
In the root directory of dex
"Convenience macro to declare a static public key and functions to interact with it" still don't get what this means
https://docs.rs/solana-program/1.8.5/solana_program/macro.declare_id.html
what is `declare_id!` in a solana program?
nevermind had to replace `<YOUR-PROGRAM-ID>`
Can someone tell me how to deploy a dex to configured cluster: DEX_PROGRAM_ID="$(solana deploy dex/target/bpfel-unknown-unknown/release/serum_dex.so | jq .programId -r)"

Like what the specific steps
client.js is the same as in the tutorial:
```
// client.js is used to introduce the reader to generating clients from IDLs.
// It is not expected users directly test with this example. For a more
// ergonomic example, see `tests/basic-0.js` in this workspace.

const anchor = require('@project-serum/anchor');

// Configure the local cluster.
anchor.setProvider(anchor.Provider.local());

async function main() {
  // #region main
  // Read the generated IDL.
  const idl = JSON.parse(require('fs').readFileSync('./target/idl/basic_0.json', 'utf8'));

  // Address of the deployed program.
  const programId = new anchor.web3.PublicKey('<YOUR-PROGRAM-ID>');

  // Generate the program client from IDL.
  const program = new anchor.Program(idl, programId);

  // Execute the RPC.
  await program.rpc.initialize();
  // #endregion main
}

console.log('Running client.');
main().then(() => console.log('Success'));
```
I'm just following this tutorial:

https://project-serum.github.io/anchor/tutorials/tutorial-0.html#building-and-emitting-an-idl
Please provide some code to go along with the error message. It's hard to debug like this.
What have you tried so far?
Anyway, running the following:
```
% ANCHOR_WALLET=/Users/prikshetsharma/my-solana-wallet/my-keypair.json node client.js

Running client.
(node:13261) UnhandledPromiseRejectionWarning: Error: Non-base58 character
    at Object.decode (/Users/prikshetsharma/Desktop/anchor/examples/tutorial/node_modules/base-x/src/index.js:111:11)
    at new PublicKey (/Users/prikshetsharma/Desktop/anchor/examples/tutorial/node_modules/@solana/web3.js/lib/index.cjs.js:1808:50)
    at main (/Users/prikshetsharma/Desktop/anchor/examples/tutorial/basic-0/client.js:16:21)
    at Object.<anonymous> (/Users/prikshetsharma/Desktop/anchor/examples/tutorial/basic-0/client.js:27:1)
    at Module._compile (internal/modules/cjs/loader.js:1085:14)
    at Object.Module._extensions..js (internal/modules/cjs/loader.js:1114:10)
    at Module.load (internal/modules/cjs/loader.js:950:32)
    at Function.Module._load (internal/modules/cjs/loader.js:790:12)
    at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:76:12)
    at internal/main/run_main_module.js:17:47
(Use `node --trace-warnings ...` to show where the warning was created)
(node:13261) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). To terminate the node process on unhandled promise rejection, use the CLI flag `--unhandled-rejections=strict` (see https://nodejs.org/api/cli.html#cli_unhandled_rejections_mode). (rejection id: 2)
(node:13261) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.
```

How to fix this?
Because I'm left with 2.9 sol from 5 sol
Is it really true that the basic-0 program costs 2.1 sol to deploy? Isn't that ethereum level cost?
that worked
So yeah the account that is used to run this is at `~/.config/solana/id.json`
Maybe try changing that to match your solana config wallet
```
[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[programs.localnet]
basic_0 = "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"

[scripts]
test = "yarn run mocha -t 1000000 tests/"
```
Lol yes a much better question.
What does your Anchor.toml wallet say?
`/Users/prikshetsharma/my-solana-wallet/my-keypair.json` looks like this is the local account that is set for you. 
Idk where anchor picks up the local config from. But I have mine setup at `~/.config/solana/id.json`
<@!519222880840450059> I did follow the steps in the anchor docs, but still getting this error
```
Config File: /Users/prikshetsharma/.config/solana/cli/config.yml
RPC URL: http://localhost:8899
WebSocket URL: ws://localhost:8900/ (computed)
Keypair Path: /Users/prikshetsharma/my-solana-wallet/my-keypair.json
Commitment: confirmed
```
Your local config seems off. Can you go through the steps given in the docs. That should fix this.
but 
```
% solana address
FP589iXyfXdJMZ7bvd8nueonu95RAgHc4syP7hZ3yzpF
```
```
% solana address -k id.json
3bKCACPSRLHMxBpKnuaTwAm77Wi4fUzAHKyxCCozv3AD
```
that explains your error I guess, Did you follow the steps given in the docs?
That gives:
```
% solana address -k id.json
Error: No default signer found, run "solana-keygen new -o id.json" to create a new one
```
`solana address -k id.json` returns the address for the key in `id.json`
But `anchor deploy` is giving error
`solana balance` is returning the correct amount after `solana airdrop x`
id.json is a bunch of numbers. It's not a string <@!519222880840450059>
Can check if `id.json` resolves to the account that is mentioned in the error message. i.e `5psUuqF3YeCGcAD6zQm5KgE5ZQ17VWkhqVN8fYiAmENP` that way you will know if airdrop works or not
Guys I have some problems with installation
Not sure how to do that off the top of my head, think you'll have to search discord
```
Config File: /Users/prikshetsharma/.config/solana/cli/config.yml
RPC URL: https://api.devnet.solana.com
WebSocket URL: wss://api.devnet.solana.com/ (computed)
Keypair Path: /Users/prikshetsharma/new-keypair.json
Commitment: confirmed
```
You'll have to set you solana cli to point to the right wallet etc.
What does `solana config get` say?
I did but still getting the same error. I don't think it's dropping in the correct address
Try `solana airdrop 5`
<@!134416332509675520> yes
Where are you deploying? To your local network?
how do I add more funds? <@!134416332509675520>
Have you tried adding more funds? "has insufficient funds for spend"
```
% anchor deploy
Deploying workspace: http://localhost:8899
Upgrade authority: /Users/prikshetsharma/.config/solana/id.json
Deploying program "basic-0"...
Program path: /Users/prikshetsharma/Desktop/anchor/examples/tutorial/basic-0/target/deploy/basic_0.so...
=====================================================================
Recover the intermediate account's ephemeral keypair file with
`solana-keygen recover` and the following 12-word seed phrase:
=====================================================================
rigid can bargain swarm donor student few moral hill dose hero define
=====================================================================
To resume a deploy, pass the recovered keypair as
the [PROGRAM_ADDRESS_SIGNER] argument to `solana deploy` or
as the [BUFFER_SIGNER] to `solana program deploy` or `solana write-buffer'.
Or to recover the account's lamports, pass it as the
[BUFFER_ACCOUNT_ADDRESS] argument to `solana program close`.
=====================================================================
Error: Account 5psUuqF3YeCGcAD6zQm5KgE5ZQ17VWkhqVN8fYiAmENP has insufficient funds for spend (1.05283224 SOL) + fee (0.00077 SOL)
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }.
```
How to fix this?
when running anchor deploy, I'm getting the following error:
I think you would use it in your crate's Cargo.toml file, where you add your dependency on anchor_lang
oh thanks! I was using to_string().as_bytes() which looks obviously stupid now 😅
How do I use the `anchor-debug` feature? Where do I need to include this?
You can do `123u64.to_be_bytes()` (or .to_le_bytes(), will need to decide on an endianness to use)
yeah, it seems good option. thank you
Got to use PDA's for that instead.
In rust, Is there any mapping variable like mapping() in solidity?
How to use a u64 as one of the seeds in the PDA? It doesn't have a to_bytes or as_ref obviously and can't use as is.. Do I need to typecast?
Check the network you are connecting to in your Anchor.toml file. I think you are looking at your local for the 500004 Sol and 2.04 Sol is on devnet
<@!326107472098099201> I believe the next big issue is the account the anchor deploy is referencing to upload is 0... however when I run solana balance it says 500004. Which means tthere are two different accounts on my computer: one anchor is referencing and one solana is refernecing
is there anyway to airdrop funds to a specific accountt if I only know the account address and not the address of the program that owns the account via cli
or more similar errors
Thanks for the help so far. The update occured and when I build the target folder now has a types folderr as a child. 

However, when I anchor deploy I gett this error

```
Recover the intermediate account's ephemeral keypair file with
`solana-keygen recover` and the following 12-word seed phrase:
========================================================================
NA: I copied it to a form
========================================================================
To resume a deploy, pass the recovered keypair as
the [PROGRAM_ADDRESS_SIGNER] argument to `solana deploy` or
as the [BUFFER_SIGNER] to `solana program deploy` or `solana write-buffer'.
Or to recover the account's lamports, pass it as the
[BUFFER_ACCOUNT_ADDRESS] argument to `solana program close`.
========================================================================
Error: Account 34UnFK2Pxpjzhc777fsNn31Y3o3ekYZzNdV6qWmTqtej has insufficient funds for spend (2.04610776 SOL) + fee (0.001475 SOL)
```
So the account says it has insufficientt funds. I  typed in solana balance and got a balance back of 50000 Sol. 

Howeverr, I ran Solana-keygen new to set up another key with funds, I ran this with anchor deploy and I come across similar problems
This command is taking some time: cargo install --git https://github.com/project-serum/anchor --tag v0.18.2 anchor-cli --locked
Thank you updating now
Meaning just rerun that command
Just reinstall from scratch
https://project-serum.github.io/anchor/getting-started/installation.html#install-rust I dont see update command
Lol, sounds like you might have some networking issues to still fix 😛
what do you mean by one problem ? 🙂ohh nvm i get it
Instructions are in the docs
what is the command
Or one problem
There's your problem, go upgrade to 0.18.2 please
anchor-cli 0.16.2
What is your `anchor --version`?
Dont see target/types

This is all I see
there isntt
Yep and there should be an escrow.ts in `target/types` and the import should work
That is what I got ^
Running: /Users/admin/.local/share/solana/install/releases/1.7.14/solana-release/bin/sdk/bpf/dependencies/bpf-tools/llvm/bin/llvm-readelf --dyn-symbols /Users/admin/Desktop/Defi/anchor-escrow/target/deploy/escrow.so

To deploy this program:
  $ solana program deploy /Users/admin/Desktop/Defi/anchor-escrow/target/deploy/escrow.so
BPF SDK: /Users/admin/.local/share/solana/install/releases/1.7.14/solana-release/bin/sdk/bpf
Running: rustup toolchain list -v
Running: cargo +bpf build --target bpfel-unknown-unknown --release
Run `anchor build` and you'll get that file
What do you mean what am I running 🙂
^ I am sorry I am not sure what that tmeans
Yeah, that's unrelated to localhost stuff
That is because the typescript hasn't been output, what are you running?
Because the import {Escrow} path doesntt exist
I think my progrram rpc is not working
How come?
OKay I thought it not being on localhost is causing this problem 

so for my tests I see this import { Escrow } from "../target/types/escrow" red bc the area patth doesnt existt 

.Can you explain what this points to?
So I took this out which means bmy program statement looks like this
  const program = anchor.workspace.AnchorEscrow


insttead of tthis

  const program = anchor.workspace.AnchorEscrow as Program<Escrow>;


Given the path doesnt exist, I thought it was bc whhere my solana testt validator was point tot
I don't think it needs to, 127.0.0.1 and localhost are almost the same thing right? https://stackoverflow.com/questions/7382602/what-is-the-difference-between-127-0-0-1-and-localhost
same thing
How do I get my JSON RPC URL to say  http://localhost:8899
127.0.0.1 is localhost though 🤔
`git checkout tags/v0.18.2`, you might need `git fetch --all --tags` first
I am trying to change it to local host
Yea so this is a local cluster... this isnt localhost
how do you mean? that is local
how do you change the solana-test-validator from  http://127.0.0.1:8899 to local
On https://project-serum.github.io/anchor/tutorials/tutorial-0.html#clone-the-repo it says "Next, checkout the tagged branch of the same version of the anchor cli you have installed."  What format do I follow for this?  It says run `git checkout tags/<version>` but my version from `anchor --version` is `anchor-cli 0.18.2`, and `git checkout tags/0.18.2` doesn't work.
So I took this out which means bmy program statement looks like this
```
  const program = anchor.workspace.AnchorEscrow
```

insttead of tthis

```
  const program = anchor.workspace.AnchorEscrow as Program<Escrow>;
```
so
```
import { Escrow } from "../target/types/escrow";
```
There is code on the top that has this in tthe escrow example. Tthe issue is tthe path doesnt exist.Can you explain what this points to?
Maybe the issue is how I am creating my program
yup
Are you doing confirmTransaction on requestAirdrop like in the escrow test?
My RPC calls are failing with error  Error: failed to send transaction: Transaction simulation failed: Attempt to debit an account but found no record of a prior credit.

```
    await program.rpc.initializeEscrow(
      new BN(initializerAmount),
      new BN(takerAmount),
      {
        accounts: {
          initializer: initializerMainAccount.publicKey,
          initializerDepositTokenAccount: initializerTokenAccountA,
          initializerReceiveTokenAccount: initializerTokenAccountB,
          escrowAccount: escrowAccount.publicKey,
          systemProgram: SystemProgram.programId,
          tokenProgram: TOKEN_PROGRAM_ID,
        },
        signers: [initializerMainAccount, escrowAccount],
      }
    );
```

However, unlike the example, I had airdrop plenty of sol to initializerMainAccount. Despite this, my rpc call fails saying the account cannot be debited.


The actual escrow account example has it as 

```
it("Initialize escrow", async () => {
    await program.rpc.initializeEscrow(
      new BN(initializerAmount),
      new BN(takerAmount),
      {
        accounts: {
          initializer: provider.wallet.publicKey,
          initializerDepositTokenAccount: initializerTokenAccountA,
          initializerReceiveTokenAccount: initializerTokenAccountB,
          escrowAccount: escrowAccount.publicKey,
          systemProgram: SystemProgram.programId,
          tokenProgram: TOKEN_PROGRAM_ID,
        },
        signers: [escrowAccount],
      }
    );

```

Any thoughhts on why I may be getting this errorr?
Will post here as well
I do have a followup question
Alright that makes so much more sense. I appreciate the assistance. Sorry for tagging you
`mintA.createAccount` creates an account on-chain and returns its pubkey
```    initializerTokenAccountA = await mintA.createAccount(
      provider.wallet.publicKey
    );
```
then `mintA.getAccountInfo` just fetches an account's data from the chain:
```    let _initializerTokenAccountA = await mintA.getAccountInfo(
      initializerTokenAccountA
    );
```
we just use `_initializerTokenAccountA` in the test to check that `createAccount` and `mintTo` worked as expected
`_initializerTokenAccountA` is a different variable
Maybe I have this backwards
hmm then I thoughht
```
    let _initializerTokenAccountA = await MintA.getAccountInfo(initializerTokenAccountA);
```

returns the pubkey from the initializerTokenAccountA account
the variable names in the escrow test are confusing
because we have 
```initializerTokenAccountA = await mintA.createAccount(
      provider.wallet.publicKey
    );```
and we can see from the IDE or from looking at the `createAccount` method that `initializerTokenAccountA ` is a public key
how can you tell, initializerTokenAccountA for instance is an accounts object.. I would need to do initializerTokenAccountA.publicKey to reference the pubkey
everything in that `accounts` object is a public key actually
it's ok
sorry
I tthought thatt was how you ask questions...
My bad I was following othhers patterns
but as for your actual question
Removed
not for general help questions no
ohh I thought you do @ tagging my abd
we don't do the @ tagging here, please delete the tag first as it sets a bad example for the children
Instruction request
```
await program.rpc.initializeEscrow(
      vault_account_bump,
      new anchor.BN(initialAmount),
      new anchor.BN(takerAmount),
      {
        accounts: {
          initializer: initializerMainAccount.publicKey,
          vaultAccount: vault_account_pda,
          mint: MintA.publicKey,
          initializerDepositTokenAccount: initializerTokenAccountA,
          initializerReceiveTokenAccount: initializerTokenAccountB,
          escrowAccount: escrowAccount.publicKey,
          systemProgram: anchor.web3.SystemProgram.programId,
          rent: anchor.web3.SYSVAR_RENT_PUBKEY,
          tokenProgram: TOKEN_PROGRAM_ID,
        },
        instructions: [
          await program.account.escrowAccount.createInstruction(escrowAccount),
        ],
        signers: [escrowAccount, initializerMainAccount],
      }
    );

```

How do you know your suppose to provide escrowAccount.publickey rather than the Account of escrowAccount for instance> 


Any tthoughhts
When looking at an IDL, how do you know if you should pass a publickey for an account or an actual account reference. For instance: 

IDL
```
"instructions": [
    {
      "name": "initializeEscrow",
      "accounts": [
        {
          "name": "initializer",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "mint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "vaultAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "initializerDepositTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "initializerReceiveTokenAccount",
          "isMut": false,
          "isSigner": false
        },
        
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rent",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
```
<@!134416332509675520> okay does that mean that solana native functionalities can be used directly in anchor?
Instead of `size_of<Vec<ty>>` I had to use `8` but all in all it seems to work out just fine
What is the difference between doing a fork on the serum-dex vs just a GUI?
Coming back to this tomorrow but is there anything in specific I need to do to compile `v1.9.0`? At the moment I just get
```
➜ solana --version
[1]    40427 killed     solana --version
```
Or are there any gotchas?
Can I use `size_of` instead, maybe? And add 8 bytes for Anchor and `size_of::<T>` in Vector multiplied by the max amount of elements?
Writing its size out manually seems like a bad solution
Good day! What would be the best way to specify `space` constraint for a huge struct with a couple of `enums` and a `Vec`
okay does that mean that solana native functionalities can be used directly in anchor?
There are docs on the Solana website about it
<@!134416332509675520> could you please tell me how an associated token account is created and what the use case looks like
So `--program-id` is being passed the correct file path for the keypair and that exists. Given that there is a difference in the Solana version I'm going to try reinstalling `v1.9.0` and see if that fixes it. I think that the problem is probably coming from the solana CLI given where the error is being thrown
``#[instruction()]``
can anyone point me to where i can find this macro?
`msg!`
In the anchor cli you can just use println! if you want
Stupid question but what's the best way to log in Rust? Trying to use `log::debug!` macro but I think the compiler is upset. I assume I need to import it somewhere?
Yep!
Grand. And that's just from the root directory of the repo?
I do `cargo install --path cli --locked --debug` (--debug since otherwise it builds a release build --> super slow)
I've only built it from source with `cargo install --git https://github.com/project-serum/anchor anchor-cli --locked
` and I've not picked up much rust yet. What do I need to do to build from a local source instead of form a remote Github url
If you're comfy installing anchor from source you could just stick in a print there and poke around
It would be nice to try adding some extra logging to the anchor cli, just to see what value it's trying to pass for `--program-id` https://github.com/project-serum/anchor/blob/master/cli/src/lib.rs#L1893
Ah I wonder if I need to bump Solana then
anchor-cli is 0.18.2 (I build from source fairly frequently), solana-cli is 1.9.0
I've got 
```blockchain/solana/myepicproject via ⬢ v16.3.0 via 🦀 v1.56.1 took 33m 52s
➜ anchor --version
anchor-cli 0.18.2

blockchain/solana/myepicproject via ⬢ v16.3.0 via 🦀 v1.56.1
➜ solana --version
solana-cli 1.8.5 (src:devbuild; feat:52865992)
```
From what I understand it's used to target a different validator. In this case I've got the solana validator running with the `--no-bpf-jit` flag.

What version of anchor and Solana have you got?
I actually don't know what it does though lol, I never use it.
Ok at any rate, using the skip-local-validator flag works fine for me
Oh sorry, did you mean the same as what you have in Anchor.toml etc—my bad
`myepicproject: FCf77eTschrz7hP9uaD21RiCHeCg2qQB7ZcBTUY8oW5L`
What does `anchor keys list` say though?
I get the name and ID as set in the `Anchor.toml` file
<@!134416332509675520> Are you running tests with the `--skip-local-validator` flag?
What happens if you run `anchor keys list`?
Huh, weird, I'm on an M1 and haven't seen that problem yet 🤔
ye, stuck on that m1 problem too
I posted on the Github but I've been having some problems when trying to run `anchor test` on an M1 Mac. Full details in the comment: https://github.com/project-serum/anchor/issues/1000#issuecomment-974870730
I’m having this error when running this command “cargo install --git https://github.com/project-serum/anchor --tag v0.18.2 anchor-cli --locked”

The error message 👇

error: failed to run custom build command for `ring v0.16.20`

Caused by:
  process didn't exit successfully: `C:\Users\HP\AppData\Local\Temp\cargo-installbwIL4P\release\build\ring-2ff300b39f35f0ff\build-script-build` (exit code: 101)
  note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
warning: build failed, waiting for other jobs to finish...
error: failed to compile `anchor-cli v0.18.2 (https://github.com/project-serum/anchor?tag=v0.18.2#1319dc65)`, intermediate artifacts can be found at `C:\Users\HP\AppData\Local\Temp\cargo-installbwIL4P`

Caused by:
 build failed


//////////////////////////////////////////////////////////////////////////////////////////

changing this worked. Thanks
that was the issue
So sounds like you might need to change that solana_fun to stake?
You might even need to rename it in the Cargo.toml file in programs/prog-name
```[programs.localnet]
solana_fun = "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"

[registry]
url = "https://anchor.projectserum.com"

[provider]
cluster = "localnet"
wallet = "/home/jjj/.config/solana/id.json"

[scripts]
test = "npx ts-mocha -p ./tsconfig.json -t 1000000 tests/*.ts"
```
Ah, have you renamed things in Anchor.toml?
I assume
which is the issue
Can post the whole test file. Contract module is actually called stake
... so what are you doing? Gotta give me some more info lol
no
Are you not doing `anchor.workspace.solana_fun` someplace?
```const provider = anchor.Provider.env()
  anchor.setProvider(provider)`` is returning {} for anchor.workspace
```
Where would I make this name replacement?
Try replacing `solana_fun` in your js/ts with `solanaFun` when you load the workspace
That error has been resolved. I am now getting ```Error: Error loading workspace IDL for solana_fun```
Thank you ser.
do `npm i -g ts-mocha` or install it locally and add `npx` prefix to the command
this is because the test is relying on you having `ts-mocha` installed globally and you probably don't
<@!495764464604413972>
The error is so vague I have no clue what to do
I created a anchor project that is able to build and deploy to a solana-test-validator. When I run anchor test I get the following error: Failed to run test: ts-mocha -p ./tsconfig.json -t 1000000 tests/*.ts: No such file or directory (os error 2)
Thank you, once again you helped me loads. 
One day I get it all figured out. 😂
Because you're invoking the system_program with that transfer call.
Yes 🙂
No i don't think I am, should i be?
is there a way to mock the on-chain block to advance time to have integration tests for cases that are time restricted?
Are you passing the system_program as an account from the client?
If the tokens are "owned" by the program (some PDA has authority over them), then you can still transfer from them in the usual way, but you'll need that authority PDA to sign the transaction (that's what `invoke_signed` is for)
but what if user is program not wallet?
ok so I am now getting this error, 
```
'Program Cq1TSA1obVQZzw2YYxvFN6Q5ia5TYxSbwyZQ9JwQCbBL failed: An account required by the instruction is missing' 
```
when the program tries to run. 
```
let ix = anchor_lang::solana_program::system_instruction::transfer(&player.key(), &base_account.key(), sb);
anchor_lang::solana_program::program::invoke(&ix, &[
                player.to_account_info(),
                base_account.to_account_info(),
              ]).unwrap();
```
Any ideas?
Yes you can use the   token::transfer to transfer the tokens ... Authority gonna be the user who is holding the token
how does a program transfer tokens to another program? can you use `token::transfer`?
what is the authority? is it the program sender's signature?
Ok cool it looks like it gets as far as this line. 
``` let transfer_amount = sb.checked_sub(account_lamports).ok_or(0)?; ```
Yeah, stuff like `msg!("Do we get here?")`
Ok so if I add print statements in the rust function will they show in the log?
So, trying to rule out that you're somehow using the wrong wallet and it doesn't have any funds, etc.
I don't see anything that would obviously give a 0x0 error, and it doesn't seem like you're getting to the system program invocation (it would show up in the log)
I'm saying it would be nice to know how far you get in this function, given that it's not clear yet what would give you that 0x0 error
Well the tests are doing a few more things before they get to this point, which all go through but fail at this function
But you consumed a decent amount of compute units, so maybe you are executing your function up to a certain point
I would have guessed that would show up in the logs you posted above
Hmm, not sure, have you tried adding extra logs? Do you get to the `transfer` call?
The user is depositing lamports to the baseAccount controlled by the program. With this function. 
```
pub fn place_bet(ctx: Context<PlaceBet>, pred: String, pool_id:u32, stake_bal:u32) -> ProgramResult {
        let base_account = &mut ctx.accounts.base_account;
        let player = &mut ctx.accounts.player;
        
        let bet = EntryStruct{
            user: player.to_account_info().key.to_string(),
            prediction: pred,
            stake_bal: stake_bal
        };
        let mut i = 0;
        let mut found = false;
        for p in &base_account.pool_list{
            if p.pool_id == pool_id {
                found = true;
                break;
            }
            i += 1;
        };
        if found{
            let sb = stake_bal as u64;
            let account_lamports = **base_account.to_account_info().lamports.borrow();
            let transfer_amount = sb.checked_sub(account_lamports).ok_or(0)?;
            let ix = anchor_lang::solana_program::system_instruction::transfer(&player.key(), &base_account.key(), transfer_amount);
            anchor_lang::solana_program::program::invoke(&ix, &[
                player.to_account_info(),
                base_account.to_account_info(),
              ]).unwrap();
            base_account.pool_list[i].pool_balance += stake_bal as u64;
            base_account.pool_list[i].entries.push(bet);
        }
        Ok(())
    }
```
What is your program doing? Not sure (in general I guess it depends on if you're doing any cross-program invocations etc.)
Looks like something else, the test wallet has Lamports, any other reason for this kind of error?
You can check this by doing `await program.provider.connection.getAccountInfo(theProviderWalletsPubkey)` and checking its lamports
Hey guys, I am getting this error. 
```
Transaction simulation failed: Error processing Instruction 0: custom program error: 0x0 
    Program Cq1TSA1obVQZzw2YYxvFN6Q5ia5TYxSbwyZQ9JwQCbBL invoke [1]
    Program log: Custom program error: 0x0
    Program Cq1TSA1obVQZzw2YYxvFN6Q5ia5TYxSbwyZQ9JwQCbBL consumed 23043 of 200000 compute units
    Program Cq1TSA1obVQZzw2YYxvFN6Q5ia5TYxSbwyZQ9JwQCbBL failed: custom program error: 0x0 
```
Could it potentially be caused by lack of funds in the test wallets created in anchor test ?
OK, thanks
`preflightCommitment` is for when simulating the tx (so you want `commitment` here)
Should I set the commitment or preflightCommitment to the `finalized` for a higher-level of tx confirmations?
Could you explain me about the `commitment` and `preflightCommitment`?
I can’t even take credit for picking up on that! But that’s good to know thanks for sharing!
Is it possible to run custom scripts as defined in the Anchor.toml? I'm trying to run something like https://github.com/project-serum/anchor/blob/master/tests/cfo/Anchor.toml#L21, but anchor build-dex/anchor build -dex both give me "subcommand not recognized"
You can specify confirmation level like this: 

`await provider.send(transaction, [signer], {
    commitment: "finalized",
  });`

Sources:
https://github.com/project-serum/anchor/blob/master/ts/src/provider.ts#L91
and
https://docs.solana.com/developing/clients/jsonrpc-api#configuring-state-commitment
I'm actually not totally sure (I'm a bit fuzzy on when you need to wait for more confirmation)
`await provider!.send(transaction)`
It's not right to wait for a higher level of tx confirmation?
But I'll use `u64` instead, right
Well, I can, it is just that I prefer `from`casts instead of `as`, and those aren't implemented for `usize`
Mm, not sure actually—can you just pick an actual fixed size, like a u64?
```
            "type": {
              "defined": "usize"
            }

```
Good day! Sorry for pestering with more questions, but do I understand correctly that `usize` is not implemented for idl? 
Is is because it is platform dependent?
Hello. Maybe you need to wait for a higher level of tx confirmation?
Yep, those work too—for whatever reason there's a whole separate trait in Rust, FromStr, specifically for string conversions 🤷‍♂️ but you can also do `Pubkey::try_from("asdfasd")`
Hi <@!134416332509675520> 

#1. await staking or unstaking
#2. then fetching the balance online.

#2 should return new balance after a staking/unstaking but sometimes, it returns the old balance on the app
<@!134416332509675520>, could you comment on that and tell me if I'm wrong please ?
or implement the `TryFrom<x>` (x being &str) in your case, so you could do `address = "asd".try_into().unwrap()` or just even `Pubkey::try_from("asd").unwrap()`
It's actually not even your fault, in idiomatic Rust, any "fallible" conversion should be named "try_from_x" to induce it returns a Result, otherwise if it is named "from_x" you _should_ be able to assume it cannot fail
Hey guys in JS test how to airdrop funds to a test account?
I second you and would love to start seeing more and contributing more open source work. In order for anything to claim decentralization, it must be open sourced. Lots of FUD and “moating” going on at the moment during quick cash grab stage of the network
Still learning rust. Makes sense!
The address needs to be an actual Pubkey. Doing `Pubkey::from_str("asdfasd")` doesn't quite return a Pubkey, it returns a Result<Pubkey, some kind of error>. You'd need to do `Pubkey::from_str("....").unwrap()`
Okay, thanks a lot mate!
- programs are upgradeable unless specifically set to non-upgradeable
- not many programs are open source
- similarly not many are actively verified
you've pretty much got all the major key points
<https://project-serum.github.io/anchor/getting-started/verification.html#images>
Sure sure, I'm not part of the "Solana is owned and governed by Anatoly blahblah" type, I'm just wondering about what is possible atm and how to think my programs, nothing else
we can only lead by example
if the public wanted it, it would happen
the issue with lack of open source code is known in solana, but it's a community issue not an issue for the "ceo of solana" to deal with
it's possible to disable upgradability
I mean, just the ability to upgrade is nice, but it introduces issues
in anchor, we push people to use anchor verifiable builds
it's a community decision
again, it's the same thing
Sure, but this is a different project, Solana might decide not to follow this path, which is why I'm asking 😉
until people kept getting rugged on ethereum, program builds were equally opaque and unverified
do you know the history of EVM?
Bruh... Do you think it will reach a stage where we can interact with programs with the same transparency and level of confidence as with the EVM ?
yes, of course
it says it expects `value` not `Pubkey` so i guess you could try to figure out how to convert pubkey to value?
Hi!
Since Solana Programs are upgradable and, at the time, rarely have verified builds, isn't the idea of "trustless" a bit biased ? Like, the owner of the program could make a change and do things with an account it owns on your behalf (e.g. a PDA), right?
Ok. Thanks anyway.
not sure how to solve your other problem, but that's what's causing the `resolver` issue
yeh, that's way out of date
solana-cli 1.7.1 
If the older version is an issue then It appears I'm in deadlock. I installed v1.7.1 to avoid another issue : "avx2 not supported by cpu"
how to print logs in anchor ?
yeh, <https://discord.com/channels/428295358100013066/517163444747894795/905125717807865976> your solana cli tools are out of date
errors from both trries
also it helps if you can post the code itself rather than a screenshot
what solana CLI version are you running?
i think resolver might be one of these weird errors from running an older version of solana
Just a syntax question now. I've tried a few combinations and can't get rust-analyzer to stop complainging

```rs

    #[account(mut, address = Pubkey.from_str("asd"))]
    pub slab_treasury: AccountInfo<'info>,
```

I've tried that and just putting the plain string and both complain. Any thouhgts?
hold on
actually
I see that. But not sure how to edit that .toml file.
Nice! I also built anchor from source but it did not solve the problem for me.
i would also try googling the error
I also don't get the correct `idl` json file. This file is generated during `anchor build` , which runs without throwing an error
the error message would suggest you need resolver
ah, i realised what i was doing wrong here. I forgot to include the mint and token constraint tokens e.g. `mint::` and `token::`
I'm trying to run $anchor test the very first time. Any ideas why I might be seeing this error?
still rusty with anchor, haven't coded in a while
```#[instruction(seed: u64)]``` forgot to remove this
LOL
oh shit
```anchor-lang = "0.18.2"
anchor-spl = "0.18.2"
```
```anchor-cli 0.18.2
```
```        "@project-serum/anchor": "^0.18.2"```
you could try changing things as part of your debugging to figure out what might be the root of the error, your program looks simple enough. That's why it looks like it might be a version error
still same error
it's not clear why `mut` would cause a serialization error
oh, might be the mut
and that it doesn't fit the expected format
this suggest something is wrong with the transaction bytes that are being passed into your program
your error is about not being able to deserialize instructions
no, if your program.provider.wallet is the signer that will be included
I didn't have to do that before, maybe it got updated ?
should I also add it to signers : [] ?
I have the user as signer
0.18.2
I'm using similar version
I see
maybe you have different version of anchor in the client vs. the program
I don't have any code inside the instruction
oh, it could also be a version thing
you could try printing out your transaction bytes, to see if anything weird is happening inside the instructions
```pub struct CreatePool<'info> {
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
    pub clock: Sysvar<'info, Clock>,
}```
```ts
const tx = await program.rpc.createPool({
      accounts: {
        user: program.provider.wallet.publicKey,
        systemProgram : anchor.web3.SystemProgram.programId,
        clock : anchor.web3.SYSVAR_CLOCK_PUBKEY,
      },
    });
    console.log("Your transaction signature", tx);```
any reason why this might happen ?
```The program could not deserialize the given instruction```
maybe there's something wrong with the local version of anchor I'm using
ran into a weird error with trying to init a token account
```rust
no function or associated item named `default` found for struct `TokenAccount` in the current scope
function or associated item not found in `TokenAccount`
```
Hi, I need to ensure that data in account A on a program X is greater than 0, to be able to call function B in my program Y.
So I have done it this way. I have stored program X pubkey in my main program account at initialize (so that it can be updated if needed later)
Now I have set conditions on the account in my function B context as below. I have also defined the full struct of Account A in my Program Y for serializing data.
#[account(seeds = [user_authority.key().as_ref(),main_account.x_program_name.as_ref().trim_ascii_whitespace(),b"x_generate",],
        bump = x_bump,
        owner = main_account.x_program
    )]
    pub a_account: Box<Account<'info, AAccount>>,

However, this fails with the message "The given account is not owned by the executing program". I was not modifying any data here, just reading it. What is the correct way to do it?
PDA with hardcoded seeds: https://github.com/drift-labs/protocol-v1/blob/master/programs/clearing_house/src/context.rs#L23
<@!812755783405797376> what can i use as an alternative to the programstate implemenation for creating a singleton?
I solved this issue today by rebuilding anchor from source.
i'll give that a bash 🕵️
This is exactly what I needed thank you Alan
What do you mean by include it in the rust program?
You can enforce a known address with the `address = ` constraint.
Is there an anchor macro for “make sure the account passed in is equal to some given account”?
Or is there maybe a less donkey brained idea to do this. I’m trying to build a program with a treasury wallet and don’t want that to change, but don’t know if I can just include it in the rust program.
So if you actually want to initialize it within that function, you'd have to declare it as `pub puppet: AccountInfo<'info>` (or even `Signer<'info>` because it will need to sign from the client in this case, given that it seems to be a keypair address)
I think the problem is that `pub puppet: Account<'info, Data>` says this puppet account needs to look like a `Data` *before* you start executing your pull_strings function.
hey there 👋 I've been playing around with the basic-3 tutorial trying to get the `puppet_master` to do the `initialize` call via cpi rather than making a seperate call to the `puppet` to initialize first. I run into this issue: ` Error: 167: The given account is not owned by the executing program`.

My code is here, is there something else I am missing: https://github.com/project-serum/anchor/compare/master...obi-ewan:make-master-do-init?expand=1

Would I have to do some pda-ness here to the `Data` account to allow it to be created by another program?
```#[derive(Accounts)]
#[instruction(bump: u8, bump1:u8)]
pub struct Vault<'info> {
    #[account(signer)]
    pub authority: AccountInfo<'info>,
    #[account(init_if_needed,payer = authority,seeds = [authority.key().as_ref(), mint.key().as_ref(), "vault".as_bytes()],bump = bump,token::mint = mint,token::authority = vault_account_data)]
    pub vault_account: Account<'info, TokenAccount>,
    #[account(  
        init_if_needed,
        payer = authority,
        seeds = [authority.key().as_ref(), mint.key().as_ref(), "vault_metadata".as_bytes()],
        bump = bump1,
        space = 8+ std::mem::size_of::<VaultMetadataAccount>()
    )]
    pub vault_account_data: Account<'info, VaultMetadataAccount>,
    #[account(mut)]
    pub mint: Account<'info, Mint>,
    #[account(mut,  constraint = token.amount == 1, constraint = token.owner == authority.key())]
    pub token: Account<'info, TokenAccount>,
    pub token_program: Program<'info, Token>,
    pub system_program: Program<'info, System>,
    pub rent: Sysvar<'info, Rent>
}```
I think I got the issue .... checking something ...
What does the `#[derive(Accounts)]` struct look like?
```
I think I'm passing it correctly in JS

await program.rpc.addVault(
      new anchor.BN(vaultAccountBump),
      new anchor.BN(vaultMetadataAccountBump),
      {
        accounts: {
          authority: provider.wallet.publicKey,
          vaultAccount: vaultAccount,
          vaultAccountData: vaultAccountData,
          mint: mint,
          token: token,
          tokenProgram: TOKEN_PROGRAM_ID,
          systemProgram: anchor.web3.SystemProgram.programId,
          rent: anchor.web3.SYSVAR_RENT_PUBKEY,
        },
      }
    );```
In the JS script.
In rust or test JS script ?
You're (I think) passing a Foo account someplace where you declared a `Account<'info, Bar>`
can't seem to understand meaning of this ? How to make sure its setted correctly
Anchor checks the first 8 bytes of account data (for accounts owned by your program, that is—not for random other accounts like token accounts etc.) and makes sure they make sense.
That means you're passing some wrong kinds of accounts somewhere. Do you understand what the error means, in terms of the discriminator stuff?
Thanks Alan !!! that worked but getting a fixed error -   Error: Invalid account discriminator for each method call but the instructions are executing fine
Its owned by another PDA ... will try to sign from that PDA seeds
I don't know who owns your PDAs tokens in this case, but they will need to sign somehow.
That's the point of signing there—the "owner" of the tokens needs to sign whenever they want to transfer them
Yes.
so the signer seeds will be whoever has the authority over that token ?
The token account itself doesn't need to sign when it transfers, its authority/owner does.
So just gotta think through why those seeds + bump aren't correct (they need to match the *authority* over the token account, not the token account itself necessarily)
This is PDA account means seeds are not right ?
So however you're signing isn't quite right, but I can't tell from here
Ah, sorry, ignore that, the error message tells you the problem: 3qGuE8k7F8Ueo4GwSPrRqry11BmpRMYzxws9hvx1v9nV's didn't sign correctly
Ok, and are all of the accounts that need to be mutable actually mutable?
yes
 ```&[&[
                    ctx.accounts.user.key().as_ref(),
                    ctx.accounts.vault_account_data.user_mint_account.key().as_ref(),
                    "token".as_bytes(), 
                    &[ctx.accounts.vault_account_data.bump]
                 ]]```
Are you signing with the PDAs seeds + bump?
Getting this error while transferring token from PDA to user token account 
```Cross-program invocation with unauthorized signer or writable account

Logs :  ["3qGuE8k7F8Ueo4GwSPrRqry11BmpRMYzxws9hvx1v9nV's signer privilege escalated",
    'Program FfNTAJ4wWv6idUUDWcswEXGFr4N2tw8ZHHjfsxAtdJ5 consumed 200000 of 200000 compute units',
    'Program FfNTAJ4wWv6idUUDWcswEXGFr4N2tw8ZHHjfsxAtdJ5 failed: Cross-program invocation with unauthorized signer or writable account']

trying to transfer token from vault to user account ```
thanks
`.fetch`
How to read data sitting inside PDA in JS ?
I also dont get the correct `idl` json file, I dont see a `metadata.address` field. Im assuming its because of the error 🤔 ?
If I want to store data on PDA and same time use that PDA to get the transferred token from user do I have to add that PDA account two times in my initialize struct or create two seperate PDAs one which store data and other which store token and link both by having authority of 2nd over 1st (2nd option makes sense to me ... just wanna confirm things) ?  One with TokenAccount and another with my data struct ?
```let cpi_accounts = Transfer {
            from: ctx.accounts.tokenAccountA.to_account_info(),
            to: ctx.accounts.vault_account.to_account_info(),
            authority: ctx.accounts.authority.to_account_info(),
        };

        let cpi_program = ctx.accounts.token_program.to_account_info();
        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
        token::transfer(cpi_ctx, 1)?;
        Ok(())```

Trying to transfer SPL token (NFT) from a token account of user to a vault account getting error - Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA failed: invalid account data for instruction

here tokenAccountA -> token account of token owned by user
         authority -  User (signer) who holds the authority over token
         vault_account - PDA of program which is trying to hold the token

```#[account(
        init_if_needed,
        payer = authority,
        space = 300,
        seeds = [authority.key().as_ref(),"token".as_bytes()],
        bump = bump
    )]
    pub vault_account: Box<Account<'info, VaultAccount>>```
Unless there is another setting some where I'm missing
```[provider]
cluster = "devnet"```
Ah, the cluster? Forgot that but it still doesn't work
```anchor deploy
Deploying workspace: https://api.devnet.solana.com
Upgrade authority: /root/.config/solana/id.json
Deploying program "theopetraapp"...
Program path: /workspace/backend/target/deploy/theopetraapp.so...
error: Invalid value for '--program-id <PROGRAM_ID>': unrecognized signer source
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }.```
`Deploying workspace: http://localhost:8899` makes it look like its not
Is it set to devnet in Anchor.toml?
Local works
devnet
Are you trying a devnet deploy or local validator?
It was, it’s just the fix didn’t help
Nope looks like cargo wasn't lying about the version
```anchor deploy
Deploying workspace: http://localhost:8899
Upgrade authority: /root/.config/solana/id.json
Deploying program "theopetraapp"...
Program path: /workspace/backend/target/deploy/theopetraapp.so...
error: Invalid value for '--program-id <PROGRAM_ID>': unrecognized signer source
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }.```
```Replaced package `anchor-cli v0.18.2 (https://github.com/project-serum/anchor#92c6d4c3)` with `anchor-cli v0.18.2 (https://github.com/project-serum/anchor#92c6d4c3)` (executable `anchor`)```
That is a very misleading message if this fixes it. Sure reads like that commit is installed
Ok I'll try forcring it
It prints the hash which is a bit confusing
Yes, it reads the latest master and looks at the commit and the version an decides it has nothing to do because the version matches
That hash matches the last commit
`Ignored package anchor-cli v0.18.2 (https://github.com/project-serum/anchor#92c6d4c3) is already installed`
the version hasn't been bumped in the repo so it won't actually install anything without the `--force`
add a `--force` to the cargo install command
```anchor deploy
Deploying workspace: http://localhost:8899
Upgrade authority: /root/.config/solana/id.json
Deploying program "theopetraapp"...
Program path: /workspace/backend/target/deploy/theopetraapp.so...
error: Invalid value for '--program-id <PROGRAM_ID>': unrecognized signer source
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }.```
```Config File: /root/.config/solana/cli/config.yml
RPC URL: https://api.devnet.solana.com 
WebSocket URL: wss://api.devnet.solana.com/ (computed)
Keypair Path: /root/.config/solana/id.json 
Commitment: confirmed
```
```cargo install --git https://github.com/project-serum/anchor anchor-cli --locked
    Updating git repository `https://github.com/project-serum/anchor`
     Ignored package `anchor-cli v0.18.2 (https://github.com/project-serum/anchor#92c6d4c3)` is already installed```
No the version commit matches
Maybe that wasn't master, trying again
oh bummer... did you comment there about it not working?  <@!501570363566587905>  seems to believe that the PR fixes it, hence why he closed it
<@!725800026760020099>
```cargo install --git https://github.com/project-serum/anchor anchor-cli --locked```
Yes, and it didn't fix it.
Hopefully this will fix it: https://github.com/project-serum/anchor/pull/1046

Anyone know how to try anchor on master???
I was able to deploy using `anchor deploy --program-name <program_id>` as <@!269047172509597697> mentioned above, but I have been unable to get `anchor test` to run without generating the 'unrecognized signer source' error
I'm also experiencing this issue. How can I make sure that solana-test-validator and cluster are devnet?
Both anchor deploy and test give that signer source error.
I've been able to deploy it directly with ```solana program deploy```
Been having the same issue while doing the buildspace project  for solana. Everything worked fine with the placeholder ID.
my cluster is "devnet", i got my id by using  `solana address -k target/deploy/myepicproject-keypair.json` and then copied this into `Anchor.toml` and `lib.rs`
Are you certain that the programId provided is valid and you didnt copy an incorrect one. Are you certain that your solana-test-validator is pointing to devnet? Are you also positive cluster is devnet too?
I am getting a `error: Invalid value for '--program-id <PROGRAM_ID>': unrecognized signer source` when I am using `anchor deploy` or `anchor test`. 

This has come after trying to deploy to devnet and trying to upgrade my program ID in the `Anchor.toml` and `lib.rs`. I can get it to deploy with the solana cli commands, but was wondering if anyone has run into this?
solana changes airdrop params all the time, so im not sure. You usually need to create a wallet and seed it money but if it already has money then great
I'm working through https://dev.to/dabit3/the-complete-guide-to-full-stack-solana-development-with-react-anchor-rust-and-phantom-3291 and there's a part where it tells you to airdrop tokens, `solana airdrop 100`.  But my account already had 500 million SOL.  Any idea why?  On localnet
no, https://buildspace.so/
is buildspace an IDE you are using?
`anchor-cli 0.18.2`
I guess so, installed everything yesterday
Lol
a real coder
<:pepekek:827565146221707308>
are you using latest cli and js lib?
Not sure (tbh I don't really look at the docs ever, I just read the source)
yes, both in lib and toml
did you update the `declare_id` macro
no idea whats the issue
no, test also stopped working. getting the same error
thank you! i see there is some documentation nested in source https://github.com/project-serum/anchor/blob/master/lang/derive/accounts/src/lib.rs#L43 do you know if theres anything like this for the `derive` macro?
Did you find a solution to this? I am running into the same issue when I am running `anchor test`
Not sure about documentation (kind of doubt it, but maybe). I would just give it a shot and see!
if I change Loader to Account, are there additional `derive` traits i need to implement? 
is there any documentation on these two?
Loader is ordinarily for big (huge) accounts. You'd generally use `Account<'info, State>` for normal uses
if i try using the `zero` annotation i get an error around the payer
is `Loader` only used if i have previously allocated account? misunderstanding on my part of how `Loader` works
So ordinarily if you're initializing a Loader account you'd use the `zero` annotation and then fill in the discriminator bytes when you do `.load_init()` in your ix handler
Loader usually expects you to allocate storage for the account in a separate instruction
And just to double check, why are you doing the `Loader` part?
```#[account(
        init_if_needed, 
        seeds = [b"fstate1".as_ref()], 
        bump = bump, 
        payer = admin_account
    )]
    pub state_account: Loader<'info, State>,```
i think the problem was i had a validator running manually so on each run of `anchor test` the ledger was not being cleared
Can you post the full `#[account(...)]` annotation?
and if i reset to `init` only i get an error around the account address `already in use`
No, but it is close
hey im using `init_if_needed` on an account but an `The account discriminator was already set on this account` error is being thrown
I guess it is this issue
https://github.com/project-serum/anchor/issues/22
But generally you need to be careful about overflow—usually you'd want to use the `checked` family of functions, the *do* check for overflow
And a huge stack trace
I had a few contracts implementing similar logic, so I split it into a new crate. To my dismay things stop work with
```
IdlError: Type not found: {"name":"veccy","type":{"defined":"Decimal"}}
```
Aren't overflow checks already turned off? 🤔
Henlo! Is it possible to use types, implementing `AnchorSerialize` and `AnchorDeserialize` from different crates?
hello, I am doing the Solana project on buildspace and I am at the point where I need to deploy using `anchor deploy`. WHen I do this it gives me the following error
```
error: Invalid value for '--program-id <PROGRAM_ID>': unrecognized signer source
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.
```
I actually needed to run `anchor deploy --program-name <program_id>` even tho the error says `program-id`
Thanks alan
The PDAness of the address doesn't really change anything about closing the account, you still just need to drain its lamports. And yes, the data will get cleared.
You mean within your rust program? Not possible, you'll need to pass it as an account from the client.
One more noob q -> can we close a PDA account ? will it erase old data right if we close it ?
How to read data of some other PDA which is not in current program ?
ah obviously im missing a declaration of the lifetime param, i.e. `pub struct InitialiseContract<'info> {`
any ideas?
hitting a weird error `error[E0261]: use of undeclared lifetime name 'info`


//////////////////////////////////////////////////////////////////////////////////////////

Mm, not sure, works for me!
still compiler throwing this error :

no function or associated item named `try_from_unchecked` found for struct `anchor_lang::Program<'_, _>` in the current scope function or associated item not found in `anchor_lang::Program<'_, _>`
ohoo...
`associated_token_program: Program<'info, AssociatedToken>`
So the `user_ata: Account<'info, TokenAccount>` (edit: sorry, typo again 🤦‍♂️)
Sorry, you need to name it literally `associated_token_program` (my bad, I typo'd above)
using this but still getting the error 
```
no function or associated item named `try_from_unchecked` found for struct `anchor_lang::Program<'_, _>` in the current scope
function or associated item not found in `anchor_lang::Program<'_, _>```
```#[account(
        init_if_needed,
        associated_token::mint = mint,
        associated_token::authority = authority,
        payer = authority
    )]
    pub user_ata: Program<'info, AssociatedToken>```
That means you need to be passing the associated_token_program as an account, `associated_token_program: Program<'info, AssociatedToken>` (edit: sorry, typo!)
Not able to compile the code  getting error :

Cannot find value `associated_token_program` in this scope  on #[derive(Accounts)]
Currently no easy way to get rid of that log, as far as I know. Just have to live with it (or make a PR!)
assert.rejects to check the errors and it's passing
But transaction simulation failed error log is there
im actually editing the metaplex candymachine programs themselves -- trying to make a custom NFT but that still adheres to the metaplex standard
It will be quite hard to read at first but it's all there.
Yep.
so i could use cargo expand to see what anchor is abstracting over ?
You can also use `cargo expand` to expand the macros that anchor uses, and get a sense for what kind of code it generates (that's what I did)
i wanted to understand solana fundamentals and understand what anchor abstracts over before starting with anchor
I think your best bet is to work through anchor examples / just start experimenting.
You generally do something like `Pubkey::create_program_address(&[ b"one seed".as_ref(), b"some_other_seed".as_ref(), a_pubkey.as_ref(), &[the_bump] ], some_program_id)`
trying to understand solana fundamentals , just read the docs and still have a lot of questions...
on this
hmm is there any good resource i could take a look at to get more indepth knowledge
Or sort of—it gets appended to the list of other seeds.
off chain and this result is what u pass in as seed to create_program_address
Yeah.
oh mb, but the bump gets appended to the seed right ?
For example, about half of all bumps end up being 255. This isn't a valid utf-8 character—it only makes sense as a byte.
Sort of/no.  Have you looked at examples of using `Pubkey::create_program_address`? The seeds aren't just strings (mentioned a few times above), they're in general a bunch of bytes (not the same thing as a string slice!).
?
does this mean we append the bump seed to the seed for example add  a character to a string "escrow" and pass the resulting "escrowa" as seed to the create_program_address
hey <@!248066053161222144>  "To reduce the compute cost, use find_program_address off-chain and pass the resulting bump seed to the program."
You can also turn off transaction simulation. But that will still result in an error
If you don't want to see them you can turn off your monitor
What's wrong with error logs
I don't understand the question
Hi <@!248066053161222144> 
Could you explain me about it?
poor alan lol
Hi <@!134416332509675520>
`anchor test` - it logs the transaction error 
Is there any way to not show the error logs?
so it needs to be wrapped in an extra array
this is just because there could be multiple `seeds` being passed
then your signer that gets passed into CpiContext is 
```
let signer = &[seeds[..]]
```
`bump: u8 = 255`
so your seeds really look like
```
seeds = [b"escrow2".as_ref(), &[bump]]
```
even if it's the default u8 value (which for seeds is 255)
aha
in practice it's always added
technically speaking the bump is just a single u8 that gets added to the end of the seed array
to find a valid program address
when the seed is not enough a bump is required
yes
do you know about the bump?
e.g.
```
        seeds = [PC_VAULT_SEED, event_list.name.as_ref(), market.name.as_ref(), &[bracket.idx]],```
thanks got it
and those are your seeds
`&[ &[u8] ]`
you have an ref array of ref u8 arrays
that's basically it
carry on
aha alright
like pubkey for example
it's better to think in terms of u8s because you can have other things in your seeds that are not string slices
i mean array of u8's...
u8s are bytes
but u8's are string slices
you need to think of seeds in terms of u8s
no
right ?
so it becomes &[&str]
yeh it's `&[ &[u8; 7] ]`
" seeds: &[&[u8]]"
and a signer is an array of seeds (in case there's more than one PDA signing)
lets just call "escrow2" a &str so its verbose
seeds are just an array of referenced u8s
but i can keep helping
😦
😛
hahahahaha
lol, maybe this actually a <#889584618372734977> thing after all sorry
an array of string slice will be &[&[u8]]
yeh
cause a string slice is &[u8]
nvm it would be &&[u8]]
something like that
and then the second `&[   ]` which wraps is just an array of seeds
&["escrow2"] is basically &[u8]
so lets break it down
yeh, i think so
so a string slice is an array of u8's right ?
&[&["escrow2"]]
this was the code
or a reference to them
it's an array of u8s
so `&[b"escrow2".as_ref()]` is the seed
just learned rust so just a beginner
seems weird
yes i just wanted to understand the syntax
this looks like a seed signer to me
`"&[&["escrow2"]]"`
Ahh okay, thanks!
your `testAccount` is already a public key so just do 
```
    const account = await program.account.testAccount.fetch(
      testAccount
    );
```
Hey guys, I had a doubt as I was learning.

I was trying to fetch the data from an account, using this piece of code: 
```
const deposit = await program.rpc.deposit(new anchor.BN(69), {
      accounts: {
        testAccount: testAccount,
      },
    });

    console.log("Deposit tx: ", deposit);

    const account = await program.account.testAccount.fetch(
      testAccount.publicKey
    );
    console.log("Balance: ", account.balance.toString());
```

But it was giving this error, 

```
1) anchorlearn
       Is initialized!:
     TypeError: Cannot read property 'toBase58' of undefined
      at Connection.getAccountInfo (node_modules/@solana/web3.js/lib/index.cjs.js:5459:71)
      at processTicksAndRejections (internal/process/task_queues.js:95:5)
      at async AccountClient.fetchNullable (node_modules/@project-serum/anchor/dist/cjs/program/namespace/account.js:87:29)
      at async AccountClient.fetch (node_modules/@project-serum/anchor/dist/cjs/program/namespace/account.js:104:22)
      at async Context.<anonymous> (tests/anchorlearn.js:36:21)
```

-----------

Whereas, if I used this piece of code, my tests run successfully
```
const deposit = await program.rpc.deposit(new anchor.BN(69), {
      accounts: {
        testAccount: testAccount,
      },
    });

    console.log("Deposit tx: ", deposit);

    const account = await program.account.testAccount.fetch(
      testAccount.toString() // CHANGED, and works with testAccount.toBase58() also
    );
    console.log("Balance: ", account.balance.toString());
```

----------

I've seen tutorials where they used the first piece of code and got it to work. So I was wondering why is it not the case here?
it was implemented by someone random
it's supposed to be
I was going to say, would have been pretty surprising if this bug hadn't surfaced earlier
Oh interesting! So preInstructions isn't just like an alias for `instructions`?
yeh, i tried switching back to `instructions` and everything worked fine
hmm, alternatively maybe `preInstructions` is incorrect
but this seems like a poor workaround
gets rid of the error
well, changing to
```rust
    #[account(mut)]
    pub event_queue: Signer<'info>,
```
but it seems like others had this issue and they solved it somehow
ok, i'll make a github issue
Oh, interesting—that sounds like a bug in anchor I guess? 🤔
have to figure out how though lol
there's probably some way to specify signers for just the preinstructions and not the whole transaction?
i think i know what i could probably do differently
ah
```rust
   #[account(mut)]
    pub event_queue: UncheckedAccount<'info>,
```
```typescript
        await program.rpc.initBracketStepTwo(serumBumps, {
            accounts: {
                eventListAuthority: program.provider.wallet.publicKey,
                eventList,
                market,
                bracket,
                yesMint,
                fUsdcMint,
                serumMarket,
                requestQueue,
                coinVault,
                pcVault,
                vaultSigner,
                eventQueue: eventQueueKeypair.publicKey,
                bids: bidsKeypair.publicKey,
                asks: asksKeypair.publicKey,
                systemProgram: anchor.web3.SystemProgram.programId,
                tokenProgram: TOKEN_PROGRAM_ID,
                dexProgram: DEX_PID,
                rent: anchor.web3.SYSVAR_RENT_PUBKEY,
            },
            preInstructions: [
                anchor.web3.SystemProgram.createAccount({
                    fromPubkey: provider.wallet.publicKey,
                    newAccountPubkey: eventQueueKeypair.publicKey,
                    lamports: await program.provider.connection.getMinimumBalanceForRentExemption(262144 + 12),
                    space: 262144 + 12,
                    programId: DEX_PID,
                }),
            ],
            signers: [
                eventQueueKeypair,
            ],
        });
```
but because we're creating the account in the same transaction with a separate instructions, of course it needs to be a signer
the issue seems to be that the program doesn't expect X account to be a signer
it's almost too much effort to share so much code
do you mind sharing the code or is it private?
i solved it with <@!134416332509675520> that time. don't remember why it happened back then since it was a while ago but i've had it since then as well and the error was always a fault in my own code
Looking at all the past discussion about the error `Error: unknown signer: `
i've started getting this error too. It's quite odd
Hi <@!134416332509675520> 
How can I build a `view function` like the solidity smart contract?
It says: "custom program error: 0xa7'". Couldn't find anything on google
In my case will need all the lamports in the account later, so I can't play much with it
<@!637707515328725002> with your strategy (if it's acceptable) it's inefficient to leave the unnecessary lamports in the account - you could transfer them out and use them to earn rewards (eg. staking or something), keeping enough in a program-owned account to cover any upcoming doubling fees. Basically it gives you an interest free loan, you should use it 😄
and also how to query all the posts
Would still have to see how much running post() costs
That's not bad at all
I think new account per post is good. That would be 128 lamport/year per post right?
Ok. What have you tried so far for debugging?

In solana, whenever you create an account, you always have to sign with that new account's address (no matter what)
You need to also add a `signers: [postAccount]` to that rpc call
still get "Translating error Error: Signature verification failed" with user: program.provider.wallet.publicKey
I see what you mean - they are always paying twice as much as they really need to, so that when doubling happens they have already paid for it. It's clever, and if that's acceptable then great 🙂 - depends what you want to optimise for though. Maybe they would prefer to pay a small amount every now and then, but overall cheaper?
Lol
I would be kind of amazed if that worked, but maybe?
nvmd it doesn't work
Like, you ran a test and it actually passed?
It didn't give an error so I presumed that it worked
That actually works?
<@!134416332509675520> I just did user: anchor.Provider.local()
how do we remember all the posts?
Probably `user: program.provider.wallet.publicKey`
This is my program:
```
#[program]
pub mod mibexy {
    use super::*;

    pub fn post(ctx: Context<Initialize>, data: String) -> ProgramResult {
        let post_account = &mut ctx.accounts.post_account; 
        post_account.post = data;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 128)]
    pub post_account: Account<'info, Post>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program <'info, System>,
}

#[account]
pub struct Post {
    pub post: String
}
```
The doubling strategy in standard libraries is designed to minimise the number of times you will need to reallocate memory, given that you have no idea how the array will be used by the program. In this case, minimising the number of account reallocations is probably not the best choice of what to optimise for
No, this works for all resize. Imagine, initial capacity is for two posts, when that's filled you already have 2 * 2 * sizeofpost lamports, which is sufficient to create 4 capacity account. Once that 4 capacity gets full, you will have 2 * 4 * sizeofpost lamports, which is sufficient to create a 8 capacity account; and so on. You cannot forget to close the older accounts, obviously.
I do have: anchor.setProvider(anchor.Provider.local());
quick question. I'm making this call:
```
await program.rpc.post("Hello World!", {
        accounts: {
            postAccount: postAccount.publicKey,
            user: ???,
            systemProgram: SystemProgram.programId
        }
    });
```
What do I put for user?
My point is that only pays for the first doubling - at the second one they would have to pay twice as much, next time 4x as much, etc. so it would be better to have a fixed size-increase each time you need more data.
That cost I defined is exactly so that they all pay the same when adding a post. Does not matter whether the accounts is going to be resized or not, the cost is fixed. That's why each pay 2*size_of_post() instead of just size_of_post()
That is presumably way more economical, yes. You'll still presumably have to have some way to remember which accounts store your user's posts though
each account is a single post that stores the ipfs
this way we don't need to double
```

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 128)]
    pub posts_account: Account<'info, Post>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program <'info, System>,
}

#[account]
pub struct Post {
    pub post: String
}
```
The doubling strategy is fairly common and sensible for re-sizing arrays in many standard libraries - since you don't know the intended usage. In this case I think doubling isn't a great strategy because eventually they will have to pay a large amount to increase their data size. It should probably increase by a fixed/acceptable amount instead.
Each person should pay cost(128 + 8 + 4 + 2 * size_of_each_post()). With this you will have enough lamports to double the account size when necessary. (128 for account metadata, 8 for anchor discriminator, 4 for vec length). With this, you will actually have more than enough to handle accounts. If you can pay the 128 + 8 + 4 yourself, then the cost could be just cost(2 * size_of_each_post())
Would that still be cost prohibitive?
which stores the ipfs?
what if I do it so that each post is one tiny account of 128 bytes?
Yep.
How do I set it up so that the signer is the one that pays for the account? Like this?:
```
#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 9000)]
    pub posts_account: Account<'info, Posts>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program <'info, System>,
}

#[account]
pub struct Posts {
    pub posts: Vec<String>
}
```
Poor people need to deal with nightmares
I can confirm this. But possible
Thanks
I see 🙂
Because e.g. when you do something with your phantom wallet, the simulation runs before you approve the tx—yet you don't pay anything, obviously, if you cancel doing the tx.
No, as far as I know (like 99% sure) no simulations ever take a transaction fee
Its simulate takes the transaction fee?
the instruction doesn't update the data, just read and emit the event
What about it?
Don't think so, no.
program.simulate doesn't take the transaction fee, right?
Yeah lol, this will be a nightmare 😛
Yeah you could have them pay something to initially create the account with a smallish amount of data, then every now and then, as they post more things, they would have to pay some more to increase the allocated size (copying the data into a new bigger account as <@!637707515328725002> mentioned)... then eventually chaining multiple accounts together once it goes over the 10MB limit. All sounds theoretically possible, but hugely impractical to me.
You could have the poster be the one that pays for the account's rent, yeah
Not exactly like that - their account is owned by the system program, so you can't store data there. You can only modify accounts owned by you (your program). Have you read the programming model: <https://docs.solana.com/developing/programming-model/overview> ? In particular relation to this is the Accounts section and the Runtime section, which explains what programs can and cannot do.
So whoever posts to the network is the one responsible for paying the rent?
hi guys, would it be possible if the signer could be the account that stored the posts?
<@!134416332509675520> 
`program.simulate` - this also takes the transaction fee like the `program.rpc`?
Also more incentive for people with large accounts they're not using to close them?
Right, but more people, more demand, more accounts, more competition for validator memory... doesn't that mean it's fine/correct for the rent-prices to "go up" this way?
I think part of the reason why rent is currently so expensive is that the rent rate is denominated in sol and was originally set back when sol was ~2 dollars 😛 (That doesn't say why they haven't changed it yet, but rent is 100x more expensive now than it was originally)
I'm still learning most of this stuff myself, so probably missing big gaps of knowledge.
It may come down in the future, I'm not sure - my guess is that it would require some very clever strategies to be developed for paging account data into memory only when needed, and I don't know if there's a plan for this, or a better/different strategy.
If you learn how validators work, this will make a lot more sense.
so basically on ethereum storage and compute are bunched together and have astronomical cost, but in solana storage is astronomical and compute is very low cost
I would say it is equivalent to serialization/deserialization steps
OK, thanks for your explanation
If you don't specify what the bump should be, anchor will recompute it for you (but this costs compute, so might not always be a good idea)
Could you let me know how it is working?
Hi <@!134416332509675520> 

```
#[account(
        mut,
        seeds = [ token_mint.key().as_ref() ],
        bump,
    )]
```
It is working with no instruction for the bump
Does copying all that data around use lots of compute budget?
amazing thanks
<@!337555205681971203> solana config get
Hi guys what's the CLI command to know where our local wallet keys .json file is ?
I am designing something where accounts are "resizable". Basically when I need more space, I create an account with double size, copy the contents from the older, and remove the lamports from the other all in the same transaction (actually I even remove the lamports of the older before to help pay the new). This is kind of shit to do and then  "this account does not have a fixed address", which is complicated for the clients. But I don't know, I am just a noob
No I wasn't alive then
wow, how old are you?
The reddit founder is giving $100 million to solana startups and I'm sure he wants to see social startups too
There's gotta be a way to do this more feasibly
That's like $1400/mb. Reminds me of the 1950s
Maybe <@!637707515328725002> sees it differently - not sure?
What we are talking about is how you could do it in theory - in practice I don't think it's practical.
wow that's a lot
Step 1. Pay LOTS of money. Each 10MB chunk will cost you about 70 SOL and you'll have to allocate the entire 10MB up front I think
```
#[account]
pub struct Posts {
    pub posts: Vec<String>
}
```
Hrm - yeah, I guess indexing would be tricky without knowing what you want to index on, such as dates, or just volume of posts...
I thought you had to manually specify each account in the program?
how do you implement this?
Not necessary if using PDAs, I think
I don't think (edit: there is one but it is very high). The limit would be 2^128, if no other program had accounts
Not directly - but you'd need another account to store the list of accounts, so there's that limit.
is there a limit on how many accounts a program can have?
you would need multiple accounts. No sure what would be the best way to design that but your program can have many many accounts
Not on the platform directly - the data limit is 10MB and you'd have to fund the account to store that amount. However it would be possible to write a program that stores that data and creates new accounts to keep adding to it as the current one gets full. You'd have to fund it in 10MB-worth-of-rent increments though, I think.
So there's no way to create a social network contract where people can post indefinitely? <@!637707515328725002>
10 mb is the current maximum solana allows
Let's say I want to create an account that holds a vector of strings. Is it possible to have that vector grow to an unlimited size in an account?
is it possible to create an account with unlimited storage?
Hey guys what's the CLI command to know where our local wallet keys .json file is ?
cool, thought so. I'm still kind of figuring out how my governance program will work, and including signed instruction to init large accounts is just extra work i'd prefer to avoid. But so be it
Yeah, 10kb is the limit whenever you do a CPI (so even just any `init` in anchor, regardless of whether it's a PDA). But you can use zero + AccountLoader etc. to go the full 10mb if you use a separate instruction for it!
(e.g. i know PDAs are limited to 10kb, but i assume the same is probably true for zero'd out regular accounts too)
or is 10kb just the limit they have for all non-instruction based `createAccount` cpi calls
Random question, if you pass in a `zero`'d account, with the keypair signature, can you initialize with more data than 10kb?
there is a pyth example in `anchor/tests`
Thanks !!!
As far as I know
The authority will have to be the `associated_token::authority` you specify (they won't necessarily need to sign though!)
ok so we can create associated token address from program and use this. Authority gonna be signer right ?
Anchor has the `associated_token::mint` and `associated_token::authority` attributes you can use with `init_if_needed` if you want
The convention is that if you don't already know where to send the user's tokens to, then yeah, you would send them to their appropriate associated token account.
When debugging Solidity, Remix support call function of smartcontract. In Anchor, how to call fn of program except from web client?
Do I need to make a ATA for a user if I want to transfer SPL token from  vault (holds by program) to user account ? If yes how do people approach it ... Do they create it in program or from JS we create and pass in instruction set ?
So you're trying to update the candymachine account within your own program? Don't think that will work—in solana, the only way to mutate an account's data is by asking the program that owns that account to do it for you (in this case, the candymachine program).

But I'm getting the following error:
```
ANCHOR_WALLET=/Users/prikshetsharma/Desktop/mibexy/target/deploy/mibexy-keypair.json node client.js
```
and I'm running like so:
And here's my client.js:
```
const anchor = require('@project-serum/anchor');

// Configure the local cluster.
anchor.setProvider(anchor.Provider.local());

async function main() {
  // #region main

  // Read the generated IDL.
  const idl = JSON.parse(require('fs').readFileSync('./target/idl/mibexy.json', 'utf8'));
  
  // Address of the deployed program.
  const programId = new anchor.web3.PublicKey('DHKddS4uotUwyEybCDrkyYunb8ZevsKedG2V7Ae5dXYG');
  
  // Generate the program client from IDL.
  const program = new anchor.Program(idl, programId);
  
  // Execute the RPC.
  await program.rpc.initialize();
  // #endregion main
}

console.log('Running client.');
main().then(() => console.log('Success'));
```
```
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod mibexy {
    use super::*;
    pub fn initialize(ctx: Context<Initialize>) -> ProgramResult {
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize {}
```
here's my lib.rs:
Hi I'm getting an error on anchor
BAN HIM
got this at build time as warning as well.
the following functions are undefined and not known syscalls ["ceil", "floor"].
hi seems like ceil and floor float functions are not available on solana runtime? Am I correct in this? How to achieve a similar effect?
'Program failed to complete: ELF error: Unresolved symbol (ceil) at instruction #18506 (ELF file offset 0x24168)',
ok weird, it seems that any new data i add won't update..
yo im trying to keep track of a list of addresses who have minted a metaplex NFT in candy machine, im using the line ```        candy_machine.minters.push(*ctx.accounts.wallet.key);
```
where minters is the vector (in CandyMachine), though the vector is not updating, where am I going wrong?
Is there any good anchor tutorial to build an SPL token (code wise, without using the cli) ?
I see, thank you!
Even if nothign existed there
So no matter what address you pass in you'll still get an AccountInfo
Ah, ok, the interesting thing is that if you pass a fresh keypair address you'll still get an AccountInfo for it, it'll just be empty/have no money + be owned by the SystemProgram
Oh, this is bad, I tried using `Option` but I was getting some confusing errors, so I hoped I could at least do it this way
By valid I mean pointing to an-actually-existing account
Pubkey::default() is actually the system_program's address, so that might be confusing 😛
And I think all addresses are valid—what kind of checks are you seeing?
Anchor doesn't do anything at all for AccountInfos (that's just the raw low-level solana account type).
I want to pass `Pubkey::default()` when an account doesn't need to be specified
It looks like it does, then is there a way to disable those checks?
Does Anchor verify that `AccountInfo` accounts point to valid addresses?
Yeah, not sure, it definitely works for me!
yeah, I tried the mentioned stuff
Not sure—have you saved the file? 😛 Not sure what else would explain it
Not sure why yours is behaving different from my local version
Mm, dumb q, if you jump to source on the `Pool` in that `Account<'info, Pool>` type, does it go to the right place?
pool = &mut ctx.accounts.pool
````anchor_lang::Account<'_, Pool>` doesn't implement `Debug`
the trait `Debug` is not implemented for `anchor_lang::Account<'_, Pool>`
required because of the requirements on the impl of `Debug` for `&mut anchor_lang::Account<'_, Pool>`
required by `std::fmt::Debug::fmt````
Huh, my first suggestion seems to work fine for me 🤔
```field `account` of struct `anchor_lang::Account` is private
```
You derived Debug on Pool, not the wrapping `Account` stuff.
Ah, try doing `msg!("{:?}", pool.account)`
````anchor_lang::Account<'_, Pool>` doesn't implement `Debug`
```
```        msg!("{:?}", pool);```
```#[account]
#[derive(Debug)]
pub struct Pool {
    pub authority: Pubkey,
}```
still doesn't work
`msg!("{:?}", the_struct)`, if you derive Debug
how to print account struct ? added derive(Debug) but still giving me an error ?
okay, it seems it works again. but it's kinda worrying if the same happened in production 😕
or maybe i'm just unlucky and share an IP on Vercel with some bad guy 😕 has anyone got any experience with that?
I think there is `AccountSerialize` for it, I saw it used when trying to find about `AnchorSerialize`
Thank you!
Oh, yes, I found it. It _just_ renames Borsh traits.
```
pub use borsh::{BorshDeserialize as AnchorDeserialize, BorshSerialize as AnchorSerialize};
```
Nope, I was right 😛 I think for `#[account]` style structs anchor just derives the borsh stuff, no fancyness (the discriminator stuff is handled elsewhere)
Nope, I'm wrong, sorry
I think, hmm 🤔
Ah, ok, I think generally anchor doesn't do anything fancy with borsh, it just does `derive` under the hood
i've been experimenting on devnet a little bit, and after a while i got the following error
> `"error":{"code": 403, "message":"Your IP or provider is banned."}`
i wonder what i could do to earn it and if it's permanent or i can redeem myself 🙄
Yes, I know, but I wonder how Anchor uses Borsh and maybe I need to be wary of some internal logic as well
I don't think there's any fancy way to do it, you just need to go implement those traits:
```.rs
impl AnchorSerialize for YourThing {
  ...
}
```
Ah, so not just with `#[derive(AnchorSerialize)]` etc.
To verify that a certain field can't be zero, etc.
Yes, I want to add a bit of a custom logic inside
For one of your own custom structs?
I tried grepping it but so far with no results
Good day! Where can I find code for implementing `AnchorDeserialize` and `AnchorSerialize` traits using proc macros?
you can also add this line below the imports before running just `node client.js`
```
process.env.ANCHOR_WALLET="~/.config/solana/id.json";
```
gotcha. thanks
Can just type that in your shell
`ANCHOR_WALLET=~/.config/solana/id.json node client.js`
Ah, you can run that exact line of code in the snippet 🙂
<@!134416332509675520> i meant how do i run the client with setting the environmental variable. where is that line of code
Ah, interesting. Hmm, my mac doesn't like the quotes for some reason 😦
Usually in `~/.config/solana/id.json` by default
where is "anchor_wallet" located?
It was for arguments with spaces
<@!448034961652449283> do you know what those extra quotes were for? Saw a PR for it recently I think
I had to edit the anchor cli source and rebuild locally 😬
I don't understand much of this yet... I know what i tried didn't work so far 😂
If I get rid of the extra quotes I can deploy fine, so not totally sure what they're for.
Ok, well, for me this is related to how we pass extra quotes around arguments to `solana program deploy`.
I've tried a few things like a clean install of anchor and then even a 
```
anchor deploy --program-name <KEYPAIR JSONADDRESS HERE>
```
This gives me a deploy successful but can't find on the solana chain
Looks like there was a PR to fix this but I'm on the latest anchor + solana and still getting it 🤔 So doing some solana source-diving.
I've actually just started getting that error too lol, I'm investigating 😛
```
error: Invalid value for '--program-id <PROGRAM_ID>': unrecognized signer source
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }.
```
Can anyone help me with the error message that I am getting?
i got this error afterwards `node: --dns-result-order= is not allowed in NODE_OPTIONS` but fixed it by using node v16.13.0
This worked for me too! Thanks!
`cargo install --git https://github.com/project-serum/anchor --tag v0.18.0 anchor-cli --locked`
<@!744592612073406525>  <@!344663059614138388>  use anchor v 0.18.0. it works for me now


//////////////////////////////////////////////////////////////////////////////////////////

Are you using `anchor deploy`? This might be a bug with the latest anchor (I run into this too)
HI all, I am trying to anchor deploy my program to begin ttesting. Tthis is the error I am getting

```
Error: Dynamic program error: No default signer found, run "solana-keygen new -o /root/.config/solana/id.json" to create a new one
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }.

```
nvm that was a stupid question. Jet lagged af <a:aPES_CryLaptop:746135860415824093>
awesome thanks
but given the new anchor keywords it's probably better to use `Signer<'info>` anyway
Sorry, yeah
Oh!
he already has `signer` in the account constraints
~~Could you repeat that? Not sure what you mean 🤔~~
Does'nt the signer attribute on account does'nt make sure the account signs it ?
Almost, you would also need that address to sign (so change `AccountInfo` to `Signer`).
```#[account(mut, signer, address =Pubkey::from_str("....").unwrap())]
    pub authority: AccountInfo<'info>```

Can I use this way to restrict certain method call by specific pubkey ? like some functions which can be called by admin.
It worked, thank you man!
What do you mean? I thought you were referring to the one you declared with `declare_id!`
And that can be any pubkey correct?
The `declare_id!` macro declares a static variable, `ID`, that you can use, as well as a top-level function, `id()`
How would one reference a declare_id? Or use it to pre-load authority?
Thanks
For example: 
```
abc_account: ProgramAccount<'info, ABCAccount>
```

abc_account should be closed when abc_account.amount == 0
You could just copy some of that code
Well, here's how anchor does it: https://github.com/project-serum/anchor/blob/master/lang/src/common.rs
But the account should be closed if it meets a condition
I know it
yes
the main program
Are these accounts owned by your program? (If so, why don't you want to use the `close` attribute? Don't have to, but might be easier)
Whether the account lives at a PDA is actually not relevant—the question is which program *owns* the account (this is not the same thing as saying from which program the address was derived)
PDA
ah I see. Thanks!
What kind of account are you trying to close? It depends on which program owns the account. But the idea is that you need to drain the account of lamports.
Hi <@!134416332509675520> 
Could you share a piece of code to close the program account, not using the `close` on context?
but what you're probably missing in your calculation is the 8 byte discriminator that anchor adds to the start of all program accounts
anchor will just calculate it automatically for you
honestly, unless you're using variables with unspecified space (strings or vecs) i wouldn't bother with specifying the `space`
or is the `space` related to the amount of data sent in the RPC call (e.g related to the size of the instructions sent) ?
Hello frens, question. I have 2 errors:

`Error: 163: Failed to deserialize the account`
`Error: 167: The given account is not owned by the executing program`

Both go away by increasing the space on the Account  I'm operating on (from 64 + 64 to 128 + 128): 

```
#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 64 + 64)]
    pub ticketing_system: Account<'info, TicketingSystem>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```

The question is, how do I calculate the total amount space I should be allocating? 

I initially assumed it was just adding up the space accupied by adding all the individual fields to be allocated (e.g  fields in the Ticket (64 + 32 + 8 + 32) * amount of tickets (3) which is 408  ) 


In the example above, the TicketingSystem account looks like this:

```
#[account]
pub struct TicketingSystem {
    pub tickets: [Ticket; 3],
}

#[derive(AnchorSerialize, AnchorDeserialize, Default, Clone, Copy)]
pub struct Ticket {
    pub owner: Pubkey,
    pub id: u32,
    pub available: bool,
    pub idx: u32,
}
```
This shows an example of a token account that the program has authority over: https://github.com/cqfd/quidproquo
<@!134416332509675520> are there any good example for that, just want to make the token account owned by PDA? Because lots of the examples in the anchor repo for that, look really complicated with a lot of different accounts. Sorry maybe for stupidy, but coming from web2 and I am really used to typescript with great dev experience.
v0.18.0 works I will wait for fix on v0.18.3
Actually, sorry, let me think about your q some more (rushing, sorry)
Ah, no, you would store the token account at the PDA, rather than using an associated token account
<@!134416332509675520> thank you for your answer!!!!

but when I try to get make the tokenAccount from an PDA (the saving of the PDA acount already works on chain), I get an error

how can I create a tokenAccount from a PDA? I need to add the bump at the Instructions somehow right?

`Error: Owner cannot sign: 8vN4E6hqD2timmqHrXSGQoyeqTJaR97kuYHcVoH8croE`

`let [userStakeAccount, bump] = await web3.PublicKey.findProgramAddress(
      [provider.wallet.publicKey.toBuffer()],
      program.programId,
    )

    const stakeTokenAccount = await token.getOrCreateAssociatedAccountInfo(userStakeAccount)`
Yea I started with the --locked but that still errors too.
Ah, I've actually seen that too—how are you upgrading? Are you passing the `--locked` cargo arg?
https://discord.com/channels/889577356681945098/889889146087301151/903082738846949406
Can you say more? Not sure what that means—what goes wrong?
Anyone having issues upgrading to 0.18.2? Having some issues with clap. Tried some of the previous mentions of the issue but stuck.
I admit that I'm surprised your `Decimal: ` version didn't error, that seems like a bug
If you don't pass that argument at all I'd expect you to get a JS error
Aren't you passing a veccy above?
But it wouldn't explain why an rpc is called when no `veccy` is provided.
Or at least I don't think it does
Anchor doesn't default any of the args—it just deserializes them from the raw bytes that came in as ix data
What do you mean by passing default() here?
What you wrote above won't work because you won't be able to sign for your own `programId` (but your program *can* sign for one of the PDAs derived from your program)
Still, can I somehow make the code above fail? Instead of passing `Default::default()` into a handler instead?
The way you have to do this is to make the authority/"owner" of the token account be some program-derived address derived from your program.
Found a solution
```
      {
        mantissa: new anchor.BN(2)
      }, 
```
Say I have a type 
```
pub struct Decimal {
    pub mantissa: u128,
}
```
Which is passed into instructions like so
```
    pub fn initialize(ctx: Context<Initialize>, veccy: Decimal) -> ProgramResult {
```
But then when I pass it inside in this way
```
    const tx = await program.rpc.initialize(
      {
          Decimal: {
            mantissa: new anchor.BN(2)
          }
      }, 
      {
--snip--
```
I get `veccy` to be zero initialized, which is not what I want
Good day! How can I pass custom types in `.ts` code into instructions?
hi want to create a token account which is owned by my program? Is this even possible? I am able to transfer token to this account, but when I want to transfer it back I get the following error. I need to sign it with the pda seeds right?


`const stakeTokenAccount = await token.getOrCreateAssociatedAccountInfo(program.programId)`

`Program log: Instruction: Transfer
Program log: Error: owner does not match`
What's the format on memcmp?
Something like this?
`let myBlogAccount = await provider.connection.getProgramAccounts(
             program.programId,
             memcmp: {
                      offset: 1,                        
                      bytes: <MYPUBKEY>
            }
);` ?

What does the offset value does?
❤️
Thanks ! that's what i was looking for, will try it now
and fill the memcmp filter with that public key
you could use - https://docs.solana.com/developing/clients/jsonrpc-api#getprogramaccounts
I need to send the account as a value from the client, but how do I get the right Blog account's address?

I want to edit the right Blog account, which has my Pubkey saved as a value in it... But i guess the way is not to pull all the program's Blog accounts and cycle through them until I find the one that has my PubKey as a value ( and that I can edit )
you want to show the connected user blog's on frontend ?
Hey guys ! Let's say I have a program to create blog posts into a Blog account, and I store along the blog text the pubKey of the blog's creator so only him can edit the blog content.

**how do I find my account as a user when doing a call on the program's rpc? I know my pubKey and the program's Id, but not the program's Blog account which has my PubKey as a value in it..**
whats with the leading 0?
when i go to deserialize it on the frontend i get this ``0100000000000000`` via ``new BN(initializerAmount).toJSON()``
i have a value of 1 SOL cast as a u64
i run this project on local it oke
hi all,
how can i run project below on solana dev net 
https://github.com/project-serum/anchor.git?
Hello, is there a way in anchor I can throw an error if an argument is not of a certain set of values? I have a function that accepts a vote weight, and I only want `-2,-1,0,1,2` as valid options.

``` pub fn vote_general_sentiment(ctx: Context<Vote>, vote_weight: u64) -> ProgramResult {```
how can i deserialize a custom program
Do all the `#[derive(Accounts)]` structs have to be in the root module? I tried moving them into submodules and it wouldn't compile
That "Party1New Party2New", but that should be right as I'm not passing anything into the initialize function now, I was passing in names beforehand, but I rebuilt the program and redeployed it as well without using any names as parameters to the instruction
I get some really weird data back
So yeah, not obvious to me yet what would cause your issue, so best bet is probably to just see what data is in the account
Default should be fine for that specific type
is derive(Default) a good general practice or just used in specific cases?
yeah I think it has something to do with the bool type being initialized, not sure what it initializes to when I attach the derive(Default) macro, might not work well for bools
That might shed some light, Ill give it a go
Interesting, well, you can always `await program.provider.connection.getAccountInfo(thatAccountsPubkey)` and take a look at its `.data`. Maybe one of those bools is somehow not 0/1?
Ah, sorry, failed to *de*serialize the account
Ah, ok, so probably not space then.
Currently just testing the initialization of this
I pretty much always specify space myself
Are there any variable-sized types in there? Maybe something else is going on
I see, so adding space to the account macro for the instruction would most likely solve this? Still wrapping my head around when to specify space and when not to, is it a good practice to always do this even when the struct just has primitive types inside?
Very often it's because you haven't allocated enough space (anchor tried to write the account back out to storage and failed)
Currently working on a test, and I'm receiving this error: Error: 163: Failed to deserialize the account. I can post relevant code snippets as well, but are there any frequently used troubleshooting techniques for this error?
^ How are you passing the treasury_authority's address from the client?
yeah
How are you determining the treasury_authority's address on the client?
What's stake here? Is that the instruction handler above?
Are you sure the seeds are the same then?
do i need to include a signer when i call stake?
i verified bump is exact same in test and smart contract. i logged both as well to double check.
That would mean you're somehow not using the right bump, I think
Are you sure you're using the right bump there?
Should be equivalent (basically)
I am getting: "Provided seeds do not result in a valid address". Any help would be appreciated.
Implementing a "freeze program" to freeze the program from new staking / unstaking.
Does it mater which implementation we choose between the following ones:
 `staking_account.freeze_program == false` at the beginning of these functions vs 
```
#[account(
        mut,
        seeds = [...],
        bump = ...,
        constraint = !staking_account.freeze_program,
    )]
    pub staking_account: ProgramAccount<'info, StakingAccount>
```
ahhhh that worked ❤️ ty
the declare_id stuff should be added to the docs lol
What you're doing there looks fine, so I'm guessing the issue is a declare_id! issue.
Nope, 0xa7 = 167 = AccountNotProgramOwned. Is it possible you've got the wrong pubkey in your `declare_id!` in your program file?
there is a lot of random little snippets of code and things that can fuck stuff up. I didn't realize it until I went deep on the examples and tried to rebuild one from scratch like that
under examples
like the anchor project folder should have this fully done for you already
and compare your code and the supporting files to that example
I would say the best way to figure it out is download the anchor examples directly
I've done the exact same thing over the last few days
any ideas?
👋 hey i'm trying to get basic-2 to work basically just copy-pasted that code, deployed to local chain

however when running
```
const myAccount = anchor.web3.Keypair.generate();
  await program.rpc.create({
    accounts: {
      counter: myAccount.publicKey,
      user: provider.wallet.publicKey,
      systemProgram: anchor.web3.SystemProgram.programId,
    },
    signers: [myAccount],
  });
``` 
keeps giving me back error code 0xa7
`The given account is not owned by the executing program`
which i looked in the anchor github is error `AccountNotMutable`

but as far as I can tell, I'm signing with the account to create and the payer is the owner of the program


//////////////////////////////////////////////////////////////////////////////////////////

Basically I feel like it must be some weirdness with solana's rpc stuff on your M1, since your anchor stuff looks fine. I would try reinstalling solana from scratch maybe (hopefully with a fresher version)
Ok, when I run the tests locally I don't get any errors, so I wonder if something is weird with your install of solana? Not sure what could cause the error you're getting 🤔
thanks a lot  🥺
K taking a look 👀
target/idl/myepicproject.json
```
{
  "version": "0.0.0",
  "name": "myepicproject",
  "instructions": [
    {
      "name": "startStuffOff",
      "accounts": [
        {
          "name": "baseAccount",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "user",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": []
    },
    {
      "name": "addGif",
      "accounts": [
        {
          "name": "baseAccount",
          "isMut": true,
          "isSigner": false
        }
      ],
      "args": []
    }
  ],
  "accounts": [
    {
      "name": "BaseAccount",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "totalGifs",
            "type": "u64"
          }
        ]
      }
    }
  ],
  "metadata": {
    "address": "7YsY7NnkANmSDLLF1ae4f8zTRxWaLpARa3jGiGFapHPr"
  }
}
```
here 🙏
https://github.com/MatthewTang/myepicproject
sure
Can you also post what your `target/idl/<progname>.json` looks like?
hmm , i currently don't , let me create a git repo real quick
Do you have your code in a repo somewhere? I'm not sure why you'd get that just by eyeballing but would be pretty easy to debug with a reproducible example
like without just running anchor test
and how can I test  a project entirely
hi, sorry to bother you, I ran into a very similar issue that you mentioned here, how did you solve it in the end ? 
my issue is listed here -> https://github.com/project-serum/anchor/issues/1062
thanks a lot ! 🙏
Hey how can I test with NFT tokens and not just airdropping dev sol
I'm testing a NFT staking program and I need to test using NFTs not SOL tokens
You always have to pass accounts in from the client too, so not possible to do it in a sneaky way on-chain
No, because seeds are ultimately public—don't store anything secret in them!
that way users can't see how their addresses are derived
and do the lookup on chain
can you use the program's private key as a seed
depends what seeds are used, but yeah
yep
and in general you can find the PDA for any wallet public key + program?
correct, anything on chain is totally public
or store private information
but in general, we can't rely on PDAs as a way to hide information, right?
but again i'm just spit-balling
ya
it wouldn't be storing an unencrypted message in a PDA whose address is seeded with a hidden key, right?
to be clear, the encryption would be for the message stored on chain, which is then decrypted on the client side, right?
there might be a better way to do this with more elegant encryption, im not sure
haven't looked at jabber
yeah what i'm suggesting would be to create a new keypair, but then the user would have to save that somehow (idk what that would look like) and associate it with their solana account, but then they couldn't read the messages if they signed in from a different device unless they also typed in the additional keypair info
so is it possible to build a webapp like this without exposing your private key to the page
just a thought
Ah, it's a mobile app!
i think you'd be better off adding something like gpg into the client and telling the user to save their private key, and associate it with their solana address, rather than requiring them to sign each message with their solana private key
Does jabber work with phantom, or only with like sollet?
The thing I'm not sure about is that if you e.g. try to send a message to my phantom wallet's public key (possible if I tell you my wallet's public key), I don't actually have a great way using phantom's API to subsequently decrypt with my private key (I can snag my private key manually of course, but phantom doesn't expose a `decryptWithPrivateKey` method etc.)
this is interesting. i don't think any of the tutorials i've viewed for similar projects have addressed this
Asymmetric key encryption lets you encrypt a message using the recipient's public key, in such a way that they can only decrypt it with their private key.
how do you encrypt it in a way that the sender and receiver can both read them
Nothing—I haven't looked at how jabber works but I assume you'd have to encrypt the messages before storing them.
what stops someone from fetching the account for someone else's inbox if they can derive the PDA address
how would we go about building a private messaging app like this with anchor? https://github.com/Bonfida/jabber
ah I see. Thank you!
I am getting 
`Program log: Custom program error: 0x65`
     Error: 101: Fallback functions are not supported
on line 77. any suggestions?
If that's not there, one could inject a different type pretending to be that account.
It's more about security.
Question:

Would it be correct to say that the 8 bytes discriminator that's added by the `#[account]` attribute is both a sanity and security check because it ensures the correct account is being accessed. Without this, you might be using the wrong account and not notice until the behaviour you get is unexpected ? Is it more about sanity than security ? I'm I thinking about this correctly ?

I'm trying to make sure I really understand.
i have question
how can i extend the storage of the contract ?
and after the transactions, i wish have 0 sols
hi dev
if i want to send all my sols from one account to another, how much should i send such that the gas fee will be taken accounted for?
It worked with this salad.

```
let info = my_account.to_account_info();
let mut data = info.try_borrow_mut_data()?;
let dst: &mut [u8] = &mut data;
let mut cursor = std::io::Cursor::new(dst);

my_account_struct.try_serialize(&mut cursor)?
```

Thanks 🙏
I have: "Error: Error loading workspace IDL for project-name".  Have found some comments about this but still couldn't managed to solve it.
thanks for your help
I'll try the cursor, bang my head against the wall, have a beer and get back to you
I've used the low-level writer stuff before
That would work too (the low-level stuff above should work too though)
perhaps I need to create a cursor
looking at the anchor source, it does this in exit()
```let mut data = info.try_borrow_mut_data()?;
            let dst: &mut [u8] = &mut data;
            let mut cursor = std::io::Cursor::new(dst);
self.account.try_serialize(&mut cursor)?;
```
Yeah, not sure how a similar line on my compute typechecks fine.
That's the thing I'm confused about, you've already got a `*` in that snippet above.
do I need to deref the Rc<RefCell> then?
I just broke the line to make sure it was saving correctly
I'll look further - just checking there wasnt some other function to use
What's the other error?
Yes definitely - If I change it the error changes
This is the impl of std::io::Write you want to ultimately end up using: https://doc.rust-lang.org/std/io/trait.Write.html#impl-Write-6
Just to double check... are you sure you've like saved your file? That specific error doesn't make sense to me given the code you pasted above.
super simple 🙂
This is my struct definition:

```#[account]
#[derive(Default)]
pub struct MyAccount {
  pub amount: u8,
}```
Yeah, think so.
so try_serialize is what I "should" be using for structs defined with #[account]?
for me too - but it's webstorm so I never trust the IDE type checker
Or at least it typechecks
Huh, typing that equivalent line seems to work fine for me, and no, you shouldn't need to implement your own writer
Hey - I think am 90% there with this - just having trouble getting this line to compile:

```
my_account_struct.try_serialize(&mut *ctx.accounts.my_account.data.borrow_mut())?
```

the trait `std::io::Write` is not implemented for `Rc<RefCell<&mut [u8]>>`

In the past I have done this either with borsh or "standard" anchor.

Do I have to create my own writer here?
Hey there, I have 2 programs, where one defines this enum;
```
#[derive(AnchorSerialize, AnchorDeserialize, Debug, Clone)]
pub enum MyEnum {
    VALUE,
    ANOTHER_VALUE,
}
```
And the other program uses that enum as an argument;
```
pub fn do_thing(
    ctx: Context<MyInstruction>,
    my_enum: MyEnum,
)
``` 
but I run into his when trying to test/generate the idl;
```
 IdlError: Type not found: {"name”:”myEnum”,”type":{"defined":"MyEnum"}} ``` 
is there anything extra I need to do? I see a few open issues like https://github.com/project-serum/anchor/issues/22. I have a workaround for this, just wasn't sure if it was supported or not atm
The most common example of this is what I'm doing in that repo, a token account (they're always owned by the spl token program) that lives at a program-derived address derived from my own program. Associated token accounts are another example: they're token accounts (owned by the spl token program), but they live at an address derived from the associated token program.
ok I thought that also, but I read there is a difference between which program owns the PDA account and from which Programm the address is derived and what is the sense then for owning a pda account derived from another account?
Yeah, you'll have to use a raw `AccountInfo` here (even if the boolean thing above worked you'd have to do the same thing, since sometimes you wouldn't initialize the account and it wouldn't have a MyAccount in it)
would anchor not complain if my_account is an empty account? I should just use AccountInfo instead of ProgramAccount then I guess
Think so, yeah.
OK . so in that case, I would just remove the  init, payer and space from the macro and initialise the account in my handler in the "old fashioned way"?
Not currently, no. You'll have to do the conditional-ing manually in your instruction handler
Hi all, is it possible to make initialisation of an account conditional on some boolean? 

I am looking for something like this

```#[account(
    init = someBoolean,
    payer = payer,
    space = 8 + 1
  )]
  my_account: ProgramAccount<'info, MyAccount>,```

Use case: I want to have an option in my program to create an account during an instruction, if some boolean property of another account is set. If it is not set, I want to save the rent cost of creating the account.
And only the deriving program can sign for a PDA (no other program/person can).
Yep, it's safe. Knowing the seeds isn't enough (their security doesn't come from secrecy), someone would need to convince the program to actually sign for them (so, don't write a dumb program 😛)
thanks
Much thanks, it works.
an not any user who know the seed can do sth with this account?
is this trick safe that the pda account has the authority of itself, so that only the program can do actions with the account?
And then in your JS it will look like
```.js
await program.rpc.initialize(123, {
  accounts: {
    ...
  }
});
```
You'll need to change your ix function to have the bump too: `pub fn initialize(ctx: Context<Initialize>, mint_bump: u8) -> ...`
```
#[program]
pub mod test_anchor {
    use super::*;
    pub fn initialize(ctx: Context<Initialize>) -> ProgramResult {
       msg!("mint: {:?}", ctx.accounts.mint.to_account_info());
        Ok(())
    }
}

#[derive(Accounts)]
#[instruction(mint_bump: u8)]
pub struct Initialize<'info> {
    #[account(
        init,
        seeds = [b"my-mint-seed".as_ref()],
        bump = mint_bump,
        payer = authority,
        mint::decimals = 6,
        mint::authority = authority,
    )]
    pub mint: Account<'info, Mint>,
    pub authority: Signer<'info>,
    pub system_program: AccountInfo<'info>,
    pub rent: Sysvar<'info, Rent>,
    pub token_program: AccountInfo<'info>,
}
```
hi, this is my instruction, on the client side how to construct the request instruction(how to input the bump i don't know)?
#[instruction(mint_bump: u8)]
https://docs.rs/solana-client/1.8.5/solana_client/rpc_client/struct.RpcClient.html#method.get_recent_blockhash
```
.and_then(|slice| slice.try_into().ok())
```
https://doc.rust-lang.org/std/result/enum.Result.html
https://doc.rust-lang.org/std/option/enum.Option.html
`and_then` applied to Option which should return Option, `try_into` return `Result` and `ok` convert it to `Option`
Morning people ☕ <a:vibe:827622201925697606>  is it possible to get the most recent block hash on chain on the rust side?
slices the data structure into an array afaik
Hi, not necessarily an Anchor query, but I was going through this [tutorial](https://paulx.dev/blog/2021/01/14/programming-on-solana-an-introduction/#further-reading) by Paul and came across this piece of code,
```
let amount = input
            .get(..8)
            .and_then(|slice| slice.try_into().ok())
            .map(u64::from_le_bytes)
            .ok_or(InvalidInstruction)?;
```

Being a beginner in Rust, I was confused about what `|slice| slice.try_into().ok()` was doing. 

Any help?
https://github.com/project-serum/anchor
hi we are trying to raise liquidity for our token. is this the right repo?
we just have to put ui and run it?
Sure!
That totally fixed it. THANK YOU <@!134416332509675520>! 🙂
Which would totally explain why it's looking for constructors, etc too.
Yup, you do.
🤦‍♂️
I didn't think you could invoke it like a function, only as a constructor
Do you not need to do `new BN(...)`?
All the other examples I've looked at seem to assume that the JS is running in node, but I'm trying to pass in a JS number as an arg to an unstruction that expects a u64 number.

It's a weird one. I've stepped through the BN.js source and I'm not sure what to make of it. Here's a screenshot that should give some context....
What error do you get?
Ok, one more problem I could use help with... When running my JS in node I can call `anchor.BN(0)` and that works like in the examples in Anchor. For example, this is how u64 numbers seem to be passed in as arguments to an instruction.

If I try the same in Chrome then the same `BN(0)` call fails and I can't assemble the arugments to my instruction. What is the right way to pass in u64 integers to an instruction from the browser?
ok ok, ty, lets type some more code then haha
Not totally sure I understand the issue, but I'll focus on the bits I do for now. Thanks again <@!134416332509675520>! 🙂
Currently yes, as far as I know 😬
So generating a new keypar seemed to make everything happy! 🙂
if i have a variable number of accounts does it mean i must use remaining_accounts to access them and do all the is Signer etc verification by hand ?
Thanks for the help <@!134416332509675520>, I'm sorry I couldn't give you more to work with.
Ok, I'm going to try that then kick this around a bit more. Will come back once I'm better able to express the issue.
You would need to re-initialize it, but yeah
If I regenerate my keypair that the JS client is using, that should get me a fresh account correct? I'm thinking I should try that and see where I'm at with a fresh account.
That seems like a different error, 0xa7 = 167 = AccountNotProgramOwned

Hmm... I just started seeing an error about space. Could this be that?
So given that you're re-using that account over and over again, my guess is that you allocated enough space for the original struct, not the new version
If you didn't allocate enough space to handle that new field you added, you won't be able to serialize the new structure
Do you have enough space for that account on the JS side?
But when I copied the IDL over to my JS app things just started to blow up and I'm now seeing messages about serialization.
I tried to add a `vote_count` to that struct and was able to do that and get my tests passing in Anchor.
So really the problem is this. I've got a struct that I was storing a bunch of links to gifs and addresses of the users who posted them in.
I lost track
What qs did you have about the rust side?
I'm going to bang at it a little longer.
Probably all of them 😛
ha ha
Depends on what other questions you have 😛
I've got my Anchor program in one project and a seperate JS one for the front end that I'm just cutting and pasting the IDL into for now.
(Do you want me to paste the `lib.rs` here? It's about 112 lines.)
Yeah, you'll be referring to a totally different account then
Ok, on the actual JS client I've generated a keypair once and saved it in JSON so I use it everytime. I assume changing that will also generate a new account.
Yes, you specify the address of the account you want to use on the client, and solana makes it show up in your program as an account
yes
This looks like its generating a fresh baseAccount on every test run (you're making a fresh keypair)
It's my understanding that the account used by the program is tied to the public key I pass in as the `baseAccount`?
I truncated out a bit of the code.
So without pasting too much text in here.. this is what I'm using to test in anchor...

```

const main = async () => {
  console.log("🚀 Starting test...");

  const provider = anchor.Provider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.Myepicproject;
  const baseAccount = anchor.web3.Keypair.generate();
  let tx = await program.rpc.startStuffOff({
    accounts: {
      baseAccount: baseAccount.publicKey,
      user: provider.wallet.publicKey,
      systemProgram: SystemProgram.programId,
    },
    signers: [baseAccount],
  });
  console.log("📝 Your transaction signature", tx);

  let account = await program.account.baseAccount.fetch(baseAccount.publicKey);
  console.log("👀 GIF Count", account.totalGifs.toString());

  // You'll need to now pass a GIF link to the function! You'll also need to pass in the user submitting the GIF!
  await program.rpc.addGif("insert_a_giphy_link_here", {
    accounts: {
      baseAccount: baseAccount.publicKey,
      user: provider.wallet.publicKey,
    },
  });

  await displayGifs(account, program, baseAccount);

  // You'll need to now pass a GIF link to the function! You'll also need to pass in the user submitting the GIF!
  await program.rpc.upvoteGif(new anchor.BN(0), {
    accounts: {
      baseAccount: baseAccount.publicKey,
      user: provider.wallet.publicKey,
    },
  });

  await displayGifs(account, program, baseAccount);

  // Clear all the GIFs!
  await program.rpc.clearGifs({
    accounts: {
      baseAccount: baseAccount.publicKey,
      user: provider.wallet.publicKey,
    },
  });

  await displayGifs(account, program, baseAccount);
};
```
What do you mean by tied to your base account? What's the base account here?
Sorry for all the dumb questions, I'm at that point where it's all so new I'm not really sure how to Google it yet. 😛
Is the account my program is accessing tied to my base account?
Like somehow corrupted the account?
It's running on devnet for that, so I'm thinking I've done something wrong there.
Ah, ok, for that I guess you may need a real validator.
I think the only way you could see invalid data like that is from a previous write you made, yeah. Fresh accounts are all zero-initialized.
It's when I copy the IDL json to a JS project when things seem to go sideways.
I've been running tests with `anchor test` and that seems to work as expected.
I'll try that right now.
You can also nuke your actual validator state with `solana-test-validator -r`
I almost exclusively test things by letting anchor spin up its own solana validator, so I start with a clean state every time.
(I can share some actual code if that would make this clearer...)
So basically in this case, it seems to be breaking because I'm getting back bad data and not neccesarily panicing (at least not until I try to add to the vector, then it does)
So the issue I've got is that I'm seeing invalid data when I deserialize the account. For the app I'm building I'm recording the number of votes for a GIF. When I added the vote field to the data structure there was a seemingly random large number for the number of votes even though I'd never initialized it. I'm assuming this is because it's deserializing from memory that's beyond the end of the original object, but I'm new to all this so that's just a guess.
Quick question... I've made some changes to my structs and things are no longer serializing / deserializing properly. This is just test data so I'd like to start a fresh account for the program.

Is changing the program id the best way to do that, or is there a proper way to flush a program's account?
is it possible to do warp_to_slot in pure anchor ts tests?
yea I am using the recent Anchor... I figured out the issue herer... you need to change /root/ to ~./.config/solana...etc


//////////////////////////////////////////////////////////////////////////////////////////

ah nvm, I guess when I run something like this
``` 
[bondPoolAccount, bumpBondPoolAccount] = await PublicKey.findProgramAddress(
            [payer.publicKey.toBuffer(), Buffer.from(anchor.utils.bytes.utf8.encode("bondPoolAccount"))],
            program.programId
        );
``` 
then the PDA is owned by `program.programId`, right? so no need to do `Keypair.generate()` (which feels like bad practice anyways)
you can probably create an iterator, and include it as part of the seed, and then maybe store the max-count of the iterator somewhere
I was wondering if you can create a Mint that is owned purely by the program. I have often seen the approach that one would generate a keypair `owner = Keypair.generate()`, but the fact that it has a private key seems flawed. Maybe I'm wrong though. That's why I was thinking of PDAs, but not sure how it works if you generate the PDA also in the frontend. Would the PDA need to be generated by the program (i.e. in Rust, instead of Typescript for example)?
ah I see
`Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account `
but getting this error

no complain in build time
so i changed to this
```
#[derive(Accounts)]
#[instruction(proposal_account_bump: u8, proposal_id: u64)]
pub struct AddProposal<'info> {
    #[account(mut)]
    pub base_account: Account<'info, BaseAccount>, 
    #[account(init, seeds = [b"proposal_account".as_ref(), proposal_id.to_be_bytes().as_ref()], bump = proposal_account_bump, payer = user, space = 10240)]
    pub proposal_account: Account<'info, ProposalAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program <'info, System>,
}
```
No quotes (not a literal string)
Not quite, you're still hard-coding the "proposal_id" part, you would need to do `proposal_id.to_bytes()` or something like that
Can anyone point me in the right debug direction?
```
Program failed to complete: exceeded maximum number of instructions allowed (1718) at instruction #9794
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA failed: Program failed to complete
    Program QMMD16kjauP5knBwxNUJRZ1Z5o3deBuFrqVjBVmmqto consumed 14938 of 14938 compute units
    Program QMMD16kjauP5knBwxNUJRZ1Z5o3deBuFrqVjBVmmqto failed: Program failed to complete
Transaction simulation failed: Error processing Instruction 0: custom program error: 0xa7 
```
Hi, i'm a newbie here. Can somebody give me some context on how/when to use TokenAccount constraints like the following
#[account(mut, token::mint = ...
or
#[account(mut, associated_token::mint =
something like this then

E.g. pass the name of the proposal as an instruction argument
Which part? You'll have to have some way to use the correct seeds there (or just not use PDAs for the proposal, not sure)
then, https://github.com/Necmttn/anchor-voting/blob/becdbe69106718d2a8021a68d2170f0d397bae19/anchor-voting/programs/anchor-voting/src/lib.rs#L101
can you help explain me this bit please
You'll have to come up with different seeds or use a fresh keypair address, etc.
Reusing the same seeds will always give you the same address back.
Did you give the second proposal a different address? [Edit after looking: nope 😛]
how can i create more PDA account 😅 
sorry if i'm spamming.
https://github.com/Necmttn/anchor-voting/blob/becdbe69106718d2a8021a68d2170f0d397bae19/anchor-voting/tests/anchor-voting.ts#L58-L62 when i try to create second proposal, i get
```
 'Allocate: account Address { address: 4x76D7BnE9ifqxnfDJ2Jxnd5AinfKEjiMnD4nwziTvY1, base: None } already in use',`
``` 
error as expected.
testing this right now.
Likewise, each vote would go at a PDA with seeds something like [proposal, voter_pubkey]. That lets you record the fact that someone has already voted for the given proposal.
You would need to store each proposal you want to vote on in a separate account most likely.
What do you mean by a decentralized token?
If the owner/authority of a mint is a PDA, that means the only way to mint new tokens is to convince that PDA's deriving program to sign a cross-program invocation to the token program asking it to mint more tokens.
is it comon that a PDA owns a Mint? 
if yes, what prevents some random guy to just mint more tokens? 
if not, how can a "decentralized" token be created?
How can  I make new proposal caller to create a new account and pay for a rent ?

Hello, been checking the examples out there but haven't figure out how to; 
Currently i'm building a tutorial for how to build simple voting app via anchor framework.
following example is working 👇🏻
https://github.com/Necmttn/anchor-voting/blob/master/anchor-voting/programs/anchor-voting/src/lib.rs 

but after certain amount of proposals & votes the rented space from `baseAccount` will run out and program will not update anymore. 

so how can i make this scalable ?
<https://github.com/solana-labs/solana-program-library/blob/master/associated-token-account/program/src/tools/account.rs#L13> there's like manual calling of transfer, allocate and assign here. I just have to start thinking in these terms if I want to create a non-system program account creation function for any other program. Although it really doesn't seem worth the hassle
will do ty for the headsup
they pay their tech support staff!
if no one answers you here the solana tech discord is also good for answers
kind of like the associated token program
you know, just thinking about it, it's actually not really that much of a hack. You're  replicating exactly what the system program does. Just making your own version of that function for creating accounts using your program's own "createAccount" function
so i was looking at  one of the spl examples, can any one explain the rust project architechture for example it had 3 files
entrypoint.rs, instruction.rs , processor.rs
what does each file represent
and what does this macro do and why is "#![cfg(not(feature = "no-entrypoint"))]
" it was present in the entrypoint.rs file
when i change the PDAs owner to the system program i can use it to pay for new accounts and use the PDA to sign transactions
well, at least your solution works
gah
You can send them to whoever you want, no ownership issues—only the source presents an ownership issue
Right, exactly
so yeh, only the program that owns an account has the ability to reduce lamports but solana doesn't care where they go
Because only the token program has the right to drain a token account's lamport balance
That's why in general you need to ask the program owner to close its accounts for you, e.g. the token program has a whole extra instruction to close accounts
because surely when accounts are closed lamports are transferred out
no i'm still annoyed at it
i think i fundamentally get it now
ok
i'm going to keep source diving
i'm not giving up just yet
that is funny
wow
Yeah
Yep, that's the thing I was worried about I think—are you using the system program but the pda account is owned by your program?
or maybe this is the error you were warning me about
```
    Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: instruction spent from the balance of an account it does not own
```
never seen this one before, more debugging is needed
Lol
now for the big reveal if it totally breaks
thanks!
yeh, that works fine
But not 100% sure
I think it's often just a dumb type inference issue, so annoying :/
i will try that
ah
What if you do `let seeds: &[&[&[u8]]] = ....`
do they need to be joined together somehow?
Heh, yeah, type inference here is brutal 😦
that's the error i get with something like that
```
mismatched types
expected reference `&[&[&[u8]]]`
   found reference `&[&[&[u8]; 2]; 2]
```
Rust-wise you need to do something like
```.rs
&[
    &[ b"first thing's seed".as_ref(), &[first_things_bump] ],
    &[ b"other thing's seed".as_ref(), "other thing's second seed".as_ref(), &[other_things_bump] ]
]
```
ah right
Ah, sorry, that hack is to let a non-system account pay for another account's creation
so i already have creating a PDA owned by a program with 0 space working. Which i think is what your hack here is supposed to get working?

However, I'm slightly stuck on combining two seeds in an array
usually it's 
`let signer = &[&payer_pda_seeds[..]];`
but i need to combine multiple in an array somehow
`let two_signers = &[payer_pda_seeds, created_pda_seeds];` this gives a compile error, i'm going to play around with different solutions but mentioning it in case you know off hand already
aside from that it's not possible to have optional accounts
search for `remaining_accounts`
common methodology is to write a javasript / tyescript test for end-to-end functionality. you can assert account balance etc. within here as well. there's also rust tests, but i guess these are more for testing individual functions. i think what you need is `anchor test` , and setup multiple user accounts, and check if the balances are correct at each stage
Hello! Is it possible to have `Option ` account in my instruction?
or does anchor have these functionalities already implemented?
etc
I mean anchor test is one option but what if I want to test my staking program by test staking et
hey how can I correctly test my program ?
Ah ok
I would expect the solana dumbness-check to happen after the CPI
Not beforehand
And it failed the transfer check for having data on the account
Someone else told me they tried it with a PDA with Solana in it
But yeah worth trying!
Yeah, I think what will happen is that solana itself double checks CPIs didn't do something dumb, and that check will fail here (so nothing in the system processor code itself necessarily)
Yeh, I'm out at the moment but I will try this morning for sure
It calls allocate and assign and transfer
Worth trying (I think I already did try this, but now not 100% sure)
Yeah, I mean solana itself will prevent this (I think)
https://github.com/solana-labs/solana/blob/e540b1cf3c329c51de60a183529d0c39ee3d86d9/runtime/src/system_instruction_processor.rs#L150
Transfer is called by create_account
Maybe there is a higher level check that happens which prevents it
https://github.com/solana-labs/solana/blob/e540b1cf3c329c51de60a183529d0c39ee3d86d9/runtime/src/system_instruction_processor.rs#L202
If the account is owned by the system program then yeah, just need a signature (PDA or otherwise), but I'm pretty sure it won't work if the account isn't owned by the system program, since solana just doesn't allow that kind of non-owner mutation.
I was like 99% sure that doesn't work (people keep trying it in the discord and they have to use `try_borrow_mut_lamports` instead)
Really? Even if the from account is owned by your program?
And transfer works fine so long as the from account is a signer and doesn't have any data in it
Since in the create account source it's just calling transfer
I feel like it's probably ok if the PDA signs
Interesting, I will have to investigate
The issue is that solana itself won't let the system program debit an account it doesn't own.
Thanks for the example. It should be possible to create an account owned by a program with 0 space and to have that pay so long as the payer is a signer. There's nothing in the source that would suggest otherwise but maybe it breaks in practice somehow. I'll have to try putting some minimal example together to test it out
hi there, on frontend, how do you create a persistently connected wallet, until user decides to disconnect? right now, whenever user returns to site, getAnchorWallet prompts a re-connect
Is there anyway to see what you can use inside of #[account], eg [account(init)], etc. I've been traversing the rust docs but can't seem to find anything
big num
hi anyone we are getting this error. any insight would be appreciated. first time to run anchor. thank you
what does "BN" stand for? 
```import { web3, BN } from '@project-serum/anchor';
```
But what you actually can do (horrible hack) is have your program account send money to the fresh account via `try_borrow_mut_lamports` stuff, then allocate the new account some space, then transfer ownership from the system program to your program 😬 There's also a sort of bug in solana that makes this even dumber than it ought to be: https://gist.github.com/cqfd/ffbdebbbcd3460ec822c3e63572cc282
This is indeed pretty tricky to do—basic answer is "no", but the less basic answer is "sort of" lol. Basic answer is no because at the end of the day the system program is going to debit the payer account, which can only work if the account is owned by the system program (so not going to work as-is if the account is actually owned by your program)
```
    if !from.data_is_empty()? {
        ic_msg!(invoke_context, "Transfer: `from` must not carry data");
```
<https://github.com/solana-labs/solana/blob/e540b1cf3c329c51de60a183529d0c39ee3d86d9/runtime/src/system_instruction_processor.rs#L184>
wow, i found it
even still, this sounds wrong
the person who mentioned this said more specifically that it was program accounts with data in them that couldn't have solana transferred from
but this can't be right because then PDAs couldn't be used to transfer solana around
i've heard rumours that they cannot
can non-system program accounts be payers when creating account?
hmmmm
Whoops, missed this already got answered, my bad!
`constraint = something @ YourCustomError` (make sure you've got an up to date anchor + anchor-cli)
you were right: Installed solana again by building it from scratch and the problem is gone.
Had version 1.8.2 before, now 1.8.5. Will submit a pull request to buildspace's tutorial to update it.
-> Wasn't an anchor bug
https://github.com/project-serum/anchor/blob/384f143f77e8dd611e48be75072e47a860c462a0/tests/errors/programs/errors/src/lib.rs#L74
how can we attach custom error code on constraint validation in anchor ?
i see :0 i have been working on setting up a linux vm .. arm ubuntu seems problematic as well... I guess I will just move on to ubuntu x64 on cloud 🤣 thanks a lot !!! appreciate you checking my issue 🙏


//////////////////////////////////////////////////////////////////////////////////////////

Finished reading this article -- the voting app example was helpful !
thank you, this makes a lot more sense now 🙂
https://www.brianfriel.xyz/understanding-program-derived-addresses/
highly recommend this read
They're just a sha256(seeds + bump + programId + some fixed string, can't remember)
Yep, exactly
I think you understood my question -- I was confused as to whether seeds + bump were global, but after some googling it looks like a PDA is derived from (programId + seed + bump), which means the derived address will never conflict w/ another program
The point of the seeds is to be human-understandable, the point of the bump is purely to make sure the result sha256 hash isn't a valid ed25519 public key
Or, hmm, maybe I'm misreading your question 🤔
Also bumps are only a single byte
So you and I can use the same seeds, but for different programs, and will get totally different addresses
No, because PDAs are always specific to a specific program!
one wonders why seeds + a bump is necessary, since couldn't everyone just use an empty seed array & just have different bump values?
Yep
I see, this makes sense. So I could just use an empty seed array b/c the bump value will result in (eventually) a valid address being found, right?
Because you've already created an account at that address
It will fail on subsequent calls
whereas true global state should only be created once
Can use whatever hardcoded seeds you want by the way (even [])
Actually -- even the above example doesn't seem correct, since `create_game_state` can be called more than once
Yep, hardcoded seeds will act like global state
https://gist.github.com/vedantroy/bbc23a19a5e5126198590cd7fd4f9d09
I think I finally figured out how to have global program state:
Thanks for the responses -- I also reached the same conclusion once I dug into the Rust.
use `Account` instead
Nope, it's deprecated 😉
Is there a tutorial on how to use the `ProgramAccount` struct in Anchor?
that's good! you will have an easier time of it than i did at least 🙂 i had to learn rust just so i could learn solana
sounds good haha -- yeah, I'm experienced with Rust but not with Solana
you can do this through PDAs. Sounds like you should dig deep into Solana Programming basics first 🙂 dont worry too much about anchor for now
I will continue looking through tutorials (I think I see something w/ a counter that might be useful for what I'm doing)
And since the state must be global --  I can't allow multiple users to each create their own global state
thanks for the quick response -- basically, what I'm trying to accomplish is letting my program have some global state. Imagine a struct with a few integers.
but if you pass one thats already been initialized on the blockchain it will fail because it's trying to create an account thats already been created
depends on the account you pass into the program. if you pass an account that hasnt been initialized, it will initialize it
Or will there only ever be a single `my_account`?
Quick beginner question here:

Will `my_account` be created for every user that calls `initialize` on the program?
sure thing
thanks <@!350632015852208140> let me try this, and I'll make sure of that😅
No @ core devs
<@!889831471748108328> when you post questions here people will naturally answer these probably (irrespectible of the core dev) 😅  i would guess it's most likely an issue with some of your SSL certificates. can you check if you can pull from github normally, this looks more like a github issue rather than an anchor issue
I've googled this and found that many have faced this same issue, yet I'm unable to find solutions
hey [edited] can you guide me through this error?
https://docs.rs/anchor-derive-accounts/0.18.2/anchor_derive_accounts/derive.Accounts.html
Is there any place where I can read about the different **attributes** such as `#[derive(Account)]` etc
Does close account attribute and close account cpi call in token does that ? Any examples ?
That's much easier than what I've been doing thanks. I foolishly went straight to Uint8array(0)
I mean `Buffer.from([0])` etc.
just dropping this in case someone else would need it.
```
/**
 * BYTE   8-bit unsigned                          buf.writeUInt8()
 * SBYTE  8-bit signed                            buf.writeInt8()
 * BOOL   8-bit boolean (0x00=False, 0xFF=True)   buf.fill(0x00) || buf.fill(0xFF)
 * CHAR   8-bit single ASCII character            buf.from('Text', 'ascii') - Make 8-bit?
 * UNI    16-bit single unicode character         buf.from('A', 'utf16le') - Correct?
 * SHORT  16-bit signed                           buf.writeInt16BE() - @see https://www.reddit.com/r/node/comments/9hob2u/buffer_endianness_little_endian_or_big_endian_how/
 * USHORT 16-bit unsigned                         buf.writeUInt16BE() - @see https://www.reddit.com/r/node/comments/9hob2u/buffer_endianness_little_endian_or_big_endian_how/
 * INT    32-bit signed                           buf.writeInt32BE - @see https://www.reddit.com/r/node/comments/9hob2u/buffer_endianness_little_endian_or_big_endian_how/
 * UINT   32-bit unsigned                         buf.writeUInt32BE - @see https://www.reddit.com/r/node/comments/9hob2u/buffer_endianness_little_endian_or_big_endian_how/
 */
```
i'm surprised that the api is kind a sucks,
yeap doesn't like that 😅
`TypeError [ERR_INVALID_ARG_TYPE]: The first argument must be of type string or an instance of Buffer, ArrayBuffer, or Array or an Array-like Object. Received type number (0)`
Have you tried using just 0 for false, 1 for true?
trying to filter votes base on mecmp,

how can i encode boolean value in JS ?
Another query I had was, what is the difference between `<Account>`, `<AccountInfo>`, etc ? And are there any docs regarding these?
What does `#[derive(Debug, Clone, AnchorSerialize, AnchorDeserialize)]` do exactly here? Are there any docs I can refer??
```
#[derive(Debug, Clone, AnchorSerialize, AnchorDeserialize)]
pub struct ItemStruct {
    pub gif_link: String,
    pub user_address: Pubkey,
}
```
Ah okay, thank you so much!
that's cool I did'nt knew that. Thanks
If the account that lives at that PDA stores one of your `#[account]` structs, then doing `Account<'info, YourStruct>` checks this ownership automatically. Otherwise you could use the `owner = id()` attribute, or just check ownership manually in your instruction function (e.g. `.to_account_info().owner`)
Have to be slightly careful—who can change the data at a PDA depends on which program *owns the account that lives there*, not on which program *derived the address*.
It's the sum of the lamports that has to remain the same
Edited the response for clarity
So by same, you mean the runtime checks for the net difference to be zero right? Because technically we are changing the lamports of individual accounts
Solana run time enforces that the total lamports across all accounts is the same at the end of a transaction as at the start. So you would get an error and a failed transaction
thanks
yeah if you add the seeds array it is a pda
https://docs.rs/anchor-derive-accounts/0.18.2/anchor_derive_accounts/derive.Accounts.html
so ya I'm doing that but on program side I'm not adding the seeds attribute on top of that account ... does adding seeds ensure its a PDA ? (Talking in general case not the case of initing where we need to pass the seeds )
yeah you have to calculate the PDA with the seeds outside of the program, then pass that into the program along with the bump seed
Another not-so-anchor doubt, hope you guys don't mind 😅 \
I was following a tutorial by Paulx, and I came across this piece of code,
```
**initializers_main_account.try_borrow_mut_lamports()? = initializers_main_account
            .lamports()
            .checked_add(escrow_account.lamports())
            .ok_or(EscrowError::AmountOverflow)?;

        **escrow_account.try_borrow_mut_lamports()? = 0;
        *escrow_account.try_borrow_mut_data()? = &mut [];
```


and I was wondering what would happen if I didn't zero the `escrow_account`??
That wouldn't add up as we're only increasing one account's balance right?
so everytime I need to do something (apart from init the PDA) I need to have seeds attribute on top of account ?
in anchor afaik when you list out the accounts, for the PDA accounts you define the seeds and the bump, and when you pass the list of accounts in to the program, it will compare the one you pass in with the expected one
How can we check if PDA(account) passed inside the call is owned by current program ? Inside the program ?
the program can change the data via function calls, but its your job to make sure that only the intended users can call the function (based on whatever you decide)
Thanks. so if I write a function to change the data on PDA inside the program. The authority on PDA can call that function and change that right ? what's  permission constraints (authority) ?
just the program, so it can be changed via function calls according to the logic that you (or anyone, depending on the permission constraints) can call
Basic q  - can anyone can change the data on a PDA ?
if I'm trying to see if an account on the blockchain is initialized, and I have an `AccountInfo` object, is `data_is_empty()` sufficient for checking this?
what's the maximum seed length for PDA's ?
```
user.to_account_info().key.to_bytes().as_ref()
``` did the trick
coming back to this, 
how can i correctly refer to `PubKey` of the user in PDA account seed ?
sir can we ask help with this?
<@!134416332509675520>  <@!350632015852208140>  thank you so much guys 😅
```
[registry]
url = "https://anchor.projectserum.com"
```
what functionality in `Anchor.toml` does this provide?
```
seed: [
    <Buffer 70 72 6f 70 6f 73 61 6c 5f 61 63 63 6f 75 6e 74>,
    <Buffer 00 00 00 00 00 00 00 00>
  ]
``` 
does look like this btw ☝️

what a roller coster 😅

thanks! ❤️
Not 100% sure you can rely on this working if you only use 6 bytes tbh, I would try to use the full 8
To get the full 8 bytes
Yuck, the alternative in node is something dumb looking like `buf.writeBigInt64LE(BigInt(123))`
What the hell, what what a weird api 🤔
Oh, wtf, that api is way weirder than I thought
changed to `0, 6` worked 🎉
```
     RangeError [ERR_OUT_OF_RANGE]: The value of "byteLength" is out of range. It must be >= 1 and <= 6. Received 8
```
new error
Look in the program logs and see if the id that gets printed matches your declare_id
Given that struct probably because your `declare_id` doesn't match the running program's actual id
```let pool = anchor.web3.Keypair.generate()

  it('Is initialized!', async () => {
    // Add your test here.
    console.log(pool.publicKey)
    const tx = await program.rpc.initializePool({
      accounts: {
        pool: pool.publicKey,
        payer: program.provider.wallet.publicKey,
        systemProgram: anchor.web3.SystemProgram.programId,
      },
      signers:[pool]
    });
    console.log("Your transaction signature", tx);
  });```
```#[account]
#[derive(Default)]
pub struct Pool {
    pub total_deposited: u64,
    pub synth1: u64,
    pub synth2: u64,
    pub price1: u64,
    pub price2: u64,
}```
```#[derive(Accounts)]
pub struct InitializePool<'info> {
    #[account(init, payer = payer, space = 8 + 40)]
    pub pool: Account<'info, Pool>,
    #[account(mut)]
    pub payer: Signer<'info>,
    pub system_program: Program<'info, System>,
}```
Assuming you're still using `.to_le_bytes` (change if using to_be_bytes, endianness needs to match)
anyone know why I get this error ? ```     Error: 167: The given account is not owned by the executing program
```
And then use that buffer in the findProgramAddress part.
Try doing something annoying like
```.rs
let totalProposalAccountBuf = Buffer.alloc(8);
totalProposalAccountBuf.writeUIntLE(theTotalCount, 0, 8);
```
The client is using `toBuffer`, but that doesn't return 8 bytes like you're doing in the program when you explicitly use a u64
I think the way you're specifying the proposal_id seed is wrong (it's different between the client and program)

bump seems like correct,
you might wanna print out the bump btw
``` 
#[account(
        init,
        payer = purchaser,
        space = 64 + 64 + 64 + 64 + 64 + 64 + 64 + 64 + 8 + 8 + 8,
        seeds = [purchaser.key.as_ref(), b"bondInstanceAccount"],
        bump = {msg!("bump be {}", _bump_bond_instance_account); _bump_bond_instance_account}
    )]
``` 
you can do it like this. then you can double check that the bump is read correctly. if it is read correctly, it should be the rest of the seeds for sure
it's failing at adding the proposal test.
but its not relevant for the issue we're discussing, separate function anyways..
i actually haven't got the part testing voting though
yh thats true, but here it doesn't, no?
But not sure I'm reading the right thing 🤔 and my internet is trash right now 😦
I think if I'm reading it right that part is ok (instructions just have to match left to right up until you don't care anymore—don't need to match exactly)
Did you ever find a solution to this? I'm having the same issue.
that could lead to the bump being mis-read (serialzation could be off). not sure if this is it, but also sth that i think could cause it (at least does so for me sometimes)
also I think you have a small bug here:
``` 
proposal_id: u64, vote: bool
```

``` 
#[derive(Accounts)]
#[instruction(proposal_account_bump: u8, proposal_id: u64)]
pub struct VoteForProposal<'info> {
    #[account(mut)]
    pub base_account: Account<'info, BaseAccount>,
    #[account(mut, seeds = [b"proposal_account".as_ref(), proposal_id.to_be_bytes().as_ref()], bump = proposal_account.bump)]
    pub proposal_account: Account<'info, ProposalAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
}
``` 
the instructions dont match the arguments of the function, if im not wrong
```
#[derive(Accounts)]
#[instruction(proposal_account_bump: u8, proposal_id: u64)]
pub struct AddProposal<'info> {
    //...
    #[account(init, seeds = [b"proposal_account".as_ref(), proposal_id.to_le_bytes().as_ref()], bump = proposal_account_bump, payer = user, space = 10240)]
    pub proposal_account: ProgramAccount<'info, ProposalAccount>,
    //
}
```
To match how you're calculating the seeds on the rust side
Ok, I think the issue is actually that `.toBuffer()` just doesn't do the right thing, you need to explicitly make it be length 8 somehow
can you print what console.log prints, and what you have as the rust constraints?
it's matches
You can verify this by printing out that pda's address (use `.toString()` on it) and seeing if it matches the error message about signer privilege escalated
That's the part that is likely failing, because you're mismatching the seeds between client and server (that's my guess)
You're signing implicitly within the program with you say `init, seeds = [...], bump` etc.
```
await program.rpc.addProposal(
      new anchor.BN(accountBump),
      account.totalProposalCount,
      "Test Title",
      "Test Description",
      {
        accounts: {
          baseAccount: baseAccount.publicKey,
          proposalAccount: proposalAccountPublicKey,
          user: provider.wallet.publicKey,
          systemProgram: SystemProgram.programId,
        },
      }
    );
``` 
at the stage i'm not signing at all 😅 but when i put baseAccount it it says incorrect signer, and don't have signer account for PDA
Not sure what doing bignum.toBuffer() actually does
Maybe you need to use `to_le_bytes()` (little-endian versus big-endian)?
`    GRSuXzC9hJeyQnPbpzVFLVDX6ZcZp6tgk2CgtMD7VEc2's signer privilege escalated
` means you're not signing correctly somehow
the full error is like this,
```
Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account 
    Program HRNkDCeaArkBn2mM3pMa1JwAMmgaNgWpXnPYeNq5eFvg invoke [1]
    GRSuXzC9hJeyQnPbpzVFLVDX6ZcZp6tgk2CgtMD7VEc2's signer privilege escalated
    Program HRNkDCeaArkBn2mM3pMa1JwAMmgaNgWpXnPYeNq5eFvg consumed 200000 of 200000 compute units
    Program HRNkDCeaArkBn2mM3pMa1JwAMmgaNgWpXnPYeNq5eFvg failed: Cross-program invocation with unauthorized signer or writable account
Translating error SendTransactionError: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account
    ......

 {
  logs: [
    'Program HRNkDCeaArkBn2mM3pMa1JwAMmgaNgWpXnPYeNq5eFvg invoke [1]',
    "GRSuXzC9hJeyQnPbpzVFLVDX6ZcZp6tgk2CgtMD7VEc2's signer privilege escalated",
    'Program HRNkDCeaArkBn2mM3pMa1JwAMmgaNgWpXnPYeNq5eFvg consumed 200000 of 200000 compute units',
    'Program HRNkDCeaArkBn2mM3pMa1JwAMmgaNgWpXnPYeNq5eFvg failed: Cross-program invocation with unauthorized signer or writable account'
  ]
}
```
the extended error code usually tells u if its a signer-, or write-issue
is there more to the error code? either some account is not mutable, or youre not passing the relevant account as a signer, would be my guess
Think your best bet to learn this stuff is to run the code!
and was curious
i wasnt running the code was just looking a example on spl program
Try removing the clones and see what error message you get 😉
any idea as to why do we clone the accounts refrence inside invoke even though the parameters are already a refrence ?
🥲 <@!134416332509675520>  can you help me to debug this ? 
https://github.com/Necmttn/anchor-voting/blob/pda_cpi/anchor-voting/programs/anchor-voting/src/lib.rs
https://github.com/Necmttn/anchor-voting/blob/pda_cpi/anchor-voting/tests/anchor-voting.ts
i have no idea wth is wrong with it 😅
i still got the 
```
Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account
``` 
error.

```
    const [proposalAccountPublicKey, accountBump] =
      await anchor.web3.PublicKey.findProgramAddress(
        [
          Buffer.from("proposal_account"),
          account.totalProposalCount.toBuffer(),
        ],
        anchor.workspace.AnchorVoting.programId
      );
    await program.rpc.addProposal(
      new anchor.BN(accountBump),
      account.totalProposalCount,
      "Test Title",
      "Test Description",
      {
        accounts: {
          baseAccount: baseAccount.publicKey,
          proposalAccount: proposalAccountPublicKey,
          user: provider.wallet.publicKey,
          systemProgram: SystemProgram.programId,
        },
      }
    );
```
and  this is how i call it
works like a charm!
alright, thx! 🙂 will play around with Box
So yeah, your program itself is fine, just gotta be a little more careful with the stack
That means you're running out of stack space 😮‍💨 (Each stack frame in solana is only 4kb, so you can run out of space pretty easily.) Easiest trick to fix this is to just stick a Box around some of your Accounts: `the_account: Box<Account<'info, TheStructType>>`
ahhh missed that. thank you so much!
dafuq 😅  also, how do you know all this man xD
I guess it's the accounts then actually.

```
Transaction simulation failed: Error processing Instruction 0: Program failed to complete 
    Program Bqv9hG1f9e3V4w5BfQu6Sqf2Su8dH8Y7ZJcy7XyZyk4A invoke [1]
    Program Bqv9hG1f9e3V4w5BfQu6Sqf2Su8dH8Y7ZJcy7XyZyk4A consumed 2320 of 200000 compute units
    Program failed to complete: Access violation in stack frame 3 at address 0x200003fe0 of size 8 by instruction #14251
    Program Bqv9hG1f9e3V4w5BfQu6Sqf2Su8dH8Y7ZJcy7XyZyk4A failed: Program failed to complete
``` 
this error, and also the fact that this error goes away when i remove a single account from the context
The size limit for an individual program is pretty big, like 10mb 🤔 What makes you think you're running out of space?
The size limit for your program? Or an individual account?
also, is there any good resources / guide / tutorial or page on how to split up a solana program into multiple solana programs? I think I am hitting the size-limit for my program
You want to derive it from your own program's id, so that your own program can sign for that address when you initialize an account there (creating an account at an address requires that that address sign—in this case because it's a program-derived address, it's up to your program to sign for it)
Ah, your problem is that you derived that address on the client using the *system program*'s id, not your own program's id (you need to use your own program's id)
The actual literal type of `b"foo"` is `[u8; 3]` (the length goes right in the type)
yeah that worked, thanks. i wonder why that happens though
Rust type inference isn't always super smart, that's because you didn't add a `.as_ref()` to the first hard-coded string
Nope. That finds an address that is *derived* from that program id. It's just an address, and addresses don't have owners (accounts have owners). Whether an account that lives there is owned by the program is independent from whether the address is derived from the program.
Hi all, I'm trying to understand how to use PDAs in an Anchor Program, and wrote a barebones Program to test. When I try to initialize from client though, I get a CPI error: `Cross-program invocation with unauthorized signer or writable account`. I posted more details at https://stackoverflow.com/questions/70138221/proper-way-to-initialize-pdas-within-the-solana-anchor-framework
thanks, ill do that
anchor docs are a good place to start learning
just start something. anything works. write a simple contract and see if you can write some tests for it and run them on localnet
sorry if i sound noobish 😐
what type of project would cover most of the base knowledge?
depends on your goals. if you want to build frontends, sure. you can, however, just stick to writing only smart contracts/backends services too though
Hi, is front-end knowledge really required to get the hang of web3 development? (e.g. react/js) My goal is working on web3 related projects, but im a system programming enjoyoor
im unsure why it expects 13 bytes as opposed to 32. any thoughts?
Hello how do you connect anchor to phantom wallet?


//////////////////////////////////////////////////////////////////////////////////////////

and then set the owner to the program
I see, so I'd use https://solana-labs.github.io/solana-web3.js/modules.html#CreateAccountParams
Regardless of address type
Mutating an account is *only* possible for the owning program
b/c this account is not a PDA
Yes, but you'd have to do the same ownership-setting for a PDA too
I see, so I would have to create this external account & then set its owner to my program?
You need the signature when you create the account, but not necessarily ever again
It's up to your program whether it requires the signature (it's free to mutate accounts it owns whenever it wants—any signature is purely a matter of politeness etc.)
That's what I'm asking about—nothing actually requires that signature
so the user must have the external account's keypair
but this means the user must have the ability to provide the external account's signature
*give the external account's signature
if the game data is stored in an external account and I want to mutate the data in the external account, then I need to sign the data
I would suggest just trying it/do some source-diving
Mm, don't have an example off hand but you can see some by searching the anchor codebase
thanks. yeah if you have example in mind feel free to send
`anchor_lang::solana_program::system_instruction`
where is `system_instruction` imported from>
i suppose initializing an account is the one im thinking of off the top of my head
The most common one you'll see is `system_instruction::transfer`, does that count? What are you wondering about more specifically?
Why do you need to keep signing? Not sure I'm following what you're trying to do
Does anchor support optional arguments for instruction calls?
I feel like this is a stupid question but is there an example that shows a CPI for the system program? like for initializing an account or somesuch
Hopefully, this works
- the PDA stores a public key under `storage_account`
- `DoGameAction` account policy checks that `storage_account` is signed
Hmmm .. so how would I implement this pointer strategy?

Current plan looks like:

```
#[account]
pub struct GameState {
    bump: u8,
    storage_account: Pubkey
}

impl GameState {
    fn space() -> usize {
        // Ident
        8 +
        // bump
        1 +
        // Pubkey
        std::mem::size_of::<Pubkey>()
    }
}

#[derive(Accounts)]
pub struct DoGameAction<'info> {
    #[account(seeds = [], bump = game_account.bump, has_one = storage_account)]
    game_account: Account<'info, GameState>,

    #[account(mut)]
    storage_account: Account<'info, Storage>,

    #[account(mut)]
    from: Signer<'info>,

    #[account(mut)]
    to: AccountInfo<'info>,


    system_program: Program<'info, System>,
}
```
& thus could submit a malicious transaction that is signed by this keypair, which would mutate the account data
but if the game runs in users browsers, then every user will have access to this keypair
that means on every transaction I need to sign using the keypair for this external account
for example, let's say this external account is the game storage
<@!739012341588557895>  <@!134416332509675520>  -- one problem with using an external account is that theoretically any malicious attacker could modify it right?
Deploying to testnet takes 1.47 sol right now, that's pretty expensive for deploying to prod
(also, are there docs I can find on this -- I only find a mention of the 10MB rent limit)
oh, that's unfortunate! Is this a limitation of Anchor or just a limitation of Solana in general
how to get program id of current program?
gotcha! Thanks a lot <@!134416332509675520> !!
And will error if the account didn't sign
Yeah, that's what `Signer` does under the hood: it just checks that the account signed the tx
so to clarify further, with `Signer` in place, even tho the instructions in the handler dont need that signer's signature (lets say on transfer and stuff) , the program will still require signer to sign to pass
Don't leak that key lol
Yep 🙂
You're asserting the address has to be the admin pubkey, *and* checking that they signed
ofc as long as admin doesnt leak private key
Yep
ohh so actually this is already safe enough
Ah, you're already doing that signature check when you say `Signer<'info>` (anchor will do it for you)
how do I impose signature check in the handler tho?
You'll need that signature to verify that it really is the admin
Yep!
is it possible that attack somehow gets the admin's publickey and try to access that handler?
Yeah, there will still be a pop-up no matter what
I guess my question is
Ah, ok
in fact it looks something like 
```
#[account(mut, address = Pubkey::from_str(constants::ADMIN_PUBKEY).unwrap())]
pub manager: Signer<'info>,
```
Also not totally sure what you're asking though 🤔
If the user is submitting the transaction you'll get the phantom popup no matter what (they have to pay for to submit the tx regardless of whether anything else needs to sign)
my usecase here is that I'd like to define n admin handler, whereby only admin can access, and therefore the `Signer`, but in the handler it's just some program state change, not really requiring the admin's signature over there
Hi got a question,  if in a `#[derive(Accounts)]` struct, I define a Signer, but in the whole instruction there is no signer's signature needed, in this case will the sign pop up still show with the browser wallets?
 ```
pub signer: Signer<'info>,
```
I imagine you could also use the `solana-keygen` command
i litereally init new project to get a fresh one 😅
that could work forme
Not sure if there's an easier way, but you could delete the old one (inside target/deploy). Running anchor build again will generate a fresh one.
how can i generate a new programId ?
Take a look! I think the source will explain itself
Not yet, just found it on the Metaplex's code
Have you tried looking at its source code?
it's the same as AccountInfo but more explicit in that anchor doesn't check if the account is owned by the program
Hi <@!134416332509675520> 
Could you explain me about the `UncheckedAccount`?
✨ Hello hello ! What would be the best way to fetch the balance of an associated token account? I tried .getBalance but obv it's giving me the accounts' SOL balance
ok thanks
If you want to close an account that's owned by a different program, you'll have to look up how that program lets you close accounts (you won't be able to do it yourself, you'll need to ask that program to do it for you)
Yep, the issue is about ownership, *not* PDAness.
So I tried it out and it was giving me this error -> Error processing Instruction 0: instruction spent from the balance of an account it does not own
That attribute will work whenever the *account* is owned by your program (as usual, the PDAness is irrelevant, it's all about which program owns the account)
Have you tried it?
Yep, that's my understanding
Is it because Solana required those accounts to be specified prior to 1.7.0? And it is a relic of that?
Oh, why do we need to pass `rent` sysvar for initializing `TokenAccount`, but for anything else we are allowed to not specify it.
Does this attribute works on PDA to close it  -> #[account(close = <target>)] ?
the PDA is kind of acting like a pointer I guess
yeah just storing the larger accounts public key so that later, when someone sends the PDA and the larger account to your program in an instruction, you can verify they belong together, essentially just preventing someone from sending in some malicious game data that doesn't actually correspond to the PDA
Thanks for your explanation
Yup 🙂
And then verify that they really are creators in the instruction handler
Ok, then yes, you'll need to pass them in as accounts
The tokens will be distributed to the nft creators like the royalites
Depends on what you're doing
But the data etc. is stored that one metadata account
So I don't have to add the creators accounts on the context?
If you need to pass a creator account for some other reason, then yeah, you'll need to pass it in
Not sure what you mean?
But on the Solana program, the `accounts` array should contain all accounts
No, they're stored in the metadata account itself.
These `creators` should be listed on the context as well?
Thanks 🙏
I'm depending on metaplex via git since their cargo lib seems out of date:
```.toml
metaplex-token-metadata = { git = "https://github.com/metaplex-foundation/metaplex", features = [
    "no-entrypoint",
] }
```
Not sure, I don't use metaplex, but something like this will probably work:
```.rs
        let metadata = metaplex_token_metadata::state::Metadata::try_from_slice(
            *ctx.accounts
                .the_metadata_account
                // .to_account_info()
                .try_borrow_data()?,
        )
        .map_err(|_| ProgramError::InvalidAccountData)?;

        let creators = metadata.data.creators;
```
So, if you want a really big account, > 10kb, it currently has to live at a keypair address.
This particularly effects accounts that live at PDAs because they *have* to be created via CPI (it's not possible to issue a separate instruction from the client, because the PDA address can't sign from there—only the program can sign for it, hence the need to CPI)
I'm catching up on your thread, but sounds like you're running into an annoying limitation: when you create an account via CPI (so, anytime you use `init` in anchor), you're limited to 10kb accounts, not 10 mb 😦
Thank you! It is just that it was named `owner` in original `spl_token`, so it got me a little confused
token::authority is who is supposed to "own" the tokens in that account (the account itself is owned by the spl token program)
yeah, authority is the owner
https://docs.rs/anchor-spl/latest/src/anchor_spl/token.rs.html#116
Sorry for asking again, but what exactly `auhtority` means in this context? Is it an `owner` of initialized `TokenAccount`? Or is it a `mint`s authority? Why would I need to pass it though, I thought it isn't needed in `InitializeAccount` instruction here? https://docs.rs/spl-token/3.2.0/src/spl_token/instruction.rs.html#63
Hi <@!134416332509675520> 
How's your weekend?
Could you share the piece of code to read the metaplex nft's metadata? (especially creators array)
which is not amazing
although, if we want to mutate data in it -- we'll need it to sign every transaction
and also, to clarify, when we store the (larger) account in the PDA -- that just means storing its public key
oh these docs are good, I'll read them over - thanks !
There's also one for fetching spl token balances in that section somewhere
Should be this https://solana-labs.github.io/solana-web3.js/classes/Connection.html#getBalance
from an account
yeah, for example in a test I might want to see that in-fact some money was deducted
sol balance?
a slightly unrelated question: Do you know how to get the balance of a public address (user or program) w/ web3.js?
no worries man, good luck haha
thanks for the help ❤️
as you are right that no one else will even know I've deployed a program
I think I'll take the risk of running the code first
Instead, if this works for your usecase, you can create the game state account, then use its public key as one of the seeds for the PDA, that way it wouldn't be a race for first to init the one global PDA, because the pda for each game state account would be unique
yeah I'm not entirely sure the best way to deal with that, usually if I'm writing a program I don't want anyone else to use, then I put in an init_program instruction where i set the owner of the program, who then is the only one allowed to use the other owner instructions. Of course you run the risk of someone beating you to calling this function, but then when you first deploy a program no one even knows you have, so I feel like that can usually be prevented
but I think it's the right direction; probably the best thing to do is to hard-code in an address into the contract
this is pretty reasonable -- I think it leaves the hole that if someone who is not you initializes the PDA first then they'll have control
similar to here:  https://project-serum.github.io/anchor/tutorials/tutorial-2.html#defining-a-program
If you also store the public key of the person who initialised the PDA in its own account data, then in your anchor program endpoints, only allow changes to the game state account public key, if the signer is the person who initialised the PDA
Thanks fayd I finally understand
if you put some access control on the initialisation endpoint in your anchor program, that could maybe fix that issue, i.e. make yourself the only one who can init the PDA and assign the game state account
if you can create another one, then anyone else can also create another one & screw you over
I think you only want the initialization to be done once though
I think you could store data in a wallet account as you've got the private key, correct me if I'm wrong anyone
Ahh I see. But what I dont get about createAccountFromSeed is that it doesnt give you a key pair but a public key
yeah you could generate an account to store data in using the createAccountFromSeed or you could use a PDA account where one of the seeds is the user's publickey
Are user wallets also accounts?
Yeah I want to be able to store user data based on the wallet pubkey they pass in
Solana leaves a bit of flexibility here, which I know can feel a bit arduous coming from solidity. It kind of depends on your use-case and how you want to do it. You're wanting to store data for each user, like you would in a mapping in solidity?
If someone were to create the account with the wrong size you could just create another one
I mean you would initialise the account (*) and then pass it into your program with your pda, where your pda would get initialised and set the account (*) as it's corresponding game data account.
I promise Ill help once I learn all this shit Lmaoo
(with, for example, a smaller size)
and if someone initializes before me, then I'm screwed
I guess a downside of the workaround is now I need to initialize a game data account w/ a certain size
thanks; I might have to try this -- I wonder why the limitation exists in the 1st place
then you just check that the correct data account is being passed in by checking if its publickey is the same as the one stored in your pda
you could break your game state data up into 2 accounts. In the PDA's account data you could store the public key of the other account that holds your game data
I remember trying it before a while ago, and I think creating account data for a PDA address can only be done inside the program
actually, it's entirely possible I can -- I'm just not sure
Thanks. This does seem like a good idea -- alas, I need to create a PDA specifically, & I'm not sure if I can create that using web3.js
Is createAccountFromSeed what I want or could I create the account in the solana program?
In solidity it would just be a key/value map basically
Im having a hard time wrapping my head around creating an account based on a user’s wallet and being able to find and modifying that account later
https://solana-labs.github.io/solana-web3.js/classes/SystemProgram.html#createAccount
Based on "SystemProgram::CreateAccount data size limited to 10240 in inner instructions" it just sounds like the anchor devs have capped the size to 10kB when creating an account inside your anchor program
as a work-around you could create the account outside of the program
oh touche, I was thinking in kB
I agree, but I'm still confused since 10240 bytes is less than 10MB
ah right yeah that size is in bytes rather than bits I'm pretty sure. For example a u64 takes up 8 units of space in an account, so it must be bytes
https://docs.solana.com/developing/programming-model/accounts#creating
that's what I was thinking but an account can hold 10MB in Solana
I think this is because 10240 exceeds the maximum accounts size limit, as you said 10MB
Thank you!
```
impl GameState {
    fn space() -> usize {
        10240
    }
}
```
And when I exceed the number 10240, Solana throws an error -- even though I know accounts can be up to 10mb in size
I have the following account policy (not sure what to call it): 

```
pub struct CreateGameState<'info> {
    #[account(init, payer=user,
      space=GameState::space(),
      seeds=[],
      bump=bump)]
    pub game_account: Account<'info, GameState>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```
More context:
could that be the issue?
i did put the wallet in my store, and am getting this using it on another component
when i log the wallet i see the functions
i keep getting ``this.wallet.signTransaction is not a function``
How do I update my anchor version within my project?
Does anyone know what "SystemProgram::CreateAccount data size limited to 10240 in inner instructions" error means?
Hmm yep it looks like the current anchor version I'm using is 0.17.0, and tutorial uses 0.18.2
Might be because tutorial is using a different anchor version 🤔
I have the following function, essentially copied from the basic-1 Anchor tutorial:

```
    pub fn init(
        ctx: Context<InitializeShowroom>,
        uuid: String,
    ) -> ProgramResult {
        let showroom= &mut ctx.accounts.showroom;
        showroom.uuid = uuid;
        Ok(())
    }
}
```

Accounts for this endpoint:
```
#[derive(Accounts)]
pub struct InitializeShowroom<'info> {
    #[account(init, payer = payer, space = 8 + 6)]
    pub showroom: Account<'info, ShowroomMetadata>,
    #[account(mut)]
    pub payer: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```

When calling this function with the following code in tests:

```
  const showroom = anchor.web3.Keypair.generate();
  const uuid = anchor.web3.Keypair.generate().publicKey.toBase58().slice(0, 6);
  const payer = provider.wallet.publicKey;

  const res = await program.rpc.init(
    uuid,
    {
      accounts: {
        showroom: showroom.publicKey,
        payer,
        systemProgram: SystemProgram.programId,
      },
      signers: [showroom],
    },
  );
```

And I get the following error: ` Error: 167: The given account is not owned by the executing program`

It seems like the showroom account isn't owned by the current program (which I thought would be the expected output). Changing the type of the `showroom` account from `Account<'info, ShowroomMetadata>` to `ProgramAccount<'info, ShowroomMetadata>` worked though.. Any ideas why?
```
Can Anchor handle vectors with structs / tuples inside of them?
```
#[account]
pub struct GameState {
    bump: u8,
    pixels: Vec<PixelState>,
}

#[derive(Clone, BorshSerialize, BorshDeserialize)]
pub struct PixelState {
    owner: Pubkey,
    color: u8,
    k: u8,
}
```

I'm getting a 

```
IdlError: Type not found: {"type":{"defined":"PixelState"}}
    at Function.fieldLayout (/home/vedantroy/Desktop/solana-pixels/contracts/pixels/node_modules/@project-serum/anchor/src/coder/idl.ts:89:19)
    at Function.fieldLayout (/home/vedantroy/Desktop/solana-pixels/contracts/pixels/node_modules/@project-serum/anchor/src/coder/idl.ts:60:22)
    at /home/vedantroy/Desktop/solana-pixels/contracts/pixels/node_modules/@project-serum/anchor/src/coder/idl.ts:117:28
    at Array.map (<anonymous>)
```
I ended up changing the file extension from js to ts and it worked.. I probably missed the underlying error but thank you for the response
Does `#[account]` work with struct that contains a `Vec<Foo>` where `Foo` is another simple struct?
is there a way to return a bool from an anchor function? rather than just Ok(())
Do anyone knows an example to close a PDA ?
try `[Buffer.from([bump])]`
no. to set it to limited you need to remove the mint authority. once the mint authority is removed there is no way to set it back
Hi everyone! Is there any way of setting mint supply from limited to unlimited with web3 ? Sorry about this unrelated question. Thank you
sure can initialize at least
```
#[account(mut)]
    pub signer: Signer<'info>,
pub mint: Account<'info, Mint>,
#[account(
        init,
        seeds = [b"YOUR_SEED".as_ref(), mint.key().as_ref()],
        bump = bump,
        payer = signer,
        token::mint = mint,
        token::authority = initializer,
    )]
    pub token_account: Account<'info, TokenAccount>,
```
I keep on trying to deploy a program to devnet using `anchor deploy` (and modifying my Anchor.toml), but the deployment gets stuck at 4.2%. Is there anything I can do on my end to fix this?
You can use the programId as a seed, but you can also just have no seeds & that's fine since the programId is included by default when creating a PDA.
But I thought there were some problems when one tried to assign None to Some or the other way around?
Good day! Can I initialize and close `TokenAccount`s inside `#[derive(Accounts)]` structure
is it possible to use the programId as a seed for a pda with anchor? not sure how to access the programId when using anchor
strange - i was trying from the root of an anchor initialized directory and calling a program defined in the lib.rs file created by anchor init
Workspaces are available in an anchor workspace. So, if you have a cli folder with your command line scripts, that gets access to it.
ahh, i think i just figured this out - workspaces are only available in tests. sorry
i'm setting ANCHOR_WALLET and ANCHOR_PROVIDER_URL the same in both invocations
when i try to use `const program = anchor.workspace.<workspace_name>` and then call `program.rpc.<function>`, rpc is undefined... but if i hardcode the reading and parsing of the IDL JSON for the same program, manually set the program ID and call new `anchor.Program(...)`, the same function works fine. is there something simple i should be checking to make the workspace discovery work correctly?
Oh woah, i didn't realize that would be the thread title 🙂
Are there docs on how to calculate the sizes for an Option?
Yes.
I guess a follow up question here is: Does Anchor have the ability to serialize types like `Option`?
Is there a way to return a value from a solana method -- for example a boolean, using anchor?
maybe Anchor can auto-derive it?
I'm sure this calculation is incorrect b/c I need to consider that I have an `Option<Pubkey>` instead of just a `Pubkey`

I.e.
Does anyone know how to calculate the space required for an Anchor account?
so I do think that `createProgramAddress` is not designed to take the bump

<@!134416332509675520>  -- I tried re-deriving program key using the bump but it complains with the type error:
is transaction simulation how wallets like phantom give a preview of how much a transaction will cost before you do it?
I guess this is one reason for transaction simulation
Yep 😬 Be careful out there!
one interesting thing I'm noticing about Solana is that it seems like if you sign a transaction where your account is marked as mutable (the program can deduct Sol), the program is allowed to deduct any amount of Sol from your account. I.e: there's no fine-grained method to say "I only want to let this program deduct 5 sol from my account instead of all 10" ... or maybe there is, but it's not as straight forward as ethereum I think?
I'm not sure how you'd be able to do that, since if the program knew some private key to do the decryption with, then that private key would eventually leak (the program compiled code is public/anyone can download it)
cool cool -- thanks 🙂 , I guess it doesn't matter too much since `findProgramAddress` isn't checking if the program address is already an existing address in Solana (if that's even possible), so if I call it w/ the same seed array it will always return the same bump
Yep 🙂
It's the last value in the seeds array
*last value
oh, should the bump be the values value in the seeds array?
You can actually see this by looking at the implementation of findProgramAddress—it calls that function successively with different bumps, 255, 254, etc.
That signature is just a little misleading, it takes the bump too
Maybe I'm looking at the wrong type signature?

Hi, some idea in how to store something encrypted in an account and decrypted it (on-chain) in the next invocation?  For example: someone uploads a number, and it is saved encrypted in an account, a second user invoke the program and get the number. The second user can't get the number only by fetching (he has to call the program)
If you just pass your seeds you'll get a different address
Nope, gotta pass the bump nestled along with the seeds
that function does not take the bump
Though tbh from the client I would just probably be lazy and re-find it
That takes the seeds *and* the bump, no looping
Then I guess you could use `anchor.web3.PublicKey.createProgramAddress`
Ah, sorry, you already know the bump
I see, so we just re-do the iteration to find the bump each time
I.e, let's say the user is visiting a page for a 2nd time -- I'd need to reconstruct the public key
await anchor.web3.PublicKey.findProgramAddress([], program.programId)
Does anyone know how to create a Program Address in anchor, if I already have the bump (& my seeds array is empty).
You're passing the system program correctly 👍
Oh got it -- the issue was that I needed to mark the account I was deducting lamports from as mutable
Hello everyone! I have this error while running an anchor test (0.18.2) with solana-cli 1.9.0: 
`failed to verify account 58qkGKGgUKo31qyWnL3oCeYaUZEM9KnUxMaDYZxEmTnw: instruction illegally modified the program id of an account`. 
I discovered with  a lot of luck that I can solve it if I put 6000 or 8000 or 10000 in space instead of 9000 here:

`#[derive(Accounts)]
pub struct StartStuffOff<'info> {
  #[account(init, payer = user, space = 9000)]
  pub base_account: Account<'info, BaseAccount>,
  #[account(mut)]
  pub user: Signer<'info>,
  pub system_program: Program <'info, System>,
}`

Any ideas why and how I could have discovered this by myself? The error is quite difficult to understand.

Thank you!!!!
which hmm ... I'll look into this
And now anchor is complaining with: " Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account"
<@!163857206721249280>
the user has to be a `Signer`, not sure what that looks like from the JS side
Hmm, maybe the issue is that I'm passing in something incorrect for the `user`
if I'm not mistaken, your approach is correct. The programId is of type PublicKey, so I think that is what you're looking for
my code looks like this -- but I'm pretty sure passing in the `programId` is incorrect
For context:
I think it's expected to be an `anchor.Address` in JS/TS, but not sure how to generate one of those for the system program
Here, I need to pass something in from JS but it's unclear what
I.e.
Does anyone know how to pass the system program as an input to anchor?
yep doing that for now 🙂
a buffer of bytes is generally used to store strings.
hello, is there a way to generate typescript type definitions from an idl file? all I have is a bunch of `IdlTypeDef` and `IdlTypes` stuff but that's not telling me which fields are in an account
What's the best way to implement string size limits (in account data) ?
A remaining question is how to pass in the address of the system program but I think I can figure that out !
This may be a noobie question, but I've seen references to "permissionless cranks" - what exactly does this mean? Is it just a program that's on-chain running in an infinite loop and calling a contract's function each iteration?
Got it -- this all makes sense, I was confused because the generated typescript types are IDL, whereas the actual typescript types are created through some complex higher order types that accept the IDL as input
Every account you declare in the `#[derive(Accounts)]` struct has to be correspondingly passed in from the client in that rpc call
The general rule is that *any* account your program needs access to has to be passed in from the client.
Just to double check I'm reading that right, you need to make sure your actual instruction handler function matches whatever is in `#[instruction(...)]` (or at least `instruction(...)` needs to mach left-to-right up to whatever arguments you care about)
You need to `findProgramAddress` on your end and pass it as an account, so `gameAccount: theGameAccountFindProgramAddressResult`
I'm assuming the only things I need to pass in are actual accounts & stuff mentioned in `#[instruction(...)]`
<@134416332509675520> -- I guess my question is for PDAs, do I still need to generate the pub key on my end , or should I just pass in the seeds + bump into anchor
(You need to declare those `#[instruction(...)]` args to match your actual instruction functions arguments exactly, at least going left to right)
In this case it looks like you're expecting the first arg to the instruction to be the bump for the global game state (so that 0 you're passing is nearly guaranteed to be wrong)
u64 and up requires a bignum (js numbers are doubles under the hood, so they can only represent integers up to 2^53—afterwards the floating point gap is too big)
For a u8 up to u32, you can use a regular old javascript number
Accounts are always passed as pubkeys (so either a keypair's public half or a PDA, etc.)
the first argument must be a number
for example, I presume that since there's an `#[instruction(bump: u8)]`
instructions & accounts both
Which ones? The instruction function arguments?
<@!134416332509675520>  -- do you know how to determine what the types of the frontend should look like given the anchor code?
Mm, not sure, are you positive that's where the error is happening?
Ah, need to cd programs/your-prog-name and run it in there
Cargo expand doesn't seem to work on Anchor programs b/c of a virtual manifest issue?
Trying to run the tests on an Anchor program with the following code:

```
import * as anchor from "@project-serum/anchor";
const { SystemProgram } = anchor.web3;

describe("basic tests", () => {
  // Use a local provider.
  const provider = anchor.Provider.local();
```

Getting the error `TypeError: Cannot read property 'local' of undefined`. However, when I print out `anchor` variable it has the `Provider` attribute as well... Any ideas here?

Anchor.toml for reference:

```
[registry]
url = "https://anchor.projectserum.com"

[provider]
cluster = "localnet"
wallet = "~/.config/solana/localnet.json"

[programs.mainnet]
nft_candy_machine = "cndyAnrLdpjq1Ssp1z8xxDsB8dxe7u4HL5Nxi2K5WXZ"

[scripts]
test = "yarn run mocha -t 1000000 tests/"

[workspace]
members = ["nft-candy-machine"]
```
You can get pretty far by `cargo expand`-ing tiny anchor programs too, and seeing if you can follow the generated output
Yeah, that's basically what I did 😬
maybe I just need to read through the Solana rust crate?
thanks! this is really helpful -- if there's an original source where you got all your info from, i'd be happy to take a look, so I can stop sending so many questions
Haven't actually tried running that but think it should be ok 🤞
You can try doing something like this:
```.rs
// the instruction function
    pub fn transfer(ctx: Context<Transfer>, amount: u64) -> ProgramResult {
        let ix = anchor_lang::solana_program::system_instruction::transfer(
            &ctx.accounts.from.key(),
            &ctx.accounts.to.key(),
            amount,
        );

        anchor_lang::solana_program::program::invoke(
            &ix,
            &[ctx.accounts.from.to_account_info(), ctx.accounts.to.clone()],
        )
    }

// The Transfer accounts struct
#[derive(Accounts)]
pub struct Transfer<'info> {
    #[account(mut)] // mut b/c we're gonna take their money
    from: Signer<'info>, // signer b/c gonna take their money
    #[account(mut)] // mut b/c gonna give them money
    to: AccountInfo<'info>, // doesn't need to sign though
    // need to pass the system_program because we're invoking it
    // and solana is just annoying like that
    system_program: Program<'info, System>,
}
```
(thanks for all the responses by the way)
Ahh -- this does make sense. I was wondering if there's any demo code / post explaining this?
If the source account is a user, then presumably the owning program for their account is the system_program, so you have to ask the system_program to do the transfer for you, with `system_instruction::transfer` (and the source account will need to sign)
Yeah, this is slightly funny in solana because it depends on which program owns the account that needs to send you sol, because in general whenever you want to mutate an account's data or spend its money, you have to ask its owning program to do it for you.
I see a lot of things in Anchor about how to mutate data; but not how to move Sol
Thanks; another quick question: How do I actually get the user to send Sol to me? I.e in a bidding, we want the person who calls the method `bid` to place of a bid, of let's say "1 sol", and if the bid is higher than the current value, 1 sol will be debited from their account
As far as I understand it, this isn't as accessible to you in solana as it is in ethereum (would love to be corrected though). Usually what you'd do instead is have some designated `Signer<'info>` account that is the intended "do-er" of the transaction (the fact that they signed indicates they weren't just randomly passed in by the client)
I think the specific question is: How can I get the account address of whatever is calling my program? (For example, in a bidding program we might need the account address so we can store who the bidder is)
https://ethereum.stackexchange.com/questions/1891/whats-the-difference-between-msg-sender-and-tx-origin/1892
For example, Ethereum has `tx.origin` and `msg.sender` which can be used to determine who called a particular contract
Does anyone know how to get the address of the user that initiated a transaction?


//////////////////////////////////////////////////////////////////////////////////////////

What is the line I need???
How do you do an "init if not initialized before" for a PDA?
I'm executing that within a folder of a hello world anchor project I created that is not related to the mentioned program id.
No I'm just using the command line. This one is an account of the program AMM55ShdkoGRB5jVYPjWziwk8m5MpwyDgsMWHaMSQWH6

anchor idl fetch 3iHYdMqmfb9rgnUgNYNQ4WXpKT6unoGwXa1uqmghP2Am
Error: Unexpected length of input
are you doing `program.account.{accountTypeFromIDL}.fetch()`?
Hi! I'm trying to get the Layout of a on chain program I don't own. anchor idl fetch <program-id> fails with Account not found
Does anyone know if goosefx or bitsol is real or a scam I already lost on the other ones I ain tryna buy a fake token again
Can the missing IDL type definition be fixed by using bytemuck instead of borsh?
Doesn't seem to work if the struct is defined in a separate crate in the same workspace. I had it `pub` and `AnchorSerialize/AnchorDeserialize`.
I literally just had this issue. I got around it by running `cargo clean` and then building again
Has anybody seen a similar error?
```
22 | #[program]
   | ^^^^^^^^^^ could not find `panic` in `core`
```
where `core` is the name of a `pub` submodule.
```
thread 'rustc' panicked at 'Failed to get crate data for crate11', compiler/rustc_metadata/src/creader.rs:136:32
```
when compiling that dependent crate by `anchor build`.
I'm trying to use structs defined in a different crate. `cargo build` succeeds but `anchor build` fails with a Rust compiler panic when I try deriving `AnchorSerialize` and `AnchorDeserialize`. How to include type definitions from dependent crates into the IDL?
I think each team mint their own test USDC token. You can just mint anything with decimal to 6
Is there any faucet?
Anyone knows how to get USDC for testnet?
 I wanna use USDC for test but I have no idea to get it.
need help installing anchor on x64 macbook
ah, there you go, good catch
🙂
dumb me
<@!886273867293802556> you are right, I did `wallet.pubicKey.toBuffer()` and was comparing it to sollet, should have done `wallet.publicKey.toBase58()`.
hmmm weird, thank you tho 🙂
not sure what the issue could be
at a glance it looks ok to me
``` 
const web3 = require("@solana/web3.js");
const anchor = require("@project-serum/anchor");
const connection = new web3.Connection("https://api.devnet.solana.com");

const bs58 = require("bs58");

let wallet = web3.Keypair.fromSecretKey(new Uint8Array(private_key));

const provider = new anchor.Provider(connection, wallet);

console.log(wallet.publicKey);
```
hmm, yeah it should match
ennn.. <@!886273867293802556> i did it and it worked but the public key in node `console.log(wallet.publicKey)` does not match what i have in sollet ?
Thank you joebuild!
Noiceee!
```
import * as web3 from '@solana/web3.js';
const bs58 = require('bs58')

let keyIntArray = bs58.decode('MY_SECRET_KEY');
let wallet = web3.Keypair.fromSecretKey(new Uint8Array(keyIntArray));
```
edgar says ty <@!501570363566587905> we are together hehe
what an idiot
andddddd the wallet had no sol
one sec..
Im writing a script to do a tx from
are you trying to build an app or just run a quick script for something?
wallet connector for node?
oh and `fromSeed` to import a existing?
otherwise you'd either need to read from your solana config key, in your file system, or integrate a wallet connector
are you trying to import an existing wallet or just any wallet, you can create one with `const authority = Keypair.generate();`
im trying to do a tx from node
how to do import a wallet in a node script?
or would that be a different eerror
so like would this fall under that explanation? #[account(has_one=authority)]
i'm thinking maybe somehow i'm not using the wallet i'm intending to use on mainnet
hmm ya these are my two cases there then
#[account(constraint= wallet.owner == &spl_token::id() || (wallet.data_is_empty() && wallet.lamports() > 0) )]
    #[account(signer, constraint= authority.data_is_empty() && authority.lamports() > 0)]
When a `#[account(constraint = <>)]` fails
anyone know how that occurs
hitting a ConstraintRaw error
hey all
so the other programs read data from this program that isn't prod yet?
Yay ty.
Yes you can see whoever has a non zero balance for the mint.
Not if you use the localnet for testing.
hey everyone. i was wondering if there is a way to know the current holder/holders of an NFT 🤔
Or if it does some logic there itself.
Trying to see if its required to airdrop sol to myself locally before doing anchor test.
Got it :).

On a different note, do we ever need to airdrop sol to our local wallets when using `anchor test`?
If you deploy the program to devnet your friend could use it
Does program id we use w/ Anchor matter?

Like -- if I give my friend this program could he just use my id if we're working locally?

I know it needs to change upon a deploy.

```
declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");
```
Any thoughts on this? Basically this won't compile

```
pub trait BarTrait {}

#[derive(AnchorDeserialize, AnchorSerialize, Debug)]
pub struct Foo {
    pub test_field: Box<dyn BarTrait>,
}
```

but removing the `derive` and manually implementing won't include Foo in the IDL (since I guess anchor doesn't know how to serialize it in the js)

```
impl AnchorSerialize for Foo {
    fn serialize<W: borsh::maybestd::io::Write>(&self, writer: &mut W) -> borsh::maybestd::io::Result<()> {
        ...
    }
}
impl AnchorDeserialize for Foo {
    fn deserialize(buf: &mut &[u8]) -> borsh::maybestd::io::Result<Self> {
        ...
    }
}
```

I can always just split the use of `Foo` into multiple different instructions (one per possible implementation of the trait) but just wanted to see if there are alternatives to get the above to work
testing on devnet failing
Runs fines on localnet


Thank you so much!
Ahaha yes i feel you, lots of head bashing to find how to do things right now
Here 
https://project-serum.github.io/anchor/ts/classes/provider.html#send
Though about `provider.send`... I think it is documented somewhere, 1 sec
There aren't many docs around, just examples in `tests` directory and source code
I got the last line by asking right here, was bashing my head at this problem for quite some time as well.
Hi all, I'm running through the tutorial here: https://project-serum.github.io/anchor/tutorials/tutorial-0.html#clone-the-repo

I'm running the test validator in a separate container, and the tutorial code is in its own container.

When I try to deploy, it seems to send transactions, but nothing ever happens. It says the transactions are still pending and ultimately the blockhash expires and it hits the max retry limit.

Does anyone know what might be wrong?
This is great, where did you find this by the way? Are there any specific docs? Trying to find the best way to get my head around all the resources
Thank you! 🙂
Ouu thank you!
```
const txn = new anchor.web3.Transaction();
const ix = program.instruction.NAME(..);
const ix2 = program.instruction.NAME(..);
txn.add(ix);
txn.add(ix2);
 await provider.send(txn, signers);
```
Though the error message wouldn't be as nice
Do I understand correctly that this account is initialized at `pda`s address with given seeds?
https://github.com/project-serum/anchor/blob/master/tests/ido-pool/programs/ido-pool/src/lib.rs#L294
sort of, you can add instructions which happen before the content of your call
https://github.com/project-serum/anchor/blob/5d8b4765f2c5a2d0c5a26c639b10719e7b6f2fd1/tests/cfo/tests/utils/stake.js#L79-L82
Is it possible to chain multiple RPCs into one transaction?
oh maybe because i was running solana test validator at the same time in the background
Whaaa, i just did :

anchor build && anchor deploy again 

and then anchor test 

And it worked 😂 this confuses me more now lol
Yep i was thinking that and then I get this: 
mut cannot be provided with initrustc

😕
https://github.com/solana-labs/solana/blob/master/program-runtime/src/instruction_processor.rs#L442-L462 should be one of these two reasons
hm, does zero_copy_account need to be marked with `mut`?


//////////////////////////////////////////////////////////////////////////////////////////

check above, you may find this interesting. havent tested it in practice but will let u know if it works
btw this was it, i forgot to set the `space` 🙄
seems to compile at least 😄
which i only figured out because i had actually saved some messages from armani in this channel several days ago
btw i updated it to this.
```
#[account]
#[derive(Default)]
struct ManyFacedAccount {
    current: Option<State>
}
#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
enum State {
    FirstState { hi:u64 },
    SecondState { hi3:u32 }
}
```
definitely gonna take advantage of this >:)
Lol, not dum, this stuff is tricky and I happen to have a lot of free time at the moment so can study a lot 😆
so i dont forget, cause i have bad memory
thank you for talking with me about this stuff, if you cant tell im very newb and dum lol, i have this giant log of ever thing you say
not really trying to do anything, just wondering in case i did lol
So not sure what you're trying to do
You can only set the owner once I think in solana, and if your program can write data to that account then it has *already* been set to be the owner (*only* the owning program can ever write to an account)
hm, i gotcha, i guess im just thinking, how would one then go about having your anchor program create a PDA then set the owner to someone else
No, I think it's just implicit in what you're doing (one of your `#[account]` things basically has to be owned by the current program, whereas a token account has to be owned by the token program, etc.)
is there an flag to set the owner to someone else then?
It's the `#[account]` thing that says that your program should be the owner
If you do a regular `init` then yeah, but not necessarily—if you do an `init` for a token account, then the program owner is the spl token program
ohhhh yeah i forgot about this, ok. It seems then that Anchor automatically sets the owner as the derived program?
Not necessarily! https://twitter.com/pencilflip/status/1455678830262173697 Which program derived the PDA is independent of which program owns the underlying account
hmm, just thinking, i guess using the example you posted, one would set the `current` to None(), and then subsequently set it to Some(SecondState), that would accomplish what i want ig
sorry i thought thats what you meant since u said not the deriving program, but yeah the pda is owned by the derived program isnt it?
I answered my own question here kinda as you can include a new `[scripts]` script to do that
What account here is owned by the system program? I'm not even sure if its possible to store data at a system program account 🤔
What do you mean? If the account is owned by your own program, then your program can just change its data
would that mean the system program? I guess this goes back to my question of doing CPIs to the system program :/
is there a way to change the default idl location on `anchor build` ? (other than running the `--idl` flag each time I mean)
FirstState would have all its own data fields i mean, etc
(sorry i just woke up lol) so basically the enum would hold all the data fields sorta do the serialization for me, and anchor itself would just see a single `current` field?
Then you could encode three states: Some(FirstState) -> None (empty-ish) -> Some(SecondState)
Could maybe do something like
```.rs
enum State {
  FirstState { ... },
  SecondState { ... }
}
#[account]
struct ManyFacedAccount {
  current: Option<State>
}
```
Changing the data in a PDA would be the same as in any other kind of address—you'd have to have some way to ask the owning program (not the deriving program) to do the wiping.
Fwiw that error is almost always related to space in my experience
i think i might just be dumb and its something else. i actually had a serious question, it's a high level question. 
Is there a way to completely clear out the data from a PDA? What im wanting to do is have a data structure with several fields in an account, and then later use that same account for a completely different data structure
Can you post more code? No idea how references could led to that kind of error
anywhere i try to pass a reference to an account, like to a function, so i can access its data fields
`&ctx.accounts.user_account`
I get this error 😦
`164 Failed to serialize the account`
Is there something about anchor's serialization im not getting?
Thanks <@!134416332509675520> its working fine now . No need to pass the ATA from client
hmm I think I got the error... I was passing the wrong mint while initing the ATA inside the program -   associated_token::mint = mint
It should definitely work, not sure what account could be missing
Could you show the whole `rpc` invocation when you try the `associated_token::` approach?
associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID
Ah, sorry, when you tried doing that `associated_token::` stuff above, were you separately passing the ASSOCIATED_TOKEN_PROGRAM_ID as an account to your own instruction?
This is the account passing here from client

```const userTokenAccount = await Token.getAssociatedTokenAddress(
      ASSOCIATED_TOKEN_PROGRAM_ID,
      TOKEN_PROGRAM_ID,
      mint,
      payer.publicKey
    );```
yes passing that account as well
Interesting... are you passing the associated_token_program as an account? I thought anchor would error if you weren't 🤔
Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: An account required by the instruction is missing
hmm this is odd ... was trying to do the same but it was throwing the error that's why I added instruction to create ATA.
```
 #[account(
        init_if_needed,
        payer = payer,
        associated_token::mint = mint,
        associated_token::authority = payer
    )]
    pub user_token_account : Account<'info, TokenAccount>,```
You could also create the ATA within your own program and use `init_if_needed` I guess
Mm, not sure, but that would be the basic idea
so refetch and then if and else block contains the same RPC call. one with  createAssociatedTokenAccountInstruction  as instruction if it does'nt exists and other one with no instruction. Is there a better way ?
You would probably need to try fetching that account and check whether it already has an account there.
So , when I try to create ATA on a wallet it creates first time when I send the Token.createAssociatedTokenAccountInstruction as instruction but when I run again it again tries to create same which throws error of account already exists . How can I handle it ? Can I pass empty instruction if ATA exists ?
In the anchor repo
You can find a list in error.ts
Currently you have to do something kind of annoying, convert to decimal 0xa7 = 167 and then search for the decimal lol
Thanks you! I searched, but I searched for 0xa7
you can also discord search for errors you get to see what other people did
```
 Error: 167: The given account is not owned by the executing program
```
167 is an anchor error
in my case the errors are in a Enum at the end of the file, but there are 14 possible errors ... how can i identify which one is with id 167 ?
but not sure how
ok, I've patched Solana & am compiling it from source
I'm running 1.8.3
oh Mainnet - v1.8.5 Latest I think
is there a way to find out what version of solana mainnet is running on?
hmm .. maybe
then some kind of solana version mismatch could be the cause
it just sounds like if you practiced uploading on testnet and it worked, and then you tried doing it on mainnet
Is it possible to configure the number of retries?
you think I compiled my program locally w/ a different version of solana?
what seems odd is that even if this is the case, why can't I upload to mainnet?
my problem is when I do `cargo install --git https://github.com/project-serum/anchor --tag v0.18.2 anchor-cli --locked`

I have the following error
 Updating git repository `https://github.com/project-serum/anchor`
error: the given reference name 'refs/heads/' is not valid; class=Reference (4)
my guess would be that you've tried uploading with a newer or different version of solana on testnet than is currently running on mainnet
that's unlikely
no
but maybe the transactions are being out-competed?
the confusing part is it's only 200 transactions, and I know solana has massive throughput
it's usually on different versions of solana
you shouldn't use testnet for development
never tried deploying it on devnet
It deploys on testnet w/o issue
have you got it working on devnet first?
That's why I stick to answering questions in discord 😌
when you still have transactions left
& hitting retry limit exceeded  / whatever the error is
i'm very confused as to how people deploy on Solana -- I spent 2 hours last night trying to deploy
judging by the progress -- I don't think it's gonna work 😦
Haha, sick, that's definitely the nuclear option 😆 Good luck!
Update: I've tried using a dedicated Solana RPC node for the deployment, hoping that will solve the issue
Ask away (more info the better)
Hello i have a problem for installing Anchor if anyone can help me plz?
is there a way to increase the number of retries?
Hmm .. no matter what I do, I can't deploy to mainnet -- I just keep on getting "run out of retries" error
can you ask a more specific question
look at error.rs
Anyone who has a good understanding of anchor escrow program ?
Hello, I'm getting this error when calling an anchor program. Does anyone know what error 167 means ?

this is the program code: https://github.com/Moonlet/metaplex/blob/master/rust/nft-candy-machine/src/lib.rs it's a fork from metaplex, and did a change on mint_nft method.
Thank you!
Pass only this from JS  ->  { simple: {} }
```
enum Type {
  Simple,
  Interval,
}
```

And I try to pass it as 
```
      { Type: { simple: {} } },
```
Now I'm getting `unable to infer src variant` errors
Good day! How to pass a enum into an instruction handler?
I'm trying to create a new account using him
I find this import in a repository :
`const serumCmn = require("@project-serum/common");`
Does this package have any documentation?
https://github.com/solana-labs/solana/issues/19357
did you try updating your cli?
I think that's an issue with the old version
where NEW_BUFF.json is the recovered buffer
doesn't seem to do the trick
but using a command like `solana -k admin_key.json -u mainnet-beta program deploy --buffer NEW_BUFF.json target/deploy/pixels.so`
I recover the keypair
do you understand how resuming  a failed deploy works?
Ah, interesting 🤔
it will just run out of retries
What goes wrong?
& you can't really control whether the deploy suceeds
i've been trying to deploy to mainnet
on an unrelated note -- it seems like Solana deploys are hellish
i'll see if I can dig up some old code
What do you mean by program account?
Ah, sorry—the PDA wouldn't be the programId account itself (think I misunderstood what you wrote above)
well, the reason this all came about was b/c in the smart contract I had people essentially depositing money into the PDA account
And then the account gets marked is immutable I think
You deposited once when you deployed
Are you sure? I'm pretty sure you can't actually
hmm, how does that work then -- b/c I know I can deposit money to the program account
oh but you mean with not rerunning the test every time, if you're running on devnet or something
you can also init variables using `let varOne` outside the `it()` blocks and assign values to them inside the tests
thanks
Mocha has a
```.js
before(async () => {
  // do stuff once before you start running tests (only runs once)
});
```
what's the way to write test cases in mocha . I want to run certain section of script only one time (like initializing a vault) and not with every anchor test. What's the best way ?
No built-in support for JSON yet, no
I think 0x1 seems to usually be that you don't have enough money, so try airdropping yourself like 10 sol just to double check
Ah, if the key you were using was the program id, that will always point to an immutable account (not possible to request write access to it)
Has anyone run into the above error? It's when a deploy seems to succeed but the txn isn't finalized
```
Error: Deploying program failed: Error processing Instruction 1: custom program error: 0x1
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }.
```
this is ur brain on solana
https://tenor.com/view/egg-fried-egg-this-is-your-brain-on-drugs-gif-17947595
my brain
😭
that has a field called owner
the data stored in the account
but not the owner owner as in
its the account owner
god damnit
oh
`constraint = feeble_token_account.owner == user.key()`
afaik the owner would be token program not ur user key
i did your constraint and it works
its totes the owner
When I look at the transaction history
I'm getting NotOwner error code
```
pub user: Signer<'info>,
#[account(owner = user.key() @ErrorCode::NotOwner, constraint = token_account.amount == 1u64 @ErrorCode::AmountZero)]
pub token_account: Account<'info, TokenAccount>,
```
What about if there is a null in the JSON format? say struct has pub name:String, but in JSOn only has...other than the name
You can pass a struct as a parameter, which is effectively in JSON format
Nvm, all I needed was `&mint.key.to_bytes()`
Can we receive a JSON arguments? from exampe it seems only u64 or String?
https://tenor.com/view/dying-monkey-dying-gif-13123180
🙂
u are a king
thank you
ahhh
If u don't want to send , it automatically finds it and does that while creating a PDA.If you want to store the bump somewhere for later use you can do so by above approach.

 ```#[account(
        init,
        payer = owner,
        seeds = [owner.key().as_ref(), "test".as_bytes()],
        bump
    )]```
(automagically appends to the seed)
and the bump attribute is automatic?
add that as function argument for initialize call in program and to pass from client side do something like this 

If u want to pass bump you can do so by 

 ```await program.rpc.initialize(bump,"hello", {
        accounts: { 
          ...
        },
      });


 pub fn initialize(ctx: Context<Initialize>, bump: u8 ,name: string) -> ProgramResult {
   Ok(())
}
```
cus i dont see my idl generate a arg for bump
This is what it looked like before
```
      await program.rpc.initialize("hello", {
        accounts: { 
          ...
        },
      });
```
or is it in the object?
Do I do something like `program.rpc.initialize("hello", bump, ...)`
With `#[instruction(bump: u8)]`?
Yes, I believe you need to generate it on the client
if you want to store it inside the struct you can pass alongwith the function call
Do I need to generate a bump clientside?
Do you know how the bump works?
yup
<@!739012341588557895> like this?
```
base_account.posts.remove(id)
```
is the same?
Something like this?
`#[account(owner = user.key(), constraint = token_account.amount == 1)]`
but ya
jk
THEY
to check if he holds that token or not
I gotta do token.amount == 1?
xD
Or `#[account(owner = user.key())]`?
```constraint = token.amount == 1, 
constraint = token.owner == signer.key()```
whats ur account struct look like
welcome to my world
lol
which is at least better to deal with than the previous error
And I got: `     Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account`
(so I changed the hard-coded key in my Rust program)
<@!739012341588557895> : ok, I tried using a key that was not generated by Anchor
```
#[derive(Accounts)]
#[instruction(bump: u8)]
pub struct Initialize<'info> {
    #[account(init, seeds=[PREFIX.as_bytes(), mint], payer=payer, bump=bump)]
    state: Account<'info, State>,
    #[account(mut, signer)]
    payer: AccountInfo<'info>,
    // With the following accounts we aren't using anchor macros because they are CPI'd
    // through to token-metadata which will do all the validations we need on them.
    #[account(mut)]
    metadata: UncheckedAccount<'info>,
    #[account(mut)]
    mint: UncheckedAccount<'info>,
    mint_authority: Signer<'info>,
    update_authority: Signer<'info>,
    #[account(mut)]
    master_edition: UncheckedAccount<'info>,
    #[account(address = metaplex_token_metadata::id())]
    token_metadata_program: UncheckedAccount<'info>,
    #[account(address = system_program::ID)]
    system_program: AccountInfo<'info>,
    rent: Sysvar<'info, Rent>,
}
```

I want to generate a PDA off an NFT mint address, and I'm using code similar to the candy machine (https://github.com/metaplex-foundation/metaplex/blob/master/rust/nft-candy-machine/src/lib.rs). Given the `mint` attribute is of type `UncheckedAccount<'info>`, how do I pass it into the `seeds` for the PDA? Do I have to use a different account type instead of `UncheckedAccount`?
If I want to make sure a token account is owned by signer what constraint do i use?
maybe the key that Anchor generates for is not possible for withdrawing funds
the public key of `adminKp` is equal to my programId
but I have a suspicion
hmm thanks for working through this w/ me, that doesn't solve the issue
const keypairPath = 'xxx/xxx';
const data = fs.readFileSync(keypairPath, 'utf8');
const secretKey = Uint8Array.from(JSON.parse(data));
return web3.Keypair.fromSecretKey(secretKey);
I guess something did  not install according to plan. But what and how do I fix that
try passing ```signers: [bidder5]```
I use:
maybe the there was something going wrong with decoding the keypair
I get this error when running 'anchor build'
`BPF SDK: /Users/alexanderlupatsiy/.local/share/solana/install/releases/1.8.5/solana-release/bin/sdk/bpf
cargo-build-bpf child: rustup toolchain list -v
cargo-build-bpf child: rustup toolchain link bpf /Users/alexanderlupatsiy/.local/share/solana/install/releases/1.8.5/solana-release/bin/sdk/bpf/dependencies/bpf-tools/rust
error: not a directory: '/Users/alexanderlupatsiy/.local/share/solana/install/releases/1.8.5/solana-release/bin/sdk/bpf/dependencies/bpf-tools/rust/bin'`
But it does mean that the function code inside the contract is running at least
This returns "invalid admin key", which is exactly what I expect since `bidder5` is not the hardcoded admin
Yeah:
where `bidder2` is generated by the above function


Now I'm doing this:
did you switch to any specific keypair or just a newly generated one?
of course it fails since I'm using a different keypair, so the check for whether the signer is equal to the admin key goes wrong
then the code runs
to a different signer
if I switch from using `adminKp`
ok this is interesting ...
fine
commenting out the Signer makes it fi
if you comment out the signer account and the contents of the withdraw function, you dont get the mut violation right?
so I don't think it's an issue with `GameState`
work fine

the other instructions like:
yes, it is
is your GameState struct annotated with #[account]?
yeah, I do. it doesn't matter even if I comment out the entire withdraw function
and right now with that code you get the 'mut constraint violated'?
If so, we transfer money from the PDA (game account) to that signer
Basically:
- The key used to deploy the program is hard-coded into the program, only that key can be used to withdraw from the program to an external account
- Inside `withdraw`, we check that the given signer is the same as the key used to deploy the program

And lastly, the client code:

Here's the withdrawal func:
^ that's the account policy (will post client side code in a sec)
yep, give me one second
could you show the client side code?
as a u64
The data you're storing, you can essentially delete yes
Hi, want to ask if solana can delete a post from array? or due to blockchain nature every data is bount to be append only?
I'm pretty sure the issue must be in `try_accounts`, but I'm not sure what it could be
From looking at the expanded code in with `cargo --expand`:

```rust
        #[inline(never)]
        pub fn withdraw(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> ProgramResult {
            let ix = instruction::Withdraw::deserialize(&mut &ix_data[..])
                .map_err(|_| anchor_lang::__private::ErrorCode::InstructionDidNotDeserialize)?;
            let instruction::Withdraw { lamports } = ix;
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts =
                WithdrawPot::try_accounts(program_id, &mut remaining_accounts, ix_data)?;
            pixels::withdraw(
                Context::new(program_id, &mut accounts, remaining_accounts),
                lamports,
            )?;
            accounts.exit(program_id)
        }
```
I'm running into an interesting dilemma:

```rust
#[derive(Accounts)]
#[instruction(lamports: u64)]
pub struct WithdrawPot<'info> {
    #[account(mut, seeds = [], bump = game_account.bump)]
    game_account: Account<'info, GameState>,

    //#[account(mut)]
    //to: Signer<'info>,

    //#[account(mut)]
    //to2: AccountInfo<'info>,

    system_program: Program<'info, System>,
}
```

For some reason, if I uncomment either of the commented fields -- I get a "mut constraint" violated at runtime.
(The method itself is a stub -- all the code is commented)
It said that BorshSerialize is not satisfied
Hi, how can I add timestamp into a struct?
maybe i should use the mint address instead of the associated token account?
so
when i remove the token stuff it all works
Have you tried to send the bump with the function call?
```
> Program returned error: Cross-program invocation with unauthorized signer or writable account
> Runtime error: Cross-program invocation with unauthorized signer or writable account
```
https://explorer.solana.com/tx/5nbiTnMnEe2Fi2d7L2kFhMR8jbhx5i6TqP6Nq85ScJvngF2BPxH62i4JWVxDRfb6m7mrvfw3kC53rRsTawyQ3Gvi?cluster=devnet
What error are you getting?
Also I feel like Im missing what to do with the bump
Want to make a keymap for ("token" + token_acount.key + user.key) -> storage
lol
send help pls
```
    #[account(init, seeds = [b"token".as_ref(), token.key().as_ref(), user.key().as_ref(), ], bump, payer = user, space = 64 + 64)]
    pub storage: Account<'info, StorageAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
    #[account(constraint = user.key() == token.owner)]
    pub token: Account<'info, TokenAccount>,
````
xD
now i'm getting privilege elevation errors
god bless
Yeah I got it figured out
Did you get your wallet adapter issues sorted out? I saw some sample code for adapting between anchor and phantom wallets that I can dig up if you need
and if so, I transfer funds to the signer
(that is hard-coded into the contract)
all I do inside the actual call is check if the signer is equal to a given public key
not sure why though as it's a fairly normal account policy?

for some reason I'm getting "mut constraint violated" when I try to transfer SOL from a PDA to a non-PDA
(money = sol)
Can PDAs transfer money to other accounts?
what the hell
omg i have two different version of anchor-lang
```
The trait bound `anchor_spl::token::TokenAccount: anchor_lang::AccountDeserialize` is not satisfied

the trait `anchor_lang::AccountDeserialize` is not implemented for `anchor_spl::token::TokenAccount`
```
Give me
pub nft: Account<'info, TokenAccount>,
I thought public / private keys were both 32 bytes
When generating a keypair with `  const kp = anchor.web3.Keypair.generate()` does anyone know why `kp.publicKey.toBytes().length` is `64` instead of `32`?
basically the most basic rust shit
i add it to cargo.toml
ahh
xD
jk i tried cargo install anchor_spl and nothing
my apologies folks
nvm
lol
or whatever
do i need to cargo get it
how do i import anchor_spl lol?
i tried that i must have used the wrong shit
lmao
`new PublicKey(<string>)`
in web3 js
lol
confused how i take a string and convert it to pubkey
Is this the way to do it?
`const state = program.coder.accounts.decode('<accountName>', accountInfo.data);`?
How do I deserialize a state account on the client?
Hey frens
Hi ! I am getting this error when i run if anyone have a solution for me its like 3 days that I can't find the solution 😭 : 
cargo install --git https://github.com/project-serum/anchor --tag v0.18.0 anchor-cli --locked

Updating git repository https://github.com/project-serum/anchor
error: the given reference name 'refs/heads/' is not valid; class=Reference (4)
Any recommendation why anchor doesnt properly run further
CLI just freezes
Only x86_64 / Linux distributed in NPM package right now.
Trying globally installed anchor.
Hi all, I am trying to run anchor build on my mac and I get stuck at this portion:
I changed those lines because when I ran the test alone, it gave me a "    Error: failed to send transaction: Transaction simulation failed: Attempt to load a program that does not exist"
thank u
Hello there! Is there an example using anchor to do NFT staking (eg freeze NFT in exchange for rewards) or SPL-token staking? Thanks in advance.
I am running the tests for basic-2 tutorial and I swapped out the program line 

const program = anchor.workspace.Basic2

for the programID public key when I upload the built program to my local cluster and idl from the built json file. when I run the test, I get the following error. 

What am I doing wrong?
yep! https://cofre.so
EDIT: You can mint a sample NFT, not make one per se, would that work? or do you want to make a custom NFT?
Is there a devnet nft market place where i can quickly make an nft?
Indeed. Try it out!
https://docs.rs/solana-program/1.8.5/solana_program/pubkey/struct.Pubkey.html#method.new_from_array
Does anyone know how `pubkey::new_from_array` works. I'm assuming it takes 32 bytes of a public key (and not a private key -- i.e., it's not returning a keypair)
All accounts are rent exempt by default.
Does it happen when u init a pda
Does that get done by sending sol directly to an account?
In anchor how do I set the rent to be 2 years for an account?
Is there a way inside Rust to get the balance of a program account?
ideally if I test this on test-net, it should also be applicable on devnet & mainnet
for example: I want to code a function in my smart contract that only allows money to be withdrawn to a specific account
Is there any way to use the same address on test net & main net
Hi All,

I have a program with an associated token account that can transfer tokens to any given address. How do you enforce a payment for the transfer? For example, the user sends 1 SOL and receives 100 XYZ token. I can send 100 XYZ tokens using the code below, but how do I add a payment to the transaction. Thanks.

```
token::transfer(
  CpiContext::new(
    ctx.accounts.token_program.to_account_info(),
    token::Transfer {
      from: ctx.accounts.from_token.to_account_info(),
      to: ctx.accounts.to_token.to_account_info(),
      authority: ctx.accounts.from.to_account_info(),
    },
  ),
  100,
)?;
```
I first encountered the problem when doing https://discord.com/channels/428295358100013066/517163444747894795/915003343825408000 but then I just tried running it on a completely newly created project, created via anchor init, but there it had the same problem
I guess something did not install according to how it should have
I get this error when running 'anchor build'
`BPF SDK: /Users/alexanderlupatsiy/.local/share/solana/install/releases/1.8.5/solana-release/bin/sdk/bpf
cargo-build-bpf child: rustup toolchain list -v
cargo-build-bpf child: rustup toolchain link bpf /Users/alexanderlupatsiy/.local/share/solana/install/releases/1.8.5/solana-release/bin/sdk/bpf/dependencies/bpf-tools/rust
error: not a directory: '/Users/alexanderlupatsiy/.local/share/solana/install/releases/1.8.5/solana-release/bin/sdk/bpf/dependencies/bpf-tools/rust/bin'`
It's in the directory you call anchor test from
i'm searching for it -- can't find it
is `.anchor` in the home directory, the target directory?
If you're using `anchor test` then logs are in `.anchor/program-logs/`
Is there a way to view the log in Anchor? I.e -- if I'm using the `msg!` macro in Solana
thanks -- and when an account runs out of rent is it just made inaccessible right (not deleted off of the chain?)
3 days per epoch on average
but it's unclear how many epochs per day
you can use `solana rent <size>` to get the rent per epoch
Let's say I want to keep an account alive for e.g. 5 days. Is there a good way to determine how much Sol that account needs?
looks like it, thanks for your time
`pub fn bytes_are_curve_point<T: AsRef<[u8]>>(_bytes: T) -> bool {
    #[cfg(not(target_arch = "bpf"))]
    {
        curve25519_dalek::edwards::CompressedEdwardsY::from_slice(_bytes.as_ref())
            .decompress()
            .is_some()
    }
    #[cfg(target_arch = "bpf")]
    unimplemented!();
}`
Hmm, interesting, guess you might have to implement that logic yourself 🤔
yes
Meaning you want to specifically check that it's an actual public key, not a PDA etc.?
is there a way to check if a publickey is valid? https://docs.rs/solana-program/latest/solana_program/pubkey/struct.Pubkey.html#method.is_on_curve says not implemented when I try to use it
200k units is the default max
https://tenor.com/view/liban-jareer-monkey-monkey-dance-liban-monkey-gif-22730016
its working on devnet
my god it was local host
Just curious, why do instruction logs always say ` consumed X of Y compute units` (where X < Y) - Where is Y defined? afaik, when you call CPI, you don't specify how many compute units are available
Thank you
They might have a more satisfactory answer
You could ask in the Solana tech discord in dev support
Thanks <@!248066053161222144>, I still "use" the signer because it is the fee payer and because it needs to create some accounts. But when my program calls another program, I'd like to ensure that the program cannot use my user's signature
Unused signers are silently ignored by Solana for now
I'm not sure what happens if the AccountMeta for that account doesn't specify it as a signer
oh I see
Mm, good question—I think the answer is no but I'm actually not sure 🤔
<@!134416332509675520> Alan is it possible to "drop" the signer attribute on an account when performing CPI?
thanks for trying cqfd
~~Hey guys, I'm trying to load my idl in my nextjs app, however there is no "metadata" key in the json file. The rest is present though. Am I missing something?~~ Nevermind that. Rerunning `anchor build` fixed it.
im just going to move to devnet i guess
solana logs didnt report shizz tho
it seems to be chugging away lol
Ah, interesting. Is your local validator working ok?
```
Transaction was not confirmed in 47.26 seconds. It is unknown if it succeeded or failed. Check signature 2WRnNLgnGmKoCjsiZZeBUpARcgyKQq5JfrgvcmEwsjdDngafg6bDgMC8LcBcTvHZWWs3fm9G4eHHzfyBxdFrbsnp using the Solana Explorer or CLI tools.
```
https://tenor.com/view/dying-monkey-dying-gif-13123180
Imma try skipPreflight
unable to fetch balance changes?


Can you still not look at the balance in phantom itself?
I'm so cursed
xD
solana account XiBSBfqqwfNCHYZFnJ4Wnu2UAxqc8T3eRJpddcX4niS gets the balance
The expected one? Lol
When I do `console.log(provider.wallet.publicKey.toString());` I get an address
Basically I'm almost positive the issue is that the account you end up using as the provider.wallet doesn't have any money, but not sure why yet
What does `provider.wallet` look like after that line?
Actually I guess that should be ok
What does it actually return?
Ah, interesting, that looks a little sketchy to me the way you're calling `useAnchorWallet` 🤔
```
  <ConnectionProvider endpoint="http://127.0.0.1:8899">
    <WalletProvider wallets={wallets} autoConnect>
      <WalletModalProvider>
        <App />
      </WalletModalProvider>
    </WalletProvider>
  </ConnectionProvider>
```
```
    const provider = new Provider(
      useConnection().connection, useAnchorWallet()!, { preflightCommitment: 'processed' },
    );
```
No, you aren't even getting to that point I don't think
Is something wrong with my accounts?
```
#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, seeds = [b"seed".as_ref(), user.key().as_ref()], bump, payer = user, space = 64 + 64)]
    pub storage: Account<'info, BaseAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```
Yep
But the balance is correct?
hahahahaha
xD
and still not working
ahh its loading now
It like processes transactions but never has show the account information lol
That sounds like a problem lol
Ah. Why won't phantom load?
lol
phantom won't load
localhost
what does `solana config get` say
lol
cli
How did you check it? Like, in your phantom wallet itself?
Ok, cool, how did you decide you have that particular balance?
😛
its just localhost
Yeah, I would double check you're talking to the network you think you are (e.g. maybe the right address but the wrong cluster). If that's not the problem, then not sure what's going on
maybe the simulator thinks my balance is empty
hmm its the correct pubkey
thats a good idea mao
Can you console.log your wallet's publicKey, just to check?
On the network you're trying to use? Is that in a phantom wallet?
`Balance: 10999.99730736 SOL`
Yeah, you'd just need a base58 version of the final 32 bytes in that file
Got it -- & presumably what you need to do is take the keypair & find the  address (same thing as public key) using web3, and that's what you stick inside of `declare_id`
Mm, do you have any money in that account?
In typescript
But anchor provider doesnt accept phantom wallet.
Ever since I started trying to use useAnchorWallet
yo alan my boy you know anything bout this stuff?
Actually not sure how to do that now that I think about it
Ah, yeah, you need to edit declare_id!, but you'll also need to tell anchor where to find the keypair when you deploy
If I want Anchor to use that keypair file, I assume I need to edit `declare_id!` and do something else as well
more concretely: I do `solana-keygen new -o /some/location/on/computer`
Anyone know how to disable the transaction simulation for dev?
Well the generated key is stored in a file, right? Even if you edit `declare_id!`, (from my understanding) Anchor will not know where new generated keypair file is (for example: what if I stored it in some random location)
Oh, I was going to rephrase that. Will try smth, thx.
https://github.com/Necmttn/anchor-voting/blob/master/solana/index.ts#L19
Yeah, currently gotta edit your declare_id! :/ Anchor may automate this in the future though
I guess the question is how to tell anchor to use the generated keypair
Hmm, not sure, sorry!
But when I use `usePhantomWallet` typescript breaks for anchor
```
      let [ pdaKey ] = await web3.PublicKey.findProgramAddress([
        Buffer.from('seed', 'utf8'),
        provider.wallet.publicKey.toBuffer()
      ], programID);

      await program.rpc.initialize("Hello World", {
        accounts: {
          storage: pdaKey,
          user: provider.wallet.publicKey,
          systemProgram: SystemProgram.programId,
        },
      });
```
I keep getting `index.js:1 Transaction simulation failed: This account may not be used to pay transaction fees `
I'm confused by the difference of `useAnchorWallet` `usePhantomWallet` in the wall adapter for react.
<@166989184513343488> 
i have script to generate new keypair in my repo.
which i write in a json file. 
where i initialize the account the app. 
check 
`yarn new_deploy`
I guess if you generate a new keypair, then you can't deploy at the same program id though
oh wait, nevermind, I didn't -- but still good to know
Is there a way to either regenerate the keypair or have anchor use an existing keypair file (maybe I can just run `solana-keygen new -o target/pixels/pixels-keypair.json`), since I accidentally checked the keypair file into git ...
Hey guys last couple days,  i been spamming here. heres the give back to learners a bit.

https://anchor-voting.dapp.necmttn.com/
and open source code 
https://github.com/Necmttn/anchor-voting

i have extensive amount of test cases for things are not documented. 

Planning to add a tutorial on top of it as well. 

so let me know if is there any  other way to improve the code quality and practices. 

specially i'm looking to improve type generation bit in client side.
Just based on the rules solana has for creating accounts at addresses
So you need to be able to sign for that new address (your program id)
is there a place where we can airdrop you sol <@!134416332509675520> ? lol
Because deploying a program creates an account at your program id, which requires a signature
I see, & the reason Anchor needs to generate a keypair (instead of using the keypair at `~/.config/solana.yml) is b/c ... ?
https://tenor.com/view/monkey-dance-swag-gif-14656700
^^^
😮
ur a king cqfd
So not a PDA, because PDAs *can't* come from a keypair (they're specifically constructed to *not* be actual public keys etc., so they don't have corresponding secret keys)
The file contains a keypair (first 32 bytes are the secret key, remaining 32 are the public key)
😮
```
#[account(init, seeds = [b"some-seed".as_ref(), user.key().as_ref()], bump, payer = user, space = 64 + 64)]
```
This look right?
yes
well it can't be a PDA presumably, so I guess it's just a normal Solana address?
or is it an address that is off the curve (PDA)?
Is it just a normal Solana address?
What exactly is the keypair file generated by Anchor?
If you open up your `target/idl/` file for your program, does it know about that PoolAccount type?
Sorry, not actually sure why that's not working for you (analogous code seems to work fine for me). Are you sure you're updating your IDL etc.?
😮
Thats wacky
<@!134416332509675520>
But yeah, you could use `seeds = [ some_other_account.key().as_ref() ]` to use another account's public key (so sort of naming an auxiliary PDA after that other account)
They can be whatever you want (ultimately bytes under the hood), even an empty list []
Think of the seeds as like an array of "names" for the address, from the perspective of the program
Is seeds like an array of public keys or strings?
(How its used)?
Is there an example of that?
Anchor says, well, I need that info in order to produce a program-side signature, but you didn't provide it, so must have been a keypair address that will sign from the client
aaaa
The fact that you didn't declare `seeds = [...], bump = the_bump`
What makes it a keypair account?
If it were a PDA, then yep, the signature *can't* come from the client, so it won't be required anymore 🙂
I want it to be a PDA
In this case, because it's a keypair account, that signature has to come from the client
When you create an account in solana, the new account's address has to sign
In the idl
What makes this account a signer?
```
    #[account(init, payer = user, space = 64 + 64)]
    pub storage: Account<'info, BaseAccount>,
```
<@!609739117600833554>  -- thank you, this makes sense
<@!166989184513343488> this has steps of deployment, you can try this
(which I can find with `anchor keys list`)
I should then replace the default program id with whatever the generated one is
& it should generate a programId
I run `anchor build` for the first time
so I create my project with `anchor init`
Hmm ... let me try to get this straight
Although I suppose you could use different ones if you want
Usually you'd just use the same id for all of them, once you've got one
So if you're being careful you wouldn't need to redeploy, you'd just anchor build, see your new keypair with `anchor keys list`, correct it, then *rebuild*, then actually deploy
so presumably the program id will change depending on devnet/testnnet/localnnet as well
But yeah, this is a bit of a gotcha: you need to make sure yo *rebuild* with the correct declare_id! before you try to deploy.
The program id is generally created when you run `anchor build`, or you could create your own keypair etc.
https://github.com/buildspace/buildspace-projects/blob/main/Solana_And_Web3/en/Section_3/Lesson_1_Deploy_Program_To_Devnet.md
after I change it, do I deploy again?
Yep, gotta go change those lol 😬
presumably the program id is generated *after* you deploy though
I'm using the default `declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");`
but inside my lib.rs
hmm, when I run anchor deploy for the testnet, I get a program id like "8oRxXtj2Cd7gV3hHMb99xkKoQt9tb39qvwHncYAvjARP"
So is that because all account data is loaded when the program is executed?
D:
Can't, you actually have to pass any accounts you care about in from the client (not possible in solana to look them up dynamically in your rust program based on their address)
how do I use one of the anchor account structs with it
Like when I create a pda
How do I cast a pubkey in rust to one of the accounts?
^

How did you define `PoolAccount` in your rust program?
followed this.

But getting `TypeError: Cannot read property 'createInstruction' of undefined` error
makes sense tysm
It just won't be supported unfortunately—if you think about what you'd be storing on chain, it would be a bunch of addresses that point... to where? To the last time your rust program ran?
a bit new to functional programming to, apologies if its a rhetorical question
is there a solution to this? using Box<> somehow or its just not supported
Nope, they're addresses (exactly what they point at is slightly tricky but they're still just addresses)
Ah, no, that won't work for other reasons too (can't store a vec of references on chain, since you haven't said where the actual UserVaults are supposed to go!)
or are those the same thing
I'll do that, hehe. Another follow-up here is: Are program Ids different from addresses?
Hmm, probably, haven't run into that one before (when in doubt, can always grep the solana source 😛)
this is my code, stripped
```#[account]
pub struct ProtocolDataAccount {


    /// Vec storing user accounts
    pub user_accounts: Vec<&mut UserVault>,
}


pub fn handler(ctx: Context<InitUserVault>) -> ProgramResult {
    let user_vault = &mut ctx.accounts.user_account;

    let protocol_data_account = &mut ctx.accounts.protocol_data_account;
    protocol_data_account.user_accounts.push(user_vault);

    msg!("New User Account Created");

    Ok(())
}
```
it says that clone is not implemented for &mut UserAccount
Hmm now I'm getting "Translating error SendTransactionError: failed to send transaction: Transaction simulation failed: This program may not be used for executing instructions" -- Is this a fancy of saying I passed an invalid program id or something?
You can have a vec of references, yep
My guess is that that `user` account is paying for the initialization of your PDA, but it doesn't have any money
well in my mind, the vector would have to be Vec<&mut UserAccounts>
What do you mean by keep references alive? What goes wrong when you try?
both of these are accounts
is there a way to keep references alive on the rust side? say i make a UserAccount struct, and want to store it in a vec of Vec<UserAccounts> in another struct. is that possible?
Insufficient funds error on testnet. It gives the same outcome, although much quicker.
But the bottom version gives "Error: Simulate error: AccountNotFound"
on the bottom is basically the same thing except using a local keypair (it's a deploy script meant for prod)
on the top, is code that I run using `anchor test` to initialize my program's PDA it runs fine
Does simulation work differently than actual transactions?

Prob because "Testnet typically runs a newer software release than both Devnet and Mainnet Beta." Lemme try
I found deploying to testnet worked better generally
Hi, I'm trying to deploy a program to devnet using anchor deploy; it throws the error:
Data writes to account failed: There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }.
Any idea?
thanks, glad it's simple
Yep, it's just an account, you can even take a look at it in explorer.solana.com
Yeah, it's 10mb in general, but annoyingly if you create an account via CPI (e.g. any time you use `init` in anchor) it's only 10kb 😦
😮
an account
What exactly is a Solana wallet?
Is it like getting a reference to a account to put stuff in it?
What is the point of try_borrow_mut_data?
oh sorry ur talking about something else
isn't it 10mb?
thanks
Take a look at the chat example in the anchor tests
Do you know any example of this?
If you need a bigger account you unfortuntely need to create it in a separate instruction from the client, and it can't live at a PDA.
A single account you create via a cross-program invocation (which includes all accounts that live at PDAs) can only have that 10kb max size.
Nope
Can we create 2 `#[account(init, payer = user, space = 10240)]` in one PDA?
Why I'm doing this, because I'm getting the same `SystemProgram::CreateAccount data size limited to 10240 in inner instructions` error. So i'm trying to create 2 accounts.
You'll have to figure out some way to have an actual PoolAccount.
Nope, you're passing a fresh keypair address, so it definitely won't be a PoolAccount once it arrives in the program.
don't know if this is the correct way to pass
(Or at least, it doesn't belong to whatever program PoolAccounts are supposed to belong to)
Is that `PoolAccount` you're passing in from the client actually a PoolAccount? The error says that the account you're passing in doesn't actually belong to the program
try https://spl.solana.com/token
Getting  `Transaction simulation failed: Error processing Instruction 0: custom program error: 0xa7 ` error. 
```
#[account(mut)]
pub pool_account: Account<'info, PoolAccount>,
```
On commenting these^, everything works fine
Hello guys. What can I use to transfer an NFT in anchor?
ok -- this makes sense


//////////////////////////////////////////////////////////////////////////////////////////

ah brilliant, thank you
Yep. (Armani mentioned this in another channel https://discord.com/channels/889577356681945098/889577356681945101/905881423775412235)
`This commit does not belong to any branch on this repository, and may belong to a fork outside of the repository.`
I think I have found the issue:

https://github.com/project-serum/stake/commit/a72e59a9b263b7e083af737669f12f5e3ee1997c
thank you. let me try
Not sure why the submodule thing fails (fails for me too), but one thing you can maybe do to work around (also not sure why, but it seems to work for me): `git checkout tags/v0.13.2` and then `cargo install --path cli --locked`
Sorry if this has been asked already, but did anyone recently start running into this error when running `anchor build`? 
```
$ cargo build-bpf
BPF SDK: /Users/garfield/Developer/solana/bin/sdk/bpf
cargo-build-bpf child: rustup toolchain list -v
cargo-build-bpf child: rustup toolchain link bpf /Users/garfield/Developer/solana/bin/sdk/bpf/dependencies/bpf-tools/rust
error: not a directory: '/Users/garfield/Developer/solana/bin/sdk/bpf/dependencies/bpf-tools/rust/lib'
```

I can see there's a tar ball in the `bpf-tools/` directory, but keep getting errors when trying to unzip it. Any ideas on how to get around this?
i just forgot it's `provider.wallet.publickey` not just `provider.publickey`
can't think of any other solutions.  Maybe 0.13.2 is using an outdated JS library? The examples on Anchor is using v0.18.0
oh nevermind
I've tried `anchor.Provider.local()` and `.env()` but neither of them have a public key
weird issue, has something changed with how `provider` works?
yes, I tried but it`s same
have you tried the command from the docs with 0.13.2? That is if you are building from source.  https://project-serum.github.io/anchor/getting-started/installation.html#build-from-source-for-other-operating-systems
```
cargo install --git https://github.com/project-serum/anchor --tag v0.13.2 anchor-cli --locked
```

Hello everyone
When I install anchor 0.13.2, I got some error
Plz help me
yeah, thank you. remaining_accounts seems the right approch but I am having difficutty deserialise the data..
Or `remaining_accounts` if it's actually genuinely optional (meaning you might not even pass it at all from the client)
Not 100% this is the best path, but if an account that comes in may or may not be owned by the program, you'll have to declare it as an `AccountInfo<'info>`, not an `Account<'info, Something>`. Bit annoying since you'll then have to do all the anchor deserialization stuff yourself.
not really sure i understand your use case. what is causing the 167 error
but for public accounts, I don't want to load those PDAs because there is no restrections
I am trying to create white list functions so all the config is stored in PDAs.
<@!168868665456984065> can you please help me?
is there a way to do optional pda accounts?
to avoid  code: 167,
  msg: 'The given account is not owned by the executing program'
that struct needs to be the Accounts derived one
ah, ok, so there's no problem with a PDA containing a vec of other PDA then? Using the above example:
```
#[account]
pub struct FooBar<'info> {
    #[account(mut)]
    pub dummy_a: Account<'info, DummyA>,
    #[account(mut)]
    pub dummy_b: Account<'info, DummyB>,
}
```
(not sure if the lifetimes are needed here...)
`#[derive(Accounts)]` is used on the struct that represents the account context structure for an instruction, and `#[account]` is used on structs that represent custom data deserializations for individual PDAs
so as long as my account/struct only uses basic rust primatives, it's just `#[account]`, but when I start composing them I have to use derive?
I have a question about `#[account]` and `#[derive(Accounts)]`. The former is used for the most basic of data structure accounts, anything that includes one of these basic accounts needs to use the latter? 

from tests/composite/programs/composite/src/lib.rs
```
#[derive(Accounts)]
pub struct Foo<'info> {
    #[account(mut)]
    pub dummy_a: Account<'info, DummyA>,
}

#[derive(Accounts)]
pub struct Bar<'info> {
    #[account(mut)]
    pub dummy_b: Account<'info, DummyB>,
}

#[account]
pub struct DummyA {
    pub data: u64,
}

#[account]
pub struct DummyB {
    pub data: u64,
}
```
thanks
Ah, interesting, I tried installing with 1.54 (not nightly, just the regular 1.54 one) and it worked fine. Was about to try 1.53 😛
let me try upgrading rust
found it..It was caused by using rustc 1.54.0-nightly (f94942d84 2021-05-19) which was from before https://github.com/rust-lang/rust/pull/84717 was merged. Update your rustc.
yeh, i dunno, have you googled the error yet
right, macs
I can try with Homebrew , don't have apt-get on my mac
rustc 1.54.0-nightly (5c0292654 2021-05-11)
Also, what version of the rust toolchain are you using? `rustc --version`
```
On Linux systems you may need to install additional dependencies if cargo install fails. On Ubuntu,

sudo apt-get update && sudo apt-get upgrade && sudo apt-get install -y pkg-config build-essential libudev-dev
```
my guess is that you're missing cargo dependencies
well i would still google your error
so you got the error while trying to install anchor
ok
**** cargo install --git https://github.com/project-serum/anchor --tag v0.18.0 anchor-cli --locked
***
cargo install --git https://github.com/project-serum/anchor --tag v0.18.0 anchor-cli --locked
I didn't do anything ..lol. I only run this command on the terminal from the docs
in general just don't use strings
i would investigate why you're getting `no function or associated item named from_str found for struct proc_macro::Literal in the current scope` this error
error[E0599]: no function or associated item named `from_str` found for struct `proc_macro::Literal` in the current scope
   --> /Users/kobe/.cargo/registry/src/github.com-1ecc6299db9ec823/proc-macro2-1.0.29/src/wrapper.rs:926:38
    |
926 |                 proc_macro::Literal::from_str(repr)
    |                                      ^^^^^^^^ function or associated item not found in `proc_macro::Literal`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0599`.
error: could not compile `proc-macro2`

To learn more, run the command again with --verbose.
warning: build failed, waiting for other jobs to finish...
error: failed to compile `anchor-cli v0.18.0 (https://github.com/project-serum/anchor?tag=v0.18.0#229e335d)`, intermediate artifacts can be found at `/var/folders/9f/gl233ql12t38njn6189_5f4m0000gn/T/cargo-installg7pphp`

Caused by:
  build failed
Getting this error trying to build anchor from source so I can use it on my mac
if anything its better that the compute is larger from a dev perspective because you dont have to test two transactions
variable compute is unavoidable if you were going to init with a seperate instruction anyways and both cases have to work
also i work with don so i might be biased
https://discord.com/channels/889577356681945098/889577399308656662/900664796884639826 i think i agree with don on everything he says (not just this part but all of it lol)
Because of the variable compute?
just read up on it and I really dont recommend using init_if_needed, but maybe i am misunderstanding hwo it works lol
waow powerful
This does exist in anchor now though 😛 (`init_if_needed`)
you can write that logic and abstract it out as an endpoint if you want, but you shouldnt put it in your smart contract even if its possible lol
I was hoping to have an endpoint where the user can update information, the first time they hit the endpoint I wanted to init the account, then every other time they hit the endpoint, it just takes it as mutable
Ah ok so I have to handle that logic outside of the program?
yes you can check if the account exists by trying to fetch data related to the pub key and then init it only if the data returns nothing
Hey guys, is there a way to only init an account if it's not already initialised with #[account(init, ...)]?
Hello. I have a problem interacting on live network. 
When I try to interact with the program I deployed, I get this:
```
Translating error Error: Raw transaction j9585MCiCgGh5dKLKdKUmvyR3GV4eM5Cj1TMrtFnSR6J4wfPmGexcxFNbhGQHQCR9tREd6a6eq3EGds7cTJgHtJ failed ({"err":{"InstructionError":[0,{"Custom":167}]}})
```
I have declare_id! matched with programId and the pubkey of keypair in the target folder. 
I had no issue when I was doing this on localhost. 

This is the transaction log:
https://explorer.solana.com/tx/j9585MCiCgGh5dKLKdKUmvyR3GV4eM5Cj1TMrtFnSR6J4wfPmGexcxFNbhGQHQCR9tREd6a6eq3EGds7cTJgHtJ?cluster=devnet

Source code (fails at L72): 
https://github.com/REGO350/macroswap/blob/feature/frontend/migrations/script.ts#L72

Any help would be appreciated! 🙏

Edit: solved
<@!501570363566587905> is it possible to fund an unfunded recipient with Anchor's SPL token CPI wrapper?
I shall spread the good word to others!!!
Ty so much for taking a moment to write that out.
But fyi, rent-exempting 10mb will cost you 70 sol lol 💸 [edit: typo! not 7 sol, 70!]
The max value for `#[account(init, ...)]` stuff is currently only 10kb in solana. For accounts that you set up with a keypair in a separate instruction from the client, you can actually go all the way up to 10mb.
Setting space is basically required, yeah, especially for values that don't have any known size at compile time (no way for anchor to guess for you even in principle)
It unfortunately doesn't grow dynamically—you (currently, solana might change this) only get 1 shot to pick an ok size
Ty for trying it out locally on your end -- I was deep in string encoding stuff lol.
Yup -- you are 100% right it's a space issue. I have 320 bytes allocated.

` #[account(init, payer = user, space = 320)]`

Is it required to set `space`? Ideally it grows dynamically?

And if not, is there like a max value? 🙂
Hmm, I tried doing this locally and can store that string just fine fwiw!
Ahh yeah true 😅 . Seems like it makes sense to always pass in the bump when possible then, unless the client already has the PDA without needing to derive it.
The client actually might still have to calculate the bump, since they probably had to call `PublicKey.findProgramAddress` too 🙃
Gotcha okay. So in this case the client doesn't do any bump calculation and it just gets shifted over to the contract. Thanks you 🙂
Thanks! I tried that by also adding `#[instruction(owner: Pubkey)` and it's unable to assign Pubkey to `token::authority` because it's expecting an `AccountInfo`. I noticed that `token::authority` on a TokenAccount just sets the owner field though. Do I need to do some type of conversion here?
Yup -- so it's funny this works:

`media2.giphy.com/media/2y98KScHKeaQM/giphy.gif?cid=ecf05e47vokqn7k3kac4ybmftxejk041go4dwpit98s0fvvp&rid=giphy.gif&ct=g`

This breaks:

`https://media2.giphy.com/media/2y98KScHKeaQM/giphy.gif?cid=ecf05e47vokqn7k3kac4ybmftxejk041go4dwpit98s0fvvp&rid=giphy.gif&ct=g`
It does a lot for you, including making some choices. You have more control if you do everything yourself.
The version there tells anchor to figure out the bump on the fly. More convenient but more computationally expensive (requires calling `Pubkey::find_program_address`)
Yep, you can use e.g. `#[instruction(the_pub_key: Pubkey)]` and then access it in the `#[derive(Accounts)]` part.
Do you definitely have enough space for the string? Not sure off the top of my head why else it would fail
Also one more question - when creating a TokenAccount via `init`, is there a way to set the `token::authority` via a public key passed in through the instruction arguments as opposed to an Account?
Update -- looks like stuff i working when I lose the `//` from the `https://` lol. No idea whats going on -- some weird escape stuff?
QQ - When initializing a PDA, what's the difference between passing a `bump` through the instruction and then setting it in the constraints versus just having a bump constraint like the following?

```
    #[account(
        init,
        seeds = [b"testing123".as_ref(), test_mint.key().as_ref()],
        bump,
        payer = payer,
    )]
    pub test_account: Loader<'info, TestStruct>,
```
Not using anchor, i.e. just rust with the solana crates
Hey y'all!!

Currently trying to store a plain ole `url`  in a string on the account, but, getting a "failed to serialize account" error.

Is there something in a string like the one below that would cause such an error?

`https://media2.giphy.com/media/2y98KScHKeaQM/giphy.gif?cid=ecf05e470iwpche2qxg35om4rcssmwimn8x0zxeldb51jpd5&rid=giphy.gif&ct=g`.

I tested w/ just a string like `wow_this_is_a_string` and all was well.
compared to what?
Are there any downsides to using anchor?
Perfect. Thanks!
Anchor has a `init_if_needed` attribute, does that work?


//////////////////////////////////////////////////////////////////////////////////////////

I might check it out tomorrow (night time in my timezone) and maybe will update here
not sure how they'd define production ready but they just released a new stable version
I’m curious how it’s possible to convert to solana. Because solana is fundamentally different.
Is solang production ready? I'm not super familiar with it.
hi guys! i've been enjoying using anchor and have followed the usual tutorials for beginning solana development, but what do you guys think of solang and compiling solidity code to be used for solana? what would i be giving up using solang?
At any rate one thing you could always do is just take a look at its bytes, `await program.provider.connection.getAccountInfo(itsPubkey)`, and see what's weird about them.
Hmm, weird. I guess one way you could get that is if you made the account with one version of your program, then upgraded it/changed the structure of that account.
I'm getting a `0xa3` and haven't run into that before. Do any of you have experience with accounts failing to deserialize?
Does this help?
https://github.com/REGO350/macroswap/blob/main/programs/macroswap/src/lib.rs#L37-L73
Hi Team. I am trying to throw some errors from the Anchor contract. I have seen the sample error contract but I am not able to find a contract that can throw both ok and error for different conditions. Any samples or suggestions would be helpful.
This worked ! Thank you <@!194280119710253068>
you can use `web3.SystemProgram.transfer` for SOL
check this out https://github.com/solana-labs/solana-web3.js/blob/master/examples/send_sol.js
```async function main() {
  let tx = new web3.Transaction();
  tx.add(
    splToken.Token.createTransferInstruction(
      splToken.TOKEN_PROGRAM_ID,
      wallet.publicKey,
      to,
      wallet.publicKey,
      [],
      10
    )
  );
  tx.feePayer = FEE_PAYER.publicKey;
  await connection.sendTransaction(tx, [FEE_PAYER]);
}
```
SOL transfer should be simple, no need for token account
what's your code?
oh how do i make one? Thank you 🙏 . im trying to send sol
target wallet does not have token account
hello good devs :), im trying to transfer tokens from a node script but I'm getting this error `Transaction simulation failed: Error processing Instruction 0: invalid account data for instruction`
Here I was thinking I'd never actually use that struct
That appears to fix my problem, thank you sir 🎩
Box<Account> ?
hmm, if I comment out the Accounts struct for the instructions it's complaining about, the errors go away. I've got about 8 accounts that I'm passing to these endpoints, most with 1 or 2 constraints, surely that's not too much
:.:
but it can even be beacuse your using the wrong version of solana
this is usualyl due to local varialbes / arrays
https://brson.github.io/2021/06/08/rust-on-solana there is a lot of reasons why this could be happening
The compiling finishes fine and the program also appears to be working fine, or at least my test cases are passing, though these messages are slightly concerning. Has anyone seen this before / know what to do to get rid of them?
On another note, when I compile the program I'm working on, I'm starting to get some of these errors: 

Error: Function ZN16presale9private8_global20init_account17h30bf23b0e45e3b89E Stack offset of -4288 exceeded max offset of -4096 by 192 bytes, please minimize large stack variables
Error: Function ZN111$LT$presale..instructions..purchase..Purchase$u20$as$u20$anchor_lang..Accounts$GT$12try_accounts17he5935ce1c81ab19aE Stack offset of -4328 exceeded max offset of -4096 by 232 bytes, please minimize large stack variables
so i cant fault you
but look, if iwas a contractor and i knew this existed lmao i would use the laziest thing possible
and check before initing. I would rec doing that
we have a flag that we load up
It's hard for me to not want to use init_if_needed for my usecase, because at the moment I've just got an instruction which inits an account and doesn't trigger any other logic. So I check outside the program if it's been initialised, if it hasn't, I hit the aforementioned endpoint, otherwise I continue with the next instruction. But what you're saying makes sense to me
on the positive side it will make testing your app easier tho so if your trying to code as fast as possible maybe its a good tradeoff
the primiary use case is a security feature for when two people try to create an account on the same blockhash
yeah you are mixing init logic with transaction lgoic its kind of insane and will lead to a lot of bloat and confusion ocne your app gets bigger
Exactly what I was hoping for! <@!867369388608061470> would you not recommend using this functionality though?
Did you already tried custom errors for constraints? With custom errors it's even possible return line in code where error is happened.
I'm gonna stop using `has_one` and start manually verifying the account. The time I spent on figuring out the error is >50% of my dev time. Not worth it
hardest thing about solana is not knowing what the error is
and do some deduction once a token issued to payer
I'd like to access some data. e.g. balance
haha, yeah my rust isn't great either, do you need to do something like:
`ctx.remaining_accounts[3].to_account_info()`?
feel like something wrong with that load fun. but I have only 2 days of rust exp.



what type is your `load` function expecting
this code painiced ..
I am trying to do some type casting
ye
`ctx.remaining_accounts`
hey all, how to access an account from remaining accounts?
Program ID. Aka program address, pubkey of program..

You can first anchor build, then do
`solana-keygen pubkey ./target/deploy/{name}-keypair.json`
And put that pubkey in declare id and Anchor.toml file. Finally, rebuild the program.
what is id in `declare_id!()` ?

try `which anchor` and see if it matches that path in the screenshot

I did, but after installation the anchor version is still 0.18.2
You need the `--locked` on cargo install
I got this error
I put in the program id into the js as well
https://project-serum.github.io/anchor/tutorials/tutorial-0.html#generating-a-client
I'm following this exactly and I get this error when i run the command to execute the client
```
Running client.
Translating error Error: Transaction instruction index 0 has undefined program id
    at Transaction.compileMessage (/usr/lib/node_modules/@project-serum/anchor/node_modules/@solana/web3.js/lib/index.cjs.js:2455:15)
    at Transaction._compile (/usr/lib/node_modules/@project-serum/anchor/node_modules/@solana/web3.js/lib/index.cjs.js:2593:26)
    at Transaction.partialSign (/usr/lib/node_modules/@project-serum/anchor/node_modules/@solana/web3.js/lib/index.cjs.js:2725:26)
    at NodeWallet.signTransaction (/usr/lib/node_modules/@project-serum/anchor/dist/cjs/provider.js:160:12)
    at Provider.send (/usr/lib/node_modules/@project-serum/anchor/dist/cjs/provider.js:78:27)
    at processTicksAndRejections (node:internal/process/task_queues:96:5)
    at async Object.rpc [as initialize] (/usr/lib/node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:11:31)
    at async main (/home/gentle/code/solana/anchor/examples/tutorial/basic-0/client.js:22:3)
node:internal/process/promises:246
          triggerUncaughtException(err, true /* fromPromise */);
```
yea
The anchor folder is the repo of anchor-0.13.2 from git tag
so do you mean cargo install --path ./anchor/anchor/cli?
how come there is nested `anchor` directories like that? that looks like `anchor/anchor/cli`, in which case you'd need `--path ./anchor/anchor/cli` for the cargo install

yes
do you have the right tag checked out?
it succeed to build, but the anchor version is still 0.18.2
let me try
`--path ./anchor/cli` i think you want, if you are trying to build the cli (and that path is correct)
how could i resolve this issue?

Hello everyone
Thanks guys!
Interesting…
I’m using v 0.17 for this
<@!220983109573804032> how did you write a command?
I got this error again

this sometimes pops up when you pass in an uninited account
what version of anchor are you using
Error: 162: 8 byte discriminator did not match what was expected
Has anyone seen this error before/ knows what it means?
thank you
got it
yep
so the --path is local path?
it was mentioned here: https://discord.com/channels/889577356681945098/889702325231427584/905879244507344956
how can i build from source?
would you like to tell me more detail?
yes by checkout out the tag branch and building from source
Yea... it took me 30 mins of experimenting, but I figured it out
sounds like a rust issue. maybe cast them and use floor/ceiling
It keeps erroring at the line I try to divide two i64s as f64s, then round them into an i64 again...
Why does Anchor really not want me to divide two i64s and round them into an i64??????
Alan telepathically caught the error
Yes... I miswrote one of my account constraints
referring to these, I believe, innit? https://project-serum.github.io/anchor/tutorials/tutorial-2.html#clone-the-repo
That was the problem...
Thanks!
There's some `constraint = ...` that failed
What does it mean that a raw constraint was violated??? Am I trying to make Solana do too much?
<@!220983109573804032> have you resolved your issue?
<@!220983109573804032> hello


//////////////////////////////////////////////////////////////////////////////////////////

thanks
sorry guys 😫
Thanks <@!134416332509675520> , it works now! 🙌
Not sure why this happens (I don't use the npm anchor-cli package), but I think you'll have to go change those dependencies in you Cargo.toml to be `0.18.0`, don't think there's actually any 0.18.2 version yet :/
Time to disable @core dev usage?
while running anchor test
my system is x86_64 linux getting this error pls help <@&889579250720575488>
Hmm, not sure if anyone on the core team develops with windows :/ Not sure what's happening there. Will have to wait and see if any windows users on the discord can help out!
Hi, i was following building solana with _buildspace, i run this command 
cargo install --git https://github.com/project-serum/anchor --tag v0.18.0 anchor-cli --locked

but it throw me this error
If you're on mac, you should actually uninstall that npm package (`npm uninstall -g @project-serum/anchor-cli` I think), and instead install things directly with cargo: https://project-serum.github.io/anchor/getting-started/installation.html#build-from-source-for-other-operating-systems
Hey folks, would really appreciate some help with this:
```❯ anchor --version
Only x86_64 / Linux distributed in NPM package right now.
Trying globally installed anchor.
Globally installed anchor version is not correct. Expected "anchor-cli 0.18.2", found "anchor-cli 0.18.0".```
I found this issue, not sure what the fix is: https://github.com/project-serum/anchor/issues/972
OS: MacOS Catalina
Is there a way to fetch all the events emitted using emit! by a program similar to web3 fetchEvents?
is there a more in depth docs around Anchor macros, etc?
Not really sure how it worked. But I'm happy 🥳
And when I plugged that new programID into the Anchor.toml file, the `anchor test --skip-local-validator` thing passed
That command generated a new programID
I ran `anchor test --skip-local-validator` while running `solana-test-validator` in a separate tab
Sorry for bothering you again
Should change Anchor.toml to match it.
Can also run `anchor keys list`, which will tell you what id the program would get deployed at
Is that the ID you expect to be running the program at? When you deployed, what did it say?
Oh, derp, sorry haven't had enough coffee yet—right, that's expected, it gets set by the Anchor.toml file 😛
Hmm this is returning the same programID that is in the Anchor.toml file 🥲
Whoops, sorry, `console.log(program.programId.toString())`
Should I change the ID in the program and Anchor.toml to the ID i received using `program.programID`?
And my Anchor.toml is configured as such:
Ok, `console.log(program.programId) is giving me this image
Ok, let me check that and get back to you.
One possibility is that the id in your `Anchor.toml` file doesn't match the actual deployed program id (you unfortunately have to make these match manually, it's annoying for the moment)
One thing you can do to debug is to `console.log(program.programId)`, just to double check what id you're trying to talk to
It's weird because I haven't written a single line of code yet and running the default test case on the default anchor code 😦
Even when I use the skip local validator flag such as `anchor test --skip-local-validator`, I am getting this error
Hey folks, I was trying out Nader Dabit's beginner Anchor guide (https://dev.to/dabit3/the-complete-guide-to-full-stack-solana-development-with-react-anchor-rust-and-phantom-3291) and I have installed anchor, solana cli, node etc, run the local validator (using solana-test-validator) and run `anchor init mysolanaapp` (the --javascript flag was throwing an error) after that I ran anchor build for the default project that I got and then running `anchor test` is giving me the error show in the image
`anchor build` runs `cargo build-bpf`, plus generates the IDL/typescript stuff. There's also the optional verifiable build stuff that I don't know much about yet.
what is the difference between doing cargo build and anchor build? What all additional sugar does anchor build bring?
Roger that, ty so much for the snippet :). 

And yes, send SOL from one user to another! Appreciate yah ❤️
If the source account is owned by the program itself though, then the program has to send the lamports itself (can't ask the system_program to do it, because the system_program doesn't own the account!): https://discord.com/channels/889577356681945098/889702325231427584/896907918727868476
```.rs
#[derive(Accounts)]
pub struct SendSol<'info> {
    #[account(mut)]
    from: Signer<'info>,
    #[account(mut)]
    to: AccountInfo<'info>,
    system_program: Program<'info, System>,
}
```
How you send sol depends on which program owns the source account. If the account is a user's wallet, it's presumably owned by the system_program, so you have to ask the system_program to do the transfer for you:
```.rs
    pub fn send_sol(ctx: Context<SendSol>, amount: u64) -> ProgramResult {
        let ix = anchor_lang::solana_program::system_instruction::transfer(
            &ctx.accounts.from.key(),
            &ctx.accounts.to.key(),
            amount,
        );
        anchor_lang::solana_program::program::invoke(
            &ix,
            &[
                ctx.accounts.from.to_account_info(),
                ctx.accounts.to.to_account_info(),
            ],
        )
    }
```
Do you mean send sol from one user to another, via a program? Or have a program send some sol to a user? (So, sol that is managed by the program itself.)
Would anyone perhaps have a snippet from the docs of how to send SOL to another user via a program :)? I see a bunch of examples of diff programs in the github repo -- but, tryna find a basic way to implement sending SOL!


//////////////////////////////////////////////////////////////////////////////////////////

Not what I prefer
It works.
Yes, I did. For now I just created a new "baseaccount" keypair so I'm restating with a new account.
Also curious though. if you find the answer let me know!
Did you update the IDL for the client application?
Do I have to take special care when I upgrade a program that is redeployed with the same ProgramId ?
Ok. Stuck again a bit further 🙂
I changed the `ItemStruct` structure in my Solana program to add a "vote" member (i64)
I redeployed my program to the devnet
And now this is what I see in my frontend console.
Got it (after searching the Discord) : 
```javascript
  it('Updates a GIF', async() => {
    // Vote { Up, Down } is mapped using { up: {} } or { down: {} }
    await program.rpc.updateItem(new anchor.BN(0), { up: {} }, {
      accounts: {
        baseAccount: baseAccount.publicKey,
      }
    });

    let account = await program.account.baseAccount.fetch(baseAccount.publicKey);
    let gifs = account.gifList;
    assert.ok(gifs[0].votes.eq(new anchor.BN(2)));
  });
```
Hi. Do you know how to access program enums from Javascript ?
```rust
...
  pub fn update_item(ctx: Context<UpdateItem>, index: u64, vote: Vote) -> ProgramResult {
    let base_account = &mut ctx.accounts.base_account;

    let i = index as usize;
    if i < base_account.gif_list.len() {
      let mut item = &mut base_account.gif_list[i];
      item.votes += vote as i64;
    }

    Ok(())
  }
...
#[derive(Debug, Copy, Clone, AnchorSerialize, AnchorDeserialize)]
pub enum Vote {
  Down = -1,
  Up   =  1,
}

```
How to call this update_item() function from Javascript ?
can anyone take a look at this whenever possible? Trying to follow the Anchor docs' example but it's not working
want my program to have a vanity program id, so it's easy to spot 🙂
how do you deploy an anchor project to a pre-grinded account?
What am I doing wrong?
Hello, I setup a new project via anchor init and ran anchor test which gives me this error:
deploying first doesn't change things. i am on an m1 mac, pretty sure i'm having this issue but unsure how to solve it: https://github.com/project-serum/anchor/issues/876
you might wanna try to change everything to devnet, and try again. also for the M1 chip i need to deploy the program first, change the address in anchor.toml and then run the tests. not sure if this is sth you need to do too
are you using an M1 chip?
yup it's all set to localnet. the program id i left unchanged from anchor init as this is a fresh repo (i've made no changes to code, just trying to get anchor working)
have you checked if youre delpoying to the right testnet / devnet cluster? also have you double checked that you input the right program id into anchor.toml?
trying anchor init and anchor test on a brand new repo i am getting:
```     Error: failed to send transaction: Transaction simulation failed: Attempt to load a program that does not exist
```
thoughts?
does anyone have any good userguides on writing solana program with multiple contracts? i.e. cross-program invocation? I wonder about best-practices, and about things like (1) whether I would have multiple projects spun out, or (2) if I would have multiple files next to each other and (3) if there is a way to deploy them all together. would appreciate any pointers a lot! 🙂
try running solana-test-validator in another terminal
Hi folks, i am come from buildspace course "Build a Web3 app on Solana with React and Rust" section 2. and when i try to "anchor test" in anchor test part. it gives me this error? try to google this thing but no luck. any tips?
I’ll try this and report back
That is EXACTLY what I'm after thank you so much!
https://www.brianfriel.xyz/understanding-program-derived-addresses/
create a PDA with the seed being the user's wallet address
Hello! Not sure if this question fits here or not:

I'm trying to recreate the concept of a user-profile. A user connects their wallet and initialises an account with some details.  'Signing in' from this point forwards just requires the same wallet that was used to create the account.

Creating accounts is pretty straight-forward, but I am struggling with retrieving the account that was created using a specific keypair. My current thought is that I need to generate a new keypair and pass this in along with the wallet signature somehow, but then how would I retrieve the account the next time the user comes back to the site?

Banging my head against a wall with this one. Any help is appreciated 🤦‍♂️
i had this problem earlier, symlinking form brew install location to /usr/local/lib fixed it for me
yea do you have openssl 1.1 installed?
Getting this error when trying to run anchor test: Unable to start test validator. Check .anchor/test-ledger/test-ledger-log.txt for errors.

When I open the log it shows:
dyld: Library not loaded: /usr/local/opt/openssl@1.1/lib/libssl.1.1.dylib
  Referenced from: /Users/GJ/.local/share/solana/install/active_release/bin/solana-test-validator
  Reason: image not found

Any help on how to get this sorted?
That did the trick! Thank you and <@!393352704644087811> for the help!
The default timeout is 5000ms, which might be slightly too small if your computer is struggling or something? Have seen this be an issue once before.
One thing you can also try is to increase the timeout used by `anchor test`. In your Anchor.toml file, try adding a `[test]` section:
```.toml
[test]
startup_wait = 10000
```
This issue might be useful: https://github.com/project-serum/anchor/issues/945
Checking with `lsof -i :9900` doesn't show anything (it does when I'm intentionally running `solana-test-validator`)
I am trying to create a contract where user comes to my website and if he has sepcific NFT he can mint some SPL token but he can only claim 100 at max for 1 day. Does somebody know how to approach this ?or any sample examples which I can look at
I think you'll have to stop the `solana-test-validator` if you have it running already.
Hello! I'm having some trouble with `anchor test` in Ubuntu WSL

Running `solana-test-validator` works fine, but when running `anchor test` it says `Unable to start test validator. Check .anchor/test-ledger/test-ledger-log.txt for errors.`

And the logs are just this:
```
Ledger location: .anchor/test-ledger
Log: .anchor/test-ledger/validator.log
Initializing...
```
Hmm it's already disabled in settings.
Good idea.


//////////////////////////////////////////////////////////////////////////////////////////

mainly because im not sure what exactly declare_id() does in the background
my brain is tired rn so idk the exact technical details
and so it errors out
because if you dont then the program is deployed at the new address but the placeholder one is in the lib.rs
oh, yeah, i was doing camdens and i figured out you have to do that
no the buildspaces one
camden's?
I'm following a tutorial right now that suggests running `solana address -k target/deploy/projname-keypair.json` to get the program id and then updating `Anchor.toml` and `lib.rs` with the new keypair. Anchor's terminal output/documentation implies to me that it automatically makes this switch on deploy, so that step is unnecessary. Is that correct?
so you can only pass 1000 bytes into the data byte array?
Here's some information that might be helpful for learning about how stack frames/the heap work in solana: https://docs.solana.com/developing/on-chain-programs/overview
Box is rust's way of putting something on the heap, as opposed to directly on the stack.
<@!867369388608061470> "boxing" accounts did the trick, but i still don't know what it does. can you please tell me where i can read up on it?
Let me know if showing me Cargo.toml will help at all
I've been stuck here fro quite some time. I tried adding `resolver = "2"` to my Cargo.toml, but same issue. I'm a beginner on managing cargo files, and apparently need to change something with my versions. But my Rustc, rustup, and cargo are all up to date. Haven't been able to find a solution for this. 

Came in through the Buildspace.so Solana project.
```tayyab@tayyabs-MacBook-Pro arsenalGIFBoard % anchor test     
BPF SDK: /Users/tayyab/.local/share/solana/install/releases/1.7.3/solana-release/bin/sdk/bpf
Running: rustup toolchain list -v
Running: cargo +bpf build --target bpfel-unknown-unknown --release
error: failed to download `solana-frozen-abi v1.8.2`

Caused by:
  unable to get packages from source

Caused by:
  failed to parse manifest at `/Users/tayyab/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-frozen-abi-1.8.2/Cargo.toml`

Caused by:
  feature `resolver` is required

  consider adding `cargo-features = ["resolver"]` to the manifest```
what does boxing an account do? how can it help with fixing the issue with stake frames?
it seems i have too many accounts in my context 😕  if i remove even one, it works fine... but there are only 8 accounts in the context, i wonder why it should be a problem 😕
if you want to store 10K items the way to go is probably split the data into 10K accounts 🤔
it's the first time i hear about stack frames. where can i read about it?
Thank you for that answer! Looks like I may have to do some off-chain magic to get that working the way I like! 🙂
My understanding is you get all of the accounts, no pagination (kind of surprising...)
Hello, when using ```program.account.someAccountType.all()``` does it limit how many accounts that will be fetched? If so, how do I adjust this limit so that I can do pagination?
How to do that manually? I have idl.json and want to decode buffer in web3?
Not sure anchor exposes this directly, hmm.
One way to more-or-less make a map (more-or-less) is to use program-derived addresses. A map with keys K and values V would be a bunch of program-derived addresses with seeds K and accounts V.
Hi community, does any one know how to use map with anchor on Solana program?
hi, is it possible to get layout from idl?
Hope y'all are doing well!

Im trying to store state (for about 1000-10k) items. Should I use solana Vectors / Arrays within an account struct, or is there another better way to proceed?

Any thoughts and pointers welcome! 🙂
Yeah, in general that means you blew solana's 4kb stackframe budget. You can potentially sneak around it by using some extra `#[inline(never)]` functions (to get a fresh 4kb stackframe to mess around in—the `#[inline(never)]` annotation says, no, seriously, give me a fresh stackframe).
not 100% sure but i think this error happens a bunch when you blow the stack by using a vec  /unboxed account
hi, i'm trying to transfer tokens via cpi and i get a cryptic error
`    'Program failed to complete: Access violation in stack frame 3 at address 0x200003f08 of size 8 by instruction #11953',`
is there a way i can debug it?
That worked, thanks!
Yes, just did the same!
Upgrade your nodejs
any one else facing this?
I see the same issue which was closed 12 hours ago, https://github.com/project-serum/anchor/issues/988
Hi, any one else facing "ReferenceError: TextEncoder is not defined" issue when running anchor test in basics-0?
ty!
ahh so the provider wallet automatically signs, and since we've specified `user = wallet.publicKey` solana makes the connection between those two.
the signer is handled at the start when you create an anchor Provider  at the beginning
Quick q about the "Arguments and Accounts" tutorial, we initialize ```#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 8 + 8)]
    pub my_account: Account<'info, MyAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}```
But when  we call the `rpc.initialize` instruction we only sign with `signers: [myAccount],` where ```const myAccount = anchor.web3.Keypair.generate();
```
Since the `user` is the payer don't we also need to sign with the `user`? Or is this something handled for us by anchor?
Thank you soooo muchhh !!!!!!!!!!!!
As cqfd said seems like transactions are limited in size. Read this: https://docs.solana.com/proposals/transactions-v2#other-proposals (it's an accepted but not implemented proposal I believe). I thought about splitting my base64 string into multiple parts and creating multiple transactions from the frontend to later on union them in the program. The only problem with this is that it would be annoying for the user to approve multiple transactions 😦 I don't know if there is a way to approve multiple transactions in one single time 🤔
You can get the connected wallet's address with `window.solana.publicKey`, and then can go fetch its account info with a solana web3 connection, `await connection.getAccountInfo(window.solana.publicKey)`. This includes their balance.
I would also like to know about this
hi is there a way to get the balance of the connected wallet through the window.solana or wallet object, (talking about frontend)
thanks for the reply <@!134416332509675520>
Thanks for the reply!
Only by passing the user b as one of the accounts (it's not possible in solana to have your program dynamically look up an account info based on its address—you have to pass that address in from the client so that it shows up in your program as an account)
One issue you'll run into is that transactions in solana have to be quite small, only 1232 bytes! This means that you won't be able to fit that 80kb image into a single transaction; you'll presumably have to do something like what solana program deploys do, which is carve up your program's code into lots of little ~1kb chunks and glue them together into a single account on-chain.
hey guys! nice to meet you all! I'm trying to use a program to send sol from user a to user b, I saw an example above that you can do a method that will use the signer wallet and you need the user b account info, is there a way to get the user b account info from his pubkey?
Hey people 👋  I am trying to send a base64 string image to my Solana program and I am getting "**RangeError: encoding overruns Buffer**". The string is really long (80kb or maybe more). I think this is related to buffer-layout. I am kinda new to this stuff so I was wondering if there is something from anchor that might be limiting my buffer? I see for example that here https://github.com/project-serum/anchor/blob/ec26966340729c7ce3d22509355254c7d9ee5b2a/ts/src/coder/accounts.ts#L34 there is a line which allocates only 1000 bytes and maybe this is my problem. Or maybe there is another way to send the image and my approach is entirely wrong 😅
https://www.brianfriel.xyz/understanding-program-derived-addresses/
this might help
Where is the documentation for the Anchor.toml? full description of each property and options, etc ?
i think it lists all tokens, not sure if it only takes from a specific whitelist tho..
pretty sure you can just use the solana explorer
No. On the devnet. anchor test works
hey guys, how can i check wether an account holds a particular token or not from my custom contract?
what is the `bump` variable that I always see when generating a PDA?
when tryin to build stake program using anchor getting this error
C:\Users\varun\stake>anchor build --verifiable
Error: Unable to deserialize config: missing field provider at line 1 column 1


//////////////////////////////////////////////////////////////////////////////////////////

Hello, does anyone know the best approach or have an example to deserialize a metaplex meta account in your program?
so there's no way to make a game like this on chain?
Also, I think the general approach here won't work (solana accounts are public/anyone can see the transactions your program does)
i see
but you're saying if someone knows the public key of a player, they can derive the address
the client can know his/her own key
You'll almost certainly need to be able to calculate those same PDAs from the client too, which will mean the client needs to know those secret keys
so i think i need a PDA for each player, and i want the seed to be something only the program has access to
well i'd like to make a game where everyone places a bid, but i don't want the other players to be able to see what anyone else has bid
Can you say more about why you want to do that? At first glance it sounds like a bad idea haha, but I may be misunderstanding you
is there a way to access the private key of the program itself from the runtime? i want to use it as the seed for a PDA
I want it to be like how orca/raydium show how much user/account have accumulated till that time period to harvest.
thanks Alan ^^
2 alphas in 1 answer
But at any rate, by default programs in solana are upgradeable, so you can just change the declare_id! and deploy again if you want 😛
So it's not deploying so much as `anchor build` that makes that key
`anchor build` will generate the key if it doesn't already exist, and then you can run `anchor keys list` to snag it
Something i haven't been able to figure out:
Anchor build doesn't give me a public key to use as program_id on top of my lib.. It only gives me the public key after anchor deploy, which, as I understand, makes it too late since "it's deployed" ? What am I doing wrong that i'm not getting the key after build ?
Hi if I want to write a program which talks to another program, how can I mock/use the other program in a setup with `anchor test`?
thank you very much!
So like you could calculate the space on the client, or so something like
```.rs
#[deriveA(ccounts)]
#[instruction(the_data: String)]
pub struct MyAccount {
  #[account(init, space = the_data.len() * 2, ...)]
  ...
}
```
alright, thanks for the tip, i'll try it! 👍
So yeah, technically you could do dynamic allocations
aha
Ohh, sorry, I misunderstood—you can actually specify whatever expression you want for the right-hand side of `space = `, and you can use instruction arguments too with the `#[instruction(...)]` macro
okay, so if i got it right, there is no way you can allocate space for a being initialized account on the fly, each account of the same type needs to be exactly the same length, or is there?
E.g. if you're ok with up to 100 ascii characters, then you'd need 104 bytes of room for those strings
Ah, no—I'm saying you'll have to pick an appropriate amount of space (whatever seems reasonable to you). If you try to `Default` your way out of specifying space, you'll only allocate enough for an empty string.
so just reserve 4 bytes for the length? but what about space for the data itself? does it just magically get allocated?
If you use a `String` type, you will necessarily have to specify `space`. If you try to do the `Default` approach you'll end up allocating too little. The default string is empty, and will get 4 bytes in Borsh's encoding scheme (every String gets 4 bytes at the front for its length).
so if i were to use a `String` instead of a byte array, would there be a way to allocate the space for an account on the fly (given it's being initialized by the instruction)? unfortunately i couldn't find any code examples, though i've been searching for a few hours 😕
thank you!!
ah actually i just realised i have two json files in the `./target/idl` directory with two different names, i think that could have contributed to the error somehow? 
let me try to rectify that and see if i still get this error
Right file, just higher up
No, I'm curious about the instruction part (it will have data about those accounts, which ones need to be mutable, which need to sign, etc.)
so its this you were referring to? 
`"metadata": {
    "address": "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"
  }`
0.18.0
What anchor cli version are you using? `anchor --version`
`anchor build` will stick it in the root of your project, in the `./target/idl` directory
K, yep, that looks fine too
sorry, where can i find this?
this is it: 
` #[derive(Accounts)]
pub struct StartStuffOff<'info> {
  #[account(init, payer = user, space = 9000)]
  pub base_account: Account<'info, BaseAccount>,
  #[account(mut)]
  pub user: Signer<'info>,
  pub system_program: Program <'info, System>,
}`
You can also look directly at the idl, in `target/idl`, and see which of those accounts was expected to sign
Hmm, that snippet looks fine. Can you show me the corresponding `#[derive(Accounts)]` struct?
haven't been able to find any solutions online so far and trying to ask around
is there any reason why i would have signed a tx with a 'wrong' address?
hmm i see. for context, im new to solana dev but have some experience in eth, am currently doing the buildspace project and this is how i declared my signer: 
` let tx = await program.rpc.startStuffOff({
    accounts: {
      baseAccount: baseAccount.publicKey,
      user: provider.wallet.publicKey,
      systemProgram: SystemProgram.programId,
    },
    signers: [baseAccount],
  });`
That means that you accidentally signed the tx with an address that wasn't meant to sign (maybe surprising that this would be an error, but it is)
hi all, first ping here. 
just wondering if anyone has run into an `unknown signer` error when running `anchor test`?
check the escrow example in `anchor/tests`
Would anyone have a snippet on how to send SPL token from one user to another user via program? I couldn't find any good examples on the docs
What kind of applications are you guys developing?
It can be used for anything, it makes it easy to develop programs on Solana
Is it only used for voting systems?
What are the different possibilities of anchor?
Yes you can!
Also check if the creators array has been signed
Hey GM guys! I have a beginner question. Am planning to do a mini hackathon with one of my peers this weekend. I was looking up voting systems and anchor came up. Can I use anchor to build a voting system for users who minted my tokens & allow them to vote on different projects (or parties as mentioned on the reade.me)?
What do you mean by fake here? If you know the mint its supposed to be from, you can just verify that the user is the owner of a token account with that mint, with amount = 1.
Working 👌
17, let me update it
Seems to work for me, are you on 0.18.0 for anchor?
`#[account(init, payer = user, space = 1024, constraint = false @ ProgramError::Custom(1234))]` fails to compile during macro parsing. Why?
I have tested and I know the answer for the second question (no).
How can I verify the NFT the owner holds is not fake in program ? I guess by checking the metadata on it and check the creators array ?
Asking in general.I have started writing the program so far I have achieved is transfer of SPL token from x account to y account.
(2 different questions)
Could someone point me to some examples of how to use custom error? What am I supposed to put after the '@'? Also, I have an account with `init`; if I add a `constraint` to that account and the constraint fails will the account be initialized/created?
Showing that the user owns a specific NFT amounts to submitting that token account and having the user sign with the token account's owner (that proves they own it).
What have you tried so far? Are you mainly asking about how to implement the 100/day max part, or general stuff about writing a program that interacts with the spl-token program?
I am trying to create a program where user comes to my website and if he has sepcific NFT he can claim my token which I created using spl-token create token but he can only claim 100 at max for 1 day. Does somebody know how to approach this ? or any sample examples which I can look at.
thank you!
This repo has an example of a program-controlled mint: https://github.com/cqfd/anchor-token-studies/blob/main/programs/token-studies/src/lib.rs#L34 No USDC, but you could tweak the `airdrop` instruction to first take some USDC from the user (they'd have to submit a USDC token account with the transaction and sign the tx with its authority/owner).
im looking to create a smart contract that mints a token for every usdc token given to it. anybody can point me in any direction to help with this?
There is no 0.18.2 tag, `anchor-cli` was not bumped in the repo.
my anchor cli version is latest 0.18.2 but there's no corresponding tag so???
I am trying to use solana-sdk. I put `solana-sdk = "1.8 .1"` in my cargo.toml but that causes an error with crate::sys
works, thanks. will have to learn to use search function in this discord👍
on the other end this
```
lang: Language::Rust,
```
turns into this
 ```
"lang": {
  "rust": {}
}
```
can I pass something from JS anchor as an enum to an anchor rust program? cannot seem to find a datatype for that in the JS API 
 or should i pass as a string and match it?
# showcase https://dennyssolissv.github.io/dragongif/
#showcase   https://dennyssolissv.github.io/dragongif/
Hello all, how can I write a rust function to send sol from one account to the other? Please help me with the resources.
hello all, on renaming a module, my tests start to fail because the workspace seems to be the old name. is there way to change the name of an anchor workspace?
So the enum syntax is just a little funky
It would look like
```.js
    let ix = program.instruction.whatever(new anchor.BN(123), new anchor.BN(10), { name: 'Bid'}, {
      accounts: { ... }
    });
```
unfortunately I can't at this particular example..
like
```
onst dataLayout = struct([nu64('tokens'), nu64('minTokens'), ???]);

  const data = Buffer.alloc(dataLayout.span);
  dataLayout.encode(
    {
      tokens,
      mintokens,
      side,
    },
    data,
  );

```
Can you use anchor to do so? `program.instruction.someInstruction`?
I am trying to build TransactionInstruction using JS
Hmm, not sure what you mean. Are you asking what the struct would look like in rust? I think I'm just not sure what you're trying to do
I mean, I am trying to encode/decode it using buffer layout.
yes
Do you mean how do you call it from JS?
I would appreciate if someone can tell what struct looks like when idl args are:
```
"args": [{
        "name": "tokens",
        "type": "u64"
    }, {
        "name": "minTokens",
        "type": "u64"
    }, {
        "name": "side",
        "type": {
            "defined": "Side"
        }
    }
]
```
```
{
    "name": "Side",
    "type": {
        "kind": "enum",
        "variants": [{
                "name": "Bid"
            }, {
                "name": "Ask"
            }
        ]
    }
}
```
Yeah
only place i've needed to use it is to validate the existence of a mint authority on a mint address which uses coption
and option just add 1 byte to the byte size of the generic correct?
Not actually sure when you need to use COption 🤔
Borsh handles regular Options fine as far as I know?
if an account needs to have an `Option<T>` in the data is it better to use the solana `COption` and or standard one?
Yeah. Though in fact, using the `Default` approach above amounts to calculating the space dynamically 😛 since under the hood anchor will construct an instance of your struct via `MyAccount::default()`, try serializing it with borsh, and just check how many bytes it ended up taking.
by "calculating the space manually" i meant adding `space = 8 + 32 + 32 + 256 + 8 + 8` in the account declaration, not calculating it dynamically 🙂
Right, your example above could be done statically, I just mean it's not possible in general.
i reserved 256 bytes, it ought to be enough for my needs
In general you might have to specify space manually, since for some types it's not possible to calculate a value statically (e.g. for a String—you need to pick how much space to use).
Thank you serr, yeh, hope I get to ask A f2f tmr
Anyone know where the documentation is for `Anchor.toml` and all the options?
easy peasy
```
#[account]
#[derive(Derivative)]
#[derivative(Default)]
pub struct MyAccount {
    ...
    #[derivative(Default(value = "[0u8; 256]"))]
    title: [u8; 256],
    ...
}
```
why should i bother? and by the way, i got it working with use of `derivative` crate
https://paulx.dev/blog/2021/01/14/programming-on-solana-an-introduction/
this talks about how to do it from Solana's JS client library, not sure about Anchor :/
I have idl with args for instruction data (one is enum). How to build struct in web3 (I can give example)?
sorry for bothering again, i've stumbled on another issue. i want to add a byte array to my account data, but avoid calculating space for the account manually.

after i removed `space`, i got `the trait Default is not implemented for [u8; 256]`, so i added a new struct

```
#[derive(BorshSerialize, BorshDeserialize, Clone)]
pub struct Title([u8; 256]);

impl Default for Title {
    fn default() -> Self { Title([0; 256]) }
}
```

the program code now compiles, but i get the following error `IdlError: Type not found: {"name":"title","type":{"defined":"Title"}}`

could you please give me a hint how i can proceed?
Probably stupid question

I have two RPC calls from two signers, how can I group the instructions and put them into the same call?


//////////////////////////////////////////////////////////////////////////////////////////

=======
>>>>>>> 20bea11087240cc616c020a0810cf4b960b99b41
