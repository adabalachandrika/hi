I didn't know about `getOrCreateAssociatedTokenAccount` until you posted it: this is how I've been doing it

```
  const playerMapVault = await findAssociatedTokenAddress(
    player.wallet.publicKey,
    treasureChestAccount.mints[0]
  );

  let createAccountInstruction = [];

  try {
    console.log("Already has account");
    playerMapVaultAccount = await serumCmn.getTokenAccount(
      player,
      playerMapVault
    );
  } catch (error) {
    console.log("Should create account ", error);
    createAccountInstruction = await serumCmn.createTokenAccountInstrs(
      player, 
      playerMapVault, 
      treasureChestAccount.mints[mintIndexes[MAP]], 
      player.wallet.publicKey
    );
  }
```
It just fails, I just tried lol
But program makes another ATA for Token A
User already has ATA for Token A
I wonder what happens when you try to create an ATA that already exists
Ah gotcha it makes sense then
Thanks, don't worry
Ah, I see what's happening, and unfortunately I'm not sure how windows environments work. Sorry!
Thanks, but i have the same problem
We were specifically talking about making a Pubkey into an AccountInfo within rust - long story short, you can't
We had a conversation a while ago, you cannot "get" AccountInfo that is not passed into the function
I would not use a `-` in your project name. Just call it `gifproject`
I figured it'd be better to do it within the program itself, but yeah, I couldn't really figure out a way to do it
Yeah that's what I'm doing now as well...client-side. Using the token mint to `getOrCreateAssociatedTokenAccount` for user's account
Right now I do that client side. I check if an associated account is already created, if not I pass in `serumCmn.createTokenAccountInstrs(...)`  to the `instructions: [],` parameter. I'm not sure how you'd do that within a program. You'd need to grab the account info from inside the function to test if it exists, which I don't believe you can do without passing it in. So I'd just create it client-side. Full disclosure, I could be wrong, I'm not an expert!

Check out the cashier's check example for what I mean for client-side https://github.com/project-serum/anchor/tree/master/tests/cashiers-check
Hi, I want init anchor project, but return a yarn error, but yarn is installed from npm install --global yarn, know about this?
I see anchor_spl::associated_token::create
Trying to create a new ATA for the user if they don‚Äôt already have one, OR use an existing one
Hey guys, is there something similar to getOrCreateAssociatedTokenAccount in anchor?
There are multi-sig wallets out there! But anyways, if you figure it out let me know! I'm new too
After all there is only one signer
Thanks for looking by the way.  My current theory is that they are passing a list of signers for a transfer from a multisig owner, even though it isn't multisig.  And maybe the runtime is accepting this..
That account should be a user's wallet, so i'm struggling to believe it's a multisig.  Also, if you click through on the account, the explorer doesn't say it's multisig.  (Though i'm quite new to all this, just thinking aloud).  The transaction is a listing on DigitalEyes, and they are all similar.
I'm just guessing here, but J9VbYTG7mGMoYgCGerzao4KYZMgok3XUncehuzaX7A1K has to be a multisig. and sure it can change authority if the multisig signs it, which it does
Is there a way to download a deployed .so from the chain?  I'm trying to build against the metaplex code, and I'd rather just grab their officially released bin than try to build from source
So it seems that if you are doing a 'set authority' on an account where the existing authority is multisig, then you can pass a signers array.  But none of the accounts involved in the txn above are multisig.  Authority is going from the user's wallet to a regular looking DigitalEyes account.
None of the accounts involved seem to be multisig, yet it mentions multisign in the set authority.
the last  instruction.  It's a listing on digitaleyes
it's on mainnet
3QvWUHbpDmLANUnXwVmHSmyDaNWzfx8X1xicSuAuAfMtkyTg2si3kzSBfqCXVVuwZ2cFEE5m1kTVzBgdvCaSgpuZ
want to post the tx? And what cluster it's on?
Nice.
Because I'm true to my word
Is it possible to 'set authority' on a token account to have multiple signers?  I'm looking at a transaction that seems to be doing this, but i cant find a command in spl-token that might correspond to it...
gm
Definitely will!
This is why we can't have nice things. üòâ  Be a good bloke, and tell the person who wrote it that they have this security hole if they don't already realize it.
This is what I have, but I'm not sure how to make a Wallet object, and I haven't been able to find documentation for that. Maybe there is a way in Anchor.toml to add a second test provider?

```
const getProvider = (keypair) => {
  const connection = new anchor.Connection(
    anchor.web3.clusterApiUrl('mainnet-beta'), 
    "processed"
  );
  const provider = new anchor.Provider(
    connection, 
    playerSecret.toBuffer(),
    "processed",
  );
  return provider;
}
```
Also, anyone know how to add a second provider for testing in a js anchor test?
Thanks!
That's what I kinda figured! So next time I see a 1-free mint, Imma just keep switching wallets lol! [Don't do this!]
If you're trying to enforce  a particular associated token account for your program, I *think* you can do it through a PDA.
I doubt it. That's kind of the point of the m44 standard.
Why can't I have two files with the same name in different folders? 

I'm trying to import protocol1::init and protocol2::init into `lib.rs`, but i'm getting an error like this: `note: run with RUST_BACKTRACE=1 environment variable to display a backtrace`
Hey all! How would a one-token-per-wallet work? (High level)

Right now, I have the following: 

```
    // Vaults
    #[account(
        mut, 
        constraint = &user_vault.owner == user.key &&
        &user_vault.mint == &program_vault.mint &&
        user_vault.amount == 0 &&
        get_associated_token_address(user.key, &program_vault.mint) ==             user_vault.key()
    )]
    pub player_map_vault: Account<'info, TokenAccount>,
```

Using `get_associated_token_address` I can force the amount in the user_vault is 0, which is directly tied to the user's public key. However, I know phantom spins up derivative addresses from the private key. ***Is it possible*** to enforce 1 per wallet (private key) vs 1 per public key?
... or I can just use "anchor build", and than use "solana program deploy ...", right?
yeah, I found that, but is for solana's cli
is there is any similar command for anchor? like anchor test --max-len etc
Yep, there's a `--max-len` arg to `solana program deploy` (check out `solana program deploy --help` for me)
hey can I somehow reduce that? I looked in solana's docs and, if I understood right, we spend more for deploy in order to expand our program in the future
but can I decrease amount of that "extra" sol?
no clue where it's coming from
I'm trying to run `anchor build` but I get this error:

```
thread 'main' panicked at 'called `Option::unwrap()` on a `None` value', ~/.cargo/git/checkouts/anchor-bf03d42499b9267c/a81ff88/lang/syn/src/idl/file.rs:161:73
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```
thanks!
Trying to find an example, basically just add an instruction function with the low-level solana signature, like
```.rs
#[program]
mod foo {
  pub fn your_fallback_fn(program_id: &Pubkey, accounts: &[AccountInfo], data: [u8]) -> ProgramResult {
  Ok(())
  }
}
```
ah found it if anyone is curious https://github.com/project-serum/anchor/issues/409
Don't worry, anchor has full autist support!
yes but the autist inside me cannot accept the fact that there is a way to do it and i dont know about it xD
are fallback functions documented somewhere i cannot find it on https://project-serum.github.io/anchor
thanks alan!! üôè
So ordinarily you would let anchor write the client for you too
Ah, I see‚Äîyou can technically make this work with anchor using its support for "fallback functions", but yeah, ordinarily you would have your own anchor-specific client
i mean we dont have control over the client and client currently they just send the raw data which is decoded to the instruction here https://github.com/jarry-xiao/solana-bootcamp-lectures/blob/master/echo-reference/src/processor.rs#L23. how would that work in anchor?
1.8.5
And no, that's new üòõ
Was looking in the wrong vscode window
Oh sorry
dang that is olddd
anchor itself seems to be using `1.10.0`
What version of solana_program should we use with anchor-0.20.1?
Is this the project? https://github.com/jarry-xiao/solana-bootcamp-lectures/tree/master/echo-reference
What have you tried so far? It will almost certainly work fine in anchor
That would be extremely surprising to me, so I would suggest defaulting to assuming the source of the bug is just something dumb
im curious if there is any way to implement `echo` program that was given as assignment in solana bootcamp using Anchor, bcz we dont have control over the client i am not able to figure out how to do it
Yeah, it's a pure laziness feature üôÇ
is possible use anchor library on angular component?
oooof okay good to know. Thanks for that
Speaking of dependencies -  I got bit hard by a release that got rolled back:  https://github.com/solana-labs/solana-program-library/issues/2791
I was getting weird errors because I happen to `cargo install` while 1.0.4 was released.   Even though it was rolled back, I needed to clear out my cargo caches in order for 1.0.3 to get installed.  Lost a few hours on this when I started working with tokens
Should `cargo update`  flag it as updateable?  It's not listing it even if I put --aggressive
which version do u recommend we use?
hey <@!347689664855015424> , can we use solana-program v1.8.14 (latest stable release) with the newest anchor version?
https://github.com/solana-labs/solana/releases
which is the recommended `solana-program` version to use with anchor-0.20.1?
! Thanks for letting me know.  Where's the source of truth on that? So I know what to trust in the future.  I have a VSCode extension that helps but I think it takes into account other deps which may limit.
seems like the most recent stable release is `1.8.14` tho
`solana-program = "1.8.6"` ah this is what i need (i think)
Just a check - Do you have :
```
[dependencies]
anchor-lang = "0.20.1"
anchor-spl = { version = "0.20.1" }
arrayref = "0.3.6"
solana-program = "1.8.6"
```
in your Cargo.toml
i still got this error
`error[E0433]: failed to resolve: could not find solana_program in the list f imported crates`
Ya they does the problem is sometimes I get the error and sometimes it goes through and tx happens.
yea I know but I suppose he just copied it which is why he got that error with the length
how do i import solana_program?
It's a real base58
I redacted that.
well yea you get that one because "mypubkey" isnt a pubkey
`error[E0433]: failed to resolve: could not find `solana_program` in the list of imported crates`
```
use anchor_lang::prelude::*;
use crate::types::*;
```
That's it. ` and crate::types::*`  is my own code.
im getting two errors with that line of code. Another one is: "pubkey array is not 32 bytes long: len=6rustc"
hmmm really. what are you importing?
I tried this after cqfd suggested using it, and it compiles:
`pub const INITIAL_ADMIN: Pubkey = anchor_lang::solana_program::pubkey!("mypubkey");`
not sure how to get solana_program tho XD
ahhh interesting. thanks!
yea it turns out that `pubkey` uses `::solana_program` instead of `solana_program`. This means you cannot use `anchor_lang::solana_program` and have to import the actual `solana_program`
Hmmm <@!347689664855015424>  I'm still getting an error with this:
```rust
use anchor_lang::prelude::*;
use anchor_lang::solana_program;

pub const PID: &str = solana_program::pubkey!("So1endDq2YkqhipRh3WViPa8hdiSpxWy6z3Z6tMCpAo");
```
*failed to resolve: could not find `solana_program` in the list of imported crates
not found in `solana_program::pubkey`*
Cool.  Thanks for clarifying that.
(technically, it starts from 255 downwards)
it can be yes. it's recommended to save the bump that `init` finds in the account itself so other instructions dont have to find it again.
to be clear - find_program_address would have to start searching from a bump of zero.
Otherwise, I'd love to get rid of all the bump params I send up on all my instructions! üòÑ
Isn't that a perf issue though?  Sending up the right bump would start from the correct bump rather than starting from bump = 0.
E.g. every `Account<'info, TokenAccount>` without an `init` etc. needs to be a real token account
That error can come from any `Account<'info, Whatever>`, just need to check that all of them make sense
yup
Are you sure your `declare_id!` is correct?
Interestingly, that syntax does actually work (anchor will recalculate the right bump for you)
These accounts are already initialized in previous instruction and in this instruction I just need to pass those accounts
```
#[derive(Accounts)]
pub struct Unbind<'info> {

    #[account(mut)]
    pub receiver: Signer<'info>,

    #[account(mut,  
        associated_token::mint = mint_account.key(),
        associated_token::authority = receiver,
        constraint = token_account.amount == 0, 
    )]
    pub token_account: Account<'info, TokenAccount>,

    #[account(mut)]
    pub mint_account: Account<'info, Mint>,

    #[account(
        mut,
        associated_token::mint = mint_account.key(),
        associated_token::authority = account_data.key(),        
        seeds = [receiver.key().as_ref(), token_account.key().as_ref(), BIND.as_bytes()],
        bump
    )]
    pub account: Account<'info, TokenAccount>,

    #[account(
        mut,
        close= receiver,
        constraint = account_data.owner == receiver.key(),
        constraint = account_data.token_account== token_account.key(),
        seeds = [receiver.key().as_ref(), token_account.key().as_ref(), METADATA.as_bytes()],
        bump
    )]
    pub account_data: Account<'info, MetadataInfo>,

    pub token_program: Program<'info, Token>,
}
```
Here's it reworked to use the built-in attributes.  I assume `account` has the same mint as the other token.
What's that `bump` value floating in there without a value assigned to it?  Shouldn't that be a parameter in your instruction?
K, just making sure.  Typing up something write now, one sec.
``` pub fn ubind(ctx: Context<Unbind>) -> ProgramResult { 
   // test
}```
What's your instruction declared as for unbind()
Can anyone assist ? Stuck on this for a while
Ohhh gotcha. Thanks so much paul!
it's possible that it expands to code that uses `solana_program`
pubkey! Is a member of solana_program, so i shouldnt need to import solana_program. Right?
that sounds correct. you didnt import it. only its members
```rust
use anchor_lang::prelude::*;
use anchor_lang::solana_program::*;

pub const PROGRAM_ID_MAINNET: &str = pubkey!("So1endDq2YkqhipRh3WViPa8hdiSpxWy6z3Z6tMCpAo");
```
^ This code gives me this error:

Could not find solana_program in the list of imported crates
Please post an error log etc., way easier to debug that way
hi guys im getting the error `could not compile 'anchor-cli'` when running `cargo install --git https://github.com/project-serum/anchor anchor-cli --locked --verbose` has anyone run into this issue? thanks! Edit: sorted it...
hi everyone, having problems because after running anchor test a few times all of a sudden the compute budget was maxed out. is it because the program is being upgraded everytime i run anchor test? how would i go about fixing this?
```
Error - Transaction simulation failed: Error processing Instruction 0: custom program error: 0xa7 
    Program Z22wRDLVireDZ7zngFjo3psykwet3oumYsWWaCw12eK invoke [1]
    Program log: Custom program error: 0xa7
    Program Z22wRDLVireDZ7zngFjo3psykwet3oumYsWWaCw12eK consumed 5769 of 200000 compute units
    Program Z22wRDLVireDZ7zngFjo3psykwet3oumYsWWaCw12eK failed: custom program error: 0xa7

Getting weird error 0xa7 while invoking an instruction sometimes and sometimes not.

------


#[derive(Accounts)]
pub struct Unbind<'info> {

    #[account(mut, signer)]
    pub receiver: AccountInfo<'info>,

    #[account(mut,  
        constraint = token_account.amount == 0, 
        constraint = token_account.owner == receiver.key() 
    )]
    pub token_account: Account<'info, TokenAccount>,

    #[account(mut, 
        constraint = token_account.mint == mint_account.to_account_info().key() 
    )]
    pub mint_account: Account<'info, Mint>,

    #[account(
        mut,
        constraint = account.owner == account_data.key(),
        seeds = [receiver.key().as_ref(), token_account.key().as_ref(), BIND.as_bytes()],
        bump
    )]
    pub account: Account<'info, TokenAccount>,

    #[account(
        mut,
        close= receiver,
        constraint = account_data.owner == receiver.key(),
        constraint = account_data.token_account== token_account.key(),
        seeds = [receiver.key().as_ref(), token_account.key().as_ref(), METADATA.as_bytes()],
        bump
    )]
    pub account_data: Account<'info, MetadataInfo>,

    pub token_program: Program<'info, Token>,
}


---------

await program.rpc.unbind(
      {
        accounts: {
          receiver: payer.publicKey,
          tokenAccount: token,
          mintAccount: mint,
          account: account,
          accountData: accountData,
          tokenProgram: TOKEN_PROGRAM_ID
        },
        signers: [payer]
      }
    );


```
can you share the instruction here?
Ya so calling a instruction with some params sometimes works and sometimes with same params returns 0xa7 which is weird
aah then it's wired
Yes they are same
check if the output of `anchor keys list` and `the address in declare_id!()` in lib.rs are the same
Facing some strange issue wrote a program getting 0xa7 error which means AccountNotOwnedByProgram sometimes and sometimes not.
that makes sense, thanks!
Is it fine to handle the transaction through the client?
I've used it when I run out of stack space.  Otherwise, not sure
When would you use a Box<Account<'info, T>> field versus  a Account<'info, T> field in an Accounts struct?
```rust
use anchor_lang::prelude::*;
use anchor_lang::solana_program::*;

pub const PROGRAM_ID_MAINNET: &str = pubkey!("So1endDq2YkqhipRh3WViPa8hdiSpxWy6z3Z6tMCpAo");
```
^ This code gives me this error
‚ù§Ô∏è
<:feelsgood:725150676849524856>
The former is cooler because it does the parsing at compile-time.
Or if that doesn't work (can't remember what version of solana that requires), you can be less fancy and do
```.rs
use std::str::FromStr;
Pubkey::from_str("asdasdfasdf").unwrap();
```
You can also do things like
```.rs
anchor_lang::solana_program::pubkey!("asdfasdfasdf'");
```
<@!195345150132748288> I just did:

```rust
const PHASE_TOKEN_MINT: &[u8] = "FZxUbyQ9oeFiSDaabw8KfAWACsDMQhbuxR9vm2Rh7Ewm".as_bytes();
...
    #[account(
        mut,
        constraint = x_token_mint.key.to_bytes() == PHASE_TOKEN_MINT,
    )]
    pub x_token_mint: AccountInfo<'info>,
```
figured it out ty
<:thinkcat:837225078877716511>
I got it from the anchor test code.  It looks like it's only one per `mod`
Gotcha, and you can use multiple ids?
It can be used for any pubkey.  That's a base58 wallet pubkey
right but we use that to define the program address
```
mod hardcoded_pubkey {
    use super::*;
    //hardcoded from provider wallet.  
    declare_id!("6teo1kumz6aJKcCaC4ECWsy1Ypu6DdiJnhrPbhPezWcZ");
}
```
ty
gg
lel
Yeah, it's just code.
without passing it in
can you define a pubkey in the program
Best reference is here: https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html
ah wait
so if i have
<:whoa:588192323888742414>
`#[account(address=<PubKey>)]` is what you're looking for I think
for example I only want swap to be used with Token X and Token Y, both of which have pubkeys
looks like this has been asked before and I answered myself (potentially), but there's no way to constrain an `AccountInfo` argument to be a very specific pubkey?
I see. That makes sense.  Thanks, So if you were launching something like Amazon, that's 1,000 tx/s then crap could fail, but 2 tx /sec isn't going to fail.
It's a matter of (in)efficiency because it's a matter of correctness: you just can't parallelize multiple transactions mutating the same state
Well, at some point you'll saturate the ability of the solana validators to process those transactions in a non-parallelized way
Ah, so it's a matter of efficiency, not failure?  So let's say you write the most popular thing in the world, then what is the consequence?
Right, that's what I mean by get sequenced one after the other
That implies that a transaction writing to the same address will not be parallelized.
I keep hearing conflicting reports on that.  https://solana.wiki/docs/solidity-guide/introduction/#transaction-parallelization
No, I think (I think) that one will just get sequenced after the other
If you have an account that receives funds for a store, does that mean two transactions that are trying to send that account SOL at the same time will compete, and one will fail?
hi there, does anyone have experience integrating Serum with Anchor?
Is there anyway to measure the network fee a signer will pay from within an instruction?
Haha, all good
much appreciated
one day I'll repay you for taking time to answer my stupid questions
lmao
```.rs
the_token_account.amount
```
On the program side? <:whoa:588192323888742414>
Ah, ok, you can just check a token account's balance and burn the whole amount
So my initial thought would be to simply pass the amount to the program and check the user's `uiAmount` on the client-side, but after some thought it might be better to have extensive checks in the program itself. I know that you can get the lamports of an account in `AccountInfo`, but I don't see a struct I can use to grab the amount of a specific token
What have you tried so far? How are you figuring out how many tokens to burn?
If I have a simple token swap program that burns all of token A in user's ATA, then closes user's ATA, then transfers token B to a new ATA, is there a way I can ensure that we're burning ALL of token A? (otherwise the program fails with `Error: Non-native account can only be closed if its balance is zero`)
it's the sol account receiving the rent exemption lamports
I'm assuming destination is the owner account of the token account (account)?
```
pub struct CloseAccount<'info> {
    pub account: AccountInfo<'info>,
    pub destination: AccountInfo<'info>,
    pub authority: AccountInfo<'info>,
}
```
from anchor-spl::token:
<@!134416332509675520>hi, sorry for that. Can you help me on <#889577399308656662> ? thanks
ok, thank you!
afaik no, and yes that's how solana works, gotta pass it in
There is no way around this? So I would pass it from the client and then check if has the address that I need it to be?
I found the problem... it was a dumb error lol i forgot to add the new parameter to `#[instruction]`
Can you post a github link?
from the client
This will need to be passed into the program as an account
(I think this has to do with the way rust allocates memory...?)
Why do I get `PrivilegeEscalation` error when I put bool as the first parameter of my instruction, but when I move it to the last parameter I get no error?
Hi! - how can you instantiate an AccountInfo variable that holds points to a given public key string? I am intending to make a token Transfer to a constant address. I tried sth. like 
```
let recipient = Pubkey::from_str("8yYHAqiEDJGMLGhYZWeAuhmLkPgSax3miBog6QzgKfzq").unwrap();
'
but I cannot get that one tied to an AccountInfo
isMut is the same to isWritable?
Hi everyone, i'm trying to install the `anchor-cli` using `cargo install --git https://github.com/project-serum/anchor anchor-cli --locked` . The install is hanging on the line ` Compiling anchor-cli v0.20.1 (/root/.cargo/git/checkouts/anchor-bf03d42499b9267c/17c9463/cli)`  has anyone else run into this? Thanks!
thank you
‚ù§Ô∏è
that's what i was missing...the bump
ffs
So you'd need to do `new_with_signer` using its seeds *and* bump.
On the other hand, I assume you do need to sign for ctx.accounts.swap_program in the second transfer (it's a PDA?)
You can just use `CpiContext::new`, no need to try to sign anything new
The first transfer you're doing shouldn't be using `ctx.accounts.signer.key().as_ref()` as a seed (the user should have already signed from the client)
```js
  // Initialize the token mints.
  let TOKEN_A_MINT;
  let TOKEN_B_MINT;

  it("Prepares for initialization", async () => {

    // Initialize the mints.
    TOKEN_A_MINT = await Token.createMint(
      provider.connection, 
      provider.wallet.payer,
      provider.wallet.publicKey, 
      null, 
      9, 
      TOKEN_PROGRAM_ID
    )
    TOKEN_B_MINT = await Token.createMint(
      provider.connection, 
      provider.wallet.payer,
      provider.wallet.publicKey, 
      null,
      9,
      TOKEN_PROGRAM_ID
    )

    // Create associated token account of token A for user.
    userAssociatedTokenAccount = await TOKEN_A_MINT.getOrCreateAssociatedAccountInfo(
      provider.wallet.publicKey
    )

    // Create 100 tokens for the user.
    TOKEN_A_MINT.mintTo(
      userAssociatedTokenAccount,
      provider.wallet.publicKey,
      [provider.wallet],
      100 * 10**9
    )

  })
```
This is correct, the PDA where the tokens are burning would be owned by the signer, or the user. The user is burning his own X token and receiving Y token


//////////////////////////////////////////////////////////////////////////////////////////

I was trying to create a mint in a program with a pda as the authority, but I'm getting `Cross-program invocation with unauthorized signer or writable account`. I can get this to work if the mint authority is `authority` but not `pda`.
```js
    const pda = (await anchor.web3.PublicKey.findProgramAddress(
      [Buffer.from("pda"), program.programId.toBuffer()], program.programId)
    )[0];
```
```rust
#[program]
pub mod member_nfts {
    use super::*;
    pub fn initialize(ctx: Context<Initialize>) -> ProgramResult {
        msg!("mint new token");
        let mint_to_ctx = token::MintTo {
            mint: ctx.accounts.mint.to_account_info(),
            to: ctx.accounts.token_account.to_account_info(),
            authority: ctx.accounts.pda.to_account_info(),
        };
        token::mint_to(
            CpiContext::new(ctx.accounts.token_program.to_account_info(), mint_to_ctx),
            1,
        )
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    pub authority: Signer<'info>,
    #[account(init, payer = authority, mint::decimals = 0, mint::authority = pda, mint::freeze_authority = pda)]
    pub mint: Account<'info, Mint>,
    #[account(init, payer = authority, associated_token::mint = mint, associated_token::authority = pda)]
    pub token_account: Account<'info, TokenAccount>,
```
ah that totally makes sense. I wasn't aware of teh anchor_lang::reload, thank you!
your token account is a deserialized version of the AccountInfo so it has no connection to the accountinfo data anymore and changes to it are not propagated. you can call `reload` on your account to update its deserialized data
Are token accounts not updated in the context of an instruction? Eg, I'm calling "msg!(token_account.amount)", transferring, and then calling the same msg! again to verify token amounts in my program logs. That amount is the same both before and after the transfer instruction but on the explorer, the "token balances" section shows that the transfer went through
You could always have the server sign with its own special public key (that no one else can sign for).
still work in progress but probably already the best resource for Anchor: https://book.anchor-lang.com/
Thanks <@915682383905316864> i will look into it
https://solana-cookbook-git-fork-losman0s-using-mainnet-6e845e-cookbook.vercel.app/#contributing
https://soldev.app/
Hi I am beginner in solana can someone let me know what resource i can follow
anchor version: `anchor-cli 0.21.0`
rust version: `rustc 1.58.1 (db9d1b20b 2022-01-20)`
Whenever I try to run anchor build üòê
Hi, i'm seeing: ```‚ûú  collective-multisig-contract git:(main) anchor build
thread 'main' panicked at 'Not in workspace.', cli/src/lib.rs:701:47
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace```
thx
e.g. https://www.youtube.com/watch?v=O0uhZEfVPt8 and https://twitter.com/pencilflip/status/1452402100470644739?s=20&t=-aoxCW3be0L6_lJEPWGccg and https://paulx.dev/blog/2021/01/14/programming-on-solana-an-introduction/
Do all accounts have a balance (lamports)?
Hi, guys. Could anyone help me understand the concept of accounts? Where are they stored? Where're SOLs of an account stored?
(for simple enums) I guess it's whatever, only want to make sure you check it on the instruction side.
thanks for clarifying. from calling rpc calls from ts, I send a `number` then I handle that in rust using the `FromPrimitive` trait/derive for simple `enums`, will that the way to go?
both use the word enum but the data structure if very different
rust enums can hold more complex types
no because ts enums are not tagged unions
Hi, looking at The Anchor Book (thanks for this!) I see that `enums` are represented as `{variant:{}}` in the ts side. While functionally it's fine but are ways to properly cast this to ts `enums`? or like to and int?
Bump
Hey there - a question for more knowledgeable ones

For example you got a dApp like a coinflip game. 

What if you‚Äôd do the random flip on a server side and then send the result to a contract instead of doing the random flip inside the contract directly?
Would there be any security issues?
Or if you d do parts of the operations on a server side? 

I can imagine it would open possibilities for users to send other results to the smart contract for example to alter the output
very useful to know!
totally works!!!
oh thanks!
You can do `program.account.theAccountType.all()` I think
Oh, sorry, in JS/TS?
ahhh no thanks though -- im trying to do it via javascript
There's unfortunately no way to do this within your solana program, is that what you mean?
some way to directly access  the AccountsCoder maybe?
is there like an "anchor way" to do "getProgramAccounts" ?   i'm trying to get all the accounts a program owns and parse the data but i have anchor bindings for it
i'm running the same  js package versions as on my linux box, which works fine.
I'm getting this, so wondering if it's a js or solana runtime versioning thing.  `Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 1: instruction modified the program id of an account
`
Is anyone having issues running the anchor ido-pool test on mac m1?
Hi all
Is there any devnet USDC faucet ?
anchor build command does not gave typescript types?
Thanks
https://discord.com/channels/889577356681945098/889702325231427584/941072866529673256
Hi, I have a question about `#[account(init, ..., space)]`. Is it possible dynamically setup space requirements based on instruction arguments? For example, I have a `String` in instruction arguments and I want to allocate account which has perfect size for this `String`
Where can i find documentation on Anchor.toml ?!
You can leave it blank if there is one signer which is the wallet
Thanks üôÇ
either store the pubkey or use a PDA
how do I then find that account to pass in for the increment function
If I initialize an account with an empty counter
how to check  what's the freeze authority of a token is ?
I have a slight confusion around signing: if I want to ensure that someone specific has signed a transaction, I would simply add  `Signer<'info>` in a ctx and then ensure that this account is passed in during the rpc call. But there's also a `signers` array field, do I have to pass this again or can I leave it blank?
For anyone else running into a weird issue like this, upgrade your solana version
ok, thanks and you still have to pass it in from the outside?
im gonna message you on the side so i dont dox myself to the whole chat if thats okay
Sure, I'm cqfd on github
the repo is private, can I add you as a collaborator? its gross code heh
Here's an example: https://github.com/cqfd/anchor-token-studies
thanks a lot btw
cool 1 sec
If you can post a link I can try running it on my machine, probably quicker for me to debug that way
You would need the mint authority to be some program-derived address derived from your program (that's solana's equivalent to having a program have authority over something)
I do yeah, I can alos just paste some more structs
No idea how the struct thing could relate to that‚Äîdo you have this in a github repo somewhere?
You're definitely doing something weird, since that error implies you're trying to mutate the spl token program itself ü§î
.toNumber()
is there a limit to number of fields?
I am running into this error:
`    TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA's writable privilege escalated`

Because I added another field `new_field` to my struct:
`
#[account]
#[derive(Default)]
pub struct VaultManager {
    pub mint: Pubkey,
    pub vault: Pubkey,
    pub change: Pubkey,
    pub change_ata: Pubkey,
    pub draw: i64,
    pub new_field: i64,
}`
I dont understand why adding another field to my struct would cause a CPI error like that
how can I set the authority of a mint account to be the program?
hi guys
so i've built a counter program and i'm trying to read the number of counters for a public key and im getting count: <BN: 4d2>
any help as to how to convert it to something human readable like 1 or 2?
looks like Mint accounts can have separate authorities for minting and freezing https://github.com/solana-labs/solana-program-library/blob/14952a75ba6cecf3ba66a412a2fca6afd8f6ce52/token/program-2022/src/state.rs#L16. that code must be helping to set the mint tokens authority.
no, sorry
Do you know what this piece of code does?
MintTokens,
}
pub enum AuthorityType {
#[derive(AnchorSerialize, AnchorDeserialize)]
cool good to know üôÇ
Thanks, I see some logs in there as well. This is one way:
1. start a local validator `solana-test-validator`
2. tail logs `solana logs --url localhost`
3. test without starting another local validator `anchor test --skip-local-validator`
I'm not 100% sure, but the .anchor folder has the a Test Ledger, might be worth checking?
nvm I just found this :p https://github.com/project-serum/anchor/blob/master/tests/spl/token-proxy/programs/token-proxy/src/lib.rs
G'day guys üôÇ can anyone point me to some good resources on using spl-tokens and NFTs in a solana program üôÇ
is there a way to see the logs from the local validator with `anchor test`?
you can pass the account size as an instruction argument and then put  `#[instruction(account_size: u64)]` at the top of your struct
Hello. Is there a way to dynamically set the size of an account while initialization? (smth like code in the picture)
got it, noted
Yeah, you'll need to have a real, already-initialized token account in order to send it tokens
unfortunately I'm not familiar with spl-tokens, but thanks for letting me know about something new to research. I assume yes though?
do you know if i'll need to initialize the account first before sending spl-tokens to it?
got it thanks!
Copy that. Thanks for the prompt response!
Yep, think so (the deployment cost is almost entirely about storing your `.so` file on-chain)
Question to the group: is the amount of SOL it costs to deploy on devnet match exactly the amount of SOL it would cost to deploy on mainnet? I've only tested my dApps on devnet
above is from buildspace tutorial. Highly recommend their create  solana program with react tutorial by Farza, creator of buildspace
run this script (credit Nader Dabit) to create a local keypair for a persistent account. Then istead of generating a new keypair using Keypair.generate, pull in stored keypair using the following code. Let me know if you have any questions.
so generate the keypair once using `new Keypair()` in js or `solana-keygen` cli and then you can load it using it's secret
it is possible. You can load the keypair from it's secret key `Keypair.fromSecertKey([...])`
I'm trying to reconstruct a key from a secret
I want to use one keypair consistently for tests instead of generating a new account every time
not sure what you mean
Is there a way I can generate the same user key pair for testing on devnet? I need to be able to send a spl token to the address ahead of time


//////////////////////////////////////////////////////////////////////////////////////////

the answer is yes, thx for being my rubber duck chat
Hi, is it possible to pass in an array like this `[u8; 6]` as an arg to an on chain program?
I mean I used the correct command but how come the path is not complete?
Cool, thank you boss
What should I do?
Ohhh, does that mean CpiContext::new is enough given the signer was passed in RPC?
skipPreflight says don't do any transaction simulation at all before sending your tx
what's the difference  preflightCommitment vs skipPreflight ?
Seeds are only for signing for one of your own program's derived addresses
If it's not a PDA, then you won't be able to freeze it unless it signed the tx you submitted from the client
if it's a PDA i'll just add it as signer, and pass its seeds,
but what if it isn't? what's the seed?!
Every mint has an address that acts as its authority
It's the mint authority, whatever that is (not sure if its a program-derived address or not)
Yes I think so. I run solana config get keypair and copied the path of the output
So it's the PDA of mint authority ?
You would need to sign with whoever is the authority over the mint
Bump
Gonna need to uninstall and try to do it all over again (lots of blog posts now about installing on an M1‚ÄîI do it directly from a github source checkout, not via the installer)
i switched macbooks recently
yep on an M1
Are you on a M1?
That means you haven't installed solana correctly, unfortunately
```‚ûú  crunchy-vs-smooth solana-test-validator
Ledger location: test-ledger
Log: test-ledger/validator.log
‚†ô Initializing...
[1]    47710 illegal hardware instruction  solana-test-validator```
ah shit, i was hoping to avoid that given
There's your hint :p
`Test validator does not look started`
I'm getting:

```‚ûú  crunchy-vs-smooth anchor test
BPF SDK: /Users/usr/.local/share/solana/install/releases/1.9.1/solana-release/bin/sdk/bpf
cargo-build-bpf child: rustup toolchain list -v
cargo-build-bpf child: cargo +bpf build --target bpfel-unknown-unknown --release
    Finished release [optimized] target(s) in 0.21s
cargo-build-bpf child: /Users/usr/.local/share/solana/install/releases/1.9.1/solana-release/bin/sdk/bpf/dependencies/bpf-tools/llvm/bin/llvm-readelf --dyn-symbols /Users/udr/Documents/coding/crunchy-vs-smooth/target/deploy/crunchy_vs_smooth.so

To deploy this program:
  $ solana program deploy /Users/usr/Documents/coding/crunchy-vs-smooth/target/deploy/crunchy_vs_smooth.so
The program address will default to this keypair (override with --program-id):
  /Users/udr/Documents/coding/crunchy-vs-smooth/target/deploy/crunchy_vs_smooth-keypair.json
Unable to get recent blockhash. Test validator does not look started. Check .anchor/test-ledger/test-ledger-log.txt for errors. Consider increasing [test.startup_wait] in Anchor.toml.```
```import { AccountClient, Program } from '@project-serum/anchor';
import { CrunchyVsSmooth } from '../target/types/crunchy_vs_smooth';

const assert = require("assert");
const anchor = require("@project-serum/anchor");
const { SystemProgram } = anchor.web3;

describe('crunchy-vs-smooth', () => {

  const provider = anchor.Provider.env();
  anchor.setProvider(provider);
  anchor.setProvider(anchor.Provider.env());
  const program = anchor.workspace.CrunchyVsSmooth as Program<CrunchyVsSmooth>;
  const voteAccount = anchor.web3.Keypair.generate();
  it("Initializes with 0 votes for crunchy and smooth", async () => {
    console.log("Testing initialize");
    await program.rpc.initialize({
      accounts: {
        voteAccount: voteAccount.publicKey,
        user: provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      },
      signers: [voteAccount],
    });
    const account = await program.account.voteAccount.fetch(
      voteAccount.publicKey
    );
    console.log("Crunchy: ", account.crunchy.toString());
    console.log("Smooth: ", account.smooth.toString());
    assert.ok(
      account.crunchy.toString() == "0" && account.smooth.toString() == "0"
    );
  });
});```
what's inside of `tests/crunchy-vs-smooth.ts`
hmm could be a typo or an invalid location,
did you provide an absolute path?
When I run `Anchor test` why doesn't it execute the javascript tests? I have my directory set up like so
please
Anyone?
got it, thanks
u8 between 0-255 calculated in run-time
it can then be accessed from your handler via ctx.bumps.get("my_account_name").unwrap()
on `init` it is found via Pubkey::find_program-address
does anyone know where `bump` comes from and why I don't have to pass it from the instruction?
```rust
#[derive(Accounts)]
pub struct CreateGroup<'info> {
    pub payer: Signer<'info>,
    #[account(init, payer = payer, seeds = [payer.key.as_ref()], bump, space = Group::LEN)]
```
Yo I'm running "ANCHOR_WALLET=<YOUR-KEYPAIR-PATH> node client.js", where I change <YOUR-KEYPAIR-PATH> to the path where my keypair is located, but I get this error:
 node:internal/modules/cjs/loader:936
  throw err;
  ^

Error: Cannot find module '(My path)'
    at Function.Module._resolveFilename (node:internal/modules/cjs/loader:933:15)
    at Function.Module._load (node:internal/modules/cjs/loader:778:27)
    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)
    at node:internal/main/run_main_module:17:47 {
  code: 'MODULE_NOT_FOUND',
  requireStack: []
}
I'm trying to freeze a metaplex NFT, i'm confused about the signers.
since the creator has the freeze authority, shouldn't the rpc call be signed by creator ?!
then are the seeds the same you used to derive an associated token program ?

Thank youüõ†Ô∏è 

```
    pub fn freeze_account(ctx: Context<FreezeAction>) -> ProgramResult {
        let signers_seeds = &[];    ==========> // What/Who should the signers be ?!
        match freeze_nft(CpiContext::new_with_signer(
            ctx.accounts.token_program.to_account_info(),
            FreezeAccount {
                mint: ctx.accounts.mint.to_account_info(), // Mint account
                authority: ctx.accounts.creator.to_account_info(), // Owner of Mint account
                account: ctx.accounts.nft.to_account_info(), // Metaplex ATA
            },
            signers_seeds,
        )) {
            result => {
                msg!("Account frozen ! {:?}", result)
            }
            _ => return Err(ErrorCode::FailedFreeze.into()),
        }
        Ok(())
    }
```
perfect, thanks!
Yep
You'll need it during your first deploy, which will create a solana account with that public key as its address
so all good to grind a vanity keypair and stick to that?
It's whatever your program's actual program_id is/will be
newb q... can pk in `declare_id!` be any owned keypair?
Time to see if i can get a working example then. Really appreciate the support man üöÄ
Alright üôÇ
`instructions` are pre
Think i found it üôÇ -

Are instructions handled before or after (since the pre and post aren't there yet)?
Because the signers array contains key*pairs*, not just addresses
What's preventing me from throwing whatever address into the signers argument? i.e. i'm doing `signers: [voteAccount]` here, but if I want to be malicious and do `signers: [yourAddress]`
cause in a code example this is in there
```
await program.rpc.createMultisig(owners, threshold, nonce, {
      accounts: {
        multisig: multisig.publicKey,
        rent: anchor.web3.SYSVAR_RENT_PUBKEY,
      },
      instructions: [
        await program.account.multisig.createInstruction(
          multisig,
          multisigSize
        ),
      ],
      signers: [multisig],
    });
```
I feel like i'm doing something wrong üòì
I don't see that contaning any of the "instructions"
the "doSomething" takes a IdlInstruction as input, 

```ts
export type IdlInstruction = {
  name: string;
  accounts: IdlAccountItem[];
  args: IdlField[];
};
```
hmm wait
no not either :/
Does it work with just `instructions`?
hmm my typescript checker is giving me shit for using the preInstructions though...
It would look like
```.js
await program.rpc.doSomething(arg1, arg2, {
  accounts: {
    ...
  },
  preInstructions: [
    program.instruction.doSomethingFirst(...),
  ],
  postInstructions: [
    program.instruction.doSomethingAfterwards(...),
  ]
});
```
Ah, sorry, maybe they're all still called `instructions: [...]` in the anchor repo (lots of examples of that int he tests/ directory)
Has there been any updates or solutions to the invalid blockhash error on deployment?
Any tips for making the transactions go through?

I seem to be able to deploy on devnet just fine but mainnet is giving me a lot of issues.
I can't find any examples using the preInstructions

but i assume you are thinking of using this:
```ts
export type IdlInstruction = {
  name: string;
  accounts: IdlAccountItem[];
  args: IdlField[]; //<-- this badboy
};
```

Not sure how you formulate it in that interface though x.x
```ts
export type IdlField = {
  name: string;
  type: IdlType;
};
```
thanks so much alan!!
Yep agreed ^
Alan you're the savior of this channel, i see your name daily lol
thank you so much
Yeah, usually multi-sig means something more complicated than just having multiple things sign
I'll send you the example when im on my laptop, it should explain itself ü§£
say more please
Hmm, i saw an example of multi-sig signing, it looked way more complicted than just passing two keypairs in the signers array
yeah makes sense. appreciate the detailed answer
Then on the rust side solana will say "this account that got passed in, it also signed btw"
No, signers just says sign the tx, on the js-side, with all of these keypairs
So I'm kind of not sure what type of answer you're looking for‚Äîit kinda just happens, via programming ü™Ñ‚ú®, lol
does signers get pushed into `Context<doSomething>`?
Mm... I'm trying to think how to answer that question. That all happens inside the rust program‚Äîon the JS side those arguments get encoded (via borsh) into the underlying instruction's data field (low-level solana stuff). So at the end of the day a low-level solana instruction gets built + invoked, and then on the rust side anchor deserializes those arguments + validates all the accounts (based on what you asked it to do in your `derive(Accounts)` struct)
To reframe my question, how does `program.rpc.doSomething(arg1, arg2, ...)` transform (arg1, arg2, ...) into `Context<doSomething>`?
do you know where I can find the general RPC function/method signature for anchor programs?
About `signers`, under the hood the js side will use each of those `signers` keypairs to sign the transaction.
2. Not sure if there's much to say about what's going on under the hood, the js syntax is just specifying which accounts your instruction cares about, and then in rust anchor gives you access to them.
1. Just means that the rpc argument list is actually flipped from how it looks in rust. In rust it's ctx, arg1, arg2, etc, whereas in JS its
```.js
program.rpc.doSomething(arg1, arg2, {
  accounts: {
    ...
  },
  ... // other stuff, like signers, preInstructions, etc.
});
```
Lots of examples in the anchor repo
If we have a struct that looks like so:

```
#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 16 + 16)]
    pub vote_account: Account<'info, VoteAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```

And a program RPC method that looks like:

```
pub fn initialize(ctx: Context<Initialize>) -> ProgramResult {
        let vote_account = &mut ctx.accounts.vote_account;
        vote_account.crunchy = 0;
        vote_account.smooth = 0;
        Ok(())
    }
```

In the tests we call `initialize` like so:

```
/* The last element passed to RPC methods is always the transaction options. Because voteAccount is being created here, we are required to pass it as a signers array */
    await program.rpc.initialize({
      accounts: {
        voteAccount: voteAccount.publicKey,
        user: provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      },
      signers: [voteAccount],
    });
```

1/ What is meant by "the last element passed to RPC methods is always the transaction options"? How is signers here a transaction option? 

2/ What is going on under the hood here? It looks like the first thing anchor does is wrap the input dictionary into a `Context<Initialize>` https://docs.rs/anchor-lang/0.13.2/anchor_lang/struct.Context.html - given the 3 variables on the Context wrapper are `program_id`, `accounts`, and `remaining_accounts`, it must infer `program_id` and `remaining_accounts` is empty, accounts is clearly passed in. What does it do with `signers` under the hood? What are some other "transaction options" we can pass through?

This question is referencing https://www.brianfriel.xyz/learning-how-to-build-on-solana/ tutorial.
How are you searchign?
I'm not finding the preInstruction anywhere :/
Hmm 2 sec let me write some pseudocode out üôÇ
The resulting transaction is a regular web3 tx object, so you'd execute it with web3 code (you can also just continue to use `program.rpc.oneInstruction` plus the `preInstructions: [...]` args etc.)
ah how do i execute these ? i don't really see a "execute" on the returned transaction? nor a method for executing transactions on the program.
second line should use `myProgram.instruction.myInstruction(...)`, but yeah
?
So hypothetically to keep it simple say i wanted to make the same call 2 times in a single transaction <:CKThink:889727701106184202> 
```ts
    let transaction = this.myProgram.transaction.myInstruction(...Args);
    transaction.add(this.myProgram.transaction.myInstruction(...Args));
```
hmm let me have a quick look <:CKThink:889727701106184202>
Can also use `program.transaction.yourInstructionName` to build a tx object, then manually add instructions to it, etc.
Bunch of ways: you can build raw instructions with `program.instruction.yourInstructionName` and add it to an existing rpc call with `preInstructions: [...]` or `postInstructions: [...]`
Is there a way to combine rpc's into a single transaction? - I can't really find a good example anywhere it's done.
Hello, Is there a way to set the program Id on a first deployment?
Hi! looking at this https://docs.rs/anchor-lang/latest/anchor_lang/context/struct.CpiContext.html#example-with-and-without-pda-signature  that shows both ways to `Cpi::new` and  `Cpi::new_with_signer`, isn't it the case that `do_cpi` won't ever run because it wont be able to sign the `authority`? (since PDA, no KeyPair)
Program-derived addresses are actually totally different from program addresses, but yeah, your description of PDAs sounds good. The key thing is that the program ID is indeed just the program account's public key (there's a second program account assuming you use the upgradeable deployment process, but yeah, your program ID is the public key for one of the resulting program accounts).
An associated token account is really just an associated token *address*. The account itself is still just a regular token account, it's only the address that is special: it's a program-derived address that has been derived from the associated token program (a little helper program, not the same thing as the spl token program) with seeds based on the mint + the token owner.
A program ID is indeed just a regular old account address‚Äîwhen you deploy a program, solana allocates two accounts (as far as I know, maybe more), one of which lives at your program id (so in other words, it's just an account address).
Nvm it does
Does freezing a token account, disable transfering token ?!
Thanks Sir! Very helpful folder. What is the difference between TokenAccount created here
https://github.com/project-serum/anchor/blob/83121c26eb578487196524d5829099a70503a5a3/tests/ido-pool/tests/ido-pool.js#L41
and the Associated Token Account  here
https://github.com/project-serum/anchor/blob/83121c26eb578487196524d5829099a70503a5a3/tests/ido-pool/tests/ido-pool.js#L165
https://solanacookbook.com/references/anchor.html#calculating-account-space-size
how to import multiple .so files in Anchor.toml?
is there a guide on how to choose the correct space when initializing an account with a Vec inside?
Think seeds as desrcibed in this macro

```
    #[account(
        init,
        token::mint = usdc_mint,
        token::authority = vault_authority,
        seeds = [VAULT_USDC_SEED.as_bytes(), vault_name.as_bytes()],
        bump = bumps.vault_usdc,
        payer = vault_admin
    )]
    pub vault_usdc: Box<Account<'info, TokenAccount>>,
```
Seed phrases? Are you deriving a PDA?
what are seeds? what would a ``` Error: 146: A seeds constraint was violated
``` mean?
Or docs
Hey, anyone have any good test scripts or some way of setting up a collection NFT?
Yes you need an airdrop. Are you generating a new key in your test, or connecting to your file system wallet? If generating a new one, you will need to request the airdrop after generating your keys.
Also im on anchor version 0.20.1
In particular I'm trying to run the it("setup game!") unit test
Am I supposed to have a local solana-test-validator running?
I'm trying to run the first test from the anchor lang milestone tutorial and I'm getting the following error:

**Transaction simulation failed: Attempt to debit an account but found no record of a prior credit. **

I think I need to request an airdrop but I'm not quite sure.

I've tried looking for a similar issue on github, here, and by googling but I'm coming up a little short. I'm super new to anchor, and rust but have a fair bit of experience writing tests for smart contracts.

I'm not sure if maybe anchor is using a different wallet then the one on the test or maybe pointing somewhere. Has anyone experienced something like this while running the test for the tutorial?
Hey guys,
hm, I guess this brings me into a more general question - what is the difference between a program ID vs. a program address vs. a public key? My understanding so far is:

A public key is a property of every account. It serves as a reference to an account (this can be for a data account or a program account)

The program address can also be called a program derived address, and this is a hash between our seeds and a programId. This program address acts as a "private key" to the corresponding program (one which our program, the one running, owns). The program address is used in the invoke/execute transaction method to run the corresponding program. What I've described is the PDA (Program Derived Address), it sounds like the program address is similar to the program account's public key? 

ProgramId, this is just the program that was deployed's resulting hash. My understanding is that this is distinctly different from the program account's public key but your comment here confuses me a bit? I guess an program account can have a program ID and a public key and declare ID allows you to verify the former.

Let me know if I'm missing anything here!
For `bump`, where is it getting the value from? https://solanacookbook.com/references/anchor.html#accounts-deserializers If I have it calculated on the front end, how do I pass it in?
how can I read this to figure out how each of the arguments to account attribute work? https://docs.rs/anchor-attribute-account/0.21.0/src/anchor_attribute_account/lib.rs.html#62-65
has nothing do to with anchor per se. It's a lifetime annotation. https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#validating-references-with-lifetimes
What is the `'info` in `Initialize<'info>,` `Signer<'info>` and all the other structs? It seems to be in every generic definition. See it being mentioned, but cant find an in depth definition in the docs https://docs.rs/anchor-lang/latest/anchor_lang/accounts/account/struct.Account.html#impl-Accounts%3C%27info%3E
lmao nvm my seed just wasnt working :/
Because before I was writing a regular counter program + passing the bump and generating a seed with a phrase and users wallet
Ok so to have a PDA I must define it as an account in another program, then call that program from the current program?
Thank u ‚ù§Ô∏è
https://docs.solana.com/developing/programming-model/calling-between-programs#program-derived-addresses
Gday guys, does anyone have any good resources on PDA's they could point me too üôÇ üíã
am I just using the blockchain in an awkward way? should I be trying to solve my problem off chain or client side?
unless the index was maybe a timestamp idk
yeah i see what youre saying, sounds like lookups would be super slow since you would just have to iterate through every single one
Definitely possible to do that, it's just significantly more awkward
i guess if my tickets had a max amount possible to be minted then i could do some math and figure out how many aggregate accounts
It wouldn't work at all with a per-user PDA, so you'd have to store that info in aggregate accounts (a bunch of users per account)
Yeah, the "all users who have ever minted" thing is a bit harder, and depends on how many users there are
i guess maybe i could do an index as part of the seed, and iterate through 0-n, inside each account having a key:value pair of user_pubkey:amount_minted
like again, but if I wanted to get all users who ever minted i wonder how i could structure it
i wouldnt be able to look up a user unless they interacted with the program
haha all good, so in that scenario
E.g. if all you care about is looking up how many tickets a given user has, you could store that in a per-user PDA
But yeah, in general you kinda just have to think about how you want to access your data (lol, not a very helpful answer)
could I do something like a PDA derived from a user pubkey and my vault pubkey, which then i would store a counter to how many tickets/tokens they minted from my vault?
oh sweet
You can still store Vectors in your account data, you just need to make sure you actually allocate enough space for their eventual max size (whatever you're comfortable with)
just kinda trying to figure out how to think about this
I cant have data structures like vectors in my account data right? So that would need to be static. I assume each Account would hold 10kb worth of data my program can reference
I wanna keep track of tickets I mint to users when they deposit into my vault
Im reading up on https://github.com/solana-labs/solana-program-library/blob/master/farms/farm-sdk/src/refdb.rs
Can you say more? Not quite sure what you mean
anyone got a simple example of an on chain db? or any tips?
beautiful, thank you!
Or `preInstructions: [...]` and `postInstructions: [...]`
Yep, see the `instructions: [...]` argument
When you hardcode your intended ID into your own source code (what declare_id does), that lets other people verify that the thing their going to CPI to really does have the right/intended program_id (necessary because the client had to submit your program as an account in order to be able to CPI to it).
hopefully quick question, does the Anchor-generated client support including multiple instructions in one transaction?
The reason why it's important is actually for *other* programs in case they want to CPI to your program: it's important that they know exactly what your intended program id is, since otherwise a devious client could trick their program into CPI-ing into some random *other* program rather than your own one.
All it does is declare a static `ID` variable with your intended program id (plus a couple helper functions).
I have a few question about the `declare_id` macro:

1/ Have read from multiple sources that this makes it easier to build more secure applications. How exactly does it do so? My guess is that there's a check when you invoke the programId of the deployed program, and if the declare_id is not equal to the invoked programId, then the rpc calls just don't run. Although I'm not really seeing this from the implementation here

```/// Defines the program's ID. This should be used at the root of all Anchor
/// based programs.
#[proc_macro]
pub fn declare_id(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
    let id = parse_macro_input!(input as id::Id);
    proc_macro::TokenStream::from(quote! {#id})
}```

source: https://docs.rs/anchor-attribute-account/0.21.0/src/anchor_attribute_account/lib.rs.html#316

2/ What happens if you put an arbitrary program here? Whenever we run `anchor build` on the same code, the programId appears to be deterministic. If we use an arbitrary programId in the declare_id macro, does our program just not run? What is going on here?

thanks!
That source code lives here: https://github.com/solana-labs/solana/blob/master/keygen/src/keygen.rs#L528
not sure if this is the right place to ask, but what is `solana keygen` calling under the hood? I want to read through the source code here but am having a hard time finding the source code
And am I understanding borsch struct serialization correctly in that the struct fields don't require any additional space beyond that required to accommodate the field's data, i.e., nothing required for the field name?
is the best practice for unit testing on chain programs to do that in the js client? also, where can I find more info on how to use the rust client for on chain programs?
from AccountInfo to Account<User>
How to convert from AccountInfo to Account ? 
have remaining accounts that are AccountInfo but might follow certain account structure
I'm trying to use https://docs.rs/spl-token-swap/2.1.0/spl_token_swap/ this in anchor but on initialize funtion I get thi error `the trait BorshSerialize is no implemented for spl_token_swap::curve::fee::Fees`
cool - here's the fix:
```rust
        let signer_seeds = [
            "pda".as_bytes(),
            &program::MemberNfts::id().to_bytes(),
            &[bump_seed],
        ];
        token::mint_to(
            CpiContext::new_with_signer(
                ctx.accounts.token_program.to_account_info(),
                mint_to_ctx,
                &[&signer_seeds],
            ),
            1,
        )
```
is there a way to check detailed log
though it creates the project directory but not sure if everything is fine within it
Installed it
Think that means you don't have `yarn` installed
thanks - was just on to that!
I get error when I do anchor init Error: yarn install failed: No such file or directory (os error 2)
Ah, ok, you aren't actually signing with the PDA when you try to do the `mint_to` part. You need to use `CpiContext::new_with_signer` and add in the PDA's seeds *and* bump.
Whoops, sorry, can't read ü§¶‚Äç‚ôÇÔ∏è
So you want the PDA to also pay for the mint's initialization?


//////////////////////////////////////////////////////////////////////////////////////////

> `The #[account] attribute implements the Owner trait for a struct using the crate::ID declared by declareId in the same program.`

what's the idiomatic way to add `#[account]` to a type `T` defined outside of the current anchor crate (where `T` corresponds to an `AccountInfo`)? Create a wrapper struct?
I don't understand which parameter could have a `.c` function or a `.b.span`
```                                H = anchor.web3.SystemProgram.createAccount({
                                    fromPubkey: payer.publicKey,
                                    newAccountPubkey: mint.publicKey,
                                    lamports: G,
                                    space: c.b.span,
                                    programId: c.c
                                }),```

Does anyone have any idea what the **c** parameter here could be?
Also more broadly, are there any repos you‚Äôd recommend reading through for examples on how anchor/solana transfer SOL and spl tokens between accounts and programs? Or just generally repos that show off best practices and have extensive coverage of solana/anchor?
Where can i find the interface for `AccountClient` and the `AccountInfo` object? I want to read through all the other methods that exist
On the rust side, the lamport balance lives on the account info, `a.to_account_info().lamports()`
On the client you'd just fetch the account:
```.rs
await program.provider.connection.getAccountInfo(keypair.publicKey)
```
Are you trying to check in your rust program? Or on the client?
for example, if I do something like:

```
invoke(
    &system_instruction::transfer(
        &a.to_account_info().key,
        &b.to_account_info().key,
        1_000_000_0, // 0.1 SOL
    ),
    &[
        a.to_account_info().clone(),
        b.to_account_info().clone(),
        system_program.to_account_info().clone(),
    ],
)?;```

best practice is to check the sol balance before transferring right? or do we not usually do that?
e.g. if I have `const keypair = anchor.web3.Keypair.generate();` is there an easy way of getting the sol balance?
given a keypair, how can you check the SOL balance?
gm
To access details about the mint account, you'll have to pass it into your instruction as a separate account (and can then deserialize it with `Account<'info, Mint>`)
Given an `Account<'info, TokenAccount>`, its mint address is lives at the `.mint` property
I have a `Token Account` here: https://explorer.solana.com/address/GcY9v6VCAnhSy2cDbue136Kwquf7rj7WfPbvdQNPXyZW?cluster=devnet

How do I get information about the `Mint Address` of the token with anchor?
anchor idl is generated when the program is built using  `anchor build`. If you don't have the source code or the idl is not published, there's no way of acquiring it.
and what's the best way to go about finding a program's idl if anchor returns null?
thanks, will check it out, probably gonna come back with few more queriesüëç
I wanna restrict the number of accounts the user(Wallet) can create in my program to just one

one : one
It is possible but without the idl or source code you would have to do reverse engineering to figure out how to encode/decode the instructions and accounts, what are the arguments and so on.
Is it possible to interact with a program for which you don‚Äôt have idl for?
thanks a lot! üôÇ
https://docs.solana.com/developing/clients/jsonrpc-api#getprogramaccounts
is there a function to find all accounts (that store data), owned by a specific program?
no need to initialize
You don't need to allocate space for PDA authorities. Just generate the address and use it.
use PDAs derived from the wallet for creating the accounts
lets say I'm initializing a PDA, and I don't intend to store any data in there. Should I put 8 as the space? or should i put a different number
What do you mean? Can you give an example?
I'm trying to restrict account to 1 per wallet, can someone suggest me how can i do it?
Unknown program
Okay thanks a lot! Damn anchor this is neat
So, yes
It will check if `tweet.author == author.key()`, close `tweet` account and return rent to `author` account
ohh okay thanks!!

and so
```rust
#[derive(Accounts)]
pub struct DeleteTweet<'info> {
    #[account(mut, has_one = author, close = author)]
    pub tweet: Account<'info, Tweet>,
    pub author: Signer<'info>,
}
```

will close that tweet account of `author` and return the rent?
The tx will fail if `author` doesn't have authority(it isn't author) of tweet
It checks if `tweet.author == author.key()`
```rust
#[derive(Accounts)]
pub struct UpdateTweet<'info> {
    #[account(mut, has_one = author)]
    pub tweet: Account<'info, Tweet>,
    pub author: Signer<'info>,
}
```

can anyone help me? what does the `has_one` parameter do in ```rust
#[account(mut, has_one = author)]
```
nvm found it: `Clock::get()?.unix_timestamp`
ty ser
ty ser
how do you get the current timestamp from within a program?
This looked like the logic related to building methods from instructions that resolved the addresses for the pdas. https://github.com/project-serum/anchor/blob/d5e7e2a7c32770c1bc50ff0957105318047a0f31/ts/src/program/accounts-resolver.ts#L43. It seemed like something like that could be used to fetch pda accounts by their seeds, but it is a little more complicated since the pda is specified in the instruction and the seeds aren't stored with the account in the idl.
In order to make this work, this has to be set in `Anchor.toml`
```
[features]
seeds = true
```
context is set up like this:
```rust
pub struct CreateUser<'info> {
    #[account(mut)]
    payer: Signer<'info>,
    #[account(init, payer = payer, seeds = [payer.key.as_ref()], bump, space = 8 + 4 + 5 * 32)]
    account: Account<'info, User>,
    system_program: Program<'info, System>,
```

but idl is coming out without being designated as pda:
```
{
      "name": "createUser",
      "accounts": [
        {
          "name": "payer",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "account",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": []
    }
```
Hello guys, may I know if PDA is deterministic? if I have one fixed seeds, it will only one bump valid for PDA?
Double check the address in your Anchor.toml file matches the one you want to use. If you re-forked the repo, it probably got overwritten to another value
I'm also interested if anyone has a tried and true system for securing the program's update authority. 2/3 multisig is desirable. I see options maybe from Goki and Cashmere, but I have not tried either. Generally, it would be awful to launch a protocol, only to find out your multisig is busted a few months later. Sort of looking for the "safe bet" if people have recommendations.
If you were paranoid you could create it with an offline computer, optionally with a seed phrase that was generated in a very offline way (paper in a hat, and calculate the checksum using seedpicker.net): https://btcguide.github.io/setup-wallets/paper
Ah, yeah, that's not an issue for solana‚Äîat any rate, I'm curious how other people manage their program_id keypair
...So maybe delete the key after you have recorded the address?
Ha ok well I won't do it, but I was just wondering. My understanding is that in ETH, if you own the key to a smart contract, you can empty any funds that get put in there
That creates the account, and then afterwards it doesn't get used for anything else (so at least no solana vulnerability if you leak that keypair, though yeah, leaking it does make me slightly nervous)
Ah, it's only used for your first deploy.
Right, as that keypair lives in target/deploy/<keypair>.json... So it's not a problem? Can anything happen if that key is compromised?
No, your program_id will be a regular keypair address
i had the multisig program up and running, and github wouldnt let me resolve some issues so i reforked it. when i try to deploy under the same provider, it is using a different address. how can i make it update the previous address?
Should an anchor program have an address that is off the elliptic curve?
https://book.anchor-lang.com/chapter_2/hello_anchor.html
How do I do that?
maybe start a new project and change Anchor.toml to point to your wallet file as a starting place?
Can someone help me please
Does this require master vs v0.21? I keep getting ` Error: Invalid arguments: account not provided.`
any good resources to recommend when looking into sending a token-transaction between accounts? I am having a hard time understanding the logic when running the actual token transactions (compared to just changing values on a single account) from one wallet to another for example
for anyone. that's my program.
What that example for me?
how does it know that `account`, `payer` and `system_program` aren't required to be included in `accounts`? https://github.com/project-serum/anchor/blob/d5e7e2a7c32770c1bc50ff0957105318047a0f31/tests/pda-derivation/programs/pda-derivation/src/lib.rs#L45
I'll see if I can figure that out to complement this:
```js
    await program.methods
      .initMyAccount(seedA)
      .accounts({
        base: base.publicKey,
        base2: base.publicKey,
      })
      .rpc();
```
Take a look at the jet protocol codebase:  https://github.com/jet-lab/jet-v1/
No, though maybe there should be (you'll need to re-find the full address)
program:

```
#[program]
pub mod solanamm {
    use super::*;
    pub fn init_mint(
        _ctx: Context<InitializeMint>
    ) -> ProgramResult {
        return Ok(())
    }
}

#[derive(Accounts)]
pub struct InitializeMint<'info> {
    #[account(
        init,
        payer = payer,
        mint::decimals = 0,
        mint::authority = payer
    )]
    pub mint: Account<'info, Mint>,
    pub payer: Signer<'info>,
    pub token_program: Program<'info, Token>,
    pub system_program: Program<'info, System>,
    pub rent: Sysvar<'info, Rent>,
}
```
 
client:

```
token_mint = Keypair()
    await program.rpc["init_mint"](
        ctx=Context(
            accounts={
                "mint": token_mint.public_key,
                "payer": payer,
                "token_program": TOKEN_PROGRAM_ID,
                "rent": SYSVAR_RENT_PUBKEY,
                "system_program": SYS_PROGRAM_ID,
            },
            signers=[]
        )
    )
```
```
anchor-lang = "0.21.0"
anchor-spl = "0.21.0"
```
Fixed the issue
Found the problem
```anchor-lang = "0.20.1"
anchor-spl = "0.21.0"```

The anchor-lang was in a different version
did this. they all match up üôÇ
All I'm trying to do is to allow a user to deposit an SPL token to the PDA token account for now. I couldn't find a simple example for this so I was using the IDO-POOL test as my reference. if there is something simpler, i'm all ears
I'm brand new to Rust and Achor so I'm sure its something fundamental I'm missing üòÑ
```error[E0277]: the trait bound `TokenAccount: anchor_lang::Owner` is not satisfied```

Issue resolved-> Solution below
Trying to work out what this error is: I stole the snippet from the test of ido. Is there some import I'm missing?
`pub user_usdc: Account<'info, TokenAccount>,`
`the trait anchor_lang::Owner is not implemented for TokenAccount`
Hey guys, I would like to know if there is a live example of spliting your code in instructions, utils, process. The main reason I am asking this is because everytime I tried to not make a single file for my code I start getting a lot of errors and I would like to know the propper way to do it. Thanks in advance!
is there a way to do this with just the seeds for a pda?
```js
const userAccount = await program.account.user.fetch(pda);
```
In case you‚Äôre unsure, look through your terminal history and try using all of the addresses
Been a while since this happened but I remember that there were a few addresses floating around ‚Äî try finding the deployed address of the contract itself
Is there a way to validate a signature given as input, assuming that the pub key is stored in the state, and the message is also received as input?
I'm trying to follow:
```rs
# Struct solana_sdk::signature::Signature
pub fn verify(&self, pubkey_bytes: &[u8], message_bytes: &[u8]) -> bool
```
Hmm, that's a pretty low-level solana error, I don't think it has anything to do with the program_id ü§î
help here appreciated.
can't figure out what to pass for buffer and pda
Is there a good resource for learning how to write test code (js) for contracts
You forgot to mark that account as mut
`    6ygRUb4g5p2nUQ5PgVzrcBAgbXLKvs7nyx3Fjp9wg3t6's writable privilege escalated
`
i'm on localhost,
minting & delegating the ata on JS
then invoking a stake_nft RPC with the delegate as signer
which invokes mpl_token_metadata::instruction::freeze_delegate_account

```
Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account 
    Program FggV1tBd4vAJTraCnWRtU7bjAG2QuzcG1tr4cd5gbsCs invoke [1]
    Program log: Instruction: StakeNft
    6ygRUb4g5p2nUQ5PgVzrcBAgbXLKvs7nyx3Fjp9wg3t6's writable privilege escalated
    Program FggV1tBd4vAJTraCnWRtU7bjAG2QuzcG1tr4cd5gbsCs consumed 12661 of 200000 compute units
    Program FggV1tBd4vAJTraCnWRtU7bjAG2QuzcG1tr4cd5gbsCs failed: Cross-program invocation with unauthorized signer or writable account
```
i can't get past this error myself.

program_id is the same in:

- declare_id!
- anchor.toml
- "address" field of my metadata.

built and deployed to testnet.
Can you post the full program log?
ah crap still can't find what i'm doing wrong to delegate freeze an account ‚ò†Ô∏è
thx!
You could do a constraint, `constraint = token_from.owner == staking_info.key()`
Yes, signers from the client are still signers across CPIs
Then shouldn't the associated_token constraint do the job?
`Can be used as a standalone as a **check** or with init to create an associated token account with the given mint address and authority.`
nono, problem not in ATA creator. I want to protect my program from send foreign ATA from another client
doesn't creating an associated token account require a mint in the first place? ü§î
no, this constraints about mint but i want check owner. But maybe i can check by authority?
i hope i understood u correctly,

check out the spl contraints
https://docs.rs/anchor-lang/0.21.0/anchor_lang/derive.Accounts.html#spl-constraints
hey guys, i have a pda account and ata account connected to this pda account. How i can check that this ATA owner = my_pda account? I tried owner = mypda.key() but this's not work, my code ```#[account(mut, owner = staking_info.key())]
    pub token_from: Account<'info, TokenAccount>,
#[account(mut, seeds = [user.key().as_ref(), b"agrostaking"], bump)]
    pub staking_info: Account<'info, StakeInfo>,```
does invoke_signed with empty seed pass RPC call signers ?!
maybe something with this would help? if local, you could just take the first one and get the `rpc` property
```js
console.log(await program.provider.connection.getClusterNodes());
```
Yep, always have to pass all account (even ones that don't exist yet, lol) into the program
question on the programming model: if i am going to init a pda in a program, I still have to pass the pda address in to the program - you can't just create the account in the program and store the address - is that right?
Yep, that will validate that its address is that PDA
Is there a function to check which network you are connected to in a typescript test?
is this a reasonable way to validate that the user account passed in is in fact the pda generated from the payer's address?
```rust
#[derive(Accounts)]
#[instruction(group_seed: Pubkey)]
pub struct CreateGroup<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    #[account(mut, seeds = [payer.key.as_ref()], bump)]
    pub user: Account<'info, User>
```
hi when we run anchor deploy (trying to run on devnet), which file does it exactly run? when I do it it keeps repetitively printing message and I'm not sure if I accidentally added a custome message somewhere.
Should I create the client.js and add the code from the id.json which contains the keypair?
Guys I think I know what's my problem. I was checking my node_modules file and I couldn't find the "client.js" one. That means it doesn't exist I don't know why. What should I do?
So you do cut some "startup" fees by bundling transactions essentially?
Don't think the preflight stuff costs any fees
One question though. How does it work with fee's, do you essentially save fee costs for bundling them up like that?
I see the combined fee is still at 0.000005 SOL
works perfectly btw ur a god! really appreciate it


//////////////////////////////////////////////////////////////////////////////////////////

The reason you need a signature when sending sol with the system program is not because of any solana reason, it's just that that's how the system program is written‚Äîit requires a signature.
To elaborate on this: because your own program owns the multisig account, it doesn't require a signature in order to take the account's lamports‚Äîit owns the account, it can do whatever it wants with it.
Or otherwise explicitly add the multisig's keypair to the signers array
So yeah, just get rid of that `signer` attribute and see what happens
So the anchor client says "... uh"
You have declared in your rust code "this account must sign", but you aren't signing for it
But there's never any solana requirement to sign (the program that owns an account can mutate it etc. without any signature)
right, in this case you are saying that there's a signing issue on the client side?
When sending sol from a system account to someone else, the system program requires the source account to sign (makes sense)
So for example, when creating an account, the system program just happens to require the new account's address to sign
The only time you *need* to sign is when whatever program you're interacting with requires it
^ yep, playing around with it
Oh, sorry, you're forking the multisig codebase
in the mean time, is there documentation or a blogpost that outlines when an account needs to be a signer and what the limitations are around this?
just sent you an invite
cqfd
What's your github handle?
Do you have your code in a github repo I could play with?
Yeah, wait, I'm pretty confused now about what you're doing
Isn't the Multisig owned by the multisig program?
Wait, don't see how it will work if you're storing the funds in the multisig account itself ü§î
It needs to be a signer since it's transferring SOL out? or are you getting at that the `multisigSigner` is what needs to be the signer?
Why doesn't it need `#[account(signer)]` though?
no worries, you are being super helpful!
it needs to be mut since it transfers from from the multisig out
Sorry, not super familiar with the multisig program
Maybe it does need to be mut
Oh, maybe not actually
It should be neither signer nor mut presumably
The problem is that you've explicitly required the multisig to sign, with that `#[account(signer, mut)]` thing
we have `accounts` and `remainingAccounts`
So the client call looks like:

```
await program.rpc.executeTransaction({
      accounts: {
        multisig: multisig.publicKey,
        multisigSigner,
        transaction: transaction.publicKey,
      },
      remainingAccounts: program.instruction.sendSol
        .accounts({
          multisig: multisig.publicKey,
          receiver: ownerA.publicKey,
          multisigSigner,
        })
        // Change the signer status on the vendor signer since it's signed by the program, not the client.
        .map((meta) =>
          meta.pubkey.equals(ownerA.publicKey)
            ? { ...meta, isSigner: true }
            : meta
        )
        .concat({
          pubkey: program.programId,
          isWritable: false,
          isSigner: false,
        }),
    });
```
hm, what is your thought process when you try to debug something like this then?
This is the part where the program says "ok, yep, everything looks good‚ÄîI'll sign for this PDA üëç"
We're finally producing a signature for the multisigSigner PDA
So we're not signing for/don't need a signature for the multisig account (the one that stores the details of the multisig, threshold etc.)
Yep
Its seed is the multisig account's address (`multisig_key.as_ref()`)
```
const [multisigSigner, nonce] =
      await anchor.web3.PublicKey.findProgramAddress(
        [multisig.publicKey.toBuffer()],
        program.programId
      );
```
Go check how the multisigSigner's address is found
That is where we programmatically sign for the *PDA*, the multisigSigner.
we get signer from the multisig_key no?
^ what's going on in the last 8 lines starting with `multisig_key` then?
```
 pub fn execute_transaction(ctx: Context<ExecuteTransaction>) -> Result<()> {
        // Has this been executed already?
        if ctx.accounts.transaction.did_execute {
            return Err(ErrorCode::AlreadyExecuted.into());
        }

        // Do we have enough signers.
        let sig_count = ctx
            .accounts
            .transaction
            .signers
            .iter()
            .filter(|&did_sign| *did_sign)
            .count() as u64;
        if sig_count < ctx.accounts.multisig.threshold {
            return Err(ErrorCode::NotEnoughSigners.into());
        }

        // Execute the transaction signed by the multisig.
        let mut ix: Instruction = (*ctx.accounts.transaction).deref().into();
        ix.accounts = ix
            .accounts
            .iter()
            .map(|acc| {
                let mut acc = acc.clone();
                if &acc.pubkey == ctx.accounts.multisig_signer.key {
                    acc.is_signer = true;
                }
                acc
            })
            .collect();
        let multisig_key = ctx.accounts.multisig.key();
        let seeds = &[multisig_key.as_ref(), &[ctx.accounts.multisig.nonce]];
        let signer = &[&seeds[..]];
        let accounts = ctx.remaining_accounts;
        solana_program::program::invoke_signed(&ix, accounts, signer)?;

        // Burn the transaction to ensure one time use.
        ctx.accounts.transaction.did_execute = true;

        Ok(())
    }
```
No, the multisig account just stores the details of your multisig situation (who the possible signers are, what the threshold is)
i.e. in the execute transaction function we have:
Doesn't the multisig need to sign in order for `execute transaction` to run?
I wouldn't expect it to need to sign again.
You've already created the multisig account.
Why does the multisig need to sign the execute transaction part?
Hmm, that error is coming from the client, and its saying that it expected some account to sign (from the client), but it didn't.
I set multisigSigner `isSigner` to false here and only `multisig` has `isSigner` set to `true`.
but for some reason, I'm getting:

```
     Error: Signature verification failed
      at Transaction.serialize (node_modules/@solana/web3.js/lib/index.cjs.js:2829:13)
      at Provider.send (node_modules/@project-serum/anchor/dist/cjs/provider.js:89:26)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at async Object.rpc [as executeTransaction] (node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:31:31)
      at async Context.<anonymous> (tests/multisig.js:164:5)
```
this is how I set up the `executeTransaction` in my test:

```
// Now that we've reached the threshold, send the transactoin.
    await program.rpc.executeTransaction({
      accounts: {
        multisig: multisig.publicKey,
        multisigSigner,
        transaction: transaction.publicKey,
      },
      remainingAccounts: program.instruction.sendSol
        .accounts({
          multisig: multisig.publicKey,
          receiver: ownerA.publicKey,
          multisigSigner,
        })
        // Change the signer status on the vendor signer since it's signed by the program, not the client.
        .map((meta) =>
          meta.pubkey.equals(multisigSigner)
            ? { ...meta, isSigner: false }
            : meta
        )
        .concat({
          pubkey: program.programId,
          isWritable: false,
          isSigner: false,
        }),
    });
```
This is a lot of code‚Äîwhat should I be looking for?
It bundles up all of the multisig verification stuff behind a single PDA, in such a way that if that PDA signs the CPI call, then you know that the conditions of the multisig were indeed met.
So the idea of the serum multisig program is that a program verifies the conditions of your particular multisig situation, and only upon verification will it agree to sign for the multisigSigner address.
I'm saying that PDAs in general are deliberately constructed in such a way that it's just not possible to sign for them from the client‚Äîpart of their purpose is that only their deriving program can sign for them.
when you say "it's not possible to sign for it from the client, only the multisig program itself can sign for that PDA", do you mean that the multisig needs `isSigner` set to `true` and `multisigSigner` needs `isSigner` set to `false`? Is it that within an RPC call only one `isSigner` can be set to true, and if if multiple are then the call fails?
but when I run this test I'm getting:

```
  1) multisig
       encoding send sol:
     Error: Signature verification failed
      at Transaction.serialize (node_modules/@solana/web3.js/lib/index.cjs.js:2829:13)
      at Provider.send (node_modules/@project-serum/anchor/dist/cjs/provider.js:89:26)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at async Object.rpc [as executeTransaction] (node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:31:31)
      at async Context.<anonymous> (tests/multisig.js:164:5)
```
```    const transaction = anchor.web3.Keypair.generate();
    const txSize = 1000; // Big enough, cuz I'm lazy.
    await program.rpc.createTransaction(pid, accounts, data, {
      accounts: {
        multisig: multisig.publicKey,
        transaction: transaction.publicKey,
        proposer: ownerA.publicKey,
      },
      instructions: [
        await program.account.transaction.createInstruction(
          transaction,
          txSize
        ),
      ],
      signers: [transaction, ownerA],
    });

    const txAccount = await program.account.transaction.fetch(
      transaction.publicKey
    );

    assert.ok(txAccount.programId.equals(pid));

    // Other owner approves transactoin.
    await program.rpc.approve({
      accounts: {
        multisig: multisig.publicKey,
        transaction: transaction.publicKey,
        owner: ownerB.publicKey,
      },
      signers: [ownerB],
    });

    // Now that we've reached the threshold, send the transactoin.
    await program.rpc.executeTransaction({
      accounts: {
        multisig: multisig.publicKey,
        multisigSigner,
        transaction: transaction.publicKey,
      },
      remainingAccounts: program.instruction.sendSol
        .accounts({
          multisig: multisig.publicKey,
          receiver: ownerA.publicKey,
          multisigSigner,
        })
        // Change the signer status on the vendor signer since it's signed by the program, not the client.
        .map((meta) =>
          meta.pubkey.equals(multisigSigner)
            ? { ...meta, isSigner: false }
            : meta
        )
        .concat({
          pubkey: program.programId,
          isWritable: false,
          isSigner: false,
        }),
    });
```
```
it ("encoding send sol", async() => {
    const multisig = anchor.web3.Keypair.generate();
    const [multisigSigner, nonce] =
      await anchor.web3.PublicKey.findProgramAddress(
        [multisig.publicKey.toBuffer()],
        program.programId
      );
    const multisigSize = 200; // Big enough.

    const ownerA = anchor.web3.Keypair.generate();
    const ownerB = anchor.web3.Keypair.generate();

    const owners = [ownerA.publicKey, ownerB.publicKey];

    const threshold = new anchor.BN(1);
    await program.rpc.createMultisig(owners, threshold, nonce, {
      accounts: {
        multisig: multisig.publicKey,
      },
      instructions: [
        await program.account.multisig.createInstruction(
          multisig,
          multisigSize
        ),
      ],
      signers: [multisig],
    });

    let multisigAccount = await program.account.multisig.fetch(
      multisig.publicKey
    );

    await program.provider.connection
      .requestAirdrop(multisig.publicKey, LAMPORTS_PER_SOL)
      .then((sig) => program.provider.connection.confirmTransaction(sig, "confirmed"));

    const pid = program.programId;
    const accounts = [
      {
        pubkey: multisig.publicKey,
        isWritable: true,
        isSigner: false,
      },
      {
        pubkey: multisigSigner,
        isWritable: false,
        isSigner: true,
      },
    ];
    const amountToMove = new anchor.BN(0.2 * 1000000000)

    const data = program.coder.instruction.encode("send_sol", {
      amount: amountToMove,
    });
```
My test looks like:
```
#[derive(Accounts)]
pub struct ExecuteTransaction<'info> {
    #[account(constraint = multisig.owner_set_seqno == transaction.owner_set_seqno)]
    multisig: Box<Account<'info, Multisig>>,
    #[account(
        seeds = [multisig.key().as_ref()],
        bump = multisig.nonce,
    )]
    multisig_signer: UncheckedAccount<'info>,
    #[account(mut, has_one = multisig)]
    transaction: Box<Account<'info, Transaction>>,
}

#[derive(Accounts)]
pub struct SendSol<'info> {
    #[account(signer, mut)]
    pub multisig: Box<Account<'info, Multisig>>,
    #[account(mut)]
    pub receiver: AccountInfo<'info>,
    #[account(
        seeds = [multisig.key().as_ref()],
        bump = multisig.nonce,
    )]
    multisig_signer: Signer<'info>,
}
```
On the serum multisig if I have:

```
pub fn send_sol(ctx: Context<SendSol>, amount: u64) -> Result<()> {
    **ctx.accounts.multisig.to_account_info().try_borrow_mut_lamports()? -= amount;
    **ctx.accounts.receiver.to_account_info().try_borrow_mut_lamports()? += amount;
    Ok(())
} 

// Executes the given transaction if threshold owners have signed it.
    pub fn execute_transaction(ctx: Context<ExecuteTransaction>) -> Result<()> {
        // Has this been executed already?
        if ctx.accounts.transaction.did_execute {
            return Err(ErrorCode::AlreadyExecuted.into());
        }

        // Do we have enough signers.
        let sig_count = ctx
            .accounts
            .transaction
            .signers
            .iter()
            .filter(|&did_sign| *did_sign)
            .count() as u64;
        if sig_count < ctx.accounts.multisig.threshold {
            return Err(ErrorCode::NotEnoughSigners.into());
        }

        // Execute the transaction signed by the multisig.
        let mut ix: Instruction = (*ctx.accounts.transaction).deref().into();
        ix.accounts = ix
            .accounts
            .iter()
            .map(|acc| {
                let mut acc = acc.clone();
                if &acc.pubkey == ctx.accounts.multisig_signer.key {
                    acc.is_signer = true;
                }
                acc
            })
            .collect();
        let multisig_key = ctx.accounts.multisig.key();
        let seeds = &[multisig_key.as_ref(), &[ctx.accounts.multisig.nonce]];
        let signer = &[&seeds[..]];
        let accounts = ctx.remaining_accounts;
        solana_program::program::invoke_signed(&ix, accounts, signer)?;
        // Burn the transaction to ensure one time use.
        ctx.accounts.transaction.did_execute = true;
        Ok(())
    }
}
```
Nvm lol i was wrong. It was asserting the account field  with the target..
Am I wrong ?üò©
üßê
I didn't get it
Account -> authority
üò∂
Hmmm Is it checking if the account is owned by that account ?
ohh ty once again.
https://github.com/project-serum/anchor/blob/master/lang/syn/src/codegen/accounts/constraints.rs#L187
Hi, what does  #[account(mut, has_one = authority)] --> has_one do ?
Its seeds are the multisig account, and then we also need its bump, which we were smart about and stored in the multisig account.
Can you say more about the seeds/signer stuff in the end? The only thing we're adding a signature for is indeed the `multisigSigner` account
Mm, not in any super easy way as far as I know (maybe the rust test setup can do this? Not sure)
Is there a way for me to log within the rpc calls? i.e. if i want to breakpoint or figure out what value seeds/signer/etc takes on, how would i do that?
Same version as anchor-lang
`anchor-spl` crate, yeah
okay thanks a lot! I ll check it out
do i have to import `associated_token_program` from a rust crate somewhere?
So when they try to call your endpoint, you force them to pass in that PDA address. If you've already stashed an account there, tell them to go away. Otherwise, store an account there (could even be an empty struct) and let them run the endpoint.
The existence of an account at that address implies yep, they've already called
With, say, seeds = `[b"has_already_called", user.key().as_ref()]`
Ah, an easier way would be to use a PDA per user.
so I store a vector of public keys which have called the endpoint?
No, not yet
can anchor idl generate rust clients <a:Hmmmm:695129200260153375>
Only very very slightly.
The client would then have to pass in that account along with their attempt to use the endpoint, and your program would validate whether or not they've already called it.
that would increase the rent, wouldnt it :/
You would need to store the fact that they've called the endpoint in an account, and check it on-chain.
Hey folks! Is there anyway I can restrict an user from calling an endpoint more than once in Anchor? I am building an application which has likes and naturally, a particular wallet cannot call the update likes function more than once.... Thanks in advance!
2. The multisigSigner is a PDA, so it's not possible to sign for it from the client‚Äîonly the multisig program itself can sign for that PDA (once you've convinced it that you really have corralled the right number of signers etc.)
Then if you want to actually sign for that token account's owner (the multisigSigner), you'd have to convince the multisig program that signing is appropriate: by passing in the actual `multisig` account, which stores all the details about this particular multisig setup, and then convincing the multisig program that, yep, enough of the possible signers have indeed signed the intended transaction, etc.
The `multisigSigner` address is the actual PDA address that can then go sign for something later. So for example, if you want the authority over a token account to be a multisig, you'd make the token's owner by `multisigSigner`.
The difference between `multisig` and `multisigSigner` is that `multisig` stores the details about this particular multisig setup in an account: who the possible signers are, and what the threshold is.
also 4/ is there a way for me to log within the rpc calls? i.e. if i want to breakpoint or figure out what value seeds/signer/etc takes on, how would i do that?
```
// Executes the given transaction if threshold owners have signed it.
    pub fn execute_transaction(ctx: Context<ExecuteTransaction>) -> Result<()> {
        // Has this been executed already?
        if ctx.accounts.transaction.did_execute {
            return Err(ErrorCode::AlreadyExecuted.into());
        }

        // Do we have enough signers.
        let sig_count = ctx
            .accounts
            .transaction
            .signers
            .iter()
            .filter(|&did_sign| *did_sign)
            .count() as u64;
        if sig_count < ctx.accounts.multisig.threshold {
            return Err(ErrorCode::NotEnoughSigners.into());
        }

        // Execute the transaction signed by the multisig.
        let mut ix: Instruction = (*ctx.accounts.transaction).deref().into();
        ix.accounts = ix
            .accounts
            .iter()
            .map(|acc| {
                let mut acc = acc.clone();
                if &acc.pubkey == ctx.accounts.multisig_signer.key {
                    acc.is_signer = true;
                }
                acc
            })
            .collect();
        let multisig_key = ctx.accounts.multisig.key();
        let seeds = &[multisig_key.as_ref(), &[ctx.accounts.multisig.nonce]];
        let signer = &[&seeds[..]];
        let accounts = ctx.remaining_accounts;
        solana_program::program::invoke_signed(&ix, accounts, signer)?;

        // Burn the transaction to ensure one time use.
        ctx.accounts.transaction.did_execute = true;

        Ok(())
    }
```

What is going on between seeds/signer in the end? why isn't the signer just the multisig signer? (related to 2)
I have a few questions here:

1/ whats the diff between multisig vs. multisigSigner? my understanding is multisigSigner is the PDA for the multisig program

2/ `// Change the signer status on the vendor signer since it's signed by the program, not the client.` <- why do we change the multisigSigner to *not* be a signer here? isn't "since it's signed by the program"?

3/    In execute_transaction rpc we have:
```
    const transaction = anchor.web3.Keypair.generate();
    const txSize = 1000; // Big enough, cuz I'm lazy.
    await program.rpc.createTransaction(pid, accounts, data, {
      accounts: {
        multisig: multisig.publicKey,
        transaction: transaction.publicKey,
        proposer: ownerA.publicKey,
      },
      instructions: [
        await program.account.transaction.createInstruction(
          transaction,
          txSize
        ),
      ],
      signers: [transaction, ownerA],
    });

    const txAccount = await program.account.transaction.fetch(
      transaction.publicKey
    );

    // Other owner approves transactoin.
    await program.rpc.approve({
      accounts: {
        multisig: multisig.publicKey,
        transaction: transaction.publicKey,
        owner: ownerB.publicKey,
      },
      signers: [ownerB],
    });

    // Now that we've reached the threshold, send the transactoin.
    await program.rpc.executeTransaction({
      accounts: {
        multisig: multisig.publicKey,
        multisigSigner,
        transaction: transaction.publicKey,
      },
      remainingAccounts: program.instruction.setOwners
        .accounts({
          multisig: multisig.publicKey,
          multisigSigner,
        })
        // Change the signer status on the vendor signer since it's signed by the program, not the client.
        .map((meta) =>
          meta.pubkey.equals(multisigSigner)
            ? { ...meta, isSigner: false }
            : meta
        )
        .concat({
          pubkey: program.programId,
          isWritable: false,
          isSigner: false,
        }),
    });
```
In the tests we have:

```
it("Tests the multisig program", async () => {
    const multisig = anchor.web3.Keypair.generate();
    const [multisigSigner, nonce] =
      await anchor.web3.PublicKey.findProgramAddress(
        [multisig.publicKey.toBuffer()],
        program.programId
      );
    const multisigSize = 200; // Big enough.

    const ownerA = anchor.web3.Keypair.generate();
    const ownerB = anchor.web3.Keypair.generate();
    const ownerC = anchor.web3.Keypair.generate();
    const ownerD = anchor.web3.Keypair.generate();
    const owners = [ownerA.publicKey, ownerB.publicKey, ownerC.publicKey];

    const threshold = new anchor.BN(2);
    await program.rpc.createMultisig(owners, threshold, nonce, {
      accounts: {
        multisig: multisig.publicKey,
      },
      instructions: [
        await program.account.multisig.createInstruction(
          multisig,
          multisigSize
        ),
      ],
      signers: [multisig],
    });

    let multisigAccount = await program.account.multisig.fetch(
      multisig.publicKey
    );

    const pid = program.programId;
    const accounts = [
      {
        pubkey: multisig.publicKey,
        isWritable: true,
        isSigner: false,
      },
      {
        pubkey: multisigSigner,
        isWritable: false,
        isSigner: true,
      },
    ];
    const newOwners = [ownerA.publicKey, ownerB.publicKey, ownerD.publicKey];
    const data = program.coder.instruction.encode("set_owners", {
      owners: newOwners,
    });
```
I'm looking through the serum multisig code (https://github.com/project-serum/multisig/blob/master/programs/multisig/src/lib.rs) and have a few questions on how they are calling the rpcs, notably the approve -> execute transaction sequence.
will check it out.
Thanks a lot alan üôè
The solana/spl-token library has a function, `Token.getAssociatedTokenAddress`
if possible can you share a snippet of it
so it's something i should do myself in the client, if so which function should i use to do it?
The anchor code above will validate that you passed in the right address.
So given a user and a mint, you don't have any choice over the associated token address.
Ah, the address for an associated token account isn't just any address. It's a program-derived address, derived from the associated token program, which uses the owner + mint as its seeds.
then (wallet, mint) combination doesn't have any relation to the address of associated token account, since we are the one passing the public key to be used for it?
Haha, about which part?
okay now i'm really confused üòÖ
Yep
?
then doesn't the associated_token_account have that public key as it's address
yeah
yeah i get that but we still pass a public key for the_ata in the client right?
every (wallet, mint) combination produces exactly one associated token account (thats how ATAs are defined). is this your question?
Hi alan i still don't associated token especially with creation of associated token account. we pass a public key that we want to be used to create the associated token account right then how is it one:one mapped to the wallet.
dope, thx!
Yep
as a final question, does this also work for 
``` 
#[account(
    init_if_needed,
    associated_token::mint = the_mint,
    associated_token::authority = the_owner,
    payer = who_should_pay_if_necessary,
)]
pub the_ata: Box<Account<'info, TokenAccount>>
``` 
when the TokenAccount is wrapped in a `Box` ?
yh sounds reasonable. thanks a lot alan! üôÇ
I think it's pretty harmless for associated token accounts, since you weren't going to do any initialization logic for them anyways.
got it, makes a lot of sense
Yes.
ah. so i guess it could be confusing in terms of program-flow, if the larger program has bugs
The risk is that if you're being slightly dumb, you might `init_if_needed` an account and then forget in your instruction function that the account may have *already* been initialized. This could be bad if you do something like `ctx.accounts.that_account.super_important_value = INITIAL_VALUE`.
Honestly still not quite sure why people have such a hard time with init_if_needed lol. It does exactly what it says: if the account comes in already initialized then it does nothing (besides checking the constraints), otherwise it initializes it according to the constraints
but i dont see a reason why there would be
is there any big side-effects to init_if_needed? I heard that its unsafe quite often
ahh very nice, thanks a lot! üôÇ
Yep, can use something like
```.rs
#[account(
    init_if_needed,
    associated_token::mint = the_mint,
    associated_token::authority = the_owner,
    payer = who_should_pay_if_necessary,
)]
pub the_ata: Account<'info, TokenAccount>
```
ah, so this works also for TokenAccounts?
Yeah, that's basically all you can do from the client. From within your rust program you could use `init_if_needed` and create the ATA on the fly if necessary.
I am trying to create a chain of instructions, s.t. the user doesn't have to click "confirm" multiple times (rather, just a single time). and for this I basically need to know if the ATAs should also be initialized 
(because if they are already initialized, it would make the transaction fail)
right now i'm just doing a try-catch. within the try, I create the account. if it fails, I just get it.
What have you tried so far? You can check from the client just by fetching the account and seeing if there's a token account in there.
specifically this https://docs.solana.com/developing/runtime-facilities/programs#secp256k1-program
Hey is there an example for ecrecover?
how do i best check if an ATA (associated token account) exists already?
~~answered my own question in the docs here for anyone else wondering: https://docs.rs/anchor-lang/0.21.0/anchor_lang/accounts/account/struct.Account.html#using-account-with-non-anchor-programs~~

the above doesn't actually work because of the orphan rule
going off the docs / code, `#[account]` generates a bunch of trait impls, which it doesn't have a problem doing since that type already impls `Borsh` + `Clone`
(asked yesterday, but just wanted to ask again to see if anyone knows)

basically I'm interested in having an `Account<'info, T>` where `T` is a type defined outside my crate

```rust
#[account]
pub struct Person {
    person: PPerson
}

#[derive(BorshSerialize, BorshDeserialize, Clone)]
pub struct PPerson {
    name: String
}
```

I run into this error: `IdlError: Type not found: {"name":"person","type":{"defined":"PPerson"}}`, which i _think_ is because the macro `#[account]` also registers the type with the IDL -- **is there a way I can "hook" this type into the IDL?**

the constraint is I can't just attach `#[account]` to a type that doesn't belong to my crate
I believe that calling the Ed25519 program could be a solution. I'm not sure how to achieve this. Source: https://docs.solana.com/es/developing/runtime-facilities/programs#ed25519-program
Following up this question. I've seen that there's a public function in the solana sdk for doing this: `solana_sdk::ed25519_instruction::verify`. However, this is not accessible in anchor, and I can't have `solana-sdk` as a dependency. Is there any workaround?
where can i find the id for associate_token_program?
Hello. Trying to find put best practice for the following scenario:  Let say there is a ToDo list and each ToDo has lot of items inside. Will it be better to create one big ToDo account as an array with all the items inside? or create each item as separate account (PDA?).
should I have a vault(token account) owned by a pda or vault as pda
for token program i can get the id from TokenInstruction how can i get that for associate token program
So associated token program is different from token program?
program id of associated token program
yes! https://twitter.com/anchorlang/status/1491168003136049155?s=20&t=9eRTSAKrP9xeMJFsjuQEFw
What is associated_token_program_id?
I don't remember, it was in an on-hold project. There I have this in an out-of-the way rust module that nothing ever uses:
```
// Nothing in Rust shall use this type. It only exists so the Anchor IDL
// knows about the type and typescript can deserialize it.
#[derive(AnchorSerialize, AnchorDeserialize, Default)]
pub struct I80F48 {
    val: i128,
}
```
Which I think works because anchor doesn't use fully qualified type names? But I don't remember if that fully resolved the issue.
did you get a follow up?
Is this new?
Hi all, in general is your development mostly Rust or Typescript/ Javascript? It seems like with composability you could stitch together different protocols to make something new and useful. But (please correct if I'm wrong) that seems like you are mostly using a TS/JS frontend to talk to existing programs. (I'm looking at something like Serum or Metaplex to start a marketplace of sorts.)
I am specifying anchor-lang and anchor-spl version 0.20.1 in my cargo.toml, but I'm getting build errors indicating that 0.21.0 is being used  `/.cargo/registry/src/github.com-1ecc6299db9ec823/anchor-lang-0.21.0/src/context.rs:51:5`
If it requires a signature from that address then yeah, only possible from within your program
if i have a pda owned by my program, and i want to create a serum open orders account for that pda, is it possible to do from js? or would it have to be from inside my program since only my program can sign for it?
Did you ever figure this out? Maybe there's a repo with an example by now? I know multiple people have built on Mango
having it derive  `#[account]` solves it, but i can't for types from crates i depend on
`IdlError: Type not found: {"name":"person","type":{"defined":"Person"}}`
how does one wrap a type for an account to be used with anchor that's defined outside of the crate?
well it might be `#[account(zero, signer)]`, but thanks I will try things! üôÇ
I haven't actually used the multisig program before, but that sounds plausible
Ah, possibly!
oh, then it might be better with `UncheckedAccount` since the `#[account(init)...]` will happen in the `multisig` program...?
The code you have here does indeed expect the `multisig` account to already be initialized (that's what `Account<'info, Multisig>` means here‚Äîyou're supposed to pass in a previously-created multisig account)
Closing an account in solana is ultimately up to its owning program's discretion
Yep, your program will need to have an instruction that (maybe amongst other things) closes an account
When you say expose an instruction, do you mean I have to create one in my Anchor program that explicitly closes a PDA?
ran program.account.theAccountType.all() like you recommended and found about 300 total accounts to close
I get a 3012 error 'the program expected this account to be already initialized' error when `anchor test`ing (excuse me for the dump)
test looks like this:
```typescript
import * as anchor from '@project-serum/anchor';
import { Program } from '@project-serum/anchor';
import { Shard } from '../target/types/shard';
import { SerumMultisig } from '../target/types/serum_multisig';
import { LAMPORTS_PER_SOL } from '@solana/web3.js';

describe('multisig', () => {

    // Configure the client to use the local cluster.
    anchor.setProvider(anchor.Provider.env());

    const program = anchor.workspace.Shard as Program<Shard>;
    const multisgProgram = anchor.workspace.SerumMultisig as Program<SerumMultisig>;

    const Keypair = anchor.web3.Keypair;
    const PublicKey = anchor.web3.PublicKey;
    const connection = program.provider.connection;

    it('create multisig', async () => {
        const threshold = new anchor.BN(1);

        const owner = Keypair.generate();
        const airdrop = await connection.requestAirdrop(owner.publicKey, 10 * LAMPORTS_PER_SOL);
        await connection.confirmTransaction(airdrop);
        const owners = [owner.publicKey];

        const multisig = Keypair.generate();
        const [multisigSigner, nonce] = await PublicKey.findProgramAddress([
            multisig.publicKey.toBytes()
        ], multisgProgram.programId);

        await program.rpc.cpiCreateMultisig(owners, threshold, nonce, {
            accounts: {
                multisig:multisig.publicKey,
                multisigProgram: multisgProgram.programId
            }
        })

    });
});
```
minimal program:
```rust
use anchor_lang::prelude::*;
use serum_multisig::Multisig;
use serum_multisig::cpi::accounts::CreateMultisig;
use serum_multisig::program::SerumMultisig;
use serum_multisig::cpi::create_multisig;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod shard {
    use super::*;
    pub fn cpi_create_multisig(ctx: Context<CpiCreateMultisig>, owners: Vec<Pubkey>, threshold: u64, nonce:u8) -> ProgramResult {

        let multisig_program = ctx.accounts.multisig_program.to_account_info();
        let multisig = ctx.accounts.multisig.to_account_info();

        let multisig_accounts = CreateMultisig {
            multisig,
        };

        let cpi_ctx = CpiContext::new(multisig_program, multisig_accounts);
        create_multisig(cpi_ctx, owners, threshold, nonce).map_err(|_e|ShardError::MultisigError.into())
    }
}

#[derive(Accounts)]
pub struct CpiCreateMultisig<'info> {
    pub multisig: Box<Account<'info, Multisig>>,
    pub multisig_program: Program<'info, SerumMultisig>
}


#[error]
pub enum ShardError {
    #[msg("multisig error")]
    MultisigError,
}
```
I was referring to this doc: https://yihau.github.io/solana-web3-demo/tour/token-transfer.html
I was playing around with this, where the user creates their own ATA before the owner has to transfer their tokens - since it costs some sol to do so.
Ah, ok, cool‚Äîwhat have you tried so far?
yes I did. The example makes sense to me. I'm trying to combine this 'multisig' feature with https://github.com/project-serum/anchor/tree/master/examples/tutorial/basic-3 (Puppet example) but kind a stuck, thought I should ask if there is previous attempts first...
Have you looked at the multisig tests? https://github.com/project-serum/multisig/blob/master/tests/multisig.js
why didn't I add this never lol
```export const CONNECTION = new Connection('https://api.devnet.solana.com',"confirmed")```
oh nice it works now
Hi, are there examples using `project-serum/multisig` through CPI's?
I think so, can't remember how to though
Mm, not totally sure (I don't quite know enough about what you're trying to do)‚Äîat any rate, just need to think about who needs to sign when
is it possible to add this in the Connection so all the transaction are handled this way ?
The former would be
```.js
await program.provider.connection.confirmTransaction(
  await program.rpc.doSomething(...),
  "confirmed"
);
```
```.js
const sleep = ms => new Promise(awaken => setTimeout(awakenen, ms));
```
how do I do the former ?
thought about that
What happens if you wait for a higher confirmation level (or just sleep a bit)
```if (program) {
            const poolState = await program.account.pool.fetch(pool.publicKey)
            console.log(poolState)
        }```
```        const initialize_pool_transaction = await program.rpc.createPool(new BN(50), new BN(50), new BN(nonce), new BN(50), {
            accounts: {
                pool: pool.publicKey,
                vault: vault,
                poolSigner: poolSigner,
                pyth,
                authority: program.provider.wallet.publicKey,
                systemProgram: SYSTEM_PROGRAM,
                clock: SYSVAR_CLOCK_PUBKEY,
            },
            signers: [pool]
        });
```
Can you post more info about what you're doing? Program log etc?
nope, using devnet on both :))
Probably using different networks in the explorer versus in your code
Yeah I think this is where I got confused. Then as the owner who wants to set up the token transfer, rather than me having to sign everytime when a user would like to get their token transferred, I would have to set the PDA to do the signing for me right?
even tho it obviously exists when I look it up in the explorer
As for closing accounts, there's no automated way to do it in solana, you need to expose an instruction that does it (try searching the anchor repo for the `close = ` attribute)
I get ```Account does not exist GxGCcvCvTsewT63YdzzKPzEhCJHz97mG6w832mYbovfm```
You can do things like `program.account.theAccountType.all()`
(the same thing, meaning the current wallet that's interacting with the program/paying the tx fees‚Äînothing necessarily to do with the wallet that deployed the program)
It's that hardcoded public key
The point is that if you want to do a token transfer, the owner of the source tokens needs to sign‚Äîbut in your code above, you seem to think the owner of the source tokens is the provider wallet, but it's not
No, they're the same thing
Are there any references on how to fetch all the PDA that a program has created?
And also how to close PDAs that a program created
ah I see. So to clarify, the provider.wallet.publicKey --> current user interacting with the client 
program.provider.wallet.publicKey --> wallet who deployed the anchor program
Is this right?
That doesn't look like `program.provider.wallet.publicKey` üòõ
``` const ownerPublicKey = new anchor.web3.PublicKey("4VRBNmqjSncw44HBYbPm5mjKEV2X87PEmT7ikcWmruj1");```
Can you post its definition?
Yeah its the public key of the account that holds all of the spl-tokens that needs to be transfered. The funding wallet
It would need to be the wallet in order for the transfer above to make sense
What is ownerPublicKey then?
```const ownerATA = await Token.getAssociatedTokenAddress(
      ASSOCIATED_TOKEN_PROGRAM_ID,
      TOKEN_PROGRAM_ID,
      tokenMint,
      ownerPublicKey
    );
```
Can you post the definition of ownerATA?
You'll have to do the transfer from within your program, since only your program can sign for one of its PDAs (you can't possibly sign for the PDA from the client)
How are you doing/trying to do that? If you want the owner of the tokens to be a PDA then you actually can't transfer the tokens like this, from the client
So when you try to do the transfer, the token program is like "wtf, the right owner didn't sign this"
That error above means that the wallet isn't actually the owner of the ownerATA
Yes, then I guess the step that I am missing is that I have to make the authority/"owner" of the token account be some program-derived address derived from your program.
To be slightly pedantic, you don't really "create" an associated token address‚Äîyou "find" it. Finding the address doesn't create the account that may or may not live there
That error log has some extra info in it, "owner does not match". Do you know what that means?
Yeah my logic for those was the following: 
1) Create ata address if it doesn't exist
2) Transfer from owner ATA --> receiving ATA
Here is my program log
Usual suspects though: are all of those token accounts already-existing, fully-created token accounts? It's not enough just to get the ATA address right
Helps if you can post the full program log (lol, think I've typed that like 10 times today haha)
Hello, I am trying to transfer an spl-token on the client side and was looking through the anchor repo and found "Token.createTransferInstruction". My code is the following:
```let transferInstr = Token.createTransferInstruction(
          TOKEN_PROGRAM_ID,
          ownerATA,
          customerATA,
          provider.wallet.publicKey,
          [],
          50
        );
        await provider.send(
          (() => {
            const tx = new anchor.web3.Transaction();
            tx.add(
              transferInstr
            );
            return tx;
          })()
        );```
However, I keep on running into Custom Program error: 0x4. Would anyone be able to help me with what I am doing wrong here?
Yeah, I'm not sure how to dig into what the issue was (definitely weird though)
<@!134416332509675520> building solana from source (master) and now running 1.10.0 fixes my issue (1.9.6 release did not). Strange though no?
That gives you all of the AccountInfo stuff, including the owner
`program.provider.connection.getAccountInfo(theAddress)`
makes sense - is there a method call that takes the public key as input and spits out which is the owning program?
I mention this above, but the only way to write to an account's data is via its owning program. The system program doesn't expose any way to write arbitrary data into an account it owns, so ==> if an account has data in it, can't be owned by the system program.
Because it's a custom struct, Multisig
how could you tell here that the multisig was owned by my own program and not owned by the system program?
<@!134416332509675520> I wanted to submit a small pr to add fetch pda functionality from `program.account` with just seeds. Do you think it would be better to have a separate `fetchPda` method or to add to the existing `fetch` method making it take either an address or seeds argument? For completeness sake, I was thinking of doing the same thing for `fetchMultiple`.
BN is for arbitrarily big integers, not floats
`new anchor.BN(0.1)` is always zero üôÇ
^ but `postTxnAcctBalance` is always 0 which tells me `send_sol` isn't being called properly
1.9.0 on the failing linux machine vs 1.10.0 will upgrade and report back. Thanks!
```
  it("test", async() => {
    const multisig = anchor.web3.Keypair.generate();
    const [multisigSigner, nonce] =
      await anchor.web3.PublicKey.findProgramAddress(
        [multisig.publicKey.toBuffer()],
        program.programId
      );
    const multisigSize = 1000; // Big enough.

    const ownerA = anchor.web3.Keypair.generate();
    const ownerB = anchor.web3.Keypair.generate();
    const owners = [ownerA.publicKey, ownerB.publicKey];

    const threshold = new anchor.BN(2);

    await program.rpc.createMultisig(owners, threshold, nonce, {
      accounts: {
        multisig: multisig.publicKey,
      },
      instructions: [
        await program.account.multisig.createInstruction(
          multisig,
          multisigSize
        ),
      ],
      signers: [multisig],
    });

    let preTxnAccountInfo = await program.provider.connection.getAccountInfo(ownerA.publicKey)
    let preAccountInfo = await program.provider.connection.getAccountInfo(multisig.publicKey)
    let preTxnAcctBalance = await program.provider.connection.getBalance(ownerA.publicKey);
    let preMultisigBalance = await program.provider.connection.getBalance(multisig.publicKey);

    await program.provider.connection
      .requestAirdrop(multisig.publicKey, LAMPORTS_PER_SOL)
      .then((sig) => program.provider.connection.confirmTransaction(sig, "confirmed"));

    await program.rpc.sendSol(new anchor.BN(0.1),
      { 
        accounts: {
          multisig: multisig.publicKey,
          receiver: ownerA.publicKey,
          systemProgram: anchor.web3.SystemProgram.programId
        },
        signers: [multisig],
      }
    );

    let multisigAccount = await program.account.multisig.fetch(
      multisig.publicKey
    );

    let postTxnAcctBalance = await program.provider.connection.getBalance(ownerA.publicKey);
    let postMultisigBalance = await program.provider.connection.getBalance(multisig.publicKey);

    assert(accountInfo);
```
test set up like so:
What am I doing incorrectly here with `try_borrow_mut_lamports`?

```
pub fn send_sol(ctx: Context<SendSol>, amount: u64) -> Result<()> {

        **ctx.accounts.multisig.to_account_info().try_borrow_mut_lamports()? -= amount;
        **ctx.accounts.receiver.to_account_info().try_borrow_mut_lamports()? += amount;

        Ok(())
    } 
```
Every now and then some weird stuff can happen based on the solana version
Ah, interesting. Same version of solana?
<@!134416332509675520> 
Seems like it's related to the machine i'm running it on. It's failing on my linux machine.
Just pushed and tested on my M1 and there it works..?
Yes, but a private one that I can't share here (just yet).
ah this is helpful
Also, that log doesn't look like it's getting to the send_sol part, it's still in CreateMultisig
It's a little bit of an odd process, 0x1778 = 6008, which is I believe one of your own custom errors (do you have an error enum?)
i don't. Feel free to point me to whatever documentation or a blogpost though
Do you know how to find those custom errors?
```Transaction simulation failed: Error processing Instruction 1: custom program error: 0x1778 
    Program 11111111111111111111111111111111 invoke [1]
    Program 11111111111111111111111111111111 success
    Program 5q6Nk8kyxa2Kkc7RSi5eouNDneRQYoyiK6ud28R2m5Uq invoke [1]
    Program log: Instruction: CreateMultisig
    Program log: Custom program error: 0x1778
    Program 5q6Nk8kyxa2Kkc7RSi5eouNDneRQYoyiK6ud28R2m5Uq consumed 3630 of 200000 compute units
    Program 5q6Nk8kyxa2Kkc7RSi5eouNDneRQYoyiK6ud28R2m5Uq failed: custom program error: 0x1778```
test case, is the same, but I'm getting:
hm, now I have my rpc method set up like so:

```
pub fn send_sol(ctx: Context<SendSol>, amount: u64) -> Result<()> {

        **ctx.accounts.multisig.to_account_info().try_borrow_mut_lamports()? -= amount;
        **ctx.accounts.receiver.to_account_info().try_borrow_mut_lamports()? += amount;

        // let ix = anchor_lang::solana_program::system_instruction::transfer(
        //     &ctx.accounts.multisig.key(),
        //     &ctx.accounts.receiver.key(),
        //     amount,
        // );

        // anchor_lang::solana_program::program::invoke(
        //     &ix,
        //     &[
        //         ctx.accounts.multisig.to_account_info(),
        //         ctx.accounts.receiver.to_account_info(),
        //         ctx.accounts.system_program.to_account_info(),
        //     ],
        // )?;

        Ok(())
    } 
```
Is your code in a github repo anywhere?
Hmm, interesting, I'm not sure what's going on there
Program log: FINAL 
Is the last log I do before returning Ok(()).
<@!134416332509675520> 

https://pastebin.com/KfsJGuFt

(Discord won't let me post it)
Can you post the full program log?
Hi

I'm receiving a custom error: 0x0 at the end of my transaction but only when I initialize a token_account using:
```
    #[account(
        init,
        payer = signer,
        seeds = [SEED.as_bytes()],
        bump,
        token::mint = mint,
        token::authority = signer
    )]
    pub token_account: Account<'info, TokenAccount>
```

During the transaction I even do a CPI call using that token account successfully, so it seemingly is not failing during initialization but rather during something anchor does after executing my instruction handler code?

Any ideas on how to fix this?
thanks <@!134416332509675520> <@!915682383905316864>
You'll have to do the transfer manually, using `try_borrow_mut_lamports()` etc.
That only works when the source is a system program account (in general, in solana every account is owned by some program, and *only* that program is allowed to mutate the account's data or spend the account's money)
You won't be able to use the system program's transfer function
Actually, is the Multisig owned by your own program?
damn, thanks for pointing this out
When you do a transfer, the source and the destination both need to be mut
Yep `    8xjfVQ6hMn2jkNETAvWAkb6W5XbMCWvXCtWeU3vFRzEi's writable privilege escalated
`
```
Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account 
    Program 5q6Nk8kyxa2Kkc7RSi5eouNDneRQYoyiK6ud28R2m5Uq invoke [1]
    Program log: Instruction: SendSol
    8xjfVQ6hMn2jkNETAvWAkb6W5XbMCWvXCtWeU3vFRzEi's writable privilege escalated
    Program 5q6Nk8kyxa2Kkc7RSi5eouNDneRQYoyiK6ud28R2m5Uq consumed 3958 of 200000 compute units
    Program 5q6Nk8kyxa2Kkc7RSi5eouNDneRQYoyiK6ud28R2m5Uq failed: Cross-program invocation with unauthorized signer or writable account
    1) test
    ‚úî Tests the multisig program (2255ms)
Transaction simulation failed: Error processing Instruction 1: custom program error: 0x1778 
    Program 11111111111111111111111111111111 invoke [1]
    Program 11111111111111111111111111111111 success
    Program 5q6Nk8kyxa2Kkc7RSi5eouNDneRQYoyiK6ud28R2m5Uq invoke [1]
    Program log: Instruction: CreateMultisig
    Program log: Custom program error: 0x1778
    Program 5q6Nk8kyxa2Kkc7RSi5eouNDneRQYoyiK6ud28R2m5Uq consumed 3630 of 200000 compute units
    Program 5q6Nk8kyxa2Kkc7RSi5eouNDneRQYoyiK6ud28R2m5Uq failed: custom program error: 0x1778
    ‚úî Assert Unique Owners
  2 passing (22s)
  1 failing
```
Yeah probably need to mark the multisig as mut
Can you post the program log? (Not the js stack trace) It will include a line that gives you more info
test looks like:

```
const anchor = require("@project-serum/anchor");
const assert = require("assert");
const solana = require("@solana/web3.js");

const { LAMPORTS_PER_SOL } = solana;

describe("multisig", () => {
  // Configure the client to use the local cluster.
  anchor.setProvider(anchor.Provider.env());

  const program = anchor.workspace.SerumMultisig;

  it("test", async() => {
    const multisig = anchor.web3.Keypair.generate();
    const [multisigSigner, nonce] =
      await anchor.web3.PublicKey.findProgramAddress(
        [multisig.publicKey.toBuffer()],
        program.programId
      );
    const multisigSize = 1000; // Big enough.

    const ownerA = anchor.web3.Keypair.generate();
    const ownerB = anchor.web3.Keypair.generate();
    const owners = [ownerA.publicKey, ownerB.publicKey];

    const threshold = new anchor.BN(2);

    await program.rpc.createMultisig(owners, threshold, nonce, {
      accounts: {
        multisig: multisig.publicKey,
      },
      instructions: [
        await program.account.multisig.createInstruction(
          multisig,
          multisigSize
        ),
      ],
      signers: [multisig],
    });

    await program.provider.connection
      .requestAirdrop(multisig.publicKey, LAMPORTS_PER_SOL)
      .then((sig) => program.provider.connection.confirmTransaction(sig, "confirmed"));

    await program.rpc.sendSol(new anchor.BN(0.1),
      { 
        accounts: {
          multisig: multisig.publicKey,
          receiver: ownerA.publicKey,
          systemProgram: anchor.web3.SystemProgram.programId
        },
        signers: [multisig],
      }
    );


    let multisigAccount = await program.account.multisig.fetch(
      multisig.publicKey
    );

    let accountInfo = await program.provider.connection.getAccountInfo(multisig.publicKey)
    let txnAccountInfo = await program.provider.connection.getAccountInfo(ownerA.publicKey)

    assert(accountInfo);
  });
  ```
My `lib.rs` looks like:

```#[program]

pub mod multisig {
    pub fn create_multisig(
        ctx: Context<CreateMultisig>,
        owners: Vec<Pubkey>,
        threshold: u64,
        nonce: u8,
    ) -> Result<()> {
        assert_unique_owners(&owners)?;
        require!(
            threshold > 0 && threshold <= owners.len() as u64,
            InvalidThreshold
        );
        require!(!owners.is_empty(), InvalidOwnersLen);

        let multisig = &mut ctx.accounts.multisig;
        multisig.owners = owners;
        multisig.threshold = threshold;
        multisig.nonce = nonce;
        multisig.owner_set_seqno = 0;
        Ok(())
    }

     pub fn send_sol(ctx: Context<SendSol>, amount: u64) -> Result<()> {
        let ix = anchor_lang::solana_program::system_instruction::transfer(
            &ctx.accounts.multisig.key(),
            &ctx.accounts.receiver.key(),
            amount,
        );

        anchor_lang::solana_program::program::invoke(
            &ix,
            &[
                ctx.accounts.multisig.to_account_info(),
                ctx.accounts.receiver.to_account_info(),
                ctx.accounts.system_program.to_account_info(),
            ],
        )?;

        Ok(())
    } 
}

#[derive(Accounts)]
pub struct SendSol<'info> {
    #[account(signer)]
    pub multisig: Box<Account<'info, Multisig>>,
    #[account(mut)]
    pub receiver: AccountInfo<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct CreateMultisig<'info> {
    #[account(zero, signer)]
    multisig: Box<Account<'info, Multisig>>,
}

#[account]
pub struct Multisig {
    pub owners: Vec<Pubkey>,
    pub threshold: u64,
    pub nonce: u8,
    pub owner_set_seqno: u32,
}```
üëã running into this error: ```     Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account
      at Connection.sendEncodedTransaction (node_modules/@solana/web3.js/lib/index.cjs.js:6820:13)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at async Connection.sendRawTransaction (node_modules/@solana/web3.js/lib/index.cjs.js:6775:20)
      at async sendAndConfirmRawTransaction (node_modules/@solana/web3.js/lib/index.cjs.js:9098:21)
      at async Provider.send (node_modules/@project-serum/anchor/dist/cjs/provider.js:90:22)
      at async Object.rpc [as sendSol] (node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:31:31)
      at async Context.<anonymous> (tests/multisig.js:65:5)
```
got it üÜó
Or at least, the JS client *does* recognize that
It should recognize that that address needs to sign
Yep
Yeah, I guess the python client isn't interpreting the IDL quite right
Might be some error reporting improvement possible on the Python client specifically?
Since that's a common mistake
I wonder why I hadn't run into that same error in JS before
Ha, interesting ü§î
well, this worked üôÉ
oh, i see.
(Whereas if it were a PDA, then the program itself would have to sign for it)
In this case the new address is a keypair address, so it needs to sign from the client
Yeah, because any time you create an account, its address needs to sign
the mint account needs to sign for its own creation? hm?
Yeah
he means the mint account
really? even if it's payer? shouldn't payer already (implicitly) be in that array?
One thing that looks wrong (but not sure it would lead to that specific error) is that you probably need to add that keypair to the signers array
using this client quite successfully in other project, FYI.
I've never heard of that error. Sounds client-side?
yes. cc <@!856894333180706876> .
Is this the Python client?
<@!134416332509675520> anything look horribly wrong here? still can't get past the "failed to sanitize accounts" error.

indeed, i want to make a mint, whose authority is the person that creates this mint.
yup
sure but your account is screwed because you can't resize it
Same with option.
For sure!. Though if you have a vec and use default, it will error as soon as you try to insert.
definitely! It's dangerous if you have vectors and stuff
maybe we should just remove the attempt to automatically calculate the space
so do i
Yeah, I honestly pretty much always just manually calculate the space, for these kinds of reasons
A while back I got some weird results using `std::mem::size_of` (I believe due to alignment padding?) so I decided never to use it. I've seen a mango contract use it though so might be ok? https://github.com/blockworks-foundation/voter-stake-registry/blob/master/programs/voter-stake-registry/src/state/deposit_entry.rs#L43
I'm writing an anchor contract where I transfer SOL around. If I create a transaction account like so: 

```await program.account.transaction.createInstruction(
          transaction,
          txSize
        ),```

This prevents me from specifying enough SOL into the account. Is there a method I can use to airdrop SOL to a particular keypair's account?
gotcha thanks
std::mem::size_of might do the right thing. About Default, the way that works with regards to space is anchor just constructs a default instance of your type and then borsh serializes it and see how many bytes it takes
wrt sizing `space` using `Default` -- let's say I have a type that is statically sized but I don't want to necessarily implement `Default` for -- is there a way to separate these two notions (something with `Space` and something with `Default`? other than manually sizing space (though maybe there's an idiomatic way to do that -- don't think `std::mem::size_of` does the right thing?)
Makes sense
Basically the way to learn this stuff is just by source-diving.
Have you read through the anchor source? https://github.com/project-serum/anchor/blob/master/ts/src/program/namespace/account.ts#L132
thanks, yeah, figured b/c of orphan rule
You would need to wrap it in a new struct, as far as I can see.
How could I go about debugging this error?

```throw new Error(
              ^
Error: Transaction instruction index 2 has undefined program id```


//////////////////////////////////////////////////////////////////////////////////////////

Thank you for this!
https://discord.com/channels/889577356681945098/889702325231427584/939323253934153741
`The owner of the smart wallet doesn't match with current.` There's your hint lol
Thanks! M pretty much newer than you so...
Sure, that depends on when i'm available,
i'm new to solana/rust too, so i'll try my best !
```Transaction simulation failed: Error processing Instruction 0: custom program error:
0x1771
    Program Govz1VyoyLD5BL6CSCxUJLVLsQHRwjfFj1prNsdNg5Jw invoke [1]
    Program log: Instruction: CreateGovernor
    Program 11111111111111111111111111111111 invoke [2]
    Program 11111111111111111111111111111111 success
    Program log: GovernorNotFound: The owner of the smart wallet doesn't match with c
urrent.
    Program log: self.smart_wallet.owners.contains(&self.governor.key())
    Program log: Error thrown at programs/govern/src/account_validators.rs:8
    Program log: Custom program error: 0x1771
    Program Govz1VyoyLD5BL6CSCxUJLVLsQHRwjfFj1prNsdNg5Jw consumed 16250 of 200000 com
pute units
    Program Govz1VyoyLD5BL6CSCxUJLVLsQHRwjfFj1prNsdNg5Jw failed: custom program error
: 0x1771
    1) "before all" hook for "test"


  0 passing (2s)
  1 failing

  1) liquidityMiner
       "before all" hook for "test":
     Error: failed to send transaction: Transaction simulation failed: Error processi
ng Instruction 0: custom program error: 0x1771
      at Connection.sendEncodedTransaction (node_modules/@solana/web3.js/src/connecti
on.ts:3961:13)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at Connection.sendRawTransaction (node_modules/@solana/web3.js/src/connection.t
s:3918:20)```
https://github.com/project-serum/anchor/issues/793#issuecomment-926915660
I think that's right since you could have multiple instances of an account type with different seeds. A small convenience, but I have a pr in be able to fetch with just seeds. https://github.com/project-serum/anchor/pull/1445
has anybody come across this one before? `error: the `#[global_allocator]` in this crate conflicts with global allocator in: mpl_token_metadata`
hey if i have problems down the line regarding PDAs can I shoot you a dm?
The new methods API saves you from having to calculate a PDA client side when you create it, but wouldn't you still need to still calculate PDAs if you have to pass it in to another function at a later point?
What's the full log?
see `anchor.web3.PublicKey.findProgramAddress`
When re-deriving you can calculate it off-chain using the JS bindings and pass it as an instruction parameter
oh okay thanks!
It's calculated for you in this function `find_program_address`
https://docs.rs/anchor-lang/0.21.0/anchor_lang/prelude/struct.Pubkey.html#method.find_program_address
I don't think I fully understand this.. can you tell me how i can calculate the bump?
It's basically an u8 number [0-254] that solana calculates for u
used to derive the PDA such that it doesn't reside on the epileptic curve.

black magic but that's how PDAs work
Thanks, I will check this out
Okay this is starting to make sense..
What is bump exactly?
You can read about account constraints here
https://docs.rs/anchor-lang/0.21.0/anchor_lang/derive.Accounts.html
very helpful
Here you're not using program derived accounts (PDA), you're using plain accounts
PDAs are created when you pass seeds in #[account] macro,

the combination of seeds you pass to the macro make each derived account unique to what you give it,
so, if each 'vibe' has a user, you can pass the user's pubkey as a seed in addition to extra piece of identifing data such as b"vibe_post"

in create post u can have:
```
#[account(
  init, payer = author,
  seeds = [
    b"vibe_post",
    author.key().as_ref()
  ], // Seeds are sent as buffers [u8]
  bump // This calculates the bump
)]
pub vibe: Account<'info, Vibe>
```

and you can re-derive it in updatelikes by passing the seeds & bump without the init and payer, also good practice to calculate the bump off-chain to reduce computation cost

as such you can handle the likes/comments  you can have PDA derived using the post's key and user's key.
what is this error: ```custom program error: 0x1771``` and ```custom program error: 0xbc4```
üëã when using wallet from getProvider, is this redundant when calling client methods? `signers: [wallet.payer]` ? seems to auto inject `wallet.payer`
```rust


#[error]
pub enum ErrorCode {
    #[msg("The provided topic should be 50 characters long maximum.")]
    TopicTooLong,
    #[msg("The provided content should be 300 characters long maximum.")]
    ContentTooLong,
}

//Size of a Vibe
const DISCRIMINATOR_LENGTH: usize = 8;
const PUBLIC_KEY_LENGTH: usize = 32;
const TIMESTAMP_LENGTH: usize = 8;
const STRING_LENGTH_PREFIX: usize = 4;
const MAX_TOPIC_LENGTH: usize = 50 * 4;
const MAX_CONTENT_LENGTH: usize = 300 * 4;
const MAX_LIKES_LENGTH: usize = 4;

impl Vibe {
    const LEN: usize = DISCRIMINATOR_LENGTH
        + PUBLIC_KEY_LENGTH // Author.
        + TIMESTAMP_LENGTH // Timestamp.
        + STRING_LENGTH_PREFIX + MAX_TOPIC_LENGTH // Topic.
        + STRING_LENGTH_PREFIX + MAX_CONTENT_LENGTH // Content.
        + MAX_LIKES_LENGTH; // Likes.
}
```
```rust
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod solvibe_social {
    use super::*;

    pub fn create_vibe(ctx: Context<CreateVibe>, topic: String, content: String) -> ProgramResult {

        let vibe = &mut ctx.accounts.vibe;
        let author = &mut ctx.accounts.author;
        let clock = Clock::get().unwrap();

        if topic.chars().count() > 50 {
            return Err(ErrorCode::TopicTooLong.into())
        }

        if content.chars().count() > 300 {
            return Err(ErrorCode::ContentTooLong.into())
        }

        vibe.author = *author.key;
        vibe.timestamp = clock.unix_timestamp;
        vibe.topic = topic;
        vibe.content = content;
        vibe.likes = 0;

        Ok(())
    }

    pub fn update_likes(ctx: Context<UpdateLikes>) -> ProgramResult {
        let vibe = &mut ctx.accounts.vibe;
        
        vibe.likes += 1;
        
        Ok(())
    }

    pub fn delete_vibe(_ctx: Context<DeleteVibe>) -> ProgramResult {
        Ok(())
    }

}

#[derive(Accounts)]
pub struct CreateVibe<'info> {
    #[account(init, payer = author, space = Vibe::LEN)]
    pub vibe: Account<'info, Vibe>,
    #[account(mut)]
    pub author: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct UpdateLikes<'info> {
    #[account(mut)]
    pub vibe: Account<'info, Vibe>,
    #[account(mut)]
    pub liker: AccountInfo<'info>,
}

#[derive(Accounts)]
pub struct DeleteVibe<'info> {
    #[account(mut, has_one = author, close = author)]
    pub vibe: Account<'info, Vibe>,
    pub author: Signer<'info>,
}

#[account]
pub struct Vibe {
    pub author: Pubkey,
    pub timestamp: i64,
    pub topic: String,
    pub content: String,
    pub likes: u32,
}

```
Hey <@!134416332509675520>! Sorry for tagging but I am having a lot of difficulty wrapping my head around PDAs, mainly how to structure my program.

So I am building a social media app where every post made by a wallet publickey is an account, and users can like a post, but I have no way of restricting an user from liking a post twice. So how do I implement that using a PDA?

the code (P.S. vibe here means post)
has anybody done an anchor wrapper for mpl-token-metadata?
I'm doing it this way
```rust
        let accountParsed = Self::deserialize(&mut &**user_account_info.try_borrow_data()?.deref()).unwrap();```
I am able to do this in rust but maybe there's better way to do it using anchor ?
up please :))
Anyone had this issue before? ```utx0@i5750 hydra-protocol]$ anchor build
BPF SDK: /home/utx0/.local/share/solana/install/releases/1.9.6/solana-release/bin/sdk/bpf
cargo-build-bpf child: rustup toolchain list -v
cargo-build-bpf child: cargo +bpf build --target bpfel-unknown-unknown --release
Unable to get file metadata for /home/utx0/Code/hydra/hydra-protocol/target/bpfel-unknown-unknown/release/hydra_staking.so: No such file or directory (os error 2)
```
i think the problem is with phantom some times i get this err but when i approve the transaction it seems to be executed successfully
remaining_accounts are accountInfos, by I want to deserialize them to certain struct
Hello, how to deserialize accountInfo data to struct ?
for the transactions I've written, I'm getting a bunch of `transaction may fail to confirm` in phantom. in the end, the transactions go through normally though. 
What could be the reasons it says that it may fail? 
Is it possible that the transaction is too long to be simulated (I'm doing multiple CPI calls), or is there any other reasons?
is there a way to load account struct for a remaining_account ?
and is the index flag actually used by anything other than to mark index=true in IDL?
are there any guidelines for which fields in an event should be marked index?
<@!134416332509675520> https://solanacookbook.com/guides/feature-parity-testing.html#scenario
Looks like the compute limits have changed since Solana 1.9.2
ok i lied it wasn't my last question üòâ i thought it was tho
why doesn't the number of compute units reset when I call `RebalanceSolend` then?
My personal instructions are `GetBalanceSolend` and `RebalanceSolend`

Above looks like the call to Refresh Reserve used up a lot of compute, `consumed 139784 of 200000 compute units`
So at that point in the log you're basically screwed üò¥
That means that at that point in the code, you had 8548 units of compute remaining, and this chunk of it used up 2661 of those units
gotcha, will do. And last question -- im not sure how to read this: `consumed 2661 of 8548 compute units`
Ah, sorry, not sure! Might have to ask in the solana discord
this is super helpful, thanks alan. Next questions for me are:
1 - wen compute budget increase? Transactions look up table proposal has been out for a while, but i've heard no progress on it.
2 - wen txn byte limit increase?
https://jstarry.notion.site/Transaction-Fees-f09387e6a8d84287aa16a34ecb58e239#6c4bae9a910641028cc4f3a747be7a6d
Yep (weirdly, and not for long)
for a total of 600K
oh wait i misunderstood this.
"Each separate instruction (sent from the client) gets a "compute budget" of 200k "units"."

So this means that if I submit a txn with instr1, instr2, and instr3, then each of those instructions gets a compute budget of 200k?
new API? What do u mean by that
There's also a new API (can't remember if it's out yet) where you can request more units
It's possible that you can try some tricks, like splitting your code up into multiple separate instructions from the client (each gets its own 200k budget)
This is extremely limiting. This means that the entire smart contract I am developing simply will not work in Solana
Each operation you do uses them up: https://github.com/solana-labs/solana/blob/master/program-runtime/src/compute_budget.rs#L22
Lol
Each separate instruction (sent from the client) gets a "compute budget" of 200k "units".
XD nice name
`consumed 20930 of 85587 compute units` 
What exactly does this mean?
i was planning on adding 3 more instructions :/
Ah, yeah, that's just saying that you ran out of compute units
Hmm, it does kind of look like you might just be running out of compute units
I called solend's instruction, which then called `Transfer` and `MintTo`, and did some other things
gotcha, will do from now on
```
Transaction simulation failed: Error processing Instruction 1: Program failed to complete 
    Program 7V9nbaCYjAw7LRUXnD6gwo6fGLrea86QAx1cstUxwEmJ invoke [1]
    Program log: Instruction: GetBalanceSolend
    Program ALend7Ketfx5bxh6ghsCDXAoDrhvEmsXT3cynB6aPLgx invoke [2]
    Program log: Instruction: Refresh Reserve
    Program ALend7Ketfx5bxh6ghsCDXAoDrhvEmsXT3cynB6aPLgx consumed 20930 of 85587 compute units
    Program ALend7Ketfx5bxh6ghsCDXAoDrhvEmsXT3cynB6aPLgx success
    Program 7V9nbaCYjAw7LRUXnD6gwo6fGLrea86QAx1cstUxwEmJ consumed 139784 of 200000 compute units
    Program 7V9nbaCYjAw7LRUXnD6gwo6fGLrea86QAx1cstUxwEmJ success
    Program 7V9nbaCYjAw7LRUXnD6gwo6fGLrea86QAx1cstUxwEmJ invoke [1]
    Program log: Instruction: RebalanceSolend
    Program ALend7Ketfx5bxh6ghsCDXAoDrhvEmsXT3cynB6aPLgx invoke [2]
    Program log: Instruction: Deposit Reserve Liquidity
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [3]
    Program log: Instruction: Transfer
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 2661 of 8548 compute units
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [3]
    Program log: Instruction: MintTo
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 2517 of 3001 compute units
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success
    Program ALend7Ketfx5bxh6ghsCDXAoDrhvEmsXT3cynB6aPLgx consumed 27146 of 27146 compute units
    Program failed to complete: exceeded maximum number of instructions allowed (27146) at instruction #39135
    Program ALend7Ketfx5bxh6ghsCDXAoDrhvEmsXT3cynB6aPLgx failed: Program failed to complete
    Program 7V9nbaCYjAw7LRUXnD6gwo6fGLrea86QAx1cstUxwEmJ consumed 200000 of 200000 compute units
    Program 7V9nbaCYjAw7LRUXnD6gwo6fGLrea86QAx1cstUxwEmJ failed: Program failed to complete
```
As a general rule, it's way easier to debug if you post the full log, not just a snippet
```Program failed to complete: exceeded maximum number of instructions allowed (27146) at instruction #39135```
I only did like 4 instructions in this transaction though
got it üòâ
ohhhh
basically i'm doing a CPI call to transfer my program's token account tokens into Solend's token acc
the test is failing
Annoyingly if the test passes then you'll have to go look for the log in the `.anchor/program-logs/` directory, but yeah
Can I log stuff into my console from my smart contract? E.g. do like a `msg!()` and then it shows up when I run my tests?
ahh gotcha. Thanks alan üôÇ
So that means you somehow didn't sign for some account that needs to sign
Yep
`signer privilege escalated`?
```
Transaction simulation failed: Error processing Instruction 1: Cross-program invocation with unauthorized signer or writable account 
    Program 7V9nbaCYjAw7LRUXnD6gwo6fGLrea86QAx1cstUxwEmJ invoke [1]
    Program log: Instruction: GetBalanceSolend
    Program ALend7Ketfx5bxh6ghsCDXAoDrhvEmsXT3cynB6aPLgx invoke [2]
    Program log: Instruction: Refresh Reserve
    Program ALend7Ketfx5bxh6ghsCDXAoDrhvEmsXT3cynB6aPLgx consumed 18824 of 85587 compute units
    Program ALend7Ketfx5bxh6ghsCDXAoDrhvEmsXT3cynB6aPLgx success
    Program 7V9nbaCYjAw7LRUXnD6gwo6fGLrea86QAx1cstUxwEmJ consumed 137678 of 200000 compute units
    Program 7V9nbaCYjAw7LRUXnD6gwo6fGLrea86QAx1cstUxwEmJ success
    Program 7V9nbaCYjAw7LRUXnD6gwo6fGLrea86QAx1cstUxwEmJ invoke [1]
    Program log: Instruction: RebalanceSolend
    5swfzZhm1CEAoXNbYWrnLGw9LQg8ZPMwJu51fXTCUFqB's signer privilege escalated
    Program 7V9nbaCYjAw7LRUXnD6gwo6fGLrea86QAx1cstUxwEmJ consumed 172899 of 200000 compute units
    Program 7V9nbaCYjAw7LRUXnD6gwo6fGLrea86QAx1cstUxwEmJ failed: Cross-program invocation with unauthorized signer or writable account
```
The full program log will have a line that says whether you messed up signing or if you forgot to mark something as mut
`Cross-program invocation with unauthorized signer or writable account`

How am I supposed to debug this?
Oh, not even by manually editing the code?
<@!134416332509675520>  The test is happy now. Really appreciate your (continuous) help!
so you would use zero to indicate that you haven't used init elsewhere in the program - like you had created a large account in another instruction outside of the program. the composite example follows this pattern https://github.com/project-serum/anchor/blob/master/tests/composite/programs/composite/src/lib.rs
One situation where this is actually necessary is if you want to create a really big account. The max you can do via a CPI to the system program (e.g. with `init`) is 10kb. But if you issue a separate instruction to the system program, rather than using a CPI, you can go up to 10mb.
When you allocated the account in a separate instruction
what is the case where the discriminator bytes are not yet set?
Assuming the multisig account is a keypair address, you'll need to add it to the `signers: [...]` array
I remember I got a 'unknown' signer` error, but will check again. thanks!
Then you can pass it along to the CPI call you make to the multisig program
So like
```.rs
#[account(mut)]
pub multisig: Signer<'info>
```
Ok, then your own program probably doesn't even need to use the Multisig type at all for this, you can pass the multisig account in as just a `Signer<'info>` (it has to sign so that the multisig program can init an account there)
yes!
Ah, so your program is going to ask the serum multisig to init the Multisig account?
what does the zero account attribute do?
sorry let me try to elaborate.. My intent is to use the `project-serum/multisig` program via CPI. (not being super confident about implementing my own multisig.) so the initiation of the multisig (along with other instructions) should be done on the `serum-multisig` side while my program will do other things...
Mm, not totally sure I understand what you want to do ü§î
Just to double check, why do you want to init the Multisig account on the client? Can you not do it with a regular `init` attribute?
so I can try init the `Multisig` Account on the caller side (as I wish) and then pass it to the callee(puppet, multisig program) and it will take it from there?
I wouldn't have guessed that it would matter much if you stick it in the heap or not.
The use of the heap here is just about where the deseriaized Multisig struct will live.
What do you mean in the heap?
the init process happends in the cpi callee side (in heap), so I thought I need to be consistent.
Have you already initialized that Multisig account?
zero has nothing necessarily to do with the heap
And `zero` means: "anchor, please don't freak out that this account doesn't have its discriminator bytes set yet"
Are you sure you need the Box at all?
hi, it's the multisig program again... I have an account marked 
```rust
#[account(zero, signer)]
multisig: Box<Account<'info, Multisig>>,
```
This part triggers this error:
```bash
Program log: panicked at 'range end index 8 out of range for slice of length 0', programs/shard/src/lib.rs:108:10
```
My understanding is this `Multisig` Account is intended to store in heap, hence the Box and zero discriminator. It was fine with only this account and the program, but if I try to add other accounts, I get this. Is this relative to the other accounts I'm passing within the same Context...?
Can you post more info, a program log, etc.?
What makes you think it needs to be mut?
Not actually sure if there's a way to turn that off
anchor client program
What do you mean by wallet program? It's an actual program, not just some regular account?
bump, sorry for the @ but i've been stuck on this or awhile
No everything is working perfectly it‚Äôs just that it‚Äôs printing the whole program output when it shouldn‚Äôt
^ bonus points if there's a way to link the repos within VSCode :p
how can I quickly find which repo/folder/file defines `spl_token::state::Account`?
If I have the following code snippet:

```
#[derive(Clone)]
pub struct TokenAccount(spl_token::state::Account);

impl TokenAccount {
    pub const LEN: usize = spl_token::state::Account::LEN;
}
```
Hey, quick question about source diving / how serum/SPL code bases are configured
Does `Unknown program metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s` mean i'm passing incorrect instruction data ?
`Program 2R7cpyuKTpjepFoW5YdyAZ6XFERY32CKm9hG2EA5TT1F failed: An account required by the instruction is missing`
bumping this
Not sure if this is what your talking about but, I got an error where whenever I deploy to devnet it would just print `msg <ADDRESS>`  alot. But then I updated to anchor and solana versions and that helped: https://stackoverflow.com/questions/70437644/error-custom-invalid-blockhash-when-solana-program-deploy
The whole program output
<@!134416332509675520> I have 3 programs wallet program, A and B.  Wallet sends a transaction to A to make a CPI call to B. B initializes an account with `account(init)` to make an account , the payer is wallet program. Does the wallet program have to be marked as  `account(mut)` in the program B?
I'm actually not quite sure what you mean, what is it logging?
<@!134416332509675520> hey man sorry to @ but you‚Äôd be coming clutch if you could help out on this small thing
it's not beta that's causing it I'm pretty sure
why are you using beta man? Use stable one
If anyone knows please let me know
mind if I dm you?
sure
Actually if you want to do a discord call, think this will be easier to explain over voice
So the multisig program says "... ok, everything looks good, I'll sign for this special address and pass it along to whatever CPI you want to do"
The point of the original multisig code is to programmatically sign for an address, the multisigSigner, only if the multisig conditions are met, and then invoke some transaction via CPI
Hey, I'm using `@project-serum/anchor@^0.17.1-beta.1` and when I try to submit a transaction it prints out all the program logs even tho I'm not doing any console.log, do you know which bit do I need to change?
What's the purpose in the original code?
`Signer<'info>` verifies that the account did indeed sign
Yes
Oh so you are suggesting this that `multisig_signer: Signer<'info>` is literally just used to check that the multisig_signer has `isSigner` set to `true`?
It serves a clear purpose in the original multisig code, not totally sure if it does in yours though
About why you need the multisig_signer, I don't know haha, if you aren't using it then I guess you don't need it
`Signer<'info>`
Wait none of it is being marked as a signer right?

```
#[derive(Accounts)]
pub struct Auth<'info> {
    #[account(mut)]
    multisig: Box<Account<'info, Multisig>>,
    #[account(
        seeds = [multisig.key().as_ref()],
        bump = multisig.nonce,
    )]
    multisig_signer: Signer<'info>,
}
```
So it almost certainly doesn't make sense to mark it as a Signer (that says, this account needs to have *already* signed in order to invoke me)
Or, well‚Äîat any rate you can't sign for a PDA like that from the client
That won't work using `Signer` like that for the multisig_signer
I'm running into a newbie issue. I'm on M1. Cloned anchor repo and ran `cargo test` and am getting
```
error: failed to run custom build command for `hidapi v1.2.7`
warning: clang-12: error: the clang compiler does not support '-march=core2'
```
It is my understanding I should maybe be using clang 13, which is what `clang --version` spits out, but I have no idea how to tell rust to use clang 13 instead. I tried adding

```
.cargo/config:

rustflags = [
  "-C", "linker=clang",  # change the version as needed
]
```
but that's not working either. I also made sure I'm using the right M1 rustup tool thing:

```
anchor % rustup show

Default host: aarch64-apple-darwin
rustup home:  ~/.rustup

installed toolchains
--------------------

stable-aarch64-apple-darwin (default)
bpf

active toolchain
----------------

stable-aarch64-apple-darwin (default)
rustc 1.58.1 (db9d1b20b 2022-01-20)
```
```
pub fn set_owners(ctx: Context<Auth>, owners: Vec<Pubkey>) -> Result<()> {
        assert_unique_owners(&owners)?;
        require!(!owners.is_empty(), InvalidOwnersLen);

        let multisig = &mut ctx.accounts.multisig;

        if (owners.len() as u64) < multisig.threshold {
            multisig.threshold = owners.len() as u64;
        }

        multisig.owners = owners;
        multisig.owner_set_seqno += 1;

        Ok(())
    }

#[derive(Accounts)]
pub struct Auth<'info> {
    #[account(mut)]
    multisig: Box<Account<'info, Multisig>>,
    #[account(
        seeds = [multisig.key().as_ref()],
        bump = multisig.nonce,
    )]
    multisig_signer: Signer<'info>,
}
```

why do we need `multisig_signer` here with the corresponding macro if it's not used at all in the RPC call?
Have another question about the PDA as an account
no that makes sense, I guess that applies for all accounts if you get the `isSigner` boolean wrong
You're basically going out of your way to require a signature from the *recipient* of the transfer (wrong), and the the client is saying "... uh, you didn't sign lol"
yes, because the client checks that everythign that is supposed to sign actually has signed
does this cause an issue? if `isSigner` is set to `true` even if it doesn't need to be it would cause `Signature verification failed`?
Why would the ownerA need to sign?
Why are you setting `isSigner` to true on something?
```
  1) multisig
       encoding send sol:
     Error: Signature verification failed
      at Transaction.serialize (node_modules/@solana/web3.js/lib/index.cjs.js:2829:13)
      at Provider.send (node_modules/@project-serum/anchor/dist/cjs/provider.js:89:26)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at async Object.rpc [as executeTransaction] (node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:31:31)
      at async Context.<anonymous> (tests/multisig.js:164:5)
```
and still getting:
running:

```
await program.rpc.executeTransaction({
      accounts: {
        multisig: multisig.publicKey,
        multisigSigner,
        transaction: transaction.publicKey,
      },
      remainingAccounts: program.instruction.sendSol
        .accounts({
          multisig: multisig.publicKey,
          receiver: ownerA.publicKey,
        })
        // Change the signer status on the vendor signer since it's signed by the program, not the client.
        .map((meta) =>
          meta.pubkey.equals(ownerA.publicKey)
            ? { ...meta, isSigner: true }
            : meta
        )
    });
```
I've updated structs to be:

```
#[derive(Accounts)]
pub struct SendSol<'info> {
    #[account(mut)]
    pub multisig: Box<Account<'info, Multisig>>,
    #[account(mut)]
    pub receiver: AccountInfo<'info>,
}
```
hm, i don't think is it


//////////////////////////////////////////////////////////////////////////////////////////

> The point of the multisigSigner PDA is that it's the thing that will sign if the multisig conditions are met

Right. Just want to check my logic here, if I have a multisig wallet and I want to create an SPL token account for that wallet, I'd do something like:

```
 mintA = await splToken.Token.createMint(
  program.provider.connection,
  payer,
  mintAuthority.publicKey,
  null,
  0,
  splToken.TOKEN_PROGRAM_ID
);

let multisigTokenAcct = await mintA.createAccount(arbitraryTokenAcct.publicKey);
```

Here the logical owner/authority of the `multisigTokenAcct` is this `arbitraryTokenAcct.publicKey`. Now, as you mentioned above, we use the `multisigSigner` PDA if the multisig conditions are met. 

To initialize this `multisigTokenAcct`, we need to change the authority to ensure that its the `multisigSigner` PDA right?
okay thanks!
yup
how do I do decimal computation with `anchor.BN` in typescript?
Small doubt: When I do something like `seeds = [b"vibe_post", author.key().as_ref()]`, it means that each account created should have a different author, right?
the size of the .so file
what is meant by program size, here?
doh, thank you!
`ctx.accounts.token_account.amount;`
any recommendations on how to determine what is contributing to program size?
Is there a way for an on chain program to know the balance of a token account which is passed into the instruction?
Noob question:

in theory, how to get the **user to sign a transaction** and, at the same time, my app will **sign this transaction using my program authority**?

> considering I can't use the program authority private key in the frontend, and having to sign it through an API, which it seems I can't have the user to sign it at the same time because there is no window and no phantom wallet extension. 

Sry for the confusion appreciate if someone can shine some light.
agreed. https://github.com/project-serum/anchor/pull/1451 <@!208527206966755329>
Interesting. Before upgrading my solana cli version to 1.9.5 , it was really fast, but now it takes 2+ mins
Shouldn't have anything to do with your program itself though
Dunno, that depends on how the cluster is doing/how big your program is
yeah restarting the IDE fixed that error. 
How long should deploying my program take?
maybe something is wrong with my IDE... will restart
So, wait, did the error resolve itself? How did you deploy if there's an error?
Ok so the program deployed but it took a realllllly long time
<@!134416332509675520>  im having two problems:
1) the error in the second pic
2) deploying my program to devnet. It's stuck at this: ```Deploying program "solend-cpi"...
Program path: ~/Desktop/accru/accrue/target/deploy/solendcpi.so...```
that's what im doing with solend
i would recommend just using their devnet program, so that everything is already set up
if i need another program on localnet, should I just start a test validator inside `.anchor` with `--clone` before running `anchor-test`?
+1 +1 +1
actually, this just has to do with using `solana_program = 1.9.5`, not `pubkey!`.  And your solution fixed it, ser alan.
wow..
Does that keep happening if you do `cargo clean` first?
alan, im getting a weird error here when using pubkey!
Heh, I used to work at a programming school (sort of, https://www.recurse.com/) and one class's parting gifts for us teachers were some sweet capes üòõ

It worked!! Not all heroes wear capes Alan.. not all heroes wear capes üò≠
You'll need to manually specify `space =` in your `init` chunk
Yeah, almost definitely (doesn't make sense to derive Default for the Vibe struct, because it has variable-sized types in it‚Äîthose Strings)
So maybe you don't have enough space allocated for that account?
0xbbc = 3004 = https://github.com/project-serum/anchor/blob/master/lang/src/error.rs#L120
```Transaction simulation failed: Error processing Instruction 0: custom program error: 0xbbc
    Program 3NcczXqNpzUsp6c2pGqLNJMnUwScvZBXduj8f3sg6Qdz invoke [1]
    Program log: Instruction: CreateVibe
    Program 11111111111111111111111111111111 invoke [2]
    Program 11111111111111111111111111111111 success
    Program log: Custom program error: 0xbbc
    Program 3NcczXqNpzUsp6c2pGqLNJMnUwScvZBXduj8f3sg6Qdz consumed 18817 of 200000 compute units
    Program 3NcczXqNpzUsp6c2pGqLNJMnUwScvZBXduj8f3sg6Qdz failed: custom program error: 0xbbc```

Getting closer I guess?
```.js
[Buffer.from("vibe_post"), author.toBuffer()]
```
I think
okay so can you help me with the syntax? something like
`[Buffer.from("vibe_post"), author.toBase58()]`
?
You're only using a single seed, `Buffer.from("vibe_post")`
You're not using the author's key in that `findProgramAddress` call (it needs to exactly match how you're doing it in rust)
test
```ts
it("can create a new vibe", async () => {
        const author = program.provider.wallet.publicKey;

        const [vibe, vibeBump] = await anchor.web3.PublicKey.findProgramAddress(
            [Buffer.from("vibe_post")],
            program.programId
        );

        console.log("Vibe:", vibe.toBase58());
        console.log("Bump:", vibeBump);
        console.log("ProgramId:", program.programId.toBase58());

        await program.rpc.createVibe("Vibe!", "Vibe Content!", vibeBump, {
            accounts: {
                vibe: vibe.toBase58(),
                author: author,
                systemProgram: anchor.web3.SystemProgram.programId,
            },
        });

        const createdVibe = await program.account.vibe.fetch(vibe.toBase58());

        assert.equal(createdVibe.topic, "Vibe!");
        assert.equal(createdVibe.content, "Vibe Content!");
        assert.equal(
            createdVibe.author.toBase58(),
            program.provider.wallet.publicKey.toBase58()
        );
        assert.equal(createdVibe.likes, 0);
        assert.ok(createdVibe.timestamp);
    });
```
Ok, how are you calling it from JS again?
account
```rust
#[account]
#[derive(Default)]
pub struct Vibe {
    pub author: Pubkey,
    pub timestamp: i64,
    pub topic: String,
    pub content: String,
    pub likes: u32,
    bump: u8,
}
```
The derive macro?
```rust
#[derive(Accounts)]
#[instruction(topic: String, content: String, vibe_account_bump: u8)]
pub struct CreateVibe<'info> {
    #[account(init, seeds = [b"vibe_post", author.key().as_ref()], bump = vibe_account_bump, payer = author)]
    pub vibe: Account<'info, Vibe>,
    #[account(mut)]
    pub author: Signer<'info>,
    pub system_program: Program<'info, System>,
}

```
Did you fix the `instruction(...)` part? Can you post your latest code?
gotcha, will try it now
Yeah
why isnt it working? has it got something to do with bump?
I don't think it will really matter
Oh i was told by Jacob from Solana that I should use solana_program = 1.8.14 , because that's what anchor is compatible with
Can try adding some random other solana-program version
Why not?
ooof... this might not work for me then... will have to see
Isn't that the same error as before?
```Transaction simulation failed: Error processing Instruction 0: Program failed to complete
    Program 3NcczXqNpzUsp6c2pGqLNJMnUwScvZBXduj8f3sg6Qdz invoke [1]
    Program log: Instruction: CreateVibe
    Program 3NcczXqNpzUsp6c2pGqLNJMnUwScvZBXduj8f3sg6Qdz consumed 10442 of 200000 compute units
    Program failed to complete: Could not create program address with signer seeds: Provided seeds do not result in a valid address
    Program 3NcczXqNpzUsp6c2pGqLNJMnUwScvZBXduj8f3sg6Qdz failed: Program failed to complete```
They are stored right in your program's code (so, strictly speaking they're stored in your program's account!)
Go for it
^ I also can't seem to get access to the `pubkey!` macro unless I had `solana-program = "1.9.5"` to my program's Cargo.toml, not totally sure why I need to do that :/
The idea is that *nothing at all* happens at runtime; it all happens ahead of time, when you compile your program. So there's zero runtime cost to build any pubkeys.
Take a look at the solana `pubkey!` macro
```.rs
use solana_program::pubkey;
const SOME_PUBKEY: Pubkey = pubkey!("asdfasdfadsfasdfasdf");
```
Shouldn't the conversion to pubkey only happen when we reach that line of code?
hey man tell me when you done with this ^
got a new error ü•≤
so where are those static variables stored at compile time?
yeah. Someone recommended that I store these values in a PDA that the user passes in instead, but I just can't afford to do that. Too many accounts being passed in
One thing that definitely jumps out, every one of those hardcoded pubkeys could be static variables computed at compile time. You're doing all that pubkey construction stuff at runtime.
So you're wondering about how to do less compute in there?
Whereas the multisig account itself just lives at some random keypair address, so you can sign for that address just by knowing its private key (so, totally independent of the multisig program's logic)
The point of the multisigSigner PDA is that it's the thing that will sign if the multisig conditions are met
each mint has its own reserve
E.g. if they pass in a fake reserve for Solend, then my program needs to check for that
It would be weird for the multisig (the account that stores the multisig details, the threshold etc.) were the authority over anything
So what i'm trying to do in this function is this:
* A user passed in a solend `mint`, corresponding  `reserve`, and `reserve_ctoken` into my program. I need to do CPI with solend, but I need to make sure they provided the right values first
cpi_program is the program that you're invoking (the program in cross-*program* invocation)
Ok so last time I reached the 200K compute cap. I found out why. It's because this function of mine is taking up 50K compute units
Got it. If we constantly need the multisig to sign transactions, it feels like the right thing to do here is set the authority as the multisig PDA. 

```
pub fn initialize_token_acct(ctx: Context<InitializeTokenAccount>) -> Result<()> {

    msg!("initialize token acct starting");

    let token_accounts = SetAuthority {
        current_authority: ctx.accounts.multisig.to_account_info().clone(),
        account_or_mint: ctx.accounts.multisig_token_program.to_account_info().clone()
    };

    msg!("set token_accounts: ");

    let cpi_program = ctx.accounts.token_program.to_account_info();

    msg!("set cpi_program: ");
    msg!("{:?}", cpi_program);

    token::set_authority(
        CpiContext::new(cpi_program, token_accounts),
        AuthorityType::AccountOwner,
        Some(*ctx.accounts.multisig_signer.key),
    )?;

    msg!("set authority");

    Ok(())
}
```

I have a few questions here:

1/ What is `cpi_program` here supposed to represent?
2/ "it feels like the right thing to do here is set the authority as the multisig PDA" <- is this the right thing to do here? If the logical owner is the multisig and we want the multisig to sign, should we be changing the authority to the multisig PDA/multisig signer? Or am I thinking about this inocrrectly
What's up
Okay will do that
You'll need to do
```.rs
#[instruction(topic: String, content: String, vibe_account_bump: u8)]
```
Or use a more up-to-date anchor which removes the need to pass bumps as arguments as far as I know
Ah, the problem is that you (unfortunately, massive gotcha) need to have your `#[instruction(...)]` args match the order of your instruction function args
i'll wait till ur done w that ^
hey alan
this?
Transaction simulation failed: Error processing Instruction 0: Program failed to complete
    Program 3NcczXqNpzUsp6c2pGqLNJMnUwScvZBXduj8f3sg6Qdz invoke [1]
    Program log: Instruction: CreateVibe
    Program 3NcczXqNpzUsp6c2pGqLNJMnUwScvZBXduj8f3sg6Qdz consumed 9375 of 200000 compute units
    Program failed to complete: Could not create program address with signer seeds: Provided seeds do not result in a valid address
    Program 3NcczXqNpzUsp6c2pGqLNJMnUwScvZBXduj8f3sg6Qdz failed: Program failed to complete
Does it not print when you run your tests?
where can i find it?
test:
```ts

    it("can create a new vibe", async () => {
        const author = program.provider.wallet.publicKey;

        const [vibe, vibeBump] = await anchor.web3.PublicKey.findProgramAddress(
            [Buffer.from("vibe_post")],
            program.programId
        );

        console.log("Vibe:", vibe.toBase58());
        console.log("Bump:", vibeBump);
        console.log("ProgramId:", program.programId.toBase58());

        await program.rpc.createVibe("Vibe!", "Vibe Content!", vibeBump, {
            accounts: {
                vibe: vibe.toBase58(),
                author: author,
                systemProgram: anchor.web3.SystemProgram.programId,
            },
        });

        // const createdVibe = await program.account.vibe.fetch(vibe.publicKey);

        // assert.equal(createdVibe.topic, "Vibe!");
        // assert.equal(createdVibe.content, "Vibe Content!");
        // assert.equal(
        //     createdVibe.author.toBase58(),
        //     program.provider.wallet.publicKey.toBase58()
        // );
        // assert.equal(createdVibe.likes, 0);
        // assert.ok(createdVibe.timestamp);
    });
```
Endpoint:
```rust
pub fn create_vibe(ctx: Context<CreateVibe>, topic: String, content: String, vibe_account_bump: u8) -> ProgramResult {

        let vibe = &mut ctx.accounts.vibe;
        let author = &mut ctx.accounts.author;
        let clock = Clock::get().unwrap();
        
        if topic.chars().count() > 50 {
            return Err(ErrorCode::TopicTooLong.into())
        }

        if content.chars().count() > 300 {
            return Err(ErrorCode::ContentTooLong.into())
        }
        
        vibe.author = *author.key;
        vibe.timestamp = clock.unix_timestamp;
        vibe.topic = topic;
        vibe.content = content;
        vibe.likes = 0;
        vibe.bump = vibe_account_bump;

        Ok(())
    }
```

derive macro:
```rust
#[derive(Accounts)]
#[instruction(vibe_account_bump: u8)]
pub struct CreateVibe<'info> {
    #[account(init, seeds = [b"vibe_post", author.key().as_ref()], bump = vibe_account_bump, payer = author)]
    pub vibe: Account<'info, Vibe>,
    #[account(mut)]
    pub author: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```

account:
```
#[account]
#[derive(Default)]
pub struct Vibe {
    pub author: Pubkey,
    pub timestamp: i64,
    pub topic: String,
    pub content: String,
    pub likes: u32,
    bump: u8,
}
```
Please at least post the full program log haha
like the parts which matter
can i send the huge code here?
Oh, sorry, the owner/authority of the token account is the multisig, yeah (I got eye-snipped by the mint part)
It's a slightly unfortunate naming choice because the `.owner` field on an AccountInfo means something totally different, the *program* that owns an account and is allowed to mutate its data or spend the account's money
In spl token terminology, the "authority"/"logical owner" is the `.owner` field
This says that the authority over the mint is `mintAuthority` (whatever that is, not sure)
^ which field on `Account` is the Logical Authority here? `owner`?
Source diving, we see `TokenAccount` as:

```
#[derive(Clone)]
pub struct TokenAccount(spl_token::state::Account);

impl TokenAccount {
    pub c
```

Looking at SPL Account, we have:

```
/// Account data.
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct Account {
    /// The mint associated with this account
    pub mint: Pubkey,
    /// The owner of this account.
    pub owner: Pubkey,
    /// The amount of tokens this account holds.
    pub amount: u64,
    /// If `delegate` is `Some` then `delegated_amount` represents
    /// the amount authorized by the delegate
    pub delegate: COption<Pubkey>,
    /// The account's state
    pub state: AccountState,
    /// If is_native.is_some, this is a native token, and the value logs the rent-exempt reserve. An
    /// Account is required to be rent-exempt, so the value is used by the Processor to ensure that
    /// wrapped SOL accounts do not drop below this threshold.
    pub is_native: COption<u64>,
    /// The amount delegated
    pub delegated_amount: u64,
    /// Optional authority to close the account.
    pub close_authority: COption<Pubkey>,
}
```
Shouldn't be any difference when writing tests, that just means you've got a bug üòõ
ah so if I generate the mint and token account like so:

```
mintA = await splToken.Token.createMint(
      program.provider.connection,
      payer,
      mintAuthority.publicKey,
      null,
      0,
      splToken.TOKEN_PROGRAM_ID
    );

    let multisigTokenAcct = await mintA.createAccount(multisig.publicKey);
```

Is the current authority/logical owner just the `multisig`?
How do you write tests for PDAs? everything I do says 
`Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account`
You'll need to sign with the current authority (the "logical owner")
That call looks a bit odd to me
1. I doubt the current_authority over the multisig is the spl token program itself?
What i'm trying to do is set the new token account's authority to be the multisig_signer, which is the PDA. So you are suggesting that in this case, I don't need to have `pub multisig_signer: Signer<'info>`
the corresponding rpc call looks like:

```
pub fn initialize_token_acct(ctx: Context<InitializeTokenAccount>) -> Result<()> {

        msg!("initialize token acct starting");

        let token_accounts = SetAuthority {
            current_authority: ctx.accounts.token_program.clone(),
            account_or_mint: ctx.accounts.multisig_token_program.to_account_info().clone()
        };

        msg!("set token_accounts: ");

        let cpi_program = ctx.accounts.token_program.to_account_info();

        msg!("set cpi_program: ");
        msg!("{:?}", cpi_program);

        token::set_authority(
            CpiContext::new(cpi_program, token_accounts),
            AuthorityType::AccountOwner,
            Some(*ctx.accounts.multisig_signer.key),
        )?;

        msg!("set authority");

        Ok(())
    }
```
So there's no need to use the `signers` array at all probably
No, I'm saying that in order to sign for the multisigSigner (if that's indeed necessary), then the only possible way to do it is by using `invoke_signed` from within your program
hm are you suggesting the right way to do this is:

```
await program.rpc.initializeTokenAcct(
      {
        accounts: {
          tokenProgram: splToken.TOKEN_PROGRAM_ID,
          multisigTokenProgram: multisigTokenAcct,
          multisig: multisig.publicKey,
          multisigSigner: multisigSigner
        },
        signers: [multisig],
      }
    );
```

replacing `signers: [multisigSigner]` with `signers: [multisig]`, since `multisig` is the deriving program. When I do this, I get:

```
 sending random tokens works!:
     Error: unknown signer: 2c8BgD9uXHJKQQmfGmTAv9NtiLB9k2Qtcq8MqYhxJJiC
      at Transaction._addSignature (node_modules/@solana/web3.js/lib/index.cjs.js:2777:13)
      at /Users/pw/Documents/coding/collective-multisig/node_modules/@solana/web3.js/lib/index.cjs.js:2751:12
      at Array.forEach (<anonymous>)
      at Transaction._partialSign (node_modules/@solana/web3.js/lib/index.cjs.js:2748:13)
      at Transaction.partialSign (node_modules/@solana/web3.js/lib/index.cjs.js:2739:10)
      at /Users/pw/Documents/coding/collective-multisig/node_modules/@project-serum/anchor/dist/cjs/provider.js:87:16
      at Array.forEach (<anonymous>)
      at Provider.send (node_modules/@project-serum/anchor/dist/cjs/provider.js:86:14)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at async Object.rpc [as initializeTokenAcct] (node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:31:31)
      at async Context.<anonymous> (tests/multisig.js:85:5)
```
That's silly - probably not deployed on localnet
I trying to pass in the token metadata program https://discord.com/channels/889577356681945098/889702325231427584/943001650950471680. Here's the address 
```
metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s
```
Is says its executable: https://explorer.solana.com/address/metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s
Are you sure the account you're passing in is actually executable? What have you done to verify that?
I'm getting this error https://github.com/project-serum/anchor/blob/40379eb21f3d2e7f492e8f95caac7d4364b5642e/lang/src/accounts/program.rs#L93
Sir! You are life saver.
I was trying to solve a problem that seems close to this discussion. Do you know where executable becomes true when passing in the id of a program account?
Try just hardcoding `b"seer"` instead of `ido_account.program_name` and you'll see that you start getting different errors.
I think the issue is that on the client side, you're passing the program name seed as (effectively) Buffer.from("seer"), but on the rust side you're actually not doing the same thing, since the `ido_account.program_name` is actually hardcoded to be length 10. So you're missing 6 zero padding bytes on the JS side.
It's a little tricky to read, but here's where your `#[account]` struct gets its auto-derived connection to the declare_id value: https://github.com/project-serum/anchor/blob/master/lang/attribute/account/src/lib.rs#L115
Here's the check üòú
Since, yeah, this is pretty annoying to debug if you aren't familiar with how it works under the hood
But I feel like anchor should probably just immediately error your program if it finds at runtime that the runtime program_id doesn't match the declare_id value
Yeah, good question‚Äîto some extent it's just easier implementation-wise to use the declare_id value
why not use program_id ?
aha I see!
When you do `Account<'info, OneOfMyAccountStructs>`, anchor will verify that the incoming account's program owner is your program‚Äîbut that check is done using the value you set with the `declare_id!`. So if you put the wrong value there, anchor will erroneously conclude that the incoming account has the wrong program owner, even if it's actually fine.
not really :))
Do you understand how it leads to the 167 error? Might make it easier to remember if you understand the underlying link
can't count how many times I forget to change that
thx
That's the problem
eh
nope
Is your declare_id! set to cadqhinsP6mNxARkS36y6TQXjn6rA2DmaMnbwLRKJ92
Any Account<'info, Whatever> will throw that error if the account you passed in doesn't have the owner that the Whatever struct expects
```  #[account(init,payer = authority,space = 8 + 32 + 32 + 32 + 32 + 1 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 1)]
    pub pool: Account<'info, Pool>,
    #[account(
        init,
        payer = authority,
        seeds = [mint.key().as_ref()],
        bump = bump,
        token::mint = mint,
        // We want the program itself to have authority over the escrow token
        // account, so we need to use some program-derived address here. Well,
        // the escrow token account itself already lives at a program-derived
        // address, so we can set its authority to be its own address.
        token::authority = vault,
    )]
    pub vault: Account<'info, TokenAccount>,
    pub mint: Account<'info, Mint>,
    pub pyth: AccountInfo<'info>,
    pub authority: Signer<'info>,
    pub system_program: Program<'info, System>,
    pub token_program: Program<'info, Token>,
    pub clock: Sysvar<'info, Clock>,
    pub rent: Sysvar<'info, Rent>,```
I already checked but didn't know why
https://github.com/project-serum/anchor/blob/v0.18.2/ts/src/error.ts#L87
```    'Program cadqhinsP6mNxARkS36y6TQXjn6rA2DmaMnbwLRKJ92 invoke [1]',
    'Program 11111111111111111111111111111111 invoke [2]',
    'Program 11111111111111111111111111111111 success',
    'Program log: Custom program error: 0xa7',
    'Program cadqhinsP6mNxARkS36y6TQXjn6rA2DmaMnbwLRKJ92 consumed 16239 of 200000 compute units',
    'Program cadqhinsP6mNxARkS36y6TQXjn6rA2DmaMnbwLRKJ92 failed: custom program error: 0xa7'```
What have you tried so far?
which function gives that error?
please post full program log
what could be the issue ?
I'm getting 167 error
Thanks sir! Here it is https://github.com/LumenMoney/ido.git
anyone
Given the existing token program
Ah, the immutable part? I'm actually not sure how to implement that
I would suggest putting your code in a full github repo, so someone can just clone it, `yarn`, `anchor test`
What about the latter ?
If you're down to use non-canonical bumps then the resulting addresses are of course not canonical either, so kind of defeats the whole purpose of an ATA
Since the whole point of an ATA is to have an obvious address to use for person X's mint M tokens.
I think at that point it's not really an ATA anymore ü§î
what about different bump ?
Because, yeah, if you change it, you can't create another ATA at that same address!
I think you should basically never ever change the authority of an associated token account (or idk, maybe not never, but it's definitely a very confusing/unexpected thing to do!)
another question :
yeah, much better tbh
Whose authority is its own address (which is a PDA, so in other words: the program controls those tokens)
But note how that example ^ isn't an ATA at all, it's just a regular PDA address.
I see, I have to initialize the token account inside of the program
E.g. like this: https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo/src/lib.rs#L182
In this case, honestly I think it's simpler to not use an associated token address at all, and instead just store the token account at one of your PDAs directly.
Yeah, to make a token account "owned by the program" means to have its authority be some PDA derived from the program.
I think I have to make the ata owned by a pda if I'm not wrong ?
<@!134416332509675520> :))
in this case I put program_id in authority ?
if the ata is owned by the program
I am stuck. Kindly have another look and see if it is something obvious?
can we use BTreeMap inside of a program?
Hi!

I'm getting `failed: custom program error: 0x0` when calling `Instruction A` but I only get it if I include `Instruction B` in the lib module with `#[program]`. If I comment out `Instruction B`, `Instruction A` runs fine. It compiles and all but right at returning `Ok(())` in `Instruction A` it'll fail with the above error if `Instruction B` is only present (not called)..

Any advice?
You need to figure out why that one account isn't actually signing
Sorry, I was wrong, the log is in there
Apologise but how to get the rust program log?
The solana stack is tiny, so sometimes you need to use the heap üôÇ
what's this good for in anchor ?
It puts the inner type onto the heap as opposed to the stack.
what's Box ?
`    CFP282CfG62c99BFRETNDANthu25UritoJwjjnu51nYN's signer privilege escalated
`
Whoops, I can't read
Ah, sorry, the full rust program log, not the JS stacktrace
Here is the full error log
https://gist.github.com/LumenMoney/17fcd47862f0aa44b0a82f9efe5e6f31
So that error is happening on the client: it's saying (in a not super helpful way) this signers thing you passed me isn't an actual keypair, it's just an address.
`multisigSigner` here is a PDA, so you can't pass it into the `signers` array (it's impossible to sign from the client for a PDA, only it's deriving program can sign for it)
Can you post the full program log?
That would mean that the underlying program account isn't executable (did you deploy it?).
Small example here: https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo/src/lib.rs#L219
an example would be much appreciated
Hello, what's best way to use ata in anchor ?
Can someone have a look. I have modified some code of IDO-POOL from anchor's test directory and I keep getting the following error
"Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account"
Here is the code
https://gist.github.com/LumenMoney/59d653ac76c82a6bb8bec48339700f32
i think this is how it should be, didn't test it give it a try
still noob to cargo
ty sirs
`anchor-lang = { version = "0.21.0", features = ["init-if-needed"]}`
https://doc.rust-lang.org/cargo/reference/features.html#dependency-features
which docs? I have been looking for it for 20 min cant find it :/
when necessary
import anchor-lang with it. the cargo docs explain how that works
`init-if-needed = []` in features doesn't work
how do I set the init_if_needed flag?
I'm wondering what's the best practice to `Box` accounts,
when is it necessary to do so ? large accounts in general ?
how can i get transaction data with a signature, i need something like the data that are displayed in the solana explorar
Ya Simply ran the installation command again and it updated
How to send time in anchor as a param to instruction ? I want to send some future date. How to convert it in big number
I defined a new type for a Program that looked like it just needed an `id` method implemented for it based on how `Token` was working.
```rust
pub token_metadata_program: Program<'info, TokenMetadata>,

#[derive(Clone)]
pub struct Token;

impl anchor_lang::Id for Token {
    fn id() -> Pubkey {
        ID
    }
}
```
but I'm getting this error:
```
Error: 3009: Program account is not executable
```
Is there something else I need to implement so that `info.executable == True` when I provide `ctx.accounts.token_metadata_program.to_account_info()` to `CpiContext::new_with_signer` for the program address?
```
multisigSigner.toString()
'2aPDLKMRepnsYNW9Zixn2RhMkwH5nNAcan9NmyXPxUBe'
multisigTokenAcct.toString()
'DZrermHPJsq6HKXoNc6km2RLsEvs1vPMG6aa3dLwQEs1'
splToken.TOKEN_PROGRAM_ID.toString()
'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'
multisigTokenAcct.toString()
'DZrermHPJsq6HKXoNc6km2RLsEvs1vPMG6aa3dLwQEs1'
```
I've made sure that:

1/ All the account inputs in the `initializeTokenAcct` call are non-null
2/ I've also added `msg!` logging to the actual program definitions but nothing is printing either - this tells me we aren't even making it into the program rpc call. 
3/ `program.rpc.createMultisig` works, so the call should be made properly

Any ideas what is causing this issue of undefined?
`tests/multisig.js:85:5` points to  `await program.rpc.initializeTokenAcct(...)`
The error i'm getting from running this test is:

```
       sending random tokens works!:
     TypeError: Cannot read properties of undefined (reading 'toString')
      at Transaction.partialSign (node_modules/@solana/web3.js/lib/index.cjs.js:2727:36)
      at /Users/pw/Documents/coding/collective-multisig/node_modules/@project-serum/anchor/dist/cjs/provider.js:87:16
      at Array.forEach (<anonymous>)
      at Provider.send (node_modules/@project-serum/anchor/dist/cjs/provider.js:86:14)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at async Object.rpc [as initializeTokenAcct] (node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:31:31)
      at async Context.<anonymous> (tests/multisig.js:85:5)
```
```
it("sending random tokens works!", async() => {

    const escrowAccount = anchor.web3.Keypair.generate();
    const payer = anchor.web3.Keypair.generate();
    const mintAuthority = anchor.web3.Keypair.generate();

    const multisig = anchor.web3.Keypair.generate();
    const [multisigSigner, nonce] =
      await anchor.web3.PublicKey.findProgramAddress(
        [multisig.publicKey.toBuffer()],
        program.programId
      );
    const multisigSize = 1000; // Big enough.

    const ownerA = anchor.web3.Keypair.generate();
    const ownerB = anchor.web3.Keypair.generate();
    const owners = [ownerA.publicKey, ownerB.publicKey];

    const threshold = new anchor.BN(2);

    await program.rpc.createMultisig(owners, threshold, nonce, {
      accounts: {
        multisig: multisig.publicKey,
      },
      instructions: [
        await program.account.multisig.createInstruction(
          multisig,
          multisigSize
        ),
      ],
      signers: [multisig],
    });

    await program.provider.connection.confirmTransaction(
      await program.provider.connection.requestAirdrop(payer.publicKey, 10000000000),
      "processed"
    );

     mintA = await splToken.Token.createMint(
      program.provider.connection,
      payer,
      mintAuthority.publicKey,
      null,
      0,
      splToken.TOKEN_PROGRAM_ID
    );

    let multisigTokenAcct = await mintA.createAccount(multisig.publicKey);

    await program.rpc.initializeTokenAcct(
      {
        accounts: {
          tokenProgram: splToken.TOKEN_PROGRAM_ID,
          multisigTokenProgram: multisigTokenAcct,
          multisig: multisig.publicKey,
          multisigSigner: multisigSigner
        },
        signers: [multisigSigner],
      }
    );
    
    assert(multisig)
  });
```
My test looks like the following:
I'm trying to figure out how to initialize new token accounts via the anchor framework. I have the following:

```
pub fn initialize_token_acct(ctx: Context<InitializeTokenAccount>) -> Result<()> {

    msg!("initialize token acct starting");

    let token_accounts = SetAuthority {
        current_authority: ctx.accounts.token_program.clone(),
        account_or_mint: ctx.accounts.multisig_token_program.to_account_info().clone()
    };

    msg!("set token_accounts: ");

    let cpi_program = ctx.accounts.token_program.to_account_info();

    msg!("set cpi_program: ");
    msg!("{:?}", cpi_program);

    token::set_authority(
        CpiContext::new(cpi_program, token_accounts),
        AuthorityType::AccountOwner,
        Some(*ctx.accounts.multisig_signer.key),
    )?;

    msg!("set authority");

    Ok(())
}

#[derive(Accounts)]
pub struct InitializeTokenAccount<'info> {
    pub token_program: AccountInfo<'info>,
    #[account(mut)]
    pub multisig_token_program: Account<'info, TokenAccount>,
    pub multisig: Box<Account<'info, Multisig>>,
    #[account(
        seeds = [multisig.key().as_ref()],
        bump = multisig.nonce,
    )]
    pub multisig_signer: Signer<'info>,
}
```
Don't think there's any difference, a PDA is just a PDA. Usually authority means some address (doesn't have to be a PDA) that needs to sign in order for something to happen (e.g. the authority over a token account is the "logical owner", the address that needs to sign in order for the spl token program to say "ok, sure, I'll transfer some tokens from this account to somewhere else üëç"
1. Generating a keypair doesn't do anything with accounts, it just generates an ed25519 keypair (so no actual solana stuff happening).
2. You can sign for that address, yes, since it's a keypair address and you have its private key.
I guess I haven't actually checked this but I would have guessed that would be the same for all CPIs: no need to pass the program as an account in the CPI `invoke` itself, but you do need to pass it from the client.
As far as I know, you just don't need to pass the system program as an account *into the CPI*. You *do* need to pass it as an account from the client though.
`ls -hl target/deply/<your-prog-name>.so` to see how big your program is, then it'll cost 1.4 sol / 100kb of code
does anyone have any good resources for program deployment costs? thanks in advance
how complicated would it be to follow imported types when parsing lib.rs? Meaning, for example, if you were using an imported type in a struct, it would look to the imports if it didn't find it defined in lib.rs directly?
https://solanacookbook.com/references/programs.html#how-to-do-cross-program-invocation
This mentions that passing the system program for a CPI is an 'exception', but doesn't explain why it is an exception or how to know something like that ahead of time. Why do you need to provide the System Program to a CreateAccount instruction? (and more importantly) where can I see this information? since it doesn't seem apparent from the Rust documentation (no mention in the Accounts reference for this instruction) https://docs.rs/solana-sdk/1.9.6/solana_sdk/system_instruction/enum.SystemInstruction.html
not strictly an Anchor question, but why do some program instructions take the system program ID as an input account? If I read the CPI docs correctly it would seem you don't need the executable program_id when calling invoke, and I'm not sure why else you would need the system program's account data (I'm assuming it's empty?). Is there another reason to take the system program as input?
We should really provide that out of the box, though.
Yea you can subclass provider to not use a wallet.
For the javascript side - why does the program need the wallet?  When a user comes to a site, and I'd like to show them chain state before they have connected with their wallet.  It appears that you need to feed the provider a wallet before I can read data
Quick question: what's the difference between a PDA key vs. PDA authority?
Here is the explorer
https://explorer.solana.com/tx/2ME4pHraQqALpisNx3rF4yGKageXL32jMEXLg6PdQcXd4pJGpKEpVqnoxoYvxp6fisr1biZNobKUFqHugCb9N23g?cluster=devnet
`let newAuthority =new anchor.web3.PublicKey("BMbhASUcRoV6DMBzWwD8dCudM9wnbum2VBLVckSXhEYb")



    return await program.rpc.updateDispatchAuthority(new anchor.BN(vbump), {
        accounts: {
            withdrawAuthority: wallet.publicKey,
            vaultPda: vpda,
            newAuthority,
            systemProgram: anchor.web3.SystemProgram.programId
        }
    })`
No. Here is the Node call
Ok, dumb question, is it possible you're accidentally passing in the *old* authority as the `new_authority` account?
https://explorer.solana.com/address/DiR3zknTTGDDncfLDgpmN75y3L2XMzyEtuM4Tpt16HMt?cluster=devnet
Here is the program
https://explorer.solana.com/address/F7U8k5HKtTDqEyoNBimLDVw2GYiAtb7PMtVHgix5cSPb?cluster=devnet
Can you link me that explorer trace?
It is for sure owned by my program
You can see the account here
Yes. 100%
Not an easy ask... I called some functions from Node, some code is in Rust and some in sin Go haah
Sounds like it is, just double checking
üòõ
I mean ignoring the PDAness, is the account itself definitely one of your own `#[account]` structs
pls post full program log ü§£
Yea...
And the account's data is still stale even if you wait a while?
It is derived from my account
(So not if the PDA's address is derived from your program‚Äîis the account itself owned by the program?)
Yes
Is that PDA's account owned by your program?
The first keypair should be `BMbhASUcRoV6DMBzWwD8dCudM9wnbum2VBLVckSXhEYb`
`{7AhfPryyniMySpTDkqjcL4sdoqu92uKiUTHbqBFHGXtN 7AhfPryyniMySpTDkqjcL4sdoqu92uKiUTHbqBFHGXtN}`
I don't think so, I am first checking the PDA's info from my Go server which says it isn't updated, then the function I want to call is failing because of a constraint issue becuase the info is not updated
"An account is owned by the system program by default. the system program has basic functions for creating more accounts and sending lamports and such and such. accounts can be assigned a new owner once and only once. this owner is always a program, which has permission to deduct lamports from the account and modify its data however it wishes" from https://2501babe.github.io/posts/solana101.html

1/What is happening when you do `solana keypair-gen`? Who owns this account? Is it the system program? 

2/ Are we able to sign/approve transactions because we have the private key?
could be that the data actually changed, but you didn't refetch the data and testing over old state
What do you mean?
Solana explorer also says vault_pda is writable (the second account being passed in)
weird, in your test did you call `fetch` again  after update?
I don't think it is that... Here is the context
`pub struct UpdateAuthority<'info> {
    #[account(mut, constraint=withdraw_authority.key()==vault_pda.withdraw_authority)]
    pub withdraw_authority: Signer<'info>,
    #[account(mut, seeds=[b"vault"], bump=vault_bump)]
    pub vault_pda: Account<'info, VaultPDA>,
    pub new_authority: AccountInfo<'info>,
    pub system_program: Program<'info, System>,
}`
Can't be that..
` pub fn update_dispatch_authority(
        ctx: Context<UpdateAuthority>,
        _vault_bump: u8,
    ) -> ProgramResult {
        let vault_pda = &mut ctx.accounts.vault_pda;
        vault_pda.dispatch_authority = ctx.accounts.new_authority.key();
        Ok(())
    }` Here is the whole function
Or maybe you forgot to pass `mut` to the account context
Shot in the dark..
I had this happen yesterday and it turned out I didn't call the actual function handler but just returned Ok(()) for the instruction in lib.. üôÑ  Maybe it's the same for you?
Any thoughts?
So i have a function that updates an authority on my contract like so
`ctx.accounts.vault_pda.dispatch_authority = ctx.accounts.new_authority.key();` The problem is that when I check the PDA to see if anything has been changed, nothing has been
Hi 

is there a reason the Debug trait isn't derived/implemented on the  anchor_spl::token::TokenAccount Struct?
Yes, I was going to say at least you can try copying it in and see if it works. I'm not sure if there is a good way to get imported structs to be picked up in the IDL
yes - there's not that much to it, so recreating isn't too bad
oh in your case the struct is imported?
actually imported from `mpl-token-metadata`
they are defined in a separate file isn't it?
It looks like all of those structs are defined in the program versus importing `DataV2`
I just observed the deserialized objects and IDL for this Drift `State` account and it worked, so I'm guessing whatever they are doing has the answer üòÑ
Not sure why that would effect IDL stuff
I'm not 100% sure that's what missing for the type to make it into the IDL tbh
Do you need Default? I would be kind of surprised if you do ü§î
ok, thanks - `Default` isn't implemented for `DataV2`, but maybe I can implement
that's what `{"name":"data","type":{"defined":"DataV2"}}` means: the field `name` is of type `DataV2` which is user-defined
you can have nested types fine, they will be listed under the `types` namespace of the IDL generated
c.f. https://github.com/drift-labs/protocol-v1/blob/master/programs/clearing_house/src/state/state.rs#L35
Clone and Default might be required for the type to be picked up
Basically, the IDL generation stuff isn't super sophisticated, so here I'm not sure how it's going to know what to make of DataV2.
Ah... hmm. There actually might not be a great way around this as far as I know‚Äîyou may have to just use your own isomorphic type and convert back and forth to that DataV2 thing within your program (ew).
that worked, but punted it to `DataV2`, which I was importing from `mpl_token_metadata`. I don't think I can implement `AnchorSerialize` and `AnchorDeSerialize` for the imported type - redefine `DataV2` in my anchor program?
```rust
#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct AnchorDataV2 {
    data: DataV2,
}
```
```
IdlError: Type not found: {"name":"data","type":{"defined":"DataV2"}}
```
If all you need to do is orchestrate instructions amongst other programs, then yeah, can do that purely from the client.
You need your own rust program generally when you want to store your own custom data on-chain (in solana, only the program that owns an account can write to it‚Äîso generally, if you want to write your own custom stuff, you probably need your own program)
As a dev on Solana are you mostly using Rust to write distinct programs or are you using Typescript to create frontends that interact with programs already written?
Ah, this is annoying but I think anchor doesn't yet support that kind of direct newtype pattern (just hasn't been implemented yet)‚Äîtry doing this instead:
```.rs
#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct AnchorDataV2 {
  pub hmm: DataV2
}
```
```rust
#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct AnchorDataV2(DataV2);
```
How did you define it in Rust?
If i have a custom type for an argument to a program instruction, how can I access that in the ts client?
```IdlError: Type not found: {"name":"data","type":{"defined":"AnchorDataV2"}}```
Okay Thanks
Yeah definitely part of learning solana is a phase where you keep going "... ffs, I have to pass that account too?"
Sure!
ohhhhhh that was the missing piece. Thank you!!
CPIs can't introduce any new accounts, unfortunately‚Äîthe rule I mentioned above still applies, the client has to pre-specify *all* accounts of interest
I think I know what you're referring to: the runtime uses the accounts in the instruction data to actually pass a handle to the Program when it is loaded. But it seems like a Program could have a 'public-facing' instruction which doesn't require the client to pass the PDA address, then on-chain it derives the PDA addresses (which it would have done anyway to verify from the client), and then CPI to itself with that address in the instruction data for the 'internal-facing' instruction. Would this not work/be wasteful in some way? I think it would be nice to avoid generating on the client-side if even just to avoid keeping seeds in sync etc.
So there's no way to avoid having the client find the address. And then if the program itself wants to sign for that address (or just validate that the address looks right), it will have to do seeds stuff too.
This is just an annoying thing about solana: any time your program wants to use an account, the client has to pre-specify its address.
Another question on PDAs, I notice in contracts that I've interacted with and in the source of some SPL programs that PDA addresses are typically sent by the client as accounts in the instruction data. Then the program re-derives the address to verify, and then invokes a separate instruction as the signer of that account. My question is, why bother having the client generate PDA addresses? Shouldn't the program always derive them and CPI as a signer? Is it a question of read vs. write? Thanks in advance üôÇ


//////////////////////////////////////////////////////////////////////////////////////////

What are `instructions`/`signers` inputs here? Not seeing these variables in the IDL and it also doesn't seem to be a part of the `Context` wrapper (reading through https://docs.rs/anchor-lang/latest/anchor_lang/context/struct.Context.html)
And in the tests, we have:

```
await program.rpc.createTransaction(pid, accounts, data, {
  accounts: {
    multisig: multisig.publicKey,
    transaction: transaction.publicKey,
    proposer: ownerA.publicKey,
  },
  instructions: [
    await program.account.transaction.createInstruction(
      transaction,
      txSize
    ),
  ],
  signers: [transaction, ownerA],
});
```
If I have:

```
// Creates a new transaction account, automatically signed by the creator,
// which must be one of the owners of the multisig.
    pub fn create_transaction(
        ctx: Context<CreateTransaction>,
        pid: Pubkey,
        accs: Vec<TransactionAccount>,
        data: Vec<u8>,
    ) -> Result<()> {
        let owner_index = ctx
            .accounts
            .multisig
            .owners
            .iter()
            .position(|a| a == ctx.accounts.proposer.key)
            .ok_or(ErrorCode::InvalidOwner)?;

        let mut signers = Vec::new();
        signers.resize(ctx.accounts.multisig.owners.len(), false);
        signers[owner_index] = true;

        let tx = &mut ctx.accounts.transaction;
        tx.program_id = pid;
        tx.accounts = accs;
        tx.data = data;
        tx.signers = signers;
        tx.multisig = ctx.accounts.multisig.key();
        tx.did_execute = false;
        tx.owner_set_seqno = ctx.accounts.multisig.owner_set_seqno;

        Ok(())
    }

#[derive(Accounts)]
pub struct CreateTransaction<'info> {
    multisig: Box<Account<'info, Multisig>>,
    #[account(zero)]
    transaction: Box<Account<'info, Transaction>>,
    // One of the owners. Checked in the handler.
    proposer: Signer<'info>,
}
```
Thanks a lot cqfd!
`program.rpc.doSomething(["foo", "bar"], ....)`
how would you pass the arguments from js to rust with vec<String> ?

Just to set orders of magnitude, millions of entries is going to cost a fair amount of money‚Äîsay 100 bytes per entry, that's 100mb, and rent-exemption costs 7 sol / mb, so you're looking at on the order of 700 sol
^The hashmap has to be persistent across blocks.
I haven't tried yet, I was thinking to use PDA accounts based on the map Keys, but it seems expensive, maybe there's a better way.
Hash size is maybe in the order of millions of entries
Are you running into a particular problem?
You can't really use literal HashMaps in solana (well, strictly speaking you can but they don't work out of the box‚Äîcan search the discord if you want the details). What have you tried doing so far?
I haven't yet. Bump pls üôè  But totally get it that it's not an Anchor specific question, so it's my last bump üòÑ
Amazing, man.  Utility and hilarity in a single repo.  May you live a thousand years.
super cool nonetheless
totally agree
and on program exit
this should be done inside the derive
yea but that's an extra macro
Here you go <@!501570363566587905> King
https://twitter.com/0xDeep/status/1493872874423468036?s=20&t=3ZdMJQSQ83S5ixy8-yktyg
with line number + file
we really need to just do the logging automatically in the framework
or you can use this, it will make your life a lot easier I guess,
```
‚ùØ‚ùØ‚ùØ fuck 0x65    
> Anchor Program
101 | InstructionFallbackNotFound: Fallback functions are not supported
```
https://github.com/0xdeepmehta/fuck-anchor
```typescript
export async function transferLamports(provider: Provider, from: Signer, to: PublicKey, amount: number) {
    const transaction = new web3.Transaction().add(
        web3.SystemProgram.transfer({
            fromPubkey: from.publicKey,
            toPubkey: to,
            lamports: amount, // number of SOL to send
        })
    );

    return await web3.sendAndConfirmTransaction(provider.connection, transaction, [from], { commitment: 'confirmed' });
}
```

Is that what you're looking for?
What's the state of art Anchor Program SDK out there ?
So, maybe try rerunning anchor build + anchor deploy (assuming you're deploying it etc.)
So, that means you've presumably not deployed it correctly, since you're otherwise just using normal anchor stuff
It means you're sending an instruction to your anchor program and it's going "... wtf is this"
Hey guys, can anyone please tell me how to send SOL tokens with calling JSON RPC anchor functoins?
I'm not sure what it meant tho
Yeah I found the error it's ```  InstructionFallbackNotFound: 101,
```
0x65 = 101 = https://github.com/project-serum/anchor/blob/v0.18.2/ts/src/error.ts#L56, which is a pretty low-level error (it means that your deployed anchor program doesn't understand the instruction you tried to send it). I think that likely means you haven't deployed correctly.
Do you know how to find that anchor error based on the hex code?
.
```Transaction simulation failed: Error processing Instruction 0: custom program error: 0x65
    Program cadqhinsP6mNxARkS36y6TQXjn6rA2DmaMnbwLRKJ92 invoke [1]
    Program log: Custom program error: 0x65
    Program cadqhinsP6mNxARkS36y6TQXjn6rA2DmaMnbwLRKJ92 consumed 3166 of 200000 compute units
    Program cadqhinsP6mNxARkS36y6TQXjn6rA2DmaMnbwLRKJ92 failed: custom program error: 0x65
1  error```
Is something not working?
is this correct ?
```  #[account(
        init,
        payer = authority,
        seeds = [mint.key().as_ref()],
        bump = bump,
        token::mint = mint,
        // We want the program itself to have authority over the escrow token
        // account, so we need to use some program-derived address here. Well,
        // the escrow token account itself already lives at a program-derived
        // address, so we can set its authority to be its own address.
        token::authority = vault,
    )]
    pub vault: Account<'info, TokenAccount>,```
``` #[account(
        seeds = [mint.key().as_ref()],
        bump = bump,
    )]
    pub vault: Account<'info, TokenAccount>,```
Has anyone done an anchor test file on something that involves NFTs? Just wondering if there is a boilerplate to tap into for the NFT creation on a local connection
Ah, interesting! Cool, good to know
Needed to also clone the program's data account:
```
[test.validator]
url = "devnet"
[[test.validator.clone]]
address = "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"
[[test.validator.clone]]
address = "PwDiXFxQsGra4sFFTT8r1QWRMd4vfumiWC1jfWNfdYT"
```
Hi, i was having trouble using this the right way. I'm doing this:
```
[test.validator]
url = "devnet"
[[test.validator.clone]]
address = "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"
```
but keep ending up with 
```
Transaction simulation failed: Attempt to load a program that does not exist
```
I'm checking to see whether it's loaded with
```js
let accInfo = await anchor.getProvider().connection.getAccountInfo(MetadataProgram.PUBKEY);
console.log(`${MetadataProgram.PUBKEY.toString()} length: ${accInfo.data.length}`);
```
and that is saying:
```
metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s length: 36
```
which seems like not long enough.
you get an solution for this? I got a similar problem?
what the `use` line for `Context`?
whats needed to store this onchain: `    pub register_pool: Vec<Pubkey>,`
you can use `msg!("log_somethng");` if you want to log on on-chain
yeah thanks
yeah make lot of sense
i ll do one comment per post per user üòÇ
üòÇ
yeah agree 70 $SOL
latter option would increase rent like crazy
so we have two way right, one comment account per post per user, or we can do one giant(10MB) comment account, and hashMap or something for mapping comment and corresponding user
`#[account(init, seeds = [b"post_comment", post.key().as_ref()], bump = comment_account_bump, payer = commentor, space = 1000 )]`

it would be like this then? but wouldnt that restrict one comment per post?
I'm a big fan of Genopets
``` const [comment, commentBump] = await anchor.web3.PublicKey.findProgramAddress(
    [Buffer.from("post"), post.toBuffer()],
    program.programId
);```
yeah, you can use PDA
He folks! I have a "Post" account and a "Comment" account. How do I link a "comment" to a "post"? using PDA?
Hi. Is it possible to use spl-memo(Memo Program v2) in an on-chain program? If possible, can i find such an example?
big fan
Huhaha, yes
are you the guy that built fuck anchor?
haha, It happens üòú
thank you - the underscores got me
<@!392163769834405899> you need to do `features = ["init-if-needed"]`
Hey! I am trying to complete the achor lang tic tack  toe tutorial but keep getting this error. I am not sure how to debug it.
Hi <@!396372249634013198>, can you able to figure that out? i'm also facing the exact issue while i'm tried to call that from js
^ Also posted this in development channel but started to think this falls under beginner, my b
I was reading some docs on "use cargo::objects" and what not but I can't seem to get those use statements to work
Hey everybody, I'm a little confused on something probably simple: I'm trying to import some Rust files that are inside a subfolder. Here's a few screenshots:
is there a function in the anchor client to close Accounts? I haven't been able to find it in the type reference. alternatively, is there a common way folks teardown after their test suite?
Hey ‚Äì would someone here be able to help us validate the attached architecture of our player-versus-player game‚Äôs smart contract?

A quick summary of how the game works:
1. Two players compete against each other
2. They both put in 1 SOL each into our escrow to begin the game
3. After the game is done, here‚Äôs how the funds are distributed:
       a. The winners wins 1.985 SOL
       b. Loser walks away with 0 SOL (loses their 1 SOL)
       c. We capture a fee of 0.015 SOL which is sent to a fee wallet

We are new to Solana smart contract development (building this using Anchor), so just wanted to make sure we were going in the right direction.

Could someone here help review the attached architecture and confirm we‚Äôre going in the right direction? Thank you!!
awesome! yeah this works too
I normally just use .only in mocha
üëã is there a way to get `anchor test` to just run a specific test or test file? I have `tests/test_one.js` and `tests/test_two.js` but every time i run `anchor test` it runs both of them. `anchor test tests/test_one.js` doesn't seem to work either
when I run `anchor test` on devnet, I get this error
```Error: Custom: Invalid blockhash
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }.```
Hi, what's a good way to keep a (fairly large) hashmap on-chain? Map<char[90],  Boolean>

getting this error when trying to build an anchor project on a ubuntu dist
I have this code: ```#[derive(Accounts)]
pub struct AddLiquidity<'info> {
    #[account(
        mut,
        seeds = [ POOL_STATE_SEED, lp_token_mint.key().as_ref() ],
        bump,
    )]
    pub pool_state: Box<Account<'info, PoolState>>,
... 
}``` and I want to make sure someone hasnt spoofed this object?
Hey, what's the reason for having the IDL on-chain? I mean, you have a JS client and misc web files anyway, so why not just host it there? Is this a necessary step for a verifiable build (anchor --verify)? Thanks for helping inform this fairly naiive pleb.
But in the case where the `multisigTokenAcct` has the multisig_signer (the multisig's PDA) how can I pass this along to sign the `send_token` instruction?

edit: figured this out, we can use the key and seeds to derive the PDA and use call `CpiContext::new_with_signer`  to get this working
I'm running into the same problem here where my `signers` argument on the `sendToken` call  - "multisigSigner here is a PDA, so you can't pass it into the signers array (it's impossible to sign from the client for a PDA, only it's deriving program can sign for it). So that error is happening on the client: it's saying (in a not super helpful way) this signers thing you passed me isn't an actual keypair, it's just an address."
```
mintA = await splToken.Token.createMint(
      program.provider.connection,
      payer,
      mintAuthority.publicKey,
      null,
      0,
      splToken.TOKEN_PROGRAM_ID
    );

    let multisigTokenAcct = await mintA.createAccount(arbitraryTokenAcct.publicKey);
    let receiverTokenAcct = await mintA.createAccount(arbitraryTokenAcct.publicKey);

    await mintA.mintTo(
      multisigTokenAcct,
      mintAuthority.publicKey,
      [mintAuthority],
      500 
    );

    let preRun = await mintA.getAccountInfo(multisigTokenAcct)

    await program.rpc.initializeTokenAcct(
      {
        accounts: {
          tokenProgram: splToken.TOKEN_PROGRAM_ID,
          multisigTokenAccount: multisigTokenAcct,
          multisig: multisig.publicKey,
          tokenAcctAuthority: arbitraryTokenAcct.publicKey,
          multisigSigner
        },
        signers: [arbitraryTokenAcct],
      }
    );
    
    let postRun = await mintA.getAccountInfo(multisigTokenAcct)

    await program.rpc.sendToken(new anchor.BN(200),
      {
        accounts: {
          multisig: multisig.publicKey,
          receiverTokenAccount: receiverTokenAcct,
          multisigTokenAccount: multisigTokenAcct,
          multisigSigner,
          tokenProgram: splToken.TOKEN_PROGRAM_ID
        },
        signers: [multisigSigner.key],
      }
    );
```
test looks like:
```
#[derive(Accounts)]
pub struct InitializeTokenAccount<'info> {
    #[account(signer)]
    pub token_acct_authority: AccountInfo<'info>,
    pub token_program: AccountInfo<'info>,
    #[account(mut)]
    pub multisig_token_account: Account<'info, TokenAccount>,
    pub multisig: Box<Account<'info, Multisig>>,
    #[account(
        seeds = [multisig.key().as_ref()],
        bump = multisig.nonce,
    )]
    pub multisig_signer: AccountInfo<'info>
}

#[derive(Accounts)]
pub struct SendTokenAcct<'info> {
    #[account(mut)]
    pub multisig: Box<Account<'info, Multisig>>,
    #[account(mut)]
    pub receiver_token_account: Account<'info, TokenAccount>,
    #[account(mut)]
    pub multisig_token_account: Account<'info, TokenAccount>,
    #[account(
        seeds = [multisig.key().as_ref()],
        bump = multisig.nonce,
    )]
    pub multisig_signer: AccountInfo<'info>,
    pub token_program: AccountInfo<'info>,
}
```
just building on this, our contract looks like:

```
pub fn initialize_token_acct(ctx: Context<InitializeTokenAccount>) -> Result<()> {
    msg!("initialize token acct starting");
    msg!("multisig_token_account.owner is {:?}", ctx.accounts.multisig_token_account.owner);

    let token_accounts = SetAuthority {
        current_authority: ctx.accounts.token_acct_authority.to_account_info().clone(),
        account_or_mint: ctx.accounts.multisig_token_account.to_account_info().clone()
    };

    msg!("set token_accounts: ");

    let cpi_program = ctx.accounts.token_program.to_account_info();

    msg!("set cpi_program: ");
    msg!("{:?}", cpi_program);

    token::set_authority(
        CpiContext::new(cpi_program, token_accounts),
        AuthorityType::AccountOwner,
        Some(ctx.accounts.multisig_signer.key()),
    )?;

    msg!("set authority complete");
    msg!("multisig_token_account.owner: {:?}", ctx.accounts.multisig_token_account.owner);

    Ok(())
}

pub fn send_token(ctx: Context<SendTokenAcct>, amount: u64) -> Result<()> {
    if ctx.accounts.multisig_token_account.amount < amount {
        return Err(ErrorCode::InvalidThreshold.into());
    }

    let cpi_accounts = Transfer {
        from: ctx.accounts.multisig_token_account.to_account_info(),
        to: ctx.accounts.receiver_token_account.to_account_info(),
        authority: ctx.accounts.multisig_signer.to_account_info()
    };

    let cpi_program = ctx.accounts.token_program.to_account_info();
    let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
    token::transfer(cpi_ctx, amount)?;

    Ok(())
}
```
do you know if there's an example of `zero_copy` with dynamically sized types? there's an example in the repo using a fixed array `pub events: [Event; 25000]]` but what about `[Event]` (edit: nvm forget `Vec` zero-copy makes no sense for that)
sorry, I actually _can_ implement `Clone` ( was thinking of a previous version of my struct where it holds an `&mut` so no clone, but now i can)
Is there a way I can pass through a constraint that a pda account exists (i.e. has been initialised) in a macro in the accounts definition ? Or would I have to find the pda in a function and then check whether its owner is the program_id  or something like that?
If `MyStruct` does not implement `Clone` you cannot use `Account<'info, MyStruct>`anyway, regardless of other IDL problems.
is it possible to register a type with the IDL after manually implementing Anchor traits?

the context here is I have an unsized `MyStruct` a (`DST`) and I want to be able to use the niceties of `Account<'info, MyStruct>` vs. just an `AccountInfo`

i've been digging a bit through Anchor macros -- I'm not sure about this but it seems the `#[account]` basically codegen the type as part of the IDL too, but I can't use that because my type can't implement `Clone` nor `Copy`
In this escrow example the escrow account is generated in the client code when called. Does this mean that I would have to store this publickey offchain somewhere to be used again when the program is cancelled/transfer is initialized? How come this account is not a PDA? 


 https://github.com/project-serum/anchor/blob/master/tests/escrow/tests/escrow.ts
If you werent aware, you can also just use `Account<'info, TokenAccount>` and anchor will deserialize it for you
Tbh I'm slightly fuzzy on the best way to do this, but I think can do
```.rs
        let data: &[u8] = *ctx
            .accounts
            .the_token_account
            .to_account_info()
            .try_borrow_data()
            .unwrap();
        TokenAccount::try_deserialize(&mut data);
```
I still don‚Äôt know how to fix this :/
You mean you want to check that the address makes sense?
Hey whats a good way to do a constraint that can confirm my custom StateObject is in fact the one I have created vai a PDA?
very weird
still doesn't work
So good!
There is also `[[test.validator.account]]` for loading account data from files
I need to document it
All validator flags should be configurable in anchor.toml
this is cool
```
[[test.validator.clone]]
address = "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"
```
You can do
```.js
await program.provider.connection.getConfirmedTransaction(
  await program.rpc.doSomething(...),
  "finalized"
);
```
fetching ```        let poolState = await program?.account.pool.fetch(pool.publicKey)``` after initializing gives that error
```Account does not exist DjDvc2CzyXp7PdDmiwgCZAs29syem5wgHzgLaTPta741``` is there a way to wait for the request to be fully confirmed ?
Can you post some code of what you've tried so far?
Hello ! I am coding my frontend but how in javascript we convert a u64 counter to a integer that  i receive from my rpc fetch ?
can you pass arguments to the test validator with `anchor test`?
Generally easier to just check ahead of time on the client + have two versions of the instruction
<@!134416332509675520> is there a way to create only if it's not initialized yet ?
never knew about this
lmao! thanks ‚ù§Ô∏è
<:KEKWait:683182130838503444>
They need to match at least up until the last argument you want to use
You need to do `#[instruction(end_time_deposit: u64, end_time: u64, bump: u8)]`
Right, that unfortunately (huge gotcha) doesnt' work
```#[instruction(bump: u8)]```
```pub fn create_pool(
        ctx: Context<CreatePool>,
        end_time_deposit: u64,
        end_time: u64,
        bump: u8,
        deposit_time: u64,
    ) -> ProgramResult {```
Your `#[instruction(...)]` thing needs to match the order of those arguments‚Äîdoesn't seem like it does, since I'm guessing the bump is the 3rd argument
```const initialize_pool_transaction = await program.rpc.createPool(new BN(50), new BN(70), new BN(b), new BN(50), {
            accounts: {
                pool: pool.publicKey,
                vault: a,
                pyth,
                authority: program.provider.wallet.publicKey,
                mint,
                systemProgram: SYSTEM_PROGRAM,
                tokenProgram: TOKEN_PROGRAM_ID,
                clock: SYSVAR_CLOCK_PUBKEY,
                rent: SYSVAR_RENT_PUBKEY,
            },
            signers: [pool]
        });

        return [initialize_pool_transaction, vault, program]```
Can you post your instruction function?
not sure why I'm getting an error
<@!134416332509675520> verified the address and the nonce, they match
Hello everyone, looking for an experienced developer to develop some basic contracts (starting with staking). If anyone interested, please dm me. Thanks.
```        const [a, b] = await PublicKey.findProgramAddress([mint.toBuffer()], program.programId)```
```#[derive(Accounts)]
#[instruction(bump: u8)]
pub struct CreatePool<'info> {
    #[account(init,payer = authority,space = 8 + 32 + 32 + 32 + 32 + 1 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 1)]
    pub pool: Account<'info, Pool>,
    #[account(
        init,
        payer = authority,
        seeds = [mint.key().as_ref()],
        bump = bump,
        token::mint = mint,
        // We want the program itself to have authority over the escrow token
        // account, so we need to use some program-derived address here. Well,
        // the escrow token account itself already lives at a program-derived
        // address, so we can set its authority to be its own address.
        token::authority = vault,
    )]
    pub vault: Account<'info, TokenAccount>,
    pub mint: Account<'info, Mint>,
    pub pyth: AccountInfo<'info>,
    pub authority: Signer<'info>,
    pub system_program: Program<'info, System>,
    pub token_program: Program<'info, Token>,
    pub clock: Sysvar<'info, Clock>,
    pub rent: Sysvar<'info, Rent>,
}```
It'll just stay as raw bytes
It'll work fine, it just won't automatically parse any of the `.data` in there
but `program.provider.connection.getAccountInfo(theAddress)` won't work if it's a `TokenAccount` right?
But system program accounts can't have any data as far as I know, just lamports
You can fetch arbitrary accounts (but won't get any automatic deserialization) with
```.js
await program.provider.connection.getAccountInfo(theAddress)
```
What is the equivalent for accounts owned by the system program?
Hey, can you help me? What am I doing wrong here?
Ok, then you aren't signing for it correctly (with seeds + bump etc.)
that address is the pda
I'll start by fixing that :))
That error means you're not signing for somethign correctly, not that an address is already in use etc.
Well that's currently what I can think of
Not sure how that relates to the error above ü§î
In JS you can do
```.js
theMint.getAccountInfo(theTokenAccountsAddress)
```
How can I check `token::set_authority` worked in changing up the account in question's owner?
so should I make a seperate instruction for initializing the pda only ?
the thing is I have that pda init in a commun instruction where it's used a lot
ah I see, I think I am initializing a pda that is already initialized
Depends on what you're doing
`    "CvsHapzvpTPkh481mxVwiQm89y9XeDN4VCmWL7iLrNzC's signer privilege escalated",
` so you somehow aren't signing for that address
```  'Program cadqhinsP6mNxARkS36y6TQXjn6rA2DmaMnbwLRKJ92 invoke [1]',
    'Program 11111111111111111111111111111111 invoke [2]',
    'Program 11111111111111111111111111111111 success',
    "CvsHapzvpTPkh481mxVwiQm89y9XeDN4VCmWL7iLrNzC's signer privilege escalated",
    'Program cadqhinsP6mNxARkS36y6TQXjn6rA2DmaMnbwLRKJ92 consumed 23806 of 200000 compute units',
    'Program cadqhinsP6mNxARkS36y6TQXjn6rA2DmaMnbwLRKJ92 failed: Cross-program invocation with unauthorized signer or writable account'```
If you know the secret key (the full keypair) then you can sign for an address from the client by using the `signers: [...]` array
ah my bad didn't post full uhh
Nothing has gone wrong there, that's just telling you that you ran some code
up :))
If you know the secret key for some keypair address, you can sign for the address.
Nope: the key thing is that how you sign for an address is purely a question about the address, it has nothing to do with the *program* that owns the account that lives at that address.
```
pub fn initialize_token_acct(ctx: Context<InitializeTokenAccount>) -> Result<()> {

        msg!("initialize token acct starting");
        msg!("multisig_token_program.owner is {:?}", ctx.accounts.multisig_token_account.owner);
        msg!("ctx.accounts.intializer is {:?}", ctx.accounts.token_acct_authority.to_account_info());

        let token_accounts = SetAuthority {
            current_authority: ctx.accounts.token_acct_authority.to_account_info().clone(),
            account_or_mint: ctx.accounts.multisig_token_account.to_account_info().clone()
        };

        msg!("set token_accounts: ");

        let cpi_program = ctx.accounts.token_program.to_account_info();

        msg!("set cpi_program: ");
        msg!("{:?}", cpi_program);

        token::set_authority(
            CpiContext::new(cpi_program, token_accounts),
            AuthorityType::AccountOwner,
            Some(ctx.accounts.multisig.key()),
        )?;

        msg!("set authority complete");
        msg!("multisig is {:?}", ctx.accounts.multisig.to_account_info());
        msg!("{:?}", ctx.accounts.multisig_token_account.to_account_info());

        Ok(())
    }
```

This piece of code works, but afterwards, `ctx.accounts.multisig_token_account.owner` is still set as `ctx.accounts.token_program`. Shouldn't `.owner` be the `ctx.accounts.multisig` after the `token::set_authority` executes?
is there a difference between `#[account(zero_copy)]` and `#[zero_copy]`?
Every account has an address (e.g. `account.to_account_info().key`) and every account has an owner (e.g. `account.to_account_info().owner`) and I guess that's the distinction. Is it correct to say that only the owner can sign for the account? 

In code, how do you "sign for an address if you know the secret key"?
possible reason ?
```    'Program cadqhinsP6mNxARkS36y6TQXjn6rA2DmaMnbwLRKJ92 consumed 3117 of 200000 compute units',```
What‚Äôs the best way to store my keys on the backend? What do other protocols do?
Sweeet
You'd just do basically the same kind of code you use in your node tests
web3.js üòõ
Basically, I have funds split across 3 lending protocols. I want my backend server to be able to set the distrivution of funds (e.g. 33% each) and then call the instructions to actually move the funds around
How would I build the txn on my node.js server? Is there some solana package for that?
Nah dont need user to sign
I haven't actually tried doing that before but should be fine
But yeah, you can do this‚Äîdo you also need the user to sign too? They'd have to partial sign from the client I guess, then ship the serialized tx to your server I guess
Dont want anyone else to have access
A very private one. Very confidential
With which keypair?
Can I sign transactions from a backend server?
I think the key thing is just to understand that addresses and accounts in solana are totally separate concepts: accounts live at addresses and have program owners (e.g. a token account is owned by the spl token program), and then addresses can be signed for: keypair addresses can be signed for if you know the secret key, and PDAs can be signed for if their deriving program decides to (note‚Äînot the same notion as an account's program owner! talking about addresses now).
ok yeah, let me change them, my bad
Sorry, I think I'm getting confused by your variable names
The situation I'm describing is setting `multisigTokenAcct` as the signer vs. `arbitraryTokenAcct` as the signer
In this case, we have :

```
let multisigTokenAcct = await mintA.createAccount(arbitraryTokenAcct.publicKey);

await program.rpc.initializeTokenAcct(
      {
        accounts: {
          tokenProgram: splToken.TOKEN_PROGRAM_ID,
          multisigTokenProgram: multisigTokenAcct,
          multisig: multisig.publicKey,
          intializer: arbitraryTokenAcct.publicKey,
        },
        signers: [arbitraryTokenAcct],
      }
    );      
```

We have `multisigTokenAcct` that is the "account" in this case. But we also have `arbitraryTokenAcct` that's the "owner" of the `multisigTokenAcct`.
What do you mean by have the owner program be a signer?
so that account can be a "signer", but you can also have the owner program be a "signer". Is there a difference between account signing vs. logical owner/program authority signing?
what's confusing here is for any given account, you have the account's own keyPair as well as a program that owns the account
But in general, the program that owns an account can do whatever it wants with it, no signature necessarily required
In this case, the spl token program won't let you change the authority unless the current authority signs, as a way of saying "yep yep I'm cool with this"
Not necessarily, no. Signing in solana is only required if the account's owning program demands it.
The key here is that I needed to pass in `signers: [arbitaryTokenAcct]`  and mark `pub intializer: AccountInfo<'info>,` with `#[account(signer)]`. This makes sense given that we are changing the `arbitaryTokenAcct/intializer` authority. Is it correct to generalize that for any `TokenAccount` or `Account` that you modify (e.g. in this case we are updating the owner), you need to mark the account's authority/logical owner with the signer tag?
```
pub fn initialize_token_acct(ctx: Context<InitializeTokenAccount>) -> Result<()> {

        msg!("initialize token acct starting");
        msg!("multisig_token_program.owner is {:?}", ctx.accounts.multisig_token_program.owner);
        msg!("ctx.accounts.intializer is {:?}", ctx.accounts.intializer.to_account_info());

        let token_accounts = SetAuthority {
            current_authority: ctx.accounts.intializer.to_account_info().clone(),
            account_or_mint: ctx.accounts.multisig_token_program.to_account_info().clone()
        };

        msg!("set token_accounts: ");

        let cpi_program = ctx.accounts.token_program.to_account_info();

        msg!("set cpi_program: ");
        msg!("{:?}", cpi_program);

        token::set_authority(
            CpiContext::new(cpi_program, token_accounts),
            AuthorityType::AccountOwner,
            Some(ctx.accounts.multisig.key()),
        )?;

        msg!("set authority complete");
        msg!("{:?}", ctx.accounts.multisig_token_program.to_account_info());

        Ok(())
    }

#[derive(Accounts)]
pub struct InitializeTokenAccount<'info> {
    #[account(signer)]
    pub intializer: AccountInfo<'info>,
    pub token_program: AccountInfo<'info>,
    #[account(mut)]
    pub multisig_token_program: Account<'info, TokenAccount>,
    pub multisig: Box<Account<'info, Multisig>>,
}
```
What's working is:

```
mintA = await splToken.Token.createMint(
      program.provider.connection,
      payer,
      mintAuthority.publicKey,
      null,
      0,
      splToken.TOKEN_PROGRAM_ID
    );

    let multisigTokenAcct = await mintA.createAccount(arbitraryTokenAcct.publicKey);

    await program.rpc.initializeTokenAcct(
      {
        accounts: {
          tokenProgram: splToken.TOKEN_PROGRAM_ID,
          multisigTokenProgram: multisigTokenAcct,
          multisig: multisig.publicKey,
          intializer: arbitraryTokenAcct.publicKey,
        },
        signers: [arbitraryTokenAcct],
      }
    );
```
ah got it
Ah ok I would suggest not calling that `_program`, since that pretty much universally means an actual executable program in solana
I did manage to get the program to work
`multisig_token_program` is the token account that's set up like so:

```
 mintA = await splToken.Token.createMint(
      program.provider.connection,
      payer,
      mintAuthority.publicKey,
      null,
      0,
      splToken.TOKEN_PROGRAM_ID
    );

let multisigTokenProgram = await mintA.createAccount(arbitraryTokenAcct.publicKey);
```
I'm confused about the name `multisig_token_program`‚Äîwhich program is that?
It's the account of the program you want to call‚Äîhere you're fiddling with a token account, so you need to ask the token program to do the mutation for you (in solana, every account has a program owner, and only that program is allowed to mutate the account's data or spend the account's lamports‚Äîhere you want to mutate the token account so you can change its `.owner` field)
The cpi_program needs to be `ctx.accounts.token_program.to_account_info()`
Ok, set_authority requires the *old* authority to sign (since its relinquishing its authority)
this doesn't have any output
trying to better understand how `set_authority` works here
Ah, ok
doing this as an exercise
I think I've forgotten why you want to change the authority to the multisig signer, rather than just having it be that to begin with
That's how you would make a token account for mintA, whose owner is the multisig signer PDA.
Why wouldn't it be `mintA.createAccount(multisigSigner)`?
Can't, BN is purely for big integers
see .anchor/program-logs/
like `anchor test --verbose` or something?
Is there a way to get the program log to print even if the test case passes?
https://github.com/project-serum/anchor/tree/3958533750c83c3e90709448c4f30ed9cce0b9b8/tests/events
any good examples or docs around `emit`?
gotcha, thank deep
`msg!("huhu");`
`msg!("hello")`?
how do I log stuff in my anchor program?
Lets say I want to check that an account is initialized and if not modify a few variables in a different account (both of which are passed in), is there a way I can check if the account is init'd inside the actual function instead of with the anchor macros setup? Right now if the account is not init my code inside the func does not get ran
ohh, got it, ty !
it's basically a transformation between objects
`.into()` is the opposite of `from`, so check if there is code that does `impl From<&...> for ProxyMintToAccount>`
what does it mean when they use .into() ? Why they don't specify the exact account ?
ty
wewt: `     Error: 3012: The program expected this account to be already initialized`
ofcourse
gotcha, but id need to pass in the seeds/bump right
yes, if you **don't** pass `init` it expects the PDA to be initialized
another turbo noob question, is there a way for an on chain program to check if a passed in PDA is initialized?
Are having constraints in the `account` macro less costly than having them in context execution?
Now I have the `intializeTokenAcct` function set up like so:

```
pub fn initialize_token_acct(ctx: Context<InitializeTokenAccount>) -> Result<()> {

    msg!("initialize token acct starting");
    msg!("multisig_token_program.owner is {:?}", ctx.accounts.multisig_token_program.owner);

    let token_accounts = SetAuthority {
        current_authority: ctx.accounts.multisig.to_account_info().clone(),
        account_or_mint: ctx.accounts.multisig_token_program.to_account_info().clone()
    };

    msg!("set token_accounts: ");

    let cpi_program = ctx.accounts.multisig.to_account_info();

    msg!("set cpi_program: ");
    msg!("{:?}", cpi_program);

    token::set_authority(
        CpiContext::new(cpi_program, token_accounts),
        AuthorityType::AccountOwner,
        Some(ctx.accounts.multisig_signer.key()),
    )?;

    msg!("set authority");

    Ok(())
}
```

1/ I'm having a bit of trouble figuring out what the cpi_program should be here to properly invoke `token::set_authority`. What I've seen in other examples where we are doing something similar is passing in the `SplToken::TOKEN_PROGRAM_ID`, is that the same case ehre?

2/ Given "> The point of the multisigSigner PDA is that it's the thing that will sign if the multisig conditions are met", is my logic correct in that we want the multisig_signer to be the authority on `multisig_token_program`?


//////////////////////////////////////////////////////////////////////////////////////////

#[account(...)] inside derive(Accounts) lets you specify constraints/random stuff about the accounts, e.g. `mut` means we need writable access to this account
#[account] over a struct says: our program is going to manage some accounts that store the following struct (once it has been serialized to bytes).
Ah yes, this is where Im getting confused..the #account over a struct vs it being used when initialising the variables
Ah, maybe another point of confusion is that #[account] over a struct is a totally different macro from `#[account(....)]` inside derive(Accounts)
So say if I did not want the `vote_account` to be mutable, in that case would it fine to remove the `#[account(mut)]`  on top of it...as my `VoteAccount` struct already has the `#[account]` attribute and the `vote_account` varibale is created from `VoteAccount` itself ?
As for rust stuff, yeah, you're going to have to learn rust decently well to be able to do anchor/solana stuff. E.g. the rust book, or Programming Rust 2nd edition are both good.
The `#[account(mut)]` thing is anchor-specific, and means that when the client invokes your contract, it needs to tell solana that it wants exclusive/writable access to that account. It's not the same thing as rust's `mut` keyword (anchor uses the same name since, yeah, it's kind of similar in intent).
Hi, have been going through some code in Anchor-framework, had a question on the usage of  `#[account]`  attribute:

Consider the snippet below:  
```#[account]
pub struct VoteAccount {
    pub crunchy: u64,
    pub smooth: u64,
}
```
From what I understood, in  the above code snippet, we are saying that I need a VoteAccount data-type which will contain 2 variables..  

Now, consider the function which is called: 
```#[derive(Accounts)]
pub struct Vote<'info> {
    /// Marking accounts as mut persists any changes made upon exiting the program 
    #[account(mut)]
    pub vote_account: Account<'info, VoteAccount>,
}
```
Here we are marking the `pub vote_account` with the `#[account(mut)]` as well. 
Why is this required? 
When the `vote_account` variable is of type `Account(VoteAccount)` , do I need to again mark the variable with the attribute? 
Is it done only because of I need it to be mutable (`mut`) ? Say I did not want it to be mutable, in that case, would removing the line be fine?  

Also I think my doubt arises from being a beginner in Rust ( and hence Solana / anchor ),  I wanted to know if this is a rust level thing or a anchor-framework level thing, i.e. what should I read on more, to better understand this ?
hm, yeah, you can filter the accounts but idk how to do it properly here
That's a RPC command
You can do it using `memcmp` on `getProgramAccounts`
ok
Don't think so, you'll have to just filter the result of calling `.all()` as far as I know
is it possible to somehow filter to return only accounts for given user
tho it looks like the mint in my program is working just fine, so it must be some other account
Thanks!
cc <@!430802284742574101> ^^^
fyi, if you get a writable privilege escalated on a burn or mint cpi call, make sure the mint account you pass is mutable
I think the next version of solana will let you add extra space on the fly, but currently you can't
so if my init account is full, how can I get more?
I need some help with `Signature verification failed` - I created a mint using the client, and I am attempting to create a user derived ATA. I derived the ATA with:
```
  const seeds: Buffer[] = [
    ownerPubKey.toBuffer(),
    TOKEN_PROGRAM_ID.toBuffer(),
    mintPubKey.toBuffer(),
  ];
  const programId: PublicKey = ASSOCIATED_TOKEN_PROGRAM_ID;
  return utils.publicKey.findProgramAddressSync(seeds, programId);
this returns: [ataPubkey, ataBump]
```
When sending with 
```
    new Transaction().add(
      SplToken.createAssociatedTokenAccountInstruction(
        ASSOCIATED_TOKEN_PROGRAM_ID,
        TOKEN_PROGRAM_ID,
        mint.publicKey,
        ataPubkey,
        user.wallet.publicKey,
        user.wallet.publicKey
      )
    );

  // sign and send txn 
  txn.feePayer = user.wallet.publicKey;
  txn.recentBlockhash = (
    await provider.connection.getLatestBlockhash()
  ).blockhash;
  const signedTxn: web3.Transaction = await txnWallet.signTransaction(txn);
  const res: string = await provider.send(signedTxn);
  const conf: web3.RpcResponseAndContext<web3.SignatureResult> =
    await provider.connection.confirmTransaction(res);
```
I get Signature verification failed
Absolute max is 10mb, but for `init` it can only be 10kb
for the init account
How much space is the max?
If there are, then PDAs are great!
Yeah, just depends on whether there are natural seeds in a given situation
in all examples they store info in a normal accounts
so why would i store escrow_data in a normal account rather than in PDA? Because PDA has a big plus that we can find escrow_accounts by seeds. And i don't see any drawbacks
But yeah, you don't have any way to "guess" all of the addresses (they're random)
You can still do `await program.account.escrowAccount.all()`
yeah...so if i am using keypairs there is no way to list for example all users escrow_accounts
Seeds only apply to program-derived addresses, not keypair addresses
You would need to pick a hashing algorithm on both the client as well as in you rust program (like, sha256 or something)
am i still able to pass seeds as well ?
oh thanks a lot! I will run some tests on this!
`username.as_bytes()`
ohkay.... could you tell me how i could hash the string?
Yeah max seed length as a &[u8] is just 32
the trait bound `std::string::String: std::convert::AsRef<[u8; 9]>` is not satisfied

username.as_ref() gives this error
But yeah ^ that's how you would do it!
Strictly speaking you can use strings, but individual seeds can't be very long (looking up how long)
You should probably just hash the username first and then use that as the seed
i just learned this recently
in the lib.rs file, you would have to pass the String as an argument to the function you wish to call i.e. ```pub fn initialize_user(ctx: Context<InitializeUser>, username: String, ...) ```
then in the ``` #[derive(Accounts)] ``` for this method, you would have to add an instruction macro to retrieve this value from the arguments and pass it into the seeds for the account 
``` #[derive(Accounts)]
    #[instruction(username: String)]
    pub struct InitializeUser<'info> {
     #[account( init, seeds = [username.as_ref(),... ```
Is there a way I can pass a string in a seed of a PDA? like i need to store usernames which need to be unique.. how do I do that?
thank you man ‚ù§Ô∏è
Yep
ohhh, so user just passes an empty account and in ```init``` method our program takes its ownership, so from now on only our program can change account fields
Just because you can sign for an account's address doesn't mean you can just randomly mutate the account itself (that's up to the account's owning program)
*Only* the program can mutate an account it owns‚Äîso having access to the keypair is irrelevant unless the program specifically asks you to sign for something
That's actually not the way solana works: you need the private key to create the account (solana makes you sign with the address of an account you're creating), but whether or not that private key has any subsequent use depends entirely on the program
but how it is safe? User generates Keypair -> passes it as an escrow_account -> program writes to an escrow_account. But because user generated the keypair he has private key and he can change info at any time
No, PDAs and keypair addresses just have different usecases.
i mean that now most of the projects hold info in pdas rather than old keypairs or not?
What do you mean by outdated?
it is outdated to hold info in these accounts, right?
That account apparently isn't using a PDA at all, it's just using a regular old keypair address
Because we can find pdas by their seeds and what seeds is used here?
hm, it does not use any seed for the EscrowAccount. So how we can find it in the client side?
If anyone have the issue `thread 'main' panicked at 'Code not parseable: Error("invalid type")', lang/syn/src/idl/file.rs:353:58`:
```rust
// Working
#[account(zero_copy)]
pub struct SomeAccount {
    pub info_accounts: [u8; 32],
}

/// Not Working
#[account(zero_copy)]
pub struct SomeAccount {
    pub info_accounts: [u8; 32],
}
```
Somehow rustdoc comments break the IDL generation.
it's an early version of the feature so i'm sure it'll be fully integrated and documented soon
That comment shows how to turn it on I guess, but I haven't tried it because I couldn't find any guidance beyond this.
ty i was just looking through github for this loll
https://github.com/project-serum/anchor/issues/1004#issuecomment-1020478661
ohhh i see. i was referencing Anchor's recent twitter post and thought we no longer needed it since they didn't use it. but the .methods is still an improvement
You still get the benefit of using `.methods` which is much cleaner.
I didn't use that and still send up the pda's since the pda stuff was disable by the flag and I couldn't find docs or examples for it.  I figured that means it's still being baked by the time.
the error is: ``` Error: Invalid arguments: post not provided ``` where post is a Post account that will be a PDA
What's the error exactly?  Are you trying to use the new pda stuff that you need to turn on with a feature flag?
hey everyone so i recently upgraded to anchor v0.21.0 and when i try to use the program.methods  on the client side call to initialize a PDA, i'm getting an error that the PDA account is not provided. to my understanding in this version it was no longer needed so is there any way i can resolve this? thanks!
So I'm packaing the idl/types in my own client library and not using idl fetch an workspaces because it wasn't clear to me how it works when using it with the frontend project.  Is there an example that shows "the right way"  Also, my actual contract tests use this library since there's endless boilerplate for setting up program state.  The `cfo` example is the closest thing I've seen to a real world setup but stops short of creating a consumable package for a front-end or other project.
Oh, missed that reply while I was typing. Didn't mean to repeat what you already said.
Yeah, just instead of typing `anchor test`, instead type `./anchortest`
If "dumb" unblocks me, it ain't dumb. üòõ
Sorry, was trying to get cute
Oh, nope lol
And then change your Anchor.toml's `test` command to be `test = anchortest`
This is definitely dumb, but you could also make that `anchortest` file I mentioned above (modified to copy stuff, or whatever)
In general I can't find the golden path of using idl / workspaces espcially when TypeScript is in the mix
Well, it means I always need to do `anchor build --idl <output> & anchor test` anytime I run tests.  I guess that could work.  Should we be able to specifiy idl location in `Anchor.toml`?
(Or maybe I'm just unclear on why the idl needs to be in a particular place‚Äîhaven't tried doing this before)
Ok, can you just copy the idl? So it lives in both places (dumb, but probably works)
Thanks for the response.  I've been trying to do gymnastics in a shell script, but `anchor.workspace` seems to get messed up unless the idl is in the target folder.
Like
```.sh
# in file anchortest
anchor build --idl whatever
anchor test
```
the one in tests uses init https://github.com/project-serum/anchor/blob/222c6e3e55daa12cbca09dd634dc83b333524413/tests/escrow/programs/escrow/src/lib.rs#L113
Ok, yeah, doesn't look like the `test` command currently supports this. As a workaround in the meantime, can you not just write your own little script that orchestrates things?
Agree, confused me a lil bit
Is that the anchor escrow tutorial? Don't think there's any particular reason to use `account(zero)` there ü§∑‚Äç‚ôÇÔ∏è
Bumping question again - Anyone know how to get `anchor build` and `anchor test` to place the idl and types in a separate folder?   `[workspace]` with `types` in `Anchor.toml` works with the TypeScript types, but idl ouput does not appear to work there.  `anchor build --idl` works, but `anchor test --idl` is an invalid flag.  Really really would appreciate help on this
But yeah, maybe that explanation is the only use cases
Hm, because I‚Äôm wondering why they use it instead of just using init
I didn't find any place to read about it other than the source, but got some help on it recently https://discord.com/channels/889577356681945098/889702325231427584/942554503239073802
I see, thanks
`.push(*test)` (or figure out why you only have a reference to it, rather than an actual value
I'm new to rust, anyone knows how to solve this?

Not sure where you can read about it, but what it does is say "anchor, don't freak out that this account doesn't have any discriminator bytes yet‚ÄîI created it in a separate instruction and am now initializing it with this one"
Ah, not sure (tbh I haven't actually used the anchor docs before, just lots of source-diving)
im using version 0.21.0 and thought i no longer needed to include the PDA on the client side, however it would give me an error so i added it back. i believe the client side is on the correct version since i used the program.methods approach but im unsure
thank you!
Any idea of what's going on?
Hello, when I add an array in an account struct I get this error (during IDL generation it seems): `thread 'main' panicked at 'Code not parseable: Error("invalid type")', lang/syn/src/idl/file.rs:353:58` I tried a lot but any array size of any type gives this while doing the same in another project works...
Is it even possible for a custom program error to be this big?
I'm doing a CPI with Serum Dex and I am seeing this error: 
`Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: custom program error: 0x10005d4`
thanks a lot <:PoggersLove:825149316795596821>
Here's an example from a recent project. Based on a very good anchor tutorial on Buildspace. I'd 100% recommend
Hello everyone Does anybody know where to find an example of Exchange NFT for SOL with a smart contract?
in what format do I pass values from js to it?
if my function has a: Vec<Custom> argument and: 
pub struct Custom {
    pub pk: Pubkey,
    pub nr: u16,
}
A few things here, for the account is already in use - You can use `init_if_needed` if there is no initialization assignment. If there is, then it‚Äôs best to create a separate `initialize_post` instruction.

However, it seems like you‚Äôre trying to make each post‚Äôs PDA  unique. In which case, you should use something unique for seeds. You are currently using a string constant, which means this PDA is effectively a singleton. You can use something deterministic, such as using `post_content` as one of the seeds. 

Lastly, in anchor 0.21.0 you won‚Äôt need to pass in the PDA on client side, it will be automatically determined by anchor so the developer ergonomics are much better.
Yes but you must serialize the instructions yourself
Hey, where can I read about #[account(zero)] tag?
is there any way to decode a transaction to figure out what exactly changed in a program account? I have a program account that has a counter, and I want to know which transaction was the one that bumped the counter to a certain value
https://solanacookbook.com/guides/account-maps.html#deriving-pdas - also a good example
hey everyone im trying to work with PDAs and i'm a bit confused on the concept of seeds and bumps. 
i'm trying to create a test program where a user can create a post and each post gets a PDA.  i'm unsure how to generate seeds to accomplish this

this is the code i currently have in TS for creating a post
```
[postAccount, postAccountBump] = await anchor.web3.PublicKey.findProgramAddress([Buffer.from("post")], programId);

const tx = await program.methods.createPost(
      postContent,
    ).accounts({
      post: postAccount,
      authority: user.publicKey,
      payer: provider.wallet.publicKey,
      systemProgram: anchor.web3.SystemProgram.programId
    }).signers(user).rpc();
```
here is the anchor code i have for the method
```
#[derive(Accounts)]
pub struct createPost<'info> {
    #[account(
        init, // hey anchor, initialize an account w/ these details (rent exempted)
        seeds = [b"post".as_ref()],
        bump,
        payer = payer, 
        space = 8 // all accounts require minimum 8 bytes
                + 32 // public key space
                + 560 // 560 bytes: 140 character count for content
character count for each
    )]
    pub post: Account<'info, Post>,
    #[account(mut)]
    pub authority: Signer<'info>, // this signer
    pub payer: AccountInfo<'info>, // this account will pay for the transaction
    pub system_program: Program<'info, System>
}
```
currently when running this code, the first post can be created, but any other post generates an error: ```account is already in use```
i thought about adding some additional string value for the seed but i'm unsure how to approach this. i appreciate any help! ty
Is there an exhaustive list of inputs to pass into RPC calls? FFT point me to source code/documentation cc <@!134416332509675520> just a gentle bump ICYMI
no worries - I think this is the better way https://discord.com/channels/889577356681945098/889702325231427584/943681775371190324
Just woke up, thx for the info üôè
Use `constraint` at the time of account deserialization
What is the idiomatic way to gate a particular program function to be only called by specific pubkeys?
Does anyone know if the Solana rpc api can call custom programs ?
Ok thanks. I'm a little confused; how is the total allowance of compute units calculated? I'm wondering if the bottleneck in my program is the amount of space allocated to the baseAccount that the program is storing data on, or the compute units of the program itself. Does that make sense?
How do you wrap SOL? When I send SOL to an associated token account with SystemProgram.transfer, it adds the SOL to the rent-exempt reserve, not the token balance. Is there a way to transfer SOL into a wSOL token account?
Bump on idl generation.  Trying not to @
I think this is actually a better way to handle this that makes better use of the feature:
```rust
let auth_seeds = ["auth".as_bytes(), &[ctx.bumps["authority"]]];

#[account(seeds = ["auth".as_bytes()], bump)]
pub authority: AccountInfo<'info>,
```
https://github.com/glyfo/glyclt-solana
Hi , I am working in a simple project to put all Solana & anchor binaries into the container  . Now I am working in anchor build - deploy & test . Any advice or feedback is welcome. This is a public repo
~~my `program.account` is coming back as an empty object in my Anchor client, but when i directly `getProvider().connection.getAccountInfo(...)` it comes back -- any tips for debugging?~~

found it, IDL issue
It's possible that this might not be exportable to IDL? Definitely can work around
Bueller?
`pub struct`
it is public right?
wait
ü§¶‚Äç‚ôÇÔ∏è thank you sir
Is the type public?
so i created a wrapper for a struct:
```
#[derive(Clone, AnchorDeserialize, AnchorSerialize)]
pub struct TokenMetadata(mpl_token_metadata::state::Metadata);
```
but it‚Äôs not showing up in the IDL. Is there something special i need to do? I‚Äôm just pattern matching anchor/token.rs
$5 bounty to anyone who can tell me how to get idl generated out of target and be respected by both anchor build and anchor test
so I always have to do anchor build before anchor test if I want my idl to live elsewhere?
I've been blocked by an hour on this just so I can start wiring up my UI.
ugh, and anchor test does not have an `--idl` option for output either.
Ah, no, `owner` doesn't have anything to do with program-derived addresses‚Äîit's about checking which program owns the account (these are two totally separate concepts)
```
[workspace]
idl = "client/src/idl"
types = "client/src/idl_types"
```

For Anchor.toml, should the above put the idl in the correct directory?  This doesn't appear to work.   The types are placed in the correct directory but not the idl
<@!134416332509675520> Interesting, based on my interpretation, the check doesn't seems to verify that the givens address are derived from any programId. The `Field` struct contain a `Ty` field that i'm interpreting as `the type of the account the field belong to` and the match clause on this `Ty` take into account type as `Signer` or `AccountInfo` and for the `container_ty` look like the same... it's doesn't seem to be restricted to program derived address. But as you said it's tricky to read. Then maybe I'll just do some test to check my assumption
Sorry for the dumb question, I'm new to Solana, and I am trying to build my helloworld solana app using Anchor. I am on aarch64 (docker container on M1 Mac). When I do `anchor build`, it appears that it tries to download the BPF SDK into `/root/.local/share/solana/install/active_release/bin/sdk/bpf`. However, I _think_ it installs the bpf tools in x86_64, which causes the command to error out with `qemu-x86_64: Could not open '/lib64/ld-linux-x86-64.so.2': No such file or directory`
Soon this will change a bit, you'll be able to request more units, etc.
Solana actually doesn't currently have gas like ethereum; your program just gets a fixed cap on how much work it can do, and if you run out of "compute units" then your transaction gets killed.
normie question here: what is compute units referring to on solana explorer?
Maybe slightly tricky to read, but this is how the owner constraint works (it's not doing anything fancy): https://github.com/project-serum/anchor/blob/master/lang/syn/src/codegen/accounts/constraints.rs#L255
<@!703647911770062878> thanks, that what's I understand, currently i'm using the constraint this way. 
```rust
    constraint = base_config.authority == signer.key()
```
Just hoping that owner could give me a shortcut. Look like this is not the case
[moved question to <#889584618372734977> ]
I believe a Program is the only entity which could modify an Account. Users with keypairs can sign transactions but ultimately they send those instructions to Programs to be executed. If you want to make sure only a given wallet can modify some data, you can have your Program own the account and only update the data there if that wallet signs a given transaction.
Hello,
When I'm reading the rust doc, I understand that the `owner` constraint can be used to specify another program address as the owner of the account. 
Can I use the `owner` constraint to specify a owner that is not a program?
Failed 3 times in a row...
I recently upgraded to solana v1.9.5 for my cli, and now when I do anchor test it takes 2 mins and often gives me this error:

```=====================================================================================
Recover the intermediate account's ephemeral keypair file with
`solana-keygen recover` and the following 12-word seed phrase:
=====================================================================================
XXXXXXXX
=====================================================================================
To resume a deploy, pass the recovered keypair as the
[BUFFER_SIGNER] to `solana program deploy` or `solana write-buffer'.
Or to recover the account's lamports, pass it as the
[BUFFER_ACCOUNT_ADDRESS] argument to `solana program close`.
=====================================================================================
Error: Custom: Invalid blockhash
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }.```
thanks <:prays:941677067622305803>
Alas, you can't. In solana you always have to pass any relevant accounts in from the client, not possible to just dynamically fetch them from within your program.
if it has any
how can I inside the anchor program, with the Pubkey get the token accounts from that key
Can you say more? Not sure what you mean
you see the update_vote fn, do you know (or can you point me in a direction) how I could get the token accounts from the pk ?
It's working
<:yay:746135853688029274>
üòõ
thanks
<:kek:833489500835282974>
I can't tell from that screenshot, do you remake the account after you delete it?
creating the proposal/updating and removing it works perfectly

How are you checking that?
yes
Ok, well, is that acc.publicKey actually pointing at a previously-initialized account?
My bad
Oh, urgh, I can't read
no
Are you trying to init that account?
Why are you adding `acc2` to the signers array?
acc2 is the random wallet

I wrote a little vote program, so one user creates a proposal  and everybody with a sol wallet can vote (no restrictions - yet). When I test it with a random user wallet, it says "The program expected this account to be already initialized"
I'm new too, so somebody else might want to chime in, but I think it mostly just depends on how many different accounts you might end up wanting to create, i.e., one per program, one per user, or something else. If it's just one for the program, then I think you're ok with just that single constant as the seed. I have one in a current program that is just one per program and ended up doing:
```rust
        let auth_seeds = [
            "pda".as_bytes(),
            &program::Nftfactory::id().to_bytes(),
            &[auth_bump],
        ];
```
If you had one per user, you might add in the key of the user into the array of seeds. You can disregard the use of `auth_bump` here - this was for a set of seeds for another cpi instruction that wasn't handled automatically by anchor.
Here was an anchor one dependent on user:
```rust
    #[account(init, payer = payer, seeds = [payer.key.as_ref()], bump, space = User::LEN)]
    account: Account<'info, User>,
```
Ahhh, I‚Äôm not confident with seeds and bumps. What seed should I pass? Like in the example?
```seeds = [b"token-seed".as_ref()],```
Keeping it fixed for different mints is ok?
You can add it after the `remainingAccounts: [...], signers: [...]`
How do I pass the `signers` array in here? would it be via the `executeTransaction`? Or at the `createTransaction` level?
I created a program with a cpi to the mpl-token-metadata program to create a metadata account and the total program size ended up being bigger than the entire mpl-token-metadata program. Is that just a function of what my program used or am I importing more than I need?
https://github.com/CalebEverett/nftfactory/blob/master/programs/nftfactory/src/lib.rs
this is the program data:
https://explorer.solana.com/address/9q8FtaxK7K3Wq3Qb35u3Qw3ZjHGf7f21HC6vPdwE4rmE?cluster=devnet
this is the program data for the token metadata program:
https://explorer.solana.com/address/PwDiXFxQsGra4sFFTT8r1QWRMd4vfumiWC1jfWNfdYT?cluster=devnet
`isSigner` means "this thing *needs* to sign"
When you set the multisig's `isSigner` to true, that means that you then actually need to sign for it by sticking its keypair in the `signers` array
No program log, so I guess it's on the client side. I have the multisig `isSigner` set to true which is what's confusing here
```
  Tests out sending sol / tokens around
    1) SOL send: multisig -> arbitrary account works


  0 passing (2s)
  1 failing

  1) Tests out sending sol / tokens around
       SOL send: multisig -> arbitrary account works:
     Error: Signature verification failed
      at Transaction.serialize (node_modules/@solana/web3.js/lib/index.cjs.js:2829:13)
      at Provider.send (node_modules/@project-serum/anchor/dist/cjs/provider.js:89:26)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at async Object.rpc [as executeTransaction] (node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:31:31)
      at async Context.<anonymous> (tests/tokens_multisig_tests.js:505:5)
```
In particular, the error looks like
```
const accounts = [
      {
        pubkey: multisig.publicKey,
        isWritable: true,
        isSigner: true,
      },
      {
        pubkey: ownerA.publicKey,
        isWritable: true,
        isSigner: false,
      },
    ];

// 0.2 SOL * LAMPORTS/SOL
    const amountToMove = new anchor.BN(0.2 * 1000000000)

    const data = program.coder.instruction.encode("send_sol", {
      amount: amountToMove,
    });

await program.rpc.createTransaction(pid, accounts, data, {
      accounts: {
        multisig: multisig.publicKey,
        transaction: transaction.publicKey,
        proposer: ownerA.publicKey,
      },
      instructions: [
        await program.account.transaction.createInstruction(
          transaction,
          txSize
        ),
      ],
      signers: [transaction, ownerA],
    });

    // Other owner approves transactoin.
    await program.rpc.approve({
      accounts: {
        multisig: multisig.publicKey,
        transaction: transaction.publicKey,
        owner: ownerB.publicKey,
      },
      signers: [ownerB],
    });

    let preMultisigBalance = await program.provider.connection.getBalance(multisig.publicKey); 
    let preTxnAcctBalance = await program.provider.connection.getBalance(ownerA.publicKey);

    // Now that we've reached the threshold, send the transactoin.
    await program.rpc.executeTransaction({
      accounts: {
        multisig: multisig.publicKey,
        multisigSigner,
        transaction: transaction.publicKey,
      },
      remainingAccounts: program.instruction.sendSol
        .accounts({
          multisig: multisig.publicKey,
          receiver: ownerA.publicKey,
        })
        .map((meta) =>
          meta.pubkey.equals(multisig.publicKey)
            ? { ...meta, isSigner: true }
            : meta
        )
        .concat({
          pubkey: program.programId,
          isWritable: false,
          isSigner: false,
        }),
    });
 ```
code is the multisig, rest looks like:

```
 pub fn send_sol(ctx: Context<SendSol>, amount: u64) -> Result<()> {

    **ctx.accounts.multisig.to_account_info().try_borrow_mut_lamports()? -= amount;
    **ctx.accounts.receiver.to_account_info().try_borrow_mut_lamports()? += amount;

    Ok(())
} 

#[derive(Accounts)]
pub struct SendSol<'info> {
    #[account(mut, signer)]
    pub multisig: Box<Account<'info, Multisig>>,
    #[account(mut)]
    pub receiver: AccountInfo<'info>,
}
```
üëã Having a signature verification failed error üòï
Probably
I use vscode + rust-analyzer, it seems to handle hop-to-source fine
is this error possible due to the space in the base account being all used up? Thanks in advance smart ppl "Failed to serialize account"
you do have to have the seeds feature on though, I believe with 
```
[features]
seeds = true
```
in your `Anchor.toml`
yes, they get added to the idl - you can check the json file in `target/idl/<myprogram>.json` and then I believe put into a hash in the context at `.bumps` so they can be determined automatically - pretty sweet
I recently upgraded to solana v1.9.5 for my cli, and now when I do `anchor test` it takes 2 mins and often gives me this error:
```=====================================================================================
Recover the intermediate account's ephemeral keypair file with
`solana-keygen recover` and the following 12-word seed phrase:
=====================================================================================
XXXXXXXX
=====================================================================================
To resume a deploy, pass the recovered keypair as the
[BUFFER_SIGNER] to `solana program deploy` or `solana write-buffer'.
Or to recover the account's lamports, pass it as the
[BUFFER_ACCOUNT_ADDRESS] argument to `solana program close`.
=====================================================================================
Error: Custom: Invalid blockhash
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }.
```
oh, awesome. so it will be autogenerated?
you can just pass `bump` as an arg instead of `bump = vault_account_bump`
i need to pass it to the instruction? but where can i get it?
hey, how to get this bump seed? It is needed for account creation, im following: https://hackmd.io/@ironaddicteddog/anchor_example_escrow
they were on context:
```
rent: ctx.accounts.rent.to_account_info()
```
Also, general question: do any of y'all have recommended editor set ups? I find myself doing a lot of source diving and wondering if there's an easy way to link the SPL/Solana/Anchor libraries with the project you are currently working on. I want to be able to click through certain definitions but that isn't possible right now. I'm using VSCode
Is there an exhaustive list of inputs to pass into RPC calls? FFT point me to source code/documentation
If I need to pass sytem and rent accounts on to a cpi, how can I access them from the passed in context if using the methods api where they aren't passed in from ts?
what's the best practice for storing strings in accounts so the size is predictable and can be padded if less than max size?
thanks, let me try
I think there are M1 binaries now, but I'm not sure‚ÄîI install everything from source, yeah
solana return "solana-test-validator" [1]    84132 illegal hardware instruction  solana-test-validator
So problem might be come from solana, should I build solana from source, I used the bash script they providing to install
(There's also a `postInstructions: [...]` thing)
The `instructions` thing lets add some additional instructions to the transaction, which will run *before* your rpc instruction
`signers` says make these keypairs sign the transaction (the corresponding accounts will show up in your rust program with their `is_signer` flag set)
Mm, I think your solana isntall is probably messed up. Just to double check, are you able to start a local validator? `solana-test-validator`
Hi everyone, I tried to run `anchor build` program at M1 device but I got 
```
BPF SDK: /Users/anduc/.local/share/solana/install/releases/1.9.6/solana-release/bin/sdk/bpf
cargo-build-bpf child: rustup toolchain list -v
cargo-build-bpf child: cargo +bpf build --target bpfel-unknown-unknown --release
error: failed to run `rustc` to learn about target-specific information

Caused by:
  process didn't exit successfully: `rustc - --crate-name ___ --print=file-names -C lto=no --target bpfel-unknown-unknown --crate-type bin --crate-type rlib --crate-type dylib --crate-type cdylib --crate-type staticlib --crate-type proc-macro --print=sysroot --print=cfg` (exit status: 1)
  --- stderr
  error: Error loading target specification: Could not find specification for target "bpfel-unknown-unknown". Run `rustc --print target-list` for a list of built-in targets
```
Anybody know how to solve this?
Hi all , I am building a simple project put all binaries into the container to develop in anchor . https://github.com/glyfo/glyclt-solana , but I have some doubts about # anchor test. Requirement .


//////////////////////////////////////////////////////////////////////////////////////////

is there a way to extract the inferred type?
Ugh, I want to write a utility for this in a pull request but it will likely be the wrong route.  TypeScript gets really gnarly with recursive type hierarchies and you run into their heuristic limits that are hard-coded in the compiler.  It's much better to just code gen the types at build time and call it a day since that's what anchor is already doing anyway.
yeah similar issue, `useState<WHAT ARE YOU>(...)`
The problem is that I want to take these results and store them in my state store for the UI, and I gotta label that thing with a type, etc.
haha yup, hence sadface
Heh, yeah, but that kind of defeats the point of all this typescript generation to an extent.
having the union isn't the end of the world for me, better than `any`
you could always write your own type and cast it üò¶
Yeah, weird, right?  I see why it's written this way, but having dealt with similar situations it is usually better to decouple the type transformation into their own types or have the code generation do a chunk of it
thought it was good, but now i realize it's the union like you said
the inferred type is all good when calling fetch, but i hadn't been able to produce the same type with TypeDef so i tried the other route
ah i see what you mean actually, yeah dotting into an account it has all the properties across accounts
is that the type setup that you've got ^?
```type MyProgram = anchor.Program<MyProgramGeneratedTypes>;
type Base = Awaited<
  ReturnType<MyProgram["account"]["base"]["fetch"]>
>;```
That's the same issue I was facing with my type derivation too.
`type Game = Awaited<ReturnType<Program<MyProgram>['account']['gameAccount']['fetch']>>`  Game here is a union of all the account types defined in my program
At least that's what VSCode is claiming
Ah, I needed `Program<MyProgram>` still - that spits out a union type not a specific account type
what do you have MyProgram set as?
Trying yours first since you know it works - I'm getting `Property 'account' does not exist on type 'MyProgram'`
can you share the code you've got? that should work
Yeah, that's where I started, but I can't seem to get it to not be a union of all account types
i'm sure there's a better way to accomplish this, but here's what i've got working: `type Base = Awaited<ReturnType<YourProgram["account"][<account name>]["fetch"]>>;`
It's weird - the types for the idl are more metadata for type generation rather than "types"  It seems `Program<T>` does type transformations on it to spit out the fluent interface but the end of the line doesn't give an expected plain type for an account
Should `fetch` and other TypeScript calls have type definitions for the accounts?   I can't seem to find a way of getting a specific account type from the generated IDL.  Everything appears to be mixed together and from reading the source, there doesn't appear to be a type mapping from the idl to a specific user-facing TypeScript type for the account.
The more broad question I'm asking is: just like how USDC and other fungible tokens follow the SPL token standard, is there an equivalent for NFTs on Solana?
This makes sense. <@!134416332509675520> 's previous answer was that if an account has a Mint Authority and an Update Authority it needs to be a program. If you look at this NFT (https://solscan.io/token/CzymaSrMbe5PNvKqi1kJgpTjmD7Wz7iG4c6aCof1Qj6U) It clearly has the mint + program authority. So does this make it a program (executable account)?
not sure, ive only deployed to devnet
limited to devnet at least?
nope :/
have you found any cause/solution? seems to happen pretty often for me as well
So everything is an "account" (Buffer storing data).
Some accounts are marked as executable and we call these programs (smart contracts)
Nft's are generally spl-tokens (just another account) and are not marked as executable no
So NFTs are programs? hmmmm
that's the strange part! i actually check for this error ```programError(306, 'Game already started.')```, but it doesn't catch for some reason.
0x132 is hexadecimal for 306
Hey! I'm trying to run a test suite on an anchor project. Most of the tests succeed, but tests that depend on program raising an error fail. For example:
```
‚óè trivia ‚Ä∫ Fails to remove the Question from the already started Game

    expect(received).rejects.toThrow(expected)

    Expected message: "306: Game already started."
    Received message: "failed to send transaction: Transaction simulation failed: Error processing Instruction 0: custom program error: 0x132"

          317 |
          318 |     test('Fails to remove the Question from the already started Game', async () => {
        > 319 |         await expect(program.rpc.removeQuestion(dummyQuestionKeypair.publicKey, {
              |         ^
          320 |             accounts: {
          321 |                 game: gamePDA,
          322 |                 authority: provider.wallet.publicKey,

          at Connection.sendEncodedTransaction (node_modules/@solana/web3.js/src/connection.ts:3689:13)
          at Connection.sendRawTransaction (node_modules/@solana/web3.js/src/connection.ts:3649:20)
          at sendAndConfirmRawTransaction (node_modules/@solana/web3.js/src/util/send-and-confirm-raw-transaction.ts:27:21)
          at Provider.send (node_modules/@project-serum/anchor/src/provider.ts:114:18)
          at Object.rpc [as removeQuestion] (node_modules/@project-serum/anchor/src/program/namespace/rpc.ts:24:23)
          at Object.<anonymous> (tests/trivia.ts:319:9)

      322 |                 authority: provider.wallet.publicKey,
      323 |             },
    > 324 |         })).rejects.toThrow(programError(306, 'Game already started.'))
          |                     ^
      325 |     })
      326 |
      327 |     test('Reveals a Question for the Game', async () => {

      at Object.toThrow (node_modules/expect/build/index.js:285:22)
      at Object.<anonymous> (tests/trivia.ts:324:21)
```
However, the error 0x132 is actually 306. Should i change my code to match the error?
many thanks, will try üôÇ
Yep, in solana the client always has to pre-specify every single account of interest, not possible to do it dynamically within the program
oh, so i can't simply call smth like `findATA()` inside program? All the accounts should be passed from the client?
No matter what, you need to pass in the address you want to use from the client, FYI
Got it!
maybe better solution will be not to pass the ATA account and just find it inside program since the ATA is owned by my program...
Or just use token account pda with mint seed so I can address it
Thx bro
And keeping the seeds + bump part.
You would do that by just changing those `associated_token::mint` etc. constraints to be `token::mint = `.
If you already have an address that makes sense in your application, there's no reason to use an associated token address
That said, it's also possible to just not use an associated token address, and just store the token account at one of your own PDAs!
You don't have any choice for the ATA's address (it's determined by the owner of the account + the mint‚Äîthe point of an ATA is to have an "obvious" address)
Yep.
oh, so the right way is to find ATA in the client and then pass it to the program?
You actually can't use seeds with an associated token address, since associated token addresses are *already* program-derived addresses (they're derived from the associated token program, so you can't try to derive them from your own program too).
hello, im running into 
```
     Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: An account required by the instruction is missing
```
```
    #[account(mut)]
    pub signer: Signer<'info>,
    #[account(mut)]
    pub signer_token_account: Account<'info, TokenAccount>,
    #[account(address = crate::id())]
    pub bridge_program: AccountInfo<'info>,

    #[account(
        init_if_needed,
        seeds = [signer.key().as_ref(), mint.key().as_ref()],
        bump,
        payer = signer,
        space = 8+64,
    )]
    pub pda_user_data: Account<'info, Balance>,

    #[account(
        init_if_needed,
        seeds = [mint.key().as_ref()],
        bump,
        associated_token::mint = mint,
        associated_token::authority = bridge_program,
        payer = signer,
    )]
    pub pda_ata_bank: Account<'info, TokenAccount>,

    pub mint: Account<'info, Mint>,
    pub token_program: Program<'info, Token>,
    pub associated_token_program: Program<'info, AssociatedToken>,
    pub rent: Sysvar<'info, Rent>,
    pub system_program: Program<'info, System>,
```
im pretty sure there is something wrong with `pda_ata_bank` account, can smn help me?
The default/*un*-initialized state is to be owned by the system program (so e.g. if you make a fresh keypair address and pass it into your program as an account, it will show up in an empty state: no data, zero lamports, owned by the system program).
Do you mean uninitialized?
are all accounts initialized are owned by the system program ?
So in other words it inits but only if the account hasn't already been init'd.
It checks to see if the incoming account is owned by the system program (this is the default, and applies to uninitialized accounts‚Äîso when you use regular `init`, it expects the incoming account to be owned by the system program). If you use `init_if_needed` and the account *isn't* owned by the system program (meaning it has already been initialized), then anchor skips its own initialization that it would have done if you said `init`, and instead just verifies that the incoming account matches what *would* have happened if you had initialized it (matches all of the constraints you used).
how does init_if_needed work ?
If thats the case then Id need to call a function setup kinda like this?

```
    pub fn create_player_token_account(ctx: Context<CreatePlayerTokenAccount>) -> ProgramResult {
        
            let instruction = create_associated_token_account(
                &ctx.accounts.player.key(), 
                &ctx.accounts.player.key(), 
                &ctx.accounts.mint.key(),
            );

            let response = 
anchor_lang::solana_program::program::invoke(
                &instruction,
                &[
                    // ?? Not sure of needed accounts
                ],
            );
        
}

#[derive(Accounts)]
pub struct CreatePlayerTokenAccount<'info> {
    #[account(mut)]
    pub player: Signer<'info>,
    #[account(mut)]
    pub new_derived_account: Account<'info, TokenAccount>, 
    pub new_wallet_address: AccountInfo<'info>,
    pub mint: Account<'info, Mint>,   
    pub token_program: AccountInfo<'info>,  
    pub system_program: Program<'info, System>,
    //Rent sysvar?
}
```

What would be the min amount of accounts I'd need to pass in? If it really is all of this - I'll just call it on the frontend.
Only https://docs.rs/anchor-spl/latest/anchor_spl/ and various stuff around the net. You could checkout solana cookbook (Google it)

Has some examples I think
Got it! 

Looking into the create_associated_token_account docs. I need the following accounts: Does that mean all of these are needed by the invoke function?

            [writeable, signer] Funding account (must be a system account)
            [writeable] Associated token account address to be created
            [] Wallet address for the new associated token account
            [] The token mint for the new associated token account
            [] System program
            [] SPL Token program
            [] Rent sysvar
You'll need to specify that address from the client ("pass it as an account")
Hey all! I'm trying to call create_associated_token_account within a Solana program. But I'm 1. not sure if I can - I image I'd have to run a CPI 2. If it's possible, can I call it with just the pubkeys, not the AccountInfo?
(only when i check with commitment finalized btw)
if i disable preflight checks, everything goes through smoothly
Hey guys.
Does anyone know why im getting "Blockhash not found" error on the sendTransaction RPC endpoint, ONLY when preflight checks are enabled?
Ok gotcha. I am testing on my localnet so thought it should show up there on the client side.
in js client rpc it does, dont think it shows up in the program logs
Right which matches, but I thought it was supposed to print out the custom message associated with the error #. Per this : https://project-serum.github.io/anchor/tutorials/tutorial-4.html#defining-a-program
0x1770 to decimal -> 6000

if 6xxx -> it's a custom errors so your error #0
Am I missing something here to get custom error messages to show in the log / on the client ? 

```
        if !full_metadata_clone.data.creators.unwrap()[0].verified {
            return Err(ErrorCode::NotVerified.into());
        }
```

```
#[error]
pub enum ErrorCode {
    #[msg("NFTs creator has not verified")]
    NotVerified,
}
```

Error is catching as desired, but it is showing up as `Error processing Instruction 1: custom program error: 0x1770`
anyone knows what I should be careful about when using `init_if_needed` in `v0.21.0`

"Put init_if_needed behind a feature flag to decrease wrong usage"
you can playaround with the wallet object given by the useWallet hook
i think phatom does not exposes that
Is there a way to detect what network/cluster the user's wallet is connected to?
Hello, 
I'm trying to close PDA accounts, but am getting the following error

``` failed to verify account GzfEUa4BXdirVtfNEgJrioGqXtWvgbTxUc2sxMmqfeWN: instruction changed the balance of a read-only account```

How do I verify a PDA account to close, and how I find the full program log? 
I tried passing in both the wallet pubkey and the PDA pubkey as an input to the Anchor instruction

I'm trying to close "items" on a "todo" list account, but I closed the "todo" list accounts first

```
  pub fn cancelitem(
        ctx: Context<CancelItem>,
        item: Pubkey) 
        -> ProgramResult {
        let item = &mut ctx.accounts.item;
        let item_creator = &ctx.accounts.item_creator;
        let user = ctx.accounts.user.to_account_info().key;
        item.close(item_creator.to_account_info())?;
        
        Ok(())
    }
```
```
#[derive(Accounts)]
#[instruction(item: Pubkey)]
pub struct CancelItem<'info> {
    pub item: Account<'info, DataAccount>,
    pub item_creator: AccountInfo<'info>,
    pub user: Signer<'info>,
}
```

```
  const closeItem = async (e) => {
    e.preventDefault();

    const provider = getProvider();
    const program = new Program(idl, programID, provider);
    console.log("ping");
    console.log(provider.wallet.publicKey.toString());

    const items = await program.account.dataAccount.all();
    console.log("All item", items);

    //Close All Item Accounts
    for (var i = 0; i < items.length; i++) {
      console.log(items[i].account.creator);
      await program.rpc.cancelitem(provider.wallet.publicKey, {
        accounts: {
          item: items[i].publicKey,
          itemCreator: provider.wallet.publicKey,
          user: provider.wallet.publicKey,
        },
      });
    }
  };
```
Can someone help me out with this?
https://github.com/project-serum/anchor/issues/1082#issuecomment-1041574986
nice üòÇüëç
you know how dumb mistake that was? `anchor new` generated the program defaulting to `id.json` while I was using different oneü§£ ü§¶‚Äç‚ôÇÔ∏è 
all it take was walking outside and take some fresh air and come back and just check wth is in the `Anchor.toml`
Hi are there any docs I can refer, couldnt find them
np man hope u get it figured out ‚úä struggling thru it
I'll ping you if with outcomes later
Thanks a lot kind strangerüòä let me try my shot first cuz I think I may have a lot of things to clarify and rerun some docs
if you've already tried restarting your machine, try to take a look at `test-ledger-log.txt` - i don't know how much help i'll be but i can take a look too
no, when you use `anchor test` it should output any `console.log`s you have in your main program. it should be able to start the test validator, so you need to fix that first
it doesn't show anything like `passed: x, failed: x` that's was confusing if it's not meant to log only when there's  a failing test haha
ooh okok, that makes sense
and nope I wasn't running the `solana-test-validator` so in that case `anchor test` output should be as in the screenshot?
no, your initial assumption was correct, I just worded it wrong. `anchor test` has it's own implementation of solana-test-validator I believe (it will start a local cluster). I just meant that you shouldn't be running `solana-test-validator` in another terminal while you run `anchor test`.
I was being led wrong this entire time if you're right
ooh now I am confused as hellüòÖ
and to answer your question, you are right in that you should not have a separate `solana-test-validator` running when you run `anchor test`.
not sure then; still try to system restart but if you still get that error check test-ledger-log.txt
my pc is running on ubuntu, not wsl
imo experience on wsl, a system restart fixed this error for some reason. have you tried?
Has anyone figured out how to do incremental builds of their anchor program (only recompile changed files)? `anchor build` takes a while
guys, was wondering if the output should be as following when run the `anchor test` command? since `solana-test-validator` is not running, I was told the `anchor test` will generate it's own validator, how accurate is that?
Can someone give me a pretty high level overview of the dev flow I need to follow? I can elaborate more but I'm essentially working on a project that's a P2E NFT game- ownership of a "player" NFT allows you to play (immutable, just need to check that user owns an NFT from the collection), separate utility token used as currency in the game (need to transfer tokens from user (to game) to user, mint/burn tokenomics). I'm new to Solana development but I know I want to use anchor to code the game logic in rust; I'm hitting a wall on how to interact with SPL tokens (NFT and utility token) on an anchor program. First, for the NFT collection itself, would it be feasible to mint the collection with Candy Machine (v2), and once it's on chain I can verify owner w/ metadata retrieval in my webapp (basically separating the initial mint w/ game program)? Second, I'm completely lost on implementing a fungible SPL utility token into my contract. My understanding is limited to creating an SPL Token with the Solana CLI, but I don't know if that could also be separated (create SPL Token w/ CLI and just interact with mint account w/ game program). Would I be able to mint and burn utility tokens by interacting with my game's program through my web app? Any help is appreciated -- I ran through buildspace's web3 anchor course, but it didn't cover anything about SPL Tokens; any docs that cover how to create/interact with SPL Tokens would help. ty üôè
Provides validations and functions for interacting with the spl-token program
(validations for tokenaccounts and mints and token transfer functions for cpis)
Yeh I just meant if I want to send spl tokens to my program should I be making a token account on that program and sending them there or an ata on that program and sending them there. Didn't know if there was a best practice.
What are main limitations of PDA's ? (just size?)
Is there a list of them somewhere
Hi question on the anchor-framework libraries, 
if I see the toml file here https://anchor.projectserum.com/build/328/nft-candy-machine/Cargo.toml , the following are the requirements: 
```[dependencies]
anchor-lang = "0.17.0" --> this is the anchor framework itself
spl-token = { version="3.1.1", features = [ "no-entrypoint" ] } --> SPL token library
anchor-spl = "0.17.0" --> what about this ?
...
```

I would like to know what the `anchor-spl` library does, I couldn't find documentation on it apart from https://docs.rs/anchor-spl
Thanks! I‚Äôll check it out
You can definitely do this, just need to force the client to sign the instruction with some known admin key. You could for example just hardcode this key into your program, or use the program's deployment upgrade authority (more complicated, but here's an example: https://github.com/project-serum/anchor/tree/master/tests/bpf-upgradeable-state)
The func I wanna protect access to is an init function to set everything in motion
If I want to gate a function so only I can call it on the main net is that idomatic? Or am I thinking about it wrong? Do ppl do this?
Ah, those accounts are still owned by the spl token program (you're just init-ing them inside your own program)
Sorry I just mean can we make ATAs that our program can send too and from just like we can regular spl token

Is there an issue with that?
I got some missing account error when giving it a try
btw. if you have a minute - I have another question (I hope a simple one, but that was my hope with the last one as well):
**how to run a specific (single) anchor test?**

- running `anchor test` launches all tests (the default `test` script)
- running ts-mocha directly doesn't bring the test blockchain up
- adding a script in `anchor.toml` doesn't bring the test blockchain up
- modifying the `test` script does work, but is extremely annoying to work with

so again, I must be missing something. I'd appreciate any help üôÇ
ps. I added the "consumed" bits to the original log message I pasted, but they are pretty unhelpful üòâ
unless I'm missing something?
I have pasted all I had. it failed with transaction simulation, so there is actually nothing more
Can you post the program log though? (Lol üòõ)
thanks. at least I know I'm not doing something wrong üòÑ
and here I thought that I'm the stupid one for diving in source all this time üòÇ
oh well, time to do some diving then.
Otherwise all mapping from raw error code to human readable string involves some deduction
Yep
so just to recap: unless the error is logged BEFORE it's returned - there is no way to make it human readable.
the only way is do some source-diving?
So, can't say much more without the full program log
It depends on the program stack trace
It's not really returned by anchor (in solana when you encounter an error it shortcircuits everything else, so in general there's no way to know what the error code corresponds to‚Äîyou just have to go source-diving/think about it)
true that. but it's returned by anchor. is there any way to unwrap those (potentially using some smart anchor functionality) ?
thanks for your answer.
full log is below
```Transaction simulation failed: Error processing Instruction 0: custom program error: 0x7
    Program 93i4jTHCR2Q23qrqQDEPu3EqCfnaQJwtiM3un7ApkNz3invoke [1]
    Program log: ----------image update----------
    Program metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s invoke [2]
    Program log: Instruction: Update Metadata Accounts
    Program log: Update Authority given does not match
    Program metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s consumed 7334 of 181386 compute units
    Program metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s failed: custom program error: 0x7
    Program 93i4jTHCR2Q23qrqQDEPu3EqCfnaQJwtiM3un7ApkNz3 consumed 200000 of 200000 compute units
    Program 93i4jTHCR2Q23qrqQDEPu3EqCfnaQJwtiM3un7ApkNz3 failed: custom program error: 0x7
```
and yes, I can see that the problem is the authority, but this was simply an example.
the author of this particular code didn't have to LOG anything before returning an error (and more often than not - they don't) 
so the question still stands.
They start at 100.
I actually don't think that's an anchor error at all ü§î
Can you post the full program log?
hey
stupid, beginner question I've been battling with for ages now:
how to unwrap something like that:
```
Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: custom program error: 0x7
```
into something actually understandable?
I know I can change this code to integer, but anything below 300 (if I remember well) is not my error code (and those are actually correctly, like `301: Not enough funds to cover fee.`), so it's really hard to actually figure out what error is that...
I'm probably missing something easy and obvious here, because it's just not possible for error handling to be so messed up, so please help üôÇ
What do you mean by program owned?
I just ran `anchor test` (I thought that usually builds and deploy the program before running the tests?)
So we can make program owned spl accounts with:
```
#[account(init, payer = authority, seeds = [config.key().as_ref(), b"tide_trtn_account".as_ref()], bump, token::mint = trtn_mint, token::authority = trtn_account)]
pub trtn_account: Account<'info, TokenAccount>,
```
Can we also make program owned ATA's?
You legendddd üî•
omg it fucking works now!!!! i just rebuilt nd redeployed it
interesting...let me try something
Hmm, that's an unusual error to get, are you sure you've deployed the program correctly etc.?
Yeah, you'd have to import that type from the other program (you'd need to depend on their source code)
I have the following error and not entirely sure what it means....

```sh
Transaction simulation failed: Error processing Instruction 0: custom program error: 0xbbd
    Program bgKX8Yxqqbu4nthUgJ3c2mqCEd4w8hQyqn6eTDzDkz1 invoke [1]
    Program log: Instruction: ProcessPlayerWithdraw
    Program log: Custom program error: 0xbbd
    Program bgKX8Yxqqbu4nthUgJ3c2mqCEd4w8hQyqn6eTDzDkz1 consumed 4434 of 200000 compute units
    Program bgKX8Yxqqbu4nthUgJ3c2mqCEd4w8hQyqn6eTDzDkz1 failed: custom program error: 0xbbd

Error: 3005: Not enough account keys given to the instruction
```

Current withdraw fn

```rust
    pub fn process_player_withdraw(ctx: Context<ProcessPlayerWithdraw>, amount: u64) -> Result<()> {
        let fund_payer = &mut ctx.accounts.player;
        let payer_balance = fund_payer.to_account_info().lamports();
        let rent_exemption = Rent::get()?.minimum_balance(fund_payer.to_account_info().data_len());

        // We check if we have enough funds
        if payer_balance - rent_exemption < amount {
            msg!("Insufficent balance");
            return Err(HouseError::InsufficientFunds.into());
        }

        // Transfer balance
        **fund_payer.to_account_info().try_borrow_mut_lamports()? -= amount;
        **ctx.accounts.receiver.try_borrow_mut_lamports()? += amount;
        Ok(())
    }

#[derive(Accounts)]
#[instruction(amount: u64)]
pub struct ProcessPlayerWithdraw<'info> {
    #[account(mut)]
    player: Account<'info, Player>,
    #[account(mut)]
    receiver: Signer<'info>,
    // #[account(address = system_program::ID)]
    // system_program: Program<'info, System>,
}

```

Test:
```typescript
await program.rpc.processPlayerWithdraw(
      new anchor.BN(withdrawAmount * LAMPORTS_PER_SOL),
      {
        accounts: {
          player: randomPlayer,
          receiver: randomKeypair.publicKey,
          // systemProgram: SystemProgram.programId
        },
        signers: [randomKeypair]
      }
    );
```
my understanding is that I cant bind `#[account]` to accounts not owned by the present program
when I did that, it gave me `required by a bound in anchor_lang::prelude::Account`
Yeah
Once you import that type
You ought to be able to just do the usual
```.rs
pub that_account: Account<'info, MarketA>
```
And program B is an anchor program?
not sure it makes sense
Program B has struct defined as 
`pub struct MarketA{
     pub field1: u64,
     pub field2: u64, ....
`

i am trying to load the data from an account key of Program B from Program A
Can you say more about what you want to do? What kind of data are you deserializing?
Are there examples of deserializing data with anchorserialize/anchordeserialize?
Mints are just accounts in solana, there's just the one-and-only spl token program behind the scenes
Mint's don't have upgrade authorities (only programs do)
Oh, sorry (I'm having like my worst reading comprehension day ever, I don't know what's going on)‚Äîthat link there is to the mint itself
The mint authority isn't stored on the token account at all, it's stored on the mint account
The mint itself in solscan is called the "Token address" (would have been easier if they just called it the mint address)
Not a program
But no, the token account's authority there is its "logical owner", e.g. a random wallet
Ah, this is annoying but the naming conventions around tokens are irritatingly nonstandard
In the case of a regular SPL token does `Authority` encompass both the mint authority and upgrade authority?
Got it - how does this differ across a regular SPL token (e.g. USDC https://solscan.io/token/EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v) where you only have the Owner Program vs. Authority?
Unlike in ethereum.
By default, when you deploy your program you can just keep on re-deploying it, updating it in the process
> Update authority is who has to sign in order to redeploy an upgradeable program (the default).

What do you mean by redeploy an upgradeable program?
Mint authority is who has to sign in order to mint new tokens. Update authority is who has to sign in order to redeploy an upgradeable program (the default). Owner program is the program that's allowed to mutate an account's data or spend the account's money (so, for a token account, that would be the spl token program)
For an SPL Token account (in particular an NFT), what's the difference between the Mint Authority vs. Update Authority vs. Owner Program?
ty for the help
but was somewhat surprised when I encountered issues there. NBD though, was not too painful to resolve
that mapped the owner to `spl_token_2022::id()`
Oh, got it
Yeah I know. I created a custom `Mint` wrapper class based on the anchor-spl version
Ah, ok. Yeah, hmm, that won't work directly with the `Mint` type unfortunately (`Mint` encodes its owning program as the original token program)
yeah, that's the difference
Ah, I wonder if the spl_token_2022 part is different?
What do you mean by a custom wrapped Mint? You can definitely `init` a mint
Solution here was to do this:
```
    #[account(
        init,
        seeds = [
            payer.key().as_ref(),
        ],
        bump,
        owner = spl_token_2022::id(),
        payer = payer,
        space = Mint::LEN,
    )]
    pub mint: UncheckedAccount<'info>,
```
idk why this worked while the other didn't (the Mint was a custom wrapped Mint object) but i'll take it
Yep, `program.instruction.yourInstructionName`
Can the anchor-ts methods namespace return an instruction instead of directly executing the rpc?
Best practice I've seen so far is just to define a `AccountName::LEN` property depending on your struct schema. Check out this example: https://lorisleiva.com/create-a-solana-dapp-from-scratch/structuring-our-tweet-account
hmm ill see if im doing smth dumb then ty
I think `Buffer.from([...])` should work ü§î
anyone know what to use in `findProgramAddress` in js to match a `&[u8; 30]` in pda seeds in rust? tried variations on Buffer.from(), Uint8Array.from(), etc but keep getting either `signer privilege escalated` or `seeds do not match`
ah got it. thank you
At some point in solana 1.9  I think you'll be able to add additional space to an account
I got I need to keep it minimal, thanks. but I worry if I deploy program it could be no way to increase it later
Not really, just "use enough space" while staying within a budget you're ok with  üò¨
ok I see. any best practices for thinking about future updates?
Bear in mind that account storage is pretty expensive. Rent-exemption costs 7 sol / mb.
I see account can be max 10 MB. but it doesn't make much sense to reserve so much space for my structs
hey guys, what account size you usually set? 
assuming it can be changed later and new fields added
üôèüèºüôèüèºüôèüèº
I seeeeeee! super super helpful. thank you for taking your time to answer these questions. I believe i got enough pointers to try to have a dabble at this again
So there isn't one way to move lamports in solana, it depends completely on which program owns the source account.
3. When you send sol to the PDA, this is a bit different: here the source account is presumably the user, and their account *is* owned by the system program‚Äîso now you actually have to use the system program's transfer instruction, because only the system program has the rights to decrement that account's balance.
2. You use try_borrow_mut_lamports on both the source and the destination account (taking from the source and giving to the destination)
1. That means some account was expected to sign (by whatever code you end up running, here the CPI to the system program), but the account didn't actually sign. Here, you never actually signed for the player account.
The `process_player_withdraw` I have is almost the same as how i deposit SOL into that PDA account. (Is using that way to deposit SOL in the account incorrect as well?)
1. Can you give me a bit more info of what `signer privilege escalated` means? (Is that some sort of authorisation error thats gets bubbled up from some where?)
2. Okay, what you said make sense regarding the PDA is owned by my program so `system_program` can't mutate it. But I have a question with if i tried to use `try_borrow_mut_lamports` where does the balance goes? (I'm not sure i fully understands it by reading that discord message)
Something like this: https://discord.com/channels/889577356681945098/889577399308656662/925907788172001301
(And no need to sign for anything, since your program owns the player account‚Äîit can do whatever it wants with it)
You'll have to directly decrement the lamports yourself, using `try_borrow_mut_lamports`
In solana, every account is owned by a program, and *only* that owning program is allowed to mutate the account's data or spend the account's money. In this case, you're asking the system program to decrement the player account's lamports‚Äîbut the system program can't do that, because it doesn't own that account (your own program does)
I think the other issue you're going to have though is that if the `player` account is owned by your program, this actually isn't how you do a transfer
Ok, so `FTu3NnMRJ7f4cBtVWstiNna9UE5EVnHDxinAQBwo6DrA's signer privilege escalated` means that you're indeed not signing for something correctly
Thank you for answering that. this is so much better than looking for answers from the internnet. been scratching my head for days now
Will this help?
```
Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account
Program bgKX8Yxqqbu4nthUgJ3c2mqCEd4w8hQyqn6eTDzDkz1 invoke [1]
Program log: Instruction: ProcessPlayerWithdraw
FTu3NnMRJ7f4cBtVWstiNna9UE5EVnHDxinAQBwo6DrA's signer privilege escalated
Program bgKX8Yxqqbu4nthUgJ3c2mqCEd4w8hQyqn6eTDzDkz1 consumed 7512 of 200000 compute units
Program bgKX8Yxqqbu4nthUgJ3c2mqCEd4w8hQyqn6eTDzDkz1 failed: Cross-program invocation with unauthorized signer or writable account
```
Yep, exactly
Ahhhh what you said make sense. part of the restriction, as it doesn't have a private key, so you can't really sign the transaction from client side?
There will be a line in it that tells you more info
Can you post the full program log from when that happens?
PDAs can't be signed for from the client (part of their purpose is that *only* their deriving program can sign for them‚Äîyou just physically can't do it from the client)
If the `Player` lives at a PDA (with seeds etc.) then you won't be able to mark it as a signer like that, `#account(mut, signer)`
I'm super new to rust, anchor and solana
If you spotted anything i can improve with my code, happy to hear it to!
Before i added `signer` to `#[account(mut)` i was getting ` Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account`
After I added `#[account(mut, signer)]` above `player: Account<'info, Player>,` in `ProcessPlayerWithdraw` I'm now getting ` Error: Signature verification failed`
My ts test code
```typescript

// Note: RandomPlayer is created with Random Keypair

async function createRandomPlayer({ username, initialBalance }: {
    username: string,
    initialBalance: number
  }) {
    const randomAccount = anchor.web3.Keypair.generate();
    await airdrop({ publicKey: randomAccount.publicKey, amount: initialBalance });
    const [player, bump] = await PublicKey.findProgramAddress(
      [randomAccount.publicKey.toBuffer()],
      program.programId
    );
    await program.rpc.createPlayer(username, {
      accounts: {
        player,
        authority: randomAccount.publicKey,
        systemProgram: anchor.web3.SystemProgram.programId,
      },
      signers: [randomAccount]
    });
    const account = await program.account.player.fetch(player);
    return {
      randomKeypair: randomAccount,
      randomPlayer: player,
      randomPDAAccount: account
    }
  }
///
    await program.rpc.processPlayerWithdraw(
      new anchor.BN(withdrawAmount * LAMPORTS_PER_SOL),
      {
        accounts: {
          player: randomPlayer,
          receiver: randomKeypair.publicKey,
          systemProgram: SystemProgram.programId
        },
        signers: [randomKeypair]
      }
    );
```
```rust

    pub fn process_player_withdraw(ctx: Context<ProcessPlayerWithdraw>, amount: u64) -> Result<()> {

        let fund_payer = &mut ctx.accounts.player;
        let fund_payer_account_lamports = **fund_payer.to_account_info().lamports.borrow();

        // TODO: Check player balance before transfer
        // TODO: Check player's authority is withdraw receiver

        let instruction = anchor_lang::solana_program::system_instruction::transfer(
            &ctx.accounts.player.key(),
            &ctx.accounts.receiver.key(),
            amount,
        );
        // Execute transfer instruction
        anchor_lang::solana_program::program::invoke(
            &instruction,
            &[
                ctx.accounts.player.to_account_info(),
                ctx.accounts.receiver.to_account_info(),
                ctx.accounts.system_program.to_account_info(),
            ],
        );
        Ok(())
    }


#[derive(Accounts)]
#[instruction(amount: u64)]
pub struct ProcessPlayerWithdraw<'info> {
    #[account(mut, signer)]
    player: Account<'info, Player>,
    #[account(mut)]
    receiver: Signer<'info>,
    #[account(address = system_program::ID)]
    system_program: Program<'info, System>,
}
```
Thanks! So here is what i have in my rust program

```rust

    pub fn create_player(ctx: Context<CreatePlayer>, name: String) -> Result<()> {
        ctx.accounts.player.name = name;
        ctx.accounts.player.enabled = true;
        ctx.accounts.player.authority = *ctx.accounts.authority.key;
        ctx.accounts.player.bump = *ctx.bumps.get("player").unwrap();
        Ok(())
    }

#[account]
pub struct Player {
    pub name: String,
    pub authority: Pubkey,
    pub enabled: bool,
    pub bump: u8,
}

#[derive(Accounts)]
#[instruction(name: String)]
pub struct CreatePlayer<'info> {
    #[account(
        init,
        seeds = [authority.key().as_ref()],
        bump,
        payer = authority,
        space = 320,
    )]
    player: Account<'info, Player>,
    #[account(mut)]
    authority: Signer<'info>,
    system_program: AccountInfo<'info>,
}
```
Easiest way is probably for you to just start posting some code!
I'm looking for some help related to withdrawing from a PDA account (I'm using anchor) which is the best channel to ask these sort of questions? (I got some signing related issue i believe)
Oh, sorry‚Äîcan use `token::mint` and `token::authority` for a TokenAccount
You can initialize a mint account though with the `mint::decimals` and `mint::authority` attributes
The issue is that in general `init` is doing more than just assigning ownership‚Äîit might have to do arbitrary other stuff depending on what kind of account you're init-ing.
https://github.com/project-serum/anchor/blob/a66257701863df288e32f7030e7708652f614f1c/lang/syn/src/parser/accounts/constraints.rs#L51 seems impossible
Would love to know if that's possible as well
Ah ok
it's a not a mint account for the normal Token Program
I see that you're trying to init a mint account. That didn't work for me either. But for TokenAccount this worked for me without any additional keywords:

```#[account(
      init_if_needed,
      payer = player,
      associated_token::mint = cost_mint,
      associated_token::authority = authority,
    )]
    pub authority_cost_ata: Box<Account<'info, TokenAccount>>,```
kinda surprised it's not general though. this is easy enough to just write by hand though so nbd
yeah for TokenAccount etc.
https://github.com/project-serum/anchor/blob/83121c26eb578487196524d5829099a70503a5a3/tests/misc/programs/misc/src/context.rs
I know you can for specific programs
Others may be able to comment but from my understanding you cannot `init` accounts for other programs. You can only `init` your own.
https://lorisleiva.com/create-a-solana-dapp-from-scratch/structuring-our-tweet-account

This should also help with understanding the layout of accounts on Solana
Just gotta know the shape of your account really well, which isn't that hard if you're allocating space for it yourself
https://solanacookbook.com/guides/get-program-accounts.html
probably a super basic question, if i want to assign an account to a different program in the the `init` macro, what's the keyword to use:
```
    #[account(
        init,
        seeds = [
            owner.key().as_ref(),
        ],
        bump,
        payer = owner,
        space = Mint::LEN,
        owner = spl_token_2022::id(),
    )]
    pub mint: Box<Account<'info, Mint>>,
```
`owner` is not the right keyword
is calling `load_init()` on an AccountLoader inside the fn the same as using `init` in the account constraints? You could do one or the other?
Got it, thanks a lot üëê
The latter
Ah this makes sense, thanks a lot, apologies if Im being unable to grasp a obvious thing here, but say I didn't have any constraints I want over my account, in that case, would my program look like this 
```#[derive(Accounts)]
pub struct Vote<'info> {
    /// Marking accounts as mut persists any changes made upon exiting the program 
    #[account( )]   --> no constraints...
    pub vote_account: Account<'info, VoteAccount>,
}
```

OR would it be like this

```#[derive(Accounts)]
pub struct Vote<'info> {
    /// Marking accounts as mut persists any changes made upon exiting the program 
    /// removed the line itself here 
    pub vote_account: Account<'info, VoteAccount>,
}
```


//////////////////////////////////////////////////////////////////////////////////////////

I guess I don't really know how large the solana programs can get, and how niched down in focus they are supposed to be.
Is it considered best practice to have two initialized types of data in one solana program? most of the tutorials i have seen include only 1 initialized type.
up
have a question about the spl-token CLI, thought i'd ask here, fft ignore if it's not relevant.

```spl-token account-info 7MC1kwNJaScpMw1QukdeD48rSp7cE3NgxZ2yKdDBPqQe
Could not find token account HJxCQzVQFjjcSaz2BYMqGJzDWAYUXT1oLgNokmSL45Ke```
When I try to query one token account, why does it give me an error on the other one?
Makes sense
I think life is 100x easier if you do you tests without an explicit validator running
And does some magic ("genesis block" stuff) to get your program in there without explicitly deploying it
anchor test will check if you've already got one running, and if so, use it; otherwise it spins one up for you
I essentially never run my own local validator/always let anchor spin it up for me
What are cases when you should run `solana-test-validator` in the background, and when you should not? More specifically, when you do `anchor test` what exactly is it running?
wow that worked... hmm
What if you don't run a test validator in the background at all, and just let anchor spin it up for you?
I did that, restarted `solana-test-validator` but still getting  `Error: failed to send transaction: Transaction simulation failed: Attempt to load a program that does not exist`
In your Anchor.toml
Think you can do this: https://discord.com/channels/889577356681945098/889702325231427584/943483106852212766
Sort of‚Äîthe account still has to get passed in from the client, but now anchor can do it for you automagically
how did you deploy this on local net?
hey just looking at your response here. Regarding the not needing to pass in the PDA on the client side, does that mean we derive the PDA account in the program, but don't pass any account in when we are calling that function on the client side>
How do you handle arrays of accounts in Anchor. I am trying to modify the escrow program to exchange multiple NFTs (2v2, 2v3, etc...). Any examples?
Could you please check?
His nick is thewuh#7483
Doesn‚Äôt get through verification
Hey there, a developer I am talking to right now has issues joining the anchor discord server
https://discord.com/channels/889577356681945098/889577399308656662/944335211506855956 this may help
Also I get this only with the javacript client, I tried making it via the python client, and it did not throw any errors. Is this is a permissions issue ? 
Or say the validator node is accessible at localhost but not at the 0.0.0.0 which javascript it trying to access ?
how to unsubscribe ?
```    program.account.pool.subscribe(pool.publicKey).on("change", state => {
                poolState = state;
                console.log("asd")
            })```
Hi started trying out the tutorial on anchor-framework, 
been getting this error 
```
ANCHOR_WALLET=/Userspath/.config/solana/id.json  node client.js                           

Running client.
/Userspath/Desktop/rust-stuff/solana-work/anchor/examples/tutorial/node_modules/@solana/web3.js/lib/index.cjs.js:5965
      throw new Error('failed to get recent blockhash: ' + e);
            ^

Error: failed to get recent blockhash: FetchError: request to http://localhost:8899/ failed, reason: connect ECONNREFUSED ::1:8899
    at Connection.getRecentBlockhash (/Users/ /Desktop/rust-stuff/solana-work/anchor/examples/tutorial/node_modules/@solana/web3.js/lib/index.cjs.js:5965:13)
    at processTicksAndRejections (node:internal/process/task_queues:96:5)
    at async Provider.send (/Users/ /Desktop/rust-stuff/solana-work/anchor/examples/tutorial/node_modules/@project-serum/anchor/dist/cjs/provider.js:82:31)
    at async Object.rpc [as initialize] (/Users/ /Desktop/rust-stuff/solana-work/anchor/examples/tutorial/node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:31:31)
    at async main (/Users/ /Desktop/rust-stuff/solana-work/anchor/examples/tutorial/basic-0/client.js:24:3)
```
Have solana validator running and 
On making wget http://localhost:8899 I do get a 405 response, which means the port is in use, but for some reason my program cant access it.
built one instead üôÇ let me know if you still need help on it happy to talk you through the program
yea like a similar test shows up fine if i try to do it in a blank new anchor repo
it seems like some config is off in my main repo but i'm not sure what it is
Mm, not sure, I would have expected the passing test to show up in `.anchor/program-logs`
and this is program logs output
lib rs
```rs
#[program]
pub mod dominari_anchor {
    use super::*;


    // Any player can initalize a space, which will have a blank feature, in any neighborhood
        // Requires (Nx,Ny) (Lx,Ly)
    pub fn init_location(ctx: Context<InitLocation>, loc:Coords) -> ProgramResult {

        msg!("{:?}", loc.nx.to_be_bytes());

        let location = &mut ctx.accounts.location;
        location.initalizer = ctx.accounts.initalizer.key();
        location.coords = loc;
        location.feature = Feature::None;
        
        Ok(())
    }

    pub fn debug(ctx: Context<Debug>, loc:Coords) -> ProgramResult {
        msg!("{:?}", loc.nx.to_be_bytes());
        Ok(())
    }
}
```
running two tests:
```ts
  it('Any player can initalize a space', async () => {
    //console.log(apollo_keypair.publicKey.toString());
    const coords = {
      nx: new anchor.BN(0),
      ny: new anchor.BN(-1),
      x: new anchor.BN(2),
      y: new anchor.BN(-178)
    }
    const [loc_address, loc_bump] = findProgramAddressSync([coords.nx.toArrayLike(Buffer, "be", 4), coords.ny.toArrayLike(Buffer, "be", 4), coords.x.toArrayLike(Buffer, "be", 4), coords.y.toArrayLike(Buffer, "be", 4)], dominari.programId)

    await dominari.methods
      .initLocation(coords)
      .accounts({
        location: loc_address,
        initializer: apollo_keypair.publicKey
      })
      .rpc();

    console.log(await dominari.account.location.fetch(loc_address));
  });

  // Configure the client to use the local cluster.
  //anchor.setProvider(anchor.Provider.env());
  //const program = anchor.workspace.DominariAnchor as Program<DominariAnchor>;
  
  it('Debug', async () => {
    const coords = {
      nx: new anchor.BN(0),
      ny: new anchor.BN(-1),
      x: new anchor.BN(2),
      y: new anchor.BN(-178)
    }
    console.log(coords.nx.toArrayLike(Buffer, "be", 8));
    console.log(coords.nx.toBuffer("be", 8));
    await dominari.methods.debug(coords);
    
  })
```

Can you show the full output of anchor test?
i did anchor test and it just says "streaming logs" but no actual logs
yea it's empty
Try looking in `.anchor/program-logs`
and this one üôè pls
reasking for help with this issue
This will apparently change in the next solana release, but not sure when that will happen
Currently you only have one shot to allocate the right amount of space for an account
I want to work with vectors. First i don't have any items in it, so i do not need to allocate space for it. But after each add i need to send a transaction + allocate more space, right?
Not sure what you mean, those seeds basically do just what it looks like they'd do (and they eventually all get chucked into a sha256 hash)
thats awesome, ty
there's also program logs in `.anchor/program-logs` directory in your anchor project
there's probably other ways but I do it with `solana logs -u localhost`
hey, how can i check outputs from the msg!() in my anchor program (on localnet)
thx! üôÇ
here's a good starting point https://docs.solana.com/developing/clients/javascript-reference#transaction
maybe you can get the correct size by serializing it and then measuring it's size `let rawTransaction = manualTransaction.serialize();`
Yes I am trying to call another library crate.
or is there a helper function or so to do so?
any idea how I can do that? would i have to take the bytecode and measure the length of this?
I believe you will have to measure this from the client side because the tx size limitation comes from the MTU size when sending the tx from the client to the network.
are you trying to use some library crate or do a cpi call? This is how you do a cpi call  https://project-serum.github.io/anchor/tutorials/tutorial-3.html#defining-a-puppet-program
and how to use that program? cpi?
is there any way to get the size of a `Transaction` object? 
I'm trying to understand how much I can squeeze in, and would be nice to know this without actually running it, but rather by printing
the same way you would in any other rust code
How are you generating random numbers? Isn't the runtime fully deterministic?
Most likely. Theres usually a more@detailed error log, do u have that as well? But yh usually seeds incorrect
Hi , I am using $ anchor test  to communicate with solana-test-validator process . it running inside the container. When I running the comand a new zombi process was created  [solana] <defunct> . the anchor test --skip-local-validator command , not try to run a new right ? Any advice or comments is welcome
How to call and use external crate in anchor program? I am confused
(using anchor test)
trying to print to logs but the logs show up empty, any advice?
```rs
    pub fn debug(ctx: Context<Debug>, loc:Coords) -> ProgramResult {
        msg!("{:?}", loc.nx.to_be_bytes());
        Ok(())
    }
```
anybody have any good resources on how constraints work and how to implement them properly?
VRF in mainnet but static locally
Any tips on mocking an on chain function for testing? I have a function which generates random numbers but I want to be able to return specific numbers in my tests
Hi folks! Is there anyway to pass individually unique parameters to seeds. Like
`seeds = [b"create_user", author.key().as_ref(), username.as_bytes()]`
i want both `author.key().as_ref()` and `username.as_bytes()` to be unique individually rather than unique in a combination..?
is there a way to use different variables depending on which network a program is deployed to
It pushes into the ix array
What is a good source/example for creating mints and tokens in Rust or Typescript (not the spl cli)?
Running into a "[PDA Account Address]'signer privilege escalated"
```
Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account 
    Program FJ9B9iLoqpTyAcx4yWkkkEgo4x7WbgV5KP2kBLVSpnKs invoke [1]
    Program log: Instruction: InitLocation
    p5y4wSfV8DehotkmvrGdNMuYkdakkfQQgjx9eHRPGpA's signer privilege escalated
    Program FJ9B9iLoqpTyAcx4yWkkkEgo4x7WbgV5KP2kBLVSpnKs consumed 7300 of 200000 compute units
    Program FJ9B9iLoqpTyAcx4yWkkkEgo4x7WbgV5KP2kBLVSpnKs failed: Cross-program invocation with unauthorized signer or writable account
```
my code: 
```rs
use anchor_lang::prelude::*;
use crate::account::*;
use crate::state::*;

#[derive(Accounts)]
#[instruction(loc: Coords, _loc_bmp:u8)]
pub struct InitLocation<'info>{
    #[account(
        init,
        //(Nx, Ny) (Lx, Ly)
        seeds=[loc.nx.to_be_bytes().as_ref(), loc.ny.to_be_bytes().as_ref(), loc.x.to_be_bytes().as_ref(), loc.y.to_be_bytes().as_ref()],
        bump=_loc_bmp,
        payer=initalizer,
        space=8+1024
    )]
    pub location: Account<'info, Location>,
    pub initalizer: Signer<'info>,
    pub system_program: Program<'info, System>
}
```
```rs
    pub fn init_location(ctx: Context<InitLocation>, coords:Coords, _loc_bmp:u8) -> ProgramResult {
        
        let mut loc = &mut ctx.accounts.location;
        loc.initalizer = ctx.accounts.initalizer.key();
        loc.coords = coords;
        loc.feature = Feature::None;
        
        Ok(())
    }
```
Does a `rror: 146: A seeds constraint was violated` error mean that the incorrect seeds were provided in a cpi call?
did u ever find a contract??
You mean the byte size of the transaction? I don't think that's happening any time soon (it depends on using QUIC as far as I understand)
also how much additional program-instruction-space is solana 1.9 going to introduce?
yeah was indeed some manual signTransaction functions I oversaw. thanks a lot for the help again! üôÇ
i think I will need to do some major refactoring soon too lol.
just switched to that, thx!
This is easier if you use `program.provider.send`, which makes sure to sign with the provider.wallet
Ah! Yeah, don't say signTransaction multiple times
yeah i think this is the case, I seem to get less clicks now that I removed some of these signTransaction
also, thx! üôÇ
yeah makes sense. perhaps there is some redundant "signTransaction" somewhere hidden ...
I would just quadruple verify that you're actually building a single Transaction object
and if i still have it i'll try to make a github link or so
let me try to debug for a bit, maybe it's some stupid bug
hmm, that's gonna be painful xD
That definitely seems wrong to me
or im doing something funky..
Can you post more of your code?
hmm weird, I'm getting a `Error: Transaction too large: 1476 > 1232`, but only after I have clicked "approve" after about 8 times (instead of the 18). so it seems like it is chaining them together, but it's asking for a new approval each time..
But I didn't realize you might need to issue multiple approvals
Well, they're still all part of a single transaction‚Äîso the whole transaction succeeds or fails
have you confirmed this actually? Intuitively, this is what I would assume it would be doing. if not, it would seem kinda pointless to chain them together..
Ok, yeah, just concatenates the instructions
that's what I would assume
I would use TransactionInstruction
Hmm, had never noticed you could `.add` a Transaction (what does it do? just smoosh all the instructions together?)
when you say instructions are these types ok? `Transaction` or `TransactionInstruction`. I realize `tx.add()` takes as input one of these two types (and more, actually..)
hmmm, I would very much hope that to be the case üòÖ üòÖ üòÖ  I have to click approve 18 times loll
You should have one Transaction that you then add a bunch of individual instructions to
ix1 can be of type `Transaction` or `TransactionInstruction`
Actually now that I think about it I guess I could be wrong‚ÄîI figured that would only trigger one approval, but not sure I've actually tested that ü§î
yeah
So you're calling `tx.add(ix1)`, `tx.add(ix2)` etc.?
hmm, i tried to do that. basically, I for each of the instructions, I call 
``` 
let ix = solbondProgram.instruction.function1
``` 
and then I bundle these together in one transaction
``` 
let tx = new Transaction();
tx.add(ix)
``` 

is there anything else I'm missing?
Yeah, by bundling all of the instructions into a single transaction
but now, i have to click "approve" for every individual instruction in this transaction. is it possible to click approve once, for all instruction?
You can also do `program.provider.send(theTx)` if you want to automatically sign with the provider wallet
turns out I was missing this line (manually sign the transaction..)
`        await qPoolContext.userAccount!.signTransaction(tx0);`
what are the things I need to look out for when going from `program.rpc` to `program.instruction` ? 

So far, for the `program.instruction` instructions, I am adding a `recentBlockhash` and a `feePayer`. I have arrived at the following set of instructions

``` 
const blockhash = await qPoolContext.connection!.getRecentBlockhash();
        console.log("Added blockhash");
        tx0.recentBlockhash = blockhash.blockhash;
        tx0.feePayer = qPoolContext.userAccount!.publicKey;
        let sg0 = await qPoolContext.connection!.sendRawTransaction(tx0.serialize());
        console.log("sg0 is: ", sg0);
        await qPoolContext.connection!.confirmTransaction(sg0, 'confirmed');
``` 

However, when I run this set of instructions, I am getting a `Error: Signature verification failed`. Is there anything else I need to add?
is it possible to use `#[account(zero_copy)]` with a type that unsafely impls `Pod` but not `Copy` -- i think that's the only reason for  the `Copy` constraint right?

it seems because `ZeroCopy` explicitly requires types be `Copy` (in addition to `Pod`), i can't circumvent the `Copy` constraint

`pub trait ZeroCopy: Discriminator + Copy + Clone + Zeroable + Pod { }`

```rust
#[automatically_derived]
unsafe impl #impl_gen anchor_lang::__private::bytemuck::Pod for #account_name #type_gen #where_clause {}
#[automatically_derived]
unsafe impl #impl_gen anchor_lang::__private::bytemuck::Zeroable for #account_name #type_gen #where_clause {}

#[automatically_derived]
impl #impl_gen anchor_lang::ZeroCopy for #account_name #type_gen #where_clause {}
```
<@!134416332509675520> thank you helping me with my stupid question
Sorry i forgot to multiply by `LAMPORTS_PER_SOL`
Ahhhh let me check something
How many lamports are you transferring? What is `transferToPlayerAmount` here?
Thank you!!
Wow you're awesome! That was it! üòÄ
Balance of `house` and  `player`  do not change and there are no error throw by the transaction
I've a question related to transferring balance from the program I've deployed to a PDA the program owns. I see no error but the balance has not changed.

```rust
pub fn transfer_balance_to_player(ctx: Context<TransferBalanceToPlayer>, amount: u64) -> Result<()> {
    let fund_payer = &mut ctx.accounts.house;
    let fund_payer_account = fund_payer.to_account_info();
    let payer_balance = fund_payer_account.lamports();
    let rent_exemption = Rent::get()?.minimum_balance(fund_payer_account.data_len());

    // We check if we have enough funds
    if payer_balance - rent_exemption < amount {
         msg!("Insufficent balance");
        return Err(HouseError::InsufficientFunds.into());
    }

    let fund_receiver = ctx.accounts.player.to_account_info();

    // Transfer balance
    **fund_payer_account.try_borrow_mut_lamports()? -= amount;
    **fund_receiver.try_borrow_mut_lamports()? += amount;
    Ok(())
}

#[derive(Accounts)]
#[instruction(amount: u64)]
pub struct TransferBalanceToPlayer<'info> {
    #[account(mut)]
    player: Account<'info, Player>,
    #[account(mut)]
    house: Signer<'info>,
}
```

```typescript
await program.rpc.transferBalanceToPlayer(
    new anchor.BN(transferToPlayerAmount), {
        accounts: {
            house: houseAccount.publicKey,
            player: randomPlayer
        },
        signers: [houseAccount]
    }
);
```
an error of `    "3H7FCK94N9qWpnAYWHLKakVgek9Z1qqEo3cZULhtrFnz's writable privilege escalated` means that an account needs to be marked as mutable that currently isn't right?
Ah, funny, I totally forgot about that option, cool!
yea, that seems to give me more stack space
you can wrap code logic in brackets {} so its garbage collected and removed from the stack
What do you mean?
I can also start using context brackets, right {}?
You can try various tricks to get around this (Box is one, but won't help here). One idea is to wrap up a bit of your code behind a helper function + invoke the helper function in your instruction hander (the helper function gets a fresh 4kb of stack space).
Yes, that means you've run out of stack space (solana's stack frames are quite tiny, only 4kb)
Is there a general reason for access violation errors?
Getting an access violation error

If I remove a block of code at the end of my program, then the program runs successfully, otherwise, the program does not run.
Did you mark the account as `#[account(mut)]`?
In a NFT collection, you have many different accounts. They are each an SPL Token with a supply of 1. The "mint" is the program that distributes each of the NFT editions. Are you saying the PDA holds a metaplex metadata account for each account in the entire NFT collection?

update: so it looks like with each NFT collection, each individual NFT (part of the collection) has a unique mint. In that case, there'd also be a unique PDA
What information does a Anchor need to verify a PDA account to close the account?
I'm trying to close accounts and get the following error "failed to verify account
: instruction changed the balance of a read-only account"
What does it take to verify a PDA account?
only the program that owns the PDA can sign on its behalf
üëã Have a question about PDAs. In the following code snippet,

```
const keypair = anchor.web3.Keypair.generate();
const [keypairSigner, nonce] =
  await anchor.web3.PublicKey.findProgramAddress(
    [keypair.publicKey.toBuffer()],
    program.programId
  );
```

Isn't the PDA something that anyone with your public key and nonce can get? If so, doesn't this pose a vulnerability as far as PDAs are used for signing on behalf of the original program?
But basically, the metadata account lives at a PDA derived from the NFT (the mint)
Can see some docs here: https://github.com/metaplex-foundation/metaplex-program-library/tree/master/token-metadata/program
```
type IdlAccounts<TProgram extends Idl> = Program<TProgram>['account'];
type FetchType<TProgram extends Idl, T extends keyof IdlAccounts<TProgram>> = Awaited<ReturnType<IdlAccounts<TProgram>[T]['fetch']>>;
type ElementType<T> = T extends Array<infer E> ? E : never;
type Accounts<TProgram extends Idl> = ElementType<IdlAccounts<TProgram>>;
type AccountDefinition<TProgram extends Idl, T extends keyof IdlAccounts<TProgram>> = Extract<Accounts<TProgram>, { name: T, type: { fields: Array<{ name: unknown }> } }>;
type Fields<TProgram extends Idl, T extends keyof IdlAccounts<TProgram>> = ElementType<AccountDefinition<TProgram, T>['type']['fields']>['name'];
type PickAccountType<TProgram extends Idl, T extends keyof IdlAccounts<TProgram>> = Pick<FetchType<TProgram, T>, Fields<TProgram, T>>;

type GameAccount = PickAccountType<MyProgram, 'gameAccount'>;
```
That took quite a bit of hunting, but there you go
How are these different accounts tied together?
So, to incorporate that additional metaplex information, you're going to need to pass in an additional account, the token metadata account (and possible others, I'm not super familiar with metaplex‚Äîat any rate, annoyingly the information you need doesn't all live in one account)
And just to be clear, anchor itself doesn't wrap spl token accounts actually‚Äîthey're still just spl token accounts
Yeah, all of that extra stuff is handled by metaplex (in a separate account)
> So I think the reason you might be getting confused is bc nfts are actually just spl-tokens that have been minted only once the had mint disabled. 

The other question I have here is how that metadata is incorporated. In code, we have `anchor_spl::token::TokenAccount` which acts as a wrapper for SPL token accounts right?

Where is the image, metadata, etc. stored when you serialize it into `TokenAccount`? Or is it that the NFT Account has these additional fields but can be serialized/deserialized into the SPL Token object since it's a strict superset (e.g. NFTs have everything that SPL tokens have but some additional metadata params)
You can treat them like any other spl
We‚Äôll that‚Äôs the cool part! Because nfts ARE spl tokens they don‚Äôt <:bagsLove:500156064507887618>
I'm pretty familiar with the SPL token library and how to incorporate that into the anchor library. The question I'm trying to answer is how my transfer, swap, etc. functions need to change if I'm dealing with an NFT instead of your regular SPL tokens
Unfortunately I don‚Äôt have any off the top of my head. What‚Äôs your use case?
There‚Äôs lots of spl token transfer examples

If you‚Äôre looking into making a different version of a minter like candymachine then the metaplex program library GitHub has all the rust/anchor source code in it which could also be helpful
Thanks for answering my nooby questions! Would you have any recs on good code repos/tutorials that utilize anchor and the metaplex metadata?
Actually no it‚Äôs from the spl-token program. You make a token with decimals zero, mint one, then disable mint all on that
Where is that restriction enforced? Guessing it's within the Metaplex Programming Library?
I just realized you both already talked about this sorry lmao
So I think the reason you might be getting confused is bc nfts are actually just spl-tokens that have been minted only once the had mint disabled. 

Aka 
USDC? Spl-Token
Sea Shanty NFT? Spl-Token

Same exact thing but usdc can keep minting more and the NFT can‚Äôt
Would you have any recs on good code repos/tutorials that utilize anchor and the metaplex metadata?
But there are unfortunately multiple separate accounts floating around under the hood
Yeah
Ah got it. So what you are saying is Solscan just has the metaplex metadata object integrated and is taking that into account when rendering what's displayed.
Since all this extra info isn't directly conveyed by the spl token program/accounts themselves (ugh).
At any rate, all the extra NFT-ness of an NFT in solana-land is conveyed by a whole separate account, the NFT's metaplex metadata account.
And people in solana just can't help themselves with overloading names lol‚Äîso I guess in a sense NFTs *do* have up*date* authorities, which is a totally different idea from a program's upgrade authority (ugh)
Ah, ok‚Äîsorry, I haven't used solscan much and it's aggregating a lot more info than the vanilla solana explorer uses
Nothing‚ÄîNFTs are just funny mints that only mint 1 token ever
Also, posted this up top, but:

> This makes sense. <@!134416332509675520> (pls post full program log) 's previous answer was that if an account has a Mint Authority and an Update Authority it needs to be a program. If you look at this NFT (https://solscan.io/token/CzymaSrMbe5PNvKqi1kJgpTjmD7Wz7iG4c6aCof1Qj6U) It clearly has the mint + program authority. So does this make it a program (executable account)?
> 
> The more broad question I'm asking is: just like how USDC and other fungible tokens follow the SPL token standard, is there an equivalent for NFTs on Solana?
What's the difference between an NFT mint vs. SPL Token mint?
Yep, programs are executable accounts, mints are just regular old non-executable accounts (owned by the spl token program, with a particular data format etc.)
So programs are executable accounts. Are mints another type of account? Feel free to just point me to documentation here üòõ
(Which aren't programs üòõ)
No, NFTs are mints
is there anything you're trying to do specifically? in general i'd say going through Metaplex's candy machine source is probably the best way, although not simple
are there any anchor/metaplex programs you'd recommend reading through? can't seem to find any good tutorials/resources
NFTs rn use Metaplex's token standard
https://docs.metaplex.com/token-metadata/specification


//////////////////////////////////////////////////////////////////////////////////////////

<:rofl_brokenteeth:909587507841204264>
the `declare_id!` doesn't match the deployed program address
lol im stupid
i have a feeling theres something wrong with the programId in the deployment (hence why `The given account is owned by a different program than expected` so I'm trying to redeploy with the right Anchor.toml config) üòÑ
oh that would be a yes
when you are trying to deploy on devnet with `anchor deploy` do you need to set the `cluster` under `[provider]` to `devnet`?
(btw feel free to help or not, I just like to publicly log all my issues so that if anyone else stumbles upon it they can search for solutions i.e. sorry for the spam)
<:thinkcat:837225078877716511>
```
bundle.js:59377 Uncaught (in promise) Error: 3007: The given account is owned by a different program than expected
```
```
bundle.js:37517 Transaction simulation failed: Error processing Instruction 4: custom program error: 0xbbf 
    Program 11111111111111111111111111111111 invoke [1]
    Program 11111111111111111111111111111111 success
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [1]
    Program log: Instruction: InitializeMint
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 2457 of 200000 compute units
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success
    Program 11111111111111111111111111111111 invoke [1]
    Program 11111111111111111111111111111111 success
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [1]
    Program log: Instruction: InitializeMint
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 2457 of 200000 compute units
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success
    Program 7B7ah6bTeycAtj1BihRuRUcDi1q4NJKCGChbV5PTfnMC invoke [1]
    Program log: Instruction: Initialize
    Program 11111111111111111111111111111111 invoke [2]
    Program 11111111111111111111111111111111 success
    Program log: Custom program error: 0xbbf
    Program 7B7ah6bTeycAtj1BihRuRUcDi1q4NJKCGChbV5PTfnMC consumed 10613 of 200000 compute units
    Program 7B7ah6bTeycAtj1BihRuRUcDi1q4NJKCGChbV5PTfnMC failed: custom program error: 0xbbf
```
<:KEK:850127013611569223>
```
bundle.js:59377 Uncaught (in promise) Error: 3007: The given account is owned by a different program than expected
```
okay added this:
`signers: [mintA, mintB],`
Yeah, I think that's your problem
O_O
do we have to include the mints as the signers?
oh wait...
<:thinkcat:837225078877716511>
but all the authorities are the current wallet
```js
                instructions: [
                    web3.SystemProgram.createAccount({
                        fromPubkey: this.wallet.publicKey,
                        newAccountPubkey: mintA.publicKey,
                        space: MintLayout.span,
                        lamports: rent,
                        programId: TOKEN_PROGRAM_ID,
                    }),
                    Token.createInitMintInstruction(
                        TOKEN_PROGRAM_ID,
                        mintA.publicKey,
                        9,
                        this.wallet.publicKey,
                        this.wallet.publicKey
                    ),
                    web3.SystemProgram.createAccount({
                        fromPubkey: this.wallet.publicKey,
                        newAccountPubkey: mintB.publicKey,
                        space: MintLayout.span,
                        lamports: rent,
                        programId: TOKEN_PROGRAM_ID,
                    }),
                    Token.createInitMintInstruction(
                        TOKEN_PROGRAM_ID,
                        mintB.publicKey,
                        9,
                        this.wallet.publicKey,
                        this.wallet.publicKey
                    ),
                ]
```
so i added instructions to my rpc call, and now it's failing on client side with `Signature verification failed`
https://programming-idioms.org/idiom/12/check-if-list-contains-a-value/414/rust
<:Shrug:856158473745727528>
so your constraint would be `list_of_mints.contains(mint.key)`
I mean, I'm *assuming* you could make a list and just use contains
Do you know if there is a good way to do this with a list of mints? eg. allow the user to pass one of [mintA, mintB, mintC] as y_token?
this fixed it
```js
        // Generate the provider and program for Anchor.
        this.provider = new Provider(this.connection, this.wallet, {
            preflightCommitment: "recent",
        });
```
the issue was I didn't define a preFlightCommitment opt when generating the provider
oh nvm i guess you didn't need to fetchIdl, because i was using local idl
ive installed anchor in the https://github.com/metaspan/solana-docker-mac-m1 Dockerfile so im guessing its an ubuntu thing. Would you have a better suggestion for using anchor with the solana-docker-mac-m1 Dockerfile?
<:worriedcry:615396682154377216>
i never used `anchor idl init`
lol
I'm wondering if something is wrong with my idl
hi all, getting this when trying to run an rpc call in js on anchor:
```
bundle.js:59377 Uncaught (in promise) TypeError: Cannot read properties of undefined (reading 'preflightCommitment')
```
Mm, why are you using qemu?
hi guys, im getting the error 
```qemu-x86_64: Could not open '/lib64/ld-linux-x86-64.so.2': No such file or directory```
when trying to run `anchor build` and `anchor test` on a Mac M1. does anyone know of a workaround for this? Thanks!
You can't opt out of account discriminators‚Äî`#[account(zero)]` just says the discriminator hasn't been set *yet*
What are the disadvantages to opting out of a discriminator with zero accounts? We need to optimize a couple program accounts for cost but don't fully understand the tradeoffs.
Hello, is there any RPC endpoint which fetches all of specific NFT address's transaction history?
What I want to achieve is to fetch specific NFT's previous owner.
Hey! What exactly is a slot? Does that represents one *transaction*? Or does it represent one *instruction* within a transaction?
ty!
You can check step finance repo. https://github.com/step-finance/step-staking
Any OS examples of staking spl tokens?
Love to help! And Congratulations!
I am trying to create a token account using the initialize_account function in in anchor_spl

 anchor_spl::token::initialize_account(CpiContext::new(
                self.token_program.to_account_info(),
                anchor_spl::token::InitializeAccount {
                    account: self.pool_token_account_1.to_account_info(),
                    authority: self.authority.to_account_info(),
                    mint: self.token_1.to_account_info(),
                    rent: self.rent.to_account_info(),
                },
    ))?;


I am passing my accounts like this in the account structure

 #[derive(Accounts)]
pub struct GetPair<'info> {
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
    #[account(mut)]
    pub token_1: AccountInfo<'info>,
    #[account(mut)]
    pub token_2: AccountInfo<'info>,
    #[account(mut)]
    pub authority: AccountInfo<'info>,
    #[account(mut)]
    pub pool_token_account_1: AccountInfo<'info>,
    #[account(mut)]
    pub pool_token_account_2: AccountInfo<'info>,
    pub token_program: Program<'info, Token>,
    pub rent: Sysvar<'info, Rent>,
}

ERROR : 'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA failed: invalid account data for instruction',
Hey guys! I have maybe strange question, but maybe someone could help me with this. So I want to have for example 2 contracts (A and B) with exact same instruction name and exact same arguments and accounts (`A::foo(ctx: Context<...>, amount: u64)` and `B::foo(ctx: Context<...>, amount: u64)`). And I want to call `foo` in third contract C instruction `C::callFooFromAorB(ctx<...>)` using CPI, like in pure Solana `invoke( &Instruction { program_id: A_or_B_Program_Id, accounts: cpi_accounts,  data: A_or_B::foo(amount), },...)` and I do not know how to do this with anchor instructions as on anchor we have `sighash` not an enum for instructions like in pure Solana. Is there some example how to do this in anchor? Not sure if I explain it correctly! Thanks in advance!

P.S. The trick that I try to achieve similar to implementation of instruction `ReceiveFlashLoan` in SPL `flash_loan_receiver`.
there is something like try_deserialize but I dont know how it works
I want to unpack the mint account to get the mint authority? how do I do it in Rust
Thx so much, it works! I added 10 sol more in case
I'm trying to understand the Solana helloworld-program I stucc uwu
What does it usually mean wen rpc send this bacc ```{'jsonrpc': '2.0', 'error': {'code': -32602, 'message': 'io error: failed to fill whole buffer'}, 'id': 1}```
Frens I'm sorry if this is too beginner, I'm literally baby level solana skillz
correct
ah I see - so it'll almost always be safer and easier to use the former then, thanks!
the former does a little more. it also checks that the token account is the associated token account of the given authority and mint
is the account constraint `associated_token::authority = signer` equivalent to `constraint = token_account.owner == signer.key()` , or am I missing something?
<@!848333406849073202> Thanks for the advice I'll try it
maybe try `anchor test ./tests/dao.test.ts`
i set up testing of multiple programs using npm scripts, i.e. `"test::init": "anchor test ./tests/init.ts"`
if you want an instruction you can use `await program.instruction.swap`
Hello, inside my anchor dir I've multiple program
```
‚îú‚îÄ‚îÄ programs
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ dao
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ tutorial
‚îú‚îÄ‚îÄ tests
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ dao.test.ts
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ tutorial.test.ts
‚îú‚îÄ‚îÄ Anchor.toml
```

Then I've done the following inside my Anchor.toml
```toml
[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"
test-dao = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/dao.test.ts"
test-tutorial = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/tutorial.test.ts"
```
But I cannot run `anchor test-dao`
Is there a way to run test only for one program?
Disclaimer: I know nothing about on-chain development on Solana so bear with me
Figures
like Balances dict in an ERC20 contract
how else do we go by doing it using accounts
i understand we need to provided a size for it in deserializing and stuff
use BTreeMap or HashMap or something
can we implemend dictionaries in solana
bros
the whole point of anchor is to avoid such horrid pain.
you will have to compute the signhash of swap and encode manually parameters
running anchor test results in "Error: Error loading workspace IDL for account" , but the ./target/idl/[name].json file exists. 
any pointers why this is happening?
I'm just not sure how to handle the `data` when your anchor instruction has multiple arguments
instead of
```js
    // Create the new account and initialize it with the program.
    const tx = await program.rpc.swap({
      accounts: {
        state: statePubkey,
        signer: provider.wallet.publicKey,
        tokenProgram: TOKEN_PROGRAM_ID,
        xTokenAccount: userAssociatedTokenAccount.address,
        yTokenAccount: userNewTokenAccount.address,
        xTokenMint: TOKEN_A_MINT.publicKey,
        yTokenMint: TOKEN_B_MINT.publicKey,
        yPool: associatedOutgoingAccount,
        cpiAuthority: cpiAuthorityPubkey
      }
    });
```
i'd like to use
```js
export const createSwapInstruction = async (signer, userAtaA, userAtaB) => {
  const data = buffer.Buffer.alloc(0);
  let keys = [{
    pubkey: PHASE_STATE_ACCOUNT,
    isSigner: false,
    isWritable: true
  }, {
    pubkey: signer,
    isSigner: true,
    isWritable: true
  }, {
    pubkey: TOKEN_PROGRAM_ID,
    isSigner: false,
    isWritable: false
  }, {
    pubkey: userAtaA,
    isSigner: false,
    isWritable: true
  }, {
    pubkey: userAtaB,
    isSigner: false,
    isWritable: true
  }, {
    pubkey: ROPE_TOKEN_MINT,
    isSigner: false,
    isWritable: false
  }, {
    pubkey: PHASE_TOKEN_MINT,
    isSigner: false,
    isWritable: false
  }, {
    pubkey: PHASE_POOL_ACCOUNT,
    isSigner: false,
    isWritable: false
  }, {
    pubkey: PHASE_AUTHORITY_ACCOUNT,
    isSigner: false,
    isWritable: false
  }];
  return new TransactionInstruction({
    keys,
    programId: SWAP_PROGRAM_ID,
    data
  });
}
```
for example
if I'd rather not use `Anchor`
does anyone know what the equivalent method is to create an instruction to interact with your program?
<@!164924128065748993>
Serum hackathon ü§î
shoutout to <@!134416332509675520>  for teaching me like all of anchor, and paulx's help too
+1 to this
you guys are the knights in shining armour üòÑ
we'll try this then
thanks a lot
nvmnvmnvm i just read the message. Yes you would need to reserialize if its not an accepted type
https://github.com/project-serum/anchor/blob/master/spl/src/dex.rs ware you using this
the serum library in the anchor spl works fine for me
And deserialize them in your program (using serde)
Otherwise you could of course pass the dex instruction as serialized bytes (like, a Vec of bytes I guess)
Anchor expects instruction arguments to use borsh; that's just the way it is.
The workaround you mention is the way I would do it
we are in the hackathon and not getting any response from the serum team
it's very urgent
Please don't at-message for non-urgent questions üôè
Hi <@!501570363566587905> <@!448034961652449283> <@!831450660146642974> <@!867369388608061470> <@!117243115676499972> could you please help with this issue:

> i have a question about an error i'm getting, "the trait bound `serum_dex::instruction::NewOrderInstructionV3: anchor_lang::AnchorSerialize` is not satisfied"
> 
> i'm getting this error because i'm attempting to have an argument which has the type serum_dex::instruction::NewOrderInstructionV3, but it looks like serum uses serde for de/serialization, and anchor expects borsh. in the past, i've kind of gotten around this by declaring a custom type that derives borsh de/serialize, and having a custom function to convert it to the serum type before using it in CPI calls to serum or mango, but i was wondering if there's a better way to do this?
Anyone else see this sometimes happen on  long test-suite runs?  
```
Error: Unable to obtain a new blockhash after 10068ms
      at Connection._pollNewBlockhash (node_modules/@solana/web3.js/src/connection.ts:3549:13)
      at Connection._recentBlockhash (node_modules/@solana/web3.js/src/connection.ts:3522:12)
      at Connection.sendTransaction (node_modules/@solana/web3.js/src/connection.ts:3665:39)
      at Object.sendAndConfirmTransaction (node_modules/@solana/web3.js/src/util/send-and-confirm-transaction.ts:29:21)
      at transferLamports (client/utils.ts:82:23)
      at Context.<anonymous> (tests/account.test.ts:79:9)

```
How could this be accomplished? Is this a use case for vaults?
thanks for the clarity boss
Correct. The PDA is derived from the initiating program, so a different program won't be able to sign for it
```
pub struct Burn<'info> {
    pub mint: AccountInfo<'info>,
    pub to: AccountInfo<'info>,
    pub authority: AccountInfo<'info>,
}
```
We're attempting to burn a token, but the authority is a PDA that our signer has authority over. We tried to use signer seeds here to burn but it didn't work. Is the issue here that this PDA account is initialized in a different program so we can't use it to sign?
Cool, thanks.
Yep, try jumping to source on AccountInfo‚Äîit doesn't directly store the lamports, it stores a reference to them
Wow.  I'm an idiot.  How is that working?  is there some ref sharing underneath the covers?
```
  transfer_from_account_we_own(
            &mut platform_payee.to_account_info(),
            &mut platform_withdrawer.to_account_info(),
            amount,
        )?;
```
That should be fine
Does using a cloned copy fail?
I've got that part - I can't find any method that doesn't result in a cloned copy of the `AccountInfo`   `to_account_info` appears to be a copy
```
let platform_payee = &mut ctx.accounts.platform_payee;
transfer_from_account_we_own(
            platform_payee.to_account_info(),
            platform_withdrawer,
            amount)

```
You just need to annotate its declaration in your `derive(Accounts)` block with `#[account(mut)]`
How can I get a mutable AccountInfo from the context?  I'm trying to transfer lamports from a non-sytem PDA as has been discussed here before:
```

fn transfer_from_account_we_own(
    src: &mut AccountInfo, // we better own this account though!
    dst: &mut AccountInfo,
    amount: u64,
) -> ProgramResult {
    // we can decrement the src account's lamports b/c we own it
    **src.try_borrow_mut_lamports()? = src
        .lamports()
        .checked_sub(amount)
        // or whatever, some error of your choosing
        .ok_or(ProgramError::InvalidArgument)?;
    // *incrementing* an account's lamports is always ok though
    **dst.try_borrow_mut_lamports()? = dst
        .lamports()
        .checked_add(amount)
        .ok_or(ProgramError::InvalidArgument)?;
    Ok(())
}
```
Well now we know! Thanks man!
It is very weird because on localhost this error never pop out
I finally find what was going wrong. This error AKA 2001 mean authority constraint was violated on the program
Awesome Thanks!
thanks, I will try
switchboard vrf https://github.com/switchboard-xyz/vrf_req_example
Anyone know the best way to get some sort of randomness in a program? I hesitate to try the rust rand library
Dope!
done <:dankfingers:581630874462978059>
But, it's just a thought
Maybe try something like this

```
let check_in = &mut ctx.accounts.checkin_account;

check_in.bump = checkin_account_bump;
check_in.token = token;
check_in.authority = ctx.accounts.authority.to_account_info().key;
check_in.audience = ctx.accounts.audience_account.to_account_info().key;
check_in.register_count += 1;

Ok(())
```
every tests pass
but it is very weird as it work fine on localhost
ok i will try it
I'm predominately from C, and I'm still learning rust. However, dereferencing  this `*ctx.accounts.authority.to_account_info().key`  and this `*ctx.accounts.audience_account.to_account_info().key;` seem suspicious; 

try this? Try taking out those `*` at the beginning
same for me, no result in google
No idea - I checked a couple of places - nada
if you can tell me what 0x7d1 error mean I  guess I can figure it out by my own
it works fine on localhost
```
   pub fn register(ctx: Context<Register>, checkin_account_bump: u8, token: String) -> ProgramResult {
        ctx.accounts.checkin_account.bump = checkin_account_bump;
        ctx.accounts.checkin_account.token = token;
        ctx.accounts.checkin_account.authority = *ctx.accounts.authority.to_account_info().key;
        ctx.accounts.checkin_account.audience = *ctx.accounts.audience_account.to_account_info().key;
        ctx.accounts.audience_account.register_count += 1;

        Ok(())
    }
```
Post the function that threw this
```index.js:1 Transaction simulation failed: Error processing Instruction 0: custom program error: 0x7d1 
    Program AAewkvZ3G72Mrtbsv5aMoZBNmsAx1U2aAswsQaj8nR3C invoke [1]
    Program log: Instruction: Register
    Program 11111111111111111111111111111111 invoke [2]
    Program 11111111111111111111111111111111 success
    Program log: Custom program error: 0x7d1
    Program AAewkvZ3G72Mrtbsv5aMoZBNmsAx1U2aAswsQaj8nR3C consumed 16560 of 200000 compute units
    Program AAewkvZ3G72Mrtbsv5aMoZBNmsAx1U2aAswsQaj8nR3C failed: custom program error: 0x7d1```
Post up the whole error message
Hi everyone. I'm having this error when testing my program on devnet: error: 0x7d1 . Anyone know what that mean?
Also, you should send me a friend request
I forgot to sign it :p All good!
i see you got the help you need but if you need help lemme know
yeah its in my program now
Thanks!
Yep!
And I take it the authority would be the TokenAccount's owner. Correct?
`to` here is really `from`‚Äîits the token account your burning tokens from
Ah, yeah, the `to` wording doesn't make sense (guess anchor should change this)
Has anyone burned a spl yet in a contract?
Below is the struct for the cpi context.

**mint:** I get this
**to:** Not really sure of this wording, i'm guessing this is the TokenAccount that we are burning from
**authority: **owner of **to:**?

Anyone know what's expected for **to:**?

https://docs.rs/anchor-spl/0.5.0/anchor_spl/token/struct.Burn.html

```
pub struct Burn<'info> {
    pub mint: AccountInfo<'info>,
    pub to: AccountInfo<'info>,
    pub authority: AccountInfo<'info>,
}
```
<:thinkcat:837225078877716511>
oh i guess you can't use it in this way because you need an authority
```
use anchor_spl::{
    associated_token::AssociatedToken,
    mint,
    token::{TokenAccount, Mint, Token}
};
```
using the given import example
when i try this it's telling me 
```
error[E0425]: cannot find value `mint` in module `associated_token`
```
hmm
```
#[account(
    associated_token::mint = mint,
    associated_token::authority = payer,
)]
pub second_token: Account<'info, TokenAccount>,
```
oh nvm i guess this works
i guess you need to use `init` though...
hmm
https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html
nvm found it
ok, understand, thx üôÇ
To do this on-chain the only way is to pass in the mint as an account
Oh I don't believe there's a way to do it on-chain
about web3js all easy üôÇ
nono, in rust program inside chain
you can use `getParsedAccountInfo`
are you talking about on web3js?
hmm, I need to ask about this TokenProgram?
```rust
    #[account(
        mut,
        constraint = token:mint = y_token_mint,
    )]
    pub y_pool: Account<'info, TokenAccount>,
```
anyone know how to use the accessors on `TokenAccount`? trying to make a mint constraint for a `TokenAccount` argument
Not directly no, the decimals are stored on the mint, not the token account itself
but if i have associated token account i can't get this info? (maybe not from anchor but from solana sdk)
You'll need to pass in its mint as an account + use `Account<'info, Mint>` etc. Then you can do `the_mint.decimals`
sorry guys for one more question, but i can't found in any docs in docs.rs. How i can get info about token by pubkey? i want to get decimal
Awesome that's what I was looking for! Thank you!
https://github.com/project-serum/anchor/blob/bbfaf9d7124838204a3838b6bcfdd81f1de4ea25/ts/src/provider.ts#L223
Have you tried jumping to source on Wallet?
Can do it within your program too
`return Err(ErrorCode::Hello.into());`
If you have an error you can return that too! https://project-serum.github.io/anchor/tutorials/tutorial-4.html
thx guys
-_-
`return Ok(());`
I guess I don't totally understand how providers work - any thoughts on getting another one (not from anchor.Provider.env()) in an anchor test? In the Provider constructor, I can't seem to find out what a Wallet Object is
and one small question, how i can finish program  not at the end of function? like return
In the `instructions:[]` param I pass it one of these after grabbing the ATA from `findAssociatedTokenAddress` 
```
serumCmn.createTokenAccountInstrs(
      provider, 
      ata, 
      ming, 
      owner
    );
```
When in doubt, clear it out! (If you can)
thanks
yeah
Don't think about it too much
lol, then just copy over your code
hmm this works lol
thanks. will try that then
I do it client-side
Just for a sanity check, try creating another project `anchor init test`
hey guys, a noob question - can smart contracts create the associated token account for user or does it have to be created outside of smart contract and then passed for token transfer?
probably
maybe i am running a newer anchor?
I'm surprised I haven't run into this myself, I get the same 1.56.0
going to try that
Mm, ok, I guess you could try rebuilding solana from source with a fresher rust?
Aha interesting
cargo +bpf --version returns 1.56.0
seems like it
Hmm, not sure. Is 1.56.0 the rust you used when you built solana or something?
All good! I just learned that today üòÑ
oh, thx, i'm stupid üòÑ
Yeah ^
your_token.mint
nono, about amount i know, what about for which token this tokenaccount?
Just `your_token_account.amount`
hehe, happens. Any idea whats happening here?
i thought anchor maybe has some constraint for account
Oh lol you already printed that üòõ Sorry
sorry, it's question or? üôÇ
cargo --version = 1.58.0
1.58.1
What does `rustc --version` say?
Like how can you check if a TokenAccount has a balance?
i updated solana and rust packages, still
running into this weird error

Got it! DENIED!
hello guys! How i can check that TokenAccount with definite mint?
Try accessing it!
so the provider.wallet.keypair is not the actual keypair? For the wallet?
Phantom will never ever give you the keypair itself, just the ability to ask phantom to sign a tx
Is there a safer way to sign clientside?
I have a security question, on the client-side I have something that needs to be signed. I get the Provider from Phantom. This gives me access to the Keypair? Is that safe?  Like, If I was malicious, I could just save the privatekey.

```
  const getProvider = () => {
    const connection = new Connection(network, opts.preflightCommitment);
    const provider = new Provider(
      connection, window.solana, opts.preflightCommitment,
    );
    return provider;
  }

        await program.rpc.buyCoffee(
          numToRust(solTolamports(0.1)),
          {
            accounts: {
              coffeeJar: coffeeJar.publicKey,
              from: provider.wallet.publicKey,
              to: barista,
              systemProgram: SystemProgram.programId,
            },
            signers: [provider.wallet.Keypair]
          }
        );
```
When I created the token I did it with --decimals 0 which I think made 1 = 1, not 1 = 1000000000 (lamports)
Ah, I think I found the issue, I was getting a `insufficent funds` error, it's not due to sol, but to how many tokens are in the account! Thanks!
And that will generally be paid for by the `provider.wallet`, the thing that submitted the tx from the client
There's no fee for the token transfer itself‚Äîthere's just a fee for submitting the entire transaction
Also 2 Questions:

1. Who pays for a spl token transfer? From, or Authority?
2. Is there a way to get the TX fee dynamically in Rust? - I have a nonce account that owns a vault TokenAccount. I want the user to pay for the TX transfer from the vault to their account.

https://docs.rs/anchor-spl/0.5.0/anchor_spl/token/struct.Transfer.html#structfield.authority
If it says you need 1.6, have 4 on hand
How much sol? Take what you think you need and double it
```Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: custom program error: 0x0```
```
/// 0
#[error("Lamport balance below rent-exempt threshold")]
NotRentExempt,
```
I keep getting instructionError `0` , but I definitely have enough balance in my account?
```rust
    #[account(
        mut,
        constraint = *x_token_mint.key == state.x_token_mint,
    )]
    pub x_token_mint: AccountInfo<'info>,

    #[account(
        mut,
        constraint = *y_token_mint.key == state.y_token_mint,
    )]
    pub y_token_mint: AccountInfo<'info>,
```
then you can do
```rust
    /// Initialization ix.
    pub fn initialize(
        ctx: Context<Initialize>, 
        bump: u8,
        cpi_authority_bump: u8,
    ) -> ProgramResult {

        msg!("Initialize");

        // Load state.
        let state = &mut ctx.accounts.state;

        // Set PDA bump used to derive the exchange PDA.
        state.bump = bump;

        // Set the admin of the protocol.
        state.admin = *ctx.accounts.admin.key;

        // Set the pool authority - random key owned by the program.
        state.cpi_authority = *ctx.accounts.cpi_authority.key;
        state.cpi_authority_bump = cpi_authority_bump;

        // Set the mint constraints.
        state.x_token_mint = *ctx.accounts.x_token_mint.key;
        state.y_token_mint = *ctx.accounts.y_token_mint.key;

        Ok(())
    }
```
<:Shrug:856158473745727528>
(like shown above)
then I lock `initialize` usage to only my pubkey
during initialize I set the token mints so then cpi authority MUST use those mints
yeah what I did is I set the token mint constraints in the initialization using states
yeah token mints are the tricky one.. if you build spl agnostic but dont want to accept anything but solana
Yeah I tried to avoid hardcoded pubkeys, but in this case this program is only to be used with a single token mint, so I wanted to make sure no one will be able to pentest their way around it
Doing `solana-test-validator -r` works too
I have found you can often refactor to avoid hard coded pubkeys, curious how often its used
```rust
use solana_program::pubkey;
use anchor_lang::prelude::*;
...

const PHASE_AUTHORITY: Pubkey = pubkey!(
    "38Wh82EtdDPWJUbBHU2zGdJ9gqertdrBxVxyGtYTDBZ1"
);

...

    #[account(
        signer,
        constraint = *admin.key == PHASE_AUTHORITY
    )]
    pub admin: AccountInfo<'info>,
```
for anyone still wondering about the `!pubkey` this worked for me
you can delete the test-ledger file
dumb question.. if we have `init_if_needed` on an account and then pass in an already initialized pda, do we need to sign or do something else? I run into `    Program log: Error: owner does not match`

edit: it was a simple bug, make sure the token::authority is the same on both instances of using an init_if_needed
how do I reset my local validator state?
I've tried:

```
const getProvider = (keypair) => {
  const connection = new anchor.Connection(
    anchor.web3.clusterApiUrl('mainnet-beta'), 
    "processed"
  );
  const provider = new anchor.Provider(
    connection, 
    playerSecret.toBuffer(),
    "processed",
  );
  return provider;
}
```
But still - Anyone know how we'd get a second Provider in an anchor js test?


//////////////////////////////////////////////////////////////////////////////////////////

or the docs for it https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html#instruction-attribute
thanks
Yep, easiest way to learn about it is by searching through the anchor tests/ directory
Does the #[instruction()] attribute still exist? Couldn't find any doc about it but it's used in this tutorial: https://www.brianfriel.xyz/understanding-program-derived-addresses/
Just to know if I understood some things.  I guess it is possible to make a Shop on the blockchain?  Each product can be saved there (a product = an account) and via a payment in SOL one can obtain the product?  The limit being the delivery system.  To deliver the product to the user, you must have your postal address and unless he enters it with each order, you cannot save your personal information on the blockchain.  So there is a certain user experience limit.  And then I guess we have to build several smart contracts for the different layers of our app?  A smart contract so that the user can sell and manage their stocks, and a smart contract so that another can buy.  With Anchor you can develop and deploy several contracts?  Because the first time it deploys is the lib.rs.  But how do you tell him to deploy a new program for the first time?  Unless suddenly you have to think about putting everything in a single contract
Currently 1 to 1 NFT exchange is working fine. 
Next I want to do 2 to 1 exchange,. For this I will need to include an extra mint field.
But I want this to be optional, so that if I pass in all 1s or all 0s as the address for the second mint, I can treat the flow as a 1 to 1 NFT
And just to make sure I'm following, why do you want to only do this deserialization conditionally?
Yes. TokenAccount. 
Account<'info, TokenAccount>
You mean a token Account object?
Ok, understood. Next question, how do I get Account object from AccountInfo?
No, not within the `derive(Accounts)` stuff. You would have to type it as `AccountInfo` and do the conditional logic yourself in your instruction function.
Is there a way to tell anchor not to deserialize an account, based on a condition?
True. Maybe rent for 48 hours vs rent exempt makes it cost effective to short the "Solana is crashing" knee jerk market reactions? Not the purpose of this channel so I'll shut up now.
Going the multiple fields, path, I am not sure how to deal with optional fields when it comes to constraints.
The Vec approach is not compiling, am I correct to believe it is a limitation on Anchor?
Either use a Vec or have multiple fields for each token. mint1, mint2, mint3 etc..
However I am unable to figure out how to handle multiple mint fields in the Initialize struct
I am trying to extend the escrow program to handle multiple NFTs
This program already exists
Its already the one I do !
But for what it's worth, loading up a bunch of data into a bunch of accounts is kind of expensive to do
Yeah, you'll probably get rate-limited (as far as I know)
Curious as to the statement, "maybe that will irritate validators". Is that a potential attack vector from within? E.g. deploy a program and load it up with dummy data so that ```program.account.whatever.all()``` can be used as a DoS attack vector?
Thanks, will try that one!
You might be able to get away with just doing `await program.account.userDataAccount.all()` (maybe, that will irritate validators since it's potentially an expensive request)
I actually want to store dynamic state somewhere. The program I am trying to create needs some kind of home page where I can fetch and visualize an overview of data accounts that are available within 'the program'. So, I would let user create the individual data accounts and store references to these accounts in a kind of global program account. Does this approach make sense?
And then if you want, you can just redeploy your program to update that state (and if you want to think of it in terms of the "everything goes in an account" perspective, that state is living in the account that stores your code)
No, but if you want *actually* static state you can always just embed that state right into your program:
```.rs
const ACTUALLY_STATIC: &'static str = "super important constant string";
```
Is there a way to create a program PDA that holds global program state at deploy time of a program? I.e. in such a way that it is properly initialized at the time of deploy.
It stores the program code directly at the program_id address, whereas the full upgradeable loader stuff instead has the program_id account just point at a separate PDA that holds the actual program code
I haven't verified this myself, but interestingly, the way anchor test embeds your program in the "genesis block" (assuming you don't have a live local validator running in the background, that you deploy to etc.) means that your program actually doesn't have an upgradeable programdata account
üëç  thanks a lot..
I mean u will pass the address always. Just if the account is not initialized it will init
Yh
how i can adding mutable on authority,please let me know.
Hi, is this correct way to test for Anchor program errors?
```await expect(program.rpc.revealAnswer(1, {
            accounts: {
                question: questionKeypair.publicKey,
                game: gamePDA,
                authority: provider.wallet.publicKey,
            },
        })).rejects.toThrow(programError(318, 'Answer already revealed.'))```
Where programError is:
```
export function programError(code: number, msg: string): anchor.ProgramError {
    return new anchor.ProgramError(code, msg, `${code}: ${msg}`)
}
```

It seems to be used in a project that's new to me,  but my tests don't pass with these errors:
```
Expected message: "318: Answer already revealed."
    Received message: "failed to send transaction: Transaction simulation failed: Error processing Instruction 0: custom program error: 0x13e"
```
Hi Team. I am looking for an example of how to create a durable nonce account using the anchor. Any link to guide/tutorial would be really helpful. <@!501570363566587905>
So while calling the createFn if I pass this `position_pda`account, it won't init otherwise it will init, am I right ?
there are some other attributes needed, the compiler will tell you
``` 
#[account(
        init_if_needed,
        payer = owner,
        space = 8 + PositionAccount::LEN
    )]
    pub position_pda: Box<Account<'info, PositionAccount>>,
``` 
sth like this tho
hmm let me find some, omw right now but when im on the laptop
Do you any example of this. I dont see it in any of the examples in the anchor's example repo
super naive implementation ofc
sth like
```
yarn 
``` 
then go into package.json
```
{
    "scripts": {
"run-and-deploy-both-projects": cd project1 && anchor build && anchor deploy && cd .. && cd project2 && anchor build && anchor deploy}, 
...
}
```
the package.json might be easier haha, should take 3 minutes to setup
i.e. it's a program-flow thingy for which people suggest to not use it. but it's all safe, etc. (just, it might be easier for you as the programmer to have bugs when you use it, so i guess be sure that there are no "side-effects")
no, it's fine to use it. the reason people say not to use it is because it is easier to introduce bugy doing it (i.e. there could be the case that the program flow should have the account existent, and this would mean that creating it from scratch is a mistake).
yeah..but people here are suggesting not to use it if not sure
Me nether ü•≤ still searching for it
have you checked the `init_if_needed` macro? this will create the account if it does not already exist
ah I think i misread your question
you can store a reference to A from within B? perhaps you can setup the PDA seeds in such a way that a one-to-many relationship is enforced
I guess easiest way to is to create a custom package.json and create an additional command which does both. I don't know of any "out of the box" tools to achieve this, however
I have two accounts A and B. A has `one to many` relationship with B. In CreateB fn  I want to create A only if is not already present. How do I achieve this ?
Hello everyone. Have a nice day!. Currently am trying to write solana program with anchor framework. Is there anyway I can write two or more independent programs in one anchor project and build all of them in one "anchor build" command?
Ill talk to them again
ideally, the solana team would just update their code so --bpf-program uses the latest loader
I see. This may be a naive suggestion but would it be possible to specify bpf loader when running `anchor test`?
youre not. thats all it does!
I see the following:
```      - run: solana-test-validator -r --quiet &
        name: start validator
      - run: cd tests/bpf-upgradeable-state && yarn
      - run: cd tests/bpf-upgradeable-state && yarn link @project-serum/anchor
      - run: cd tests/bpf-upgradeable-state && anchor build
      - run: cd tests/bpf-upgradeable-state && solana program deploy --program-id program_with_different_programdata.json target/deploy/bpf_upgradeable_state.so
      - run: cd tests/bpf-upgradeable-state && cp bpf_upgradeable_state-keypair.json target/deploy/bpf_upgradeable_state-keypair.json && anchor deploy && anchor test --skip-deploy --skip-build```
Does this mean to start the test validator manually, deploy the program normally, then run anchor test without deploying or building? Or is there more here that I'm missing?
Thank you so much I knew there was a good reason for this.
in anchor test we add programs with the --bpf-program flag and unfortunately this loads them with the bpfloader2. check out the bpf-upgradable-state ci in our tests.yaml for a workaround
Hi started trying out the tutorial on anchor-framework, 
been getting this error 
```
ANCHOR_WALLET=/Userspath/.config/solana/id.json  node client.js                           

Running client.
/Userspath/Desktop/rust-stuff/solana-work/anchor/examples/tutorial/node_modules/@solana/web3.js/lib/index.cjs.js:5965
      throw new Error('failed to get recent blockhash: ' + e);
            ^

Error: failed to get recent blockhash: FetchError: request to http://localhost:8899/ failed, reason: connect ECONNREFUSED ::1:8899
    at Connection.getRecentBlockhash (/Users/Desktop/rust-stuff/solana-work/anchor/examples/tutorial/node_modules/@solana/web3.js/lib/index.cjs.js:5965:13)
...
...
...
    at async main (/Users/Userspath/Desktop/rust-stuff/solana-work/anchor/examples/tutorial/basic-0/client.js:24:3)
```
Have the solana validator running and 
On making wget http://localhost:8899/ I do get a 405 response, which means the port is in use, but for some reason my program cant access it. 
 
Also I get this only with the javacript client, I tried making it via the python client, and it did not throw any errors. Is this is a permissions issue ? 
Or say the validator node is accessible at localhost but not at the 0.0.0.0 which javascript it trying to access ?

Any help on what should I look into, what are the potential points of failure here
Anyone been profiling solana programs in a way or another?
https://github.com/CalebEverett/nftfactory/blob/2c0e99f11e06fa8590cef1034856678388bcc9ec/Anchor.toml#L18
Weirdly for me. `ctx.accounts.program.programdata_address()` is returning `None` in `anchor test` so I cannot test using the upgrade authority as a constraint. Any reason why that is?
basically you want to constrain the uniqueness on 2 fields independently. My first instinct is a naive solution, which is to create a PDA from the public key and another PDA from the username. If you use `init` on the macros for both accounts, if it's already initialized then the instruction will reject. Maybe others have better ideas but this is the simplest I can think of that is on-chain.
help this poor soul ;-;
<@!134416332509675520>
PDA stuff
1) I like this one: https://dev.to/dabit3/the-complete-guide-to-full-stack-solana-development-with-react-anchor-rust-and-phantom-3291

No idea on #2, I've only ever used `anchor test`
Yeah - or hardhat - cus I like that better.
Bonus noob question : Anchor is like Truffle for Solidity ?
And that's my last two noob questions for today:

1) Do you have any docs/tutorials for creating Solana dapps with Anchor/React? I need to make several docs to understand what I'm doing.

2) Why does the unit test not react the same depending on the CLI command I'm doing? Example:
- anchor run test
- runs the test
- error "Fallback functions are not supported"

- anchor test
- runs the test
- test passed

I specify that in the example one I have a local ledger launched
Thx I'll check !
You can do this to truly nuke your program: https://jstarry.notion.site/Program-deploys-29780c48794c47308d5f138074dd9838#147e89b2c27e4429ba45075e722e73ac
Yes
What do you mean by deactivate? Delete? Render unusable?
Taking a look now - thanks for hookup
Not sure if this covers what you want, but here's an example of a program-controlled mint: https://github.com/cqfd/anchor-token-studies/blob/main/programs/token-studies/src/lib.rs#L95
Another basic question! Is it possible to deactivate a program? Let's say I develop a Smart contract and there is a case I didn't manage. It creates a flaw and if someone finds it he can exploit it and literally break a whole project. And those, all the time that I find the problem, that I fix it and that I re-deploy it
When creating a mint account is it normal to use the CLI for the initial setup or is there a good tutorial on how to do it in code
ahh. got it. makes sense thank you.
So there they're cloning the programs themselves (slight wrinkle since you actually need to clone *two* accounts for a single program, because it's deployed with the upgradeable loader program)
Yeah, just those specific accounts‚Äîyou can manually specify however many you want
Does this clone both the program and the accounts? I assume just the program otherwise it's way too heavyweight for things like metaplex
Thank you
Yep!
Amazing. Is this in `Anchor.toml`?
And just straight up clone accounts from devnet etc.
üëç  Thanks ! I don't need it now but I learn some differents logic. That can help me for understand some things üôÇ Thx
You can actually use the clone feature: https://discord.com/channels/889577356681945098/889702325231427584/943483106852212766
Yep. In the example I gave, the receiver would be receiving back the lamports, so you could make that the author.
hey jinx. I actually came here to ask a question. If my program has dependencies on other programs for CPI, how do I make that work in `anchor test`? I assume I have to deploy the other programs in the  `before` hook of test? Are there examples of this?
Ooh I see! Indeed since a tweet is an account, we can drain it, close it and send back to the author the drained funds
from here: https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html
In solana, you drain their rent lamports (and then send them to someone else, e.g. refund the poster)
You can close the account. 

```#[account(mut, close = receiver)]
pub data_account: Account<'info, MyData>,
#[account(mut)]
pub receiver: SystemAccount<'info>```
You can close accounts just fine!
So it's a question of logic. In Web2, we use a CRUD to manipulate the data. In our case in Web3, assuming we want to make a Twitter like.

I user I want to tweet, I do it and the tweet is recorded in the blockchain. However, I can't delete it, can I? In this case, how to do the D of the CRUD? Should we think about an active/inactive status and display on our projects only active tweets but inactive ones remain visible on the blockchain? Or is it possible to clearly remove information from the blockchain?
Thanks I‚Äôll take a look!
I haven't actually tried this myself, but yes, you can freeze an account: https://spl.solana.com/token#freezing-accounts
Is there a way to make a token non transferable once it‚Äôs minted?
Hehe just found that too, nice üôÇ
seems to work ok for now
ok i just tried with `let secret: &'static str = env!("SECRET");`
Mm, yeah, I feel like I learned how to do that at one point but now I can't remember ü§î
What if the secret isn't that big of deal to store as machine code binaries but I don't want it in the repo, is there a good way to use environment variables to inject these variables at compile time
Yes, I see. In itself I am not affected by this problem. I saw on the Solana Discord someone who wanted to do this and I had the same speech as you. I'm just taking advantage of a brand new discord with new future friends to make sure I'm not talking nonsense üôÇ
Your program itself also lives in an account/blockchains are public etc.
But decrypting the data on-chain, within your program, doesn't really work, because you can't really store anything secret *in* your program
Yes ok I understand
Well, you can store whatever data you want in an account‚Äîit's just bytes
And encryption does not cause problems with validators?
No, there isn't really any way to store private data (you could encrypt it, but anyone can download an account's data at any time)
For example on the current Web2, we can save data in a DB and be able to access this data if the user pays a subscription for example. On the blockchain side, it is literally a DB open to everyone. So my question is, is there a way to store private data, recoverable only under certain conditions like for example that the payment of a subscription has been made? I believe that on ETH with Solidity there is the possibility to save private data
What do you mean by "recoverable" here?
And I was wondering, do you know if it is possible to store on the blockchain specific data recoverable only if the user has paid?
All right. I don't understand anything you're saying ü•≤. I'm learning to do Rust and use Anchor at the same time. I understand some of the logic but it takes time to get familiar with it all. I already understand that you have to use accounts for almost everything etc.. I still don't see what SystemProgram is really for. I do, I see that it works and generally I try to understand why after lmao
Idiomatic anchor will very rarely use AccountInfo
Or really any incoming program
But yes, you should use what I wrote every single time you interact with the system program
Lol
Ofc Program
That's not what I wrote üòõ

Ok I understand. Its always the same case ? When I use the system_program field I need to use System ? Actually have this error:

Wrong number of type arguments: expected 0, found 1 (AccountInfo)
Anchor is telling you that doing that is a bad idea‚Äîyou should be verifying that the incoming account really truly is the system program (that's what the line I wrote does)
Yep‚Äîchange it to what I wrote üòõ
I have this actually
Do `system_program: Program<'info, System>` instead of whatever you have now
Hi ! Im totally new and I wanna understand why I can't build my program. Any ideas ?
Ah great. Very easy to do. Thanks
By any chance do you have an example of what it looks like? I can see it would see save a lot of lines of code but just not 100% where I have to throw in the seeds still
writing it here in case someone else runs into a similar problem, I was able to solve the problem using the byteify library to convert the BN properly when using negative numbers to find_program_address. while still passing the BNs through the client side of anchor
One way is to just delete/move the old target/<your-prog-name> keypair file
So if i want to change my program id, which is currently "6qgQxwtSDhC8sEJ1AERrchDcyWVKsyj6cN5uk5papLsd". is there a way to regenerate the id that is initially created by anchor on init?
ah okay. really not ideal at all lol. but this is devnet, so i guess if i dont change the code now to mess up the structs it wont happen in the future. rip
that makes a lot of sense
oh wow! this is what causes it
Yeah, take a look at how those seeds on the JS side turn into byte buffers (they're wrong/lose track of the negative signs)
I personally never did find a fix for that. Another user in a different discord I'm in however ran into the same issue and managed to fix it by generating a new keypair for the underlying program account and initializing a new account
<@!672944020053557268> How did you solve the issue with "The value of "offset" is out of range. It must be >= 0 "
omfg if i use just positive numbers it works. what is this random code behaviorrrrrrr
ah i see other's have had the same issue. here is what you said. "That means that the actual data in that account doesn't match the expected <my-account> type
Try fetching it the lower-level way, program.provider.connection.getAccountInfo and see what it looks like". from running that command, it pulls `"TypeError: publicKey.toBase58 is not a function"`
uh are you sure? because when i did print out of the PDA on both the client and generated it using find_program_address on the rust side and they both printed out the same thing
Hmmm. it seems to be returning this error now? Even though the offset is 8 still ```RangeError [ERR_OUT_OF_RANGE]: The value of "offset" is out of range. It must be >= 0 and <= 8675. Received 778792772
      at new NodeError (node:internal/errors:363:5)
      at boundsError (node:internal/buffer:86:9)
      at Buffer.readUInt8 (node:internal/buffer:252:5)
      at Buffer.readUIntLE (node:internal/buffer:182:17)
      at UInt.decode (node_modules/buffer-layout/lib/Layout.js:570:14)
      at WrappedLayout.decode (node_modules/@project-serum/borsh/dist/lib/index.js:62:41)
      at Structure.decode (node_modules/buffer-layout/lib/Layout.js:1234:32)
      at AccountsCoder.decode (node_modules/@project-serum/anchor/dist/cjs/coder/accounts.js:47:23)
      at /home/byron/_solspot/node_modules/@project-serum/anchor/dist/cjs/program/namespace/account.js:164:47
      at Array.map (<anonymous>)
      at AccountClient.all (node_modules/@project-serum/anchor/dist/cjs/program/namespace/account.js:161:21)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at async Context.<anonymous> (tests/_solspot.js:198:17)```
but ohhh that makes that it cannot rewrite the structs in different orders. I will give that a go and rewrite the new struct to follow that. thank you so much!
ok haha so my understanding of that is correct. nice.
Oh, sorry, got it üëç
but i am searching with the user address who owns the profile_address being searched for
Hm. well I am searching for the user address that owns the account. Which then has to search within the data at the user var I assume? If i use fetch, then I would have to pass the profile_address i am looking for right?
You have to make sure you add all new fields at the *end* of the struct, so you don't overwrite previous ones
Yeah, you made a non-backwards-compatible update to that account struct
~~Quick q, why not use `await program.account.profile.fetch(old_acc_address)`?~~
Sorry if this is too long. i can definitely delete it if need be. The issue is that accounts created before the update are no longer working. it will not even query using the below command . new accounts can be created and function as assumed. i have no idea what to do? ```let old_acc_address = "7eXSNy1Q2b7SLCWNtprRT6KAViDrk94jj2ht8z1UNoar";
      profile = await program.account.profile.all([
         {
            memcmp: {
               offset: 8, // Discriminator.
               bytes: old_acc_address,
            }
         }
      ]);``` here is the new struct ```#[account]
#[account]
pub struct Profile {
    pub user: Pubkey,
    pub bio: String,
    pub color: String,
    pub light_theme: bool,
    pub individual: bool,
    pub link_list: Vec<ContentStruct>,
}
``` Here is the old account struct ```#[account]
#[account]
pub struct Profile {
    pub user: Pubkey,
    pub bio: String,
    pub link_list: Vec<ContentStruct>,
}```  Here is the error ```Error: Invalid bool: 119
      at WrappedLayout.decodeBool [as decoder] (node_modules/@project-serum/borsh/dist/lib/index.js:124:11)
      at WrappedLayout.decode (node_modules/@project-serum/borsh/dist/lib/index.js:62:21)
      at Structure.decode (node_modules/buffer-layout/lib/Layout.js:1234:32)
      at AccountsCoder.decode (node_modules/@project-serum/anchor/dist/cjs/coder/accounts.js:47:23)
      at /home/byron/_solspot/node_modules/@project-serum/anchor/dist/cjs/program/namespace/account.js:164:47
      at Array.map (<anonymous>)
      at AccountClient.all (node_modules/@project-serum/anchor/dist/cjs/program/namespace/account.js:161:21)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at async Context.<anonymous> (tests/_solspot.js:197:17)```
It ends up dropping the sign (not actually sure why it would do that ü§î)
Interesting, have to admit I didn't see this coming: the issue is that those attempts at converting the JS BN coordinates into buffers doesn't do what you'd think it would do!
https://github.com/spacemandev-git/dominari
une moment let me push
Is your code on github? I can poke at it if so
okay I confirmed the PDA is correct, so that means i have even less of a clue why this error is happening:
```
Calculated PDA: 8bTnQchSvfuaxGyqvjphd9biEirGU1tBZjqRsUc8wJDQ
Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account 
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS invoke [1]
    Program log: Instruction: InitLocation
    8bTnQchSvfuaxGyqvjphd9biEirGU1tBZjqRsUc8wJDQ's signer privilege escalated
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS consumed 10833 of 200000 compute units
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS failed: Cross-program invocation with unauthorized signer or writable account
```

Context: 

```rs
#[derive(Accounts)]
#[instruction(loc: Coords)]
pub struct InitLocation<'info>{
    #[account(
        init,
        //(Nx, Ny) (Lx, Ly)
        seeds=[loc.nx.to_be_bytes().as_ref(), loc.ny.to_be_bytes().as_ref(), loc.x.to_be_bytes().as_ref(), loc.y.to_be_bytes().as_ref()],
        bump,
        payer=initalizer,
        space=8+1024
    )]
    pub location: Account<'info, Location>,
    #[account(mut)]
    pub initalizer: Signer<'info>,
    pub system_program: Program<'info, System>
}
```
nvm forget about reset.
ah reset might not be the best word choice as if i update any rust program on a mainnet i would have to factor in supporting old program structure
What do you mean by reset?
I am getting this when I call this filter. ```Error checking init Error: Invalid bool: 119
    at WrappedLayout.decodeBool [as decoder] (index.ts:177:1)
    at WrappedLayout.decode (index.ts:100:1)
    at Structure.decode (Layout.js:1234:1)
    at $.decodeUnchecked (accounts.ts:72:1)
    at $.decode (accounts.ts:62:1)
    at account.ts:222:1
    at Array.map (<anonymous>)
    at _e.all (account.ts:206:1)
    at async checkIfInit (create.js:72:1)```
ahh thank you. I am running into errors when I deploy a new version of my anchor program. the accounts created for some reason. is there a way to reset all accounts when i query using this call? ```const profile = await program.account.profile.all([
            {
               memcmp: {
                  offset: 8, // Discriminator.
                  bytes: walletAddress,
               }
            }
         ]);```
\`\`\`langName here for syntax highlight (rs for rust, or ts for typescript)
CODE
\`\`\`
Triple ticks
I think anchor actually verifies that your bump is "canonical", which means it needs to re-run find_program_address with your seeds + then verify that the resulting bump is the one you said it should be
how do you make your code be in nice boxes? the only thing online i could find was to use the ticks like so `hello world`
`create_program_address` is for when you *also* supply the bump
which method does the account init macro use? create or find? having a problem with PDA signer priviledge esclation so seeing if my PDA i'm passing in on the client side is the same as the one generated by the account init macro
Yeah. If you use the `program.methods` feature in 0.21.0, the client will automatically derive the PDA based on the IDL generated by anchor 0.21.0 so you don‚Äôt need to pass it in. It saves quite a few lines of code if you have a bunch of PDAs.
Try hopping to source on them to see the difference
Yep, it's `find_program_address` üòõ
what's the difference? / is there a find program address in rust?
Gotta be consistent
Ah, well, you're using `create_program_address` in rust but findProgramAddress in JS
i64
What is the rust type of `loc.nx`, `loc.ny` etc.?
this 
```rs
let address = Pubkey::create_program_address(&[loc.nx.to_be_bytes().as_ref(), loc.ny.to_be_bytes().as_ref(), loc.x.to_be_bytes().as_ref(), loc.y.to_be_bytes().as_ref()], ctx.program_id);
```
generates a different address than 
```ts
const [loc_address, loc_bump] = findProgramAddressSync([coords.nx.toArrayLike(Buffer, "be", 8), coords.ny.toArrayLike(Buffer, "be", 8), coords.x.toArrayLike(Buffer, "be", 8), coords.y.toArrayLike(Buffer, "be", 8)], dominari.programId)    
```

how can i get them to generate the same address?
I have 2 NFTs (created using metaplex) inside my phantom under a collection name `Album` . is there any way I can fetch a single collection by name/id( if there is any) ?
well ig this is a waste right. it will throw an error if the param is not bool. oh nvm lol
`        if type_of(light) != type_of(bool)  {
            return Err(ErrorCode::LightNotBool.into())
        }`
also, does anyone know how i can verify a parameter is a boolean on the rust side?
Cool I just ended up using init_if_needed and it solved my issue. Could look into turning on the seed feature in the future if that is recommended
im interested to hear this answer as well. the way i solved it was by checking in the frontend, but obviously I would prefer it to be checked in the rust script
i want to make an account which can store both public key of an user and a username he chooses, and these fields will be individually unique.. so if "b123" publickey sets "abcd" as username, they wont be able to create another account with the same publickey.. similarly someone with "b456" publickey wont be able to take the "abcd" username.. m trying to achieve this... 
m so sorry if my question was unclear


//////////////////////////////////////////////////////////////////////////////////////////

üëã hello! hope y'all had a good weekend. I have a question on best practices for structuring solana programs vs. the front-end/client. Do we typically avoid storing state in the program accounts/objects? Is there a doc that outlines do's/don'ts and the reasoning behind it?
Maybe I am just doing it all wrong, any example repo that shows this functionality so I can try it out locally myself?
thank you
ah, that was it lol
Are you sure it's not some other test that is failing?
Mm, that doesn't make sense to me, why are the logs talking about associated token stuff then?

Im not passing it in anything, thats the entire test. I commented out the actual instruction
u can try this out https://dev.to/nickgarfield/how-to-install-solana-dev-tools-on-an-m1-mac-kfn
Yeah, gotta start over (I install from source on an M1, not via the installer/downloader, so not sure if that even works)
This is the mac m1 thing...üò©
`mattbraz@patty:.anchor$ solana-test-validator
Ledger location: test-ledger
Log: test-ledger/validator.log
‚†ô Initializing...
Illegal instruction: 4`
oh crap
Are you actually able to start the validator at all though? `solana-test-validator`
Yeah
can i delete the contents of .anchor?
`Unable to start test validator. Check .anchor/test-ledger/test-ledger-log.txt for errors.
mattbraz@patty:escrow$ cat .anchor/test-ledger/test-ledger-log.txt
Ledger location: .anchor/test-ledger
Log: .anchor/test-ledger/validator.log
Initializing...`
now i have:
ah great, making progress..
And then retry
Try doing `cargo clean`
`mattbraz@patty:escrow$ anchor test
BPF SDK: /Users/mattbraz/.local/share/solana/install/releases/1.9.1/solana-release/bin/sdk/bpf
cargo-build-bpf child: rustup toolchain list -v
cargo-build-bpf child: rustup toolchain uninstall bpf
info: uninstalling toolchain 'bpf'
info: toolchain 'bpf' uninstalled
cargo-build-bpf child: rustup toolchain link bpf /Users/mattbraz/.local/share/solana/install/releases/1.9.1/solana-release/bin/sdk/bpf/dependencies/bpf-tools/rust
cargo-build-bpf child: cargo +bpf build --target bpfel-unknown-unknown --release
   Compiling blake3 v1.3.1
error[E0460]: found possibly newer version of crate `compiler_builtins` which `arrayref` depends on
 --> /Users/mattbraz/.cargo/registry/src/github.com-1ecc6299db9ec823/blake3-1.3.1/src/portable.rs:5:5
  |
5 | use arrayref::{array_mut_ref, array_ref};
  |     ^^^^^^^^
  |
  = note: perhaps that crate needs to be recompiled?
  = note: the following crate versions were found:
          crate `compiler_builtins`: /Users/mattbraz/.cache/solana/v1.20/bpf-tools/rust/lib/rustlib/bpfel-unknown-unknown/lib/libcompiler_builtins-2b55923f9138f2d9.rlib
          crate `arrayref`: /Users/mattbraz/Coding/3rd/anchor/tests/escrow/target/bpfel-unknown-unknown/release/deps/libarrayref-5374d35c67a5c556.rmeta

error: could not compile `blake3` due to previous error`
ok, i'm even more broken now
How are you actually passing in that mint account into your instruction?

WTH am I doing wrong here? 
```
Transaction simulation failed: Error processing Instruction 0: custom program error: 0x2 
  Program ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL invoke [1]
  Program log: Transfer 2039280 lamports to the associated token account
  Program 11111111111111111111111111111111 invoke [2]
  Program 11111111111111111111111111111111 success
  Program log: Allocate space for the associated token account
  Program 11111111111111111111111111111111 invoke [2]
  Program 11111111111111111111111111111111 success
  Program log: Assign the associated token account to the SPL Token program
  Program 11111111111111111111111111111111 invoke [2]
  Program 11111111111111111111111111111111 success
  Program log: Initialize the associated token account
  Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [2]
  Program log: Instruction: InitializeAccount
  Program log: Error: Invalid Mint
  Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 3069 of 181474 compute units
  Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA failed: custom program error: 0x2
  Program ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL consumed 21595 of 200000 compute units
  Program ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL failed: custom program error: 0x2
SendTransactionError: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: custom program error: 0x2 at Connection.sendEncodedTransaction
]
```
`i'm loathe to disturb it` ü§£
im giving it a go
sh -c "$(curl -sSfL https://release.solana.com/v1.9.1/install)"
I'm on mac M1, so installing solana was a palaver, i'm loathe to disturb it
Yeah, try reinstalling from scratch
solana --version
solana-cli 1.8.5 (src:devbuild; feat:52865992)
This error seems to be something with a busted version of solana actually, I would just try reinstalling solana from scratch
I'm supposing this is something to do with node packages, but don't know how to proceed from here.  Everything was working a while back.
error is: `     Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 1: instruction modified the program id of an account
`
If `anchor test` fails on all programs, including the anchor's own tests, with the same error, how could i go about fixing it?
Ah, ok, yeah I've got an actual `--clone` flag in there
`.anchor/test-ledger/validator.log`
omg that was it - had a later version of `anchor-spl`, switched both to the same and the error went away
Where are you getting the logs from?
do your logs look like my anchor logs?
ah maybe ill try fetch and get back to you
Hmm, not sure, the feature seems to work fine for me when I try it locally (I can fetch the cloned accounts, etc.)
here's an example with the validator run manually ( no anchor)
```
        inner: [
            "solana-test-validator",
            "-c",
            "7azgmy1pFXHikv36q1zZASvFq5vFa39TT9NweVugKKTU",
            "-u",
            "devnet",
        ],
    }
```
I dont see the `-c` options in the logs when I run `anchor test`
```
        inner: [
            "solana-test-validator",
            "--ledger",
            ".anchor/test-ledger",
            "--mint",
            "D5B1iguWRmkrjiNU6zSt1LxwDocFRyzfab38y4JXwed",
            "--bpf-program",
            "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS",
            "/Users/bm/sandbox/solana/marinade-onchain/target/deploy/marinade_onchain.so",
            "--bind-address",
            "0.0.0.0",
            "--rpc-port",
            "8899",
            "--url",
            "https://api.mainnet-beta.solana.com",
        ],
    }
```
with anchor test and the toml config i get no such error
if I use the `solana-test-validator -c XXXX -u devnet` method it definitely does, it takes 10+ seconds to load all the accounts and 2 of those it can't find on the mainnet
What do you mean by doesn't seem like it?
I passed in about 8 different accounts 
```
[test.validator]
url = "https://api.mainnet-beta.solana.com"

[[test.validator.clone]]
address = "MarBmsSgKXdrN1egZf5sqe1TMai9K1rChYNDJgjq7aD"

[[test.validator.clone]]
address = "3JLPCS1qM2zRw3Dp6V4hZnYHd4toMNPkNesXdX9tg6KM"

[[test.validator.clone]]
address = "8szGkuLTAux9XMgZ2vtY39jVSowEcpBfFfD8hXSEqdGC"

[[test.validator.clone]]
address = "HZsepB79dnpvH6qfVgvMpS738EndHw3qSHo4Gv5WX1KA"

[[test.validator.clone]]
address = "mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So"

[[test.validator.clone]]
address = "UefNb6z6yvArqe4cJHTXCqStRsKmWhGxnZzuHbikP5Q"

[[test.validator.clone]]
address = "7GgPYjS5Dza89wV6FpZ23kUJRG5vbQ1GM25ezspYFSoE"

[[test.validator.clone]]
address = "Du3Ysj1wKbxPKkuPPnvzQLQh8oMSVifs3jGZjJWXFmHN"
```
It doesnt seem like it
I'm actually not sure, does anchor seem to load that account?
Ok, cool
Not for anchor test, i thought anchor test spins one up for me
I think those only take effect if you *don't* run a validator, and instead let anchor spin it up for you
Are you running a validator in the background?
If I define:
```
[test.validator]
url = "https://api.mainnet-beta.solana.com"

[[test.validator.clone]]
address = "MarBmsSgKXdrN1egZf5sqe1TMai9K1rChYNDJgjq7aD"
```
In my Anchor.toml, when I run `anchor test` do the addresses get cloned before the tests run? It seems to start up very fast, when I run with `solana-test-validator -c MarBmsSgKXdrN1egZf5sqe1TMai9K1rChYNDJgjq7aD -u mainnet-beta` it takes much longer and I see the addresses show up in the logs. I do not see the addresses in the logs for the Anchor.toml method
will have to do w/o auto-pda for now
aye alas its failing for another issue when I'm importing account from another anchor program: https://github.com/project-serum/anchor/issues/1487
that works! very nice thank you
Basing that guess off the test for this feature: https://github.com/project-serum/anchor/blob/master/tests/pda-derivation/programs/pda-derivation/src/lib.rs#L60
Mm, annoying but try doing `your_u8.to_le_bytes().as_ref()` ?
Anchor is giving this error:
```WARNING: unexpected seed: Array(ExprArray { attrs: [], bracket_token: Bracket, elems: [Path(ExprPath { attrs: [], qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(seed_type), arguments: None }] } })] })```
when seed_type is a u8, set as seed with `&[seed_type]`.  Any idea how i can cast this to avoid the warning?
storing it on the pda account, i.e. `ctx.accounts.pda_account.seed_string`, `ctx.accounts.pda_account.bump`
Where are you getting that seed + bump choice?
Working through my understanding of CPI's right now

So I have a program function I want to call where a PDA is the authority. In my other program I try to use that with a CPI. When I call this I should pass in that PDA as the authority, and then the signer seeds are the seeds for that PDA?

```
use outside_program::{
  PdaAccountType,
  program::OutsideProgram
};
use outside_program::cpi::{
  outside_function,
  OutsideFunction
};

...

pub fn inside_function(Context<InsideFunction>, bump:u8){
  outside_function(
    ctx.accounts.into_outside_function_context()
    .with_signer_seeds(&[&[pda_seed_string.as_ref(), &[bump]])
  )
}
...

#[derive(Accounts)]
pub struct InsideFunction<'info> {
  #[account(mut)]
  pub authority: Signer<'info>,
  #[account(mut)]
  pub pda_account: Account<'info, PdaAccountType>,
  pub outside_program: Program<'info, OutsideProgram>,
}

impl<'info> InsideFunction<'info>{
  fn into_transfer_fora_token_context(&self) 
    -> CpiContext<'_, '_, '_, 'info, OutsideFunction<'info>> {
    let cpi_program = self.outside_program.to_account_info();
    let cpi_accounts = {
      authority: self.pda_account,
      ...
    };
    CpiContext::new(cpi_program, cpi_accounts)
  }
}
```
The seeds for the PDA are a string and a bump.

When I call this I get the error `Program failed to complete: Could not create program address with signer seeds: Provided seeds do not result in a valid address`. Am I choosing the seeds correctly? I don't really understand what the signer seeds `&['a, &['b, &['c]]]` struct is.
Beginner answer, so maybe disregard: by using many individual accounts, you could handle one ticket just like one token, and so use the mechanics for it that already exist rather than re-implementing it in your system
Lots of small accounts are potentially way cheaper if you don't end up needing all 7000 users
Sorry forgot to mention, I can make this big account fixed, let say only 7000 users can buy ticket, so I guess it makes things easy.
On the other hand what are the benefits of not using one big account and create as many accounts as needed?
I solved it by installing node 16.12 alongside 16.14 and switching with nvm
The tradeoff with the one-big-account approach is that you currently can't resize accounts (you hopefully will be able to in the next solana release, 1.9, but not clear when that will come out). So, you kind of need to just guess how much space to allocate.
How do you recommend to organize account structure:  let say users will be buying lottery tickets, shall I keep purchased tickets in one big account as an array? or have many accounts, one per ticket? with the second approach will it be practical to search for thousands of ticket accounts?
Thanks for replying I appreciate it
This is the error I was getting
--faucet-sol argument ignored, ledger already exists
Aborted
OK, for me it just continues on the existing ledger
What I just did was re-install solana using the stable build and it's all better now
ah ok cool. In this case it actually then abortedf
That's not an error, it just means it's not reinitializing a new ledger but reusing the existing one
You can just send money to that address (it's an account like any other, the PDAness only affects its address)
Quick super n00b question: My PDA is running into insufficient lamports issue. How do I fund it? Should I deposit money in the program account or do something else?
Hello, I'm running into a problem. I'm not sure if this is the right place for this. I just finished updating rust/solana/anchor and now when I try to run a test-validator I'm getting an error message: "--faucet-sol argument ignored, ledger already exists". Any idea?
yeah i was just thinking that, thanks for the helpful info
Well, you could have your node script reach out to the filesystem and read the Anchor.toml file etc.
yes am running in the way you mentioned. ok so there's no getting around the env vars if we run a JS client then
If you just do `node my_client.js` then anchor doesn't have a chance to inject any env vars.
What kind of client? How are you running that client etc.?
is there any reason why we need to set the ANCHOR_PROVIDER_URL and ANCHOR_WALLET env vars when running clients, but when we  deploy with anchor it can use the values in the provider section in Anchor.toml? I.e can we just have it so clients automatically use values in the anchor.toml file as well, instead of having to set the env vars?
oh hmm, ok thanks, let me look at it.
Using `init` you can unfortunately only allocate 10kb, not 10mb. To get the full 10mb you're unfortunately going to have to use a separate instruction issued from the client that creates the account, and then use `#[account(zero)]` etc. (try searching the anchor repo for examples)
I'm trying to build & localnet deploy CMv2 which apparently uses anchor 0.19. Is there an accepted way to run multiple versions of anchor?
Hello, I'm trying to allocate some space to store some pub keys lVec<Pubkey>  but, when I try to allocate (32 * 400) bytes (for 400 pubkeys) it says `Failed to reallocate account data`  As far as I read, we should be able to store up to 10MB data in an account, any idea why does that fail? 

I'm  defining account like

```
 #[account(
    init,
    payer = authority,
    space = PoolAccount::needed_space(),
    )]
    pub pool_account: Account<'info, PoolAccount>,
```

where needed_space returns 32 * 400 and some small addition for other metadata
That would be an example where you don't actually know how much space you'll need, since each individual Foo takes up a variable amount, but at any rate basically the same idea‚Äîthe first four bytes of the result will be `[2, 0, 0, 0]` because borsh uses little-endian and the vec has length 2. The "I'm a foo" will turn into `[9, 0, 0, 0, 73, 39, 109, 32, 97, 32, 102, 111, 111]` because the string has length 9, etc.
You can also always just experiment with this stuff,
```.rs
#[test]
fn hmm() {
    #[derive(AnchorSerialize)]
    struct Foo {
        x: u32,
        y: String,
    }

    let foos = vec![
        Foo {
            x: 123,
            y: "I'm a foo".to_string(),
        },
        Foo {
            x: 0,
            y: "".to_string(),
        },
    ];

    eprintln!("{:?}", foos.try_to_vec());
}
```
Think <@!401712056543477761> explained it well, borsh serializes a Vec<Foo> by first writing out 4 bytes for the length of the vector, followed by each foo one after the other. So assuming you know how much space borsh needs per foo, the total amount of space you need for that Vec<Foo> is 4 + len * foo_size.
Yeah. Though there's also the idea of "wrapped sol", which is a token-ized version of native sol for when you want to be able to handle sol in a token-y way.
oh, nvm now they are there. I've run `anchor build` one more time and its fine
Hi, just want to clarify, `anchor_spl::token` is like ERC20 in solidity? And not for sending native SOL?
what types are you missing exactly? have you run `anchor build`?
btw <@!347689664855015424> , do you know why typings for program are not generated? Can I try to generate them using some command or so?
thanks üôÇ
Yeah, that was the problem. Thank you üôÇ
yea we missed adding `ProgramResult` you can manually change it for now and we're releasing a patch ASAP
Are you using different versions of anchor-lang and anchor-spl in your program's Cargo.toml?
from the latest changelog https://github.com/project-serum/anchor/blob/master/CHANGELOG.md

If you just `anchor init` and cannot build the project maybe it because of `ProgramResult`. in `anchor 0.22.0` you have to change to `Result<()>`
Am I missing somethingüòÖ ?
for example `ProgramResult` is not in the scope as well as program types are not autogenerated under `target/types`
I'm asking cuz it seems like generated project doesnt contain everything
hello üôÇ Is there any tutorial about tranfer spl token on anchor program?
I think you should always update to the latest (1.9.8)
I was not able to build my project on `v1.9.4`
where can I find which version of Solana is currently supported by Anchor?
https://lorisleiva.com/create-a-solana-dapp-from-scratch/structuring-our-tweet-account#size-recap

It‚Äôs from this awesome tutorial, highly recommend
still struggling with this lmao
whats the source of this data table>? want to make sure i save this one. super handy
ie : ```
#[account]
#[derive(Derivative)]
#[derivative(Debug, Default)]
pub struct PoolState {
    ...
    pub padding: PoolStatePadding,
}

#[derive(Clone, Debug)]
pub struct PoolStatePadding([u8; POOL_STATE_PADDING_SIZE]);
...
```
Hey guys, how can I tell anchor to ignore my Padding type? ```IdlError: Type not found: {"name":"padding","type":{"defined":"PoolStatePadding"}}
  ...
error Command failed with exit code 1.
info Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.

```
thanks for the help!
will wait for alan
hmm idk
in the example vector holds u16. u16 weights 2 bytes, so if you hold 10 items in vector it will be 4 (prefix) + 10 * 2. If you hold 10 PublicKey, which weights 32 bytes, it will be 4 (prefix) + 10 * 32. 
If you don't put any items in vector it will be 4 bytes (just prefix), i guess this is how much space anchor allocate for just empty vector
any multiple of 2 bytes? So what's the exact number?
this was helpful but i dont fully get it

Also, What's the point of having `version` on an account?
How much space does anchor buffer when I add a Vec to my account?
e.g.
```#[account]
pub struct MyAccount {
    pub version: u8,
    pub protocols: Vec<OtherAccount>, 
    pub creator: Pubkey,
    pub vault_extra_space: [u8; 256],
}```

As I add protocols, does `creator` get shifted down?
```
pub fn take_ownership(ctx: Context<TakeOwnership>, auth_bump: u8) -> ProgramResult {
        let license = &mut ctx.accounts.treasury_license;
        license.treasury_key = ctx.accounts.payer.key();
        license.reload()?;
        msg!("Owner of tokens: {}", license.treasury_key);
        Ok(())

    }

#[derive(Accounts)]
#[instruction(auth_bump: u8)]
pub struct TakeOwnership<'info> {
    #[account(
        init,
        payer=payer,
        seeds = [b"treasury_license".as_ref()],
        bump = auth_bump,
        space = 8 + 32
    )]
    pub treasury_license: Account<'info, License>,
    #[account(mut)]
    pub payer: Signer<'info>,
    pub system_program: Program<'info, System>,

}


#[account]
pub struct License {
  pub treasury_key: Pubkey,
}



```
Fails with this error:  8 byte discriminator did not match what was expected
been struggling with this all arvo, anyone got a clue? 

```
const [auth, authBump] = await anchor.web3.PublicKey.findProgramAddress(
      [Buffer.from("treasury_license")],
      program.programId
    );
const tx = await program.rpc.takeOwnership(authBump, {
  accounts: {
    treasuryLicense: auth,
    payer: program.provider.wallet.publicKey,
    systemProgram: anchor.web3.SystemProgram.programId,
  },
});
console.log("Your transaction signature", tx);
```
thanks üôÇ
`anchor_spl::token::accessor::amount` for token accounts
How can I check token account balance and lamport balances in an Anchor program?
my struct
```#[derive(Accounts)]
pub struct MarinadeDeposit<'info> {
    pub state: AccountInfo<'info>,
    pub msol_mint: Account<'info, token::Mint>,
    pub liq_pool_sol_leg_pda: AccountInfo<'info>,
    pub liq_pool_msol_leg: AccountInfo<'info>,
    pub liq_pool_msol_leg_authority: AccountInfo<'info>,
    pub reserve_pda: AccountInfo<'info>,
    pub transfer_from: Account<'info, token::TokenAccount>,
    pub mint_to: Account<'info, token::TokenAccount>,
    pub msol_mint_authority: AccountInfo<'info>,
    pub system_program: Program<'info, System>,
    pub token_program: Program<'info, token::Token>,
}```
trying to do: `    pub marinade_accounts: MarinadeDeposit<'info>,`
getting an err I dont fully understand:
```
use of undeclared crate or module `__client_accounts_marinade_deposit`rustc(E0432)
lib.rs(311, 10): use of undeclared crate or module `__client_accounts_marinade_deposit`
failed to resolve: use of undeclared crate or module `__client_accounts_marinade_deposit`
```
Can I nest a struct of `#[derive(Accounts)]` inside `#[derive(Accounts)]` struct? I am trying to add accounts to call another program from my on chain program
Trying to use the basic `initialize_mint` function but getting an odd compile time error that doesn't make sense. I am annotating the types as it wants but it is still complaining. Any ideas?
Hey everyone! Can one of you help us validate the approach for our smart contract? New to Solana smart contract dev!

**Context**
We are building a player-vs-player game. Two players put in 1 SOL each - the winner wins 2 SOL and the loser gets nothing. The winner is determined off-chain.

**Our Approach**

1. Call an `initiatilize` endpoint every time a new player joins the game (with the player's signature)

2. The `initiatilize` function (1) creates a token account for the player, (2) transfers funds from the player's wallet to the token account, and (3) sets the PDA as the authority / owner of the token account

3. Once a winner is declared, game calls the function `declare_winner(winner_token_account_address, loser_token_account_address)`

4. The declare-winner function (1) transfers funds from `loser_token_account_address` to `winner_token_account_address` , (2) transfers funds from `winner_token_account_address` to the initializer of that the account (the winner's wallet), and (3) cancels the token accounts
You would have to add an instruction to do the closing, but you can use the `close = who_to_send_the_lamports_to` attribute in the derive(Accounts) struct
i see anchor_spl has a close token account function but im not sure what to use for an anchor struct pda
is there a quick anchor way to close a #[account] pda so i can re-init it later?
Ok this makes sense. I guess i need to find some examples with PDAs to fully understand how those work
So here you're creating the `counter` account, and it lives at a keypair address (as opposed to a program-derived address, which can only be signed for by its deriving program, within the program itself), so you need to explicitly sign for it
Ah, yeah, good/confusing question: the provider.wallet signs automatically, always, because it pays the tx fees. Sometimes you need to sign for additional accounts too though: a common example is when you're creating an account that lives at a keypair address. In solana, whenever you create an account you need to sign for its address (this is just how the system_program works, it prevents you from like squatting on somebody's public key etc.)
ty. One thing i haven't really been able to fully grasp is the signers parameter in the tests. (basic2 - signers: [counter]) Why wouldn't the wallet need to sign if they are the payer? Why is the counter account signing?
thanks
yeah that's what i figured, hm ok, i may be able to pull some stuff out of the struct to help
Yep, sounds like that's just the rent exemption cost. That's about the rent exemption for a 100 bytes of account storage.
Ah, yeah, I think that's kind of just random‚Äîyou're right that if it were always going to be the provider.wallet's key then you wouldn't want to pass it as an argument
i'm looking to run an initialize function that'll create a couple 1000 mint config accounts (1 per mint) - devnet initialize tests are showing around `0.0016704 SOL` transferred to each account. am i looking at `<number of mints> * 0.0016704 SOL` to initialize the configs alone?
in the basic-2 example the create function takes in authority as a pubkey, but this is also the same as the user in the context. what is the point of doing it that way? couldn't you just assign the counter.authority = user.authority? (not trying to askchully gotcha anyone here, just trying to understand)
Nope, totally random (it's a fresh keypair)
what factors determine what a programs programID will be when you do anchor build? ie is it based on the account/signer, and a hash of the program code or something?
nvm just went through :))
anyone else having issues deploying to devnet, getting invalid blockhash error
Sounds good. Ty
Now read the tests in the anchor repo
Good job
Yea
Yes that thing
?
https://book.anchor-lang.com/
wait what do u mean? i am a bit unsure, so if I was to try and send an NFT from 1 account to another, the **to and from addresses** are the associated token account addresses? but how do u actually get the receiving persons ATA?? i have just noticed on spl-token cmd it sometimes prompts to --fund-recipient if they dont already have an associated account i gathered?
But the issue is that if you store a token account at an associated token address, that address is calculated from the ostensible owner/authority of the tokens (plus the mint). So, it's quite surprising to go look for person X's mint M associated token account, only to find that the actual authority over that account is in fact person Y.
Associated token accounts are just kind of the default in general
Ah, good point
i am still heaps noob hey so could be wrong in my understanding
because if u do a transfer doesn't the associated token account have to be created?
why is that?
That said, I would expect NFTs to often be stored in associated token accounts, and you really shouldn't change an associated token account's authority (just do the transfer)
Is it actually cheaper? I've never compared their costs, I would have expected them to be essentially the same
is "set_authority" on the token account that holds the NFT a cheaper version of "transfer" for an NFT/spl-token?
reading more sophisticated example code is a good next step that helped me. you may want to take a look at 
anchor escrow https://github.com/project-serum/anchor/blob/master/tests/escrow/programs/escrow/src/lib.rs re: transferring spl tokens
Have you read the book as well as the tutorials?
after completing the 5 tutorials, what would you all recommend next? I‚Äôm trying to learn how to transfer sol and spl tokens next.
i'm trying to tinker with advanced stuff,
saw the Serum DEX program, sort of event-based with a crank ... still seems like magic to me lol
Hahah makes sense
CPIs are just like calling a function in normal programming, just slightly weirder
Mm, I guess it depends on what you mean by concurrency üòõ Your program would still do its thing, then let the CPI do its thing for a bit, then back to your program (so I guess their executions are interleaved, but in the usual boring vanilla calling-another-function kind of way, nothing like threads)
Can u perhaps simulate concurrency with cpi? :3
On that note, any good technical resources for the solana program execution life-cycle?
No, can't use threads
I know concurrency is a big thing in rust, just wondering if you can open threads and execute stuff in solana,
excuse the stupid answer i still don't understand the program life-cycle well
Not within your rust program (or, what do you mean? What would be an example?)
Or you just think of a big-enough number that doesn't feel too expensive to you
You could do that (sort of, you need an extra 4 bytes since that's how borsh serializes strings: 4 bytes for the length in bytes, followed by the actual bytes)
Can you do concurrency ?!  is it supported? just curious
How does one properly deal with String space size allocation? Calculate the size dynamically somehow to allocate just enough?
That actually worked üòÆ
Mm, what happens if you get rid of those `_` arguments and give them actual names, like `_something`

Even though I defined the instructions:
I am having issues with empty instruction IDL that is generated:
ü•∫


//////////////////////////////////////////////////////////////////////////////////////////

This is maybe more general than you're looking for, but I think you can think of it a lot like a zero-downtime migration in a regular database setup. Redeploying has zero effect on existing accounts (~ rows in the db), so whatever changes you make need to continue to work with any old account structures, etc.
üëã are there any restrictions/best practices on redeploying programs? more specifically, how can we make sure that the new deployed program doesn't introduce any compatibility issues?
gotcha
note that if you click on the badge it will take you to the source
thank you!
yeah, that‚Äôs working now. dependent on the dev publishing ofc
https://twitter.com/solscanofficial/status/1491258622764261378?s=21
hi guys, is there a way for us to see the rust program's source code in like solscan? like in etherscan we can solidity source code
Thanks so much, I have been looking at it since you mentioned, will write here any results.
The issue was that we were creating with a different size than the actual size we need on rust side. So, not giving a size on client solved the problem because js predicted the exact size of we need on backend.
Hey guys! 

I want to pass an array of associated token accounts to have their balances updated. The problem is that the number of elements in this array of ATAs is variable. Meaning I want to keep it flexible how many ATAs can have their balances updated. What's the best way to pass this varying length of ATAs array as a part of accounts to the ix handler, from the client?
<@!916187801115037728> <@!733281043641008239> I think you can use https://github.com/saber-hq/merkle-distributor as example in the part related to generating and verifying merkle proof.
did u find a solution to this, if so could you share what was the issue ?
https://medium.com/crypto-0-nite/merkle-proofs-explained-6dd429623dc5
Hey, <@!290210612947058689>, could you provide some example source about merkle tree proof?
merkle tree proof.
Hello everyone, can anyone please give some suggestion about whitelisting 10k pubkeys (nft list) in a contract? doing a loop over 10k elements always exceeds the computing limit.
Installing from source 1.8.16 fixes this. thanks. üëç
Trying to run this mintTo function now but not sure what the multisig arg should be ? i thought it was optional? but i get Type Errors in my tests. I think its the multisig array because it was saying the length of null is undefined but then i tried an empty array as well to no success ```
    //creates the token
    await mintTo(
      provider.connection,
      fromWallet,
      mintA,
      tokenAddress1.publicKey,
      fromWallet.publicKey,
      1,
      null,
      null,
      TOKEN_PROGRAM_ID);```
Hello, 
I'm trying to create a large account (more than 10kb) and then, update it using anchor / zero_copy.


My pool account data structure is like;
```
#[account(zero_copy)]
pub struct PoolAccount {
    // Pool name
    pub name: [u8; 50],
    // Allowed mint addresses (up to 10k)
    pub nft_allowed_mint_list: [Pubkey; 10000],
    pub starts_at: u64,
    pub ends_at: u64,

    // reward
    pub reward_token_mint: Pubkey,
    pub reward_amount: u64,
    pub reward_vault_nonce: u8,
    pub reward_per_hour: u64,

    // auth
    pub creator: Pubkey,
}
```

This is how I define in the context:
```
 #[account(mut)]
    pub pool_account: AccountLoader<'info, PoolAccount>,
```

And this is how I try to reach in an instruction; (already created by a separate clientside instruction)
```
 let pool_account = &mut ctx.accounts.pool_account.load_mut()?;  // (This is first line in instruction)
```


And at that line, I'm getting this error message when I interact with the contract for this instruction
```
Program log: panicked at 'from_bytes_mut>SizeMismatch', /Users/tfnyldrm/.cargo/registry/src/github.com-1ecc6299db9ec823/bytemuck-1.7.3/src/lib.rs:119:3
```


Anyone familiar with this message and how to fix it?
not 100% sure, I am still pretty new to this but in most cases a PDA can sign on behalf of the contract so you would transfer to that first
but in my case, I need a function to transfer token from program owner to user. Can my program do it automatically without asking for approval?
oh okay
thanks man
ah okay sweet

I think because of TOKEN_PROGRAM_ID because they change signature of the function
``` let mintA = await createMint(
      provider.connection,
      fromWallet,
      fromWallet.publicKey,
      null,
      0,
      TOKEN_PROGRAM_ID
    );````
its regarding the same createMint function
did u see anything like this directly after ```TypeError: Cannot read property 'toString' of undefined
      at Transaction.sign (node_modules/@solana/web3.js/src/transaction.ts:460:36)
      at Connection.sendTransaction (node_modules/@solana/web3.js/src/connection.ts:3886:21)
      at processTicksAndRejections (internal/process/task_queues.js:95:5)
      at sendAndConfirmTransaction (node_modules/@solana/web3.js/src/util/send-and-confirm-transaction.ts:30:21)```
how to check if a signer owns the mint passed in Anchor program?
any one else facing error while typing avm use latest, the upgrade keeps failing due to some spl token compilation errors.
thanks for help man
ahahaha wtf
do not know either. I faced the same problem as you today LOL
and how would i find this for myself? is it documented anywhere
aha ah beautiful wish i asked earlier
There is no Token in @solana/spl-token 0.2.0 anymore. You should import createMint directly `import { createMint } from "@solana/spl-token"`
i think u only need IDL?
I am getting this error in my test code for a solana program, gotta be something heaps beginner but no idea. Tried reinstalling the library but yeh i got no idea? does the method even exist anymore or something? Any help is appreciated: 
```import { TOKEN_PROGRAM_ID, Token } from "@solana/spl-token";```
``` let mintA = await Token.createMint(
      provider.connection,
      fromWallet,
      fromWallet.publicKey,
      null,
      0,
      TOKEN_PROGRAM_ID
    );````

```TypeError: Cannot read property 'createMint' of undefined
      at /home/kali/Desktop/SOLANA/NFTTransfers/tests/NFTTransfers.ts:30:29
      at Generator.next (<anonymous>)
      at fulfilled (tests/NFTTransfers.ts:24:58)
      at processTicksAndRejections (internal/process/task_queues.js:95:5)```
*need
Hello guys. I'm new to anchor and solana and I'm trying to make a ddapp on solana. My question is: Must I put my reactjs front-end in anchor's app folder and push all of them to server or the IDL is all I neef?
Thanks Anan
Hey, <@!823873608878522379>, try `space = 8 + Transaction::size(trans)`
Any idea what I am doing wrong
I am getting this error: TypeError: Blob.encode[data] requires (length 289) Buffer as src
Amazing mouse... Just one more help. Please consider the code below  #[program]
pub mod mysolanaapp {
    use super::*;
    pub fn initialize(ctx: Context<Initialize>, trans: Vec<u8>) -> ProgramResult {
        msg!("Initalization started");
        let my_account = &mut ctx.accounts.my_account;
        msg!("Got my account");
        my_account.transaction = trans;
        Ok(())
    }
}

#[derive(Accounts)]
#[instruction(trans: Vec<u8>)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = Transaction::size(trans))]
    pub my_account: Account<'info, Transaction>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[account]
pub struct Transaction {
    pub transaction: Vec<u8>,
}

impl Transaction {
    pub fn size(trans: Vec<u8>) -> usize {
        4 + trans.len()
    }
}
https://imfeld.dev/writing/starting_with_solana_part04
Cool... Can you please help me with the URL of this code. Really awesome
This is based off a todo list tutorial. Is this what you are looking for?
```
//Create List
#[derive(Accounts)]
#[instruction(name: String, capacity: u16, list_bump: u8)]
pub struct CreateList<'info> {
    #[account(init,
        payer=user,
        space=List::space(&name, capacity),
        seeds=[
            b"list",
            user.to_account_info().key.as_ref(),
            name_seed(&name)
        ],
        bump=list_bump)]
    pub list: Account<'info, List>,
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}


//"List" Data Account fields
#[account]
pub struct List {
    pub owner: Pubkey,
    pub name: String,
    pub bump: u8,
    pub capacity: u16,
    pub lines: Vec<Pubkey>,
}

impl List {
    fn space(name: &str, capacity: u16) -> usize {
        // discriminator + owner pubkey + bump + capacity
        8 + 32 + 1 + 2 +
            // name string
            4 + name.len() +
            // vec of item pubkeys
            4 + (capacity as usize) * std::mem::size_of::<Pubkey>()
    }
}
```
yes
Hi Apollo.. is it a reply for me.
i just leave extra space for it
it starts out as 4 bytes. The 4 bytes just hold the length
Hi Apollo... I have q question for you... How you will init Vault info... like how you will implement size fo Vec<Protocol>
Hi Team. I am using anchor for development. I have taken an Vectot of u8. Now while init I need to provide the size of it. Any idea how I can implement the size of a vector for saving it in an account.
How do I check the space on a struct within my account? I want to make sure that each `Protocol` is the right size in the `protocols` vector:

```#[account]
pub struct VaultInfo {
    pub version: u8,
    pub protocols: Vec<Protocol>, 
    pub creator: Pubkey,
}```
Hey guys, need some help working with creating reserve space at the end of my state object, however I am getting a random IDL error with anchor and cant seam to find away around this? Have put together this base repo with only the code required to reproduce the error. Any help would be much appreceated as ive been stuck on this for days now: https://github.com/utx0/anchor_reserve_idl_error Thanks
https://medium.com/@Arrivant_/how-to-verify-nfts-in-an-anchor-program-a051299acde8
ahh nvm this helped me üôÇ
trying this
From what I understand adding a constraint to the ATA account that the balance > 0 is a good start, but that doesn't verfiy the ATA is owned by the signer.
how to do unit test using anchor?
`.owner` returns a token program on Mint and TokenAccount types
how can I check that a signer owns the token it passes in?
ok so i think i understand what those terms mean, but what exactly is  _bump_seed being set to in this line? (and why?)
https://discord.com/channels/889577356681945098/889702325231427584/939324164890845265
looking into escrow sample code making sure i understand each line... what exactly is happening here?  
let (pda, _bump_seed) = Pubkey::find_program_address(&[ESCROW_PDA_SEED], ctx.program_id);
If you decide to change the structure of that account, it might be nice to store a version number so it's easy in your code to say "ah, hmm, this is a super old v2 account, we're on v19 now so need to update it"
Thank you! Appreciate it.
Run a test validator with `solana-test-validator`
Bump
Aww that is kind of unfortunate üò¶ since the limit is quite small.
Not as far as I know/I doubt it, since the confirmation is supposed to be for the entire transaction
What's the point of adding a `version` variable to an account?
<@!134416332509675520>  Sorry to ping you, but i do believe you helped me the last time around.
Is there a way to basically split the transactions, while still only having a single "frontend confirmation"?
Hey all, just running through the tutorial in the book at https://project-serum.github.io/anchor/tutorials/tutorial-0.html#generating-a-client. When I try to run "node client.js", I get the following error, any thoughts?

throw new Error('failed to get recent blockhash: ' + e);
            ^

Error: failed to get recent blockhash: FetchError: request to http://localhost:8899/ failed, reason: connect ECONNREFUSED 127.0.0.1:8899
Anchor needs to do some stuff at the end of your instruction function. For example, it lets you work with these nice rust structs etc. instead of raw accounts, but at the end of the day you still need to actually persist those structs back into the raw account storage.
what is meant by exit routine? any examples üòÖ
Hey i was in here a lil while ago, looking into how to chain transactions and got that working kinda nicely. But I am running into a transaction too large error.
Is there a neat way to actually get around that? :/
Mm, not totally sure if this is the right way to do it, but something like (random useless example):
```.rs
        for r in ctx.remaining_accounts {
            let hmm = Account::<Owner>::try_from(r)?;
            // do stuff with it
            ...
            // and then remember to call its exit routine
            // so you actually write the changes back out
            // this would happen automagically if you
            // didn't use remaining_accounts
            hmm.exit(ctx.program_id)?;
        }
```
anyway to have multiple programs in 1 anchor project that use different anchor-lang/spl versions? Im getting dep errors
i want to do this with a variable number of accounts
Why do you not want to just pass it as a normal account?
any examples handy?
Mm, yes, though you'd have to make sure that anchor actually writes the discriminator bytes (can't remember what that requires off the top of my head‚Äîway easier to just do it the usual way)
is there a way to do this through the remaining accounts?
You would need to pass that address into the `createMultisig` instruction too, and do another `#[account(zero)]` on top of it.
You never actually init the `ownerA` account, you just allocate its storage. So you never git anchor a chance to set the first 8 bytes of the account storage to be the right `Owner` discriminator bytes.
program log:
```
‚ûú  git:(main) ‚úó cat .anchor/program-logs/5q6Nk8kyxa2Kkc7RSi5eouNDneRQYoyiK6ud28R2m5Uq.serum_multisig.log
Streaming transaction logs mentioning 5q6Nk8kyxa2Kkc7RSi5eouNDneRQYoyiK6ud28R2m5Uq. Confirmed commitment
Transaction executed in slot 2:
  Signature: KZrUBSfmAqP1X6YjtxNksmDJma3qhUohwuieYEpsDR5xggQn9v2WpDJarrm1oD3p6VV7nBoZeBQ2cienvH5Th2d
  Status: Ok
  Log Messages:
    Program 11111111111111111111111111111111 invoke [1]
    Program 11111111111111111111111111111111 success
    Program 11111111111111111111111111111111 invoke [1]
    Program 11111111111111111111111111111111 success
    Program 5q6Nk8kyxa2Kkc7RSi5eouNDneRQYoyiK6ud28R2m5Uq invoke [1]
    Program log: Instruction: CreateMultisig
    Program 5q6Nk8kyxa2Kkc7RSi5eouNDneRQYoyiK6ud28R2m5Uq consumed 3211 of 200000 compute units
    Program 5q6Nk8kyxa2Kkc7RSi5eouNDneRQYoyiK6ud28R2m5Uq success
```
Running into an `Invalid account discriminator here`

```
const multisig = anchor.web3.Keypair.generate();
const [multisigSigner, nonce] =
  await anchor.web3.PublicKey.findProgramAddress(
    [multisig.publicKey.toBuffer()],
    program.programId
  );
const multisigSize = 200; // Big enough.

const ownerA = anchor.web3.Keypair.generate();
const ownerB = anchor.web3.Keypair.generate();

const owners = [ownerA.publicKey, ownerB.publicKey];

const threshold = new anchor.BN(1);
await program.rpc.createMultisig(owners, threshold, nonce, {
  accounts: {
    multisig: multisig.publicKey,
  },
  instructions: [
    await program.account.multisig.createInstruction(
      multisig,
      multisigSize
    ),
    await program.account.owner.createInstruction(
      ownerA,
      multisigSize
    ),
  ],
  signers: [multisig, ownerA],
});

let multisigAccount = await program.account.multisig.fetch(
  multisig.publicKey
);

let ownerAAccount = await program.account.owner.fetch(
  ownerA.publicKey
);

assert(ownerAAccount);
```    
The error  is happenign specifically on `let ownerAAccount = await program.account.owner.fetch(ownerA.publicKey);`. Why is this the case?
I have:

```
 pub fn create_multisig(
    ctx: Context<CreateMultisig>,
    owners: Vec<Pubkey>,
    threshold: u64,
    nonce: u8,
) -> Result<()> {
    assert_unique_owners(&owners)?;
    require!(
        threshold > 0 && threshold <= owners.len() as u64,
        InvalidThreshold
    );
    require!(!owners.is_empty(), InvalidOwnersLen);

    // construct the multisig
    let multisig = &mut ctx.accounts.multisig;
    multisig.owners = owners;
    multisig.threshold = threshold;
    multisig.nonce = nonce;
    multisig.owner_set_seqno = 0;
    Ok(())
}

#[derive(Accounts)]
pub struct CreateMultisig<'info> {
    #[account(zero, signer)]
    multisig: Box<Account<'info, Multisig>>,
}

#[account]
pub struct Multisig {
    pub owners: Vec<Pubkey>,
    pub threshold: u64,
    pub nonce: u8, // this is the nonce we use to find the PDA
    pub owner_set_seqno: u32, // set of owners version #
}

#[account]
pub struct Owner {
    pub multisigs: Vec<Pubkey>,
}
```
Do you know how i can encode and decode a file or a message using the keypair of my wallet ? I search for javascript library or function but i found nothing on this subject
ohhhh
No, unfortunately anchor does support this yet. You'll need to use the `remaining_accounts` feature and handle the deserialization etc. yourself (remainign_accounts are all just AccountInfos)
But you're just rewriting out the data from scratch
Assuming you made sure to allocate enough space, then yeah, when you add things into the protocols vec and the re-serialize the struct back into the account, it just writes everything back out again‚Äîso in effect everything else gets pushed over to make space
where does the next field start, though? In this example, I'm initializing the account with zero `protocols`. So where is the `creator`'s first byte? Is it only 4 after? Then what happens if I add an item to the Vec? Does `creator`'s location get moved?

```#[account]
pub struct MyAccount {
    pub version: u8,
    pub protocols: Vec<OtherAccount>, 
    pub creator: Pubkey,
    pub vault_extra_space: [u8; 256],
}```
Follow up on this - is there any way to pass in a variable number of accounts (all of the same type)? E.g.

```
#[derive(Accounts)]
pub struct CreateMultisig<'info> {
    #[account(zero, signer)]
    multisig: Box<Account<'info, Multisig>>,
    #[account(mut)]
    owners: Vec<Account<'info, Owner>>,
}


#[account]
pub struct Multisig {
    pub owners: Vec<Pubkey>,
    pub threshold: u64,
    pub nonce: u8, // this is the nonce we use to find the PDA
    pub owner_set_seqno: u32, // set of owners version #
}

#[account]
pub struct Owner {
    pub multisigs: Vec<Pubkey>,
}
```
If this is something we can do, what are the restrictions here? Also for some more context: for any multisig, we have a mapping of owners (see `owners: Vec<Pubkey>` on the `Multisig` object) - but I want to create this reverse mapping. The nature of it is that owners:multisig is n:1, so passing in a variable # of accounts on the `#[derive(Accounts)]` obj is what we'd need to do
thx
ah, ok üôÇ i'm already using two different instructions for this but decided to ask about this )
Either don't use init_if_needed at all, and just have two separate instructions, one for when it's already init'd and one for when it's not, or store a flag, `has_already_been_initialized: bool` in the struct, etc.
i think i need to setup default value 0 when it initialized, but i don't know how to do this only on initialization
i have ```#[account(
    init_if_needed,
    payer = user,
    space = 64,
    seeds = [user.key().as_ref(), b"soltery"],
    bump = staker_bump)]
pub staking_info: Account<'info, StakeInfo>,

#[account]
pub struct UserSettings {
    pub staked_amount: u64,
    pub last_changed_date: i64,
    pub pending_tickets: u64,
}``` And i want use this in one method but how i can check that this account initialized first time to increase staked_amount value?
What do you mean? Not sure I understand your question
if i have field with type u64 i can check ctx.accounts.myaccount.myfield == 0 ?
You can however do something like this:
```.rs
*ctx.accounts.that_new_account = ItsStruct::default();
```
Not really, the data starts off with all zeros
Hi! it's possible to define default values for data account if it initialized first time?
Is anyone using regex in a contract?
 `Function _ZN5regex4exec11ExecBuilder5build17h6409425ee0b47b20E Stack offset of 11208 exceeded max offset of 4096 by 7112 bytes, please minimize large stack variables`


// Getting stack size too large when using regex üò¶
```
fn clean_username(username: String) -> String {
    let re = Regex::new(r"\W+").unwrap();
    let result = re.replace_all(&username, "");
    return result.to_string();
}
```
Do you know how i can encode and decode a file or a message using the keypair of my wallet ? I search for javascript library or function but i found nothing on this subject
more detail about the script here https://github.com/glyfo/glyclt-solana/blob/main/glyclt
my question is about declare! public key , what is the best option to replace it ? in automatic mode
Hi , I am using this script to do anchor build inside the container . ```rust
   docker exec -i solanaX /bin/bash -s <<EOF
   export PATH=$_path
   export RUST_BACKTRACE=full
   export ANCHOR_WALLET=$MASTER_WALLET
   home=$(pwd | sed 's#.*/##')
   echo "Proyect:\$home"
   cd /usr/src/\$home
   rm -rf target 
   anchor build
   exit
```
Yeah, the signers array takes in full keypairs
I have another question about signers here:

```
const payer = anchor.web3.Keypair.generate();

await program.rpc.initializeTokenAcct(
      {
        accounts: {
          tokenProgram: splToken.TOKEN_PROGRAM_ID,
          multisigTokenAccount: multisigNFTAccount,
          multisig: multisig.publicKey,
          tokenAcctAuthority: payer.publicKey,
          multisigSigner
        },
        signers: [payer],
      }
    );
```
I'm able to assign payer as a signer in this RPC call. Is that because I have the keypair here? If we only had the `publicKey` would I get an error for trying to set `payer` as signers in this case?
Mm, I'm not sure, there may be some now‚Äîthere's a new version of the spl token js library, I think the type signatures there should explain a lot
Your program gets passed some `&[AccountInfo]`s, and that's it‚Äîno way to load any new ones.
Got it. Is there a guide or relevant functions in managing the associated token accounts?
I think it's helpful to think of this in terms of the lowlevel solana entrypoint signature: https://github.com/solana-labs/example-helloworld/blob/master/src/program-rust/src/lib.rs#L24
That's just how solana's performance model works‚Äîthe client always has to specify every single account of interest, so that the solana runtime can load them all ahead of time/maybe parallelize your tx with others.
> The program can't dynamically look up an associated token account etc.

Why is this the case?
In solana I think it's best to think of there not being much of a separation between client and server, since at the end of the day the client needs to know so much about the addresses/accounts the server expects.
Ah, there's no avoiding approach #2 if I'm understanding you right‚Äîno matter what the client has to specify all relevant accounts. The program can't dynamically look up an associated token account etc.
For example, if we want to do an SPL token transfer, we can structure our program vs. client in a few diff ways. I.e. 

Approach #1:

Program/contract takes the owner's public key as input and then does a search to see if the associated token account exists. If not, create one, then execute the transfer

Approach #2:

Program/contract takes the public key of the associated token account. The client code is responsible for fetching the owner's token accounts and seeing fi the associated token acct exists. 

Approach #1 vs #2 are different based off *where* the code lives to manage the associated token accts given the owner's public key. 

I'm wondering if there are best practices and pitfalls to avoid when structuring your code across programs vs. client code
What do you mean by avoid storing state in program accounts/objects? As opposed to storing it where?


//////////////////////////////////////////////////////////////////////////////////////////

and thx for sharing!
as i heard it will only increase it by a bit though, you still wont be able to run for too long, right?
Any examples of cacheing anchor in github actions?
Sorry for the noob question but whats the diff between the program address that is output by "anchor deploy" vs metadata address that magically appeared in the idl file? I notice the values are different.

I am looking at the https://project-serum.github.io/anchor/tutorials/tutorial-0.html tutorial
<@!826339689195241512> <@!350632015852208140> 
Check out the "Upcoming Changes" section of this doc: https://jstarry.notion.site/Transaction-Fees-f09387e6a8d84287aa16a34ecb58e239#6c4bae9a910641028cc4f3a747be7a6d
hey david
this will be fixed in solana v1.9
yeahh i think devnet is down rip
If yes, could someone help me refer the way?
Question. Is it possible to fetch the IDL without it being verified?
Hey, did u solve it?
any repo which has updated to 0.21.0 or 0.22.0 i could take a look at, wanted to see how people are taking advantages of the new changes and basically implementation etc.
if you find a way to chain more transactions together lmk. let all of us know haha
aight well there's ur answer xD
Yeah I wrote a test and tried it out. Runs out of compute limit after 3 mint calls and 1 transfer üòÖ
just gotta try it out xD
ah actually when you say minting idk
could also be close lol
yh that should go through, but you gotta test it
8 CPIs basically include 7 token minting instructions and 1 token transfer instruction üòÖ
Yes I got same error
8 CPI calls sonuds like quite a bit. if you only create basic token accounts might work, if its juicy endpoints probably not
hey guys, so I'm not sure if devnet is still down, but did anyone ever get this error here? 


``` 
Error: failed to send transaction: Node is behind by 46584 slots
``` 

could be because of devnet being flaky rn
Yeah tried. The program fails and runs out of compute limit after executing 4 CPI calls. 

Looking for suggestions to optimize üôÇ
no idea try it out yourself
<@!347689664855015424> <@!134416332509675520> need urgent help. üôè
Hey guys,

1. What's the MAX number of CPI transfer/mint calls that can be accommodated in an instruction handler?

2. Is it possible to do like 8 CPI calls in a IX handler?
No, that's tied to an `address = ....` constraint
i don't understand your question
Thanks <@!831450660146642974> , its worked and one more, how can i use it for token which is created by spl token program mint 
eg:- ``let pdaTokenAccount = await token.getOrCreateAssociatedAccountInfo(pdaAddress);`` what can i do for  this?
allowOffCurve
let tokenAccount = await Token.getAssociatedTokenAddress(
    ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, tokenMint, authority, **true**);
Hi <@!831450660146642974> and <@!916187801115037728>, I am stuck in creating token account for an PDA address. could you help me with this?,  I check with the solution which is provided by <@!831450660146642974>, that is not available for now. could you please share me some resource to resolve my issue, Thank you.
Error: HTTP status server error (503 Service Unavailable) for url (https://api.devnet.solana.com/)
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.
I'm having some issue with the dev net too
Can someone help üò¶
I'm trying to follow the code in this tutorial: https://hackmd.io/@ironaddicteddog/solana-anchor-escrow#References. But I got the error message: "bump targets should not be provided with init. Please use bump without a target.". What does it mean? This is where the error come from.
Is devnet just slow for everyone else right now, or is it just me? I can't even airdrop tokens to a wallet atm
can I wrap any account in a box? is there a trade-off when storing accounts in a box to speed / security?
https://docs.rs/anchor-lang/0.22.0/anchor_lang/derive.Accounts.html
I'm getting an error or ```Error: 152: An address constraint was violated``` which im assuming is tied to it
what does the has_one constraint in anchor context like so mean?
```
    #[account(mut,
              has_one = market,
              has_one = vault,
              has_one = deposit_note_mint)]
    pub reserve: Loader<'info, Reserve>,
```
Should I call Instruction + invoke, invoke_signed instead of CpiContext in case of the platform that I want to integrate use another version of anchor?
Any ideas on what I can do here?
If I remove the `.clone()` I get the error:

```
cannot move out of `ctx.accounts.multisig` which is behind a mutable reference

move occurs because `ctx.accounts.multisig` has type `std::boxed::Box<anchor_lang::prelude::Account<'_, Multisig>>`, which does not implement the `Copy` traitrustc(E0507)
lib.rs(81, 31): move occurs because `ctx.accounts.multisig` has type `std::boxed::Box<anchor_lang::prelude::Account<'_, Multisig>>`, which does not implement the `Copy` trait
```
The problem I'm running into is the `multisigAccount` at the end of my test ends up not having anything set - it seems like the `create_multisig` didn't work. I suspect this i the case because I'm calling `multisig: ctx.accounts.multisig.clone()` here...
My test looks like:

```
let multisigSize = 200; // Big enough.
    let multisig = anchor.web3.Keypair.generate();
    let [multisigSigner, nonce] =
      await anchor.web3.PublicKey.findProgramAddress(
        [multisig.publicKey.toBuffer()],
        program.programId
      );
    

    const ownerA = anchor.web3.Keypair.generate();
    const ownerB = anchor.web3.Keypair.generate();
    const ownerC = anchor.web3.Keypair.generate();
    const owners = [ownerA.publicKey, ownerB.publicKey, ownerC.publicKey];

    const threshold = new anchor.BN(1);

    await program.rpc.createMultisigNewOwnersMetadata(owners, threshold, nonce, {
      accounts: {
        multisig: multisig.publicKey,
        ownersMetadata: ownerA.publicKey,
      },
      instructions: [
        await program.account.multisig.createInstruction(
          multisig,
          multisigSize
        ),
        await program.account.ownersMetadata.createInstruction(
          ownerA,
          multisigSize
        ),
      ],
      signers: [multisig, ownerA],
    });

    let multisigAccount = await program.account.multisig.fetch(multisig.publicKey);

    assert(multisigAccount);
```
Suppose I have:

```
pub fn create_multisig_new_owners_metadata(
    ctx: Context<CreateMultisigNewOwnersMetadata>,
    owners: Vec<Pubkey>,
    threshold: u64,
    nonce: u8
) -> Result<()> {

    // msg!("ctx.accounts: {:?}", *ctx.accounts);
    
    create_multisig(
        Context::new(
            ctx.program_id,
            &mut CreateMultisig {
                multisig: ctx.accounts.multisig.clone()
            },
            &[],    
            ctx.bumps.clone()
        ),
        owners,
        threshold,
        nonce,
    )?;

    Ok(())
}

pub fn create_multisig(
        ctx: Context<CreateMultisig>,
        owners: Vec<Pubkey>,
        threshold: u64,
        nonce: u8,
    ) -> Result<()> {
        assert_unique_owners(&owners)?;
        require!(
            threshold > 0 && threshold <= owners.len() as u64,
            InvalidThreshold
        );
        require!(!owners.is_empty(), InvalidOwnersLen);

        // construct the multisig
        let multisig = &mut ctx.accounts.multisig;
        multisig.owners = owners;
        multisig.threshold = threshold;
        multisig.nonce = nonce;
        multisig.owner_set_seqno = 0;
        Ok(())
    }

#[derive(Accounts)]
pub struct CreateMultisig<'info> {
    #[account(zero, signer)]
    multisig: Box<Account<'info, Multisig>>,
}

#[derive(Accounts)]
pub struct CreateMultisigNewOwnersMetadata<'info> {
    #[account(zero, signer)]
    multisig: Box<Account<'info, Multisig>>,
    #[account(zero)]
    owners_metadata: Box<Account<'info, OwnersMetadata>>,
}
```
or any tutorials and examples? üò¶
these things make me really confused üò¶ Can you explain more in detailed
You can transfer authority of token account to pda account owner by you program. And invoke_signed any instructions from this pda.
Is there any way a program can hold spl token and how can I get the token from that program?
I guess yes, that NFT would have an token account which then I can get the owner of that token account? but then the balance could be 0 if the owner traded it and their token account still exists
is it possible to get the owner of an NFT if the mint address is passed into the on chain program?
Yeah makes sense, 6 is arbitrary here
So I may be wrong that that's the explanation for limiting stuff to 6 positions etc. ü§î
Transactions have to fit in 1232 bytes, and each account costs at least 32 bytes just to send its pubkey. Given random other stuff in the tx (I'm fuzzy, can't remember), the absolute absolute max is around 30 if I remember right.
What's the rough limitation around number of accounts per tx?
I think in order to check invariants around those accounts you need to pass all of them into instructions ü§î Not actually sure if that's the explanation‚Äîbut it would imply a strict limit, since you just can't fit all that many accounts into a tx üòî
üëã not really an anchor specific question but have noticed a limitation around certain DeFi apps restricting the number of "accounts" you can have (e.g on solend.fi, you can't open more than 6 positions per wallet). Is this related to the limit compute budget (e.g. `consumed 38775 of 200000 compute units` from the program logs)? What is causing the restriction in allowing for ~infinite token accounts?
ü§¶‚Äç‚ôÇÔ∏è
This is kind of a gotcha, but you haven't marked the `owners_metadata` account as mut
thanks man, just found the IDL as well
`program.rpc.transferNft` <- js changes the casing
honestly not really sure how to trace out the naming/setting up of the test scripts like how does the workspace/program/rpc get set up
Getting this error when running my tests: must be really basic issue regarding naming somewhere right? ```TypeError: program.rpc.transfer_nft is not a function``` in my lib.rs i have a function defined as ```pub fn transfer_nft(ctx: Context<TransferNFT>) -> ProgramResult {
        Ok(())
    }```
is using uninitialized authority accountinfo dangerous?
gotcha, thanks alan
```
Transaction executed in slot 3:
  Signature: 4s6nk9BoUBFyBtm8vAq5qGmFg3mKAcudvgPukTPPU7FwzHn2h8Ycgh7AaAZ6rNQMQNzyTQ8jhinVL6a5th7xkCh4
  Status: Ok
  Log Messages:
    Program 11111111111111111111111111111111 invoke [1]
    Program 11111111111111111111111111111111 success
    Program 5q6Nk8kyxa2Kkc7RSi5eouNDneRQYoyiK6ud28R2m5Uq invoke [1]
    Program log: Instruction: CreateOwnersMetadata
    Program log: owners_metadata.multisigs: []
    Program log: owners_metadata.multisigs: [Fss8iTgHY8Y8AcfYDdTiKUXym2Btn3QLDcJrkNgT4vXH]
    Program 5q6Nk8kyxa2Kkc7RSi5eouNDneRQYoyiK6ud28R2m5Uq consumed 16725 of 200000 compute units
    Program 5q6Nk8kyxa2Kkc7RSi5eouNDneRQYoyiK6ud28R2m5Uq success
...
Transaction executed in slot 5:
  Signature: 6mjvbzCaYipUtfyA3MnjZ74KE74iiQvtbpa9cQsB3nusGkztsAuLJiFu4N3MbuSAUaYaTtznZu9QzH1qRUbKSy8
  Status: Ok
  Log Messages:
    Program 5q6Nk8kyxa2Kkc7RSi5eouNDneRQYoyiK6ud28R2m5Uq invoke [1]
    Program log: Instruction: AddToOwnersMetadata
    Program log: owners_metadata.multisigs: [Fss8iTgHY8Y8AcfYDdTiKUXym2Btn3QLDcJrkNgT4vXH]
    Program log: owners_metadata.multisigs: [Fss8iTgHY8Y8AcfYDdTiKUXym2Btn3QLDcJrkNgT4vXH, 7kAto7oM7uMuwhJQRw5RugnBSA4iTFJcTtQY4tDt5Z9C]
    Program log: ctx.accounts.owners_metadata.multisigs: [Fss8iTgHY8Y8AcfYDdTiKUXym2Btn3QLDcJrkNgT4vXH, 7kAto7oM7uMuwhJQRw5RugnBSA4iTFJcTtQY4tDt5Z9C]
    Program 5q6Nk8kyxa2Kkc7RSi5eouNDneRQYoyiK6ud28R2m5Uq consumed 62780 of 200000 compute units
    Program 5q6Nk8kyxa2Kkc7RSi5eouNDneRQYoyiK6ud28R2m5Uq success
```
What's also interesting is the program logs show that it is getting modified properly
Why is it that `ownerAMetadataAccountPostTwo.multisigs` doesn't contain `setTwo.multisig.publicKey`? But `ownerAMetadataAccountPost.multisigs` contains `multisig.publicKey`? The functions to add to the array are literally the same, the only difference between the function calls are the `instructions` arg but that should be fine since the `ownersMetadata` account is already initialized
Calling it like so:

```
await program.rpc.createOwnersMetadata(
  {
    accounts: {
      ownersMetadata: ownerA.publicKey,
      multisig: multisig.publicKey,
      owner: ownerA.publicKey
    },
    instructions: [
      await program.account.ownersMetadata.createInstruction(
        ownerA,
        multisigSize
      ),
    ],
    signers: [ownerA]
  }
)

let ownerAMetadataAccountPost = await program.account.ownersMetadata.fetchNullable(
  ownerA.publicKey
);

let finishedTxn = await program.rpc.addToOwnersMetadata(
  {
    accounts: {
      ownersMetadata: ownerA.publicKey,
      multisig: setTwo.multisig.publicKey,
      owner: ownerA.publicKey
    },
    signers: [ownerA]
  }
);

let ownerAMetadataAccountPostTwo = await program.account.ownersMetadata.fetchNullable(
  ownerA.publicKey
);
```
I have:

```
#[derive(Accounts)]
    pub struct AddToOwnersMetadata<'info> {
    #[account(signer)]
    owners_metadata: Box<Account<'info, OwnersMetadata>>,
    multisig: Box<Account<'info, Multisig>>,
    owner: AccountInfo<'info>
}

#[derive(Accounts)]
pub struct CreateOwnersMetadata<'info> {
    #[account(zero, signer)]
    owners_metadata: Box<Account<'info, OwnersMetadata>>,
    multisig: Box<Account<'info, Multisig>>,
    owner: AccountInfo<'info>
}

#[account]
pub struct OwnersMetadata {
    pub multisigs: Vec<Pubkey>,
}

pub fn create_owners_metadata(
    ctx: Context<CreateOwnersMetadata>
) -> Result<()> {

    let multisig_owners = &ctx.accounts.multisig.owners;

    if multisig_owners.contains(&ctx.accounts.owner.key) { 
        let owners_metadata = &mut ctx.accounts.owners_metadata;
        msg!("owners_metadata.multisigs: {:?}", owners_metadata.multisigs);
        owners_metadata.multisigs.push(ctx.accounts.multisig.key());
        msg!("owners_metadata.multisigs: {:?}", owners_metadata.multisigs);
    } else {
        return Err(ErrorCode::InvalidOwner.into());
    }

    Ok(())
}


pub fn add_to_owners_metadata(
    ctx: Context<AddToOwnersMetadata>
) -> Result<()> {
    let multisig_owners = &ctx.accounts.multisig.owners;

    if multisig_owners.contains(&ctx.accounts.owner.key) { 
        let owners_metadata = &mut ctx.accounts.owners_metadata;
        msg!("owners_metadata.multisigs: {:?}", owners_metadata.multisigs);
        owners_metadata.multisigs.push(ctx.accounts.multisig.key());
        msg!("owners_metadata.multisigs: {:?}", owners_metadata.multisigs);
        msg!("ctx.accounts.owners_metadata.multisigs: {:?}", ctx.accounts.owners_metadata.multisigs);
    } else {
        return Err(ErrorCode::InvalidOwner.into());
    }

    Ok(())
}
```
You *have* to use them if your program needs to sign for an address.
PDAs are totally different kinds of addresses than regular keypair addresses, so their use-cases are just different: https://book.anchor-lang.com/chapter_3/PDAs.html
Probably the easiest way is to just write a test and serialize an instance of the struct, and just check how big it is (think I've posted that example a few times)
<@!134416332509675520> can you help me with this? I have gone through your PDA related answers. Still  confused.
No, BN is only for integers. Can you just use regular numbers?
still anchor.BN?
how do we use float in the new 0.22 from the ts side?
I just want to make sure that I set the right amount of space for `Protocol` . 

I created `pub struct Protocol`, and gave it an attribute `size()`. When I actually `init` the account, I do `1 + 1 + 8 + ... + Protocol::size()`. I want to make sure that `Protocol::size()` is actually correct
How does one decide if the account should be a PDA or non-pda ? 
I want to store a NFT account address, a wallet address and some metadata (configured by the client) on chain. Should I store this in a PDA or non PDA account ?
Also I need to fetch all the accounts  which has the above wallet address stored in them. How can I do this ?
Why do you need to check the space? Not quite sure what you mean
How do I check the space on a struct within my account? I want to make sure that each Protocol is the right size in the protocols vector:

```#[account]
pub struct VaultInfo {
    pub version: u8,
    pub protocols: Vec<Protocol>, 
    pub creator: Pubkey,
}```


//////////////////////////////////////////////////////////////////////////////////////////

Anyone else get this error when they run `anchor test` in devnet?

```================================================================================
Recover the intermediate account's ephemeral keypair file with
`solana-keygen recover` and the following 12-word seed phrase:
================================================================================
furnace arrest argue dress depend twenty more together miracle fault summer park
================================================================================
To resume a deploy, pass the recovered keypair as the
[BUFFER_SIGNER] to `solana program deploy` or `solana write-buffer'.
Or to recover the account's lamports, pass it as the
[BUFFER_ACCOUNT_ADDRESS] argument to `solana program close`.
================================================================================
Error: Custom: Invalid blockhash
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }.```
too hard so i just moved to a different folder
If i have a vault that holds multiple SPL tokens I need to create a vault-authority pda that holds SOL and then derive ATA's from that pda, right?
my program directory looks like this:
target_program
random_program_1
random_program_2

when I call `anchor build` it tries to build everything, but I only want it to build the target_program. My workspace Cargo.toml looks like this:
```
[workspace]
members = [
    "programs/target_program"
]

exclude = [
    "programs/random_program_1",
    "programs/random_program_2"
]
```
When I call `cargo build-bpf` these are ignored. How do i get it to be ignored when building and testing?
anyone?
Hi <@!669837238816735242>, i am also facing some trouble with the PDA to sign a transaction transfer. could able to resolve this, can you please share me the solution. how can i use the pda as authority for the token transfer cpi call?, thanks
hi guys i'm trying to run anchor test on one of the anchor examples, basic_04 in particular.

i'm getting an error 
ReferenceError: describe is not defined @ basic-4.js:4:1

am i missing something?
look like I found something
```
anchor upgrade ./target/deploy/tutorial.so --provider.cluster testnet --program-id DkDLANn2cCG7q557VA5ieicUQQYDnZsexgDrRZgcXRQX
```
Is there an easy way to do that?
Hi, how can upgrade an already deployed anchor program?
I've deployed using `anchor deploy`
Nope, not possible to do any network requests etc. of any kind
Is this functin give a PDA ability to transfer "all token" of the user that it set authority from
can someone tell me the purpose of anchor_spl::token::set_authority?
Is there something like this:

https://docs.chain.link/docs/request-and-receive-data/
for solana?
Let‚Äòs say there is a json with a string on arweave, can I get this string reliably in my rust program somehow?
Is it possible to fetch http/arweave data on the blockchain?
It has money, not just generated sorry, am using from a static keypair.json file.
Is that authority just a fresh keypair? Does it have any money?
yes, 
```
   #[account
    (init_if_needed,
    token::mint=reward_mint,
    token::authority=authority,
    payer=authority
    )]
    pub reward_user_account: Account<'info, TokenAccount>,
```
Who is paying for the creation of the ATA here? The `authority` account?
what I want to be initialized (if it does exist) is `rewardUserAccount`  which I find by `getATAAdress` this is one of Saber library util function, I also am sure that the address is correct becase I minted it manually and checked if that gives me the correct address.
```
let userRewardTokenAddress = await getATAAddress({
            mint: DEVNET_TICKET_PUBKEY,
            owner: usr1Keypair.publicKey,
        })
        console.log("userRewardTokenAddress vault: ", userRewardTokenAddress.toBase58())

        
        const tx = await program.rpc.claim({
            accounts: {
                poolAccount: poolDataAccount.publicKey,
                stakeAccount: stakeDataAccount.publicKey,
                rewardVaultAccount: rewardVaultAccount,
                authority: usr1Keypair.publicKey,
                tokenProgram: TOKEN_PROGRAM_ID,
                rewardMint: DEVNET_TICKET_MINT,
                rewardUserAccount: userRewardTokenAddress,
                systemProgram: anchor.web3.SystemProgram.programId,
                rent: anchor.web3.SYSVAR_RENT_PUBKEY,
            },
            signers: [usr1Keypair]
        });
        console.log("Your claim signature", tx);
    });
```

so , `usr1Keypair` is a simple keypair that just generated.
`Account` is an anchor thing that lets you declare: the client had better pass in a base_account account whose data really does look like the BaseAccount struct, and (in this case), the account had better be owned by my program.
`'info` is a rust lifetime parameter (lots and lots of resources on this if you google it‚Äîit's one of rust's main claims to fame).
Can you post your JS code again?
honestly, not sure yet... its like wrapping decoartors/types fro rust? i think... idk what they are actually called someone in here will know tho and not really 100% what they actually do
``` {
          "name": "authority",
          "isMut": true,
          "isSigner": true
        },```

only authority `isSigner : true` if you meant this and I already send that sign.
What is the "lifetime mismatch" error and how I can solve this problem ? I would like to pass "remaining_account" in picture 2 into "CPIContext"  but it can't compile due to "lifetime mismatch". Can anyone help me solve it  ? üò≠
You can definitely init an associated token address within your program, so not sure why you're getting that signer error (from the client, which is surprising to me)
Check your target/idl/ file for your program; it may help you figure out which account is unexpectedly needing to sign from the client
Hello everyone, Still having same issue and couldn't find a way of creating a token account for the signer. Should I just use a seperate transaction clientside or anyone have solution for it?
Thanks <@!832771976190754846> ... based on what u are saying (focusing on the AddGif)
- AddGif struct alone contains "2" accounts. The 1stof which is **base_account**, and 2nd of wihch is **user**
- base_account has in turn 2 accounts, which is (1) 'info and (2) BaseAccount
- What then, is **Account**, and  '**info** that i have bolded in the code below?

`#[derive(Accounts)]
pub struct AddGif<'info> {
  #[account(mut)]
  pub base_account: *Account*<'*info*, BaseAccount>,
  #[account(mut)]
  pub user: Signer<'info>,
}`

pub base_account: ***Account***<'***info***, BaseAccount>,
```export const getProgramAndProvider = async (
  anchorWallet: anchor.Wallet,
  connection: anchor.web3.Connection,
): Promise<NFTUpgradeAccount> => {
  const provider = new anchor.Provider(connection, anchorWallet, {
    preflightCommitment: 'recent',
  });

  const idl = await anchor.Program.fetchIdl(NFT_UPGRADE_PROGRAM, provider);

  const program = new anchor.Program(idl, NFT_UPGRADE_PROGRAM, provider);

  return {
    program, 
    provider
  };
};```

Any ideas tho guys getting this error still on the frontend, am i missing something stupid?
Seems the idl still doesnt exist or something??

```/**
     * Fetches an idl from the blockchain.
     *
     * In order to use this method, an IDL must have been previously initialized
     * via the anchor CLI's `anchor idl init` command.
     *
     * @param programId The on-chain address of the program.
     * @param provider  The network and wallet context.
     */
    static async fetchIdl(address, provider) {
        provider = provider !== null && provider !== void 0 ? provider : getProvider();
        const programId = translateAddress(address);
        const idlAddr = await idlAddress(programId);
        const accountInfo = await provider.connection.getAccountInfo(idlAddr);
        // Chop off account discriminator.
        let idlAccount = decodeIdlAccount(accountInfo.data.slice(8));
        const inflatedIdl = inflate(idlAccount.data);
        return JSON.parse(utf8.decode(inflatedIdl));
    }```

```TypeError: Cannot read properties of undefined (reading 'getAccountInfo')
    at Function.fetchIdl (index.ts:309:1)
```

Basically saying the IDL can't be found here for some reason?? I have run anchor idl init so not sure what else to try now?
hey dude, just worked this out to answer my own question above^, i assume you haven't run ```anchor idl init -f path/to/idl.json <YOUR_PROGRAM_ID>``` that fixed it for me, seems like you are actually registering the IDL in an account somewhere or something?
so like startstuffoff function takes 3 accounts as arguments, while the AddGif function is taking 2 accounts as args and 1 of those accounts is of type BaseAccount which is the 3rd struct u have defined
from what i understand the ```#[account]``` indicates a single account taht you are defining for storage purposes of data, while the ```#[derive(Accounts)]``` structs are defining input arguments signatures for the functions in your program
```msg 8tvqnQszDVuZVAGWeiXduh9JfmzycnQGgqQZP346zias
msg 8tvqnQszDVuZVAGWeiXduh9JfmzycnQGgqQZP346zias
msg 8tvqnQszDVuZVAGWeiXduh9JfmzycnQGgqQZP346zias
msg 8tvqnQszDVuZVAGWeiXduh9JfmzycnQGgqQZP346zias
Program Id: 75ZsUGwBkzpAwF5wJqTKzZEYKRg25Rnn49GBVXEMPtcu

Deploy success```

```$ anchor idl fetch 75ZsUGwBkzpAwF5wJqTKzZEYKRg25Rnn49GBVXEMPtcu
Error: Account not found```

Can someone please enlighten me?? I am trying to use fetchIdl in the frontend 
as well which is returning nothing, similar to above. I dont really understand wtf 
is going on at this point tho, trying to deploy to devnet
Hi Guys can someone help with some basic questions
1 - how many accounts do i have below?
2 - whats the difference between the Accounts in `#[derive(Accounts)]` and `#[account]`

`#[derive(Accounts)]

pub struct StartStuffOff<'info> {
      #[account(init, payer = user, space = 9000)]
    pub base_account: Account<'info, BaseAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program <'info, System>,
}

#[derive(Accounts)]
pub struct AddGif<'info> {
  #[account(mut)]
  pub base_account: Account<'info, BaseAccount>,
  #[account(mut)]
  pub user: Signer<'info>,
}

#[account]
pub struct BaseAccount {
    pub total_gifs: u64,
    // Attach a Vector of type ItemStruct to the account.
    pub gif_list: Vec<ItemStruct>,
}`
has anyone experience this ?
anchor test or anchor localnet no longer working after upgraded to v0.22.0

<@!326107472098099201> ?
Yea it got left out before release, it‚Äôs updated on master now though
Thanks! I'm assuming the ```anchor init``` command just wasn't updated to use this new syntax
https://github.com/project-serum/anchor/commit/40596824bf85df8c2b3313a677ebbaef559361c9 üò¨
how is this possible when all my accounts are `mut`? ```     Error: 2000: A mut constraint was violated
```
in here?
Probably add the candy-machine to your anchor project programs folder
i guess I'm supposed to replace ProgramResults with Result<()>. Found that in the discord here. Wondering is there a place I could look for documentation around this? I know documentation is limited üò¨
i am running it in the candy-machine dir
Brand new newb question üò±  version 0.22 gives me an error "ProgramResult not found in this scope" when building. Doesn't happy in 0.19. Any thoughts?
docs are great, I learn best by listening to someone who is excited talking about it
paying for anchor/good-posture lessons. come from a .net/python background and diving into rust.
If it‚Äôs raw solana anchor won‚Äôt work
Also doesn‚Äôt look like an anchor project
Hmm but you are not running anchor build in the candy-machine dir?
nothing üò¶

There should be a file in target/idl

No output at all?
Once I have the .json file, I can run this command to generate the idl:
anchor idl init -f <target/idl/program.json> <program-id>
no it just doesnt generate the .json file that I need to build the idl
Not enough info, do you get an error?
can someone please help me with some anchor issues? I am running ```anchor build``` in the candy machine repo to deploy a modified candy machine. However, there is no program.json that is generated, and thus i cannot create an idl. Why is it not generated? For other programs like token-entangler, i see that the program.json is generated. Thank you!
not sure if you can provide the argument from the top
i see it is the same problem
Sorry for that, <@!831450660146642974>. Actually what i want is, I am creating a token mint using spl token program:-
```
let token = await spl.Token.createMint(
        provider.connection,
        tokenAuthority,
        tokenAuthority.publicKey,
        null,
        5,
        spl.TOKEN_PROGRAM_ID
      );
```
Now I am trying to create a token account for this token  which should be associated to my PDA address (not to publ
of  a keypair).  

```let tokenAccount = await token.getOrCreateAssociatedAccountInfo(PDAaddress);```

While trying this , i'm getting an error
```Error: Owner cannot sign: A5a7KT8gJ7QBxrTTEM24gUYQi7pGrMbq1NpAtMYXjKpq```
if such an option doesn't exist which advice could you give me to reduce the size of the **.so** ?
I know that the allocated ProgramData buffer is twice the size of the **.so** file and we can specify a custom value a the deployment stage.
Anyway is there any other strategy to reduce the build size?
Hi, is there a way to reduce the build size of a program. I mean using cargo we can define a release flag to optimized the build is there any similar option with cargo-build-bpf ?
<@!881771727376494693> devnet is down currently
any advice for uploading larger programs? get hit with invalid blockhash error everytime
nvm I just tested a smaller program and it works fine
is devnet down atm?
Is it possible to resolve these CPI imports in VS Code? It compiles/runs fine but would be useful if it could resolve cross-program imports
or is there a better way to do this?
if you wanted to split the lib.rs file into multiple files would you use multiple #[program] ? or a single #[program] and just chain the functions to functions inside the other files?
anyone got any hints for debuging the following error when you have a tone of different accounts getting passed in? ```Transaction simulation failed: Error processing Instruction 0: invalid account data for instruction 
    Program BBjT5U42SuA6FcVZEofPgjAVZahvtWzHaQ8pJHyKkC5T invoke [1]
    Program log: Instruction: AddLiquidity
    Program log: An account's data contents was invalid
    Program BBjT5U42SuA6FcVZEofPgjAVZahvtWzHaQ8pJHyKkC5T consumed 7825 of 200000 compute units
    Program BBjT5U42SuA6FcVZEofPgjAVZahvtWzHaQ8pJHyKkC5T failed: invalid account data for instruction
```
can someone please help me with some anchor issues? I am running ```anchor build``` in the candy machine repo to deploy a modified candy machine. However, there is no program.json that is generated, and thus i cannot create an idl. Why is it not generated? For other programs like token-entangler, i see that the program.json is generated. Thank you!
cool! thanks so much again haha
It has not real semantic effect, purely a hack to save stack space
No, it just sticks some stuff in the heap rather than on the stack (the stack in solana is very small, so you can run out)
Does boxing an account apply and restrictions to using that account or affect security, I don't really understand the tradeoff and what accounts I should be wraping in a Box `<>`
I got one more quick question if thats cool
thank u heaps
Hmm okay yeah I have been using it wrong lol üòÖ
Like, a CPI that changed a TokenAccount's token balance, etc.
You would ordinarily only do it after doing a CPI that altered the account's data
Which is all zeros at this point
reload() says refresh my struct from the underlying AccountInfo's data
I had just set a start timestamp and wantrd the end timestamp to be x amount longer, so I was reloading to borrow the start time and add x, kinda stupid lol
What was the intent there?
Ah, no üôÇ
I guess you cant do that while initializing an account?
I was calling reload on the account in the business logic
nvm I just figured it out
üôÇ
there should be working now
hold up I didnt add tests but will just update it
https://github.com/HappyAwesomePeople/art-token
yeah sorry little clumsy with git, thanks for the help üôÇ
Have to install random stuff, etc.
This doesn't run off the bat
Hey, can you upload a version that's all ready to run, with a package.json etc.?
there is an extra pda (treasury_license ) but I have been trying without it aswell so I know that isnt the troublesome account
https://github.com/HappyAwesomePeople/git-token
sorry for the wait
its not uploaded yet
wait lmao
yeah sure ill post it quickly üôÇ
Can you send me a github link or something?
```
#[account]
#[derive(Default)]
pub struct GalleryLedger {
    bump: u8, //1
    authority: Pubkey, // 32
    current_epoch: u64, //8
    epoch_start: i64, //8
    epoch_end: i64, //8
}
```
How is that GalleryLedger account defined?
Ah, should be better actually without out (so I guess that's not the problem I was wondering about)
Ill try a test validator
no background validator just anchor test
Mm, that's sufficiently weird that I wonder if something else is going on. How are you running your tests? Are you using a running validator in the background, or letting anchor spin them up, etc.?
1 failing
```

  1) art-token
       Create Gallery Ledger!:
     Error: 3002: 8 byte discriminator did not match what was expected
      at Function.parse (node_modules/@project-serum/anchor/src/error.ts:41:14)
      at Object.rpc [as generateGalleryLedger] (node_modules/@project-serum/anchor/src/program/namespace/rpc.ts:32:42)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
```
Mm, where's the error lol
wait holdup maybe this is better
yup thanks so much!
Can you post the full program log? (Lol)
That's definitely a weird error to get with the code above. Are you sure it's not from a different endpoint or something? Is that definitely the code throwing that error?
halfway through this new PDA article in the anchor book and I just want to say its really helpful!
is there a way I can check the 8 byte discriminator of an account I am passing in? It should be zero since it's being initialized right?
I swear I have done the same thing elsewhere and it worked ://
Heyoo keep getting stumped when making PDAs,  getting this error:  8 byte discriminator did not match what was expected

```
#[derive(Accounts)]
#[instruction(gallery_ledger_bump: u8)]
pub struct GenerateGalleryLedger<'info> {
    #[account(init, seeds = [b"gallery_ledger".as_ref()], bump = gallery_ledger_bump, payer=treasury_key)]
    pub gallery_ledger: Account<'info, GalleryLedger>,
    pub treasury_key: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```
---
```
const [galleryLedger, galleryLedgerBump] =
      await anchor.web3.PublicKey.findProgramAddress(
        [Buffer.from("gallery_ledger")],
        program.programId
      );

const tx = await program.rpc.generateGalleryLedger(galleryLedgerBump, {
      accounts: {
        galleryLedger: galleryLedger,
        treasuryKey: program.provider.wallet.publicKey,
        systemProgram: anchor.web3.SystemProgram.programId,
      },
    });
```
is there an easy way to get the Fee for an anchor transaction from the anchor client? The `RpcNamespace` methods seem to only return a TransactionSignature, so I'm not sure how to use `getFeeForMessage` (the alternative I found: `getRecentBlockhashAndContext` is not returning accurate results and is deprecated so I'd really like to use this method).
afaik
you cant create an ATA for another user and have them pay
yes
Doing this on frontend, this would require payer private key.
https://spl.solana.com/token
`const tokenAccount = await getOrCreateAssociatedTokenAccount(
  connection,
  payer,
  mint,
  payer.publicKey
)

console.log(tokenAccount.address.toBase58());
// 7UX2i7SucgLMQcfZ75s3VXmZZY4YRUyJN9X1RgfMoDUi`
I'm trying to have the user create an ATA for themselves
Hello, I am trying to interact with a transfer program I have deployed. How would I send over the amount via a js api function? I am using bs58.encode(1_000_000) and getting the error "Expected Buffer"
found it, and & was out of place
ok, thanks!
<@134416332509675520>  just in case you have a quick tip for it
Yes, you can even make an ATA for another user, this is needed so you can send them tokens.
Anyone know if it's possible to get the program logs from the client side?
The rust error message is just bad unfortunately
You have an error somewhere else, can't tell from that snippet
hi, i'm getting an issue with lifetimes

```
error[E0637]: `&` without an explicit lifetime name cannot be used here
  --> programs/hello/src/lib.rs:15:1
   |
15 | #[program]
   | ^ explicit lifetime name needed here
   |
   = note: this error originates in the attribute macro `program` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0106]: missing lifetime specifier
  --> programs/hello/src/lib.rs:15:1
   |
15 | #[program]
   | ^ expected named lifetime parameter
```

any idea what i'm doing wrong?
I'm trying  to allow a user to claim an `spl-token` to their wallet.

This invariably requires an initialized `Associated Token Account`. 

Can a user initialize an `Associated Token Account` without the authority of the `Mint`  owner? 

i.e sign and pay for the initialization?
Hey! Thanks for sharing this. Understood. That can certainly help execute more CPI calls.
lol solved. I was importing program A to program B from github, not from the path, so it cause errors because on github there's the version with old anchor version
Hi, I'm updating my programs from anchor 0.19.0 to 0.22.0 and now getting these errors 
`the trait anchor_lang::Owner is not implemented for CoinInfo` and
`the trait anchor_lang::AccountDeserialize is not implemented for CoinInfo`
I have this struct on my program
```Rust
#[account]
#[derive(Default)]
pub struct CoinInfo {
    pub orca_price: u64,
    pub coin_gecko_price: u64,
    pub last_update_timestamp: u64,
    pub authority: Pubkey,
    pub symbol: String,
}
```
And when trying to use the struct CoinInfo in another program I get the errors
```Rust
#[derive(Accounts)]
pub struct UpdateCoinPrice<'info> {
    #[account(constraint = switchboard_optimized_feed_account.key() == coin_data.switchboard_optimized_feed_account)]
    switchboard_optimized_feed_account: AccountInfo<'info>,
    #[account(constraint = pyth_price_account.key() == coin_data.pyth_price_account)]
    pyth_price_account: AccountInfo<'info>,
    // struct CoinInfo is imported from delphor-oracle, so the owner MUST be delphor-oracle
    // no need for additional checks
    oracle: Account<'info, CoinInfo>,
    #[account(mut)]
    coin_data: Account<'info, CoinData>,
    payer: Signer<'info>,
    system_program: AccountInfo<'info>,
}
```
Any idea?
jk fixed
i moved some things around and i'm getting an error
```
error: no such subcommand: `build-bpf`
```
when running `anchor test`. how do I solve this?
where should i look to diagnose why an `anchor build` would not generate an idl?

the binary is built w/no issues but no idl is generated in the target folder...havent been able to find any logs
I feel like the program address somehow changed under my feet, but i can't understand how
so i should copy the keypair from the default one in target to my program and Anchor.toml and i should be good going forward?
oh well, i can't explain it
mucho confusing
yet it was only just now that the address changed when i switched to devnet
the existing keypair, which has the new unexpected address, was created on feb 9th, ages ago
cos my program id changed, and i cant find the old keypair
ah ok...
Yeah, at least the first time (the private key is necessary for creating the account that lives at your program_id, but subsequent redeploys actually don't need it‚Äîthey need your program's upgrade authority, which is probably the wallet that did the deploy)
So i must have the private key to deploy to an program address (makes sense).
currently I am handling all this in the frontend but it would be really awesome to check all this through the rust script
Hey! I am having a problem..
m creating user accounts where there is a field for username... now the seeds for the PDA are `seeds = [b"vibe_user", username.as_bytes()]`
but I also want the publickey to be unique along with the username...
so if someone with publickey 1234 has username "qwerty" then that publickey cannot create another user account, and conversely some other public key 6789 cannot use the username "qwerty"

anyway I can do this?
So, when I use `init_if_needed`  with  `payer=authority` where authority is the signer+payer, and I set `token::authority = authority` (which I think that should be the the account owner. I'm getting  ` Signature verification failed`   when I remove `init_if_needed` and create the token account manually, use `mut` instead, it works. and I'm pretty sure that `authority` is the signer
Hello, what is the easiest way of creating an ATA for the signer, I just want to make sure user has the ATA or create it to be able to transfer some funds from program account to there.
I can't remember off the top of my head if there's an option for `anchor deploy` itself
That's the default‚Äîyou can specify a different keypair if you want (try doing `solana program deploy --help`)
so ultimately it's that file that drives it all?
Yep, that's your default keypair (the stuff in Anchor.toml isn't enough information‚Äîyou need an entire keypair, not just the address)
so anchor will always use this address to deploy?  for all envs?
target/deploy/xxx-keypair.json ?
It lives in your `target/` directory, so you'll get a new one if you happen to delete the one in there.
I switched to devnet, and did an anchor test.  Which gave me a whole new program id, ignoring the one in my Anchor.toml and in my program source.
Under what circumstances do i get a new program id?
Hi all
does anybody have any examples of how to create a dockerfile for an anchor project? Kind of new to containerizing things in general and would love some direction.
Hi, not a question but just thought I can give back what I've been asking here. If anyone needs to interact with the `project-serum/multisig` program, I made an minimal anchor example that shows how to do so. I think this might give one more step of understanding CPI's and PDAs. (which I noticed that the book updated üëç ). Thanks to <@!134416332509675520> for the guidance! https://github.com/yasushisakai/multisig-cpi
https://github.com/mark-antony1/jet-vault/commit/9d0821c08761290a0d49606d761331101a40f534
yes!
Can you post the CPI code you're running?
Very unlikely
is it possible that the address constraint error is misclassifying the error?
unless there is some other address constraint i haven't seen
Yeah, seems plausible from the link you sent
does this sound right to you?
its possible I've made a mistake and tracked the wrong IDs but I don't think so
the token id looks like it points to the spl_token program crate which then has the token id i think
i believe the crate ID is the program id which I tracked in that repo and found to be what I'm passing in
in the github link the two constraints are     #[account(address = crate::ID)]
and     #[account(address = token::ID)]
Like, what do you think it should be?
in the logs i print out the addresses
But how are you checking it is what you think it ought to be?
How are you checking that address?
Yes it works! Thanks <@!134416332509675520>  üòÑ
https://github.com/jet-lab/jet-v1/blob/cpi-library/programs/jet/src/instructions/withdraw.rs#L72 are the addresses the CPI i'm making is expecting
Checking
Can you not just do `nft_ata.mint == nft_mint.key()`?
Hi! This may be a dumb question, but how do I validate account data in a constraint in anchor?
`constraint = nft_ata.into_inner().mint == nft_mint.key(),`

```
This gives me a note: this function takes ownership of the receiver self, which moves nft_ata
label: nft_ata moved due to this method call
```

got it, i've checked my addresses i'm passing in and they seem correct, but i'm still getting an address constraint issue
just had to read the docco
Anchor New!! yes found it
Guys a noob question. If I want to create multiple programs should I create them manually inside the programs folder or do I need to run an anchor command to generate them for me?
Why am I getting `Transaction simulation failed: Blockhash not found ` on localnet?
does the `createAssociatedTokenAccountInstruction` fail if the address exists already?
also, any idea why I could be getting a 

`Transaction simulation failed: Error processing Instruction 3: custom program error: 0x0` when running the create associated token account?

```
Token.createAssociatedTokenAccountInstruction(
            ASSOCIATED_TOKEN_PROGRAM_ID,
            TOKEN_PROGRAM_ID,
            mint,
            address,
            owner,
            wallet.publicKey
        ) 
``` 

I do have 0.8 SOL in my wallet ü§∑‚Äç‚ôÇÔ∏è
you can call a program to request more compute


//////////////////////////////////////////////////////////////////////////////////////////

thanx!
So you'd just check for an exception
Ah, there's no chai-specific anchor stuff, just pure chai
Hardhat used to select packages for me ü§™
I think my problem is just that the current chai package I installed doesnt have the to.be.reverted instruction
exactly
So you just want to catch an exception in chai?
Ah‚Äîjust a failed transaction üôÇ
Sorry, I'm coming from Ethereum like development. How is it called in solana when a transaction fails?
What do you mean by revert?
Hi! does anyone know the syntax for testing a revert with anchor/chai?
sadge. thx tho! üôÇ
Nope, that's what a transaction is for üôÇ
is there any way to make a number of instructions atomic, without chaining them together in one transaction?
Upgrade your anchor cli too
Hey, 
In the test file... can't seem to find a way to get the SOL balance of an account.... Can anyone help me out with this ?
is that mean there are something wrong with the idl?
Hi I was trying to make an simple rpc call from js client and I got error from client side saying r.send is not a function
Ah just saw the `anchor-ts` channel
I update anchor-lang and anchor-spl to v0.22.0. Which is said "support float type" but problem still not solved üò¶
How do i send enum when i'm testing via the `program.rpc` in typesript? 

```rust
#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub enum Outcome {
    Heads,
    Tails
}

```
tkss
and if it is already possible, where can I learn more about it?
is it already possible to make transaction longer/bigger (i.e. devnet), or is this still something in progress?
avoid the fact that is replying an error on line 34, i just added that **provider** constant in order to see if the program creation wass succesfully done, but no it didn't. Before that, it was showing the same error but pointing at line 41
Does anyone know, why im getting this error about the Provider? Initially i didn't need the provider when creating a new Program (i made it before and the rpc calls based on the idl pass without any problem), but now im getting this error when creating a new Program. Any ideas?
Arbitrarily big integers (not decimals)
How to use float number üò¶
can someone tell me what anchor.BN do?
Oh problem solved now. I got lucky haha :))
It said that javascript heap out of memory üò¶

I solved that by providing the bump. But new error come üò¶
You might need to mark the creator account as `#[account(mut, signer)]`, since it's paying
Can you post the full program log? That's just the summary
And it return this error
This is what I'm doing now
In this Pda account, what should I put as seeds in ts test?
Thank youuu ‚ù§Ô∏è solved my problem üòç
```rs
#[derive(Default)]
[account]
pub struct ProjectIdoPool
```
Possible with anchor to send a generic CPI call without pre-defining the target smart contract?
I dont understand this error. Can someone help :9
this is the idl json, i'm trying to check, account.dataList.length === 2, but I get the error: Property 'length' does not exist on type 'unknown'.
const account: TypeDef<{
    name: "baseAccount";
    type: {
        kind: "struct";
        fields: [{
            name: "data";
            type: "string";
        }, {
            name: "dataList";
            type: {
                vec: "string";
            };
        }];
    };
}
does typescript support the type vec?  or rather, how would I access or get the length of a vec from the idl.
this is the error messages

What is wrong with this code? I want ido_token_payment to store a vector.
oh yeahh! I forgot it. tksss
Isn‚Äôt the user who initiated the transaction?
hello. Can someone tell me who will pay when a transaction is sign by a pda?
Some one told me that Anchor generates client automatically from IDL. for now i'm seeking that how it is possible.
notice I am a noob yet, the code to interact with the program you have to write it, for example, the tests are code that you program and in which you interact with the logic of the Solana program in JS/TS, as you can do in the backend of your app
[cannot find attribute `[error_code]` in this scope] why I could get this error using the macro?
ü¶Ä ü¶Ä ü¶Ä **HELP**ü¶Ä ü¶Ä ü¶Ä 
Does Anchor automatically Generates Client code for Solana program or we have to write manually code to interact with Solana program? <@!448034961652449283> <@!347689664855015424>
like it is done in the `solend_refresh_obligation` function
specify the lifetimes explicitly
I'm trying to deposit a token into a pool. This is my instruction
```rs
    pub fn deposit(ctx: Context<CreateDeposit>, _pool_name: String, amount: u64) -> ProgramResult {
        let cpi_accounts = Transfer {
            from: ctx.accounts.authority_usdc_account.to_account_info(),
            to: ctx.accounts.pool_usdc.to_account_info(),
            authority: ctx.accounts.signer.to_account_info(),
        };
        let cpi_program = ctx.accounts.token_program.to_account_info();
        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
        token::transfer(cpi_ctx, amount)?;
        let pool_account = &mut ctx.accounts.pool_account;
        pool_account.num_tokens += amount;

        Ok(())
    }
```

And I'm doing it on a test

```js
  it('Deposits some USDC from the wallet\'s account into the Pool', async () => {
    const amountToDeposit = new anchor.BN("50");
    program.rpc.deposit(amountToDeposit, {
      accounts: {
        usdcMint: usdcMint.publicKey,
        poolAccount: poolAccount,
        poolUsdc,
        authorityUsdcAccount,
        signer: provider.wallet.publicKey,
        tokenProgram: TOKEN_PROGRAM_ID,
      },
      signers: [authorityUsdcAccount, poolAccount]
    })

    // check that the account has the right balance for the token
    const balanceInAccount = await provider.connection.getTokenAccountBalance(authorityUsdcAccount);
    console.log(balanceInAccount.value.amount);

    // assert.equal(balanceInAccount.value.amount, new anchor.BN("50"));
  });
```

There are no errors, but the `balanceInAccount` has the original balance, and not 50 less as I would expect.
Why do you want to do it? Boxing normal accounts is possible: https://github.com/project-serum/anchor/blob/master/tests/ido-pool/programs/ido-pool/src/lib.rs#L325
Hello, can multiple PDAs share a same seeds?
Hey, can someone tell me what is the vulnerability caused by `init_if_needed`?
ok makes sense, thanks for the answer!
It's kind of just a random rust thing, a "lifetime annotation". You can call it whatever you want, like `'foo`. It's usually called `info` because under the hood it will end up matching up with the lifetime annotation on the low-level solana AccountInfos that come in with the transaction.
can someone explain what the 'info' part is when we define accounts in the #[derive(Accounts)] macro?

eg for this example from the docs:

`#[derive(Accounts)]
pub struct Update<'info> {
    #[account(mut)]
    pub my_account: Account<'info, MyAccount>,
}`

what does the 'info' part mean in the struct definition, and in the my_account definition
anyone help me please üò≠
I am looking for React/Anchor expert for connecting to smart contract, if you are, DM
When using `anchor test` against localnet, I am hitting an issue of fluctuating transaction fees. I know that Solana's design includes dynamic adjustment of fees, but even if I use `getFeeForMessage`, I always receive `5000` lamports per signature. After sending the transaction however, the fee is off by about 20-40 lamports. I have verified in the Program itself and from the client that the transaction fee being charged is between 5010 and 5040 usually, and is rarely 5000 exactly (seems to be only when it is the first run in a while). Is this expected behavior when running the single local validator, or is there another way I should be checking the fee? How do folks test that the balances of accounts change by the appropriate amount if the fee cannot be accurately predicted?
Thanks very much for your help. And <@!134416332509675520>
gotcha
yea
What is that second one?  The account that holds the program itself?
`[test.validator]
url = "devnet"
[[test.validator.clone]]
address = "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"
[[test.validator.clone]]
address = "PwDiXFxQsGra4sFFTT8r1QWRMd4vfumiWC1jfWNfdYT"`
ah adding the other account seems to make progress...at least..im getting a different error now üôÇ
npnp
Thanks, a lot!
you probably need to also clone that data account
I get the same data returned by the rpc call with and without running the validator with --clone
i think you want to checkout `connection.getTokenBalance`
I'm trying to mint a token, and then check that the account balance is correct.
```ts
    const tx = await mintTo(
      provider,
      usdcMint.publicKey,
      provider.wallet.publicKey,
      tokenAccount,
      new anchor.BN("100"),
    );
    const accreditedAccount = await getTokenAccount(provider, tokenAccount);
    assert.ok(accreditedAccount.amount(new anchor.BN("100")));
```

It fails 
```
     TypeError: Cannot read properties of undefined (reading 'fromBuffer')
      at parseTokenAccount (node_modules/@project-serum/common/src/index.ts:221:28)
      at Object.getTokenAccount (node_modules/@project-serum/common/src/index.ts:214:10)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
```
Is this indicating success?   the program should be large no?
it's a cpi call to the token meta program im trying to do
that's fine
that bpf-program arg is my program
aka [programs.localnet]
having the wrong arg for --bpf-program would also cause that error i think
i can do ` solana-test-validator --clone metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s --url m` and then this: https://gist.github.com/tomlinton/9f63405db0d19a6aebbabd69ab60fa0d
it may be unrelated to the clone bit
`[2022-02-25T00:01:26.660495771Z INFO  solana_test_validator] solana-validator 1.9.1 (src:b66e2ae3; feat:4100269022)
[2022-02-25T00:01:26.660506440Z INFO  solana_test_validator] Starting validator with: ArgsOs {
        inner: [
            "solana-test-validator",
            "--ledger",
            ".anchor/test-ledger",
            "--mint",
            "H7jhMmPhTn6KcyrBcDZB6ewwsBfLELwGhsiaxi4hjYMr",
            "--bpf-program",
            "Emffmf7LnCget7zyBhvoQaKVZVMHR3ShKW579YYG5swr",
            "/home/mattbraz/Coding/repos/tryagain/target/deploy/tryagain.so",
            "--bind-address",
            "0.0.0.0",
            "--clone",
            "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s",
            "--rpc-port",
            "8899",
            "--url",
            "https://api.mainnet-beta.solana.com",
        ],
    }
`
tried this too:
the address does exist on devnet
It'll run quick if it doesn't exist on devnet
Looks like you are passing a mainnet url to the validator but from the args you can see its passing devnet as the url
Copying the program account should take some time no?  The whole thing runs in under a second
but nothing related after that
Is that a devnet address?
`[2022-02-25T00:01:26.708402530Z INFO  solana_test_validator] Fetching metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s over RPC...
`
i also see this
`            "--bind-address",
            "0.0.0.0",
            "--clone",
            "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s",
            "--rpc-port",
            "8899",
            "--url",
            "devnet",
        ],
    }
`
I do see the clone in the validator log
ok i was getting: `Account metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s is not executable`
Now i'm getting: `Transaction simulation failed: Attempt to load a program that does not exist `
I'm not sure the reason, but I think this is a known and unsolved issue https://github.com/project-serum/anchor/issues/675
In a future line, I do `program.idl` and get this error -> ```TypeError: Cannot read properties of undefined (reading 'idl')````
Basically, program is undefined
Will post the program log in one sec.. üòâ
`const program = anchor.workspace.Solendcpi as anchor.Program<Solendcpi>;`

Question: Why isn't this working when I do `anchor test --skip-deploy`?
Ah, shoot, looks like it requires version 0.21.0
are there any good example?
Hi everyone
I have a question
How can I get Colateral value and borrowed value and Net APR in Anchor borrwoed?
`[programs.localnet]
tryagain = "Emffmf7LnCget7zyBhvoQaKVZVMHR3ShKW579YYG5swr"

[registry]
url = "https://anchor.projectserum.com"

[provider]
cluster = "localnet"
wallet = "/home/mattbraz/.config/solana/id.json"

[scripts]
test = "yarn run mocha -t 1000000 tests/"

[test.validator]
url = "https://api.mainnet-beta.solana.com"
[[test.validator.clone]]
address = "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"
`
my Anchor.toml looks like this:
nope still nothing
Ah, what if you use an actual url in that Anchor.toml syntax, like `url = "https://api.mainnet-beta.solana.com"`
it does not
Check your `.anchor/test-ledger/validator.log`, right at the very top, and see if you see a `--clone` argument
anchor-cli 0.20.1
nothing in the cli output about the deployment
Mm, what version of anchor are you using?
cos it's not working
and anchor will copy those accounts from devnet when i run anchor test?
Should i be able to just drop those lines into my Anchor.toml?
```const program = anchor.workspace.Solendcpi as Program<Solendcpi>;```
anchor.workspace doesn't have my program "Solendcpi" it seems
When I run `anchor test --skip-deploy`, I get this error:

```TypeError: Cannot read properties of undefined (reading 'provider')
    at Object.<anonymous> (~/Desktop/accrue/accrue/tests/general/utils.ts:18:28)
    at Module._compile (node:internal/modules/cjs/loader:1101:14)
    at Module.m._compile (~/Desktop/accrue/accrue/node_modules/ts-node/src/index.ts:439:23)
    at Module._extensions..js (node:internal/modules/cjs/loader:1153:10)
    at Object.require.extensions.<computed> [as .ts] (~/Desktop/accrue/accrue/node_modules/ts-node/src/index.ts:442:12)```
unless I share both now and delete just after?
how i can use u8 instruction for seed contstraint? compiler says that it want &u8 but instruction - u8
could I share this in a private space and delete that?
thanks!
I am not technically allowed to post publicky
I changed the thing
The rust code above expects a single argument, not 4
I'm confused by that `createProposal` call, it doesn't have the same signature as the rust code above
JS code
Yeah need the JS
Rust
Can you post/repost the syntax you're using?
I do an Transaction instruction then I put it in u8Array wich length is 447
How difficult would it be to make that kind of oracle, and well this would propably not be an established one so only I would be running a node, do i need to be a validator node for that?
That's a JS error, how big is the data you're trying to encode? How many bytes?
hello people, I'm getting mad, 
I've tried a lot of things but I keep on having the same error over again : `TypeError: Blob.encode[data] requires (length 447) Buffer as src`

what is the root of this kind of error? the size of account?
Yep‚Äîthis is in fact why oracles exist
So an oracle is needed
You have zero network access whatsoever
ah shit
What's the point of doing that, if you don't have access to TCP/IP at all?
You can use this Anchor.toml feature: https://discord.com/channels/889577356681945098/889702325231427584/943483106852212766
If I were to create my own implementation of the reqwests library in rust that just interacts with the TCP/IP stack
Not sure what you mean?
Even if I would create a library from scratch and I am sure the response is the same one every time?
101% not possible, no
Is it 100% not possible at all?
hey guys, can i have an optional account?
fixed
which lifetime want #[program]?
is cloning straight forward?  Anchor spins up a new validator each time for localnet, would i have to clone it each time?
like there is for token and assoc_token
by the way, is it correct that there is no anchor cpi wrapper thingy for the spl_token_metadata program yet?
i have not cloned it
ahh ok
Have you cloned that account from mainnet etc.? I don't think it exists on localnet by default
hello guys, i have started a new program and don't understand error ```18 | #[program]
   | ^ expected named lifetime parameter```
`    #[account(address = spl_token_metadata::id())]
    pub token_metadata_program: AccountInfo<'info>,
`
which i am having to pass in the context like this:
it's the spl_token_metadata program
`Account metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s is not executable`    <-- This should be executable on localnet right?
but for user atas then yes users should pay for those
well the vault atas should be paid for by the vault or the creator of the vault
Ok, so you don't want the user to have to pay for those etc.
creating ATAs, updating vault data
Which ones?
so it can pay for operations
I see that there's a section for idl in the Anchor API. However, I've yet to see this filled. Is this meant to be filled or are you supposed to use something like anchor.Program.fetchIdl?
Why do you need that pda to hold sol?
Im pretty sure It's because we upgraded our solana cli
ive been getting it all week LOL
I was getting that a lot yesterday.  Just kept retrying eventually it works.  Assumed it was temporary network issues.
npnp
Thank you!
should show all the msg! macro calls
Im afk, would test myself otherwise but do I need to include the message in the ProgramError itself? Or does throwing any error show me all of the msg! macro output for the program?
i think u have to throw an error to see the msg macro infos
How can I see the `msg!` macro output from the test validator when running `anchor test`? I am not running the validator separately but am having trouble debugging from rustland without seeing the stdout output
or perhaps I should just copy the programs/structs without that declared id, eh?
if i'm copying some code from another open source program, should I (and if so how do I) change the declared id?
does anyone have any examples of calling the swap function on raydium/orca from within a anchor contract?


//////////////////////////////////////////////////////////////////////////////////////////

thank you that worked!
You have v9.2.0 installed, but the package.json in examples/tutorials mentions ^9.1.3, so my guess is you installed mocha globally on your own? Instead go to `examples/tutorial` and run `yarn install`, then it should be available to `anchor test`
Hi Guys, i'm running "anchor test" on anchor basic-0 example, and getting the error in the screenshot Command "mocha" not found. . I have mocha installed. Any idea? Not been able to find any help on google or the yarnpkg link provided by the info output
thanks!
It finally worked. You were right, no need to pass the logged wallet as signer. Actually I didn't need the workaround in that article, it just worked with the rpc call
why not. It is just a public interface of your program. You can't consider your contract public API as something private.
should I push idl to github?
The provider.wallet signs the tx automatically, no need to add it to that signers array
In that github post, adding `provider.wallet` to the signers array doesn't make sense/isn't necessary (you can only add Keypairs to that array, and the provider.wallet isn't a keypair)
Gm fam! I'm quite stuck with the "TypeError: unexpected type, use Uint8Array" trying to send a transaction. I've followed https://github.com/project-serum/anchor/issues/1109 but still get  the same error on "tx.sign(wallet);" so I may be doing something else wrong. Any tip? Thanks in advance!
i think i've fixed thx!
Can you post a code snippet of it?
same
Try using `author_account`  (or whichever name you are using for the account) instead of `author_account_bump` in the `get` function.
I want to pass a vector of ProjectTokenPayment (struct of timestamp and amount) to program function. How can I do that with anchor and ts? The type of that argiment in my test file is type: { vec: { defined: "ProjectTokenPayment"; }
Hi! According to this changelog https://github.com/project-serum/anchor/blob/master/CHANGELOG.md we can't provide the bump target with init now and its recommend to store the bump on account, but how to store on that the target? With _bump = *ctx.bumps.get(author_account_bump).unwrap(); ? It gets error too
Hello, why this function required u64 :(. How to transfer token with amount of f64 type?
in the Anchor.toml
just overwrite the `target/deploy/[program_name]-keypair.json` and replace the `declare_id` in the lib.rs &
 ```
[programs.localnet]
program_name = UPDATEHERE
```
Hey guys Im struggling to think of a good way to check that the signer doesn't own a provided NFT, I was thinking maybe:

```
pub nft_mint: Account<'info, Mint>,
    #[account(
        constraint = nft_ata.owner == payer.key(),
        constraint = nft_ata.mint == nft_mint.key(),
        constraint = nft_ata.amount == 0
    )]
    pub nft_ata: Account<'info, TokenAccount>,
    pub payer: Signer<'info>,

```
but this expects the account to be initialized,
I could just use init if needed but that is a waste of SOL (you cant close an account in the same transaction as initing it guess?) I don't really want users to have to sign a second transaction to claim that sol back as this is intended to be a regularly used function :))) would appreciate any ideas
I changed the "authority" to a different keypair and now idk how to update
how do I generate a new keypair for an anchor program?
The template update just got left out of the release
hmm why is this ? Why would anchor give an example program that doesn't compile ?

Excuse my ignorance.

Also, for #1, it seems like this message appears on every anchor command I run.
Replace ProgramResult with Result<()>

Hello everyone. I am new here. Started with anchor development today but running into a few issues.

1. Using MacOS, I had to build from scratch ; however, there is an issue where my terminal shows the error `Only x86_64 / Linux distributed in NPM package right now.
Trying globally installed anchor.` , which is odd because my anchor cli is installed and *working*.

edit: issue 1 is just annoying, not really code breaking [ i don't think at least ]

2. I tried to init a new project and run `anchor build`, but for some reason i am getting the error that `ProgramResult is not found in this scope`.

I am not sure if issues 1 and issues 2 are related, but for reference I was following the following guide ( apart from having a different wallet setup ). : https://dev.to/dabit3/the-complete-guide-to-full-stack-solana-development-with-react-anchor-rust-and-phantom-3291
Error redesign is 0.22.0 except template fix for Result<()>
Seems so
So error redesign is in master but not 0.22.0?
Might be nice if it handled master
Avm only deals with tags on GitHub
The template change is in master but not in an official release
N/m. Found it https://book.anchor-lang.com/chapter_2/installation.html
which doesn't include the latest updates? Noob question, how do i get the latest?
But it seems avm use latest only installs up to anchor-cli 0.22.0
Oh, I mean the tutorial is updated, but I think we have to update anchor
Milestone project still uses Result(<>)
Makes sense. The tutorial in the Anchor Book is outdated in that case
Yep yep
In other words, we have to update anchor
Me too. Noob question guys, does this have to do with https://github.com/project-serum/anchor/pull/1462#issuecomment-1046377488 ?
You must be on an older version of anchor... 
Instead of `[error_code]` switch to `[error]` once and try
<@!134416332509675520> never mind, was just an issue with my NPM cache. The reverse of what I said was actually introduced since 17.0. Sorry for the confusion, no further help is needed.   https://github.com/project-serum/anchor/commit/73f046e0a574628fdcd6001362e0870df81ce619#diff-0e2c48e520eafaabcd0d9de371c7d2e74f5bbb4eba766216bb24efb265c0e5c3
in ido-pool examples they use Box for all account
I have another question: when we should use Box for our account?
when referencing an anchor program which tests fine
im trying to use the anchor-client crate but am getting ```
error[E0277]: the trait bound `Pubkey: BorshDeserialize` is not satisfied
yes that solved my problem. thank you ‚ù§Ô∏è
Hi, where can I find doccumentation regarding the `#[instruction(...)]` macro?
is there a type to represent time or a timestamp in solana?
Can you point me to that source? I don't see where it changed ü§î
and I'm getting cluster-version to 1.9.9 although my local solana is 1.8.14 <:pepeThink:844646497911046164>
edit: still returning 1.9.9 but local solana at 1.8.16 works
What's the current cluster-version? Did a reinstall on my mbp to use Darwin
hey guys, I just upgraded to the latest version of anchor and the `async all()` method no longer accepts program filter[]

NEW: `async all(filter?: Buffer): Promise<ProgramAccount<any>[]> `
OLD:  `async all(filters?: Buffer | GetProgramAccountsFilter[]): Promise<ProgramAccount<T>[]> `
The OLD one is more flexible and allows to multiple filters at any offsets, the NEW one only accepts a single filter starting from offset 0. Any context on this change ?
This is great, i've got this working now, thanks very much.
You get the log when it fails, but i assume it can be grabbed when the program succeeds too, which would be useful for debugging.
While i have you, any idea how to get the program log from the js client?
cheers
ok, i see a few usages in the tests in anchor.
Yep üëç
These are accounts passed, but not explicitly mentioned in the Context struct?
In anchor you'd have to use the `remaining_accounts` feature
Not possible to make an AccountInfo within your rust program (well, it's "possible" but it doesn't do what you want‚Äîin solana *all* accounts of interest have to be passed in from the client)
Anyone know how i can send lamports to an arbitrary number of accounts?  For example if i get a vec of Pubkey, can I create an AccountInfo for those and make a transfer ix for each?   I cant find a way to make an AccountInfo in the body of the program, implying i need to have the accounts in the Context, or can the AccountInfos be passed as regular params?
i think i pointed you in the right direction on this, the repo you showed me was not an anchor project, you can do this `git clone https://github.com/metaplex-foundation/metaplex-program-library && cd metaplex-program-library && anchor idl parse --file candy-machine/program/src/lib.rs`
can someone please help me with some anchor issues? I am running ```anchor build``` in the candy machine repo to deploy a modified candy machine. However, there is no program.json that is generated, and thus i cannot create an idl. Why is it not generated? For other programs like token-entangler, i see that the program.json is generated. Thank you!


//////////////////////////////////////////////////////////////////////////////////////////

Hello!

i'm getting this issue `     Error: 4100: The declared program id does not match the actual program id` any idea what is causing this?
anchor_lang::emit
refactor your code such that the logic for the signing of the mintTo ix happens inside instruction logic and then just sign with the pda seeds from within the ix
only a program can sign on behalf of a PDA, you can't do it from a client afaik
i appreciate this. i haven't gotten to that error bc I'm running into one which requires me to copy over a program and a few mints from mainnet
How do I sign `mintTo` with my PDA using `"@solana/spl-token": "^0.2.0",`?
correct. currently it has to be an account
I dont think this can work. youre using seeds as well as `associated_token` constraints. an associated token account is already derived and the `associated_token` constraint checks the seeds. plus the seeds youre providing are wrong for an ATA (but again, you dont have to provide them for ATAs in the first place)
or, where can I pass in `-c, -u` arguments to `solana-test-validator`
Okay, I have a set of accounts i cloned over from mainnet onto a local test-ledger. When I run anchor test tho, it seems to spin up it's own test ledger. how can I have anchor use a diff test-ledger?
it works üòÑ
apparently might need to put some accts in heap -- lemme try it out
along with this
I should mention I get 
```
Program failed to complete: Access violation in stack frame 3 at address 0x200003760 of size 8 by instruction #15612
```
as well
looking forward to StackExchange, haha
Is there a "common errors" page? don't know what to do about this

```
 Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Program failed to complete
```
I feel like i need to pass in the bump somehow to mintTo but I dont see a way to do that
I am a bit confused with the new funcs regarding the spl-token typescript lib:

```
const tokenSwapAccount = new anchor.web3.Account();

    const [tokenSwapAccountAuthority, tokenSwapAccountAuthorityBump] =
      await anchor.web3.PublicKey.findProgramAddress(
        [tokenSwapAccount.publicKey.toBuffer()],
        tokenSwap.TOKEN_SWAP_PROGRAM_ID
      );

    // create pool mint, token A & B mints

    const tokenPoolMint = await spl.createMint(
      program.provider.connection,
      payer,
      tokenSwapAccountAuthority,
      null,
      2
    );
    console.log("created pool mint");
```

^ create mint with authority as mint authority

```
const swapPoolMintTokenAccount =
      await spl.getOrCreateAssociatedTokenAccount(
        program.provider.connection,
        payer,
        tokenPoolMint,
        tokenSwapAccountAuthority,
        true
      );
```
^ create token account with same authority

```
 await spl.mintTo(
      program.provider.connection,
      payer,
      tokenPoolMint,
      swapPoolMintTokenAccount.address,
      tokenSwapAccountAuthority,
      100
    );
```
^ try to mint 100 tokens to the token account and I get a `Signature verification failed` .. cant figure out why though. Maybe I have been looking at it too long
nice, it worked üòÑ
Yep!
I'm an anchor bby. just to clarify, you are saying I do something like this

```rust
  #[account(address=mint)]
  pub token_a_mint: Account<'info, Mint>
```
and  then pass `token_a_mint ` into  `associated_token::mint = token_a_mint`?
Not as an instruction argument
You just pass it as a regular account, yeah
ah... so then how do I pass in that account as an arg?
Ah, I think this is maybe a bug in anchor, can't remember, but I think that `associated_token::mint` constraint has to have an actual mint account on the right hand side, not just a pubkey (it should work with a pubkey, but I don't think it actually does currently)
```rust
    /// Account that stores token A
    #[account(
        init, 
        associated_token::mint = mint,
        associated_token::authority = vault_authority,
        seeds = [VAULT_TOKENA_SEED.as_bytes(), vault_name.as_bytes()],
        bump,
        payer = vault_admin
    )]
    pub vault_token_a: Account<'info, TokenAccount>,
```
Where are you using that `mint: Pubkey` argument?
```
pub fn initialize_vault(
        _ctx: Context<InitializeVault>,
        _vault_name: String,
        _mint: Pubkey,
    ) -> ProgramResult 
```

```
#[derive(Accounts)]
#[instruction(
    vault_name: String, 
    mint: Pubkey,
)]
pub struct InitializeVault<'info> {

  /// Vault admin
    #[account(mut)]
    pub vault_admin: Signer<'info>,

    /// Vault Info
    #[account(
        init,
        payer = vault_admin,
        seeds = [VAULT_INFO_SEED.as_bytes(), vault_name.as_bytes()],
        bump,
    )]
    pub vault_info: Account<'info, VaultInfo>,

    /// Vault authority: PDA which manages everything within the vault
    /// CHECK: this is fine for now but maybe revisit later
    #[account(
        init, 
        payer = vault_admin,
        seeds = [VAULT_AUTHORITY_SEED.as_bytes(), vault_name.as_bytes()],
        bump,
    )]
    pub vault_authority: Account<'info, VaultAuthority>,

    [some mint accounts, some associated token accounts, system program, rent sysvar, token program]
}
```
Thank you very much!. I've just realize it too. Problem solved ‚ù§Ô∏è
Borsh serializes vectors as 4 bytes for the length of the vec, plus each of the items in it one after the other. So how much space you need depends on how big you want to allow that vector to get (you need to give it some amount of space that you're comfortable paying for, since space costs rent money)
Using `derive(Default)` on an account that stores a `Vec` doesn't make sense, because it won't allocate enough space for you (the default value for a vec is empty!). You need to manually specify `space =` in your `init` annotation if you want to use dynamically-sized things like vecs, strings, etc.
I realize that the problem only happend when my vector is not empty. When it empty, I receive an empty array in console.log
can I see the this instruction?
Is there anything I need to know when storing vector in account? I've been struggling with the problem all day and still cannot fix it üò¶
Did you find anything üò¶ I tried to change to vec<u64> but it still not work
nothing in the ctx isn't an account
any idea what causes this error? can't figure it out.

```
10 | #[derive(Accounts)]
   |          ^^^^^^^^ method cannot be called on `anchor_lang::prelude::Pubkey` due to unsatisfied trait bounds
```
if I change the name in my Anchor.toml, it still generates IDLs and other things with the old name. I also changed the cargo.toml in the programs/my_program/ dir
what files/lines do I have to change in order to change the name of a program?
And original prolem back again
I change it back to #[account]
No üò¶
does that fix your original problem then?
That error because I tried to change #[account] to #[state]. It wasn't work haha
I fixed that bro. Please pull again
<@!519199929776865308> u may want to correct this
here bro. Thanks a lot!
https://github.com/thanhlongtld/ido-program
can u send your repo? might have time to take a look later
and Box<Account<‚Äòinfo, Mint>>
like Box<Account<‚Äòinfo, TokenAccount>>
try boxing some token accounts or mint accounts
is the tokenswap program automatically loaded by anchor's local validator?
Try using Box<> around your accounts
```
Stack offset of 6184 exceeded max offset of 4096 by 2088 bytes, please minimize large stack variables
```
what does this mean exactly and what should I do about it
can someone help me with this. My deadline is getting close :((
thankss
dont think so. best use scaled up integers
Is there anything wrong with this code? I create the UserDeposit account successfully but I receive "Error: 3004: Failed to serialize the account"
hello. can anchor_spl transfer float type amount of token?
ty
Yep, `Pubkey::default()` üôÇ
How do I check if a `Pubkey` field in an account struct is initialized or not? Without using a separate initialize var? Is there something like `Pubkey.default`?
Got it üëå
You can't store an AccountInfo on-chain in an account‚Äîit's already the solana thing that represents an account!
Ah, no‚Äîonly in derive(Accounts)
like so
```
    // vault Accounts
    #[account(
        seeds = [vault.vault_name.as_ref().strip()],
        bump = vault.bumps.vault,
        constraint = vault.usdc_mint == usdc_mint.key() @ ErrorCode::InvalidUsdcMint
    )]
    pub vault: Box<Account<'info, Vault>>,
```
in this case, i believe the `Vault` struct is data stored on an account
Is that always the case, AccountInfo is preferable to a Pubkey?
At any rate my point is that saying `pub some_account: Pubkey` in the derive(Accounts) struct doesn't really make sense, since you would rather have at the very least an AccountInfo
u32::default() is 0u32, etc.
Pubkey::default() is the zero address
`#[derive(Default)]` says "rust compiler, please just figure out a reasonable way to make `Vault::default()` make a normal-ish instance of the Vault struct"
i'm not sure what the derive(Default) attribute does üòÖ
I'm asking if there is some relationship between Default and Pubkey
What do you mean? Pubkey does impl Default
```
#[account]
#[derive(Default)]
pub struct Vault {
    pub vault_name: [u8; 20], // Setting an arbitrary max of twenty characters in the vault name.
    pub bumps: VaultBumps,
    pub vault_admin: Pubkey,

    pub usdc_mint: Pubkey,
    pub redeemable_mint: Pubkey,
    pub vault_usdc: Pubkey,

    pub epoch_times: EpochTimes,
}
```
ex:
does the Pubkey reference have some reference to `#[derive(Default)]`?
trying to understand this new bump 'magic' i've been told about
is this section about the new functionality with setting bumps in the context `lang: Context now has a new bumps: BTree<String, u8> argument, mapping account name to bump seed "found" by the accounts context. This allows one to access bump seeds without having to pass them in from the client or recalculate them in the handler` ?
I haven't tried, I'm just trying to understand where, if ever, it makes sense to use a Pubkey
when writing out a struct to be used by a solana program üòÖ
Ah, no, writing Pubkey there just doesn't work‚Äîdoes it even compile when you try?

sure!
Can you write out some sample code? I'm still not sure what you mean‚Äîwhat does it mean to list an account as a Pubkey?
vs Account or AccountInfo
üëå
When I'm writing context, is there ever a reason to list an account as a `Pubkey`?
Just to be clear, you can't do that haha
Not sure what you mean
is there a reason to ever list an account as a pubkey?
cool
The supply of the mint will live on a `Account<'info, Mint>` as just its `.supply`, no need to call to_account_info() on it.
You mean call to_account_info() on a Pubkey?
If I reference a field on context as a pubkey and its the token mint, can I do to_account_info on it? and then query the supply or do I need to do something else?
Doesn't look like you've marked the multisig account as `mut`
`programID.toString()`
When you allocate space for that account, it's all zeros to start.
Hi, so this is a more generic solana  dev doubt rather than specific to Anchor, 
Have been following the solana bootcamp playlist, consider the simple counter example, 

My question is when we first create the counter account, where the initial value ( counter = 0 ) comes from? 
In the client code (https://github.com/jarry-xiao/solana-bootcamp-lectures/blob/master/lecture_1/js/index.js)  , we are using 
```    let createIx = SystemProgram.createAccount({
      fromPubkey: feePayer.publicKey,
      newAccountPubkey: counterKey,
      lamports: await connection.getMinimumBalanceForRentExemption(8),
      space: 8,
      programId: programId,
    });
``` 
In the above, there is no data sent that my inital counter value should be 0. We are only specifying the space. 

In the program side on-chain , we have 
```
#[derive(BorshSerialize, BorshDeserialize, Debug, Clone)]
pub struct Counter {
    pub count: u64,
}

let mut counter = Counter::try_from_slice(&counter_ai.data.borrow())?;
```
My question is how does the initial counter value = 0 comes from ?
When deploying a new program, is there a good rule of thumb for how much account space to reserve? I expect to add a bunch of features over time to a minimal program, so i'm not sure if the 2x default is the right amount
gm people! having a bit of a problem here.. how do you write tests to send `Vec<Struct>` as a parameter to rpc endpoints?
In my webapp, how do i output the programID in the same representation as used in my declare_id? I want to check that they're the same

my lib.rs:
`declare_id!("FyyEsLnaGWdteFK2x38UNzeVveLsgYw4PkXRAk34gMrH");`

my web app:
`const programID = new PublicKey(idl.metadata.address);
console.log("Program ID is " , programID); `

Output in attached screenshot, representation is not the same
Hey there. plz help solve this issue. I'm so close to completing  the buildspace Session 3.ü§î
Any ideas what I can do here?
If I remove the `.clone()` I get the error:

```
cannot move out of `ctx.accounts.multisig` which is behind a mutable reference

move occurs because `ctx.accounts.multisig` has type `std::boxed::Box<anchor_lang::prelude::Account<'_, Multisig>>`, which does not implement the `Copy` traitrustc(E0507)
lib.rs(81, 31): move occurs because `ctx.accounts.multisig` has type `std::boxed::Box<anchor_lang::prelude::Account<'_, Multisig>>`, which does not implement the `Copy` trait
```
The problem I'm running into is the `multisigAccount` at the end of my test ends up not having anything set - it seems like the `create_multisig` didn't work. I suspect this i the case because I'm calling `multisig: ctx.accounts.multisig.clone()` here...
My test looks like:

```
let multisigSize = 200; // Big enough.
    let multisig = anchor.web3.Keypair.generate();
    let [multisigSigner, nonce] =
      await anchor.web3.PublicKey.findProgramAddress(
        [multisig.publicKey.toBuffer()],
        program.programId
      );
    

    const ownerA = anchor.web3.Keypair.generate();
    const ownerB = anchor.web3.Keypair.generate();
    const ownerC = anchor.web3.Keypair.generate();
    const owners = [ownerA.publicKey, ownerB.publicKey, ownerC.publicKey];

    const threshold = new anchor.BN(1);

    await program.rpc.createMultisigNewOwnersMetadata(owners, threshold, nonce, {
      accounts: {
        multisig: multisig.publicKey,
        ownersMetadata: ownerA.publicKey,
      },
      instructions: [
        await program.account.multisig.createInstruction(
          multisig,
          multisigSize
        ),
        await program.account.ownersMetadata.createInstruction(
          ownerA,
          multisigSize
        ),
      ],
      signers: [multisig, ownerA],
    });

    let multisigAccount = await program.account.multisig.fetch(multisig.publicKey);

    assert(multisigAccount);
```
Suppose I have:

```
pub fn create_multisig_new_owners_metadata(
    ctx: Context<CreateMultisigNewOwnersMetadata>,
    owners: Vec<Pubkey>,
    threshold: u64,
    nonce: u8
) -> Result<()> {

    // msg!("ctx.accounts: {:?}", *ctx.accounts);
    
    create_multisig(
        Context::new(
            ctx.program_id,
            &mut CreateMultisig {
                multisig: ctx.accounts.multisig.clone()
            },
            &[],    
            ctx.bumps.clone()
        ),
        owners,
        threshold,
        nonce,
    )?;

    Ok(())
}

pub fn create_multisig(
        ctx: Context<CreateMultisig>,
        owners: Vec<Pubkey>,
        threshold: u64,
        nonce: u8,
    ) -> Result<()> {
        assert_unique_owners(&owners)?;
        require!(
            threshold > 0 && threshold <= owners.len() as u64,
            InvalidThreshold
        );
        require!(!owners.is_empty(), InvalidOwnersLen);

        // construct the multisig
        let multisig = &mut ctx.accounts.multisig;
        multisig.owners = owners;
        multisig.threshold = threshold;
        multisig.nonce = nonce;
        multisig.owner_set_seqno = 0;
        Ok(())
    }

#[derive(Accounts)]
pub struct CreateMultisig<'info> {
    #[account(zero, signer)]
    multisig: Box<Account<'info, Multisig>>,
}

#[derive(Accounts)]
pub struct CreateMultisigNewOwnersMetadata<'info> {
    #[account(zero, signer)]
    multisig: Box<Account<'info, Multisig>>,
    #[account(zero)]
    owners_metadata: Box<Account<'info, OwnersMetadata>>,
}
```


//////////////////////////////////////////////////////////////////////////////////////////

(From the client)
You need to pass the PDA1 account in as well
Hello, dummy question here.
I have created a program that stores an instruction that is signed and serialized into a PDA (PDA1)
Then i put the pubkey of the pda into some data of an other account (PDA2)

Then i create a new function that have the PDA2 in account entry.
I can retrieve the PDA1 Pubkey
But I'm not sure how i can :
1) retreive and deserialize the data from pda 1
2) proceed to the transaction that was signed and serialized in it PDA1

in front there is sendrawtrandaction

Any help where to look?
There actually shouldn't really be anything PDA-specific, you just need to sign with the original authority
https://hackmd.io/@ironaddicteddog/solana-anchor-escrow#Processor-Part-2

He does that here
Looks like `JSON.stringify()` is the solution here
üëã any example on transferring authority to a PDA?
Thanks!
You would need to check that one of the accounts passed in has the right address, and that it is a signer, e.g.
```.rs
#[account(seeds = [...], bump, seeds::program = the_calling_programs_program_id)
pub that_account: Signer<'info>
```
Hey all! How can I check inside instruction if that instruction was signed by right PDA? (I call instruction using CPI)  Is there an example available?
Hey, do you guys know of the preferred way to assert a rust enum variant in ts? Eg I'm fetching the account and it contains { variant: {} } where `variant` is one of the members of my enum. I want the ts function to behave differently based on the value of that enum but things like `account.exampleEnum == { variant: {} }` always resolve to false
Hey, can someone tell me what is the issue caused by init_if_needed?
<@!100062204333686784> I think I figured it out. There's a flag when you fetch the account info that indicates if mint authority is valid `mintAuthorityOption`. Idk if this documented anywhere, but it looks like when u unset the authority on a mint, it doesn't actually change the authority value, but it just changes the `mintAuthorityOption` from 1 to 0.

```
{                                                                                                
  mintAuthorityOption: 0,                                                                                                                                                  
  mintAuthority: <Buffer c2 4e cd 4c d0 df a6 c5 b0 02 e6 57 37 54 09 43 2d 74 86 20 98 30 02 26 f3 69 b5 83 ed 85 4c 07>,                                                 
  supply: <Buffer 01 00 00 00 00 00 00 00>,                                                                                                                                
  decimals: 0,                                                                                                                                                             
  isInitialized: 1,                                                                                                                                                        
  freezeAuthorityOption: 0,                                                                                                                                                
  freezeAuthority: <Buffer 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00>                                                
}
```
Turns out if I look at the explorer, the authority is actually set to null. But idk why my tests always get a non-null value when fetching it
But yeah, I strongly encourage just playing around with this experimentally, using the `#[test]` trick I showed above
Hooray! Thanks a million!
(When using borsh)
And yeah, anchor just reserializes the account data from scratch at the end of the instruction
8 is for the account "discriminator" bytes (they specify what struct anchor should use to deserialize the account data into (in this case, SomeAccount)
In the deserialization/serialization process, does it re-write the memory to keep the vectors contiguous? 

Lets take a look at this account: 
```
#[account]
pub struct SomeAccount {
    pub vector: vec<Pubkey>,
    pub vector_two: vec<Pubkey>,
}
```

First we call an Init function: 
(Program memory)
[ 
08: vector_size 
0B: vector_two_size
...
]


Then we call a push some_pubkey function to vector 2
(Program memory)
[ 
08: vector_size 
0B: vector_two_size
0F: some_pubkey
...
]

Then we call a  push some_other_pubkey to vector 1. 
(Program memory)
[ 
08: vector_size  <- Where does some_other_pubkey go?
0B: vector_two_size
0F: some_pubkey
...
]

Where does some_other_pubkey go? 
I assume the deserialization/serialization handles this and the result is:
(Program memory)
[ 
08: vector_size  <- Where does some_other_pubkey go?
0B: some_other_pubkey
2B: vector_two_size
2F: some_pubkey
...
]
I have a question about this: `8 +2* (4 + 2*32)`

8 + = ?
2 * (vecSize) = there are 2 vecs of vecSize
4 = size of a vec header
2 * (pubkeySize) = there are 2 pubkeys per vec
32 = size of a pubkey

Not sure what the 8 is for
How can I manually encode a program instruction in Rust?
When looking at the official token swap program (not the one I am using) some magic bytes are added. Is there another function I should use to convert my instruction to bytes?
```rust
       buf.push(1);
                buf.extend_from_slice(&amount_in.to_le_bytes());
                buf.extend_from_slice(&minimum_amount_out.to_le_bytes());
                buf.push(*flags);
```
And then the point is that borsh's serialization strategy always ensures that during *de*serialization, borsh will have enough information to decide when one field ends and the next begins (e.g. this is why it serializes vecs with an explicit length at the beginning: so it knows how many individual items to try to deserialize)
Borsh deserialization is greedy. It tries to deserialize the first thing, and looks at however many bytes is necessary to do so; then moves onto the next one, etc.
I'm going to try now . Thanks again !
not yet
Have you tried doing the `#[test]` thing I suggest above? I think I'm not understanding what you're confused about ü§î
Perhaps;) I mean, in fact, our data structure (with dynamic fields) actually lies in an array of bytes. So I don‚Äôt understand how Borsch understands in a continuous data stream where one field of the structure ends and another begins. If there were two usize (length and capacity), then where the field ends can be understood through address arithmetic (current_pos + capacity*data_size). And how to understand this when you only have a length is not entirely clear to me.

PS I'm sorry, it's just that English is not my native language, so I'm not always able to succinctly formulate the question üôÇ
Hi! I'm trying to manually construct a Instruction from an anchor based crate.
```rust

        let data = cpamm::instruction::Swap {
            amount_in: amounts.amount_in,
            minimum_amount_out: amounts.minimum_amount_out,
        }
        .try_to_vec()
        .unwrap();


....



        Ok(TransactionInput {
            instructions: vec![Instruction {
                program_id: id(),
                accounts,
                data,
            }],
            signers: vec![],
            payer: None,
        })
```
But transaction fails and transaction data seems to be shorter then the ones executed from the js web frontend. Accounts are the same as on the web initiated tx. Any ideas?
But basically borsh always does the absolute dead-simplest thing possible at every step
I think you should try printing some borsh serializations just to get a sense for how they work, it's pretty easy to use a `#[test]` in rust for this:
```.rs
#[test]
fn hmm() {
  #[derive(AnchorSerialize)]
  struct Thing {
    x: u8,
    y: u32,
    z: String // dynamically sized!
  }
  let things = vec![
    Thing { x: 0, y: 1, z: "foo".to_string() },
    Thing { x: 1, y: 2, z: "way bigger string".to_string() },
  ];
  eprintln!("{:?}", things.try_to_vec());
}
```
I'm just saying that for an empty vec, there's no data at all, just the 4 bytes for the size
It does! Maybe I'm misunderstanding your question ü§î
Thanks ! I just thought that the size of the second vector would lie immediately after the data of the first vector
It understands that by just greedily deserializing from left to right. So, ignoring the discriminator bytes, it says "ok need to deserialize a vec now" and looks at the next four bytes. They're all zeros, so it says ok, done, empty vec. Now I need to deserialize *another* vec, ok, look at the *next* 4 bytes‚Äîall zeros again, ok done.
Do you mean that in 1.9 there will be this option (deallocate account size)?
```Rust
#[account]
pub struct SomeAccount {
    pub vector: vec<Pubkey>,
    pub vector_two: vec<Pubkey>,
}
```
Suppose I have this structure, I allocated an account for 2 keys for each of the vectors. 8 +2* (4 + 2*32) its size. After the allocation, if I understand you correctly, from 8 to 11 bytes will be 0000, right? However, like everything else (all bytes will be equal to 0). It's just not entirely clear to me how Borsh understands where the boundaries of one dynamic object end and another begins.
Hey <@!100062204333686784> did you figure this out? I am running into the same issue as well 

```
    token::set_authority(
        CpiContext::new_with_signer(
            token_program.to_account_info().clone(),
            SetAuthority {
                current_authority: vault.to_account_info().clone(),
                account_or_mint: mint.to_account_info().clone(),
            },
            &[&vault_seeds],
        ),
        AuthorityType::MintTokens,
        None,
    )?;
```
seems to succeed, but querying for the mint account, the authority is still set. I tried sleeping before fetching as well, same result.
Yeah. Dynamic reallocation is coming at some point (whenever 1.9 lands, as far as I know)
I'm talking about the fact that, unlike the ethereum, you yourself are responsible for maintaining the state via saving data in accounts. And the vector here is a kind of wrapper over the array, because in fact you will not be able to dynamically re-allocate the size of the account.
I talked about it)
Ah, ok, got it!
No, just while I was writing, you already answered. That's what I meant when I wrote about the bad ending.
hey thanks it works fine now :)) I was afraid there would be other magic I am missing
But your nice vec living on the stack, with its data in the heap, can grow just fine at runtime
Maybe I'm agreeing with you‚Äîif you don't allocate enough space, then yeah, you won't be able to serialize the account back into storage
oh ok let me try
The discriminator is 8 bytes, not 1

Sorry, I maybe misunderstood what you were saying
Did I miss something and now in Solana you can change the size of accounts? )
It will fail when you try to serialize the account struct *back* into the underlying AccountInfo's storage though, yes
The data in that vec lives on the heap
It will end fine actually, because vecs are built to support dynamic reallocation üôÇ
What header are you stripping? The discriminator takes up 8 bytes
Just in the context of Solana vec reminds me more of a generic array. Again, if I allocated 320 bytes (10 keys), then if there are 10 keys in the vector, and I push another one, then something tells me that this will not end well üôÇ
How can I manually deserialize that struct (https://github.com/SenchaHQ/sencha/blob/master/programs/cpamm/src/state.rs#L45) from an account state's vec<u8>. I tried several approaches but do not get expected results
```rust
            let swap_info = match try_from_slice_unchecked::<SwapInfo>(data_stripped) {
                Ok(v) => { ..
```

```rust
SwapInfo:deserialize(..)
```

I tried it with and without stripping headers
```rust
       let data_stripped = &mut &data[1..];
```
This is *also* how borsh would serialize an array, so it's not like borsh is being super precise with its serialization strategy
It's not reproducing the capacity you specified when you serialized them‚Äîit throws that information away
Mm, it just does something dumb and says, ok, gotta stick these N things in a vec
Thanks !  I know about this restriction, but I am pleased that you decided to mention it to warn about potential problems. 10 000 was an example. I'm just saying that a vector in Rust on the stack allocates 3 usize: the address of the first element, the length and the capacity. How Borsh can deserialize it only on the basis of one usize is still unclear to me.
To have an account that big, you'll be forced to use `#[account(zero_copy)]` and AccountLoader etc, which don't use borsh at all.
When you allocate space for an account, that space is managed by solana (at runtime at least, it lives wherever the underlying AccountInfo's `.data` field points to). Borsh doesn't care about this at all, and will in fact deserialize your struct onto the stack (so 10k worth of pubkeys won't work, that's far too big for solana's stack frames or even its 32kb heap)
I suppose that is what the doc was telling me...further reading of the rust book required üòõ
Ahh... I see . Thanks ) 
If I understand you correctly, then during initialization I just set capacity , the actual size will be determined by the given usize(32 bits). And then how does he understand where the vector ends? I mean that for example, I allocated places for 10,000 keys (320 kb), but put only one key. Those. we have a capacity of 10,000 and a length of 1.
Yes that does work, thanks
ah misunderstood you, lemme try that
Did you do that `use` statement I mentioned?
You can test this out by doing
```.rs
// in your program file somewhere
#[test]
fn hmm() {
  let xs = vec![1,2,3];
  eprintln!("{:?}", xs.try_to_vec());
}
```
Yeah it should, but i get:  `Pubkey::from_str("3ap2azWa1GzpCxEbRqZYkuGP6GaoC5tzuRMqSPdgLQzn").unwrap(),
                 ^^^^^^^^ function or associated item not found in `anchor_lang::prelude::Pubkey`
`
4 zero bytes
But what you have above should work too, btw
What does <0000> mean?
ah this is what i need, thanks very much
If you have an actual static pubkey, you can also use a solana macro to do that same thing at compile-time, without any runtime cost
```.rs
const HMM: Pubkey = anchor_lang::solana_program::pubkey!("asdasdfasdfasd");
```
to get a pubkey, but the method isn't exiting in Pubkey
`use std::str::FromStr;` if that complains at you
The anchor docs imply that i can do this: `Pubkey::from_str("3ap2azWa1GzpCxEbRqZYkuGP6GaoC5tzuRMqSPdgLQzn").unwrap()`
No, it'll be empty (borsh will serialize that empty vec, regardless of its capacity, as <0000>)
The way borsh serializes a vector is separate from the actual vector itself. Borsh doesn't care about the capacity when it serializes, it only cares about the length.
Usually a vector has a length and a capacity, here I get the impression that length == capacity. For example, I have a collection of 10k pubkeys. Let's say I initialize an account where one of the fields (pub vector: vec<Pubkey>) has a length of 10,000. When I deserialize this account, vector.len() will be 10,000 (assuming I don't actually put even one key)?
Do people use the `?` operator for Result handling in their programs? Would there be any reason not to do this?
is there a way to call find program address with a program?
I found this but I'm not sure if it's going to lead anywhere https://stackoverflow.com/questions/69432084/how-to-decode-a-solana-transaction
Like I can do program.account.myAccountType.fetch(address) to parse an account's data, but there doesn't seem to be a program.transaction.MyTransactionType.fetch(signature)
How do I parse a transaction (starting w/ signature) in my program for associated instruction from JS?
anybody know how to convert a [u8; 32] to a uint?
You can have a `struct`  `impl` a `Trait` in Rust similar to have a `class` can `implements` an `interface` in Java, basically extend the functionality of a struct and update the type definition of the struct so clients of the struct can call those methods you added
can someone explain what impl is and why I would use it?
are bumps often passed to the program instruction handler from the client-side rather than using `find_program_address` in the program in order to make the transaction cheaper for the end-user?
Why do we call them bumps instead of nonces? Is it because we're trying to use a seed to bump the resulting address off the elliptic curve ?
now I"m just getting a insufficient funds issue, which I've fixed
in typescript this operation made the entries include a " character in the string at beginning and end. no idea why the IDL does that by default?
nice... got it
may have found the issue...
interestingly, when I print out the seeds via
```rust
seeds = [{msg!("vault_info seed = {}", VAULT_INFO_SEED); VAULT_INFO_SEED}.as_bytes(), {msg!("vault_name = {}", &vault_name); &vault_name}.as_bytes()],
```
it prints out everything twice in the program log:
```
    Program log: Instruction: InitializeVault
    Program log: vault_info seed = vault-info
    Program log: vault_name = my_vault
    Program log: vault_info seed = vault-info
    Program log: vault_name = my_vault
```
... is that expected?
I can't even init a single PDA so I def think something is wrong here
it is in a github repo but it's private for now and don't have permissions
If this is in a github repo (with a failing test) I can take a quick look, might be faster to debug that way
That probably will be a problem, yeah, but the error above is different
I realized I am passing in `const vaultAdmin = anchor.web3.Keypair.generate()` as the payer/signer. is it possible that it's just complaining bc no funds?
Nope, just have to be careful to get the seeds right
is there anything special you have to do when initing multiple pdas?
```rust
    /// Vault Info
    #[account(
        init,
        payer = vault_admin,
        seeds = [VAULT_INFO_SEED.as_bytes(), vault_name.as_bytes()],
        bump,
    )]
    pub vault_info: Account<'info, VaultInfo>,
```
and
```rust
/// Accounts in context of initialize_vault instruction
#[account]
#[derive(Default)]
pub struct VaultInfo {

    /// Mint address of token A
    pub token_a: Pubkey,

    /// Mint address of token B
    pub token_b: Pubkey,
}
```
let me send that over
You posted the one for vault_token_a above, unless I'm looking in the wrong place
Ah, what does its derive(Accounts) thing look like?
Which is a nonATA PDA
Well. I‚Äôll fix that, but It‚Äôs the vaultinfo account which is complaining
hmm
I though anchor actually checked for that, but I guess not, huh
Maybe you want to just use `token::mint` etc.? So a token account but using one of your own PDAs, not as associated token address
Associated token addresses are *already* PDAs derived from a totally different program, so doesn't make sense to also use your own seeds.
Ah, well, for one, you can't use seeds with `associated_token::` constraints, so not sure what's going on there ü§î
&str
what type is VAULT_INFO_SEED?
for completeness, 

```typescript
let programConstants = Object.assign({}, ...program.idl.constants.map((x) => ({[x.name]: x.value})));
```
^e.g.
```typescript
let [vaultInfo, infoBump] = await anchor.web3.PublicKey.findProgramAddress(
      [
        Buffer.from(anchor.utils.bytes.utf8.encode(programConstants['VAULT_INFO_SEED'])),
        Buffer.from(anchor.utils.bytes.utf8.encode(vault_name))
      ],
      program.programId
    )
```
the program_id i am not so sure about. I have changed the name of files and directories, but I have not changed the declared program id
```
/// Accounts that stores token A
    #[account(
        init, 
        payer = vault_admin,
        associated_token::mint = token_a_mint,
        associated_token::authority = vault_authority,
        seeds = [VAULT_TOKENA_SEED.as_bytes(), vault_name.as_bytes()],
        bump,
    )]
    pub vault_token_a: Box<Account<'info, TokenAccount>>,
```
the `VAULT_TOKEN_A_SEED` is defined in a constants file, which is also read in by my .ts file. the `vault_name` is in the `#[instruction(vault_name: String ... )]` macro, and so the same vault_name is being passed into `findProgramAddress` as the instruction.
Or are you positive you've got the right declare_id! ?
Are you 100% sure you're using the right seeds?
Yep I have init, payer, seeds, bump
To init an account that lives at a PDA requires using `seeds = [...], bump` alongside `init`
`init` CPIs to the system program
You probably have an `init` for that PDA?
the initializeVault instruction is currently empty. the CPIs are all just to create accounts, token accounts, associated token accounts.
I actually don't remember, but yeah, I think if you let anchor spin up its own validator it starts with a totally fresh one (usually what you want)
The only way to sign for a PDA is by having its deriving program sign for it at the point you do the CPI (with `invoke_signed` under the hood)
<@!134416332509675520> is that the intended behavior?
oh wait I'm passing in a keypair.generate() for `vaultInfo` and all other PDAs... that's probably the issue
```
Admin Key: DHXC8h7HxMNuP6jvTT4F6j9fUUS14NHGWCCCupx8Pq86
Info Key: A5rGkqceqPHfVxnv1aNfsJaaccigYPZDtQJF2gjafFfs
Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account 
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS invoke [1]
    Program log: Instruction: InitializeVault
    A5rGkqceqPHfVxnv1aNfsJaaccigYPZDtQJF2gjafFfs's signer privilege escalated
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS consumed 21157 of 1400000 compute units
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS failed: Cross-program invocation with unauthorized signer or writable account
    1) Vault initialized!


  0 passing (132ms)
  1 failing

  1) Vault
       Vault initialized!:
     Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account
```
ah yes there's something going wrong here. the signer privilege of `vault_info` (a pda), not of `vault_admin` is escalated. when I pass in that account, though, it gives me an unknown signer error...
Ah, ok, all good
I fixed the issue would you still like to see the instruction?
Ok, so if I deploy the program to my test validator and run the anchor test it works, but when I don't have the validator running it returns Error: 3012: The program expected this account to be already initialized.
Can you print your whole instruction function?
I was boxing AccountInfo, which I guess is not allowed
Going to need to print what happens after you log `requesting randomness`
```
  logs: [
    'Program GJmxJGYZETm142yHTQVasceWxWSVzC1Zi86UrCEpgrhK invoke [1]',
    'Program log: Instruction: Gamble',
    'Program log: in gamble',
    'Program 11111111111111111111111111111111 invoke [2]',
    'Program 11111111111111111111111111111111 success',
    'Program log: invoked transfer',
    'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [2]',
    'Program log: Instruction: Transfer',
    'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 2755 of 181942 compute units',
    'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success',
    'Program log: requesting randomness',
    'Program log: Failed to borrow a reference to account data, already borrowed',
    'Program GJmxJGYZETm142yHTQVasceWxWSVzC1Zi86UrCEpgrhK consumed 28686 of 200000 compute units',
    'Program GJmxJGYZETm142yHTQVasceWxWSVzC1Zi86UrCEpgrhK failed: instruction tries to borrow reference for an account which is already borrowed'
  ]
```
Hey all! Getting this error 
```
     Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: instruction tries to borrow reference for an account which is already borrowed
```
install a gcc toolchain, how you do that depends on what OS you are on
```error: linker `cc` not found
  |
  = note: No such file or directory (os error 2)

error: could not compile `semver` due to previous error
warning: build failed, waiting for other jobs to finish...
error: build failed```
but it failed with error
I created new anchor project and I tried to run command 'anchor build'
anchor.setProvider(anchor.Provider.env()) how can i check where its running using anchor test
Assume nothing tricky/unexpected is happening
(Basically there's going to be a dumb explanation of what's going wrong, or maybe some other account was expected to be initialized, etc.)
Ok, then are you sure your code is running on localnet?
first, didn't know I could connect to my locahost with the explorer, this is awesome.
Sometimes (sometimes) boxing an Account<'info, Whatever> helps
You're out of stack space, depends a lot on what you're doing
```
  logs: [
    'Program GJmxJGYZETm142yHTQVasceWxWSVzC1Zi86UrCEpgrhK invoke [1]',
    'Program GJmxJGYZETm142yHTQVasceWxWSVzC1Zi86UrCEpgrhK consumed 3256 of 200000 compute units',
    'Program failed to complete: Access violation in stack frame 3 at address 0x200003e78 of size 8 by instruction #11650',
    'Program GJmxJGYZETm142yHTQVasceWxWSVzC1Zi86UrCEpgrhK failed: Program failed to complete'
  ]
```
getting ```Access violation in stack frame``` as an error but i don't have a ton going on in my program, any ideas?
Well, you can always just open up explorer.solana.com and select your network + check if that token address is there
solana config get returns RPC URL: http://localhost:8899, anchor.toml has cluster = "localnet"
Entrypoint has a specific meaning in solana, but I don't think you're referring to the same thing
Mm, can you say more about your question? What do you mean by entrypoint here?
gotcha, okay I will make some of the calls to look at what the data looks like. makes sense tho, I am trying to get balance and it says account doesn't exist so in that case know that they need to create one
Is the the entry point just the position in the instructions array?
Only by fetching the account and just checking to see if it's already initialized (or doing the equivalent kind of thing in your own program)
ah I see. is there a way of knowing if there is already a token account that is created? that makes sense so they have to actually sign a transaction to create the token account to use. is there a way of knowing is they already did that tho, and that the address that is being returned is "set up" in a way
Are you sure you created the account on the same network as where your code is running?
<@!134416332509675520> any ideas on my issue above?
E.g. something like this https://solanacookbook.com/references/token.html#how-to-create-a-token-account
Which isn't about an address, it's about the actual token account
And createProgramAddress is also not what you want unfortunately‚Äîyou would need to actually create the token account if necessary
No, that doesn't create an account, it just "finds" the right address.
Anchor does generate an entrypoint for you, but I'm not sure what the rest of your question is about
Not an anchor question, but for the spl-token program the `findProgramAddress` to get an associated token account. if one doesn't exist, does it create it automatically? I noticed I don't think I created a token account but it gets me an address, so wondering if it is all set up or if need to explicitly create it with `createProgramAddress`

https://spl.solana.com/associated-token-account#finding-the-associated-token-account-address
Do you know which account is 2dbC37PZs7Vurk3DGfsov5fdaY7th7NVVtf4H8JaQFmi? If that's your PDA then you're somehow not signing for it correctly when you do the CPI
Does anchor generate entry points? is the instructions array in idl just [0,1,2] when sending tx?
I used the CLI to create an spl token, created an account with spl-token create-account and tried to pass the account in to my program as a  Account<'info, TokenAccount>, but I'm getting Error: 3012: The program expected this account to be already initialized.  What am I missing?
I am seeing this
```
  2dbC37PZs7Vurk3DGfsov5fdaY7th7NVVtf4H8JaQFmi's signer privilege escalated
  Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS consumed 21157 of 1400000 compute units
  Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS failed: Cross-program invocation with unauthorized signer or writable account
```
in an instruction where one `vault_admin` is signing for everything, i.e. all PDA inits (including associated token accounts). not sure what to do bc i can't pass any other account as a signer bc I get "unknown signer" error, so this is the only valid signer
got it to work! thank you so much
getting this error `     Error: failed to send transaction: Transaction simulation failed: This program may not be used for executing instructions` have you seen this before?
One address per key
Yea I see it's a Option<Vec<CloneEntry>> where CloneEntry is a struct with address field. I don't know how to format that in the toml exactly. 

address = "someaddress"
address = "someotheraddress"

doesn't seem to work. says it expects a sequence. an array-esque [key, other_key] didn't work either.
its not documented but you can decipher it from the types here https://github.com/project-serum/anchor/blob/master/cli/src/config.rs#L537-L580
I have 6 pubkeys i'm tryna clone. edit: 8 actually
address = pubkey
or just list of pubkeys
like what exactly do I put under, account_a=PUBKEY?
is there a doc on format?
[[test.validator.clone]] for the accounts
ty i'll try it out
Yes
where tho, Anchor.toml?
all the [test.validator.*] keys get passed straight to `solana-test-validator`
bumping this
The syntax changed to [[test.validator.clone]] but I cant recall if that was before or after 0.20.1
I have a token program mint that I've created. I'm trying to set the minting authority to null. The transaction goes through and doesn't error but nothing happens. I can successfully change the mint authority to another pubkey. Any idea what's going on?
anything glaringly wrong in the code? added program log for context too
```[test.validator]
url = "https://api.mainnet-beta.solana.com"
[[test.clone]]
address = "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"```
anchor.toml
```
    const accountInfo = await connection.getAccountInfo(tokenAMint)
    console.log("accountInfo", accountInfo)
```
`  const connection = new Connection("http://127.0.0.1:8899", 'confirmed');`
account info is null
Hello! I'm just getting started with Solana and Anchor and I'd like to start building a bet program: bet account with options, the user can bet for an option and the owner of the bet account can set the winner option and distribute the prize (lamports for example) for all who picked the right option

And I face with one question about the best approach for it, I'd like to have dynamic amount of players so I create a new account every time a new player joins the bet, the issue that I'm facing is how to distribute the prize among the winners

From what I understand, I have to pass all the accounts from the client when I pick a winner option, does that mean that I should fetch all the winner accounts in the client and pass them to the pick winner instruction besides the bet account? is there any way to handle everything in the program itself?

Thanks for the help!
anchor-cli 0.20.1
What version of anchor cli are you using? `anchor --version`
Double check that the cloning actually worked by fetching the account in JS etc.
I wonder what I'm doing wrong getting this error `     Error: 3012: The program expected this account to be already initialized` which refers to token_a_mint which is an account i'm cloning from mainnet
Yep
cool, and then if those addresses are token mints I can call methods to move relevant spl-tokens in token accounts they own and stuff?
In your Anchor.toml you can do
```.toml
[test.validator]
url = "https://api.mainnet-beta.solana.com"
[[test.clone]]
address = "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"
[[test.clone]]
address = "PwDiXFxQsGra4sFFTT8r1QWRMd4vfumiWC1jfWNfdYT"
[[test.clone]]
address = "GvDMxPzN1sCj7L26YDK2HnMRXEQmQ2aemov8YBtPS7vR"
[[test.clone]]
address = "WMW5xc3HypXwTnPesyUT49uLsyHwNURsWAEk39onKuk"
```
You can clone accounts from mainnet, yeah
Is there any way to fork mainnet locally so I can reference token mint accounts and mint authorities on mainnet when testing locally?
Thanks
That means your `declare_id!` doesn't match your program's actual program id üòõ


//////////////////////////////////////////////////////////////////////////////////////////

Thanks alan! ü¶æ
https://github.com/killercup/cargo-edit
`cargo upgrade`
No matter what you're going to need some initialization instruction that does something like
```.rs
**ctx.accounts.that_account = ItsStruct::default();
```
Don't think there's a way to avoid this. When you create an account in solana its data starts off as all zeros.
update, seems like yes, that's all you do to upgrade it
hey all, i am new to rust ecosystem, so this is a super noob question, but i can't seem to find a clear answer on google. 

If i wanted to update anchor-lang to the latest package for my solana program, how do i go about doing that? Do i just simply modify the Cargo.toml anchor-lang dependency to the latest version?

i.e.
`
[dependencies]
anchor-lang = "0.20.1"
`
I'm not sure if it is possible or not. you may need to change how `Default` trait is defined.
I don't want to manually add the word "TSLA" in every instruction
```rs
#[program]
pub mod stockprogram{
  pub fn initialize_account(ctx: Context<CreateStock>) -> ProgramResult{
    ctx.accounts.stock.uuid = b"TSLA";
    Ok(())
  }
}
#[account]
pub struct Stock{
  pub uuid: &[u8; 4],
}
#[derive(Accounts)]
pub struct CreateStock<'info>{
  #[account(init, payer = signer, space = 8 + 4)]
  stock: Account<'info, Stock>,
  signer: Signer<'info>,
  system_program: Program<'info, System>,
}
```
is this what you mean?
Hmmm maybe alan knows.
üòï
Is there an anchor-level way to create default values?
Even with `Default`, I need to do `let s: Stock = Default::default()`
how do I set the default value to TSLA
implement `Default` trait for Stock.
Like say i have account

```
#[account] 
pub struct Stock {
    Uuid: [u8; 4]
}

```

How can I set a default value for uuid? E.g. ‚ÄúTSLA‚Äù
`#[derive(Default)]`
default values ? like 0 in place of slot?
How can I set default values for when my account is instantiated?
And thanks pramit!
This answered my question, thanks Alan!
Bools still take a full byte.
8 for u64, 1 for bool and 8 for discriminator
how much space does this take up?
Here's a better example:
```
pub struct LastUpdate {
    pub stale: bool,
    pub slot: u64,
}
```
but the problem is, bool only takes up 1 bit.
8 + 1
How much space should I allocate to create an account like this?
```
pub struct LastUpdate {
    pub slot: u64,
    pub stale: bool,
}
```
Ya Just update the global anchor/cli package
When I store a bool, it only should take up 1 bit. But when I initialize a new account, I can only allocate bytes of space, not bits. Does this mean that a bool variable takes up a full byte of space?
did you have any luck with this?
<@!919972203020308490> you can use this reference ü¶Ä
Hy! Why the fetchIdl returns with null with some candymachine addresses?
Hey I'm new to anchor and blockchain development in general!
I was following the minimal example in the docs and i am getting an error while generating a client! 

Error: failed to get recent blockhash: FetchError: request to http://127.0.0.1:8899/ failed, reason: connect ECONNREFUSED 127.0.0.1:8899
at Connection.getRecentBlockhash (./anchor/examples/tutorial/node_modules/@solana/web3.js/lib/index.cjs.js:5965:13
at processTicksAndRejections (node:internal/process/task_queues:96:5)
at async Provider.send (./anchor/examples/tutorial/node_modules/@project-serum/anchor/dist/cjs/provider.js:82:31)
at async Object.rpc [as initialize] (./anchor/examples/tutorial/node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:31:31)
at async main (./anchor/examples/tutorial/basic-0/client.js:25:3)
I‚Äôm really new to all of this terminal language.
Can someone help me understand what [brew] is?
Also what‚Äôs a PATH? 
And I see a lot of talk about being in the right directory, does this class leave out a lot of code that they expect us to know?
üôè much appreciated.  This details were kinda unclear for me
Is it possible to read PDA data of someone's program or do I need to know the IDL structure ?
has anyone played with how to create a "Solana Pay" button or have an example of one on a website?
The point-of-sale is super awesome
https://github.com/solana-labs/solana-pay
When I store a bool, it only should take up 1 bit. But when I initialize a new account, I can only allocate bytes of space, not bits. Does this mean that a bool variable takes up a full byte of space?
I think I found an older answer to my question https://discordapp.com/channels/889577356681945098/889702325231427584/918271640431902891
hey guys Im looking at the escrow example in the anchor tests repo, but im struggling to understand how this token::set_authority works and haven't been able to find it in the token source code. I get what it does (sets the authority of some account to the pda) but am not understanding how. could someone explain how this function works and how 'ctx.accounts.into()' works too?

`let (pda, _bump_seed) = Pubkey::find_program_address(&[ESCROW_PDA_SEED], ctx.program_id);
 token::set_authority(ctx.accounts.into(), AuthorityType::AccountOwner, Some(pda))?;`
What is a lazy symbol and how do I motivate it to work?
<:jerrywut:921157219444195419>
<:Shrug:856158473745727528>
i blame wormhole
then suddenly it works
i was trying to figure it out for like an hour
yeah ik idk
<:kek:866983238492356609>
yep
are you using the same deploy script?
<:worriedcry:615396682154377216>
it does
does `solana address` show you the expected address?
yep
is this the full stack trace?
haha
idk
I deployed the program from the same account on both mainnet and devnet
yeah i did have them both funded
best to triple check if you have funded the account on both
devnet sol vs mainnet sol
| #[program]
   | ^^^^^^^^^^ could not find `__client_accounts_deposit_token` in the crate root
is this just saying that the macro is completely wrong or is there really missing a crate?
<:Shrug:856158473745727528>
i didn't change anything
and then it worked
then i tried running initialize again on mainnet
that worked
I deployed on devnet from the same address
lol <@!848333406849073202> <@!134416332509675520> idk what happened
triple check youve got the right wallet being used as the `admin` account
awesome, thank you. will try!
<:thinkcat:837225078877716511>

https://solscan.io/account/PH4SWc3n6wUNEKjdBtA2SBLBT2tqQCj7RBwCTyAchvP
```
const PHASE_AUTHORITY: Pubkey = pubkey!(
    "PH4SWc3n6wUNEKjdBtA2SBLBT2tqQCj7RBwCTyAchvP"
);
```
That error basically means what it says, so you'll just have to double + triple check that the PHASE_AUTHORITY (I guess) actually has sol, specifically on mainnet
there's 0.3 SOL left in there
admin (my wallet) has SOL and used SOL to deploy this program
```
#[derive(Accounts)]
#[instruction(bump: u8)]
pub struct Initialize<'info> {
    #[account(
        init,
        seeds = [PHASE_STATE_SEED.as_bytes()],
        bump = bump,
        constraint = state.to_account_info().owner == program_id,
        payer = admin
    )]
    pub state: Account<'info, State>,
    #[account(
        signer,
        constraint = *admin.key == PHASE_AUTHORITY
    )]
    pub admin: AccountInfo<'info>,
    pub system_program: Program<'info, System>,
    pub cpi_authority: AccountInfo<'info>,
    pub x_token_mint: AccountInfo<'info>,
    pub y_token_mint: AccountInfo<'info>
}
```
localnet tests work fine
hey all, tried to deploy to mainnet, but I'm getting this when trying to initialize:

```
Uncaught (in promise) Error: failed to send transaction: Transaction simulation failed: Attempt to debit an account but found no record of a prior credit.
```
In this case if you want the program itself to have authority over the tokens, you could use `token::owner = pool_account`, since pool_account's address is already a PDA.
1) To init a token account, you need to provide more attributes, since anchor needs to know which mint and owner to use for the token account:
```.rs
#[derive(Accounts)]
pub struct Test<'info>{
    pub user_authority: Signer<'info>,
    #[account(init,
    payer = user_authority,
    seeds = [b'test'],
    bump = dont_forget_the_bump,
    token::mint = some_mint_account_you_passed_in,
    token::owner = whoever_has_authority_over_these_tokens,
    )]
    pub pool_account: Box<Account<'info, TokenAccount>>,
}
```
I am intending to send SPL tokens to a PDA account of my program and thought I could would just need to init it like this, but I am getting all kinds of errors.


#[derive(Accounts)]
pub struct Test<'info>{
    pub user_authority: Signer<'info>,
    #[account(init,
    payer = user_authority,
    seeds = [b'test'],
    )]
    pub pool_account: Box<Account<'info, TokenAccount>>,
}

1) Can I do it with TokenAccount or would I need to create a custom struct?
2) what is missing/wrong with the account macro parameters?
So if you want to add a new field, you need to do it at the end, and you need to have pre-allocated enough space to do so.
No, you generally can't change anything about the order (field names doesn't matter though). The issue is that the on-chain data format won't change‚Äîso if you change the field order etc., anchor will try to deserialize the *old* on-chain data according to the *new* struct definition.
yes, my bad I didn't pre-allocate enough space for Account and actually have increased space on upgrade. I see why I have an issue now üôà
so it is only about pre-allocated space, like size should be the same? can I change fields names, types, change fields order in the struct? and still have it backward compatible
just deployed program on mainnet after successful test on devnet. thank you <@!134416332509675520> for literally hand holding me through mud
Any old accounts will remain unchanged after an upgrade‚Äîif you want to change their struct, you'll have to make sure its backwards compatible with the old format, pre-allocate additional space, etc.
e.g. I did update my program changing Account struct with new fields, and I still can read old accounts but can't write them anymore, only new accounts can be updated properly
hey guys! Any suggestions on resources where I can read about updating Anchor programs? specifically, wondered how much I can mess with a code, like changing Account struct, so existing accounts still valid, writable / readable
when it shouldve been wallet.publicKey üòÑ
i was passing in a wallet
nvm
and how is that supposed to work with phantom
I'm getting `TypeError: y.pubkey.toBase58 is not a function` on my client
when you pass a `pub user: Signer<'info>,`, does it need to be a keypair or a pubkey?
good.
Im good i found something thanks !
.
and on github people said that is it because i run a ledger in background
I try this also but i got another error Error: failed to send transaction: Transaction simulation failed: Attempt to load a program that does not exist
run `solana-test-validator` in another terminal
but in the doc it said to not run a ledger in background
Unable to start test validator. Check .anchor/test-ledger/test-ledger-log.txt for errors.
Hi i try to test my first program but when i run anchor test i have this error
Alternatively, can we change/set the default wallet?
Hi, it seems that on the client side the default wallet ```program.provider.wallet``` signs all transactions by default. Is it possible to change this behavior? If yes, how?
<@!134416332509675520> Thanks
Helps with stack space issues (each solana stack frame is quite tiny, only 4kb, so you can run out pretty easily)
Hi, where is the point to wrap an account inside a Box like this:
```rust
    pub token_mint: Box<Account<'info, Mint>>,
```
https://dev.to/0xmuse/accelerated-guide-to-fullstack-web3-with-ass-anchor-solana-and-svelte-1mg
nice
oh nvm I'm just not following the steps to grab the keypair
<:thinkcat:837225078877716511>
as well as this in my `Anchor.toml`:
```
[programs.localnet]
swap = "PH4SdxsogmPaG5bX8jx74PCPz3ePjHvrbem54TW1iWz"

[programs.devnet]
swap = "PH4SdxsogmPaG5bX8jx74PCPz3ePjHvrbem54TW1iWz"

[programs.mainnet]
swap = "PH4SdxsogmPaG5bX8jx74PCPz3ePjHvrbem54TW1iWz"
```

but its still deploying to a different address
I have a:
```rust
declare_id!("PH4SdxsogmPaG5bX8jx74PCPz3ePjHvrbem54TW1iWz");
```
hmm


//////////////////////////////////////////////////////////////////////////////////////////

sounds like the rust you have installed is too old. `rustup update`
whenever I create a new project, I get these warning. any solution for these?
```
warning @project-serum/anchor > @solana/web3.js > rpc-websockets > circular-json@0.5.9: CircularJSON is in maintenance only, flatted is its successor.
[2/4] Fetching packages...
[3/4] Linking dependencies...
warning " > ts-mocha@8.0.0" has incorrect peer dependency "mocha@^3.X.X || ^4.X.X || ^5.X.X || ^6.X.X || ^7.X.X || ^8.X.X".```
Bumping my question from last night as I can't find the answer anywhere - I need to make sure I always get the same program id.  A new keypair is always generated if I blow away the `target` directory and `target` is not checked into source control.   I understand that a keypair is generated in the target directory next to the `.so` What's the purpose of this keypair, and how is it generated?  Does it need to be saved for future use, and what's the security implications of it? Is that key in anyway associated with the wallet defined in `ANCHOR_WALLET` or in `solana_config --keypair` path?
But it doesnt happen in my other anchor repository ü§î
```
error: package `uint v0.9.3` cannot be built because it requires rustc 1.56.1 or newer, while the currently active rustc version is 1.56.0-dev
```

Getting this error when i run `anchor build`
How do I bump the rust version of my anchor program?
I'm caught up now I think, and the source of confusion for me.  You are correct in all things.  The ATA program has an allocation function that allocates and initializes itself to be a real token account.  Thanks for explaining things.  What lead me to think there was a requirement was because the clientside semantics I needed were transferring based on a normal token owner which is what's driven by ATA's.  Neat-o.
maybe you changed to code in your head already ;-). would be convenient!
Hmm, for some reason I thought we had changed that
Ah, sorry, you're right‚Äîyeah, just do them manually
yes, but token::mint seems to be bound to the init macro. So would need to do the constraints manually
gotcha, ty
No
Can you fetch historical transaction information from within a program?
You maybe want to just use `token::mint` etc.
ahh, skipped that part
Associated token addresses are already PDAs derived from a totally different program
I mentioned this above, but you can't use both associated_token *and* seeds constraints
It feel's like the macro is "unhappy" with the authority to itself.
this one still give an "An associated constraint was violated" error
when I remove the associated_token macros this error is gone
 ```#[account(mut,
    associated_token::mint = token_mint.key(),
    associated_token::authority = pool_token.key(),
    seeds = [token_mint.to_account_info().key.as_ref()],
    bump,
    )]
    pub pool_token: Box<Account<'info, TokenAccount>>,
    pub token_mint: Box<Account<'info, Mint>>,```
Cool, no rush, happy to keep chatting about it!
Grr, have a meeting but will come back to this.  Thanks for taking the time.  I'm still trying to reconcile how this works out with the signing.
okay, great!
I'm still parsing these lines, and the ownership, but your last point is basically where I started with this in that there aren't two different entities just addresses, yes.   I though there were three accounts in play when I first did this.
That leads to a regular token account that lives at that specific PDA derived from your program though, yes
To be pedantic, that's not an associated token account‚Äîit's just a regular token account
Anyways lol the main takeaway is that associated token accounts are just regular token accounts with special addresses (their purpose is to give you an "obvious" address to use if you want to send person P some tokens with mint M)
As much as I have understood it: If am taking the program address and add a seed (here the Mint-address of the token): I will have a PDA.

```[pda, _nonce] = await PublicKey.findProgramAddress(
                [TokenMint.publicKey.toBuffer()],
                program.programId
            );```

I am initializing it with my Initialize call. It has the macros
```#[account(init,
    token::mint = token_mint,
    token::authority = pool_token,
    payer = user_authority,
    seeds = [token_mint.to_account_info().key.as_ref()],
    bump,
    )]
    pub pool_token: Box<Account<'info, TokenAccount>>,
    pub token_mint: Box<Account<'info, Mint>>,```

This leads to an associated token account at the PDA address pool_token, right?
Which gets invoked here: https://github.com/solana-labs/solana-program-library/blob/master/token/program/src/processor.rs#L284
https://github.com/solana-labs/solana-program-library/blob/master/token/program/src/processor.rs#L910
btw, If you've done this before, then all this is moot. So I'll just hunt for the explanation
Yeah, when you do a token transfer from A to B, the logical owner of the A token account (as stored in its `.data`) has to sign the tx
Pedantic is always welcome. üòÑ   Sorry, I meant who has to own the authority account.
Just to be pedantic, the program owner of a token account is *always* the spl token program
FYI What I'm hunting for - where the balance of the token is stored, and when someone does token transfer what program has to own the account.
This is going to take a second.  github.dev died this morning and I'm trying to find again where they allocate accounts in the token library.  I apologize in advance when I discover I'm wrong. üôÇ   Will be hunting for  abit.
Hey guys, kinda off topic question. I'm using @ solana/web3.js and I don't know if there is a way of adding callbacks when a transaction is done against a specific address? Any ideas?
So no, the token program itself works perfectly fine without the associated token stuff
The associated token program is purely for convenience, it's not essential
No, I think it's worth emphasizing that there are token accounts, and possibly, if you want, associated token *addresses*
Yes, I think so.  I read the actual spl token lib code and it was very eye crossing, and strange, and I could be wrong of course, but - When you create a "token" account, that just means they are creating an associated token account, and that's it.  It sounds like there are two "token accounts" but there aren't.  The token program expects that there is an account created via the Associated Token Program with the PDA scheme of  derived with `[owner, TOKEN_PROGRAM_ID, mint] with the ASSOCIATED_TOKEN_PROGRAM_ID as the owning program.
It's only the address that is special: it's a PDA derived from the associated token program, with seeds based on the mint + the logical owner
"Associated token account" is a tiny misnomer, it's really an associated token *address*. As an account it's just a regular token account
In the case above, on the command line, the logical "owner" is the wallet (a system program account)
Are you familiar with how associated token accounts work?
Can you say more? Not sure I'm following
See this is what I found really confusing - I think there's *only* an associated token account in the world of tokens.  like when you do `spl-token create-account --owner $MY_KEYPAIR $TOKEN_ADDRESS` on the command line, the owner is just a system program account and remains owned by the system.  The only other account created is the associated token account.
So in effect, it's the program that has authority over the tokens
Which in this case is the account's *own address", which works because it's a PDA
The "owner" logically-speaking is the authority
The program owner of a token account is always the token program (even for associated token accounts)
No, I'm saying do something like this:
```.rs
#[account(
    init,
    token::mint = some_mint,
    token::authority = my_own_address,
    payer = whoever,
    seeds = [...],
    bump = the_bump
  )]
my_own_address: Account<'info, TokenAccount>
```
I  think that would mean the token account's program owner is the token program then, which means his program will no longer be able to sign for that pda for other operations, right?  That's why I used two accounts if I recall correctly.
Then the token account's own address can be its authority
Why not just store the token account at one of his own program's PDAs?
That's kind of why I'm wondering why he's using associated token addresses at all here
Wouldn't he need an account for the PDA which is the authority of the associated token account?
The authority should be the owner of the token.
Do you not actually want to use an associated token address, but rather one of your own PDAs to hold a token account?
your authority is set to itself.
So they can't have your own seeds + bump etc.
Associated tokens are *already* PDAs of a *different* program, the associated token program
You can't use `seeds` and bump with associated_token:: constraints
There now seems to be something wrong with authority of the PDA account. I am now getting an "An associated constraint was violated". I still wonder if that is legal to refer the autority to the PDA.
 ```#[account(mut,
    associated_token::mint = token_mint.key(),
    associated_token::authority = pool_token.key(),
    seeds = [token_mint.to_account_info().key.as_ref()],
    bump,
    )]
    pub pool_token: Box<Account<'info, TokenAccount>>,```
Thank you very much, I am trying to fix it with your input! ‚ù§Ô∏è
To get the associated token account address, it's a PDA.  You can get it from 
```import { ASSOCIATED_TOKEN_PROGRAM_ID, Token, TOKEN_PROGRAM_ID } from '@solana/spl-token';
const associatedTokenAddress = await Token.getAssociatedTokenAddress(ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, mintPublicKey, tokenOwnerPublicKey)```
```
    #[account(  
        mut,
        associated_token::mint = mint,                  
        associated_token::authority = current_owner,        
        constraint = current_owner_token_account.amount == 1,        
    )]
    pub current_owner_token_account: Box<Account<'info, TokenAccount>>,    
    #[account(
        mut,
        constraint = current_owner.key() != user.key())]
    pub current_owner: AccountInfo<'info>,
    #[account(seeds = [PDA_SEED_MINT, bump = mint_bump)]
    pub mint: Box<Account<'info, Mint>>,
```
That's how I do it and it got rid of a lot of cryptic errors.  You just need to make sure you get the associated token account for the token owner in your client.
`constraint = user_paying_account.mint == tokenid::SOL`  and  `constraint = user_paying_account.owner == user_authority.key(),` do what the `associated_token::` fields do.
Just to cover all bases, and this may not be the cause of your issue, but your usage of `TokenAccount` in `SwapToken` doesn't use `associated_token::mint` and `associated_token::authority` I had trouble using existing TokenAccounts until I started passing in the associated token account.
It's a gotcha and the first thing I check when I get unauthorized errors.   That's strange since you didn't mark it as mut...
Yes, I can store Tokens and see them on the PDA address
good thing, to know!
Is the call to  initialize actually working?
First thing - I think you need to mark user_authority with #[account(mut)] otherwise it won't be able to pay.
Sure, I can also add the implementation, it is not so big. Using a 3 step process: 1) Init pool account, 2) deposit Token to swap for (not shown here) 3) send SOL, get token back
```#[derive(Accounts)]
pub struct Initialize<'info> {
    // User Accounts
    pub user_authority: Signer<'info>,    
    #[account(init,
    token::mint = token_mint,
    token::authority = pool_token,
    payer = user_authority,
    seeds = [token_mint.to_account_info().key.as_ref()],
    bump,
    )]
    pub pool_token: Box<Account<'info, TokenAccount>>,
    pub token_mint: Box<Account<'info, Mint>>,
    // Programs and Sysvars
    pub token_program: Program<'info, Token>,
    pub system_program: Program<'info, System>,
    pub rent: Sysvar<'info, Rent>,
}
#[derive(Accounts)]
pub struct SwapToken<'info>  {
    // User Accounts
    pub user_authority: Signer<'info>,
    #[account(
    mut,
    constraint = user_paying_account.mint == tokenid::SOL,
    constraint = user_paying_account.owner == user_authority.key(),
    )]
    pub user_paying_account: Box<Account<'info, TokenAccount>>,
    #[account(
    mut,
    address = tokenid::TARGET,
    )]
    pub recipient: Box<Account<'info, TokenAccount>>,
    #[account(mut,
    seeds = [token_mint.to_account_info().key.as_ref()],
    bump,
    constraint = pool_token.mint == token_mint.key()
    )]
    pub pool_token: Box<Account<'info, TokenAccount>>,
    pub token_mint: Box<Account<'info, Mint>>,
    #[account(mut,
    constraint = user_token.owner == user_authority.key(),
    constraint = user_token.mint == token_mint.key())]
    pub user_token: Box<Account<'info, TokenAccount>>,
    //rec_program: Pubkey,
    //usdc_mint: Box<Account<'info, Mint>>,
    // Programs and Sysvars
    pub token_program: Program<'info, Token>,
    pub system_program: Program<'info, System>,
}
pub fn initialize(ctx: Context<Initialize>) -> ProgramResult {
        msg!("INIT");       

        Ok(())
    }
pub fn swap_token(ctx: Context<SwapToken>, amount: u64) -> ProgramResult {
        msg!("SWAP TOKEN");
        
        if ctx.accounts.user_paying_account.amount < amount {
            return Err(ErrorCode::LowToken.into());
        }

        let cpi_accounts = Transfer {
            from: ctx.accounts.user_paying_account.to_account_info(),
            to: ctx.accounts.recipient.to_account_info(),
            authority: ctx.accounts.user_authority.to_account_info(),
        };
        let cpi_program = ctx.accounts.token_program.to_account_info();
        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
        token::transfer(cpi_ctx, amount)?;

        // Send Token back
        let cpi_accounts = Transfer {
            from: ctx.accounts.pool_token.to_account_info(),
            to: ctx.accounts.user_token.to_account_info(),      
            authority: ctx.accounts.pool_token.to_account_info(),
        };
        let cpi_program = ctx.accounts.token_program.to_account_info();
        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
        token::transfer(cpi_ctx, 10000)?;

        Ok(())
    }```
resolved thaxs
Need the actual code.
That error can happen a lot. Need to post your structs and your instruction code in order to help usually.
FYI - etiquette here is to not @ the mods.  They are really active and helpful so just be patient
simulation failed: Error processing Instruction 0: custom program error: 0x13c
<@!347689664855015424> any thought on this?
Also, need to post the rest of your struct.  Need to see if user_authority is marked a mutable, etc.
Can you post your instruction contents?
ok thanks
I got a question regarding PDAs. I am storing tokens in a pool (PDA), but I am encountering problems with the authority over that storage. I thought that my program would automatically be owner by using a PDA as storage. I wonder if I would need to create an additional PDA account only to act as an authority for my storage?


```#[account(init,
    token::mint = token_mint,
    token::authority = pool_token,
    payer = user_authority,
    seeds = [token_mint.to_account_info().key.as_ref()],
    bump,
    )]
    pub pool_token: Box<Account<'info, TokenAccount>>,
    pub token_mint: Box<Account<'info, Mint>>,```

When trying to transfer the tokens out I am getting
```Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account```
‚û°Ô∏è  I am so grateful of the level of support you provide here! <a:ScalebounceHeartRed:870562664412250182>
hmmm using `uint = "0.8"` seemed to work
Hey! I'm trying to add `uint = "0.9.0"` as a dependency and get this error:
```
cargo-build-bpf child: rustup toolchain list -v
cargo-build-bpf child: cargo +bpf build --target bpfel-unknown-unknown --release
error: package `uint v0.9.3` cannot be built because it requires rustc 1.56.1 or newer, while the currently active rustc version is 1.56.0-dev
```

But this is my rustc version
```
rustc --version
rustc 1.58.1 (db9d1b20b 2022-01-20)
```
if ive understood correctly
you could pass in the user's public key as a seed also, i.e. one `audience_account` per user
but dont know how to achieve this in rust
I want to be able to pass in the seed an integer that i can iterate in the front in order to create more audience account
what can I add to it in order to create more audience account
the point is my seed is not "variable"
```
----
#[program]
pub mod nft_lock {
    use super::*;
    pub fn initialize(ctx: Context<Initialize>, audience_account_bump: u8, audience_name: String ) -> ProgramResult {
        ctx.accounts.audience_account.bump = audience_account_bump;
        ctx.accounts.audience_account.name = audience_name;
        ctx.accounts.audience_account.authority = *ctx.accounts.authority.to_account_info().key;
        Ok(())
    }
    pub fn register(ctx: Context<Register>, checkin_account_bump: u8, token: String) -> ProgramResult {
        ctx.accounts.checkin_account.bump = checkin_account_bump;
        ctx.accounts.checkin_account.token = token;
        ctx.accounts.checkin_account.authority = *ctx.accounts.authority.to_account_info().key;
        ctx.accounts.checkin_account.audience = *ctx.accounts.audience_account.to_account_info().key;
        ctx.accounts.audience_account.register_count += 1;

        Ok(())
    }
}

#[derive(Accounts)]
#[instruction(audience_account_bump: u8)]
pub struct Initialize<'info> {
    #[account(
        init,
        seeds = [
            b"influenceur".as_ref()
        ],
        bump = audience_account_bump,
        payer = authority,
        space = 300,
    )]
    pub audience_account: Account<'info, Audience>,
    #[account(mut)]
    pub authority: Signer<'info>,
    #[account(address = system_program::ID)]
    pub system_program: Program<'info, System>,
}
-----------------------------------------
```
Hello, i have some issue i'm trying to fix in my program. This might due to my lack of knowledge in Rust language.
the folowing is my program and i want to be able to create many audience account:
book.anchor-lang.com
via faucet such as https://faucet.ropsten.be/
can anyone run by me what `#[program]`, `#[derive(Accounts)]` and `#[account]` do
```rust
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod myepicproject {
  use super::*;
  pub fn start_stuff_off(ctx: Context<StartStuffOff>) -> ProgramResult {
    // Get a reference to the account.
    let base_account = &mut ctx.accounts.base_account;
    // Initialize total_gifs.
    base_account.total_gifs = 0;
    Ok(())
  }
}

// Attach certain variables to the StartStuffOff context.
#[derive(Accounts)]
pub struct StartStuffOff<'info> {
    #[account(init, payer = user, space = 9000)]
    pub base_account: Account<'info, BaseAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program <'info, System>,
}

// Tell Solana what we want to store on this account.
#[account]
pub struct BaseAccount {
    pub total_gifs: u64,
}
```
How do i get other coins on devnet? Like usdc / eth / etc
isn't using vector a bad idea? I saw on a conference video, "he said avoid using vector and string"
Is there docs on how the program id is derived?
I have ANCHOR_WALLET set before all of my commands, yet if I delete the target directory, I get a new program id generated every time.
gotcha, thanks alan
I don't think there's any macro way to do it, just have to actually do it via a CPI.
How do I close a *token* account using anchor's macro? i know I can do `#[account(close = <destination>)]` to close a regular account
thanks üòõ
Yes you can üòÜ
how can I view my anchor transactions on solana explorer? the hash says its not found
looks like the answer is yes but just wanna confirm üôÇ
can i pass a dynamically sized Vec into an instruction?
Hey guys, is it just me or do you guys get an invalid blockhash error when anchor deploying programs?
Or update your os
So you're probably going to have to build solana from source (not via the installer, via a github checkout)
Aha, that sounds like your problem‚Äîthat error message specifically says something was built for os x 11.0
10.13.6 High Sierra
not an M1 mac
but solana --version returns 1.9.5
sh -c "$(curl -sSfL https://release.solana.com/v1.9.5/install)"
but i never updated the PATH if that was important, not sure at all what that meant .
Are you on a M1 etc?
Hmm, how did you install solana?

Hey guys! Keep trying to run an anchor test but i keep getting an error that i find on the internet but not with my compilers.... lazy symbol binding failed
Thanks, that worked, but if I close phantom and reopen it, the spinner returns 100% of the time...
Your `provider.wallet` signs the tx no matter what
Mm, yeah, sometimes this happens, not sure why yet‚Äîyou can "fix" it by switching networks to devnet or whatever and then switching back
Any trick to getting phantom to connect to solana-test-validator on localhost? I'm just getting a spinner.
thanks <:PoggersLove:825149316795596821>
hey guys anyone know how I can sign a transaction with my client wallet? Say I pass in an account owned by 'provider.wallet.publicKey' and want to sign a transfer instruction on the smart contract side with this account. I haven't seen a way to pass it in as a signer
thanks üëå
yes
How can I pass in a dynamically sized array into my txn?
is it safe to just use u64 instead?
Seems like anchor doesn't have a `Slot` variable?
I am trying to run my tests but get this error: `IdlError: Type not found: {"name":"slot","type":{"defined":"Slot"}}`
Sweet! Just found what youre talking about. Thanks tom
there is examples of using a const in `tests/misc/programs/misc/src/account.rs`
sweet. I will do this. Thanks so much Tom, really appreciate it üôè
if you did `const SIZE: usize = 5;` and removed that it would work
i pushed a fix for it in https://github.com/project-serum/anchor/pull/968/files but i think because of the casting to `as usize` it won't work correctly
that's so weird. Why can't i put in a const variable as a parameter for size?
omfgggg you were right
0.20.0
what version of anchor?
is this wrong?
```
const SIZE: i32 = 5;

#[account]
pub struct MyAccount {
  pub field: [u8, SIZE as usize],
}
```
they can for account data, but not for some other things like events
can array sizes not be const?
you've got a const for an array size in enum i think
The thread "main" panicked at Result::unwrap() on an err value?
Anyone know what's going on here?

```
To deploy this program:
  $ solana program deploy ~/Desktop/accrue/accrue/target/deploy/accrue.so
The program address will default to this keypair (override with --program-id):
  ~/Desktop/accrue/accrue/target/deploy/accrue-keypair.json
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: ParseIntError { kind: InvalidDigit }', lang/syn/src/idl/mod.rs:153:76
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```
Ah, gotcha. So a Rust client that talks to the chain?
different form cargo unit tests
there's a program_test crate made by solana for rust integration tests
nope
In other words, the JavaScript tests sort of killed two birds.
You mean [cfg(test)] in the rust programs?  If that's what you're talking about, I was wondering if that would be a quicker journey than through javascript.  However, I've noticed that as my tests grew, the amount of shared code grew, and then it turned into a javascript client library for building my transactions.  Kind of like how the CFO test started doing it.   That code is the exact code my web app uses, so I broke it out to a JavaScript lib that's shared by the anchor tests and the web app.
we really need some good program_test rust examples
The examples all use chai/mocha.
what testing frameworks/setup do most people run for anchor programs?


//////////////////////////////////////////////////////////////////////////////////////////

` The currently active rustc version is rustc 1.58.1`
Been stuck on this for a while. Would appreciate help üëå  thanks
I'm try to add this crate to my Cargo.toml:
```
[dependencies]
spl-token-lending = { git="https://github.com/solendprotocol/solana-program-library/", version = "0.1.0", features = ["no-entrypoint"] }
```

But I get this error when I run `anchor build`:
```error: package `uint v0.9.3` cannot be built because it requires rustc 1.56.1 or newer, while the currently active rustc version is 1.56.0-dev```
okay, running yarn worked, thanks
Depending on what version of anchor you're using you can also just run `yarn` inside your project directory
`npm install -g mocha`, or something similar (you need to install mocha)
hello, i am trying to run 'anchor test' and im getting an error saying command "mocha" not found, what should i do?
Will dig into the source some more to get a better view - thanks!
But no, no accounts are being created here
Have you tried jumping to source on the `SystemProgram.transfer` function?
<@!134416332509675520>  maybe you can clarify something else. I am looking at the https://docs.solana.com/developing/clients/javascript-reference and it says `Each TransactionInstruction consists of keys, data, and a programId` yet in the sample given, `programId` is not used anywhere. Does this mean that when you do 
```js
// Add an instruction to execute
transaction.add(web3.SystemProgram.transfer({
    fromPubkey: payer.publicKey,
    toPubkey: toAccount.publicKey,
    lamports: 1000,
}));
```
are the `from` and `to` accounts being created under the covers and are owned by the `SystemProgram`? 
Or are no accounts being created in this case?
Can anyone explain what is the difference between Ethereum Mint(Solidity) and Solana Mint?
I am an expert in Rust, but very beginner to Solana blockchain. I want help.
The `provider.wallet` is what pays for the tx fees, so it signs automatically
By not needing to add it do you mean manually or it's automagically added in the signer array?
If you're using phantom as your `provider.wallet`, you don't need to add it as a signer (and in fact, you can't, because phantom will never give you access to the wallet's secret key)
Does `provider.wallet.publicKey` work?
ohhh wow, Very glad u told me that lol thanks
No, you'll need to do `my_account.reload()?;` to update its struct stuff (its underlying `.data` field on the AccountInfo updates right away, but not the fancy anchor struct stuff on top)
(My guess is 2)
If I do a CPI call to change the value of an account, will I have the most up-to-date value for that account right after?

E.g. 
1. Do a CPI call to change SolendReserve.amount = 1 to SolendReserve.amount = 2
2. In the same instruction, get SolendReserve.amount. Would it be 1? or 2?
indeed
This makes things a bit weird for assoc accs
Huh, guess you can.
https://github.com/solana-labs/solana-program-library/blob/482a9281f6afcf149870cd60d9c2742a1cdda9bc/token/program/src/instruction.rs#L153
you can
thanks! super helpful
you can't transfer the ownership if I'm not mistaken, but you can delegate https://spl.solana.com/token#authority-delegation
does it transfer the ownership of the token account?
The authority is the  key which needs to sign to spend the tokens on the account. It's explained here https://spl.solana.com/token
What's the exact meaning of authority for spl tokens? https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html#spl-constraints doesn't seem to explain
how do I pass the connection to phantom wallet as signer of a transaction?

signers: [
          provider?
           ]
okay.. i ll check
I'm not familiar with the error but sounds like it could be something with the program id keypair. Maybe you're trying to deploy the contract to an address which doesn't match the keypair in ./target/deploy ?
same error occurs in anchor test too
Hey guys. Need your help. This error appears on running anchor test or anchor deploy.
switched to devnet -> anchor build -> changed program id in lib.rs and anchor.toml -> anchor build
after this anchor deploy gives this error

```
error: Invalid value for '--program-id <PROGRAM_ID>': unrecognized signer source
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.
```
Bummer. But thanks for the reply!
Ah, that unfortunately isn't possible to do inside your solana program, you always have to pass every single account you want to access in from the client
Thank you. What I meant is that I'm trying to find data that may exist among a bunch of [data] accounts owned by a program. With the `getParsedProgramAccounts(...)` you can use `memcmp` to grab slices and match data, then return the full account that matches, for instance. Haven't seen an example that does it within an Anchor program, though...
Fantastic explanation - thanks for that. You condensed a bunch of docs into a paragraph üëç
Maybe sticking closely to the usual close to be safu
https://github.com/project-serum/anchor/blob/df51a27a48e5d03005e841f383f407aef74e3555/lang/src/common.rs#L6-L24
Oh, right‚Äîgiven the issue above about not being able to deserialize it, should you just zero out its data too?
Mmmh careful with that, descriptor and data will remain, so a following ix can fund it to be rent exempt again.
You don't need to deserialize it in order to close it. Just pass it in as a `AccountInfo<'info>` and take its lamports/send them somewhere else.
that is an awesome explanation. Thank you very much! <:minecraftheart:930151977948684359>
i cant close it cuz i cant deserialize it ;-;
i can try to close it and then reinitialize it right?
what do i do here
But in general you can't really just change around existing fields, becaus yeah, when you try to deserialize the *old* account structure it won't look right according the new struct definition.
You probably don't have enough space in that account
I am getting a ```failed to deserialize account``` error after changing around some fields in the structs. how do i fix this?
It's an annoying implementation detail and anchor is hoping to automate some of it soon.
Each such choice of bump has about a 50/50 chance of working, so `findProgramAddress` may have to try a few different bumps (255, 254, 253...) until it finds something that works.
Briefly: program-derived addresses are sha256 hashes of the seeds + the deriving program's program_id (plus a fixed string, not important‚Äîtry jumping to source to see the exact details). The purpose of the bump is that each sha256 hash happens to have about a 50/50 chance of being an *actual, valid public key*, in the ed25519 cryptographic sense. PDAs are supposed to only be signable by their deriving program, so solana decided to force PDAs to *not* be actual, valid public keys. The trick to make this work is the bump: it's a u8 that starts at 255, and you stick it into the rest of the sha256 hash; if the resulting hash is "off-curve" (meaning, successfully *not* a real public key), then that's the bump; otherwise try bump = 254, etc., until you get lucky and the hash is off-curve.
Have you tried jumping to source on how `findProgramAddress` works?
I have no idea what the bump is and where I might need it. Also I could not find it explained anywhere in the documentation.
    I guess the seed is like an additional value I would pass add to a hash function like hash("1235..ab"+see)=new address .
     ```#[account(
        seeds = [vesting.to_account_info().key.as_ref()],
        bump = vesting.nonce,
    )]```
Ah, yeah, bummer
once i changed that to a hardcoded number it worked
ah ok it seems like the issue is me defining the length in rust as a global const - `weights: [u64; MAX_L],`
That error is coming from the IDL generation phase, not you calling it with JS
What version of anchor are you using? `anchor --version`
any ideas?
im trying to pass a [u64; 5] from js as an argument to an anchor instruction and getting this error:
```
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: ParseIntError { kind: InvalidDigit }', lang/syn/src/idl/mod.rs:153:76
```
ive tried it like this:
```
let s = [new anchor.BN(1), new anchor.BN(1), new anchor.BN(0), new anchor.BN(0), new anchor.BN(0)];
```
as well as a standard int array wrapped with anchor.BN()
Lots of examples of doing this in the anchor tutorials/tests
You would pass that other account into your program and then deserialize its data
Is there a way to perform getParsedProgramAccounts() from within Anchor? I'm trying to check to see if some data already exists in another program-owned account, and avoid creating a new one if the data (a public key), already exists within the account data.
This one also supports sollet web if I'm not mistaken https://github.com/solana-labs/wallet-adapter
https://github.com/project-serum/sol-wallet-adapter
looks like this is the way to go
are there any examples of integrating sollet web wallet with anchor?
heyo
is there a way to use anchor without setting the 'ANCHOR_WALLET` param? eg say i just want to run a js script that pulls data from accounts, but never generates any transactions, therefore doesn't require a wallet. If i try run my script without setting it, it errors out. but if i set it to a new/empty wallet , then it works
Did you ever figure out this issue? Or did you have to just use integers?
There is‚Äîat least for the first deploy. The program_id arg points to the full keypair, not just the public key
Ah, so there's no signing happening with the private key in the target directory?
The `keypair` is what pays for the deployment tx fees (and I think is then the upgrade authority, by default)
Ah, no, the program_id is the next argument, `--program-id`, which comes from `program.keypair_file()`
https://github.dev/project-serum/anchor/blob/9fea72e701813662a4af3733cb14ab713ebfdbef/cli/src/lib.rs#L2131

Looking at that code, it appears the key is pulled from the providers wallet, but the program id is inferred from the file name.    `let keypair = cfg.provider.wallet.to_string();` is what defines the keypair, not the keyfile in the `target` directory.  That seems wrong?
Yup, the private key is needed in order to create the account where the program will be uploaded to (which is it's program id). In order to create any account on solana you need to sign it with the respective private key (the address is the public key basically). That's why it's needed only on the first deploy. After that the upgrades handled by the upgradeable loader program are signed with the upgrade authority.
The implementation of `anchor deploy` (try searching for `fn deploy` in the anchor repo) seems to indeed hardcode the path from inside target
Hmm, I thought there was (you can definitely specify a specific keypair with `solana program deploy`) but maybe not with `anchor deploy`
Hmm.  So if you want a consistent address on devnet/testnet/mainnet you'd need to keep the key then, right?  Is there a way to tell anchor to use an existing key?
So you need the private key in order to do your first deploy, but you actually don't need it subsequently as far as I know (for upgrades a different keypair is used, the program's upgrade authority)
They keypair's public key is your eventual program_id, and its private key is used to create your program's account that lives at that address.
In my program, I want to hardcode different values depending on the cluster. Is there an easy way to get the cluster from the Anchor.toml file?
Running into an issue where I can't use f32 in my rust program, looks like others have similar issues: https://github.com/project-serum/anchor/issues/1353. Any advice?
Solution: Change the name of your smart contract: 
```
#[program]
mod newname {
```
I changed the name of my repo, and now `anchor build`  keeps generating an IDL with the old name of my repo. How do I fix this?


//////////////////////////////////////////////////////////////////////////////////////////

THANK YOU
You nailed it --> System account was labeled mutable, source of the error. Function works now:
Ok. Will check. Does the bump need to exist? I am not creating a PDA, so I wouldn't need a bump seed (to my limited understanding), but I haven't seen an alternative way to do it
The `system_program` itself can't be mut, so you should get rid of that last `#[account(mut)]`
`#[derive(Accounts)]
pub struct SendSol<'info> {
    #[account(mut)]
    pub from: Signer<'info>,
    #[account(mut)]
    pub receiver: AccountInfo<'info>,
    #[account(mut)]
    system_program: Program<'info, System>,
}`
Thank you. Good input. I feel like the accounts are configured correctly:
So you likely forgot to mark an account as `mut` (both the source and the destination of the sol need to be mut)
Lol. I think I see an issue = wrong program ID
0x7d0 = 2000 = https://github.com/project-serum/anchor/blob/master/lang/src/error.rs#L41
`Transaction simulation failed: Error processing Instruction 0: custom program error: 0x7d0`
What ends up going wrong?
Hey there. I have tried to modify this program (https://github.com/Kriptikz/anchor-pda-transfer-sol) to just use the send_sol function to a public key I provide (via my client).
What have you tried doing so far? PDAness won't have any effect on this
Cool, it does seems way simpler indeed ! I'll go with that üôÇ
Anybody know of a simple anchor example that uses a program to collect a fee to a static address (non PDA)?
You can do this
```.js
await program.rpc.yourInstructionThing(arg1, arg2, {
  accounts: {
    ...
  },
  preInstructions: [
     thatSignatureInstruction
  ],
  postInstructions: [ ifYouWant ],
});
```
Think you need to use WSL
how do I install it for windows?
`npm ERR! notsup Unsupported platform for @project-serum/anchor-cli@0.20.1: wanted {"os":"linux","arch":"x64"} (current: {"os":"win32","arch":"x64"})`
getting this error
trying to install anchor
Any example on best practices to do that ? üôè
What is the proper way to build an anchor ix when we want to do multiple ix in the same transaction ?
Currently doing this, but it feels very dirty :

```javascript
    const signatureInstruction = Ed25519Program.createInstructionWithPublicKey({
      instructionIndex: 0,
      message,
      publicKey,
      signature,
    });

    const AnchorInstruction = new TransactionInstruction({
      programId: program._idl.metadata.address,
      keys: [
        { pubkey: payer.publicKey, isSigner: true, isWritable: false },
        { pubkey: SYSVAR_INSTRUCTIONS_PUBKEY, isSigner: false, isWritable: false },
      ],
      data: new anchor.InstructionCoder(program._idl).encode('verify', {}),
    });

    const transaction = new Transaction();
    transaction.add(signatureInstruction, AnchorInstruction);
    
    const test = await provider.connection.sendTransaction(transaction, [payer]);
```
Yeah, in practice it makes the js code easier to read that way
Hello. I'm trying to the below tutorial.
https://project-serum.github.io/anchor/tutorials/tutorial-1.html#defining-a-program


Rust code is the below
```
    pub fn initialize(ctx: Context<Initialize>, data: u64) -> `ProgramResult {
        let my_account = &mut ctx.accounts.my_account;
        my_account.data = data;
        Ok(())
    }
```

And Javascript code is the below
```
await program.rpc.initialize(new anchor.BN(1234), {
  accounts: {
    myAccount: myAccount.publicKey,
    user: provider.wallet.publicKey,
    systemProgram: SystemProgram.programId,
  },
  signers: [myAccount],
});
```

In the Rust code, the context argument is written first, but in the Javascript code, it is last. Is it a rule for anchors that the Context should be written last in javascript?
`anchor test` runs the script specified in your Anchor.toml file (plus some other stuff‚Äîto see that other stuff you'd need to go read the anchor cli source, try searching for `fn test` in the anchor repo)
Think you can just do `*my_account` (so de-reference it)
someone know where can I found the script launched by "anchor test" and other anchor commands ? üôÇ
hey guys i'm trying to run anchor test on my pc keep getting the error below

Running: rustup toolchain list -v

Running: rustup toolchain link bpf /Applications/XAMPP/xamppfiles/htdocs/solana/bin/sdk/bpf/dependencies/bpf-tools/rust

error: not a directory: '/Applications/XAMPP/xamppfiles/htdocs/solana/bin/sdk/bpf/dependencies/bpf-tools/rust/lib'
gotcha! Tysm for the clarification üôÇ
That's correct and that's why the token authority is needed when creating a token account. It specifies who can spend from the account.
My guess is that the token authority has the ability to transfer the tokens, whereas mint authority can supply/mint new tokens, correct me if I'm wrong
is there a difference between mint and token authority? Because it seems like specifying a token authority that doesn't equal the mint authority is totally acceptable
when providing a token mint address in the creation of an account, why is a token authority needed?
Once all accounts are boxed/signers/Unchecked, where to look for in order to reduce `large stack variables`? I'm using 33 accounts <:pepesadHands:904036531277279293>
Yes problem is with the last version of anchor. Need to specify env variable.
`ANCHOR_WALLET=~/.config/solana/id.json yarn run mocha -t 1000000 tests/`
How to use Anchor with wallet-adapter?
that sounds like an issue with the idl
as far as I know, it has an implicit conversion under the hood so you can pass `Account<'info, MyAccount>` into a function that takes a parameter that is type `MyAccount`
anyone know why a String type would show up as ...unknown[] on the client side after being built?
I have a context with a field `pub my_account: Account<'info, MyAccount>`. 

I have a function that takes in `MyAccount`. 
how can I convert `Account<'info, MyAccount>` to `MyAccount`?
<:thonk:895614589562150913>  if i remove the newly added program and run the test, there's no error
oh strange, it seems to be related to me adding a new (4th) program within my project dir
nothing obviously related, hmm
hey frens, `anchor verify` does this work on dev/test nets? the documentation says `To verify a build against a program deployed on mainnet, run ...` and deploying to mainnet is a bit cost prohibitive at the moment
no nothing like that
hmm let me see if i can see what commit caused ci to start failing
Are you doing anything funny in your tests? Like, do they try to do something once the tests finish?
Ha, interesting, never seen that before
im running `anchor test ./tests/faucet.ts`
literally is just that <:what:866983240992292874>

Can you post more of the test output log?
i just see this error after them
the tests run
Unless something odd is happening with how you're installed the anchor cli, maybe (vague memory of this happening to someone else)
sorry maybe that wasnt a good explanation lol
You'll get that same os error if you have `test = "foo"`
Ok, then you need to install `npx`
sadly no
a bash terminal i think?
Oh, did that fix the error?
If you just type `npx` at the terminal, what do you get?
it did say `test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000"`

i updated it to `test = "npx ts-mocha -p ./tsconfig.json -t 1000000"` but no luck
That error isn't really an anchor error, it's your shell saying "I don't know how to run this thing you told me to run"
What does your Anchor.toml file say for its test command?
must be something local i guess
using 0.18.2, im sure i didnt have this a few days back
i think its a new error, ive not changed anything major locally
That usually means you don't have mocha or something installed (might depend on what version of anchor you're using)
`Error: No such file or directory (os error 2)` started to see this after running `anchor test` locally and in CI, any ideas? read previously around ds_store files but ive removed all of them
how do i specify lib.path?
but now getting Failed to obtain package metadata: `cargo metadata` exited with an error: error: failed to parse manifest at `/Users/carlosdelrio/myepicproject/programs/myepicproject/Cargo.toml`

Caused by:
  can't find library `myepicproject`, rename file to `src/lib.rs` or specify lib.path
still trying to run anchor test
Hey guys, updated my OS
`= "x.y.z"` is equal to `= "^x.y.z"`. The `= "=x.y.z"` guarantees that only this exact version will be used. <https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html>
Or does uint have to be in the brackets of `spl-token-lending`?
for this, do u mean just doing:
```
[dependencies]
spl-token-lending = ...
uint = "0.9.1"
...
```
It's not possible: would be, if sysvar supported it. But only from instructions, you can't extract this info. Solana team probably recognized that such feature is not required for any meaningful application, but we might see it implemented in the future, who knows (if there's no security or any other implication).

No, we will probably never see this. What runtime does is that it goes through the raw transaction and prepares the data as an input to the rBPF VM. When you go through the accounts in the program itself via `solana_proram`, what you see is in the account struct is already preprocessed, e.g. signer and writer fields are not part of the instruction or transaction itself, they are smartly encoded in the message header of the raw transaction, which is recognized and added by the runtime before execution.

It'd likely be a big overhead if `solana_program` was meant to bring the raw tx data back to the on-chain program and let you iterate over it. The only sensible thing is maybe to prepare a simple function that would just return the pubkey of the fee payer. But I wonder if it's somehow useful.
Yeah, that's my understanding too‚Äîdon't think instruction sysvar is quite enough info
<@!134416332509675520> it'd be possible, if sysvar provided not just access to instructions (you can introspect other instructions from the tx), but also the transaction itself, then the fee payer would be the first pubkey from the tx account list, if I'm not mistaken. Fee Payer is always the first account, right? https://docs.rs/solana-program/latest/solana_program/sysvar/index.html
would u mind showing the whole block of code?
This is kind of dumb, but seemed to work by just manually specifying a dependency on `uint = "=0.9.1"` in the program's Cargo.toml üôÑ
Yes that was exactly my point. Indeed, I see there is no field for this even in `AccountInfo`. Thanks üôÇ
Sort of the best you can do in general is ask some account to sign the tx, but that doesn't strictly speaking guarantee that they were the fee payer
In general you can't necessarily get access to this info, unfortunately
Yes you are right, mb üôÇ
That would be the pay-er üôÇ
I'm no trying to pay. I want to get from the anchor program the pubkey of the user who paid for the transaction (the payee)
What do you mean? Who are you trying to pay?
Is there an easy way to get payee pubkey in anchor ?
Ok, well, that 1.56.0-dev is coming from how solana install's a special bpf toolchain
Is it possible to get the config public key related to a candy machine v2 when fetching its state?
I think you'll be better reading up the last link and the next page in that doc üòÑ
after verifying?
üòÇ üò≠
Lol, where the fuck is this 1.56.0-dev coming from üòµ‚Äçüí´
`anchor publish` ultimately
https://project-serum.github.io/anchor/getting-started/verification.html#verifying
how do the programs get listed there? anchor build --verifiable?
thx
https://anchor.projectserum.com/
Where can I find verifiable builds on a website? what was the url?
very weird that it's saying that we have the wrong version of rust tho.. idk. whatever
no worries! we tried üò§
Heh, trent does know what he's talking about though, so maybe I'm wrong üòõ
Still fiddling though
Yeah, I don't think that's the problem (I saw your post in the solana discord)
im gonna try some other workaround solutions, instead of using `git` as the parameter
hmmm i think part of the problem is that the outer `Cargo.toml` is a workspace, and not a crate?
Taking a look, can now reproduce that error on one of my own repos
Does anyone have a solution to the rust version problem I mentioned above?
The rust nightly version aren't stable.
Any ideas on how to speed up fetching data? Maybe an API that indexes and saves in redis?
well, you can upgrade it to `1.6.0` with nightly version.
```
rustup toolchain install nightly
rustup default nightly
```


//////////////////////////////////////////////////////////////////////////////////////////

how can I iterate an array of 5000 elements and check if a passed element exists or not in it in anchor ?
Boom üí• 

> % anchor --version
> anchor-cli 0.20.1

Time to have some fun. Thank you! üòä
It looks like that could be it. Trying now. Thanks üôå
maybe you need `libssl-dev` also?
Looks like I have it installed ‚úÖ
> % openssl version
> OpenSSL 1.1.1  11 Sep 2018
How do I determine if openssl is installed?
(I am a Ubuntu noob)
>  run pkg_config fail: "`\"pkg-config\" \"--libs\" \"--cflags\" \"openssl\"` did not exit successfully: exit status: 1\n--- stderr\nPackage openssl was not found in the pkg-config search path.\nPerhaps you should add the directory containing `openssl.pc'\nto the PKG_CONFIG_PATH environment variable\nNo package 'openssl' found\n"
> 
>   --- stderr
>   thread 'main' panicked at '
> 
>   Could not find directory of OpenSSL installation, and this `-sys` crate cannot
>   proceed without this knowledge. If OpenSSL is installed and this crate had
>   trouble finding it,  you can set the `OPENSSL_DIR` environment variable for the
>   compilation process.
> 
>   Make sure you also have the development packages of openssl installed.
>   For example, `libssl-dev` on Ubuntu or `openssl-devel` on Fedora.
> 
>   If you're in a situation where you think the directory *should* be found
>   automatically, please open a bug at https://github.com/sfackler/rust-openssl
>   and include information about your system as well as this message.
> 
>   $HOST = x86_64-unknown-linux-gnu
>   $TARGET = x86_64-unknown-linux-gnu
>   openssl-sys = 0.9.71
> 
>   ', /home/eric/.cargo/registry/src/github.com-1ecc6299db9ec823/openssl-sys-0.9.71/build/find_normal.rs:180:5
>   note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
> warning: build failed, waiting for other jobs to finish...
> error: failed to compile `anchor-cli v0.20.1 (https://github.com/project-serum/anchor?tag=v0.20.1#a81ff88d)`, intermediate artifacts can be found at `/tmp/cargo-installkc2QUt`
When I last did this there was nothing special to do
Hi there üëã 

I'm having some trouble installing on Ubuntu under WSL 2 on Windows 10. Will do a bit of reading of previous issues, but if there is anything special to take care of with this setup, please let me know üôè
btw on the line where you're doing `amount * 1000000000` it's better to use the `LAMPORTS_PER_SOL` constant in order to avoid any errors with the conversion  https://github.com/solana-labs/solana/blob/master/sdk/program/src/native_token.rs#L3
Thanks a bunch! üòÑ
Yea, basically you're implementing an "admin" instruction. What you do is you  load the program's `upgrade_authority` and verify that it has signed the tx. Here's an example https://github.com/project-serum/anchor/blob/master/tests/bpf-upgradeable-state/programs/bpf-upgradeable-state/src/lib.rs#L64. Make sure you do all the constraints correctly.
Hey quick question, is there a way to get the details about the deployed Program itself (i.e. the info you get from the cli `solana program show [PROGRAM_ADDRESS]`) inside of the Anchor program?

Additional context: I have an "Initialize" instruction that needs to be run after deployment, and to be extra safe I want to be sure that this instruction is only run by the same Address that deployed the program.
this is how I did it for a program where the "user" pays an amount to a "receiver"
disregard item1 and item2 which are accounts that increment based on the amount transferred.

Solana Pay might be a better way to transfer SOL between accounts if you can figure out how to use inside an anchor program

```
    pub fn pay(
        ctx: Context<Pay>,
        amount: u64,
    ) -> ProgramResult {
        let item1 = &mut ctx.accounts.item1;
        let item2 = &mut ctx.accounts.item2;
        let user: &Signer = &ctx.accounts.user;
        item1.amount -= amount;
        item2.amount += amount;


        let ix = anchor_lang::solana_program::system_instruction::transfer(
            &ctx.accounts.user.key(),
            &ctx.accounts.receiver.key(),
            amount * 1000000000,
        );
        anchor_lang::solana_program::program::invoke(
            &ix,
            &[
                ctx.accounts.user.to_account_info(),
                ctx.accounts.receiver.to_account_info(),
                ctx.accounts.system_program.to_account_info(),
            ],
        );

        Ok(())
    }


// Pay SOL
#[derive(Accounts)]
#[instruction(amount: u64)]
pub struct Pay<'info> {
    #[account(mut)]
    pub item1: Account<'info, DataAccount>,
    #[account(mut)]
    pub item2: Account<'info, DataAccount>,
    #[account(mut)]
    pub receiver: AccountInfo<'info>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[account]
pub struct DataAccount{
    pub creator: Pubkey,
    pub name: String,
    pub amount: u64,
}

```
The keypair doesn't have authority over upgrading the program. It's needed only to deploy the program the first time (which will also set the upgrade authority).
There was a discussion about this recently here https://discord.com/channels/889577356681945098/889702325231427584/939253575886975026
the `target/deploy` keypair is what im interested in, what is it for, does it have authority over program deployment? if so, it should be kept secret. but then, to keep the code unchanged (due to `declare_id!` requires program id). the keypair needs to  be shared...
Pubkey::from_str(<string>)
how to create pubkey from string
I guess you use this https://github.com/solana-labs/solana/blob/master/sdk/program/src/system_instruction.rs#L390 to create the instruction and call it with CPI
Kind of. It's not really "signing" it but when you're creating a PDA account you need to call the create_account instruction using `invoke_signed` method and provide it the seeds used to generate the PDA. The runtime then checks the seeds and program id of the program you're calling from and if it matches then the instruction is considered to be "signed" by the program.
`token_program: Program<'info, Token>`
When creating a regular account it has to sign the transaction, is there a similar constraint for PDAs?
what's a better way to write this ? ```    #[account(address = anchor_spl::token::ID)]
    pub token_program: AccountInfo<'info>,```
Hey guys, is there any reference on how to transfer SOL to and from accounts using anchor?
its running on the test validator (the first 2 tests run fine, only the last one breaks, not sure why)
Perhaps your test validator isn't running or you're running the test against devnet?
It is possible. If by local dev machines you mean the `solana-test-validator`, it's possible to start it with the `--bpf-program` flag which will pre-add the program at the specified address. The other way to do it is to use the generated program keypair in the `target/deploy` directory.
im using mac m1 btw
(its also not an issue with the tests/program cause on a linux vm the tests run fine, it only breaks on my m1)
<@!851910655334023168> everything is synchronous in Solana programs and CPIs return either `() or ProgramError`. What do you need to read?
<@!134416332509675520> Thanks
Hi, is it possible, or make sense, to make program id consistent across muliple local dev machines as well as mainnet deployment? if not what would be the way to go
Yep, that's fine, `hash.as_bytes()` I think
Hi,
Could we use a string passed as input to derive our pda seed? I mean

```rust
#[derive(Accounts)]
#[instruction(bump: u8, hash: string)]
pub struct Initialize<'info> {
  #[account(
    init_if_needed,
    payer = payer,
    seeds = [
      b"gamba", 
      hash.as_ref() <== is there someworking solution here?
    ],
    bump = bump
  )]
...
}

pub fn handler(ctx: Context<Initialize>, bump: u8, hash: string) -> ProgramResult {
..}
```
Thanks
<@!195345150132748288> did you find a solution to this?
i get this error when running slightly long tests: 
```
Error: Unable to obtain a new blockhash after 10149ms
```
anyone dealt with this before?
what do ppl usually do to get around this? like if I want to validate something about one of the accounts being passed in, I obvs cant make an API call
like would the program being called just write to a 3rd account which then the initial invoking program reads from?
do I understand correctly that I cant actually wait for the return value of a CPI?
any examples of creating a mint owned by the program so it can mint/burn them?
Hi. I'm trying to use ```anchor build``` in subdirectory but I'm getting error ```no such subcommand: `build-bpf```.
Having trouble installing on Mac M1. I'm following this guide: https://github.com/buildspace/buildspace-projects/blob/main/Solana_And_Web3/en/Section_2/Resources/m1_setup.md 

And getting this error: "dyld[26505]: symbol not found in flat namespace '_BIO_free_all'" When running "solana-test-validator --no-bpf-jit" according to the guide
bump for anyone who may have some idea on this, thanks
are there any examples of staking programs built with anchor?
hey fam
I am guessing I can use the under the hood method of the Account<'info, T> wrapper but unsure where it is
how do i deserialize the array of remaining_accounts into my specific account struct?
definitely keep at it
lol promise it looks worse than it is
I‚Äôm over here stuck trying to build an environment looking at your problem like jeez, idk if I ever want your problems lmao
Will having multiple copies of anchor files in my directories be an issue at all?
does anyone have any idea why there might be duplicate of same tx in solana logs?

```

[2022-02-06T22:06:07.281682000Z DEBUG solana_runtime::message_processor::stable_log] Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [1]
[2022-02-06T22:06:07.282005000Z DEBUG solana_runtime::message_processor::stable_log] Program log: Instruction: InitializeMint
[2022-02-06T22:06:07.282131000Z DEBUG solana_runtime::message_processor::stable_log] Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 2279 of 200000 compute units
[2022-02-06T22:06:07.282325000Z DEBUG solana_runtime::message_processor::stable_log] Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success
[2022-02-06T22:06:07.340233000Z DEBUG solana_runtime::message_processor::stable_log] Program Vote111111111111111111111111111111111111111 invoke [1]
[2022-02-06T22:06:07.340433000Z DEBUG solana_runtime::message_processor::stable_log] Program 11111111111111111111111111111111 invoke [1]
[2022-02-06T22:06:07.340540000Z DEBUG solana_runtime::message_processor::stable_log] Program 11111111111111111111111111111111 success
[2022-02-06T22:06:07.341072000Z DEBUG solana_runtime::message_processor::stable_log] Program Vote111111111111111111111111111111111111111 success
[2022-02-06T22:06:07.426774000Z DEBUG solana_runtime::message_processor::stable_log] Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [1]
[2022-02-06T22:06:07.427001000Z DEBUG solana_runtime::message_processor::stable_log] Program log: Instruction: InitializeMint
[2022-02-06T22:06:07.427125000Z DEBUG solana_runtime::message_processor::stable_log] Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 2279 of 200000 compute units
[2022-02-06T22:06:07.427279000Z DEBUG solana_runtime::message_processor::stable_log] Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success
```

as you can see `InitializeMint` appears twice, but I promise I'm calling it once. The timestamps differ perhaps my log filter is misconfigured?
In this case, if you wanted to make this `mut` then you would have to change the type to be at least `AccountInfo` right?
Getting this after anchor test Failed to obtain package metadata: `cargo metadata` exited with an error: error: failed to parse manifest at `/Users/carlosdelrio/myepicproject/programs/myepicproject/Cargo.toml`

Caused by:
  can't find library `myepicproject`, rename file to `src/lib.rs` or specify lib.path
https://docs.rs/rust_decimal/1.21.0/rust_decimal/struct.Decimal.html

Is this safe to use?
need max value of at least `u64::MAX`
how does one do decimals in rust üòÇ


//////////////////////////////////////////////////////////////////////////////////////////

if by create, you mean "is owned by a program", then only that program can transfer lamports out of the account (only a single program can create accounts, the system program). other programs can add lamports to the account though
hi guys! just wanna clarify, if a program creates an account, the lamports in that account cannot be transferred out no matter what right?
thanks ser!
exactly
i see! so should i add another string or u8 to the seed and store that value inside the account struct to differentiate between PDAs?
definitely don't do that
no big footgun
is that a recommended pattern?
cam you have different PDAs initialzied with the same seeds (using different bumps)?
I want to fetch all transactions (ever happened) for a wallet. How should i go about it? Any API/Doc i can refer to?
But yeah, I'm saying that you need to figure out what your program's *actual*, deployed program id is, and use it in both Anchor.toml, IDL, declare_id!, etc. (everywhere)
It's a completely separate account‚Äîin bfriel's tutorial it has a fresh keypair address
The voteAccount is completely separate from the program ID, like no relation whatsoever
what you are saying is the programID has to be the same across the IDL metadata address and the `declare_id!` call, but that this isn't the same as the voteACcount
If it's actually the *same* key, then you messed up how you deployed it, maybe
Right, I'm saying you'll need to run `anchor keys list`, it's likely a different key
ah nvm
If you follow the code snippets, you can see that: `const programID = new PublicKey(idl.metadata.address);` and `metadata": {
    "address": "7Ntd1GePKvSSYseiHqdk88k3mRLaQrMxmGnnoVpn8QQd"
  }`.  Additionally, in lib.rs they have `declare_id!("7Ntd1GePKvSSYseiHqdk88k3mRLaQrMxmGnnoVpn8QQd");`
The programID etc. is not the same thing as the voteAccount, or am I misunderstanding your question?
Ah, I think yo're confused about the difference between the actual program itself vs the voteAccount (two totally different accounts)
is this group appropiate for substrate devs?
Try doing `anchor keys list`
so here the programID being used is the same as the voteAccount
and https://github.com/bfriel/crunchy-vs-smooth/blob/master/app/src/utils/index.js, notably `export const programID = new PublicKey(idl.metadata.address);`
Ok, so when you did `anchor deploy` (if you did) it printed out a program id
https://github.com/bfriel/crunchy-vs-smooth/blob/master/tests/crunchy-vs-smooth.js#L11 is using a fresh keypair for the voteAccount
https://github.com/bfriel/crunchy-vs-smooth/blob/master/app/src/idl.json#L68 notably `"metadata": {
    "address": "7Ntd1GePKvSSYseiHqdk88k3mRLaQrMxmGnnoVpn8QQd"
  }`
Ok, cool. So how did you end up using that same exact id for the voteAccount?
https://github.com/bfriel/crunchy-vs-smooth/blob/master/programs/crunchy-vs-smooth/src/lib.rs#L3 notably `declare_id!("7Ntd1GePKvSSYseiHqdk88k3mRLaQrMxmGnnoVpn8QQd");`
I'm saying that that error above is coming from you accidentally trying to talk to the wrong program id (or maybe the right program id, but you didn't deploy it correctly, etc.)
Ah I see - so I think the solution would be to use a PDA derived from program 1 as the explicit Signer<> account in the CPI call to program 2, add this PDA to the allowed list of callers to program 2, and probably also transfer the requisite lamports needed from the user to the PDA in order to pay for the account created by the program 2 CPI instruction... Thanks for your help!
Sure, but I'm unclear why they would end up having the same address (they definitely shouldn't)
We've already created/deployed the program (which is what we've deployed). The vote account is supposed to be the data store.
Mm, they shouldn't be the same‚Äîcan you point me to where they end up being the same in the tutorial?
To clarify, my question here is: why is the voteAccount public key is the same as the deployed program id? Shouldn't these be separate things?
So you actually don't need to do anything to have that user signature also work for the CPI.
Also, note that if the user signed the tx from their client, then that signature carries over across CPIs!
Yep, this is what PDAs are for: they are funny addresses that can *only* be signed for by their deriving program.
That means you're not using the right program id somehow‚Äîif you're deploying your anchor program, you might need to check what its actual program_id is (as printed by the deploy) and stick it in your Anchor.toml + declare_id!, etc.
follow up question - can a program sign a CPI instruction? say if I had a user call program 1, but program 1 needs to make a CPI call to program 2, which has an allowed list of callers and will initialise a new account, the user can't sign that instruction, but can program 1? so far it looks like the answer is no but I'm struggling to reason why
I went through brian friel's crunchy vs smooth anchor guide. For those who haven't seen it would highly recommend. Had a follow up question that I posted as a reply to his tweet https://twitter.com/0xjayepeg/status/1491067386778521601 - would love some input here from you guys <@!501570363566587905> and anyone else who's an expert here!
OK
Anyone know about NFT merging and unmerging?
After the program invocation fetch the account and read the account content
Thanks got it)
haha no worries! I thought it was a good question
something like 

```
#[account]
pub struct UlyanaTokenAccount {
  pub token_acc: Pubkey,
  pub my_field: u8,
  ...
}
```
I would highly recommend that approach
You can create a new account that has a `pubkey` link to the original token account, as well as the new field you want
yeah, but I want to create another one, something like TokenAccount struct with pre-allocated extra space for extra field.
Yeah it does - I've since worked out that I was being a dummy and that the signer/payer of the first call looks like they do indeed pay for the CPI calls - I was testing locally and forgot to airdrop ü•≤
Does the CPI call create a new account or something?
you cannot do that, since the TokenAccount is owned by the TokenProgram
read the docs on the website, they explain that
Hey guys! Maybe someone knows how to extend TokenAccount with an additional field or is it even possible?
Who pays for a CPI call? I'm trying to get program 1 to call an instruction in program 2 but I'm getting an insufficient lamports error. How can I get the original caller of program 1 to pay for the CPI call, or have I fundamentally misunderstood something?
Here's some resources for you
- https://pencilflip.medium.com/solanas-token-program-explained-de0ddce29714
- https://paulx.dev/blog/2021/01/14/programming-on-solana-an-introduction/#the-token-program-part-1
You can check the anchor repo -> tests -> ido-pool example
Bear for more questions. Coming from Eth/terra background, trying to make sense of Solana's development model.
This is to be done on client side or backend? Can you guide to an example?
you need to set the mint's owner (mint authority) to a program derived address
How to create a token whose mint is Solana program?
i hv question, what does anchor js really do ?
hello
any simple anchor examples
how to mint NFT programmatically
Thanks got it.
this is because the `number` type in js can only store up to 53 bits, but the number you have is larger than that. There's no way to convert it to number. Use the BN  to do your calculations.
Is it possible to get  txns of a particular RPC call ? like I have a update method I want to know the txns involved with that method. I know txns are related with accounts but is there any way to filter account txn for a particular RPC method call ?
any resources related to the above, solana vanilla or anchor either thing works.
which then can be displayed on phantom
so i have an idea of how nfts work in the theoretical sens but wanted to do it from scratch to understand it better is there any existing tutorial which makes an nft form scratch i.e make a spl token mint, attach spl-metadata to it, store it in arweave and mint its token
tried `BN.toNumber()` but got an erorr `Uncaught Error: Number can only safely store up to 53 bits`
Hey how can I convert BN to number in js
hey guys, i ran into this error while trying to run some anchor code, what's the meaning of this error ?
```
Error: Program's authority Some(JEETbGbfaqfvTdzGYLLtxTMkmrR2bHPH9oDWbme5Xj3L) does not match authority provided AYCBZSFpvef3FjQjk7Sk56whMC2mU4hzYQaxnHWZ5TQM
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.
```
I did
You don't have `mocha` installed
Hi. I'm trying to deploy after ```anchor build``` but error came up ```Failed to run test: mocha -t 1000000 tests/: No such file or directory (os error 2)```.  It looks like OS issue. I'm using Mac M1 now. what cause this error?
got it - some extra lines of code in there related to anchor doing all the verifying accounts and other checks that I probably wouldn't think of on my own
Your program is almost certainly several hundred kbs.
To keep a number in mind, rent-exemption + the 2xing means it costs about 1.4 sol / 100kb to deploy.
Yep, it's for rent-exempting your `.so` file. The default deploy command also 2x's the storage so you can upgrade your program later.
ok, thanks - is that because of the program storage requirements? I just did `solana rent 250000` on devnet and got 1.7 sol - so the anchor program is approximately 250kb?
Should some of those be Saved in the programs folder?
Mm, you don't have any programs at all in your `programs/` directory (that won't work‚Äîdid you delete the default one?)
Unfortunately deploying actually takes a lot of sol
You can ignore the messages (somebody forgot to get rid of a log line in the solana cli tool, lol)
Can I subscribe to a random account's changes on the Solana blockchain?
this seems like a lot to deploy the basic 3 program to devnet - is this right? 
`Error: Account xxxx has insufficient funds for spend (1.80334296 SOL) + fee (0.001295 SOL)`
It is also printing a ton of msg s with the same id

Now do that inside `programs` (or type `ls -la programs/`)

That was cool 
What is ls -la
~sounds like it's bonking because it can't find `myepicproject` in `programs/`. what do you get if you `ls -la programs`~  scratch that - actually maybe an error in `myepicproject/Cargo.toml`
Carloss-MBP:myepicproject carlosdelrio$ anchor test
Failed to obtain package metadata: `cargo metadata` exited with an error: error: failed to parse manifest at `/Users/carlosdelrio/myepicproject/programs/myepicproject/Cargo.toml`

Caused by:
  can't find library `myepicproject`, rename file to `src/lib.rs` or specify lib.path
I have a feeling its something to do with the way i saved all these files on my mac but i keep getting this
I'm just starting myself, but what seems to be the problem?
HIIII EVERYONE, I AM A DETERMINED FELLOW JUST LOOKING FOR SOME HELP... ITS GOTTEN DESPERATE SO IM WILLING TO PAY! $20 TO THE PERSON WHO CAN HELP ME RUN                       anchor test
And then once all the programs have been deployed together with the deploy command are programs then upgraded individually, passing the program id and file path?
Is it build, then calc the pubkey string from the keypair.json in deploy and update the `declare_id!` macro and `[programs.localnet]`?
my version says 0.20.1. the init and new commands create Cargo.toml's with editions of 2018 and `declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");`
Could I trouble someone for a link on best practice for program ids?
The instruction module generation is here https://github.com/project-serum/anchor/blob/master/lang/syn/src/codegen/program/instruction.rs
1. https://github.com/project-serum/anchor/blob/master/lang/syn/src/codegen/program/accounts.rs
2. https://github.com/project-serum/anchor/blob/master/lang/syn/src/codegen/accounts/__client_accounts.rs
Then the `#[program]` module aggregates all the various derive macro by re-exporting the types inside the private derive modules
First all the derive macros create a private module and type.
The accounts module is a bit tricky.
what's a good way to debug a struct not de-serializing correctly in the frontend? building off the tic-tac-toe example in the Anchor book and I tested everything on the backend but when I sent the board struct back to the frontend it fills in the same slot on the board no matter what {row, col} input is chosen
Speaking of, where in the Anchor repo is the code that generates those modules?
fucking legend. Just realized the packages are there and the code builds, but VS code just doesn't recognize the generated modules. Is there an extension needed to resolve those warnings?
those modules are created by the macro
run cargo doc to see them
Running 0.20.1
There's the comment which says `// The accounts and instructions modules are generated by the framework.` but I don't see those for my program crate. Is there something special to do to enable these modules?
anyone know what to use in `findProgramAddress` in js to match a `&[u8; 30]` in pda seeds in rust? tried variations on Buffer.from(), Uint8Array.from(), etc but keep getting either `signer privilege escalated` or `seeds do not match`
see the example here https://github.com/project-serum/anchor/tree/master/client/example
kind of, though not exactly the same
Does anchor auto-generate a Rust client similar to the TS client?
üò¢
Exactly
You can do that also but then you dont have mint authority which can be annoying
to use for testing
but then we wouldn't be able to mint other ppls tokens lol
thanks, or maybe even pick some random tokens that ppl already created
Yea, thats what I do.
how do ppl usually test programs in devnet that have dependencies on Token program and other programs? any best practices or do you create dummy tokens to use and pretend like, this is USDC and this is SRM
you can do it in js, just add both instructions to the same tx.
would that be possible if youre allocating the mint space in js and then calling initialize_mint from rust, or would both have to be in rust?
i read in the source file for initialize_mint that you need to create the account and turn it into a mint in the same transaction for security reasons?
oh ok makes sense - i just switched to init'ing the mint in the context in the meantime
So you can't pass in a totally fresh keypair
Ah, the error you're getting now though is that you actually have to allocate the mint's space ahead of this instruction.
It was added to the repo six months ago though, so I figured it would already be deployed
Hmm, interesting. Maybe the version of the spl token program that's deployed doesn't support the mint2 instruction?
the token program is the token program, same with rent sysvar, the mint is a pubkey from a fresh keypair, and the mint_authority is a pda owned by my program
switching to initialize_mint instead of initialize_mint2 now gets me ```Program log: Instruction: InitializeMint
    Program log: Error: InvalidAccountData```
Interesting, not sure why that wouldn't work‚Äîwhat you have their looks pretty reasonable to me
Looking at IDO pool code why do we need to have a redeemable_mint. can't we keep track of contribution of user USDC on a PDA  and then calculate final price based on that?
the `mint` im passing in from ts is just a fresh keypair
does anything seem wrong with this call? im getting 
```Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [2]
    Program log: Error: Invalid instruction```
Ok that‚Äôs interesting, thanks. In theory that means even if the program decrypted it would write unencrypted for anyone to read on said new account
So the way you can "return" something to the client is by having the client pass in a "return account" where the program should write its answer/return value to.
It can compute on data read from accounts, but all it can do is then write that computation back out into some other account
I‚Äôd have to build a custom wallet to expose encrypting using a wallets private keys which seems like an adoption barrier. Jabber seems to have done just that for the encrypted messaging.
so it can‚Äôt actually compute on data read from accounts?
You mean your solana program itself? Your solana program itself actually can't even really "return" anything at all‚Äîall it can do is read/write to accounts.
I‚Äôm trying to efficiently store encrypted string data on accounts (so much secret). Any possibly that programs can encrypt/decrypt data stored on accounts using the program‚Äôs keys and return unencrypted strings to user? I know data is then travelling unencrypted on the final leg but at least it‚Äôs still encrypted on the accounts. The popular wallets don‚Äôt expose a decrypt feature and I don‚Äôt want to store a second set of keys somewhere centralised!
ahhh interesting
Its because the token program will try to mutate the accs and the runtime wont allow it
It will compile but the cpi call will fail when you call the instruction
The program seems to compile even when I don't have `mut` though
Yes
**Question**: Say I have a Context with `mint` and `user_account`. I want to mint tokens to `user_account`. This would change mint's supply and user_account.amount

```
let mint = &??? ctx.accounts.mint
let user_account = &??? ctx.accounts.user_account

mint_to(..., mint, user_account)
```

Do I need to make these variables `mut`, because they're changing?
most of that uses rust. user the `iter()` function to iterate in an array


//////////////////////////////////////////////////////////////////////////////////////////

you only pay for space the first time you deploy
you don't
i'm not sure about that one
that's cool - then in either upgrade or deploy if it's been deployed before and you haven't changed the id, you don't incur cost for more space?
When you deploy again, you're essentially upgrading the on-chain program (same program ID). If you create a new account for the program, you'll deploy it to a different address (and the original one will stay unmodified on the blockchain)
what happens if you deploy again vs upgrade? re-use the existing account vs. creating a new one?
Don't think there's really a "right" way of doing things unfortunately. You just need to think carefully about what you're worried about, and remove/reduce that worry by checking things with your tests.
If I were to test every part of my program, it would take ~200 tests. For example, checking the signer actually signed the txn for each instruction, checking if they own the account, etc. My program will have 30+ instructions. The tests would take probably 10 minutes to complete on devnet. 

Is this the right way of doing it? Or am I missing something
Steps on ids: https://book.anchor-lang.com/chapter_3/milestone_project_tic-tac-toe.html#deployment
<@!134416332509675520>  I got it! Basically, I needed to mark the accounts with `'info` , instead of `'a` because they have different lifetimes üëç 

Old: 
```
pub fn solend_deposit<'a, 'b, 'c>(
    account1: AccountInfo<'a>
    account2: AccountInfo<'a>
    signer_seeds: &'a [&'b [&'c [u8]]],
) -> ProgramResult {
```

New:
```
pub fn solend_deposit<'a, 'b, 'c, 'info>(
    account1: AccountInfo<'info>
    account2: AccountInfo<'info>
    signer_seeds: &'a [&'b [&'c [u8]]],
) -> ProgramResult {
```
Thanks!
Yep, using `findProgramAddress` with those same seeds will find the same address
Ahh that did the trick, thanks!
‚Ä¶ so am I right that I‚Äôll get a correct map and can just find pda from the same combination of seeds?
Hey guys, is it correct? I want my PDA seed to be a combination of mint and user pubkeys

seeds=[user_token_account.key().as_ref(), user_token_account.mint.as_ref()]
Ok, now try this trick: https://discord.com/channels/889577356681945098/889584618372734977/938777998377766913
(But yes it seemed to have solved the type problem)
then I get a lifetime mismatch error:

```
// call solend deposit
solend_deposit(
    ...,
    pool.to_account_info(), <- error
    ...
    &[&[
        "pool".as_bytes(), 
         vault_info.mint.as_ref(), 
         vault_info.vault_creator.as_ref(),
         &[vault_info.pool.bump]
   ]]
)
```

The error is: `lifetime mismatch ...but data from ctx flows into ctx here`
What if you try inlining that variable (don't give it a name, just inline the expression right into the function call)
Hey alan, not sure if my last message got drowned
That would be in here: https://github.com/project-serum/anchor/blob/master/lang/syn/src/codegen/accounts/constraints.rs#L566
not just bump but other expr in the account macro
The issue is that in general many other choices of bump could be combined with those seeds and result in a valid program-derived address, but that's super confusing since everyone just uses `find_program_address`
where can i see the macro implementations if i wanna see how these constraints work under the hood.
Yep, it just uses `find_program_address` and uses that bump.
kinda confused by this statement "Checks that given account is a PDA derived from the currently executing program, the seeds, and if provided, the bump. If not provided, anchor uses the canonical bump." kinda confused how is this achieved under the hood my understanding is that anchor calls find program address with the executing program id and the seeds passed just to calculate the canonical bump ? or does it just use 255 ?
```
let signer_seeds = &[&[
            "acd".as_bytes(), 
            my_account.mint.as_ref(), 
            my_account.pool.as_ref(),
            &[my_account.pool.bump]
        ]];
```

I'm trying to pass that into my function

```
pub fn solend_deposit<'a, 'b, 'c>(
    ...
    signer_seeds: &'a [&'b [&'c [u8]]],
) -> ProgramResult {
```

But I get an error:
```mismatched types
expected reference `&[&[&[u8]]]`
   found reference `&[&[&[u8]; 4]; 1]```
i am stuck
hi alan
You need to also do `use anchor_lang::AccountsClose;` (not totally sure why that isn't part of the prelude)
you could reimplement https://github.com/project-serum/anchor/blob/master/lang/src/common.rs (since it doesn't appear to be exported in the crate) so call conditionally on the target account
Is there any way to conditionally close a PDA within an instruction? I know I can mark an account to be closed in an instruction's Context struct but as far as I can tell that will always close the PDA at the end of the instruction. Is there some way to instead conditionally call `close()` in my instruction handling logic?

I see there is a `close()` method on my PDA account, but when I try to call it in my instruction logic I get a build error
```
No method named `close` found for struct `anchor_lang::prelude::Account<'_, MyTestPDA>` in the current scope
```
according to solana docs, we can use `msg!` and others to print debug messages but how do I see it? it's not in validator.log
Quick general q about PDAs, when would I want to create a PDA based off of an account? In other words more specifically, when would I want to create a PDA from an account so that the PDA signs transactions instead of the Program? 

I‚Äôm trying to understand the need for a PDA to be created to sign for transactions.
I had the same problem. Try deleting the folder that contains the local validator
I'm testing it on local validator it giving me 1 month old time.
It give you current timestamp in unix_formate
does it gave us the unix epoch time?
`&id`
you can use `crate::id()` i believe
Clock::get()?.unix_timestamp
How do we get current time in unix in program?
any way to get the current program id? it's declared using `declare_id()` but can't figure out where it is saved
If you mean from an on chain program, that is a no. Every solana program needs to be passed all the accounts it needs for an instruction when it is called
Is there a way to run the anchor account rpc calls from the anchor app itself?
Aka in my anchors business logic I want to run program.accounts.fetch() or program.account.track() etc
Im not completely sure what i did... i didnt know i had to direct the terminal first where to store files when installing
how do you decide whether to choose u128, u192 or u256? not sure what are best practices in defi projects
Oh i see this..
`Error: Function _ZN15foo9__private8__global7deposit17h7f99f1ed05ea4cd4E Stack offset of -4512 exceeded max offset of -4096 by 416 bytes, please minimize large stack variables` sneaky
Hi team, I was running into this error: 
`    Program failed to complete: Access violation in stack frame 3 at address 0x200003e60 of size 8 by instruction #13358`

I searched discord and found someone mention to `Box` my `Account` and yay this worked! I am curious as to why it worked though? What is the point of Box? Thanks
Is there another creative way to validate that a past transaction has happened, from within a program?
Transaction includes a Token Transfer and a Memo
Nope, you'd have to find some other way to pass it into your program (as ix data, store it in an account, etc.)
Is there a way to read (past) transaction data from within a program?
you rock btw, your token studies repo has been a god send lately
sounds good, i'll play around with it
Mmmm I think so... I don't remember exactly how anchor "linearizes" the constraint stuff to be honest ü§î
in regards to this, do members of the context struct run in order?
for instance, if i do
```
#[derive(Accounts)]
pub struct SomeContext<'info> {
  #[account(
    constraint = if_this_fails_then_i_know_xyz_init_will_fail 
      @ErrorCode::AlreadyExists,
  )]
  pub something: AccountInfo<'info>,
  #[account(init, ...)]
  pub xyz: Account<'info, Xyz>,
}```
can i trigger my own error?
Well, you can sort of hack your way into a nicer error message‚Äîyou'd have to find some way to get some code to run before the `init` part (but really it's easier to just check if the account already exists on the client ü§∑‚Äç‚ôÇÔ∏è)
<@!669837238816735242> ^
Definitely surprising.
Alas, no‚Äîwhen a CPI fails in solana it straight up fails your whole program, you don't get a chance to recover from it :/
is it possible to return your own custom program error inside of the account init macro?

current scenario is```
Allocate: account Address { address: 7U2RJS24w9i9b845v8xRAfpqnGsJTj64p44CkvCgsVKH, base: None } already in use
    Program 11111111111111111111111111111111 failed: custom program error: 0x0
    Program 8QeSzG8ueV5JpztDfkJaPn63VdFSvo5DcckfRgahjWZR consumed 17198 of 200000 compute units
    Program 8QeSzG8ueV5JpztDfkJaPn63VdFSvo5DcckfRgahjWZR failed: custom program error: 0x0
``` but the error msg returned is `undefined` and the error message is `custom program error`. Can i make this return something like `account collision occurred on xyz account init`?
Would you recommend a similar way that  SPL-Token uses AccountLayout?
bingo! you are awesome. Makes sense now
Ok now how would you recommend reading in the bytes I get from getAccountInfo in order to be able to like index my array and get the data I need?
let me see
ty sir
Yep
lewt me try
didnt know i needed to isntall this for this step
oh is it the solana tool?
Sounds like you don't have your solana install set up correctly
anyone know why the build action isnt working
I hope soüôè  one second
If you fetch the account with `program.provider.connection.getAccountInfo`, does the data look ok? (It'll be just bytes)
Ah, ok, I don't think `program.account.accountLoader` will work correctly here, since it expects the account to use borsh as far as I know‚Äîand kind of the point of AccountLoader is that it doesn't use borsh
The reason I am using an account loader in the first place is because I want to store a dynamic amount of data which I can do by filling in a certain sized array stored within the account loader struct. So for example, if my AccountLoader has 3 fields, one that holds a public key, one that holds a number, and one that holds an array of custom structs of size 100. Let's say that AccountLoader and struct looks something like...

```#[account(zero_copy)]
pub struct AccountLoader {
    pub number: u64,
    pub pubkey: Pubkey 
    pub structs: [Struct; 100], 
}

#[zero_copy]
#[derive(Default)]
pub struct Struct {
    pub data: u32,
    pub more_data: Pubkey, 
}```

When I set the data fields for the AccountLoader in an instruction that ARE NOT a part of the array of custom structs, I have no problems and can fetch the correct data. However, when I set lets say the 0th index of the array to 
Struct {
    data = 5
    more_data = Account.PublicKey
} 
in an instruction and then try to fetch the updated array with...

```const fetchedAccountData = (await program.account.accountLoader.fetch(
      publicKey
    )) as AccountLoaderInterface;
console.log(fetchedAccountData.structs)```

data values across the entire array seemed to be changed unpredictably as if the data I fetched was contaminated. Checking to see that the data at the 0th index was what I expected with msg!() on chain yield the correct values. What am I missing?
So, not via borsh
In what way does the data look weird? The way AccountLoader works is that it stores your rust struct "as-is" in the data
Hello guys, is it possible to safely fetch account data for an AccountLoader type Account? The data off chain that I get is completely unexpected while on chain the data seems to be perfect fine. Any known reason for this?
Hello there! Is there a way to receive the contents of a signed message from the frontend in the Rust program?
i see, gotcha!


//////////////////////////////////////////////////////////////////////////////////////////

<<<<<<< HEAD
I didn't know about `getOrCreateAssociatedTokenAccount` until you posted it: this is how I've been doing it

```
  const playerMapVault = await findAssociatedTokenAddress(
    player.wallet.publicKey,
    treasureChestAccount.mints[0]
  );

  let createAccountInstruction = [];

  try {
    console.log("Already has account");
    playerMapVaultAccount = await serumCmn.getTokenAccount(
      player,
      playerMapVault
    );
  } catch (error) {
    console.log("Should create account ", error);
    createAccountInstruction = await serumCmn.createTokenAccountInstrs(
      player, 
      playerMapVault, 
      treasureChestAccount.mints[mintIndexes[MAP]], 
      player.wallet.publicKey
    );
  }
```
It just fails, I just tried lol
But program makes another ATA for Token A
User already has ATA for Token A
I wonder what happens when you try to create an ATA that already exists
Ah gotcha it makes sense then
Thanks, don't worry
Ah, I see what's happening, and unfortunately I'm not sure how windows environments work. Sorry!
Thanks, but i have the same problem
We were specifically talking about making a Pubkey into an AccountInfo within rust - long story short, you can't
We had a conversation a while ago, you cannot "get" AccountInfo that is not passed into the function
I would not use a `-` in your project name. Just call it `gifproject`
I figured it'd be better to do it within the program itself, but yeah, I couldn't really figure out a way to do it
Yeah that's what I'm doing now as well...client-side. Using the token mint to `getOrCreateAssociatedTokenAccount` for user's account
Right now I do that client side. I check if an associated account is already created, if not I pass in `serumCmn.createTokenAccountInstrs(...)`  to the `instructions: [],` parameter. I'm not sure how you'd do that within a program. You'd need to grab the account info from inside the function to test if it exists, which I don't believe you can do without passing it in. So I'd just create it client-side. Full disclosure, I could be wrong, I'm not an expert!

Check out the cashier's check example for what I mean for client-side https://github.com/project-serum/anchor/tree/master/tests/cashiers-check
Hi, I want init anchor project, but return a yarn error, but yarn is installed from npm install --global yarn, know about this?
I see anchor_spl::associated_token::create
Trying to create a new ATA for the user if they don‚Äôt already have one, OR use an existing one
Hey guys, is there something similar to getOrCreateAssociatedTokenAccount in anchor?
There are multi-sig wallets out there! But anyways, if you figure it out let me know! I'm new too
After all there is only one signer
Thanks for looking by the way.  My current theory is that they are passing a list of signers for a transfer from a multisig owner, even though it isn't multisig.  And maybe the runtime is accepting this..
That account should be a user's wallet, so i'm struggling to believe it's a multisig.  Also, if you click through on the account, the explorer doesn't say it's multisig.  (Though i'm quite new to all this, just thinking aloud).  The transaction is a listing on DigitalEyes, and they are all similar.
I'm just guessing here, but J9VbYTG7mGMoYgCGerzao4KYZMgok3XUncehuzaX7A1K has to be a multisig. and sure it can change authority if the multisig signs it, which it does
Is there a way to download a deployed .so from the chain?  I'm trying to build against the metaplex code, and I'd rather just grab their officially released bin than try to build from source
So it seems that if you are doing a 'set authority' on an account where the existing authority is multisig, then you can pass a signers array.  But none of the accounts involved in the txn above are multisig.  Authority is going from the user's wallet to a regular looking DigitalEyes account.
None of the accounts involved seem to be multisig, yet it mentions multisign in the set authority.
the last  instruction.  It's a listing on digitaleyes
it's on mainnet
3QvWUHbpDmLANUnXwVmHSmyDaNWzfx8X1xicSuAuAfMtkyTg2si3kzSBfqCXVVuwZ2cFEE5m1kTVzBgdvCaSgpuZ
want to post the tx? And what cluster it's on?
Nice.
Because I'm true to my word
Is it possible to 'set authority' on a token account to have multiple signers?  I'm looking at a transaction that seems to be doing this, but i cant find a command in spl-token that might correspond to it...
gm
Definitely will!
This is why we can't have nice things. üòâ  Be a good bloke, and tell the person who wrote it that they have this security hole if they don't already realize it.
This is what I have, but I'm not sure how to make a Wallet object, and I haven't been able to find documentation for that. Maybe there is a way in Anchor.toml to add a second test provider?

```
const getProvider = (keypair) => {
  const connection = new anchor.Connection(
    anchor.web3.clusterApiUrl('mainnet-beta'), 
    "processed"
  );
  const provider = new anchor.Provider(
    connection, 
    playerSecret.toBuffer(),
    "processed",
  );
  return provider;
}
```
Also, anyone know how to add a second provider for testing in a js anchor test?
Thanks!
That's what I kinda figured! So next time I see a 1-free mint, Imma just keep switching wallets lol! [Don't do this!]
If you're trying to enforce  a particular associated token account for your program, I *think* you can do it through a PDA.
I doubt it. That's kind of the point of the m44 standard.
Why can't I have two files with the same name in different folders? 

I'm trying to import protocol1::init and protocol2::init into `lib.rs`, but i'm getting an error like this: `note: run with RUST_BACKTRACE=1 environment variable to display a backtrace`
Hey all! How would a one-token-per-wallet work? (High level)

Right now, I have the following: 

```
    // Vaults
    #[account(
        mut, 
        constraint = &user_vault.owner == user.key &&
        &user_vault.mint == &program_vault.mint &&
        user_vault.amount == 0 &&
        get_associated_token_address(user.key, &program_vault.mint) ==             user_vault.key()
    )]
    pub player_map_vault: Account<'info, TokenAccount>,
```

Using `get_associated_token_address` I can force the amount in the user_vault is 0, which is directly tied to the user's public key. However, I know phantom spins up derivative addresses from the private key. ***Is it possible*** to enforce 1 per wallet (private key) vs 1 per public key?
... or I can just use "anchor build", and than use "solana program deploy ...", right?
yeah, I found that, but is for solana's cli
is there is any similar command for anchor? like anchor test --max-len etc
Yep, there's a `--max-len` arg to `solana program deploy` (check out `solana program deploy --help` for me)
hey can I somehow reduce that? I looked in solana's docs and, if I understood right, we spend more for deploy in order to expand our program in the future
but can I decrease amount of that "extra" sol?
no clue where it's coming from
I'm trying to run `anchor build` but I get this error:

```
thread 'main' panicked at 'called `Option::unwrap()` on a `None` value', ~/.cargo/git/checkouts/anchor-bf03d42499b9267c/a81ff88/lang/syn/src/idl/file.rs:161:73
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```
thanks!
Trying to find an example, basically just add an instruction function with the low-level solana signature, like
```.rs
#[program]
mod foo {
  pub fn your_fallback_fn(program_id: &Pubkey, accounts: &[AccountInfo], data: [u8]) -> ProgramResult {
  Ok(())
  }
}
```
ah found it if anyone is curious https://github.com/project-serum/anchor/issues/409
Don't worry, anchor has full autist support!
yes but the autist inside me cannot accept the fact that there is a way to do it and i dont know about it xD
are fallback functions documented somewhere i cannot find it on https://project-serum.github.io/anchor
thanks alan!! üôè
So ordinarily you would let anchor write the client for you too
Ah, I see‚Äîyou can technically make this work with anchor using its support for "fallback functions", but yeah, ordinarily you would have your own anchor-specific client
i mean we dont have control over the client and client currently they just send the raw data which is decoded to the instruction here https://github.com/jarry-xiao/solana-bootcamp-lectures/blob/master/echo-reference/src/processor.rs#L23. how would that work in anchor?
1.8.5
And no, that's new üòõ
Was looking in the wrong vscode window
Oh sorry
dang that is olddd
anchor itself seems to be using `1.10.0`
What version of solana_program should we use with anchor-0.20.1?
Is this the project? https://github.com/jarry-xiao/solana-bootcamp-lectures/tree/master/echo-reference
What have you tried so far? It will almost certainly work fine in anchor
That would be extremely surprising to me, so I would suggest defaulting to assuming the source of the bug is just something dumb
im curious if there is any way to implement `echo` program that was given as assignment in solana bootcamp using Anchor, bcz we dont have control over the client i am not able to figure out how to do it
Yeah, it's a pure laziness feature üôÇ
is possible use anchor library on angular component?
oooof okay good to know. Thanks for that
Speaking of dependencies -  I got bit hard by a release that got rolled back:  https://github.com/solana-labs/solana-program-library/issues/2791
I was getting weird errors because I happen to `cargo install` while 1.0.4 was released.   Even though it was rolled back, I needed to clear out my cargo caches in order for 1.0.3 to get installed.  Lost a few hours on this when I started working with tokens
Should `cargo update`  flag it as updateable?  It's not listing it even if I put --aggressive
which version do u recommend we use?
hey <@!347689664855015424> , can we use solana-program v1.8.14 (latest stable release) with the newest anchor version?
https://github.com/solana-labs/solana/releases
which is the recommended `solana-program` version to use with anchor-0.20.1?
! Thanks for letting me know.  Where's the source of truth on that? So I know what to trust in the future.  I have a VSCode extension that helps but I think it takes into account other deps which may limit.
seems like the most recent stable release is `1.8.14` tho
`solana-program = "1.8.6"` ah this is what i need (i think)
Just a check - Do you have :
```
[dependencies]
anchor-lang = "0.20.1"
anchor-spl = { version = "0.20.1" }
arrayref = "0.3.6"
solana-program = "1.8.6"
```
in your Cargo.toml
i still got this error
`error[E0433]: failed to resolve: could not find solana_program in the list f imported crates`
Ya they does the problem is sometimes I get the error and sometimes it goes through and tx happens.
yea I know but I suppose he just copied it which is why he got that error with the length
how do i import solana_program?
It's a real base58
I redacted that.
well yea you get that one because "mypubkey" isnt a pubkey
`error[E0433]: failed to resolve: could not find `solana_program` in the list of imported crates`
```
use anchor_lang::prelude::*;
use crate::types::*;
```
That's it. ` and crate::types::*`  is my own code.
im getting two errors with that line of code. Another one is: "pubkey array is not 32 bytes long: len=6rustc"
hmmm really. what are you importing?
I tried this after cqfd suggested using it, and it compiles:
`pub const INITIAL_ADMIN: Pubkey = anchor_lang::solana_program::pubkey!("mypubkey");`
not sure how to get solana_program tho XD
ahhh interesting. thanks!
yea it turns out that `pubkey` uses `::solana_program` instead of `solana_program`. This means you cannot use `anchor_lang::solana_program` and have to import the actual `solana_program`
Hmmm <@!347689664855015424>  I'm still getting an error with this:
```rust
use anchor_lang::prelude::*;
use anchor_lang::solana_program;

pub const PID: &str = solana_program::pubkey!("So1endDq2YkqhipRh3WViPa8hdiSpxWy6z3Z6tMCpAo");
```
*failed to resolve: could not find `solana_program` in the list of imported crates
not found in `solana_program::pubkey`*
Cool.  Thanks for clarifying that.
(technically, it starts from 255 downwards)
it can be yes. it's recommended to save the bump that `init` finds in the account itself so other instructions dont have to find it again.
to be clear - find_program_address would have to start searching from a bump of zero.
Otherwise, I'd love to get rid of all the bump params I send up on all my instructions! üòÑ
Isn't that a perf issue though?  Sending up the right bump would start from the correct bump rather than starting from bump = 0.
E.g. every `Account<'info, TokenAccount>` without an `init` etc. needs to be a real token account
That error can come from any `Account<'info, Whatever>`, just need to check that all of them make sense
yup
Are you sure your `declare_id!` is correct?
Interestingly, that syntax does actually work (anchor will recalculate the right bump for you)
These accounts are already initialized in previous instruction and in this instruction I just need to pass those accounts
```
#[derive(Accounts)]
pub struct Unbind<'info> {

    #[account(mut)]
    pub receiver: Signer<'info>,

    #[account(mut,  
        associated_token::mint = mint_account.key(),
        associated_token::authority = receiver,
        constraint = token_account.amount == 0, 
    )]
    pub token_account: Account<'info, TokenAccount>,

    #[account(mut)]
    pub mint_account: Account<'info, Mint>,

    #[account(
        mut,
        associated_token::mint = mint_account.key(),
        associated_token::authority = account_data.key(),        
        seeds = [receiver.key().as_ref(), token_account.key().as_ref(), BIND.as_bytes()],
        bump
    )]
    pub account: Account<'info, TokenAccount>,

    #[account(
        mut,
        close= receiver,
        constraint = account_data.owner == receiver.key(),
        constraint = account_data.token_account== token_account.key(),
        seeds = [receiver.key().as_ref(), token_account.key().as_ref(), METADATA.as_bytes()],
        bump
    )]
    pub account_data: Account<'info, MetadataInfo>,

    pub token_program: Program<'info, Token>,
}
```
Here's it reworked to use the built-in attributes.  I assume `account` has the same mint as the other token.
What's that `bump` value floating in there without a value assigned to it?  Shouldn't that be a parameter in your instruction?
K, just making sure.  Typing up something write now, one sec.
``` pub fn ubind(ctx: Context<Unbind>) -> ProgramResult { 
   // test
}```
What's your instruction declared as for unbind()
Can anyone assist ? Stuck on this for a while
Ohhh gotcha. Thanks so much paul!
it's possible that it expands to code that uses `solana_program`
pubkey! Is a member of solana_program, so i shouldnt need to import solana_program. Right?
that sounds correct. you didnt import it. only its members
```rust
use anchor_lang::prelude::*;
use anchor_lang::solana_program::*;

pub const PROGRAM_ID_MAINNET: &str = pubkey!("So1endDq2YkqhipRh3WViPa8hdiSpxWy6z3Z6tMCpAo");
```
^ This code gives me this error:

Could not find solana_program in the list of imported crates
Please post an error log etc., way easier to debug that way
hi guys im getting the error `could not compile 'anchor-cli'` when running `cargo install --git https://github.com/project-serum/anchor anchor-cli --locked --verbose` has anyone run into this issue? thanks! Edit: sorted it...
hi everyone, having problems because after running anchor test a few times all of a sudden the compute budget was maxed out. is it because the program is being upgraded everytime i run anchor test? how would i go about fixing this?
```
Error - Transaction simulation failed: Error processing Instruction 0: custom program error: 0xa7 
    Program Z22wRDLVireDZ7zngFjo3psykwet3oumYsWWaCw12eK invoke [1]
    Program log: Custom program error: 0xa7
    Program Z22wRDLVireDZ7zngFjo3psykwet3oumYsWWaCw12eK consumed 5769 of 200000 compute units
    Program Z22wRDLVireDZ7zngFjo3psykwet3oumYsWWaCw12eK failed: custom program error: 0xa7

Getting weird error 0xa7 while invoking an instruction sometimes and sometimes not.

------


#[derive(Accounts)]
pub struct Unbind<'info> {

    #[account(mut, signer)]
    pub receiver: AccountInfo<'info>,

    #[account(mut,  
        constraint = token_account.amount == 0, 
        constraint = token_account.owner == receiver.key() 
    )]
    pub token_account: Account<'info, TokenAccount>,

    #[account(mut, 
        constraint = token_account.mint == mint_account.to_account_info().key() 
    )]
    pub mint_account: Account<'info, Mint>,

    #[account(
        mut,
        constraint = account.owner == account_data.key(),
        seeds = [receiver.key().as_ref(), token_account.key().as_ref(), BIND.as_bytes()],
        bump
    )]
    pub account: Account<'info, TokenAccount>,

    #[account(
        mut,
        close= receiver,
        constraint = account_data.owner == receiver.key(),
        constraint = account_data.token_account== token_account.key(),
        seeds = [receiver.key().as_ref(), token_account.key().as_ref(), METADATA.as_bytes()],
        bump
    )]
    pub account_data: Account<'info, MetadataInfo>,

    pub token_program: Program<'info, Token>,
}


---------

await program.rpc.unbind(
      {
        accounts: {
          receiver: payer.publicKey,
          tokenAccount: token,
          mintAccount: mint,
          account: account,
          accountData: accountData,
          tokenProgram: TOKEN_PROGRAM_ID
        },
        signers: [payer]
      }
    );


```
can you share the instruction here?
Ya so calling a instruction with some params sometimes works and sometimes with same params returns 0xa7 which is weird
aah then it's wired
Yes they are same
check if the output of `anchor keys list` and `the address in declare_id!()` in lib.rs are the same
Facing some strange issue wrote a program getting 0xa7 error which means AccountNotOwnedByProgram sometimes and sometimes not.
that makes sense, thanks!
Is it fine to handle the transaction through the client?
I've used it when I run out of stack space.  Otherwise, not sure
When would you use a Box<Account<'info, T>> field versus  a Account<'info, T> field in an Accounts struct?
```rust
use anchor_lang::prelude::*;
use anchor_lang::solana_program::*;

pub const PROGRAM_ID_MAINNET: &str = pubkey!("So1endDq2YkqhipRh3WViPa8hdiSpxWy6z3Z6tMCpAo");
```
^ This code gives me this error
‚ù§Ô∏è
<:feelsgood:725150676849524856>
The former is cooler because it does the parsing at compile-time.
Or if that doesn't work (can't remember what version of solana that requires), you can be less fancy and do
```.rs
use std::str::FromStr;
Pubkey::from_str("asdasdfasdf").unwrap();
```
You can also do things like
```.rs
anchor_lang::solana_program::pubkey!("asdfasdfasdf'");
```
<@!195345150132748288> I just did:

```rust
const PHASE_TOKEN_MINT: &[u8] = "FZxUbyQ9oeFiSDaabw8KfAWACsDMQhbuxR9vm2Rh7Ewm".as_bytes();
...
    #[account(
        mut,
        constraint = x_token_mint.key.to_bytes() == PHASE_TOKEN_MINT,
    )]
    pub x_token_mint: AccountInfo<'info>,
```
figured it out ty
<:thinkcat:837225078877716511>
I got it from the anchor test code.  It looks like it's only one per `mod`
Gotcha, and you can use multiple ids?
It can be used for any pubkey.  That's a base58 wallet pubkey
right but we use that to define the program address
```
mod hardcoded_pubkey {
    use super::*;
    //hardcoded from provider wallet.  
    declare_id!("6teo1kumz6aJKcCaC4ECWsy1Ypu6DdiJnhrPbhPezWcZ");
}
```
ty
gg
lel
Yeah, it's just code.
without passing it in
can you define a pubkey in the program
Best reference is here: https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html
ah wait
so if i have
<:whoa:588192323888742414>
`#[account(address=<PubKey>)]` is what you're looking for I think
for example I only want swap to be used with Token X and Token Y, both of which have pubkeys
looks like this has been asked before and I answered myself (potentially), but there's no way to constrain an `AccountInfo` argument to be a very specific pubkey?
I see. That makes sense.  Thanks, So if you were launching something like Amazon, that's 1,000 tx/s then crap could fail, but 2 tx /sec isn't going to fail.
It's a matter of (in)efficiency because it's a matter of correctness: you just can't parallelize multiple transactions mutating the same state
Well, at some point you'll saturate the ability of the solana validators to process those transactions in a non-parallelized way
Ah, so it's a matter of efficiency, not failure?  So let's say you write the most popular thing in the world, then what is the consequence?
Right, that's what I mean by get sequenced one after the other
That implies that a transaction writing to the same address will not be parallelized.
I keep hearing conflicting reports on that.  https://solana.wiki/docs/solidity-guide/introduction/#transaction-parallelization
No, I think (I think) that one will just get sequenced after the other
If you have an account that receives funds for a store, does that mean two transactions that are trying to send that account SOL at the same time will compete, and one will fail?
hi there, does anyone have experience integrating Serum with Anchor?
Is there anyway to measure the network fee a signer will pay from within an instruction?
Haha, all good
much appreciated
one day I'll repay you for taking time to answer my stupid questions
lmao
```.rs
the_token_account.amount
```
On the program side? <:whoa:588192323888742414>
Ah, ok, you can just check a token account's balance and burn the whole amount
So my initial thought would be to simply pass the amount to the program and check the user's `uiAmount` on the client-side, but after some thought it might be better to have extensive checks in the program itself. I know that you can get the lamports of an account in `AccountInfo`, but I don't see a struct I can use to grab the amount of a specific token
What have you tried so far? How are you figuring out how many tokens to burn?
If I have a simple token swap program that burns all of token A in user's ATA, then closes user's ATA, then transfers token B to a new ATA, is there a way I can ensure that we're burning ALL of token A? (otherwise the program fails with `Error: Non-native account can only be closed if its balance is zero`)
it's the sol account receiving the rent exemption lamports
I'm assuming destination is the owner account of the token account (account)?
```
pub struct CloseAccount<'info> {
    pub account: AccountInfo<'info>,
    pub destination: AccountInfo<'info>,
    pub authority: AccountInfo<'info>,
}
```
from anchor-spl::token:
<@!134416332509675520>hi, sorry for that. Can you help me on <#889577399308656662> ? thanks
ok, thank you!
afaik no, and yes that's how solana works, gotta pass it in
There is no way around this? So I would pass it from the client and then check if has the address that I need it to be?
I found the problem... it was a dumb error lol i forgot to add the new parameter to `#[instruction]`
Can you post a github link?
from the client
This will need to be passed into the program as an account
(I think this has to do with the way rust allocates memory...?)
Why do I get `PrivilegeEscalation` error when I put bool as the first parameter of my instruction, but when I move it to the last parameter I get no error?
Hi! - how can you instantiate an AccountInfo variable that holds points to a given public key string? I am intending to make a token Transfer to a constant address. I tried sth. like 
```
let recipient = Pubkey::from_str("8yYHAqiEDJGMLGhYZWeAuhmLkPgSax3miBog6QzgKfzq").unwrap();
'
but I cannot get that one tied to an AccountInfo
isMut is the same to isWritable?
Hi everyone, i'm trying to install the `anchor-cli` using `cargo install --git https://github.com/project-serum/anchor anchor-cli --locked` . The install is hanging on the line ` Compiling anchor-cli v0.20.1 (/root/.cargo/git/checkouts/anchor-bf03d42499b9267c/17c9463/cli)`  has anyone else run into this? Thanks!
thank you
‚ù§Ô∏è
that's what i was missing...the bump
ffs
So you'd need to do `new_with_signer` using its seeds *and* bump.
On the other hand, I assume you do need to sign for ctx.accounts.swap_program in the second transfer (it's a PDA?)
You can just use `CpiContext::new`, no need to try to sign anything new
The first transfer you're doing shouldn't be using `ctx.accounts.signer.key().as_ref()` as a seed (the user should have already signed from the client)
```js
  // Initialize the token mints.
  let TOKEN_A_MINT;
  let TOKEN_B_MINT;

  it("Prepares for initialization", async () => {

    // Initialize the mints.
    TOKEN_A_MINT = await Token.createMint(
      provider.connection, 
      provider.wallet.payer,
      provider.wallet.publicKey, 
      null, 
      9, 
      TOKEN_PROGRAM_ID
    )
    TOKEN_B_MINT = await Token.createMint(
      provider.connection, 
      provider.wallet.payer,
      provider.wallet.publicKey, 
      null,
      9,
      TOKEN_PROGRAM_ID
    )

    // Create associated token account of token A for user.
    userAssociatedTokenAccount = await TOKEN_A_MINT.getOrCreateAssociatedAccountInfo(
      provider.wallet.publicKey
    )

    // Create 100 tokens for the user.
    TOKEN_A_MINT.mintTo(
      userAssociatedTokenAccount,
      provider.wallet.publicKey,
      [provider.wallet],
      100 * 10**9
    )

  })
```
This is correct, the PDA where the tokens are burning would be owned by the signer, or the user. The user is burning his own X token and receiving Y token


//////////////////////////////////////////////////////////////////////////////////////////

I was trying to create a mint in a program with a pda as the authority, but I'm getting `Cross-program invocation with unauthorized signer or writable account`. I can get this to work if the mint authority is `authority` but not `pda`.
```js
    const pda = (await anchor.web3.PublicKey.findProgramAddress(
      [Buffer.from("pda"), program.programId.toBuffer()], program.programId)
    )[0];
```
```rust
#[program]
pub mod member_nfts {
    use super::*;
    pub fn initialize(ctx: Context<Initialize>) -> ProgramResult {
        msg!("mint new token");
        let mint_to_ctx = token::MintTo {
            mint: ctx.accounts.mint.to_account_info(),
            to: ctx.accounts.token_account.to_account_info(),
            authority: ctx.accounts.pda.to_account_info(),
        };
        token::mint_to(
            CpiContext::new(ctx.accounts.token_program.to_account_info(), mint_to_ctx),
            1,
        )
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    pub authority: Signer<'info>,
    #[account(init, payer = authority, mint::decimals = 0, mint::authority = pda, mint::freeze_authority = pda)]
    pub mint: Account<'info, Mint>,
    #[account(init, payer = authority, associated_token::mint = mint, associated_token::authority = pda)]
    pub token_account: Account<'info, TokenAccount>,
```
ah that totally makes sense. I wasn't aware of teh anchor_lang::reload, thank you!
your token account is a deserialized version of the AccountInfo so it has no connection to the accountinfo data anymore and changes to it are not propagated. you can call `reload` on your account to update its deserialized data
Are token accounts not updated in the context of an instruction? Eg, I'm calling "msg!(token_account.amount)", transferring, and then calling the same msg! again to verify token amounts in my program logs. That amount is the same both before and after the transfer instruction but on the explorer, the "token balances" section shows that the transfer went through
You could always have the server sign with its own special public key (that no one else can sign for).
still work in progress but probably already the best resource for Anchor: https://book.anchor-lang.com/
Thanks <@915682383905316864> i will look into it
https://solana-cookbook-git-fork-losman0s-using-mainnet-6e845e-cookbook.vercel.app/#contributing
https://soldev.app/
Hi I am beginner in solana can someone let me know what resource i can follow
anchor version: `anchor-cli 0.21.0`
rust version: `rustc 1.58.1 (db9d1b20b 2022-01-20)`
Whenever I try to run anchor build üòê
Hi, i'm seeing: ```‚ûú  collective-multisig-contract git:(main) anchor build
thread 'main' panicked at 'Not in workspace.', cli/src/lib.rs:701:47
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace```
thx
e.g. https://www.youtube.com/watch?v=O0uhZEfVPt8 and https://twitter.com/pencilflip/status/1452402100470644739?s=20&t=-aoxCW3be0L6_lJEPWGccg and https://paulx.dev/blog/2021/01/14/programming-on-solana-an-introduction/
Do all accounts have a balance (lamports)?
Hi, guys. Could anyone help me understand the concept of accounts? Where are they stored? Where're SOLs of an account stored?
(for simple enums) I guess it's whatever, only want to make sure you check it on the instruction side.
thanks for clarifying. from calling rpc calls from ts, I send a `number` then I handle that in rust using the `FromPrimitive` trait/derive for simple `enums`, will that the way to go?
both use the word enum but the data structure if very different
rust enums can hold more complex types
no because ts enums are not tagged unions
Hi, looking at The Anchor Book (thanks for this!) I see that `enums` are represented as `{variant:{}}` in the ts side. While functionally it's fine but are ways to properly cast this to ts `enums`? or like to and int?
Bump
Hey there - a question for more knowledgeable ones

For example you got a dApp like a coinflip game. 

What if you‚Äôd do the random flip on a server side and then send the result to a contract instead of doing the random flip inside the contract directly?
Would there be any security issues?
Or if you d do parts of the operations on a server side? 

I can imagine it would open possibilities for users to send other results to the smart contract for example to alter the output
very useful to know!
totally works!!!
oh thanks!
You can do `program.account.theAccountType.all()` I think
Oh, sorry, in JS/TS?
ahhh no thanks though -- im trying to do it via javascript
There's unfortunately no way to do this within your solana program, is that what you mean?
some way to directly access  the AccountsCoder maybe?
is there like an "anchor way" to do "getProgramAccounts" ?   i'm trying to get all the accounts a program owns and parse the data but i have anchor bindings for it
i'm running the same  js package versions as on my linux box, which works fine.
I'm getting this, so wondering if it's a js or solana runtime versioning thing.  `Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 1: instruction modified the program id of an account
`
Is anyone having issues running the anchor ido-pool test on mac m1?
Hi all
Is there any devnet USDC faucet ?
anchor build command does not gave typescript types?
Thanks
https://discord.com/channels/889577356681945098/889702325231427584/941072866529673256
Hi, I have a question about `#[account(init, ..., space)]`. Is it possible dynamically setup space requirements based on instruction arguments? For example, I have a `String` in instruction arguments and I want to allocate account which has perfect size for this `String`
Where can i find documentation on Anchor.toml ?!
You can leave it blank if there is one signer which is the wallet
Thanks üôÇ
either store the pubkey or use a PDA
how do I then find that account to pass in for the increment function
If I initialize an account with an empty counter
how to check  what's the freeze authority of a token is ?
I have a slight confusion around signing: if I want to ensure that someone specific has signed a transaction, I would simply add  `Signer<'info>` in a ctx and then ensure that this account is passed in during the rpc call. But there's also a `signers` array field, do I have to pass this again or can I leave it blank?
For anyone else running into a weird issue like this, upgrade your solana version
ok, thanks and you still have to pass it in from the outside?
im gonna message you on the side so i dont dox myself to the whole chat if thats okay
Sure, I'm cqfd on github
the repo is private, can I add you as a collaborator? its gross code heh
Here's an example: https://github.com/cqfd/anchor-token-studies
thanks a lot btw
cool 1 sec
If you can post a link I can try running it on my machine, probably quicker for me to debug that way
You would need the mint authority to be some program-derived address derived from your program (that's solana's equivalent to having a program have authority over something)
I do yeah, I can alos just paste some more structs
No idea how the struct thing could relate to that‚Äîdo you have this in a github repo somewhere?
You're definitely doing something weird, since that error implies you're trying to mutate the spl token program itself ü§î
.toNumber()
is there a limit to number of fields?
I am running into this error:
`    TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA's writable privilege escalated`

Because I added another field `new_field` to my struct:
`
#[account]
#[derive(Default)]
pub struct VaultManager {
    pub mint: Pubkey,
    pub vault: Pubkey,
    pub change: Pubkey,
    pub change_ata: Pubkey,
    pub draw: i64,
    pub new_field: i64,
}`
I dont understand why adding another field to my struct would cause a CPI error like that
how can I set the authority of a mint account to be the program?
hi guys
so i've built a counter program and i'm trying to read the number of counters for a public key and im getting count: <BN: 4d2>
any help as to how to convert it to something human readable like 1 or 2?
looks like Mint accounts can have separate authorities for minting and freezing https://github.com/solana-labs/solana-program-library/blob/14952a75ba6cecf3ba66a412a2fca6afd8f6ce52/token/program-2022/src/state.rs#L16. that code must be helping to set the mint tokens authority.
no, sorry
Do you know what this piece of code does?
MintTokens,
}
pub enum AuthorityType {
#[derive(AnchorSerialize, AnchorDeserialize)]
cool good to know üôÇ
Thanks, I see some logs in there as well. This is one way:
1. start a local validator `solana-test-validator`
2. tail logs `solana logs --url localhost`
3. test without starting another local validator `anchor test --skip-local-validator`
I'm not 100% sure, but the .anchor folder has the a Test Ledger, might be worth checking?
nvm I just found this :p https://github.com/project-serum/anchor/blob/master/tests/spl/token-proxy/programs/token-proxy/src/lib.rs
G'day guys üôÇ can anyone point me to some good resources on using spl-tokens and NFTs in a solana program üôÇ
is there a way to see the logs from the local validator with `anchor test`?
you can pass the account size as an instruction argument and then put  `#[instruction(account_size: u64)]` at the top of your struct
Hello. Is there a way to dynamically set the size of an account while initialization? (smth like code in the picture)
got it, noted
Yeah, you'll need to have a real, already-initialized token account in order to send it tokens
unfortunately I'm not familiar with spl-tokens, but thanks for letting me know about something new to research. I assume yes though?
do you know if i'll need to initialize the account first before sending spl-tokens to it?
got it thanks!
Copy that. Thanks for the prompt response!
Yep, think so (the deployment cost is almost entirely about storing your `.so` file on-chain)
Question to the group: is the amount of SOL it costs to deploy on devnet match exactly the amount of SOL it would cost to deploy on mainnet? I've only tested my dApps on devnet
above is from buildspace tutorial. Highly recommend their create  solana program with react tutorial by Farza, creator of buildspace
run this script (credit Nader Dabit) to create a local keypair for a persistent account. Then istead of generating a new keypair using Keypair.generate, pull in stored keypair using the following code. Let me know if you have any questions.
so generate the keypair once using `new Keypair()` in js or `solana-keygen` cli and then you can load it using it's secret
it is possible. You can load the keypair from it's secret key `Keypair.fromSecertKey([...])`
I'm trying to reconstruct a key from a secret
I want to use one keypair consistently for tests instead of generating a new account every time
not sure what you mean
Is there a way I can generate the same user key pair for testing on devnet? I need to be able to send a spl token to the address ahead of time


//////////////////////////////////////////////////////////////////////////////////////////

the answer is yes, thx for being my rubber duck chat
Hi, is it possible to pass in an array like this `[u8; 6]` as an arg to an on chain program?
I mean I used the correct command but how come the path is not complete?
Cool, thank you boss
What should I do?
Ohhh, does that mean CpiContext::new is enough given the signer was passed in RPC?
skipPreflight says don't do any transaction simulation at all before sending your tx
what's the difference  preflightCommitment vs skipPreflight ?
Seeds are only for signing for one of your own program's derived addresses
If it's not a PDA, then you won't be able to freeze it unless it signed the tx you submitted from the client
if it's a PDA i'll just add it as signer, and pass its seeds,
but what if it isn't? what's the seed?!
Every mint has an address that acts as its authority
It's the mint authority, whatever that is (not sure if its a program-derived address or not)
Yes I think so. I run solana config get keypair and copied the path of the output
So it's the PDA of mint authority ?
You would need to sign with whoever is the authority over the mint
Bump
Gonna need to uninstall and try to do it all over again (lots of blog posts now about installing on an M1‚ÄîI do it directly from a github source checkout, not via the installer)
i switched macbooks recently
yep on an M1
Are you on a M1?
That means you haven't installed solana correctly, unfortunately
```‚ûú  crunchy-vs-smooth solana-test-validator
Ledger location: test-ledger
Log: test-ledger/validator.log
‚†ô Initializing...
[1]    47710 illegal hardware instruction  solana-test-validator```
ah shit, i was hoping to avoid that given
There's your hint :p
`Test validator does not look started`
I'm getting:

```‚ûú  crunchy-vs-smooth anchor test
BPF SDK: /Users/usr/.local/share/solana/install/releases/1.9.1/solana-release/bin/sdk/bpf
cargo-build-bpf child: rustup toolchain list -v
cargo-build-bpf child: cargo +bpf build --target bpfel-unknown-unknown --release
    Finished release [optimized] target(s) in 0.21s
cargo-build-bpf child: /Users/usr/.local/share/solana/install/releases/1.9.1/solana-release/bin/sdk/bpf/dependencies/bpf-tools/llvm/bin/llvm-readelf --dyn-symbols /Users/udr/Documents/coding/crunchy-vs-smooth/target/deploy/crunchy_vs_smooth.so

To deploy this program:
  $ solana program deploy /Users/usr/Documents/coding/crunchy-vs-smooth/target/deploy/crunchy_vs_smooth.so
The program address will default to this keypair (override with --program-id):
  /Users/udr/Documents/coding/crunchy-vs-smooth/target/deploy/crunchy_vs_smooth-keypair.json
Unable to get recent blockhash. Test validator does not look started. Check .anchor/test-ledger/test-ledger-log.txt for errors. Consider increasing [test.startup_wait] in Anchor.toml.```
```import { AccountClient, Program } from '@project-serum/anchor';
import { CrunchyVsSmooth } from '../target/types/crunchy_vs_smooth';

const assert = require("assert");
const anchor = require("@project-serum/anchor");
const { SystemProgram } = anchor.web3;

describe('crunchy-vs-smooth', () => {

  const provider = anchor.Provider.env();
  anchor.setProvider(provider);
  anchor.setProvider(anchor.Provider.env());
  const program = anchor.workspace.CrunchyVsSmooth as Program<CrunchyVsSmooth>;
  const voteAccount = anchor.web3.Keypair.generate();
  it("Initializes with 0 votes for crunchy and smooth", async () => {
    console.log("Testing initialize");
    await program.rpc.initialize({
      accounts: {
        voteAccount: voteAccount.publicKey,
        user: provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      },
      signers: [voteAccount],
    });
    const account = await program.account.voteAccount.fetch(
      voteAccount.publicKey
    );
    console.log("Crunchy: ", account.crunchy.toString());
    console.log("Smooth: ", account.smooth.toString());
    assert.ok(
      account.crunchy.toString() == "0" && account.smooth.toString() == "0"
    );
  });
});```
what's inside of `tests/crunchy-vs-smooth.ts`
hmm could be a typo or an invalid location,
did you provide an absolute path?
When I run `Anchor test` why doesn't it execute the javascript tests? I have my directory set up like so
please
Anyone?
got it, thanks
u8 between 0-255 calculated in run-time
it can then be accessed from your handler via ctx.bumps.get("my_account_name").unwrap()
on `init` it is found via Pubkey::find_program-address
does anyone know where `bump` comes from and why I don't have to pass it from the instruction?
```rust
#[derive(Accounts)]
pub struct CreateGroup<'info> {
    pub payer: Signer<'info>,
    #[account(init, payer = payer, seeds = [payer.key.as_ref()], bump, space = Group::LEN)]
```
Yo I'm running "ANCHOR_WALLET=<YOUR-KEYPAIR-PATH> node client.js", where I change <YOUR-KEYPAIR-PATH> to the path where my keypair is located, but I get this error:
 node:internal/modules/cjs/loader:936
  throw err;
  ^

Error: Cannot find module '(My path)'
    at Function.Module._resolveFilename (node:internal/modules/cjs/loader:933:15)
    at Function.Module._load (node:internal/modules/cjs/loader:778:27)
    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)
    at node:internal/main/run_main_module:17:47 {
  code: 'MODULE_NOT_FOUND',
  requireStack: []
}
I'm trying to freeze a metaplex NFT, i'm confused about the signers.
since the creator has the freeze authority, shouldn't the rpc call be signed by creator ?!
then are the seeds the same you used to derive an associated token program ?

Thank youüõ†Ô∏è 

```
    pub fn freeze_account(ctx: Context<FreezeAction>) -> ProgramResult {
        let signers_seeds = &[];    ==========> // What/Who should the signers be ?!
        match freeze_nft(CpiContext::new_with_signer(
            ctx.accounts.token_program.to_account_info(),
            FreezeAccount {
                mint: ctx.accounts.mint.to_account_info(), // Mint account
                authority: ctx.accounts.creator.to_account_info(), // Owner of Mint account
                account: ctx.accounts.nft.to_account_info(), // Metaplex ATA
            },
            signers_seeds,
        )) {
            result => {
                msg!("Account frozen ! {:?}", result)
            }
            _ => return Err(ErrorCode::FailedFreeze.into()),
        }
        Ok(())
    }
```
perfect, thanks!
Yep
You'll need it during your first deploy, which will create a solana account with that public key as its address
so all good to grind a vanity keypair and stick to that?
It's whatever your program's actual program_id is/will be
newb q... can pk in `declare_id!` be any owned keypair?
Time to see if i can get a working example then. Really appreciate the support man üöÄ
Alright üôÇ
`instructions` are pre
Think i found it üôÇ -

Are instructions handled before or after (since the pre and post aren't there yet)?
Because the signers array contains key*pairs*, not just addresses
What's preventing me from throwing whatever address into the signers argument? i.e. i'm doing `signers: [voteAccount]` here, but if I want to be malicious and do `signers: [yourAddress]`
cause in a code example this is in there
```
await program.rpc.createMultisig(owners, threshold, nonce, {
      accounts: {
        multisig: multisig.publicKey,
        rent: anchor.web3.SYSVAR_RENT_PUBKEY,
      },
      instructions: [
        await program.account.multisig.createInstruction(
          multisig,
          multisigSize
        ),
      ],
      signers: [multisig],
    });
```
I feel like i'm doing something wrong üòì
I don't see that contaning any of the "instructions"
the "doSomething" takes a IdlInstruction as input, 

```ts
export type IdlInstruction = {
  name: string;
  accounts: IdlAccountItem[];
  args: IdlField[];
};
```
hmm wait
no not either :/
Does it work with just `instructions`?
hmm my typescript checker is giving me shit for using the preInstructions though...
It would look like
```.js
await program.rpc.doSomething(arg1, arg2, {
  accounts: {
    ...
  },
  preInstructions: [
    program.instruction.doSomethingFirst(...),
  ],
  postInstructions: [
    program.instruction.doSomethingAfterwards(...),
  ]
});
```
Ah, sorry, maybe they're all still called `instructions: [...]` in the anchor repo (lots of examples of that int he tests/ directory)
Has there been any updates or solutions to the invalid blockhash error on deployment?
Any tips for making the transactions go through?

I seem to be able to deploy on devnet just fine but mainnet is giving me a lot of issues.
I can't find any examples using the preInstructions

but i assume you are thinking of using this:
```ts
export type IdlInstruction = {
  name: string;
  accounts: IdlAccountItem[];
  args: IdlField[]; //<-- this badboy
};
```

Not sure how you formulate it in that interface though x.x
```ts
export type IdlField = {
  name: string;
  type: IdlType;
};
```
thanks so much alan!!
Yep agreed ^
Alan you're the savior of this channel, i see your name daily lol
thank you so much
Yeah, usually multi-sig means something more complicated than just having multiple things sign
I'll send you the example when im on my laptop, it should explain itself ü§£
say more please
Hmm, i saw an example of multi-sig signing, it looked way more complicted than just passing two keypairs in the signers array
yeah makes sense. appreciate the detailed answer
Then on the rust side solana will say "this account that got passed in, it also signed btw"
No, signers just says sign the tx, on the js-side, with all of these keypairs
So I'm kind of not sure what type of answer you're looking for‚Äîit kinda just happens, via programming ü™Ñ‚ú®, lol
does signers get pushed into `Context<doSomething>`?
Mm... I'm trying to think how to answer that question. That all happens inside the rust program‚Äîon the JS side those arguments get encoded (via borsh) into the underlying instruction's data field (low-level solana stuff). So at the end of the day a low-level solana instruction gets built + invoked, and then on the rust side anchor deserializes those arguments + validates all the accounts (based on what you asked it to do in your `derive(Accounts)` struct)
To reframe my question, how does `program.rpc.doSomething(arg1, arg2, ...)` transform (arg1, arg2, ...) into `Context<doSomething>`?
do you know where I can find the general RPC function/method signature for anchor programs?
About `signers`, under the hood the js side will use each of those `signers` keypairs to sign the transaction.
2. Not sure if there's much to say about what's going on under the hood, the js syntax is just specifying which accounts your instruction cares about, and then in rust anchor gives you access to them.
1. Just means that the rpc argument list is actually flipped from how it looks in rust. In rust it's ctx, arg1, arg2, etc, whereas in JS its
```.js
program.rpc.doSomething(arg1, arg2, {
  accounts: {
    ...
  },
  ... // other stuff, like signers, preInstructions, etc.
});
```
Lots of examples in the anchor repo
If we have a struct that looks like so:

```
#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 16 + 16)]
    pub vote_account: Account<'info, VoteAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```

And a program RPC method that looks like:

```
pub fn initialize(ctx: Context<Initialize>) -> ProgramResult {
        let vote_account = &mut ctx.accounts.vote_account;
        vote_account.crunchy = 0;
        vote_account.smooth = 0;
        Ok(())
    }
```

In the tests we call `initialize` like so:

```
/* The last element passed to RPC methods is always the transaction options. Because voteAccount is being created here, we are required to pass it as a signers array */
    await program.rpc.initialize({
      accounts: {
        voteAccount: voteAccount.publicKey,
        user: provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      },
      signers: [voteAccount],
    });
```

1/ What is meant by "the last element passed to RPC methods is always the transaction options"? How is signers here a transaction option? 

2/ What is going on under the hood here? It looks like the first thing anchor does is wrap the input dictionary into a `Context<Initialize>` https://docs.rs/anchor-lang/0.13.2/anchor_lang/struct.Context.html - given the 3 variables on the Context wrapper are `program_id`, `accounts`, and `remaining_accounts`, it must infer `program_id` and `remaining_accounts` is empty, accounts is clearly passed in. What does it do with `signers` under the hood? What are some other "transaction options" we can pass through?

This question is referencing https://www.brianfriel.xyz/learning-how-to-build-on-solana/ tutorial.
How are you searchign?
I'm not finding the preInstruction anywhere :/
Hmm 2 sec let me write some pseudocode out üôÇ
The resulting transaction is a regular web3 tx object, so you'd execute it with web3 code (you can also just continue to use `program.rpc.oneInstruction` plus the `preInstructions: [...]` args etc.)
ah how do i execute these ? i don't really see a "execute" on the returned transaction? nor a method for executing transactions on the program.
second line should use `myProgram.instruction.myInstruction(...)`, but yeah
?
So hypothetically to keep it simple say i wanted to make the same call 2 times in a single transaction <:CKThink:889727701106184202> 
```ts
    let transaction = this.myProgram.transaction.myInstruction(...Args);
    transaction.add(this.myProgram.transaction.myInstruction(...Args));
```
hmm let me have a quick look <:CKThink:889727701106184202>
Can also use `program.transaction.yourInstructionName` to build a tx object, then manually add instructions to it, etc.
Bunch of ways: you can build raw instructions with `program.instruction.yourInstructionName` and add it to an existing rpc call with `preInstructions: [...]` or `postInstructions: [...]`
Is there a way to combine rpc's into a single transaction? - I can't really find a good example anywhere it's done.
Hello, Is there a way to set the program Id on a first deployment?
Hi! looking at this https://docs.rs/anchor-lang/latest/anchor_lang/context/struct.CpiContext.html#example-with-and-without-pda-signature  that shows both ways to `Cpi::new` and  `Cpi::new_with_signer`, isn't it the case that `do_cpi` won't ever run because it wont be able to sign the `authority`? (since PDA, no KeyPair)
Program-derived addresses are actually totally different from program addresses, but yeah, your description of PDAs sounds good. The key thing is that the program ID is indeed just the program account's public key (there's a second program account assuming you use the upgradeable deployment process, but yeah, your program ID is the public key for one of the resulting program accounts).
An associated token account is really just an associated token *address*. The account itself is still just a regular token account, it's only the address that is special: it's a program-derived address that has been derived from the associated token program (a little helper program, not the same thing as the spl token program) with seeds based on the mint + the token owner.
A program ID is indeed just a regular old account address‚Äîwhen you deploy a program, solana allocates two accounts (as far as I know, maybe more), one of which lives at your program id (so in other words, it's just an account address).
Nvm it does
Does freezing a token account, disable transfering token ?!
Thanks Sir! Very helpful folder. What is the difference between TokenAccount created here
https://github.com/project-serum/anchor/blob/83121c26eb578487196524d5829099a70503a5a3/tests/ido-pool/tests/ido-pool.js#L41
and the Associated Token Account  here
https://github.com/project-serum/anchor/blob/83121c26eb578487196524d5829099a70503a5a3/tests/ido-pool/tests/ido-pool.js#L165
https://solanacookbook.com/references/anchor.html#calculating-account-space-size
how to import multiple .so files in Anchor.toml?
is there a guide on how to choose the correct space when initializing an account with a Vec inside?
Think seeds as desrcibed in this macro

```
    #[account(
        init,
        token::mint = usdc_mint,
        token::authority = vault_authority,
        seeds = [VAULT_USDC_SEED.as_bytes(), vault_name.as_bytes()],
        bump = bumps.vault_usdc,
        payer = vault_admin
    )]
    pub vault_usdc: Box<Account<'info, TokenAccount>>,
```
Seed phrases? Are you deriving a PDA?
what are seeds? what would a ``` Error: 146: A seeds constraint was violated
``` mean?
Or docs
Hey, anyone have any good test scripts or some way of setting up a collection NFT?
Yes you need an airdrop. Are you generating a new key in your test, or connecting to your file system wallet? If generating a new one, you will need to request the airdrop after generating your keys.
Also im on anchor version 0.20.1
In particular I'm trying to run the it("setup game!") unit test
Am I supposed to have a local solana-test-validator running?
I'm trying to run the first test from the anchor lang milestone tutorial and I'm getting the following error:

**Transaction simulation failed: Attempt to debit an account but found no record of a prior credit. **

I think I need to request an airdrop but I'm not quite sure.

I've tried looking for a similar issue on github, here, and by googling but I'm coming up a little short. I'm super new to anchor, and rust but have a fair bit of experience writing tests for smart contracts.

I'm not sure if maybe anchor is using a different wallet then the one on the test or maybe pointing somewhere. Has anyone experienced something like this while running the test for the tutorial?
Hey guys,
hm, I guess this brings me into a more general question - what is the difference between a program ID vs. a program address vs. a public key? My understanding so far is:

A public key is a property of every account. It serves as a reference to an account (this can be for a data account or a program account)

The program address can also be called a program derived address, and this is a hash between our seeds and a programId. This program address acts as a "private key" to the corresponding program (one which our program, the one running, owns). The program address is used in the invoke/execute transaction method to run the corresponding program. What I've described is the PDA (Program Derived Address), it sounds like the program address is similar to the program account's public key? 

ProgramId, this is just the program that was deployed's resulting hash. My understanding is that this is distinctly different from the program account's public key but your comment here confuses me a bit? I guess an program account can have a program ID and a public key and declare ID allows you to verify the former.

Let me know if I'm missing anything here!
For `bump`, where is it getting the value from? https://solanacookbook.com/references/anchor.html#accounts-deserializers If I have it calculated on the front end, how do I pass it in?
how can I read this to figure out how each of the arguments to account attribute work? https://docs.rs/anchor-attribute-account/0.21.0/src/anchor_attribute_account/lib.rs.html#62-65
has nothing do to with anchor per se. It's a lifetime annotation. https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#validating-references-with-lifetimes
What is the `'info` in `Initialize<'info>,` `Signer<'info>` and all the other structs? It seems to be in every generic definition. See it being mentioned, but cant find an in depth definition in the docs https://docs.rs/anchor-lang/latest/anchor_lang/accounts/account/struct.Account.html#impl-Accounts%3C%27info%3E
lmao nvm my seed just wasnt working :/
Because before I was writing a regular counter program + passing the bump and generating a seed with a phrase and users wallet
Ok so to have a PDA I must define it as an account in another program, then call that program from the current program?
Thank u ‚ù§Ô∏è
https://docs.solana.com/developing/programming-model/calling-between-programs#program-derived-addresses
Gday guys, does anyone have any good resources on PDA's they could point me too üôÇ üíã
am I just using the blockchain in an awkward way? should I be trying to solve my problem off chain or client side?
unless the index was maybe a timestamp idk
yeah i see what youre saying, sounds like lookups would be super slow since you would just have to iterate through every single one
Definitely possible to do that, it's just significantly more awkward
i guess if my tickets had a max amount possible to be minted then i could do some math and figure out how many aggregate accounts
It wouldn't work at all with a per-user PDA, so you'd have to store that info in aggregate accounts (a bunch of users per account)
Yeah, the "all users who have ever minted" thing is a bit harder, and depends on how many users there are
i guess maybe i could do an index as part of the seed, and iterate through 0-n, inside each account having a key:value pair of user_pubkey:amount_minted
like again, but if I wanted to get all users who ever minted i wonder how i could structure it
i wouldnt be able to look up a user unless they interacted with the program
haha all good, so in that scenario
E.g. if all you care about is looking up how many tickets a given user has, you could store that in a per-user PDA
But yeah, in general you kinda just have to think about how you want to access your data (lol, not a very helpful answer)
could I do something like a PDA derived from a user pubkey and my vault pubkey, which then i would store a counter to how many tickets/tokens they minted from my vault?
oh sweet
You can still store Vectors in your account data, you just need to make sure you actually allocate enough space for their eventual max size (whatever you're comfortable with)
just kinda trying to figure out how to think about this
I cant have data structures like vectors in my account data right? So that would need to be static. I assume each Account would hold 10kb worth of data my program can reference
I wanna keep track of tickets I mint to users when they deposit into my vault
Im reading up on https://github.com/solana-labs/solana-program-library/blob/master/farms/farm-sdk/src/refdb.rs
Can you say more? Not quite sure what you mean
anyone got a simple example of an on chain db? or any tips?
beautiful, thank you!
Or `preInstructions: [...]` and `postInstructions: [...]`
Yep, see the `instructions: [...]` argument
When you hardcode your intended ID into your own source code (what declare_id does), that lets other people verify that the thing their going to CPI to really does have the right/intended program_id (necessary because the client had to submit your program as an account in order to be able to CPI to it).
hopefully quick question, does the Anchor-generated client support including multiple instructions in one transaction?
The reason why it's important is actually for *other* programs in case they want to CPI to your program: it's important that they know exactly what your intended program id is, since otherwise a devious client could trick their program into CPI-ing into some random *other* program rather than your own one.
All it does is declare a static `ID` variable with your intended program id (plus a couple helper functions).
I have a few question about the `declare_id` macro:

1/ Have read from multiple sources that this makes it easier to build more secure applications. How exactly does it do so? My guess is that there's a check when you invoke the programId of the deployed program, and if the declare_id is not equal to the invoked programId, then the rpc calls just don't run. Although I'm not really seeing this from the implementation here

```/// Defines the program's ID. This should be used at the root of all Anchor
/// based programs.
#[proc_macro]
pub fn declare_id(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
    let id = parse_macro_input!(input as id::Id);
    proc_macro::TokenStream::from(quote! {#id})
}```

source: https://docs.rs/anchor-attribute-account/0.21.0/src/anchor_attribute_account/lib.rs.html#316

2/ What happens if you put an arbitrary program here? Whenever we run `anchor build` on the same code, the programId appears to be deterministic. If we use an arbitrary programId in the declare_id macro, does our program just not run? What is going on here?

thanks!
That source code lives here: https://github.com/solana-labs/solana/blob/master/keygen/src/keygen.rs#L528
not sure if this is the right place to ask, but what is `solana keygen` calling under the hood? I want to read through the source code here but am having a hard time finding the source code
And am I understanding borsch struct serialization correctly in that the struct fields don't require any additional space beyond that required to accommodate the field's data, i.e., nothing required for the field name?
is the best practice for unit testing on chain programs to do that in the js client? also, where can I find more info on how to use the rust client for on chain programs?
from AccountInfo to Account<User>
How to convert from AccountInfo to Account ? 
have remaining accounts that are AccountInfo but might follow certain account structure
I'm trying to use https://docs.rs/spl-token-swap/2.1.0/spl_token_swap/ this in anchor but on initialize funtion I get thi error `the trait BorshSerialize is no implemented for spl_token_swap::curve::fee::Fees`
cool - here's the fix:
```rust
        let signer_seeds = [
            "pda".as_bytes(),
            &program::MemberNfts::id().to_bytes(),
            &[bump_seed],
        ];
        token::mint_to(
            CpiContext::new_with_signer(
                ctx.accounts.token_program.to_account_info(),
                mint_to_ctx,
                &[&signer_seeds],
            ),
            1,
        )
```
is there a way to check detailed log
though it creates the project directory but not sure if everything is fine within it
Installed it
Think that means you don't have `yarn` installed
thanks - was just on to that!
I get error when I do anchor init Error: yarn install failed: No such file or directory (os error 2)
Ah, ok, you aren't actually signing with the PDA when you try to do the `mint_to` part. You need to use `CpiContext::new_with_signer` and add in the PDA's seeds *and* bump.
Whoops, sorry, can't read ü§¶‚Äç‚ôÇÔ∏è
So you want the PDA to also pay for the mint's initialization?


//////////////////////////////////////////////////////////////////////////////////////////

> `The #[account] attribute implements the Owner trait for a struct using the crate::ID declared by declareId in the same program.`

what's the idiomatic way to add `#[account]` to a type `T` defined outside of the current anchor crate (where `T` corresponds to an `AccountInfo`)? Create a wrapper struct?
I don't understand which parameter could have a `.c` function or a `.b.span`
```                                H = anchor.web3.SystemProgram.createAccount({
                                    fromPubkey: payer.publicKey,
                                    newAccountPubkey: mint.publicKey,
                                    lamports: G,
                                    space: c.b.span,
                                    programId: c.c
                                }),```

Does anyone have any idea what the **c** parameter here could be?
Also more broadly, are there any repos you‚Äôd recommend reading through for examples on how anchor/solana transfer SOL and spl tokens between accounts and programs? Or just generally repos that show off best practices and have extensive coverage of solana/anchor?
Where can i find the interface for `AccountClient` and the `AccountInfo` object? I want to read through all the other methods that exist
On the rust side, the lamport balance lives on the account info, `a.to_account_info().lamports()`
On the client you'd just fetch the account:
```.rs
await program.provider.connection.getAccountInfo(keypair.publicKey)
```
Are you trying to check in your rust program? Or on the client?
for example, if I do something like:

```
invoke(
    &system_instruction::transfer(
        &a.to_account_info().key,
        &b.to_account_info().key,
        1_000_000_0, // 0.1 SOL
    ),
    &[
        a.to_account_info().clone(),
        b.to_account_info().clone(),
        system_program.to_account_info().clone(),
    ],
)?;```

best practice is to check the sol balance before transferring right? or do we not usually do that?
e.g. if I have `const keypair = anchor.web3.Keypair.generate();` is there an easy way of getting the sol balance?
given a keypair, how can you check the SOL balance?
gm
To access details about the mint account, you'll have to pass it into your instruction as a separate account (and can then deserialize it with `Account<'info, Mint>`)
Given an `Account<'info, TokenAccount>`, its mint address is lives at the `.mint` property
I have a `Token Account` here: https://explorer.solana.com/address/GcY9v6VCAnhSy2cDbue136Kwquf7rj7WfPbvdQNPXyZW?cluster=devnet

How do I get information about the `Mint Address` of the token with anchor?
anchor idl is generated when the program is built using  `anchor build`. If you don't have the source code or the idl is not published, there's no way of acquiring it.
and what's the best way to go about finding a program's idl if anchor returns null?
thanks, will check it out, probably gonna come back with few more queriesüëç
I wanna restrict the number of accounts the user(Wallet) can create in my program to just one

one : one
It is possible but without the idl or source code you would have to do reverse engineering to figure out how to encode/decode the instructions and accounts, what are the arguments and so on.
Is it possible to interact with a program for which you don‚Äôt have idl for?
thanks a lot! üôÇ
https://docs.solana.com/developing/clients/jsonrpc-api#getprogramaccounts
is there a function to find all accounts (that store data), owned by a specific program?
no need to initialize
You don't need to allocate space for PDA authorities. Just generate the address and use it.
use PDAs derived from the wallet for creating the accounts
lets say I'm initializing a PDA, and I don't intend to store any data in there. Should I put 8 as the space? or should i put a different number
What do you mean? Can you give an example?
I'm trying to restrict account to 1 per wallet, can someone suggest me how can i do it?
Unknown program
Okay thanks a lot! Damn anchor this is neat
So, yes
It will check if `tweet.author == author.key()`, close `tweet` account and return rent to `author` account
ohh okay thanks!!

and so
```rust
#[derive(Accounts)]
pub struct DeleteTweet<'info> {
    #[account(mut, has_one = author, close = author)]
    pub tweet: Account<'info, Tweet>,
    pub author: Signer<'info>,
}
```

will close that tweet account of `author` and return the rent?
The tx will fail if `author` doesn't have authority(it isn't author) of tweet
It checks if `tweet.author == author.key()`
```rust
#[derive(Accounts)]
pub struct UpdateTweet<'info> {
    #[account(mut, has_one = author)]
    pub tweet: Account<'info, Tweet>,
    pub author: Signer<'info>,
}
```

can anyone help me? what does the `has_one` parameter do in ```rust
#[account(mut, has_one = author)]
```
nvm found it: `Clock::get()?.unix_timestamp`
ty ser
ty ser
how do you get the current timestamp from within a program?
This looked like the logic related to building methods from instructions that resolved the addresses for the pdas. https://github.com/project-serum/anchor/blob/d5e7e2a7c32770c1bc50ff0957105318047a0f31/ts/src/program/accounts-resolver.ts#L43. It seemed like something like that could be used to fetch pda accounts by their seeds, but it is a little more complicated since the pda is specified in the instruction and the seeds aren't stored with the account in the idl.
In order to make this work, this has to be set in `Anchor.toml`
```
[features]
seeds = true
```
context is set up like this:
```rust
pub struct CreateUser<'info> {
    #[account(mut)]
    payer: Signer<'info>,
    #[account(init, payer = payer, seeds = [payer.key.as_ref()], bump, space = 8 + 4 + 5 * 32)]
    account: Account<'info, User>,
    system_program: Program<'info, System>,
```

but idl is coming out without being designated as pda:
```
{
      "name": "createUser",
      "accounts": [
        {
          "name": "payer",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "account",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": []
    }
```
Hello guys, may I know if PDA is deterministic? if I have one fixed seeds, it will only one bump valid for PDA?
Double check the address in your Anchor.toml file matches the one you want to use. If you re-forked the repo, it probably got overwritten to another value
I'm also interested if anyone has a tried and true system for securing the program's update authority. 2/3 multisig is desirable. I see options maybe from Goki and Cashmere, but I have not tried either. Generally, it would be awful to launch a protocol, only to find out your multisig is busted a few months later. Sort of looking for the "safe bet" if people have recommendations.
If you were paranoid you could create it with an offline computer, optionally with a seed phrase that was generated in a very offline way (paper in a hat, and calculate the checksum using seedpicker.net): https://btcguide.github.io/setup-wallets/paper
Ah, yeah, that's not an issue for solana‚Äîat any rate, I'm curious how other people manage their program_id keypair
...So maybe delete the key after you have recorded the address?
Ha ok well I won't do it, but I was just wondering. My understanding is that in ETH, if you own the key to a smart contract, you can empty any funds that get put in there
That creates the account, and then afterwards it doesn't get used for anything else (so at least no solana vulnerability if you leak that keypair, though yeah, leaking it does make me slightly nervous)
Ah, it's only used for your first deploy.
Right, as that keypair lives in target/deploy/<keypair>.json... So it's not a problem? Can anything happen if that key is compromised?
No, your program_id will be a regular keypair address
i had the multisig program up and running, and github wouldnt let me resolve some issues so i reforked it. when i try to deploy under the same provider, it is using a different address. how can i make it update the previous address?
Should an anchor program have an address that is off the elliptic curve?
https://book.anchor-lang.com/chapter_2/hello_anchor.html
How do I do that?
maybe start a new project and change Anchor.toml to point to your wallet file as a starting place?
Can someone help me please
Does this require master vs v0.21? I keep getting ` Error: Invalid arguments: account not provided.`
any good resources to recommend when looking into sending a token-transaction between accounts? I am having a hard time understanding the logic when running the actual token transactions (compared to just changing values on a single account) from one wallet to another for example
for anyone. that's my program.
What that example for me?
how does it know that `account`, `payer` and `system_program` aren't required to be included in `accounts`? https://github.com/project-serum/anchor/blob/d5e7e2a7c32770c1bc50ff0957105318047a0f31/tests/pda-derivation/programs/pda-derivation/src/lib.rs#L45
I'll see if I can figure that out to complement this:
```js
    await program.methods
      .initMyAccount(seedA)
      .accounts({
        base: base.publicKey,
        base2: base.publicKey,
      })
      .rpc();
```
Take a look at the jet protocol codebase:  https://github.com/jet-lab/jet-v1/
No, though maybe there should be (you'll need to re-find the full address)
program:

```
#[program]
pub mod solanamm {
    use super::*;
    pub fn init_mint(
        _ctx: Context<InitializeMint>
    ) -> ProgramResult {
        return Ok(())
    }
}

#[derive(Accounts)]
pub struct InitializeMint<'info> {
    #[account(
        init,
        payer = payer,
        mint::decimals = 0,
        mint::authority = payer
    )]
    pub mint: Account<'info, Mint>,
    pub payer: Signer<'info>,
    pub token_program: Program<'info, Token>,
    pub system_program: Program<'info, System>,
    pub rent: Sysvar<'info, Rent>,
}
```
 
client:

```
token_mint = Keypair()
    await program.rpc["init_mint"](
        ctx=Context(
            accounts={
                "mint": token_mint.public_key,
                "payer": payer,
                "token_program": TOKEN_PROGRAM_ID,
                "rent": SYSVAR_RENT_PUBKEY,
                "system_program": SYS_PROGRAM_ID,
            },
            signers=[]
        )
    )
```
```
anchor-lang = "0.21.0"
anchor-spl = "0.21.0"
```
Fixed the issue
Found the problem
```anchor-lang = "0.20.1"
anchor-spl = "0.21.0"```

The anchor-lang was in a different version
did this. they all match up üôÇ
All I'm trying to do is to allow a user to deposit an SPL token to the PDA token account for now. I couldn't find a simple example for this so I was using the IDO-POOL test as my reference. if there is something simpler, i'm all ears
I'm brand new to Rust and Achor so I'm sure its something fundamental I'm missing üòÑ
```error[E0277]: the trait bound `TokenAccount: anchor_lang::Owner` is not satisfied```

Issue resolved-> Solution below
Trying to work out what this error is: I stole the snippet from the test of ido. Is there some import I'm missing?
`pub user_usdc: Account<'info, TokenAccount>,`
`the trait anchor_lang::Owner is not implemented for TokenAccount`
Hey guys, I would like to know if there is a live example of spliting your code in instructions, utils, process. The main reason I am asking this is because everytime I tried to not make a single file for my code I start getting a lot of errors and I would like to know the propper way to do it. Thanks in advance!
is there a way to do this with just the seeds for a pda?
```js
const userAccount = await program.account.user.fetch(pda);
```
In case you‚Äôre unsure, look through your terminal history and try using all of the addresses
Been a while since this happened but I remember that there were a few addresses floating around ‚Äî try finding the deployed address of the contract itself
Is there a way to validate a signature given as input, assuming that the pub key is stored in the state, and the message is also received as input?
I'm trying to follow:
```rs
# Struct solana_sdk::signature::Signature
pub fn verify(&self, pubkey_bytes: &[u8], message_bytes: &[u8]) -> bool
```
Hmm, that's a pretty low-level solana error, I don't think it has anything to do with the program_id ü§î
help here appreciated.
can't figure out what to pass for buffer and pda
Is there a good resource for learning how to write test code (js) for contracts
You forgot to mark that account as mut
`    6ygRUb4g5p2nUQ5PgVzrcBAgbXLKvs7nyx3Fjp9wg3t6's writable privilege escalated
`
i'm on localhost,
minting & delegating the ata on JS
then invoking a stake_nft RPC with the delegate as signer
which invokes mpl_token_metadata::instruction::freeze_delegate_account

```
Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account 
    Program FggV1tBd4vAJTraCnWRtU7bjAG2QuzcG1tr4cd5gbsCs invoke [1]
    Program log: Instruction: StakeNft
    6ygRUb4g5p2nUQ5PgVzrcBAgbXLKvs7nyx3Fjp9wg3t6's writable privilege escalated
    Program FggV1tBd4vAJTraCnWRtU7bjAG2QuzcG1tr4cd5gbsCs consumed 12661 of 200000 compute units
    Program FggV1tBd4vAJTraCnWRtU7bjAG2QuzcG1tr4cd5gbsCs failed: Cross-program invocation with unauthorized signer or writable account
```
i can't get past this error myself.

program_id is the same in:

- declare_id!
- anchor.toml
- "address" field of my metadata.

built and deployed to testnet.
Can you post the full program log?
ah crap still can't find what i'm doing wrong to delegate freeze an account ‚ò†Ô∏è
thx!
You could do a constraint, `constraint = token_from.owner == staking_info.key()`
Yes, signers from the client are still signers across CPIs
Then shouldn't the associated_token constraint do the job?
`Can be used as a standalone as a **check** or with init to create an associated token account with the given mint address and authority.`
nono, problem not in ATA creator. I want to protect my program from send foreign ATA from another client
doesn't creating an associated token account require a mint in the first place? ü§î
no, this constraints about mint but i want check owner. But maybe i can check by authority?
i hope i understood u correctly,

check out the spl contraints
https://docs.rs/anchor-lang/0.21.0/anchor_lang/derive.Accounts.html#spl-constraints
hey guys, i have a pda account and ata account connected to this pda account. How i can check that this ATA owner = my_pda account? I tried owner = mypda.key() but this's not work, my code ```#[account(mut, owner = staking_info.key())]
    pub token_from: Account<'info, TokenAccount>,
#[account(mut, seeds = [user.key().as_ref(), b"agrostaking"], bump)]
    pub staking_info: Account<'info, StakeInfo>,```
does invoke_signed with empty seed pass RPC call signers ?!
maybe something with this would help? if local, you could just take the first one and get the `rpc` property
```js
console.log(await program.provider.connection.getClusterNodes());
```
Yep, always have to pass all account (even ones that don't exist yet, lol) into the program
question on the programming model: if i am going to init a pda in a program, I still have to pass the pda address in to the program - you can't just create the account in the program and store the address - is that right?
Yep, that will validate that its address is that PDA
Is there a function to check which network you are connected to in a typescript test?
is this a reasonable way to validate that the user account passed in is in fact the pda generated from the payer's address?
```rust
#[derive(Accounts)]
#[instruction(group_seed: Pubkey)]
pub struct CreateGroup<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    #[account(mut, seeds = [payer.key.as_ref()], bump)]
    pub user: Account<'info, User>
```
hi when we run anchor deploy (trying to run on devnet), which file does it exactly run? when I do it it keeps repetitively printing message and I'm not sure if I accidentally added a custome message somewhere.
Should I create the client.js and add the code from the id.json which contains the keypair?
Guys I think I know what's my problem. I was checking my node_modules file and I couldn't find the "client.js" one. That means it doesn't exist I don't know why. What should I do?
So you do cut some "startup" fees by bundling transactions essentially?
Don't think the preflight stuff costs any fees
One question though. How does it work with fee's, do you essentially save fee costs for bundling them up like that?
I see the combined fee is still at 0.000005 SOL
works perfectly btw ur a god! really appreciate it


//////////////////////////////////////////////////////////////////////////////////////////

The reason you need a signature when sending sol with the system program is not because of any solana reason, it's just that that's how the system program is written‚Äîit requires a signature.
To elaborate on this: because your own program owns the multisig account, it doesn't require a signature in order to take the account's lamports‚Äîit owns the account, it can do whatever it wants with it.
Or otherwise explicitly add the multisig's keypair to the signers array
So yeah, just get rid of that `signer` attribute and see what happens
So the anchor client says "... uh"
You have declared in your rust code "this account must sign", but you aren't signing for it
But there's never any solana requirement to sign (the program that owns an account can mutate it etc. without any signature)
right, in this case you are saying that there's a signing issue on the client side?
When sending sol from a system account to someone else, the system program requires the source account to sign (makes sense)
So for example, when creating an account, the system program just happens to require the new account's address to sign
The only time you *need* to sign is when whatever program you're interacting with requires it
^ yep, playing around with it
Oh, sorry, you're forking the multisig codebase
in the mean time, is there documentation or a blogpost that outlines when an account needs to be a signer and what the limitations are around this?
just sent you an invite
cqfd
What's your github handle?
Do you have your code in a github repo I could play with?
Yeah, wait, I'm pretty confused now about what you're doing
Isn't the Multisig owned by the multisig program?
Wait, don't see how it will work if you're storing the funds in the multisig account itself ü§î
It needs to be a signer since it's transferring SOL out? or are you getting at that the `multisigSigner` is what needs to be the signer?
Why doesn't it need `#[account(signer)]` though?
no worries, you are being super helpful!
it needs to be mut since it transfers from from the multisig out
Sorry, not super familiar with the multisig program
Maybe it does need to be mut
Oh, maybe not actually
It should be neither signer nor mut presumably
The problem is that you've explicitly required the multisig to sign, with that `#[account(signer, mut)]` thing
we have `accounts` and `remainingAccounts`
So the client call looks like:

```
await program.rpc.executeTransaction({
      accounts: {
        multisig: multisig.publicKey,
        multisigSigner,
        transaction: transaction.publicKey,
      },
      remainingAccounts: program.instruction.sendSol
        .accounts({
          multisig: multisig.publicKey,
          receiver: ownerA.publicKey,
          multisigSigner,
        })
        // Change the signer status on the vendor signer since it's signed by the program, not the client.
        .map((meta) =>
          meta.pubkey.equals(ownerA.publicKey)
            ? { ...meta, isSigner: true }
            : meta
        )
        .concat({
          pubkey: program.programId,
          isWritable: false,
          isSigner: false,
        }),
    });
```
hm, what is your thought process when you try to debug something like this then?
This is the part where the program says "ok, yep, everything looks good‚ÄîI'll sign for this PDA üëç"
We're finally producing a signature for the multisigSigner PDA
So we're not signing for/don't need a signature for the multisig account (the one that stores the details of the multisig, threshold etc.)
Yep
Its seed is the multisig account's address (`multisig_key.as_ref()`)
```
const [multisigSigner, nonce] =
      await anchor.web3.PublicKey.findProgramAddress(
        [multisig.publicKey.toBuffer()],
        program.programId
      );
```
Go check how the multisigSigner's address is found
That is where we programmatically sign for the *PDA*, the multisigSigner.
we get signer from the multisig_key no?
^ what's going on in the last 8 lines starting with `multisig_key` then?
```
 pub fn execute_transaction(ctx: Context<ExecuteTransaction>) -> Result<()> {
        // Has this been executed already?
        if ctx.accounts.transaction.did_execute {
            return Err(ErrorCode::AlreadyExecuted.into());
        }

        // Do we have enough signers.
        let sig_count = ctx
            .accounts
            .transaction
            .signers
            .iter()
            .filter(|&did_sign| *did_sign)
            .count() as u64;
        if sig_count < ctx.accounts.multisig.threshold {
            return Err(ErrorCode::NotEnoughSigners.into());
        }

        // Execute the transaction signed by the multisig.
        let mut ix: Instruction = (*ctx.accounts.transaction).deref().into();
        ix.accounts = ix
            .accounts
            .iter()
            .map(|acc| {
                let mut acc = acc.clone();
                if &acc.pubkey == ctx.accounts.multisig_signer.key {
                    acc.is_signer = true;
                }
                acc
            })
            .collect();
        let multisig_key = ctx.accounts.multisig.key();
        let seeds = &[multisig_key.as_ref(), &[ctx.accounts.multisig.nonce]];
        let signer = &[&seeds[..]];
        let accounts = ctx.remaining_accounts;
        solana_program::program::invoke_signed(&ix, accounts, signer)?;

        // Burn the transaction to ensure one time use.
        ctx.accounts.transaction.did_execute = true;

        Ok(())
    }
```
No, the multisig account just stores the details of your multisig situation (who the possible signers are, what the threshold is)
i.e. in the execute transaction function we have:
Doesn't the multisig need to sign in order for `execute transaction` to run?
I wouldn't expect it to need to sign again.
You've already created the multisig account.
Why does the multisig need to sign the execute transaction part?
Hmm, that error is coming from the client, and its saying that it expected some account to sign (from the client), but it didn't.
I set multisigSigner `isSigner` to false here and only `multisig` has `isSigner` set to `true`.
but for some reason, I'm getting:

```
     Error: Signature verification failed
      at Transaction.serialize (node_modules/@solana/web3.js/lib/index.cjs.js:2829:13)
      at Provider.send (node_modules/@project-serum/anchor/dist/cjs/provider.js:89:26)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at async Object.rpc [as executeTransaction] (node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:31:31)
      at async Context.<anonymous> (tests/multisig.js:164:5)
```
this is how I set up the `executeTransaction` in my test:

```
// Now that we've reached the threshold, send the transactoin.
    await program.rpc.executeTransaction({
      accounts: {
        multisig: multisig.publicKey,
        multisigSigner,
        transaction: transaction.publicKey,
      },
      remainingAccounts: program.instruction.sendSol
        .accounts({
          multisig: multisig.publicKey,
          receiver: ownerA.publicKey,
          multisigSigner,
        })
        // Change the signer status on the vendor signer since it's signed by the program, not the client.
        .map((meta) =>
          meta.pubkey.equals(multisigSigner)
            ? { ...meta, isSigner: false }
            : meta
        )
        .concat({
          pubkey: program.programId,
          isWritable: false,
          isSigner: false,
        }),
    });
```
This is a lot of code‚Äîwhat should I be looking for?
It bundles up all of the multisig verification stuff behind a single PDA, in such a way that if that PDA signs the CPI call, then you know that the conditions of the multisig were indeed met.
So the idea of the serum multisig program is that a program verifies the conditions of your particular multisig situation, and only upon verification will it agree to sign for the multisigSigner address.
I'm saying that PDAs in general are deliberately constructed in such a way that it's just not possible to sign for them from the client‚Äîpart of their purpose is that only their deriving program can sign for them.
when you say "it's not possible to sign for it from the client, only the multisig program itself can sign for that PDA", do you mean that the multisig needs `isSigner` set to `true` and `multisigSigner` needs `isSigner` set to `false`? Is it that within an RPC call only one `isSigner` can be set to true, and if if multiple are then the call fails?
but when I run this test I'm getting:

```
  1) multisig
       encoding send sol:
     Error: Signature verification failed
      at Transaction.serialize (node_modules/@solana/web3.js/lib/index.cjs.js:2829:13)
      at Provider.send (node_modules/@project-serum/anchor/dist/cjs/provider.js:89:26)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at async Object.rpc [as executeTransaction] (node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:31:31)
      at async Context.<anonymous> (tests/multisig.js:164:5)
```
```    const transaction = anchor.web3.Keypair.generate();
    const txSize = 1000; // Big enough, cuz I'm lazy.
    await program.rpc.createTransaction(pid, accounts, data, {
      accounts: {
        multisig: multisig.publicKey,
        transaction: transaction.publicKey,
        proposer: ownerA.publicKey,
      },
      instructions: [
        await program.account.transaction.createInstruction(
          transaction,
          txSize
        ),
      ],
      signers: [transaction, ownerA],
    });

    const txAccount = await program.account.transaction.fetch(
      transaction.publicKey
    );

    assert.ok(txAccount.programId.equals(pid));

    // Other owner approves transactoin.
    await program.rpc.approve({
      accounts: {
        multisig: multisig.publicKey,
        transaction: transaction.publicKey,
        owner: ownerB.publicKey,
      },
      signers: [ownerB],
    });

    // Now that we've reached the threshold, send the transactoin.
    await program.rpc.executeTransaction({
      accounts: {
        multisig: multisig.publicKey,
        multisigSigner,
        transaction: transaction.publicKey,
      },
      remainingAccounts: program.instruction.sendSol
        .accounts({
          multisig: multisig.publicKey,
          receiver: ownerA.publicKey,
          multisigSigner,
        })
        // Change the signer status on the vendor signer since it's signed by the program, not the client.
        .map((meta) =>
          meta.pubkey.equals(multisigSigner)
            ? { ...meta, isSigner: false }
            : meta
        )
        .concat({
          pubkey: program.programId,
          isWritable: false,
          isSigner: false,
        }),
    });
```
```
it ("encoding send sol", async() => {
    const multisig = anchor.web3.Keypair.generate();
    const [multisigSigner, nonce] =
      await anchor.web3.PublicKey.findProgramAddress(
        [multisig.publicKey.toBuffer()],
        program.programId
      );
    const multisigSize = 200; // Big enough.

    const ownerA = anchor.web3.Keypair.generate();
    const ownerB = anchor.web3.Keypair.generate();

    const owners = [ownerA.publicKey, ownerB.publicKey];

    const threshold = new anchor.BN(1);
    await program.rpc.createMultisig(owners, threshold, nonce, {
      accounts: {
        multisig: multisig.publicKey,
      },
      instructions: [
        await program.account.multisig.createInstruction(
          multisig,
          multisigSize
        ),
      ],
      signers: [multisig],
    });

    let multisigAccount = await program.account.multisig.fetch(
      multisig.publicKey
    );

    await program.provider.connection
      .requestAirdrop(multisig.publicKey, LAMPORTS_PER_SOL)
      .then((sig) => program.provider.connection.confirmTransaction(sig, "confirmed"));

    const pid = program.programId;
    const accounts = [
      {
        pubkey: multisig.publicKey,
        isWritable: true,
        isSigner: false,
      },
      {
        pubkey: multisigSigner,
        isWritable: false,
        isSigner: true,
      },
    ];
    const amountToMove = new anchor.BN(0.2 * 1000000000)

    const data = program.coder.instruction.encode("send_sol", {
      amount: amountToMove,
    });
```
My test looks like:
```
#[derive(Accounts)]
pub struct ExecuteTransaction<'info> {
    #[account(constraint = multisig.owner_set_seqno == transaction.owner_set_seqno)]
    multisig: Box<Account<'info, Multisig>>,
    #[account(
        seeds = [multisig.key().as_ref()],
        bump = multisig.nonce,
    )]
    multisig_signer: UncheckedAccount<'info>,
    #[account(mut, has_one = multisig)]
    transaction: Box<Account<'info, Transaction>>,
}

#[derive(Accounts)]
pub struct SendSol<'info> {
    #[account(signer, mut)]
    pub multisig: Box<Account<'info, Multisig>>,
    #[account(mut)]
    pub receiver: AccountInfo<'info>,
    #[account(
        seeds = [multisig.key().as_ref()],
        bump = multisig.nonce,
    )]
    multisig_signer: Signer<'info>,
}
```
On the serum multisig if I have:

```
pub fn send_sol(ctx: Context<SendSol>, amount: u64) -> Result<()> {
    **ctx.accounts.multisig.to_account_info().try_borrow_mut_lamports()? -= amount;
    **ctx.accounts.receiver.to_account_info().try_borrow_mut_lamports()? += amount;
    Ok(())
} 

// Executes the given transaction if threshold owners have signed it.
    pub fn execute_transaction(ctx: Context<ExecuteTransaction>) -> Result<()> {
        // Has this been executed already?
        if ctx.accounts.transaction.did_execute {
            return Err(ErrorCode::AlreadyExecuted.into());
        }

        // Do we have enough signers.
        let sig_count = ctx
            .accounts
            .transaction
            .signers
            .iter()
            .filter(|&did_sign| *did_sign)
            .count() as u64;
        if sig_count < ctx.accounts.multisig.threshold {
            return Err(ErrorCode::NotEnoughSigners.into());
        }

        // Execute the transaction signed by the multisig.
        let mut ix: Instruction = (*ctx.accounts.transaction).deref().into();
        ix.accounts = ix
            .accounts
            .iter()
            .map(|acc| {
                let mut acc = acc.clone();
                if &acc.pubkey == ctx.accounts.multisig_signer.key {
                    acc.is_signer = true;
                }
                acc
            })
            .collect();
        let multisig_key = ctx.accounts.multisig.key();
        let seeds = &[multisig_key.as_ref(), &[ctx.accounts.multisig.nonce]];
        let signer = &[&seeds[..]];
        let accounts = ctx.remaining_accounts;
        solana_program::program::invoke_signed(&ix, accounts, signer)?;
        // Burn the transaction to ensure one time use.
        ctx.accounts.transaction.did_execute = true;
        Ok(())
    }
}
```
Nvm lol i was wrong. It was asserting the account field  with the target..
Am I wrong ?üò©
üßê
I didn't get it
Account -> authority
üò∂
Hmmm Is it checking if the account is owned by that account ?
ohh ty once again.
https://github.com/project-serum/anchor/blob/master/lang/syn/src/codegen/accounts/constraints.rs#L187
Hi, what does  #[account(mut, has_one = authority)] --> has_one do ?
Its seeds are the multisig account, and then we also need its bump, which we were smart about and stored in the multisig account.
Can you say more about the seeds/signer stuff in the end? The only thing we're adding a signature for is indeed the `multisigSigner` account
Mm, not in any super easy way as far as I know (maybe the rust test setup can do this? Not sure)
Is there a way for me to log within the rpc calls? i.e. if i want to breakpoint or figure out what value seeds/signer/etc takes on, how would i do that?
Same version as anchor-lang
`anchor-spl` crate, yeah
okay thanks a lot! I ll check it out
do i have to import `associated_token_program` from a rust crate somewhere?
So when they try to call your endpoint, you force them to pass in that PDA address. If you've already stashed an account there, tell them to go away. Otherwise, store an account there (could even be an empty struct) and let them run the endpoint.
The existence of an account at that address implies yep, they've already called
With, say, seeds = `[b"has_already_called", user.key().as_ref()]`
Ah, an easier way would be to use a PDA per user.
so I store a vector of public keys which have called the endpoint?
No, not yet
can anchor idl generate rust clients <a:Hmmmm:695129200260153375>
Only very very slightly.
The client would then have to pass in that account along with their attempt to use the endpoint, and your program would validate whether or not they've already called it.
that would increase the rent, wouldnt it :/
You would need to store the fact that they've called the endpoint in an account, and check it on-chain.
Hey folks! Is there anyway I can restrict an user from calling an endpoint more than once in Anchor? I am building an application which has likes and naturally, a particular wallet cannot call the update likes function more than once.... Thanks in advance!
2. The multisigSigner is a PDA, so it's not possible to sign for it from the client‚Äîonly the multisig program itself can sign for that PDA (once you've convinced it that you really have corralled the right number of signers etc.)
Then if you want to actually sign for that token account's owner (the multisigSigner), you'd have to convince the multisig program that signing is appropriate: by passing in the actual `multisig` account, which stores all the details about this particular multisig setup, and then convincing the multisig program that, yep, enough of the possible signers have indeed signed the intended transaction, etc.
The `multisigSigner` address is the actual PDA address that can then go sign for something later. So for example, if you want the authority over a token account to be a multisig, you'd make the token's owner by `multisigSigner`.
The difference between `multisig` and `multisigSigner` is that `multisig` stores the details about this particular multisig setup in an account: who the possible signers are, and what the threshold is.
also 4/ is there a way for me to log within the rpc calls? i.e. if i want to breakpoint or figure out what value seeds/signer/etc takes on, how would i do that?
```
// Executes the given transaction if threshold owners have signed it.
    pub fn execute_transaction(ctx: Context<ExecuteTransaction>) -> Result<()> {
        // Has this been executed already?
        if ctx.accounts.transaction.did_execute {
            return Err(ErrorCode::AlreadyExecuted.into());
        }

        // Do we have enough signers.
        let sig_count = ctx
            .accounts
            .transaction
            .signers
            .iter()
            .filter(|&did_sign| *did_sign)
            .count() as u64;
        if sig_count < ctx.accounts.multisig.threshold {
            return Err(ErrorCode::NotEnoughSigners.into());
        }

        // Execute the transaction signed by the multisig.
        let mut ix: Instruction = (*ctx.accounts.transaction).deref().into();
        ix.accounts = ix
            .accounts
            .iter()
            .map(|acc| {
                let mut acc = acc.clone();
                if &acc.pubkey == ctx.accounts.multisig_signer.key {
                    acc.is_signer = true;
                }
                acc
            })
            .collect();
        let multisig_key = ctx.accounts.multisig.key();
        let seeds = &[multisig_key.as_ref(), &[ctx.accounts.multisig.nonce]];
        let signer = &[&seeds[..]];
        let accounts = ctx.remaining_accounts;
        solana_program::program::invoke_signed(&ix, accounts, signer)?;

        // Burn the transaction to ensure one time use.
        ctx.accounts.transaction.did_execute = true;

        Ok(())
    }
```

What is going on between seeds/signer in the end? why isn't the signer just the multisig signer? (related to 2)
I have a few questions here:

1/ whats the diff between multisig vs. multisigSigner? my understanding is multisigSigner is the PDA for the multisig program

2/ `// Change the signer status on the vendor signer since it's signed by the program, not the client.` <- why do we change the multisigSigner to *not* be a signer here? isn't "since it's signed by the program"?

3/    In execute_transaction rpc we have:
```
    const transaction = anchor.web3.Keypair.generate();
    const txSize = 1000; // Big enough, cuz I'm lazy.
    await program.rpc.createTransaction(pid, accounts, data, {
      accounts: {
        multisig: multisig.publicKey,
        transaction: transaction.publicKey,
        proposer: ownerA.publicKey,
      },
      instructions: [
        await program.account.transaction.createInstruction(
          transaction,
          txSize
        ),
      ],
      signers: [transaction, ownerA],
    });

    const txAccount = await program.account.transaction.fetch(
      transaction.publicKey
    );

    // Other owner approves transactoin.
    await program.rpc.approve({
      accounts: {
        multisig: multisig.publicKey,
        transaction: transaction.publicKey,
        owner: ownerB.publicKey,
      },
      signers: [ownerB],
    });

    // Now that we've reached the threshold, send the transactoin.
    await program.rpc.executeTransaction({
      accounts: {
        multisig: multisig.publicKey,
        multisigSigner,
        transaction: transaction.publicKey,
      },
      remainingAccounts: program.instruction.setOwners
        .accounts({
          multisig: multisig.publicKey,
          multisigSigner,
        })
        // Change the signer status on the vendor signer since it's signed by the program, not the client.
        .map((meta) =>
          meta.pubkey.equals(multisigSigner)
            ? { ...meta, isSigner: false }
            : meta
        )
        .concat({
          pubkey: program.programId,
          isWritable: false,
          isSigner: false,
        }),
    });
```
In the tests we have:

```
it("Tests the multisig program", async () => {
    const multisig = anchor.web3.Keypair.generate();
    const [multisigSigner, nonce] =
      await anchor.web3.PublicKey.findProgramAddress(
        [multisig.publicKey.toBuffer()],
        program.programId
      );
    const multisigSize = 200; // Big enough.

    const ownerA = anchor.web3.Keypair.generate();
    const ownerB = anchor.web3.Keypair.generate();
    const ownerC = anchor.web3.Keypair.generate();
    const ownerD = anchor.web3.Keypair.generate();
    const owners = [ownerA.publicKey, ownerB.publicKey, ownerC.publicKey];

    const threshold = new anchor.BN(2);
    await program.rpc.createMultisig(owners, threshold, nonce, {
      accounts: {
        multisig: multisig.publicKey,
      },
      instructions: [
        await program.account.multisig.createInstruction(
          multisig,
          multisigSize
        ),
      ],
      signers: [multisig],
    });

    let multisigAccount = await program.account.multisig.fetch(
      multisig.publicKey
    );

    const pid = program.programId;
    const accounts = [
      {
        pubkey: multisig.publicKey,
        isWritable: true,
        isSigner: false,
      },
      {
        pubkey: multisigSigner,
        isWritable: false,
        isSigner: true,
      },
    ];
    const newOwners = [ownerA.publicKey, ownerB.publicKey, ownerD.publicKey];
    const data = program.coder.instruction.encode("set_owners", {
      owners: newOwners,
    });
```
I'm looking through the serum multisig code (https://github.com/project-serum/multisig/blob/master/programs/multisig/src/lib.rs) and have a few questions on how they are calling the rpcs, notably the approve -> execute transaction sequence.
will check it out.
Thanks a lot alan üôè
The solana/spl-token library has a function, `Token.getAssociatedTokenAddress`
if possible can you share a snippet of it
so it's something i should do myself in the client, if so which function should i use to do it?
The anchor code above will validate that you passed in the right address.
So given a user and a mint, you don't have any choice over the associated token address.
Ah, the address for an associated token account isn't just any address. It's a program-derived address, derived from the associated token program, which uses the owner + mint as its seeds.
then (wallet, mint) combination doesn't have any relation to the address of associated token account, since we are the one passing the public key to be used for it?
Haha, about which part?
okay now i'm really confused üòÖ
Yep
?
then doesn't the associated_token_account have that public key as it's address
yeah
yeah i get that but we still pass a public key for the_ata in the client right?
every (wallet, mint) combination produces exactly one associated token account (thats how ATAs are defined). is this your question?
Hi alan i still don't associated token especially with creation of associated token account. we pass a public key that we want to be used to create the associated token account right then how is it one:one mapped to the wallet.
dope, thx!
Yep
as a final question, does this also work for 
``` 
#[account(
    init_if_needed,
    associated_token::mint = the_mint,
    associated_token::authority = the_owner,
    payer = who_should_pay_if_necessary,
)]
pub the_ata: Box<Account<'info, TokenAccount>>
``` 
when the TokenAccount is wrapped in a `Box` ?
yh sounds reasonable. thanks a lot alan! üôÇ
I think it's pretty harmless for associated token accounts, since you weren't going to do any initialization logic for them anyways.
got it, makes a lot of sense
Yes.
ah. so i guess it could be confusing in terms of program-flow, if the larger program has bugs
The risk is that if you're being slightly dumb, you might `init_if_needed` an account and then forget in your instruction function that the account may have *already* been initialized. This could be bad if you do something like `ctx.accounts.that_account.super_important_value = INITIAL_VALUE`.
Honestly still not quite sure why people have such a hard time with init_if_needed lol. It does exactly what it says: if the account comes in already initialized then it does nothing (besides checking the constraints), otherwise it initializes it according to the constraints
but i dont see a reason why there would be
is there any big side-effects to init_if_needed? I heard that its unsafe quite often
ahh very nice, thanks a lot! üôÇ
Yep, can use something like
```.rs
#[account(
    init_if_needed,
    associated_token::mint = the_mint,
    associated_token::authority = the_owner,
    payer = who_should_pay_if_necessary,
)]
pub the_ata: Account<'info, TokenAccount>
```
ah, so this works also for TokenAccounts?
Yeah, that's basically all you can do from the client. From within your rust program you could use `init_if_needed` and create the ATA on the fly if necessary.
I am trying to create a chain of instructions, s.t. the user doesn't have to click "confirm" multiple times (rather, just a single time). and for this I basically need to know if the ATAs should also be initialized 
(because if they are already initialized, it would make the transaction fail)
right now i'm just doing a try-catch. within the try, I create the account. if it fails, I just get it.
What have you tried so far? You can check from the client just by fetching the account and seeing if there's a token account in there.
specifically this https://docs.solana.com/developing/runtime-facilities/programs#secp256k1-program
Hey is there an example for ecrecover?
how do i best check if an ATA (associated token account) exists already?
~~answered my own question in the docs here for anyone else wondering: https://docs.rs/anchor-lang/0.21.0/anchor_lang/accounts/account/struct.Account.html#using-account-with-non-anchor-programs~~

the above doesn't actually work because of the orphan rule
going off the docs / code, `#[account]` generates a bunch of trait impls, which it doesn't have a problem doing since that type already impls `Borsh` + `Clone`
(asked yesterday, but just wanted to ask again to see if anyone knows)

basically I'm interested in having an `Account<'info, T>` where `T` is a type defined outside my crate

```rust
#[account]
pub struct Person {
    person: PPerson
}

#[derive(BorshSerialize, BorshDeserialize, Clone)]
pub struct PPerson {
    name: String
}
```

I run into this error: `IdlError: Type not found: {"name":"person","type":{"defined":"PPerson"}}`, which i _think_ is because the macro `#[account]` also registers the type with the IDL -- **is there a way I can "hook" this type into the IDL?**

the constraint is I can't just attach `#[account]` to a type that doesn't belong to my crate
I believe that calling the Ed25519 program could be a solution. I'm not sure how to achieve this. Source: https://docs.solana.com/es/developing/runtime-facilities/programs#ed25519-program
Following up this question. I've seen that there's a public function in the solana sdk for doing this: `solana_sdk::ed25519_instruction::verify`. However, this is not accessible in anchor, and I can't have `solana-sdk` as a dependency. Is there any workaround?
where can i find the id for associate_token_program?
Hello. Trying to find put best practice for the following scenario:  Let say there is a ToDo list and each ToDo has lot of items inside. Will it be better to create one big ToDo account as an array with all the items inside? or create each item as separate account (PDA?).
should I have a vault(token account) owned by a pda or vault as pda
for token program i can get the id from TokenInstruction how can i get that for associate token program
So associated token program is different from token program?
program id of associated token program
yes! https://twitter.com/anchorlang/status/1491168003136049155?s=20&t=9eRTSAKrP9xeMJFsjuQEFw
What is associated_token_program_id?
I don't remember, it was in an on-hold project. There I have this in an out-of-the way rust module that nothing ever uses:
```
// Nothing in Rust shall use this type. It only exists so the Anchor IDL
// knows about the type and typescript can deserialize it.
#[derive(AnchorSerialize, AnchorDeserialize, Default)]
pub struct I80F48 {
    val: i128,
}
```
Which I think works because anchor doesn't use fully qualified type names? But I don't remember if that fully resolved the issue.
did you get a follow up?
Is this new?
Hi all, in general is your development mostly Rust or Typescript/ Javascript? It seems like with composability you could stitch together different protocols to make something new and useful. But (please correct if I'm wrong) that seems like you are mostly using a TS/JS frontend to talk to existing programs. (I'm looking at something like Serum or Metaplex to start a marketplace of sorts.)
I am specifying anchor-lang and anchor-spl version 0.20.1 in my cargo.toml, but I'm getting build errors indicating that 0.21.0 is being used  `/.cargo/registry/src/github.com-1ecc6299db9ec823/anchor-lang-0.21.0/src/context.rs:51:5`
If it requires a signature from that address then yeah, only possible from within your program
if i have a pda owned by my program, and i want to create a serum open orders account for that pda, is it possible to do from js? or would it have to be from inside my program since only my program can sign for it?
Did you ever figure this out? Maybe there's a repo with an example by now? I know multiple people have built on Mango
having it derive  `#[account]` solves it, but i can't for types from crates i depend on
`IdlError: Type not found: {"name":"person","type":{"defined":"Person"}}`
how does one wrap a type for an account to be used with anchor that's defined outside of the crate?
well it might be `#[account(zero, signer)]`, but thanks I will try things! üôÇ
I haven't actually used the multisig program before, but that sounds plausible
Ah, possibly!
oh, then it might be better with `UncheckedAccount` since the `#[account(init)...]` will happen in the `multisig` program...?
The code you have here does indeed expect the `multisig` account to already be initialized (that's what `Account<'info, Multisig>` means here‚Äîyou're supposed to pass in a previously-created multisig account)
Closing an account in solana is ultimately up to its owning program's discretion
Yep, your program will need to have an instruction that (maybe amongst other things) closes an account
When you say expose an instruction, do you mean I have to create one in my Anchor program that explicitly closes a PDA?
ran program.account.theAccountType.all() like you recommended and found about 300 total accounts to close
I get a 3012 error 'the program expected this account to be already initialized' error when `anchor test`ing (excuse me for the dump)
test looks like this:
```typescript
import * as anchor from '@project-serum/anchor';
import { Program } from '@project-serum/anchor';
import { Shard } from '../target/types/shard';
import { SerumMultisig } from '../target/types/serum_multisig';
import { LAMPORTS_PER_SOL } from '@solana/web3.js';

describe('multisig', () => {

    // Configure the client to use the local cluster.
    anchor.setProvider(anchor.Provider.env());

    const program = anchor.workspace.Shard as Program<Shard>;
    const multisgProgram = anchor.workspace.SerumMultisig as Program<SerumMultisig>;

    const Keypair = anchor.web3.Keypair;
    const PublicKey = anchor.web3.PublicKey;
    const connection = program.provider.connection;

    it('create multisig', async () => {
        const threshold = new anchor.BN(1);

        const owner = Keypair.generate();
        const airdrop = await connection.requestAirdrop(owner.publicKey, 10 * LAMPORTS_PER_SOL);
        await connection.confirmTransaction(airdrop);
        const owners = [owner.publicKey];

        const multisig = Keypair.generate();
        const [multisigSigner, nonce] = await PublicKey.findProgramAddress([
            multisig.publicKey.toBytes()
        ], multisgProgram.programId);

        await program.rpc.cpiCreateMultisig(owners, threshold, nonce, {
            accounts: {
                multisig:multisig.publicKey,
                multisigProgram: multisgProgram.programId
            }
        })

    });
});
```
minimal program:
```rust
use anchor_lang::prelude::*;
use serum_multisig::Multisig;
use serum_multisig::cpi::accounts::CreateMultisig;
use serum_multisig::program::SerumMultisig;
use serum_multisig::cpi::create_multisig;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod shard {
    use super::*;
    pub fn cpi_create_multisig(ctx: Context<CpiCreateMultisig>, owners: Vec<Pubkey>, threshold: u64, nonce:u8) -> ProgramResult {

        let multisig_program = ctx.accounts.multisig_program.to_account_info();
        let multisig = ctx.accounts.multisig.to_account_info();

        let multisig_accounts = CreateMultisig {
            multisig,
        };

        let cpi_ctx = CpiContext::new(multisig_program, multisig_accounts);
        create_multisig(cpi_ctx, owners, threshold, nonce).map_err(|_e|ShardError::MultisigError.into())
    }
}

#[derive(Accounts)]
pub struct CpiCreateMultisig<'info> {
    pub multisig: Box<Account<'info, Multisig>>,
    pub multisig_program: Program<'info, SerumMultisig>
}


#[error]
pub enum ShardError {
    #[msg("multisig error")]
    MultisigError,
}
```
I was referring to this doc: https://yihau.github.io/solana-web3-demo/tour/token-transfer.html
I was playing around with this, where the user creates their own ATA before the owner has to transfer their tokens - since it costs some sol to do so.
Ah, ok, cool‚Äîwhat have you tried so far?
yes I did. The example makes sense to me. I'm trying to combine this 'multisig' feature with https://github.com/project-serum/anchor/tree/master/examples/tutorial/basic-3 (Puppet example) but kind a stuck, thought I should ask if there is previous attempts first...
Have you looked at the multisig tests? https://github.com/project-serum/multisig/blob/master/tests/multisig.js
why didn't I add this never lol
```export const CONNECTION = new Connection('https://api.devnet.solana.com',"confirmed")```
oh nice it works now
Hi, are there examples using `project-serum/multisig` through CPI's?
I think so, can't remember how to though
Mm, not totally sure (I don't quite know enough about what you're trying to do)‚Äîat any rate, just need to think about who needs to sign when
is it possible to add this in the Connection so all the transaction are handled this way ?
The former would be
```.js
await program.provider.connection.confirmTransaction(
  await program.rpc.doSomething(...),
  "confirmed"
);
```
```.js
const sleep = ms => new Promise(awaken => setTimeout(awakenen, ms));
```
how do I do the former ?
thought about that
What happens if you wait for a higher confirmation level (or just sleep a bit)
```if (program) {
            const poolState = await program.account.pool.fetch(pool.publicKey)
            console.log(poolState)
        }```
```        const initialize_pool_transaction = await program.rpc.createPool(new BN(50), new BN(50), new BN(nonce), new BN(50), {
            accounts: {
                pool: pool.publicKey,
                vault: vault,
                poolSigner: poolSigner,
                pyth,
                authority: program.provider.wallet.publicKey,
                systemProgram: SYSTEM_PROGRAM,
                clock: SYSVAR_CLOCK_PUBKEY,
            },
            signers: [pool]
        });
```
Can you post more info about what you're doing? Program log etc?
nope, using devnet on both :))
Probably using different networks in the explorer versus in your code
Yeah I think this is where I got confused. Then as the owner who wants to set up the token transfer, rather than me having to sign everytime when a user would like to get their token transferred, I would have to set the PDA to do the signing for me right?
even tho it obviously exists when I look it up in the explorer
As for closing accounts, there's no automated way to do it in solana, you need to expose an instruction that does it (try searching the anchor repo for the `close = ` attribute)
I get ```Account does not exist GxGCcvCvTsewT63YdzzKPzEhCJHz97mG6w832mYbovfm```
You can do things like `program.account.theAccountType.all()`
(the same thing, meaning the current wallet that's interacting with the program/paying the tx fees‚Äînothing necessarily to do with the wallet that deployed the program)
It's that hardcoded public key
The point is that if you want to do a token transfer, the owner of the source tokens needs to sign‚Äîbut in your code above, you seem to think the owner of the source tokens is the provider wallet, but it's not
No, they're the same thing
Are there any references on how to fetch all the PDA that a program has created?
And also how to close PDAs that a program created
ah I see. So to clarify, the provider.wallet.publicKey --> current user interacting with the client 
program.provider.wallet.publicKey --> wallet who deployed the anchor program
Is this right?
That doesn't look like `program.provider.wallet.publicKey` üòõ
``` const ownerPublicKey = new anchor.web3.PublicKey("4VRBNmqjSncw44HBYbPm5mjKEV2X87PEmT7ikcWmruj1");```
Can you post its definition?
Yeah its the public key of the account that holds all of the spl-tokens that needs to be transfered. The funding wallet
It would need to be the wallet in order for the transfer above to make sense
What is ownerPublicKey then?
```const ownerATA = await Token.getAssociatedTokenAddress(
      ASSOCIATED_TOKEN_PROGRAM_ID,
      TOKEN_PROGRAM_ID,
      tokenMint,
      ownerPublicKey
    );
```
Can you post the definition of ownerATA?
You'll have to do the transfer from within your program, since only your program can sign for one of its PDAs (you can't possibly sign for the PDA from the client)
How are you doing/trying to do that? If you want the owner of the tokens to be a PDA then you actually can't transfer the tokens like this, from the client
So when you try to do the transfer, the token program is like "wtf, the right owner didn't sign this"
That error above means that the wallet isn't actually the owner of the ownerATA
Yes, then I guess the step that I am missing is that I have to make the authority/"owner" of the token account be some program-derived address derived from your program.
To be slightly pedantic, you don't really "create" an associated token address‚Äîyou "find" it. Finding the address doesn't create the account that may or may not live there
That error log has some extra info in it, "owner does not match". Do you know what that means?
Yeah my logic for those was the following: 
1) Create ata address if it doesn't exist
2) Transfer from owner ATA --> receiving ATA
Here is my program log
Usual suspects though: are all of those token accounts already-existing, fully-created token accounts? It's not enough just to get the ATA address right
Helps if you can post the full program log (lol, think I've typed that like 10 times today haha)
Hello, I am trying to transfer an spl-token on the client side and was looking through the anchor repo and found "Token.createTransferInstruction". My code is the following:
```let transferInstr = Token.createTransferInstruction(
          TOKEN_PROGRAM_ID,
          ownerATA,
          customerATA,
          provider.wallet.publicKey,
          [],
          50
        );
        await provider.send(
          (() => {
            const tx = new anchor.web3.Transaction();
            tx.add(
              transferInstr
            );
            return tx;
          })()
        );```
However, I keep on running into Custom Program error: 0x4. Would anyone be able to help me with what I am doing wrong here?
Yeah, I'm not sure how to dig into what the issue was (definitely weird though)
<@!134416332509675520> building solana from source (master) and now running 1.10.0 fixes my issue (1.9.6 release did not). Strange though no?
That gives you all of the AccountInfo stuff, including the owner
`program.provider.connection.getAccountInfo(theAddress)`
makes sense - is there a method call that takes the public key as input and spits out which is the owning program?
I mention this above, but the only way to write to an account's data is via its owning program. The system program doesn't expose any way to write arbitrary data into an account it owns, so ==> if an account has data in it, can't be owned by the system program.
Because it's a custom struct, Multisig
how could you tell here that the multisig was owned by my own program and not owned by the system program?
<@!134416332509675520> I wanted to submit a small pr to add fetch pda functionality from `program.account` with just seeds. Do you think it would be better to have a separate `fetchPda` method or to add to the existing `fetch` method making it take either an address or seeds argument? For completeness sake, I was thinking of doing the same thing for `fetchMultiple`.
BN is for arbitrarily big integers, not floats
`new anchor.BN(0.1)` is always zero üôÇ
^ but `postTxnAcctBalance` is always 0 which tells me `send_sol` isn't being called properly
1.9.0 on the failing linux machine vs 1.10.0 will upgrade and report back. Thanks!
```
  it("test", async() => {
    const multisig = anchor.web3.Keypair.generate();
    const [multisigSigner, nonce] =
      await anchor.web3.PublicKey.findProgramAddress(
        [multisig.publicKey.toBuffer()],
        program.programId
      );
    const multisigSize = 1000; // Big enough.

    const ownerA = anchor.web3.Keypair.generate();
    const ownerB = anchor.web3.Keypair.generate();
    const owners = [ownerA.publicKey, ownerB.publicKey];

    const threshold = new anchor.BN(2);

    await program.rpc.createMultisig(owners, threshold, nonce, {
      accounts: {
        multisig: multisig.publicKey,
      },
      instructions: [
        await program.account.multisig.createInstruction(
          multisig,
          multisigSize
        ),
      ],
      signers: [multisig],
    });

    let preTxnAccountInfo = await program.provider.connection.getAccountInfo(ownerA.publicKey)
    let preAccountInfo = await program.provider.connection.getAccountInfo(multisig.publicKey)
    let preTxnAcctBalance = await program.provider.connection.getBalance(ownerA.publicKey);
    let preMultisigBalance = await program.provider.connection.getBalance(multisig.publicKey);

    await program.provider.connection
      .requestAirdrop(multisig.publicKey, LAMPORTS_PER_SOL)
      .then((sig) => program.provider.connection.confirmTransaction(sig, "confirmed"));

    await program.rpc.sendSol(new anchor.BN(0.1),
      { 
        accounts: {
          multisig: multisig.publicKey,
          receiver: ownerA.publicKey,
          systemProgram: anchor.web3.SystemProgram.programId
        },
        signers: [multisig],
      }
    );

    let multisigAccount = await program.account.multisig.fetch(
      multisig.publicKey
    );

    let postTxnAcctBalance = await program.provider.connection.getBalance(ownerA.publicKey);
    let postMultisigBalance = await program.provider.connection.getBalance(multisig.publicKey);

    assert(accountInfo);
```
test set up like so:
What am I doing incorrectly here with `try_borrow_mut_lamports`?

```
pub fn send_sol(ctx: Context<SendSol>, amount: u64) -> Result<()> {

        **ctx.accounts.multisig.to_account_info().try_borrow_mut_lamports()? -= amount;
        **ctx.accounts.receiver.to_account_info().try_borrow_mut_lamports()? += amount;

        Ok(())
    } 
```
Every now and then some weird stuff can happen based on the solana version
Ah, interesting. Same version of solana?
<@!134416332509675520> 
Seems like it's related to the machine i'm running it on. It's failing on my linux machine.
Just pushed and tested on my M1 and there it works..?
Yes, but a private one that I can't share here (just yet).
ah this is helpful
Also, that log doesn't look like it's getting to the send_sol part, it's still in CreateMultisig
It's a little bit of an odd process, 0x1778 = 6008, which is I believe one of your own custom errors (do you have an error enum?)
i don't. Feel free to point me to whatever documentation or a blogpost though
Do you know how to find those custom errors?
```Transaction simulation failed: Error processing Instruction 1: custom program error: 0x1778 
    Program 11111111111111111111111111111111 invoke [1]
    Program 11111111111111111111111111111111 success
    Program 5q6Nk8kyxa2Kkc7RSi5eouNDneRQYoyiK6ud28R2m5Uq invoke [1]
    Program log: Instruction: CreateMultisig
    Program log: Custom program error: 0x1778
    Program 5q6Nk8kyxa2Kkc7RSi5eouNDneRQYoyiK6ud28R2m5Uq consumed 3630 of 200000 compute units
    Program 5q6Nk8kyxa2Kkc7RSi5eouNDneRQYoyiK6ud28R2m5Uq failed: custom program error: 0x1778```
test case, is the same, but I'm getting:
hm, now I have my rpc method set up like so:

```
pub fn send_sol(ctx: Context<SendSol>, amount: u64) -> Result<()> {

        **ctx.accounts.multisig.to_account_info().try_borrow_mut_lamports()? -= amount;
        **ctx.accounts.receiver.to_account_info().try_borrow_mut_lamports()? += amount;

        // let ix = anchor_lang::solana_program::system_instruction::transfer(
        //     &ctx.accounts.multisig.key(),
        //     &ctx.accounts.receiver.key(),
        //     amount,
        // );

        // anchor_lang::solana_program::program::invoke(
        //     &ix,
        //     &[
        //         ctx.accounts.multisig.to_account_info(),
        //         ctx.accounts.receiver.to_account_info(),
        //         ctx.accounts.system_program.to_account_info(),
        //     ],
        // )?;

        Ok(())
    } 
```
Is your code in a github repo anywhere?
Hmm, interesting, I'm not sure what's going on there
Program log: FINAL 
Is the last log I do before returning Ok(()).
<@!134416332509675520> 

https://pastebin.com/KfsJGuFt

(Discord won't let me post it)
Can you post the full program log?
Hi

I'm receiving a custom error: 0x0 at the end of my transaction but only when I initialize a token_account using:
```
    #[account(
        init,
        payer = signer,
        seeds = [SEED.as_bytes()],
        bump,
        token::mint = mint,
        token::authority = signer
    )]
    pub token_account: Account<'info, TokenAccount>
```

During the transaction I even do a CPI call using that token account successfully, so it seemingly is not failing during initialization but rather during something anchor does after executing my instruction handler code?

Any ideas on how to fix this?
thanks <@!134416332509675520> <@!915682383905316864>
You'll have to do the transfer manually, using `try_borrow_mut_lamports()` etc.
That only works when the source is a system program account (in general, in solana every account is owned by some program, and *only* that program is allowed to mutate the account's data or spend the account's money)
You won't be able to use the system program's transfer function
Actually, is the Multisig owned by your own program?
damn, thanks for pointing this out
When you do a transfer, the source and the destination both need to be mut
Yep `    8xjfVQ6hMn2jkNETAvWAkb6W5XbMCWvXCtWeU3vFRzEi's writable privilege escalated
`
```
Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account 
    Program 5q6Nk8kyxa2Kkc7RSi5eouNDneRQYoyiK6ud28R2m5Uq invoke [1]
    Program log: Instruction: SendSol
    8xjfVQ6hMn2jkNETAvWAkb6W5XbMCWvXCtWeU3vFRzEi's writable privilege escalated
    Program 5q6Nk8kyxa2Kkc7RSi5eouNDneRQYoyiK6ud28R2m5Uq consumed 3958 of 200000 compute units
    Program 5q6Nk8kyxa2Kkc7RSi5eouNDneRQYoyiK6ud28R2m5Uq failed: Cross-program invocation with unauthorized signer or writable account
    1) test
    ‚úî Tests the multisig program (2255ms)
Transaction simulation failed: Error processing Instruction 1: custom program error: 0x1778 
    Program 11111111111111111111111111111111 invoke [1]
    Program 11111111111111111111111111111111 success
    Program 5q6Nk8kyxa2Kkc7RSi5eouNDneRQYoyiK6ud28R2m5Uq invoke [1]
    Program log: Instruction: CreateMultisig
    Program log: Custom program error: 0x1778
    Program 5q6Nk8kyxa2Kkc7RSi5eouNDneRQYoyiK6ud28R2m5Uq consumed 3630 of 200000 compute units
    Program 5q6Nk8kyxa2Kkc7RSi5eouNDneRQYoyiK6ud28R2m5Uq failed: custom program error: 0x1778
    ‚úî Assert Unique Owners
  2 passing (22s)
  1 failing
```
Yeah probably need to mark the multisig as mut
Can you post the program log? (Not the js stack trace) It will include a line that gives you more info
test looks like:

```
const anchor = require("@project-serum/anchor");
const assert = require("assert");
const solana = require("@solana/web3.js");

const { LAMPORTS_PER_SOL } = solana;

describe("multisig", () => {
  // Configure the client to use the local cluster.
  anchor.setProvider(anchor.Provider.env());

  const program = anchor.workspace.SerumMultisig;

  it("test", async() => {
    const multisig = anchor.web3.Keypair.generate();
    const [multisigSigner, nonce] =
      await anchor.web3.PublicKey.findProgramAddress(
        [multisig.publicKey.toBuffer()],
        program.programId
      );
    const multisigSize = 1000; // Big enough.

    const ownerA = anchor.web3.Keypair.generate();
    const ownerB = anchor.web3.Keypair.generate();
    const owners = [ownerA.publicKey, ownerB.publicKey];

    const threshold = new anchor.BN(2);

    await program.rpc.createMultisig(owners, threshold, nonce, {
      accounts: {
        multisig: multisig.publicKey,
      },
      instructions: [
        await program.account.multisig.createInstruction(
          multisig,
          multisigSize
        ),
      ],
      signers: [multisig],
    });

    await program.provider.connection
      .requestAirdrop(multisig.publicKey, LAMPORTS_PER_SOL)
      .then((sig) => program.provider.connection.confirmTransaction(sig, "confirmed"));

    await program.rpc.sendSol(new anchor.BN(0.1),
      { 
        accounts: {
          multisig: multisig.publicKey,
          receiver: ownerA.publicKey,
          systemProgram: anchor.web3.SystemProgram.programId
        },
        signers: [multisig],
      }
    );


    let multisigAccount = await program.account.multisig.fetch(
      multisig.publicKey
    );

    let accountInfo = await program.provider.connection.getAccountInfo(multisig.publicKey)
    let txnAccountInfo = await program.provider.connection.getAccountInfo(ownerA.publicKey)

    assert(accountInfo);
  });
  ```
My `lib.rs` looks like:

```#[program]

pub mod multisig {
    pub fn create_multisig(
        ctx: Context<CreateMultisig>,
        owners: Vec<Pubkey>,
        threshold: u64,
        nonce: u8,
    ) -> Result<()> {
        assert_unique_owners(&owners)?;
        require!(
            threshold > 0 && threshold <= owners.len() as u64,
            InvalidThreshold
        );
        require!(!owners.is_empty(), InvalidOwnersLen);

        let multisig = &mut ctx.accounts.multisig;
        multisig.owners = owners;
        multisig.threshold = threshold;
        multisig.nonce = nonce;
        multisig.owner_set_seqno = 0;
        Ok(())
    }

     pub fn send_sol(ctx: Context<SendSol>, amount: u64) -> Result<()> {
        let ix = anchor_lang::solana_program::system_instruction::transfer(
            &ctx.accounts.multisig.key(),
            &ctx.accounts.receiver.key(),
            amount,
        );

        anchor_lang::solana_program::program::invoke(
            &ix,
            &[
                ctx.accounts.multisig.to_account_info(),
                ctx.accounts.receiver.to_account_info(),
                ctx.accounts.system_program.to_account_info(),
            ],
        )?;

        Ok(())
    } 
}

#[derive(Accounts)]
pub struct SendSol<'info> {
    #[account(signer)]
    pub multisig: Box<Account<'info, Multisig>>,
    #[account(mut)]
    pub receiver: AccountInfo<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct CreateMultisig<'info> {
    #[account(zero, signer)]
    multisig: Box<Account<'info, Multisig>>,
}

#[account]
pub struct Multisig {
    pub owners: Vec<Pubkey>,
    pub threshold: u64,
    pub nonce: u8,
    pub owner_set_seqno: u32,
}```
üëã running into this error: ```     Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account
      at Connection.sendEncodedTransaction (node_modules/@solana/web3.js/lib/index.cjs.js:6820:13)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at async Connection.sendRawTransaction (node_modules/@solana/web3.js/lib/index.cjs.js:6775:20)
      at async sendAndConfirmRawTransaction (node_modules/@solana/web3.js/lib/index.cjs.js:9098:21)
      at async Provider.send (node_modules/@project-serum/anchor/dist/cjs/provider.js:90:22)
      at async Object.rpc [as sendSol] (node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:31:31)
      at async Context.<anonymous> (tests/multisig.js:65:5)
```
got it üÜó
Or at least, the JS client *does* recognize that
It should recognize that that address needs to sign
Yep
Yeah, I guess the python client isn't interpreting the IDL quite right
Might be some error reporting improvement possible on the Python client specifically?
Since that's a common mistake
I wonder why I hadn't run into that same error in JS before
Ha, interesting ü§î
well, this worked üôÉ
oh, i see.
(Whereas if it were a PDA, then the program itself would have to sign for it)
In this case the new address is a keypair address, so it needs to sign from the client
Yeah, because any time you create an account, its address needs to sign
the mint account needs to sign for its own creation? hm?
Yeah
he means the mint account
really? even if it's payer? shouldn't payer already (implicitly) be in that array?
One thing that looks wrong (but not sure it would lead to that specific error) is that you probably need to add that keypair to the signers array
using this client quite successfully in other project, FYI.
I've never heard of that error. Sounds client-side?
yes. cc <@!856894333180706876> .
Is this the Python client?
<@!134416332509675520> anything look horribly wrong here? still can't get past the "failed to sanitize accounts" error.

indeed, i want to make a mint, whose authority is the person that creates this mint.
yup
sure but your account is screwed because you can't resize it
Same with option.
For sure!. Though if you have a vec and use default, it will error as soon as you try to insert.
definitely! It's dangerous if you have vectors and stuff
maybe we should just remove the attempt to automatically calculate the space
so do i
Yeah, I honestly pretty much always just manually calculate the space, for these kinds of reasons
A while back I got some weird results using `std::mem::size_of` (I believe due to alignment padding?) so I decided never to use it. I've seen a mango contract use it though so might be ok? https://github.com/blockworks-foundation/voter-stake-registry/blob/master/programs/voter-stake-registry/src/state/deposit_entry.rs#L43
I'm writing an anchor contract where I transfer SOL around. If I create a transaction account like so: 

```await program.account.transaction.createInstruction(
          transaction,
          txSize
        ),```

This prevents me from specifying enough SOL into the account. Is there a method I can use to airdrop SOL to a particular keypair's account?
gotcha thanks
std::mem::size_of might do the right thing. About Default, the way that works with regards to space is anchor just constructs a default instance of your type and then borsh serializes it and see how many bytes it takes
wrt sizing `space` using `Default` -- let's say I have a type that is statically sized but I don't want to necessarily implement `Default` for -- is there a way to separate these two notions (something with `Space` and something with `Default`? other than manually sizing space (though maybe there's an idiomatic way to do that -- don't think `std::mem::size_of` does the right thing?)
Makes sense
Basically the way to learn this stuff is just by source-diving.
Have you read through the anchor source? https://github.com/project-serum/anchor/blob/master/ts/src/program/namespace/account.ts#L132
thanks, yeah, figured b/c of orphan rule
You would need to wrap it in a new struct, as far as I can see.
How could I go about debugging this error?

```throw new Error(
              ^
Error: Transaction instruction index 2 has undefined program id```


//////////////////////////////////////////////////////////////////////////////////////////

Thank you for this!
https://discord.com/channels/889577356681945098/889702325231427584/939323253934153741
`The owner of the smart wallet doesn't match with current.` There's your hint lol
Thanks! M pretty much newer than you so...
Sure, that depends on when i'm available,
i'm new to solana/rust too, so i'll try my best !
```Transaction simulation failed: Error processing Instruction 0: custom program error:
0x1771
    Program Govz1VyoyLD5BL6CSCxUJLVLsQHRwjfFj1prNsdNg5Jw invoke [1]
    Program log: Instruction: CreateGovernor
    Program 11111111111111111111111111111111 invoke [2]
    Program 11111111111111111111111111111111 success
    Program log: GovernorNotFound: The owner of the smart wallet doesn't match with c
urrent.
    Program log: self.smart_wallet.owners.contains(&self.governor.key())
    Program log: Error thrown at programs/govern/src/account_validators.rs:8
    Program log: Custom program error: 0x1771
    Program Govz1VyoyLD5BL6CSCxUJLVLsQHRwjfFj1prNsdNg5Jw consumed 16250 of 200000 com
pute units
    Program Govz1VyoyLD5BL6CSCxUJLVLsQHRwjfFj1prNsdNg5Jw failed: custom program error
: 0x1771
    1) "before all" hook for "test"


  0 passing (2s)
  1 failing

  1) liquidityMiner
       "before all" hook for "test":
     Error: failed to send transaction: Transaction simulation failed: Error processi
ng Instruction 0: custom program error: 0x1771
      at Connection.sendEncodedTransaction (node_modules/@solana/web3.js/src/connecti
on.ts:3961:13)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at Connection.sendRawTransaction (node_modules/@solana/web3.js/src/connection.t
s:3918:20)```
https://github.com/project-serum/anchor/issues/793#issuecomment-926915660
I think that's right since you could have multiple instances of an account type with different seeds. A small convenience, but I have a pr in be able to fetch with just seeds. https://github.com/project-serum/anchor/pull/1445
has anybody come across this one before? `error: the `#[global_allocator]` in this crate conflicts with global allocator in: mpl_token_metadata`
hey if i have problems down the line regarding PDAs can I shoot you a dm?
The new methods API saves you from having to calculate a PDA client side when you create it, but wouldn't you still need to still calculate PDAs if you have to pass it in to another function at a later point?
What's the full log?
see `anchor.web3.PublicKey.findProgramAddress`
When re-deriving you can calculate it off-chain using the JS bindings and pass it as an instruction parameter
oh okay thanks!
It's calculated for you in this function `find_program_address`
https://docs.rs/anchor-lang/0.21.0/anchor_lang/prelude/struct.Pubkey.html#method.find_program_address
I don't think I fully understand this.. can you tell me how i can calculate the bump?
It's basically an u8 number [0-254] that solana calculates for u
used to derive the PDA such that it doesn't reside on the epileptic curve.

black magic but that's how PDAs work
Thanks, I will check this out
Okay this is starting to make sense..
What is bump exactly?
You can read about account constraints here
https://docs.rs/anchor-lang/0.21.0/anchor_lang/derive.Accounts.html
very helpful
Here you're not using program derived accounts (PDA), you're using plain accounts
PDAs are created when you pass seeds in #[account] macro,

the combination of seeds you pass to the macro make each derived account unique to what you give it,
so, if each 'vibe' has a user, you can pass the user's pubkey as a seed in addition to extra piece of identifing data such as b"vibe_post"

in create post u can have:
```
#[account(
  init, payer = author,
  seeds = [
    b"vibe_post",
    author.key().as_ref()
  ], // Seeds are sent as buffers [u8]
  bump // This calculates the bump
)]
pub vibe: Account<'info, Vibe>
```

and you can re-derive it in updatelikes by passing the seeds & bump without the init and payer, also good practice to calculate the bump off-chain to reduce computation cost

as such you can handle the likes/comments  you can have PDA derived using the post's key and user's key.
what is this error: ```custom program error: 0x1771``` and ```custom program error: 0xbc4```
üëã when using wallet from getProvider, is this redundant when calling client methods? `signers: [wallet.payer]` ? seems to auto inject `wallet.payer`
```rust


#[error]
pub enum ErrorCode {
    #[msg("The provided topic should be 50 characters long maximum.")]
    TopicTooLong,
    #[msg("The provided content should be 300 characters long maximum.")]
    ContentTooLong,
}

//Size of a Vibe
const DISCRIMINATOR_LENGTH: usize = 8;
const PUBLIC_KEY_LENGTH: usize = 32;
const TIMESTAMP_LENGTH: usize = 8;
const STRING_LENGTH_PREFIX: usize = 4;
const MAX_TOPIC_LENGTH: usize = 50 * 4;
const MAX_CONTENT_LENGTH: usize = 300 * 4;
const MAX_LIKES_LENGTH: usize = 4;

impl Vibe {
    const LEN: usize = DISCRIMINATOR_LENGTH
        + PUBLIC_KEY_LENGTH // Author.
        + TIMESTAMP_LENGTH // Timestamp.
        + STRING_LENGTH_PREFIX + MAX_TOPIC_LENGTH // Topic.
        + STRING_LENGTH_PREFIX + MAX_CONTENT_LENGTH // Content.
        + MAX_LIKES_LENGTH; // Likes.
}
```
```rust
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod solvibe_social {
    use super::*;

    pub fn create_vibe(ctx: Context<CreateVibe>, topic: String, content: String) -> ProgramResult {

        let vibe = &mut ctx.accounts.vibe;
        let author = &mut ctx.accounts.author;
        let clock = Clock::get().unwrap();

        if topic.chars().count() > 50 {
            return Err(ErrorCode::TopicTooLong.into())
        }

        if content.chars().count() > 300 {
            return Err(ErrorCode::ContentTooLong.into())
        }

        vibe.author = *author.key;
        vibe.timestamp = clock.unix_timestamp;
        vibe.topic = topic;
        vibe.content = content;
        vibe.likes = 0;

        Ok(())
    }

    pub fn update_likes(ctx: Context<UpdateLikes>) -> ProgramResult {
        let vibe = &mut ctx.accounts.vibe;
        
        vibe.likes += 1;
        
        Ok(())
    }

    pub fn delete_vibe(_ctx: Context<DeleteVibe>) -> ProgramResult {
        Ok(())
    }

}

#[derive(Accounts)]
pub struct CreateVibe<'info> {
    #[account(init, payer = author, space = Vibe::LEN)]
    pub vibe: Account<'info, Vibe>,
    #[account(mut)]
    pub author: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct UpdateLikes<'info> {
    #[account(mut)]
    pub vibe: Account<'info, Vibe>,
    #[account(mut)]
    pub liker: AccountInfo<'info>,
}

#[derive(Accounts)]
pub struct DeleteVibe<'info> {
    #[account(mut, has_one = author, close = author)]
    pub vibe: Account<'info, Vibe>,
    pub author: Signer<'info>,
}

#[account]
pub struct Vibe {
    pub author: Pubkey,
    pub timestamp: i64,
    pub topic: String,
    pub content: String,
    pub likes: u32,
}

```
Hey <@!134416332509675520>! Sorry for tagging but I am having a lot of difficulty wrapping my head around PDAs, mainly how to structure my program.

So I am building a social media app where every post made by a wallet publickey is an account, and users can like a post, but I have no way of restricting an user from liking a post twice. So how do I implement that using a PDA?

the code (P.S. vibe here means post)
has anybody done an anchor wrapper for mpl-token-metadata?
I'm doing it this way
```rust
        let accountParsed = Self::deserialize(&mut &**user_account_info.try_borrow_data()?.deref()).unwrap();```
I am able to do this in rust but maybe there's better way to do it using anchor ?
up please :))
Anyone had this issue before? ```utx0@i5750 hydra-protocol]$ anchor build
BPF SDK: /home/utx0/.local/share/solana/install/releases/1.9.6/solana-release/bin/sdk/bpf
cargo-build-bpf child: rustup toolchain list -v
cargo-build-bpf child: cargo +bpf build --target bpfel-unknown-unknown --release
Unable to get file metadata for /home/utx0/Code/hydra/hydra-protocol/target/bpfel-unknown-unknown/release/hydra_staking.so: No such file or directory (os error 2)
```
i think the problem is with phantom some times i get this err but when i approve the transaction it seems to be executed successfully
remaining_accounts are accountInfos, by I want to deserialize them to certain struct
Hello, how to deserialize accountInfo data to struct ?
for the transactions I've written, I'm getting a bunch of `transaction may fail to confirm` in phantom. in the end, the transactions go through normally though. 
What could be the reasons it says that it may fail? 
Is it possible that the transaction is too long to be simulated (I'm doing multiple CPI calls), or is there any other reasons?
is there a way to load account struct for a remaining_account ?
and is the index flag actually used by anything other than to mark index=true in IDL?
are there any guidelines for which fields in an event should be marked index?
<@!134416332509675520> https://solanacookbook.com/guides/feature-parity-testing.html#scenario
Looks like the compute limits have changed since Solana 1.9.2
ok i lied it wasn't my last question üòâ i thought it was tho
why doesn't the number of compute units reset when I call `RebalanceSolend` then?
My personal instructions are `GetBalanceSolend` and `RebalanceSolend`

Above looks like the call to Refresh Reserve used up a lot of compute, `consumed 139784 of 200000 compute units`
So at that point in the log you're basically screwed üò¥
That means that at that point in the code, you had 8548 units of compute remaining, and this chunk of it used up 2661 of those units
gotcha, will do. And last question -- im not sure how to read this: `consumed 2661 of 8548 compute units`
Ah, sorry, not sure! Might have to ask in the solana discord
this is super helpful, thanks alan. Next questions for me are:
1 - wen compute budget increase? Transactions look up table proposal has been out for a while, but i've heard no progress on it.
2 - wen txn byte limit increase?
https://jstarry.notion.site/Transaction-Fees-f09387e6a8d84287aa16a34ecb58e239#6c4bae9a910641028cc4f3a747be7a6d
Yep (weirdly, and not for long)
for a total of 600K
oh wait i misunderstood this.
"Each separate instruction (sent from the client) gets a "compute budget" of 200k "units"."

So this means that if I submit a txn with instr1, instr2, and instr3, then each of those instructions gets a compute budget of 200k?
new API? What do u mean by that
There's also a new API (can't remember if it's out yet) where you can request more units
It's possible that you can try some tricks, like splitting your code up into multiple separate instructions from the client (each gets its own 200k budget)
This is extremely limiting. This means that the entire smart contract I am developing simply will not work in Solana
Each operation you do uses them up: https://github.com/solana-labs/solana/blob/master/program-runtime/src/compute_budget.rs#L22
Lol
Each separate instruction (sent from the client) gets a "compute budget" of 200k "units".
XD nice name
`consumed 20930 of 85587 compute units` 
What exactly does this mean?
i was planning on adding 3 more instructions :/
Ah, yeah, that's just saying that you ran out of compute units
Hmm, it does kind of look like you might just be running out of compute units
I called solend's instruction, which then called `Transfer` and `MintTo`, and did some other things
gotcha, will do from now on
```
Transaction simulation failed: Error processing Instruction 1: Program failed to complete 
    Program 7V9nbaCYjAw7LRUXnD6gwo6fGLrea86QAx1cstUxwEmJ invoke [1]
    Program log: Instruction: GetBalanceSolend
    Program ALend7Ketfx5bxh6ghsCDXAoDrhvEmsXT3cynB6aPLgx invoke [2]
    Program log: Instruction: Refresh Reserve
    Program ALend7Ketfx5bxh6ghsCDXAoDrhvEmsXT3cynB6aPLgx consumed 20930 of 85587 compute units
    Program ALend7Ketfx5bxh6ghsCDXAoDrhvEmsXT3cynB6aPLgx success
    Program 7V9nbaCYjAw7LRUXnD6gwo6fGLrea86QAx1cstUxwEmJ consumed 139784 of 200000 compute units
    Program 7V9nbaCYjAw7LRUXnD6gwo6fGLrea86QAx1cstUxwEmJ success
    Program 7V9nbaCYjAw7LRUXnD6gwo6fGLrea86QAx1cstUxwEmJ invoke [1]
    Program log: Instruction: RebalanceSolend
    Program ALend7Ketfx5bxh6ghsCDXAoDrhvEmsXT3cynB6aPLgx invoke [2]
    Program log: Instruction: Deposit Reserve Liquidity
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [3]
    Program log: Instruction: Transfer
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 2661 of 8548 compute units
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [3]
    Program log: Instruction: MintTo
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 2517 of 3001 compute units
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success
    Program ALend7Ketfx5bxh6ghsCDXAoDrhvEmsXT3cynB6aPLgx consumed 27146 of 27146 compute units
    Program failed to complete: exceeded maximum number of instructions allowed (27146) at instruction #39135
    Program ALend7Ketfx5bxh6ghsCDXAoDrhvEmsXT3cynB6aPLgx failed: Program failed to complete
    Program 7V9nbaCYjAw7LRUXnD6gwo6fGLrea86QAx1cstUxwEmJ consumed 200000 of 200000 compute units
    Program 7V9nbaCYjAw7LRUXnD6gwo6fGLrea86QAx1cstUxwEmJ failed: Program failed to complete
```
As a general rule, it's way easier to debug if you post the full log, not just a snippet
```Program failed to complete: exceeded maximum number of instructions allowed (27146) at instruction #39135```
I only did like 4 instructions in this transaction though
got it üòâ
ohhhh
basically i'm doing a CPI call to transfer my program's token account tokens into Solend's token acc
the test is failing
Annoyingly if the test passes then you'll have to go look for the log in the `.anchor/program-logs/` directory, but yeah
Can I log stuff into my console from my smart contract? E.g. do like a `msg!()` and then it shows up when I run my tests?
ahh gotcha. Thanks alan üôÇ
So that means you somehow didn't sign for some account that needs to sign
Yep
`signer privilege escalated`?
```
Transaction simulation failed: Error processing Instruction 1: Cross-program invocation with unauthorized signer or writable account 
    Program 7V9nbaCYjAw7LRUXnD6gwo6fGLrea86QAx1cstUxwEmJ invoke [1]
    Program log: Instruction: GetBalanceSolend
    Program ALend7Ketfx5bxh6ghsCDXAoDrhvEmsXT3cynB6aPLgx invoke [2]
    Program log: Instruction: Refresh Reserve
    Program ALend7Ketfx5bxh6ghsCDXAoDrhvEmsXT3cynB6aPLgx consumed 18824 of 85587 compute units
    Program ALend7Ketfx5bxh6ghsCDXAoDrhvEmsXT3cynB6aPLgx success
    Program 7V9nbaCYjAw7LRUXnD6gwo6fGLrea86QAx1cstUxwEmJ consumed 137678 of 200000 compute units
    Program 7V9nbaCYjAw7LRUXnD6gwo6fGLrea86QAx1cstUxwEmJ success
    Program 7V9nbaCYjAw7LRUXnD6gwo6fGLrea86QAx1cstUxwEmJ invoke [1]
    Program log: Instruction: RebalanceSolend
    5swfzZhm1CEAoXNbYWrnLGw9LQg8ZPMwJu51fXTCUFqB's signer privilege escalated
    Program 7V9nbaCYjAw7LRUXnD6gwo6fGLrea86QAx1cstUxwEmJ consumed 172899 of 200000 compute units
    Program 7V9nbaCYjAw7LRUXnD6gwo6fGLrea86QAx1cstUxwEmJ failed: Cross-program invocation with unauthorized signer or writable account
```
The full program log will have a line that says whether you messed up signing or if you forgot to mark something as mut
`Cross-program invocation with unauthorized signer or writable account`

How am I supposed to debug this?
Oh, not even by manually editing the code?
<@!134416332509675520>  The test is happy now. Really appreciate your (continuous) help!
so you would use zero to indicate that you haven't used init elsewhere in the program - like you had created a large account in another instruction outside of the program. the composite example follows this pattern https://github.com/project-serum/anchor/blob/master/tests/composite/programs/composite/src/lib.rs
One situation where this is actually necessary is if you want to create a really big account. The max you can do via a CPI to the system program (e.g. with `init`) is 10kb. But if you issue a separate instruction to the system program, rather than using a CPI, you can go up to 10mb.
When you allocated the account in a separate instruction
what is the case where the discriminator bytes are not yet set?
Assuming the multisig account is a keypair address, you'll need to add it to the `signers: [...]` array
I remember I got a 'unknown' signer` error, but will check again. thanks!
Then you can pass it along to the CPI call you make to the multisig program
So like
```.rs
#[account(mut)]
pub multisig: Signer<'info>
```
Ok, then your own program probably doesn't even need to use the Multisig type at all for this, you can pass the multisig account in as just a `Signer<'info>` (it has to sign so that the multisig program can init an account there)
yes!
Ah, so your program is going to ask the serum multisig to init the Multisig account?
what does the zero account attribute do?
sorry let me try to elaborate.. My intent is to use the `project-serum/multisig` program via CPI. (not being super confident about implementing my own multisig.) so the initiation of the multisig (along with other instructions) should be done on the `serum-multisig` side while my program will do other things...
Mm, not totally sure I understand what you want to do ü§î
Just to double check, why do you want to init the Multisig account on the client? Can you not do it with a regular `init` attribute?
so I can try init the `Multisig` Account on the caller side (as I wish) and then pass it to the callee(puppet, multisig program) and it will take it from there?
I wouldn't have guessed that it would matter much if you stick it in the heap or not.
The use of the heap here is just about where the deseriaized Multisig struct will live.
What do you mean in the heap?
the init process happends in the cpi callee side (in heap), so I thought I need to be consistent.
Have you already initialized that Multisig account?
zero has nothing necessarily to do with the heap
And `zero` means: "anchor, please don't freak out that this account doesn't have its discriminator bytes set yet"
Are you sure you need the Box at all?
hi, it's the multisig program again... I have an account marked 
```rust
#[account(zero, signer)]
multisig: Box<Account<'info, Multisig>>,
```
This part triggers this error:
```bash
Program log: panicked at 'range end index 8 out of range for slice of length 0', programs/shard/src/lib.rs:108:10
```
My understanding is this `Multisig` Account is intended to store in heap, hence the Box and zero discriminator. It was fine with only this account and the program, but if I try to add other accounts, I get this. Is this relative to the other accounts I'm passing within the same Context...?
Can you post more info, a program log, etc.?
What makes you think it needs to be mut?
Not actually sure if there's a way to turn that off
anchor client program
What do you mean by wallet program? It's an actual program, not just some regular account?
bump, sorry for the @ but i've been stuck on this or awhile
No everything is working perfectly it‚Äôs just that it‚Äôs printing the whole program output when it shouldn‚Äôt
^ bonus points if there's a way to link the repos within VSCode :p
how can I quickly find which repo/folder/file defines `spl_token::state::Account`?
If I have the following code snippet:

```
#[derive(Clone)]
pub struct TokenAccount(spl_token::state::Account);

impl TokenAccount {
    pub const LEN: usize = spl_token::state::Account::LEN;
}
```
Hey, quick question about source diving / how serum/SPL code bases are configured
Does `Unknown program metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s` mean i'm passing incorrect instruction data ?
`Program 2R7cpyuKTpjepFoW5YdyAZ6XFERY32CKm9hG2EA5TT1F failed: An account required by the instruction is missing`
bumping this
Not sure if this is what your talking about but, I got an error where whenever I deploy to devnet it would just print `msg <ADDRESS>`  alot. But then I updated to anchor and solana versions and that helped: https://stackoverflow.com/questions/70437644/error-custom-invalid-blockhash-when-solana-program-deploy
The whole program output
<@!134416332509675520> I have 3 programs wallet program, A and B.  Wallet sends a transaction to A to make a CPI call to B. B initializes an account with `account(init)` to make an account , the payer is wallet program. Does the wallet program have to be marked as  `account(mut)` in the program B?
I'm actually not quite sure what you mean, what is it logging?
<@!134416332509675520> hey man sorry to @ but you‚Äôd be coming clutch if you could help out on this small thing
it's not beta that's causing it I'm pretty sure
why are you using beta man? Use stable one
If anyone knows please let me know
mind if I dm you?
sure
Actually if you want to do a discord call, think this will be easier to explain over voice
So the multisig program says "... ok, everything looks good, I'll sign for this special address and pass it along to whatever CPI you want to do"
The point of the original multisig code is to programmatically sign for an address, the multisigSigner, only if the multisig conditions are met, and then invoke some transaction via CPI
Hey, I'm using `@project-serum/anchor@^0.17.1-beta.1` and when I try to submit a transaction it prints out all the program logs even tho I'm not doing any console.log, do you know which bit do I need to change?
What's the purpose in the original code?
`Signer<'info>` verifies that the account did indeed sign
Yes
Oh so you are suggesting this that `multisig_signer: Signer<'info>` is literally just used to check that the multisig_signer has `isSigner` set to `true`?
It serves a clear purpose in the original multisig code, not totally sure if it does in yours though
About why you need the multisig_signer, I don't know haha, if you aren't using it then I guess you don't need it
`Signer<'info>`
Wait none of it is being marked as a signer right?

```
#[derive(Accounts)]
pub struct Auth<'info> {
    #[account(mut)]
    multisig: Box<Account<'info, Multisig>>,
    #[account(
        seeds = [multisig.key().as_ref()],
        bump = multisig.nonce,
    )]
    multisig_signer: Signer<'info>,
}
```
So it almost certainly doesn't make sense to mark it as a Signer (that says, this account needs to have *already* signed in order to invoke me)
Or, well‚Äîat any rate you can't sign for a PDA like that from the client
That won't work using `Signer` like that for the multisig_signer
I'm running into a newbie issue. I'm on M1. Cloned anchor repo and ran `cargo test` and am getting
```
error: failed to run custom build command for `hidapi v1.2.7`
warning: clang-12: error: the clang compiler does not support '-march=core2'
```
It is my understanding I should maybe be using clang 13, which is what `clang --version` spits out, but I have no idea how to tell rust to use clang 13 instead. I tried adding

```
.cargo/config:

rustflags = [
  "-C", "linker=clang",  # change the version as needed
]
```
but that's not working either. I also made sure I'm using the right M1 rustup tool thing:

```
anchor % rustup show

Default host: aarch64-apple-darwin
rustup home:  ~/.rustup

installed toolchains
--------------------

stable-aarch64-apple-darwin (default)
bpf

active toolchain
----------------

stable-aarch64-apple-darwin (default)
rustc 1.58.1 (db9d1b20b 2022-01-20)
```
```
pub fn set_owners(ctx: Context<Auth>, owners: Vec<Pubkey>) -> Result<()> {
        assert_unique_owners(&owners)?;
        require!(!owners.is_empty(), InvalidOwnersLen);

        let multisig = &mut ctx.accounts.multisig;

        if (owners.len() as u64) < multisig.threshold {
            multisig.threshold = owners.len() as u64;
        }

        multisig.owners = owners;
        multisig.owner_set_seqno += 1;

        Ok(())
    }

#[derive(Accounts)]
pub struct Auth<'info> {
    #[account(mut)]
    multisig: Box<Account<'info, Multisig>>,
    #[account(
        seeds = [multisig.key().as_ref()],
        bump = multisig.nonce,
    )]
    multisig_signer: Signer<'info>,
}
```

why do we need `multisig_signer` here with the corresponding macro if it's not used at all in the RPC call?
Have another question about the PDA as an account
no that makes sense, I guess that applies for all accounts if you get the `isSigner` boolean wrong
You're basically going out of your way to require a signature from the *recipient* of the transfer (wrong), and the the client is saying "... uh, you didn't sign lol"
yes, because the client checks that everythign that is supposed to sign actually has signed
does this cause an issue? if `isSigner` is set to `true` even if it doesn't need to be it would cause `Signature verification failed`?
Why would the ownerA need to sign?
Why are you setting `isSigner` to true on something?
```
  1) multisig
       encoding send sol:
     Error: Signature verification failed
      at Transaction.serialize (node_modules/@solana/web3.js/lib/index.cjs.js:2829:13)
      at Provider.send (node_modules/@project-serum/anchor/dist/cjs/provider.js:89:26)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at async Object.rpc [as executeTransaction] (node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:31:31)
      at async Context.<anonymous> (tests/multisig.js:164:5)
```
and still getting:
running:

```
await program.rpc.executeTransaction({
      accounts: {
        multisig: multisig.publicKey,
        multisigSigner,
        transaction: transaction.publicKey,
      },
      remainingAccounts: program.instruction.sendSol
        .accounts({
          multisig: multisig.publicKey,
          receiver: ownerA.publicKey,
        })
        // Change the signer status on the vendor signer since it's signed by the program, not the client.
        .map((meta) =>
          meta.pubkey.equals(ownerA.publicKey)
            ? { ...meta, isSigner: true }
            : meta
        )
    });
```
I've updated structs to be:

```
#[derive(Accounts)]
pub struct SendSol<'info> {
    #[account(mut)]
    pub multisig: Box<Account<'info, Multisig>>,
    #[account(mut)]
    pub receiver: AccountInfo<'info>,
}
```
hm, i don't think is it


//////////////////////////////////////////////////////////////////////////////////////////

> The point of the multisigSigner PDA is that it's the thing that will sign if the multisig conditions are met

Right. Just want to check my logic here, if I have a multisig wallet and I want to create an SPL token account for that wallet, I'd do something like:

```
 mintA = await splToken.Token.createMint(
  program.provider.connection,
  payer,
  mintAuthority.publicKey,
  null,
  0,
  splToken.TOKEN_PROGRAM_ID
);

let multisigTokenAcct = await mintA.createAccount(arbitraryTokenAcct.publicKey);
```

Here the logical owner/authority of the `multisigTokenAcct` is this `arbitraryTokenAcct.publicKey`. Now, as you mentioned above, we use the `multisigSigner` PDA if the multisig conditions are met. 

To initialize this `multisigTokenAcct`, we need to change the authority to ensure that its the `multisigSigner` PDA right?
okay thanks!
yup
how do I do decimal computation with `anchor.BN` in typescript?
Small doubt: When I do something like `seeds = [b"vibe_post", author.key().as_ref()]`, it means that each account created should have a different author, right?
the size of the .so file
what is meant by program size, here?
doh, thank you!
`ctx.accounts.token_account.amount;`
any recommendations on how to determine what is contributing to program size?
Is there a way for an on chain program to know the balance of a token account which is passed into the instruction?
Noob question:

in theory, how to get the **user to sign a transaction** and, at the same time, my app will **sign this transaction using my program authority**?

> considering I can't use the program authority private key in the frontend, and having to sign it through an API, which it seems I can't have the user to sign it at the same time because there is no window and no phantom wallet extension. 

Sry for the confusion appreciate if someone can shine some light.
agreed. https://github.com/project-serum/anchor/pull/1451 <@!208527206966755329>
Interesting. Before upgrading my solana cli version to 1.9.5 , it was really fast, but now it takes 2+ mins
Shouldn't have anything to do with your program itself though
Dunno, that depends on how the cluster is doing/how big your program is
yeah restarting the IDE fixed that error. 
How long should deploying my program take?
maybe something is wrong with my IDE... will restart
So, wait, did the error resolve itself? How did you deploy if there's an error?
Ok so the program deployed but it took a realllllly long time
<@!134416332509675520>  im having two problems:
1) the error in the second pic
2) deploying my program to devnet. It's stuck at this: ```Deploying program "solend-cpi"...
Program path: ~/Desktop/accru/accrue/target/deploy/solendcpi.so...```
that's what im doing with solend
i would recommend just using their devnet program, so that everything is already set up
if i need another program on localnet, should I just start a test validator inside `.anchor` with `--clone` before running `anchor-test`?
+1 +1 +1
actually, this just has to do with using `solana_program = 1.9.5`, not `pubkey!`.  And your solution fixed it, ser alan.
wow..
Does that keep happening if you do `cargo clean` first?
alan, im getting a weird error here when using pubkey!
Heh, I used to work at a programming school (sort of, https://www.recurse.com/) and one class's parting gifts for us teachers were some sweet capes üòõ

It worked!! Not all heroes wear capes Alan.. not all heroes wear capes üò≠
You'll need to manually specify `space =` in your `init` chunk
Yeah, almost definitely (doesn't make sense to derive Default for the Vibe struct, because it has variable-sized types in it‚Äîthose Strings)
So maybe you don't have enough space allocated for that account?
0xbbc = 3004 = https://github.com/project-serum/anchor/blob/master/lang/src/error.rs#L120
```Transaction simulation failed: Error processing Instruction 0: custom program error: 0xbbc
    Program 3NcczXqNpzUsp6c2pGqLNJMnUwScvZBXduj8f3sg6Qdz invoke [1]
    Program log: Instruction: CreateVibe
    Program 11111111111111111111111111111111 invoke [2]
    Program 11111111111111111111111111111111 success
    Program log: Custom program error: 0xbbc
    Program 3NcczXqNpzUsp6c2pGqLNJMnUwScvZBXduj8f3sg6Qdz consumed 18817 of 200000 compute units
    Program 3NcczXqNpzUsp6c2pGqLNJMnUwScvZBXduj8f3sg6Qdz failed: custom program error: 0xbbc```

Getting closer I guess?
```.js
[Buffer.from("vibe_post"), author.toBuffer()]
```
I think
okay so can you help me with the syntax? something like
`[Buffer.from("vibe_post"), author.toBase58()]`
?
You're only using a single seed, `Buffer.from("vibe_post")`
You're not using the author's key in that `findProgramAddress` call (it needs to exactly match how you're doing it in rust)
test
```ts
it("can create a new vibe", async () => {
        const author = program.provider.wallet.publicKey;

        const [vibe, vibeBump] = await anchor.web3.PublicKey.findProgramAddress(
            [Buffer.from("vibe_post")],
            program.programId
        );

        console.log("Vibe:", vibe.toBase58());
        console.log("Bump:", vibeBump);
        console.log("ProgramId:", program.programId.toBase58());

        await program.rpc.createVibe("Vibe!", "Vibe Content!", vibeBump, {
            accounts: {
                vibe: vibe.toBase58(),
                author: author,
                systemProgram: anchor.web3.SystemProgram.programId,
            },
        });

        const createdVibe = await program.account.vibe.fetch(vibe.toBase58());

        assert.equal(createdVibe.topic, "Vibe!");
        assert.equal(createdVibe.content, "Vibe Content!");
        assert.equal(
            createdVibe.author.toBase58(),
            program.provider.wallet.publicKey.toBase58()
        );
        assert.equal(createdVibe.likes, 0);
        assert.ok(createdVibe.timestamp);
    });
```
Ok, how are you calling it from JS again?
account
```rust
#[account]
#[derive(Default)]
pub struct Vibe {
    pub author: Pubkey,
    pub timestamp: i64,
    pub topic: String,
    pub content: String,
    pub likes: u32,
    bump: u8,
}
```
The derive macro?
```rust
#[derive(Accounts)]
#[instruction(topic: String, content: String, vibe_account_bump: u8)]
pub struct CreateVibe<'info> {
    #[account(init, seeds = [b"vibe_post", author.key().as_ref()], bump = vibe_account_bump, payer = author)]
    pub vibe: Account<'info, Vibe>,
    #[account(mut)]
    pub author: Signer<'info>,
    pub system_program: Program<'info, System>,
}

```
Did you fix the `instruction(...)` part? Can you post your latest code?
gotcha, will try it now
Yeah
why isnt it working? has it got something to do with bump?
I don't think it will really matter
Oh i was told by Jacob from Solana that I should use solana_program = 1.8.14 , because that's what anchor is compatible with
Can try adding some random other solana-program version
Why not?
ooof... this might not work for me then... will have to see
Isn't that the same error as before?
```Transaction simulation failed: Error processing Instruction 0: Program failed to complete
    Program 3NcczXqNpzUsp6c2pGqLNJMnUwScvZBXduj8f3sg6Qdz invoke [1]
    Program log: Instruction: CreateVibe
    Program 3NcczXqNpzUsp6c2pGqLNJMnUwScvZBXduj8f3sg6Qdz consumed 10442 of 200000 compute units
    Program failed to complete: Could not create program address with signer seeds: Provided seeds do not result in a valid address
    Program 3NcczXqNpzUsp6c2pGqLNJMnUwScvZBXduj8f3sg6Qdz failed: Program failed to complete```
They are stored right in your program's code (so, strictly speaking they're stored in your program's account!)
Go for it
^ I also can't seem to get access to the `pubkey!` macro unless I had `solana-program = "1.9.5"` to my program's Cargo.toml, not totally sure why I need to do that :/
The idea is that *nothing at all* happens at runtime; it all happens ahead of time, when you compile your program. So there's zero runtime cost to build any pubkeys.
Take a look at the solana `pubkey!` macro
```.rs
use solana_program::pubkey;
const SOME_PUBKEY: Pubkey = pubkey!("asdfasdfadsfasdfasdf");
```
Shouldn't the conversion to pubkey only happen when we reach that line of code?
hey man tell me when you done with this ^
got a new error ü•≤
so where are those static variables stored at compile time?
yeah. Someone recommended that I store these values in a PDA that the user passes in instead, but I just can't afford to do that. Too many accounts being passed in
One thing that definitely jumps out, every one of those hardcoded pubkeys could be static variables computed at compile time. You're doing all that pubkey construction stuff at runtime.
So you're wondering about how to do less compute in there?
Whereas the multisig account itself just lives at some random keypair address, so you can sign for that address just by knowing its private key (so, totally independent of the multisig program's logic)
The point of the multisigSigner PDA is that it's the thing that will sign if the multisig conditions are met
each mint has its own reserve
E.g. if they pass in a fake reserve for Solend, then my program needs to check for that
It would be weird for the multisig (the account that stores the multisig details, the threshold etc.) were the authority over anything
So what i'm trying to do in this function is this:
* A user passed in a solend `mint`, corresponding  `reserve`, and `reserve_ctoken` into my program. I need to do CPI with solend, but I need to make sure they provided the right values first
cpi_program is the program that you're invoking (the program in cross-*program* invocation)
Ok so last time I reached the 200K compute cap. I found out why. It's because this function of mine is taking up 50K compute units
Got it. If we constantly need the multisig to sign transactions, it feels like the right thing to do here is set the authority as the multisig PDA. 

```
pub fn initialize_token_acct(ctx: Context<InitializeTokenAccount>) -> Result<()> {

    msg!("initialize token acct starting");

    let token_accounts = SetAuthority {
        current_authority: ctx.accounts.multisig.to_account_info().clone(),
        account_or_mint: ctx.accounts.multisig_token_program.to_account_info().clone()
    };

    msg!("set token_accounts: ");

    let cpi_program = ctx.accounts.token_program.to_account_info();

    msg!("set cpi_program: ");
    msg!("{:?}", cpi_program);

    token::set_authority(
        CpiContext::new(cpi_program, token_accounts),
        AuthorityType::AccountOwner,
        Some(*ctx.accounts.multisig_signer.key),
    )?;

    msg!("set authority");

    Ok(())
}
```

I have a few questions here:

1/ What is `cpi_program` here supposed to represent?
2/ "it feels like the right thing to do here is set the authority as the multisig PDA" <- is this the right thing to do here? If the logical owner is the multisig and we want the multisig to sign, should we be changing the authority to the multisig PDA/multisig signer? Or am I thinking about this inocrrectly
What's up
Okay will do that
You'll need to do
```.rs
#[instruction(topic: String, content: String, vibe_account_bump: u8)]
```
Or use a more up-to-date anchor which removes the need to pass bumps as arguments as far as I know
Ah, the problem is that you (unfortunately, massive gotcha) need to have your `#[instruction(...)]` args match the order of your instruction function args
i'll wait till ur done w that ^
hey alan
this?
Transaction simulation failed: Error processing Instruction 0: Program failed to complete
    Program 3NcczXqNpzUsp6c2pGqLNJMnUwScvZBXduj8f3sg6Qdz invoke [1]
    Program log: Instruction: CreateVibe
    Program 3NcczXqNpzUsp6c2pGqLNJMnUwScvZBXduj8f3sg6Qdz consumed 9375 of 200000 compute units
    Program failed to complete: Could not create program address with signer seeds: Provided seeds do not result in a valid address
    Program 3NcczXqNpzUsp6c2pGqLNJMnUwScvZBXduj8f3sg6Qdz failed: Program failed to complete
Does it not print when you run your tests?
where can i find it?
test:
```ts

    it("can create a new vibe", async () => {
        const author = program.provider.wallet.publicKey;

        const [vibe, vibeBump] = await anchor.web3.PublicKey.findProgramAddress(
            [Buffer.from("vibe_post")],
            program.programId
        );

        console.log("Vibe:", vibe.toBase58());
        console.log("Bump:", vibeBump);
        console.log("ProgramId:", program.programId.toBase58());

        await program.rpc.createVibe("Vibe!", "Vibe Content!", vibeBump, {
            accounts: {
                vibe: vibe.toBase58(),
                author: author,
                systemProgram: anchor.web3.SystemProgram.programId,
            },
        });

        // const createdVibe = await program.account.vibe.fetch(vibe.publicKey);

        // assert.equal(createdVibe.topic, "Vibe!");
        // assert.equal(createdVibe.content, "Vibe Content!");
        // assert.equal(
        //     createdVibe.author.toBase58(),
        //     program.provider.wallet.publicKey.toBase58()
        // );
        // assert.equal(createdVibe.likes, 0);
        // assert.ok(createdVibe.timestamp);
    });
```
Endpoint:
```rust
pub fn create_vibe(ctx: Context<CreateVibe>, topic: String, content: String, vibe_account_bump: u8) -> ProgramResult {

        let vibe = &mut ctx.accounts.vibe;
        let author = &mut ctx.accounts.author;
        let clock = Clock::get().unwrap();
        
        if topic.chars().count() > 50 {
            return Err(ErrorCode::TopicTooLong.into())
        }

        if content.chars().count() > 300 {
            return Err(ErrorCode::ContentTooLong.into())
        }
        
        vibe.author = *author.key;
        vibe.timestamp = clock.unix_timestamp;
        vibe.topic = topic;
        vibe.content = content;
        vibe.likes = 0;
        vibe.bump = vibe_account_bump;

        Ok(())
    }
```

derive macro:
```rust
#[derive(Accounts)]
#[instruction(vibe_account_bump: u8)]
pub struct CreateVibe<'info> {
    #[account(init, seeds = [b"vibe_post", author.key().as_ref()], bump = vibe_account_bump, payer = author)]
    pub vibe: Account<'info, Vibe>,
    #[account(mut)]
    pub author: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```

account:
```
#[account]
#[derive(Default)]
pub struct Vibe {
    pub author: Pubkey,
    pub timestamp: i64,
    pub topic: String,
    pub content: String,
    pub likes: u32,
    bump: u8,
}
```
Please at least post the full program log haha
like the parts which matter
can i send the huge code here?
Oh, sorry, the owner/authority of the token account is the multisig, yeah (I got eye-snipped by the mint part)
It's a slightly unfortunate naming choice because the `.owner` field on an AccountInfo means something totally different, the *program* that owns an account and is allowed to mutate its data or spend the account's money
In spl token terminology, the "authority"/"logical owner" is the `.owner` field
This says that the authority over the mint is `mintAuthority` (whatever that is, not sure)
^ which field on `Account` is the Logical Authority here? `owner`?
Source diving, we see `TokenAccount` as:

```
#[derive(Clone)]
pub struct TokenAccount(spl_token::state::Account);

impl TokenAccount {
    pub c
```

Looking at SPL Account, we have:

```
/// Account data.
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct Account {
    /// The mint associated with this account
    pub mint: Pubkey,
    /// The owner of this account.
    pub owner: Pubkey,
    /// The amount of tokens this account holds.
    pub amount: u64,
    /// If `delegate` is `Some` then `delegated_amount` represents
    /// the amount authorized by the delegate
    pub delegate: COption<Pubkey>,
    /// The account's state
    pub state: AccountState,
    /// If is_native.is_some, this is a native token, and the value logs the rent-exempt reserve. An
    /// Account is required to be rent-exempt, so the value is used by the Processor to ensure that
    /// wrapped SOL accounts do not drop below this threshold.
    pub is_native: COption<u64>,
    /// The amount delegated
    pub delegated_amount: u64,
    /// Optional authority to close the account.
    pub close_authority: COption<Pubkey>,
}
```
Shouldn't be any difference when writing tests, that just means you've got a bug üòõ
ah so if I generate the mint and token account like so:

```
mintA = await splToken.Token.createMint(
      program.provider.connection,
      payer,
      mintAuthority.publicKey,
      null,
      0,
      splToken.TOKEN_PROGRAM_ID
    );

    let multisigTokenAcct = await mintA.createAccount(multisig.publicKey);
```

Is the current authority/logical owner just the `multisig`?
How do you write tests for PDAs? everything I do says 
`Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account`
You'll need to sign with the current authority (the "logical owner")
That call looks a bit odd to me
1. I doubt the current_authority over the multisig is the spl token program itself?
What i'm trying to do is set the new token account's authority to be the multisig_signer, which is the PDA. So you are suggesting that in this case, I don't need to have `pub multisig_signer: Signer<'info>`
the corresponding rpc call looks like:

```
pub fn initialize_token_acct(ctx: Context<InitializeTokenAccount>) -> Result<()> {

        msg!("initialize token acct starting");

        let token_accounts = SetAuthority {
            current_authority: ctx.accounts.token_program.clone(),
            account_or_mint: ctx.accounts.multisig_token_program.to_account_info().clone()
        };

        msg!("set token_accounts: ");

        let cpi_program = ctx.accounts.token_program.to_account_info();

        msg!("set cpi_program: ");
        msg!("{:?}", cpi_program);

        token::set_authority(
            CpiContext::new(cpi_program, token_accounts),
            AuthorityType::AccountOwner,
            Some(*ctx.accounts.multisig_signer.key),
        )?;

        msg!("set authority");

        Ok(())
    }
```
So there's no need to use the `signers` array at all probably
No, I'm saying that in order to sign for the multisigSigner (if that's indeed necessary), then the only possible way to do it is by using `invoke_signed` from within your program
hm are you suggesting the right way to do this is:

```
await program.rpc.initializeTokenAcct(
      {
        accounts: {
          tokenProgram: splToken.TOKEN_PROGRAM_ID,
          multisigTokenProgram: multisigTokenAcct,
          multisig: multisig.publicKey,
          multisigSigner: multisigSigner
        },
        signers: [multisig],
      }
    );
```

replacing `signers: [multisigSigner]` with `signers: [multisig]`, since `multisig` is the deriving program. When I do this, I get:

```
 sending random tokens works!:
     Error: unknown signer: 2c8BgD9uXHJKQQmfGmTAv9NtiLB9k2Qtcq8MqYhxJJiC
      at Transaction._addSignature (node_modules/@solana/web3.js/lib/index.cjs.js:2777:13)
      at /Users/pw/Documents/coding/collective-multisig/node_modules/@solana/web3.js/lib/index.cjs.js:2751:12
      at Array.forEach (<anonymous>)
      at Transaction._partialSign (node_modules/@solana/web3.js/lib/index.cjs.js:2748:13)
      at Transaction.partialSign (node_modules/@solana/web3.js/lib/index.cjs.js:2739:10)
      at /Users/pw/Documents/coding/collective-multisig/node_modules/@project-serum/anchor/dist/cjs/provider.js:87:16
      at Array.forEach (<anonymous>)
      at Provider.send (node_modules/@project-serum/anchor/dist/cjs/provider.js:86:14)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at async Object.rpc [as initializeTokenAcct] (node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:31:31)
      at async Context.<anonymous> (tests/multisig.js:85:5)
```
That's silly - probably not deployed on localnet
I trying to pass in the token metadata program https://discord.com/channels/889577356681945098/889702325231427584/943001650950471680. Here's the address 
```
metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s
```
Is says its executable: https://explorer.solana.com/address/metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s
Are you sure the account you're passing in is actually executable? What have you done to verify that?
I'm getting this error https://github.com/project-serum/anchor/blob/40379eb21f3d2e7f492e8f95caac7d4364b5642e/lang/src/accounts/program.rs#L93
Sir! You are life saver.
I was trying to solve a problem that seems close to this discussion. Do you know where executable becomes true when passing in the id of a program account?
Try just hardcoding `b"seer"` instead of `ido_account.program_name` and you'll see that you start getting different errors.
I think the issue is that on the client side, you're passing the program name seed as (effectively) Buffer.from("seer"), but on the rust side you're actually not doing the same thing, since the `ido_account.program_name` is actually hardcoded to be length 10. So you're missing 6 zero padding bytes on the JS side.
It's a little tricky to read, but here's where your `#[account]` struct gets its auto-derived connection to the declare_id value: https://github.com/project-serum/anchor/blob/master/lang/attribute/account/src/lib.rs#L115
Here's the check üòú
Since, yeah, this is pretty annoying to debug if you aren't familiar with how it works under the hood
But I feel like anchor should probably just immediately error your program if it finds at runtime that the runtime program_id doesn't match the declare_id value
Yeah, good question‚Äîto some extent it's just easier implementation-wise to use the declare_id value
why not use program_id ?
aha I see!
When you do `Account<'info, OneOfMyAccountStructs>`, anchor will verify that the incoming account's program owner is your program‚Äîbut that check is done using the value you set with the `declare_id!`. So if you put the wrong value there, anchor will erroneously conclude that the incoming account has the wrong program owner, even if it's actually fine.
not really :))
Do you understand how it leads to the 167 error? Might make it easier to remember if you understand the underlying link
can't count how many times I forget to change that
thx
That's the problem
eh
nope
Is your declare_id! set to cadqhinsP6mNxARkS36y6TQXjn6rA2DmaMnbwLRKJ92
Any Account<'info, Whatever> will throw that error if the account you passed in doesn't have the owner that the Whatever struct expects
```  #[account(init,payer = authority,space = 8 + 32 + 32 + 32 + 32 + 1 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 1)]
    pub pool: Account<'info, Pool>,
    #[account(
        init,
        payer = authority,
        seeds = [mint.key().as_ref()],
        bump = bump,
        token::mint = mint,
        // We want the program itself to have authority over the escrow token
        // account, so we need to use some program-derived address here. Well,
        // the escrow token account itself already lives at a program-derived
        // address, so we can set its authority to be its own address.
        token::authority = vault,
    )]
    pub vault: Account<'info, TokenAccount>,
    pub mint: Account<'info, Mint>,
    pub pyth: AccountInfo<'info>,
    pub authority: Signer<'info>,
    pub system_program: Program<'info, System>,
    pub token_program: Program<'info, Token>,
    pub clock: Sysvar<'info, Clock>,
    pub rent: Sysvar<'info, Rent>,```
I already checked but didn't know why
https://github.com/project-serum/anchor/blob/v0.18.2/ts/src/error.ts#L87
```    'Program cadqhinsP6mNxARkS36y6TQXjn6rA2DmaMnbwLRKJ92 invoke [1]',
    'Program 11111111111111111111111111111111 invoke [2]',
    'Program 11111111111111111111111111111111 success',
    'Program log: Custom program error: 0xa7',
    'Program cadqhinsP6mNxARkS36y6TQXjn6rA2DmaMnbwLRKJ92 consumed 16239 of 200000 compute units',
    'Program cadqhinsP6mNxARkS36y6TQXjn6rA2DmaMnbwLRKJ92 failed: custom program error: 0xa7'```
What have you tried so far?
which function gives that error?
please post full program log
what could be the issue ?
I'm getting 167 error
Thanks sir! Here it is https://github.com/LumenMoney/ido.git
anyone
Given the existing token program
Ah, the immutable part? I'm actually not sure how to implement that
I would suggest putting your code in a full github repo, so someone can just clone it, `yarn`, `anchor test`
What about the latter ?
If you're down to use non-canonical bumps then the resulting addresses are of course not canonical either, so kind of defeats the whole purpose of an ATA
Since the whole point of an ATA is to have an obvious address to use for person X's mint M tokens.
I think at that point it's not really an ATA anymore ü§î
what about different bump ?
Because, yeah, if you change it, you can't create another ATA at that same address!
I think you should basically never ever change the authority of an associated token account (or idk, maybe not never, but it's definitely a very confusing/unexpected thing to do!)
another question :
yeah, much better tbh
Whose authority is its own address (which is a PDA, so in other words: the program controls those tokens)
But note how that example ^ isn't an ATA at all, it's just a regular PDA address.
I see, I have to initialize the token account inside of the program
E.g. like this: https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo/src/lib.rs#L182
In this case, honestly I think it's simpler to not use an associated token address at all, and instead just store the token account at one of your PDAs directly.
Yeah, to make a token account "owned by the program" means to have its authority be some PDA derived from the program.
I think I have to make the ata owned by a pda if I'm not wrong ?
<@!134416332509675520> :))
in this case I put program_id in authority ?
if the ata is owned by the program
I am stuck. Kindly have another look and see if it is something obvious?
can we use BTreeMap inside of a program?
Hi!

I'm getting `failed: custom program error: 0x0` when calling `Instruction A` but I only get it if I include `Instruction B` in the lib module with `#[program]`. If I comment out `Instruction B`, `Instruction A` runs fine. It compiles and all but right at returning `Ok(())` in `Instruction A` it'll fail with the above error if `Instruction B` is only present (not called)..

Any advice?
You need to figure out why that one account isn't actually signing
Sorry, I was wrong, the log is in there
Apologise but how to get the rust program log?
The solana stack is tiny, so sometimes you need to use the heap üôÇ
what's this good for in anchor ?
It puts the inner type onto the heap as opposed to the stack.
what's Box ?
`    CFP282CfG62c99BFRETNDANthu25UritoJwjjnu51nYN's signer privilege escalated
`
Whoops, I can't read
Ah, sorry, the full rust program log, not the JS stacktrace
Here is the full error log
https://gist.github.com/LumenMoney/17fcd47862f0aa44b0a82f9efe5e6f31
So that error is happening on the client: it's saying (in a not super helpful way) this signers thing you passed me isn't an actual keypair, it's just an address.
`multisigSigner` here is a PDA, so you can't pass it into the `signers` array (it's impossible to sign from the client for a PDA, only it's deriving program can sign for it)
Can you post the full program log?
That would mean that the underlying program account isn't executable (did you deploy it?).
Small example here: https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo/src/lib.rs#L219
an example would be much appreciated
Hello, what's best way to use ata in anchor ?
Can someone have a look. I have modified some code of IDO-POOL from anchor's test directory and I keep getting the following error
"Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account"
Here is the code
https://gist.github.com/LumenMoney/59d653ac76c82a6bb8bec48339700f32
i think this is how it should be, didn't test it give it a try
still noob to cargo
ty sirs
`anchor-lang = { version = "0.21.0", features = ["init-if-needed"]}`
https://doc.rust-lang.org/cargo/reference/features.html#dependency-features
which docs? I have been looking for it for 20 min cant find it :/
when necessary
import anchor-lang with it. the cargo docs explain how that works
`init-if-needed = []` in features doesn't work
how do I set the init_if_needed flag?
I'm wondering what's the best practice to `Box` accounts,
when is it necessary to do so ? large accounts in general ?
how can i get transaction data with a signature, i need something like the data that are displayed in the solana explorar
Ya Simply ran the installation command again and it updated
How to send time in anchor as a param to instruction ? I want to send some future date. How to convert it in big number
I defined a new type for a Program that looked like it just needed an `id` method implemented for it based on how `Token` was working.
```rust
pub token_metadata_program: Program<'info, TokenMetadata>,

#[derive(Clone)]
pub struct Token;

impl anchor_lang::Id for Token {
    fn id() -> Pubkey {
        ID
    }
}
```
but I'm getting this error:
```
Error: 3009: Program account is not executable
```
Is there something else I need to implement so that `info.executable == True` when I provide `ctx.accounts.token_metadata_program.to_account_info()` to `CpiContext::new_with_signer` for the program address?
```
multisigSigner.toString()
'2aPDLKMRepnsYNW9Zixn2RhMkwH5nNAcan9NmyXPxUBe'
multisigTokenAcct.toString()
'DZrermHPJsq6HKXoNc6km2RLsEvs1vPMG6aa3dLwQEs1'
splToken.TOKEN_PROGRAM_ID.toString()
'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'
multisigTokenAcct.toString()
'DZrermHPJsq6HKXoNc6km2RLsEvs1vPMG6aa3dLwQEs1'
```
I've made sure that:

1/ All the account inputs in the `initializeTokenAcct` call are non-null
2/ I've also added `msg!` logging to the actual program definitions but nothing is printing either - this tells me we aren't even making it into the program rpc call. 
3/ `program.rpc.createMultisig` works, so the call should be made properly

Any ideas what is causing this issue of undefined?
`tests/multisig.js:85:5` points to  `await program.rpc.initializeTokenAcct(...)`
The error i'm getting from running this test is:

```
       sending random tokens works!:
     TypeError: Cannot read properties of undefined (reading 'toString')
      at Transaction.partialSign (node_modules/@solana/web3.js/lib/index.cjs.js:2727:36)
      at /Users/pw/Documents/coding/collective-multisig/node_modules/@project-serum/anchor/dist/cjs/provider.js:87:16
      at Array.forEach (<anonymous>)
      at Provider.send (node_modules/@project-serum/anchor/dist/cjs/provider.js:86:14)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at async Object.rpc [as initializeTokenAcct] (node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:31:31)
      at async Context.<anonymous> (tests/multisig.js:85:5)
```
```
it("sending random tokens works!", async() => {

    const escrowAccount = anchor.web3.Keypair.generate();
    const payer = anchor.web3.Keypair.generate();
    const mintAuthority = anchor.web3.Keypair.generate();

    const multisig = anchor.web3.Keypair.generate();
    const [multisigSigner, nonce] =
      await anchor.web3.PublicKey.findProgramAddress(
        [multisig.publicKey.toBuffer()],
        program.programId
      );
    const multisigSize = 1000; // Big enough.

    const ownerA = anchor.web3.Keypair.generate();
    const ownerB = anchor.web3.Keypair.generate();
    const owners = [ownerA.publicKey, ownerB.publicKey];

    const threshold = new anchor.BN(2);

    await program.rpc.createMultisig(owners, threshold, nonce, {
      accounts: {
        multisig: multisig.publicKey,
      },
      instructions: [
        await program.account.multisig.createInstruction(
          multisig,
          multisigSize
        ),
      ],
      signers: [multisig],
    });

    await program.provider.connection.confirmTransaction(
      await program.provider.connection.requestAirdrop(payer.publicKey, 10000000000),
      "processed"
    );

     mintA = await splToken.Token.createMint(
      program.provider.connection,
      payer,
      mintAuthority.publicKey,
      null,
      0,
      splToken.TOKEN_PROGRAM_ID
    );

    let multisigTokenAcct = await mintA.createAccount(multisig.publicKey);

    await program.rpc.initializeTokenAcct(
      {
        accounts: {
          tokenProgram: splToken.TOKEN_PROGRAM_ID,
          multisigTokenProgram: multisigTokenAcct,
          multisig: multisig.publicKey,
          multisigSigner: multisigSigner
        },
        signers: [multisigSigner],
      }
    );
    
    assert(multisig)
  });
```
My test looks like the following:
I'm trying to figure out how to initialize new token accounts via the anchor framework. I have the following:

```
pub fn initialize_token_acct(ctx: Context<InitializeTokenAccount>) -> Result<()> {

    msg!("initialize token acct starting");

    let token_accounts = SetAuthority {
        current_authority: ctx.accounts.token_program.clone(),
        account_or_mint: ctx.accounts.multisig_token_program.to_account_info().clone()
    };

    msg!("set token_accounts: ");

    let cpi_program = ctx.accounts.token_program.to_account_info();

    msg!("set cpi_program: ");
    msg!("{:?}", cpi_program);

    token::set_authority(
        CpiContext::new(cpi_program, token_accounts),
        AuthorityType::AccountOwner,
        Some(*ctx.accounts.multisig_signer.key),
    )?;

    msg!("set authority");

    Ok(())
}

#[derive(Accounts)]
pub struct InitializeTokenAccount<'info> {
    pub token_program: AccountInfo<'info>,
    #[account(mut)]
    pub multisig_token_program: Account<'info, TokenAccount>,
    pub multisig: Box<Account<'info, Multisig>>,
    #[account(
        seeds = [multisig.key().as_ref()],
        bump = multisig.nonce,
    )]
    pub multisig_signer: Signer<'info>,
}
```
Don't think there's any difference, a PDA is just a PDA. Usually authority means some address (doesn't have to be a PDA) that needs to sign in order for something to happen (e.g. the authority over a token account is the "logical owner", the address that needs to sign in order for the spl token program to say "ok, sure, I'll transfer some tokens from this account to somewhere else üëç"
1. Generating a keypair doesn't do anything with accounts, it just generates an ed25519 keypair (so no actual solana stuff happening).
2. You can sign for that address, yes, since it's a keypair address and you have its private key.
I guess I haven't actually checked this but I would have guessed that would be the same for all CPIs: no need to pass the program as an account in the CPI `invoke` itself, but you do need to pass it from the client.
As far as I know, you just don't need to pass the system program as an account *into the CPI*. You *do* need to pass it as an account from the client though.
`ls -hl target/deply/<your-prog-name>.so` to see how big your program is, then it'll cost 1.4 sol / 100kb of code
does anyone have any good resources for program deployment costs? thanks in advance
how complicated would it be to follow imported types when parsing lib.rs? Meaning, for example, if you were using an imported type in a struct, it would look to the imports if it didn't find it defined in lib.rs directly?
https://solanacookbook.com/references/programs.html#how-to-do-cross-program-invocation
This mentions that passing the system program for a CPI is an 'exception', but doesn't explain why it is an exception or how to know something like that ahead of time. Why do you need to provide the System Program to a CreateAccount instruction? (and more importantly) where can I see this information? since it doesn't seem apparent from the Rust documentation (no mention in the Accounts reference for this instruction) https://docs.rs/solana-sdk/1.9.6/solana_sdk/system_instruction/enum.SystemInstruction.html
not strictly an Anchor question, but why do some program instructions take the system program ID as an input account? If I read the CPI docs correctly it would seem you don't need the executable program_id when calling invoke, and I'm not sure why else you would need the system program's account data (I'm assuming it's empty?). Is there another reason to take the system program as input?
We should really provide that out of the box, though.
Yea you can subclass provider to not use a wallet.
For the javascript side - why does the program need the wallet?  When a user comes to a site, and I'd like to show them chain state before they have connected with their wallet.  It appears that you need to feed the provider a wallet before I can read data
Quick question: what's the difference between a PDA key vs. PDA authority?
Here is the explorer
https://explorer.solana.com/tx/2ME4pHraQqALpisNx3rF4yGKageXL32jMEXLg6PdQcXd4pJGpKEpVqnoxoYvxp6fisr1biZNobKUFqHugCb9N23g?cluster=devnet
`let newAuthority =new anchor.web3.PublicKey("BMbhASUcRoV6DMBzWwD8dCudM9wnbum2VBLVckSXhEYb")



    return await program.rpc.updateDispatchAuthority(new anchor.BN(vbump), {
        accounts: {
            withdrawAuthority: wallet.publicKey,
            vaultPda: vpda,
            newAuthority,
            systemProgram: anchor.web3.SystemProgram.programId
        }
    })`
No. Here is the Node call
Ok, dumb question, is it possible you're accidentally passing in the *old* authority as the `new_authority` account?
https://explorer.solana.com/address/DiR3zknTTGDDncfLDgpmN75y3L2XMzyEtuM4Tpt16HMt?cluster=devnet
Here is the program
https://explorer.solana.com/address/F7U8k5HKtTDqEyoNBimLDVw2GYiAtb7PMtVHgix5cSPb?cluster=devnet
Can you link me that explorer trace?
It is for sure owned by my program
You can see the account here
Yes. 100%
Not an easy ask... I called some functions from Node, some code is in Rust and some in sin Go haah
Sounds like it is, just double checking
üòõ
I mean ignoring the PDAness, is the account itself definitely one of your own `#[account]` structs
pls post full program log ü§£
Yea...
And the account's data is still stale even if you wait a while?
It is derived from my account
(So not if the PDA's address is derived from your program‚Äîis the account itself owned by the program?)
Yes
Is that PDA's account owned by your program?
The first keypair should be `BMbhASUcRoV6DMBzWwD8dCudM9wnbum2VBLVckSXhEYb`
`{7AhfPryyniMySpTDkqjcL4sdoqu92uKiUTHbqBFHGXtN 7AhfPryyniMySpTDkqjcL4sdoqu92uKiUTHbqBFHGXtN}`
I don't think so, I am first checking the PDA's info from my Go server which says it isn't updated, then the function I want to call is failing because of a constraint issue becuase the info is not updated
"An account is owned by the system program by default. the system program has basic functions for creating more accounts and sending lamports and such and such. accounts can be assigned a new owner once and only once. this owner is always a program, which has permission to deduct lamports from the account and modify its data however it wishes" from https://2501babe.github.io/posts/solana101.html

1/What is happening when you do `solana keypair-gen`? Who owns this account? Is it the system program? 

2/ Are we able to sign/approve transactions because we have the private key?
could be that the data actually changed, but you didn't refetch the data and testing over old state
What do you mean?
Solana explorer also says vault_pda is writable (the second account being passed in)
weird, in your test did you call `fetch` again  after update?
I don't think it is that... Here is the context
`pub struct UpdateAuthority<'info> {
    #[account(mut, constraint=withdraw_authority.key()==vault_pda.withdraw_authority)]
    pub withdraw_authority: Signer<'info>,
    #[account(mut, seeds=[b"vault"], bump=vault_bump)]
    pub vault_pda: Account<'info, VaultPDA>,
    pub new_authority: AccountInfo<'info>,
    pub system_program: Program<'info, System>,
}`
Can't be that..
` pub fn update_dispatch_authority(
        ctx: Context<UpdateAuthority>,
        _vault_bump: u8,
    ) -> ProgramResult {
        let vault_pda = &mut ctx.accounts.vault_pda;
        vault_pda.dispatch_authority = ctx.accounts.new_authority.key();
        Ok(())
    }` Here is the whole function
Or maybe you forgot to pass `mut` to the account context
Shot in the dark..
I had this happen yesterday and it turned out I didn't call the actual function handler but just returned Ok(()) for the instruction in lib.. üôÑ  Maybe it's the same for you?
Any thoughts?
So i have a function that updates an authority on my contract like so
`ctx.accounts.vault_pda.dispatch_authority = ctx.accounts.new_authority.key();` The problem is that when I check the PDA to see if anything has been changed, nothing has been
Hi 

is there a reason the Debug trait isn't derived/implemented on the  anchor_spl::token::TokenAccount Struct?
Yes, I was going to say at least you can try copying it in and see if it works. I'm not sure if there is a good way to get imported structs to be picked up in the IDL
yes - there's not that much to it, so recreating isn't too bad
oh in your case the struct is imported?
actually imported from `mpl-token-metadata`
they are defined in a separate file isn't it?
It looks like all of those structs are defined in the program versus importing `DataV2`
I just observed the deserialized objects and IDL for this Drift `State` account and it worked, so I'm guessing whatever they are doing has the answer üòÑ
Not sure why that would effect IDL stuff
I'm not 100% sure that's what missing for the type to make it into the IDL tbh
Do you need Default? I would be kind of surprised if you do ü§î
ok, thanks - `Default` isn't implemented for `DataV2`, but maybe I can implement
that's what `{"name":"data","type":{"defined":"DataV2"}}` means: the field `name` is of type `DataV2` which is user-defined
you can have nested types fine, they will be listed under the `types` namespace of the IDL generated
c.f. https://github.com/drift-labs/protocol-v1/blob/master/programs/clearing_house/src/state/state.rs#L35
Clone and Default might be required for the type to be picked up
Basically, the IDL generation stuff isn't super sophisticated, so here I'm not sure how it's going to know what to make of DataV2.
Ah... hmm. There actually might not be a great way around this as far as I know‚Äîyou may have to just use your own isomorphic type and convert back and forth to that DataV2 thing within your program (ew).
that worked, but punted it to `DataV2`, which I was importing from `mpl_token_metadata`. I don't think I can implement `AnchorSerialize` and `AnchorDeSerialize` for the imported type - redefine `DataV2` in my anchor program?
```rust
#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct AnchorDataV2 {
    data: DataV2,
}
```
```
IdlError: Type not found: {"name":"data","type":{"defined":"DataV2"}}
```
If all you need to do is orchestrate instructions amongst other programs, then yeah, can do that purely from the client.
You need your own rust program generally when you want to store your own custom data on-chain (in solana, only the program that owns an account can write to it‚Äîso generally, if you want to write your own custom stuff, you probably need your own program)
As a dev on Solana are you mostly using Rust to write distinct programs or are you using Typescript to create frontends that interact with programs already written?
Ah, this is annoying but I think anchor doesn't yet support that kind of direct newtype pattern (just hasn't been implemented yet)‚Äîtry doing this instead:
```.rs
#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct AnchorDataV2 {
  pub hmm: DataV2
}
```
```rust
#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct AnchorDataV2(DataV2);
```
How did you define it in Rust?
If i have a custom type for an argument to a program instruction, how can I access that in the ts client?
```IdlError: Type not found: {"name":"data","type":{"defined":"AnchorDataV2"}}```
Okay Thanks
Yeah definitely part of learning solana is a phase where you keep going "... ffs, I have to pass that account too?"
Sure!
ohhhhhh that was the missing piece. Thank you!!
CPIs can't introduce any new accounts, unfortunately‚Äîthe rule I mentioned above still applies, the client has to pre-specify *all* accounts of interest
I think I know what you're referring to: the runtime uses the accounts in the instruction data to actually pass a handle to the Program when it is loaded. But it seems like a Program could have a 'public-facing' instruction which doesn't require the client to pass the PDA address, then on-chain it derives the PDA addresses (which it would have done anyway to verify from the client), and then CPI to itself with that address in the instruction data for the 'internal-facing' instruction. Would this not work/be wasteful in some way? I think it would be nice to avoid generating on the client-side if even just to avoid keeping seeds in sync etc.
So there's no way to avoid having the client find the address. And then if the program itself wants to sign for that address (or just validate that the address looks right), it will have to do seeds stuff too.
This is just an annoying thing about solana: any time your program wants to use an account, the client has to pre-specify its address.
Another question on PDAs, I notice in contracts that I've interacted with and in the source of some SPL programs that PDA addresses are typically sent by the client as accounts in the instruction data. Then the program re-derives the address to verify, and then invokes a separate instruction as the signer of that account. My question is, why bother having the client generate PDA addresses? Shouldn't the program always derive them and CPI as a signer? Is it a question of read vs. write? Thanks in advance üôÇ


//////////////////////////////////////////////////////////////////////////////////////////

What are `instructions`/`signers` inputs here? Not seeing these variables in the IDL and it also doesn't seem to be a part of the `Context` wrapper (reading through https://docs.rs/anchor-lang/latest/anchor_lang/context/struct.Context.html)
And in the tests, we have:

```
await program.rpc.createTransaction(pid, accounts, data, {
  accounts: {
    multisig: multisig.publicKey,
    transaction: transaction.publicKey,
    proposer: ownerA.publicKey,
  },
  instructions: [
    await program.account.transaction.createInstruction(
      transaction,
      txSize
    ),
  ],
  signers: [transaction, ownerA],
});
```
If I have:

```
// Creates a new transaction account, automatically signed by the creator,
// which must be one of the owners of the multisig.
    pub fn create_transaction(
        ctx: Context<CreateTransaction>,
        pid: Pubkey,
        accs: Vec<TransactionAccount>,
        data: Vec<u8>,
    ) -> Result<()> {
        let owner_index = ctx
            .accounts
            .multisig
            .owners
            .iter()
            .position(|a| a == ctx.accounts.proposer.key)
            .ok_or(ErrorCode::InvalidOwner)?;

        let mut signers = Vec::new();
        signers.resize(ctx.accounts.multisig.owners.len(), false);
        signers[owner_index] = true;

        let tx = &mut ctx.accounts.transaction;
        tx.program_id = pid;
        tx.accounts = accs;
        tx.data = data;
        tx.signers = signers;
        tx.multisig = ctx.accounts.multisig.key();
        tx.did_execute = false;
        tx.owner_set_seqno = ctx.accounts.multisig.owner_set_seqno;

        Ok(())
    }

#[derive(Accounts)]
pub struct CreateTransaction<'info> {
    multisig: Box<Account<'info, Multisig>>,
    #[account(zero)]
    transaction: Box<Account<'info, Transaction>>,
    // One of the owners. Checked in the handler.
    proposer: Signer<'info>,
}
```
Thanks a lot cqfd!
`program.rpc.doSomething(["foo", "bar"], ....)`
how would you pass the arguments from js to rust with vec<String> ?

Just to set orders of magnitude, millions of entries is going to cost a fair amount of money‚Äîsay 100 bytes per entry, that's 100mb, and rent-exemption costs 7 sol / mb, so you're looking at on the order of 700 sol
^The hashmap has to be persistent across blocks.
I haven't tried yet, I was thinking to use PDA accounts based on the map Keys, but it seems expensive, maybe there's a better way.
Hash size is maybe in the order of millions of entries
Are you running into a particular problem?
You can't really use literal HashMaps in solana (well, strictly speaking you can but they don't work out of the box‚Äîcan search the discord if you want the details). What have you tried doing so far?
I haven't yet. Bump pls üôè  But totally get it that it's not an Anchor specific question, so it's my last bump üòÑ
Amazing, man.  Utility and hilarity in a single repo.  May you live a thousand years.
super cool nonetheless
totally agree
and on program exit
this should be done inside the derive
yea but that's an extra macro
Here you go <@!501570363566587905> King
https://twitter.com/0xDeep/status/1493872874423468036?s=20&t=3ZdMJQSQ83S5ixy8-yktyg
with line number + file
we really need to just do the logging automatically in the framework
or you can use this, it will make your life a lot easier I guess,
```
‚ùØ‚ùØ‚ùØ fuck 0x65    
> Anchor Program
101 | InstructionFallbackNotFound: Fallback functions are not supported
```
https://github.com/0xdeepmehta/fuck-anchor
```typescript
export async function transferLamports(provider: Provider, from: Signer, to: PublicKey, amount: number) {
    const transaction = new web3.Transaction().add(
        web3.SystemProgram.transfer({
            fromPubkey: from.publicKey,
            toPubkey: to,
            lamports: amount, // number of SOL to send
        })
    );

    return await web3.sendAndConfirmTransaction(provider.connection, transaction, [from], { commitment: 'confirmed' });
}
```

Is that what you're looking for?
What's the state of art Anchor Program SDK out there ?
So, maybe try rerunning anchor build + anchor deploy (assuming you're deploying it etc.)
So, that means you've presumably not deployed it correctly, since you're otherwise just using normal anchor stuff
It means you're sending an instruction to your anchor program and it's going "... wtf is this"
Hey guys, can anyone please tell me how to send SOL tokens with calling JSON RPC anchor functoins?
I'm not sure what it meant tho
Yeah I found the error it's ```  InstructionFallbackNotFound: 101,
```
0x65 = 101 = https://github.com/project-serum/anchor/blob/v0.18.2/ts/src/error.ts#L56, which is a pretty low-level error (it means that your deployed anchor program doesn't understand the instruction you tried to send it). I think that likely means you haven't deployed correctly.
Do you know how to find that anchor error based on the hex code?
.
```Transaction simulation failed: Error processing Instruction 0: custom program error: 0x65
    Program cadqhinsP6mNxARkS36y6TQXjn6rA2DmaMnbwLRKJ92 invoke [1]
    Program log: Custom program error: 0x65
    Program cadqhinsP6mNxARkS36y6TQXjn6rA2DmaMnbwLRKJ92 consumed 3166 of 200000 compute units
    Program cadqhinsP6mNxARkS36y6TQXjn6rA2DmaMnbwLRKJ92 failed: custom program error: 0x65
1  error```
Is something not working?
is this correct ?
```  #[account(
        init,
        payer = authority,
        seeds = [mint.key().as_ref()],
        bump = bump,
        token::mint = mint,
        // We want the program itself to have authority over the escrow token
        // account, so we need to use some program-derived address here. Well,
        // the escrow token account itself already lives at a program-derived
        // address, so we can set its authority to be its own address.
        token::authority = vault,
    )]
    pub vault: Account<'info, TokenAccount>,```
``` #[account(
        seeds = [mint.key().as_ref()],
        bump = bump,
    )]
    pub vault: Account<'info, TokenAccount>,```
Has anyone done an anchor test file on something that involves NFTs? Just wondering if there is a boilerplate to tap into for the NFT creation on a local connection
Ah, interesting! Cool, good to know
Needed to also clone the program's data account:
```
[test.validator]
url = "devnet"
[[test.validator.clone]]
address = "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"
[[test.validator.clone]]
address = "PwDiXFxQsGra4sFFTT8r1QWRMd4vfumiWC1jfWNfdYT"
```
Hi, i was having trouble using this the right way. I'm doing this:
```
[test.validator]
url = "devnet"
[[test.validator.clone]]
address = "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"
```
but keep ending up with 
```
Transaction simulation failed: Attempt to load a program that does not exist
```
I'm checking to see whether it's loaded with
```js
let accInfo = await anchor.getProvider().connection.getAccountInfo(MetadataProgram.PUBKEY);
console.log(`${MetadataProgram.PUBKEY.toString()} length: ${accInfo.data.length}`);
```
and that is saying:
```
metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s length: 36
```
which seems like not long enough.
you get an solution for this? I got a similar problem?
what the `use` line for `Context`?
whats needed to store this onchain: `    pub register_pool: Vec<Pubkey>,`
you can use `msg!("log_somethng");` if you want to log on on-chain
yeah thanks
yeah make lot of sense
i ll do one comment per post per user üòÇ
üòÇ
yeah agree 70 $SOL
latter option would increase rent like crazy
so we have two way right, one comment account per post per user, or we can do one giant(10MB) comment account, and hashMap or something for mapping comment and corresponding user
`#[account(init, seeds = [b"post_comment", post.key().as_ref()], bump = comment_account_bump, payer = commentor, space = 1000 )]`

it would be like this then? but wouldnt that restrict one comment per post?
I'm a big fan of Genopets
``` const [comment, commentBump] = await anchor.web3.PublicKey.findProgramAddress(
    [Buffer.from("post"), post.toBuffer()],
    program.programId
);```
yeah, you can use PDA
He folks! I have a "Post" account and a "Comment" account. How do I link a "comment" to a "post"? using PDA?
Hi. Is it possible to use spl-memo(Memo Program v2) in an on-chain program? If possible, can i find such an example?
big fan
Huhaha, yes
are you the guy that built fuck anchor?
haha, It happens üòú
thank you - the underscores got me
<@!392163769834405899> you need to do `features = ["init-if-needed"]`
Hey! I am trying to complete the achor lang tic tack  toe tutorial but keep getting this error. I am not sure how to debug it.
Hi <@!396372249634013198>, can you able to figure that out? i'm also facing the exact issue while i'm tried to call that from js
^ Also posted this in development channel but started to think this falls under beginner, my b
I was reading some docs on "use cargo::objects" and what not but I can't seem to get those use statements to work
Hey everybody, I'm a little confused on something probably simple: I'm trying to import some Rust files that are inside a subfolder. Here's a few screenshots:
is there a function in the anchor client to close Accounts? I haven't been able to find it in the type reference. alternatively, is there a common way folks teardown after their test suite?
Hey ‚Äì would someone here be able to help us validate the attached architecture of our player-versus-player game‚Äôs smart contract?

A quick summary of how the game works:
1. Two players compete against each other
2. They both put in 1 SOL each into our escrow to begin the game
3. After the game is done, here‚Äôs how the funds are distributed:
       a. The winners wins 1.985 SOL
       b. Loser walks away with 0 SOL (loses their 1 SOL)
       c. We capture a fee of 0.015 SOL which is sent to a fee wallet

We are new to Solana smart contract development (building this using Anchor), so just wanted to make sure we were going in the right direction.

Could someone here help review the attached architecture and confirm we‚Äôre going in the right direction? Thank you!!
awesome! yeah this works too
I normally just use .only in mocha
üëã is there a way to get `anchor test` to just run a specific test or test file? I have `tests/test_one.js` and `tests/test_two.js` but every time i run `anchor test` it runs both of them. `anchor test tests/test_one.js` doesn't seem to work either
when I run `anchor test` on devnet, I get this error
```Error: Custom: Invalid blockhash
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }.```
Hi, what's a good way to keep a (fairly large) hashmap on-chain? Map<char[90],  Boolean>

getting this error when trying to build an anchor project on a ubuntu dist
I have this code: ```#[derive(Accounts)]
pub struct AddLiquidity<'info> {
    #[account(
        mut,
        seeds = [ POOL_STATE_SEED, lp_token_mint.key().as_ref() ],
        bump,
    )]
    pub pool_state: Box<Account<'info, PoolState>>,
... 
}``` and I want to make sure someone hasnt spoofed this object?
Hey, what's the reason for having the IDL on-chain? I mean, you have a JS client and misc web files anyway, so why not just host it there? Is this a necessary step for a verifiable build (anchor --verify)? Thanks for helping inform this fairly naiive pleb.
But in the case where the `multisigTokenAcct` has the multisig_signer (the multisig's PDA) how can I pass this along to sign the `send_token` instruction?

edit: figured this out, we can use the key and seeds to derive the PDA and use call `CpiContext::new_with_signer`  to get this working
I'm running into the same problem here where my `signers` argument on the `sendToken` call  - "multisigSigner here is a PDA, so you can't pass it into the signers array (it's impossible to sign from the client for a PDA, only it's deriving program can sign for it). So that error is happening on the client: it's saying (in a not super helpful way) this signers thing you passed me isn't an actual keypair, it's just an address."
```
mintA = await splToken.Token.createMint(
      program.provider.connection,
      payer,
      mintAuthority.publicKey,
      null,
      0,
      splToken.TOKEN_PROGRAM_ID
    );

    let multisigTokenAcct = await mintA.createAccount(arbitraryTokenAcct.publicKey);
    let receiverTokenAcct = await mintA.createAccount(arbitraryTokenAcct.publicKey);

    await mintA.mintTo(
      multisigTokenAcct,
      mintAuthority.publicKey,
      [mintAuthority],
      500 
    );

    let preRun = await mintA.getAccountInfo(multisigTokenAcct)

    await program.rpc.initializeTokenAcct(
      {
        accounts: {
          tokenProgram: splToken.TOKEN_PROGRAM_ID,
          multisigTokenAccount: multisigTokenAcct,
          multisig: multisig.publicKey,
          tokenAcctAuthority: arbitraryTokenAcct.publicKey,
          multisigSigner
        },
        signers: [arbitraryTokenAcct],
      }
    );
    
    let postRun = await mintA.getAccountInfo(multisigTokenAcct)

    await program.rpc.sendToken(new anchor.BN(200),
      {
        accounts: {
          multisig: multisig.publicKey,
          receiverTokenAccount: receiverTokenAcct,
          multisigTokenAccount: multisigTokenAcct,
          multisigSigner,
          tokenProgram: splToken.TOKEN_PROGRAM_ID
        },
        signers: [multisigSigner.key],
      }
    );
```
test looks like:
```
#[derive(Accounts)]
pub struct InitializeTokenAccount<'info> {
    #[account(signer)]
    pub token_acct_authority: AccountInfo<'info>,
    pub token_program: AccountInfo<'info>,
    #[account(mut)]
    pub multisig_token_account: Account<'info, TokenAccount>,
    pub multisig: Box<Account<'info, Multisig>>,
    #[account(
        seeds = [multisig.key().as_ref()],
        bump = multisig.nonce,
    )]
    pub multisig_signer: AccountInfo<'info>
}

#[derive(Accounts)]
pub struct SendTokenAcct<'info> {
    #[account(mut)]
    pub multisig: Box<Account<'info, Multisig>>,
    #[account(mut)]
    pub receiver_token_account: Account<'info, TokenAccount>,
    #[account(mut)]
    pub multisig_token_account: Account<'info, TokenAccount>,
    #[account(
        seeds = [multisig.key().as_ref()],
        bump = multisig.nonce,
    )]
    pub multisig_signer: AccountInfo<'info>,
    pub token_program: AccountInfo<'info>,
}
```
just building on this, our contract looks like:

```
pub fn initialize_token_acct(ctx: Context<InitializeTokenAccount>) -> Result<()> {
    msg!("initialize token acct starting");
    msg!("multisig_token_account.owner is {:?}", ctx.accounts.multisig_token_account.owner);

    let token_accounts = SetAuthority {
        current_authority: ctx.accounts.token_acct_authority.to_account_info().clone(),
        account_or_mint: ctx.accounts.multisig_token_account.to_account_info().clone()
    };

    msg!("set token_accounts: ");

    let cpi_program = ctx.accounts.token_program.to_account_info();

    msg!("set cpi_program: ");
    msg!("{:?}", cpi_program);

    token::set_authority(
        CpiContext::new(cpi_program, token_accounts),
        AuthorityType::AccountOwner,
        Some(ctx.accounts.multisig_signer.key()),
    )?;

    msg!("set authority complete");
    msg!("multisig_token_account.owner: {:?}", ctx.accounts.multisig_token_account.owner);

    Ok(())
}

pub fn send_token(ctx: Context<SendTokenAcct>, amount: u64) -> Result<()> {
    if ctx.accounts.multisig_token_account.amount < amount {
        return Err(ErrorCode::InvalidThreshold.into());
    }

    let cpi_accounts = Transfer {
        from: ctx.accounts.multisig_token_account.to_account_info(),
        to: ctx.accounts.receiver_token_account.to_account_info(),
        authority: ctx.accounts.multisig_signer.to_account_info()
    };

    let cpi_program = ctx.accounts.token_program.to_account_info();
    let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
    token::transfer(cpi_ctx, amount)?;

    Ok(())
}
```
do you know if there's an example of `zero_copy` with dynamically sized types? there's an example in the repo using a fixed array `pub events: [Event; 25000]]` but what about `[Event]` (edit: nvm forget `Vec` zero-copy makes no sense for that)
sorry, I actually _can_ implement `Clone` ( was thinking of a previous version of my struct where it holds an `&mut` so no clone, but now i can)
Is there a way I can pass through a constraint that a pda account exists (i.e. has been initialised) in a macro in the accounts definition ? Or would I have to find the pda in a function and then check whether its owner is the program_id  or something like that?
If `MyStruct` does not implement `Clone` you cannot use `Account<'info, MyStruct>`anyway, regardless of other IDL problems.
is it possible to register a type with the IDL after manually implementing Anchor traits?

the context here is I have an unsized `MyStruct` a (`DST`) and I want to be able to use the niceties of `Account<'info, MyStruct>` vs. just an `AccountInfo`

i've been digging a bit through Anchor macros -- I'm not sure about this but it seems the `#[account]` basically codegen the type as part of the IDL too, but I can't use that because my type can't implement `Clone` nor `Copy`
In this escrow example the escrow account is generated in the client code when called. Does this mean that I would have to store this publickey offchain somewhere to be used again when the program is cancelled/transfer is initialized? How come this account is not a PDA? 


 https://github.com/project-serum/anchor/blob/master/tests/escrow/tests/escrow.ts
If you werent aware, you can also just use `Account<'info, TokenAccount>` and anchor will deserialize it for you
Tbh I'm slightly fuzzy on the best way to do this, but I think can do
```.rs
        let data: &[u8] = *ctx
            .accounts
            .the_token_account
            .to_account_info()
            .try_borrow_data()
            .unwrap();
        TokenAccount::try_deserialize(&mut data);
```
I still don‚Äôt know how to fix this :/
You mean you want to check that the address makes sense?
Hey whats a good way to do a constraint that can confirm my custom StateObject is in fact the one I have created vai a PDA?
very weird
still doesn't work
So good!
There is also `[[test.validator.account]]` for loading account data from files
I need to document it
All validator flags should be configurable in anchor.toml
this is cool
```
[[test.validator.clone]]
address = "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"
```
You can do
```.js
await program.provider.connection.getConfirmedTransaction(
  await program.rpc.doSomething(...),
  "finalized"
);
```
fetching ```        let poolState = await program?.account.pool.fetch(pool.publicKey)``` after initializing gives that error
```Account does not exist DjDvc2CzyXp7PdDmiwgCZAs29syem5wgHzgLaTPta741``` is there a way to wait for the request to be fully confirmed ?
Can you post some code of what you've tried so far?
Hello ! I am coding my frontend but how in javascript we convert a u64 counter to a integer that  i receive from my rpc fetch ?
can you pass arguments to the test validator with `anchor test`?
Generally easier to just check ahead of time on the client + have two versions of the instruction
<@!134416332509675520> is there a way to create only if it's not initialized yet ?
never knew about this
lmao! thanks ‚ù§Ô∏è
<:KEKWait:683182130838503444>
They need to match at least up until the last argument you want to use
You need to do `#[instruction(end_time_deposit: u64, end_time: u64, bump: u8)]`
Right, that unfortunately (huge gotcha) doesnt' work
```#[instruction(bump: u8)]```
```pub fn create_pool(
        ctx: Context<CreatePool>,
        end_time_deposit: u64,
        end_time: u64,
        bump: u8,
        deposit_time: u64,
    ) -> ProgramResult {```
Your `#[instruction(...)]` thing needs to match the order of those arguments‚Äîdoesn't seem like it does, since I'm guessing the bump is the 3rd argument
```const initialize_pool_transaction = await program.rpc.createPool(new BN(50), new BN(70), new BN(b), new BN(50), {
            accounts: {
                pool: pool.publicKey,
                vault: a,
                pyth,
                authority: program.provider.wallet.publicKey,
                mint,
                systemProgram: SYSTEM_PROGRAM,
                tokenProgram: TOKEN_PROGRAM_ID,
                clock: SYSVAR_CLOCK_PUBKEY,
                rent: SYSVAR_RENT_PUBKEY,
            },
            signers: [pool]
        });

        return [initialize_pool_transaction, vault, program]```
Can you post your instruction function?
not sure why I'm getting an error
<@!134416332509675520> verified the address and the nonce, they match
Hello everyone, looking for an experienced developer to develop some basic contracts (starting with staking). If anyone interested, please dm me. Thanks.
```        const [a, b] = await PublicKey.findProgramAddress([mint.toBuffer()], program.programId)```
```#[derive(Accounts)]
#[instruction(bump: u8)]
pub struct CreatePool<'info> {
    #[account(init,payer = authority,space = 8 + 32 + 32 + 32 + 32 + 1 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 1)]
    pub pool: Account<'info, Pool>,
    #[account(
        init,
        payer = authority,
        seeds = [mint.key().as_ref()],
        bump = bump,
        token::mint = mint,
        // We want the program itself to have authority over the escrow token
        // account, so we need to use some program-derived address here. Well,
        // the escrow token account itself already lives at a program-derived
        // address, so we can set its authority to be its own address.
        token::authority = vault,
    )]
    pub vault: Account<'info, TokenAccount>,
    pub mint: Account<'info, Mint>,
    pub pyth: AccountInfo<'info>,
    pub authority: Signer<'info>,
    pub system_program: Program<'info, System>,
    pub token_program: Program<'info, Token>,
    pub clock: Sysvar<'info, Clock>,
    pub rent: Sysvar<'info, Rent>,
}```
It'll just stay as raw bytes
It'll work fine, it just won't automatically parse any of the `.data` in there
but `program.provider.connection.getAccountInfo(theAddress)` won't work if it's a `TokenAccount` right?
But system program accounts can't have any data as far as I know, just lamports
You can fetch arbitrary accounts (but won't get any automatic deserialization) with
```.js
await program.provider.connection.getAccountInfo(theAddress)
```
What is the equivalent for accounts owned by the system program?
Hey, can you help me? What am I doing wrong here?
Ok, then you aren't signing for it correctly (with seeds + bump etc.)
that address is the pda
I'll start by fixing that :))
That error means you're not signing for somethign correctly, not that an address is already in use etc.
Well that's currently what I can think of
Not sure how that relates to the error above ü§î
In JS you can do
```.js
theMint.getAccountInfo(theTokenAccountsAddress)
```
How can I check `token::set_authority` worked in changing up the account in question's owner?
so should I make a seperate instruction for initializing the pda only ?
the thing is I have that pda init in a commun instruction where it's used a lot
ah I see, I think I am initializing a pda that is already initialized
Depends on what you're doing
`    "CvsHapzvpTPkh481mxVwiQm89y9XeDN4VCmWL7iLrNzC's signer privilege escalated",
` so you somehow aren't signing for that address
```  'Program cadqhinsP6mNxARkS36y6TQXjn6rA2DmaMnbwLRKJ92 invoke [1]',
    'Program 11111111111111111111111111111111 invoke [2]',
    'Program 11111111111111111111111111111111 success',
    "CvsHapzvpTPkh481mxVwiQm89y9XeDN4VCmWL7iLrNzC's signer privilege escalated",
    'Program cadqhinsP6mNxARkS36y6TQXjn6rA2DmaMnbwLRKJ92 consumed 23806 of 200000 compute units',
    'Program cadqhinsP6mNxARkS36y6TQXjn6rA2DmaMnbwLRKJ92 failed: Cross-program invocation with unauthorized signer or writable account'```
If you know the secret key (the full keypair) then you can sign for an address from the client by using the `signers: [...]` array
ah my bad didn't post full uhh
Nothing has gone wrong there, that's just telling you that you ran some code
up :))
If you know the secret key for some keypair address, you can sign for the address.
Nope: the key thing is that how you sign for an address is purely a question about the address, it has nothing to do with the *program* that owns the account that lives at that address.
```
pub fn initialize_token_acct(ctx: Context<InitializeTokenAccount>) -> Result<()> {

        msg!("initialize token acct starting");
        msg!("multisig_token_program.owner is {:?}", ctx.accounts.multisig_token_account.owner);
        msg!("ctx.accounts.intializer is {:?}", ctx.accounts.token_acct_authority.to_account_info());

        let token_accounts = SetAuthority {
            current_authority: ctx.accounts.token_acct_authority.to_account_info().clone(),
            account_or_mint: ctx.accounts.multisig_token_account.to_account_info().clone()
        };

        msg!("set token_accounts: ");

        let cpi_program = ctx.accounts.token_program.to_account_info();

        msg!("set cpi_program: ");
        msg!("{:?}", cpi_program);

        token::set_authority(
            CpiContext::new(cpi_program, token_accounts),
            AuthorityType::AccountOwner,
            Some(ctx.accounts.multisig.key()),
        )?;

        msg!("set authority complete");
        msg!("multisig is {:?}", ctx.accounts.multisig.to_account_info());
        msg!("{:?}", ctx.accounts.multisig_token_account.to_account_info());

        Ok(())
    }
```

This piece of code works, but afterwards, `ctx.accounts.multisig_token_account.owner` is still set as `ctx.accounts.token_program`. Shouldn't `.owner` be the `ctx.accounts.multisig` after the `token::set_authority` executes?
is there a difference between `#[account(zero_copy)]` and `#[zero_copy]`?
Every account has an address (e.g. `account.to_account_info().key`) and every account has an owner (e.g. `account.to_account_info().owner`) and I guess that's the distinction. Is it correct to say that only the owner can sign for the account? 

In code, how do you "sign for an address if you know the secret key"?
possible reason ?
```    'Program cadqhinsP6mNxARkS36y6TQXjn6rA2DmaMnbwLRKJ92 consumed 3117 of 200000 compute units',```
What‚Äôs the best way to store my keys on the backend? What do other protocols do?
Sweeet
You'd just do basically the same kind of code you use in your node tests
web3.js üòõ
Basically, I have funds split across 3 lending protocols. I want my backend server to be able to set the distrivution of funds (e.g. 33% each) and then call the instructions to actually move the funds around
How would I build the txn on my node.js server? Is there some solana package for that?
Nah dont need user to sign
I haven't actually tried doing that before but should be fine
But yeah, you can do this‚Äîdo you also need the user to sign too? They'd have to partial sign from the client I guess, then ship the serialized tx to your server I guess
Dont want anyone else to have access
A very private one. Very confidential
With which keypair?
Can I sign transactions from a backend server?
I think the key thing is just to understand that addresses and accounts in solana are totally separate concepts: accounts live at addresses and have program owners (e.g. a token account is owned by the spl token program), and then addresses can be signed for: keypair addresses can be signed for if you know the secret key, and PDAs can be signed for if their deriving program decides to (note‚Äînot the same notion as an account's program owner! talking about addresses now).
ok yeah, let me change them, my bad
Sorry, I think I'm getting confused by your variable names
The situation I'm describing is setting `multisigTokenAcct` as the signer vs. `arbitraryTokenAcct` as the signer
In this case, we have :

```
let multisigTokenAcct = await mintA.createAccount(arbitraryTokenAcct.publicKey);

await program.rpc.initializeTokenAcct(
      {
        accounts: {
          tokenProgram: splToken.TOKEN_PROGRAM_ID,
          multisigTokenProgram: multisigTokenAcct,
          multisig: multisig.publicKey,
          intializer: arbitraryTokenAcct.publicKey,
        },
        signers: [arbitraryTokenAcct],
      }
    );      
```

We have `multisigTokenAcct` that is the "account" in this case. But we also have `arbitraryTokenAcct` that's the "owner" of the `multisigTokenAcct`.
What do you mean by have the owner program be a signer?
so that account can be a "signer", but you can also have the owner program be a "signer". Is there a difference between account signing vs. logical owner/program authority signing?
what's confusing here is for any given account, you have the account's own keyPair as well as a program that owns the account
But in general, the program that owns an account can do whatever it wants with it, no signature necessarily required
In this case, the spl token program won't let you change the authority unless the current authority signs, as a way of saying "yep yep I'm cool with this"
Not necessarily, no. Signing in solana is only required if the account's owning program demands it.
The key here is that I needed to pass in `signers: [arbitaryTokenAcct]`  and mark `pub intializer: AccountInfo<'info>,` with `#[account(signer)]`. This makes sense given that we are changing the `arbitaryTokenAcct/intializer` authority. Is it correct to generalize that for any `TokenAccount` or `Account` that you modify (e.g. in this case we are updating the owner), you need to mark the account's authority/logical owner with the signer tag?
```
pub fn initialize_token_acct(ctx: Context<InitializeTokenAccount>) -> Result<()> {

        msg!("initialize token acct starting");
        msg!("multisig_token_program.owner is {:?}", ctx.accounts.multisig_token_program.owner);
        msg!("ctx.accounts.intializer is {:?}", ctx.accounts.intializer.to_account_info());

        let token_accounts = SetAuthority {
            current_authority: ctx.accounts.intializer.to_account_info().clone(),
            account_or_mint: ctx.accounts.multisig_token_program.to_account_info().clone()
        };

        msg!("set token_accounts: ");

        let cpi_program = ctx.accounts.token_program.to_account_info();

        msg!("set cpi_program: ");
        msg!("{:?}", cpi_program);

        token::set_authority(
            CpiContext::new(cpi_program, token_accounts),
            AuthorityType::AccountOwner,
            Some(ctx.accounts.multisig.key()),
        )?;

        msg!("set authority complete");
        msg!("{:?}", ctx.accounts.multisig_token_program.to_account_info());

        Ok(())
    }

#[derive(Accounts)]
pub struct InitializeTokenAccount<'info> {
    #[account(signer)]
    pub intializer: AccountInfo<'info>,
    pub token_program: AccountInfo<'info>,
    #[account(mut)]
    pub multisig_token_program: Account<'info, TokenAccount>,
    pub multisig: Box<Account<'info, Multisig>>,
}
```
What's working is:

```
mintA = await splToken.Token.createMint(
      program.provider.connection,
      payer,
      mintAuthority.publicKey,
      null,
      0,
      splToken.TOKEN_PROGRAM_ID
    );

    let multisigTokenAcct = await mintA.createAccount(arbitraryTokenAcct.publicKey);

    await program.rpc.initializeTokenAcct(
      {
        accounts: {
          tokenProgram: splToken.TOKEN_PROGRAM_ID,
          multisigTokenProgram: multisigTokenAcct,
          multisig: multisig.publicKey,
          intializer: arbitraryTokenAcct.publicKey,
        },
        signers: [arbitraryTokenAcct],
      }
    );
```
ah got it
Ah ok I would suggest not calling that `_program`, since that pretty much universally means an actual executable program in solana
I did manage to get the program to work
`multisig_token_program` is the token account that's set up like so:

```
 mintA = await splToken.Token.createMint(
      program.provider.connection,
      payer,
      mintAuthority.publicKey,
      null,
      0,
      splToken.TOKEN_PROGRAM_ID
    );

let multisigTokenProgram = await mintA.createAccount(arbitraryTokenAcct.publicKey);
```
I'm confused about the name `multisig_token_program`‚Äîwhich program is that?
It's the account of the program you want to call‚Äîhere you're fiddling with a token account, so you need to ask the token program to do the mutation for you (in solana, every account has a program owner, and only that program is allowed to mutate the account's data or spend the account's lamports‚Äîhere you want to mutate the token account so you can change its `.owner` field)
The cpi_program needs to be `ctx.accounts.token_program.to_account_info()`
Ok, set_authority requires the *old* authority to sign (since its relinquishing its authority)
this doesn't have any output
trying to better understand how `set_authority` works here
Ah, ok
doing this as an exercise
I think I've forgotten why you want to change the authority to the multisig signer, rather than just having it be that to begin with
That's how you would make a token account for mintA, whose owner is the multisig signer PDA.
Why wouldn't it be `mintA.createAccount(multisigSigner)`?
Can't, BN is purely for big integers
see .anchor/program-logs/
like `anchor test --verbose` or something?
Is there a way to get the program log to print even if the test case passes?
https://github.com/project-serum/anchor/tree/3958533750c83c3e90709448c4f30ed9cce0b9b8/tests/events
any good examples or docs around `emit`?
gotcha, thank deep
`msg!("huhu");`
`msg!("hello")`?
how do I log stuff in my anchor program?
Lets say I want to check that an account is initialized and if not modify a few variables in a different account (both of which are passed in), is there a way I can check if the account is init'd inside the actual function instead of with the anchor macros setup? Right now if the account is not init my code inside the func does not get ran
ohh, got it, ty !
it's basically a transformation between objects
`.into()` is the opposite of `from`, so check if there is code that does `impl From<&...> for ProxyMintToAccount>`
what does it mean when they use .into() ? Why they don't specify the exact account ?
ty
wewt: `     Error: 3012: The program expected this account to be already initialized`
ofcourse
gotcha, but id need to pass in the seeds/bump right
yes, if you **don't** pass `init` it expects the PDA to be initialized
another turbo noob question, is there a way for an on chain program to check if a passed in PDA is initialized?
Are having constraints in the `account` macro less costly than having them in context execution?
Now I have the `intializeTokenAcct` function set up like so:

```
pub fn initialize_token_acct(ctx: Context<InitializeTokenAccount>) -> Result<()> {

    msg!("initialize token acct starting");
    msg!("multisig_token_program.owner is {:?}", ctx.accounts.multisig_token_program.owner);

    let token_accounts = SetAuthority {
        current_authority: ctx.accounts.multisig.to_account_info().clone(),
        account_or_mint: ctx.accounts.multisig_token_program.to_account_info().clone()
    };

    msg!("set token_accounts: ");

    let cpi_program = ctx.accounts.multisig.to_account_info();

    msg!("set cpi_program: ");
    msg!("{:?}", cpi_program);

    token::set_authority(
        CpiContext::new(cpi_program, token_accounts),
        AuthorityType::AccountOwner,
        Some(ctx.accounts.multisig_signer.key()),
    )?;

    msg!("set authority");

    Ok(())
}
```

1/ I'm having a bit of trouble figuring out what the cpi_program should be here to properly invoke `token::set_authority`. What I've seen in other examples where we are doing something similar is passing in the `SplToken::TOKEN_PROGRAM_ID`, is that the same case ehre?

2/ Given "> The point of the multisigSigner PDA is that it's the thing that will sign if the multisig conditions are met", is my logic correct in that we want the multisig_signer to be the authority on `multisig_token_program`?


//////////////////////////////////////////////////////////////////////////////////////////

#[account(...)] inside derive(Accounts) lets you specify constraints/random stuff about the accounts, e.g. `mut` means we need writable access to this account
#[account] over a struct says: our program is going to manage some accounts that store the following struct (once it has been serialized to bytes).
Ah yes, this is where Im getting confused..the #account over a struct vs it being used when initialising the variables
Ah, maybe another point of confusion is that #[account] over a struct is a totally different macro from `#[account(....)]` inside derive(Accounts)
So say if I did not want the `vote_account` to be mutable, in that case would it fine to remove the `#[account(mut)]`  on top of it...as my `VoteAccount` struct already has the `#[account]` attribute and the `vote_account` varibale is created from `VoteAccount` itself ?
As for rust stuff, yeah, you're going to have to learn rust decently well to be able to do anchor/solana stuff. E.g. the rust book, or Programming Rust 2nd edition are both good.
The `#[account(mut)]` thing is anchor-specific, and means that when the client invokes your contract, it needs to tell solana that it wants exclusive/writable access to that account. It's not the same thing as rust's `mut` keyword (anchor uses the same name since, yeah, it's kind of similar in intent).
Hi, have been going through some code in Anchor-framework, had a question on the usage of  `#[account]`  attribute:

Consider the snippet below:  
```#[account]
pub struct VoteAccount {
    pub crunchy: u64,
    pub smooth: u64,
}
```
From what I understood, in  the above code snippet, we are saying that I need a VoteAccount data-type which will contain 2 variables..  

Now, consider the function which is called: 
```#[derive(Accounts)]
pub struct Vote<'info> {
    /// Marking accounts as mut persists any changes made upon exiting the program 
    #[account(mut)]
    pub vote_account: Account<'info, VoteAccount>,
}
```
Here we are marking the `pub vote_account` with the `#[account(mut)]` as well. 
Why is this required? 
When the `vote_account` variable is of type `Account(VoteAccount)` , do I need to again mark the variable with the attribute? 
Is it done only because of I need it to be mutable (`mut`) ? Say I did not want it to be mutable, in that case, would removing the line be fine?  

Also I think my doubt arises from being a beginner in Rust ( and hence Solana / anchor ),  I wanted to know if this is a rust level thing or a anchor-framework level thing, i.e. what should I read on more, to better understand this ?
hm, yeah, you can filter the accounts but idk how to do it properly here
That's a RPC command
You can do it using `memcmp` on `getProgramAccounts`
ok
Don't think so, you'll have to just filter the result of calling `.all()` as far as I know
is it possible to somehow filter to return only accounts for given user
tho it looks like the mint in my program is working just fine, so it must be some other account
Thanks!
cc <@!430802284742574101> ^^^
fyi, if you get a writable privilege escalated on a burn or mint cpi call, make sure the mint account you pass is mutable
I think the next version of solana will let you add extra space on the fly, but currently you can't
so if my init account is full, how can I get more?
I need some help with `Signature verification failed` - I created a mint using the client, and I am attempting to create a user derived ATA. I derived the ATA with:
```
  const seeds: Buffer[] = [
    ownerPubKey.toBuffer(),
    TOKEN_PROGRAM_ID.toBuffer(),
    mintPubKey.toBuffer(),
  ];
  const programId: PublicKey = ASSOCIATED_TOKEN_PROGRAM_ID;
  return utils.publicKey.findProgramAddressSync(seeds, programId);
this returns: [ataPubkey, ataBump]
```
When sending with 
```
    new Transaction().add(
      SplToken.createAssociatedTokenAccountInstruction(
        ASSOCIATED_TOKEN_PROGRAM_ID,
        TOKEN_PROGRAM_ID,
        mint.publicKey,
        ataPubkey,
        user.wallet.publicKey,
        user.wallet.publicKey
      )
    );

  // sign and send txn 
  txn.feePayer = user.wallet.publicKey;
  txn.recentBlockhash = (
    await provider.connection.getLatestBlockhash()
  ).blockhash;
  const signedTxn: web3.Transaction = await txnWallet.signTransaction(txn);
  const res: string = await provider.send(signedTxn);
  const conf: web3.RpcResponseAndContext<web3.SignatureResult> =
    await provider.connection.confirmTransaction(res);
```
I get Signature verification failed
Absolute max is 10mb, but for `init` it can only be 10kb
for the init account
How much space is the max?
If there are, then PDAs are great!
Yeah, just depends on whether there are natural seeds in a given situation
in all examples they store info in a normal accounts
so why would i store escrow_data in a normal account rather than in PDA? Because PDA has a big plus that we can find escrow_accounts by seeds. And i don't see any drawbacks
But yeah, you don't have any way to "guess" all of the addresses (they're random)
You can still do `await program.account.escrowAccount.all()`
yeah...so if i am using keypairs there is no way to list for example all users escrow_accounts
Seeds only apply to program-derived addresses, not keypair addresses
You would need to pick a hashing algorithm on both the client as well as in you rust program (like, sha256 or something)
am i still able to pass seeds as well ?
oh thanks a lot! I will run some tests on this!
`username.as_bytes()`
ohkay.... could you tell me how i could hash the string?
Yeah max seed length as a &[u8] is just 32
the trait bound `std::string::String: std::convert::AsRef<[u8; 9]>` is not satisfied

username.as_ref() gives this error
But yeah ^ that's how you would do it!
Strictly speaking you can use strings, but individual seeds can't be very long (looking up how long)
You should probably just hash the username first and then use that as the seed
i just learned this recently
in the lib.rs file, you would have to pass the String as an argument to the function you wish to call i.e. ```pub fn initialize_user(ctx: Context<InitializeUser>, username: String, ...) ```
then in the ``` #[derive(Accounts)] ``` for this method, you would have to add an instruction macro to retrieve this value from the arguments and pass it into the seeds for the account 
``` #[derive(Accounts)]
    #[instruction(username: String)]
    pub struct InitializeUser<'info> {
     #[account( init, seeds = [username.as_ref(),... ```
Is there a way I can pass a string in a seed of a PDA? like i need to store usernames which need to be unique.. how do I do that?
thank you man ‚ù§Ô∏è
Yep
ohhh, so user just passes an empty account and in ```init``` method our program takes its ownership, so from now on only our program can change account fields
Just because you can sign for an account's address doesn't mean you can just randomly mutate the account itself (that's up to the account's owning program)
*Only* the program can mutate an account it owns‚Äîso having access to the keypair is irrelevant unless the program specifically asks you to sign for something
That's actually not the way solana works: you need the private key to create the account (solana makes you sign with the address of an account you're creating), but whether or not that private key has any subsequent use depends entirely on the program
but how it is safe? User generates Keypair -> passes it as an escrow_account -> program writes to an escrow_account. But because user generated the keypair he has private key and he can change info at any time
No, PDAs and keypair addresses just have different usecases.
i mean that now most of the projects hold info in pdas rather than old keypairs or not?
What do you mean by outdated?
it is outdated to hold info in these accounts, right?
That account apparently isn't using a PDA at all, it's just using a regular old keypair address
Because we can find pdas by their seeds and what seeds is used here?
hm, it does not use any seed for the EscrowAccount. So how we can find it in the client side?
If anyone have the issue `thread 'main' panicked at 'Code not parseable: Error("invalid type")', lang/syn/src/idl/file.rs:353:58`:
```rust
// Working
#[account(zero_copy)]
pub struct SomeAccount {
    pub info_accounts: [u8; 32],
}

/// Not Working
#[account(zero_copy)]
pub struct SomeAccount {
    pub info_accounts: [u8; 32],
}
```
Somehow rustdoc comments break the IDL generation.
it's an early version of the feature so i'm sure it'll be fully integrated and documented soon
That comment shows how to turn it on I guess, but I haven't tried it because I couldn't find any guidance beyond this.
ty i was just looking through github for this loll
https://github.com/project-serum/anchor/issues/1004#issuecomment-1020478661
ohhh i see. i was referencing Anchor's recent twitter post and thought we no longer needed it since they didn't use it. but the .methods is still an improvement
You still get the benefit of using `.methods` which is much cleaner.
I didn't use that and still send up the pda's since the pda stuff was disable by the flag and I couldn't find docs or examples for it.  I figured that means it's still being baked by the time.
the error is: ``` Error: Invalid arguments: post not provided ``` where post is a Post account that will be a PDA
What's the error exactly?  Are you trying to use the new pda stuff that you need to turn on with a feature flag?
hey everyone so i recently upgraded to anchor v0.21.0 and when i try to use the program.methods  on the client side call to initialize a PDA, i'm getting an error that the PDA account is not provided. to my understanding in this version it was no longer needed so is there any way i can resolve this? thanks!
So I'm packaing the idl/types in my own client library and not using idl fetch an workspaces because it wasn't clear to me how it works when using it with the frontend project.  Is there an example that shows "the right way"  Also, my actual contract tests use this library since there's endless boilerplate for setting up program state.  The `cfo` example is the closest thing I've seen to a real world setup but stops short of creating a consumable package for a front-end or other project.
Oh, missed that reply while I was typing. Didn't mean to repeat what you already said.
Yeah, just instead of typing `anchor test`, instead type `./anchortest`
If "dumb" unblocks me, it ain't dumb. üòõ
Sorry, was trying to get cute
Oh, nope lol
And then change your Anchor.toml's `test` command to be `test = anchortest`
This is definitely dumb, but you could also make that `anchortest` file I mentioned above (modified to copy stuff, or whatever)
In general I can't find the golden path of using idl / workspaces espcially when TypeScript is in the mix
Well, it means I always need to do `anchor build --idl <output> & anchor test` anytime I run tests.  I guess that could work.  Should we be able to specifiy idl location in `Anchor.toml`?
(Or maybe I'm just unclear on why the idl needs to be in a particular place‚Äîhaven't tried doing this before)
Ok, can you just copy the idl? So it lives in both places (dumb, but probably works)
Thanks for the response.  I've been trying to do gymnastics in a shell script, but `anchor.workspace` seems to get messed up unless the idl is in the target folder.
Like
```.sh
# in file anchortest
anchor build --idl whatever
anchor test
```
the one in tests uses init https://github.com/project-serum/anchor/blob/222c6e3e55daa12cbca09dd634dc83b333524413/tests/escrow/programs/escrow/src/lib.rs#L113
Ok, yeah, doesn't look like the `test` command currently supports this. As a workaround in the meantime, can you not just write your own little script that orchestrates things?
Agree, confused me a lil bit
Is that the anchor escrow tutorial? Don't think there's any particular reason to use `account(zero)` there ü§∑‚Äç‚ôÇÔ∏è
Bumping question again - Anyone know how to get `anchor build` and `anchor test` to place the idl and types in a separate folder?   `[workspace]` with `types` in `Anchor.toml` works with the TypeScript types, but idl ouput does not appear to work there.  `anchor build --idl` works, but `anchor test --idl` is an invalid flag.  Really really would appreciate help on this
But yeah, maybe that explanation is the only use cases
Hm, because I‚Äôm wondering why they use it instead of just using init
I didn't find any place to read about it other than the source, but got some help on it recently https://discord.com/channels/889577356681945098/889702325231427584/942554503239073802
I see, thanks
`.push(*test)` (or figure out why you only have a reference to it, rather than an actual value
I'm new to rust, anyone knows how to solve this?

Not sure where you can read about it, but what it does is say "anchor, don't freak out that this account doesn't have any discriminator bytes yet‚ÄîI created it in a separate instruction and am now initializing it with this one"
Ah, not sure (tbh I haven't actually used the anchor docs before, just lots of source-diving)
im using version 0.21.0 and thought i no longer needed to include the PDA on the client side, however it would give me an error so i added it back. i believe the client side is on the correct version since i used the program.methods approach but im unsure
thank you!
Any idea of what's going on?
Hello, when I add an array in an account struct I get this error (during IDL generation it seems): `thread 'main' panicked at 'Code not parseable: Error("invalid type")', lang/syn/src/idl/file.rs:353:58` I tried a lot but any array size of any type gives this while doing the same in another project works...
Is it even possible for a custom program error to be this big?
I'm doing a CPI with Serum Dex and I am seeing this error: 
`Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: custom program error: 0x10005d4`
thanks a lot <:PoggersLove:825149316795596821>
Here's an example from a recent project. Based on a very good anchor tutorial on Buildspace. I'd 100% recommend
Hello everyone Does anybody know where to find an example of Exchange NFT for SOL with a smart contract?
in what format do I pass values from js to it?
if my function has a: Vec<Custom> argument and: 
pub struct Custom {
    pub pk: Pubkey,
    pub nr: u16,
}
A few things here, for the account is already in use - You can use `init_if_needed` if there is no initialization assignment. If there is, then it‚Äôs best to create a separate `initialize_post` instruction.

However, it seems like you‚Äôre trying to make each post‚Äôs PDA  unique. In which case, you should use something unique for seeds. You are currently using a string constant, which means this PDA is effectively a singleton. You can use something deterministic, such as using `post_content` as one of the seeds. 

Lastly, in anchor 0.21.0 you won‚Äôt need to pass in the PDA on client side, it will be automatically determined by anchor so the developer ergonomics are much better.
Yes but you must serialize the instructions yourself
Hey, where can I read about #[account(zero)] tag?
is there any way to decode a transaction to figure out what exactly changed in a program account? I have a program account that has a counter, and I want to know which transaction was the one that bumped the counter to a certain value
https://solanacookbook.com/guides/account-maps.html#deriving-pdas - also a good example
hey everyone im trying to work with PDAs and i'm a bit confused on the concept of seeds and bumps. 
i'm trying to create a test program where a user can create a post and each post gets a PDA.  i'm unsure how to generate seeds to accomplish this

this is the code i currently have in TS for creating a post
```
[postAccount, postAccountBump] = await anchor.web3.PublicKey.findProgramAddress([Buffer.from("post")], programId);

const tx = await program.methods.createPost(
      postContent,
    ).accounts({
      post: postAccount,
      authority: user.publicKey,
      payer: provider.wallet.publicKey,
      systemProgram: anchor.web3.SystemProgram.programId
    }).signers(user).rpc();
```
here is the anchor code i have for the method
```
#[derive(Accounts)]
pub struct createPost<'info> {
    #[account(
        init, // hey anchor, initialize an account w/ these details (rent exempted)
        seeds = [b"post".as_ref()],
        bump,
        payer = payer, 
        space = 8 // all accounts require minimum 8 bytes
                + 32 // public key space
                + 560 // 560 bytes: 140 character count for content
character count for each
    )]
    pub post: Account<'info, Post>,
    #[account(mut)]
    pub authority: Signer<'info>, // this signer
    pub payer: AccountInfo<'info>, // this account will pay for the transaction
    pub system_program: Program<'info, System>
}
```
currently when running this code, the first post can be created, but any other post generates an error: ```account is already in use```
i thought about adding some additional string value for the seed but i'm unsure how to approach this. i appreciate any help! ty
Is there an exhaustive list of inputs to pass into RPC calls? FFT point me to source code/documentation cc <@!134416332509675520> just a gentle bump ICYMI
no worries - I think this is the better way https://discord.com/channels/889577356681945098/889702325231427584/943681775371190324
Just woke up, thx for the info üôè
Use `constraint` at the time of account deserialization
What is the idiomatic way to gate a particular program function to be only called by specific pubkeys?
Does anyone know if the Solana rpc api can call custom programs ?
Ok thanks. I'm a little confused; how is the total allowance of compute units calculated? I'm wondering if the bottleneck in my program is the amount of space allocated to the baseAccount that the program is storing data on, or the compute units of the program itself. Does that make sense?
How do you wrap SOL? When I send SOL to an associated token account with SystemProgram.transfer, it adds the SOL to the rent-exempt reserve, not the token balance. Is there a way to transfer SOL into a wSOL token account?
Bump on idl generation.  Trying not to @
I think this is actually a better way to handle this that makes better use of the feature:
```rust
let auth_seeds = ["auth".as_bytes(), &[ctx.bumps["authority"]]];

#[account(seeds = ["auth".as_bytes()], bump)]
pub authority: AccountInfo<'info>,
```
https://github.com/glyfo/glyclt-solana
Hi , I am working in a simple project to put all Solana & anchor binaries into the container  . Now I am working in anchor build - deploy & test . Any advice or feedback is welcome. This is a public repo
~~my `program.account` is coming back as an empty object in my Anchor client, but when i directly `getProvider().connection.getAccountInfo(...)` it comes back -- any tips for debugging?~~

found it, IDL issue
It's possible that this might not be exportable to IDL? Definitely can work around
Bueller?
`pub struct`
it is public right?
wait
ü§¶‚Äç‚ôÇÔ∏è thank you sir
Is the type public?
so i created a wrapper for a struct:
```
#[derive(Clone, AnchorDeserialize, AnchorSerialize)]
pub struct TokenMetadata(mpl_token_metadata::state::Metadata);
```
but it‚Äôs not showing up in the IDL. Is there something special i need to do? I‚Äôm just pattern matching anchor/token.rs
$5 bounty to anyone who can tell me how to get idl generated out of target and be respected by both anchor build and anchor test
so I always have to do anchor build before anchor test if I want my idl to live elsewhere?
I've been blocked by an hour on this just so I can start wiring up my UI.
ugh, and anchor test does not have an `--idl` option for output either.
Ah, no, `owner` doesn't have anything to do with program-derived addresses‚Äîit's about checking which program owns the account (these are two totally separate concepts)
```
[workspace]
idl = "client/src/idl"
types = "client/src/idl_types"
```

For Anchor.toml, should the above put the idl in the correct directory?  This doesn't appear to work.   The types are placed in the correct directory but not the idl
<@!134416332509675520> Interesting, based on my interpretation, the check doesn't seems to verify that the givens address are derived from any programId. The `Field` struct contain a `Ty` field that i'm interpreting as `the type of the account the field belong to` and the match clause on this `Ty` take into account type as `Signer` or `AccountInfo` and for the `container_ty` look like the same... it's doesn't seem to be restricted to program derived address. But as you said it's tricky to read. Then maybe I'll just do some test to check my assumption
Sorry for the dumb question, I'm new to Solana, and I am trying to build my helloworld solana app using Anchor. I am on aarch64 (docker container on M1 Mac). When I do `anchor build`, it appears that it tries to download the BPF SDK into `/root/.local/share/solana/install/active_release/bin/sdk/bpf`. However, I _think_ it installs the bpf tools in x86_64, which causes the command to error out with `qemu-x86_64: Could not open '/lib64/ld-linux-x86-64.so.2': No such file or directory`
Soon this will change a bit, you'll be able to request more units, etc.
Solana actually doesn't currently have gas like ethereum; your program just gets a fixed cap on how much work it can do, and if you run out of "compute units" then your transaction gets killed.
normie question here: what is compute units referring to on solana explorer?
Maybe slightly tricky to read, but this is how the owner constraint works (it's not doing anything fancy): https://github.com/project-serum/anchor/blob/master/lang/syn/src/codegen/accounts/constraints.rs#L255
<@!703647911770062878> thanks, that what's I understand, currently i'm using the constraint this way. 
```rust
    constraint = base_config.authority == signer.key()
```
Just hoping that owner could give me a shortcut. Look like this is not the case
[moved question to <#889584618372734977> ]
I believe a Program is the only entity which could modify an Account. Users with keypairs can sign transactions but ultimately they send those instructions to Programs to be executed. If you want to make sure only a given wallet can modify some data, you can have your Program own the account and only update the data there if that wallet signs a given transaction.
Hello,
When I'm reading the rust doc, I understand that the `owner` constraint can be used to specify another program address as the owner of the account. 
Can I use the `owner` constraint to specify a owner that is not a program?
Failed 3 times in a row...
I recently upgraded to solana v1.9.5 for my cli, and now when I do anchor test it takes 2 mins and often gives me this error:

```=====================================================================================
Recover the intermediate account's ephemeral keypair file with
`solana-keygen recover` and the following 12-word seed phrase:
=====================================================================================
XXXXXXXX
=====================================================================================
To resume a deploy, pass the recovered keypair as the
[BUFFER_SIGNER] to `solana program deploy` or `solana write-buffer'.
Or to recover the account's lamports, pass it as the
[BUFFER_ACCOUNT_ADDRESS] argument to `solana program close`.
=====================================================================================
Error: Custom: Invalid blockhash
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }.```
thanks <:prays:941677067622305803>
Alas, you can't. In solana you always have to pass any relevant accounts in from the client, not possible to just dynamically fetch them from within your program.
if it has any
how can I inside the anchor program, with the Pubkey get the token accounts from that key
Can you say more? Not sure what you mean
you see the update_vote fn, do you know (or can you point me in a direction) how I could get the token accounts from the pk ?
It's working
<:yay:746135853688029274>
üòõ
thanks
<:kek:833489500835282974>
I can't tell from that screenshot, do you remake the account after you delete it?
creating the proposal/updating and removing it works perfectly

How are you checking that?
yes
Ok, well, is that acc.publicKey actually pointing at a previously-initialized account?
My bad
Oh, urgh, I can't read
no
Are you trying to init that account?
Why are you adding `acc2` to the signers array?
acc2 is the random wallet

I wrote a little vote program, so one user creates a proposal  and everybody with a sol wallet can vote (no restrictions - yet). When I test it with a random user wallet, it says "The program expected this account to be already initialized"
I'm new too, so somebody else might want to chime in, but I think it mostly just depends on how many different accounts you might end up wanting to create, i.e., one per program, one per user, or something else. If it's just one for the program, then I think you're ok with just that single constant as the seed. I have one in a current program that is just one per program and ended up doing:
```rust
        let auth_seeds = [
            "pda".as_bytes(),
            &program::Nftfactory::id().to_bytes(),
            &[auth_bump],
        ];
```
If you had one per user, you might add in the key of the user into the array of seeds. You can disregard the use of `auth_bump` here - this was for a set of seeds for another cpi instruction that wasn't handled automatically by anchor.
Here was an anchor one dependent on user:
```rust
    #[account(init, payer = payer, seeds = [payer.key.as_ref()], bump, space = User::LEN)]
    account: Account<'info, User>,
```
Ahhh, I‚Äôm not confident with seeds and bumps. What seed should I pass? Like in the example?
```seeds = [b"token-seed".as_ref()],```
Keeping it fixed for different mints is ok?
You can add it after the `remainingAccounts: [...], signers: [...]`
How do I pass the `signers` array in here? would it be via the `executeTransaction`? Or at the `createTransaction` level?
I created a program with a cpi to the mpl-token-metadata program to create a metadata account and the total program size ended up being bigger than the entire mpl-token-metadata program. Is that just a function of what my program used or am I importing more than I need?
https://github.com/CalebEverett/nftfactory/blob/master/programs/nftfactory/src/lib.rs
this is the program data:
https://explorer.solana.com/address/9q8FtaxK7K3Wq3Qb35u3Qw3ZjHGf7f21HC6vPdwE4rmE?cluster=devnet
this is the program data for the token metadata program:
https://explorer.solana.com/address/PwDiXFxQsGra4sFFTT8r1QWRMd4vfumiWC1jfWNfdYT?cluster=devnet
`isSigner` means "this thing *needs* to sign"
When you set the multisig's `isSigner` to true, that means that you then actually need to sign for it by sticking its keypair in the `signers` array
No program log, so I guess it's on the client side. I have the multisig `isSigner` set to true which is what's confusing here
```
  Tests out sending sol / tokens around
    1) SOL send: multisig -> arbitrary account works


  0 passing (2s)
  1 failing

  1) Tests out sending sol / tokens around
       SOL send: multisig -> arbitrary account works:
     Error: Signature verification failed
      at Transaction.serialize (node_modules/@solana/web3.js/lib/index.cjs.js:2829:13)
      at Provider.send (node_modules/@project-serum/anchor/dist/cjs/provider.js:89:26)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at async Object.rpc [as executeTransaction] (node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:31:31)
      at async Context.<anonymous> (tests/tokens_multisig_tests.js:505:5)
```
In particular, the error looks like
```
const accounts = [
      {
        pubkey: multisig.publicKey,
        isWritable: true,
        isSigner: true,
      },
      {
        pubkey: ownerA.publicKey,
        isWritable: true,
        isSigner: false,
      },
    ];

// 0.2 SOL * LAMPORTS/SOL
    const amountToMove = new anchor.BN(0.2 * 1000000000)

    const data = program.coder.instruction.encode("send_sol", {
      amount: amountToMove,
    });

await program.rpc.createTransaction(pid, accounts, data, {
      accounts: {
        multisig: multisig.publicKey,
        transaction: transaction.publicKey,
        proposer: ownerA.publicKey,
      },
      instructions: [
        await program.account.transaction.createInstruction(
          transaction,
          txSize
        ),
      ],
      signers: [transaction, ownerA],
    });

    // Other owner approves transactoin.
    await program.rpc.approve({
      accounts: {
        multisig: multisig.publicKey,
        transaction: transaction.publicKey,
        owner: ownerB.publicKey,
      },
      signers: [ownerB],
    });

    let preMultisigBalance = await program.provider.connection.getBalance(multisig.publicKey); 
    let preTxnAcctBalance = await program.provider.connection.getBalance(ownerA.publicKey);

    // Now that we've reached the threshold, send the transactoin.
    await program.rpc.executeTransaction({
      accounts: {
        multisig: multisig.publicKey,
        multisigSigner,
        transaction: transaction.publicKey,
      },
      remainingAccounts: program.instruction.sendSol
        .accounts({
          multisig: multisig.publicKey,
          receiver: ownerA.publicKey,
        })
        .map((meta) =>
          meta.pubkey.equals(multisig.publicKey)
            ? { ...meta, isSigner: true }
            : meta
        )
        .concat({
          pubkey: program.programId,
          isWritable: false,
          isSigner: false,
        }),
    });
 ```
code is the multisig, rest looks like:

```
 pub fn send_sol(ctx: Context<SendSol>, amount: u64) -> Result<()> {

    **ctx.accounts.multisig.to_account_info().try_borrow_mut_lamports()? -= amount;
    **ctx.accounts.receiver.to_account_info().try_borrow_mut_lamports()? += amount;

    Ok(())
} 

#[derive(Accounts)]
pub struct SendSol<'info> {
    #[account(mut, signer)]
    pub multisig: Box<Account<'info, Multisig>>,
    #[account(mut)]
    pub receiver: AccountInfo<'info>,
}
```
üëã Having a signature verification failed error üòï
Probably
I use vscode + rust-analyzer, it seems to handle hop-to-source fine
is this error possible due to the space in the base account being all used up? Thanks in advance smart ppl "Failed to serialize account"
you do have to have the seeds feature on though, I believe with 
```
[features]
seeds = true
```
in your `Anchor.toml`
yes, they get added to the idl - you can check the json file in `target/idl/<myprogram>.json` and then I believe put into a hash in the context at `.bumps` so they can be determined automatically - pretty sweet
I recently upgraded to solana v1.9.5 for my cli, and now when I do `anchor test` it takes 2 mins and often gives me this error:
```=====================================================================================
Recover the intermediate account's ephemeral keypair file with
`solana-keygen recover` and the following 12-word seed phrase:
=====================================================================================
XXXXXXXX
=====================================================================================
To resume a deploy, pass the recovered keypair as the
[BUFFER_SIGNER] to `solana program deploy` or `solana write-buffer'.
Or to recover the account's lamports, pass it as the
[BUFFER_ACCOUNT_ADDRESS] argument to `solana program close`.
=====================================================================================
Error: Custom: Invalid blockhash
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }.
```
oh, awesome. so it will be autogenerated?
you can just pass `bump` as an arg instead of `bump = vault_account_bump`
i need to pass it to the instruction? but where can i get it?
hey, how to get this bump seed? It is needed for account creation, im following: https://hackmd.io/@ironaddicteddog/anchor_example_escrow
they were on context:
```
rent: ctx.accounts.rent.to_account_info()
```
Also, general question: do any of y'all have recommended editor set ups? I find myself doing a lot of source diving and wondering if there's an easy way to link the SPL/Solana/Anchor libraries with the project you are currently working on. I want to be able to click through certain definitions but that isn't possible right now. I'm using VSCode
Is there an exhaustive list of inputs to pass into RPC calls? FFT point me to source code/documentation
If I need to pass sytem and rent accounts on to a cpi, how can I access them from the passed in context if using the methods api where they aren't passed in from ts?
what's the best practice for storing strings in accounts so the size is predictable and can be padded if less than max size?
thanks, let me try
I think there are M1 binaries now, but I'm not sure‚ÄîI install everything from source, yeah
solana return "solana-test-validator" [1]    84132 illegal hardware instruction  solana-test-validator
So problem might be come from solana, should I build solana from source, I used the bash script they providing to install
(There's also a `postInstructions: [...]` thing)
The `instructions` thing lets add some additional instructions to the transaction, which will run *before* your rpc instruction
`signers` says make these keypairs sign the transaction (the corresponding accounts will show up in your rust program with their `is_signer` flag set)
Mm, I think your solana isntall is probably messed up. Just to double check, are you able to start a local validator? `solana-test-validator`
Hi everyone, I tried to run `anchor build` program at M1 device but I got 
```
BPF SDK: /Users/anduc/.local/share/solana/install/releases/1.9.6/solana-release/bin/sdk/bpf
cargo-build-bpf child: rustup toolchain list -v
cargo-build-bpf child: cargo +bpf build --target bpfel-unknown-unknown --release
error: failed to run `rustc` to learn about target-specific information

Caused by:
  process didn't exit successfully: `rustc - --crate-name ___ --print=file-names -C lto=no --target bpfel-unknown-unknown --crate-type bin --crate-type rlib --crate-type dylib --crate-type cdylib --crate-type staticlib --crate-type proc-macro --print=sysroot --print=cfg` (exit status: 1)
  --- stderr
  error: Error loading target specification: Could not find specification for target "bpfel-unknown-unknown". Run `rustc --print target-list` for a list of built-in targets
```
Anybody know how to solve this?
Hi all , I am building a simple project put all binaries into the container to develop in anchor . https://github.com/glyfo/glyclt-solana , but I have some doubts about # anchor test. Requirement .


//////////////////////////////////////////////////////////////////////////////////////////

is there a way to extract the inferred type?
Ugh, I want to write a utility for this in a pull request but it will likely be the wrong route.  TypeScript gets really gnarly with recursive type hierarchies and you run into their heuristic limits that are hard-coded in the compiler.  It's much better to just code gen the types at build time and call it a day since that's what anchor is already doing anyway.
yeah similar issue, `useState<WHAT ARE YOU>(...)`
The problem is that I want to take these results and store them in my state store for the UI, and I gotta label that thing with a type, etc.
haha yup, hence sadface
Heh, yeah, but that kind of defeats the point of all this typescript generation to an extent.
having the union isn't the end of the world for me, better than `any`
you could always write your own type and cast it üò¶
Yeah, weird, right?  I see why it's written this way, but having dealt with similar situations it is usually better to decouple the type transformation into their own types or have the code generation do a chunk of it
thought it was good, but now i realize it's the union like you said
the inferred type is all good when calling fetch, but i hadn't been able to produce the same type with TypeDef so i tried the other route
ah i see what you mean actually, yeah dotting into an account it has all the properties across accounts
is that the type setup that you've got ^?
```type MyProgram = anchor.Program<MyProgramGeneratedTypes>;
type Base = Awaited<
  ReturnType<MyProgram["account"]["base"]["fetch"]>
>;```
That's the same issue I was facing with my type derivation too.
`type Game = Awaited<ReturnType<Program<MyProgram>['account']['gameAccount']['fetch']>>`  Game here is a union of all the account types defined in my program
At least that's what VSCode is claiming
Ah, I needed `Program<MyProgram>` still - that spits out a union type not a specific account type
what do you have MyProgram set as?
Trying yours first since you know it works - I'm getting `Property 'account' does not exist on type 'MyProgram'`
can you share the code you've got? that should work
Yeah, that's where I started, but I can't seem to get it to not be a union of all account types
i'm sure there's a better way to accomplish this, but here's what i've got working: `type Base = Awaited<ReturnType<YourProgram["account"][<account name>]["fetch"]>>;`
It's weird - the types for the idl are more metadata for type generation rather than "types"  It seems `Program<T>` does type transformations on it to spit out the fluent interface but the end of the line doesn't give an expected plain type for an account
Should `fetch` and other TypeScript calls have type definitions for the accounts?   I can't seem to find a way of getting a specific account type from the generated IDL.  Everything appears to be mixed together and from reading the source, there doesn't appear to be a type mapping from the idl to a specific user-facing TypeScript type for the account.
The more broad question I'm asking is: just like how USDC and other fungible tokens follow the SPL token standard, is there an equivalent for NFTs on Solana?
This makes sense. <@!134416332509675520> 's previous answer was that if an account has a Mint Authority and an Update Authority it needs to be a program. If you look at this NFT (https://solscan.io/token/CzymaSrMbe5PNvKqi1kJgpTjmD7Wz7iG4c6aCof1Qj6U) It clearly has the mint + program authority. So does this make it a program (executable account)?
not sure, ive only deployed to devnet
limited to devnet at least?
nope :/
have you found any cause/solution? seems to happen pretty often for me as well
So everything is an "account" (Buffer storing data).
Some accounts are marked as executable and we call these programs (smart contracts)
Nft's are generally spl-tokens (just another account) and are not marked as executable no
So NFTs are programs? hmmmm
that's the strange part! i actually check for this error ```programError(306, 'Game already started.')```, but it doesn't catch for some reason.
0x132 is hexadecimal for 306
Hey! I'm trying to run a test suite on an anchor project. Most of the tests succeed, but tests that depend on program raising an error fail. For example:
```
‚óè trivia ‚Ä∫ Fails to remove the Question from the already started Game

    expect(received).rejects.toThrow(expected)

    Expected message: "306: Game already started."
    Received message: "failed to send transaction: Transaction simulation failed: Error processing Instruction 0: custom program error: 0x132"

          317 |
          318 |     test('Fails to remove the Question from the already started Game', async () => {
        > 319 |         await expect(program.rpc.removeQuestion(dummyQuestionKeypair.publicKey, {
              |         ^
          320 |             accounts: {
          321 |                 game: gamePDA,
          322 |                 authority: provider.wallet.publicKey,

          at Connection.sendEncodedTransaction (node_modules/@solana/web3.js/src/connection.ts:3689:13)
          at Connection.sendRawTransaction (node_modules/@solana/web3.js/src/connection.ts:3649:20)
          at sendAndConfirmRawTransaction (node_modules/@solana/web3.js/src/util/send-and-confirm-raw-transaction.ts:27:21)
          at Provider.send (node_modules/@project-serum/anchor/src/provider.ts:114:18)
          at Object.rpc [as removeQuestion] (node_modules/@project-serum/anchor/src/program/namespace/rpc.ts:24:23)
          at Object.<anonymous> (tests/trivia.ts:319:9)

      322 |                 authority: provider.wallet.publicKey,
      323 |             },
    > 324 |         })).rejects.toThrow(programError(306, 'Game already started.'))
          |                     ^
      325 |     })
      326 |
      327 |     test('Reveals a Question for the Game', async () => {

      at Object.toThrow (node_modules/expect/build/index.js:285:22)
      at Object.<anonymous> (tests/trivia.ts:324:21)
```
However, the error 0x132 is actually 306. Should i change my code to match the error?
many thanks, will try üôÇ
Yep, in solana the client always has to pre-specify every single account of interest, not possible to do it dynamically within the program
oh, so i can't simply call smth like `findATA()` inside program? All the accounts should be passed from the client?
No matter what, you need to pass in the address you want to use from the client, FYI
Got it!
maybe better solution will be not to pass the ATA account and just find it inside program since the ATA is owned by my program...
Or just use token account pda with mint seed so I can address it
Thx bro
And keeping the seeds + bump part.
You would do that by just changing those `associated_token::mint` etc. constraints to be `token::mint = `.
If you already have an address that makes sense in your application, there's no reason to use an associated token address
That said, it's also possible to just not use an associated token address, and just store the token account at one of your own PDAs!
You don't have any choice for the ATA's address (it's determined by the owner of the account + the mint‚Äîthe point of an ATA is to have an "obvious" address)
Yep.
oh, so the right way is to find ATA in the client and then pass it to the program?
You actually can't use seeds with an associated token address, since associated token addresses are *already* program-derived addresses (they're derived from the associated token program, so you can't try to derive them from your own program too).
hello, im running into 
```
     Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: An account required by the instruction is missing
```
```
    #[account(mut)]
    pub signer: Signer<'info>,
    #[account(mut)]
    pub signer_token_account: Account<'info, TokenAccount>,
    #[account(address = crate::id())]
    pub bridge_program: AccountInfo<'info>,

    #[account(
        init_if_needed,
        seeds = [signer.key().as_ref(), mint.key().as_ref()],
        bump,
        payer = signer,
        space = 8+64,
    )]
    pub pda_user_data: Account<'info, Balance>,

    #[account(
        init_if_needed,
        seeds = [mint.key().as_ref()],
        bump,
        associated_token::mint = mint,
        associated_token::authority = bridge_program,
        payer = signer,
    )]
    pub pda_ata_bank: Account<'info, TokenAccount>,

    pub mint: Account<'info, Mint>,
    pub token_program: Program<'info, Token>,
    pub associated_token_program: Program<'info, AssociatedToken>,
    pub rent: Sysvar<'info, Rent>,
    pub system_program: Program<'info, System>,
```
im pretty sure there is something wrong with `pda_ata_bank` account, can smn help me?
The default/*un*-initialized state is to be owned by the system program (so e.g. if you make a fresh keypair address and pass it into your program as an account, it will show up in an empty state: no data, zero lamports, owned by the system program).
Do you mean uninitialized?
are all accounts initialized are owned by the system program ?
So in other words it inits but only if the account hasn't already been init'd.
It checks to see if the incoming account is owned by the system program (this is the default, and applies to uninitialized accounts‚Äîso when you use regular `init`, it expects the incoming account to be owned by the system program). If you use `init_if_needed` and the account *isn't* owned by the system program (meaning it has already been initialized), then anchor skips its own initialization that it would have done if you said `init`, and instead just verifies that the incoming account matches what *would* have happened if you had initialized it (matches all of the constraints you used).
how does init_if_needed work ?
If thats the case then Id need to call a function setup kinda like this?

```
    pub fn create_player_token_account(ctx: Context<CreatePlayerTokenAccount>) -> ProgramResult {
        
            let instruction = create_associated_token_account(
                &ctx.accounts.player.key(), 
                &ctx.accounts.player.key(), 
                &ctx.accounts.mint.key(),
            );

            let response = 
anchor_lang::solana_program::program::invoke(
                &instruction,
                &[
                    // ?? Not sure of needed accounts
                ],
            );
        
}

#[derive(Accounts)]
pub struct CreatePlayerTokenAccount<'info> {
    #[account(mut)]
    pub player: Signer<'info>,
    #[account(mut)]
    pub new_derived_account: Account<'info, TokenAccount>, 
    pub new_wallet_address: AccountInfo<'info>,
    pub mint: Account<'info, Mint>,   
    pub token_program: AccountInfo<'info>,  
    pub system_program: Program<'info, System>,
    //Rent sysvar?
}
```

What would be the min amount of accounts I'd need to pass in? If it really is all of this - I'll just call it on the frontend.
Only https://docs.rs/anchor-spl/latest/anchor_spl/ and various stuff around the net. You could checkout solana cookbook (Google it)

Has some examples I think
Got it! 

Looking into the create_associated_token_account docs. I need the following accounts: Does that mean all of these are needed by the invoke function?

            [writeable, signer] Funding account (must be a system account)
            [writeable] Associated token account address to be created
            [] Wallet address for the new associated token account
            [] The token mint for the new associated token account
            [] System program
            [] SPL Token program
            [] Rent sysvar
You'll need to specify that address from the client ("pass it as an account")
Hey all! I'm trying to call create_associated_token_account within a Solana program. But I'm 1. not sure if I can - I image I'd have to run a CPI 2. If it's possible, can I call it with just the pubkeys, not the AccountInfo?
(only when i check with commitment finalized btw)
if i disable preflight checks, everything goes through smoothly
Hey guys.
Does anyone know why im getting "Blockhash not found" error on the sendTransaction RPC endpoint, ONLY when preflight checks are enabled?
Ok gotcha. I am testing on my localnet so thought it should show up there on the client side.
in js client rpc it does, dont think it shows up in the program logs
Right which matches, but I thought it was supposed to print out the custom message associated with the error #. Per this : https://project-serum.github.io/anchor/tutorials/tutorial-4.html#defining-a-program
0x1770 to decimal -> 6000

if 6xxx -> it's a custom errors so your error #0
Am I missing something here to get custom error messages to show in the log / on the client ? 

```
        if !full_metadata_clone.data.creators.unwrap()[0].verified {
            return Err(ErrorCode::NotVerified.into());
        }
```

```
#[error]
pub enum ErrorCode {
    #[msg("NFTs creator has not verified")]
    NotVerified,
}
```

Error is catching as desired, but it is showing up as `Error processing Instruction 1: custom program error: 0x1770`
anyone knows what I should be careful about when using `init_if_needed` in `v0.21.0`

"Put init_if_needed behind a feature flag to decrease wrong usage"
you can playaround with the wallet object given by the useWallet hook
i think phatom does not exposes that
Is there a way to detect what network/cluster the user's wallet is connected to?
Hello, 
I'm trying to close PDA accounts, but am getting the following error

``` failed to verify account GzfEUa4BXdirVtfNEgJrioGqXtWvgbTxUc2sxMmqfeWN: instruction changed the balance of a read-only account```

How do I verify a PDA account to close, and how I find the full program log? 
I tried passing in both the wallet pubkey and the PDA pubkey as an input to the Anchor instruction

I'm trying to close "items" on a "todo" list account, but I closed the "todo" list accounts first

```
  pub fn cancelitem(
        ctx: Context<CancelItem>,
        item: Pubkey) 
        -> ProgramResult {
        let item = &mut ctx.accounts.item;
        let item_creator = &ctx.accounts.item_creator;
        let user = ctx.accounts.user.to_account_info().key;
        item.close(item_creator.to_account_info())?;
        
        Ok(())
    }
```
```
#[derive(Accounts)]
#[instruction(item: Pubkey)]
pub struct CancelItem<'info> {
    pub item: Account<'info, DataAccount>,
    pub item_creator: AccountInfo<'info>,
    pub user: Signer<'info>,
}
```

```
  const closeItem = async (e) => {
    e.preventDefault();

    const provider = getProvider();
    const program = new Program(idl, programID, provider);
    console.log("ping");
    console.log(provider.wallet.publicKey.toString());

    const items = await program.account.dataAccount.all();
    console.log("All item", items);

    //Close All Item Accounts
    for (var i = 0; i < items.length; i++) {
      console.log(items[i].account.creator);
      await program.rpc.cancelitem(provider.wallet.publicKey, {
        accounts: {
          item: items[i].publicKey,
          itemCreator: provider.wallet.publicKey,
          user: provider.wallet.publicKey,
        },
      });
    }
  };
```
Can someone help me out with this?
https://github.com/project-serum/anchor/issues/1082#issuecomment-1041574986
nice üòÇüëç
you know how dumb mistake that was? `anchor new` generated the program defaulting to `id.json` while I was using different oneü§£ ü§¶‚Äç‚ôÇÔ∏è 
all it take was walking outside and take some fresh air and come back and just check wth is in the `Anchor.toml`
Hi are there any docs I can refer, couldnt find them
np man hope u get it figured out ‚úä struggling thru it
I'll ping you if with outcomes later
Thanks a lot kind strangerüòä let me try my shot first cuz I think I may have a lot of things to clarify and rerun some docs
if you've already tried restarting your machine, try to take a look at `test-ledger-log.txt` - i don't know how much help i'll be but i can take a look too
no, when you use `anchor test` it should output any `console.log`s you have in your main program. it should be able to start the test validator, so you need to fix that first
it doesn't show anything like `passed: x, failed: x` that's was confusing if it's not meant to log only when there's  a failing test haha
ooh okok, that makes sense
and nope I wasn't running the `solana-test-validator` so in that case `anchor test` output should be as in the screenshot?
no, your initial assumption was correct, I just worded it wrong. `anchor test` has it's own implementation of solana-test-validator I believe (it will start a local cluster). I just meant that you shouldn't be running `solana-test-validator` in another terminal while you run `anchor test`.
I was being led wrong this entire time if you're right
ooh now I am confused as hellüòÖ
and to answer your question, you are right in that you should not have a separate `solana-test-validator` running when you run `anchor test`.
not sure then; still try to system restart but if you still get that error check test-ledger-log.txt
my pc is running on ubuntu, not wsl
imo experience on wsl, a system restart fixed this error for some reason. have you tried?
Has anyone figured out how to do incremental builds of their anchor program (only recompile changed files)? `anchor build` takes a while
guys, was wondering if the output should be as following when run the `anchor test` command? since `solana-test-validator` is not running, I was told the `anchor test` will generate it's own validator, how accurate is that?
Can someone give me a pretty high level overview of the dev flow I need to follow? I can elaborate more but I'm essentially working on a project that's a P2E NFT game- ownership of a "player" NFT allows you to play (immutable, just need to check that user owns an NFT from the collection), separate utility token used as currency in the game (need to transfer tokens from user (to game) to user, mint/burn tokenomics). I'm new to Solana development but I know I want to use anchor to code the game logic in rust; I'm hitting a wall on how to interact with SPL tokens (NFT and utility token) on an anchor program. First, for the NFT collection itself, would it be feasible to mint the collection with Candy Machine (v2), and once it's on chain I can verify owner w/ metadata retrieval in my webapp (basically separating the initial mint w/ game program)? Second, I'm completely lost on implementing a fungible SPL utility token into my contract. My understanding is limited to creating an SPL Token with the Solana CLI, but I don't know if that could also be separated (create SPL Token w/ CLI and just interact with mint account w/ game program). Would I be able to mint and burn utility tokens by interacting with my game's program through my web app? Any help is appreciated -- I ran through buildspace's web3 anchor course, but it didn't cover anything about SPL Tokens; any docs that cover how to create/interact with SPL Tokens would help. ty üôè
Provides validations and functions for interacting with the spl-token program
(validations for tokenaccounts and mints and token transfer functions for cpis)
Yeh I just meant if I want to send spl tokens to my program should I be making a token account on that program and sending them there or an ata on that program and sending them there. Didn't know if there was a best practice.
What are main limitations of PDA's ? (just size?)
Is there a list of them somewhere
Hi question on the anchor-framework libraries, 
if I see the toml file here https://anchor.projectserum.com/build/328/nft-candy-machine/Cargo.toml , the following are the requirements: 
```[dependencies]
anchor-lang = "0.17.0" --> this is the anchor framework itself
spl-token = { version="3.1.1", features = [ "no-entrypoint" ] } --> SPL token library
anchor-spl = "0.17.0" --> what about this ?
...
```

I would like to know what the `anchor-spl` library does, I couldn't find documentation on it apart from https://docs.rs/anchor-spl
Thanks! I‚Äôll check it out
You can definitely do this, just need to force the client to sign the instruction with some known admin key. You could for example just hardcode this key into your program, or use the program's deployment upgrade authority (more complicated, but here's an example: https://github.com/project-serum/anchor/tree/master/tests/bpf-upgradeable-state)
The func I wanna protect access to is an init function to set everything in motion
If I want to gate a function so only I can call it on the main net is that idomatic? Or am I thinking about it wrong? Do ppl do this?
Ah, those accounts are still owned by the spl token program (you're just init-ing them inside your own program)
Sorry I just mean can we make ATAs that our program can send too and from just like we can regular spl token

Is there an issue with that?
I got some missing account error when giving it a try
btw. if you have a minute - I have another question (I hope a simple one, but that was my hope with the last one as well):
**how to run a specific (single) anchor test?**

- running `anchor test` launches all tests (the default `test` script)
- running ts-mocha directly doesn't bring the test blockchain up
- adding a script in `anchor.toml` doesn't bring the test blockchain up
- modifying the `test` script does work, but is extremely annoying to work with

so again, I must be missing something. I'd appreciate any help üôÇ
ps. I added the "consumed" bits to the original log message I pasted, but they are pretty unhelpful üòâ
unless I'm missing something?
I have pasted all I had. it failed with transaction simulation, so there is actually nothing more
Can you post the program log though? (Lol üòõ)
thanks. at least I know I'm not doing something wrong üòÑ
and here I thought that I'm the stupid one for diving in source all this time üòÇ
oh well, time to do some diving then.
Otherwise all mapping from raw error code to human readable string involves some deduction
Yep
so just to recap: unless the error is logged BEFORE it's returned - there is no way to make it human readable.
the only way is do some source-diving?
So, can't say much more without the full program log
It depends on the program stack trace
It's not really returned by anchor (in solana when you encounter an error it shortcircuits everything else, so in general there's no way to know what the error code corresponds to‚Äîyou just have to go source-diving/think about it)
true that. but it's returned by anchor. is there any way to unwrap those (potentially using some smart anchor functionality) ?
thanks for your answer.
full log is below
```Transaction simulation failed: Error processing Instruction 0: custom program error: 0x7
    Program 93i4jTHCR2Q23qrqQDEPu3EqCfnaQJwtiM3un7ApkNz3invoke [1]
    Program log: ----------image update----------
    Program metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s invoke [2]
    Program log: Instruction: Update Metadata Accounts
    Program log: Update Authority given does not match
    Program metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s consumed 7334 of 181386 compute units
    Program metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s failed: custom program error: 0x7
    Program 93i4jTHCR2Q23qrqQDEPu3EqCfnaQJwtiM3un7ApkNz3 consumed 200000 of 200000 compute units
    Program 93i4jTHCR2Q23qrqQDEPu3EqCfnaQJwtiM3un7ApkNz3 failed: custom program error: 0x7
```
and yes, I can see that the problem is the authority, but this was simply an example.
the author of this particular code didn't have to LOG anything before returning an error (and more often than not - they don't) 
so the question still stands.
They start at 100.
I actually don't think that's an anchor error at all ü§î
Can you post the full program log?
hey
stupid, beginner question I've been battling with for ages now:
how to unwrap something like that:
```
Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: custom program error: 0x7
```
into something actually understandable?
I know I can change this code to integer, but anything below 300 (if I remember well) is not my error code (and those are actually correctly, like `301: Not enough funds to cover fee.`), so it's really hard to actually figure out what error is that...
I'm probably missing something easy and obvious here, because it's just not possible for error handling to be so messed up, so please help üôÇ
What do you mean by program owned?
I just ran `anchor test` (I thought that usually builds and deploy the program before running the tests?)
So we can make program owned spl accounts with:
```
#[account(init, payer = authority, seeds = [config.key().as_ref(), b"tide_trtn_account".as_ref()], bump, token::mint = trtn_mint, token::authority = trtn_account)]
pub trtn_account: Account<'info, TokenAccount>,
```
Can we also make program owned ATA's?
You legendddd üî•
omg it fucking works now!!!! i just rebuilt nd redeployed it
interesting...let me try something
Hmm, that's an unusual error to get, are you sure you've deployed the program correctly etc.?
Yeah, you'd have to import that type from the other program (you'd need to depend on their source code)
I have the following error and not entirely sure what it means....

```sh
Transaction simulation failed: Error processing Instruction 0: custom program error: 0xbbd
    Program bgKX8Yxqqbu4nthUgJ3c2mqCEd4w8hQyqn6eTDzDkz1 invoke [1]
    Program log: Instruction: ProcessPlayerWithdraw
    Program log: Custom program error: 0xbbd
    Program bgKX8Yxqqbu4nthUgJ3c2mqCEd4w8hQyqn6eTDzDkz1 consumed 4434 of 200000 compute units
    Program bgKX8Yxqqbu4nthUgJ3c2mqCEd4w8hQyqn6eTDzDkz1 failed: custom program error: 0xbbd

Error: 3005: Not enough account keys given to the instruction
```

Current withdraw fn

```rust
    pub fn process_player_withdraw(ctx: Context<ProcessPlayerWithdraw>, amount: u64) -> Result<()> {
        let fund_payer = &mut ctx.accounts.player;
        let payer_balance = fund_payer.to_account_info().lamports();
        let rent_exemption = Rent::get()?.minimum_balance(fund_payer.to_account_info().data_len());

        // We check if we have enough funds
        if payer_balance - rent_exemption < amount {
            msg!("Insufficent balance");
            return Err(HouseError::InsufficientFunds.into());
        }

        // Transfer balance
        **fund_payer.to_account_info().try_borrow_mut_lamports()? -= amount;
        **ctx.accounts.receiver.try_borrow_mut_lamports()? += amount;
        Ok(())
    }

#[derive(Accounts)]
#[instruction(amount: u64)]
pub struct ProcessPlayerWithdraw<'info> {
    #[account(mut)]
    player: Account<'info, Player>,
    #[account(mut)]
    receiver: Signer<'info>,
    // #[account(address = system_program::ID)]
    // system_program: Program<'info, System>,
}

```

Test:
```typescript
await program.rpc.processPlayerWithdraw(
      new anchor.BN(withdrawAmount * LAMPORTS_PER_SOL),
      {
        accounts: {
          player: randomPlayer,
          receiver: randomKeypair.publicKey,
          // systemProgram: SystemProgram.programId
        },
        signers: [randomKeypair]
      }
    );
```
my understanding is that I cant bind `#[account]` to accounts not owned by the present program
when I did that, it gave me `required by a bound in anchor_lang::prelude::Account`
Yeah
Once you import that type
You ought to be able to just do the usual
```.rs
pub that_account: Account<'info, MarketA>
```
And program B is an anchor program?
not sure it makes sense
Program B has struct defined as 
`pub struct MarketA{
     pub field1: u64,
     pub field2: u64, ....
`

i am trying to load the data from an account key of Program B from Program A
Can you say more about what you want to do? What kind of data are you deserializing?
Are there examples of deserializing data with anchorserialize/anchordeserialize?
Mints are just accounts in solana, there's just the one-and-only spl token program behind the scenes
Mint's don't have upgrade authorities (only programs do)
Oh, sorry (I'm having like my worst reading comprehension day ever, I don't know what's going on)‚Äîthat link there is to the mint itself
The mint authority isn't stored on the token account at all, it's stored on the mint account
The mint itself in solscan is called the "Token address" (would have been easier if they just called it the mint address)
Not a program
But no, the token account's authority there is its "logical owner", e.g. a random wallet
Ah, this is annoying but the naming conventions around tokens are irritatingly nonstandard
In the case of a regular SPL token does `Authority` encompass both the mint authority and upgrade authority?
Got it - how does this differ across a regular SPL token (e.g. USDC https://solscan.io/token/EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v) where you only have the Owner Program vs. Authority?
Unlike in ethereum.
By default, when you deploy your program you can just keep on re-deploying it, updating it in the process
> Update authority is who has to sign in order to redeploy an upgradeable program (the default).

What do you mean by redeploy an upgradeable program?
Mint authority is who has to sign in order to mint new tokens. Update authority is who has to sign in order to redeploy an upgradeable program (the default). Owner program is the program that's allowed to mutate an account's data or spend the account's money (so, for a token account, that would be the spl token program)
For an SPL Token account (in particular an NFT), what's the difference between the Mint Authority vs. Update Authority vs. Owner Program?
ty for the help
but was somewhat surprised when I encountered issues there. NBD though, was not too painful to resolve
that mapped the owner to `spl_token_2022::id()`
Oh, got it
Yeah I know. I created a custom `Mint` wrapper class based on the anchor-spl version
Ah, ok. Yeah, hmm, that won't work directly with the `Mint` type unfortunately (`Mint` encodes its owning program as the original token program)
yeah, that's the difference
Ah, I wonder if the spl_token_2022 part is different?
What do you mean by a custom wrapped Mint? You can definitely `init` a mint
Solution here was to do this:
```
    #[account(
        init,
        seeds = [
            payer.key().as_ref(),
        ],
        bump,
        owner = spl_token_2022::id(),
        payer = payer,
        space = Mint::LEN,
    )]
    pub mint: UncheckedAccount<'info>,
```
idk why this worked while the other didn't (the Mint was a custom wrapped Mint object) but i'll take it
Yep, `program.instruction.yourInstructionName`
Can the anchor-ts methods namespace return an instruction instead of directly executing the rpc?
Best practice I've seen so far is just to define a `AccountName::LEN` property depending on your struct schema. Check out this example: https://lorisleiva.com/create-a-solana-dapp-from-scratch/structuring-our-tweet-account
hmm ill see if im doing smth dumb then ty
I think `Buffer.from([...])` should work ü§î
anyone know what to use in `findProgramAddress` in js to match a `&[u8; 30]` in pda seeds in rust? tried variations on Buffer.from(), Uint8Array.from(), etc but keep getting either `signer privilege escalated` or `seeds do not match`
ah got it. thank you
At some point in solana 1.9  I think you'll be able to add additional space to an account
I got I need to keep it minimal, thanks. but I worry if I deploy program it could be no way to increase it later
Not really, just "use enough space" while staying within a budget you're ok with  üò¨
ok I see. any best practices for thinking about future updates?
Bear in mind that account storage is pretty expensive. Rent-exemption costs 7 sol / mb.
I see account can be max 10 MB. but it doesn't make much sense to reserve so much space for my structs
hey guys, what account size you usually set? 
assuming it can be changed later and new fields added
üôèüèºüôèüèºüôèüèº
I seeeeeee! super super helpful. thank you for taking your time to answer these questions. I believe i got enough pointers to try to have a dabble at this again
So there isn't one way to move lamports in solana, it depends completely on which program owns the source account.
3. When you send sol to the PDA, this is a bit different: here the source account is presumably the user, and their account *is* owned by the system program‚Äîso now you actually have to use the system program's transfer instruction, because only the system program has the rights to decrement that account's balance.
2. You use try_borrow_mut_lamports on both the source and the destination account (taking from the source and giving to the destination)
1. That means some account was expected to sign (by whatever code you end up running, here the CPI to the system program), but the account didn't actually sign. Here, you never actually signed for the player account.
The `process_player_withdraw` I have is almost the same as how i deposit SOL into that PDA account. (Is using that way to deposit SOL in the account incorrect as well?)
1. Can you give me a bit more info of what `signer privilege escalated` means? (Is that some sort of authorisation error thats gets bubbled up from some where?)
2. Okay, what you said make sense regarding the PDA is owned by my program so `system_program` can't mutate it. But I have a question with if i tried to use `try_borrow_mut_lamports` where does the balance goes? (I'm not sure i fully understands it by reading that discord message)
Something like this: https://discord.com/channels/889577356681945098/889577399308656662/925907788172001301
(And no need to sign for anything, since your program owns the player account‚Äîit can do whatever it wants with it)
You'll have to directly decrement the lamports yourself, using `try_borrow_mut_lamports`
In solana, every account is owned by a program, and *only* that owning program is allowed to mutate the account's data or spend the account's money. In this case, you're asking the system program to decrement the player account's lamports‚Äîbut the system program can't do that, because it doesn't own that account (your own program does)
I think the other issue you're going to have though is that if the `player` account is owned by your program, this actually isn't how you do a transfer
Ok, so `FTu3NnMRJ7f4cBtVWstiNna9UE5EVnHDxinAQBwo6DrA's signer privilege escalated` means that you're indeed not signing for something correctly
Thank you for answering that. this is so much better than looking for answers from the internnet. been scratching my head for days now
Will this help?
```
Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account
Program bgKX8Yxqqbu4nthUgJ3c2mqCEd4w8hQyqn6eTDzDkz1 invoke [1]
Program log: Instruction: ProcessPlayerWithdraw
FTu3NnMRJ7f4cBtVWstiNna9UE5EVnHDxinAQBwo6DrA's signer privilege escalated
Program bgKX8Yxqqbu4nthUgJ3c2mqCEd4w8hQyqn6eTDzDkz1 consumed 7512 of 200000 compute units
Program bgKX8Yxqqbu4nthUgJ3c2mqCEd4w8hQyqn6eTDzDkz1 failed: Cross-program invocation with unauthorized signer or writable account
```
Yep, exactly
Ahhhh what you said make sense. part of the restriction, as it doesn't have a private key, so you can't really sign the transaction from client side?
There will be a line in it that tells you more info
Can you post the full program log from when that happens?
PDAs can't be signed for from the client (part of their purpose is that *only* their deriving program can sign for them‚Äîyou just physically can't do it from the client)
If the `Player` lives at a PDA (with seeds etc.) then you won't be able to mark it as a signer like that, `#account(mut, signer)`
I'm super new to rust, anchor and solana
If you spotted anything i can improve with my code, happy to hear it to!
Before i added `signer` to `#[account(mut)` i was getting ` Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account`
After I added `#[account(mut, signer)]` above `player: Account<'info, Player>,` in `ProcessPlayerWithdraw` I'm now getting ` Error: Signature verification failed`
My ts test code
```typescript

// Note: RandomPlayer is created with Random Keypair

async function createRandomPlayer({ username, initialBalance }: {
    username: string,
    initialBalance: number
  }) {
    const randomAccount = anchor.web3.Keypair.generate();
    await airdrop({ publicKey: randomAccount.publicKey, amount: initialBalance });
    const [player, bump] = await PublicKey.findProgramAddress(
      [randomAccount.publicKey.toBuffer()],
      program.programId
    );
    await program.rpc.createPlayer(username, {
      accounts: {
        player,
        authority: randomAccount.publicKey,
        systemProgram: anchor.web3.SystemProgram.programId,
      },
      signers: [randomAccount]
    });
    const account = await program.account.player.fetch(player);
    return {
      randomKeypair: randomAccount,
      randomPlayer: player,
      randomPDAAccount: account
    }
  }
///
    await program.rpc.processPlayerWithdraw(
      new anchor.BN(withdrawAmount * LAMPORTS_PER_SOL),
      {
        accounts: {
          player: randomPlayer,
          receiver: randomKeypair.publicKey,
          systemProgram: SystemProgram.programId
        },
        signers: [randomKeypair]
      }
    );
```
```rust

    pub fn process_player_withdraw(ctx: Context<ProcessPlayerWithdraw>, amount: u64) -> Result<()> {

        let fund_payer = &mut ctx.accounts.player;
        let fund_payer_account_lamports = **fund_payer.to_account_info().lamports.borrow();

        // TODO: Check player balance before transfer
        // TODO: Check player's authority is withdraw receiver

        let instruction = anchor_lang::solana_program::system_instruction::transfer(
            &ctx.accounts.player.key(),
            &ctx.accounts.receiver.key(),
            amount,
        );
        // Execute transfer instruction
        anchor_lang::solana_program::program::invoke(
            &instruction,
            &[
                ctx.accounts.player.to_account_info(),
                ctx.accounts.receiver.to_account_info(),
                ctx.accounts.system_program.to_account_info(),
            ],
        );
        Ok(())
    }


#[derive(Accounts)]
#[instruction(amount: u64)]
pub struct ProcessPlayerWithdraw<'info> {
    #[account(mut, signer)]
    player: Account<'info, Player>,
    #[account(mut)]
    receiver: Signer<'info>,
    #[account(address = system_program::ID)]
    system_program: Program<'info, System>,
}
```
Thanks! So here is what i have in my rust program

```rust

    pub fn create_player(ctx: Context<CreatePlayer>, name: String) -> Result<()> {
        ctx.accounts.player.name = name;
        ctx.accounts.player.enabled = true;
        ctx.accounts.player.authority = *ctx.accounts.authority.key;
        ctx.accounts.player.bump = *ctx.bumps.get("player").unwrap();
        Ok(())
    }

#[account]
pub struct Player {
    pub name: String,
    pub authority: Pubkey,
    pub enabled: bool,
    pub bump: u8,
}

#[derive(Accounts)]
#[instruction(name: String)]
pub struct CreatePlayer<'info> {
    #[account(
        init,
        seeds = [authority.key().as_ref()],
        bump,
        payer = authority,
        space = 320,
    )]
    player: Account<'info, Player>,
    #[account(mut)]
    authority: Signer<'info>,
    system_program: AccountInfo<'info>,
}
```
Easiest way is probably for you to just start posting some code!
I'm looking for some help related to withdrawing from a PDA account (I'm using anchor) which is the best channel to ask these sort of questions? (I got some signing related issue i believe)
Oh, sorry‚Äîcan use `token::mint` and `token::authority` for a TokenAccount
You can initialize a mint account though with the `mint::decimals` and `mint::authority` attributes
The issue is that in general `init` is doing more than just assigning ownership‚Äîit might have to do arbitrary other stuff depending on what kind of account you're init-ing.
https://github.com/project-serum/anchor/blob/a66257701863df288e32f7030e7708652f614f1c/lang/syn/src/parser/accounts/constraints.rs#L51 seems impossible
Would love to know if that's possible as well
Ah ok
it's a not a mint account for the normal Token Program
I see that you're trying to init a mint account. That didn't work for me either. But for TokenAccount this worked for me without any additional keywords:

```#[account(
      init_if_needed,
      payer = player,
      associated_token::mint = cost_mint,
      associated_token::authority = authority,
    )]
    pub authority_cost_ata: Box<Account<'info, TokenAccount>>,```
kinda surprised it's not general though. this is easy enough to just write by hand though so nbd
yeah for TokenAccount etc.
https://github.com/project-serum/anchor/blob/83121c26eb578487196524d5829099a70503a5a3/tests/misc/programs/misc/src/context.rs
I know you can for specific programs
Others may be able to comment but from my understanding you cannot `init` accounts for other programs. You can only `init` your own.
https://lorisleiva.com/create-a-solana-dapp-from-scratch/structuring-our-tweet-account

This should also help with understanding the layout of accounts on Solana
Just gotta know the shape of your account really well, which isn't that hard if you're allocating space for it yourself
https://solanacookbook.com/guides/get-program-accounts.html
probably a super basic question, if i want to assign an account to a different program in the the `init` macro, what's the keyword to use:
```
    #[account(
        init,
        seeds = [
            owner.key().as_ref(),
        ],
        bump,
        payer = owner,
        space = Mint::LEN,
        owner = spl_token_2022::id(),
    )]
    pub mint: Box<Account<'info, Mint>>,
```
`owner` is not the right keyword
is calling `load_init()` on an AccountLoader inside the fn the same as using `init` in the account constraints? You could do one or the other?
Got it, thanks a lot üëê
The latter
Ah this makes sense, thanks a lot, apologies if Im being unable to grasp a obvious thing here, but say I didn't have any constraints I want over my account, in that case, would my program look like this 
```#[derive(Accounts)]
pub struct Vote<'info> {
    /// Marking accounts as mut persists any changes made upon exiting the program 
    #[account( )]   --> no constraints...
    pub vote_account: Account<'info, VoteAccount>,
}
```

OR would it be like this

```#[derive(Accounts)]
pub struct Vote<'info> {
    /// Marking accounts as mut persists any changes made upon exiting the program 
    /// removed the line itself here 
    pub vote_account: Account<'info, VoteAccount>,
}
```


//////////////////////////////////////////////////////////////////////////////////////////

I guess I don't really know how large the solana programs can get, and how niched down in focus they are supposed to be.
Is it considered best practice to have two initialized types of data in one solana program? most of the tutorials i have seen include only 1 initialized type.
up
have a question about the spl-token CLI, thought i'd ask here, fft ignore if it's not relevant.

```spl-token account-info 7MC1kwNJaScpMw1QukdeD48rSp7cE3NgxZ2yKdDBPqQe
Could not find token account HJxCQzVQFjjcSaz2BYMqGJzDWAYUXT1oLgNokmSL45Ke```
When I try to query one token account, why does it give me an error on the other one?
Makes sense
I think life is 100x easier if you do you tests without an explicit validator running
And does some magic ("genesis block" stuff) to get your program in there without explicitly deploying it
anchor test will check if you've already got one running, and if so, use it; otherwise it spins one up for you
I essentially never run my own local validator/always let anchor spin it up for me
What are cases when you should run `solana-test-validator` in the background, and when you should not? More specifically, when you do `anchor test` what exactly is it running?
wow that worked... hmm
What if you don't run a test validator in the background at all, and just let anchor spin it up for you?
I did that, restarted `solana-test-validator` but still getting  `Error: failed to send transaction: Transaction simulation failed: Attempt to load a program that does not exist`
In your Anchor.toml
Think you can do this: https://discord.com/channels/889577356681945098/889702325231427584/943483106852212766
Sort of‚Äîthe account still has to get passed in from the client, but now anchor can do it for you automagically
how did you deploy this on local net?
hey just looking at your response here. Regarding the not needing to pass in the PDA on the client side, does that mean we derive the PDA account in the program, but don't pass any account in when we are calling that function on the client side>
How do you handle arrays of accounts in Anchor. I am trying to modify the escrow program to exchange multiple NFTs (2v2, 2v3, etc...). Any examples?
Could you please check?
His nick is thewuh#7483
Doesn‚Äôt get through verification
Hey there, a developer I am talking to right now has issues joining the anchor discord server
https://discord.com/channels/889577356681945098/889577399308656662/944335211506855956 this may help
Also I get this only with the javacript client, I tried making it via the python client, and it did not throw any errors. Is this is a permissions issue ? 
Or say the validator node is accessible at localhost but not at the 0.0.0.0 which javascript it trying to access ?
how to unsubscribe ?
```    program.account.pool.subscribe(pool.publicKey).on("change", state => {
                poolState = state;
                console.log("asd")
            })```
Hi started trying out the tutorial on anchor-framework, 
been getting this error 
```
ANCHOR_WALLET=/Userspath/.config/solana/id.json  node client.js                           

Running client.
/Userspath/Desktop/rust-stuff/solana-work/anchor/examples/tutorial/node_modules/@solana/web3.js/lib/index.cjs.js:5965
      throw new Error('failed to get recent blockhash: ' + e);
            ^

Error: failed to get recent blockhash: FetchError: request to http://localhost:8899/ failed, reason: connect ECONNREFUSED ::1:8899
    at Connection.getRecentBlockhash (/Users/ /Desktop/rust-stuff/solana-work/anchor/examples/tutorial/node_modules/@solana/web3.js/lib/index.cjs.js:5965:13)
    at processTicksAndRejections (node:internal/process/task_queues:96:5)
    at async Provider.send (/Users/ /Desktop/rust-stuff/solana-work/anchor/examples/tutorial/node_modules/@project-serum/anchor/dist/cjs/provider.js:82:31)
    at async Object.rpc [as initialize] (/Users/ /Desktop/rust-stuff/solana-work/anchor/examples/tutorial/node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:31:31)
    at async main (/Users/ /Desktop/rust-stuff/solana-work/anchor/examples/tutorial/basic-0/client.js:24:3)
```
Have solana validator running and 
On making wget http://localhost:8899 I do get a 405 response, which means the port is in use, but for some reason my program cant access it.
built one instead üôÇ let me know if you still need help on it happy to talk you through the program
yea like a similar test shows up fine if i try to do it in a blank new anchor repo
it seems like some config is off in my main repo but i'm not sure what it is
Mm, not sure, I would have expected the passing test to show up in `.anchor/program-logs`
and this is program logs output
lib rs
```rs
#[program]
pub mod dominari_anchor {
    use super::*;


    // Any player can initalize a space, which will have a blank feature, in any neighborhood
        // Requires (Nx,Ny) (Lx,Ly)
    pub fn init_location(ctx: Context<InitLocation>, loc:Coords) -> ProgramResult {

        msg!("{:?}", loc.nx.to_be_bytes());

        let location = &mut ctx.accounts.location;
        location.initalizer = ctx.accounts.initalizer.key();
        location.coords = loc;
        location.feature = Feature::None;
        
        Ok(())
    }

    pub fn debug(ctx: Context<Debug>, loc:Coords) -> ProgramResult {
        msg!("{:?}", loc.nx.to_be_bytes());
        Ok(())
    }
}
```
running two tests:
```ts
  it('Any player can initalize a space', async () => {
    //console.log(apollo_keypair.publicKey.toString());
    const coords = {
      nx: new anchor.BN(0),
      ny: new anchor.BN(-1),
      x: new anchor.BN(2),
      y: new anchor.BN(-178)
    }
    const [loc_address, loc_bump] = findProgramAddressSync([coords.nx.toArrayLike(Buffer, "be", 4), coords.ny.toArrayLike(Buffer, "be", 4), coords.x.toArrayLike(Buffer, "be", 4), coords.y.toArrayLike(Buffer, "be", 4)], dominari.programId)

    await dominari.methods
      .initLocation(coords)
      .accounts({
        location: loc_address,
        initializer: apollo_keypair.publicKey
      })
      .rpc();

    console.log(await dominari.account.location.fetch(loc_address));
  });

  // Configure the client to use the local cluster.
  //anchor.setProvider(anchor.Provider.env());
  //const program = anchor.workspace.DominariAnchor as Program<DominariAnchor>;
  
  it('Debug', async () => {
    const coords = {
      nx: new anchor.BN(0),
      ny: new anchor.BN(-1),
      x: new anchor.BN(2),
      y: new anchor.BN(-178)
    }
    console.log(coords.nx.toArrayLike(Buffer, "be", 8));
    console.log(coords.nx.toBuffer("be", 8));
    await dominari.methods.debug(coords);
    
  })
```

Can you show the full output of anchor test?
i did anchor test and it just says "streaming logs" but no actual logs
yea it's empty
Try looking in `.anchor/program-logs`
and this one üôè pls
reasking for help with this issue
This will apparently change in the next solana release, but not sure when that will happen
Currently you only have one shot to allocate the right amount of space for an account
I want to work with vectors. First i don't have any items in it, so i do not need to allocate space for it. But after each add i need to send a transaction + allocate more space, right?
Not sure what you mean, those seeds basically do just what it looks like they'd do (and they eventually all get chucked into a sha256 hash)
thats awesome, ty
there's also program logs in `.anchor/program-logs` directory in your anchor project
there's probably other ways but I do it with `solana logs -u localhost`
hey, how can i check outputs from the msg!() in my anchor program (on localnet)
thx! üôÇ
here's a good starting point https://docs.solana.com/developing/clients/javascript-reference#transaction
maybe you can get the correct size by serializing it and then measuring it's size `let rawTransaction = manualTransaction.serialize();`
Yes I am trying to call another library crate.
or is there a helper function or so to do so?
any idea how I can do that? would i have to take the bytecode and measure the length of this?
I believe you will have to measure this from the client side because the tx size limitation comes from the MTU size when sending the tx from the client to the network.
are you trying to use some library crate or do a cpi call? This is how you do a cpi call  https://project-serum.github.io/anchor/tutorials/tutorial-3.html#defining-a-puppet-program
and how to use that program? cpi?
is there any way to get the size of a `Transaction` object? 
I'm trying to understand how much I can squeeze in, and would be nice to know this without actually running it, but rather by printing
the same way you would in any other rust code
How are you generating random numbers? Isn't the runtime fully deterministic?
Most likely. Theres usually a more@detailed error log, do u have that as well? But yh usually seeds incorrect
Hi , I am using $ anchor test  to communicate with solana-test-validator process . it running inside the container. When I running the comand a new zombi process was created  [solana] <defunct> . the anchor test --skip-local-validator command , not try to run a new right ? Any advice or comments is welcome
How to call and use external crate in anchor program? I am confused
(using anchor test)
trying to print to logs but the logs show up empty, any advice?
```rs
    pub fn debug(ctx: Context<Debug>, loc:Coords) -> ProgramResult {
        msg!("{:?}", loc.nx.to_be_bytes());
        Ok(())
    }
```
anybody have any good resources on how constraints work and how to implement them properly?
VRF in mainnet but static locally
Any tips on mocking an on chain function for testing? I have a function which generates random numbers but I want to be able to return specific numbers in my tests
Hi folks! Is there anyway to pass individually unique parameters to seeds. Like
`seeds = [b"create_user", author.key().as_ref(), username.as_bytes()]`
i want both `author.key().as_ref()` and `username.as_bytes()` to be unique individually rather than unique in a combination..?
is there a way to use different variables depending on which network a program is deployed to
It pushes into the ix array
What is a good source/example for creating mints and tokens in Rust or Typescript (not the spl cli)?
Running into a "[PDA Account Address]'signer privilege escalated"
```
Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account 
    Program FJ9B9iLoqpTyAcx4yWkkkEgo4x7WbgV5KP2kBLVSpnKs invoke [1]
    Program log: Instruction: InitLocation
    p5y4wSfV8DehotkmvrGdNMuYkdakkfQQgjx9eHRPGpA's signer privilege escalated
    Program FJ9B9iLoqpTyAcx4yWkkkEgo4x7WbgV5KP2kBLVSpnKs consumed 7300 of 200000 compute units
    Program FJ9B9iLoqpTyAcx4yWkkkEgo4x7WbgV5KP2kBLVSpnKs failed: Cross-program invocation with unauthorized signer or writable account
```
my code: 
```rs
use anchor_lang::prelude::*;
use crate::account::*;
use crate::state::*;

#[derive(Accounts)]
#[instruction(loc: Coords, _loc_bmp:u8)]
pub struct InitLocation<'info>{
    #[account(
        init,
        //(Nx, Ny) (Lx, Ly)
        seeds=[loc.nx.to_be_bytes().as_ref(), loc.ny.to_be_bytes().as_ref(), loc.x.to_be_bytes().as_ref(), loc.y.to_be_bytes().as_ref()],
        bump=_loc_bmp,
        payer=initalizer,
        space=8+1024
    )]
    pub location: Account<'info, Location>,
    pub initalizer: Signer<'info>,
    pub system_program: Program<'info, System>
}
```
```rs
    pub fn init_location(ctx: Context<InitLocation>, coords:Coords, _loc_bmp:u8) -> ProgramResult {
        
        let mut loc = &mut ctx.accounts.location;
        loc.initalizer = ctx.accounts.initalizer.key();
        loc.coords = coords;
        loc.feature = Feature::None;
        
        Ok(())
    }
```
Does a `rror: 146: A seeds constraint was violated` error mean that the incorrect seeds were provided in a cpi call?
did u ever find a contract??
You mean the byte size of the transaction? I don't think that's happening any time soon (it depends on using QUIC as far as I understand)
also how much additional program-instruction-space is solana 1.9 going to introduce?
yeah was indeed some manual signTransaction functions I oversaw. thanks a lot for the help again! üôÇ
i think I will need to do some major refactoring soon too lol.
just switched to that, thx!
This is easier if you use `program.provider.send`, which makes sure to sign with the provider.wallet
Ah! Yeah, don't say signTransaction multiple times
yeah i think this is the case, I seem to get less clicks now that I removed some of these signTransaction
also, thx! üôÇ
yeah makes sense. perhaps there is some redundant "signTransaction" somewhere hidden ...
I would just quadruple verify that you're actually building a single Transaction object
and if i still have it i'll try to make a github link or so
let me try to debug for a bit, maybe it's some stupid bug
hmm, that's gonna be painful xD
That definitely seems wrong to me
or im doing something funky..
Can you post more of your code?
hmm weird, I'm getting a `Error: Transaction too large: 1476 > 1232`, but only after I have clicked "approve" after about 8 times (instead of the 18). so it seems like it is chaining them together, but it's asking for a new approval each time..
But I didn't realize you might need to issue multiple approvals
Well, they're still all part of a single transaction‚Äîso the whole transaction succeeds or fails
have you confirmed this actually? Intuitively, this is what I would assume it would be doing. if not, it would seem kinda pointless to chain them together..
Ok, yeah, just concatenates the instructions
that's what I would assume
I would use TransactionInstruction
Hmm, had never noticed you could `.add` a Transaction (what does it do? just smoosh all the instructions together?)
when you say instructions are these types ok? `Transaction` or `TransactionInstruction`. I realize `tx.add()` takes as input one of these two types (and more, actually..)
hmmm, I would very much hope that to be the case üòÖ üòÖ üòÖ  I have to click approve 18 times loll
You should have one Transaction that you then add a bunch of individual instructions to
ix1 can be of type `Transaction` or `TransactionInstruction`
Actually now that I think about it I guess I could be wrong‚ÄîI figured that would only trigger one approval, but not sure I've actually tested that ü§î
yeah
So you're calling `tx.add(ix1)`, `tx.add(ix2)` etc.?
hmm, i tried to do that. basically, I for each of the instructions, I call 
``` 
let ix = solbondProgram.instruction.function1
``` 
and then I bundle these together in one transaction
``` 
let tx = new Transaction();
tx.add(ix)
``` 

is there anything else I'm missing?
Yeah, by bundling all of the instructions into a single transaction
but now, i have to click "approve" for every individual instruction in this transaction. is it possible to click approve once, for all instruction?
You can also do `program.provider.send(theTx)` if you want to automatically sign with the provider wallet
turns out I was missing this line (manually sign the transaction..)
`        await qPoolContext.userAccount!.signTransaction(tx0);`
what are the things I need to look out for when going from `program.rpc` to `program.instruction` ? 

So far, for the `program.instruction` instructions, I am adding a `recentBlockhash` and a `feePayer`. I have arrived at the following set of instructions

``` 
const blockhash = await qPoolContext.connection!.getRecentBlockhash();
        console.log("Added blockhash");
        tx0.recentBlockhash = blockhash.blockhash;
        tx0.feePayer = qPoolContext.userAccount!.publicKey;
        let sg0 = await qPoolContext.connection!.sendRawTransaction(tx0.serialize());
        console.log("sg0 is: ", sg0);
        await qPoolContext.connection!.confirmTransaction(sg0, 'confirmed');
``` 

However, when I run this set of instructions, I am getting a `Error: Signature verification failed`. Is there anything else I need to add?
is it possible to use `#[account(zero_copy)]` with a type that unsafely impls `Pod` but not `Copy` -- i think that's the only reason for  the `Copy` constraint right?

it seems because `ZeroCopy` explicitly requires types be `Copy` (in addition to `Pod`), i can't circumvent the `Copy` constraint

`pub trait ZeroCopy: Discriminator + Copy + Clone + Zeroable + Pod { }`

```rust
#[automatically_derived]
unsafe impl #impl_gen anchor_lang::__private::bytemuck::Pod for #account_name #type_gen #where_clause {}
#[automatically_derived]
unsafe impl #impl_gen anchor_lang::__private::bytemuck::Zeroable for #account_name #type_gen #where_clause {}

#[automatically_derived]
impl #impl_gen anchor_lang::ZeroCopy for #account_name #type_gen #where_clause {}
```
<@!134416332509675520> thank you helping me with my stupid question
Sorry i forgot to multiply by `LAMPORTS_PER_SOL`
Ahhhh let me check something
How many lamports are you transferring? What is `transferToPlayerAmount` here?
Thank you!!
Wow you're awesome! That was it! üòÄ
Balance of `house` and  `player`  do not change and there are no error throw by the transaction
I've a question related to transferring balance from the program I've deployed to a PDA the program owns. I see no error but the balance has not changed.

```rust
pub fn transfer_balance_to_player(ctx: Context<TransferBalanceToPlayer>, amount: u64) -> Result<()> {
    let fund_payer = &mut ctx.accounts.house;
    let fund_payer_account = fund_payer.to_account_info();
    let payer_balance = fund_payer_account.lamports();
    let rent_exemption = Rent::get()?.minimum_balance(fund_payer_account.data_len());

    // We check if we have enough funds
    if payer_balance - rent_exemption < amount {
         msg!("Insufficent balance");
        return Err(HouseError::InsufficientFunds.into());
    }

    let fund_receiver = ctx.accounts.player.to_account_info();

    // Transfer balance
    **fund_payer_account.try_borrow_mut_lamports()? -= amount;
    **fund_receiver.try_borrow_mut_lamports()? += amount;
    Ok(())
}

#[derive(Accounts)]
#[instruction(amount: u64)]
pub struct TransferBalanceToPlayer<'info> {
    #[account(mut)]
    player: Account<'info, Player>,
    #[account(mut)]
    house: Signer<'info>,
}
```

```typescript
await program.rpc.transferBalanceToPlayer(
    new anchor.BN(transferToPlayerAmount), {
        accounts: {
            house: houseAccount.publicKey,
            player: randomPlayer
        },
        signers: [houseAccount]
    }
);
```
an error of `    "3H7FCK94N9qWpnAYWHLKakVgek9Z1qqEo3cZULhtrFnz's writable privilege escalated` means that an account needs to be marked as mutable that currently isn't right?
Ah, funny, I totally forgot about that option, cool!
yea, that seems to give me more stack space
you can wrap code logic in brackets {} so its garbage collected and removed from the stack
What do you mean?
I can also start using context brackets, right {}?
You can try various tricks to get around this (Box is one, but won't help here). One idea is to wrap up a bit of your code behind a helper function + invoke the helper function in your instruction hander (the helper function gets a fresh 4kb of stack space).
Yes, that means you've run out of stack space (solana's stack frames are quite tiny, only 4kb)
Is there a general reason for access violation errors?
Getting an access violation error

If I remove a block of code at the end of my program, then the program runs successfully, otherwise, the program does not run.
Did you mark the account as `#[account(mut)]`?
In a NFT collection, you have many different accounts. They are each an SPL Token with a supply of 1. The "mint" is the program that distributes each of the NFT editions. Are you saying the PDA holds a metaplex metadata account for each account in the entire NFT collection?

update: so it looks like with each NFT collection, each individual NFT (part of the collection) has a unique mint. In that case, there'd also be a unique PDA
What information does a Anchor need to verify a PDA account to close the account?
I'm trying to close accounts and get the following error "failed to verify account
: instruction changed the balance of a read-only account"
What does it take to verify a PDA account?
only the program that owns the PDA can sign on its behalf
üëã Have a question about PDAs. In the following code snippet,

```
const keypair = anchor.web3.Keypair.generate();
const [keypairSigner, nonce] =
  await anchor.web3.PublicKey.findProgramAddress(
    [keypair.publicKey.toBuffer()],
    program.programId
  );
```

Isn't the PDA something that anyone with your public key and nonce can get? If so, doesn't this pose a vulnerability as far as PDAs are used for signing on behalf of the original program?
But basically, the metadata account lives at a PDA derived from the NFT (the mint)
Can see some docs here: https://github.com/metaplex-foundation/metaplex-program-library/tree/master/token-metadata/program
```
type IdlAccounts<TProgram extends Idl> = Program<TProgram>['account'];
type FetchType<TProgram extends Idl, T extends keyof IdlAccounts<TProgram>> = Awaited<ReturnType<IdlAccounts<TProgram>[T]['fetch']>>;
type ElementType<T> = T extends Array<infer E> ? E : never;
type Accounts<TProgram extends Idl> = ElementType<IdlAccounts<TProgram>>;
type AccountDefinition<TProgram extends Idl, T extends keyof IdlAccounts<TProgram>> = Extract<Accounts<TProgram>, { name: T, type: { fields: Array<{ name: unknown }> } }>;
type Fields<TProgram extends Idl, T extends keyof IdlAccounts<TProgram>> = ElementType<AccountDefinition<TProgram, T>['type']['fields']>['name'];
type PickAccountType<TProgram extends Idl, T extends keyof IdlAccounts<TProgram>> = Pick<FetchType<TProgram, T>, Fields<TProgram, T>>;

type GameAccount = PickAccountType<MyProgram, 'gameAccount'>;
```
That took quite a bit of hunting, but there you go
How are these different accounts tied together?
So, to incorporate that additional metaplex information, you're going to need to pass in an additional account, the token metadata account (and possible others, I'm not super familiar with metaplex‚Äîat any rate, annoyingly the information you need doesn't all live in one account)
And just to be clear, anchor itself doesn't wrap spl token accounts actually‚Äîthey're still just spl token accounts
Yeah, all of that extra stuff is handled by metaplex (in a separate account)
> So I think the reason you might be getting confused is bc nfts are actually just spl-tokens that have been minted only once the had mint disabled. 

The other question I have here is how that metadata is incorporated. In code, we have `anchor_spl::token::TokenAccount` which acts as a wrapper for SPL token accounts right?

Where is the image, metadata, etc. stored when you serialize it into `TokenAccount`? Or is it that the NFT Account has these additional fields but can be serialized/deserialized into the SPL Token object since it's a strict superset (e.g. NFTs have everything that SPL tokens have but some additional metadata params)
You can treat them like any other spl
We‚Äôll that‚Äôs the cool part! Because nfts ARE spl tokens they don‚Äôt <:bagsLove:500156064507887618>
I'm pretty familiar with the SPL token library and how to incorporate that into the anchor library. The question I'm trying to answer is how my transfer, swap, etc. functions need to change if I'm dealing with an NFT instead of your regular SPL tokens
Unfortunately I don‚Äôt have any off the top of my head. What‚Äôs your use case?
There‚Äôs lots of spl token transfer examples

If you‚Äôre looking into making a different version of a minter like candymachine then the metaplex program library GitHub has all the rust/anchor source code in it which could also be helpful
Thanks for answering my nooby questions! Would you have any recs on good code repos/tutorials that utilize anchor and the metaplex metadata?
Actually no it‚Äôs from the spl-token program. You make a token with decimals zero, mint one, then disable mint all on that
Where is that restriction enforced? Guessing it's within the Metaplex Programming Library?
I just realized you both already talked about this sorry lmao
So I think the reason you might be getting confused is bc nfts are actually just spl-tokens that have been minted only once the had mint disabled. 

Aka 
USDC? Spl-Token
Sea Shanty NFT? Spl-Token

Same exact thing but usdc can keep minting more and the NFT can‚Äôt
Would you have any recs on good code repos/tutorials that utilize anchor and the metaplex metadata?
But there are unfortunately multiple separate accounts floating around under the hood
Yeah
Ah got it. So what you are saying is Solscan just has the metaplex metadata object integrated and is taking that into account when rendering what's displayed.
Since all this extra info isn't directly conveyed by the spl token program/accounts themselves (ugh).
At any rate, all the extra NFT-ness of an NFT in solana-land is conveyed by a whole separate account, the NFT's metaplex metadata account.
And people in solana just can't help themselves with overloading names lol‚Äîso I guess in a sense NFTs *do* have up*date* authorities, which is a totally different idea from a program's upgrade authority (ugh)
Ah, ok‚Äîsorry, I haven't used solscan much and it's aggregating a lot more info than the vanilla solana explorer uses
Nothing‚ÄîNFTs are just funny mints that only mint 1 token ever
Also, posted this up top, but:

> This makes sense. <@!134416332509675520> (pls post full program log) 's previous answer was that if an account has a Mint Authority and an Update Authority it needs to be a program. If you look at this NFT (https://solscan.io/token/CzymaSrMbe5PNvKqi1kJgpTjmD7Wz7iG4c6aCof1Qj6U) It clearly has the mint + program authority. So does this make it a program (executable account)?
> 
> The more broad question I'm asking is: just like how USDC and other fungible tokens follow the SPL token standard, is there an equivalent for NFTs on Solana?
What's the difference between an NFT mint vs. SPL Token mint?
Yep, programs are executable accounts, mints are just regular old non-executable accounts (owned by the spl token program, with a particular data format etc.)
So programs are executable accounts. Are mints another type of account? Feel free to just point me to documentation here üòõ
(Which aren't programs üòõ)
No, NFTs are mints
is there anything you're trying to do specifically? in general i'd say going through Metaplex's candy machine source is probably the best way, although not simple
are there any anchor/metaplex programs you'd recommend reading through? can't seem to find any good tutorials/resources
NFTs rn use Metaplex's token standard
https://docs.metaplex.com/token-metadata/specification


//////////////////////////////////////////////////////////////////////////////////////////

<:rofl_brokenteeth:909587507841204264>
the `declare_id!` doesn't match the deployed program address
lol im stupid
i have a feeling theres something wrong with the programId in the deployment (hence why `The given account is owned by a different program than expected` so I'm trying to redeploy with the right Anchor.toml config) üòÑ
oh that would be a yes
when you are trying to deploy on devnet with `anchor deploy` do you need to set the `cluster` under `[provider]` to `devnet`?
(btw feel free to help or not, I just like to publicly log all my issues so that if anyone else stumbles upon it they can search for solutions i.e. sorry for the spam)
<:thinkcat:837225078877716511>
```
bundle.js:59377 Uncaught (in promise) Error: 3007: The given account is owned by a different program than expected
```
```
bundle.js:37517 Transaction simulation failed: Error processing Instruction 4: custom program error: 0xbbf 
    Program 11111111111111111111111111111111 invoke [1]
    Program 11111111111111111111111111111111 success
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [1]
    Program log: Instruction: InitializeMint
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 2457 of 200000 compute units
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success
    Program 11111111111111111111111111111111 invoke [1]
    Program 11111111111111111111111111111111 success
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [1]
    Program log: Instruction: InitializeMint
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 2457 of 200000 compute units
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success
    Program 7B7ah6bTeycAtj1BihRuRUcDi1q4NJKCGChbV5PTfnMC invoke [1]
    Program log: Instruction: Initialize
    Program 11111111111111111111111111111111 invoke [2]
    Program 11111111111111111111111111111111 success
    Program log: Custom program error: 0xbbf
    Program 7B7ah6bTeycAtj1BihRuRUcDi1q4NJKCGChbV5PTfnMC consumed 10613 of 200000 compute units
    Program 7B7ah6bTeycAtj1BihRuRUcDi1q4NJKCGChbV5PTfnMC failed: custom program error: 0xbbf
```
<:KEK:850127013611569223>
```
bundle.js:59377 Uncaught (in promise) Error: 3007: The given account is owned by a different program than expected
```
okay added this:
`signers: [mintA, mintB],`
Yeah, I think that's your problem
O_O
do we have to include the mints as the signers?
oh wait...
<:thinkcat:837225078877716511>
but all the authorities are the current wallet
```js
                instructions: [
                    web3.SystemProgram.createAccount({
                        fromPubkey: this.wallet.publicKey,
                        newAccountPubkey: mintA.publicKey,
                        space: MintLayout.span,
                        lamports: rent,
                        programId: TOKEN_PROGRAM_ID,
                    }),
                    Token.createInitMintInstruction(
                        TOKEN_PROGRAM_ID,
                        mintA.publicKey,
                        9,
                        this.wallet.publicKey,
                        this.wallet.publicKey
                    ),
                    web3.SystemProgram.createAccount({
                        fromPubkey: this.wallet.publicKey,
                        newAccountPubkey: mintB.publicKey,
                        space: MintLayout.span,
                        lamports: rent,
                        programId: TOKEN_PROGRAM_ID,
                    }),
                    Token.createInitMintInstruction(
                        TOKEN_PROGRAM_ID,
                        mintB.publicKey,
                        9,
                        this.wallet.publicKey,
                        this.wallet.publicKey
                    ),
                ]
```
so i added instructions to my rpc call, and now it's failing on client side with `Signature verification failed`
https://programming-idioms.org/idiom/12/check-if-list-contains-a-value/414/rust
<:Shrug:856158473745727528>
so your constraint would be `list_of_mints.contains(mint.key)`
I mean, I'm *assuming* you could make a list and just use contains
Do you know if there is a good way to do this with a list of mints? eg. allow the user to pass one of [mintA, mintB, mintC] as y_token?
this fixed it
```js
        // Generate the provider and program for Anchor.
        this.provider = new Provider(this.connection, this.wallet, {
            preflightCommitment: "recent",
        });
```
the issue was I didn't define a preFlightCommitment opt when generating the provider
oh nvm i guess you didn't need to fetchIdl, because i was using local idl
ive installed anchor in the https://github.com/metaspan/solana-docker-mac-m1 Dockerfile so im guessing its an ubuntu thing. Would you have a better suggestion for using anchor with the solana-docker-mac-m1 Dockerfile?
<:worriedcry:615396682154377216>
i never used `anchor idl init`
lol
I'm wondering if something is wrong with my idl
hi all, getting this when trying to run an rpc call in js on anchor:
```
bundle.js:59377 Uncaught (in promise) TypeError: Cannot read properties of undefined (reading 'preflightCommitment')
```
Mm, why are you using qemu?
hi guys, im getting the error 
```qemu-x86_64: Could not open '/lib64/ld-linux-x86-64.so.2': No such file or directory```
when trying to run `anchor build` and `anchor test` on a Mac M1. does anyone know of a workaround for this? Thanks!
You can't opt out of account discriminators‚Äî`#[account(zero)]` just says the discriminator hasn't been set *yet*
What are the disadvantages to opting out of a discriminator with zero accounts? We need to optimize a couple program accounts for cost but don't fully understand the tradeoffs.
Hello, is there any RPC endpoint which fetches all of specific NFT address's transaction history?
What I want to achieve is to fetch specific NFT's previous owner.
Hey! What exactly is a slot? Does that represents one *transaction*? Or does it represent one *instruction* within a transaction?
ty!
You can check step finance repo. https://github.com/step-finance/step-staking
Any OS examples of staking spl tokens?
Love to help! And Congratulations!
I am trying to create a token account using the initialize_account function in in anchor_spl

 anchor_spl::token::initialize_account(CpiContext::new(
                self.token_program.to_account_info(),
                anchor_spl::token::InitializeAccount {
                    account: self.pool_token_account_1.to_account_info(),
                    authority: self.authority.to_account_info(),
                    mint: self.token_1.to_account_info(),
                    rent: self.rent.to_account_info(),
                },
    ))?;


I am passing my accounts like this in the account structure

 #[derive(Accounts)]
pub struct GetPair<'info> {
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
    #[account(mut)]
    pub token_1: AccountInfo<'info>,
    #[account(mut)]
    pub token_2: AccountInfo<'info>,
    #[account(mut)]
    pub authority: AccountInfo<'info>,
    #[account(mut)]
    pub pool_token_account_1: AccountInfo<'info>,
    #[account(mut)]
    pub pool_token_account_2: AccountInfo<'info>,
    pub token_program: Program<'info, Token>,
    pub rent: Sysvar<'info, Rent>,
}

ERROR : 'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA failed: invalid account data for instruction',
Hey guys! I have maybe strange question, but maybe someone could help me with this. So I want to have for example 2 contracts (A and B) with exact same instruction name and exact same arguments and accounts (`A::foo(ctx: Context<...>, amount: u64)` and `B::foo(ctx: Context<...>, amount: u64)`). And I want to call `foo` in third contract C instruction `C::callFooFromAorB(ctx<...>)` using CPI, like in pure Solana `invoke( &Instruction { program_id: A_or_B_Program_Id, accounts: cpi_accounts,  data: A_or_B::foo(amount), },...)` and I do not know how to do this with anchor instructions as on anchor we have `sighash` not an enum for instructions like in pure Solana. Is there some example how to do this in anchor? Not sure if I explain it correctly! Thanks in advance!

P.S. The trick that I try to achieve similar to implementation of instruction `ReceiveFlashLoan` in SPL `flash_loan_receiver`.
there is something like try_deserialize but I dont know how it works
I want to unpack the mint account to get the mint authority? how do I do it in Rust
Thx so much, it works! I added 10 sol more in case
I'm trying to understand the Solana helloworld-program I stucc uwu
What does it usually mean wen rpc send this bacc ```{'jsonrpc': '2.0', 'error': {'code': -32602, 'message': 'io error: failed to fill whole buffer'}, 'id': 1}```
Frens I'm sorry if this is too beginner, I'm literally baby level solana skillz
correct
ah I see - so it'll almost always be safer and easier to use the former then, thanks!
the former does a little more. it also checks that the token account is the associated token account of the given authority and mint
is the account constraint `associated_token::authority = signer` equivalent to `constraint = token_account.owner == signer.key()` , or am I missing something?
<@!848333406849073202> Thanks for the advice I'll try it
maybe try `anchor test ./tests/dao.test.ts`
i set up testing of multiple programs using npm scripts, i.e. `"test::init": "anchor test ./tests/init.ts"`
if you want an instruction you can use `await program.instruction.swap`
Hello, inside my anchor dir I've multiple program
```
‚îú‚îÄ‚îÄ programs
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ dao
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ tutorial
‚îú‚îÄ‚îÄ tests
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ dao.test.ts
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ tutorial.test.ts
‚îú‚îÄ‚îÄ Anchor.toml
```

Then I've done the following inside my Anchor.toml
```toml
[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"
test-dao = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/dao.test.ts"
test-tutorial = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/tutorial.test.ts"
```
But I cannot run `anchor test-dao`
Is there a way to run test only for one program?
Disclaimer: I know nothing about on-chain development on Solana so bear with me
Figures
like Balances dict in an ERC20 contract
how else do we go by doing it using accounts
i understand we need to provided a size for it in deserializing and stuff
use BTreeMap or HashMap or something
can we implemend dictionaries in solana
bros
the whole point of anchor is to avoid such horrid pain.
you will have to compute the signhash of swap and encode manually parameters
running anchor test results in "Error: Error loading workspace IDL for account" , but the ./target/idl/[name].json file exists. 
any pointers why this is happening?
I'm just not sure how to handle the `data` when your anchor instruction has multiple arguments
instead of
```js
    // Create the new account and initialize it with the program.
    const tx = await program.rpc.swap({
      accounts: {
        state: statePubkey,
        signer: provider.wallet.publicKey,
        tokenProgram: TOKEN_PROGRAM_ID,
        xTokenAccount: userAssociatedTokenAccount.address,
        yTokenAccount: userNewTokenAccount.address,
        xTokenMint: TOKEN_A_MINT.publicKey,
        yTokenMint: TOKEN_B_MINT.publicKey,
        yPool: associatedOutgoingAccount,
        cpiAuthority: cpiAuthorityPubkey
      }
    });
```
i'd like to use
```js
export const createSwapInstruction = async (signer, userAtaA, userAtaB) => {
  const data = buffer.Buffer.alloc(0);
  let keys = [{
    pubkey: PHASE_STATE_ACCOUNT,
    isSigner: false,
    isWritable: true
  }, {
    pubkey: signer,
    isSigner: true,
    isWritable: true
  }, {
    pubkey: TOKEN_PROGRAM_ID,
    isSigner: false,
    isWritable: false
  }, {
    pubkey: userAtaA,
    isSigner: false,
    isWritable: true
  }, {
    pubkey: userAtaB,
    isSigner: false,
    isWritable: true
  }, {
    pubkey: ROPE_TOKEN_MINT,
    isSigner: false,
    isWritable: false
  }, {
    pubkey: PHASE_TOKEN_MINT,
    isSigner: false,
    isWritable: false
  }, {
    pubkey: PHASE_POOL_ACCOUNT,
    isSigner: false,
    isWritable: false
  }, {
    pubkey: PHASE_AUTHORITY_ACCOUNT,
    isSigner: false,
    isWritable: false
  }];
  return new TransactionInstruction({
    keys,
    programId: SWAP_PROGRAM_ID,
    data
  });
}
```
for example
if I'd rather not use `Anchor`
does anyone know what the equivalent method is to create an instruction to interact with your program?
<@!164924128065748993>
Serum hackathon ü§î
shoutout to <@!134416332509675520>  for teaching me like all of anchor, and paulx's help too
+1 to this
you guys are the knights in shining armour üòÑ
we'll try this then
thanks a lot
nvmnvmnvm i just read the message. Yes you would need to reserialize if its not an accepted type
https://github.com/project-serum/anchor/blob/master/spl/src/dex.rs ware you using this
the serum library in the anchor spl works fine for me
And deserialize them in your program (using serde)
Otherwise you could of course pass the dex instruction as serialized bytes (like, a Vec of bytes I guess)
Anchor expects instruction arguments to use borsh; that's just the way it is.
The workaround you mention is the way I would do it
we are in the hackathon and not getting any response from the serum team
it's very urgent
Please don't at-message for non-urgent questions üôè
Hi <@!501570363566587905> <@!448034961652449283> <@!831450660146642974> <@!867369388608061470> <@!117243115676499972> could you please help with this issue:

> i have a question about an error i'm getting, "the trait bound `serum_dex::instruction::NewOrderInstructionV3: anchor_lang::AnchorSerialize` is not satisfied"
> 
> i'm getting this error because i'm attempting to have an argument which has the type serum_dex::instruction::NewOrderInstructionV3, but it looks like serum uses serde for de/serialization, and anchor expects borsh. in the past, i've kind of gotten around this by declaring a custom type that derives borsh de/serialize, and having a custom function to convert it to the serum type before using it in CPI calls to serum or mango, but i was wondering if there's a better way to do this?
Anyone else see this sometimes happen on  long test-suite runs?  
```
Error: Unable to obtain a new blockhash after 10068ms
      at Connection._pollNewBlockhash (node_modules/@solana/web3.js/src/connection.ts:3549:13)
      at Connection._recentBlockhash (node_modules/@solana/web3.js/src/connection.ts:3522:12)
      at Connection.sendTransaction (node_modules/@solana/web3.js/src/connection.ts:3665:39)
      at Object.sendAndConfirmTransaction (node_modules/@solana/web3.js/src/util/send-and-confirm-transaction.ts:29:21)
      at transferLamports (client/utils.ts:82:23)
      at Context.<anonymous> (tests/account.test.ts:79:9)

```
How could this be accomplished? Is this a use case for vaults?
thanks for the clarity boss
Correct. The PDA is derived from the initiating program, so a different program won't be able to sign for it
```
pub struct Burn<'info> {
    pub mint: AccountInfo<'info>,
    pub to: AccountInfo<'info>,
    pub authority: AccountInfo<'info>,
}
```
We're attempting to burn a token, but the authority is a PDA that our signer has authority over. We tried to use signer seeds here to burn but it didn't work. Is the issue here that this PDA account is initialized in a different program so we can't use it to sign?
Cool, thanks.
Yep, try jumping to source on AccountInfo‚Äîit doesn't directly store the lamports, it stores a reference to them
Wow.  I'm an idiot.  How is that working?  is there some ref sharing underneath the covers?
```
  transfer_from_account_we_own(
            &mut platform_payee.to_account_info(),
            &mut platform_withdrawer.to_account_info(),
            amount,
        )?;
```
That should be fine
Does using a cloned copy fail?
I've got that part - I can't find any method that doesn't result in a cloned copy of the `AccountInfo`   `to_account_info` appears to be a copy
```
let platform_payee = &mut ctx.accounts.platform_payee;
transfer_from_account_we_own(
            platform_payee.to_account_info(),
            platform_withdrawer,
            amount)

```
You just need to annotate its declaration in your `derive(Accounts)` block with `#[account(mut)]`
How can I get a mutable AccountInfo from the context?  I'm trying to transfer lamports from a non-sytem PDA as has been discussed here before:
```

fn transfer_from_account_we_own(
    src: &mut AccountInfo, // we better own this account though!
    dst: &mut AccountInfo,
    amount: u64,
) -> ProgramResult {
    // we can decrement the src account's lamports b/c we own it
    **src.try_borrow_mut_lamports()? = src
        .lamports()
        .checked_sub(amount)
        // or whatever, some error of your choosing
        .ok_or(ProgramError::InvalidArgument)?;
    // *incrementing* an account's lamports is always ok though
    **dst.try_borrow_mut_lamports()? = dst
        .lamports()
        .checked_add(amount)
        .ok_or(ProgramError::InvalidArgument)?;
    Ok(())
}
```
Well now we know! Thanks man!
It is very weird because on localhost this error never pop out
I finally find what was going wrong. This error AKA 2001 mean authority constraint was violated on the program
Awesome Thanks!
thanks, I will try
switchboard vrf https://github.com/switchboard-xyz/vrf_req_example
Anyone know the best way to get some sort of randomness in a program? I hesitate to try the rust rand library
Dope!
done <:dankfingers:581630874462978059>
But, it's just a thought
Maybe try something like this

```
let check_in = &mut ctx.accounts.checkin_account;

check_in.bump = checkin_account_bump;
check_in.token = token;
check_in.authority = ctx.accounts.authority.to_account_info().key;
check_in.audience = ctx.accounts.audience_account.to_account_info().key;
check_in.register_count += 1;

Ok(())
```
every tests pass
but it is very weird as it work fine on localhost
ok i will try it
I'm predominately from C, and I'm still learning rust. However, dereferencing  this `*ctx.accounts.authority.to_account_info().key`  and this `*ctx.accounts.audience_account.to_account_info().key;` seem suspicious; 

try this? Try taking out those `*` at the beginning
same for me, no result in google
No idea - I checked a couple of places - nada
if you can tell me what 0x7d1 error mean I  guess I can figure it out by my own
it works fine on localhost
```
   pub fn register(ctx: Context<Register>, checkin_account_bump: u8, token: String) -> ProgramResult {
        ctx.accounts.checkin_account.bump = checkin_account_bump;
        ctx.accounts.checkin_account.token = token;
        ctx.accounts.checkin_account.authority = *ctx.accounts.authority.to_account_info().key;
        ctx.accounts.checkin_account.audience = *ctx.accounts.audience_account.to_account_info().key;
        ctx.accounts.audience_account.register_count += 1;

        Ok(())
    }
```
Post the function that threw this
```index.js:1 Transaction simulation failed: Error processing Instruction 0: custom program error: 0x7d1 
    Program AAewkvZ3G72Mrtbsv5aMoZBNmsAx1U2aAswsQaj8nR3C invoke [1]
    Program log: Instruction: Register
    Program 11111111111111111111111111111111 invoke [2]
    Program 11111111111111111111111111111111 success
    Program log: Custom program error: 0x7d1
    Program AAewkvZ3G72Mrtbsv5aMoZBNmsAx1U2aAswsQaj8nR3C consumed 16560 of 200000 compute units
    Program AAewkvZ3G72Mrtbsv5aMoZBNmsAx1U2aAswsQaj8nR3C failed: custom program error: 0x7d1```
Post up the whole error message
Hi everyone. I'm having this error when testing my program on devnet: error: 0x7d1 . Anyone know what that mean?
Also, you should send me a friend request
I forgot to sign it :p All good!
i see you got the help you need but if you need help lemme know
yeah its in my program now
Thanks!
Yep!
And I take it the authority would be the TokenAccount's owner. Correct?
`to` here is really `from`‚Äîits the token account your burning tokens from
Ah, yeah, the `to` wording doesn't make sense (guess anchor should change this)
Has anyone burned a spl yet in a contract?
Below is the struct for the cpi context.

**mint:** I get this
**to:** Not really sure of this wording, i'm guessing this is the TokenAccount that we are burning from
**authority: **owner of **to:**?

Anyone know what's expected for **to:**?

https://docs.rs/anchor-spl/0.5.0/anchor_spl/token/struct.Burn.html

```
pub struct Burn<'info> {
    pub mint: AccountInfo<'info>,
    pub to: AccountInfo<'info>,
    pub authority: AccountInfo<'info>,
}
```
<:thinkcat:837225078877716511>
oh i guess you can't use it in this way because you need an authority
```
use anchor_spl::{
    associated_token::AssociatedToken,
    mint,
    token::{TokenAccount, Mint, Token}
};
```
using the given import example
when i try this it's telling me 
```
error[E0425]: cannot find value `mint` in module `associated_token`
```
hmm
```
#[account(
    associated_token::mint = mint,
    associated_token::authority = payer,
)]
pub second_token: Account<'info, TokenAccount>,
```
oh nvm i guess this works
i guess you need to use `init` though...
hmm
https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html
nvm found it
ok, understand, thx üôÇ
To do this on-chain the only way is to pass in the mint as an account
Oh I don't believe there's a way to do it on-chain
about web3js all easy üôÇ
nono, in rust program inside chain
you can use `getParsedAccountInfo`
are you talking about on web3js?
hmm, I need to ask about this TokenProgram?
```rust
    #[account(
        mut,
        constraint = token:mint = y_token_mint,
    )]
    pub y_pool: Account<'info, TokenAccount>,
```
anyone know how to use the accessors on `TokenAccount`? trying to make a mint constraint for a `TokenAccount` argument
Not directly no, the decimals are stored on the mint, not the token account itself
but if i have associated token account i can't get this info? (maybe not from anchor but from solana sdk)
You'll need to pass in its mint as an account + use `Account<'info, Mint>` etc. Then you can do `the_mint.decimals`
sorry guys for one more question, but i can't found in any docs in docs.rs. How i can get info about token by pubkey? i want to get decimal
Awesome that's what I was looking for! Thank you!
https://github.com/project-serum/anchor/blob/bbfaf9d7124838204a3838b6bcfdd81f1de4ea25/ts/src/provider.ts#L223
Have you tried jumping to source on Wallet?
Can do it within your program too
`return Err(ErrorCode::Hello.into());`
If you have an error you can return that too! https://project-serum.github.io/anchor/tutorials/tutorial-4.html
thx guys
-_-
`return Ok(());`
I guess I don't totally understand how providers work - any thoughts on getting another one (not from anchor.Provider.env()) in an anchor test? In the Provider constructor, I can't seem to find out what a Wallet Object is
and one small question, how i can finish program  not at the end of function? like return
In the `instructions:[]` param I pass it one of these after grabbing the ATA from `findAssociatedTokenAddress` 
```
serumCmn.createTokenAccountInstrs(
      provider, 
      ata, 
      ming, 
      owner
    );
```
When in doubt, clear it out! (If you can)
thanks
yeah
Don't think about it too much
lol, then just copy over your code
hmm this works lol
thanks. will try that then
I do it client-side
Just for a sanity check, try creating another project `anchor init test`
hey guys, a noob question - can smart contracts create the associated token account for user or does it have to be created outside of smart contract and then passed for token transfer?
probably
maybe i am running a newer anchor?
I'm surprised I haven't run into this myself, I get the same 1.56.0
going to try that
Mm, ok, I guess you could try rebuilding solana from source with a fresher rust?
Aha interesting
cargo +bpf --version returns 1.56.0
seems like it
Hmm, not sure. Is 1.56.0 the rust you used when you built solana or something?
All good! I just learned that today üòÑ
oh, thx, i'm stupid üòÑ
Yeah ^
your_token.mint
nono, about amount i know, what about for which token this tokenaccount?
Just `your_token_account.amount`
hehe, happens. Any idea whats happening here?
i thought anchor maybe has some constraint for account
Oh lol you already printed that üòõ Sorry
sorry, it's question or? üôÇ
cargo --version = 1.58.0
1.58.1
What does `rustc --version` say?
Like how can you check if a TokenAccount has a balance?
i updated solana and rust packages, still
running into this weird error

Got it! DENIED!
hello guys! How i can check that TokenAccount with definite mint?
Try accessing it!
so the provider.wallet.keypair is not the actual keypair? For the wallet?
Phantom will never ever give you the keypair itself, just the ability to ask phantom to sign a tx
Is there a safer way to sign clientside?
I have a security question, on the client-side I have something that needs to be signed. I get the Provider from Phantom. This gives me access to the Keypair? Is that safe?  Like, If I was malicious, I could just save the privatekey.

```
  const getProvider = () => {
    const connection = new Connection(network, opts.preflightCommitment);
    const provider = new Provider(
      connection, window.solana, opts.preflightCommitment,
    );
    return provider;
  }

        await program.rpc.buyCoffee(
          numToRust(solTolamports(0.1)),
          {
            accounts: {
              coffeeJar: coffeeJar.publicKey,
              from: provider.wallet.publicKey,
              to: barista,
              systemProgram: SystemProgram.programId,
            },
            signers: [provider.wallet.Keypair]
          }
        );
```
When I created the token I did it with --decimals 0 which I think made 1 = 1, not 1 = 1000000000 (lamports)
Ah, I think I found the issue, I was getting a `insufficent funds` error, it's not due to sol, but to how many tokens are in the account! Thanks!
And that will generally be paid for by the `provider.wallet`, the thing that submitted the tx from the client
There's no fee for the token transfer itself‚Äîthere's just a fee for submitting the entire transaction
Also 2 Questions:

1. Who pays for a spl token transfer? From, or Authority?
2. Is there a way to get the TX fee dynamically in Rust? - I have a nonce account that owns a vault TokenAccount. I want the user to pay for the TX transfer from the vault to their account.

https://docs.rs/anchor-spl/0.5.0/anchor_spl/token/struct.Transfer.html#structfield.authority
If it says you need 1.6, have 4 on hand
How much sol? Take what you think you need and double it
```Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: custom program error: 0x0```
```
/// 0
#[error("Lamport balance below rent-exempt threshold")]
NotRentExempt,
```
I keep getting instructionError `0` , but I definitely have enough balance in my account?
```rust
    #[account(
        mut,
        constraint = *x_token_mint.key == state.x_token_mint,
    )]
    pub x_token_mint: AccountInfo<'info>,

    #[account(
        mut,
        constraint = *y_token_mint.key == state.y_token_mint,
    )]
    pub y_token_mint: AccountInfo<'info>,
```
then you can do
```rust
    /// Initialization ix.
    pub fn initialize(
        ctx: Context<Initialize>, 
        bump: u8,
        cpi_authority_bump: u8,
    ) -> ProgramResult {

        msg!("Initialize");

        // Load state.
        let state = &mut ctx.accounts.state;

        // Set PDA bump used to derive the exchange PDA.
        state.bump = bump;

        // Set the admin of the protocol.
        state.admin = *ctx.accounts.admin.key;

        // Set the pool authority - random key owned by the program.
        state.cpi_authority = *ctx.accounts.cpi_authority.key;
        state.cpi_authority_bump = cpi_authority_bump;

        // Set the mint constraints.
        state.x_token_mint = *ctx.accounts.x_token_mint.key;
        state.y_token_mint = *ctx.accounts.y_token_mint.key;

        Ok(())
    }
```
<:Shrug:856158473745727528>
(like shown above)
then I lock `initialize` usage to only my pubkey
during initialize I set the token mints so then cpi authority MUST use those mints
yeah what I did is I set the token mint constraints in the initialization using states
yeah token mints are the tricky one.. if you build spl agnostic but dont want to accept anything but solana
Yeah I tried to avoid hardcoded pubkeys, but in this case this program is only to be used with a single token mint, so I wanted to make sure no one will be able to pentest their way around it
Doing `solana-test-validator -r` works too
I have found you can often refactor to avoid hard coded pubkeys, curious how often its used
```rust
use solana_program::pubkey;
use anchor_lang::prelude::*;
...

const PHASE_AUTHORITY: Pubkey = pubkey!(
    "38Wh82EtdDPWJUbBHU2zGdJ9gqertdrBxVxyGtYTDBZ1"
);

...

    #[account(
        signer,
        constraint = *admin.key == PHASE_AUTHORITY
    )]
    pub admin: AccountInfo<'info>,
```
for anyone still wondering about the `!pubkey` this worked for me
you can delete the test-ledger file
dumb question.. if we have `init_if_needed` on an account and then pass in an already initialized pda, do we need to sign or do something else? I run into `    Program log: Error: owner does not match`

edit: it was a simple bug, make sure the token::authority is the same on both instances of using an init_if_needed
how do I reset my local validator state?
I've tried:

```
const getProvider = (keypair) => {
  const connection = new anchor.Connection(
    anchor.web3.clusterApiUrl('mainnet-beta'), 
    "processed"
  );
  const provider = new anchor.Provider(
    connection, 
    playerSecret.toBuffer(),
    "processed",
  );
  return provider;
}
```
But still - Anyone know how we'd get a second Provider in an anchor js test?


//////////////////////////////////////////////////////////////////////////////////////////

or the docs for it https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html#instruction-attribute
thanks
Yep, easiest way to learn about it is by searching through the anchor tests/ directory
Does the #[instruction()] attribute still exist? Couldn't find any doc about it but it's used in this tutorial: https://www.brianfriel.xyz/understanding-program-derived-addresses/
Just to know if I understood some things.  I guess it is possible to make a Shop on the blockchain?  Each product can be saved there (a product = an account) and via a payment in SOL one can obtain the product?  The limit being the delivery system.  To deliver the product to the user, you must have your postal address and unless he enters it with each order, you cannot save your personal information on the blockchain.  So there is a certain user experience limit.  And then I guess we have to build several smart contracts for the different layers of our app?  A smart contract so that the user can sell and manage their stocks, and a smart contract so that another can buy.  With Anchor you can develop and deploy several contracts?  Because the first time it deploys is the lib.rs.  But how do you tell him to deploy a new program for the first time?  Unless suddenly you have to think about putting everything in a single contract
Currently 1 to 1 NFT exchange is working fine. 
Next I want to do 2 to 1 exchange,. For this I will need to include an extra mint field.
But I want this to be optional, so that if I pass in all 1s or all 0s as the address for the second mint, I can treat the flow as a 1 to 1 NFT
And just to make sure I'm following, why do you want to only do this deserialization conditionally?
Yes. TokenAccount. 
Account<'info, TokenAccount>
You mean a token Account object?
Ok, understood. Next question, how do I get Account object from AccountInfo?
No, not within the `derive(Accounts)` stuff. You would have to type it as `AccountInfo` and do the conditional logic yourself in your instruction function.
Is there a way to tell anchor not to deserialize an account, based on a condition?
True. Maybe rent for 48 hours vs rent exempt makes it cost effective to short the "Solana is crashing" knee jerk market reactions? Not the purpose of this channel so I'll shut up now.
Going the multiple fields, path, I am not sure how to deal with optional fields when it comes to constraints.
The Vec approach is not compiling, am I correct to believe it is a limitation on Anchor?
Either use a Vec or have multiple fields for each token. mint1, mint2, mint3 etc..
However I am unable to figure out how to handle multiple mint fields in the Initialize struct
I am trying to extend the escrow program to handle multiple NFTs
This program already exists
Its already the one I do !
But for what it's worth, loading up a bunch of data into a bunch of accounts is kind of expensive to do
Yeah, you'll probably get rate-limited (as far as I know)
Curious as to the statement, "maybe that will irritate validators". Is that a potential attack vector from within? E.g. deploy a program and load it up with dummy data so that ```program.account.whatever.all()``` can be used as a DoS attack vector?
Thanks, will try that one!
You might be able to get away with just doing `await program.account.userDataAccount.all()` (maybe, that will irritate validators since it's potentially an expensive request)
I actually want to store dynamic state somewhere. The program I am trying to create needs some kind of home page where I can fetch and visualize an overview of data accounts that are available within 'the program'. So, I would let user create the individual data accounts and store references to these accounts in a kind of global program account. Does this approach make sense?
And then if you want, you can just redeploy your program to update that state (and if you want to think of it in terms of the "everything goes in an account" perspective, that state is living in the account that stores your code)
No, but if you want *actually* static state you can always just embed that state right into your program:
```.rs
const ACTUALLY_STATIC: &'static str = "super important constant string";
```
Is there a way to create a program PDA that holds global program state at deploy time of a program? I.e. in such a way that it is properly initialized at the time of deploy.
It stores the program code directly at the program_id address, whereas the full upgradeable loader stuff instead has the program_id account just point at a separate PDA that holds the actual program code
I haven't verified this myself, but interestingly, the way anchor test embeds your program in the "genesis block" (assuming you don't have a live local validator running in the background, that you deploy to etc.) means that your program actually doesn't have an upgradeable programdata account
üëç  thanks a lot..
I mean u will pass the address always. Just if the account is not initialized it will init
Yh
how i can adding mutable on authority,please let me know.
Hi, is this correct way to test for Anchor program errors?
```await expect(program.rpc.revealAnswer(1, {
            accounts: {
                question: questionKeypair.publicKey,
                game: gamePDA,
                authority: provider.wallet.publicKey,
            },
        })).rejects.toThrow(programError(318, 'Answer already revealed.'))```
Where programError is:
```
export function programError(code: number, msg: string): anchor.ProgramError {
    return new anchor.ProgramError(code, msg, `${code}: ${msg}`)
}
```

It seems to be used in a project that's new to me,  but my tests don't pass with these errors:
```
Expected message: "318: Answer already revealed."
    Received message: "failed to send transaction: Transaction simulation failed: Error processing Instruction 0: custom program error: 0x13e"
```
Hi Team. I am looking for an example of how to create a durable nonce account using the anchor. Any link to guide/tutorial would be really helpful. <@!501570363566587905>
So while calling the createFn if I pass this `position_pda`account, it won't init otherwise it will init, am I right ?
there are some other attributes needed, the compiler will tell you
``` 
#[account(
        init_if_needed,
        payer = owner,
        space = 8 + PositionAccount::LEN
    )]
    pub position_pda: Box<Account<'info, PositionAccount>>,
``` 
sth like this tho
hmm let me find some, omw right now but when im on the laptop
Do you any example of this. I dont see it in any of the examples in the anchor's example repo
super naive implementation ofc
sth like
```
yarn 
``` 
then go into package.json
```
{
    "scripts": {
"run-and-deploy-both-projects": cd project1 && anchor build && anchor deploy && cd .. && cd project2 && anchor build && anchor deploy}, 
...
}
```
the package.json might be easier haha, should take 3 minutes to setup
i.e. it's a program-flow thingy for which people suggest to not use it. but it's all safe, etc. (just, it might be easier for you as the programmer to have bugs when you use it, so i guess be sure that there are no "side-effects")
no, it's fine to use it. the reason people say not to use it is because it is easier to introduce bugy doing it (i.e. there could be the case that the program flow should have the account existent, and this would mean that creating it from scratch is a mistake).
yeah..but people here are suggesting not to use it if not sure
Me nether ü•≤ still searching for it
have you checked the `init_if_needed` macro? this will create the account if it does not already exist
ah I think i misread your question
you can store a reference to A from within B? perhaps you can setup the PDA seeds in such a way that a one-to-many relationship is enforced
I guess easiest way to is to create a custom package.json and create an additional command which does both. I don't know of any "out of the box" tools to achieve this, however
I have two accounts A and B. A has `one to many` relationship with B. In CreateB fn  I want to create A only if is not already present. How do I achieve this ?
Hello everyone. Have a nice day!. Currently am trying to write solana program with anchor framework. Is there anyway I can write two or more independent programs in one anchor project and build all of them in one "anchor build" command?
Ill talk to them again
ideally, the solana team would just update their code so --bpf-program uses the latest loader
I see. This may be a naive suggestion but would it be possible to specify bpf loader when running `anchor test`?
youre not. thats all it does!
I see the following:
```      - run: solana-test-validator -r --quiet &
        name: start validator
      - run: cd tests/bpf-upgradeable-state && yarn
      - run: cd tests/bpf-upgradeable-state && yarn link @project-serum/anchor
      - run: cd tests/bpf-upgradeable-state && anchor build
      - run: cd tests/bpf-upgradeable-state && solana program deploy --program-id program_with_different_programdata.json target/deploy/bpf_upgradeable_state.so
      - run: cd tests/bpf-upgradeable-state && cp bpf_upgradeable_state-keypair.json target/deploy/bpf_upgradeable_state-keypair.json && anchor deploy && anchor test --skip-deploy --skip-build```
Does this mean to start the test validator manually, deploy the program normally, then run anchor test without deploying or building? Or is there more here that I'm missing?
Thank you so much I knew there was a good reason for this.
in anchor test we add programs with the --bpf-program flag and unfortunately this loads them with the bpfloader2. check out the bpf-upgradable-state ci in our tests.yaml for a workaround
Hi started trying out the tutorial on anchor-framework, 
been getting this error 
```
ANCHOR_WALLET=/Userspath/.config/solana/id.json  node client.js                           

Running client.
/Userspath/Desktop/rust-stuff/solana-work/anchor/examples/tutorial/node_modules/@solana/web3.js/lib/index.cjs.js:5965
      throw new Error('failed to get recent blockhash: ' + e);
            ^

Error: failed to get recent blockhash: FetchError: request to http://localhost:8899/ failed, reason: connect ECONNREFUSED ::1:8899
    at Connection.getRecentBlockhash (/Users/Desktop/rust-stuff/solana-work/anchor/examples/tutorial/node_modules/@solana/web3.js/lib/index.cjs.js:5965:13)
...
...
...
    at async main (/Users/Userspath/Desktop/rust-stuff/solana-work/anchor/examples/tutorial/basic-0/client.js:24:3)
```
Have the solana validator running and 
On making wget http://localhost:8899/ I do get a 405 response, which means the port is in use, but for some reason my program cant access it. 
 
Also I get this only with the javacript client, I tried making it via the python client, and it did not throw any errors. Is this is a permissions issue ? 
Or say the validator node is accessible at localhost but not at the 0.0.0.0 which javascript it trying to access ?

Any help on what should I look into, what are the potential points of failure here
Anyone been profiling solana programs in a way or another?
https://github.com/CalebEverett/nftfactory/blob/2c0e99f11e06fa8590cef1034856678388bcc9ec/Anchor.toml#L18
Weirdly for me. `ctx.accounts.program.programdata_address()` is returning `None` in `anchor test` so I cannot test using the upgrade authority as a constraint. Any reason why that is?
basically you want to constrain the uniqueness on 2 fields independently. My first instinct is a naive solution, which is to create a PDA from the public key and another PDA from the username. If you use `init` on the macros for both accounts, if it's already initialized then the instruction will reject. Maybe others have better ideas but this is the simplest I can think of that is on-chain.
help this poor soul ;-;
<@!134416332509675520>
PDA stuff
1) I like this one: https://dev.to/dabit3/the-complete-guide-to-full-stack-solana-development-with-react-anchor-rust-and-phantom-3291

No idea on #2, I've only ever used `anchor test`
Yeah - or hardhat - cus I like that better.
Bonus noob question : Anchor is like Truffle for Solidity ?
And that's my last two noob questions for today:

1) Do you have any docs/tutorials for creating Solana dapps with Anchor/React? I need to make several docs to understand what I'm doing.

2) Why does the unit test not react the same depending on the CLI command I'm doing? Example:
- anchor run test
- runs the test
- error "Fallback functions are not supported"

- anchor test
- runs the test
- test passed

I specify that in the example one I have a local ledger launched
Thx I'll check !
You can do this to truly nuke your program: https://jstarry.notion.site/Program-deploys-29780c48794c47308d5f138074dd9838#147e89b2c27e4429ba45075e722e73ac
Yes
What do you mean by deactivate? Delete? Render unusable?
Taking a look now - thanks for hookup
Not sure if this covers what you want, but here's an example of a program-controlled mint: https://github.com/cqfd/anchor-token-studies/blob/main/programs/token-studies/src/lib.rs#L95
Another basic question! Is it possible to deactivate a program? Let's say I develop a Smart contract and there is a case I didn't manage. It creates a flaw and if someone finds it he can exploit it and literally break a whole project. And those, all the time that I find the problem, that I fix it and that I re-deploy it
When creating a mint account is it normal to use the CLI for the initial setup or is there a good tutorial on how to do it in code
ahh. got it. makes sense thank you.
So there they're cloning the programs themselves (slight wrinkle since you actually need to clone *two* accounts for a single program, because it's deployed with the upgradeable loader program)
Yeah, just those specific accounts‚Äîyou can manually specify however many you want
Does this clone both the program and the accounts? I assume just the program otherwise it's way too heavyweight for things like metaplex
Thank you
Yep!
Amazing. Is this in `Anchor.toml`?
And just straight up clone accounts from devnet etc.
üëç  Thanks ! I don't need it now but I learn some differents logic. That can help me for understand some things üôÇ Thx
You can actually use the clone feature: https://discord.com/channels/889577356681945098/889702325231427584/943483106852212766
Yep. In the example I gave, the receiver would be receiving back the lamports, so you could make that the author.
hey jinx. I actually came here to ask a question. If my program has dependencies on other programs for CPI, how do I make that work in `anchor test`? I assume I have to deploy the other programs in the  `before` hook of test? Are there examples of this?
Ooh I see! Indeed since a tweet is an account, we can drain it, close it and send back to the author the drained funds
from here: https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html
In solana, you drain their rent lamports (and then send them to someone else, e.g. refund the poster)
You can close the account. 

```#[account(mut, close = receiver)]
pub data_account: Account<'info, MyData>,
#[account(mut)]
pub receiver: SystemAccount<'info>```
You can close accounts just fine!
So it's a question of logic. In Web2, we use a CRUD to manipulate the data. In our case in Web3, assuming we want to make a Twitter like.

I user I want to tweet, I do it and the tweet is recorded in the blockchain. However, I can't delete it, can I? In this case, how to do the D of the CRUD? Should we think about an active/inactive status and display on our projects only active tweets but inactive ones remain visible on the blockchain? Or is it possible to clearly remove information from the blockchain?
Thanks I‚Äôll take a look!
I haven't actually tried this myself, but yes, you can freeze an account: https://spl.solana.com/token#freezing-accounts
Is there a way to make a token non transferable once it‚Äôs minted?
Hehe just found that too, nice üôÇ
seems to work ok for now
ok i just tried with `let secret: &'static str = env!("SECRET");`
Mm, yeah, I feel like I learned how to do that at one point but now I can't remember ü§î
What if the secret isn't that big of deal to store as machine code binaries but I don't want it in the repo, is there a good way to use environment variables to inject these variables at compile time
Yes, I see. In itself I am not affected by this problem. I saw on the Solana Discord someone who wanted to do this and I had the same speech as you. I'm just taking advantage of a brand new discord with new future friends to make sure I'm not talking nonsense üôÇ
Your program itself also lives in an account/blockchains are public etc.
But decrypting the data on-chain, within your program, doesn't really work, because you can't really store anything secret *in* your program
Yes ok I understand
Well, you can store whatever data you want in an account‚Äîit's just bytes
And encryption does not cause problems with validators?
No, there isn't really any way to store private data (you could encrypt it, but anyone can download an account's data at any time)
For example on the current Web2, we can save data in a DB and be able to access this data if the user pays a subscription for example. On the blockchain side, it is literally a DB open to everyone. So my question is, is there a way to store private data, recoverable only under certain conditions like for example that the payment of a subscription has been made? I believe that on ETH with Solidity there is the possibility to save private data
What do you mean by "recoverable" here?
And I was wondering, do you know if it is possible to store on the blockchain specific data recoverable only if the user has paid?
All right. I don't understand anything you're saying ü•≤. I'm learning to do Rust and use Anchor at the same time. I understand some of the logic but it takes time to get familiar with it all. I already understand that you have to use accounts for almost everything etc.. I still don't see what SystemProgram is really for. I do, I see that it works and generally I try to understand why after lmao
Idiomatic anchor will very rarely use AccountInfo
Or really any incoming program
But yes, you should use what I wrote every single time you interact with the system program
Lol
Ofc Program
That's not what I wrote üòõ

Ok I understand. Its always the same case ? When I use the system_program field I need to use System ? Actually have this error:

Wrong number of type arguments: expected 0, found 1 (AccountInfo)
Anchor is telling you that doing that is a bad idea‚Äîyou should be verifying that the incoming account really truly is the system program (that's what the line I wrote does)
Yep‚Äîchange it to what I wrote üòõ
I have this actually
Do `system_program: Program<'info, System>` instead of whatever you have now
Hi ! Im totally new and I wanna understand why I can't build my program. Any ideas ?
Ah great. Very easy to do. Thanks
By any chance do you have an example of what it looks like? I can see it would see save a lot of lines of code but just not 100% where I have to throw in the seeds still
writing it here in case someone else runs into a similar problem, I was able to solve the problem using the byteify library to convert the BN properly when using negative numbers to find_program_address. while still passing the BNs through the client side of anchor
One way is to just delete/move the old target/<your-prog-name> keypair file
So if i want to change my program id, which is currently "6qgQxwtSDhC8sEJ1AERrchDcyWVKsyj6cN5uk5papLsd". is there a way to regenerate the id that is initially created by anchor on init?
ah okay. really not ideal at all lol. but this is devnet, so i guess if i dont change the code now to mess up the structs it wont happen in the future. rip
that makes a lot of sense
oh wow! this is what causes it
Yeah, take a look at how those seeds on the JS side turn into byte buffers (they're wrong/lose track of the negative signs)
I personally never did find a fix for that. Another user in a different discord I'm in however ran into the same issue and managed to fix it by generating a new keypair for the underlying program account and initializing a new account
<@!672944020053557268> How did you solve the issue with "The value of "offset" is out of range. It must be >= 0 "
omfg if i use just positive numbers it works. what is this random code behaviorrrrrrr
ah i see other's have had the same issue. here is what you said. "That means that the actual data in that account doesn't match the expected <my-account> type
Try fetching it the lower-level way, program.provider.connection.getAccountInfo and see what it looks like". from running that command, it pulls `"TypeError: publicKey.toBase58 is not a function"`
uh are you sure? because when i did print out of the PDA on both the client and generated it using find_program_address on the rust side and they both printed out the same thing
Hmmm. it seems to be returning this error now? Even though the offset is 8 still ```RangeError [ERR_OUT_OF_RANGE]: The value of "offset" is out of range. It must be >= 0 and <= 8675. Received 778792772
      at new NodeError (node:internal/errors:363:5)
      at boundsError (node:internal/buffer:86:9)
      at Buffer.readUInt8 (node:internal/buffer:252:5)
      at Buffer.readUIntLE (node:internal/buffer:182:17)
      at UInt.decode (node_modules/buffer-layout/lib/Layout.js:570:14)
      at WrappedLayout.decode (node_modules/@project-serum/borsh/dist/lib/index.js:62:41)
      at Structure.decode (node_modules/buffer-layout/lib/Layout.js:1234:32)
      at AccountsCoder.decode (node_modules/@project-serum/anchor/dist/cjs/coder/accounts.js:47:23)
      at /home/byron/_solspot/node_modules/@project-serum/anchor/dist/cjs/program/namespace/account.js:164:47
      at Array.map (<anonymous>)
      at AccountClient.all (node_modules/@project-serum/anchor/dist/cjs/program/namespace/account.js:161:21)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at async Context.<anonymous> (tests/_solspot.js:198:17)```
but ohhh that makes that it cannot rewrite the structs in different orders. I will give that a go and rewrite the new struct to follow that. thank you so much!
ok haha so my understanding of that is correct. nice.
Oh, sorry, got it üëç
but i am searching with the user address who owns the profile_address being searched for
Hm. well I am searching for the user address that owns the account. Which then has to search within the data at the user var I assume? If i use fetch, then I would have to pass the profile_address i am looking for right?
You have to make sure you add all new fields at the *end* of the struct, so you don't overwrite previous ones
Yeah, you made a non-backwards-compatible update to that account struct
~~Quick q, why not use `await program.account.profile.fetch(old_acc_address)`?~~
Sorry if this is too long. i can definitely delete it if need be. The issue is that accounts created before the update are no longer working. it will not even query using the below command . new accounts can be created and function as assumed. i have no idea what to do? ```let old_acc_address = "7eXSNy1Q2b7SLCWNtprRT6KAViDrk94jj2ht8z1UNoar";
      profile = await program.account.profile.all([
         {
            memcmp: {
               offset: 8, // Discriminator.
               bytes: old_acc_address,
            }
         }
      ]);``` here is the new struct ```#[account]
#[account]
pub struct Profile {
    pub user: Pubkey,
    pub bio: String,
    pub color: String,
    pub light_theme: bool,
    pub individual: bool,
    pub link_list: Vec<ContentStruct>,
}
``` Here is the old account struct ```#[account]
#[account]
pub struct Profile {
    pub user: Pubkey,
    pub bio: String,
    pub link_list: Vec<ContentStruct>,
}```  Here is the error ```Error: Invalid bool: 119
      at WrappedLayout.decodeBool [as decoder] (node_modules/@project-serum/borsh/dist/lib/index.js:124:11)
      at WrappedLayout.decode (node_modules/@project-serum/borsh/dist/lib/index.js:62:21)
      at Structure.decode (node_modules/buffer-layout/lib/Layout.js:1234:32)
      at AccountsCoder.decode (node_modules/@project-serum/anchor/dist/cjs/coder/accounts.js:47:23)
      at /home/byron/_solspot/node_modules/@project-serum/anchor/dist/cjs/program/namespace/account.js:164:47
      at Array.map (<anonymous>)
      at AccountClient.all (node_modules/@project-serum/anchor/dist/cjs/program/namespace/account.js:161:21)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at async Context.<anonymous> (tests/_solspot.js:197:17)```
It ends up dropping the sign (not actually sure why it would do that ü§î)
Interesting, have to admit I didn't see this coming: the issue is that those attempts at converting the JS BN coordinates into buffers doesn't do what you'd think it would do!
https://github.com/spacemandev-git/dominari
une moment let me push
Is your code on github? I can poke at it if so
okay I confirmed the PDA is correct, so that means i have even less of a clue why this error is happening:
```
Calculated PDA: 8bTnQchSvfuaxGyqvjphd9biEirGU1tBZjqRsUc8wJDQ
Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account 
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS invoke [1]
    Program log: Instruction: InitLocation
    8bTnQchSvfuaxGyqvjphd9biEirGU1tBZjqRsUc8wJDQ's signer privilege escalated
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS consumed 10833 of 200000 compute units
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS failed: Cross-program invocation with unauthorized signer or writable account
```

Context: 

```rs
#[derive(Accounts)]
#[instruction(loc: Coords)]
pub struct InitLocation<'info>{
    #[account(
        init,
        //(Nx, Ny) (Lx, Ly)
        seeds=[loc.nx.to_be_bytes().as_ref(), loc.ny.to_be_bytes().as_ref(), loc.x.to_be_bytes().as_ref(), loc.y.to_be_bytes().as_ref()],
        bump,
        payer=initalizer,
        space=8+1024
    )]
    pub location: Account<'info, Location>,
    #[account(mut)]
    pub initalizer: Signer<'info>,
    pub system_program: Program<'info, System>
}
```
nvm forget about reset.
ah reset might not be the best word choice as if i update any rust program on a mainnet i would have to factor in supporting old program structure
What do you mean by reset?
I am getting this when I call this filter. ```Error checking init Error: Invalid bool: 119
    at WrappedLayout.decodeBool [as decoder] (index.ts:177:1)
    at WrappedLayout.decode (index.ts:100:1)
    at Structure.decode (Layout.js:1234:1)
    at $.decodeUnchecked (accounts.ts:72:1)
    at $.decode (accounts.ts:62:1)
    at account.ts:222:1
    at Array.map (<anonymous>)
    at _e.all (account.ts:206:1)
    at async checkIfInit (create.js:72:1)```
ahh thank you. I am running into errors when I deploy a new version of my anchor program. the accounts created for some reason. is there a way to reset all accounts when i query using this call? ```const profile = await program.account.profile.all([
            {
               memcmp: {
                  offset: 8, // Discriminator.
                  bytes: walletAddress,
               }
            }
         ]);```
\`\`\`langName here for syntax highlight (rs for rust, or ts for typescript)
CODE
\`\`\`
Triple ticks
I think anchor actually verifies that your bump is "canonical", which means it needs to re-run find_program_address with your seeds + then verify that the resulting bump is the one you said it should be
how do you make your code be in nice boxes? the only thing online i could find was to use the ticks like so `hello world`
`create_program_address` is for when you *also* supply the bump
which method does the account init macro use? create or find? having a problem with PDA signer priviledge esclation so seeing if my PDA i'm passing in on the client side is the same as the one generated by the account init macro
Yeah. If you use the `program.methods` feature in 0.21.0, the client will automatically derive the PDA based on the IDL generated by anchor 0.21.0 so you don‚Äôt need to pass it in. It saves quite a few lines of code if you have a bunch of PDAs.
Try hopping to source on them to see the difference
Yep, it's `find_program_address` üòõ
what's the difference? / is there a find program address in rust?
Gotta be consistent
Ah, well, you're using `create_program_address` in rust but findProgramAddress in JS
i64
What is the rust type of `loc.nx`, `loc.ny` etc.?
this 
```rs
let address = Pubkey::create_program_address(&[loc.nx.to_be_bytes().as_ref(), loc.ny.to_be_bytes().as_ref(), loc.x.to_be_bytes().as_ref(), loc.y.to_be_bytes().as_ref()], ctx.program_id);
```
generates a different address than 
```ts
const [loc_address, loc_bump] = findProgramAddressSync([coords.nx.toArrayLike(Buffer, "be", 8), coords.ny.toArrayLike(Buffer, "be", 8), coords.x.toArrayLike(Buffer, "be", 8), coords.y.toArrayLike(Buffer, "be", 8)], dominari.programId)    
```

how can i get them to generate the same address?
I have 2 NFTs (created using metaplex) inside my phantom under a collection name `Album` . is there any way I can fetch a single collection by name/id( if there is any) ?
well ig this is a waste right. it will throw an error if the param is not bool. oh nvm lol
`        if type_of(light) != type_of(bool)  {
            return Err(ErrorCode::LightNotBool.into())
        }`
also, does anyone know how i can verify a parameter is a boolean on the rust side?
Cool I just ended up using init_if_needed and it solved my issue. Could look into turning on the seed feature in the future if that is recommended
im interested to hear this answer as well. the way i solved it was by checking in the frontend, but obviously I would prefer it to be checked in the rust script
i want to make an account which can store both public key of an user and a username he chooses, and these fields will be individually unique.. so if "b123" publickey sets "abcd" as username, they wont be able to create another account with the same publickey.. similarly someone with "b456" publickey wont be able to take the "abcd" username.. m trying to achieve this... 
m so sorry if my question was unclear


//////////////////////////////////////////////////////////////////////////////////////////

üëã hello! hope y'all had a good weekend. I have a question on best practices for structuring solana programs vs. the front-end/client. Do we typically avoid storing state in the program accounts/objects? Is there a doc that outlines do's/don'ts and the reasoning behind it?
Maybe I am just doing it all wrong, any example repo that shows this functionality so I can try it out locally myself?
thank you
ah, that was it lol
Are you sure it's not some other test that is failing?
Mm, that doesn't make sense to me, why are the logs talking about associated token stuff then?

Im not passing it in anything, thats the entire test. I commented out the actual instruction
u can try this out https://dev.to/nickgarfield/how-to-install-solana-dev-tools-on-an-m1-mac-kfn
Yeah, gotta start over (I install from source on an M1, not via the installer/downloader, so not sure if that even works)
This is the mac m1 thing...üò©
`mattbraz@patty:.anchor$ solana-test-validator
Ledger location: test-ledger
Log: test-ledger/validator.log
‚†ô Initializing...
Illegal instruction: 4`
oh crap
Are you actually able to start the validator at all though? `solana-test-validator`
Yeah
can i delete the contents of .anchor?
`Unable to start test validator. Check .anchor/test-ledger/test-ledger-log.txt for errors.
mattbraz@patty:escrow$ cat .anchor/test-ledger/test-ledger-log.txt
Ledger location: .anchor/test-ledger
Log: .anchor/test-ledger/validator.log
Initializing...`
now i have:
ah great, making progress..
And then retry
Try doing `cargo clean`
`mattbraz@patty:escrow$ anchor test
BPF SDK: /Users/mattbraz/.local/share/solana/install/releases/1.9.1/solana-release/bin/sdk/bpf
cargo-build-bpf child: rustup toolchain list -v
cargo-build-bpf child: rustup toolchain uninstall bpf
info: uninstalling toolchain 'bpf'
info: toolchain 'bpf' uninstalled
cargo-build-bpf child: rustup toolchain link bpf /Users/mattbraz/.local/share/solana/install/releases/1.9.1/solana-release/bin/sdk/bpf/dependencies/bpf-tools/rust
cargo-build-bpf child: cargo +bpf build --target bpfel-unknown-unknown --release
   Compiling blake3 v1.3.1
error[E0460]: found possibly newer version of crate `compiler_builtins` which `arrayref` depends on
 --> /Users/mattbraz/.cargo/registry/src/github.com-1ecc6299db9ec823/blake3-1.3.1/src/portable.rs:5:5
  |
5 | use arrayref::{array_mut_ref, array_ref};
  |     ^^^^^^^^
  |
  = note: perhaps that crate needs to be recompiled?
  = note: the following crate versions were found:
          crate `compiler_builtins`: /Users/mattbraz/.cache/solana/v1.20/bpf-tools/rust/lib/rustlib/bpfel-unknown-unknown/lib/libcompiler_builtins-2b55923f9138f2d9.rlib
          crate `arrayref`: /Users/mattbraz/Coding/3rd/anchor/tests/escrow/target/bpfel-unknown-unknown/release/deps/libarrayref-5374d35c67a5c556.rmeta

error: could not compile `blake3` due to previous error`
ok, i'm even more broken now
How are you actually passing in that mint account into your instruction?

WTH am I doing wrong here? 
```
Transaction simulation failed: Error processing Instruction 0: custom program error: 0x2 
  Program ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL invoke [1]
  Program log: Transfer 2039280 lamports to the associated token account
  Program 11111111111111111111111111111111 invoke [2]
  Program 11111111111111111111111111111111 success
  Program log: Allocate space for the associated token account
  Program 11111111111111111111111111111111 invoke [2]
  Program 11111111111111111111111111111111 success
  Program log: Assign the associated token account to the SPL Token program
  Program 11111111111111111111111111111111 invoke [2]
  Program 11111111111111111111111111111111 success
  Program log: Initialize the associated token account
  Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [2]
  Program log: Instruction: InitializeAccount
  Program log: Error: Invalid Mint
  Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 3069 of 181474 compute units
  Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA failed: custom program error: 0x2
  Program ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL consumed 21595 of 200000 compute units
  Program ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL failed: custom program error: 0x2
SendTransactionError: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: custom program error: 0x2 at Connection.sendEncodedTransaction
]
```
`i'm loathe to disturb it` ü§£
im giving it a go
sh -c "$(curl -sSfL https://release.solana.com/v1.9.1/install)"
I'm on mac M1, so installing solana was a palaver, i'm loathe to disturb it
Yeah, try reinstalling from scratch
solana --version
solana-cli 1.8.5 (src:devbuild; feat:52865992)
This error seems to be something with a busted version of solana actually, I would just try reinstalling solana from scratch
I'm supposing this is something to do with node packages, but don't know how to proceed from here.  Everything was working a while back.
error is: `     Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 1: instruction modified the program id of an account
`
If `anchor test` fails on all programs, including the anchor's own tests, with the same error, how could i go about fixing it?
Ah, ok, yeah I've got an actual `--clone` flag in there
`.anchor/test-ledger/validator.log`
omg that was it - had a later version of `anchor-spl`, switched both to the same and the error went away
Where are you getting the logs from?
do your logs look like my anchor logs?
ah maybe ill try fetch and get back to you
Hmm, not sure, the feature seems to work fine for me when I try it locally (I can fetch the cloned accounts, etc.)
here's an example with the validator run manually ( no anchor)
```
        inner: [
            "solana-test-validator",
            "-c",
            "7azgmy1pFXHikv36q1zZASvFq5vFa39TT9NweVugKKTU",
            "-u",
            "devnet",
        ],
    }
```
I dont see the `-c` options in the logs when I run `anchor test`
```
        inner: [
            "solana-test-validator",
            "--ledger",
            ".anchor/test-ledger",
            "--mint",
            "D5B1iguWRmkrjiNU6zSt1LxwDocFRyzfab38y4JXwed",
            "--bpf-program",
            "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS",
            "/Users/bm/sandbox/solana/marinade-onchain/target/deploy/marinade_onchain.so",
            "--bind-address",
            "0.0.0.0",
            "--rpc-port",
            "8899",
            "--url",
            "https://api.mainnet-beta.solana.com",
        ],
    }
```
with anchor test and the toml config i get no such error
if I use the `solana-test-validator -c XXXX -u devnet` method it definitely does, it takes 10+ seconds to load all the accounts and 2 of those it can't find on the mainnet
What do you mean by doesn't seem like it?
I passed in about 8 different accounts 
```
[test.validator]
url = "https://api.mainnet-beta.solana.com"

[[test.validator.clone]]
address = "MarBmsSgKXdrN1egZf5sqe1TMai9K1rChYNDJgjq7aD"

[[test.validator.clone]]
address = "3JLPCS1qM2zRw3Dp6V4hZnYHd4toMNPkNesXdX9tg6KM"

[[test.validator.clone]]
address = "8szGkuLTAux9XMgZ2vtY39jVSowEcpBfFfD8hXSEqdGC"

[[test.validator.clone]]
address = "HZsepB79dnpvH6qfVgvMpS738EndHw3qSHo4Gv5WX1KA"

[[test.validator.clone]]
address = "mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So"

[[test.validator.clone]]
address = "UefNb6z6yvArqe4cJHTXCqStRsKmWhGxnZzuHbikP5Q"

[[test.validator.clone]]
address = "7GgPYjS5Dza89wV6FpZ23kUJRG5vbQ1GM25ezspYFSoE"

[[test.validator.clone]]
address = "Du3Ysj1wKbxPKkuPPnvzQLQh8oMSVifs3jGZjJWXFmHN"
```
It doesnt seem like it
I'm actually not sure, does anchor seem to load that account?
Ok, cool
Not for anchor test, i thought anchor test spins one up for me
I think those only take effect if you *don't* run a validator, and instead let anchor spin it up for you
Are you running a validator in the background?
If I define:
```
[test.validator]
url = "https://api.mainnet-beta.solana.com"

[[test.validator.clone]]
address = "MarBmsSgKXdrN1egZf5sqe1TMai9K1rChYNDJgjq7aD"
```
In my Anchor.toml, when I run `anchor test` do the addresses get cloned before the tests run? It seems to start up very fast, when I run with `solana-test-validator -c MarBmsSgKXdrN1egZf5sqe1TMai9K1rChYNDJgjq7aD -u mainnet-beta` it takes much longer and I see the addresses show up in the logs. I do not see the addresses in the logs for the Anchor.toml method
will have to do w/o auto-pda for now
aye alas its failing for another issue when I'm importing account from another anchor program: https://github.com/project-serum/anchor/issues/1487
that works! very nice thank you
Basing that guess off the test for this feature: https://github.com/project-serum/anchor/blob/master/tests/pda-derivation/programs/pda-derivation/src/lib.rs#L60
Mm, annoying but try doing `your_u8.to_le_bytes().as_ref()` ?
Anchor is giving this error:
```WARNING: unexpected seed: Array(ExprArray { attrs: [], bracket_token: Bracket, elems: [Path(ExprPath { attrs: [], qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident(seed_type), arguments: None }] } })] })```
when seed_type is a u8, set as seed with `&[seed_type]`.  Any idea how i can cast this to avoid the warning?
storing it on the pda account, i.e. `ctx.accounts.pda_account.seed_string`, `ctx.accounts.pda_account.bump`
Where are you getting that seed + bump choice?
Working through my understanding of CPI's right now

So I have a program function I want to call where a PDA is the authority. In my other program I try to use that with a CPI. When I call this I should pass in that PDA as the authority, and then the signer seeds are the seeds for that PDA?

```
use outside_program::{
  PdaAccountType,
  program::OutsideProgram
};
use outside_program::cpi::{
  outside_function,
  OutsideFunction
};

...

pub fn inside_function(Context<InsideFunction>, bump:u8){
  outside_function(
    ctx.accounts.into_outside_function_context()
    .with_signer_seeds(&[&[pda_seed_string.as_ref(), &[bump]])
  )
}
...

#[derive(Accounts)]
pub struct InsideFunction<'info> {
  #[account(mut)]
  pub authority: Signer<'info>,
  #[account(mut)]
  pub pda_account: Account<'info, PdaAccountType>,
  pub outside_program: Program<'info, OutsideProgram>,
}

impl<'info> InsideFunction<'info>{
  fn into_transfer_fora_token_context(&self) 
    -> CpiContext<'_, '_, '_, 'info, OutsideFunction<'info>> {
    let cpi_program = self.outside_program.to_account_info();
    let cpi_accounts = {
      authority: self.pda_account,
      ...
    };
    CpiContext::new(cpi_program, cpi_accounts)
  }
}
```
The seeds for the PDA are a string and a bump.

When I call this I get the error `Program failed to complete: Could not create program address with signer seeds: Provided seeds do not result in a valid address`. Am I choosing the seeds correctly? I don't really understand what the signer seeds `&['a, &['b, &['c]]]` struct is.
Beginner answer, so maybe disregard: by using many individual accounts, you could handle one ticket just like one token, and so use the mechanics for it that already exist rather than re-implementing it in your system
Lots of small accounts are potentially way cheaper if you don't end up needing all 7000 users
Sorry forgot to mention, I can make this big account fixed, let say only 7000 users can buy ticket, so I guess it makes things easy.
On the other hand what are the benefits of not using one big account and create as many accounts as needed?
I solved it by installing node 16.12 alongside 16.14 and switching with nvm
The tradeoff with the one-big-account approach is that you currently can't resize accounts (you hopefully will be able to in the next solana release, 1.9, but not clear when that will come out). So, you kind of need to just guess how much space to allocate.
How do you recommend to organize account structure:  let say users will be buying lottery tickets, shall I keep purchased tickets in one big account as an array? or have many accounts, one per ticket? with the second approach will it be practical to search for thousands of ticket accounts?
Thanks for replying I appreciate it
This is the error I was getting
--faucet-sol argument ignored, ledger already exists
Aborted
OK, for me it just continues on the existing ledger
What I just did was re-install solana using the stable build and it's all better now
ah ok cool. In this case it actually then abortedf
That's not an error, it just means it's not reinitializing a new ledger but reusing the existing one
You can just send money to that address (it's an account like any other, the PDAness only affects its address)
Quick super n00b question: My PDA is running into insufficient lamports issue. How do I fund it? Should I deposit money in the program account or do something else?
Hello, I'm running into a problem. I'm not sure if this is the right place for this. I just finished updating rust/solana/anchor and now when I try to run a test-validator I'm getting an error message: "--faucet-sol argument ignored, ledger already exists". Any idea?
yeah i was just thinking that, thanks for the helpful info
Well, you could have your node script reach out to the filesystem and read the Anchor.toml file etc.
yes am running in the way you mentioned. ok so there's no getting around the env vars if we run a JS client then
If you just do `node my_client.js` then anchor doesn't have a chance to inject any env vars.
What kind of client? How are you running that client etc.?
is there any reason why we need to set the ANCHOR_PROVIDER_URL and ANCHOR_WALLET env vars when running clients, but when we  deploy with anchor it can use the values in the provider section in Anchor.toml? I.e can we just have it so clients automatically use values in the anchor.toml file as well, instead of having to set the env vars?
oh hmm, ok thanks, let me look at it.
Using `init` you can unfortunately only allocate 10kb, not 10mb. To get the full 10mb you're unfortunately going to have to use a separate instruction issued from the client that creates the account, and then use `#[account(zero)]` etc. (try searching the anchor repo for examples)
I'm trying to build & localnet deploy CMv2 which apparently uses anchor 0.19. Is there an accepted way to run multiple versions of anchor?
Hello, I'm trying to allocate some space to store some pub keys lVec<Pubkey>  but, when I try to allocate (32 * 400) bytes (for 400 pubkeys) it says `Failed to reallocate account data`  As far as I read, we should be able to store up to 10MB data in an account, any idea why does that fail? 

I'm  defining account like

```
 #[account(
    init,
    payer = authority,
    space = PoolAccount::needed_space(),
    )]
    pub pool_account: Account<'info, PoolAccount>,
```

where needed_space returns 32 * 400 and some small addition for other metadata
That would be an example where you don't actually know how much space you'll need, since each individual Foo takes up a variable amount, but at any rate basically the same idea‚Äîthe first four bytes of the result will be `[2, 0, 0, 0]` because borsh uses little-endian and the vec has length 2. The "I'm a foo" will turn into `[9, 0, 0, 0, 73, 39, 109, 32, 97, 32, 102, 111, 111]` because the string has length 9, etc.
You can also always just experiment with this stuff,
```.rs
#[test]
fn hmm() {
    #[derive(AnchorSerialize)]
    struct Foo {
        x: u32,
        y: String,
    }

    let foos = vec![
        Foo {
            x: 123,
            y: "I'm a foo".to_string(),
        },
        Foo {
            x: 0,
            y: "".to_string(),
        },
    ];

    eprintln!("{:?}", foos.try_to_vec());
}
```
Think <@!401712056543477761> explained it well, borsh serializes a Vec<Foo> by first writing out 4 bytes for the length of the vector, followed by each foo one after the other. So assuming you know how much space borsh needs per foo, the total amount of space you need for that Vec<Foo> is 4 + len * foo_size.
Yeah. Though there's also the idea of "wrapped sol", which is a token-ized version of native sol for when you want to be able to handle sol in a token-y way.
oh, nvm now they are there. I've run `anchor build` one more time and its fine
Hi, just want to clarify, `anchor_spl::token` is like ERC20 in solidity? And not for sending native SOL?
what types are you missing exactly? have you run `anchor build`?
btw <@!347689664855015424> , do you know why typings for program are not generated? Can I try to generate them using some command or so?
thanks üôÇ
Yeah, that was the problem. Thank you üôÇ
yea we missed adding `ProgramResult` you can manually change it for now and we're releasing a patch ASAP
Are you using different versions of anchor-lang and anchor-spl in your program's Cargo.toml?
from the latest changelog https://github.com/project-serum/anchor/blob/master/CHANGELOG.md

If you just `anchor init` and cannot build the project maybe it because of `ProgramResult`. in `anchor 0.22.0` you have to change to `Result<()>`
Am I missing somethingüòÖ ?
for example `ProgramResult` is not in the scope as well as program types are not autogenerated under `target/types`
I'm asking cuz it seems like generated project doesnt contain everything
hello üôÇ Is there any tutorial about tranfer spl token on anchor program?
I think you should always update to the latest (1.9.8)
I was not able to build my project on `v1.9.4`
where can I find which version of Solana is currently supported by Anchor?
https://lorisleiva.com/create-a-solana-dapp-from-scratch/structuring-our-tweet-account#size-recap

It‚Äôs from this awesome tutorial, highly recommend
still struggling with this lmao
whats the source of this data table>? want to make sure i save this one. super handy
ie : ```
#[account]
#[derive(Derivative)]
#[derivative(Debug, Default)]
pub struct PoolState {
    ...
    pub padding: PoolStatePadding,
}

#[derive(Clone, Debug)]
pub struct PoolStatePadding([u8; POOL_STATE_PADDING_SIZE]);
...
```
Hey guys, how can I tell anchor to ignore my Padding type? ```IdlError: Type not found: {"name":"padding","type":{"defined":"PoolStatePadding"}}
  ...
error Command failed with exit code 1.
info Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.

```
thanks for the help!
will wait for alan
hmm idk
in the example vector holds u16. u16 weights 2 bytes, so if you hold 10 items in vector it will be 4 (prefix) + 10 * 2. If you hold 10 PublicKey, which weights 32 bytes, it will be 4 (prefix) + 10 * 32. 
If you don't put any items in vector it will be 4 bytes (just prefix), i guess this is how much space anchor allocate for just empty vector
any multiple of 2 bytes? So what's the exact number?
this was helpful but i dont fully get it

Also, What's the point of having `version` on an account?
How much space does anchor buffer when I add a Vec to my account?
e.g.
```#[account]
pub struct MyAccount {
    pub version: u8,
    pub protocols: Vec<OtherAccount>, 
    pub creator: Pubkey,
    pub vault_extra_space: [u8; 256],
}```

As I add protocols, does `creator` get shifted down?
```
pub fn take_ownership(ctx: Context<TakeOwnership>, auth_bump: u8) -> ProgramResult {
        let license = &mut ctx.accounts.treasury_license;
        license.treasury_key = ctx.accounts.payer.key();
        license.reload()?;
        msg!("Owner of tokens: {}", license.treasury_key);
        Ok(())

    }

#[derive(Accounts)]
#[instruction(auth_bump: u8)]
pub struct TakeOwnership<'info> {
    #[account(
        init,
        payer=payer,
        seeds = [b"treasury_license".as_ref()],
        bump = auth_bump,
        space = 8 + 32
    )]
    pub treasury_license: Account<'info, License>,
    #[account(mut)]
    pub payer: Signer<'info>,
    pub system_program: Program<'info, System>,

}


#[account]
pub struct License {
  pub treasury_key: Pubkey,
}



```
Fails with this error:  8 byte discriminator did not match what was expected
been struggling with this all arvo, anyone got a clue? 

```
const [auth, authBump] = await anchor.web3.PublicKey.findProgramAddress(
      [Buffer.from("treasury_license")],
      program.programId
    );
const tx = await program.rpc.takeOwnership(authBump, {
  accounts: {
    treasuryLicense: auth,
    payer: program.provider.wallet.publicKey,
    systemProgram: anchor.web3.SystemProgram.programId,
  },
});
console.log("Your transaction signature", tx);
```
thanks üôÇ
`anchor_spl::token::accessor::amount` for token accounts
How can I check token account balance and lamport balances in an Anchor program?
my struct
```#[derive(Accounts)]
pub struct MarinadeDeposit<'info> {
    pub state: AccountInfo<'info>,
    pub msol_mint: Account<'info, token::Mint>,
    pub liq_pool_sol_leg_pda: AccountInfo<'info>,
    pub liq_pool_msol_leg: AccountInfo<'info>,
    pub liq_pool_msol_leg_authority: AccountInfo<'info>,
    pub reserve_pda: AccountInfo<'info>,
    pub transfer_from: Account<'info, token::TokenAccount>,
    pub mint_to: Account<'info, token::TokenAccount>,
    pub msol_mint_authority: AccountInfo<'info>,
    pub system_program: Program<'info, System>,
    pub token_program: Program<'info, token::Token>,
}```
trying to do: `    pub marinade_accounts: MarinadeDeposit<'info>,`
getting an err I dont fully understand:
```
use of undeclared crate or module `__client_accounts_marinade_deposit`rustc(E0432)
lib.rs(311, 10): use of undeclared crate or module `__client_accounts_marinade_deposit`
failed to resolve: use of undeclared crate or module `__client_accounts_marinade_deposit`
```
Can I nest a struct of `#[derive(Accounts)]` inside `#[derive(Accounts)]` struct? I am trying to add accounts to call another program from my on chain program
Trying to use the basic `initialize_mint` function but getting an odd compile time error that doesn't make sense. I am annotating the types as it wants but it is still complaining. Any ideas?
Hey everyone! Can one of you help us validate the approach for our smart contract? New to Solana smart contract dev!

**Context**
We are building a player-vs-player game. Two players put in 1 SOL each - the winner wins 2 SOL and the loser gets nothing. The winner is determined off-chain.

**Our Approach**

1. Call an `initiatilize` endpoint every time a new player joins the game (with the player's signature)

2. The `initiatilize` function (1) creates a token account for the player, (2) transfers funds from the player's wallet to the token account, and (3) sets the PDA as the authority / owner of the token account

3. Once a winner is declared, game calls the function `declare_winner(winner_token_account_address, loser_token_account_address)`

4. The declare-winner function (1) transfers funds from `loser_token_account_address` to `winner_token_account_address` , (2) transfers funds from `winner_token_account_address` to the initializer of that the account (the winner's wallet), and (3) cancels the token accounts
You would have to add an instruction to do the closing, but you can use the `close = who_to_send_the_lamports_to` attribute in the derive(Accounts) struct
i see anchor_spl has a close token account function but im not sure what to use for an anchor struct pda
is there a quick anchor way to close a #[account] pda so i can re-init it later?
Ok this makes sense. I guess i need to find some examples with PDAs to fully understand how those work
So here you're creating the `counter` account, and it lives at a keypair address (as opposed to a program-derived address, which can only be signed for by its deriving program, within the program itself), so you need to explicitly sign for it
Ah, yeah, good/confusing question: the provider.wallet signs automatically, always, because it pays the tx fees. Sometimes you need to sign for additional accounts too though: a common example is when you're creating an account that lives at a keypair address. In solana, whenever you create an account you need to sign for its address (this is just how the system_program works, it prevents you from like squatting on somebody's public key etc.)
ty. One thing i haven't really been able to fully grasp is the signers parameter in the tests. (basic2 - signers: [counter]) Why wouldn't the wallet need to sign if they are the payer? Why is the counter account signing?
thanks
yeah that's what i figured, hm ok, i may be able to pull some stuff out of the struct to help
Yep, sounds like that's just the rent exemption cost. That's about the rent exemption for a 100 bytes of account storage.
Ah, yeah, I think that's kind of just random‚Äîyou're right that if it were always going to be the provider.wallet's key then you wouldn't want to pass it as an argument
i'm looking to run an initialize function that'll create a couple 1000 mint config accounts (1 per mint) - devnet initialize tests are showing around `0.0016704 SOL` transferred to each account. am i looking at `<number of mints> * 0.0016704 SOL` to initialize the configs alone?
in the basic-2 example the create function takes in authority as a pubkey, but this is also the same as the user in the context. what is the point of doing it that way? couldn't you just assign the counter.authority = user.authority? (not trying to askchully gotcha anyone here, just trying to understand)
Nope, totally random (it's a fresh keypair)
what factors determine what a programs programID will be when you do anchor build? ie is it based on the account/signer, and a hash of the program code or something?
nvm just went through :))
anyone else having issues deploying to devnet, getting invalid blockhash error
Sounds good. Ty
Now read the tests in the anchor repo
Good job
Yea
Yes that thing
?
https://book.anchor-lang.com/
wait what do u mean? i am a bit unsure, so if I was to try and send an NFT from 1 account to another, the **to and from addresses** are the associated token account addresses? but how do u actually get the receiving persons ATA?? i have just noticed on spl-token cmd it sometimes prompts to --fund-recipient if they dont already have an associated account i gathered?
But the issue is that if you store a token account at an associated token address, that address is calculated from the ostensible owner/authority of the tokens (plus the mint). So, it's quite surprising to go look for person X's mint M associated token account, only to find that the actual authority over that account is in fact person Y.
Associated token accounts are just kind of the default in general
Ah, good point
i am still heaps noob hey so could be wrong in my understanding
because if u do a transfer doesn't the associated token account have to be created?
why is that?
That said, I would expect NFTs to often be stored in associated token accounts, and you really shouldn't change an associated token account's authority (just do the transfer)
Is it actually cheaper? I've never compared their costs, I would have expected them to be essentially the same
is "set_authority" on the token account that holds the NFT a cheaper version of "transfer" for an NFT/spl-token?
reading more sophisticated example code is a good next step that helped me. you may want to take a look at 
anchor escrow https://github.com/project-serum/anchor/blob/master/tests/escrow/programs/escrow/src/lib.rs re: transferring spl tokens
Have you read the book as well as the tutorials?
after completing the 5 tutorials, what would you all recommend next? I‚Äôm trying to learn how to transfer sol and spl tokens next.
i'm trying to tinker with advanced stuff,
saw the Serum DEX program, sort of event-based with a crank ... still seems like magic to me lol
Hahah makes sense
CPIs are just like calling a function in normal programming, just slightly weirder
Mm, I guess it depends on what you mean by concurrency üòõ Your program would still do its thing, then let the CPI do its thing for a bit, then back to your program (so I guess their executions are interleaved, but in the usual boring vanilla calling-another-function kind of way, nothing like threads)
Can u perhaps simulate concurrency with cpi? :3
On that note, any good technical resources for the solana program execution life-cycle?
No, can't use threads
I know concurrency is a big thing in rust, just wondering if you can open threads and execute stuff in solana,
excuse the stupid answer i still don't understand the program life-cycle well
Not within your rust program (or, what do you mean? What would be an example?)
Or you just think of a big-enough number that doesn't feel too expensive to you
You could do that (sort of, you need an extra 4 bytes since that's how borsh serializes strings: 4 bytes for the length in bytes, followed by the actual bytes)
Can you do concurrency ?!  is it supported? just curious
How does one properly deal with String space size allocation? Calculate the size dynamically somehow to allocate just enough?
That actually worked üòÆ
Mm, what happens if you get rid of those `_` arguments and give them actual names, like `_something`

Even though I defined the instructions:
I am having issues with empty instruction IDL that is generated:
ü•∫


//////////////////////////////////////////////////////////////////////////////////////////

This is maybe more general than you're looking for, but I think you can think of it a lot like a zero-downtime migration in a regular database setup. Redeploying has zero effect on existing accounts (~ rows in the db), so whatever changes you make need to continue to work with any old account structures, etc.
üëã are there any restrictions/best practices on redeploying programs? more specifically, how can we make sure that the new deployed program doesn't introduce any compatibility issues?
gotcha
note that if you click on the badge it will take you to the source
thank you!
yeah, that‚Äôs working now. dependent on the dev publishing ofc
https://twitter.com/solscanofficial/status/1491258622764261378?s=21
hi guys, is there a way for us to see the rust program's source code in like solscan? like in etherscan we can solidity source code
Thanks so much, I have been looking at it since you mentioned, will write here any results.
The issue was that we were creating with a different size than the actual size we need on rust side. So, not giving a size on client solved the problem because js predicted the exact size of we need on backend.
Hey guys! 

I want to pass an array of associated token accounts to have their balances updated. The problem is that the number of elements in this array of ATAs is variable. Meaning I want to keep it flexible how many ATAs can have their balances updated. What's the best way to pass this varying length of ATAs array as a part of accounts to the ix handler, from the client?
<@!916187801115037728> <@!733281043641008239> I think you can use https://github.com/saber-hq/merkle-distributor as example in the part related to generating and verifying merkle proof.
did u find a solution to this, if so could you share what was the issue ?
https://medium.com/crypto-0-nite/merkle-proofs-explained-6dd429623dc5
Hey, <@!290210612947058689>, could you provide some example source about merkle tree proof?
merkle tree proof.
Hello everyone, can anyone please give some suggestion about whitelisting 10k pubkeys (nft list) in a contract? doing a loop over 10k elements always exceeds the computing limit.
Installing from source 1.8.16 fixes this. thanks. üëç
Trying to run this mintTo function now but not sure what the multisig arg should be ? i thought it was optional? but i get Type Errors in my tests. I think its the multisig array because it was saying the length of null is undefined but then i tried an empty array as well to no success ```
    //creates the token
    await mintTo(
      provider.connection,
      fromWallet,
      mintA,
      tokenAddress1.publicKey,
      fromWallet.publicKey,
      1,
      null,
      null,
      TOKEN_PROGRAM_ID);```
Hello, 
I'm trying to create a large account (more than 10kb) and then, update it using anchor / zero_copy.


My pool account data structure is like;
```
#[account(zero_copy)]
pub struct PoolAccount {
    // Pool name
    pub name: [u8; 50],
    // Allowed mint addresses (up to 10k)
    pub nft_allowed_mint_list: [Pubkey; 10000],
    pub starts_at: u64,
    pub ends_at: u64,

    // reward
    pub reward_token_mint: Pubkey,
    pub reward_amount: u64,
    pub reward_vault_nonce: u8,
    pub reward_per_hour: u64,

    // auth
    pub creator: Pubkey,
}
```

This is how I define in the context:
```
 #[account(mut)]
    pub pool_account: AccountLoader<'info, PoolAccount>,
```

And this is how I try to reach in an instruction; (already created by a separate clientside instruction)
```
 let pool_account = &mut ctx.accounts.pool_account.load_mut()?;  // (This is first line in instruction)
```


And at that line, I'm getting this error message when I interact with the contract for this instruction
```
Program log: panicked at 'from_bytes_mut>SizeMismatch', /Users/tfnyldrm/.cargo/registry/src/github.com-1ecc6299db9ec823/bytemuck-1.7.3/src/lib.rs:119:3
```


Anyone familiar with this message and how to fix it?
not 100% sure, I am still pretty new to this but in most cases a PDA can sign on behalf of the contract so you would transfer to that first
but in my case, I need a function to transfer token from program owner to user. Can my program do it automatically without asking for approval?
oh okay
thanks man
ah okay sweet

I think because of TOKEN_PROGRAM_ID because they change signature of the function
``` let mintA = await createMint(
      provider.connection,
      fromWallet,
      fromWallet.publicKey,
      null,
      0,
      TOKEN_PROGRAM_ID
    );````
its regarding the same createMint function
did u see anything like this directly after ```TypeError: Cannot read property 'toString' of undefined
      at Transaction.sign (node_modules/@solana/web3.js/src/transaction.ts:460:36)
      at Connection.sendTransaction (node_modules/@solana/web3.js/src/connection.ts:3886:21)
      at processTicksAndRejections (internal/process/task_queues.js:95:5)
      at sendAndConfirmTransaction (node_modules/@solana/web3.js/src/util/send-and-confirm-transaction.ts:30:21)```
how to check if a signer owns the mint passed in Anchor program?
any one else facing error while typing avm use latest, the upgrade keeps failing due to some spl token compilation errors.
thanks for help man
ahahaha wtf
do not know either. I faced the same problem as you today LOL
and how would i find this for myself? is it documented anywhere
aha ah beautiful wish i asked earlier
There is no Token in @solana/spl-token 0.2.0 anymore. You should import createMint directly `import { createMint } from "@solana/spl-token"`
i think u only need IDL?
I am getting this error in my test code for a solana program, gotta be something heaps beginner but no idea. Tried reinstalling the library but yeh i got no idea? does the method even exist anymore or something? Any help is appreciated: 
```import { TOKEN_PROGRAM_ID, Token } from "@solana/spl-token";```
``` let mintA = await Token.createMint(
      provider.connection,
      fromWallet,
      fromWallet.publicKey,
      null,
      0,
      TOKEN_PROGRAM_ID
    );````

```TypeError: Cannot read property 'createMint' of undefined
      at /home/kali/Desktop/SOLANA/NFTTransfers/tests/NFTTransfers.ts:30:29
      at Generator.next (<anonymous>)
      at fulfilled (tests/NFTTransfers.ts:24:58)
      at processTicksAndRejections (internal/process/task_queues.js:95:5)```
*need
Hello guys. I'm new to anchor and solana and I'm trying to make a ddapp on solana. My question is: Must I put my reactjs front-end in anchor's app folder and push all of them to server or the IDL is all I neef?
Thanks Anan
Hey, <@!823873608878522379>, try `space = 8 + Transaction::size(trans)`
Any idea what I am doing wrong
I am getting this error: TypeError: Blob.encode[data] requires (length 289) Buffer as src
Amazing mouse... Just one more help. Please consider the code below  #[program]
pub mod mysolanaapp {
    use super::*;
    pub fn initialize(ctx: Context<Initialize>, trans: Vec<u8>) -> ProgramResult {
        msg!("Initalization started");
        let my_account = &mut ctx.accounts.my_account;
        msg!("Got my account");
        my_account.transaction = trans;
        Ok(())
    }
}

#[derive(Accounts)]
#[instruction(trans: Vec<u8>)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = Transaction::size(trans))]
    pub my_account: Account<'info, Transaction>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[account]
pub struct Transaction {
    pub transaction: Vec<u8>,
}

impl Transaction {
    pub fn size(trans: Vec<u8>) -> usize {
        4 + trans.len()
    }
}
https://imfeld.dev/writing/starting_with_solana_part04
Cool... Can you please help me with the URL of this code. Really awesome
This is based off a todo list tutorial. Is this what you are looking for?
```
//Create List
#[derive(Accounts)]
#[instruction(name: String, capacity: u16, list_bump: u8)]
pub struct CreateList<'info> {
    #[account(init,
        payer=user,
        space=List::space(&name, capacity),
        seeds=[
            b"list",
            user.to_account_info().key.as_ref(),
            name_seed(&name)
        ],
        bump=list_bump)]
    pub list: Account<'info, List>,
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}


//"List" Data Account fields
#[account]
pub struct List {
    pub owner: Pubkey,
    pub name: String,
    pub bump: u8,
    pub capacity: u16,
    pub lines: Vec<Pubkey>,
}

impl List {
    fn space(name: &str, capacity: u16) -> usize {
        // discriminator + owner pubkey + bump + capacity
        8 + 32 + 1 + 2 +
            // name string
            4 + name.len() +
            // vec of item pubkeys
            4 + (capacity as usize) * std::mem::size_of::<Pubkey>()
    }
}
```
yes
Hi Apollo.. is it a reply for me.
i just leave extra space for it
it starts out as 4 bytes. The 4 bytes just hold the length
Hi Apollo... I have q question for you... How you will init Vault info... like how you will implement size fo Vec<Protocol>
Hi Team. I am using anchor for development. I have taken an Vectot of u8. Now while init I need to provide the size of it. Any idea how I can implement the size of a vector for saving it in an account.
How do I check the space on a struct within my account? I want to make sure that each `Protocol` is the right size in the `protocols` vector:

```#[account]
pub struct VaultInfo {
    pub version: u8,
    pub protocols: Vec<Protocol>, 
    pub creator: Pubkey,
}```
Hey guys, need some help working with creating reserve space at the end of my state object, however I am getting a random IDL error with anchor and cant seam to find away around this? Have put together this base repo with only the code required to reproduce the error. Any help would be much appreceated as ive been stuck on this for days now: https://github.com/utx0/anchor_reserve_idl_error Thanks
https://medium.com/@Arrivant_/how-to-verify-nfts-in-an-anchor-program-a051299acde8
ahh nvm this helped me üôÇ
trying this
From what I understand adding a constraint to the ATA account that the balance > 0 is a good start, but that doesn't verfiy the ATA is owned by the signer.
how to do unit test using anchor?
`.owner` returns a token program on Mint and TokenAccount types
how can I check that a signer owns the token it passes in?
ok so i think i understand what those terms mean, but what exactly is  _bump_seed being set to in this line? (and why?)
https://discord.com/channels/889577356681945098/889702325231427584/939324164890845265
looking into escrow sample code making sure i understand each line... what exactly is happening here?  
let (pda, _bump_seed) = Pubkey::find_program_address(&[ESCROW_PDA_SEED], ctx.program_id);
If you decide to change the structure of that account, it might be nice to store a version number so it's easy in your code to say "ah, hmm, this is a super old v2 account, we're on v19 now so need to update it"
Thank you! Appreciate it.
Run a test validator with `solana-test-validator`
Bump
Aww that is kind of unfortunate üò¶ since the limit is quite small.
Not as far as I know/I doubt it, since the confirmation is supposed to be for the entire transaction
What's the point of adding a `version` variable to an account?
<@!134416332509675520>  Sorry to ping you, but i do believe you helped me the last time around.
Is there a way to basically split the transactions, while still only having a single "frontend confirmation"?
Hey all, just running through the tutorial in the book at https://project-serum.github.io/anchor/tutorials/tutorial-0.html#generating-a-client. When I try to run "node client.js", I get the following error, any thoughts?

throw new Error('failed to get recent blockhash: ' + e);
            ^

Error: failed to get recent blockhash: FetchError: request to http://localhost:8899/ failed, reason: connect ECONNREFUSED 127.0.0.1:8899
Anchor needs to do some stuff at the end of your instruction function. For example, it lets you work with these nice rust structs etc. instead of raw accounts, but at the end of the day you still need to actually persist those structs back into the raw account storage.
what is meant by exit routine? any examples üòÖ
Hey i was in here a lil while ago, looking into how to chain transactions and got that working kinda nicely. But I am running into a transaction too large error.
Is there a neat way to actually get around that? :/
Mm, not totally sure if this is the right way to do it, but something like (random useless example):
```.rs
        for r in ctx.remaining_accounts {
            let hmm = Account::<Owner>::try_from(r)?;
            // do stuff with it
            ...
            // and then remember to call its exit routine
            // so you actually write the changes back out
            // this would happen automagically if you
            // didn't use remaining_accounts
            hmm.exit(ctx.program_id)?;
        }
```
anyway to have multiple programs in 1 anchor project that use different anchor-lang/spl versions? Im getting dep errors
i want to do this with a variable number of accounts
Why do you not want to just pass it as a normal account?
any examples handy?
Mm, yes, though you'd have to make sure that anchor actually writes the discriminator bytes (can't remember what that requires off the top of my head‚Äîway easier to just do it the usual way)
is there a way to do this through the remaining accounts?
You would need to pass that address into the `createMultisig` instruction too, and do another `#[account(zero)]` on top of it.
You never actually init the `ownerA` account, you just allocate its storage. So you never git anchor a chance to set the first 8 bytes of the account storage to be the right `Owner` discriminator bytes.
program log:
```
‚ûú  git:(main) ‚úó cat .anchor/program-logs/5q6Nk8kyxa2Kkc7RSi5eouNDneRQYoyiK6ud28R2m5Uq.serum_multisig.log
Streaming transaction logs mentioning 5q6Nk8kyxa2Kkc7RSi5eouNDneRQYoyiK6ud28R2m5Uq. Confirmed commitment
Transaction executed in slot 2:
  Signature: KZrUBSfmAqP1X6YjtxNksmDJma3qhUohwuieYEpsDR5xggQn9v2WpDJarrm1oD3p6VV7nBoZeBQ2cienvH5Th2d
  Status: Ok
  Log Messages:
    Program 11111111111111111111111111111111 invoke [1]
    Program 11111111111111111111111111111111 success
    Program 11111111111111111111111111111111 invoke [1]
    Program 11111111111111111111111111111111 success
    Program 5q6Nk8kyxa2Kkc7RSi5eouNDneRQYoyiK6ud28R2m5Uq invoke [1]
    Program log: Instruction: CreateMultisig
    Program 5q6Nk8kyxa2Kkc7RSi5eouNDneRQYoyiK6ud28R2m5Uq consumed 3211 of 200000 compute units
    Program 5q6Nk8kyxa2Kkc7RSi5eouNDneRQYoyiK6ud28R2m5Uq success
```
Running into an `Invalid account discriminator here`

```
const multisig = anchor.web3.Keypair.generate();
const [multisigSigner, nonce] =
  await anchor.web3.PublicKey.findProgramAddress(
    [multisig.publicKey.toBuffer()],
    program.programId
  );
const multisigSize = 200; // Big enough.

const ownerA = anchor.web3.Keypair.generate();
const ownerB = anchor.web3.Keypair.generate();

const owners = [ownerA.publicKey, ownerB.publicKey];

const threshold = new anchor.BN(1);
await program.rpc.createMultisig(owners, threshold, nonce, {
  accounts: {
    multisig: multisig.publicKey,
  },
  instructions: [
    await program.account.multisig.createInstruction(
      multisig,
      multisigSize
    ),
    await program.account.owner.createInstruction(
      ownerA,
      multisigSize
    ),
  ],
  signers: [multisig, ownerA],
});

let multisigAccount = await program.account.multisig.fetch(
  multisig.publicKey
);

let ownerAAccount = await program.account.owner.fetch(
  ownerA.publicKey
);

assert(ownerAAccount);
```    
The error  is happenign specifically on `let ownerAAccount = await program.account.owner.fetch(ownerA.publicKey);`. Why is this the case?
I have:

```
 pub fn create_multisig(
    ctx: Context<CreateMultisig>,
    owners: Vec<Pubkey>,
    threshold: u64,
    nonce: u8,
) -> Result<()> {
    assert_unique_owners(&owners)?;
    require!(
        threshold > 0 && threshold <= owners.len() as u64,
        InvalidThreshold
    );
    require!(!owners.is_empty(), InvalidOwnersLen);

    // construct the multisig
    let multisig = &mut ctx.accounts.multisig;
    multisig.owners = owners;
    multisig.threshold = threshold;
    multisig.nonce = nonce;
    multisig.owner_set_seqno = 0;
    Ok(())
}

#[derive(Accounts)]
pub struct CreateMultisig<'info> {
    #[account(zero, signer)]
    multisig: Box<Account<'info, Multisig>>,
}

#[account]
pub struct Multisig {
    pub owners: Vec<Pubkey>,
    pub threshold: u64,
    pub nonce: u8, // this is the nonce we use to find the PDA
    pub owner_set_seqno: u32, // set of owners version #
}

#[account]
pub struct Owner {
    pub multisigs: Vec<Pubkey>,
}
```
Do you know how i can encode and decode a file or a message using the keypair of my wallet ? I search for javascript library or function but i found nothing on this subject
ohhhh
No, unfortunately anchor does support this yet. You'll need to use the `remaining_accounts` feature and handle the deserialization etc. yourself (remainign_accounts are all just AccountInfos)
But you're just rewriting out the data from scratch
Assuming you made sure to allocate enough space, then yeah, when you add things into the protocols vec and the re-serialize the struct back into the account, it just writes everything back out again‚Äîso in effect everything else gets pushed over to make space
where does the next field start, though? In this example, I'm initializing the account with zero `protocols`. So where is the `creator`'s first byte? Is it only 4 after? Then what happens if I add an item to the Vec? Does `creator`'s location get moved?

```#[account]
pub struct MyAccount {
    pub version: u8,
    pub protocols: Vec<OtherAccount>, 
    pub creator: Pubkey,
    pub vault_extra_space: [u8; 256],
}```
Follow up on this - is there any way to pass in a variable number of accounts (all of the same type)? E.g.

```
#[derive(Accounts)]
pub struct CreateMultisig<'info> {
    #[account(zero, signer)]
    multisig: Box<Account<'info, Multisig>>,
    #[account(mut)]
    owners: Vec<Account<'info, Owner>>,
}


#[account]
pub struct Multisig {
    pub owners: Vec<Pubkey>,
    pub threshold: u64,
    pub nonce: u8, // this is the nonce we use to find the PDA
    pub owner_set_seqno: u32, // set of owners version #
}

#[account]
pub struct Owner {
    pub multisigs: Vec<Pubkey>,
}
```
If this is something we can do, what are the restrictions here? Also for some more context: for any multisig, we have a mapping of owners (see `owners: Vec<Pubkey>` on the `Multisig` object) - but I want to create this reverse mapping. The nature of it is that owners:multisig is n:1, so passing in a variable # of accounts on the `#[derive(Accounts)]` obj is what we'd need to do
thx
ah, ok üôÇ i'm already using two different instructions for this but decided to ask about this )
Either don't use init_if_needed at all, and just have two separate instructions, one for when it's already init'd and one for when it's not, or store a flag, `has_already_been_initialized: bool` in the struct, etc.
i think i need to setup default value 0 when it initialized, but i don't know how to do this only on initialization
i have ```#[account(
    init_if_needed,
    payer = user,
    space = 64,
    seeds = [user.key().as_ref(), b"soltery"],
    bump = staker_bump)]
pub staking_info: Account<'info, StakeInfo>,

#[account]
pub struct UserSettings {
    pub staked_amount: u64,
    pub last_changed_date: i64,
    pub pending_tickets: u64,
}``` And i want use this in one method but how i can check that this account initialized first time to increase staked_amount value?
What do you mean? Not sure I understand your question
if i have field with type u64 i can check ctx.accounts.myaccount.myfield == 0 ?
You can however do something like this:
```.rs
*ctx.accounts.that_new_account = ItsStruct::default();
```
Not really, the data starts off with all zeros
Hi! it's possible to define default values for data account if it initialized first time?
Is anyone using regex in a contract?
 `Function _ZN5regex4exec11ExecBuilder5build17h6409425ee0b47b20E Stack offset of 11208 exceeded max offset of 4096 by 7112 bytes, please minimize large stack variables`


// Getting stack size too large when using regex üò¶
```
fn clean_username(username: String) -> String {
    let re = Regex::new(r"\W+").unwrap();
    let result = re.replace_all(&username, "");
    return result.to_string();
}
```
Do you know how i can encode and decode a file or a message using the keypair of my wallet ? I search for javascript library or function but i found nothing on this subject
more detail about the script here https://github.com/glyfo/glyclt-solana/blob/main/glyclt
my question is about declare! public key , what is the best option to replace it ? in automatic mode
Hi , I am using this script to do anchor build inside the container . ```rust
   docker exec -i solanaX /bin/bash -s <<EOF
   export PATH=$_path
   export RUST_BACKTRACE=full
   export ANCHOR_WALLET=$MASTER_WALLET
   home=$(pwd | sed 's#.*/##')
   echo "Proyect:\$home"
   cd /usr/src/\$home
   rm -rf target 
   anchor build
   exit
```
Yeah, the signers array takes in full keypairs
I have another question about signers here:

```
const payer = anchor.web3.Keypair.generate();

await program.rpc.initializeTokenAcct(
      {
        accounts: {
          tokenProgram: splToken.TOKEN_PROGRAM_ID,
          multisigTokenAccount: multisigNFTAccount,
          multisig: multisig.publicKey,
          tokenAcctAuthority: payer.publicKey,
          multisigSigner
        },
        signers: [payer],
      }
    );
```
I'm able to assign payer as a signer in this RPC call. Is that because I have the keypair here? If we only had the `publicKey` would I get an error for trying to set `payer` as signers in this case?
Mm, I'm not sure, there may be some now‚Äîthere's a new version of the spl token js library, I think the type signatures there should explain a lot
Your program gets passed some `&[AccountInfo]`s, and that's it‚Äîno way to load any new ones.
Got it. Is there a guide or relevant functions in managing the associated token accounts?
I think it's helpful to think of this in terms of the lowlevel solana entrypoint signature: https://github.com/solana-labs/example-helloworld/blob/master/src/program-rust/src/lib.rs#L24
That's just how solana's performance model works‚Äîthe client always has to specify every single account of interest, so that the solana runtime can load them all ahead of time/maybe parallelize your tx with others.
> The program can't dynamically look up an associated token account etc.

Why is this the case?
In solana I think it's best to think of there not being much of a separation between client and server, since at the end of the day the client needs to know so much about the addresses/accounts the server expects.
Ah, there's no avoiding approach #2 if I'm understanding you right‚Äîno matter what the client has to specify all relevant accounts. The program can't dynamically look up an associated token account etc.
For example, if we want to do an SPL token transfer, we can structure our program vs. client in a few diff ways. I.e. 

Approach #1:

Program/contract takes the owner's public key as input and then does a search to see if the associated token account exists. If not, create one, then execute the transfer

Approach #2:

Program/contract takes the public key of the associated token account. The client code is responsible for fetching the owner's token accounts and seeing fi the associated token acct exists. 

Approach #1 vs #2 are different based off *where* the code lives to manage the associated token accts given the owner's public key. 

I'm wondering if there are best practices and pitfalls to avoid when structuring your code across programs vs. client code
What do you mean by avoid storing state in program accounts/objects? As opposed to storing it where?


//////////////////////////////////////////////////////////////////////////////////////////

and thx for sharing!
as i heard it will only increase it by a bit though, you still wont be able to run for too long, right?
Any examples of cacheing anchor in github actions?
Sorry for the noob question but whats the diff between the program address that is output by "anchor deploy" vs metadata address that magically appeared in the idl file? I notice the values are different.

I am looking at the https://project-serum.github.io/anchor/tutorials/tutorial-0.html tutorial
<@!826339689195241512> <@!350632015852208140> 
Check out the "Upcoming Changes" section of this doc: https://jstarry.notion.site/Transaction-Fees-f09387e6a8d84287aa16a34ecb58e239#6c4bae9a910641028cc4f3a747be7a6d
hey david
this will be fixed in solana v1.9
yeahh i think devnet is down rip
If yes, could someone help me refer the way?
Question. Is it possible to fetch the IDL without it being verified?
Hey, did u solve it?
any repo which has updated to 0.21.0 or 0.22.0 i could take a look at, wanted to see how people are taking advantages of the new changes and basically implementation etc.
if you find a way to chain more transactions together lmk. let all of us know haha
aight well there's ur answer xD
Yeah I wrote a test and tried it out. Runs out of compute limit after 3 mint calls and 1 transfer üòÖ
just gotta try it out xD
ah actually when you say minting idk
could also be close lol
yh that should go through, but you gotta test it
8 CPIs basically include 7 token minting instructions and 1 token transfer instruction üòÖ
Yes I got same error
8 CPI calls sonuds like quite a bit. if you only create basic token accounts might work, if its juicy endpoints probably not
hey guys, so I'm not sure if devnet is still down, but did anyone ever get this error here? 


``` 
Error: failed to send transaction: Node is behind by 46584 slots
``` 

could be because of devnet being flaky rn
Yeah tried. The program fails and runs out of compute limit after executing 4 CPI calls. 

Looking for suggestions to optimize üôÇ
no idea try it out yourself
<@!347689664855015424> <@!134416332509675520> need urgent help. üôè
Hey guys,

1. What's the MAX number of CPI transfer/mint calls that can be accommodated in an instruction handler?

2. Is it possible to do like 8 CPI calls in a IX handler?
No, that's tied to an `address = ....` constraint
i don't understand your question
Thanks <@!831450660146642974> , its worked and one more, how can i use it for token which is created by spl token program mint 
eg:- ``let pdaTokenAccount = await token.getOrCreateAssociatedAccountInfo(pdaAddress);`` what can i do for  this?
allowOffCurve
let tokenAccount = await Token.getAssociatedTokenAddress(
    ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, tokenMint, authority, **true**);
Hi <@!831450660146642974> and <@!916187801115037728>, I am stuck in creating token account for an PDA address. could you help me with this?,  I check with the solution which is provided by <@!831450660146642974>, that is not available for now. could you please share me some resource to resolve my issue, Thank you.
Error: HTTP status server error (503 Service Unavailable) for url (https://api.devnet.solana.com/)
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.
I'm having some issue with the dev net too
Can someone help üò¶
I'm trying to follow the code in this tutorial: https://hackmd.io/@ironaddicteddog/solana-anchor-escrow#References. But I got the error message: "bump targets should not be provided with init. Please use bump without a target.". What does it mean? This is where the error come from.
Is devnet just slow for everyone else right now, or is it just me? I can't even airdrop tokens to a wallet atm
can I wrap any account in a box? is there a trade-off when storing accounts in a box to speed / security?
https://docs.rs/anchor-lang/0.22.0/anchor_lang/derive.Accounts.html
I'm getting an error or ```Error: 152: An address constraint was violated``` which im assuming is tied to it
what does the has_one constraint in anchor context like so mean?
```
    #[account(mut,
              has_one = market,
              has_one = vault,
              has_one = deposit_note_mint)]
    pub reserve: Loader<'info, Reserve>,
```
Should I call Instruction + invoke, invoke_signed instead of CpiContext in case of the platform that I want to integrate use another version of anchor?
Any ideas on what I can do here?
If I remove the `.clone()` I get the error:

```
cannot move out of `ctx.accounts.multisig` which is behind a mutable reference

move occurs because `ctx.accounts.multisig` has type `std::boxed::Box<anchor_lang::prelude::Account<'_, Multisig>>`, which does not implement the `Copy` traitrustc(E0507)
lib.rs(81, 31): move occurs because `ctx.accounts.multisig` has type `std::boxed::Box<anchor_lang::prelude::Account<'_, Multisig>>`, which does not implement the `Copy` trait
```
The problem I'm running into is the `multisigAccount` at the end of my test ends up not having anything set - it seems like the `create_multisig` didn't work. I suspect this i the case because I'm calling `multisig: ctx.accounts.multisig.clone()` here...
My test looks like:

```
let multisigSize = 200; // Big enough.
    let multisig = anchor.web3.Keypair.generate();
    let [multisigSigner, nonce] =
      await anchor.web3.PublicKey.findProgramAddress(
        [multisig.publicKey.toBuffer()],
        program.programId
      );
    

    const ownerA = anchor.web3.Keypair.generate();
    const ownerB = anchor.web3.Keypair.generate();
    const ownerC = anchor.web3.Keypair.generate();
    const owners = [ownerA.publicKey, ownerB.publicKey, ownerC.publicKey];

    const threshold = new anchor.BN(1);

    await program.rpc.createMultisigNewOwnersMetadata(owners, threshold, nonce, {
      accounts: {
        multisig: multisig.publicKey,
        ownersMetadata: ownerA.publicKey,
      },
      instructions: [
        await program.account.multisig.createInstruction(
          multisig,
          multisigSize
        ),
        await program.account.ownersMetadata.createInstruction(
          ownerA,
          multisigSize
        ),
      ],
      signers: [multisig, ownerA],
    });

    let multisigAccount = await program.account.multisig.fetch(multisig.publicKey);

    assert(multisigAccount);
```
Suppose I have:

```
pub fn create_multisig_new_owners_metadata(
    ctx: Context<CreateMultisigNewOwnersMetadata>,
    owners: Vec<Pubkey>,
    threshold: u64,
    nonce: u8
) -> Result<()> {

    // msg!("ctx.accounts: {:?}", *ctx.accounts);
    
    create_multisig(
        Context::new(
            ctx.program_id,
            &mut CreateMultisig {
                multisig: ctx.accounts.multisig.clone()
            },
            &[],    
            ctx.bumps.clone()
        ),
        owners,
        threshold,
        nonce,
    )?;

    Ok(())
}

pub fn create_multisig(
        ctx: Context<CreateMultisig>,
        owners: Vec<Pubkey>,
        threshold: u64,
        nonce: u8,
    ) -> Result<()> {
        assert_unique_owners(&owners)?;
        require!(
            threshold > 0 && threshold <= owners.len() as u64,
            InvalidThreshold
        );
        require!(!owners.is_empty(), InvalidOwnersLen);

        // construct the multisig
        let multisig = &mut ctx.accounts.multisig;
        multisig.owners = owners;
        multisig.threshold = threshold;
        multisig.nonce = nonce;
        multisig.owner_set_seqno = 0;
        Ok(())
    }

#[derive(Accounts)]
pub struct CreateMultisig<'info> {
    #[account(zero, signer)]
    multisig: Box<Account<'info, Multisig>>,
}

#[derive(Accounts)]
pub struct CreateMultisigNewOwnersMetadata<'info> {
    #[account(zero, signer)]
    multisig: Box<Account<'info, Multisig>>,
    #[account(zero)]
    owners_metadata: Box<Account<'info, OwnersMetadata>>,
}
```
or any tutorials and examples? üò¶
these things make me really confused üò¶ Can you explain more in detailed
You can transfer authority of token account to pda account owner by you program. And invoke_signed any instructions from this pda.
Is there any way a program can hold spl token and how can I get the token from that program?
I guess yes, that NFT would have an token account which then I can get the owner of that token account? but then the balance could be 0 if the owner traded it and their token account still exists
is it possible to get the owner of an NFT if the mint address is passed into the on chain program?
Yeah makes sense, 6 is arbitrary here
So I may be wrong that that's the explanation for limiting stuff to 6 positions etc. ü§î
Transactions have to fit in 1232 bytes, and each account costs at least 32 bytes just to send its pubkey. Given random other stuff in the tx (I'm fuzzy, can't remember), the absolute absolute max is around 30 if I remember right.
What's the rough limitation around number of accounts per tx?
I think in order to check invariants around those accounts you need to pass all of them into instructions ü§î Not actually sure if that's the explanation‚Äîbut it would imply a strict limit, since you just can't fit all that many accounts into a tx üòî
üëã not really an anchor specific question but have noticed a limitation around certain DeFi apps restricting the number of "accounts" you can have (e.g on solend.fi, you can't open more than 6 positions per wallet). Is this related to the limit compute budget (e.g. `consumed 38775 of 200000 compute units` from the program logs)? What is causing the restriction in allowing for ~infinite token accounts?
ü§¶‚Äç‚ôÇÔ∏è
This is kind of a gotcha, but you haven't marked the `owners_metadata` account as mut
thanks man, just found the IDL as well
`program.rpc.transferNft` <- js changes the casing
honestly not really sure how to trace out the naming/setting up of the test scripts like how does the workspace/program/rpc get set up
Getting this error when running my tests: must be really basic issue regarding naming somewhere right? ```TypeError: program.rpc.transfer_nft is not a function``` in my lib.rs i have a function defined as ```pub fn transfer_nft(ctx: Context<TransferNFT>) -> ProgramResult {
        Ok(())
    }```
is using uninitialized authority accountinfo dangerous?
gotcha, thanks alan
```
Transaction executed in slot 3:
  Signature: 4s6nk9BoUBFyBtm8vAq5qGmFg3mKAcudvgPukTPPU7FwzHn2h8Ycgh7AaAZ6rNQMQNzyTQ8jhinVL6a5th7xkCh4
  Status: Ok
  Log Messages:
    Program 11111111111111111111111111111111 invoke [1]
    Program 11111111111111111111111111111111 success
    Program 5q6Nk8kyxa2Kkc7RSi5eouNDneRQYoyiK6ud28R2m5Uq invoke [1]
    Program log: Instruction: CreateOwnersMetadata
    Program log: owners_metadata.multisigs: []
    Program log: owners_metadata.multisigs: [Fss8iTgHY8Y8AcfYDdTiKUXym2Btn3QLDcJrkNgT4vXH]
    Program 5q6Nk8kyxa2Kkc7RSi5eouNDneRQYoyiK6ud28R2m5Uq consumed 16725 of 200000 compute units
    Program 5q6Nk8kyxa2Kkc7RSi5eouNDneRQYoyiK6ud28R2m5Uq success
...
Transaction executed in slot 5:
  Signature: 6mjvbzCaYipUtfyA3MnjZ74KE74iiQvtbpa9cQsB3nusGkztsAuLJiFu4N3MbuSAUaYaTtznZu9QzH1qRUbKSy8
  Status: Ok
  Log Messages:
    Program 5q6Nk8kyxa2Kkc7RSi5eouNDneRQYoyiK6ud28R2m5Uq invoke [1]
    Program log: Instruction: AddToOwnersMetadata
    Program log: owners_metadata.multisigs: [Fss8iTgHY8Y8AcfYDdTiKUXym2Btn3QLDcJrkNgT4vXH]
    Program log: owners_metadata.multisigs: [Fss8iTgHY8Y8AcfYDdTiKUXym2Btn3QLDcJrkNgT4vXH, 7kAto7oM7uMuwhJQRw5RugnBSA4iTFJcTtQY4tDt5Z9C]
    Program log: ctx.accounts.owners_metadata.multisigs: [Fss8iTgHY8Y8AcfYDdTiKUXym2Btn3QLDcJrkNgT4vXH, 7kAto7oM7uMuwhJQRw5RugnBSA4iTFJcTtQY4tDt5Z9C]
    Program 5q6Nk8kyxa2Kkc7RSi5eouNDneRQYoyiK6ud28R2m5Uq consumed 62780 of 200000 compute units
    Program 5q6Nk8kyxa2Kkc7RSi5eouNDneRQYoyiK6ud28R2m5Uq success
```
What's also interesting is the program logs show that it is getting modified properly
Why is it that `ownerAMetadataAccountPostTwo.multisigs` doesn't contain `setTwo.multisig.publicKey`? But `ownerAMetadataAccountPost.multisigs` contains `multisig.publicKey`? The functions to add to the array are literally the same, the only difference between the function calls are the `instructions` arg but that should be fine since the `ownersMetadata` account is already initialized
Calling it like so:

```
await program.rpc.createOwnersMetadata(
  {
    accounts: {
      ownersMetadata: ownerA.publicKey,
      multisig: multisig.publicKey,
      owner: ownerA.publicKey
    },
    instructions: [
      await program.account.ownersMetadata.createInstruction(
        ownerA,
        multisigSize
      ),
    ],
    signers: [ownerA]
  }
)

let ownerAMetadataAccountPost = await program.account.ownersMetadata.fetchNullable(
  ownerA.publicKey
);

let finishedTxn = await program.rpc.addToOwnersMetadata(
  {
    accounts: {
      ownersMetadata: ownerA.publicKey,
      multisig: setTwo.multisig.publicKey,
      owner: ownerA.publicKey
    },
    signers: [ownerA]
  }
);

let ownerAMetadataAccountPostTwo = await program.account.ownersMetadata.fetchNullable(
  ownerA.publicKey
);
```
I have:

```
#[derive(Accounts)]
    pub struct AddToOwnersMetadata<'info> {
    #[account(signer)]
    owners_metadata: Box<Account<'info, OwnersMetadata>>,
    multisig: Box<Account<'info, Multisig>>,
    owner: AccountInfo<'info>
}

#[derive(Accounts)]
pub struct CreateOwnersMetadata<'info> {
    #[account(zero, signer)]
    owners_metadata: Box<Account<'info, OwnersMetadata>>,
    multisig: Box<Account<'info, Multisig>>,
    owner: AccountInfo<'info>
}

#[account]
pub struct OwnersMetadata {
    pub multisigs: Vec<Pubkey>,
}

pub fn create_owners_metadata(
    ctx: Context<CreateOwnersMetadata>
) -> Result<()> {

    let multisig_owners = &ctx.accounts.multisig.owners;

    if multisig_owners.contains(&ctx.accounts.owner.key) { 
        let owners_metadata = &mut ctx.accounts.owners_metadata;
        msg!("owners_metadata.multisigs: {:?}", owners_metadata.multisigs);
        owners_metadata.multisigs.push(ctx.accounts.multisig.key());
        msg!("owners_metadata.multisigs: {:?}", owners_metadata.multisigs);
    } else {
        return Err(ErrorCode::InvalidOwner.into());
    }

    Ok(())
}


pub fn add_to_owners_metadata(
    ctx: Context<AddToOwnersMetadata>
) -> Result<()> {
    let multisig_owners = &ctx.accounts.multisig.owners;

    if multisig_owners.contains(&ctx.accounts.owner.key) { 
        let owners_metadata = &mut ctx.accounts.owners_metadata;
        msg!("owners_metadata.multisigs: {:?}", owners_metadata.multisigs);
        owners_metadata.multisigs.push(ctx.accounts.multisig.key());
        msg!("owners_metadata.multisigs: {:?}", owners_metadata.multisigs);
        msg!("ctx.accounts.owners_metadata.multisigs: {:?}", ctx.accounts.owners_metadata.multisigs);
    } else {
        return Err(ErrorCode::InvalidOwner.into());
    }

    Ok(())
}
```
You *have* to use them if your program needs to sign for an address.
PDAs are totally different kinds of addresses than regular keypair addresses, so their use-cases are just different: https://book.anchor-lang.com/chapter_3/PDAs.html
Probably the easiest way is to just write a test and serialize an instance of the struct, and just check how big it is (think I've posted that example a few times)
<@!134416332509675520> can you help me with this? I have gone through your PDA related answers. Still  confused.
No, BN is only for integers. Can you just use regular numbers?
still anchor.BN?
how do we use float in the new 0.22 from the ts side?
I just want to make sure that I set the right amount of space for `Protocol` . 

I created `pub struct Protocol`, and gave it an attribute `size()`. When I actually `init` the account, I do `1 + 1 + 8 + ... + Protocol::size()`. I want to make sure that `Protocol::size()` is actually correct
How does one decide if the account should be a PDA or non-pda ? 
I want to store a NFT account address, a wallet address and some metadata (configured by the client) on chain. Should I store this in a PDA or non PDA account ?
Also I need to fetch all the accounts  which has the above wallet address stored in them. How can I do this ?
Why do you need to check the space? Not quite sure what you mean
How do I check the space on a struct within my account? I want to make sure that each Protocol is the right size in the protocols vector:

```#[account]
pub struct VaultInfo {
    pub version: u8,
    pub protocols: Vec<Protocol>, 
    pub creator: Pubkey,
}```


//////////////////////////////////////////////////////////////////////////////////////////

Anyone else get this error when they run `anchor test` in devnet?

```================================================================================
Recover the intermediate account's ephemeral keypair file with
`solana-keygen recover` and the following 12-word seed phrase:
================================================================================
furnace arrest argue dress depend twenty more together miracle fault summer park
================================================================================
To resume a deploy, pass the recovered keypair as the
[BUFFER_SIGNER] to `solana program deploy` or `solana write-buffer'.
Or to recover the account's lamports, pass it as the
[BUFFER_ACCOUNT_ADDRESS] argument to `solana program close`.
================================================================================
Error: Custom: Invalid blockhash
There was a problem deploying: Output { status: ExitStatus(ExitStatus(256)), stdout: "", stderr: "" }.```
too hard so i just moved to a different folder
If i have a vault that holds multiple SPL tokens I need to create a vault-authority pda that holds SOL and then derive ATA's from that pda, right?
my program directory looks like this:
target_program
random_program_1
random_program_2

when I call `anchor build` it tries to build everything, but I only want it to build the target_program. My workspace Cargo.toml looks like this:
```
[workspace]
members = [
    "programs/target_program"
]

exclude = [
    "programs/random_program_1",
    "programs/random_program_2"
]
```
When I call `cargo build-bpf` these are ignored. How do i get it to be ignored when building and testing?
anyone?
Hi <@!669837238816735242>, i am also facing some trouble with the PDA to sign a transaction transfer. could able to resolve this, can you please share me the solution. how can i use the pda as authority for the token transfer cpi call?, thanks
hi guys i'm trying to run anchor test on one of the anchor examples, basic_04 in particular.

i'm getting an error 
ReferenceError: describe is not defined @ basic-4.js:4:1

am i missing something?
look like I found something
```
anchor upgrade ./target/deploy/tutorial.so --provider.cluster testnet --program-id DkDLANn2cCG7q557VA5ieicUQQYDnZsexgDrRZgcXRQX
```
Is there an easy way to do that?
Hi, how can upgrade an already deployed anchor program?
I've deployed using `anchor deploy`
Nope, not possible to do any network requests etc. of any kind
Is this functin give a PDA ability to transfer "all token" of the user that it set authority from
can someone tell me the purpose of anchor_spl::token::set_authority?
Is there something like this:

https://docs.chain.link/docs/request-and-receive-data/
for solana?
Let‚Äòs say there is a json with a string on arweave, can I get this string reliably in my rust program somehow?
Is it possible to fetch http/arweave data on the blockchain?
It has money, not just generated sorry, am using from a static keypair.json file.
Is that authority just a fresh keypair? Does it have any money?
yes, 
```
   #[account
    (init_if_needed,
    token::mint=reward_mint,
    token::authority=authority,
    payer=authority
    )]
    pub reward_user_account: Account<'info, TokenAccount>,
```
Who is paying for the creation of the ATA here? The `authority` account?
what I want to be initialized (if it does exist) is `rewardUserAccount`  which I find by `getATAAdress` this is one of Saber library util function, I also am sure that the address is correct becase I minted it manually and checked if that gives me the correct address.
```
let userRewardTokenAddress = await getATAAddress({
            mint: DEVNET_TICKET_PUBKEY,
            owner: usr1Keypair.publicKey,
        })
        console.log("userRewardTokenAddress vault: ", userRewardTokenAddress.toBase58())

        
        const tx = await program.rpc.claim({
            accounts: {
                poolAccount: poolDataAccount.publicKey,
                stakeAccount: stakeDataAccount.publicKey,
                rewardVaultAccount: rewardVaultAccount,
                authority: usr1Keypair.publicKey,
                tokenProgram: TOKEN_PROGRAM_ID,
                rewardMint: DEVNET_TICKET_MINT,
                rewardUserAccount: userRewardTokenAddress,
                systemProgram: anchor.web3.SystemProgram.programId,
                rent: anchor.web3.SYSVAR_RENT_PUBKEY,
            },
            signers: [usr1Keypair]
        });
        console.log("Your claim signature", tx);
    });
```

so , `usr1Keypair` is a simple keypair that just generated.
`Account` is an anchor thing that lets you declare: the client had better pass in a base_account account whose data really does look like the BaseAccount struct, and (in this case), the account had better be owned by my program.
`'info` is a rust lifetime parameter (lots and lots of resources on this if you google it‚Äîit's one of rust's main claims to fame).
Can you post your JS code again?
honestly, not sure yet... its like wrapping decoartors/types fro rust? i think... idk what they are actually called someone in here will know tho and not really 100% what they actually do
``` {
          "name": "authority",
          "isMut": true,
          "isSigner": true
        },```

only authority `isSigner : true` if you meant this and I already send that sign.
What is the "lifetime mismatch" error and how I can solve this problem ? I would like to pass "remaining_account" in picture 2 into "CPIContext"  but it can't compile due to "lifetime mismatch". Can anyone help me solve it  ? üò≠
You can definitely init an associated token address within your program, so not sure why you're getting that signer error (from the client, which is surprising to me)
Check your target/idl/ file for your program; it may help you figure out which account is unexpectedly needing to sign from the client
Hello everyone, Still having same issue and couldn't find a way of creating a token account for the signer. Should I just use a seperate transaction clientside or anyone have solution for it?
Thanks <@!832771976190754846> ... based on what u are saying (focusing on the AddGif)
- AddGif struct alone contains "2" accounts. The 1stof which is **base_account**, and 2nd of wihch is **user**
- base_account has in turn 2 accounts, which is (1) 'info and (2) BaseAccount
- What then, is **Account**, and  '**info** that i have bolded in the code below?

`#[derive(Accounts)]
pub struct AddGif<'info> {
  #[account(mut)]
  pub base_account: *Account*<'*info*, BaseAccount>,
  #[account(mut)]
  pub user: Signer<'info>,
}`

pub base_account: ***Account***<'***info***, BaseAccount>,
```export const getProgramAndProvider = async (
  anchorWallet: anchor.Wallet,
  connection: anchor.web3.Connection,
): Promise<NFTUpgradeAccount> => {
  const provider = new anchor.Provider(connection, anchorWallet, {
    preflightCommitment: 'recent',
  });

  const idl = await anchor.Program.fetchIdl(NFT_UPGRADE_PROGRAM, provider);

  const program = new anchor.Program(idl, NFT_UPGRADE_PROGRAM, provider);

  return {
    program, 
    provider
  };
};```

Any ideas tho guys getting this error still on the frontend, am i missing something stupid?
Seems the idl still doesnt exist or something??

```/**
     * Fetches an idl from the blockchain.
     *
     * In order to use this method, an IDL must have been previously initialized
     * via the anchor CLI's `anchor idl init` command.
     *
     * @param programId The on-chain address of the program.
     * @param provider  The network and wallet context.
     */
    static async fetchIdl(address, provider) {
        provider = provider !== null && provider !== void 0 ? provider : getProvider();
        const programId = translateAddress(address);
        const idlAddr = await idlAddress(programId);
        const accountInfo = await provider.connection.getAccountInfo(idlAddr);
        // Chop off account discriminator.
        let idlAccount = decodeIdlAccount(accountInfo.data.slice(8));
        const inflatedIdl = inflate(idlAccount.data);
        return JSON.parse(utf8.decode(inflatedIdl));
    }```

```TypeError: Cannot read properties of undefined (reading 'getAccountInfo')
    at Function.fetchIdl (index.ts:309:1)
```

Basically saying the IDL can't be found here for some reason?? I have run anchor idl init so not sure what else to try now?
hey dude, just worked this out to answer my own question above^, i assume you haven't run ```anchor idl init -f path/to/idl.json <YOUR_PROGRAM_ID>``` that fixed it for me, seems like you are actually registering the IDL in an account somewhere or something?
so like startstuffoff function takes 3 accounts as arguments, while the AddGif function is taking 2 accounts as args and 1 of those accounts is of type BaseAccount which is the 3rd struct u have defined
from what i understand the ```#[account]``` indicates a single account taht you are defining for storage purposes of data, while the ```#[derive(Accounts)]``` structs are defining input arguments signatures for the functions in your program
```msg 8tvqnQszDVuZVAGWeiXduh9JfmzycnQGgqQZP346zias
msg 8tvqnQszDVuZVAGWeiXduh9JfmzycnQGgqQZP346zias
msg 8tvqnQszDVuZVAGWeiXduh9JfmzycnQGgqQZP346zias
msg 8tvqnQszDVuZVAGWeiXduh9JfmzycnQGgqQZP346zias
Program Id: 75ZsUGwBkzpAwF5wJqTKzZEYKRg25Rnn49GBVXEMPtcu

Deploy success```

```$ anchor idl fetch 75ZsUGwBkzpAwF5wJqTKzZEYKRg25Rnn49GBVXEMPtcu
Error: Account not found```

Can someone please enlighten me?? I am trying to use fetchIdl in the frontend 
as well which is returning nothing, similar to above. I dont really understand wtf 
is going on at this point tho, trying to deploy to devnet
Hi Guys can someone help with some basic questions
1 - how many accounts do i have below?
2 - whats the difference between the Accounts in `#[derive(Accounts)]` and `#[account]`

`#[derive(Accounts)]

pub struct StartStuffOff<'info> {
      #[account(init, payer = user, space = 9000)]
    pub base_account: Account<'info, BaseAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program <'info, System>,
}

#[derive(Accounts)]
pub struct AddGif<'info> {
  #[account(mut)]
  pub base_account: Account<'info, BaseAccount>,
  #[account(mut)]
  pub user: Signer<'info>,
}

#[account]
pub struct BaseAccount {
    pub total_gifs: u64,
    // Attach a Vector of type ItemStruct to the account.
    pub gif_list: Vec<ItemStruct>,
}`
has anyone experience this ?
anchor test or anchor localnet no longer working after upgraded to v0.22.0

<@!326107472098099201> ?
Yea it got left out before release, it‚Äôs updated on master now though
Thanks! I'm assuming the ```anchor init``` command just wasn't updated to use this new syntax
https://github.com/project-serum/anchor/commit/40596824bf85df8c2b3313a677ebbaef559361c9 üò¨
how is this possible when all my accounts are `mut`? ```     Error: 2000: A mut constraint was violated
```
in here?
Probably add the candy-machine to your anchor project programs folder
i guess I'm supposed to replace ProgramResults with Result<()>. Found that in the discord here. Wondering is there a place I could look for documentation around this? I know documentation is limited üò¨
i am running it in the candy-machine dir
Brand new newb question üò±  version 0.22 gives me an error "ProgramResult not found in this scope" when building. Doesn't happy in 0.19. Any thoughts?
docs are great, I learn best by listening to someone who is excited talking about it
paying for anchor/good-posture lessons. come from a .net/python background and diving into rust.
If it‚Äôs raw solana anchor won‚Äôt work
Also doesn‚Äôt look like an anchor project
Hmm but you are not running anchor build in the candy-machine dir?
nothing üò¶

There should be a file in target/idl

No output at all?
Once I have the .json file, I can run this command to generate the idl:
anchor idl init -f <target/idl/program.json> <program-id>
no it just doesnt generate the .json file that I need to build the idl
Not enough info, do you get an error?
can someone please help me with some anchor issues? I am running ```anchor build``` in the candy machine repo to deploy a modified candy machine. However, there is no program.json that is generated, and thus i cannot create an idl. Why is it not generated? For other programs like token-entangler, i see that the program.json is generated. Thank you!
not sure if you can provide the argument from the top
i see it is the same problem
Sorry for that, <@!831450660146642974>. Actually what i want is, I am creating a token mint using spl token program:-
```
let token = await spl.Token.createMint(
        provider.connection,
        tokenAuthority,
        tokenAuthority.publicKey,
        null,
        5,
        spl.TOKEN_PROGRAM_ID
      );
```
Now I am trying to create a token account for this token  which should be associated to my PDA address (not to publ
of  a keypair).  

```let tokenAccount = await token.getOrCreateAssociatedAccountInfo(PDAaddress);```

While trying this , i'm getting an error
```Error: Owner cannot sign: A5a7KT8gJ7QBxrTTEM24gUYQi7pGrMbq1NpAtMYXjKpq```
if such an option doesn't exist which advice could you give me to reduce the size of the **.so** ?
I know that the allocated ProgramData buffer is twice the size of the **.so** file and we can specify a custom value a the deployment stage.
Anyway is there any other strategy to reduce the build size?
Hi, is there a way to reduce the build size of a program. I mean using cargo we can define a release flag to optimized the build is there any similar option with cargo-build-bpf ?
<@!881771727376494693> devnet is down currently
any advice for uploading larger programs? get hit with invalid blockhash error everytime
nvm I just tested a smaller program and it works fine
is devnet down atm?
Is it possible to resolve these CPI imports in VS Code? It compiles/runs fine but would be useful if it could resolve cross-program imports
or is there a better way to do this?
if you wanted to split the lib.rs file into multiple files would you use multiple #[program] ? or a single #[program] and just chain the functions to functions inside the other files?
anyone got any hints for debuging the following error when you have a tone of different accounts getting passed in? ```Transaction simulation failed: Error processing Instruction 0: invalid account data for instruction 
    Program BBjT5U42SuA6FcVZEofPgjAVZahvtWzHaQ8pJHyKkC5T invoke [1]
    Program log: Instruction: AddLiquidity
    Program log: An account's data contents was invalid
    Program BBjT5U42SuA6FcVZEofPgjAVZahvtWzHaQ8pJHyKkC5T consumed 7825 of 200000 compute units
    Program BBjT5U42SuA6FcVZEofPgjAVZahvtWzHaQ8pJHyKkC5T failed: invalid account data for instruction
```
can someone please help me with some anchor issues? I am running ```anchor build``` in the candy machine repo to deploy a modified candy machine. However, there is no program.json that is generated, and thus i cannot create an idl. Why is it not generated? For other programs like token-entangler, i see that the program.json is generated. Thank you!
cool! thanks so much again haha
It has not real semantic effect, purely a hack to save stack space
No, it just sticks some stuff in the heap rather than on the stack (the stack in solana is very small, so you can run out)
Does boxing an account apply and restrictions to using that account or affect security, I don't really understand the tradeoff and what accounts I should be wraping in a Box `<>`
I got one more quick question if thats cool
thank u heaps
Hmm okay yeah I have been using it wrong lol üòÖ
Like, a CPI that changed a TokenAccount's token balance, etc.
You would ordinarily only do it after doing a CPI that altered the account's data
Which is all zeros at this point
reload() says refresh my struct from the underlying AccountInfo's data
I had just set a start timestamp and wantrd the end timestamp to be x amount longer, so I was reloading to borrow the start time and add x, kinda stupid lol
What was the intent there?
Ah, no üôÇ
I guess you cant do that while initializing an account?
I was calling reload on the account in the business logic
nvm I just figured it out
üôÇ
there should be working now
hold up I didnt add tests but will just update it
https://github.com/HappyAwesomePeople/art-token
yeah sorry little clumsy with git, thanks for the help üôÇ
Have to install random stuff, etc.
This doesn't run off the bat
Hey, can you upload a version that's all ready to run, with a package.json etc.?
there is an extra pda (treasury_license ) but I have been trying without it aswell so I know that isnt the troublesome account
https://github.com/HappyAwesomePeople/git-token
sorry for the wait
its not uploaded yet
wait lmao
yeah sure ill post it quickly üôÇ
Can you send me a github link or something?
```
#[account]
#[derive(Default)]
pub struct GalleryLedger {
    bump: u8, //1
    authority: Pubkey, // 32
    current_epoch: u64, //8
    epoch_start: i64, //8
    epoch_end: i64, //8
}
```
How is that GalleryLedger account defined?
Ah, should be better actually without out (so I guess that's not the problem I was wondering about)
Ill try a test validator
no background validator just anchor test
Mm, that's sufficiently weird that I wonder if something else is going on. How are you running your tests? Are you using a running validator in the background, or letting anchor spin them up, etc.?
1 failing
```

  1) art-token
       Create Gallery Ledger!:
     Error: 3002: 8 byte discriminator did not match what was expected
      at Function.parse (node_modules/@project-serum/anchor/src/error.ts:41:14)
      at Object.rpc [as generateGalleryLedger] (node_modules/@project-serum/anchor/src/program/namespace/rpc.ts:32:42)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
```
Mm, where's the error lol
wait holdup maybe this is better
yup thanks so much!
Can you post the full program log? (Lol)
That's definitely a weird error to get with the code above. Are you sure it's not from a different endpoint or something? Is that definitely the code throwing that error?
halfway through this new PDA article in the anchor book and I just want to say its really helpful!
is there a way I can check the 8 byte discriminator of an account I am passing in? It should be zero since it's being initialized right?
I swear I have done the same thing elsewhere and it worked ://
Heyoo keep getting stumped when making PDAs,  getting this error:  8 byte discriminator did not match what was expected

```
#[derive(Accounts)]
#[instruction(gallery_ledger_bump: u8)]
pub struct GenerateGalleryLedger<'info> {
    #[account(init, seeds = [b"gallery_ledger".as_ref()], bump = gallery_ledger_bump, payer=treasury_key)]
    pub gallery_ledger: Account<'info, GalleryLedger>,
    pub treasury_key: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```
---
```
const [galleryLedger, galleryLedgerBump] =
      await anchor.web3.PublicKey.findProgramAddress(
        [Buffer.from("gallery_ledger")],
        program.programId
      );

const tx = await program.rpc.generateGalleryLedger(galleryLedgerBump, {
      accounts: {
        galleryLedger: galleryLedger,
        treasuryKey: program.provider.wallet.publicKey,
        systemProgram: anchor.web3.SystemProgram.programId,
      },
    });
```
is there an easy way to get the Fee for an anchor transaction from the anchor client? The `RpcNamespace` methods seem to only return a TransactionSignature, so I'm not sure how to use `getFeeForMessage` (the alternative I found: `getRecentBlockhashAndContext` is not returning accurate results and is deprecated so I'd really like to use this method).
afaik
you cant create an ATA for another user and have them pay
yes
Doing this on frontend, this would require payer private key.
https://spl.solana.com/token
`const tokenAccount = await getOrCreateAssociatedTokenAccount(
  connection,
  payer,
  mint,
  payer.publicKey
)

console.log(tokenAccount.address.toBase58());
// 7UX2i7SucgLMQcfZ75s3VXmZZY4YRUyJN9X1RgfMoDUi`
I'm trying to have the user create an ATA for themselves
Hello, I am trying to interact with a transfer program I have deployed. How would I send over the amount via a js api function? I am using bs58.encode(1_000_000) and getting the error "Expected Buffer"
found it, and & was out of place
ok, thanks!
<@134416332509675520>  just in case you have a quick tip for it
Yes, you can even make an ATA for another user, this is needed so you can send them tokens.
Anyone know if it's possible to get the program logs from the client side?
The rust error message is just bad unfortunately
You have an error somewhere else, can't tell from that snippet
hi, i'm getting an issue with lifetimes

```
error[E0637]: `&` without an explicit lifetime name cannot be used here
  --> programs/hello/src/lib.rs:15:1
   |
15 | #[program]
   | ^ explicit lifetime name needed here
   |
   = note: this error originates in the attribute macro `program` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0106]: missing lifetime specifier
  --> programs/hello/src/lib.rs:15:1
   |
15 | #[program]
   | ^ expected named lifetime parameter
```

any idea what i'm doing wrong?
I'm trying  to allow a user to claim an `spl-token` to their wallet.

This invariably requires an initialized `Associated Token Account`. 

Can a user initialize an `Associated Token Account` without the authority of the `Mint`  owner? 

i.e sign and pay for the initialization?
Hey! Thanks for sharing this. Understood. That can certainly help execute more CPI calls.
lol solved. I was importing program A to program B from github, not from the path, so it cause errors because on github there's the version with old anchor version
Hi, I'm updating my programs from anchor 0.19.0 to 0.22.0 and now getting these errors 
`the trait anchor_lang::Owner is not implemented for CoinInfo` and
`the trait anchor_lang::AccountDeserialize is not implemented for CoinInfo`
I have this struct on my program
```Rust
#[account]
#[derive(Default)]
pub struct CoinInfo {
    pub orca_price: u64,
    pub coin_gecko_price: u64,
    pub last_update_timestamp: u64,
    pub authority: Pubkey,
    pub symbol: String,
}
```
And when trying to use the struct CoinInfo in another program I get the errors
```Rust
#[derive(Accounts)]
pub struct UpdateCoinPrice<'info> {
    #[account(constraint = switchboard_optimized_feed_account.key() == coin_data.switchboard_optimized_feed_account)]
    switchboard_optimized_feed_account: AccountInfo<'info>,
    #[account(constraint = pyth_price_account.key() == coin_data.pyth_price_account)]
    pyth_price_account: AccountInfo<'info>,
    // struct CoinInfo is imported from delphor-oracle, so the owner MUST be delphor-oracle
    // no need for additional checks
    oracle: Account<'info, CoinInfo>,
    #[account(mut)]
    coin_data: Account<'info, CoinData>,
    payer: Signer<'info>,
    system_program: AccountInfo<'info>,
}
```
Any idea?
jk fixed
i moved some things around and i'm getting an error
```
error: no such subcommand: `build-bpf`
```
when running `anchor test`. how do I solve this?
where should i look to diagnose why an `anchor build` would not generate an idl?

the binary is built w/no issues but no idl is generated in the target folder...havent been able to find any logs
I feel like the program address somehow changed under my feet, but i can't understand how
so i should copy the keypair from the default one in target to my program and Anchor.toml and i should be good going forward?
oh well, i can't explain it
mucho confusing
yet it was only just now that the address changed when i switched to devnet
the existing keypair, which has the new unexpected address, was created on feb 9th, ages ago
cos my program id changed, and i cant find the old keypair
ah ok...
Yeah, at least the first time (the private key is necessary for creating the account that lives at your program_id, but subsequent redeploys actually don't need it‚Äîthey need your program's upgrade authority, which is probably the wallet that did the deploy)
So i must have the private key to deploy to an program address (makes sense).
currently I am handling all this in the frontend but it would be really awesome to check all this through the rust script
Hey! I am having a problem..
m creating user accounts where there is a field for username... now the seeds for the PDA are `seeds = [b"vibe_user", username.as_bytes()]`
but I also want the publickey to be unique along with the username...
so if someone with publickey 1234 has username "qwerty" then that publickey cannot create another user account, and conversely some other public key 6789 cannot use the username "qwerty"

anyway I can do this?
So, when I use `init_if_needed`  with  `payer=authority` where authority is the signer+payer, and I set `token::authority = authority` (which I think that should be the the account owner. I'm getting  ` Signature verification failed`   when I remove `init_if_needed` and create the token account manually, use `mut` instead, it works. and I'm pretty sure that `authority` is the signer
Hello, what is the easiest way of creating an ATA for the signer, I just want to make sure user has the ATA or create it to be able to transfer some funds from program account to there.
I can't remember off the top of my head if there's an option for `anchor deploy` itself
That's the default‚Äîyou can specify a different keypair if you want (try doing `solana program deploy --help`)
so ultimately it's that file that drives it all?
Yep, that's your default keypair (the stuff in Anchor.toml isn't enough information‚Äîyou need an entire keypair, not just the address)
so anchor will always use this address to deploy?  for all envs?
target/deploy/xxx-keypair.json ?
It lives in your `target/` directory, so you'll get a new one if you happen to delete the one in there.
I switched to devnet, and did an anchor test.  Which gave me a whole new program id, ignoring the one in my Anchor.toml and in my program source.
Under what circumstances do i get a new program id?
Hi all
does anybody have any examples of how to create a dockerfile for an anchor project? Kind of new to containerizing things in general and would love some direction.
Hi, not a question but just thought I can give back what I've been asking here. If anyone needs to interact with the `project-serum/multisig` program, I made an minimal anchor example that shows how to do so. I think this might give one more step of understanding CPI's and PDAs. (which I noticed that the book updated üëç ). Thanks to <@!134416332509675520> for the guidance! https://github.com/yasushisakai/multisig-cpi
https://github.com/mark-antony1/jet-vault/commit/9d0821c08761290a0d49606d761331101a40f534
yes!
Can you post the CPI code you're running?
Very unlikely
is it possible that the address constraint error is misclassifying the error?
unless there is some other address constraint i haven't seen
Yeah, seems plausible from the link you sent
does this sound right to you?
its possible I've made a mistake and tracked the wrong IDs but I don't think so
the token id looks like it points to the spl_token program crate which then has the token id i think
i believe the crate ID is the program id which I tracked in that repo and found to be what I'm passing in
in the github link the two constraints are     #[account(address = crate::ID)]
and     #[account(address = token::ID)]
Like, what do you think it should be?
in the logs i print out the addresses
But how are you checking it is what you think it ought to be?
How are you checking that address?
Yes it works! Thanks <@!134416332509675520>  üòÑ
https://github.com/jet-lab/jet-v1/blob/cpi-library/programs/jet/src/instructions/withdraw.rs#L72 are the addresses the CPI i'm making is expecting
Checking
Can you not just do `nft_ata.mint == nft_mint.key()`?
Hi! This may be a dumb question, but how do I validate account data in a constraint in anchor?
`constraint = nft_ata.into_inner().mint == nft_mint.key(),`

```
This gives me a note: this function takes ownership of the receiver self, which moves nft_ata
label: nft_ata moved due to this method call
```

got it, i've checked my addresses i'm passing in and they seem correct, but i'm still getting an address constraint issue
just had to read the docco
Anchor New!! yes found it
Guys a noob question. If I want to create multiple programs should I create them manually inside the programs folder or do I need to run an anchor command to generate them for me?
Why am I getting `Transaction simulation failed: Blockhash not found ` on localnet?
does the `createAssociatedTokenAccountInstruction` fail if the address exists already?
also, any idea why I could be getting a 

`Transaction simulation failed: Error processing Instruction 3: custom program error: 0x0` when running the create associated token account?

```
Token.createAssociatedTokenAccountInstruction(
            ASSOCIATED_TOKEN_PROGRAM_ID,
            TOKEN_PROGRAM_ID,
            mint,
            address,
            owner,
            wallet.publicKey
        ) 
``` 

I do have 0.8 SOL in my wallet ü§∑‚Äç‚ôÇÔ∏è
you can call a program to request more compute


//////////////////////////////////////////////////////////////////////////////////////////

thanx!
So you'd just check for an exception
Ah, there's no chai-specific anchor stuff, just pure chai
Hardhat used to select packages for me ü§™
I think my problem is just that the current chai package I installed doesnt have the to.be.reverted instruction
exactly
So you just want to catch an exception in chai?
Ah‚Äîjust a failed transaction üôÇ
Sorry, I'm coming from Ethereum like development. How is it called in solana when a transaction fails?
What do you mean by revert?
Hi! does anyone know the syntax for testing a revert with anchor/chai?
sadge. thx tho! üôÇ
Nope, that's what a transaction is for üôÇ
is there any way to make a number of instructions atomic, without chaining them together in one transaction?
Upgrade your anchor cli too
Hey, 
In the test file... can't seem to find a way to get the SOL balance of an account.... Can anyone help me out with this ?
is that mean there are something wrong with the idl?
Hi I was trying to make an simple rpc call from js client and I got error from client side saying r.send is not a function
Ah just saw the `anchor-ts` channel
I update anchor-lang and anchor-spl to v0.22.0. Which is said "support float type" but problem still not solved üò¶
How do i send enum when i'm testing via the `program.rpc` in typesript? 

```rust
#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub enum Outcome {
    Heads,
    Tails
}

```
tkss
and if it is already possible, where can I learn more about it?
is it already possible to make transaction longer/bigger (i.e. devnet), or is this still something in progress?
avoid the fact that is replying an error on line 34, i just added that **provider** constant in order to see if the program creation wass succesfully done, but no it didn't. Before that, it was showing the same error but pointing at line 41
Does anyone know, why im getting this error about the Provider? Initially i didn't need the provider when creating a new Program (i made it before and the rpc calls based on the idl pass without any problem), but now im getting this error when creating a new Program. Any ideas?
Arbitrarily big integers (not decimals)
How to use float number üò¶
can someone tell me what anchor.BN do?
Oh problem solved now. I got lucky haha :))
It said that javascript heap out of memory üò¶

I solved that by providing the bump. But new error come üò¶
You might need to mark the creator account as `#[account(mut, signer)]`, since it's paying
Can you post the full program log? That's just the summary
And it return this error
This is what I'm doing now
In this Pda account, what should I put as seeds in ts test?
Thank youuu ‚ù§Ô∏è solved my problem üòç
```rs
#[derive(Default)]
[account]
pub struct ProjectIdoPool
```
Possible with anchor to send a generic CPI call without pre-defining the target smart contract?
I dont understand this error. Can someone help :9
this is the idl json, i'm trying to check, account.dataList.length === 2, but I get the error: Property 'length' does not exist on type 'unknown'.
const account: TypeDef<{
    name: "baseAccount";
    type: {
        kind: "struct";
        fields: [{
            name: "data";
            type: "string";
        }, {
            name: "dataList";
            type: {
                vec: "string";
            };
        }];
    };
}
does typescript support the type vec?  or rather, how would I access or get the length of a vec from the idl.
this is the error messages

What is wrong with this code? I want ido_token_payment to store a vector.
oh yeahh! I forgot it. tksss
Isn‚Äôt the user who initiated the transaction?
hello. Can someone tell me who will pay when a transaction is sign by a pda?
Some one told me that Anchor generates client automatically from IDL. for now i'm seeking that how it is possible.
notice I am a noob yet, the code to interact with the program you have to write it, for example, the tests are code that you program and in which you interact with the logic of the Solana program in JS/TS, as you can do in the backend of your app
[cannot find attribute `[error_code]` in this scope] why I could get this error using the macro?
ü¶Ä ü¶Ä ü¶Ä **HELP**ü¶Ä ü¶Ä ü¶Ä 
Does Anchor automatically Generates Client code for Solana program or we have to write manually code to interact with Solana program? <@!448034961652449283> <@!347689664855015424>
like it is done in the `solend_refresh_obligation` function
specify the lifetimes explicitly
I'm trying to deposit a token into a pool. This is my instruction
```rs
    pub fn deposit(ctx: Context<CreateDeposit>, _pool_name: String, amount: u64) -> ProgramResult {
        let cpi_accounts = Transfer {
            from: ctx.accounts.authority_usdc_account.to_account_info(),
            to: ctx.accounts.pool_usdc.to_account_info(),
            authority: ctx.accounts.signer.to_account_info(),
        };
        let cpi_program = ctx.accounts.token_program.to_account_info();
        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
        token::transfer(cpi_ctx, amount)?;
        let pool_account = &mut ctx.accounts.pool_account;
        pool_account.num_tokens += amount;

        Ok(())
    }
```

And I'm doing it on a test

```js
  it('Deposits some USDC from the wallet\'s account into the Pool', async () => {
    const amountToDeposit = new anchor.BN("50");
    program.rpc.deposit(amountToDeposit, {
      accounts: {
        usdcMint: usdcMint.publicKey,
        poolAccount: poolAccount,
        poolUsdc,
        authorityUsdcAccount,
        signer: provider.wallet.publicKey,
        tokenProgram: TOKEN_PROGRAM_ID,
      },
      signers: [authorityUsdcAccount, poolAccount]
    })

    // check that the account has the right balance for the token
    const balanceInAccount = await provider.connection.getTokenAccountBalance(authorityUsdcAccount);
    console.log(balanceInAccount.value.amount);

    // assert.equal(balanceInAccount.value.amount, new anchor.BN("50"));
  });
```

There are no errors, but the `balanceInAccount` has the original balance, and not 50 less as I would expect.
Why do you want to do it? Boxing normal accounts is possible: https://github.com/project-serum/anchor/blob/master/tests/ido-pool/programs/ido-pool/src/lib.rs#L325
Hello, can multiple PDAs share a same seeds?
Hey, can someone tell me what is the vulnerability caused by `init_if_needed`?
ok makes sense, thanks for the answer!
It's kind of just a random rust thing, a "lifetime annotation". You can call it whatever you want, like `'foo`. It's usually called `info` because under the hood it will end up matching up with the lifetime annotation on the low-level solana AccountInfos that come in with the transaction.
can someone explain what the 'info' part is when we define accounts in the #[derive(Accounts)] macro?

eg for this example from the docs:

`#[derive(Accounts)]
pub struct Update<'info> {
    #[account(mut)]
    pub my_account: Account<'info, MyAccount>,
}`

what does the 'info' part mean in the struct definition, and in the my_account definition
anyone help me please üò≠
I am looking for React/Anchor expert for connecting to smart contract, if you are, DM
When using `anchor test` against localnet, I am hitting an issue of fluctuating transaction fees. I know that Solana's design includes dynamic adjustment of fees, but even if I use `getFeeForMessage`, I always receive `5000` lamports per signature. After sending the transaction however, the fee is off by about 20-40 lamports. I have verified in the Program itself and from the client that the transaction fee being charged is between 5010 and 5040 usually, and is rarely 5000 exactly (seems to be only when it is the first run in a while). Is this expected behavior when running the single local validator, or is there another way I should be checking the fee? How do folks test that the balances of accounts change by the appropriate amount if the fee cannot be accurately predicted?
Thanks very much for your help. And <@!134416332509675520>
gotcha
yea
What is that second one?  The account that holds the program itself?
`[test.validator]
url = "devnet"
[[test.validator.clone]]
address = "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"
[[test.validator.clone]]
address = "PwDiXFxQsGra4sFFTT8r1QWRMd4vfumiWC1jfWNfdYT"`
ah adding the other account seems to make progress...at least..im getting a different error now üôÇ
npnp
Thanks, a lot!
you probably need to also clone that data account
I get the same data returned by the rpc call with and without running the validator with --clone
i think you want to checkout `connection.getTokenBalance`
I'm trying to mint a token, and then check that the account balance is correct.
```ts
    const tx = await mintTo(
      provider,
      usdcMint.publicKey,
      provider.wallet.publicKey,
      tokenAccount,
      new anchor.BN("100"),
    );
    const accreditedAccount = await getTokenAccount(provider, tokenAccount);
    assert.ok(accreditedAccount.amount(new anchor.BN("100")));
```

It fails 
```
     TypeError: Cannot read properties of undefined (reading 'fromBuffer')
      at parseTokenAccount (node_modules/@project-serum/common/src/index.ts:221:28)
      at Object.getTokenAccount (node_modules/@project-serum/common/src/index.ts:214:10)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
```
Is this indicating success?   the program should be large no?
it's a cpi call to the token meta program im trying to do
that's fine
that bpf-program arg is my program
aka [programs.localnet]
having the wrong arg for --bpf-program would also cause that error i think
i can do ` solana-test-validator --clone metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s --url m` and then this: https://gist.github.com/tomlinton/9f63405db0d19a6aebbabd69ab60fa0d
it may be unrelated to the clone bit
`[2022-02-25T00:01:26.660495771Z INFO  solana_test_validator] solana-validator 1.9.1 (src:b66e2ae3; feat:4100269022)
[2022-02-25T00:01:26.660506440Z INFO  solana_test_validator] Starting validator with: ArgsOs {
        inner: [
            "solana-test-validator",
            "--ledger",
            ".anchor/test-ledger",
            "--mint",
            "H7jhMmPhTn6KcyrBcDZB6ewwsBfLELwGhsiaxi4hjYMr",
            "--bpf-program",
            "Emffmf7LnCget7zyBhvoQaKVZVMHR3ShKW579YYG5swr",
            "/home/mattbraz/Coding/repos/tryagain/target/deploy/tryagain.so",
            "--bind-address",
            "0.0.0.0",
            "--clone",
            "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s",
            "--rpc-port",
            "8899",
            "--url",
            "https://api.mainnet-beta.solana.com",
        ],
    }
`
tried this too:
the address does exist on devnet
It'll run quick if it doesn't exist on devnet
Looks like you are passing a mainnet url to the validator but from the args you can see its passing devnet as the url
Copying the program account should take some time no?  The whole thing runs in under a second
but nothing related after that
Is that a devnet address?
`[2022-02-25T00:01:26.708402530Z INFO  solana_test_validator] Fetching metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s over RPC...
`
i also see this
`            "--bind-address",
            "0.0.0.0",
            "--clone",
            "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s",
            "--rpc-port",
            "8899",
            "--url",
            "devnet",
        ],
    }
`
I do see the clone in the validator log
ok i was getting: `Account metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s is not executable`
Now i'm getting: `Transaction simulation failed: Attempt to load a program that does not exist `
I'm not sure the reason, but I think this is a known and unsolved issue https://github.com/project-serum/anchor/issues/675
In a future line, I do `program.idl` and get this error -> ```TypeError: Cannot read properties of undefined (reading 'idl')````
Basically, program is undefined
Will post the program log in one sec.. üòâ
`const program = anchor.workspace.Solendcpi as anchor.Program<Solendcpi>;`

Question: Why isn't this working when I do `anchor test --skip-deploy`?
Ah, shoot, looks like it requires version 0.21.0
are there any good example?
Hi everyone
I have a question
How can I get Colateral value and borrowed value and Net APR in Anchor borrwoed?
`[programs.localnet]
tryagain = "Emffmf7LnCget7zyBhvoQaKVZVMHR3ShKW579YYG5swr"

[registry]
url = "https://anchor.projectserum.com"

[provider]
cluster = "localnet"
wallet = "/home/mattbraz/.config/solana/id.json"

[scripts]
test = "yarn run mocha -t 1000000 tests/"

[test.validator]
url = "https://api.mainnet-beta.solana.com"
[[test.validator.clone]]
address = "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"
`
my Anchor.toml looks like this:
nope still nothing
Ah, what if you use an actual url in that Anchor.toml syntax, like `url = "https://api.mainnet-beta.solana.com"`
it does not
Check your `.anchor/test-ledger/validator.log`, right at the very top, and see if you see a `--clone` argument
anchor-cli 0.20.1
nothing in the cli output about the deployment
Mm, what version of anchor are you using?
cos it's not working
and anchor will copy those accounts from devnet when i run anchor test?
Should i be able to just drop those lines into my Anchor.toml?
```const program = anchor.workspace.Solendcpi as Program<Solendcpi>;```
anchor.workspace doesn't have my program "Solendcpi" it seems
When I run `anchor test --skip-deploy`, I get this error:

```TypeError: Cannot read properties of undefined (reading 'provider')
    at Object.<anonymous> (~/Desktop/accrue/accrue/tests/general/utils.ts:18:28)
    at Module._compile (node:internal/modules/cjs/loader:1101:14)
    at Module.m._compile (~/Desktop/accrue/accrue/node_modules/ts-node/src/index.ts:439:23)
    at Module._extensions..js (node:internal/modules/cjs/loader:1153:10)
    at Object.require.extensions.<computed> [as .ts] (~/Desktop/accrue/accrue/node_modules/ts-node/src/index.ts:442:12)```
unless I share both now and delete just after?
how i can use u8 instruction for seed contstraint? compiler says that it want &u8 but instruction - u8
could I share this in a private space and delete that?
thanks!
I am not technically allowed to post publicky
I changed the thing
The rust code above expects a single argument, not 4
I'm confused by that `createProposal` call, it doesn't have the same signature as the rust code above
JS code
Yeah need the JS
Rust
Can you post/repost the syntax you're using?
I do an Transaction instruction then I put it in u8Array wich length is 447
How difficult would it be to make that kind of oracle, and well this would propably not be an established one so only I would be running a node, do i need to be a validator node for that?
That's a JS error, how big is the data you're trying to encode? How many bytes?
hello people, I'm getting mad, 
I've tried a lot of things but I keep on having the same error over again : `TypeError: Blob.encode[data] requires (length 447) Buffer as src`

what is the root of this kind of error? the size of account?
Yep‚Äîthis is in fact why oracles exist
So an oracle is needed
You have zero network access whatsoever
ah shit
What's the point of doing that, if you don't have access to TCP/IP at all?
You can use this Anchor.toml feature: https://discord.com/channels/889577356681945098/889702325231427584/943483106852212766
If I were to create my own implementation of the reqwests library in rust that just interacts with the TCP/IP stack
Not sure what you mean?
Even if I would create a library from scratch and I am sure the response is the same one every time?
101% not possible, no
Is it 100% not possible at all?
hey guys, can i have an optional account?
fixed
which lifetime want #[program]?
is cloning straight forward?  Anchor spins up a new validator each time for localnet, would i have to clone it each time?
like there is for token and assoc_token
by the way, is it correct that there is no anchor cpi wrapper thingy for the spl_token_metadata program yet?
i have not cloned it
ahh ok
Have you cloned that account from mainnet etc.? I don't think it exists on localnet by default
hello guys, i have started a new program and don't understand error ```18 | #[program]
   | ^ expected named lifetime parameter```
`    #[account(address = spl_token_metadata::id())]
    pub token_metadata_program: AccountInfo<'info>,
`
which i am having to pass in the context like this:
it's the spl_token_metadata program
`Account metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s is not executable`    <-- This should be executable on localnet right?
but for user atas then yes users should pay for those
well the vault atas should be paid for by the vault or the creator of the vault
Ok, so you don't want the user to have to pay for those etc.
creating ATAs, updating vault data
Which ones?
so it can pay for operations
I see that there's a section for idl in the Anchor API. However, I've yet to see this filled. Is this meant to be filled or are you supposed to use something like anchor.Program.fetchIdl?
Why do you need that pda to hold sol?
Im pretty sure It's because we upgraded our solana cli
ive been getting it all week LOL
I was getting that a lot yesterday.  Just kept retrying eventually it works.  Assumed it was temporary network issues.
npnp
Thank you!
should show all the msg! macro calls
Im afk, would test myself otherwise but do I need to include the message in the ProgramError itself? Or does throwing any error show me all of the msg! macro output for the program?
i think u have to throw an error to see the msg macro infos
How can I see the `msg!` macro output from the test validator when running `anchor test`? I am not running the validator separately but am having trouble debugging from rustland without seeing the stdout output
or perhaps I should just copy the programs/structs without that declared id, eh?
if i'm copying some code from another open source program, should I (and if so how do I) change the declared id?
does anyone have any examples of calling the swap function on raydium/orca from within a anchor contract?


//////////////////////////////////////////////////////////////////////////////////////////

thank you that worked!
You have v9.2.0 installed, but the package.json in examples/tutorials mentions ^9.1.3, so my guess is you installed mocha globally on your own? Instead go to `examples/tutorial` and run `yarn install`, then it should be available to `anchor test`
Hi Guys, i'm running "anchor test" on anchor basic-0 example, and getting the error in the screenshot Command "mocha" not found. . I have mocha installed. Any idea? Not been able to find any help on google or the yarnpkg link provided by the info output
thanks!
It finally worked. You were right, no need to pass the logged wallet as signer. Actually I didn't need the workaround in that article, it just worked with the rpc call
why not. It is just a public interface of your program. You can't consider your contract public API as something private.
should I push idl to github?
The provider.wallet signs the tx automatically, no need to add it to that signers array
In that github post, adding `provider.wallet` to the signers array doesn't make sense/isn't necessary (you can only add Keypairs to that array, and the provider.wallet isn't a keypair)
Gm fam! I'm quite stuck with the "TypeError: unexpected type, use Uint8Array" trying to send a transaction. I've followed https://github.com/project-serum/anchor/issues/1109 but still get  the same error on "tx.sign(wallet);" so I may be doing something else wrong. Any tip? Thanks in advance!
i think i've fixed thx!
Can you post a code snippet of it?
same
Try using `author_account`  (or whichever name you are using for the account) instead of `author_account_bump` in the `get` function.
I want to pass a vector of ProjectTokenPayment (struct of timestamp and amount) to program function. How can I do that with anchor and ts? The type of that argiment in my test file is type: { vec: { defined: "ProjectTokenPayment"; }
Hi! According to this changelog https://github.com/project-serum/anchor/blob/master/CHANGELOG.md we can't provide the bump target with init now and its recommend to store the bump on account, but how to store on that the target? With _bump = *ctx.bumps.get(author_account_bump).unwrap(); ? It gets error too
Hello, why this function required u64 :(. How to transfer token with amount of f64 type?
in the Anchor.toml
just overwrite the `target/deploy/[program_name]-keypair.json` and replace the `declare_id` in the lib.rs &
 ```
[programs.localnet]
program_name = UPDATEHERE
```
Hey guys Im struggling to think of a good way to check that the signer doesn't own a provided NFT, I was thinking maybe:

```
pub nft_mint: Account<'info, Mint>,
    #[account(
        constraint = nft_ata.owner == payer.key(),
        constraint = nft_ata.mint == nft_mint.key(),
        constraint = nft_ata.amount == 0
    )]
    pub nft_ata: Account<'info, TokenAccount>,
    pub payer: Signer<'info>,

```
but this expects the account to be initialized,
I could just use init if needed but that is a waste of SOL (you cant close an account in the same transaction as initing it guess?) I don't really want users to have to sign a second transaction to claim that sol back as this is intended to be a regularly used function :))) would appreciate any ideas
I changed the "authority" to a different keypair and now idk how to update
how do I generate a new keypair for an anchor program?
The template update just got left out of the release
hmm why is this ? Why would anchor give an example program that doesn't compile ?

Excuse my ignorance.

Also, for #1, it seems like this message appears on every anchor command I run.
Replace ProgramResult with Result<()>

Hello everyone. I am new here. Started with anchor development today but running into a few issues.

1. Using MacOS, I had to build from scratch ; however, there is an issue where my terminal shows the error `Only x86_64 / Linux distributed in NPM package right now.
Trying globally installed anchor.` , which is odd because my anchor cli is installed and *working*.

edit: issue 1 is just annoying, not really code breaking [ i don't think at least ]

2. I tried to init a new project and run `anchor build`, but for some reason i am getting the error that `ProgramResult is not found in this scope`.

I am not sure if issues 1 and issues 2 are related, but for reference I was following the following guide ( apart from having a different wallet setup ). : https://dev.to/dabit3/the-complete-guide-to-full-stack-solana-development-with-react-anchor-rust-and-phantom-3291
Error redesign is 0.22.0 except template fix for Result<()>
Seems so
So error redesign is in master but not 0.22.0?
Might be nice if it handled master
Avm only deals with tags on GitHub
The template change is in master but not in an official release
N/m. Found it https://book.anchor-lang.com/chapter_2/installation.html
which doesn't include the latest updates? Noob question, how do i get the latest?
But it seems avm use latest only installs up to anchor-cli 0.22.0
Oh, I mean the tutorial is updated, but I think we have to update anchor
Milestone project still uses Result(<>)
Makes sense. The tutorial in the Anchor Book is outdated in that case
Yep yep
In other words, we have to update anchor
Me too. Noob question guys, does this have to do with https://github.com/project-serum/anchor/pull/1462#issuecomment-1046377488 ?
You must be on an older version of anchor... 
Instead of `[error_code]` switch to `[error]` once and try
<@!134416332509675520> never mind, was just an issue with my NPM cache. The reverse of what I said was actually introduced since 17.0. Sorry for the confusion, no further help is needed.   https://github.com/project-serum/anchor/commit/73f046e0a574628fdcd6001362e0870df81ce619#diff-0e2c48e520eafaabcd0d9de371c7d2e74f5bbb4eba766216bb24efb265c0e5c3
in ido-pool examples they use Box for all account
I have another question: when we should use Box for our account?
when referencing an anchor program which tests fine
im trying to use the anchor-client crate but am getting ```
error[E0277]: the trait bound `Pubkey: BorshDeserialize` is not satisfied
yes that solved my problem. thank you ‚ù§Ô∏è
Hi, where can I find doccumentation regarding the `#[instruction(...)]` macro?
is there a type to represent time or a timestamp in solana?
Can you point me to that source? I don't see where it changed ü§î
and I'm getting cluster-version to 1.9.9 although my local solana is 1.8.14 <:pepeThink:844646497911046164>
edit: still returning 1.9.9 but local solana at 1.8.16 works
What's the current cluster-version? Did a reinstall on my mbp to use Darwin
hey guys, I just upgraded to the latest version of anchor and the `async all()` method no longer accepts program filter[]

NEW: `async all(filter?: Buffer): Promise<ProgramAccount<any>[]> `
OLD:  `async all(filters?: Buffer | GetProgramAccountsFilter[]): Promise<ProgramAccount<T>[]> `
The OLD one is more flexible and allows to multiple filters at any offsets, the NEW one only accepts a single filter starting from offset 0. Any context on this change ?
This is great, i've got this working now, thanks very much.
You get the log when it fails, but i assume it can be grabbed when the program succeeds too, which would be useful for debugging.
While i have you, any idea how to get the program log from the js client?
cheers
ok, i see a few usages in the tests in anchor.
Yep üëç
These are accounts passed, but not explicitly mentioned in the Context struct?
In anchor you'd have to use the `remaining_accounts` feature
Not possible to make an AccountInfo within your rust program (well, it's "possible" but it doesn't do what you want‚Äîin solana *all* accounts of interest have to be passed in from the client)
Anyone know how i can send lamports to an arbitrary number of accounts?  For example if i get a vec of Pubkey, can I create an AccountInfo for those and make a transfer ix for each?   I cant find a way to make an AccountInfo in the body of the program, implying i need to have the accounts in the Context, or can the AccountInfos be passed as regular params?
i think i pointed you in the right direction on this, the repo you showed me was not an anchor project, you can do this `git clone https://github.com/metaplex-foundation/metaplex-program-library && cd metaplex-program-library && anchor idl parse --file candy-machine/program/src/lib.rs`
can someone please help me with some anchor issues? I am running ```anchor build``` in the candy machine repo to deploy a modified candy machine. However, there is no program.json that is generated, and thus i cannot create an idl. Why is it not generated? For other programs like token-entangler, i see that the program.json is generated. Thank you!


//////////////////////////////////////////////////////////////////////////////////////////

Hello!

i'm getting this issue `     Error: 4100: The declared program id does not match the actual program id` any idea what is causing this?
anchor_lang::emit
refactor your code such that the logic for the signing of the mintTo ix happens inside instruction logic and then just sign with the pda seeds from within the ix
only a program can sign on behalf of a PDA, you can't do it from a client afaik
i appreciate this. i haven't gotten to that error bc I'm running into one which requires me to copy over a program and a few mints from mainnet
How do I sign `mintTo` with my PDA using `"@solana/spl-token": "^0.2.0",`?
correct. currently it has to be an account
I dont think this can work. youre using seeds as well as `associated_token` constraints. an associated token account is already derived and the `associated_token` constraint checks the seeds. plus the seeds youre providing are wrong for an ATA (but again, you dont have to provide them for ATAs in the first place)
or, where can I pass in `-c, -u` arguments to `solana-test-validator`
Okay, I have a set of accounts i cloned over from mainnet onto a local test-ledger. When I run anchor test tho, it seems to spin up it's own test ledger. how can I have anchor use a diff test-ledger?
it works üòÑ
apparently might need to put some accts in heap -- lemme try it out
along with this
I should mention I get 
```
Program failed to complete: Access violation in stack frame 3 at address 0x200003760 of size 8 by instruction #15612
```
as well
looking forward to StackExchange, haha
Is there a "common errors" page? don't know what to do about this

```
 Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Program failed to complete
```
I feel like i need to pass in the bump somehow to mintTo but I dont see a way to do that
I am a bit confused with the new funcs regarding the spl-token typescript lib:

```
const tokenSwapAccount = new anchor.web3.Account();

    const [tokenSwapAccountAuthority, tokenSwapAccountAuthorityBump] =
      await anchor.web3.PublicKey.findProgramAddress(
        [tokenSwapAccount.publicKey.toBuffer()],
        tokenSwap.TOKEN_SWAP_PROGRAM_ID
      );

    // create pool mint, token A & B mints

    const tokenPoolMint = await spl.createMint(
      program.provider.connection,
      payer,
      tokenSwapAccountAuthority,
      null,
      2
    );
    console.log("created pool mint");
```

^ create mint with authority as mint authority

```
const swapPoolMintTokenAccount =
      await spl.getOrCreateAssociatedTokenAccount(
        program.provider.connection,
        payer,
        tokenPoolMint,
        tokenSwapAccountAuthority,
        true
      );
```
^ create token account with same authority

```
 await spl.mintTo(
      program.provider.connection,
      payer,
      tokenPoolMint,
      swapPoolMintTokenAccount.address,
      tokenSwapAccountAuthority,
      100
    );
```
^ try to mint 100 tokens to the token account and I get a `Signature verification failed` .. cant figure out why though. Maybe I have been looking at it too long
nice, it worked üòÑ
Yep!
I'm an anchor bby. just to clarify, you are saying I do something like this

```rust
  #[account(address=mint)]
  pub token_a_mint: Account<'info, Mint>
```
and  then pass `token_a_mint ` into  `associated_token::mint = token_a_mint`?
Not as an instruction argument
You just pass it as a regular account, yeah
ah... so then how do I pass in that account as an arg?
Ah, I think this is maybe a bug in anchor, can't remember, but I think that `associated_token::mint` constraint has to have an actual mint account on the right hand side, not just a pubkey (it should work with a pubkey, but I don't think it actually does currently)
```rust
    /// Account that stores token A
    #[account(
        init, 
        associated_token::mint = mint,
        associated_token::authority = vault_authority,
        seeds = [VAULT_TOKENA_SEED.as_bytes(), vault_name.as_bytes()],
        bump,
        payer = vault_admin
    )]
    pub vault_token_a: Account<'info, TokenAccount>,
```
Where are you using that `mint: Pubkey` argument?
```
pub fn initialize_vault(
        _ctx: Context<InitializeVault>,
        _vault_name: String,
        _mint: Pubkey,
    ) -> ProgramResult 
```

```
#[derive(Accounts)]
#[instruction(
    vault_name: String, 
    mint: Pubkey,
)]
pub struct InitializeVault<'info> {

  /// Vault admin
    #[account(mut)]
    pub vault_admin: Signer<'info>,

    /// Vault Info
    #[account(
        init,
        payer = vault_admin,
        seeds = [VAULT_INFO_SEED.as_bytes(), vault_name.as_bytes()],
        bump,
    )]
    pub vault_info: Account<'info, VaultInfo>,

    /// Vault authority: PDA which manages everything within the vault
    /// CHECK: this is fine for now but maybe revisit later
    #[account(
        init, 
        payer = vault_admin,
        seeds = [VAULT_AUTHORITY_SEED.as_bytes(), vault_name.as_bytes()],
        bump,
    )]
    pub vault_authority: Account<'info, VaultAuthority>,

    [some mint accounts, some associated token accounts, system program, rent sysvar, token program]
}
```
Thank you very much!. I've just realize it too. Problem solved ‚ù§Ô∏è
Borsh serializes vectors as 4 bytes for the length of the vec, plus each of the items in it one after the other. So how much space you need depends on how big you want to allow that vector to get (you need to give it some amount of space that you're comfortable paying for, since space costs rent money)
Using `derive(Default)` on an account that stores a `Vec` doesn't make sense, because it won't allocate enough space for you (the default value for a vec is empty!). You need to manually specify `space =` in your `init` annotation if you want to use dynamically-sized things like vecs, strings, etc.
I realize that the problem only happend when my vector is not empty. When it empty, I receive an empty array in console.log
can I see the this instruction?
Is there anything I need to know when storing vector in account? I've been struggling with the problem all day and still cannot fix it üò¶
Did you find anything üò¶ I tried to change to vec<u64> but it still not work
nothing in the ctx isn't an account
any idea what causes this error? can't figure it out.

```
10 | #[derive(Accounts)]
   |          ^^^^^^^^ method cannot be called on `anchor_lang::prelude::Pubkey` due to unsatisfied trait bounds
```
if I change the name in my Anchor.toml, it still generates IDLs and other things with the old name. I also changed the cargo.toml in the programs/my_program/ dir
what files/lines do I have to change in order to change the name of a program?
And original prolem back again
I change it back to #[account]
No üò¶
does that fix your original problem then?
That error because I tried to change #[account] to #[state]. It wasn't work haha
I fixed that bro. Please pull again
<@!519199929776865308> u may want to correct this
here bro. Thanks a lot!
https://github.com/thanhlongtld/ido-program
can u send your repo? might have time to take a look later
and Box<Account<‚Äòinfo, Mint>>
like Box<Account<‚Äòinfo, TokenAccount>>
try boxing some token accounts or mint accounts
is the tokenswap program automatically loaded by anchor's local validator?
Try using Box<> around your accounts
```
Stack offset of 6184 exceeded max offset of 4096 by 2088 bytes, please minimize large stack variables
```
what does this mean exactly and what should I do about it
can someone help me with this. My deadline is getting close :((
thankss
dont think so. best use scaled up integers
Is there anything wrong with this code? I create the UserDeposit account successfully but I receive "Error: 3004: Failed to serialize the account"
hello. can anchor_spl transfer float type amount of token?
ty
Yep, `Pubkey::default()` üôÇ
How do I check if a `Pubkey` field in an account struct is initialized or not? Without using a separate initialize var? Is there something like `Pubkey.default`?
Got it üëå
You can't store an AccountInfo on-chain in an account‚Äîit's already the solana thing that represents an account!
Ah, no‚Äîonly in derive(Accounts)
like so
```
    // vault Accounts
    #[account(
        seeds = [vault.vault_name.as_ref().strip()],
        bump = vault.bumps.vault,
        constraint = vault.usdc_mint == usdc_mint.key() @ ErrorCode::InvalidUsdcMint
    )]
    pub vault: Box<Account<'info, Vault>>,
```
in this case, i believe the `Vault` struct is data stored on an account
Is that always the case, AccountInfo is preferable to a Pubkey?
At any rate my point is that saying `pub some_account: Pubkey` in the derive(Accounts) struct doesn't really make sense, since you would rather have at the very least an AccountInfo
u32::default() is 0u32, etc.
Pubkey::default() is the zero address
`#[derive(Default)]` says "rust compiler, please just figure out a reasonable way to make `Vault::default()` make a normal-ish instance of the Vault struct"
i'm not sure what the derive(Default) attribute does üòÖ
I'm asking if there is some relationship between Default and Pubkey
What do you mean? Pubkey does impl Default
```
#[account]
#[derive(Default)]
pub struct Vault {
    pub vault_name: [u8; 20], // Setting an arbitrary max of twenty characters in the vault name.
    pub bumps: VaultBumps,
    pub vault_admin: Pubkey,

    pub usdc_mint: Pubkey,
    pub redeemable_mint: Pubkey,
    pub vault_usdc: Pubkey,

    pub epoch_times: EpochTimes,
}
```
ex:
does the Pubkey reference have some reference to `#[derive(Default)]`?
trying to understand this new bump 'magic' i've been told about
is this section about the new functionality with setting bumps in the context `lang: Context now has a new bumps: BTree<String, u8> argument, mapping account name to bump seed "found" by the accounts context. This allows one to access bump seeds without having to pass them in from the client or recalculate them in the handler` ?
I haven't tried, I'm just trying to understand where, if ever, it makes sense to use a Pubkey
when writing out a struct to be used by a solana program üòÖ
Ah, no, writing Pubkey there just doesn't work‚Äîdoes it even compile when you try?

sure!
Can you write out some sample code? I'm still not sure what you mean‚Äîwhat does it mean to list an account as a Pubkey?
vs Account or AccountInfo
üëå
When I'm writing context, is there ever a reason to list an account as a `Pubkey`?
Just to be clear, you can't do that haha
Not sure what you mean
is there a reason to ever list an account as a pubkey?
cool
The supply of the mint will live on a `Account<'info, Mint>` as just its `.supply`, no need to call to_account_info() on it.
You mean call to_account_info() on a Pubkey?
If I reference a field on context as a pubkey and its the token mint, can I do to_account_info on it? and then query the supply or do I need to do something else?
Doesn't look like you've marked the multisig account as `mut`
`programID.toString()`
When you allocate space for that account, it's all zeros to start.
Hi, so this is a more generic solana  dev doubt rather than specific to Anchor, 
Have been following the solana bootcamp playlist, consider the simple counter example, 

My question is when we first create the counter account, where the initial value ( counter = 0 ) comes from? 
In the client code (https://github.com/jarry-xiao/solana-bootcamp-lectures/blob/master/lecture_1/js/index.js)  , we are using 
```    let createIx = SystemProgram.createAccount({
      fromPubkey: feePayer.publicKey,
      newAccountPubkey: counterKey,
      lamports: await connection.getMinimumBalanceForRentExemption(8),
      space: 8,
      programId: programId,
    });
``` 
In the above, there is no data sent that my inital counter value should be 0. We are only specifying the space. 

In the program side on-chain , we have 
```
#[derive(BorshSerialize, BorshDeserialize, Debug, Clone)]
pub struct Counter {
    pub count: u64,
}

let mut counter = Counter::try_from_slice(&counter_ai.data.borrow())?;
```
My question is how does the initial counter value = 0 comes from ?
When deploying a new program, is there a good rule of thumb for how much account space to reserve? I expect to add a bunch of features over time to a minimal program, so i'm not sure if the 2x default is the right amount
gm people! having a bit of a problem here.. how do you write tests to send `Vec<Struct>` as a parameter to rpc endpoints?
In my webapp, how do i output the programID in the same representation as used in my declare_id? I want to check that they're the same

my lib.rs:
`declare_id!("FyyEsLnaGWdteFK2x38UNzeVveLsgYw4PkXRAk34gMrH");`

my web app:
`const programID = new PublicKey(idl.metadata.address);
console.log("Program ID is " , programID); `

Output in attached screenshot, representation is not the same
Hey there. plz help solve this issue. I'm so close to completing  the buildspace Session 3.ü§î
Any ideas what I can do here?
If I remove the `.clone()` I get the error:

```
cannot move out of `ctx.accounts.multisig` which is behind a mutable reference

move occurs because `ctx.accounts.multisig` has type `std::boxed::Box<anchor_lang::prelude::Account<'_, Multisig>>`, which does not implement the `Copy` traitrustc(E0507)
lib.rs(81, 31): move occurs because `ctx.accounts.multisig` has type `std::boxed::Box<anchor_lang::prelude::Account<'_, Multisig>>`, which does not implement the `Copy` trait
```
The problem I'm running into is the `multisigAccount` at the end of my test ends up not having anything set - it seems like the `create_multisig` didn't work. I suspect this i the case because I'm calling `multisig: ctx.accounts.multisig.clone()` here...
My test looks like:

```
let multisigSize = 200; // Big enough.
    let multisig = anchor.web3.Keypair.generate();
    let [multisigSigner, nonce] =
      await anchor.web3.PublicKey.findProgramAddress(
        [multisig.publicKey.toBuffer()],
        program.programId
      );
    

    const ownerA = anchor.web3.Keypair.generate();
    const ownerB = anchor.web3.Keypair.generate();
    const ownerC = anchor.web3.Keypair.generate();
    const owners = [ownerA.publicKey, ownerB.publicKey, ownerC.publicKey];

    const threshold = new anchor.BN(1);

    await program.rpc.createMultisigNewOwnersMetadata(owners, threshold, nonce, {
      accounts: {
        multisig: multisig.publicKey,
        ownersMetadata: ownerA.publicKey,
      },
      instructions: [
        await program.account.multisig.createInstruction(
          multisig,
          multisigSize
        ),
        await program.account.ownersMetadata.createInstruction(
          ownerA,
          multisigSize
        ),
      ],
      signers: [multisig, ownerA],
    });

    let multisigAccount = await program.account.multisig.fetch(multisig.publicKey);

    assert(multisigAccount);
```
Suppose I have:

```
pub fn create_multisig_new_owners_metadata(
    ctx: Context<CreateMultisigNewOwnersMetadata>,
    owners: Vec<Pubkey>,
    threshold: u64,
    nonce: u8
) -> Result<()> {

    // msg!("ctx.accounts: {:?}", *ctx.accounts);
    
    create_multisig(
        Context::new(
            ctx.program_id,
            &mut CreateMultisig {
                multisig: ctx.accounts.multisig.clone()
            },
            &[],    
            ctx.bumps.clone()
        ),
        owners,
        threshold,
        nonce,
    )?;

    Ok(())
}

pub fn create_multisig(
        ctx: Context<CreateMultisig>,
        owners: Vec<Pubkey>,
        threshold: u64,
        nonce: u8,
    ) -> Result<()> {
        assert_unique_owners(&owners)?;
        require!(
            threshold > 0 && threshold <= owners.len() as u64,
            InvalidThreshold
        );
        require!(!owners.is_empty(), InvalidOwnersLen);

        // construct the multisig
        let multisig = &mut ctx.accounts.multisig;
        multisig.owners = owners;
        multisig.threshold = threshold;
        multisig.nonce = nonce;
        multisig.owner_set_seqno = 0;
        Ok(())
    }

#[derive(Accounts)]
pub struct CreateMultisig<'info> {
    #[account(zero, signer)]
    multisig: Box<Account<'info, Multisig>>,
}

#[derive(Accounts)]
pub struct CreateMultisigNewOwnersMetadata<'info> {
    #[account(zero, signer)]
    multisig: Box<Account<'info, Multisig>>,
    #[account(zero)]
    owners_metadata: Box<Account<'info, OwnersMetadata>>,
}
```


//////////////////////////////////////////////////////////////////////////////////////////

(From the client)
You need to pass the PDA1 account in as well
Hello, dummy question here.
I have created a program that stores an instruction that is signed and serialized into a PDA (PDA1)
Then i put the pubkey of the pda into some data of an other account (PDA2)

Then i create a new function that have the PDA2 in account entry.
I can retrieve the PDA1 Pubkey
But I'm not sure how i can :
1) retreive and deserialize the data from pda 1
2) proceed to the transaction that was signed and serialized in it PDA1

in front there is sendrawtrandaction

Any help where to look?
There actually shouldn't really be anything PDA-specific, you just need to sign with the original authority
https://hackmd.io/@ironaddicteddog/solana-anchor-escrow#Processor-Part-2

He does that here
Looks like `JSON.stringify()` is the solution here
üëã any example on transferring authority to a PDA?
Thanks!
You would need to check that one of the accounts passed in has the right address, and that it is a signer, e.g.
```.rs
#[account(seeds = [...], bump, seeds::program = the_calling_programs_program_id)
pub that_account: Signer<'info>
```
Hey all! How can I check inside instruction if that instruction was signed by right PDA? (I call instruction using CPI)  Is there an example available?
Hey, do you guys know of the preferred way to assert a rust enum variant in ts? Eg I'm fetching the account and it contains { variant: {} } where `variant` is one of the members of my enum. I want the ts function to behave differently based on the value of that enum but things like `account.exampleEnum == { variant: {} }` always resolve to false
Hey, can someone tell me what is the issue caused by init_if_needed?
<@!100062204333686784> I think I figured it out. There's a flag when you fetch the account info that indicates if mint authority is valid `mintAuthorityOption`. Idk if this documented anywhere, but it looks like when u unset the authority on a mint, it doesn't actually change the authority value, but it just changes the `mintAuthorityOption` from 1 to 0.

```
{                                                                                                
  mintAuthorityOption: 0,                                                                                                                                                  
  mintAuthority: <Buffer c2 4e cd 4c d0 df a6 c5 b0 02 e6 57 37 54 09 43 2d 74 86 20 98 30 02 26 f3 69 b5 83 ed 85 4c 07>,                                                 
  supply: <Buffer 01 00 00 00 00 00 00 00>,                                                                                                                                
  decimals: 0,                                                                                                                                                             
  isInitialized: 1,                                                                                                                                                        
  freezeAuthorityOption: 0,                                                                                                                                                
  freezeAuthority: <Buffer 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00>                                                
}
```
Turns out if I look at the explorer, the authority is actually set to null. But idk why my tests always get a non-null value when fetching it
But yeah, I strongly encourage just playing around with this experimentally, using the `#[test]` trick I showed above
Hooray! Thanks a million!
(When using borsh)
And yeah, anchor just reserializes the account data from scratch at the end of the instruction
8 is for the account "discriminator" bytes (they specify what struct anchor should use to deserialize the account data into (in this case, SomeAccount)
In the deserialization/serialization process, does it re-write the memory to keep the vectors contiguous? 

Lets take a look at this account: 
```
#[account]
pub struct SomeAccount {
    pub vector: vec<Pubkey>,
    pub vector_two: vec<Pubkey>,
}
```

First we call an Init function: 
(Program memory)
[ 
08: vector_size 
0B: vector_two_size
...
]


Then we call a push some_pubkey function to vector 2
(Program memory)
[ 
08: vector_size 
0B: vector_two_size
0F: some_pubkey
...
]

Then we call a  push some_other_pubkey to vector 1. 
(Program memory)
[ 
08: vector_size  <- Where does some_other_pubkey go?
0B: vector_two_size
0F: some_pubkey
...
]

Where does some_other_pubkey go? 
I assume the deserialization/serialization handles this and the result is:
(Program memory)
[ 
08: vector_size  <- Where does some_other_pubkey go?
0B: some_other_pubkey
2B: vector_two_size
2F: some_pubkey
...
]
I have a question about this: `8 +2* (4 + 2*32)`

8 + = ?
2 * (vecSize) = there are 2 vecs of vecSize
4 = size of a vec header
2 * (pubkeySize) = there are 2 pubkeys per vec
32 = size of a pubkey

Not sure what the 8 is for
How can I manually encode a program instruction in Rust?
When looking at the official token swap program (not the one I am using) some magic bytes are added. Is there another function I should use to convert my instruction to bytes?
```rust
       buf.push(1);
                buf.extend_from_slice(&amount_in.to_le_bytes());
                buf.extend_from_slice(&minimum_amount_out.to_le_bytes());
                buf.push(*flags);
```
And then the point is that borsh's serialization strategy always ensures that during *de*serialization, borsh will have enough information to decide when one field ends and the next begins (e.g. this is why it serializes vecs with an explicit length at the beginning: so it knows how many individual items to try to deserialize)
Borsh deserialization is greedy. It tries to deserialize the first thing, and looks at however many bytes is necessary to do so; then moves onto the next one, etc.
I'm going to try now . Thanks again !
not yet
Have you tried doing the `#[test]` thing I suggest above? I think I'm not understanding what you're confused about ü§î
Perhaps;) I mean, in fact, our data structure (with dynamic fields) actually lies in an array of bytes. So I don‚Äôt understand how Borsch understands in a continuous data stream where one field of the structure ends and another begins. If there were two usize (length and capacity), then where the field ends can be understood through address arithmetic (current_pos + capacity*data_size). And how to understand this when you only have a length is not entirely clear to me.

PS I'm sorry, it's just that English is not my native language, so I'm not always able to succinctly formulate the question üôÇ
Hi! I'm trying to manually construct a Instruction from an anchor based crate.
```rust

        let data = cpamm::instruction::Swap {
            amount_in: amounts.amount_in,
            minimum_amount_out: amounts.minimum_amount_out,
        }
        .try_to_vec()
        .unwrap();


....



        Ok(TransactionInput {
            instructions: vec![Instruction {
                program_id: id(),
                accounts,
                data,
            }],
            signers: vec![],
            payer: None,
        })
```
But transaction fails and transaction data seems to be shorter then the ones executed from the js web frontend. Accounts are the same as on the web initiated tx. Any ideas?
But basically borsh always does the absolute dead-simplest thing possible at every step
I think you should try printing some borsh serializations just to get a sense for how they work, it's pretty easy to use a `#[test]` in rust for this:
```.rs
#[test]
fn hmm() {
  #[derive(AnchorSerialize)]
  struct Thing {
    x: u8,
    y: u32,
    z: String // dynamically sized!
  }
  let things = vec![
    Thing { x: 0, y: 1, z: "foo".to_string() },
    Thing { x: 1, y: 2, z: "way bigger string".to_string() },
  ];
  eprintln!("{:?}", things.try_to_vec());
}
```
I'm just saying that for an empty vec, there's no data at all, just the 4 bytes for the size
It does! Maybe I'm misunderstanding your question ü§î
Thanks ! I just thought that the size of the second vector would lie immediately after the data of the first vector
It understands that by just greedily deserializing from left to right. So, ignoring the discriminator bytes, it says "ok need to deserialize a vec now" and looks at the next four bytes. They're all zeros, so it says ok, done, empty vec. Now I need to deserialize *another* vec, ok, look at the *next* 4 bytes‚Äîall zeros again, ok done.
Do you mean that in 1.9 there will be this option (deallocate account size)?
```Rust
#[account]
pub struct SomeAccount {
    pub vector: vec<Pubkey>,
    pub vector_two: vec<Pubkey>,
}
```
Suppose I have this structure, I allocated an account for 2 keys for each of the vectors. 8 +2* (4 + 2*32) its size. After the allocation, if I understand you correctly, from 8 to 11 bytes will be 0000, right? However, like everything else (all bytes will be equal to 0). It's just not entirely clear to me how Borsh understands where the boundaries of one dynamic object end and another begins.
Hey <@!100062204333686784> did you figure this out? I am running into the same issue as well 

```
    token::set_authority(
        CpiContext::new_with_signer(
            token_program.to_account_info().clone(),
            SetAuthority {
                current_authority: vault.to_account_info().clone(),
                account_or_mint: mint.to_account_info().clone(),
            },
            &[&vault_seeds],
        ),
        AuthorityType::MintTokens,
        None,
    )?;
```
seems to succeed, but querying for the mint account, the authority is still set. I tried sleeping before fetching as well, same result.
Yeah. Dynamic reallocation is coming at some point (whenever 1.9 lands, as far as I know)
I'm talking about the fact that, unlike the ethereum, you yourself are responsible for maintaining the state via saving data in accounts. And the vector here is a kind of wrapper over the array, because in fact you will not be able to dynamically re-allocate the size of the account.
I talked about it)
Ah, ok, got it!
No, just while I was writing, you already answered. That's what I meant when I wrote about the bad ending.
hey thanks it works fine now :)) I was afraid there would be other magic I am missing
But your nice vec living on the stack, with its data in the heap, can grow just fine at runtime
Maybe I'm agreeing with you‚Äîif you don't allocate enough space, then yeah, you won't be able to serialize the account back into storage
oh ok let me try
The discriminator is 8 bytes, not 1

Sorry, I maybe misunderstood what you were saying
Did I miss something and now in Solana you can change the size of accounts? )
It will fail when you try to serialize the account struct *back* into the underlying AccountInfo's storage though, yes
The data in that vec lives on the heap
It will end fine actually, because vecs are built to support dynamic reallocation üôÇ
What header are you stripping? The discriminator takes up 8 bytes
Just in the context of Solana vec reminds me more of a generic array. Again, if I allocated 320 bytes (10 keys), then if there are 10 keys in the vector, and I push another one, then something tells me that this will not end well üôÇ
How can I manually deserialize that struct (https://github.com/SenchaHQ/sencha/blob/master/programs/cpamm/src/state.rs#L45) from an account state's vec<u8>. I tried several approaches but do not get expected results
```rust
            let swap_info = match try_from_slice_unchecked::<SwapInfo>(data_stripped) {
                Ok(v) => { ..
```

```rust
SwapInfo:deserialize(..)
```

I tried it with and without stripping headers
```rust
       let data_stripped = &mut &data[1..];
```
This is *also* how borsh would serialize an array, so it's not like borsh is being super precise with its serialization strategy
It's not reproducing the capacity you specified when you serialized them‚Äîit throws that information away
Mm, it just does something dumb and says, ok, gotta stick these N things in a vec
Thanks !  I know about this restriction, but I am pleased that you decided to mention it to warn about potential problems. 10 000 was an example. I'm just saying that a vector in Rust on the stack allocates 3 usize: the address of the first element, the length and the capacity. How Borsh can deserialize it only on the basis of one usize is still unclear to me.
To have an account that big, you'll be forced to use `#[account(zero_copy)]` and AccountLoader etc, which don't use borsh at all.
When you allocate space for an account, that space is managed by solana (at runtime at least, it lives wherever the underlying AccountInfo's `.data` field points to). Borsh doesn't care about this at all, and will in fact deserialize your struct onto the stack (so 10k worth of pubkeys won't work, that's far too big for solana's stack frames or even its 32kb heap)
I suppose that is what the doc was telling me...further reading of the rust book required üòõ
Ahh... I see . Thanks ) 
If I understand you correctly, then during initialization I just set capacity , the actual size will be determined by the given usize(32 bits). And then how does he understand where the vector ends? I mean that for example, I allocated places for 10,000 keys (320 kb), but put only one key. Those. we have a capacity of 10,000 and a length of 1.
Yes that does work, thanks
ah misunderstood you, lemme try that
Did you do that `use` statement I mentioned?
You can test this out by doing
```.rs
// in your program file somewhere
#[test]
fn hmm() {
  let xs = vec![1,2,3];
  eprintln!("{:?}", xs.try_to_vec());
}
```
Yeah it should, but i get:  `Pubkey::from_str("3ap2azWa1GzpCxEbRqZYkuGP6GaoC5tzuRMqSPdgLQzn").unwrap(),
                 ^^^^^^^^ function or associated item not found in `anchor_lang::prelude::Pubkey`
`
4 zero bytes
But what you have above should work too, btw
What does <0000> mean?
ah this is what i need, thanks very much
If you have an actual static pubkey, you can also use a solana macro to do that same thing at compile-time, without any runtime cost
```.rs
const HMM: Pubkey = anchor_lang::solana_program::pubkey!("asdasdfasdfasd");
```
to get a pubkey, but the method isn't exiting in Pubkey
`use std::str::FromStr;` if that complains at you
The anchor docs imply that i can do this: `Pubkey::from_str("3ap2azWa1GzpCxEbRqZYkuGP6GaoC5tzuRMqSPdgLQzn").unwrap()`
No, it'll be empty (borsh will serialize that empty vec, regardless of its capacity, as <0000>)
The way borsh serializes a vector is separate from the actual vector itself. Borsh doesn't care about the capacity when it serializes, it only cares about the length.
Usually a vector has a length and a capacity, here I get the impression that length == capacity. For example, I have a collection of 10k pubkeys. Let's say I initialize an account where one of the fields (pub vector: vec<Pubkey>) has a length of 10,000. When I deserialize this account, vector.len() will be 10,000 (assuming I don't actually put even one key)?
Do people use the `?` operator for Result handling in their programs? Would there be any reason not to do this?
is there a way to call find program address with a program?
I found this but I'm not sure if it's going to lead anywhere https://stackoverflow.com/questions/69432084/how-to-decode-a-solana-transaction
Like I can do program.account.myAccountType.fetch(address) to parse an account's data, but there doesn't seem to be a program.transaction.MyTransactionType.fetch(signature)
How do I parse a transaction (starting w/ signature) in my program for associated instruction from JS?
anybody know how to convert a [u8; 32] to a uint?
You can have a `struct`  `impl` a `Trait` in Rust similar to have a `class` can `implements` an `interface` in Java, basically extend the functionality of a struct and update the type definition of the struct so clients of the struct can call those methods you added
can someone explain what impl is and why I would use it?
are bumps often passed to the program instruction handler from the client-side rather than using `find_program_address` in the program in order to make the transaction cheaper for the end-user?
Why do we call them bumps instead of nonces? Is it because we're trying to use a seed to bump the resulting address off the elliptic curve ?
now I"m just getting a insufficient funds issue, which I've fixed
in typescript this operation made the entries include a " character in the string at beginning and end. no idea why the IDL does that by default?
nice... got it
may have found the issue...
interestingly, when I print out the seeds via
```rust
seeds = [{msg!("vault_info seed = {}", VAULT_INFO_SEED); VAULT_INFO_SEED}.as_bytes(), {msg!("vault_name = {}", &vault_name); &vault_name}.as_bytes()],
```
it prints out everything twice in the program log:
```
    Program log: Instruction: InitializeVault
    Program log: vault_info seed = vault-info
    Program log: vault_name = my_vault
    Program log: vault_info seed = vault-info
    Program log: vault_name = my_vault
```
... is that expected?
I can't even init a single PDA so I def think something is wrong here
it is in a github repo but it's private for now and don't have permissions
If this is in a github repo (with a failing test) I can take a quick look, might be faster to debug that way
That probably will be a problem, yeah, but the error above is different
I realized I am passing in `const vaultAdmin = anchor.web3.Keypair.generate()` as the payer/signer. is it possible that it's just complaining bc no funds?
Nope, just have to be careful to get the seeds right
is there anything special you have to do when initing multiple pdas?
```rust
    /// Vault Info
    #[account(
        init,
        payer = vault_admin,
        seeds = [VAULT_INFO_SEED.as_bytes(), vault_name.as_bytes()],
        bump,
    )]
    pub vault_info: Account<'info, VaultInfo>,
```
and
```rust
/// Accounts in context of initialize_vault instruction
#[account]
#[derive(Default)]
pub struct VaultInfo {

    /// Mint address of token A
    pub token_a: Pubkey,

    /// Mint address of token B
    pub token_b: Pubkey,
}
```
let me send that over
You posted the one for vault_token_a above, unless I'm looking in the wrong place
Ah, what does its derive(Accounts) thing look like?
Which is a nonATA PDA
Well. I‚Äôll fix that, but It‚Äôs the vaultinfo account which is complaining
hmm
I though anchor actually checked for that, but I guess not, huh
Maybe you want to just use `token::mint` etc.? So a token account but using one of your own PDAs, not as associated token address
Associated token addresses are *already* PDAs derived from a totally different program, so doesn't make sense to also use your own seeds.
Ah, well, for one, you can't use seeds with `associated_token::` constraints, so not sure what's going on there ü§î
&str
what type is VAULT_INFO_SEED?
for completeness, 

```typescript
let programConstants = Object.assign({}, ...program.idl.constants.map((x) => ({[x.name]: x.value})));
```
^e.g.
```typescript
let [vaultInfo, infoBump] = await anchor.web3.PublicKey.findProgramAddress(
      [
        Buffer.from(anchor.utils.bytes.utf8.encode(programConstants['VAULT_INFO_SEED'])),
        Buffer.from(anchor.utils.bytes.utf8.encode(vault_name))
      ],
      program.programId
    )
```
the program_id i am not so sure about. I have changed the name of files and directories, but I have not changed the declared program id
```
/// Accounts that stores token A
    #[account(
        init, 
        payer = vault_admin,
        associated_token::mint = token_a_mint,
        associated_token::authority = vault_authority,
        seeds = [VAULT_TOKENA_SEED.as_bytes(), vault_name.as_bytes()],
        bump,
    )]
    pub vault_token_a: Box<Account<'info, TokenAccount>>,
```
the `VAULT_TOKEN_A_SEED` is defined in a constants file, which is also read in by my .ts file. the `vault_name` is in the `#[instruction(vault_name: String ... )]` macro, and so the same vault_name is being passed into `findProgramAddress` as the instruction.
Or are you positive you've got the right declare_id! ?
Are you 100% sure you're using the right seeds?
Yep I have init, payer, seeds, bump
To init an account that lives at a PDA requires using `seeds = [...], bump` alongside `init`
`init` CPIs to the system program
You probably have an `init` for that PDA?
the initializeVault instruction is currently empty. the CPIs are all just to create accounts, token accounts, associated token accounts.
I actually don't remember, but yeah, I think if you let anchor spin up its own validator it starts with a totally fresh one (usually what you want)
The only way to sign for a PDA is by having its deriving program sign for it at the point you do the CPI (with `invoke_signed` under the hood)
<@!134416332509675520> is that the intended behavior?
oh wait I'm passing in a keypair.generate() for `vaultInfo` and all other PDAs... that's probably the issue
```
Admin Key: DHXC8h7HxMNuP6jvTT4F6j9fUUS14NHGWCCCupx8Pq86
Info Key: A5rGkqceqPHfVxnv1aNfsJaaccigYPZDtQJF2gjafFfs
Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account 
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS invoke [1]
    Program log: Instruction: InitializeVault
    A5rGkqceqPHfVxnv1aNfsJaaccigYPZDtQJF2gjafFfs's signer privilege escalated
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS consumed 21157 of 1400000 compute units
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS failed: Cross-program invocation with unauthorized signer or writable account
    1) Vault initialized!


  0 passing (132ms)
  1 failing

  1) Vault
       Vault initialized!:
     Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account
```
ah yes there's something going wrong here. the signer privilege of `vault_info` (a pda), not of `vault_admin` is escalated. when I pass in that account, though, it gives me an unknown signer error...
Ah, ok, all good
I fixed the issue would you still like to see the instruction?
Ok, so if I deploy the program to my test validator and run the anchor test it works, but when I don't have the validator running it returns Error: 3012: The program expected this account to be already initialized.
Can you print your whole instruction function?
I was boxing AccountInfo, which I guess is not allowed
Going to need to print what happens after you log `requesting randomness`
```
  logs: [
    'Program GJmxJGYZETm142yHTQVasceWxWSVzC1Zi86UrCEpgrhK invoke [1]',
    'Program log: Instruction: Gamble',
    'Program log: in gamble',
    'Program 11111111111111111111111111111111 invoke [2]',
    'Program 11111111111111111111111111111111 success',
    'Program log: invoked transfer',
    'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [2]',
    'Program log: Instruction: Transfer',
    'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 2755 of 181942 compute units',
    'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success',
    'Program log: requesting randomness',
    'Program log: Failed to borrow a reference to account data, already borrowed',
    'Program GJmxJGYZETm142yHTQVasceWxWSVzC1Zi86UrCEpgrhK consumed 28686 of 200000 compute units',
    'Program GJmxJGYZETm142yHTQVasceWxWSVzC1Zi86UrCEpgrhK failed: instruction tries to borrow reference for an account which is already borrowed'
  ]
```
Hey all! Getting this error 
```
     Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: instruction tries to borrow reference for an account which is already borrowed
```
install a gcc toolchain, how you do that depends on what OS you are on
```error: linker `cc` not found
  |
  = note: No such file or directory (os error 2)

error: could not compile `semver` due to previous error
warning: build failed, waiting for other jobs to finish...
error: build failed```
but it failed with error
I created new anchor project and I tried to run command 'anchor build'
anchor.setProvider(anchor.Provider.env()) how can i check where its running using anchor test
Assume nothing tricky/unexpected is happening
(Basically there's going to be a dumb explanation of what's going wrong, or maybe some other account was expected to be initialized, etc.)
Ok, then are you sure your code is running on localnet?
first, didn't know I could connect to my locahost with the explorer, this is awesome.
Sometimes (sometimes) boxing an Account<'info, Whatever> helps
You're out of stack space, depends a lot on what you're doing
```
  logs: [
    'Program GJmxJGYZETm142yHTQVasceWxWSVzC1Zi86UrCEpgrhK invoke [1]',
    'Program GJmxJGYZETm142yHTQVasceWxWSVzC1Zi86UrCEpgrhK consumed 3256 of 200000 compute units',
    'Program failed to complete: Access violation in stack frame 3 at address 0x200003e78 of size 8 by instruction #11650',
    'Program GJmxJGYZETm142yHTQVasceWxWSVzC1Zi86UrCEpgrhK failed: Program failed to complete'
  ]
```
getting ```Access violation in stack frame``` as an error but i don't have a ton going on in my program, any ideas?
Well, you can always just open up explorer.solana.com and select your network + check if that token address is there
solana config get returns RPC URL: http://localhost:8899, anchor.toml has cluster = "localnet"
Entrypoint has a specific meaning in solana, but I don't think you're referring to the same thing
Mm, can you say more about your question? What do you mean by entrypoint here?
gotcha, okay I will make some of the calls to look at what the data looks like. makes sense tho, I am trying to get balance and it says account doesn't exist so in that case know that they need to create one
Is the the entry point just the position in the instructions array?
Only by fetching the account and just checking to see if it's already initialized (or doing the equivalent kind of thing in your own program)
ah I see. is there a way of knowing if there is already a token account that is created? that makes sense so they have to actually sign a transaction to create the token account to use. is there a way of knowing is they already did that tho, and that the address that is being returned is "set up" in a way
Are you sure you created the account on the same network as where your code is running?
<@!134416332509675520> any ideas on my issue above?
E.g. something like this https://solanacookbook.com/references/token.html#how-to-create-a-token-account
Which isn't about an address, it's about the actual token account
And createProgramAddress is also not what you want unfortunately‚Äîyou would need to actually create the token account if necessary
No, that doesn't create an account, it just "finds" the right address.
Anchor does generate an entrypoint for you, but I'm not sure what the rest of your question is about
Not an anchor question, but for the spl-token program the `findProgramAddress` to get an associated token account. if one doesn't exist, does it create it automatically? I noticed I don't think I created a token account but it gets me an address, so wondering if it is all set up or if need to explicitly create it with `createProgramAddress`

https://spl.solana.com/associated-token-account#finding-the-associated-token-account-address
Do you know which account is 2dbC37PZs7Vurk3DGfsov5fdaY7th7NVVtf4H8JaQFmi? If that's your PDA then you're somehow not signing for it correctly when you do the CPI
Does anchor generate entry points? is the instructions array in idl just [0,1,2] when sending tx?
I used the CLI to create an spl token, created an account with spl-token create-account and tried to pass the account in to my program as a  Account<'info, TokenAccount>, but I'm getting Error: 3012: The program expected this account to be already initialized.  What am I missing?
I am seeing this
```
  2dbC37PZs7Vurk3DGfsov5fdaY7th7NVVtf4H8JaQFmi's signer privilege escalated
  Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS consumed 21157 of 1400000 compute units
  Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS failed: Cross-program invocation with unauthorized signer or writable account
```
in an instruction where one `vault_admin` is signing for everything, i.e. all PDA inits (including associated token accounts). not sure what to do bc i can't pass any other account as a signer bc I get "unknown signer" error, so this is the only valid signer
got it to work! thank you so much
getting this error `     Error: failed to send transaction: Transaction simulation failed: This program may not be used for executing instructions` have you seen this before?
One address per key
Yea I see it's a Option<Vec<CloneEntry>> where CloneEntry is a struct with address field. I don't know how to format that in the toml exactly. 

address = "someaddress"
address = "someotheraddress"

doesn't seem to work. says it expects a sequence. an array-esque [key, other_key] didn't work either.
its not documented but you can decipher it from the types here https://github.com/project-serum/anchor/blob/master/cli/src/config.rs#L537-L580
I have 6 pubkeys i'm tryna clone. edit: 8 actually
address = pubkey
or just list of pubkeys
like what exactly do I put under, account_a=PUBKEY?
is there a doc on format?
[[test.validator.clone]] for the accounts
ty i'll try it out
Yes
where tho, Anchor.toml?
all the [test.validator.*] keys get passed straight to `solana-test-validator`
bumping this
The syntax changed to [[test.validator.clone]] but I cant recall if that was before or after 0.20.1
I have a token program mint that I've created. I'm trying to set the minting authority to null. The transaction goes through and doesn't error but nothing happens. I can successfully change the mint authority to another pubkey. Any idea what's going on?
anything glaringly wrong in the code? added program log for context too
```[test.validator]
url = "https://api.mainnet-beta.solana.com"
[[test.clone]]
address = "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"```
anchor.toml
```
    const accountInfo = await connection.getAccountInfo(tokenAMint)
    console.log("accountInfo", accountInfo)
```
`  const connection = new Connection("http://127.0.0.1:8899", 'confirmed');`
account info is null
Hello! I'm just getting started with Solana and Anchor and I'd like to start building a bet program: bet account with options, the user can bet for an option and the owner of the bet account can set the winner option and distribute the prize (lamports for example) for all who picked the right option

And I face with one question about the best approach for it, I'd like to have dynamic amount of players so I create a new account every time a new player joins the bet, the issue that I'm facing is how to distribute the prize among the winners

From what I understand, I have to pass all the accounts from the client when I pick a winner option, does that mean that I should fetch all the winner accounts in the client and pass them to the pick winner instruction besides the bet account? is there any way to handle everything in the program itself?

Thanks for the help!
anchor-cli 0.20.1
What version of anchor cli are you using? `anchor --version`
Double check that the cloning actually worked by fetching the account in JS etc.
I wonder what I'm doing wrong getting this error `     Error: 3012: The program expected this account to be already initialized` which refers to token_a_mint which is an account i'm cloning from mainnet
Yep
cool, and then if those addresses are token mints I can call methods to move relevant spl-tokens in token accounts they own and stuff?
In your Anchor.toml you can do
```.toml
[test.validator]
url = "https://api.mainnet-beta.solana.com"
[[test.clone]]
address = "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"
[[test.clone]]
address = "PwDiXFxQsGra4sFFTT8r1QWRMd4vfumiWC1jfWNfdYT"
[[test.clone]]
address = "GvDMxPzN1sCj7L26YDK2HnMRXEQmQ2aemov8YBtPS7vR"
[[test.clone]]
address = "WMW5xc3HypXwTnPesyUT49uLsyHwNURsWAEk39onKuk"
```
You can clone accounts from mainnet, yeah
Is there any way to fork mainnet locally so I can reference token mint accounts and mint authorities on mainnet when testing locally?
Thanks
That means your `declare_id!` doesn't match your program's actual program id üòõ


//////////////////////////////////////////////////////////////////////////////////////////

Thanks alan! ü¶æ
https://github.com/killercup/cargo-edit
`cargo upgrade`
No matter what you're going to need some initialization instruction that does something like
```.rs
**ctx.accounts.that_account = ItsStruct::default();
```
Don't think there's a way to avoid this. When you create an account in solana its data starts off as all zeros.
update, seems like yes, that's all you do to upgrade it
hey all, i am new to rust ecosystem, so this is a super noob question, but i can't seem to find a clear answer on google. 

If i wanted to update anchor-lang to the latest package for my solana program, how do i go about doing that? Do i just simply modify the Cargo.toml anchor-lang dependency to the latest version?

i.e.
`
[dependencies]
anchor-lang = "0.20.1"
`
I'm not sure if it is possible or not. you may need to change how `Default` trait is defined.
I don't want to manually add the word "TSLA" in every instruction
```rs
#[program]
pub mod stockprogram{
  pub fn initialize_account(ctx: Context<CreateStock>) -> ProgramResult{
    ctx.accounts.stock.uuid = b"TSLA";
    Ok(())
  }
}
#[account]
pub struct Stock{
  pub uuid: &[u8; 4],
}
#[derive(Accounts)]
pub struct CreateStock<'info>{
  #[account(init, payer = signer, space = 8 + 4)]
  stock: Account<'info, Stock>,
  signer: Signer<'info>,
  system_program: Program<'info, System>,
}
```
is this what you mean?
Hmmm maybe alan knows.
üòï
Is there an anchor-level way to create default values?
Even with `Default`, I need to do `let s: Stock = Default::default()`
how do I set the default value to TSLA
implement `Default` trait for Stock.
Like say i have account

```
#[account] 
pub struct Stock {
    Uuid: [u8; 4]
}

```

How can I set a default value for uuid? E.g. ‚ÄúTSLA‚Äù
`#[derive(Default)]`
default values ? like 0 in place of slot?
How can I set default values for when my account is instantiated?
And thanks pramit!
This answered my question, thanks Alan!
Bools still take a full byte.
8 for u64, 1 for bool and 8 for discriminator
how much space does this take up?
Here's a better example:
```
pub struct LastUpdate {
    pub stale: bool,
    pub slot: u64,
}
```
but the problem is, bool only takes up 1 bit.
8 + 1
How much space should I allocate to create an account like this?
```
pub struct LastUpdate {
    pub slot: u64,
    pub stale: bool,
}
```
Ya Just update the global anchor/cli package
When I store a bool, it only should take up 1 bit. But when I initialize a new account, I can only allocate bytes of space, not bits. Does this mean that a bool variable takes up a full byte of space?
did you have any luck with this?
<@!919972203020308490> you can use this reference ü¶Ä
Hy! Why the fetchIdl returns with null with some candymachine addresses?
Hey I'm new to anchor and blockchain development in general!
I was following the minimal example in the docs and i am getting an error while generating a client! 

Error: failed to get recent blockhash: FetchError: request to http://127.0.0.1:8899/ failed, reason: connect ECONNREFUSED 127.0.0.1:8899
at Connection.getRecentBlockhash (./anchor/examples/tutorial/node_modules/@solana/web3.js/lib/index.cjs.js:5965:13
at processTicksAndRejections (node:internal/process/task_queues:96:5)
at async Provider.send (./anchor/examples/tutorial/node_modules/@project-serum/anchor/dist/cjs/provider.js:82:31)
at async Object.rpc [as initialize] (./anchor/examples/tutorial/node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:31:31)
at async main (./anchor/examples/tutorial/basic-0/client.js:25:3)
I‚Äôm really new to all of this terminal language.
Can someone help me understand what [brew] is?
Also what‚Äôs a PATH? 
And I see a lot of talk about being in the right directory, does this class leave out a lot of code that they expect us to know?
üôè much appreciated.  This details were kinda unclear for me
Is it possible to read PDA data of someone's program or do I need to know the IDL structure ?
has anyone played with how to create a "Solana Pay" button or have an example of one on a website?
The point-of-sale is super awesome
https://github.com/solana-labs/solana-pay
When I store a bool, it only should take up 1 bit. But when I initialize a new account, I can only allocate bytes of space, not bits. Does this mean that a bool variable takes up a full byte of space?
I think I found an older answer to my question https://discordapp.com/channels/889577356681945098/889702325231427584/918271640431902891
hey guys Im looking at the escrow example in the anchor tests repo, but im struggling to understand how this token::set_authority works and haven't been able to find it in the token source code. I get what it does (sets the authority of some account to the pda) but am not understanding how. could someone explain how this function works and how 'ctx.accounts.into()' works too?

`let (pda, _bump_seed) = Pubkey::find_program_address(&[ESCROW_PDA_SEED], ctx.program_id);
 token::set_authority(ctx.accounts.into(), AuthorityType::AccountOwner, Some(pda))?;`
What is a lazy symbol and how do I motivate it to work?
<:jerrywut:921157219444195419>
<:Shrug:856158473745727528>
i blame wormhole
then suddenly it works
i was trying to figure it out for like an hour
yeah ik idk
<:kek:866983238492356609>
yep
are you using the same deploy script?
<:worriedcry:615396682154377216>
it does
does `solana address` show you the expected address?
yep
is this the full stack trace?
haha
idk
I deployed the program from the same account on both mainnet and devnet
yeah i did have them both funded
best to triple check if you have funded the account on both
devnet sol vs mainnet sol
| #[program]
   | ^^^^^^^^^^ could not find `__client_accounts_deposit_token` in the crate root
is this just saying that the macro is completely wrong or is there really missing a crate?
<:Shrug:856158473745727528>
i didn't change anything
and then it worked
then i tried running initialize again on mainnet
that worked
I deployed on devnet from the same address
lol <@!848333406849073202> <@!134416332509675520> idk what happened
triple check youve got the right wallet being used as the `admin` account
awesome, thank you. will try!
<:thinkcat:837225078877716511>

https://solscan.io/account/PH4SWc3n6wUNEKjdBtA2SBLBT2tqQCj7RBwCTyAchvP
```
const PHASE_AUTHORITY: Pubkey = pubkey!(
    "PH4SWc3n6wUNEKjdBtA2SBLBT2tqQCj7RBwCTyAchvP"
);
```
That error basically means what it says, so you'll just have to double + triple check that the PHASE_AUTHORITY (I guess) actually has sol, specifically on mainnet
there's 0.3 SOL left in there
admin (my wallet) has SOL and used SOL to deploy this program
```
#[derive(Accounts)]
#[instruction(bump: u8)]
pub struct Initialize<'info> {
    #[account(
        init,
        seeds = [PHASE_STATE_SEED.as_bytes()],
        bump = bump,
        constraint = state.to_account_info().owner == program_id,
        payer = admin
    )]
    pub state: Account<'info, State>,
    #[account(
        signer,
        constraint = *admin.key == PHASE_AUTHORITY
    )]
    pub admin: AccountInfo<'info>,
    pub system_program: Program<'info, System>,
    pub cpi_authority: AccountInfo<'info>,
    pub x_token_mint: AccountInfo<'info>,
    pub y_token_mint: AccountInfo<'info>
}
```
localnet tests work fine
hey all, tried to deploy to mainnet, but I'm getting this when trying to initialize:

```
Uncaught (in promise) Error: failed to send transaction: Transaction simulation failed: Attempt to debit an account but found no record of a prior credit.
```
In this case if you want the program itself to have authority over the tokens, you could use `token::owner = pool_account`, since pool_account's address is already a PDA.
1) To init a token account, you need to provide more attributes, since anchor needs to know which mint and owner to use for the token account:
```.rs
#[derive(Accounts)]
pub struct Test<'info>{
    pub user_authority: Signer<'info>,
    #[account(init,
    payer = user_authority,
    seeds = [b'test'],
    bump = dont_forget_the_bump,
    token::mint = some_mint_account_you_passed_in,
    token::owner = whoever_has_authority_over_these_tokens,
    )]
    pub pool_account: Box<Account<'info, TokenAccount>>,
}
```
I am intending to send SPL tokens to a PDA account of my program and thought I could would just need to init it like this, but I am getting all kinds of errors.


#[derive(Accounts)]
pub struct Test<'info>{
    pub user_authority: Signer<'info>,
    #[account(init,
    payer = user_authority,
    seeds = [b'test'],
    )]
    pub pool_account: Box<Account<'info, TokenAccount>>,
}

1) Can I do it with TokenAccount or would I need to create a custom struct?
2) what is missing/wrong with the account macro parameters?
So if you want to add a new field, you need to do it at the end, and you need to have pre-allocated enough space to do so.
No, you generally can't change anything about the order (field names doesn't matter though). The issue is that the on-chain data format won't change‚Äîso if you change the field order etc., anchor will try to deserialize the *old* on-chain data according to the *new* struct definition.
yes, my bad I didn't pre-allocate enough space for Account and actually have increased space on upgrade. I see why I have an issue now üôà
so it is only about pre-allocated space, like size should be the same? can I change fields names, types, change fields order in the struct? and still have it backward compatible
just deployed program on mainnet after successful test on devnet. thank you <@!134416332509675520> for literally hand holding me through mud
Any old accounts will remain unchanged after an upgrade‚Äîif you want to change their struct, you'll have to make sure its backwards compatible with the old format, pre-allocate additional space, etc.
e.g. I did update my program changing Account struct with new fields, and I still can read old accounts but can't write them anymore, only new accounts can be updated properly
hey guys! Any suggestions on resources where I can read about updating Anchor programs? specifically, wondered how much I can mess with a code, like changing Account struct, so existing accounts still valid, writable / readable
when it shouldve been wallet.publicKey üòÑ
i was passing in a wallet
nvm
and how is that supposed to work with phantom
I'm getting `TypeError: y.pubkey.toBase58 is not a function` on my client
when you pass a `pub user: Signer<'info>,`, does it need to be a keypair or a pubkey?
good.
Im good i found something thanks !
.
and on github people said that is it because i run a ledger in background
I try this also but i got another error Error: failed to send transaction: Transaction simulation failed: Attempt to load a program that does not exist
run `solana-test-validator` in another terminal
but in the doc it said to not run a ledger in background
Unable to start test validator. Check .anchor/test-ledger/test-ledger-log.txt for errors.
Hi i try to test my first program but when i run anchor test i have this error
Alternatively, can we change/set the default wallet?
Hi, it seems that on the client side the default wallet ```program.provider.wallet``` signs all transactions by default. Is it possible to change this behavior? If yes, how?
<@!134416332509675520> Thanks
Helps with stack space issues (each solana stack frame is quite tiny, only 4kb, so you can run out pretty easily)
Hi, where is the point to wrap an account inside a Box like this:
```rust
    pub token_mint: Box<Account<'info, Mint>>,
```
https://dev.to/0xmuse/accelerated-guide-to-fullstack-web3-with-ass-anchor-solana-and-svelte-1mg
nice
oh nvm I'm just not following the steps to grab the keypair
<:thinkcat:837225078877716511>
as well as this in my `Anchor.toml`:
```
[programs.localnet]
swap = "PH4SdxsogmPaG5bX8jx74PCPz3ePjHvrbem54TW1iWz"

[programs.devnet]
swap = "PH4SdxsogmPaG5bX8jx74PCPz3ePjHvrbem54TW1iWz"

[programs.mainnet]
swap = "PH4SdxsogmPaG5bX8jx74PCPz3ePjHvrbem54TW1iWz"
```

but its still deploying to a different address
I have a:
```rust
declare_id!("PH4SdxsogmPaG5bX8jx74PCPz3ePjHvrbem54TW1iWz");
```
hmm


//////////////////////////////////////////////////////////////////////////////////////////

sounds like the rust you have installed is too old. `rustup update`
whenever I create a new project, I get these warning. any solution for these?
```
warning @project-serum/anchor > @solana/web3.js > rpc-websockets > circular-json@0.5.9: CircularJSON is in maintenance only, flatted is its successor.
[2/4] Fetching packages...
[3/4] Linking dependencies...
warning " > ts-mocha@8.0.0" has incorrect peer dependency "mocha@^3.X.X || ^4.X.X || ^5.X.X || ^6.X.X || ^7.X.X || ^8.X.X".```
Bumping my question from last night as I can't find the answer anywhere - I need to make sure I always get the same program id.  A new keypair is always generated if I blow away the `target` directory and `target` is not checked into source control.   I understand that a keypair is generated in the target directory next to the `.so` What's the purpose of this keypair, and how is it generated?  Does it need to be saved for future use, and what's the security implications of it? Is that key in anyway associated with the wallet defined in `ANCHOR_WALLET` or in `solana_config --keypair` path?
But it doesnt happen in my other anchor repository ü§î
```
error: package `uint v0.9.3` cannot be built because it requires rustc 1.56.1 or newer, while the currently active rustc version is 1.56.0-dev
```

Getting this error when i run `anchor build`
How do I bump the rust version of my anchor program?
I'm caught up now I think, and the source of confusion for me.  You are correct in all things.  The ATA program has an allocation function that allocates and initializes itself to be a real token account.  Thanks for explaining things.  What lead me to think there was a requirement was because the clientside semantics I needed were transferring based on a normal token owner which is what's driven by ATA's.  Neat-o.
maybe you changed to code in your head already ;-). would be convenient!
Hmm, for some reason I thought we had changed that
Ah, sorry, you're right‚Äîyeah, just do them manually
yes, but token::mint seems to be bound to the init macro. So would need to do the constraints manually
gotcha, ty
No
Can you fetch historical transaction information from within a program?
You maybe want to just use `token::mint` etc.
ahh, skipped that part
Associated token addresses are already PDAs derived from a totally different program
I mentioned this above, but you can't use both associated_token *and* seeds constraints
It feel's like the macro is "unhappy" with the authority to itself.
this one still give an "An associated constraint was violated" error
when I remove the associated_token macros this error is gone
 ```#[account(mut,
    associated_token::mint = token_mint.key(),
    associated_token::authority = pool_token.key(),
    seeds = [token_mint.to_account_info().key.as_ref()],
    bump,
    )]
    pub pool_token: Box<Account<'info, TokenAccount>>,
    pub token_mint: Box<Account<'info, Mint>>,```
Cool, no rush, happy to keep chatting about it!
Grr, have a meeting but will come back to this.  Thanks for taking the time.  I'm still trying to reconcile how this works out with the signing.
okay, great!
I'm still parsing these lines, and the ownership, but your last point is basically where I started with this in that there aren't two different entities just addresses, yes.   I though there were three accounts in play when I first did this.
That leads to a regular token account that lives at that specific PDA derived from your program though, yes
To be pedantic, that's not an associated token account‚Äîit's just a regular token account
Anyways lol the main takeaway is that associated token accounts are just regular token accounts with special addresses (their purpose is to give you an "obvious" address to use if you want to send person P some tokens with mint M)
As much as I have understood it: If am taking the program address and add a seed (here the Mint-address of the token): I will have a PDA.

```[pda, _nonce] = await PublicKey.findProgramAddress(
                [TokenMint.publicKey.toBuffer()],
                program.programId
            );```

I am initializing it with my Initialize call. It has the macros
```#[account(init,
    token::mint = token_mint,
    token::authority = pool_token,
    payer = user_authority,
    seeds = [token_mint.to_account_info().key.as_ref()],
    bump,
    )]
    pub pool_token: Box<Account<'info, TokenAccount>>,
    pub token_mint: Box<Account<'info, Mint>>,```

This leads to an associated token account at the PDA address pool_token, right?
Which gets invoked here: https://github.com/solana-labs/solana-program-library/blob/master/token/program/src/processor.rs#L284
https://github.com/solana-labs/solana-program-library/blob/master/token/program/src/processor.rs#L910
btw, If you've done this before, then all this is moot. So I'll just hunt for the explanation
Yeah, when you do a token transfer from A to B, the logical owner of the A token account (as stored in its `.data`) has to sign the tx
Pedantic is always welcome. üòÑ   Sorry, I meant who has to own the authority account.
Just to be pedantic, the program owner of a token account is *always* the spl token program
FYI What I'm hunting for - where the balance of the token is stored, and when someone does token transfer what program has to own the account.
This is going to take a second.  github.dev died this morning and I'm trying to find again where they allocate accounts in the token library.  I apologize in advance when I discover I'm wrong. üôÇ   Will be hunting for  abit.
Hey guys, kinda off topic question. I'm using @ solana/web3.js and I don't know if there is a way of adding callbacks when a transaction is done against a specific address? Any ideas?
So no, the token program itself works perfectly fine without the associated token stuff
The associated token program is purely for convenience, it's not essential
No, I think it's worth emphasizing that there are token accounts, and possibly, if you want, associated token *addresses*
Yes, I think so.  I read the actual spl token lib code and it was very eye crossing, and strange, and I could be wrong of course, but - When you create a "token" account, that just means they are creating an associated token account, and that's it.  It sounds like there are two "token accounts" but there aren't.  The token program expects that there is an account created via the Associated Token Program with the PDA scheme of  derived with `[owner, TOKEN_PROGRAM_ID, mint] with the ASSOCIATED_TOKEN_PROGRAM_ID as the owning program.
It's only the address that is special: it's a PDA derived from the associated token program, with seeds based on the mint + the logical owner
"Associated token account" is a tiny misnomer, it's really an associated token *address*. As an account it's just a regular token account
In the case above, on the command line, the logical "owner" is the wallet (a system program account)
Are you familiar with how associated token accounts work?
Can you say more? Not sure I'm following
See this is what I found really confusing - I think there's *only* an associated token account in the world of tokens.  like when you do `spl-token create-account --owner $MY_KEYPAIR $TOKEN_ADDRESS` on the command line, the owner is just a system program account and remains owned by the system.  The only other account created is the associated token account.
So in effect, it's the program that has authority over the tokens
Which in this case is the account's *own address", which works because it's a PDA
The "owner" logically-speaking is the authority
The program owner of a token account is always the token program (even for associated token accounts)
No, I'm saying do something like this:
```.rs
#[account(
    init,
    token::mint = some_mint,
    token::authority = my_own_address,
    payer = whoever,
    seeds = [...],
    bump = the_bump
  )]
my_own_address: Account<'info, TokenAccount>
```
I  think that would mean the token account's program owner is the token program then, which means his program will no longer be able to sign for that pda for other operations, right?  That's why I used two accounts if I recall correctly.
Then the token account's own address can be its authority
Why not just store the token account at one of his own program's PDAs?
That's kind of why I'm wondering why he's using associated token addresses at all here
Wouldn't he need an account for the PDA which is the authority of the associated token account?
The authority should be the owner of the token.
Do you not actually want to use an associated token address, but rather one of your own PDAs to hold a token account?
your authority is set to itself.
So they can't have your own seeds + bump etc.
Associated tokens are *already* PDAs of a *different* program, the associated token program
You can't use `seeds` and bump with associated_token:: constraints
There now seems to be something wrong with authority of the PDA account. I am now getting an "An associated constraint was violated". I still wonder if that is legal to refer the autority to the PDA.
 ```#[account(mut,
    associated_token::mint = token_mint.key(),
    associated_token::authority = pool_token.key(),
    seeds = [token_mint.to_account_info().key.as_ref()],
    bump,
    )]
    pub pool_token: Box<Account<'info, TokenAccount>>,```
Thank you very much, I am trying to fix it with your input! ‚ù§Ô∏è
To get the associated token account address, it's a PDA.  You can get it from 
```import { ASSOCIATED_TOKEN_PROGRAM_ID, Token, TOKEN_PROGRAM_ID } from '@solana/spl-token';
const associatedTokenAddress = await Token.getAssociatedTokenAddress(ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, mintPublicKey, tokenOwnerPublicKey)```
```
    #[account(  
        mut,
        associated_token::mint = mint,                  
        associated_token::authority = current_owner,        
        constraint = current_owner_token_account.amount == 1,        
    )]
    pub current_owner_token_account: Box<Account<'info, TokenAccount>>,    
    #[account(
        mut,
        constraint = current_owner.key() != user.key())]
    pub current_owner: AccountInfo<'info>,
    #[account(seeds = [PDA_SEED_MINT, bump = mint_bump)]
    pub mint: Box<Account<'info, Mint>>,
```
That's how I do it and it got rid of a lot of cryptic errors.  You just need to make sure you get the associated token account for the token owner in your client.
`constraint = user_paying_account.mint == tokenid::SOL`  and  `constraint = user_paying_account.owner == user_authority.key(),` do what the `associated_token::` fields do.
Just to cover all bases, and this may not be the cause of your issue, but your usage of `TokenAccount` in `SwapToken` doesn't use `associated_token::mint` and `associated_token::authority` I had trouble using existing TokenAccounts until I started passing in the associated token account.
It's a gotcha and the first thing I check when I get unauthorized errors.   That's strange since you didn't mark it as mut...
Yes, I can store Tokens and see them on the PDA address
good thing, to know!
Is the call to  initialize actually working?
First thing - I think you need to mark user_authority with #[account(mut)] otherwise it won't be able to pay.
Sure, I can also add the implementation, it is not so big. Using a 3 step process: 1) Init pool account, 2) deposit Token to swap for (not shown here) 3) send SOL, get token back
```#[derive(Accounts)]
pub struct Initialize<'info> {
    // User Accounts
    pub user_authority: Signer<'info>,    
    #[account(init,
    token::mint = token_mint,
    token::authority = pool_token,
    payer = user_authority,
    seeds = [token_mint.to_account_info().key.as_ref()],
    bump,
    )]
    pub pool_token: Box<Account<'info, TokenAccount>>,
    pub token_mint: Box<Account<'info, Mint>>,
    // Programs and Sysvars
    pub token_program: Program<'info, Token>,
    pub system_program: Program<'info, System>,
    pub rent: Sysvar<'info, Rent>,
}
#[derive(Accounts)]
pub struct SwapToken<'info>  {
    // User Accounts
    pub user_authority: Signer<'info>,
    #[account(
    mut,
    constraint = user_paying_account.mint == tokenid::SOL,
    constraint = user_paying_account.owner == user_authority.key(),
    )]
    pub user_paying_account: Box<Account<'info, TokenAccount>>,
    #[account(
    mut,
    address = tokenid::TARGET,
    )]
    pub recipient: Box<Account<'info, TokenAccount>>,
    #[account(mut,
    seeds = [token_mint.to_account_info().key.as_ref()],
    bump,
    constraint = pool_token.mint == token_mint.key()
    )]
    pub pool_token: Box<Account<'info, TokenAccount>>,
    pub token_mint: Box<Account<'info, Mint>>,
    #[account(mut,
    constraint = user_token.owner == user_authority.key(),
    constraint = user_token.mint == token_mint.key())]
    pub user_token: Box<Account<'info, TokenAccount>>,
    //rec_program: Pubkey,
    //usdc_mint: Box<Account<'info, Mint>>,
    // Programs and Sysvars
    pub token_program: Program<'info, Token>,
    pub system_program: Program<'info, System>,
}
pub fn initialize(ctx: Context<Initialize>) -> ProgramResult {
        msg!("INIT");       

        Ok(())
    }
pub fn swap_token(ctx: Context<SwapToken>, amount: u64) -> ProgramResult {
        msg!("SWAP TOKEN");
        
        if ctx.accounts.user_paying_account.amount < amount {
            return Err(ErrorCode::LowToken.into());
        }

        let cpi_accounts = Transfer {
            from: ctx.accounts.user_paying_account.to_account_info(),
            to: ctx.accounts.recipient.to_account_info(),
            authority: ctx.accounts.user_authority.to_account_info(),
        };
        let cpi_program = ctx.accounts.token_program.to_account_info();
        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
        token::transfer(cpi_ctx, amount)?;

        // Send Token back
        let cpi_accounts = Transfer {
            from: ctx.accounts.pool_token.to_account_info(),
            to: ctx.accounts.user_token.to_account_info(),      
            authority: ctx.accounts.pool_token.to_account_info(),
        };
        let cpi_program = ctx.accounts.token_program.to_account_info();
        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
        token::transfer(cpi_ctx, 10000)?;

        Ok(())
    }```
resolved thaxs
Need the actual code.
That error can happen a lot. Need to post your structs and your instruction code in order to help usually.
FYI - etiquette here is to not @ the mods.  They are really active and helpful so just be patient
simulation failed: Error processing Instruction 0: custom program error: 0x13c
<@!347689664855015424> any thought on this?
Also, need to post the rest of your struct.  Need to see if user_authority is marked a mutable, etc.
Can you post your instruction contents?
ok thanks
I got a question regarding PDAs. I am storing tokens in a pool (PDA), but I am encountering problems with the authority over that storage. I thought that my program would automatically be owner by using a PDA as storage. I wonder if I would need to create an additional PDA account only to act as an authority for my storage?


```#[account(init,
    token::mint = token_mint,
    token::authority = pool_token,
    payer = user_authority,
    seeds = [token_mint.to_account_info().key.as_ref()],
    bump,
    )]
    pub pool_token: Box<Account<'info, TokenAccount>>,
    pub token_mint: Box<Account<'info, Mint>>,```

When trying to transfer the tokens out I am getting
```Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account```
‚û°Ô∏è  I am so grateful of the level of support you provide here! <a:ScalebounceHeartRed:870562664412250182>
hmmm using `uint = "0.8"` seemed to work
Hey! I'm trying to add `uint = "0.9.0"` as a dependency and get this error:
```
cargo-build-bpf child: rustup toolchain list -v
cargo-build-bpf child: cargo +bpf build --target bpfel-unknown-unknown --release
error: package `uint v0.9.3` cannot be built because it requires rustc 1.56.1 or newer, while the currently active rustc version is 1.56.0-dev
```

But this is my rustc version
```
rustc --version
rustc 1.58.1 (db9d1b20b 2022-01-20)
```
if ive understood correctly
you could pass in the user's public key as a seed also, i.e. one `audience_account` per user
but dont know how to achieve this in rust
I want to be able to pass in the seed an integer that i can iterate in the front in order to create more audience account
what can I add to it in order to create more audience account
the point is my seed is not "variable"
```
----
#[program]
pub mod nft_lock {
    use super::*;
    pub fn initialize(ctx: Context<Initialize>, audience_account_bump: u8, audience_name: String ) -> ProgramResult {
        ctx.accounts.audience_account.bump = audience_account_bump;
        ctx.accounts.audience_account.name = audience_name;
        ctx.accounts.audience_account.authority = *ctx.accounts.authority.to_account_info().key;
        Ok(())
    }
    pub fn register(ctx: Context<Register>, checkin_account_bump: u8, token: String) -> ProgramResult {
        ctx.accounts.checkin_account.bump = checkin_account_bump;
        ctx.accounts.checkin_account.token = token;
        ctx.accounts.checkin_account.authority = *ctx.accounts.authority.to_account_info().key;
        ctx.accounts.checkin_account.audience = *ctx.accounts.audience_account.to_account_info().key;
        ctx.accounts.audience_account.register_count += 1;

        Ok(())
    }
}

#[derive(Accounts)]
#[instruction(audience_account_bump: u8)]
pub struct Initialize<'info> {
    #[account(
        init,
        seeds = [
            b"influenceur".as_ref()
        ],
        bump = audience_account_bump,
        payer = authority,
        space = 300,
    )]
    pub audience_account: Account<'info, Audience>,
    #[account(mut)]
    pub authority: Signer<'info>,
    #[account(address = system_program::ID)]
    pub system_program: Program<'info, System>,
}
-----------------------------------------
```
Hello, i have some issue i'm trying to fix in my program. This might due to my lack of knowledge in Rust language.
the folowing is my program and i want to be able to create many audience account:
book.anchor-lang.com
via faucet such as https://faucet.ropsten.be/
can anyone run by me what `#[program]`, `#[derive(Accounts)]` and `#[account]` do
```rust
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod myepicproject {
  use super::*;
  pub fn start_stuff_off(ctx: Context<StartStuffOff>) -> ProgramResult {
    // Get a reference to the account.
    let base_account = &mut ctx.accounts.base_account;
    // Initialize total_gifs.
    base_account.total_gifs = 0;
    Ok(())
  }
}

// Attach certain variables to the StartStuffOff context.
#[derive(Accounts)]
pub struct StartStuffOff<'info> {
    #[account(init, payer = user, space = 9000)]
    pub base_account: Account<'info, BaseAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program <'info, System>,
}

// Tell Solana what we want to store on this account.
#[account]
pub struct BaseAccount {
    pub total_gifs: u64,
}
```
How do i get other coins on devnet? Like usdc / eth / etc
isn't using vector a bad idea? I saw on a conference video, "he said avoid using vector and string"
Is there docs on how the program id is derived?
I have ANCHOR_WALLET set before all of my commands, yet if I delete the target directory, I get a new program id generated every time.
gotcha, thanks alan
I don't think there's any macro way to do it, just have to actually do it via a CPI.
How do I close a *token* account using anchor's macro? i know I can do `#[account(close = <destination>)]` to close a regular account
thanks üòõ
Yes you can üòÜ
how can I view my anchor transactions on solana explorer? the hash says its not found
looks like the answer is yes but just wanna confirm üôÇ
can i pass a dynamically sized Vec into an instruction?
Hey guys, is it just me or do you guys get an invalid blockhash error when anchor deploying programs?
Or update your os
So you're probably going to have to build solana from source (not via the installer, via a github checkout)
Aha, that sounds like your problem‚Äîthat error message specifically says something was built for os x 11.0
10.13.6 High Sierra
not an M1 mac
but solana --version returns 1.9.5
sh -c "$(curl -sSfL https://release.solana.com/v1.9.5/install)"
but i never updated the PATH if that was important, not sure at all what that meant .
Are you on a M1 etc?
Hmm, how did you install solana?

Hey guys! Keep trying to run an anchor test but i keep getting an error that i find on the internet but not with my compilers.... lazy symbol binding failed
Thanks, that worked, but if I close phantom and reopen it, the spinner returns 100% of the time...
Your `provider.wallet` signs the tx no matter what
Mm, yeah, sometimes this happens, not sure why yet‚Äîyou can "fix" it by switching networks to devnet or whatever and then switching back
Any trick to getting phantom to connect to solana-test-validator on localhost? I'm just getting a spinner.
thanks <:PoggersLove:825149316795596821>
hey guys anyone know how I can sign a transaction with my client wallet? Say I pass in an account owned by 'provider.wallet.publicKey' and want to sign a transfer instruction on the smart contract side with this account. I haven't seen a way to pass it in as a signer
thanks üëå
yes
How can I pass in a dynamically sized array into my txn?
is it safe to just use u64 instead?
Seems like anchor doesn't have a `Slot` variable?
I am trying to run my tests but get this error: `IdlError: Type not found: {"name":"slot","type":{"defined":"Slot"}}`
Sweet! Just found what youre talking about. Thanks tom
there is examples of using a const in `tests/misc/programs/misc/src/account.rs`
sweet. I will do this. Thanks so much Tom, really appreciate it üôè
if you did `const SIZE: usize = 5;` and removed that it would work
i pushed a fix for it in https://github.com/project-serum/anchor/pull/968/files but i think because of the casting to `as usize` it won't work correctly
that's so weird. Why can't i put in a const variable as a parameter for size?
omfgggg you were right
0.20.0
what version of anchor?
is this wrong?
```
const SIZE: i32 = 5;

#[account]
pub struct MyAccount {
  pub field: [u8, SIZE as usize],
}
```
they can for account data, but not for some other things like events
can array sizes not be const?
you've got a const for an array size in enum i think
The thread "main" panicked at Result::unwrap() on an err value?
Anyone know what's going on here?

```
To deploy this program:
  $ solana program deploy ~/Desktop/accrue/accrue/target/deploy/accrue.so
The program address will default to this keypair (override with --program-id):
  ~/Desktop/accrue/accrue/target/deploy/accrue-keypair.json
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: ParseIntError { kind: InvalidDigit }', lang/syn/src/idl/mod.rs:153:76
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```
Ah, gotcha. So a Rust client that talks to the chain?
different form cargo unit tests
there's a program_test crate made by solana for rust integration tests
nope
In other words, the JavaScript tests sort of killed two birds.
You mean [cfg(test)] in the rust programs?  If that's what you're talking about, I was wondering if that would be a quicker journey than through javascript.  However, I've noticed that as my tests grew, the amount of shared code grew, and then it turned into a javascript client library for building my transactions.  Kind of like how the CFO test started doing it.   That code is the exact code my web app uses, so I broke it out to a JavaScript lib that's shared by the anchor tests and the web app.
we really need some good program_test rust examples
The examples all use chai/mocha.
what testing frameworks/setup do most people run for anchor programs?


//////////////////////////////////////////////////////////////////////////////////////////

` The currently active rustc version is rustc 1.58.1`
Been stuck on this for a while. Would appreciate help üëå  thanks
I'm try to add this crate to my Cargo.toml:
```
[dependencies]
spl-token-lending = { git="https://github.com/solendprotocol/solana-program-library/", version = "0.1.0", features = ["no-entrypoint"] }
```

But I get this error when I run `anchor build`:
```error: package `uint v0.9.3` cannot be built because it requires rustc 1.56.1 or newer, while the currently active rustc version is 1.56.0-dev```
okay, running yarn worked, thanks
Depending on what version of anchor you're using you can also just run `yarn` inside your project directory
`npm install -g mocha`, or something similar (you need to install mocha)
hello, i am trying to run 'anchor test' and im getting an error saying command "mocha" not found, what should i do?
Will dig into the source some more to get a better view - thanks!
But no, no accounts are being created here
Have you tried jumping to source on the `SystemProgram.transfer` function?
<@!134416332509675520>  maybe you can clarify something else. I am looking at the https://docs.solana.com/developing/clients/javascript-reference and it says `Each TransactionInstruction consists of keys, data, and a programId` yet in the sample given, `programId` is not used anywhere. Does this mean that when you do 
```js
// Add an instruction to execute
transaction.add(web3.SystemProgram.transfer({
    fromPubkey: payer.publicKey,
    toPubkey: toAccount.publicKey,
    lamports: 1000,
}));
```
are the `from` and `to` accounts being created under the covers and are owned by the `SystemProgram`? 
Or are no accounts being created in this case?
Can anyone explain what is the difference between Ethereum Mint(Solidity) and Solana Mint?
I am an expert in Rust, but very beginner to Solana blockchain. I want help.
The `provider.wallet` is what pays for the tx fees, so it signs automatically
By not needing to add it do you mean manually or it's automagically added in the signer array?
If you're using phantom as your `provider.wallet`, you don't need to add it as a signer (and in fact, you can't, because phantom will never give you access to the wallet's secret key)
Does `provider.wallet.publicKey` work?
ohhh wow, Very glad u told me that lol thanks
No, you'll need to do `my_account.reload()?;` to update its struct stuff (its underlying `.data` field on the AccountInfo updates right away, but not the fancy anchor struct stuff on top)
(My guess is 2)
If I do a CPI call to change the value of an account, will I have the most up-to-date value for that account right after?

E.g. 
1. Do a CPI call to change SolendReserve.amount = 1 to SolendReserve.amount = 2
2. In the same instruction, get SolendReserve.amount. Would it be 1? or 2?
indeed
This makes things a bit weird for assoc accs
Huh, guess you can.
https://github.com/solana-labs/solana-program-library/blob/482a9281f6afcf149870cd60d9c2742a1cdda9bc/token/program/src/instruction.rs#L153
you can
thanks! super helpful
you can't transfer the ownership if I'm not mistaken, but you can delegate https://spl.solana.com/token#authority-delegation
does it transfer the ownership of the token account?
The authority is the  key which needs to sign to spend the tokens on the account. It's explained here https://spl.solana.com/token
What's the exact meaning of authority for spl tokens? https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html#spl-constraints doesn't seem to explain
how do I pass the connection to phantom wallet as signer of a transaction?

signers: [
          provider?
           ]
okay.. i ll check
I'm not familiar with the error but sounds like it could be something with the program id keypair. Maybe you're trying to deploy the contract to an address which doesn't match the keypair in ./target/deploy ?
same error occurs in anchor test too
Hey guys. Need your help. This error appears on running anchor test or anchor deploy.
switched to devnet -> anchor build -> changed program id in lib.rs and anchor.toml -> anchor build
after this anchor deploy gives this error

```
error: Invalid value for '--program-id <PROGRAM_ID>': unrecognized signer source
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.
```
Bummer. But thanks for the reply!
Ah, that unfortunately isn't possible to do inside your solana program, you always have to pass every single account you want to access in from the client
Thank you. What I meant is that I'm trying to find data that may exist among a bunch of [data] accounts owned by a program. With the `getParsedProgramAccounts(...)` you can use `memcmp` to grab slices and match data, then return the full account that matches, for instance. Haven't seen an example that does it within an Anchor program, though...
Fantastic explanation - thanks for that. You condensed a bunch of docs into a paragraph üëç
Maybe sticking closely to the usual close to be safu
https://github.com/project-serum/anchor/blob/df51a27a48e5d03005e841f383f407aef74e3555/lang/src/common.rs#L6-L24
Oh, right‚Äîgiven the issue above about not being able to deserialize it, should you just zero out its data too?
Mmmh careful with that, descriptor and data will remain, so a following ix can fund it to be rent exempt again.
You don't need to deserialize it in order to close it. Just pass it in as a `AccountInfo<'info>` and take its lamports/send them somewhere else.
that is an awesome explanation. Thank you very much! <:minecraftheart:930151977948684359>
i cant close it cuz i cant deserialize it ;-;
i can try to close it and then reinitialize it right?
what do i do here
But in general you can't really just change around existing fields, becaus yeah, when you try to deserialize the *old* account structure it won't look right according the new struct definition.
You probably don't have enough space in that account
I am getting a ```failed to deserialize account``` error after changing around some fields in the structs. how do i fix this?
It's an annoying implementation detail and anchor is hoping to automate some of it soon.
Each such choice of bump has about a 50/50 chance of working, so `findProgramAddress` may have to try a few different bumps (255, 254, 253...) until it finds something that works.
Briefly: program-derived addresses are sha256 hashes of the seeds + the deriving program's program_id (plus a fixed string, not important‚Äîtry jumping to source to see the exact details). The purpose of the bump is that each sha256 hash happens to have about a 50/50 chance of being an *actual, valid public key*, in the ed25519 cryptographic sense. PDAs are supposed to only be signable by their deriving program, so solana decided to force PDAs to *not* be actual, valid public keys. The trick to make this work is the bump: it's a u8 that starts at 255, and you stick it into the rest of the sha256 hash; if the resulting hash is "off-curve" (meaning, successfully *not* a real public key), then that's the bump; otherwise try bump = 254, etc., until you get lucky and the hash is off-curve.
Have you tried jumping to source on how `findProgramAddress` works?
I have no idea what the bump is and where I might need it. Also I could not find it explained anywhere in the documentation.
    I guess the seed is like an additional value I would pass add to a hash function like hash("1235..ab"+see)=new address .
     ```#[account(
        seeds = [vesting.to_account_info().key.as_ref()],
        bump = vesting.nonce,
    )]```
Ah, yeah, bummer
once i changed that to a hardcoded number it worked
ah ok it seems like the issue is me defining the length in rust as a global const - `weights: [u64; MAX_L],`
That error is coming from the IDL generation phase, not you calling it with JS
What version of anchor are you using? `anchor --version`
any ideas?
im trying to pass a [u64; 5] from js as an argument to an anchor instruction and getting this error:
```
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: ParseIntError { kind: InvalidDigit }', lang/syn/src/idl/mod.rs:153:76
```
ive tried it like this:
```
let s = [new anchor.BN(1), new anchor.BN(1), new anchor.BN(0), new anchor.BN(0), new anchor.BN(0)];
```
as well as a standard int array wrapped with anchor.BN()
Lots of examples of doing this in the anchor tutorials/tests
You would pass that other account into your program and then deserialize its data
Is there a way to perform getParsedProgramAccounts() from within Anchor? I'm trying to check to see if some data already exists in another program-owned account, and avoid creating a new one if the data (a public key), already exists within the account data.
This one also supports sollet web if I'm not mistaken https://github.com/solana-labs/wallet-adapter
https://github.com/project-serum/sol-wallet-adapter
looks like this is the way to go
are there any examples of integrating sollet web wallet with anchor?
heyo
is there a way to use anchor without setting the 'ANCHOR_WALLET` param? eg say i just want to run a js script that pulls data from accounts, but never generates any transactions, therefore doesn't require a wallet. If i try run my script without setting it, it errors out. but if i set it to a new/empty wallet , then it works
Did you ever figure out this issue? Or did you have to just use integers?
There is‚Äîat least for the first deploy. The program_id arg points to the full keypair, not just the public key
Ah, so there's no signing happening with the private key in the target directory?
The `keypair` is what pays for the deployment tx fees (and I think is then the upgrade authority, by default)
Ah, no, the program_id is the next argument, `--program-id`, which comes from `program.keypair_file()`
https://github.dev/project-serum/anchor/blob/9fea72e701813662a4af3733cb14ab713ebfdbef/cli/src/lib.rs#L2131

Looking at that code, it appears the key is pulled from the providers wallet, but the program id is inferred from the file name.    `let keypair = cfg.provider.wallet.to_string();` is what defines the keypair, not the keyfile in the `target` directory.  That seems wrong?
Yup, the private key is needed in order to create the account where the program will be uploaded to (which is it's program id). In order to create any account on solana you need to sign it with the respective private key (the address is the public key basically). That's why it's needed only on the first deploy. After that the upgrades handled by the upgradeable loader program are signed with the upgrade authority.
The implementation of `anchor deploy` (try searching for `fn deploy` in the anchor repo) seems to indeed hardcode the path from inside target
Hmm, I thought there was (you can definitely specify a specific keypair with `solana program deploy`) but maybe not with `anchor deploy`
Hmm.  So if you want a consistent address on devnet/testnet/mainnet you'd need to keep the key then, right?  Is there a way to tell anchor to use an existing key?
So you need the private key in order to do your first deploy, but you actually don't need it subsequently as far as I know (for upgrades a different keypair is used, the program's upgrade authority)
They keypair's public key is your eventual program_id, and its private key is used to create your program's account that lives at that address.
In my program, I want to hardcode different values depending on the cluster. Is there an easy way to get the cluster from the Anchor.toml file?
Running into an issue where I can't use f32 in my rust program, looks like others have similar issues: https://github.com/project-serum/anchor/issues/1353. Any advice?
Solution: Change the name of your smart contract: 
```
#[program]
mod newname {
```
I changed the name of my repo, and now `anchor build`  keeps generating an IDL with the old name of my repo. How do I fix this?


//////////////////////////////////////////////////////////////////////////////////////////

THANK YOU
You nailed it --> System account was labeled mutable, source of the error. Function works now:
Ok. Will check. Does the bump need to exist? I am not creating a PDA, so I wouldn't need a bump seed (to my limited understanding), but I haven't seen an alternative way to do it
The `system_program` itself can't be mut, so you should get rid of that last `#[account(mut)]`
`#[derive(Accounts)]
pub struct SendSol<'info> {
    #[account(mut)]
    pub from: Signer<'info>,
    #[account(mut)]
    pub receiver: AccountInfo<'info>,
    #[account(mut)]
    system_program: Program<'info, System>,
}`
Thank you. Good input. I feel like the accounts are configured correctly:
So you likely forgot to mark an account as `mut` (both the source and the destination of the sol need to be mut)
Lol. I think I see an issue = wrong program ID
0x7d0 = 2000 = https://github.com/project-serum/anchor/blob/master/lang/src/error.rs#L41
`Transaction simulation failed: Error processing Instruction 0: custom program error: 0x7d0`
What ends up going wrong?
Hey there. I have tried to modify this program (https://github.com/Kriptikz/anchor-pda-transfer-sol) to just use the send_sol function to a public key I provide (via my client).
What have you tried doing so far? PDAness won't have any effect on this
Cool, it does seems way simpler indeed ! I'll go with that üôÇ
Anybody know of a simple anchor example that uses a program to collect a fee to a static address (non PDA)?
You can do this
```.js
await program.rpc.yourInstructionThing(arg1, arg2, {
  accounts: {
    ...
  },
  preInstructions: [
     thatSignatureInstruction
  ],
  postInstructions: [ ifYouWant ],
});
```
Think you need to use WSL
how do I install it for windows?
`npm ERR! notsup Unsupported platform for @project-serum/anchor-cli@0.20.1: wanted {"os":"linux","arch":"x64"} (current: {"os":"win32","arch":"x64"})`
getting this error
trying to install anchor
Any example on best practices to do that ? üôè
What is the proper way to build an anchor ix when we want to do multiple ix in the same transaction ?
Currently doing this, but it feels very dirty :

```javascript
    const signatureInstruction = Ed25519Program.createInstructionWithPublicKey({
      instructionIndex: 0,
      message,
      publicKey,
      signature,
    });

    const AnchorInstruction = new TransactionInstruction({
      programId: program._idl.metadata.address,
      keys: [
        { pubkey: payer.publicKey, isSigner: true, isWritable: false },
        { pubkey: SYSVAR_INSTRUCTIONS_PUBKEY, isSigner: false, isWritable: false },
      ],
      data: new anchor.InstructionCoder(program._idl).encode('verify', {}),
    });

    const transaction = new Transaction();
    transaction.add(signatureInstruction, AnchorInstruction);
    
    const test = await provider.connection.sendTransaction(transaction, [payer]);
```
Yeah, in practice it makes the js code easier to read that way
Hello. I'm trying to the below tutorial.
https://project-serum.github.io/anchor/tutorials/tutorial-1.html#defining-a-program


Rust code is the below
```
    pub fn initialize(ctx: Context<Initialize>, data: u64) -> `ProgramResult {
        let my_account = &mut ctx.accounts.my_account;
        my_account.data = data;
        Ok(())
    }
```

And Javascript code is the below
```
await program.rpc.initialize(new anchor.BN(1234), {
  accounts: {
    myAccount: myAccount.publicKey,
    user: provider.wallet.publicKey,
    systemProgram: SystemProgram.programId,
  },
  signers: [myAccount],
});
```

In the Rust code, the context argument is written first, but in the Javascript code, it is last. Is it a rule for anchors that the Context should be written last in javascript?
`anchor test` runs the script specified in your Anchor.toml file (plus some other stuff‚Äîto see that other stuff you'd need to go read the anchor cli source, try searching for `fn test` in the anchor repo)
Think you can just do `*my_account` (so de-reference it)
someone know where can I found the script launched by "anchor test" and other anchor commands ? üôÇ
hey guys i'm trying to run anchor test on my pc keep getting the error below

Running: rustup toolchain list -v

Running: rustup toolchain link bpf /Applications/XAMPP/xamppfiles/htdocs/solana/bin/sdk/bpf/dependencies/bpf-tools/rust

error: not a directory: '/Applications/XAMPP/xamppfiles/htdocs/solana/bin/sdk/bpf/dependencies/bpf-tools/rust/lib'
gotcha! Tysm for the clarification üôÇ
That's correct and that's why the token authority is needed when creating a token account. It specifies who can spend from the account.
My guess is that the token authority has the ability to transfer the tokens, whereas mint authority can supply/mint new tokens, correct me if I'm wrong
is there a difference between mint and token authority? Because it seems like specifying a token authority that doesn't equal the mint authority is totally acceptable
when providing a token mint address in the creation of an account, why is a token authority needed?
Once all accounts are boxed/signers/Unchecked, where to look for in order to reduce `large stack variables`? I'm using 33 accounts <:pepesadHands:904036531277279293>
Yes problem is with the last version of anchor. Need to specify env variable.
`ANCHOR_WALLET=~/.config/solana/id.json yarn run mocha -t 1000000 tests/`
How to use Anchor with wallet-adapter?
that sounds like an issue with the idl
as far as I know, it has an implicit conversion under the hood so you can pass `Account<'info, MyAccount>` into a function that takes a parameter that is type `MyAccount`
anyone know why a String type would show up as ...unknown[] on the client side after being built?
I have a context with a field `pub my_account: Account<'info, MyAccount>`. 

I have a function that takes in `MyAccount`. 
how can I convert `Account<'info, MyAccount>` to `MyAccount`?
<:thonk:895614589562150913>  if i remove the newly added program and run the test, there's no error
oh strange, it seems to be related to me adding a new (4th) program within my project dir
nothing obviously related, hmm
hey frens, `anchor verify` does this work on dev/test nets? the documentation says `To verify a build against a program deployed on mainnet, run ...` and deploying to mainnet is a bit cost prohibitive at the moment
no nothing like that
hmm let me see if i can see what commit caused ci to start failing
Are you doing anything funny in your tests? Like, do they try to do something once the tests finish?
Ha, interesting, never seen that before
im running `anchor test ./tests/faucet.ts`
literally is just that <:what:866983240992292874>

Can you post more of the test output log?
i just see this error after them
the tests run
Unless something odd is happening with how you're installed the anchor cli, maybe (vague memory of this happening to someone else)
sorry maybe that wasnt a good explanation lol
You'll get that same os error if you have `test = "foo"`
Ok, then you need to install `npx`
sadly no
a bash terminal i think?
Oh, did that fix the error?
If you just type `npx` at the terminal, what do you get?
it did say `test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000"`

i updated it to `test = "npx ts-mocha -p ./tsconfig.json -t 1000000"` but no luck
That error isn't really an anchor error, it's your shell saying "I don't know how to run this thing you told me to run"
What does your Anchor.toml file say for its test command?
must be something local i guess
using 0.18.2, im sure i didnt have this a few days back
i think its a new error, ive not changed anything major locally
That usually means you don't have mocha or something installed (might depend on what version of anchor you're using)
`Error: No such file or directory (os error 2)` started to see this after running `anchor test` locally and in CI, any ideas? read previously around ds_store files but ive removed all of them
how do i specify lib.path?
but now getting Failed to obtain package metadata: `cargo metadata` exited with an error: error: failed to parse manifest at `/Users/carlosdelrio/myepicproject/programs/myepicproject/Cargo.toml`

Caused by:
  can't find library `myepicproject`, rename file to `src/lib.rs` or specify lib.path
still trying to run anchor test
Hey guys, updated my OS
`= "x.y.z"` is equal to `= "^x.y.z"`. The `= "=x.y.z"` guarantees that only this exact version will be used. <https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html>
Or does uint have to be in the brackets of `spl-token-lending`?
for this, do u mean just doing:
```
[dependencies]
spl-token-lending = ...
uint = "0.9.1"
...
```
It's not possible: would be, if sysvar supported it. But only from instructions, you can't extract this info. Solana team probably recognized that such feature is not required for any meaningful application, but we might see it implemented in the future, who knows (if there's no security or any other implication).

No, we will probably never see this. What runtime does is that it goes through the raw transaction and prepares the data as an input to the rBPF VM. When you go through the accounts in the program itself via `solana_proram`, what you see is in the account struct is already preprocessed, e.g. signer and writer fields are not part of the instruction or transaction itself, they are smartly encoded in the message header of the raw transaction, which is recognized and added by the runtime before execution.

It'd likely be a big overhead if `solana_program` was meant to bring the raw tx data back to the on-chain program and let you iterate over it. The only sensible thing is maybe to prepare a simple function that would just return the pubkey of the fee payer. But I wonder if it's somehow useful.
Yeah, that's my understanding too‚Äîdon't think instruction sysvar is quite enough info
<@!134416332509675520> it'd be possible, if sysvar provided not just access to instructions (you can introspect other instructions from the tx), but also the transaction itself, then the fee payer would be the first pubkey from the tx account list, if I'm not mistaken. Fee Payer is always the first account, right? https://docs.rs/solana-program/latest/solana_program/sysvar/index.html
would u mind showing the whole block of code?
This is kind of dumb, but seemed to work by just manually specifying a dependency on `uint = "=0.9.1"` in the program's Cargo.toml üôÑ
Yes that was exactly my point. Indeed, I see there is no field for this even in `AccountInfo`. Thanks üôÇ
Sort of the best you can do in general is ask some account to sign the tx, but that doesn't strictly speaking guarantee that they were the fee payer
In general you can't necessarily get access to this info, unfortunately
Yes you are right, mb üôÇ
That would be the pay-er üôÇ
I'm no trying to pay. I want to get from the anchor program the pubkey of the user who paid for the transaction (the payee)
What do you mean? Who are you trying to pay?
Is there an easy way to get payee pubkey in anchor ?
Ok, well, that 1.56.0-dev is coming from how solana install's a special bpf toolchain
Is it possible to get the config public key related to a candy machine v2 when fetching its state?
I think you'll be better reading up the last link and the next page in that doc üòÑ
after verifying?
üòÇ üò≠
Lol, where the fuck is this 1.56.0-dev coming from üòµ‚Äçüí´
`anchor publish` ultimately
https://project-serum.github.io/anchor/getting-started/verification.html#verifying
how do the programs get listed there? anchor build --verifiable?
thx
https://anchor.projectserum.com/
Where can I find verifiable builds on a website? what was the url?
very weird that it's saying that we have the wrong version of rust tho.. idk. whatever
no worries! we tried üò§
Heh, trent does know what he's talking about though, so maybe I'm wrong üòõ
Still fiddling though
Yeah, I don't think that's the problem (I saw your post in the solana discord)
im gonna try some other workaround solutions, instead of using `git` as the parameter
hmmm i think part of the problem is that the outer `Cargo.toml` is a workspace, and not a crate?
Taking a look, can now reproduce that error on one of my own repos
Does anyone have a solution to the rust version problem I mentioned above?
The rust nightly version aren't stable.
Any ideas on how to speed up fetching data? Maybe an API that indexes and saves in redis?
well, you can upgrade it to `1.6.0` with nightly version.
```
rustup toolchain install nightly
rustup default nightly
```


//////////////////////////////////////////////////////////////////////////////////////////

how can I iterate an array of 5000 elements and check if a passed element exists or not in it in anchor ?
Boom üí• 

> % anchor --version
> anchor-cli 0.20.1

Time to have some fun. Thank you! üòä
It looks like that could be it. Trying now. Thanks üôå
maybe you need `libssl-dev` also?
Looks like I have it installed ‚úÖ
> % openssl version
> OpenSSL 1.1.1  11 Sep 2018
How do I determine if openssl is installed?
(I am a Ubuntu noob)
>  run pkg_config fail: "`\"pkg-config\" \"--libs\" \"--cflags\" \"openssl\"` did not exit successfully: exit status: 1\n--- stderr\nPackage openssl was not found in the pkg-config search path.\nPerhaps you should add the directory containing `openssl.pc'\nto the PKG_CONFIG_PATH environment variable\nNo package 'openssl' found\n"
> 
>   --- stderr
>   thread 'main' panicked at '
> 
>   Could not find directory of OpenSSL installation, and this `-sys` crate cannot
>   proceed without this knowledge. If OpenSSL is installed and this crate had
>   trouble finding it,  you can set the `OPENSSL_DIR` environment variable for the
>   compilation process.
> 
>   Make sure you also have the development packages of openssl installed.
>   For example, `libssl-dev` on Ubuntu or `openssl-devel` on Fedora.
> 
>   If you're in a situation where you think the directory *should* be found
>   automatically, please open a bug at https://github.com/sfackler/rust-openssl
>   and include information about your system as well as this message.
> 
>   $HOST = x86_64-unknown-linux-gnu
>   $TARGET = x86_64-unknown-linux-gnu
>   openssl-sys = 0.9.71
> 
>   ', /home/eric/.cargo/registry/src/github.com-1ecc6299db9ec823/openssl-sys-0.9.71/build/find_normal.rs:180:5
>   note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
> warning: build failed, waiting for other jobs to finish...
> error: failed to compile `anchor-cli v0.20.1 (https://github.com/project-serum/anchor?tag=v0.20.1#a81ff88d)`, intermediate artifacts can be found at `/tmp/cargo-installkc2QUt`
When I last did this there was nothing special to do
Hi there üëã 

I'm having some trouble installing on Ubuntu under WSL 2 on Windows 10. Will do a bit of reading of previous issues, but if there is anything special to take care of with this setup, please let me know üôè
btw on the line where you're doing `amount * 1000000000` it's better to use the `LAMPORTS_PER_SOL` constant in order to avoid any errors with the conversion  https://github.com/solana-labs/solana/blob/master/sdk/program/src/native_token.rs#L3
Thanks a bunch! üòÑ
Yea, basically you're implementing an "admin" instruction. What you do is you  load the program's `upgrade_authority` and verify that it has signed the tx. Here's an example https://github.com/project-serum/anchor/blob/master/tests/bpf-upgradeable-state/programs/bpf-upgradeable-state/src/lib.rs#L64. Make sure you do all the constraints correctly.
Hey quick question, is there a way to get the details about the deployed Program itself (i.e. the info you get from the cli `solana program show [PROGRAM_ADDRESS]`) inside of the Anchor program?

Additional context: I have an "Initialize" instruction that needs to be run after deployment, and to be extra safe I want to be sure that this instruction is only run by the same Address that deployed the program.
this is how I did it for a program where the "user" pays an amount to a "receiver"
disregard item1 and item2 which are accounts that increment based on the amount transferred.

Solana Pay might be a better way to transfer SOL between accounts if you can figure out how to use inside an anchor program

```
    pub fn pay(
        ctx: Context<Pay>,
        amount: u64,
    ) -> ProgramResult {
        let item1 = &mut ctx.accounts.item1;
        let item2 = &mut ctx.accounts.item2;
        let user: &Signer = &ctx.accounts.user;
        item1.amount -= amount;
        item2.amount += amount;


        let ix = anchor_lang::solana_program::system_instruction::transfer(
            &ctx.accounts.user.key(),
            &ctx.accounts.receiver.key(),
            amount * 1000000000,
        );
        anchor_lang::solana_program::program::invoke(
            &ix,
            &[
                ctx.accounts.user.to_account_info(),
                ctx.accounts.receiver.to_account_info(),
                ctx.accounts.system_program.to_account_info(),
            ],
        );

        Ok(())
    }


// Pay SOL
#[derive(Accounts)]
#[instruction(amount: u64)]
pub struct Pay<'info> {
    #[account(mut)]
    pub item1: Account<'info, DataAccount>,
    #[account(mut)]
    pub item2: Account<'info, DataAccount>,
    #[account(mut)]
    pub receiver: AccountInfo<'info>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[account]
pub struct DataAccount{
    pub creator: Pubkey,
    pub name: String,
    pub amount: u64,
}

```
The keypair doesn't have authority over upgrading the program. It's needed only to deploy the program the first time (which will also set the upgrade authority).
There was a discussion about this recently here https://discord.com/channels/889577356681945098/889702325231427584/939253575886975026
the `target/deploy` keypair is what im interested in, what is it for, does it have authority over program deployment? if so, it should be kept secret. but then, to keep the code unchanged (due to `declare_id!` requires program id). the keypair needs to  be shared...
Pubkey::from_str(<string>)
how to create pubkey from string
I guess you use this https://github.com/solana-labs/solana/blob/master/sdk/program/src/system_instruction.rs#L390 to create the instruction and call it with CPI
Kind of. It's not really "signing" it but when you're creating a PDA account you need to call the create_account instruction using `invoke_signed` method and provide it the seeds used to generate the PDA. The runtime then checks the seeds and program id of the program you're calling from and if it matches then the instruction is considered to be "signed" by the program.
`token_program: Program<'info, Token>`
When creating a regular account it has to sign the transaction, is there a similar constraint for PDAs?
what's a better way to write this ? ```    #[account(address = anchor_spl::token::ID)]
    pub token_program: AccountInfo<'info>,```
Hey guys, is there any reference on how to transfer SOL to and from accounts using anchor?
its running on the test validator (the first 2 tests run fine, only the last one breaks, not sure why)
Perhaps your test validator isn't running or you're running the test against devnet?
It is possible. If by local dev machines you mean the `solana-test-validator`, it's possible to start it with the `--bpf-program` flag which will pre-add the program at the specified address. The other way to do it is to use the generated program keypair in the `target/deploy` directory.
im using mac m1 btw
(its also not an issue with the tests/program cause on a linux vm the tests run fine, it only breaks on my m1)
<@!851910655334023168> everything is synchronous in Solana programs and CPIs return either `() or ProgramError`. What do you need to read?
<@!134416332509675520> Thanks
Hi, is it possible, or make sense, to make program id consistent across muliple local dev machines as well as mainnet deployment? if not what would be the way to go
Yep, that's fine, `hash.as_bytes()` I think
Hi,
Could we use a string passed as input to derive our pda seed? I mean

```rust
#[derive(Accounts)]
#[instruction(bump: u8, hash: string)]
pub struct Initialize<'info> {
  #[account(
    init_if_needed,
    payer = payer,
    seeds = [
      b"gamba", 
      hash.as_ref() <== is there someworking solution here?
    ],
    bump = bump
  )]
...
}

pub fn handler(ctx: Context<Initialize>, bump: u8, hash: string) -> ProgramResult {
..}
```
Thanks
<@!195345150132748288> did you find a solution to this?
i get this error when running slightly long tests: 
```
Error: Unable to obtain a new blockhash after 10149ms
```
anyone dealt with this before?
what do ppl usually do to get around this? like if I want to validate something about one of the accounts being passed in, I obvs cant make an API call
like would the program being called just write to a 3rd account which then the initial invoking program reads from?
do I understand correctly that I cant actually wait for the return value of a CPI?
any examples of creating a mint owned by the program so it can mint/burn them?
Hi. I'm trying to use ```anchor build``` in subdirectory but I'm getting error ```no such subcommand: `build-bpf```.
Having trouble installing on Mac M1. I'm following this guide: https://github.com/buildspace/buildspace-projects/blob/main/Solana_And_Web3/en/Section_2/Resources/m1_setup.md 

And getting this error: "dyld[26505]: symbol not found in flat namespace '_BIO_free_all'" When running "solana-test-validator --no-bpf-jit" according to the guide
bump for anyone who may have some idea on this, thanks
are there any examples of staking programs built with anchor?
hey fam
I am guessing I can use the under the hood method of the Account<'info, T> wrapper but unsure where it is
how do i deserialize the array of remaining_accounts into my specific account struct?
definitely keep at it
lol promise it looks worse than it is
I‚Äôm over here stuck trying to build an environment looking at your problem like jeez, idk if I ever want your problems lmao
Will having multiple copies of anchor files in my directories be an issue at all?
does anyone have any idea why there might be duplicate of same tx in solana logs?

```

[2022-02-06T22:06:07.281682000Z DEBUG solana_runtime::message_processor::stable_log] Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [1]
[2022-02-06T22:06:07.282005000Z DEBUG solana_runtime::message_processor::stable_log] Program log: Instruction: InitializeMint
[2022-02-06T22:06:07.282131000Z DEBUG solana_runtime::message_processor::stable_log] Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 2279 of 200000 compute units
[2022-02-06T22:06:07.282325000Z DEBUG solana_runtime::message_processor::stable_log] Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success
[2022-02-06T22:06:07.340233000Z DEBUG solana_runtime::message_processor::stable_log] Program Vote111111111111111111111111111111111111111 invoke [1]
[2022-02-06T22:06:07.340433000Z DEBUG solana_runtime::message_processor::stable_log] Program 11111111111111111111111111111111 invoke [1]
[2022-02-06T22:06:07.340540000Z DEBUG solana_runtime::message_processor::stable_log] Program 11111111111111111111111111111111 success
[2022-02-06T22:06:07.341072000Z DEBUG solana_runtime::message_processor::stable_log] Program Vote111111111111111111111111111111111111111 success
[2022-02-06T22:06:07.426774000Z DEBUG solana_runtime::message_processor::stable_log] Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [1]
[2022-02-06T22:06:07.427001000Z DEBUG solana_runtime::message_processor::stable_log] Program log: Instruction: InitializeMint
[2022-02-06T22:06:07.427125000Z DEBUG solana_runtime::message_processor::stable_log] Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 2279 of 200000 compute units
[2022-02-06T22:06:07.427279000Z DEBUG solana_runtime::message_processor::stable_log] Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success
```

as you can see `InitializeMint` appears twice, but I promise I'm calling it once. The timestamps differ perhaps my log filter is misconfigured?
In this case, if you wanted to make this `mut` then you would have to change the type to be at least `AccountInfo` right?
Getting this after anchor test Failed to obtain package metadata: `cargo metadata` exited with an error: error: failed to parse manifest at `/Users/carlosdelrio/myepicproject/programs/myepicproject/Cargo.toml`

Caused by:
  can't find library `myepicproject`, rename file to `src/lib.rs` or specify lib.path
https://docs.rs/rust_decimal/1.21.0/rust_decimal/struct.Decimal.html

Is this safe to use?
need max value of at least `u64::MAX`
how does one do decimals in rust üòÇ


//////////////////////////////////////////////////////////////////////////////////////////

if by create, you mean "is owned by a program", then only that program can transfer lamports out of the account (only a single program can create accounts, the system program). other programs can add lamports to the account though
hi guys! just wanna clarify, if a program creates an account, the lamports in that account cannot be transferred out no matter what right?
thanks ser!
exactly
i see! so should i add another string or u8 to the seed and store that value inside the account struct to differentiate between PDAs?
definitely don't do that
no big footgun
is that a recommended pattern?
cam you have different PDAs initialzied with the same seeds (using different bumps)?
I want to fetch all transactions (ever happened) for a wallet. How should i go about it? Any API/Doc i can refer to?
But yeah, I'm saying that you need to figure out what your program's *actual*, deployed program id is, and use it in both Anchor.toml, IDL, declare_id!, etc. (everywhere)
It's a completely separate account‚Äîin bfriel's tutorial it has a fresh keypair address
The voteAccount is completely separate from the program ID, like no relation whatsoever
what you are saying is the programID has to be the same across the IDL metadata address and the `declare_id!` call, but that this isn't the same as the voteACcount
If it's actually the *same* key, then you messed up how you deployed it, maybe
Right, I'm saying you'll need to run `anchor keys list`, it's likely a different key
ah nvm
If you follow the code snippets, you can see that: `const programID = new PublicKey(idl.metadata.address);` and `metadata": {
    "address": "7Ntd1GePKvSSYseiHqdk88k3mRLaQrMxmGnnoVpn8QQd"
  }`.  Additionally, in lib.rs they have `declare_id!("7Ntd1GePKvSSYseiHqdk88k3mRLaQrMxmGnnoVpn8QQd");`
The programID etc. is not the same thing as the voteAccount, or am I misunderstanding your question?
Ah, I think yo're confused about the difference between the actual program itself vs the voteAccount (two totally different accounts)
is this group appropiate for substrate devs?
Try doing `anchor keys list`
so here the programID being used is the same as the voteAccount
and https://github.com/bfriel/crunchy-vs-smooth/blob/master/app/src/utils/index.js, notably `export const programID = new PublicKey(idl.metadata.address);`
Ok, so when you did `anchor deploy` (if you did) it printed out a program id
https://github.com/bfriel/crunchy-vs-smooth/blob/master/tests/crunchy-vs-smooth.js#L11 is using a fresh keypair for the voteAccount
https://github.com/bfriel/crunchy-vs-smooth/blob/master/app/src/idl.json#L68 notably `"metadata": {
    "address": "7Ntd1GePKvSSYseiHqdk88k3mRLaQrMxmGnnoVpn8QQd"
  }`
Ok, cool. So how did you end up using that same exact id for the voteAccount?
https://github.com/bfriel/crunchy-vs-smooth/blob/master/programs/crunchy-vs-smooth/src/lib.rs#L3 notably `declare_id!("7Ntd1GePKvSSYseiHqdk88k3mRLaQrMxmGnnoVpn8QQd");`
I'm saying that that error above is coming from you accidentally trying to talk to the wrong program id (or maybe the right program id, but you didn't deploy it correctly, etc.)
Ah I see - so I think the solution would be to use a PDA derived from program 1 as the explicit Signer<> account in the CPI call to program 2, add this PDA to the allowed list of callers to program 2, and probably also transfer the requisite lamports needed from the user to the PDA in order to pay for the account created by the program 2 CPI instruction... Thanks for your help!
Sure, but I'm unclear why they would end up having the same address (they definitely shouldn't)
We've already created/deployed the program (which is what we've deployed). The vote account is supposed to be the data store.
Mm, they shouldn't be the same‚Äîcan you point me to where they end up being the same in the tutorial?
To clarify, my question here is: why is the voteAccount public key is the same as the deployed program id? Shouldn't these be separate things?
So you actually don't need to do anything to have that user signature also work for the CPI.
Also, note that if the user signed the tx from their client, then that signature carries over across CPIs!
Yep, this is what PDAs are for: they are funny addresses that can *only* be signed for by their deriving program.
That means you're not using the right program id somehow‚Äîif you're deploying your anchor program, you might need to check what its actual program_id is (as printed by the deploy) and stick it in your Anchor.toml + declare_id!, etc.
follow up question - can a program sign a CPI instruction? say if I had a user call program 1, but program 1 needs to make a CPI call to program 2, which has an allowed list of callers and will initialise a new account, the user can't sign that instruction, but can program 1? so far it looks like the answer is no but I'm struggling to reason why
I went through brian friel's crunchy vs smooth anchor guide. For those who haven't seen it would highly recommend. Had a follow up question that I posted as a reply to his tweet https://twitter.com/0xjayepeg/status/1491067386778521601 - would love some input here from you guys <@!501570363566587905> and anyone else who's an expert here!
OK
Anyone know about NFT merging and unmerging?
After the program invocation fetch the account and read the account content
Thanks got it)
haha no worries! I thought it was a good question
something like 

```
#[account]
pub struct UlyanaTokenAccount {
  pub token_acc: Pubkey,
  pub my_field: u8,
  ...
}
```
I would highly recommend that approach
You can create a new account that has a `pubkey` link to the original token account, as well as the new field you want
yeah, but I want to create another one, something like TokenAccount struct with pre-allocated extra space for extra field.
Yeah it does - I've since worked out that I was being a dummy and that the signer/payer of the first call looks like they do indeed pay for the CPI calls - I was testing locally and forgot to airdrop ü•≤
Does the CPI call create a new account or something?
you cannot do that, since the TokenAccount is owned by the TokenProgram
read the docs on the website, they explain that
Hey guys! Maybe someone knows how to extend TokenAccount with an additional field or is it even possible?
Who pays for a CPI call? I'm trying to get program 1 to call an instruction in program 2 but I'm getting an insufficient lamports error. How can I get the original caller of program 1 to pay for the CPI call, or have I fundamentally misunderstood something?
Here's some resources for you
- https://pencilflip.medium.com/solanas-token-program-explained-de0ddce29714
- https://paulx.dev/blog/2021/01/14/programming-on-solana-an-introduction/#the-token-program-part-1
You can check the anchor repo -> tests -> ido-pool example
Bear for more questions. Coming from Eth/terra background, trying to make sense of Solana's development model.
This is to be done on client side or backend? Can you guide to an example?
you need to set the mint's owner (mint authority) to a program derived address
How to create a token whose mint is Solana program?
i hv question, what does anchor js really do ?
hello
any simple anchor examples
how to mint NFT programmatically
Thanks got it.
this is because the `number` type in js can only store up to 53 bits, but the number you have is larger than that. There's no way to convert it to number. Use the BN  to do your calculations.
Is it possible to get  txns of a particular RPC call ? like I have a update method I want to know the txns involved with that method. I know txns are related with accounts but is there any way to filter account txn for a particular RPC method call ?
any resources related to the above, solana vanilla or anchor either thing works.
which then can be displayed on phantom
so i have an idea of how nfts work in the theoretical sens but wanted to do it from scratch to understand it better is there any existing tutorial which makes an nft form scratch i.e make a spl token mint, attach spl-metadata to it, store it in arweave and mint its token
tried `BN.toNumber()` but got an erorr `Uncaught Error: Number can only safely store up to 53 bits`
Hey how can I convert BN to number in js
hey guys, i ran into this error while trying to run some anchor code, what's the meaning of this error ?
```
Error: Program's authority Some(JEETbGbfaqfvTdzGYLLtxTMkmrR2bHPH9oDWbme5Xj3L) does not match authority provided AYCBZSFpvef3FjQjk7Sk56whMC2mU4hzYQaxnHWZ5TQM
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.
```
I did
You don't have `mocha` installed
Hi. I'm trying to deploy after ```anchor build``` but error came up ```Failed to run test: mocha -t 1000000 tests/: No such file or directory (os error 2)```.  It looks like OS issue. I'm using Mac M1 now. what cause this error?
got it - some extra lines of code in there related to anchor doing all the verifying accounts and other checks that I probably wouldn't think of on my own
Your program is almost certainly several hundred kbs.
To keep a number in mind, rent-exemption + the 2xing means it costs about 1.4 sol / 100kb to deploy.
Yep, it's for rent-exempting your `.so` file. The default deploy command also 2x's the storage so you can upgrade your program later.
ok, thanks - is that because of the program storage requirements? I just did `solana rent 250000` on devnet and got 1.7 sol - so the anchor program is approximately 250kb?
Should some of those be Saved in the programs folder?
Mm, you don't have any programs at all in your `programs/` directory (that won't work‚Äîdid you delete the default one?)
Unfortunately deploying actually takes a lot of sol
You can ignore the messages (somebody forgot to get rid of a log line in the solana cli tool, lol)
Can I subscribe to a random account's changes on the Solana blockchain?
this seems like a lot to deploy the basic 3 program to devnet - is this right? 
`Error: Account xxxx has insufficient funds for spend (1.80334296 SOL) + fee (0.001295 SOL)`
It is also printing a ton of msg s with the same id

Now do that inside `programs` (or type `ls -la programs/`)

That was cool 
What is ls -la
~sounds like it's bonking because it can't find `myepicproject` in `programs/`. what do you get if you `ls -la programs`~  scratch that - actually maybe an error in `myepicproject/Cargo.toml`
Carloss-MBP:myepicproject carlosdelrio$ anchor test
Failed to obtain package metadata: `cargo metadata` exited with an error: error: failed to parse manifest at `/Users/carlosdelrio/myepicproject/programs/myepicproject/Cargo.toml`

Caused by:
  can't find library `myepicproject`, rename file to `src/lib.rs` or specify lib.path
I have a feeling its something to do with the way i saved all these files on my mac but i keep getting this
I'm just starting myself, but what seems to be the problem?
HIIII EVERYONE, I AM A DETERMINED FELLOW JUST LOOKING FOR SOME HELP... ITS GOTTEN DESPERATE SO IM WILLING TO PAY! $20 TO THE PERSON WHO CAN HELP ME RUN                       anchor test
And then once all the programs have been deployed together with the deploy command are programs then upgraded individually, passing the program id and file path?
Is it build, then calc the pubkey string from the keypair.json in deploy and update the `declare_id!` macro and `[programs.localnet]`?
my version says 0.20.1. the init and new commands create Cargo.toml's with editions of 2018 and `declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");`
Could I trouble someone for a link on best practice for program ids?
The instruction module generation is here https://github.com/project-serum/anchor/blob/master/lang/syn/src/codegen/program/instruction.rs
1. https://github.com/project-serum/anchor/blob/master/lang/syn/src/codegen/program/accounts.rs
2. https://github.com/project-serum/anchor/blob/master/lang/syn/src/codegen/accounts/__client_accounts.rs
Then the `#[program]` module aggregates all the various derive macro by re-exporting the types inside the private derive modules
First all the derive macros create a private module and type.
The accounts module is a bit tricky.
what's a good way to debug a struct not de-serializing correctly in the frontend? building off the tic-tac-toe example in the Anchor book and I tested everything on the backend but when I sent the board struct back to the frontend it fills in the same slot on the board no matter what {row, col} input is chosen
Speaking of, where in the Anchor repo is the code that generates those modules?
fucking legend. Just realized the packages are there and the code builds, but VS code just doesn't recognize the generated modules. Is there an extension needed to resolve those warnings?
those modules are created by the macro
run cargo doc to see them
Running 0.20.1
There's the comment which says `// The accounts and instructions modules are generated by the framework.` but I don't see those for my program crate. Is there something special to do to enable these modules?
anyone know what to use in `findProgramAddress` in js to match a `&[u8; 30]` in pda seeds in rust? tried variations on Buffer.from(), Uint8Array.from(), etc but keep getting either `signer privilege escalated` or `seeds do not match`
see the example here https://github.com/project-serum/anchor/tree/master/client/example
kind of, though not exactly the same
Does anchor auto-generate a Rust client similar to the TS client?
üò¢
Exactly
You can do that also but then you dont have mint authority which can be annoying
to use for testing
but then we wouldn't be able to mint other ppls tokens lol
thanks, or maybe even pick some random tokens that ppl already created
Yea, thats what I do.
how do ppl usually test programs in devnet that have dependencies on Token program and other programs? any best practices or do you create dummy tokens to use and pretend like, this is USDC and this is SRM
you can do it in js, just add both instructions to the same tx.
would that be possible if youre allocating the mint space in js and then calling initialize_mint from rust, or would both have to be in rust?
i read in the source file for initialize_mint that you need to create the account and turn it into a mint in the same transaction for security reasons?
oh ok makes sense - i just switched to init'ing the mint in the context in the meantime
So you can't pass in a totally fresh keypair
Ah, the error you're getting now though is that you actually have to allocate the mint's space ahead of this instruction.
It was added to the repo six months ago though, so I figured it would already be deployed
Hmm, interesting. Maybe the version of the spl token program that's deployed doesn't support the mint2 instruction?
the token program is the token program, same with rent sysvar, the mint is a pubkey from a fresh keypair, and the mint_authority is a pda owned by my program
switching to initialize_mint instead of initialize_mint2 now gets me ```Program log: Instruction: InitializeMint
    Program log: Error: InvalidAccountData```
Interesting, not sure why that wouldn't work‚Äîwhat you have their looks pretty reasonable to me
Looking at IDO pool code why do we need to have a redeemable_mint. can't we keep track of contribution of user USDC on a PDA  and then calculate final price based on that?
the `mint` im passing in from ts is just a fresh keypair
does anything seem wrong with this call? im getting 
```Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [2]
    Program log: Error: Invalid instruction```
Ok that‚Äôs interesting, thanks. In theory that means even if the program decrypted it would write unencrypted for anyone to read on said new account
So the way you can "return" something to the client is by having the client pass in a "return account" where the program should write its answer/return value to.
It can compute on data read from accounts, but all it can do is then write that computation back out into some other account
I‚Äôd have to build a custom wallet to expose encrypting using a wallets private keys which seems like an adoption barrier. Jabber seems to have done just that for the encrypted messaging.
so it can‚Äôt actually compute on data read from accounts?
You mean your solana program itself? Your solana program itself actually can't even really "return" anything at all‚Äîall it can do is read/write to accounts.
I‚Äôm trying to efficiently store encrypted string data on accounts (so much secret). Any possibly that programs can encrypt/decrypt data stored on accounts using the program‚Äôs keys and return unencrypted strings to user? I know data is then travelling unencrypted on the final leg but at least it‚Äôs still encrypted on the accounts. The popular wallets don‚Äôt expose a decrypt feature and I don‚Äôt want to store a second set of keys somewhere centralised!
ahhh interesting
Its because the token program will try to mutate the accs and the runtime wont allow it
It will compile but the cpi call will fail when you call the instruction
The program seems to compile even when I don't have `mut` though
Yes
**Question**: Say I have a Context with `mint` and `user_account`. I want to mint tokens to `user_account`. This would change mint's supply and user_account.amount

```
let mint = &??? ctx.accounts.mint
let user_account = &??? ctx.accounts.user_account

mint_to(..., mint, user_account)
```

Do I need to make these variables `mut`, because they're changing?
most of that uses rust. user the `iter()` function to iterate in an array


//////////////////////////////////////////////////////////////////////////////////////////

you only pay for space the first time you deploy
you don't
i'm not sure about that one
that's cool - then in either upgrade or deploy if it's been deployed before and you haven't changed the id, you don't incur cost for more space?
When you deploy again, you're essentially upgrading the on-chain program (same program ID). If you create a new account for the program, you'll deploy it to a different address (and the original one will stay unmodified on the blockchain)
what happens if you deploy again vs upgrade? re-use the existing account vs. creating a new one?
Don't think there's really a "right" way of doing things unfortunately. You just need to think carefully about what you're worried about, and remove/reduce that worry by checking things with your tests.
If I were to test every part of my program, it would take ~200 tests. For example, checking the signer actually signed the txn for each instruction, checking if they own the account, etc. My program will have 30+ instructions. The tests would take probably 10 minutes to complete on devnet. 

Is this the right way of doing it? Or am I missing something
Steps on ids: https://book.anchor-lang.com/chapter_3/milestone_project_tic-tac-toe.html#deployment
<@!134416332509675520>  I got it! Basically, I needed to mark the accounts with `'info` , instead of `'a` because they have different lifetimes üëç 

Old: 
```
pub fn solend_deposit<'a, 'b, 'c>(
    account1: AccountInfo<'a>
    account2: AccountInfo<'a>
    signer_seeds: &'a [&'b [&'c [u8]]],
) -> ProgramResult {
```

New:
```
pub fn solend_deposit<'a, 'b, 'c, 'info>(
    account1: AccountInfo<'info>
    account2: AccountInfo<'info>
    signer_seeds: &'a [&'b [&'c [u8]]],
) -> ProgramResult {
```
Thanks!
Yep, using `findProgramAddress` with those same seeds will find the same address
Ahh that did the trick, thanks!
‚Ä¶ so am I right that I‚Äôll get a correct map and can just find pda from the same combination of seeds?
Hey guys, is it correct? I want my PDA seed to be a combination of mint and user pubkeys

seeds=[user_token_account.key().as_ref(), user_token_account.mint.as_ref()]
Ok, now try this trick: https://discord.com/channels/889577356681945098/889584618372734977/938777998377766913
(But yes it seemed to have solved the type problem)
then I get a lifetime mismatch error:

```
// call solend deposit
solend_deposit(
    ...,
    pool.to_account_info(), <- error
    ...
    &[&[
        "pool".as_bytes(), 
         vault_info.mint.as_ref(), 
         vault_info.vault_creator.as_ref(),
         &[vault_info.pool.bump]
   ]]
)
```

The error is: `lifetime mismatch ...but data from ctx flows into ctx here`
What if you try inlining that variable (don't give it a name, just inline the expression right into the function call)
Hey alan, not sure if my last message got drowned
That would be in here: https://github.com/project-serum/anchor/blob/master/lang/syn/src/codegen/accounts/constraints.rs#L566
not just bump but other expr in the account macro
The issue is that in general many other choices of bump could be combined with those seeds and result in a valid program-derived address, but that's super confusing since everyone just uses `find_program_address`
where can i see the macro implementations if i wanna see how these constraints work under the hood.
Yep, it just uses `find_program_address` and uses that bump.
kinda confused by this statement "Checks that given account is a PDA derived from the currently executing program, the seeds, and if provided, the bump. If not provided, anchor uses the canonical bump." kinda confused how is this achieved under the hood my understanding is that anchor calls find program address with the executing program id and the seeds passed just to calculate the canonical bump ? or does it just use 255 ?
```
let signer_seeds = &[&[
            "acd".as_bytes(), 
            my_account.mint.as_ref(), 
            my_account.pool.as_ref(),
            &[my_account.pool.bump]
        ]];
```

I'm trying to pass that into my function

```
pub fn solend_deposit<'a, 'b, 'c>(
    ...
    signer_seeds: &'a [&'b [&'c [u8]]],
) -> ProgramResult {
```

But I get an error:
```mismatched types
expected reference `&[&[&[u8]]]`
   found reference `&[&[&[u8]; 4]; 1]```
i am stuck
hi alan
You need to also do `use anchor_lang::AccountsClose;` (not totally sure why that isn't part of the prelude)
you could reimplement https://github.com/project-serum/anchor/blob/master/lang/src/common.rs (since it doesn't appear to be exported in the crate) so call conditionally on the target account
Is there any way to conditionally close a PDA within an instruction? I know I can mark an account to be closed in an instruction's Context struct but as far as I can tell that will always close the PDA at the end of the instruction. Is there some way to instead conditionally call `close()` in my instruction handling logic?

I see there is a `close()` method on my PDA account, but when I try to call it in my instruction logic I get a build error
```
No method named `close` found for struct `anchor_lang::prelude::Account<'_, MyTestPDA>` in the current scope
```
according to solana docs, we can use `msg!` and others to print debug messages but how do I see it? it's not in validator.log
Quick general q about PDAs, when would I want to create a PDA based off of an account? In other words more specifically, when would I want to create a PDA from an account so that the PDA signs transactions instead of the Program? 

I‚Äôm trying to understand the need for a PDA to be created to sign for transactions.
I had the same problem. Try deleting the folder that contains the local validator
I'm testing it on local validator it giving me 1 month old time.
It give you current timestamp in unix_formate
does it gave us the unix epoch time?
`&id`
you can use `crate::id()` i believe
Clock::get()?.unix_timestamp
How do we get current time in unix in program?
any way to get the current program id? it's declared using `declare_id()` but can't figure out where it is saved
If you mean from an on chain program, that is a no. Every solana program needs to be passed all the accounts it needs for an instruction when it is called
Is there a way to run the anchor account rpc calls from the anchor app itself?
Aka in my anchors business logic I want to run program.accounts.fetch() or program.account.track() etc
Im not completely sure what i did... i didnt know i had to direct the terminal first where to store files when installing
how do you decide whether to choose u128, u192 or u256? not sure what are best practices in defi projects
Oh i see this..
`Error: Function _ZN15foo9__private8__global7deposit17h7f99f1ed05ea4cd4E Stack offset of -4512 exceeded max offset of -4096 by 416 bytes, please minimize large stack variables` sneaky
Hi team, I was running into this error: 
`    Program failed to complete: Access violation in stack frame 3 at address 0x200003e60 of size 8 by instruction #13358`

I searched discord and found someone mention to `Box` my `Account` and yay this worked! I am curious as to why it worked though? What is the point of Box? Thanks
Is there another creative way to validate that a past transaction has happened, from within a program?
Transaction includes a Token Transfer and a Memo
Nope, you'd have to find some other way to pass it into your program (as ix data, store it in an account, etc.)
Is there a way to read (past) transaction data from within a program?
you rock btw, your token studies repo has been a god send lately
sounds good, i'll play around with it
Mmmm I think so... I don't remember exactly how anchor "linearizes" the constraint stuff to be honest ü§î
in regards to this, do members of the context struct run in order?
for instance, if i do
```
#[derive(Accounts)]
pub struct SomeContext<'info> {
  #[account(
    constraint = if_this_fails_then_i_know_xyz_init_will_fail 
      @ErrorCode::AlreadyExists,
  )]
  pub something: AccountInfo<'info>,
  #[account(init, ...)]
  pub xyz: Account<'info, Xyz>,
}```
can i trigger my own error?
Well, you can sort of hack your way into a nicer error message‚Äîyou'd have to find some way to get some code to run before the `init` part (but really it's easier to just check if the account already exists on the client ü§∑‚Äç‚ôÇÔ∏è)
<@!669837238816735242> ^
Definitely surprising.
Alas, no‚Äîwhen a CPI fails in solana it straight up fails your whole program, you don't get a chance to recover from it :/
is it possible to return your own custom program error inside of the account init macro?

current scenario is```
Allocate: account Address { address: 7U2RJS24w9i9b845v8xRAfpqnGsJTj64p44CkvCgsVKH, base: None } already in use
    Program 11111111111111111111111111111111 failed: custom program error: 0x0
    Program 8QeSzG8ueV5JpztDfkJaPn63VdFSvo5DcckfRgahjWZR consumed 17198 of 200000 compute units
    Program 8QeSzG8ueV5JpztDfkJaPn63VdFSvo5DcckfRgahjWZR failed: custom program error: 0x0
``` but the error msg returned is `undefined` and the error message is `custom program error`. Can i make this return something like `account collision occurred on xyz account init`?
Would you recommend a similar way that  SPL-Token uses AccountLayout?
bingo! you are awesome. Makes sense now
Ok now how would you recommend reading in the bytes I get from getAccountInfo in order to be able to like index my array and get the data I need?
let me see
ty sir
Yep
lewt me try
didnt know i needed to isntall this for this step
oh is it the solana tool?
Sounds like you don't have your solana install set up correctly
anyone know why the build action isnt working
I hope soüôè  one second
If you fetch the account with `program.provider.connection.getAccountInfo`, does the data look ok? (It'll be just bytes)
Ah, ok, I don't think `program.account.accountLoader` will work correctly here, since it expects the account to use borsh as far as I know‚Äîand kind of the point of AccountLoader is that it doesn't use borsh
The reason I am using an account loader in the first place is because I want to store a dynamic amount of data which I can do by filling in a certain sized array stored within the account loader struct. So for example, if my AccountLoader has 3 fields, one that holds a public key, one that holds a number, and one that holds an array of custom structs of size 100. Let's say that AccountLoader and struct looks something like...

```#[account(zero_copy)]
pub struct AccountLoader {
    pub number: u64,
    pub pubkey: Pubkey 
    pub structs: [Struct; 100], 
}

#[zero_copy]
#[derive(Default)]
pub struct Struct {
    pub data: u32,
    pub more_data: Pubkey, 
}```

When I set the data fields for the AccountLoader in an instruction that ARE NOT a part of the array of custom structs, I have no problems and can fetch the correct data. However, when I set lets say the 0th index of the array to 
Struct {
    data = 5
    more_data = Account.PublicKey
} 
in an instruction and then try to fetch the updated array with...

```const fetchedAccountData = (await program.account.accountLoader.fetch(
      publicKey
    )) as AccountLoaderInterface;
console.log(fetchedAccountData.structs)```

data values across the entire array seemed to be changed unpredictably as if the data I fetched was contaminated. Checking to see that the data at the 0th index was what I expected with msg!() on chain yield the correct values. What am I missing?
So, not via borsh
In what way does the data look weird? The way AccountLoader works is that it stores your rust struct "as-is" in the data
Hello guys, is it possible to safely fetch account data for an AccountLoader type Account? The data off chain that I get is completely unexpected while on chain the data seems to be perfect fine. Any known reason for this?
Hello there! Is there a way to receive the contents of a signed message from the frontend in the Rust program?
i see, gotcha!


//////////////////////////////////////////////////////////////////////////////////////////

=======
>>>>>>> 20bea11087240cc616c020a0810cf4b960b99b41
