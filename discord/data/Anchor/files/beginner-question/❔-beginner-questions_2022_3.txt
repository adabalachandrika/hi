ok, so I have redeployed to mainnet several times with different ID after closing, and gone back and re-tested dev. One of my accounts seems to be owned by another program (I am inferring that because I have an instruction that initialises an account that *does* work - its a later instruction with a bunch of other accounts that fails)

could there be any differences between the macro that checks `account is owned by a different program` in dev/main ? 

is there any way to diagnose which account ? technically a bunch of my accounts can be owned by another program so I dont know why this isnt failing over all of them (unless it is and it just doesnt check in dev)
is there a minimum swap amount for the token-swap program? I am seeing this error:
```
Given pool token amount results in zero trading tokens
```

If I raise the amount_in and minimum_amount_out variables i dont see this error anymore, but just being an end user on Orca for example I can trade small amounts without issue
Have there been other reports of this?  Is this a network thing, or perhaps a solana version thing?
I got this error deploying todevnet about 2/3 of the time.  Today i get it every time.  `Error: Custom: Invalid blockhash
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.`
ahh got it
Not if you let it spin up a validator for you‚Äîit uses a "genesis block" trick to skip an actual deploy
doesn‚Äôt anchor test go through an anchor deploy though?
ok thanks!
idk wth I did anymore... thanks tho! Mistakes kinda costly lol
(And maybe rerun `anchor build` and then redeploy just to make sure)
Make sure your `declare_id!` matches the actual runtime program_id
You may have accidentally deleted the old one
hmm.. ok... the keypair.json in the deploy directory does have a different publicKey compared to the deployed program. Will that cause an issue ? 

also confused as to how that file can be different to the deployed program
At any rate, I don't know what's wrong with your anchor test spinup process, sorry!
Ah, yeah‚Äîdeploy only makes sense with respect to a running validator
i have to run a local test validator to deploy
```
Error: RPC request error: cluster version query failed: error sending request for url (http://0.0.0.0:8899/): error trying to connect: tcp connect error: Connection refused (os error 61)
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.
```
is there any other cause of the owned by different program issue ? can I debug the account that is owned incorrectly pls ?
anchor deploy is also now failing so perhaps it is related
yep! tried that, but the same problem occurs
I half deployed using anchor, but it took too long, so I had to switch to a different RPC and finish using solana program deploy...
Hi, am running into `The given account is owned by a different program`

reading the posts it generally relates to delcareId being different in the lib compared to what was deployed.

however I can see DrKZW91WAfgc1f6R3WNLj7UbwnfuJmii8PFtAucooqfh in the file. This is the same as the command line reported when deploying the program.
ok here's what i realize:

When running **anchor test ** my IDL file is populated (or repopulated with) the address metadata upon successful deployment (see image)

When running **anchor test --skip-deploy** those lines in the IDL on the address metadata **immediately disappear**, and although the program instructions seem to run successfully on devnet (CLI output seems ok and sol explorer instruction transactions have no error), the CLI outputs the last line as: `Error: Program address not found.`
Can you just get rid of all of the clones, just to narrow things down?

What does your `.anchor/test-ledger/validator.log` look like? (It might be too big to post)
still getting `Unable to get recent blockhash. Test validator does not look started. Check .anchor/test-ledger/test-ledger-log.txt for errors. Consider increasing [test.startup_wait] in Anchor.toml.`
yep! trying now
Can you try nuking your `.anchor` directory?
Unable to get recent blockhash. Test validator does not look started. Check .anchor/test-ledger/test-ledger-log.txt for errors. Consider increasing [test.startup_wait] in Anchor.toml.
it does look that way, but the validator still does not start
That sort of looks like it worked
What's the actual error message though?
(Debugging tip is to have a checkout of the solana codebase, searching it for `Failed to fetch {}` found that error
I removed a couple, but even so the test validator doesen't seem to start AND has no errors

```
[2022-03-01T16:12:43.456515000Z WARN  solana_perf] CUDA is disabled
[2022-03-01T16:12:43.478490000Z INFO  solana_faucet::faucet] Faucet started. Listening on: 0.0.0.0:9900
[2022-03-01T16:12:43.478513000Z INFO  solana_faucet::faucet] Faucet account address: AdTuv39i8piRGiSGMZpBdN1Faxxt17TuQKMy84nz5cb6
[2022-03-01T16:12:43.481265000Z INFO  solana_core::test_validator] Fetching Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB over RPC...
[2022-03-01T16:12:45.510993000Z INFO  solana_core::test_validator] Fetching EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v over RPC...
[2022-03-01T16:12:45.754411000Z INFO  solana_core::test_validator] Fetching 4bcFeLv4nydFrsZqV5CgwCVrPhkQKsXtzfy2KyMz7ozM over RPC...
[2022-03-01T16:12:46.008505000Z INFO  solana_core::test_validator] Fetching Amig8TisuLpzun8XyGfC5HJHHGUQEscjLgoTWsCCKihg over RPC...
[2022-03-01T16:12:46.257889000Z INFO  solana_core::test_validator] Fetching gLhY2arqFpmVGkpbBbTi3TeWbsWevA8dqrwbKacK3vJ over RPC...
[2022-03-01T16:12:46.513823000Z INFO  solana_core::test_validator] Fetching VMc13PVs9GBhL1hxXeF33XtaKVMjg8YyMMszGawFPS2 over RPC...
[2022-03-01T16:12:46.783379000Z INFO  solana_ledger::blockstore] Maximum open file descriptors: 500000
[2022-03-01T16:12:46.783442000Z INFO  solana_ledger::blockstore] Opening database at ".anchor/test-ledger/rocksdb"
[2022-03-01T16:12:47.071578000Z INFO  solana_ledger::blockstore] ".anchor/test-ledger/rocksdb" open took 288ms
```
You might have a busted account address in there
So maybe just comment out your `Anchor.toml`'s clone section
Ah, that error is coming from failing to clone some accounts
BUQDUjPtzSV2oznkWqn4BM71rsYSNMBuc7NCtEgL9RzQ
Hmm, what does `solana address` say for you?
at the very end
```[2022-03-01T16:07:32.254140000Z ERROR solana_core::test_validator] Failed to fetch BJb1uP68pEuvRojzM61JR49pNSodihorVk6TosVMsr74: AccountNotFound: pubkey=BJb1uP68pEuvRojzM61JR49pNSodihorVk6TosVMsr74```
pointed me to the validator log which says
Have you also read that test-ledger-log?
yea getting the same error even with a longer wait
right?
[test]
startup_wait = 100000
do i need to change a field in the toml for it to take longer to wait?
everytime i've changing the wait, it still doesn't load but I can try again
Did you try that test.startup_wait trick?
it does when i do so manually, but if i turn off the validator and then run anchor test i get `Unable to get recent blockhash. Test validator does not look started. Check .anchor/test-ledger/test-ledger-log.txt for errors. Consider increasing [test.startup_wait] in Anchor.toml.`
What happens if you turn off that validator then?
You can run `solana-test-validator` and see if it starts
to clarify, `anchor test` works fine as long as I have a `solana-test-validator` in  separate window
pretty sure yeah, my test instructions are appearing on sol explorer devnet, no errors seen on the instructions
weird, is there anyway I can check its installed correctly or incorreclty?
Solana works fine on M1 assuming you've installed it correctly (I use an M1 and anchor test spins a validator up just fine)
Are you sure you're running against devnet?
when doing this my test runs fine though, but the end of it it outputs an error line:
`Error: Program address not found.`
how can I get `anchor test` to spin up a local validator as it runs on an m1?
awesome thanks!
`anchor test --skip-deploy`
Is there a way to stop "anchor test" from redeploying the program when testing on devnet?
Ah ok, i understand now! Thanks
So you'll submit one big tx from the client, with at least two instructions: the secp256k1 instruction, plus your own program's instruction.
No (this is the irritating part) you'll have to issue that call as a separate instruction, from the client, and then within your own program you'll have to use instruction inspection to verify that the client really did submit that verification instruction.
By making verify signature call to secp256k1 program from my program?
Yeah (or at least I haven't heard anything about it not working)
also, does anchor 0.20 work with solana 1.9?
Cool, thanks üëç
You can verify on-chain, it's just ergonomically super irritating (that link explains how to do it on-chain using instruction inspection https://docs.solana.com/implemented-proposals/instruction_introspection)
In general you can see a bunch of other ones by searching the anchor repo for `#[account(zero)]`
The multisig test has an example: https://github.com/project-serum/anchor/blob/master/tests/multisig/tests/multisig.js#L32
Any examples on this?
Agh, according to this discussion, I don't think I can verify signature on-chain
https://discord.com/channels/428295358100013066/517163444747894795/943150095040405525
running 1.8 on devnet is flaky already, so i guess would be good to wait until mainnet also upgrades before deploying any programs on mainnet
hey guys, any idea when solana 1.9 comes to mainnet?
Thankyou sir. Ofcourse you had 8 in there as the previous example was a u64. This has been a good exercise in organising the order of bytes lol üòÖ
Thank you!
Perhaps this will be useful to you. I myself briefly got acquainted with this material when I studied the attack on Wormhole
https://docs.solana.com/ru/developing/runtime-facilities/programs#secp256k1-program
Is it possible to use Ed25519 or Secp256k1 crate in anchor/solana program? I want to verify a message signature on-chain.
`.clone()` is pretty much always just a "fuck it‚Äîgive me a break rust!" They're never really done for "interesting" reasons, just to make rust happy
after `anchor build` keypair is generated for the contract then 
`solana address --keypair ./target/deploy/anchor_escrow-keypair.json`
Thanks a lot for your advice! Yes, indeed, when serialized, it does not preserve the capacity of the vector (only the length + the data itself). Indeed, he makes the most simple steps.
Update: Solution was using "msg!("{:?}", string)" to print non-unicode chars such as null chars and used ".trim_matches(char::from(0));" to remove the null chars.
```let nft_type: &str = &*full_metadata_clone.data.name;

        msg!("{}", nft_type);
        msg!("{}", bronze_name);

        print_type_of(&bronze_name);
        print_type_of(&nft_type);

        if bronze_name == nft_type {
            new_uri.push_str("link");
            new_name.push_str("Silver Flathead");
        } else if silver_name == nft_type {
            new_uri.push_str("link");
            new_name.push_str("Unknown Legendary");
        } else {
            msg!("else hey");
        }
```  Why would this **if statement comparison not be working!**  Both bronze_name and nft_type types are &str and also logged as the same value. Seems to be logging "else hey" so i know the **if is returning false for some weird reason.** Thx for the help
it depends what you want to do
quarry protocol is in prod and much simpler for stake weighed emission
fixed with #![cfg(feature = "test-bpf")]
Hey guys what is the to_account_info() method used for in an account
hey Alan, has this been fixed? I seem to have run into a similar issue
How can I get a transaction before it's signed via the anchor typescript program API? I want to create multiple transactions then send them all to the wallet at once so there isn't multiple signature requests sent to the user's wallet
I'm trying to define an account, but am getting the following error:

```20 | #[derive(Accounts)]
   |          ^^^^^^^^ function or associated item not found in `User`
...
37 | pub struct User {
   | --------------- function or associated item `default` not found for this
   |
   = help: items from traits can only be used if the trait is implemented and in scope
   = note: the following trait defines an item `default`, perhaps you need to implement it:
           candidate #1: `Default`
```
I'm brand new to rust and anchor, and I've searched online, tried the documentation, and used rustc --explain, but I am still having trouble understanding. Code below. Any ideas?
```
#[derive(Accounts)]
pub struct CreateAccount<'info> {
    // Create account of type User and assign user's pubkey as the payer
    #[account(init, payer = owner)] // Need to add space = User::LEN?
    pub account: Account<'info, User>,

    // Define user as mutable - money in their account, profile data, etc.
    #[account(mut)]
    pub owner: Signer<'info>,

    // Ensure System Program is the official one from Solana.
    #[account(address = system_program::ID)]
    pub system_program: AccountInfo<'info> 
}

#[account]
pub struct User {
    pub pubkey: Pubkey,
    pub username: String,
    pub email: String,
    pub description: String,
    // benefits: Vec<String>,
}

impl User {
    const LEN: usize = DISCRIMINATOR_LENGTH
        + PUBKEY_LENGTH
        + STRING_LENGTH_PREFIX + USERNAME_LENGTH
        + STRING_LENGTH_PREFIX + EMAIL_LENGTH
        + STRING_LENGTH_PREFIX + DESCRIPTION_LENGTH;
        // + BENEFITS LENGTH
}

```
would token::set_authority() work to pass an NFT's update authority over to another account or do I have to go through the metaplex program?
This is how I thought I might throw togther a CPI to the metaplex metadata program 

```
CpiContext::new(
            ctx.accounts.nft_metadata_account.to_account_info(),
            update_metadata_accounts_v2(
                ctx.accounts.token_metadata_program.to_account_info().key(), 
                ctx.accounts.nft_metadata_account.to_account_info().key(), 
                ctx.accounts.payer.to_account_info().key(), 
                Some(ctx.accounts.artist_license.to_account_info().key()), 
                None, 
                None, 
                Some(false),
            )

        );
```
lol it doesnt even seem close...vscode is telling me ```the trait bound Instruction: anchor_lang::ToAccountInfos<'_> is not satisfied
the trait anchor_lang::ToAccountInfos<'_> is not implemented for Instruction```
given some account info how do I get the program which owns it in Rust?
in short you sign the transactions, not pass a keypair
This is a great read for how wallets are plugged in: https://github.com/solana-labs/wallet-adapter
üëã have a few super noob-y question: 

1/ when I hit approve via the phantom/sollet interface, what is going on here exactly? Am I passing through my keypair through the `web3.js` call?
2/ Is the idea behind a wallet approve that, given a public Key -> approve -> keyPair? Please point me to some code as a starting point!
so that no new tokens can be minted,
seems like avm is decoupled with anchor altogether. When I try `avm uninstall 0.22.0` and `anchor --version` it stays the same `0.22.0`
Why would you ever want to set the mint authority to be none here?
What am I looking for?
üëã Looking at some examples of some SPL instructions on anchor, why is it that we always need to clone the accounts? i.e.

```
let token_accounts = InitializeMint {
            mint: self.mint.clone(),
            rent: self.rent.to_account_info(),
        };
```
How do I use the token program from a `.ts` test file?
maybe missing `<'info>` in struct definition
check your $PATH
How do I load an older version of anchor? I tried `avm use 0.21.0` it installs but when I check `anchor --version` it's still the same `0.22.0`
I have an instruction in my program that I may want to call from other instructions within my same program, what is the idiomatic way to do this? do I still use CpiContext as if it was a different program?
What is the difference between UncheckedAccount and AccountInfo?
Any thoughts on this error:
```
error[E0107]: this trait takes 0 generic arguments but 1 generic argument was supplied
   --> programs/deltaone-protocol/src/instructions/attempt_liquidation.rs:26:34
    |
26  |     pub vault_lp_token_mint: Box<Account<'info, Mint>>,
    |                                  ^^^^^^^        ---- help: remove this generic argument
    |                                  |
    |                                  expected 0 generic arguments
```
Was just wondering if this repo is being maintained, as I saw the last commit for this was back in July
I saw that stake-v1 was deprecated
https://github.com/project-serum/stake-v2 Looking at spl-token staking, is this the best repo to go by?
This worked Finally! I can call my programs from android üî•
Got it  üëç  thanks dude
sighash is generally sha256("global:instruction_name")
I'm not sure what's going on in your program, but I'm just saying, expect it to be something simple/straightforward
You didn't write exactly what I wrote (what I wrote would have logged something different, with a `vs` in there, etc.)
but i wrote exactly what u specified and then it gave me that log message? is that expected?
also what hash is used sha256?
So what are the parameters for the sighash function? is it instruction:functionName
Basically, rust isn't doing anything tricky/sneaky here
Ok, are you sure the conditional isn't firing?
looks pretty similar...

Just log `msg!("{} vs {}", nft_name, other_name);`
Make your life easier and get rid of that DEBUG thing
so like the names seems the same but it doesn't format correctly, is that a sign taht it might be of a different type??
```Actual name
[DEBUG]Actual name```
and it logs
msg!("[DEBUG]{}", nft_type);
        msg!("[DEBUG]{}", other_name);
Lol
yeh yeh? i tried logging it and it kind of checks out kind of doesn't
I would try logging what the other string is
That's how you compare strings, so must be that the other string is different
I am trying to compare 2 strings in rust unsuccessfully. One is coming from the metaplex metadata.
Currently, it always returns false.
let metadata_full_account = &mut Metadata::from_account_info(&ctx.accounts.nft_metadata_account_5)?;

   let full_metadata_clone = metadata_full_account.clone();

   //this is the first string I am comparing
   let nft_name = full_metadata_clone.data.name;

   let other_string = String::from("some_string");

   if(nft_name == other_string){
    //do something
   }

Thanks for any help.
Looks like running `getProgramAccounts` on the token program times out
```
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: ClientError { request: Some(GetProgramAccounts), kind: Reqwest(reqwest::Error { kind: Request, url: Url { scheme: "https", cannot_be_a_base: false, username: "", password: None, host: Some(Domain("psytrbhymqlkfrhudd.dev.genesysgo.net")), port: Some(8899), path: "/", query: None, fragment: None }, source: TimedOut }) }', bot/src/recover.rs:28:10
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```
How does `getProgramAccounts` behave on a program with ~millions of accounts? Does it return a random subset, or does the request perhaps timeout?
If on the rust side it's a `u16`, then you'd want to do `count.toArrayLike(Buffer, 'le', 2)` since a u16 takes 2 bytes
Coming back to this problem from a while back. If I have a u16 number saved in a customised account (vault.count for example). How could I properly serialize the bytes on the rust and the client side? 

I tried this on the rust side:

``` seeds = [..., vault.count.to_le_bytes().as_ref()]
```
Then this on the client side:
```
const count = new anchor.BN(_count)
PublicKey.findProgramAddress(
  [..., count.toArrayLike(Buffer, 'le', 8)],
  ...)
```

But didn't work. Any other suggestions?
incorrect version of anchor-lang in programs Cargo.toml maybe?
I'm on anchor `0.22`
Any idea why this would happen or how to fix it?
Hello, I'm getting ```error: internal compiler error: expansion entered force mode without producing any errors
``` when I use the #[error_code] macro.  My rustc --version --verbose is rustc 1.59.0 (9d1b2106e 2022-02-23)
binary: rustc
commit-hash: 9d1b2106e23b1abd32fce1f17267604a5102f57a
commit-date: 2022-02-23
host: x86_64-apple-darwin
release: 1.59.0
LLVM version: 13.0.0
The usual way nowadays would be to use PDAs with static seeds, yeah
Unless there's a way I'm missing to track global accounts the program makes use of?
Ah. I guess I'll just have to use PDAs for everything, e.g. the mint, token program, etc.
But you can see lots of examples if you search through the anchor repo's old tests
Strictly speaking the whole macro is deprecated
What is the correct way to use the #[state] macro? When I tried to use it and later access the global state variables in it, I got errors saying that I can only use `self` in associated functions.
Would it be `Clock::get()?.slot`
how do i get the current block # from within the instruction handler?
yea i saw that, but I was ok with the slight difference in precision. thank you though!
Lol
For example, 2509377967226505829 in JS will actually be equal to 2509377967226505700, lol
That number is too big to be safely represented as a JS number, lol, and BN knows this/blows up
thank you!
`BN("12312412342342341324")`
This is a funny issue, you need to wrap the number in quotes
I'm trying to pass a big number into a test and it fails because "Error: Assertion Failed" as soon as it tries to create the BN
```ts
const ammUpdatedBaseAssetAmount = new BN(2509377967226505829);```

```
Error: Assertion failed
    at assert (/Users/user/crypto/cpi-example/node_modules/bn.js/lib/bn.js:6:21)
    at BN._initNumber (/Users/user/crypto/example/node_modules/bn.js/lib/bn.js:128:7)
```
Also was wondering if anyone noticed that `program.account.theAccountType.fetch` is returning the union type of all accounts rather than a specific account's type. Basically I'm getting a return type of `theAccountType | theOtherAccountType | theThirdAccountType` instead of just `theAccountType`. Maybe this is just some issue with the version of anchor I'm using? I've been using a script which always uses the latest anchor pushed
Nice! `fetchNullable` worked. I prefer that method so I'm not making 2 RPC calls
Or I think you can also just use `program.account.theAccountType.fetchNullable` ü§î
`await program.provider.connection.getAccountInfo(theAddress)`
How should I check if an account exists in TypeScript? The generated fetch method from the contract will just throw an error with no specific usable properties if the account doesn't exist. It doesn't make sense to parse the error message there
ur the best :)))
In your anchor.toml, do `mpl_token_metadata = { version = "...", features = ["no-entrypoint"] }`
Thanks; that should work.
`error: the #[global_allocator] in this crate conflicts with global allocator in: mpl_token_metadata`

does anyone know what this error means?
The way that would work is having mint::authority = some_pda_derived_from_your_program
Nope, every mint has an authority on it in solana. You could have your own program be the authority though, and let anyone ask your program to mint tokens.
Or am I misunderstanding the meaning of `mint::authority`?
What if I want anyone to be able to mint tokens, as https://medium.com/linum-labs/intro-to-bonding-curves-and-shapes-bf326bc4e11a ?
To init a mint, you'll need to also use the `mint::decimals =` and `mint::authority = ` attributes in there
Very simplistic so far; I haven't written anything more because the Mint type is giving me that error. Do I even need it?
https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html look at this page
the account docs are pretty good tbh, shows many examples
I just learned how to init some token accounts, associated token accounts, and token account PDAs
can u show ur struct
And my current attempt gives me the error:

```
No function or associated item named `default` found for struct `Mint` in the current scope. This error originates in the derive macro `Accounts`.
```
Google doesn't seem to turn up any.
Are there any good examples or tutorials for using `anchor_spl` to implement an SPL-like token?
i'll push a fix
oh, it's because the doc comment contains `Accounts`, the idl parser thinks its a `#[derive(Accounts)]`
definitely a bug though
it works for me without the doc comment
nope
You presumably didn't need that to be a doc comment right?
Or change it to a regular good old fashioned double slash lol
oh...
I'm saying just delete that triple comment, the `/// Accounts in context of...` part
will probably just do u128 for now, haha
is there any other way to store fixed size data?
hmm
Heh, not sure why yet it would be an issue, but it is ü§∑‚Äç‚ôÇÔ∏è Some kind of bug in anchor's IDL parsing
```rust
/// Accounts in context of initialize_vault instruction
#[account]
#[derive(Default)]
pub struct VaultInfo {

    /// Mint address of token A
    pub token_a: Pubkey,

    /// Mint address of token B
    pub token_b: Pubkey,

    pub vault_name: [u8; 20],
}
```
Actually yes
Nope
Do you have a `///` comment on top of that #[account] line?
is there anything different that has to be done for storing arrays in an acct in 0.22.0? currently trying via:
```rust
#[account]
#[derive(Default)]
pub struct VaultInfo {

    /// Mint address of token A
    pub token_a: Pubkey,

    /// Mint address of token B
    pub token_b: Pubkey,

    pub vault_name: [u8; 20],
```
which I'm 99% sure worked before but i'm getting an error  `thread 'main' panicked at 'Code not parseable: Error("invalid type")', lang/syn/src/idl/file.rs:357:58` . If i change the vault_name to a u8 the code compiles and runs (but obv can only store a u8)
üëã  Does anyone have an example here of how NFTs are collected? For example a series of web3 javascript calls to build up the mint, metadata, master edition, etc?
Thanks a lot, I tried to find it rust documentation ... but honestly I didn't know what to search
It's a rust thing (you can honestly kind of just ignore it if you want): https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html
Hello, I'm trying to work on a simple program to understand a bit more how anchor and rust works. I'm currently reading  some OS programs done with anchor. I see this notation a lot <'info ...  Can someone help me to understand what it does / refer (sorry for the n00b question) ?
Yeah, I'm importing a (deceptively large) struct from a different crate for simplicity and I think that's the issue. I'll probably just end up writing my own pared down version. Thanks for the help!
i would never have figured that out on my own
WOW thank you
You've blown your stack limit by a fair amount though, so I wonder if you have some big structs.
Not that I know of :/ You basically just have to think about it‚Äîthe basic situation is that in solana, each stack frame only gets 4kb of space, so if you e.g. have a large variable on the stack, like `let stuff = [0u8; 2000];`, that's a bad idea (you've just used up 2kb of your 4kb)
Is there any way to get more details about stack space as an output of anchor build (or cargo build-bpf)? I can see this very useful warning when I run anchor build on a program that exceeds the stack: `Function --- Stack offset of 5232 exceeded max offset of 4096 by 1136 bytes, please minimize large stack variables` and I'm trying to get an understanding of where the extra 1136 bytes are coming from. I've Boxed a few accounts but I want to get a deeper understanding of what I'm doing wrong
hello all has anyone been able to successfully  setup and build environment for farms locally from the https://github.com/solana-labs/solana-program-library/tree/master/farms. I get the following errors when trying to compile it with cargo build or cargo build-bpf.

```error: cannot find attribute `error` in this scope
  --> /home/kali/.cargo/registry/src/github.com-1ecc6299db9ec823/vipers-1.6.1/src/lib.rs:58:3
   |
58 | #[error(offset = 1100)]
   |   ^^^^^
   |
note: `error` is imported here, but it is a function-like macro
  --> /home/kali/.cargo/registry/src/github.com-1ecc6299db9ec823/vipers-1.6.1/src/lib.rs:10:5```
The issue is with serde on how rust compiler is confusing import as macro. any info on how to solve it new to anchor and rust programming. Thanks for the help. üôÇ
Get your point thanks!
No idea, sorry. I'm just saying that there's got to be some rust api to send transactions, and I expect it will mirror the JS/TS one
I can find this in the anchor book?
I am very confused.
Or in the anchor_lang in the rust book?
I will search for it
Hello, I am not quite understand why it's matter using canonical bump the example 7 in https://github.com/project-serum/sealevel-attacks/blob/master/programs/7-bump-seed-canonicalization/insecure/src/lib.rs,
 it seems more like an inappropriate seeds problem or the bump should saved inside the data field instead of passing it,  because in that example, both find_program_address or create_program_address are able to verify the given account is actually we want.
is this correct? Could you please explain a little bit? Thanks! <@!501570363566587905> <@!134416332509675520>
There's nothing front-end specific about that call, it just happens to be in JS/TS
There will be some analogue, yeah (presumably)
You mean in my rust program i put a Connection.sendrawtransaction(u8Array)?
Ok i will try when I get to my computer.
I have no idea that would work
Why wouldn't it work from the backend?
That's on front and and works but I want to trigger from backend
Mm, there's a method called `sendRawTransaction` on connection objects, have you tried that?
Any direction about u8 array raw transaction to send?
Ah, I'm saying that is sounds like your client needs to first fetch PDA1 just in order to be able to even know the address of PDA2.
Context 
The CTX.accounts.PDA2 for eg
The accounts passed in the context
What's a CTX?
1) So no need to provide PDA 1 as input?
How do you fetch data in an account that is not in CTX? 
But I have the struct of it.
2) after fetching this u8Array from PDA1, what function i use to send to Blockchain? Not sure where to find this info
Ah, you would just have to fetch PDA2, read the PDA1 key, and then fetch PDA1
(doing a durable nonce transaction)
1 ) tx.sign
2) tx.serialize
3) store in PDA1 as u8Array
4) store PDA1 Pubkey in PDA2 

5) from backend, i want to fetch the signed and serialized transaction and proceed with it (that is stored in PDA 1)
So maybe I'm misunderstanding your question
You would send a transaction in much the same way that your JS tests run
Ok and from the data in the account.
How do you send a raw transaction from backend?


//////////////////////////////////////////////////////////////////////////////////////////

Curious, if a CPI fail, would it always fail the caller transaction? Is it possible to act on the failure messages and do something to handle it?
Getting a lot of failed txn -

 Translating error Error: Transaction was not confirmed in 30.00 seconds. It is unknown if it succeeded or failed. Check signature 3jYVQFWYtrv89n9wdBMJzAXv5UsUT4rwdaSHZc3GjbWZiku63pVL1f5FPga9pCTAweGhZYRnUfWt9QezDFr5RdyZ using the Solana Explorer or CLI tools.

Is there anything I can do on my side to ensure it passes through ?
üëã What determines whether phantom shows a proper preview or this?
Even when I have my code structured like so:

```
const result = await mpl.actions.mintEditionFromMaster({
        connection,
        wallet: wallet,
        masterEditionMint: mintAddress,
        updateAuthority: walletPublicKey
      });

      // confirm transaction
      await program.provider.connection.getTransaction(result.txId, { commitment: "finalized" });

      // this actually contains a link the the master edition
      const editionData = await mplToken.Metadata.getEdition(connection, result.mint);
```

still getting some the issues occasionally. I guess this is just a limitation on the solana blockchain?
Hey <@!134416332509675520>  is there an anchor program using pyth-client. I wanted to use pyth-client to consume data in anchor. Can you please point me to a repo or a guide using it.
Calling `.to_account_info()` does a `.clone()` on the underlying AccountInfo for that account, which I wouldn't expect to be super expensive but it does have to do a little bit of work.
is it better for compute budget to create variables when you need to call to_account_info() in one function a few times, or just call  to_account_info() whenever you need it?
Yeah
to clarify you mean adding `await program.provider.connection.getTransaction(result)` between the mintEdition and getEdition calls?
Or `.getTransaction(result, { commitment: "finalized" })` to wait extra hard
You can try doing `await program.provider.connection.getTransaction(result)`
üëã I have a snippet of JS code like so:

```
const result = await mpl.actions.mintEditionFromMaster({
        connection,
        wallet: wallet,
        masterEditionMint: mintAddress,
        updateAuthority: walletPublicKey
      });

      // this actually contains a link the the master edition
      const editionData = setTimeout(await mplToken.Metadata.getEdition(connection, result.mint), 1000);
```
I find that the `Metadata.getEdition` call often fails with a `Unhandled Rejection (Error): Unable to find account: ` but when I use explorer with the account pubkey it's there. I suspect it takes a few seconds for block confirmation. Any ways you guys avoid the `Unhandled Rejection` errors?
im building an AMM is there any easy way to do it here? im trying to get it using RUST but im having trouble... was wondering if there was an easy way with Anchor.
post your error message
smart contract
Yep, https://jstarry.notion.site/Program-deploys-29780c48794c47308d5f138074dd9838#ed8a7e1fe88546aa9a0a3bd551de1ad6 covers this in the "Reclaiming buffer accounts" section
any way i can find out if my keypair has any leftover open buffers from failed deploys?
what are you deploying? - smart contracts seem to be all good for me
anyone had luck deploying to devnet or is it just me ?
right on... np
thank you for your help!
i believe so
problem solved tho?
so embarassing don't ask
caveman moment
hol up
can you post the whole code?
program.instruction.connect(...) seems to be calling it
how are you sending the tx?
like the request for me to sign
hmm... there's no error logs it just keeps posting multiple transactions every time
If that doesn't work either... post your error logs
thx ill take a look :0
I'm currently using the Methods Builder... Here's how it looks https://github.com/heavy-duty/platform/blob/master/apps/bulldozer-programs/tests/workspace.spec.ts#L78 if you replace `.rpc()` with `.instruction()` should give you a promise that resolves a `TransactionInstruction`
do you have any examples I could look at - they're still popping up and I've done something wrong
thank you very much!
try `program.instruction.<your-ix-name>` instead of `program.rpc`
how do I bundle up instructions to send them in a single transaction?
Using program.rpc.increment and transaction = new Transaction().
I'm currently trying:
```
let transaction = new Transaction()
for (let i = 0; i < 3; i++) {
        transaction.add(
            program.rpc.increment(
              ...
            )
            )
        )
    }
```
However that just triggers three tranasctions immedietely
Hi there, I started using #[access_control] for handling instructions pre-conditions, in contrast with the account `constraint` that's more of an invariant style of validation. But now I'm wondering...

1. Is there an alternative for `access_control` that runs `after` the instruction handler to deal with post-conditions?
2. Is it possible to turn `access_control` into an invariant rather than just a pre-condition check?

Thanks in advance
Thank you so much!!!
https://github.com/project-serum/anchor/blob/master/tests/ido-pool/programs/ido-pool/src/lib.rs#L83
Hello developers, could I get links about the example code of SPL-token transfer using the Anchor framework?
I've tried, but I could not find any example. 
TIA.
Hello, someone knows how to manage errors with account.subscribe (try/catch or errorCallback)?  For example, when an account is deleted. I'm getting Error: Invalid account discriminator (subscribe - https://github.com/project-serum/anchor/blob/b733610d/ts/src/program/namespace/account.ts#L234)
solana-keygen grind --help
How do you get a program address with a word at the beginning? For example `metaXXXXX‚Ä¶` in for the metaplex contract
nope i didn't, just exported from replit, but the npm start says "Could not find a required file"
did you create the app via `npx create-react-app app_name`? if so, check the package.json and find the `scripts` part. should have a `start` script there. defaults to `start: react-scripts start` which you can also execute by running `npm start`
i was working on replit, but now that i moved to vscode i cant figure it out why it isnt working
it doesn' work either
you need to run `yarn start` in a separate terminal
guys, does anyone know how to open localhost on react via vscode? im struggling with this
lol literally feel like 50% of the traffic in this channel has been me this past month
thanks a lot
Yep, anchor handles everything else for you
Nope, no need to sign (your program never requires a signature to mutate one of its own accounts)
The lamports are returned to the receiver and I don't have to worry about signing? Also, guessing I also don't need anything beyond `Ok(())` in the function itself?
<@!891024357026041907> this is the easiest way to close one of your own accounts
got an example of closing one of your own program's accounts?
(which requires asking the spl token program to do it for you, since the account is owned by the spl token program if it's a token account)
ah thanks for that clarification ü§¶‚Äç‚ôÇÔ∏è
The above code is how you'd close a token account
Ok, so the thing you're doing above involves the spl token program‚Äîthat's unrelated/not how you close one of your own accounts
^ so this is an account owned by my program
No it's defined:

```
#[account]
pub struct ExchangeInfo {
    pub mint_address: Pubkey
}
```
I thought it was just a regular account account
Is global_state a token account?
How come?
The authority should be my program here right? The account was created and owned by my program
```
let cpi_ctx = CpiContext::new_with_signer(
            ctx.accounts.program.to_account_info(),
            anchor_spl::token::CloseAccount {
                account: ctx.accounts.global_state.to_account_info(),
                destination: ctx.accounts.receiver.to_account_info(),
                authority: ctx.accounts.program.to_account_info(),
            },
            signer 
        );
```
Why do you need to access your own program though?
The accounts I'm trying to close are owned by my program. So wondering if there's an easier way to access it without having to explicitly pass in my own program in
Or, what are you trying to do?
Where are you trying to do that?
Yeah the issue here is you still need to set up an additional instruction/struct üòê
What's the right syntax to pass your own program as input? `ctx.program.to_account_info(),` doesn't seem to work
```
#[account(mut, close = receiver)]
pub data_account: Account<'info, MyData>,
#[account(mut)]
pub receiver: SystemAccount<'info>
```
https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html
Does this achieve what you intend to do?
At the end of the day you need to drain the account's lamports, and that requires asking the program to do it for you
Nope, requires an instruction
üëã is there a more automated way to close a custom program account? e.g. suppose I have:

```
#[derive(Accounts)]
pub struct RandomizeExchange<'info> {
    #[account(
        init,
        payer = payer,
        seeds = [payer.key().as_ref(), burn_mint.key().as_ref()],
        bump,
        space = 100 // 32 * 2 to store accounts
    )]
    pub exchange_info: Account<'info, ExchangeInfo>, 
    pub system_program: Program<'info, System>,
    #[account(mut)]
    pub global_thing: Account<'info, GlobalThing>,
    pub burn_mint: Account<'info, Mint>,
    #[account(mut)]
    pub payer: Signer<'info>,
}
```
Rather than writing a custom instruction to close `ExchangeInfo` is there a generic command that every program has to close all the `ExchangeInfo` account?
Is there a way to optimize this cost for short duration programs by not using rent-exempt
2 times because the first deploy doubles your space to give you room to grow
The cost is going to be (7 sol / mb) * (2 times .so file size)
Deploying to mainnet will be the same cost as deploying to devnet (or at least super super close, modulo tiny fee differences I guess)
I guess one thing you can do is just check if that program_id is already an account on-chain (like, in the explorer etc.)
```
‚ûú  solana-burn-token-for-token-v3 git:(main) ‚úó solana balance GFaWuwHEv7DPMP8VAZMrnHf1kDqSMEzWMf2iYwQH8ZJC
4.22231716 SOL
‚ûú  solana-burn-token-for-token-v3 git:(main) ‚úó anchor deploy --provider.cluster devnet
Deploying workspace: https://api.devnet.solana.com
Upgrade authority: /Users/pw/.config/solana/id.json
Deploying program "solana-burn-token-for-token-v3"...
Program path: /Users/pw/Documents/coding/solana-burn-token-for-token-v3/target/deploy/solana_burn_token_for_token_v3.so...
Program Id: GpLZRedGz2uNoFXo24UxxfQivDvw3xSHzdGhTYFFKdSC

Deploy success
‚ûú  solana-burn-token-for-token-v3 git:(main) ‚úó solana balance GFaWuwHEv7DPMP8VAZMrnHf1kDqSMEzWMf2iYwQH8ZJC
4.22021216 SOL
```
So upgrading a program doesn't cost any additional SOL, is there a way to check beforehand what the cost of deploying a program to mainnet will be? In other words, based of your *.so and idl and program ID is there a way to determine whether you are newly deploying a program vs. upgrading an existing one?
Ah, it was in spl_token::state::Mint, not in anchor_spl. Thank you!
And you'll have to do this annoying `mint.mint_authority == COption::Some(authority.key())` thing
Try jumping to source
`mint.mint_authority`
Hi, how can I get mint authority of a token mint account?

I'm trying to implement the following code but cannot get it to work.
```
#[account(constraint = mint.owner == authority.key())]
pub mint: Account<'info, Mint>,
```
Default way of writing your tests in JS/TS.
should i have it installed? what is it even used for?
im seeing a lot of people mentioning mocha, but the anchor website doesnt mention it when its walking you through setting up anchor
awesome, thank you
Starting to see this too, did you end up figuring this out?
üëã getting:

```
Error: Custom: Invalid blockhash
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.
``` 
when trying to deploy, is this because devnet is down? How can I check?
Are there any docker containers to keep all the versions in line?
It uses compute units to populate that cache (it has to call find_program_address), but afterwards it, yeah, caches them
does `ctx.bumps.get()` use compute units to find bumps?
Here https://docs.rs/anchor-lang/latest/anchor_lang/prelude/derive.Accounts.html (scroll down/search for init_if_needed)
`init_if_needed` requires that anchor-lang be imported with the init-if-needed cargo feature enabled. Carefully read the init_if_needed docs before using this feature to make sure you know how to protect yourself against re-initialization attacks. <- where can I find these docs? https://www.google.com/search?q=init+if+needed+anchor&oq=init+if+needed+anchor&aqs=chrome..69i57j33i160j33i160i395.4140j1j7&sourceid=chrome&ie=UTF-8 doesn't seem to have anything substantial
Thanks for the quick answer!
`camelCase("globalNftTracker", { pascalCase: true })` is "GlobalNftTracker", not GlobalNFTTracker
But the issue is here: https://github.com/project-serum/anchor/blob/master/ts/src/coder/borsh/accounts.ts#L98
Guess this should go in an anchor bug-report
üîÆ
wtf? what was causing this?
wow that works
Yep
As in:

```
#[account]
pub struct GlobalThing {
    pub used_items: Vec<bool>
}
```
And then do `program.account.globalThing.fetch(...)`
I guess that's saying we have actually init the account, question is why does `program.account.globalNftTracker.all()` return nothing and `await program.account.globalNftTracker.fetch(globalStateAcct);` give me `invalid account discrim..` hmm ü§î
Just to check, can you change the name of the struct to something simpler case-wise? Like `GlobalThing`
Ok cool
It's `{data: Buffer(1000), executable: false, lamports: 7850880, owner: PublicKey, rentEpoch: 0}` when I set `space = 1000`
(fwiw that won't really work for a dynamically-sized account)
I reset the space size to be `space = 8 + std::mem::size_of::<GlobalNFTTracker>(),`
When I do `await program.account.globalNftTracker.all();` it gives me nothing
Why does it only have length 32 though, rather than 1000?
so something exists when i fetch it
`{data: Buffer(32), executable: false, lamports: 1113600, owner: PublicKey, rentEpoch: 0}`
What do you get if you fetch the account the old-school way, `await program.provider.connection.getAccountInfo(globalStateAcct)`?
i've also checked that the `program.programId` is correct...
Per the program logs it looks like everything runs alright:

```
Streaming transaction logs mentioning ConhfBtNQGFLWuUAjpCs3U5ycQV22pgJMMRfUmete2zg. Confirmed commitment
Transaction executed in slot 6:
  Signature: 33kFBLkKv19ypnKitdhhNmpD6R8sp5njY9A1aBLsvLge7T365xxVTzF7K4MXhvhJ2m1PQm3kiMd2N2LwYm153aBK
  Status: Ok
  Log Messages:
    Program ConhfBtNQGFLWuUAjpCs3U5ycQV22pgJMMRfUmete2zg invoke [1]
    Program log: Instruction: InitializeTokenAcct
    Program 11111111111111111111111111111111 invoke [2]
    Program 11111111111111111111111111111111 success
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [2]
    Program log: Instruction: InitializeAccount
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 3384 of 185649 compute units
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success
    Program 11111111111111111111111111111111 invoke [2]
    Program 11111111111111111111111111111111 success
    Program log: Transferring tokens from: F3YfsXBDw182taRMUEuzqzMhiakcAZiDs5nxMHqsYkuJ
    Program log: To: CtvJRm99CEXMRgmdiLahqvDmxTGZuoJH4CEd3sDH5HSS
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [2]
    Program log: Instruction: Transfer
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 3200 of 147551 compute units
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success
    Program ConhfBtNQGFLWuUAjpCs3U5ycQV22pgJMMRfUmete2zg consumed 56836 of 200000 compute units
    Program ConhfBtNQGFLWuUAjpCs3U5ycQV22pgJMMRfUmete2zg succes
```
Seems like im initializing the account properly, I've added the necessary macros here
Running into: 
```
  1) solana-burn-token-for-token
       Token version: it passes authority to the PDA, mints and burns token:
     Error: Invalid account discriminator
```
What am I doing incorrectly here?
I've got:

```
#[derive(Accounts)]
pub struct InitializeTokenAcct<'info> {
    #[account(mut)]
    pub token_acct: Account<'info, TokenAccount>,
    #[account(mut)]
    pub token_mint: Account<'info, Mint>,
    #[account(signer)]
    pub acct_authority: AccountInfo<'info>,
    pub token_program: AccountInfo<'info>,
    // This is where we'll store the offer maker's tokens.
    #[account(
        init,
        payer = payer,
        seeds = [token_acct.mint.as_ref()],
        bump,
        token::mint = token_mint,
        token::authority = escrowed_token_acct,
    )]
    pub escrowed_token_acct: Account<'info, TokenAccount>,
    #[account(mut)]
    pub payer: Signer<'info>,
    #[account(
        init,
        payer = payer,
        seeds = [b"test".as_ref()],
        bump,
        space = 1000
    )]
    pub global_state: Account<'info, GlobalNFTTracker>,
    pub system_program: Program<'info, System>,
    pub rent: Sysvar<'info, Rent>
}

#[account]
#[derive(Default)]
pub struct GlobalNFTTracker {
    pub used_items: Vec<bool>
}
```

Calling this in a test like so:

```
const [escrowedMakerTokens, escrowedMakerTokensBump] = await anchor.web3.PublicKey.findProgramAddress(
      [preInitTokenAcct.mint.toBuffer()],
      program.programId
    );

const [globalStateAcct, _] = await anchor.web3.PublicKey.findProgramAddress(
  [Buffer.from("test")], program.programId
);

const tx = await program.rpc.initializeTokenAcct({
  accounts: {
    tokenAcct: senderTokenAccount,
    tokenMint: sampleMint.publicKey,
    acctAuthority: sender.publicKey,
    tokenProgram: spl.TOKEN_PROGRAM_ID,
    escrowedTokenAcct: escrowedMakerTokens,
    payer: payer.publicKey,
    globalState: globalStateAcct,
    systemProgram: anchor.web3.SystemProgram.programId,
    rent: anchor.web3.SYSVAR_RENT_PUBKEY,
  },
  signers: [payer, sender]
});

const globalStaetAccount = await program.account.globalNftTracker.fetch(
  globalStateAcct
);
```
Any associated token examples i could find?
was confused looking at an older program
ahh right thanks
That's what `Program<'info, System>` and `Program<'info, Token>` do for you
how do i apply these checks in the account attribute itself?
Hmm, I'm not sure actually. Is that a property of your solana install? Like when you run anchor build, anchor just kicks out to your solana toolchain‚Äîso I think it would depend on your solana install in the background.
Is there a way to know what solana bpf version a given anchor installation is using?
But anchor usually uses the term "authority" for that idea, since "owner" is annoyingly overloaded with program owner
Here `token::authority` will end up being the token's `.owner` field
That's just the syntax anchor has chosen, so basically just have to read the docs/have read the source before
üëã in your quidproquo program, you initialize an account like so:

```
#[account(
        init,
        payer = payer,
        seeds = [token_acct.mint.as_ref()],
        bump,
        token::mint = token_mint,
        // We want the program itself to have authority over the escrow token
        // account, so we need to use some program-derived address here. Well,
        // the escrow token account itself already lives at a program-derived
        // address, so we can set its authority to be its own address.
        token::authority = escrowed_token_acct,
    )]
pub escrowed_token_acct: Account<'info, TokenAccount>,
```
When you do this, how do you determine what the arguments are? How do you know you can add a `token::mint` and `token::authority`?  Looking at `TokenAccount` struct, we I don't see a `token::authority` object at all so wondering where this is going?


//////////////////////////////////////////////////////////////////////////////////////////

Don't think there's a super easy way to control the error, as far as I know
Have you tried running it?
got it, since `ctx.account.the_account` is `Account<TheStruct>`, `*` for deref gets to `TheStruct`
What would the error be? can we control the error messge by any means ?
Should work I think
```.rs
*ctx.accounts.the_account = TheStruct {
  ...
};
```
Do accounts need to have their properties updated individually or can you update from a struct?
Is it possible an associated token account which is generally linked with one wallet could be same for some other wallet ? I don't think so it should be the case but I'm facing some weird issue where a wallet transfer a token from his ATA to other account and then close his ATA and then if I try to find ATA for that wallet and mint I get different account altogether.
Oh. awesome!! Thanks. didn't know that
I tried but type error is not disappearing
It will fail on the second one (so it already enforces that you can only create the account once)
Have you tried running that instruction multiple times?
Argument of type '[{ metadataAccount: string; createdTimestamp: number; startTimestamp: number; endTimestamp: number; distributionTimestamp: number; nftPrice: number; participateSativPerTicketRatio: number; }, { ...; }]' is not assignable to parameter of type '[...(number | BN | TypeDef<{ name: "Data"; type: { kind: "struct"; fields: [{ name: "metadataAccount"; type: "publicKey"; }, { name: "createdTimestamp"; type: "i64"; }, { name: "startTimestamp"; type: "i64"; }, { ...; }, { ...; }, { ...; }, { ...; }]; }; } & { ...; }, Record<...>>)[], Context<...>]'.
  Type at position 0 in source is not compatible with type at position 0 in target.
    Type '{ metadataAccount: string; createdTimestamp: number; startTimestamp: number; endTimestamp: number; distributionTimestamp: number; nftPrice: number; participateSativPerTicketRatio: number; }' is not assignable to type 'number | BN | TypeDef<{ name: "Data"; type: { kind: "struct"; fields: [{ name: "metadataAccount"; type: "publicKey"; }, { name: "createdTimestamp"; type: "i64"; }, { name: "startTimestamp"; type: "i64"; }, { ...; }, { ...; }, { ...; }, { ...; }]; }; } & { ...; }, Record<...>>'.
      Types of property 'metadataAccount' are incompatible.
        Type 'string' is not assignable to type 'PublicKey'.ts(2345)
Thanks for your reply <@!134416332509675520> .

But would you please elaborate more on how I could use it in my use case below ?

```
#[derive(Accounts)]
pub struct CreateSubscription<'info> {
    // Create account of type Subscription and assign creator's pubkey as the payer
    #[account(init, seeds = [benefit.key().as_ref(), user.key().as_ref(), b"subscription".as_ref()], bump, payer = user, space = Subscription::LEN)]
    pub subscription: Account<'info, Subscription>,

    // Define user as mutable - money in their account
    #[account(mut)]
    pub user: Signer<'info>,

    // The benefit to which user wants to subscribe to
    pub benefit: Account<'info, Benefit>,

    // Ensure System Program is the official one from Solana
    pub system_program: Program<'info, System>,
}
```
How can I make sure, I don't create the subcription for the user if they already have one ?
can i ask you any sample code?
You just pass them as objects in JS/TS, with the right fields
Do I need to create the types or are they generated from the idl?
That error happens here, fwiw: https://github.com/project-serum/anchor/blob/master/cli/src/lib.rs#L2455
builds correctly but it's not able to deploy
That's my anchor TOML
```toml
[workspace]
members = ["programs/graph_program"]

[programs.mainnet]
graph_program = "grphSXQnjAoPXSG5p1aJ7ZFw2A1akqP3pkXvjfbSJef"

[programs.devnet]
graph_program = "grphSXQnjAoPXSG5p1aJ7ZFw2A1akqP3pkXvjfbSJef"

[registry]
url = "https://anchor.projectserum.com"

[provider]
cluster = "mainnet"
wallet = "./id.json"

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"
```
I think it may be related to the container not being able to read the deployer keypair
Is anything weird about your Anchor.toml file?
Thank you, I still don't get why this happens
```.rs
#[account(seeds = [... the seeds ... ], bump,)]
pub the_account: Account<'info. Whatever>
```
I was trying to figure out how to get access to the `AnchorDataV2` constructor in the client.

neither of these was it:
```js
const anchorDataV2 = new program.account.anchorDataV2({})
const anchorDataV2 = program.account.anchorDataV2.new({})
```
You can pass compound structs to you program, yeah, as long as they implement `AnchorSerialize, AnchorDeserialize, Clone` I think
Hey guys! How to check in anchor if an account exists with a particular PDA ? This is needed for validation in the program in rust.
I have this as an program instruction:
```rust
pub fn create_non_fungible(
        ctx: Context<CreateNonFungible>,
        data: AnchorDataV2,
        is_mutable: bool,
        max_supply: Option<u64>,
    ) -> Result<()> {
```
and want to create an `AnchorDataV2` object in the client to pass in to the program.

That gets defined in the program as "
```rust
#[derive(AnchorSerialize, AnchorDeserialize, PartialEq, Debug, Clone)]
pub struct AnchorDataV2 {
    /// The name of the asset
    pub name: String,
    /// The symbol for the asset
    pub symbol: String,
```
I was curious if that type was created in the client so that I could do something like:

```js
    const data = new AnchorDataV2 ({
      name: "Series",
      symbol: "NFT",
    });

const tx0 = await program.methods.createNonFungible(data, true, null)...
```
Can you show some code/pseudocode? Not sure what you mean
Can I create  an account object in the js client for accounts defined in the program? Does a type get created automatically or do I have to pass in the properties separately or recreate the type if I want to pass it in?
Is there any difference b/w token account or ATA ?
You can try -     
    var crankWallet = web3.Keypair.fromSecretKey([12,31,......]);
Signature verification failed when i use market.makeSettleFundsTransaction() with wrapped sol, why? any help, thanks
any idea how I can create a wallet from a keypair? 
I am currently trying to write this here
``` 
crankWallet = new anchor.Wallet(tmpKeypair);
``` 

but I'm getting

``` 
  Type 'NodeWallet' has no construct signatures.
```
but there may be multiple token accounts. the ATA is unique, but you can have other token accounts as well
associated token account yes
const accounts = await connection.getTokenAccountsByOwner(wallet, {mint: mintPublicKey}); Does this always give me one account?
can someone correct me - one mint address with one wallet would have one unique ATA ?
google??
Just in case some one is struggling to deploy on devnet, pls make sure
1. the key pair in anchor.toml has sufficient devnet SOL
2. upgrade solana to latest version (not sure if this helps)
3. make sure you are using the right proxy/vpn if necessaryÔºàuse solana balance to verify you could get a reponse)
OK, I manage to solve it: don't use api.google.devnet
Hi, sorry for the noob questions but my deployment failed with 'anchor deploy' due to timeout, I recovered the buffer with;

'solana-keygen recover

But when I tried again with:
solana program deploy --buffer recovery.json target/deploy/escrow.so

He tells me that the account not found (Pubkey: programIDPubkey), can someone help me with it ?

Thanks
^getting this error when trying to deploy the tictactoe example
Error: Account Aso---- is not an upgradable program or already in use
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: ""}.
it is super flaky actually... it just worked for once, and then not anymore

my IDL seems to show the account
Any idea why I'm getting
```
TypeError: Cannot read properties of undefined (reading 'fetch')
```

when I run 

```
let response = await this.solbondProgram.account.portfolioAccount.fetch(portfolioPDA); 
```  ?
The same happened to me because the internet blocked access to some sites here. So i changed the internet connection and it deployed fine. So, although its a rare case, I suggest you to try with different internet connection
Just in case some one is struggling to deploy on devnet, pls make sure
1. the key pair in anchor.toml has sufficient devnet SOL
2. upgrade solana to latest version (not sure if this helps)
3. make sure you are using the right proxy/vpn if necessaryÔºàuse solana balance to verify you could get a reponse)
devnet deploy failed
Just in case some one is struggling to deploy on devnet, pls make sure
1. the key pair in anchor.toml has sufficient devnet SOL
2. upgrade solana to latest version (not sure if this helps)
3. make sure you are using the right proxy/vpn if necessaryÔºàuse solana balance to verify you could get a reponse)
answering my own questions.. private functions are supposed to be implemented as impl fn in the struct used in the #[program] fns or can we can use separate pub mod and use them. New to Rust
basic-4 tutorial answered this ü§¶‚Äç‚ôÇÔ∏è 
https://github.com/project-serum/anchor/blob/master/examples/tutorial/basic-4/programs/basic-4/src/lib.rs
https://discord.com/channels/889577356681945098/889702325231427584/924850140341219349 check this out
<@!108582345895866368>  thank you for your advice. let me try to do it
you cannot do CPI of system program unless it's accounts owned by system program. In your case, the account is owned by your OWN program. So you need do the transfer without calling system program, directly change the lamports amount
Can we have private functions in the #[program] mod ? or do they all have to be pub and callable from outside?
Or do we have to resort to panics ?
Is it possible to return an error in the main function; I mean the 'initialize' function or any function of a program being called from outside?
Like returning Ok(()), can we return Err(CustomError::MyCustomError).
is it possible to disable the ///CHECK safety check? I understand what its trying to do but I literally just write "///CHECK asdf" and then go about my day
no clue sorry :/ haven't seen that one before - make sure your solana cli is up to date
This is instruction structure
```
#[derive(Accounts)]
pub struct SwapTokenToSOL<'info> {
    #[account(mut)]
    pub user_authority: Signer<'info>,
    // NOTE: this will also be SOL account.
    #[account(mut,
        seeds = [state_account.swap_name.as_ref()],
        bump= state_account.bumps.state_account
    )]
    pub state_account: Box<Account<'info, StateAccount>>,
    #[account(mut)]
    pub quote_mint: Account<'info,Mint>,
    #[account(
        mut,
        constraint = user_quote.owner == user_authority.key(),
        constraint = user_quote.mint == quote_mint.key()
    )]
    pub user_quote : Box<Account<'info, TokenAccount>>,
    #[account(
        mut,
        constraint = quote_pool.owner == state_account.key(),
        constraint = quote_pool.mint == quote_mint.key()
    )]
    pub quote_pool : Box<Account<'info, TokenAccount>>,
    // Programs and Sysvars
    pub system_program: Program<'info, System>,
    pub token_program: Program<'info, Token>,
    pub rent: Sysvar<'info, Rent>
}```

```
#[account]
#[derive(Default)]
pub struct StateAccount {
    pub swap_name: [u8; 10],
    pub bumps: SwapBumps,
    pub owner: Pubkey
    ...
}

```

```
#[derive(Accounts)]
#[instruction(swap_name: String, bumps: SwapBumps)]
pub struct Initialize<'info> {
    // Token program authority
    #[account(mut)]
    pub authority: Signer<'info>,
    // State Accounts
    #[account(init,
        seeds = [swap_name.as_bytes()],
        bump,
        payer = authority
    )]
    pub state_account: Box<Account<'info, StateAccount>>,
    ...
}
```
I am going to make my own simple swap  system.
"swap sol to token" works well but "swap token to sol" is not working. Here the problem is that the SOL transfer from program pool to user's wallet.

```Transaction simulation failed: Error processing Instruction 0: invalid program argument 
    Program 9jBjsXqKo6W54Hf65wrgR9k9AVYuCfDQQNUfygFtjWPJ invoke [1]
    Program log: Instruction: SwapTokenToSol
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [2]
    Program log: Instruction: Transfer
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 2643 of 186709 compute units
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success
    Program log: Sending Token: !!"1219073"!!
    Program 11111111111111111111111111111111 invoke [2]
    Transfer: `from` must not carry data
    Program 11111111111111111111111111111111 failed: invalid program argument
    Program 9jBjsXqKo6W54Hf65wrgR9k9AVYuCfDQQNUfygFtjWPJ consumed 22031 of 200000 compute units
    Program 9jBjsXqKo6W54Hf65wrgR9k9AVYuCfDQQNUfygFtjWPJ failed: invalid program argument```

This is code
```     let seeds = &[
            ctx.accounts.state_account.swap_name.as_ref(),
            &[ctx.accounts.state_account.bumps.state_account],
        ];
        let signer = &[&seeds[..]];
        msg!("Sending Token: !!{:?}!!", transfer_amount.to_string());

        invoke_signed(
            &system_instruction::transfer(
                ctx.accounts.state_account.to_account_info().key,
                ctx.accounts.user_authority.key,
                transfer_amount
            ),
            &[
                ctx.accounts.state_account.to_account_info().clone(),
                ctx.accounts.user_authority.to_account_info().clone(),
                ctx.accounts.system_program.to_account_info().clone()
            ],
            signer
        )?;```
Nice one, was doing something way most complex lol.
solana-cli 1.9.4 (src:8ce65878; feat:3258470607)
What's your local solana version? `solana -V`
This seems like a proper version of what a TS object should look like
still struggling to deploy on devnet 
```Error: RPC request error: cluster version query failed: error sending request for url (https://api.devnet.solana.com/)```
<@!341381788620423168> I think it would be something like
```
const fees = {
  tradeFeeNumerator: new anchor.BN(0),
  tradeFeeDenominator: new anchor.BN(0),
}
```
```
================================================================================
Recover the intermediate account's ephemeral keypair file with
`solana-keygen recover` and the following 12-word seed phrase:
================================================================================
crater witness mammal blush weather carbon element exit wait viable spice embark
================================================================================
To resume a deploy, pass the recovered keypair as the
[BUFFER_SIGNER] to `solana program deploy` or `solana write-buffer'.
Or to recover the account's lamports, pass it as the
[BUFFER_ACCOUNT_ADDRESS] argument to `solana program close`.
================================================================================
Error: error sending request for url (https://api.devnet.solana.com/): operation timed out
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.
```
or
```
=======================================================================
Recover the intermediate account's ephemeral keypair file with
`solana-keygen recover` and the following 12-word seed phrase:
=======================================================================
divide hungry pole shrimp bar movie truly source race hat foster census
=======================================================================
To resume a deploy, pass the recovered keypair as the
[BUFFER_SIGNER] to `solana program deploy` or `solana write-buffer'.
Or to recover the account's lamports, pass it as the
[BUFFER_ACCOUNT_ADDRESS] argument to `solana program close`.
=======================================================================
Error: Custom: Invalid blockhash
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.
```
deploy failed on devnet
In that case something along 
```{
  { x::u64 },
  { y::u64 }
}``` 
? I'm so bad at JS that you should not take my word though
Havn't tried this myself, but I believe as for enum, by creating an equivalent js object. Taking Hana article example rust side `pub enum Color { Black, White }` -> js side `{ Black: {} }`
Hey guys, I have this type that I am passing into an instruction as a param: ```#[derive(AnchorSerialize, AnchorDeserialize, Default, Clone, Debug)]
pub struct Fees {
    pub trade_fee_numerator: u64,
    /// Trade fee denominator
    pub trade_fee_denominator: u64,
}
``` And it generates as this in the IDL: ```  types: [
    {
      name: "Fees";
      type: {
        kind: "struct";
        fields: [
          {
            name: "tradeFeeNumerator";
            type: "u64";
          },
          {
            name: "tradeFeeDenominator";
            type: "u64";
          }
        ];
      };
    }
  ];
``` However for the life of me I cant seam to workout how do I use this type in my typescript tests?
created an issue for this. pls fill it with all information that you think might help us return a better error or fix the bug if there is one https://github.com/project-serum/anchor/issues/1594
Going to ask question here since I've tried Serum developer questions and was recommended to cross-post here:

I'm trying to open a new open orders account, swap, and close in the same transaction. Everything up to the close open orders instruction works, and then the close instructions breaks the TX. I'm getting error 42 which is TooManyOpenOrders, even though the Swap instruction should be settling all balances.

Example transaction here: https://explorer.solana.com/tx/3dBY3YB6NcuubAjw1FygyvqBqZTNEEeYPraBUzQUbURrV2qWXpHTXtb2ZKkL49g7qH74zVU53VngTFd2G2rgcstf

Code I think I am hitting is here: https://github.com/project-serum/serum-dex/blob/4d0a8dcdbff1706dd4447ab63f562c040c2b9e6f/dex/src/state.rs#L2304-L2318

I'm following the examples in the swap contract repo, does closeAccount not work in the same transaction?
It seems that Solana's programming model is not very similar to that of Ethereum.
I need much more trial and error. üôÇ
Thanks for the answer.
Not possible in solana, you have to pass that address in from the client as an account
Does anyone know how to get an instance of Account struct from a publicKey in anchor? Is it possible?
Can you say more? Strictly-speaking no, but I'm not quite sure what you're asking
Mm, probably (just try removing it and see if rust complains üòõ)
I'm getting this at the end of the anchor publish command, and I have my Anchor.toml there
are bumps required for creating PDAs?
Have some questions about Serum Swap, can anyone here help me out or should I ask in another channel?
?
Anyone gets this
`Workspace configuration error: No such file or directory (os error 2)`
running `anchor publish`
yes
Thanks. I've seen some code that does a .to_account_info().clone(), is that extra clone overkill?
Any good examples for the new bump requirements or generating a PDA. Thanks üôÇ
makes sense
Yeah, just do `let tx = new Transaction();` at the top, then `tx = new Transaction()` instead of trying to clear it
But I'm not sure, maybe you can mutate it or whatever (probably not a common use case)
I would just make a new tx (it's just a little data structure)
what i'm really trying to do here is:

```
const tx = new Transaction():
for each address:
  tx.add(...)
  if (tx.size() == 4) program.send(tx, ...); tx.clear(); // so I can keep going in this for loop
```
but not sure how to do the `.clear()` part, I just want an empty tx again
What would that do? Not sure what you mean
Anyway to clear a transaction object? e.g. 

```
const transaction = new Transaction();
transaction.add(...)
...
transaction.clear()? // how can I clear this transaction object
```
ok thanks I'll do that.
Looks like that call does a decent amount of work, so I doubt you can jam very many of them into a single tx (but you could try): https://github.com/metaplex-foundation/js/blob/main/src/actions/mintNFT.ts#L101
Try working through this tutorial: https://www.brianfriel.xyz/understanding-program-derived-addresses/
PDAs are "guessable"/obvious, you just use the same seeds on the client and the rust side
ok so that takes care of the rust side... 
How would I test it? as now the priceAccount PublicKey is not known to my tests as it's defined by the program??

it('Is initialized!', async () => {

    const tx = await program.rpc.initialize({
      accounts: {
        priceAccount: acc_kp.publicKey,
        user: anchor.getProvider().wallet.publicKey,
        systemProgram: SystemProgram.programId,
      },
      signers: [acc_kp]
    });
    console.log("Your transaction signature", tx);
  });

  it('can update price', async () => {
    const tx = await program.rpc.updatePrice(new BN(7862), {
      accounts: {
        priceAccount: acc_kp.publicKey,
        user: anchor.getProvider().wallet.publicKey
      },
      signers: [acc_kp]
    });
    console.log("Your transaction signature", tx);
  });
That would be how you'd use a PDA address, yeah (no Keypair.generate())
#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 8 // discriminator 
         + 8 // u64 for the price
         + 32// PubKey for the owner
        )]
    pub price_account: Account<'info, PriceAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}

******BECOMES*****

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, seeds = [b"crazy-seed-phrase", domain.as_bytes()], payer = user, space = 8 // discriminator 
         + 8 // u64 for the price
         + 32// PubKey for the owner
        )]
    pub price_account: Account<'info, PriceAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}
Is that how you do it?
actually I found this:
üëã is there a way to batch call the metaplex action `mintNFT`? E.g. instead of calling `mpl.actions
      .mintNFT` multiple times and having to approve the txn multiple times, i want to batch the instruction call
Basically I need to replace that first line with a acc_kp that is a PDA derived from a seed. I can't seem to find an example on how to do this..
Right that where I am now...

  const acc_kp = anchor.web3.Keypair.generate();

  it('Is initialized!', async () => {

    const tx = await program.rpc.initialize({
      accounts: {
        priceAccount: acc_kp.publicKey,
        user: anchor.getProvider().wallet.publicKey,
        systemProgram: SystemProgram.programId,
      },
      signers: [acc_kp]
    });
    console.log("Your transaction signature", tx);
  });

  it('can update price', async () => {
    const tx = await program.rpc.updatePrice(new BN(7862), {
      accounts: {
        priceAccount: acc_kp.publicKey,
        user: anchor.getProvider().wallet.publicKey
      },
      signers: [acc_kp]
    });
    console.log("Your transaction signature", tx);
  });
Yeah, but I think you still need to make sure that that user key is one you expect
then like this in the init:
pub fn initialize(ctx: Context<Initialize>) -> ProgramResult {
        let price_account = &mut ctx.accounts.price_account;
        price_account.price = 0;
        price_account.owner = ctx.accounts.user.key();
        Ok(())
    }
Oh derp was just about to type that‚Äîyep, that works
I had introduced an owner variable on the PriceAccount struct
~~The `.owner` of an account like the one you have above isn't what you think it is, it's the *program* that owns the account (so, your own program)~~
Almost
```.rs
#[derive(Accounts)]
pub struct UpdatePrice<'info> {
   #[account(mut, seeds = ["the-one-and-only-price-account"], bump)]
    pub price_account: Account<'info, PriceAccount>,

    #[account(address = SOME_KNOWN_ADMIN_ADDRESS)]
    pub user: Signer<'info>,
}
```
yeah nvm, figured this out
it will `console.log` the private key not the public key. You can put the output directly to phantom
I just tried it to double check and it works, the code: 
```ts
const kpArray = new Uint8Array(
    JSON.parse((await fs.readFile(process.env.KEYPAIR_PATH!)).toString())
  );

  const privateKey = bs58.encode(kpArray);
  console.log(privateKey);
```
And then make sure that the user.Key is the same PDA account that was used to make the program?
<@!134416332509675520> - So I can do something like this

#[derive(Accounts)]
pub struct UpdatePrice<'info> {
   #[account(mut, constraint = price_account.owner == user.key())]
    pub price_account: Account<'info, PriceAccount>,
    pub user: Signer<'info>,
}

#[account]
pub struct PriceAccount {
    pub price: u64,
    pub owner: Pubkey,
}
yeah thanks a lot! it should work!
ha lol
Answering catrovacer's question above
what do you mean double PDA?
Like, that's basically how you'd do it in Python haha
Yeah, the double PDA thing would work fine I think
yeah basically... thanks! i will think on this
I'll go break my head on that for a little while
Basically nothing really solana specific here, it's just a data structures problem
Alright thanks for pointing me in the right direction
I think you'd just have to use multiple PDAs for this, ["username", "qwerty"] --> a little account showing that qwerty is already taken, ["pubkey", asdfasdfasdf] -> a little account showing that that pubkey has already registered, etc.
<@!134416332509675520> Quite an old message lol. Is there anything i can do in anchor? or do i have to handle this in frontend only? Thanks!
but the problem was I didn't have lamports for the transaction...
Ah, no
Then I was trying something like this

  let seed = Uint8Array.from([70,60,102,100,70,60,102,100,70,60,102.....]);
  let accountFromSeed = anchor.web3.Keypair.fromSeed(seed);
But yeah, this would be better to do with a PDA and then have your instruction above only agree to init an account at that specific PDA address (so can only be done once)
Not wrong necessarily, just inconvenient
Which is obviously wrong.
anchor.web3.Keypair.generate(); is what I was using in my tests.
It's then up to you to write your program so that no one (or only some specific someones) can call any instructions that update that account
Very good, That's what I was looking for.
E.g. use a PDA with seeds = ["the-one-and-only-price-account"]
I don't want the price to be alterable by a bad actor and thus affect things.
Ok, then you'd just have to store that account at some address of your chosing
Yes sorry about that. I'm not 100% sure myself. 
So if I refine the question:

I need one PriceAccount That contains the price. I will then read this data from another program to make decisions.
Ok, what do you mean above by "(person)" then?
Yes. exactly!
Haha not sure what you're asking üòõ
Do you mean you only want there to exist one PriceAccount?
This is the code.
#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 8 // discriminator 
         + 8 // u64 for the price
         + 32// PubKey for the owner
        )]
    pub price_account: Account<'info, PriceAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct UpdatePrice<'info> {
   #[account(mut, constraint = user.key() == user.key())]
    pub price_account: Account<'info, PriceAccount>,
    pub user: Signer<'info>,
}

#[account]
pub struct PriceAccount {
    pub price: u64
}
Can you say more? What do you mean be "one person (account)"?
Really that matters less. I only want one person (account) to be allowed.
You can limit it to whoever you want‚ÄîI thought you wanted to limit it to the deployer of the program?
Who do you want to be able to update the state account?
So that's the update authority. Which correct me if I'm wrong affects the program. Does that also affect the state account?
Right, not there‚Äîlook at the rust side
https://github.com/project-serum/anchor/blob/master/tests/bpf-upgradeable-state/programs/bpf-upgradeable-state/src/lib.rs#L61
the test on line 107 I meant
Sorry, not line 107, that link you just posted üòõ
Yeah
Here? https://github.com/project-serum/anchor/blob/master/tests/bpf-upgradeable-state/programs/bpf-upgradeable-state/src/lib.rs
hmm, when I do this I get a different publickey than what's in my cli ü§î
Check out the rust half
line 107?
Basically, you force that one-and-only special person to sign the tx, and verify in your program that they did so
Right, that test has an example
<@!134416332509675520> - So I few things:
1 - I have no idea really what I'm talking about, so what I'm asking might not be possible.

2 - The problem I'm trying to solve is to have a piece of data in a state account (price) that can only be updated by one person.
This test has some examples of restricting access to the program creator: https://github.com/project-serum/anchor/blob/master/tests/bpf-upgradeable-state/tests/bpf-upgradable-state.ts
Think I'm not quite sure what you're asking‚Äîhow are you enforcing that only the program creator can invoke that instruction?
<@!134416332509675520> - Did you have a chance to check out my question? I'm sure I'm just not understanding something simple here... it's my first week on anchor/solana
How does one attach metadata to a regular spl-token (not nft) or is the process the same? I want things like symbol, name, pic etc.
Ah whoops üëç
The first half is actually the Private key.
Hey, not sure if u got an answer to this already, but as I understand it. The edition is a part of the metaplex standard that no one really uses or pays attention to. All nfts have a master edition, and for most that‚Äôs all they have.

However, metaplex does support creating any number of editions (other versions of the same nft) for any particular master edition. Editions have their own token mint but I believe the metadata is the same?

I haven‚Äôt looked in to this in a while, so I‚Äôm fuzzy on the details, but i hope that clarifies something.
and put it to Phantom
yeah you can ```ts
console.log(privateKey)
```
The private key is just half of the keypair.json file (think the second half)
<@!185605576162672641> Here you go:

#[account]
pub struct PriceAccount {
    pub price: u64
}
will this out, thanks!
yep
```ts
import * as bs58 from "bs58"
const privateKey = bs58.encode(bytesFromJSON)
```
Are you using the Phantom `Add / Connect Wallet` thing?
you need to convert the bytes into `base58`. You can `yarn add bs58` or `npm i bs58`
I have a keypair generated via the solana cli (stored in `~/my-solana-wallet/my-keypair.json`). Any easy steps to import this into phantom or any other online wallet? I've tried importing the output of `cat ~/my-solana-wallet/my-keypair.json` but that doesn't seem to work
oh that's interesting. Any reason why that might be the case?
thanks for the quick answers!
`program.instruction.initializeTokenAcct`, then add that instruction to a tx
Interestingly, this doesn't work (I thought it did too, but surprisingly it doesn't)‚Äîfailed CPIs immediately halt the whole transaction, without any way to recover from them (so their Result-y type is a lie lol, you can't actually match on it etc.)
yes you can call `program.instruction.initializeTokenAcct` and it will return `Instruction`
E.g. something like:

```
const transaction = new Transaction()

transaction.add(
  SystemProgram.createAccount({
    fromPubkey: payer,
    newAccountPubkey: mintAccount.publicKey,
    lamports: balanceNeeded,
    space: spl.MintLayout.span,
    programId: spl.TOKEN_PROGRAM_ID,
  }),
);

transaction.add(
  spl.Token.createInitMintInstruction(
    spl.TOKEN_PROGRAM_ID,
    mintAccount.publicKey,
    0,
    authority,
    authority,
  ),
);

await program.provider.send(transaction, [...]);
```
üëã suppose I my own program instruction: 

`program.rpc.initializeTokenAcct` and I want to call this multiple times. Is there a way to add this all into one transaction?
Can you provide the account struct for your update price instruction?
Hello I have a very simple question and I think the answer is too simple that I must be missing some fundamental concept here...

I have a program. this problem defines a priceAccount. The priceAccount has one properpty, the price. I can init this without a problem and I get a program Id to confirm that we are deployed to devnet. 

Next I have another instruction to update the price. I want this defined that only the owner of the program is allowed to update the price. I've tried to load the wallet of the program owner from the seed, but nothing seems to be working. 

When I look at the program account data I do have a ProgramData Address. This public key is not something that I've created and I don't know how I can get the private key of this account. In any case I don't think there are any lamports in the PDA account to be able to update the price anyways... 

where is my logic wrong?
Changing my provider commitment from `recent` to `finalized` fixes the issue, if anyone know why that would break Jest but not Mocha, I'd love to know
<@!222259920727310336> can't you just handle the `ProgramResult` from a CPI call?
hi everyone I have a somewhat basic question - is there a way to recover my instruction context given a transaction hash? I know we can do this manually by parsing accountKeys and comparing the order but that doesn't strike me as the best way to do this. It is very easy to decode arguments outside of the instructionContext using BorschInstructionCoder but I can't put my finger on how to map the accounts to the expected values in IDL other than manually
anyone faced this before?
`anchor deploy` is giving me this error 
```Blockhash expired. 5 retries remaining
Blockhash expired. 4 retries remaining```
It is a chain of errors that's happening
Context for this: The IDL for the Swap program is out of date in the SDK and I want to rebuild it from the program directly
~~Having trouble building the Serum Swap program from source. I've run `rustup` like it says in the guide, but having difficulties with building the DEX subdependency on this command:
```
cd deps/serum-dex/dex/ && cargo build-bpf && cd ../../../
```
`cargo build-bpf` keeps failing, do I need to install a utility globally for this to work?~~

Edit: Oh man, didn't have Solana Tools CLI installed, <a:smh:883157005571866674>
For anyone that has used Jest for testing, have you had issues with `Account does not exist`? 

The test work fine with chai.  When querying the blockchain, the account exists. It seems like it is an async issue specifically with Jest trying to fetch account data before it is confirmed on chain
very confused here, would appreciate any explanation of ^^
Solution:
```
#[account(
        init,
        payer = payer,
        seeds = [b"nfttracker".as_ref()],
        bump,
        space = 1200 // 24 * 32 * 2 to store accounts + some extra in case
    )]
```
Removing the `.as_ref()` in the seeds declaration fixes this ‚ùì
Will preface that this was happening after running an `anchor deploy`
üëã getting:

```
Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account 
    Program GpLZRedGz2uNoFXo24UxxfQivDvw3xSHzdGhTYFFKdSC invoke [1]
    Program log: Instruction: InitializeTracker
    7na4Cw6JrvoY5erxT4bA48kvDKR9LNs5adFCpMSgvn7e's signer privilege escalated
    Program GpLZRedGz2uNoFXo24UxxfQivDvw3xSHzdGhTYFFKdSC consumed 14831 of 200000 compute units
    Program GpLZRedGz2uNoFXo24UxxfQivDvw3xSHzdGhTYFFKdSC failed: Cross-program invocation with unauthorized signer or writable account
```
Program ID is correct, the PDA seed is correct, honestly not sure what the issue is here üò¶


//////////////////////////////////////////////////////////////////////////////////////////

the error is occuring in  ` sendAndConfirmTransaction()`
```js
 // let toAccount = web3.Keypair.generate();

      // const opts = {
      //   preflightCommitment: "processed",
      // };
      
      // const connection = new Connection(network, opts.preflightCommitment);

      const instruction  = w3.SystemProgram.transfer({
        fromPubKey: walletAddress,
        toPubKey: toAddress,
        lamports: LAMPORTS_PER_SOL
      });

      let payer = w3.Keypair.generate();
      console.log(payer)
      walletAccountInfo = await connection.getAccountInfo(payer.publicKey);
      console.log(walletAccountInfo)

      // let trans = await setWalletTransaction(instruction);
      let transaction = new Transaction();

      transaction.add(instruction)

      console.log(transaction, connection, baseAccount)
      console.log(walletAddress.toBase58())
      const signature = await sendAndConfirmTransaction(connection, transaction , [walletAddress])

      console.log("signature", signature);
      const balanceAfterPay = await connection.getAccountInfo(walletAddress);
      console.log("Balance after payment ",walletAccountInfo.lamports); ```
post peace of code which is throwing that
guys im getting this error
``` Couldnt pay  TypeError: Cannot read properties of undefined (reading 'toBase58')
    at transaction.ts:262:1
    at Array.sort (<anonymous>)
    at Transaction.compileMessage (transaction.ts:261:1)
    at Transaction._compile (transaction.ts:379:1)
    at Transaction.sign (transaction.ts:474:1)
    at Connection.sendTransaction (connection.ts:3886:1)
    at async sendAndConfirmTransaction (send-and-confirm-transaction.ts:30:1)
    at async payUser (App.js:230:1) ```
wasn't sure if that check was automatic
btw no need to add `owner = crate::ID` to `AccountLoader`
looks like idl got corrupt actually that may have been the problem
deleted the idl and regenned, same problem
but problem with deployment still exist üò¶ just get error  Error: Custom: Invalid blockhash
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.
oh, find, sorry
if i set "mut" for account whoch payer, i get error from compiler...
hey guys, i'm using achor 0.22.1 and solana-cli 1.9.12, when i do anchor build i get error at the end: thread 'main' panicked at 'Code not parseable: Error("the payer specified for an init constraint must be mutable.")', lang/syn/src/idl/file.rs:357:58 but my program compiled When i try to deploy it i get an error: Error: Custom: Invalid blockhash WHich problem??
ah damn, okay will have to look for a better way to test then, thanks
The validator itself doesn't expose a way to warp time as far as I know
The idea is that you just don't use an actual validator, you use a pure rust test
Ah, sorry, you'll have to run the whole test in rust
interesting, guess I can expose a test only instruction in my program to call this?
https://docs.rs/solana-program-test/latest/solana_program_test/struct.ProgramTestContext.html#method.warp_to_slot
Not that I know of. You can do it with the solana-program-test crate though
Is there a way to advance time in the test validator using anchor in an integration test?
Thanks got it working
Often happens because you ran out of space for that account
What does this error means
Error Code: AccountDidNotSerialize. Error Number: 3004. Error Message: Failed to serialize the account.
Are you sure you're using the latest version of the IDL in your client code?
Error Number: 3004
https://github.com/project-serum/anchor/issues/1157
wtf ? maybe try downgrading to lower version help? 
sh -c "$(curl -sSfL https://release.solana.com/v1.8.14/install)"
Thanks will check out
You would just do it all in javascript using solana's version of web3.js: https://spl.solana.com/token
I‚Äôm pretty new to solana and come from a background of solidity, so it‚Äôs pretty confusing for me
Then how can I do this?
If they pay them directly then it doesn't involve your smart contract.
tried marking every account `mut` and fails as well??
```rust
#[derive(Accounts)]
pub struct StartOrder<'info> {
    #[account(mut)]
    pub prism_etf_mint: Account<'info, Mint>,

    /// The Prism ETF [Account] that describes the assets being purchased
    #[account(seeds = [b"PrismEtf".as_ref(), &prism_etf_mint.key().to_bytes(), &beamsplitter.key().to_bytes()], bump = prism_etf.bump, has_one = weighted_tokens)]
    pub prism_etf: Box<Account<'info, PrismEtf>>,

    #[account(mut, seeds = [b"OrderState".as_ref(), &prism_etf_mint.key().to_bytes(), &orderer.key().to_bytes(), &beamsplitter.key().to_bytes()], bump = order_state.bump, has_one = transferred_tokens)]
    pub order_state: Box<Account<'info, OrderState>>,

    #[account(owner = crate::ID)]
    pub weighted_tokens: AccountLoader<'info, WeightedTokens>,

    #[account(owner = crate::ID, mut)]
    pub transferred_tokens: AccountLoader<'info, TransferredTokens>,

    /// The [Signer] of the tx and owner of the [Deposit] [Account]\
    pub orderer: Signer<'info>,

    /// The [TokenAccount] that recieves the Basket Tokens
    #[account(mut, associated_token::mint = prism_etf_mint, associated_token::authority = orderer)]
    pub orderer_etf_ata: Box<Account<'info, TokenAccount>>,

    /// The [Beamsplitter] [Account] that holds all of the Program's funds
    pub rent: Sysvar<'info, Rent>,

    #[account(
        seeds = [
            b"Beamsplitter".as_ref(),
        ],
        bump = beamsplitter.bump,
    )]
    pub beamsplitter: Box<Account<'info, Beamsplitter>>,

    pub associated_token_program: Program<'info, AssociatedToken>,

    pub token_program: Program<'info, Token>,
    /// The [System] program.
    pub system_program: Program<'info, System>,
}
```
instruction is empty still failing
it's a pda for ref, don't think that makes a diff though
is this a known bug
before it worked but state did not persist (obv), but after adding mut it errors out??
weirdly arises after I added mut to one of my accounts
getting 0x7d0 or 2000 : "A mut constraint was violated" but all accounts changed are marked mut
what if the user has to pay some money to another user
The CPI chapter in the anchor book (https://book.anchor-lang.com/chapter_3/CPIs.html) and a contract that uses the token program, such as https://github.com/ironaddicteddog/anchor-escrow/blob/master/programs/anchor-escrow/src/lib.rs
Are there any resources I can refer to?
Yes using anchor smart contract
Using an anchor smart contract? You'll want to use the anchor_spl crate to interface with solana's token program
Thanks
Are there any resources?
Guys how to transfer money from one account to another account using solana?
I think you want a default = [‚Äúcpi"]
It seems to have changed recently because the book makes no mention of additional changes being necessary
Yeah I have to do that too, but the default value of `cpi = ["no-entrypoint"]` prevents it from working with just that addition
in anchor.toml
```
[dependencies]
anchor-lang = { version = "0.22.1", features = ["init-if-needed"] }
```
this is how i enable the init if needed, might be the same?
How do I enable cpi in the `[features]` section of the cargo.toml of the callee? The defalt is `cpi = ["no-entrypoint"]` but I'm not sure what to change it to.
https://github.com/project-serum/anchor/issues/1157
anyone had successfuly deployed on devnet recently? what version of cli are you using?
Best way to parse Base64 data?
and ... keep failing again
init_if_needed doesnt skip the seed checks right?
Or you can just run it locally, with an actual live solana-test-validator in the background
Oh, lol, yeah
i was thinking just run the test on devnet
You mean clone it from devnet?
ok then devnet?
Not sure you can tbh
ok, so in my test I should just create that account
If you let anchor spin up a test for you, the "genesis" stuff it/solana does doesn't use the upgradeable loader at all
Unfortunately, depending on how you run your tests, you might not actually have an account that lives there
I was trying the admin setting setup from the tests:
```rust
#[derive(Accounts)]
pub struct AdminSettingsInit<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    #[account(init, seeds = ["admin".as_bytes()], bump, payer = payer)]
    pub admin_settings: Account<'info, AdminSettings>,
    #[account(constraint = program.programdata_address() == Some(program_data.key()))]
    pub program: Program<'info, crate::program::MyProgram>,
    // only the program update authority can initialize the admin settings account
    #[account(constraint = program_data.upgrade_authority_address == Some(payer.key()))]
    pub program_data: Account<'info, ProgramData>,
    pub system_program: Program<'info, System>,
}
```
I'm using this, but getting `Error Code: AccountNotInitialized`:
```js
    const [programData] = await anchor.web3.PublicKey.findProgramAddress([
      program.programId.toBuffer()
    ], new anchor.web3.PublicKey("BPFLoaderUpgradeab1e11111111111111111111111"));
```
is there a convenience method for the program data address?
https://github.com/project-serum/anchor/blob/master/lang/src/error.rs#L91
I'm getting `Runtime error: custom program error: 2015` when I try to execute my transaction, can I read somewhere what this means?
Thanks <@!134416332509675520> !
Ok, thanks!! I will try to do that
Try searching the anchor repo for `close =` for a bunch of examples
You'll need a whole separate instruction to close the account
No, in the derive(Accounts) for a separate instruction
Where do you use that attribute? When you run the app in the terminal?
ah! I didn't know that
Anchor has a `close = who_to_send_the_rent_to` attribute you can use
You'd have to close the account
yes
What does the PDAness of the address have to do with this?
So you want to be able to create it all over again?
Since it is a PDA, I don't find the way to have the app in the same state like in the beginning.
In the counter example, first you need to create the counter and then you can increase the value. I would like to find a way to start again with the process (creating the counter) to check some UX/UI stuff in the frontend.
Why wouldn't you be able to reset it to zero?
yes
How do you want to reset it? Not sure I'm understanding your question (you can of course have a separate instruction that resets the count to zero)
(Sorry, think I'm misunderstanding your question‚Äîreading again)
Ok, I will try to check that again because I expect the same too. Another question, let imagine I have a counter in a PDA Dapp, and the state at this moment is higher than 0 ( I've clicked the counter already a few times... ), is it possible to reset that counter? I mean with this to reset the state to the initial status.
I would definitely not expect validator state to be the same across separate clones of the same repo
But if you copied it over, it might work
I doubt that test ledger is in your git repo
Even cloning the project in another folder the ledger is the same?
Inside `.anchor/test-ledger`
Because I think the ledger is living right in your original folder, at least I think
```account.ts:154 Uncaught (in promise) Error: Account does not exist DWJaZaa8xh8PRTS2ts3i1vJi8ua4ku934z1jDkkTHuys```
I can explain it on another way. I have that project running, and as a PDA the state is persisting as I was expecting. ( running anchor build, anchor deploy and solana-test-validator). When I clone the project to another folder, If i do the same process I get that error:
All have to go in the #[program] module
Sounds like you want to just run a persistent validator? Or maybe you could restart the validator with an explicit ledger options (`solana-test-validator --help`)
can you put instructions in separate modules and import into the program module or do all instructions for a program have to be defined in the program module?
ah thanks, I forgot about that
<@!134416332509675520> do you have any suggestion for this? üôÇ
https://docs.rs/anchor-lang/latest/anchor_lang/prelude/derive.Accounts.html#instruction-attribute
How do I access instruction arguments in the accounts list struct attributes, e.g. for a user-defined seed in seeds=[...] when initializing a PDA?
possibly with the way things got packed together for the i32 it meant that a later test (which was just missing some inputs into the struct) was making it through
so it's not catching things there
I think the typescript code is a lil confused all around because of the Uint8Array -> [u8; 32] conversion
Yeah, is this definitely not weird? I'm not sure why you'd get a instruction deserialization error
weird that the i32 is working then!
Haha üòÅ
ü§¶‚Äç‚ôÄÔ∏è I'm going to go and sit in the shame corner
ahhh, I think I'm being incredibly dumb, and this is having an impact on an unrelated test
```
   60 #[derive(Clone, AnchorSerialize, AnchorDeserialize)]
   61 pub enum AccessType {
   62     Ardrive,
   63     Url,
   64     Pda,
   65 }
```
How is AccessType defined?
Ok I'm currently baffled by this a little. If I have a struct like this that I'm using as one of the function command inputs (ie `ext_append(ctx, data: ExtAppendData)`:
```
  436 #[derive(AnchorSerialize, AnchorDeserialize, Clone)]
  437 pub struct ExtAppendData {
  438     pub timestamp: i64,
  439     pub data_hash: [u8; 32],
  440     pub prev_hash: [u8; 32], 
  441     pub new_hash: [u8; 32],
  442     pub access_type: AccessType, 
  443     pub id: [u8; 32],      
  444 }
```

I get a 102 instruction deserialization error.

If I replace the `AccessType` with an `i32` it goes away. `String` has the same error. I thought enums had a well defined size? It's recognizing the enum on the typescript size, I get a different error when that is incorrect. Is there something else I need to do here so I can use a struct as a function argument?
sorry i should've specified rust client here. updated message to reflect this
well, I've created a repo with the code of this article https://www.brianfriel.xyz/understanding-program-derived-addresses/ . I run `anchor localnet` and the project is running, but if I stop that command in the terminal and I try to run it again, I get that error saying that the account is does not exists.
What do you mean by reset?
Is there a way to reset a PDA every time I start run the project.
```account.ts:154 Uncaught (in promise) Error: Account does not exist DWJaZaa8xh8PRTS2ts3i1vJi8ua4ku934z1jDkkTHuys```
Working with a PDA in localhost, if I stop the `anchor lotalnet`  and I try to run the program, I get this error:
Thank you, I think that is what I need
Sort of‚Äîsol itself isn't an spl token, so it doesn't strictly speaking have a mint, but there's the idea of "wrapped sol", which is exactly what you're talking about: a tokenized version of sol: https://explorer.solana.com/address/So11111111111111111111111111111111111111112
Is there a mint address that represents SOL? Would that make any sense?
any examples for writing a rust client for listening to a variety of events emitted from an anchor program?
okay i understand.. thanks! I just might have nudged you in multiple servers and channels. sorry about that üòÖ !
https://docs.rs/anchor-lang/latest/anchor_lang/prelude/derive.Accounts.html#instruction-attribute
But I don't think it has anything to do with deploy success/failure (IDL is an anchor-specific thing, and solana deploy doesn't care about it)
What does the `#[intruction()]` macro do?
I actually don't know why anchor sometimes decides to write the metadata section or not (I see where it happens in the code, but I don't know why we write/don't write it etc.)
is there any recommended anchor/solana cli/rust version people need to use for anchor build to work properly? I read somewhere solana-frozen-abi package and solana-cli should be the same version. a few weeks back `anchor build` was populating the metadata address.. It is not anymore (I might have changed the solana cli version somewhere in the middle)
Call `.to_account_info()` on it
Im trying the escrow program and it gets error using cpis (using Signer<'info>) idk much about that
Not much, `Signer` is a little bit nicer since it conveys the signer-ness right in the type
What is the difference between...? :
-------------------------------------
#[account(mut, signer)]
pub initializer: AccountInfo<'info>
-------------------------------------
#[account(mut)]
pub initializer: Signer<'info>
https://github.com/drift-labs/protocol-v1 has a bunch of examples
Anyone haver an example project of an Anchor program split into multiple files? Particularly with a state.rs file
is this something related with the new version?
stuff is not in the `.../idl/<projectname>.json` file after `Anchor build` ?
```"metadata": {
    "address": "Cco9Jh1g8w86iu1qzGYsLXuJKqoZMVGoaHE5yteLUbmF"
  }```
Hi everyone. A question about building in Anchor. Why the :
I tried to manually re-create the solution from anchor according to https://github.com/project-serum/anchor/pull/1363/files

```
export declare class CustomWallet extends NodeWallet {}
``` 

But calling `new CustomWallet(keypair)` still doesnt work... any idea what i could try next?
added some better error msgs here https://github.com/project-serum/anchor/pull/1603. Feel free to check out the PR already and tell me if it helped
This returns a keypair tho, right?
The key, judging by reading the code
Do you guys have an example of how is usually `anchor publish` run ? I think it fails to read a file


//////////////////////////////////////////////////////////////////////////////////////////

awesome, thanks for the clarification
The question mark is indeed what triggers the short-circuiting you want (so you need it)
i was getting a warning when trying to call it, i guess i left off the ?
What goes wrong?
here's another way i was trying: 
`pub fn verify_something2 (program_id: &Pubkey, account : &AccountInfo) -> Result<()> {
    if true { 
        return Err(error!(MyErrors::BadInput));
    }
    Ok(())
}`
That looks good so far, how are you using it?
`pub fn verify_something (program_id: &Pubkey, account : &AccountInfo) -> std::result::Result<(), ProgramError> {
    if true { 
        return Err(MyErrors::BadInput.into());
    }
    Ok(())
}`
What have you tried so far?
I'm trying to find an example of a sub function that returns an error (and stops the program) similar to the way you use return Err(error!(MyErrors::BadData)) in a main function.
Got it. This is helpful. Thanks a lot.
https://github.com/cqfd/quidproquo
<@!134416332509675520>
Yeah, guess so‚Äîat any rate, you won't have any way to asynchronously burn someone else's tokens
Oh great and burn issue will still exist. SO then use pda for token account instead of trader token account?
No, just the CHECK stuff
Unable to get beyond the 3007
Can someone share an example of a token transfer contract and client?
Yep
Ah I see. So make RPC call on chain.  Get the data and then make accounts from pubkey. Then call contract
It's definitely annoying to not be able to do it in a single request, but it's certainly possible to do it in 2
You can fetch that info from the chain, figure out which accounts are relevant, and *then* make your request to your contract
Yeah I feel our design may be not congruent with Solana paradigm.
Basically, when a match happens on OrderBook, we wont have accountinfo of token account. We will have all the info needed to get to it but it is all on chain. 
And IIRC i cant pass accountinfo of all traders via frontend cause there is a limit of how many you can pass.
I think I would need to take deeper dive into  how serum solved it. Probably will need 2-3 on chain programs to handle this. 
A nice thing would be to get pda account from key and seeds on chain (if program is the authority /owner) and write to it.
Thanks for indulging cqfd
that has other effects though right
anchor build --skip-lint
Is there anyway to ignore the ///CHECK errors?
but like alan said, you already have a key so no need to call `key()` anyway
fix is already merged, will be fixed with next release
It's a bug, yeah
Yeah, that could work
If this is the fix, why was it not an error in 0.20.1 but its an error in 0.21.0
Like so?
`    #[account(
        init,
        payer = initializer,
        mint::decimals = 9,
        mint::authority = long_mint_account,
        seeds = [
            oracle_asset_key.as_ref(),
            &expiry.to_le_bytes(),
            &strike.to_le_bytes(),
            &strike_exponent.to_le_bytes(),
            b"long"
        ], 
        bump = long_mint_bump
    )]
    pub long_mint_account: Account<'info, Mint>,`
But yeah, if you want to programmatically burn tokens (via program control), the way you'd do that is with a separate token account whose authority is a PDA
Just get rid of the `key()` thing, you've already got one apparently
Mm, not sure I understand your use case well enough, but sure, you could have another PDA to store tokens
Hi, Im running into and error that looks like this
```
error[E0599]: the method `key` exists for struct `anchor_lang::prelude::Pubkey`, but its trait bounds were not satisfied
   --> programs/squeeth/src/lib.rs:522:38
    |
522 |             vault.load()?.identifier.key().as_ref()
    |                                      ^^^ method cannot be called on `anchor_lang::prelude::Pubkey` due to unsatisfied trait bounds
    |
   ::: /Users/philpang/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-program-1.10.0/src/pubkey.rs:71:1
    |
71  | pub struct Pubkey(pub(crate) [u8; 32]);
    | ---------------------------------------
    | |
    | doesn't satisfy `_: AsRef<anchor_lang::prelude::AccountInfo<'_>>`
    | doesn't satisfy `anchor_lang::prelude::Pubkey: anchor_lang::Key`
    |
    = note: the following trait bounds were not satisfied:
            `anchor_lang::prelude::Pubkey: AsRef<anchor_lang::prelude::AccountInfo<'_>>`
            which is required by `anchor_lang::prelude::Pubkey: anchor_lang::Key`
```
after updating to 0.21.0. Ive seen other people running into this when searching the channel but non of their solutions worked for me
store what? We are storing sol in the escrow pda. Are you saying we store tokens there too?
Yeah, store them in an escrow token account whose authority is a PDA derived from your program
program owns the mint
like trader is the one that owns the assco token account
yes. Is there a way?
Sounds like you want those tokens to be under control of the program, not the trader
(Sorry, more dumb questions) which tokens are you burning?
well not 'just'. Is a big issue
just this issue
GUi etc is coming fine
Also 4 days before hackathon submission and we are scrambling üò¶
but we got stuck cause burn requires signature of trader
Alas no. Cause matching will happen on chain. SO will know the pubkey of the account on chain. How to get account from there will be the problem. I think we tried emitting the pubkey and converting into account.
The front end doesn't know which account?
yes but front end does not know the account and even if i could some how (using emit/event etc) I cant burn tokens without trader signature. Can I?
Ah, ok, yeah, you would need to pre-emptively fetch that order book account on the client and then use it to pass in the right accounts (definitely annoying)
so i was thinking to use pubkey of traders to make pda and write to that. But i still have the issue of missing accountinfo.
But at that time i  do not have account info of those two matched traders. I have their pubkey
So trying to do a binary option type of platform. The sample code in solana repo uses long_token_min and short-token_mint as a way to track the options in a user account. That is a cool way of doing this. But they pass both seller and buyer's accountinfo in the instruction.
I can't do that cause I don't know who buyer and seller are. Traders come. Enter order. Order sits in a orderbook (Vec) and matching happens when price matches. At that point i would like to  mint tokens to the two matching counter parties
Like, how else is your program getting invoked?
Can you say more about what's not working? Reading your question again, I think I'm not sure what you mean by when the user has "disconnected" from the program
üôÇ . ofc. That has been a pain point in designing the async app. Will necessitate postgresdb etc which i was hoping to avoid.  Or use pda as data stores and pay up lamports.
was hoping to use mint and burn tokens as db solution but that is not possible without accountinfo.
And there is no way to save accountinfo or a transaction on chain for later execution (when cerayin conditions are met)
No, you always need to pass in from the client any accounts you want to use
A noob question. To access account and write to it we need accountinfo to be passed from front end.
But can we use pda on chain to get account that we can write to (as in not accountinfo passed from front end).
Need a place to store data and change it after the user has disconneceted from program
Full variable name (it's just an expression that gets injected during codegen)
is there a shorthand ie ("this", "self", etc) in the constraints or do you have to use the full variable name?
you can also use `address` on the target instead of constraint. thats a little less verbose
yea the name isnt great. we'd be very happy to adjust the name. just havent found anything so far that encapsulates its function
ok I agree as well. constraint is a lot easier to read.  has_one seems like it was created by someone that wasn't a native/fluent english speaker (no offense). To me the phrase "has_one" means that the object has one (and only one) of something.
Personally I find the `constraint =` version easier to understand so I just use that one ü§∑‚Äç‚ôÇÔ∏è
Yep https://github.com/project-serum/anchor/blob/master/lang/syn/src/codegen/accounts/constraints.rs#L199
is has_one = whatever @error::xyz equivalent to constraint = this.whatever == whatever.key() @error::xyz ?
gm! I'm trying to deploy my first program with anchor, and I'm getting this error (an issue search in github didn't lead me to anything). Does anyone have any idea what I'm doing wrong here?

``` ‚ûú  myepicproject anchor deploy
Deploying workspace: https://api.devnet.solana.com
Upgrade authority: /Users/hugomn/.config/solana/id.json
Deploying program "myepicproject"...
Program path: /Users/hugomn/workspace/hugomn/solana/myepicproject/target/deploy/myepicproject.so...
=======================================================================
Recover the intermediate account's ephemeral keypair file with
`solana-keygen recover` and the following 12-word seed phrase:
=======================================================================
cat tunnel tunnel speed type rival journal hair coach report false bored
=======================================================================
To resume a deploy, pass the recovered keypair as the
[BUFFER_SIGNER] to `solana program deploy` or `solana write-buffer'.
Or to recover the account's lamports, pass it as the
[BUFFER_ACCOUNT_ADDRESS] argument to `solana program close`.
=======================================================================
Error: Deploying program failed: Error processing Instruction 1: custom program error: 0x1
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.
```
I thought that might be wishful thinking üòá
No (no way to do that in a general way)
are methods implemented on accounts in the program generated in the typescript client>
in case you weren't sure, i don't see it in the solana explorer either (not a solution just letting you know in case u thought its unique to your network)
hello! what's the preferred way of importing an idl into a client using typescript? i'm getting an incorrect type error when i try to initialize a new Program instance
can someone help me out here?
hey guys, I tried to deploy and it says success:

```
 $ÓÇ∞ anchor deploy --program-name 7xurYiJYztaosgqyCdtKer5MDmgJJHn2gPdtUthUXs6n
Deploying workspace: https://api.devnet.solana.com
Upgrade authority: /Users/0xonizuka/.config/solana/id.json
Deploy success
```

but why I can't see it in the Solana Explorer: https://explorer.solana.com/address/7xurYiJYztaosgqyCdtKer5MDmgJJHn2gPdtUthUXs6n?cluster=devnet
I was looking here but didnt find a list.
thanks! üôÇ
Think you want `connection.getTokenAccountsByOwner`
without iterating through all SPL-tokens, and making an RPC get-request every time
is there an easy way to get all the tokenAccounts that the user holds in his (phantom) wallet?
try solana 1.8.12
I think when you get bump we use account variable name instead of local variable name (comment instead of comment_account)
umm... what is the significance behind this?
```Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account
    Program 3NcczXqNpzUsp6c2pGqLNJMnUwScvZBXduj8f3sg6Qdz invoke [1]
    Program log: Instruction: AddComment
    GzStgSSy82mYhc847W871fkuQNuzGLtRqiuHkEPTzwMP's signer privilege escalated
    Program 3NcczXqNpzUsp6c2pGqLNJMnUwScvZBXduj8f3sg6Qdz consumed 15756 of 1400000 compute units
    Program 3NcczXqNpzUsp6c2pGqLNJMnUwScvZBXduj8f3sg6Qdz failed: Cross-program invocation with unauthorized signer or writable account
    1) can create comment```

new error
can you try `comment_account.bump = *ctx.bumps.get("comment").unwrap();`?
can anyone help?
I dont understand where I am going wrong
```rust
#[derive(Accounts)]
pub struct AddComment<'info> {
    #[account(init, seeds=[b"vibe_comment", commentor.key().as_ref(), vibe.key().as_ref()], bump, payer = commentor, space = Comment::LEN)]
    pub comment: Account<'info, Comment>,
    #[account(mut)]
    pub vibe: Account<'info, Vibe>,
    #[account(mut)]
    pub commentor: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[account]
pub struct Comment {
    pub vibe: Pubkey,
    pub commentor: Pubkey,
    pub comment: String,
    pub bump: u8,
}
```
endpoint
```rust
    pub fn add_comment(ctx: Context<AddComment>, comment: String) ->  Result<()>  {
        let comment_account = &mut ctx.accounts.comment;
        let commentor = &mut ctx.accounts.commentor;
        let vibe = &mut ctx.accounts.vibe;

        if comment.chars().count() > 150 {
            return Err(ErrorCode::CommentTooLong.into())
        }

        comment_account.vibe = vibe.key();
        comment_account.commentor = *commentor.key;
        comment_account.comment = comment;
        
        comment_account.bump = *ctx.bumps.get("comment_account").unwrap();

        vibe.comments += 1;

        Ok(())
    }
```
Test
```ts
it("can create comment", async () => {
        const vibe = anchor.web3.Keypair.generate();
        const author = program.provider.wallet;

        await program.rpc.createVibe("New Vibe", "Comment to be Added", {
            accounts: {
                vibe: vibe.publicKey,
                author: author.publicKey,
                systemProgram: anchor.web3.SystemProgram.programId,
            },
            signers: [vibe],
        });

        const [commentAccount, _] = await PublicKey.findProgramAddress(
            [
                anchor.utils.bytes.utf8.encode("vibe_comment"),
                author.publicKey.toBuffer(),
                vibe.publicKey.toBuffer(),
            ],
            program.programId
        );

        await program.rpc.addComment("New Comment", {
            accounts: {
                comment: commentAccount,
                vibe: vibe.publicKey,
                commentor: author.publicKey,
                systemProgram: SystemProgram.programId,
            },
        });

        const createdVibe = await program.account.vibe.fetch(vibe.publicKey);
        const createdComment = await program.account.comment.fetch(
            commentAccount
        );

        assert.equal(
            createdComment.commentor.toBase58(),
            author.publicKey.toBase58()
        );
        assert.equal(createdComment.comment, "New Comment");
        assert.equal(createdVibe.comments, 1);
    });
```
New day new error
```
Transaction simulation failed: Error processing Instruction 0: Program failed to complete
    Program 3NcczXqNpzUsp6c2pGqLNJMnUwScvZBXduj8f3sg6Qdz invoke [1]
    Program log: Instruction: AddComment
    Program 11111111111111111111111111111111 invoke [2]
    Program 11111111111111111111111111111111 success
    Program log: panicked at 'called `Option::unwrap()` on a `None` value', programs/solvibe-social/src/lib.rs:100:66
    Program 3NcczXqNpzUsp6c2pGqLNJMnUwScvZBXduj8f3sg6Qdz consumed 19383 of 1400000 compute units
    Program failed to complete: BPF program panicked
    Program 3NcczXqNpzUsp6c2pGqLNJMnUwScvZBXduj8f3sg6Qdz failed: Program failed to complete
    1) can create comment
```

I am trying out Anchor v0.22.1 and this error is occuring for some reason
borsh.io
anyone have a quick reference to the space each data type takes up?
`use anchor_lang::prelude::*`. Should just be `use anchor_lang::error_code`. This will fix it https://github.com/project-serum/anchor/pull/1610
Anyone know what I need to import in order for the #[error_code] instruction to compile?
ah, thanks
https://docs.rs/anchor-lang/latest/anchor_lang/prelude/derive.Accounts.html#spl-constraints
Thanks. Where in the anchor docs can I find the attribute arguments like `mint::decimals` needed to initialize accounts like Mint?
perfect, thanks!
Yeah
like the one in `target/deploy/<program_name>_keypair.json`
ok and the runtime program_id is determined by the program's associated keypair, right?
No, you do need to change it‚Äîit needs to exactly match your actual runtime program_id
so when i deploy a project to mainnet, i dont have to bother changing that default address? it'll just create a new random one for me and deploy the program to that?
Hmm, don't think anchor has an option for that, as far as I know‚Äîyou just need to change it yourself once you make your own keypair
yeah
You mean the Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS one?
how does one change the default deployment address that anchor generates for you when you create a new program?
The spl token program isn't an anchor program, so no discriminator. Also, if you want you can just let anchor make the mint for you: https://github.com/cqfd/anchor-token-studies/blob/main/programs/token-studies/src/lib.rs#L95
Oh actually I see there's a `Mint::LEN` property that I think gives me what I need. Would I need to add 8 for a discriminator or does anchor not add a discriminator to Mint accounts?
Or do I leave it up to the initialize_mint CPI to create the account and just pass it a PDA that hasn't been created yet?
I'm trying to create a program-owned token mint from within a smart contract. When creating the Mint account from a PDA, how much space do I need to allocate?
yes ) last 1.8 release work
For a quick solution I had to downgrade solana to `1.8.14`  and it worked like a charm for me. Try downgrading it and deploy again
Any reason not to store all data in JSON string that I can pass  and desearialize locally and then deserialize on Solana when necessary?
```let signedTrans = await window.solana.signTransaction(trans);``` I am using this now, but still im getting the same error...
i need the user to sign the transaction using phantom wallet
i am probably missing something out,  you may construct a new PublicKey object then toBase it if that is what u desire
```js
   const connectWallet = async () => {
    const { solana } = window;

    if (solana) {
      console.log("Wallet is found");
      const response = await solana.connect();
      console.log("Key is: ", response.publicKey.toString());
      console.log(response)
      setWalletAddress(response.publicKey);
      setWallet(response);
    }
  }; ```
the walletAddress is the public key i recieved when i connected the wallet
.toBase58() does not exist for walletAddress
guys can anyone help me solve this problem?


//////////////////////////////////////////////////////////////////////////////////////////

Any tips on how to debug `AccountDidNotDeserialize` errors? I added an account to a struct and now when I try to execute that instruction it states that it can't deserialize the account. There are other cases that seemingly look identical where things work as expected

```
    Program 6mn7W95E1C3SPn8KHsLXKsi2UhpEkvZhZLZ6QAZd5Dc9 invoke [1]
    Program log: Instruction: RequestResult
    Program log: AnchorError caused by account: vault_manager. Error Code: AccountDidNotDeserialize. Error Number: 3003. Error Message: Failed to deserialize the account.
```
So for that size program I think you'd need about 5 sol
You annoyingly need about the same amount as when you first deployed, but solana won't actually charge you for it
Deploying program failed: unable to confirm transaction. This can happen in situations such as transaction expiration and insufficient fee-payer funds. How much fund do I need to upgrade a program ? File size is 354 KB
by web3
How can I get buffer account from program address?
just realized that i'm not giving it a bump nvm
oops
Thank you. This fixed my issue.
Man this anchor bug took 8 hrs . 
On to chewing more glass üôÇ
is there a ticket for it?
may be i can help you fix it
yeah
Yeah, it's just doing nothing :/
seems like
But yeah, this is a bug in the anchor cli, it doesn't really realize when you feed it a program that it's confused about
which actually deployed the program
I end up using solana program deploy
i kind of gave up
```
 $ÓÇ∞ anchor deploy --program-name mynftproject
Deploying workspace: https://api.devnet.solana.com
Upgrade authority: /Users/0xonizuka/.config/solana/id.json
Deploy success
```

it shows this, but how do I check that it's deployed correctly.. things are running so fast though, skeptical if it's actually deployed
i tried that too
I think the --program-name argument is supposed to be the actual name of the program, not its program_id
is that because my directory path to the project contain spaces?
getting the same error on `anchor test`
can someone help me with this? https://github.com/project-serum/anchor/issues/1000#issuecomment-1066722199
Thanks üëç
Bumps are deterministic functions of the seeds
No
So it's not related to security or something like that?
Any of those three options is fine
You can certainly do it that way if you want
Oh, OK.
Ok, to elaborate: passing them in from the client is annoying
Really?
Or tried to at least
I just answered that üòõ
I know that: the question is: why store them inside the program state instead of just providing them from the client?
You need access to the bumps if your program wants to sign for one of those PDAs, so you basically have three options: stash the bumps in program state, pass them in from the client as instruction arguments, or recalculate them on the fly with `Pubkey::find_program_address` (which can cost a surprising amount of compute units).
I find that it's done a lot inside the Anchor code
Hey, why do people store the bump seeds in the program state?
any ideas?
hey guys, why am I getting this error:

```
error: Invalid value for '--program-id <PROGRAM_ID>': unrecognized signer source
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.
```
In solana, when you create an account you need to sign for the account's address. You're not doing that here: you need to add a `, signers: [this.newAccount]` to that call
I have the update function sorted, just don't know how to implement the custom type on either end
Does anyone know how to update a list with a custom data type such as a struct from the react front end so that it can compile
I think you should send newAccount to the signer anyway (try to change data field in that account maybe). AFAIK only the wallet that will be sign automatically
umm not sure about this. I dont know the best practices to handle this case. I think you can store your keypair somewhere and replace when target/deploy/*keypair after build for the first time but it is still extra step anyway.
Then I have to include the generated keypair in git for team members to run the tests without updating `declare_id!()`?
if you didn't mind to change the program id (for test purpose) then yes you have to change declare_id! and Anchor.toml to match the generated keypair.
But what does it have to do with the `declare_id!()`? Do I have to update the `declare_id!()` to match with the generated keypair?
Thanks for the answer. üôÇ 
The reason why the code has not a signer(s) parameter is that sends a transaction using a web browser-based wallet like Phantom.
In that case, as I know, no needed signer(s) because the provider will sign the transaction automatically.
you will get difference keypair. even if you delete target directory then build again in the same machine you still get different keypair
How keypairs `target/deploy/*-keypair.json`  are generated? If I `cargo clean && anchor build` in another machine, does Anchor generate the same keypair?
No clue if this is going to solve your problem, but for me it looks like you're not passing signer(s) to your RPC call.

```
accounts: {
  ...
},
signers: [this.newAccount]
```
Can I ask one fundamental question?

If I created a new account from a specific deployed program with SystemProgram, after that trying to create a new different account is not available?

Whenever I trying create a new account with new key-pairs, I can't create a new account with the same program.

Contract side is below:
```#[derive(Accounts)]
pub struct Create<'info> {
    #[account(init, payer = authority, space = 8 + ?)]
    pub program_status: Account<'info, Status>,
    #[account(mut)]
    pub authority: Signer<'info>,
    pub system_program: Program<'info, System>,
}```

Client side is below:
```await program.rpc.create({
    accounts: {
        programStatus : this.newAccount.publicKey,
        authority: this.wallet.publicKey,
        systemProgram: web3.SystemProgram.programId,
    },
});```

The new account part is `this.newAccount.publicKey` .
And the error message is `Error: Signature verification failed` .

Thank you for reading.
How to change rpc endpoint to custom one when deploying with Anchor? I cannot find the list of config that I can change in Anchor.toml. If it already have document for that please enlighten me
for passing data in, it looks like struct are ok, but only with primitive types as properties, i.e, no structs as properties of the struct that gets passed in as data? - this works - wasn't camelCase everywhere
Try upgrading anchor. I had an identical bug that was fixed by updating anchor to 0.22.1 and switching to the new bump syntax
Anyone know how i could adjust the clock of my local validator? it's off by 5 days
The problem was the default commitment level. I'm not sure why ours are different but adding `commitment: 'processed'` fixed it and now it's very speedy.

Example:
```
new anchor.Provider(connection, walletWrapper, {
        preflightCommitment: 'recent',
        commitment: 'processed'
    });
```
`TypeError: Cannot read properties of undefined (reading 'preflightCommitment')`
Looks like it's required.
whats the error?
It errors out. I just tried `'singleGossip'` and it takes the same amount of time.
what happens if u set it to undefined?
I just use the default & using anchor version 0.22.0
I set the preflightCommitment to: `preflightCommitment: 'recent'`
what is your commitment level? The default commitment works fine for me locally, and is pretty fast.
Is there a good way to optimize the speed of calls to: `program.rpc.SomeTransaction`?
Anything I try from the client takes about 15 sec locally and that seems pretty slow given Solana's speed. 

For example, from the docs: 
```
   const txSignature = await program.rpc.increment({
   accounts: {
      counter,
      authority,
   },
});
```

How do others handle this?
trader_mint_pda is getting privilige escalation
the front end is -
`    const trader_mint_seeds = [
      Buffer.from("foo")
    ]
    const [ trader_mint_pda, trader_mint_bump ] = await PublicKey.findProgramAddress(
      trader_mint_seeds,
      program.programId
    );`
i have dealt with a lot of this error in past but this time i am stumped
any ideas what I am missing.
for the pub trader_mint_pda: AccountInfo<'info>,
```pub struct OpenNewTrade<'info> {
    //TODO make sure trader has money
    #[account(
        signer,
        mut
    )]
    pub trader: AccountInfo<'info>,

    #[account(
        init,
        payer = trader,
        space = 16,
        seeds = [ b"foo".as_ref()],
        bump = trader_mint_bump,
    )]
    pub trader_mint_pda: AccountInfo<'info>,

    #[account(
        init_if_needed,
        payer = trader,
        associated_token::mint = long_mint_account,
        associated_token::authority = trader_mint_pda,
        
    )]
    pub trader_long_mint_account: Box<Account<'info, TokenAccount>>,

    #[account(
        init_if_needed,
        payer = trader,
        associated_token::mint = short_mint_account,
        associated_token::authority = trader_mint_pda,
      
    )]
    pub trader_short_mint_account: Box<Account<'info, TokenAccount>>,
    
    #[account(mut)]
    pub option_account: Box<Account<'info, OptionAccount>>,

    #[account(mut)]
    pub vault_account: Box<Account<'info, Mint>>,
    //Check if mints match
    #[account(mut)]
    pub long_mint_account: Box<Account<'info, Mint>>,
    #[account(mut)]
    pub short_mint_account: Box<Account<'info, Mint>>,
    pub associated_token_program: Program<'info, AssociatedToken>,
    pub token_program: Program<'info, Token>,
    pub rent: Sysvar<'info, Rent>,
    pub system_program: Program<'info, System>,```
Getting CPI unauthorized error or writable acoount. Not sure why. The account is not being used for anyhting yet.
Anyone know how to adjust the clock of my local validator? it's off by 5 days
yea, just add them one after another, separated by commas
is there a way to add multiple constraints on an account, each with their own error?
just logging for anyone searching discord: if you get  `Access violation in stack frame` and u are passing in a lot of accounts you can wrap the accounts in `Box<>` like `pub mint1: Box<Account<'info, Mint>>` to allocate directly on the heap and save stack space
anyone know? üòì
yes, it fixed, big thx!
thx, will try
You probably need to pass a `new anchor.BN(...)` instead of  JS number
I have a 4 arguments for my call and when create a call from test, i get TypeError: src.toArrayLike is not a function, but if comment any arg a get an error that i forget some account, where a problem? Thx
hey guys im doing a project with anchor but this question is a question unrelated to anchor hope someone can help me out üòõ for some reason i cant locate any projects that i create on ubuntu on my pc. anyone know why?
Unable to createassociatedtokenaccount
gg
theres a getBalance function
lol for future lurkers: https://github.com/solana-labs/solana-web3.js/blob/35f0608a8363d3878d045bdb09cdd13af696bc6b/src/connection.ts
how can we see balances of public keys when testing with anchor? i think we have to make a connection but not sure how to use the same details as the anchor.Provider.env()
Yeah, shouldn't matter, but you'll have to be consistent and do things like `theClientSideBN.toArrayLike(Buffer, 'le', 4)` (so 'le' for little-endian and 4 b/c it's a u32 = 4 bytes)
theoretically if it was a u32, i guess it doest matter either as long as its consistent? is there a best practice?
If it's only a single byte then it doesn't matter (endianness only applies when the number takes more than one byte)
beginner rust question. How do i pass an integer as one of the seeds to find_program_address, should it be a big-endian, little-endian etc?

```rust
            let authority_id: u8 = 0;
            let (authority, authority_nonce) = Pubkey::find_program_address(
                &[
                    ctx.accounts
                        .authority
                        .to_account_info()
                        .owner
                        .as_ref(),
                    &authority_id.to_be_bytes(),
                ],
```


//////////////////////////////////////////////////////////////////////////////////////////

This is coming from the other function that used that same context.  No compile time warning though.  This works fine with anchor 0.20.0
Looks like i spoke too soon.  
`    Program failed to complete: Access violation in stack frame 5 at address 0x200005000 of size 8 by instruction #59515`
Hi!

I am trying to validate an account (to which some SOL has to be transferred) as 

```
    #[account(mut)]
    pub creator_spl_account: Account<'info, TokenAccount>,
```

This account is created and airdropped some lamports on the tests.ts as

```
      const creatorsWalletKeypair = anchor.web3.Keypair.generate();
      let signature = await program.provider.connection.requestAirdrop(
        creatorsWalletKeypair.publicKey,
        1000000000 // 1 SOL ‚Äî or 1 billion lamports
      );
```

I am getting the following error:

```
Program log: AnchorError caused by account: creator_spl_account. Error Code: AccountOwnedByWrongProgram. Error Number: 3007. Error Message: The given account is owned by a different program than expected.
```

Is it right to validate it as a `TokenAccount` if only SOL is being sent to it ?
If so, is the `tokenAccount`created when we airdropped SOL for the first time ?

<@!134416332509675520>
That same context is used else where without error. (that offending func is a copy pasta).  I'll circle back on this later if i find anything interesting.  Removed it for now.
I have added cpi features to my Cargo.toml
do I need anything in my Anchor.toml
but I could not find the cpi crate when I try to compile:
```
error[E0433]: failed to resolve: could not find `cpi` in `stable_swap`
  --> programs/stableTry/src/lib.rs:31:22
   |
31 |         stable_swap::cpi::process_instruction(
   |                      ^^^ could not find `cpi` in `stable_swap`
```
Ok, I'm trying to figure out exactly why I can't find the cpi crate.
I'm trying to call the saber-swap program, process_instruction function:
```
//! Program entrypoint definitions
#![cfg(not(feature = "no-entrypoint"))]

use crate::{error::SwapError, processor::Processor};
use solana_program::{
    account_info::AccountInfo, entrypoint, entrypoint::ProgramResult,
    program_error::PrintProgramError, pubkey::Pubkey,
};

entrypoint!(process_instruction);
fn process_instruction<'a>(
    program_id: &Pubkey,
    accounts: &'a [AccountInfo<'a>],
    instruction_data: &[u8],
) -> ProgramResult {
    if let Err(error) = Processor::process(program_id, accounts, instruction_data) {
        // catch the error so we can print it
        error.print::<SwapError>();
        return Err(error);
    }
    Ok(())
}```
^This is the file in the saber-protocol  stable-swap-program/program/src/entrpoint.rs in this github: https://github.com/saber-hq/stable-swap

And this is what I'm trying to write, calling the stable-swap protocol:
 ```
use stable_swap::*;
#[program]
pub mod stable_try {
    use super::*;
    pub fn test(ctx: Context<SwapInfoCtx>) -> ProgramResult {
        let sInfo1 = *ctx.accounts.swap_info_account;
        let boolz = sInfo1.is_initialized;
        msg!("raw data1:{:?}", boolz);
        ////try to pause it and get an error
        //stable-swap program-id-key
        let idKey = "SSwpkEEcbUqx4vtoEByFjSkhKdCT862DNVb52nZg1UZ";
        let programID: Pubkey = idKey.parse().unwrap();
        stable_swap::cpi::process_instruction(
            &programID,
            &[ctx.accounts.ac1, ctx.accounts.ac2],
            &[102]
        );
        Ok(())
    }
}
#[derive(Accounts)]
pub struct SwapInfoCtx<'info> {
  pub swap_info_account: Account<'info, SwapInfo>,
  pub ac1: AccountInfo<'info>,
  pub ac2: AccountInfo<'info>
}```
Ah, it's from all the work anchor is doing to get that Context thing set up
hmm, removing that function avoids the error.  nothing wrong looking in that func to me though..
`    pub fn make_offer(_ctx: Context<BuyToken>) -> Result<()> {
        Ok(())
    }
`
This is the function complained about:
Maybe i'm not understanding exactly what the error means.
Why hard to believe?
This is the call stack?  This i find hard to believe..
THanks
Got it
account data is what I am after
You would have to pass that account in from the client
Or do I CPI the data into the program that neads to read, from the program to be read
From the client?
Only thing you can read in solana is account data, so you'd have to pass whatever account holds the data you care about into your program
How do i read data from a program inside a separate program?
Have to pass the account in from the client, no way around it
Nope
any way to convert publicKey type to AccountInfo type?
(which in general  will fail at runtime)
Mm, not actually sure if that will fail at runtime, but yeah, you're nearly completely out of stack space
should i be worried about this?  `Error: Function _ZN11marketplace9__private8__global10make_offer17h0acc83c64d41a369E Stack offset of 4096 exceeded max offset of 4096 by 0 bytes, please minimize large stack variables
`
ok got it compiling
`error: cannot find attribute `error` in this scope`
did the error stuff get switched around in the new anchor?
ah, thats it, thank you
And then later use a `&` if you need to
Like, just do `let Ac1: Pubkey = ac1.parse().unwrap();` to be explicit
Ah, make sure you're trying to get an actual `Pubkey`, not a `&Pubkey`
Double check you've added that use statement in an accessible place, should work (works for me)
hmm, still same error
`use std::str::FromStr;`
on the lines:
```
        //necessary accounts
        let ac1 =  "SQDY9uoDoCbNq7F3HAHYYQZbrUzpKxDtdWLvYcqBLak";
        let Ac1 =  ac1.parse().unwrap();
```
```error[E0277]: the trait bound `&anchor_lang::prelude::Pubkey: FromStr` is not satisfied
  --> programs/stableTry/src/lib.rs:25:24
   |
25 |         let Ac1 =  ac1.parse().unwrap();
   |                        ^^^^^ the trait `FromStr` is not implemented for `&anchor_lang::prelude::Pubkey`
   |
```
`"aasdfasdfasd".parse().unwrap()` should probably work here
I feel like I'm getting close. I'm trying to call "pause" this is what I have:
```
#[program]
pub mod stable_try {
    use super::*;
    pub fn test(ctx: Context<SwapInfoCtx>) -> ProgramResult {
        //try to pause it and get an error
        //stable-swap program-id-key
        let idKey = "SSwpkEEcbUqx4vtoEByFjSkhKdCT862DNVb52nZg1UZ";
        //necessary accounts
        let the_accounts = ["SQDY9uoDoCbNq7F3HAHYYQZbrUzpKxDtdWLvYcqBLak",
                        "AUMZDG77zj4G4Ex9bfB3TsNaCQLb1m3WTRM9Dmb6VUgU"];
        let signer_seed = "foo";

        //let ix = stable_swap_client::instruction::pause(ctx.accounts.swap.key, ctx.accounts.admin.key)?;
        let ix = stable_swap_client::instruction::pause(
            "SQDY9uoDoCbNq7F3HAHYYQZbrUzpKxDtdWLvYcqBLak",
            "AUMZDG77zj4G4Ex9bfB3TsNaCQLb1m3WTRM9Dmb6VUgU")?;
        solana_program::program::invoke_signed(&ix, &idKey, signer_seed)?;

        Ok(())
    }
}```
It doesn't compile. How do I convert an address string to a publicKey object?
been grinding w emacs and vim/tmux
yeah gotta install vscode too lol
Vscode has a slick way to automagically attach a node debugger if you run the tests from its built-in console
the describe and it keywords, guess i'll use ndb
nah its just anchor test
How are you running that code? In the browser?
um how would i use a debugger in this case lol only ever used gdb and c
Mm, not sure, can always try stepping through with a debugger though
sorry for interrupting but is there anything i can try in the meantime lol
But yeah, assume it's going to be something simple üòõ
Can try doing a `cargo clean` and then rebuild?
v odd
There is something different between the two program configs....but it;s not the lib.rs or the Cargo.toml.  Both identical now
New versions of anchor do make a type alias for that Result thing, but old ones don't‚Äîthat's why I thought it might be a version issue
I get a few weird errors:
`error[E0432]: unresolved import `crate`
  --> programs/fractions/src/lib.rs:16:1
   |
16 | #[program]
   | ^^^^^^^^^^ could not find `__client_accounts_list_token` in the crate root
`
Mm, not sure, but it will be something simple‚Äîa slightly different import, etc.
the anchor-lang version in Cargo.lock matches the versions in both Cargo.toml files. (though i had to downgrade the newly created program to the same version as my existing program)
i implemented my own transfer function and it works with the same parameters but really not sure why the system instruction doesn't üò¶
yup i did just a number first but added that out of desperation lol
and i've tried these console logs and they all work
```    console.log("investor", investor.publicKey.toBase58(), investor.secretKey);
    console.log("creatorTreasury", creatorTreasury.toBase58());```
That lamports amount should just be a number, fwiw (not sure if that's the issue though)
Investor is a keypair, creatorTreasury is a public key
``` const transaction = new Transaction().add(
      SystemProgram.transfer({
        fromPubKey: investor.publicKey,
        toPubKey: creatorTreasury,
        lamports: new anchor.BN(transferVal),
      })
    );

    await sendAndConfirmTransaction(
      provider.connection,
      transaction,
      [investor],
      {commitment: "confirmed"}
    );
```

I'm trying to use SystemProgram.transfer but keep getting ```TypeError: Cannot read properties of undefined (reading 'toBase58')```
Different anchor-lang versions (check the corresponding Cargo.lock files)
`error[E0107]: this enum takes 2 generic arguments but 1 generic argument was supplied
   --> programs/fractions/src/lib.rs:16:10
    |
16  |     ) -> Result<()> {
    |          ^^^^^^ -- supplied 1 generic argument
    |          |
    |          expected 2 generic arguments`
The second program i made today with `anchor new`.  Cargo.toml matches
how is it possible that the same code in two separate programs within a project compiles ok in one but not the other?
There's some random extra stuff happening in this example, but yeah: https://discord.com/channels/889577356681945098/889702325231427584/948964633094529064
any example on building the instruction?
It will be somewhat tricky to use though, since building the instruction is kinda tough
Sure
So I can use that instead?
if I understand correctly: I can import stuff with anchor to do calls, but it's also possible to do a raw invoke call using something like this:
https://docs.solana.com/developing/programming-model/calling-between-programs
Think ordinarily you'd let the wallet adapter stuff handle that for you, e.g. this kind of thing with `useConnection` (in react anyway): https://github.com/solana-labs/wallet-adapter#usage
Some of them are magically generated by anchor macros, so it's hard to see an actual list/you unfortunately can't jump to source on them :/
üëã quick question - what is the best practice for setting the network in Solana web.js? In the typescript code, I've been hardcoding the network as a constant, but want to change this dynamically based off the network the user has selected in their wallet (e.g. if they have devnet selected, change the typescript params to point to the devnet rpc url)
any way I could find all the things I'm importing when I use:
`use stable_swap::*;`
Like where can I find the list of crates I import with the above line?
Mm, I think that's all you should need to do
do I need to compile something to get a cpi module?
I noticed there's no module explicitly labelled cpi in the example either
yeah
Is that an anchor program?
So this line is in my cargo.toml for the contract I'm writing:
stable-swap = { path = "/home/a/stable-swap/stable-swap-program/program", features = ["cpi"] }
but I get an error that the cpi module can't be found:
```error[E0432]: unresolved import `stable_swap::cpi`
 --> programs/stableTry/src/lib.rs:6:18
  |
6 | use stable_swap::cpi::*;
  |                  ^^^ could not find `cpi` in `stable_swap`
 ```
How is the cpi module generated?
I'm also looking at figuring out how to do a CPI from this tutorial:
https://project-serum.github.io/anchor/tutorials/tutorial-3.html#defining-a-puppet-master-program

I think I missing the cpi crate somehow?
thank you
ah, that works
I would like to log just the account, just one variable, like is_initialized
Ah, try doing `**sInfo` instead
What's wrong with the log above?
with
```#[derive(Accounts)]
pub struct SwapInfoCtx<'info> {
    ///Check: based
  pub swap_info_account: Account<'info, SwapInfo>
}```
or actually a pointer to it:
```        let sInfo1 = &ctx.accounts.swap_info_account;```
Account<'info, SwapInfo>
Or, are you saying that's wrong?
What type is sInfo?
This gets logged:
```Program log: raw data1:Account { account: SwapInfo(SwapInfo { is_initialized: true, is_paused: false, nonce: 254, initial_amp_factor: 200, target_amp_factor: 200, start_ramp_ts: 0, stop_ramp_ts: 0, future_admin_deadline: 0, future_admin_key: 11111111111111111111111111111111, admin_key: AUMZDG77zj4G4Ex9bfB3TsNaCQLb1m3WTRM9Dmb6VUgU, token_a: SwapTokenInfo { reserves: GiehZ4X2uQjhEKuxSm3ACmEFrabxh3RTvjbLfLjw1xGX, mint: EgQ3yNtVhdHz7g1ZhjfGbxhFKMPPaFkz8QHXM5RBZBgi, admin_fees: nukUCjiUHV3XxsQGfigvxAHRLrJprpB45oQ2PHB1Bue, index: 0 }, token_b: SwapTokenInfo { reserves: rxDQYV77NKRKYxCjq4cECX3QQsiSyLv1T1FT2X3zNA2, mint: JEFFSQ3s8T3wKsvp4tnRAsUBW7Cqgnf8ukBZC4C8XBm1, admin_fees: EjFDsYacwgvHNWQR8eBRA4cFTDWxfeNrkgmdV3cjrMXH, index: 1 }, pool_mint: AVDuGckLavyLr5YifViaxnoveY6rwqDezHw5kiKiRQEC, fees: Fees { admin_trade_fee_numerator: 0, admin_trade_fee_denominator: 10000, admin_withdraw_fee_numerator: 0, admin_withdraw_fee_denominator: 10000, trade_fee_numerator: 4, trade_fee_denominator: 10000, withdraw_fee_numerator: 0, withdraw_fee_denominator: 10000 } }), info: AccountInfo { key: SQDY9uoDoCbNq7F3HAHYYQZbrUzpKxDtdWLvYcqBLak, owner: SSwpkEEcbUqx4vtoEByFjSkhKdCT862DNVb52nZg1UZ, is_signer: false, is_writable: false, executable: false, rent_epoch: 289, lamports: 3640080, data.len: 395, data: 0100fec800000000000000c800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, .. } }
```
That's not what I wrote üòõ `*sInfo` all by itself
```error[E0616]: field `account` of struct `anchor_lang::prelude::Account` is private
  --> programs/stableTry/src/lib.rs:15:40
   |
15 |         msg!("raw data1:{:?}", *sInfo1.account);
   |                                        ^^^^^^^ private field

```
same problem
Do `msg!("raw data1: {:?}", *sInfo);` instead
<@!134416332509675520> can you quickly check the above, any way to turn private variable to public?
noob q, so when I do `div` that has a remainder, it just returns the whole part? I should check here - thx
Can you say more? What kind of floor? bn.js only supports integers
what it a good way to do a floor calc with bn.js 4.11? Newer version looks like it has `divmod`
Forgot to mention that the program I'm interfacing with has an ABI so I can access all the necessary functions inside my program. I've just enabled the cpi feature and specified the crate name and that seems to be ok as is. Thanks for your help!
Great, thanks a lot!!
I was checking this out the other day https://github.com/project-serum/anchor/blob/master/tests/events/tests/events.js
Strictly speaking no, but in practice you might need to, yeah, because you need to be able to build the A instruction you want to invoke.
gm! üåû does anybody know if we need to care about referencing program A from program B's Cargo.toml file when doing a CPI if program A isn't yours? The docs say it's important but the example is only for 2 programs in your codebase.
Hmm could you elaborate, would really appreciate it üôè
Hello. I want to get some ideas here. 
I want to listen for events emitted from my program.
Is there something similar to TheGraph that I can easily index and query? Or do I have to build my own backend (NodeJS) and listen to raw events and put event info to database?
```
However, if you want to use the bump in your instruction, you can pass it in as instruction data and set the bump value like shown in the example, using the instruction_data attribute. Anchor will then check that the bump returned by find_program_address equals the bump in the instruction data.
```
ig
doc is not updated ser
yeah it works with `bump,` alone, but the docs seems to suggest differnet semantics
"Checks that given account is a PDA derived from the currently executing program, the seeds, and if provided, the bump. If not provided, anchor uses the canonical bump."
```#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(
        init, payer = payer,
        seeds = [b"example_seed".as_ref()],
        bump
    )]```
you don't need to pass bump in new version of anchor
bump = xx with `mut` works fine
is this example wrong in the docs? Use bump=xxx with ‚Äùinit", throw the following error :
"bump targets should not be provided with init. Please use bump without a target"
https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html
is this code example from the doc wrong?
```
#[derive(Accounts)]
#[instruction(bump: u8)]
pub struct Initialize<'info> {
    #[account(
        init, payer = payer,
        seeds = [b"example_seed".as_ref()], bump = bump
    )]
```
I used to face this error when I used another library that checked their account against their mainnet program id.
pretty sure I haven't labelled any accounts as `Account` that aren't owned by my program
my program_ids all match
`3007: The given account is owned by a different program than expected` getting this error
Yeah your right my bad
I thought mint always owned by token program. Did you mean mint authority? sorry If I'm wrong.
meaning if the mint owner is someone else it should just be passed in as AccountInfo instead?
does this lead the program concluding that the mint is owned by the program?
pub mint: Account<'info, Mint>,
when providing a token mint to a program
but if I try to get the account variable of the above, sInfo.account, I get the private thing
If I just log sInfo itself it works:
```
Program log: raw data1:Account { account: SwapInfo(SwapInfo { is_initialized: true, is_paused: false, nonce: 254, initial_amp_factor: 200, target_amp_factor: 200, start_ramp_ts: 0, stop_ramp_ts: 0, future_admin_deadline: 0, future_admin_key: 11111111111111111111111111111111, admin_key: AUMZDG77zj4G4Ex9bfB3TsNaCQLb1m3WTRM9Dmb6VUgU, token_a: SwapTokenInfo { reserves: GiehZ4X2uQjhEKuxSm3ACmEFrabxh3RTvjbLfLjw1xGX, mint: EgQ3yNtVhdHz7g1ZhjfGbxhFKMPPaFkz8QHXM5RBZBgi, admin_fees: nukUCjiUHV3XxsQGfigvxAHRLrJprpB45oQ2PHB1Bue, index: 0 }, token_b: SwapTokenInfo { reserves: rxDQYV77NKRKYxCjq4cECX3QQsiSyLv1T1FT2X3zNA2, mint: JEFFSQ3s8T3wKsvp4tnRAsUBW7Cqgnf8ukBZC4C8XBm1, admin_fees: EjFDsYacwgvHNWQR8eBRA4cFTDWxfeNrkgmdV3cjrMXH, index: 1 }, pool_mint: AVDuGckLavyLr5YifViaxnoveY6rwqDezHw5kiKiRQEC, fees: Fees { admin_trade_fee_numerator: 0, admin_trade_fee_denominator: 10000, admin_withdraw_fee_numerator: 0, admin_withdraw_fee_denominator: 10000, trade_fee_numerator: 4, trade_fee_denominator: 10000, withdraw_fee_numerator: 0, withdraw_fee_denominator: 10000 } }), info: AccountInfo { key: SQDY9uoDoCbNq7F3HAHYYQZbrUzpKxDtdWLvYcqBLak, owner: SSwpkEEcbUqx4vtoEByFjSkhKdCT862DNVb52nZg1UZ, is_signer: false, is_writable: false, executable: false, rent_epoch: 289, lamports: 3640080, data.len: 395, data: 0100fec800000000000000c800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, .. } }```
share `SwapInfo` struct code
are you talking about `pub`
Any way to make the account field not private on an Account struct within anchor?
```error[E0616]: field `account` of struct `anchor_lang::prelude::Account` is private
  --> programs/stableTry/src/lib.rs:12:38
   |
12 |         msg!("raw data1:{:?}", sInfo.account);
   |                                      ^^^^^^^ private field```
And sInfo is of type: Account<'info, SwapInfo> . 
If I want to extract just the SwapInfo I believe sInfo.account would give it to me but it's private? How else can I log it?
Does my question make sense?
any way to make the account field not private when reading data?
what kind of default validation is there for Account<'info, whatever> ?
what was your solution here?
Hi everyone, struggling to get my initialize PDA instruction to work properly.

Here's the clientside code:
```const [nftPDA, _meronBump] = await PublicKey.findProgramAddress(
      [
        anchor.utils.bytes.utf8.encode("nft-stats"),
        nftMint.toBuffer()
      ],
      program.programId
    )
  await program.rpc.createNftStats(1000, 1, nftMint.publicKey, {
      accounts: {
        signer: program.provider.wallet.publicKey,
        nftStats: nftPDA,
        systemProgram: SystemProgram.programId
      },
    })
```
Here's my validation struct:
```
#[derive(Accounts)]
#[instruction(nft: Pubkey)]
pub struct CreateNFTStats<'info> {
    #[account(mut)]
    pub signer: Signer<'info>,
    #[account(
        init,
        payer = signer,
        space = 8 + NFTStats::LEN,
        seeds = [b"nft-stats", nft.as_ref()], 
        bump
    )]
    pub nft_stats: Account<'info, NFTStats>,
    pub system_program: Program<'info, System>,
}
```

Here's the error stack from the program log:
```Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account 
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS invoke [1]
    Program log: Instruction: CreateNftStats
    7mLqFZLNDer9n2eXTw9rEzSFVDrne5nFvjxmkk4f99te's signer privilege escalated
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS consumed 11909 of 1400000 compute units
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS failed: Cross-program invocation with unauthorized signer or writable account```

No idea what i'm doing wrong
not so far no
I didn't know about it. Now, It works well. 
Thanks a lot! üôÇ
Thank you so much.
I got mistaken for I have tried passing the new account into the parameter and it was not working.
Now, it works well. üôÇ
Though in general that won't always work, since js numbers are too small (can't represent integers exactly over 2^53, so not big enough for all 64 bits)
I think you can just do `theU64.toNumber()`
unless you're storing an metric load of data on your account 1 or 2 sol should be enough to test this indefinitely - i'd just make a special case for this or surround the airdrop rpc call with a try-catch and ignore if it errors
I'm trying to write a program that plays around with nfts minted from a specific wallet, anyone know of any code examples for testing something like this? I'm struggling with minting an nft to a wallet read in from a file locally in typescript
üëã  Any easy way to convert between spl u64 to number in typescript?
Hey all, I'm facing an error when testing my program on devnet:
```Error: 429 Too Many Requests:  {"jsonrpc":"2.0","error":{"code": 429, "message":"Too many requests for a specific RPC call, contact your app developer or support@rpcpool.com."}, "id": "c6d2ff37-a65a-4aee-9e96-1f480d007570" } ```

In the tests, I'm creating 2 accounts and trying to airdrop 1 SOL to one of them so it can pay rent. I think it may be erring here, as I'm doing this a total of 4 times. Would anyone know how to work around this?
When you use init on an AccountInfo type account, how do you close the account and return rent to some user? If I use the close=user argument, it says "close must be on an Account, ProgramAccount, or Loader"
ok, can you please tell me if the flow below is ok then?
Create check account:
- Inits an escrow_check of type Check account - stores data relevant to the transaction
- Inits a vault account of type AccountInfo - stores SOL transferred from a player
Cashes check:
Gets both escrow_check and vault as mutable accounts and uses same seeds and bump used in create check to get PDA. The error occurs here, when I am trying to transfer the SOL from vault account to another player.
1. When using JS, if I run both in sequence I'm able to succeed.
2. If there is a delay between them, then it says escrow_check is not initialized
Not sure then, but the above code should be fine‚Äîso I would check to make sure you're not doing something else wrong someplace else
hmm yes the first test case that inits this account passed the test
Are you sure the first tx actually succeeded?
still getting the same error
```.js
await program.provider.connection.confirmTransaction(
  await program.rpc.doSomething(...),
  "confirmed" // or "finalized" if you want
);
```
sorry what does that mean? Like wait longer for some connection?
Ok, might need to wait for more confirmation
from TS yes. Even from JS it says "account not initialized"
In JS you mean?
So I do set some variables in the escrow_check account. But when I try to access this account from another function, it says "account does not exist"
Nope, though if you don't set anything on the escrow_check account it will get initialized as all zeros
Hi All - When you use init in the account struct like so, ``` #[account(init, 
        seeds=[b"escrow-seed".as_ref()], 
        bump, 
        payer=from, 
        space = 8 + std::mem::size_of::<Check>()
    )]
    escrow_check: Account<'info, Check>,```
Do you need to specifically create an account in the function implementation?
Nothing, the first version is just the new/cooler/easier way
did you end up figuring this out?
üëã anyone have a snippet of code handy in reading/parsing IDL in typescript?
what's the difference between using the clock like this `Clock::get().unwrap()` vs passing it in as an account `pub clock: Sysvar<'info, Clock>,`


//////////////////////////////////////////////////////////////////////////////////////////

Hey , so i have been writing tests for testing the record program in Anchor. So I wrote a test to check for the initialization of the record account so im facing this error -

https://github.com/Anurag5086/record-anchor/blob/master/tests/record-anchor.ts

this is the test which i have written
Hey guys! Is it possible to write the typescript client code in javascript? Would there be any major issues?
https://github.com/project-serum/anchor/issues/1002
I tried creating it with just one instruction that had an `args` property in the object that gets created from idl.json of:
```
      "args": [
        {
          "name": "data",
          "type": {
            "defined": "AdminSettings"
          }
        }
      ]
```
and am getting:
```
Type '{ name: string; accounts: ({ name: string; isMut: boolean; isSigner: boolean; pda?: undefined; } | { name: string; isMut: boolean; isSigner: boolean; pda: { seeds: { kind: string; type: string; path: string; }[]; }; })[]; args: { ...; }[]; } | { ...; } | { ...; }' is not assignable to type 'IdlInstruction'.
  Type '{ name: string; accounts: ({ name: string; isMut: boolean; isSigner: boolean; pda?: undefined; } | { name: string; isMut: boolean; isSigner: boolean; pda: { seeds: { kind: string; type: string; path: string; }[]; }; })[]; args: { ...; }[]; }' is not assignable to type 'IdlInstruction'.
    Types of property 'args' are incompatible.
      Type '{ name: string; type: string; }[]' is not assignable to type 'IdlField[]'.
        Type '{ name: string; type: string; }' is not assignable to type 'IdlField'.
          Types of property 'type' are incompatible.
            Type 'string' is not assignable to type 'IdlType'
```
but if I look at `IdlType` it includes "string" as one of the allowable types.
so the signers can be an array then within any given instruction? crazy
```js
import idl from '../../target/idl/idl.json';
const program = new Program(idl, programID, provider);
```
is saying:
```
Argument of type '{ version: string; name: string; instructions: ({ name: string; accounts: ({ name: string; isMut: boolean; isSigner: boolean; pda?: undefined; } | { name: string; isMut: boolean; isSigner: boolean; pda: { ...; }; })[]; args: { ...; }[]; } | { ...; } | { ...; })[]; accounts: ({ ...; } | { ...; })[]; types: ({ ...; } ...' is not assignable to parameter of type 'Idl'.
  Types of property 'instructions' are incompatible.
    Type '({ name: string; accounts: ({ name: string; isMut: boolean; isSigner: boolean; pda?: undefined; } | { name: string; isMut: boolean; isSigner: boolean; pda: { seeds: { kind: string; type: string; path: string; }[]; }; })[]; args: { ...; }[]; } | { ...; } | { ...; })[]' is not assignable to type 'IdlInstruction[]'.
      Type '{ name: string; accounts: ({ name: string; isMut: boolean; isSigner: boolean; pda?: undefined; } | { name: string; isMut: boolean; isSigner: boolean; pda: { seeds: { kind: string; type: string; path: string; }[]; }; })[]; args: { ...; }[]; } | { ...; } | { ...; }' is not assignable to type 'IdlInstruction'.
        Type '{ name: string; accounts: ({ name: string; isMut: boolean; isSigner: boolean; pda?: undefined; } | { name: string; isMut: boolean; isSigner: boolean; pda: { seeds: { kind: string; type: string; path: string; }[]; }; })[]; args: { ...; }[]; }' is not assignable to type 'IdlInstruction'.
          Types of property 'args' are incompatible.
            Type '{ name: string; type: string; }[]' is not assignable to type 'IdlField[]'.
              Type '{ name: string; type: string; }' is not assignable to type 'IdlField'.
```
How do I read the idl.json into the Idl type?
I want to create a vault where users can deposit spl (farm / lp) tokens with the "claim" method which will harvest rewards and transfer them to the address / charities, can you recommend me some place/libs to start ?
no
like in ethereum
solana question: each transaction can only have 1 signing account right?
the tests folder in the anchor repo is your friend: https://github.com/project-serum/anchor/tree/master/tests
thx
You're gonna need to give the rust book a read probably: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html
ok, what does .unwrap() do, is like an evaluation?
It seems to be returning a Result, not an Instruction, so you probably need to add a `?` at the end, or an `.unwrap()` if you're lazy
Do you have your editor set up to give you type information like that?
Check what the actual return type is of that function call
Thanks!
yeah, I'm using anchor for some things too, still learning rust though
I've used some stuff from ```stable_swap_anchor```, it's probably easier to work with if you're using anchor üëç
Are you familiar with saber?
I'm gonna try that ^
I'm just trying to get a feel for solana/rust, using the saber library.
Right now I'm just trying to get a failing transaction calling pause() on it
you probably want to import 
```
use anchor_lang::{
    
    solana_program::instruction::{Instruction},
};
```
Then 
```
let ix = Instruction {
//program_id,
//accountstuff,
//data_stuff
};
```
I might be able to help out more if you tell me what you're actually trying to do with saber haha
quick question:
```
stable_swap::instruction::pause(
            &c.arber.pubkey(),
            &c.payer.pubkey(),
            )
```
I'm trying to use the above to generate an instruction to execute but I get this error:
```error[E0308]: mismatched types
  --> src/main.rs:43:11
   |
43 |           &[stable_swap::instruction::pause(
   |  ___________^
44 | |             &c.arber.pubkey(),
45 | |             &c.payer.pubkey(),
46 | |         )
   | |_________^ expected struct `Instruction`, found enum `Result`
   |
   = note: expected struct `Instruction`
                found enum `Result<Instruction, ProgramError>```
How do I get the instruction from the enum? I don't know enough rust lol.
learning by doing is probably the best way. Also look through other project's source code if they're public. Metaplex, Saber, marinade-finance for example
Hello everyone! I am new to solana and have some background with Rust. How would you recommend I get started with Anchor? I've checked out the Anchor Book but it seems limited in scope.
0xbbb
Think you want to use https://solana-labs.github.io/wallet-adapter/modules/_solana_wallet_adapter_react.html#useAnchorWallet instead
Thanks, trying to hook that up like:
```js
    const { wallet } = useWallet();

    async function getProvider(): Promise<Provider | null> {
        if (wallet) {
            const network = "http://127.0.0.1:8899";
            const connection = new Connection(network, "confirmed");

            const provider = new Provider(
                connection, wallet, opts.preflightCommitment,
            );
            return provider;
        } else {
            return null;
        }

    };
```
but getting
```
Argument of type 'import("").Wallet' is not assignable to parameter of type 'import("/home/caleb/projects/mediamarket/node_modules/@project-serum/anchor/dist/cjs/provider").Wallet'.
  Type 'Wallet' is missing the following properties from type 'Wallet': signTransaction, signAllTransactions, publicKey
```
i will give it a try. cheers <@!134416332509675520>
Another way is to keep using `program.rpc.doSomething` but also add in the `preInstructions: [...]` and/or `postInstructions: [...]` arguments to the call
You can start building a tx with `program.transaction.initializePool(...)` and then `.add(...)` other ixs to it
`const ix1 = program.instruction.initializePool(<...>)` etc.
anchor sends its transaction to rpc like this:
```
const tx = await program.rpc.initializePool(<‚Ä¶>)
const tx = await program.rpc.fundPool(<‚Ä¶>)
```
how to combine multiple transactions into one tx?
ü§†  seems working now. thank you <@!134416332509675520>
okay
Just put it anywhere else in the file, not in the program mod
And define that outside of the `#[program]` mod
We can't help unless you actually say what the issue is
```
#[program]
pub mod my_protocol {
    use super::*;
    fn get_price(pyth_account: AccountInfo) -> Result<u64> {
        let pyth_price_info = &pyth_account;
        let pyth_price_data = &pyth_price_info.try_borrow_data()?;
        let pyth_price = pyth_client::cast::<pyth_client::Price>(pyth_price_data);
        let dest_price = pyth_price.agg.price as u64;
        Ok(dest_price)
    }

    pub fn my_function(ctx: Context<MyFunction>) -> Result<()> {
        let price = get_price(ctx.accounts.pyth_btc_account);
    }    
```
I did like this but getting issue.
Yep, just define it üòõ
Is there any way to define one function that will be called a lot in one program?
late reply but https://www.youtube.com/watch?v=ZLp7M64_pTU&list=PLrYlwHDZuXW0qfPc26qTQQwrt-e9p5DQe&index=14
Is there any way to identify which type an account belongs to? Let's say I use one seed for type types of accounts. Is there a way for me to distinguish which of the two types it is?
useWallet() using the "@solana/wallet-adapter-react" is pretty good if you're using react
Helo. Is there any diffirence between transfer nft and normal spl token with anchor-spl?
When you want the deserialization use the later one
Can sb tell me when to AccountInfo<'info> or Account<'info, x>
yeah you need to pass all the account
how do you connect a phantom wallet to an anchor program?
Say for example, Instruction X in Program A calls Instruction Y in Program B which needs access to Account M. Do we have to pass Account M in the accounts list when calling Instruction X ?
Do we have to specify all the accounts that will be touched by a CPI as well ?
Yeah, original funder is irrelevant‚Äîas WrRaThy said, all that matters is who can sign for the vault's address (only your program)
given that it's a PDA - only the program can transfer from this account. nothing else needed
Check this tutorial https://hackmd.io/@ironaddicteddog/solana-anchor-escrow
Hi - I am trying to transfer SOL (not tokens) from a "from" player to a vault account (a PDA). I then distribute this SOL from the vault to other wallets. I have the program sign for this transaction since the vault is at a program derived address. Now does the original "from" player still have any control over this vault account (since he paid the rent and all)? Do I need to transfer authority of this vault account like we do for Tokens? I am under the impression that native solana works different from the tokens.
Does anyone know of an open source vault-like program I may reference? simple deposit in exchange for receipt token functionality
NVM:

I've been using spl transfer function from anchor all this time ü§¶ 

Just found this and it works!!

https://stackoverflow.com/a/70574227
space wise
Whats the largest you can initialise a program at
ive done:
```typescript
const {
  Connection,
  sendAndConfirmTransaction,
  Keypair,
  Transaction,
  SystemProgram,
  PublicKey,
  TransactionInstruction,
} = require("@solana/web3.js");
const connection = new Connection("https://api.devnet.solana.com/");
const feePayer = new Keypair();
await connection.requestAirdrop(feePayer.publicKey, 2e9);
```

to airdrop myself SOL in tests before
Does anybody have a link to a repo with anchor program, wallet adapter and react app as an example of a good development set up they could share?
hello! new user to anchor here. the below is part of my solana code for the tictactoe example in the anchor book.
```rust
  #[account]
  pub struct GameState {
      pub turn: u64,
      pub grid: [[Option<Sign>; 3]; 3],
      pub status: Status,
  }

  #[derive(
      AnchorSerialize, AnchorDeserialize, FromPrimitive, ToPrimitive, Copy, Clone, PartialEq, Eq,
  )]
  pub enum Sign {
      X = 0,
      O = 1,
  }
```

in my typescript tests, i access the GameState account. 

```typescript

        switch (JSON.stringify(s.grid[i][j])) {
          case "null":
            break;
          case "{\"x\":{}}": { // this looks ugly!
            console.log(`X at ${i},${j}`);
            break;
          }
          default: {
            console.log(`didn't handle ${JSON.stringify(s.grid[i][j])}`);
            break;
```
however I think {x: {}} is an ugly way of representing Sign::X. I'm also a typescript noob so maybe there's an easy way to interact with this data. Is there some way to keep using the Sign enum in rust, but have some nice conversion in typescript? eg Sign::X in rust somehow converts to 'X' in typescript
<@!134416332509675520>  How would we create a `SystemAccount` in tests ?

Right now just doing the following to create:

```
      const creatorsWalletKeypair = anchor.web3.Keypair.generate();
      let signature = await program.provider.connection.requestAirdrop(
        creatorsWalletKeypair.publicKey,
        1000000000 // 1 SOL ‚Äî or 1 billion lamports
      );
```

and getting this errror:

```
    Program log: Instruction: Transfer
    Program log: Error: InvalidAccountData
```
I see.
Sol isn't a token, it's just sol
No, that doesn't sound like it's a token account, just a `pub create_spl_account: SystemAccount<'info>`
<@!134416332509675520> could you please help with this ? Thanks
Great <@!134416332509675520> Thanks
Not quite, since that only passes in one address (so only one account). You can instead do `account.random.all()` or `account.random.fetchMultiple` though
If there is an account with the following structure:

```
#[account]
pub struct Random {
    pub user: Pubkey,
    pub creator: Pubkey,
    pub expire_timestamp: i64,
    pub bump: u8
}
```

Can we fetch multiple `Random`s (having same user) with `anchor.account.random.fetch(userPubKey)`?
is it possible to cpi create a mint without passing in generated keypair as a signer?
hey, i want to create vault where anyone can deposit spl token and withdraw it at any time and specific user can call contract func which will use deposited tokens to  claim rewards (collateral pay), im newbie in solana ecosystem so can someone give me some info where to start or what i can use to develop that ?
fantastic, thanks much !
There is this IDO example:  
https://github.com/project-serum/anchor/tree/e04f144e1208f359ff24273f968ae61ba39dfb25/tests/ido-pool
hello, is there any ICO code using anchor I can fork and take as a base?
So I guess my question is, is there a method like:
`anchor.sendTransaction(programID, accounts, data)`
You can clone executable programs on solana using validator.clone right?
But I just have a PublicKey that I want to send to
Normally I'd do this if its in my anchor workspace:   const program = anchor.workspace.StableTry as Program<StableTry>;
<@!134416332509675520>  any tutorial on sending a transaction to an already deployed contract? I'm cloning a contract using anchor test and want to send a single transaction to it from the terminal
Can I use structs with anchor?
I can use Box<xxx> apparently, to put the accounts on the heap, rather than the stack..


//////////////////////////////////////////////////////////////////////////////////////////

How init_if_needed check that the account already init? only the owner and lamport?
Is there any opensource staking program made using anchor or Solana, just wanted to see how is staking implemented on solana
‚ù§Ô∏è
thanks buddy; I will it give it a go
https://github.com/switchboard-xyz/vrf-cpi-example/blob/main/programs/anchor-example/src/actions/request_result.rs#L16 found it
oh ok
I used to see someone call .load()? directly in the constraints but not fully sure. I tried to find the example that I saw but not found anymore. Maybe you can try that
is it possible to access the data of `AccountLoader` while defining the accounts? Basically I would love to use some values from the underlying data to define some constraints

e.g.

```
pub struct Deposit<'info> {
  #[account(mut)]
  pub state: AccountLoader<'info, State>,
  
  #[account(
    constraint = treasury.owner == state.user
    constraint = treasury.mint == state.token
  )]
  pub treasury: Box<Account<'info, TokenAccount>>,
}
```
hey guys
`getOrCreateAssociatedTokenAccount` sends the full tx signed an all for u but u just want the unsigned tx which u get them to sign themselves
i think u have to interface with phantom or some other solana wallet and basically give them the tx and have them sign it
I have a program which sends out a new token to the person who calls the one function. Now Im writing the webapp and have to create the token account for the user or get the address of the already existing token account. I do this like this:
`const new_token_acc = await getOrCreateAssociatedTokenAccount(
            connection,
            signerAccount,
            mint_address,
            signerAccount.publicKey
          );`

The problem is, that signer Account needs to be the Keypair of the user who is connected with the webapp. I think nobody would use a wallet which gives Keypairs to websites they connect with so Im obviously doing something wrong. Could someone please tell me how can get/create the token account for the user who connected with the webapp?
`bump = token_vault_bump` just becomes `bump`
Turns out I was using an outdated anchor version and just needed to change my bump
```pub struct CreateMangoAccount<'info> {
    #[account(constraint = vault.manager == manager.key())]
    pub vault: Account<'info, Vault>,
    #[account(mut)]
    pub unverified_mango_owner_pda: AccountInfo<'info>, // needs to be here since mango needs a parsed accountinfo, but using find_program_address on-chain only gives a pubkey
    #[account(mut)]
    pub unverified_mango_account_pda: AccountInfo<'info>, // ^^ as above
    #[account(mut)]
    pub manager: Signer<'info>,
    pub mango_program_id: AccountInfo<'info>,
    #[account(mut)]
    pub mango_group_ai: AccountInfo<'info>,
    pub system_program: Program<'info, System>,
}```
How did your account constraint look?
Anyone ever gotten this before? `thread 'main' panicked at 'Code not parseable: Error("bump targets should not be provided with init. Please use bump without a target.")'`?
How to Fix TestScript error <@!134416332509675520>  <@!665112704553320473>
is there a way to print some message on lib.rs so it'll appear on terminal when we run anchor test?
Since often using them is a sign you're doing something dumb
You just need to add a `/// CHECK: here's why I'm not being dumb...` comment in order to use an AccountInfo or an UncheckedAccount
yes but did't understand.
Did you read that link?
Error: 
        Struct field "vault_token_account" is unsafe, but is not documented.
        Please add a `/// CHECK:` doc comment explaining why no checks through types are necessary.
        See https://book.anchor-lang.com/chapter_3/the_accounts_struct.html#safety-checks for more information.

What Does that mean? <@!134416332509675520>
ah gotcha. thanks for the link
And no, solana tx fees don't work that way anyway: https://jstarry.notion.site/Transaction-Fees-f09387e6a8d84287aa16a34ecb58e239
That's just rust code‚Äîyou're already inside an instruction, not doing an additional one etc.
i always though every ix costs some money
running this ix on chain
What would you be paying for though?
this
transfer_from_account_we_own
What's an instruction call?
What do you mean?
not a big deal just curious
understood, Also a follow up. When we do it the try_borrow_mut_lamport way. We pay for instruction call? or just txn cost
But the higher level solana point is that asking the sytem program to move money only works if the system program actually owns the source account
thanks
man you are godsend
Something like
```.rs
fn transfer_from_account_we_own(
    src: &mut AccountInfo, // we better own this account though
    dst: &mut AccountInfo,
    amount: u64,
) -> ProgramResult {
    **src.try_borrow_mut_lamports()? = src
        .lamports()
        .checked_sub(amount)
        .ok_or(ProgramError::InvalidArgument)?;
    **dst.try_borrow_mut_lamports()? = dst
        .lamports()
        .checked_add(amount)
        .ok_or(ProgramError::InvalidArgument)?;
    Ok(())
}
```
so every account made suing `#[account()]` is owned by my program
You need to use `.try_borrow_mut_lamports()` and move the money yourself
You can't use the system program to do that transfer, since it's *your* account, not the sytem program's
So if that account that lives at that PDA has data, it's presumably an account that's owned by your program (a struct with `#[account]` on top of it)
is there a way to make it work
https://discord.com/channels/889577356681945098/889577399308656662/949784094378700830
invoke_signed
sorry this
```amount_to_refund = quantity * price * (10^constants::PRICE_EXPONENT as u64);
            let ix = system_instruction::transfer(
                ctx.accounts.vault_account.to_account_info().key,
                ctx.accounts.trader.to_account_info().key,
                amount_to_refund,
            );
        
            invoke_signed(
                &ix,
                &[
                    ctx.accounts.vault_account.to_account_info(),
                    ctx.accounts.trader.to_account_info(),
                    ctx.accounts.system_program.to_account_info(),
                ],
                &[&vault_seeds]

            )?;```
```let ix = system_instruction::transfer(
                ctx.accounts.vault_account.to_account_info().key,
                ctx.accounts.trader.to_account_info().key,
                amount_to_refund,
            );
        
            invoke(
                &ix,
                &[
                    ctx.accounts.vault_account.to_account_info(),
                    ctx.accounts.trader.to_account_info(),
                    ctx.accounts.system_program.to_account_info(),
                ],
            )?;```
A noob issue. Trying to transfer sol from PDA to user wallet in Rust on chain program.
Running intoo 'from' must not carry data.
Make sure your anchor-lang and anchor-spl dependencies use the exact same version
the trait bound `anchor_spl::token::MintTo<'info>: anchor_lang::ToAccountMetas` is not satisfied
   --> programs/DstageNFT/src/lib.rs:167:30
    |
167 |     pub fn mint_to(&self) -> CpiContext<'_, '_, '_, 'info, MintTo<'info>> {
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `anchor_lang::ToAccountMetas` is not implemented for `anchor_spl::token::MintTo<'info>`

<@!134416332509675520> Help Please
No, anchor doesn't support that directly‚Äîyou'll need to use the `remaining_accounts` feature (try searching the anchor repo for examples)
Ok I get it that i need to "pass it in as an account". So if i wanna pass in a  Vec <AcountInfo> / or basically a variable  number of AccountInfos, i will need to then put that  Vec<AccountInfo>  as one of the data items in my account context
0.2.0
What version does your yarn.lock say you're using?
Oh, but actually you ought to be able to import that
The newest version changed their APIs a bit
I had the `TypeError: fields must be array of Layout instances` Error so I cleared node_modules and reinstalled everything with yarn. Now Im getting this and Im super confused. Neither `getOrCreateAssociatedTokenAccount `nor `getOrCreateAssociatedAccountInfo `can be found in @solana/spl-token. Any Idead what im doing wrong?
Right, can't do it that way, you need to "pass it as an account" (in the `Participate` context thing, like the other accounts you pass there)
Hi , when i try to pass in a  <AccountInfo> as one of the instruction parameters, i get a program macro error, how do i pass in an AccountInfo?

`pub fn participate(ctx: Context<Participate>, stake: u64, lucky_num: u8, test:<AccountInfo>) -> ProgramResult {`
You have to add that as a dependency to your Cargo.toml
use anchor_spl::token::{
  |     ^^^^^^^^^^ use of undeclared crate or module `anchor_spl`
need solution?
`the_account_info.key`
hello how do i get the account address from an accountInfo?
oooo thanks. devnet is on v1.9.9 which includes the per tx limit right? would make sense why my txs are hitting a limit on localnet and devnet
Interestingly, it's currently per ix but the overall limit will soon be per tx: https://jstarry.notion.site/Transaction-Fees-f09387e6a8d84287aa16a34ecb58e239#67aeb39d8b2540019cb37792c6a2cd32
noob q: is there a limit of 200,000 compute units per tx or is it per ix?
You'd have to just verify in the program that the threshold has indeed been reached
Yeah, can't do that kind of dynamic account lookup in your program
So I guess the only way is fetch the PDA, check if the number of participant has reach the threshold. If yes, call the program and pass all accountInfo in? There's no getAccountInfo equivalent on Solana program right?
dmed my git repo since it has my irl name
Sure
would it be okay if i just posted my whole code? its simple but long
Yep. Can you post your `pub fn` instruction's signature too?
my point was the authority is the treasury account, which is a pda, since we're trying to sign with this pda, we need the seeds for the authority
thats the instruction thats messing up
```anchor_spl::token::mint_to(
                CpiContext::new_with_signer(
                    ctx.accounts.token_program.to_account_info(),
                    anchor_spl::token::MintTo {
                        mint: core_mint.to_account_info(),
                        to: core_deposit_wallet.to_account_info(),
                        authority: treasury.to_account_info(),
                    },
                    // &[&[b"core_mint".as_ref(), treasury.key().as_ref()]],
                    &[&[
                        b"treasury_account".as_ref(),
                        creator.key.as_ref(),
                        treasury.name.as_ref(),
                        &[treasury_bump],
                    ]],
                ),
                1,
            )?;
```
thats my contexts

At any rate, you need to know a PDA's bump in order to sign for it, e.g. here: https://github.com/cqfd/anchor-token-studies/blob/main/programs/token-studies/src/lib.rs#L22
Can you post some code? Not sure which situation you mean
okay i have been doing ,bump actually, but  should i be checking the mint bump or the authority bump for the actual signature?
(But you need to know the bump somehow in order to sign for that address, which is necessary here to init the mint)
(That's the old-school way, new-school is to just skip that part entirely and do `bump,`)
https://github.com/cqfd/anchor-token-studies/blob/main/programs/token-studies/src/lib.rs#L85
just to make sure, the bump i'm checking is the mint authority for the mint_to ix, so the treasury pda?
um i didn't realize we were every supposed to pass in the actual bump, just the seeds
Are you using the `#[instruction(...)]` macro to do that? (But yeah, just try doing `bump,` instead, that's actually how anchor now does things anyway)
I'm saying that on the client, you're apparently not passing the bump correctly to the rust side
Ah, yeah
but we're just checking the signature here not calculating a bump seed
well pdas are usually derived by decrementing the bump seed from 255 till its off the curve
What do you mean by not deriving a pda here?
ahhhh yeah ik how pdas are derived, but since we're not deriving a pda here, if the first bump doesn't work, it would be on the curve got it
So double check you're actually passing in that bump correctly (or do the lazy thing and just say `bump,`, no equals sign)
So sometimes you'll actually get lucky and produce an off-curve (but maybe incorrect) address, and sometimes it won't produce an off-curve address at all
Right, the way that can happen is kind of interesting‚Äîeach choice of bump has a 50/50 chance of working for a given choice of seeds
yeah that makes sense, but i was extremely lost when i was getting different errors when I didn't even modify the code
The second stack trace also means you're using the wrong bump, but this time it happens to be a "valid" bump, in that the resulting address is "off curve", but the resulting address doesn't match the actual PDA address you're trying to use
That first stack trace means that the bump you're trying to use is wrong, in the sense that it doesn't actually work as a bump‚Äîthe resulting address is "on the curve".
and i'm trying to run your old https://github.com/cqfd/anchor-token-studies/blob/main/programs/token-studies/src/lib.rs, but theres a bunch of errors like missing msg! logs amoung others, wondering if you ever ran into that
hey <@!134416332509675520> wanted to bump my question if you had time
Thanks a lot greatly appreciate it
```.rs
let ix = Instruction {
  program_id: c::id(),
  accounts: accounts,
  data: that_instruction_thing.data()
}
```
Thank you so much
1 sec, finding an example
What would you recommend to fix this.
Ah, ok, that isn't quite right‚Äîthat won't do anchor's "sighash" stuff correctly.
I am currently using this to this  
```let ix = Instruction::new_with_borsh(
        c::id(),
         &c::instruction::MyInstruction {
            _req_bump: req_bump,
            amount,
            a_bump,
            b_bump,
        },
        accounts,
    );
```
Well I do not but at the moment I am figuring out the problem.
How do I serialize the instruction that I think is the problem that is why its falling back to this
You ordinarily shouldn't need to do that‚Äîdo you deliberately want to have a catch-all fallback function like that?
That's unfortunately the only way to do it (storing the Pubkey). You'll then need to pass that account in from the client when you eventually want to use it as an AccountInfo.
Hi Thanks but this issue was solved by implementing a fallback i.e a function that takes raw entry poing args.
```rust
  pub fn fallback<'info>(
        program_id: &Pubkey,
        accounts: &[AccountInfo<'info>],
        data: &[u8],
    ) -> Result<()> {
        Ok(())
    }
```
something like this.
Hi! Is there a way to store accountInfo? I'm creating an escrow that include multiple accounts. The escrow will execute transfer once it reaching a certain number of account. For transfer we need the accountInfo, I'm currently storing only the address pubkey. How should I go about this?
is it possible to init an account and an ata for it with a single context?
```
#[account(mut)]
seller: Signer<'info>,
#[account(init, payer = seller, space=Order::LEN, seeds = [utils::ORDER_PREFIX.as_ref(), 
marketplace.order_count.to_le_bytes().as_ref()], bump)]
order: Account<'info, Order>,
#[account(init, payer = seller, associated_token::mint = nft_mint, associated_token::authority = order)]
order_nft_account: Account<'info, TokenAccount>,
```
make sure that you didn't call to the wrong program id. if not I'm sorry I dont know either
well I can see the instruction generated in the crate
maybe you call to not exist function
Hi is it possible to write tests in rust and while doing so I have come accross this error any way I could solve this?
finally, weirdly enough i keep getting two different stack traces, really not sure what to make of this
```anchor_spl::token::mint_to(
                CpiContext::new_with_signer(
                    ctx.accounts.token_program.to_account_info(),
                    anchor_spl::token::MintTo {
                        mint: core_mint.to_account_info(),
                        to: core_deposit_wallet.to_account_info(),
                        authority: treasury.to_account_info(),
                    },
                    // &[&[b"core_mint".as_ref(), treasury.key().as_ref()]],
                    &[&[
                        b"treasury_account".as_ref(),
                        creator.key.as_ref(),
                        treasury.name.as_ref(),
                    ]],
                ),
                1,
            )?;
```
where the seeds are supposed to be the signature for treasury (which is a pda), and thats how the treasury was inited to begin with
this is the cpi i'm trying to do:
this is my context struct

```#[account(init, payer = creator, seeds = [b"core_mint".as_ref(), treasury_account.key().as_ref()], bump, mint::decimals = 1, mint::authority = treasury_account.key(), mint::freeze_authority = treasury_account) ]
    pub core_mint: Account<'info, Mint>,```
man i've been stuck on getting my signature right for minting, and turns out this contraint fails?

```assert!(core_mint.mint_authority == COption::Some(*treasury_account.key));```
what's the syntax for skipping preflight?
Yeah I was looking at its implementation
```
(method) PublicKey.findProgramAddress(seeds: (Buffer | Uint8Array)[], programId: anchor.web3.PublicKey): Promise<[anchor.web3.PublicKey, number]>
```
And I wanted to respectively use the bump that is returned from this function as unique ids since it is a number. For example, every new unique user that interacts with my program will have a unique number associated to them.
dont quite understand your use case but it is reasonable to assume that different inputs to the `findProgramAddress` will return different outputs (it's a hash function under the hood).
Hey I have a quick question, is it safe to assume that all users will have a different program derived address when I use the findProgramAddress function? I am generating a list of users by id and was wondering if I could do that by using the findProgramAddress function and passing it by the user's publickey.

hi, in rust i have a enum, 
enum ActivityTypeEnum{
Airdrop,
BoxNormal,
..
}

//my pda account
pub struct activity{
header: ActivityTypeEnum
}

in ts side how to parse the value,
    {
      "name": "ActivityTypeEnum",
      "type": {
        "kind": "enum",
        "variants": [
          {
            "name": "Airdrop"
          },
          {
            "name": "BoxNormal"
          },
          {
            "name": "BoxEssence"
          }
        ]
      }
    },

const mp = await program.account.activity.fetch(activity);
const myenum = mp.header.ActivityTypeEnum ? this is not work, any help with much thanks?
Just `anchor build`?
How do you generate a new idl file?
Hi, if your able to would you be able to tell me how you achieved what you are explaining here? I'm trying to make something similar to this
#[account(init, payer = voting_owner, seeds = [
        b"voter_votes",
        voter_pubkey.as_ref(),
        voting_state.as_ref().key.as_ref(),
    ], bump = _voter_votes_bump_seed)]
Why need to put user's pubkey in the seeds. I know that seed + bump is PDA but will it affect anything if seed has user's pubkey inside ? Eg: #[account(init, payer = voting_owner, seeds = [
        b"voter_votes",
        voter_pubkey.as_ref(),
        voting_state.as_ref().key.as_ref(),
    ]
option takes up one byte https://borsh.io/ see the specification
https://doc.rust-lang.org/std/option/
Someone correct me if I'm wrong, but `Option<>` is a Rust idiom to basically say "this can be null"
does wrapping a pubkey in Option<> increase the space to store it?
What does account initialization mean?
Hey guys quick noob question, what does it mean when I'm getting this: `anchorpy.error.ProgramError: 3012: The program expected this account to be already initialized`?
yes, this is exactly what i was looking for! thank you üôÇ
I was on the same mission yesterday:
```js
import idl from '../../target/idl/idl.json';

const programID = new PublicKey("3Ee8Sx8cP4b91Sf7nyGWHDpfwxKB6Mv3e1KTAozwHXjF");
const confirmOptions: ConfirmOptions = {
    skipPreflight: false,
    commitment: "confirmed",
    preflightCommitment: "processed",
    maxRetries: 10
};

//https://dev.to/edge-and-node/the-complete-guide-to-full-stack-solana-development-with-react-anchor-rust-and-phantom-3291
//https://docs.phantom.app/integrating/displaying-your-app

export const App: FC = () => {
    return (
        <Theme>
            <Wallet>
                <Content />
            </Wallet>
        </Theme>
    );
};

export const Content: FC = () => {
    console.log(idl);

    const wallet = useAnchorWallet();

    async function getProvider(): Promise<Provider | null> {
        if (wallet) {
            const network = "http://127.0.0.1:8899";
            const connection = new Connection(network, confirmOptions);
            const provider = new Provider(
                connection, wallet, confirmOptions,
            );
            return provider;
        } else {
            return null;
        }
    };

    async function createGroup() {
        const provider = await getProvider()
        // @ts-ignore
        const program = new Program(idl, programID, provider);
        await program.methods.createGroup().accounts().rpc();
...
```
React.js or react.tsx which is better for anchor?
I want to write a webapp for a program i wrote but i struggle a bit with the client (never did webdev/ts/js before). 
`// Read the generated IDL.
const idl = JSON.parse(
  require("fs").readFileSync("./target/idl/basic_0.json", "utf8")
);`
This doesent work for the website because i cant use "fs" nor load local files.
Im now looking to create a ts client which i can use for my webapp. The book says this:
> The anchor typescript client can automatically parse this IDL and generate functions based on it. What this means is that each anchor program gets its own typescript client for free!

Could someone please tell me how i can get my ts client for my program?
I read somewhere that we cant create a nft by using a wrapper over candy machine program, but  we can in our own custom program directly Interact with the metaplex program and spl programs to create nfts, is there any example of this done on anchor ?, Create nft in an anchor program, a simple one, just to get a grasp o. How it all works.
Something like this? https://github.com/Arrowana/anchor-scaffold
Hi there! I am trying to start my project but when I wrote "anchor in it <project>" it throws me this message. I have Ubuntu (KDE neon) and node v17. 7.0. Thanks for the help
Hey is there an anchor react template that I can clone from GitHub? Spent many hours today trying to initialize an anchor provider from react and no luck üò¶
It was devnet before but I changed it to run it on localnet on this branch. And I am able to run tests on my local machine. Or maybe I am missing something ??
In this branch it is localnet: https://github.com/MikaelCarpenter/NFT-Club/tree/subscription
I don't think so, based on your Anchor.toml
Actually it is localnet
(I can't actually run your tests because of this)
Are you actually using fresh addresses each time?
Oh, you're running your tests on devnet?
And here is the subscription program: https://github.com/MikaelCarpenter/NFT-Club/blob/subscription/programs/nft-club/src/components/subscription.rs
Specifically talking about subscription tests: https://github.com/MikaelCarpenter/NFT-Club/blob/subscription/tests/subscription.ts
Here it is
https://github.com/MikaelCarpenter/NFT-Club/tree/subscription
Oh my bad: sure I will send.
Not enough code above to tell what's going wrong
I can't really help any more unless you send me a full github repo, sorry!
`CreateSubscription` has the following validator
```
    #[account(
        init, 
        // seeded with creatorPubKey + userPubKey + "subscription"
        seeds = [creator.key().as_ref(), user.key().as_ref(), b"subscription".as_ref()], 
        bump, 
        payer = user, 
        space = Subscription::LEN
    )]
    pub subscription: Account<'info, Subscription>,
```

And `UpdateSubscription`, this one:

```
#[account(seeds = [creator.key().as_ref(), user.key().as_ref(), b"subscription".as_ref()], bump)]
pub subscription: Account<'info, Subscription>,
```

First create is called and then update is called with the same pubkey
Not sure, but yeah, that's what that error means‚Äîyou'll just have to look through what your code is doing
This is how it is being run  in a tests file
```
      txn.add(
        program.instruction.createSubscription({
          accounts: {
            subscription: subscriptionPubKey,
            creator: creatorPubKey,
            creatorSolAccount: creatorsWalletKeypair.publicKey,
            user: userPubKey,
            systemProgram: anchor.web3.SystemProgram.programId,
            tokenProgram: TOKEN_PROGRAM_ID,
          },
          signers: [usersWalletKeypair],
        })
      );

      txn.add(
        program.instruction.updateSubscription({
          accounts: {
            subscription: subscriptionPubKey,
            creator: creatorPubKey,
            creatorSolAccount: creatorsWalletKeypair.publicKey,
            user: userPubKey,
            systemProgram: anchor.web3.SystemProgram.programId,
            tokenProgram: TOKEN_PROGRAM_ID,
          },
          signers: [usersWalletKeypair],
        })
      );
```
That's the only thing that that error means
Are you sure you aren't accidentally init'ing it somewhere else?
That's fine
But actually it is not init
```
#[account(seeds = [creator.key().as_ref(), user.key().as_ref(), b"subscription".as_ref()], bump)]
```

Is this also supposed to return the error ?
It means there's already an account there, but you're apparently trying to `init` another one
What does the error: `Allocate: account Address { address: B84QasHcaN4rz65sYm4myKDx4LvyTTFNijwhogYpK95B, base: None } already in use` mean ?
at the moment I'm just using a new arbitrary keypair in each thread since for rpc account requests it doesn't seem to matter
Sorry, misunderstood that
Ohhh
I can't send an Rc to a different thread at all, nor an AnchorClient for that reason
okay header now needs to be #[error_code] (in 0.21) as opposed to #[error] in prev versions (till 0.19)
how did you get it to compile? I'm still getting the "cannot find attribute `error` in this scope" when i try to compile
Can you just do
```.rs
let payer = Rc::new(payerKeypair);
let payer2 = payer.clone();
let payer3 = payer.clone();
```
(and doesn't seem to be clone on the secrets e.g.)
I'm trying to parallelize some RPC calls, but I'm having difficulty sharing the payer Keypair, which is Rc in the anchor client constructor


//////////////////////////////////////////////////////////////////////////////////////////

Weirdly even swapping for absolute path of run-integ-tests.sh doesn't work
<@!134416332509675520> Thanks for the link, I will continue to test and reseach on this topic maybe I missed something
Anchor isn't doing anything but pass those filters along to solana
According to the solana docs, they ought to already be ANDed together: https://docs.solana.com/developing/clients/jsonrpc-api#parameters-26
I'd like to have all account that match both `memcmp`
Hi, I'd like to apply to `memcmp` filter in `AND` logic like
I've tested this, but I have an `OR` logic like
```typescript
  const data = await program.account.proposalAccount.all([
    {
      memcmp: {
        offset: ProposalAccountOffset.Slug,
        bytes: stringToBytes(input),
      },
    },
    {
      memcmp: {
        offset: ProposalAccountOffset.State,
        bytes: proposalStateEtoBytes(ProposalStateE.funded),
      },
    },
  ]);
```
Mm, think something must be odd about the directory structure, etc. That error means that the shell can't find that executable
yep its there
Do you definitely have that `./scripts/run-integ-tests.sh` file?
```Failed to run test: ./scripts/run-integ-tests.sh: No such file or directory (os error 2)``` any idea on this error, also i have installed mocha globally?
anchor-cli is just released recently
May it an error of anchor-cli or solana-cli
invalid blockhash, interesting
Im using anchor-cli 0.22.0, solana-cli 1.9.13
This is another message

that still not enough?
I airdroped like 5 sol in my wallet
Get more balance then run the write buffer command it gave you
I've gotten this before when I didn't have enough balance in my wallet. You need 2x the rent cost b/c of the intermediate buffer cost.
and sol in my wallet decreased üò¶
I got this error when deploying my program to devnet, What does it mean üò¶
In my program, i have an account and an enhanced account (stores account + extra info). Is there a way to set the context struct to support either one of these, or do I need to make two different context structs?
we need only to run "anchor deploy" to update a smart contract right?
#[derive(Default)]

<@!134416332509675520>  what does mean that?
Can I throttle it its just for testing
This often happens when you ask for too many airdrops of SOL üôÇ
Hi. again I am trying to run tests on devnet . I get `Server responded with 429 Too Many Requests.  Retrying after 500ms delay...` anyway to solve this without storing keys locally?
Thanks figured it out appreciate the help üôå
You can configure that in Anchor.toml
Maybe push your program to devnet to check whether it's a local-only issue
found it but wouldn't help I think
I'm not sure how that command works
I am writing tests in rust and using solana-program-test
how to do that sorry
no i have not
My first guess is that the chain is not in the state your program expects. If you're testing locally, have you reset your validator?
so only one instruction creates the pda in the whole program so how might I fix this?
Sounds reasonable
Well I am not doing explicitly at least it a pda being init by the program?
It seems like you're trying to set the size of an account that already exists, which isn't allowed
Hi. Any info on `Account data resizing not supported yet: 0 -> 232. Consider making this test conditional on `#[cfg(feature = "test-bpf")]` solving this error?
Technically, you are better than me haha ! Im a perfect newbie. So you are not a newbie anymore
Thanks for kind words. üòä
No problem ! Some here are big boss ! You will be too one day üòä
IDK, I'm a pretty newbie here. haha.
If you know how üëÄ Why not ü•≤
No gem farm allowed üòÇ
Damn that perfect ! I have 1 of my 4 program now haha ‚ù§Ô∏è

Others are :
- Stake NFT (multi staking, with multiple GEN and $COIN reward and lock time)
- Inject liquidity pair in a pool $COIN/USDC for have a second token
- Stake the second token for being rewarded with the first token
Oh. And Token program is callable with Anchor. I got it. But, I see in the example about the need of create a swap pool ??? But we already have a pool for create the DEX $COIN/USDC. Did I missed something ?
I recommend you to check this repository out https://github.com/project-serum/anchor, especially `tests` directory.
Yes, the smart contract is just the on-chain program typically written in Rust. To swap tokens, you could invoke the Token Swap Program from your own code. https://spl.solana.com/token-swap
Hi ! I have a noob question‚Ä¶

A Smart Contract is only the RUST part?  Or are the algorithms in Web3 also considered as Smart Contract?  I ask this question because I was told that it was possible to do a token exchange ($COIN <-> UDSC for example) with a Smart Contract.  But I don't see how Rust/Anchor can do that ü§î
Found an example. This project has some custom client-side code that uses the oracle's idl
https://github.com/Synthetify/synthetify-protocol/blob/master/tests/oracleUtils.ts
are there any tools to help visualize accounts ?
How would you test oracle-dependent code locally? That is, how would you mock an oracle?
is there alternative to set local connection??
OK, it seems a more complicated issue than I thought.
is there better way to do this ```const provider = anchor.Provider.local();
```
i dont want to fix it on my webpack side
nah its anchor issue
I think it is about the node.js issue. 
Check to install Node.js well out and its related packages.
I recommend you re-installing the Node.js framework.
After that, delete the `node_modules` directory in your project directory and run the command `npm install` or `yarn` to install the related packages.
I need solution for that?
but i cant use it with vue
provider uses fs module in anchor
<@!943367070702243862>
Could you show the error messages?
Thanks a lot! 
You are saving my time again. 
It was because of the `#[account(mut)]`'. üòÖ
hi, how can i fix the fs module error that Im getting while using provider local for anchor in the client side ?
If you look at the full program log you'll see a line about so-and-so's writable privilege escalated
Error message is a little confusing, but you need to mark the `mint` as `#[account(mut)]` (the mint keeps track of its total extant supply, so burning tokens requires mutating the mint)
Can I get some advice on token transferring and burning in Anchor?

These two code block exists in the same function. 
The transfer is working, but the burn is not working.

What am I missing?

Do I need to sign to create CpiContext even I passed the token owner's account?

The transfering block is below:
```
let cpi_accounts = Transfer {
    from: ctx.accounts.user_token.to_account_info().clone(),
    to: ctx.accounts.token_acc.to_account_info().clone(),
    authority: ctx.accounts.authority.to_account_info().clone(),
};
let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
transfer(cpi_ctx, status.fee)?;
```

The burn block is below:
```
let cpi_accounts = Burn {
    mint: ctx.accounts.token_mint.to_account_info(),
    to: ctx.accounts.user_token.to_account_info(),
    authority: ctx.accounts.authority.to_account_info(),
};
let cpi_program = ctx.accounts.token_program.to_account_info();
let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
burn(cpi_ctx, amount)?;
```

The struct is below:
```
#[derive(Accounts)]
pub struct Swap<'info> {
    #[account(mut, constraint = user_token.owner == authority.key())]
    user_token: Account<'info, TokenAccount>,
    #[account(mut, constraint = user_token.mint == token_acc.mint)]
    token_acc: Account<'info, TokenAccount>,
    token_mint: Box<Account<'info, Mint>>,
    #[account(mut)]
    status: Account<'info, Status>,
    token_program: Program<'info, Token>,
    authority: Signer<'info>,
}
```

The Error message is below:
```
Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account
```
Thanks that seemed to fix it
Ill try that
This is the accounts I'm trying to init
So probably you need both: `signers: [lotteryAccount, vaultAccount]`
Their addresses (keypairs, really) need to sign
Which accounts are you initializing here?
That means you need to sign with something else
Seem to still be getting this error after removing the signers array
Right that makes sense
In general the `signers` array has to hold keypairs, not public keys (you need the actual private key to be able to sign‚Äîthe public half isn't enough)
You actually don't need that `signers` array at all here (the `provider.wallet` signs no matter what since it pays the tx fees)

Does anyone have any idea how to fix this issue? I'm passing the wallet pubkey from react into the signer which should be right
Cool! Yeah, the multisig program is definitely instructional to read
got it! thanks for clearing this all up
So no, I mean the token program exposes a way to do that‚Äîthe multisig program exposes a way to run any tx, but that tx needs to then go ask some other program/programs to do things they already know how to do
It's completely generic over what tx you want to do
All the multisig program does is just `invoke_signed` whatever transaction you want to run, it can be anything at all: https://github.com/project-serum/multisig/blob/master/programs/multisig/src/lib.rs#L186
"if you want to send a tx to mint some tokens, you can do that, because the token program exposes a way to do that" - do you mean the *multisig* program exposes a way to do that?
(But if it did have a `pub fn rescue_trapped_multisig_sol`, then you could)
I guess the way I'd phrase that is that if you want to send a tx to mint some tokens, you can do that, because the token program exposes a way to do that. But if you want to rescue that sol, the multisig program just doesn't provide that functionality‚Äîso doesn't matter what tx you send it to execute, it just doesn't have any way to do what you want it to do
Understood - so basically a txn for sending SOL needs making changes to data *inside* the account which is not possible. But a txn for minting tokens from the multisig, is possible directly from the existing code
At any rate, there just isn't any transaction you could submit that could rescue that sol, since the multisig program just doesn't provide an instruction to do it.
(Though in principle one could be added‚Äîthen you could rescue that sol)
And the multisig program just doesn't provide an instruction to do that.
The issue is that in solana, every account has a program owner, and only that program can decrement the account's sol or mutate its data‚Äîno other program has those rights. In this case, the multisig account (the one with the multisig data in it, that struct I linked above) is owned by the multisig program itself, so *only* the multisig program itself can decrement those lamports.
just one clarification - if the multisig code can enable any transaction through it then why can it not enable sending SOL held in the multisig account? (just trying to figure what makes this txn different)
Sweet big thanks for the help
thank you <@!134416332509675520>
its just this... sleep is important my friends
ctx.accounts.escrow_account.initializer_receive_token_account = *ctx.accounts.initializer_receive_token_account.to_account_info().key;
omg I am so dumb
That sets the `initializer_receive_token_account` variable (of type `Pubkey`) on the escrow_account struct
Yeah, it could even just be a `pub vault: SystemAccount<'info>`
Hey guys
Does somebody know what the following does exactly:
```
 ctx.accounts
            .escrow_account
            .initializer_receive_token_account = *ctx
            .accounts
            .initializer_receive_token_account
            .to_account_info()
            .key;
```
https://github.com/ironaddicteddog/anchor-escrow/blob/master/programs/anchor-escrow/src/lib.rs
its from this
I see, tysm! very helpful
Ok sweet thanks, can I just define the vault account as a regular account within the program then?
Assuming the source of the sol is the user's wallet etc.
You'd instead (probably, depends) use the system_instruction::transfer instruction to do the transfer
No, vanilla sol isn't a token at all, so no need for token accounts or mints of any kind
So Ive just been creating the account like this, because I want to transfer sol to the vault account by user, however is the mint parameter necessary if its just sol?
You can execute whatever kind of transaction you want
No, that's what the transaction stuff is for
Also, I'm actually looking to use the serum multisig code to make the multisig a mint_authority for a token. I'm guessing that I would have to write custom instructions in the existing code to enable minting from the multisig address?
No, I put it in the multisig account only. And I get what you're saying - the current multisig does not have an instruction to transfer SOL and hence the sol I sent to it is locked in that account forever
How do you want to do it? In your rust program? Via the cli, etc.?
What would be the process of transfering then in that case?
None, sol isn't a token actually, it's just sol
Say I want to transfer sol from one account to a PDA, what mint address would I use?
What is the address of the account like?
Or, wait, do mean you've put the sol in the multisig signer PDA?
But let me double check
So, assuming I'm reading the program right, that sol is locked in that multisig account forever-ish
The multisig program would need to provide an instruction for moving sol out of the multisig account (or closing it, etc.), but I don't see that it has one
I'm not super familiar with the serum multisig but I'm actually not sure that's possible‚Äîgenerally it's not a good idea to send sol to an account owned by a totally different program (rather than to a regular wallet account, owned by the system program)
yes, and i want to send the SOL from the multisig account to some other account
So the sol is in the multisig account itself? This thing? https://github.com/project-serum/multisig/blob/master/programs/multisig/src/lib.rs#L245
Hi, this is related to serum_multisig:
I'm trying to move SOL held in my multisig account by creating a transaction using the create_transaction method in the multisig code. However, I feel that create_transaction only allows to create transactions for methods that are already written in the serum_multisig program (for eg set_owners). Can someone confirm if I need to write a new method to the original serum_multisig code for transferring SOL?
Got this error when calling my Anchor program (which works fine when I use `anchor test`) from a React app. Any idea what this error means? Does it have to do with passing a BN into an instruction?
Also this? `InvalidRentPayingAccount`
I get this error? any ideas how to solve this.
HI. `Account data resizing not supported yet: 0 -> 232`
i have a question regarding seeds for PDA gen...
this works fine: 
```seeds = [b"123456", user.key().as_ref()],```
and then when using a string with the same valu from instruction args like this: 
``` seeds = [&block_id_string.as_bytes(), user.key().as_ref()],```
I get the error:
```Program failed to complete: Could not create program address with signer seeds: Length of the seed is too long for address generation```

although the string passed in instruction args, block_id_string = "123456"

i have an issue here:
https://github.com/project-serum/anchor/issues/1641


//////////////////////////////////////////////////////////////////////////////////////////

when anchor init's accounts, does it make them rent-exempt? 
in other words, does the init transaction include an instruction to send as much SOL to that account, as would be needed to make it rent-exempt?
"That" being this
<@!254789293267091458> Magic! That did the trick for me, thank you üôÇ
oops thanks
https://discord.com/channels/889577356681945098/889606719829835816/954754995985727578
GM folks. I am working on a project which uses anchor v0.13.2.. could anyone point me to where I can find anchor docs of that version?
How can I get spl token's decimals with @solana/spl-token?
yes, that was it - doing `use myanchorprogram::*` was messing it up. Just `myanchorprogram::id` without importing anything did the trick - üëç
Oh, just do `myanchorprogram::ID`, not `myanchorprogram::myanchorprogram::ID` etc.?
Hmm, weird, those are ostensibly both `pub` in the anchor macro source, not actually sure why they would end up being private
still saying private static - I found an example here to reverse engineer https://github.com/metaplex-foundation/metaplex-program-library/tree/master/auction-house/program
Just do `myanchorprogram::ID` instead maybe
I was trying to set up bpf tests in rust, but getting private function errors:
```rust
ProgramTest::new("myanchorprogram", myanchorprogram::myanchorprogram::id(), None)
```
```
error[E0603]: function `id` is private
  --> programs/myanchorprogram/tests/myanchorprogram.rs:5:63
   |
5  |     ProgramTest::new("myanchorprogram", myanchorprogram::myanchorprogram::id(), None)
   |                                                                           ^^ private function
```
So, it was zero because you were grabbing the first 8 bytes of that u64 which were probably all zeros
The arguments have to appear in the same order as in the function, but you can omit args after those that you need. So, should put all bumps and args used first and then any others
Hmm isee. Thank you.
No, instruction arguments all use borsh
Does anchor support that automatically or ?
Can I implement zero copy instead of clone for that ?
So sure will do that. Thank you so much.
Oh makes sense. Gotcha
But yeah, maybe being able to pass an account struct ought to work too
Try doing
```.rs
#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub struct YourArgument {
  name: String,
  foo: u8
}
```
It can, but not an account struct
So, its instruction doesn't take struct as its parameter ??
üëç
Thank you for your time brah
that would be lot easier. If you could do something like that tbh
It was my mistake, i was passing config as a parameter in the instruction... ü§ï I fixed it.
Oh sure. Just give me some time.
If there's an actual bug here anchor would like to know about it/fix it
No, the whole project
For idl ?
Can you just send me your code in a github link or whatever?
Coz I've other struct type build the same way. And they r working perfectly fine ..
Just doesn't work on the client side ...
And gives me new idl
It rebuilds fine
I wouldn't need that at this stage ... haha
Assume that this will have a simple explanation, it will make debugging easier.
What happens if you add it back and rebuild etc.?
Dafaq... ü•≤
üò∂
In my rust and created a new idl again..
It worked after I removed the config
Can you just post the whole idl file?
Copy what inside to the idl in my client side
Anchor deploy
Anchor build
You have to run something in order to produce it/update it once you make changes etc. How are you doing that?
Wym by building idl?
That part should be fine actually, how are you building the IDL?
i will try deleteing the config and see what happens and get back at u
i see. seems fair but sad.
```rust
#[account]
pub struct Config {
    pub bump: u8,
    pub is_initialized: bool,
    pub mint_account_authority: Pubkey,
    pub admin_account_authority: Pubkey,
}

impl Config {
    /// space = 8 + 1 + 32 + 32 
    pub const LEN: usize = size_of::<Config>() + 8;
}
```
It's generated automatically, but not in a super robust way yet lol
Ohh I didn't knew it would matter in my smart contract coz the idl was generated automatically
Ok, how is that Config type defined in your rust code?
ü•≤

this is literally everything
```js
const anchor = require("@project-serum/anchor");
import idl from "../utils/idl.json";

const provider = new anchor.Provider(connection, wallet, { commitment: "processed" });
anchor.setProvider(provider);

console.log(provider, "provider is working")
// Address of the deployed program
const programId = new anchor.web3.PublicKey(idl.metadata.address);

// Generate program client from IDL
console.log(idl)
const program = new anchor.Program(idl, programId);
```
i tallied it with the other idl examples
idk looks ok to me.
What does the idl look like if you log it etc.? Does it actually look ok?
Import idl from "./program.json";
Can you post more code? How is that idl thing defined?
Im Literally passing the idl from anchor  smart contract..
Did I fuck it up somewhere ?
Brah why is it giving me that error ü•≤
This error sucked in all me energyü•≤
It just doesn't do anything ...ü•≤
Coz im trying to use that with program.state.instruction.initialize () and add this to a tx
Oh yea, I looked at it. Thank you. That make sense.
No, it gives me undefined value for the program üò∂
It is recommended practice to prevent attack. I am not a good explainer so u can check cqfd's answer. üòÖ
Does your code work if you ignore that error?
Alas, closing accounts is surprisingly subtle in solana: https://discord.com/channels/889577356681945098/889606719829835816/954329783813144616
ü•¶
brah, why is it giving me error, when Im literally passing idl there??
Macro handles it
No, the discriminator isn't part of the address, it's part of the account's data. You can do
```.rs
use anchor_lang::Discriminator;
let bytes = TheAccountStruct::discriminator();
```
Hi, I literally have this on the  anchor client and its giving me error on this idk y.. 
```const program = new anchor.Program(idl, programId);```
when I pass the idl to the the anchor program .. it give me this error.
``is not assignable to parameter of type 'Idl'``
when you close the account will be deleted so? why would you require to delete the data
If I close PDA using anchor account attribute #[account(mut, seeds, bump, close=xxx, )], should I still clear data inside PDA? Or will it be handled by macro?
or do i do to just use await program.rpc.someinstruction??
Hi, while connecting to the smart contract throught client in anchor, can I add the instruction to the transaction and pass it through the sendconfirmation??
‚Äò‚Äô‚Äôyarn add ts-mocha‚Äô‚Äô‚Äô updating it to the latest one usually fixed that one for me
Still having issues with this. Looks like `$f9936ec00aa88bd7$exports` which is `anchor` never gets built by Parcel into my production build. I imported anchor by `import * as anchor from '@project-serum/anchor`

What configuration steps are needed from Parcel to support it? CRA is atrocious and I want to avoid using that if I can üòÖ
and I dont know how which variable to use for payer in that function
yeah and this is my getOrCreateAssociatedTokenAccount
This function is used to get all the token accounts of a User using the mint or the TOKEN_PROGRAM_ID
If the Token Account hasn't been created for that user than you have to call the getorCreateAssociatedToken Account function from the solana spl lib
<@!743130416801775687>
What is that function? I used getTokenAccountbyOwner but it return empty array if the user‚Äôve never added the token to wallet
Im still stuck with this error and do have mocha installed globally and the file does exist, changing to absolute path of file also results in same error. Any help on this will be appreciated.
Thanks!
https://switchboard.xyz/
There is no fixed way to do that everyone does it in their own way.
hi! is there a way to generate a random number in the program?
Use the web3 library to get the token accounts
Can you give me an example please
You need to construct the tx object and get it signed this way
`program.provider.send(tx,[mint]);` This is what i do when i am using anchor
I need to get token account of connected wallet from my app
But i need to get token account first
Yes
Are you using Anchor to sign tx ?
```
        space = {
            let space = (Game::LEN as u64).wrapping_add((max_participants as u64).wrapping_mul(Game::PACTICIPANT_LEN as u64)).try_into().unwrap();
            space
          })]
```
Got it to work. max_participants was 0. Not sure why this didn't work...
```
#[instruction(max_participants: u8)]
```

Update all argument
```
#[instruction(stake: u64, max_participants: u8, lucky_num: u8, vault_bump: u8)]
```
how to get this Signer object with wallet-adapter?
45000000049 is O(10^10) bytes. can you verify you are computing/requesting the right number of bytes by doing this and reporting back:

```rust
#[account(
  init, 
  payer = initializer, 
  space = {
    let space = Game::LEN + (max_participants * Game::PACTICIPANT_LEN);
    msg!(format!("requesting {} bytes for game_info", space));
    space
  },
)]
pub game_info: Account<'info, Game>,
```
I'm trying to set dynamic space allocation.
```#[derive(Accounts)]
#[instruction(max_participants: usize)]
pub struct Initialize<'info> {
    #[account(init, payer = initializer, 
        space = Game::LEN + (max_participants * Game::PACTICIPANT_LEN))]
    pub game_info: Account<'info, Game>,
    #[account(init, payer = initializer, space = Vault::LEN, seeds = [b"pubkey"], bump)]
    pub vault: Account<'info, Vault>,
    #[account(mut, constraint = initializer.lamports() >= game_info.stake)]
    pub initializer: Signer<'info>,
    pub system_program: Program <'info, System>
}```

However I'm having issue with max_participants, which I'm passing in as an argument.
When I manually set that amount to a fix integer. It works.

```
Transaction simulation failed: Error processing Instruction 0: custom program error: 0x3 
    Program 8BQunCRwyBZ3EaPP4bmCraTWhVvazrajNR3CtTM7P5rT invoke [1]
    Program log: Instruction: Initialize
    Program 11111111111111111111111111111111 invoke [2]
    Allocate: requested 45000000049, max allowed 10485760
    Program 11111111111111111111111111111111 failed: custom program error: 0x3
```

I'm getting this issue. Seems like max_participants is no deserialise? Any advice?
within a context, how can I easily get the 8 byte unique account identifier of an account? is it just the first 8 bytes of `account.key().to_bytes()`?
btw, what is in your Accounts struct that is creating the Accounts<never> ts type?
yes
By using `Account<'info, Mint>` in a context, does that assert that the token passed in is a mint account, i.e. cannot pass in a random pubkey
i think you need to handle the null for rewardBMint
This is the call I am making:
```
        const txSig = await this.poolProgram.rpc.initializePool(
            poolNonce,
            rewardDuration,
            {
                accounts: {
                    authority: this.provider.wallet.publicKey,
                    xTokenPoolVault: xTokenPoolVault,
                    xTokenDepositor: this.xTokenPubkey,
                    xTokenDepositAuthority: this.provider.wallet.publicKey,
                    stakingMint: stakingMintObject.publicKey,
                    stakingVault: stakingMintVault,
                    rewardAMint: mintAObject.publicKey,
                    rewardAVault: mintAVault,
                    rewardBMint: singleStake ? mintAObject.publicKey : null,
                    rewardBVault: singleStake ? mintAVault : mintBVault,
                    poolSigner: poolSigner,
                    pool: poolPubkey,
                    tokenProgram: TOKEN_PROGRAM_ID,
                },
                signers: [poolKeypair],
                instructions: [
                    await this.poolProgram.account.Pool.createInstruction(poolKeypair, ),
                ],
            }
        );
```
Hello, I am trying to interact with my rust program on the client side, but I constantly face this error:
```
Argument of type '[number, BN, { accounts: { authority: PublicKey; xTokenPoolVault: PublicKey; xTokenDepositor: PublicKey; xTokenDepositAuthority: PublicKey; ... 8 more ...; tokenProgram: PublicKey; }; signers: Keypair[]; instructions: TransactionInstruction[]; }]' is not assignable to parameter of type '[...(number | BN)[], Context<Accounts<{ name: "authority"; isMut: false; isSigner: false; } | { name: "xTokenPoolVault"; isMut: true; isSigner: false; } | { name: "xTokenDepositor"; isMut: true; isSigner: false; } | ... 9 more ... | { ...; }>>]'.
  Type at position 2 in source is not compatible with type at position 1 in target.
    The types of 'accounts.rewardBMint' are incompatible between these types.
      Type 'PublicKey | null' is not assignable to type 'Address | Accounts<never>'.
```
Could I get some help on this?
if i have 2 entry points with very similar account lists, is there a way to avoid duplicating the code?
hi all, saw a couple of mentions of this in here, but nothing that made it particularly clear to me what the cause was or the actions to resolve it ```gm-solana/tsconfig.json" needs an import assertion of type "json"``` Anyone happen to know? This is just gm-solana created with Anchor out of the box as a test. Only potential complicating factor I could think of is it's in Manjaro in WSL.
makes senses thanks
oh so its because it was init before already
Hey guys, calling `anchor build` does not generate the types file under /target/types for me. Only generated it for the first time i ran it, and did not update subsequently after running it. Does anyone know the solution to regenerating and updating the types file? Thanks so much!
Sounds like you're passing in an account that didn't need `init_if_needed` (was already init'd), but it has the wrong amount of space
The "train" is in a
#[derive(Accounts)]
#[instruction(vault_account_bump: u8)]
pub struct Initialize<'info> {
btw.
Happens since I am using 2 vectors, somehow
i get the error when I call it
Error Code: ConstraintSpace. Error Number: 2019. Error Message: A space 

Anybody knows what this means?
```
#[account(
            init_if_needed, 
            seeds = [initializer.key.as_ref()],
            bump,
            payer = initializer, 
            space = 2048
    )]
    pub train: Account<'info, Train>,

#[account]
pub struct Train {
    pub wolves: Vec<Pubkey>,
    pub wolves_time: Vec<i64>
}
```
how can i get unix timestamps of previous epoch start time?
thank you so much that did the trick
yea i didnt mark the payer as mut, let me see if that fixes it
~~But I guess there's no system program in that log, so nevermind~~ [edit: mm, not sure]
Every `init` is a CPI
You've forgotten to mark some account as mut (maybe the payer for an init?)

Can you post the error?
hey guys im getting this CPI error but I don't think I am calling another program, can someone help me out?
thanks! this clears that up for me
Then inside the .json file is

```json
{
    "name": "BitWhips S1AD - #187",
    "symbol": "BWTSLR",
    "description": "BitWhips S1 AirDrop - Teslerr",
    "seller_fee_basis_points": 1000,
    "image": "IMAGE LINK",
    "external_url": "www.bitwhips.io",
    "edition": 187,
    "attributes": [
        { "trait_type": "Backgrounds", "value": "Custom" },
        { "trait_type": "Treads", "value": "Custom" },
        { "trait_type": "Shadow", "value": "Custom" },
        { "trait_type": "Wheels", "value": "Custom" },
        { "trait_type": "Headlights", "value": "Custom" },
        { "trait_type": "Tint", "value": "Custom" },
        { "trait_type": "Bodys", "value": "Custom" },
        { "trait_type": "Line Art", "value": "Custom" },
        { "trait_type": "Plugs", "value": "Custom" },
        { "trait_type": "Accessories", "value": "Custom" },
        { "trait_type": "Ditto", "value": "Custom" },
        { "trait_type": "License Plate", "value": "Custom" }
    ],
    "properties": {
        "files": [
            {
                "uri": "IMAGE LINK",
                "type": "image/png"
            }
        ],
        "category": "image",
        "creators": [
            { "address": "blahblahblah", "share": 0, "verified": true },
        ]
    }
}
```
so then inside the json will be my image url?
```json
{
  "name": "BitWhips S1AD - #187",
  "symbol": "BWTSLR",
  "uri": "LINKTOJSON.json",
  "sellerFeeBasisPoints": 1000,
  "creators": [
    {
      "address": "blahblahblah",
      "verified": 0,
      "share": 0
    }
  ]
}
```
doh
ahh
What you have there is an image
the uri field needs to navigate to a JSON file with the image, name, symbol, and attributes as well.
that is my code btw for the metadata
```
// metadata params
        let data = DataV2 {
            name: "TEST_TICK".to_string(),
            symbol: "TEST".to_string(),
            uri: "https://emojipedia-us.s3.dualstack.us-west-1.amazonaws.com/thumbs/320/openmoji/292/admission-tickets_1f39f-fe0f.png".to_string(),
            seller_fee_basis_points: 0,
            creators: None,
            collection: Some(Collection {
                verified: false,
                key: ctx.accounts.collection_mint.key(),
            }),
            uses: None,
        };
```
ah, will it be on solscan though if im running on localhost?
Check the metadata on Solscan. I just had a mainnet mint where the metadata url actually navigated to a manifest of somesort from arweave, instead of the actual metadata + image.
hi all, I minted my own NFT on localnet using the metaplex program (cloned from devnet) and I can successfully mint it but in the phantom wallet the image never loads, has anyone else seen this before?
Getting this error in production in regards to this line here. Everything works in dev server just fine. Using parcel to build the app. I'm modifying a mint page to add some extra functions. User types a metaplex candy machine id and the site will load it so they can mint nfts from it. The mint page I took this function from uses @project-serum/anchor 0.14.0, while I'm now using 0.22.1. I figured since I'm using an updated version I may need to switch things up but not sure what needs to be changed. Any insight is appreciated!

Full function

```typescript
export const getCandyMachineState = async (
    anchorWallet: anchor.Wallet,
    candyMachineId: anchor.web3.PublicKey,
    connection: anchor.web3.Connection
): Promise<CandyMachineAccount> => {
    const provider = new anchor.Provider(connection, anchorWallet, {
        preflightCommitment: 'recent',
    });

    const idl = await anchor.Program.fetchIdl(CANDY_MACHINE_PROGRAM, provider);

    const program = new anchor.Program(idl, CANDY_MACHINE_PROGRAM, provider);

    const state: any = await program.account.candyMachine.fetch(candyMachineId);
    const itemsAvailable = state.data.itemsAvailable.toNumber();
    const itemsRedeemed = state.itemsRedeemed.toNumber();
    const itemsRemaining = itemsAvailable - itemsRedeemed;

    const presale =
        state.data.whitelistMintSettings &&
        state.data.whitelistMintSettings.presale &&
        (!state.data.goLiveDate || state.data.goLiveDate.toNumber() > new Date().getTime() / 1000);

    return {
        id: candyMachineId,
        program,
        state: {
            itemsAvailable,
            itemsRedeemed,
            itemsRemaining,
            isSoldOut: itemsRemaining === 0,
            isActive:
                (presale || state.data.goLiveDate?.toNumber() < new Date().getTime() / 1000) &&
                (state.data.endSettings
                    ? state.data.endSettings.endSettingType.date
                        ? state.data.endSettings.number.toNumber() > new Date().getTime() / 1000
                        : itemsRedeemed < state.data.endSettings.number.toNumber()
                    : true),
            isPresale: presale,
            goLiveDate: state.data.goLiveDate,
            treasury: state.wallet,
            tokenMint: state.tokenMint,
            gatekeeper: state.data.gatekeeper,
            endSettings: state.data.endSettings,
            whitelistMintSettings: state.data.whitelistMintSettings,
            hiddenSettings: state.data.hiddenSettings,
            price: state.data.price,
        },
    };
};
```
```Use this to clone an account from the test.validator.clone.url cluster to the cluster of your test. If address points to a program owned by the "BPF upgradeable loader", anchor (>= 0.23.0) will clone the program data account of the program for you automatically.```
this is from the anchor book, so we need to wait for anchor 0.23.0 for this feature ? until then we should clone both bpf upgradeable loader for example of the token metadata acc and the program data of token metadata ?
Ah yeah
<@!134416332509675520>
use the `pubkey!` macro though instead of doing `"..".parse()`
the anchor program id is the public key of the keypair generated when i did anchor init program_name, right ? if so where is this keypair privatekey / file wallet stored ?
it works like this. Thank you
thank you for your help. I new new to Rust. Thats why I can (am by the way) surely do silly mistakes due to not deep understanding. But I am learning. Your answer will surely help me understand better
(You should instead probably be doing `address = "bufford....".parse().unwrap()`)
In what way did it not work? That constraint definitely looks wrong to me, but in a way unrelated to the CHECK stuff
I tried something like this but it didn't work
yes, thank you. I read this. I just don't know how to check "address" for a string constant. I need to make a Pubkey from a string before that somehow
https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html
You can see all of the constraint here. For your use case it should be `address =`
<@!134416332509675520> That's right the logic of `memcmp` is already ANDed my bug was elsewhere üôÇ
if I expect a particular pubkey there
hey guys. Any options to check an account pubkey for a constant inside anchor contraints?
Hey! I'm facing an IDL issue while running anchor tests -
So for a while now i havent been able to  install ancohr it keeps giving the error that the build for spl token 3.2.0 failed, i have reinstalled solana and tried to reinstall anchor too but too no effect, it still gives the same error,


//////////////////////////////////////////////////////////////////////////////////////////

Why are you using the program id as one of the seeds? Not sure what the point of doing that is, since the program_id is already an ingredient in the PDA (under the hood it's already part of the sha256 hash)
Ah, ok, you have access to it as `ID`
The program ID was used as part of the seeds.
Ah, maybe you can just do `anchor test --provider.wallet path/to/wallet`
Yeah, seeds *plus* the right bump. You don't need to know the program id, only the seeds + bump.
Do I use the same seeds as the signer seeds as to generate the PDA? If so, how do I get the program ID outside of a macro?
doesnt work. I tried `console.log(anchor.Provider.env().wallet.publicKey.toString());` and its still not the same as the one in `ANCHOR_WALLET` . Am I setting it correctly I do `ANCHOR_WALLET=<path to keypair>`, do I have to run anything after to change it?
Ah, that might be it then. I've been using CpiContext::new instead.
You sign within the program when you do a CPI, using invoke_signed (or CpiContext::new_with_signer)
Recalling the signer escalation error I mentioned yesterday. I added the only non-PDA involved as a signer from the client, and got this error, saying that the signer is unknown. How do I sign using a PDA from within the program itself?
Use anchor.Provider.env() instead I think
small bump
What do you mean by marked unknown? Can you show an example?
PDAs can't sign from the client, but their deriving program can sign for them within the program itself.
Is there a way to use a PDA as a signer? In general, where can I find the rules for what sort of signers an instruction requires and why some signers are marked unknown?
Hi I have a question about anchor wallet. In `anchor.toml` I have this `wallet = "~/.config/solana/id.json"` which means that the program deployed is owned by this wallet. In my test I want other other than the one that owns the program eg. These wallets are meant to be users. Currently I just hardcode the private keys of these wallets on my test file, is there a better way to store them? I tried setting `ANCHOR_WALLET=<user_keypair>` .json but `anchor.provider.local()` seems to not get it
current set up only allows for fungible tokens as whitelist tokens
sup y'all, im trying to see if i can hack metaplex a bit so i can set multiple tokens as whitelist tokens (use nft collection as whitelist tokens, all with unique mint addresses) does anyone have any tips on where to look/what to potentially change?
https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html#instruction-attribute
üëã is there any good documentation on the `#instruction` macro? Can't seem to find anything here https://book.anchor-lang.com/
np
seems cleaner, thank you so much
which is usually what the program expects
to get the lamports equiv
yes
right... so basically i do something like? 
`new BN(1 * LAMPORTS_PER_SOL)`
use the LAMPORTS_PER_SOL variable in web3.js
Or normally I should create transaction and add accounts to it?
Try searching the anchor repo for `remainingAccounts:` lots of examples
would  best practice be to handle adding the zeros on the reactjs side or, to add the zeros on the program instruction side, or it don't matter?
Hey, is way to pass   ctx.remaining_accounts from typescript?
That's a million, not a billion üòõ
oh f me. so I want to send 1 sol i need to do a `new BN(1000000)` ?
So you're sending about a millionth of a sol
Sol is denominated in lamports, which are 1 billionth of a sol
HI Guys whats going on here? Trying to send 999 sol, but wallet is saying i'm trying to send a miniscule amount?

reactjs:
`await program.rpc.sendSol(new BN(999), {
        accounts: {
          from: provider.wallet.publicKey,
          to: destination,
          systemProgram: SystemProgram.programId,
        },
      });`

lib.rs:
`pub fn send_sol(ctx: Context<SendSol>, amount: u64) -> Result<()> {
        let ix = anchor_lang::solana_program::system_instruction::transfer(
            &ctx.accounts.from.key(),
            &ctx.accounts.to.key(),
            amount,
        );
        anchor_lang::solana_program::program::invoke(
            &ix,
            &[
                ctx.accounts.from.to_account_info(),
                ctx.accounts.to.to_account_info(),
            ],
        )?; return Ok(());`
`anchor idl init` (you can seem more options by doing `anchor idl --help`)
i deployed my program to devnet, but now i'm trying to use anchorpy to call it, and i get 
```IdlNotFoundError: IDL not found for program: 7W8hRd8PqFQt5EZDHu9mmBhmiY4UPCcv9UuL86sYkm2K```
how do i publish my idl on-chain?
yeah i called the program tmp lol
ok cool thanks
There ought to be a `target/deply/<your-program-name>-keypair.json` in there
Or just move it out of the way, up to you
so delete the `tmp-keypair.json` ?
You can delete/move the old one (it lives in target/deploy) and anchor/solana will automatically generate a new one.
is there a way to generate a new programID for deployment? i know only some Ids are valid right?
thanks for this! might save some pain in the future
I now have this and seems to .. work, thank you

`import { Program, Provider, web3, BN } from '@project-serum/anchor';
await program.rpc.sendSol(new BN(1), {`
Yeah. Alternative is to do `import * as anchor from "@project-serum/anchor";`
`anchor` is not defined in the import since you are destructuring the export object from the package
add `BN` to the import destructure, and use `new BN(1)`
I have this 
`import { Connection, PublicKey, clusterApiUrl } from '@solana/web3.js';
import { Program, Provider, web3 } from '@project-serum/anchor';`
can you show where you're importing the package?
You're apparently not importing it correctly
Hi Guys, in my reactjs front end i'm trying to pass in a "new anchor.BN(1)" to an RPC but am getting

`ReferenceError: anchor is not defined`

what am i missing here?
Still stuck, If anyone has any ideas!
There is no instruction logic
Ah my bad, i had some name clashes
`anchor build` should be building and generating IDLs for all listed programs in the `Anchor.toml` (defined in the workspace)
I added an entry under `[programs.localnet]` in the Anchor.toml
If i have two programs in my programs directory.  How do i get anchor to make the idl for the new one?  It seems to be compiling the binary, but not making the idl
Much appreciated, will give this a try later today, simplifies a lot
Just answered my own question haha
It doesnt
Why does it have to happen inside the program?
to fund creating that ATA
I guess it wouldnt matter, since anyone can be the payer
Otherwise you are saying you check from the client side if the PDA has an ATA, if not, create one (but i thought this had to happen inside the program)
Yes this is what ive been missing haha
Ahhhh
Oh, got it
Yes, I just removed all the program(instruction) logic and now it just return Ok(()),  but I am still getting the stack violation error
```.rs
#[account(
    init_if_needed,
    payer = somebody,
    associated_token::mint = the_mint_account,
    associated_token::owner = the_pda,
)]
pub the_ata: Account<'info, TokenAccount>
```
If you want
You can use `init_if_needed` with associated token addresses
Ahhh
Ah, no, you can't create the ATA within your instruction function‚Äîno matter what you'd have to pass in the account from the client
Yea I mean, i enter the Deposit function, and in there check if the PDA has an ATA for that passed in mint if not, create one, then deposit the passed in token
Basically a token account is just a token account, and token accounts can have whatever owner you want
Like in the handler
What do you mean by on the fly?
I posted a beefy thread above lol but it really boils down to the question I just asked
can I do this on the fly or should it be added to the attribute on the ix?
Doesn't matter if it has a sol balance‚Äîyou just need to make sure it has some token account, yeah.
Can i transfer any SPL token to a PDA that already has been initialized and contains a SOL balance? Or do I need to make sure that PDA has an ATA for that mint?
I'm saying just take a chunk of your instruction logic
I can't tell what I'm looking at there
ah, I just did this  in my instruction, Still getting stack violation
```rust
    ) -> Result<()> {
        Ok(())
```
should i still try with helper functions?
Alright, I will try this
Thank You
Can also add #[inline(never)] on top of the function to be extra sure rust will give you a fresh stack frame
Yeah, try moving some of the instruction function logic into a helper function, and then just invoke the helper function
24 accounts üòÖ
If so you can bundle up some of its logic into a helper function (this is a kind of silly trick, but doing so gives you access to a fresh 4kb stack frame)
Yes, it is long
Do you have a long instruction function?
Hey, I am getting   `Program failed to complete: Access violation in stack frame 5 at address 0x200005eb8 of size 8 by instruction #8602` I have boxed all the accounts I can what else is possible to deal with the problem
it works ! thank you so much.
cool!
Whoops, typo, `=0.9.1`
current dependencies in toml

```
[dependencies]
anchor-lang = "0.22.0"
anchor-spl = "0.22.0"
spl-token-lending = { git = "https://github.com/solana-labs/solana-program-library", version = "0.1.0", features = ["no-entrypoint"] }
uint = "=0,9.1"
```
```error: failed to select a version for the requirement `uint = "=0, ^9.1"`
candidate versions found which didn't match: 0.9.3, 0.9.2, 0.9.1, ...
location searched: crates.io index
required by package `splendor v0.1.0 (/repos/solanaRepos/splendorprotocol/programs/splendor)```
Note the extra equal sign!
Add an explicit dependency to your program's Cargo.toml:
```.toml
uint = "=0.9.1" # had a typo before, whoops
```
Urgh, I can't find the syntax I want, but at any rate you can do something like
```.toml
that_dependency = { version = "...", features = ["mainnet"] }
```
Getting this error with anchor build
```error: package `uint v0.9.3` cannot be built because it requires rustc 1.56.1 or newer, while the currently active rustc version is 1.56.0-dev
```
```{
  "compilerOptions": {
    "types": ["mocha", "chai"],
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015"],
    "target": "es5",
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "commonjs",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "incremental": true
  }
}```
What does you tsconfig.json look like?
Got it working for myself by changing `test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/unloc-nft-loan.ts"` to `test = "yarn run ts-mocha -t 1000000 tests/**/unloc-nft-loan.ts"`
Running `anchor test` results in:
`Module "file:///users/..../tsconfig.json" needs an import assertion of type "json"`
Any ideas whats wrong?
I can't remember the cargo syntax though :/
What I think you can do is say "build my program for mainnet" and it will automatically build that dependency with the mainnet declaration enabled
ah, think I follow the idea - I need to declare each account with the actual owner for the target deploy env - that correct ?
Ah, no‚Äîsorry, let me figure out the syntax to use
so here it is saying if its mainnet then assume dammHkt7jmytvbS3nHTxQNEcP59aE57nxwV21YdqEDN... and if not then AsW7LnXB9UA1uec9wi9MctYTgTz7YH9snhxd16GsFaGX. Are you saying I can use the same declare ID in my program ? (confused tho - wouldnt that mean I need the private key ?)
Here's an example of what I mean: https://github.com/drift-labs/protocol-v1/blob/master/programs/clearing_house/src/lib.rs#L31
What I would do is source-dive on any third party structs and just go see if you can find what program_id they're expecting
ok, thank you. Will follow up on that lead
You may need to build your code with a special `-- --features mainnet` or whatever flag to actually be able to run on mainnet
Ok, one possibility is that if you're using a third party struct, their code might use conditional compilation to declare multiple different declare_ids.
however I am still not understanding how it works in dev and not main.... Its becoming less and less likely its a simple user error - every deploy I've done in dev has worked... but mocing to prod always has this issue.

I dumped the program files from dev/main and they are identical
ok, thats clearer, thank you.... (and thanks for your patience explaining it)
Anchor checks for this condition with any `Account<'info, Whatever>`. The Whatever struct, in order to be usable with `Account`, has to declare what its expected program owner is (this happens automagically when you make an `#[account]` struct in your program: the resulting struct says "ok, I should be owned by whatever `declare_id!` says")
If the mint authority is that pda, then you aren't actually ever signing for the PDA within your `exchange` function (it's not enough to just pass the PDA in from the client, since anyone can do that! You need your program to proactively say "yes, I'm going to sign for this thing" by using `CpiContext::new_with_signers` for example)
You can just skip passing those bumps entirely! The `bump,` syntax means "anchor, figure it out for me".
Yep, works fine
Nope, this just isn't possible in solana‚Äîyou always have to pass any accounts of interest into the program from the client.
Hopefully im wrong? üòÑ
I know that the docs required building from source, so I'm guessing avm will not work
Dumbo question, does anyone use `avm` on Mac M1 chips? Does it work on it?
I am using Box<Account<'info, State>> where state is owned by a different program, and also AccountLoader<'info, Markets>, as an example of where I think its failing
any help greatly appreciated
Hi, I'm having some problems with AccountOwnedByWrongProgram. I'm pretty sure its to do with an account, not the declareId (i've redeployed a few times to check in dev/main). Confusingly the problem only shows up in mainnet.

Question please - how/when does the anchor macro that checks for AccountOwnedByWrongProgram run please ? For example I can tell it runs when I submit the transaction to my own Program... (because it barfs) - does it also run when doing CPI ? ie on entry to each anchor built program ? ( I assume it is because the invoked code uses AccountLoader for example)

If the checks are done on every program boundary how does one pass user accounts/state between programs without hitting this error?
Can we use BTreeMap in account like this ?  if can how much space to be define for init account ?
Has it ever happened to anyone that from one day to the next you run anchor test and it comes back as if it did not run any? (0 passing/0 executed, when they are programmed and yesterday they were working lmao)
<@!756621864113012896>
thats not correct. it means that you used the `executable` constraint and on an account and but the account you passed in was not `executable`. It's a specific constraint called "executable", not just any constraint. The error log should even tell you which account violated it if youre using `>0.22.0`
Got it thanks I'll look into it more closely
sample constraint https://github.com/Kriptikz/anchor-token-vault/blob/master/programs/anchor-token-vault/src/lib.rs#L138
One of the contraints on your ix struct is preventing the program from executing. typically passing a different signer than the authority or key mismatch. could be any of the contraints youve defined on your structs, so its hard to tell without seeing what contraints u have
anyone know what the following error means ` Error Code: ConstraintExecutable. Error Number: 2007. Error Message: An executable constraint was violated.`
then in order to execute the transfer: 
```
let total_fee = calculateFee(..); //u64
anchor_spl::token::transfer(
            CpiContext::new(
                token_program.to_account_info(),
                anchor_spl::token::Transfer {
                    from: associated_token_account.to_account_info(),
                    to: my_game_fee_account.to_account_info(),
                    authority: authority.to_account_info(),
                },
            ),
            total_fee,
        );
```
Basically I am trying to figure out if I need to create an entirely new program to support SPL integration or if I can just add SPL specific functions that basically do the same transfers but with specified SPL tokens. 

Current program structure: 
On program initialize a fee is set for all transactions,
PDAs are created for the treasury and fee accounts
And other information
Has several functions, Deposit, Play, Claim. 
Deposit, play and claim basically send all the necessary fees to the fee PDA and Claim with withdraw from the PDA treasury.
Currently these are all using the ```invoke_signed( &system_instruction::transfer(...``` way to transfer SOL.

Question 1: Would you suggest I basically clone the existing code, update the SOL transfers to SPL-transfers and deploy a new program? If I do this, would there a be a good way to control which SPL-Tokens are allowed for the Fee and Treasury PDAs?

Question 2: If I don't need to deploy a new program, how can I make it so the existing Treasury and Fee PDAs to accept the SPL-token mints passed in? Figured I would need to create some ATA for them to allow this to happen. If this isn't the case thats great. Also, if I wanted a different fee for SPL tokens, I would probably need to hardcode this since the SOL fee was set on initialize. I was thinking I could just add new properties to the Program struct and use the update function I have to then set the fee, but not sure if upgrading the contract will allow for this? 

Now for some code:

Current structs: 
```
#[derive(Accounts)]
#[instruction(escrow_payment_bump: u8)]
pub struct Deposit<'info> {
    wallet: Signer<'info>,
    #[account(mut)]
    payment_account: UncheckedAccount<'info>,
    #[account(mut, seeds=[PREFIX.as_bytes(), my_game.key().as_ref(), wallet.key().as_ref()], bump=escrow_payment_bump)]
    escrow_payment_account: UncheckedAccount<'info>,
    #[account(seeds=[PREFIX.as_bytes(), my_game.creator.as_ref()], bump=my_game.bump, has_one=authority, has_one=my_game_fee_account, )]
    my_game: Account<'info, MyGame>,
    #[account(mut, seeds=[PREFIX.as_bytes(), my_game.key().as_ref(), FEE_ACCOUNT.as_bytes()], bump=my_game.fee_account_bump)]
    my_game_fee_account: UncheckedAccount<'info>,
    authority: UncheckedAccount<'info>,
    system_program: Program<'info, System>,
}
```
Proposed SPL version:
```
#[derive(Accounts)]
#[instruction(escrow_payment_bump: u8)]
pub struct DepositSpl<'info> {
    wallet: Signer<'info>,
    #[account(mut)]
    payment_account: UncheckedAccount<'info>,
    #[account(mut, seeds=[PREFIX.as_bytes(), my_game.key().as_ref(), wallet.key().as_ref()], bump=escrow_payment_bump)]
    escrow_payment_account: UncheckedAccount<'info>,
    #[account(seeds=[PREFIX.as_bytes(), my_game.creator.as_ref()], bump=my_game.bump, has_one=authority, has_one=my_game_fee_account, )]
    my_game: Account<'info, MyGame>,
    #[account(mut, seeds=[PREFIX.as_bytes(), my_game.key().as_ref(), FEE_ACCOUNT.as_bytes()], bump=my_game.fee_account_bump)]
    my_game_fee_account: UncheckedAccount<'info>,
    #[account(mut)]
    mint: Account<'info, Mint>,
    #[account(mut, associated_token::mint = mint, associated_token::authority = wallet)]
    token_account: Account<'info, TokenAccount>,
    token_program: Program<'info, Token>,
    authority: UncheckedAccount<'info>,
    system_program: Program<'info, System>,
}
```
üò≠
Hey all, I have a couple existing programs that involve SOL transfers and looking to upgrade to allow SPL transfers. Was digging thought search history for a while and found some very useful information but looking for some guidance on how to proceed. Would it be recommended to upgrade the program if it involves changes I would like to make to the initialize function or can I do that via an existing update function (aka can I add properties to the main account struct for the program?
https://tenor.com/view/puppy-eyes-sorry-funny-animals-puppy-dog-eyes-gif-14502312
the "examples" folder in the anchor repo is a gold mine: https://github.com/project-serum/anchor/tree/master/tests
thanks for helping arma
make sure to hit "reply" to ppl
https://github.com/project-serum/anchor/blob/master/tests/escrow/programs/escrow/src/lib.rs#L28
or declare seed as const in the program and use find_progarm_address again to find the bump
got any code snippets/examples for this?
create a new program-owned account and store it in that
whats the best way for me to store the bump/signer seeds? I create these in the `initialize_mint` function but have no way to persist this state currently. Feel free to point me to any existing examples
Can i deserialize data differently based on a field? E.g.

```
pub struct Protocol {
    pub uuid: [u8; UUID_SIZE],    
    pub protocol_extra_data: [u8; 32],
}
```
Can I deserialize protocol_extra_data differently based on the value of `uuid`?
Can use try use CpiContext::new_with_signer and use seeds and bump as signer seeds? When you create mint to cpi context
My own error seems similar. Also, whenever I try to use either of the PDAs above, I cannot because they are lone Pubkeys, lacking a secret key.
Program logs end up giving me:

```
[PDA]'s signer privilege escalated
```

What am I doing wrong here? How can I avoid this error?? Thanks üôÇ
```
const tx = await program.rpc.initializeMint(
  {
    accounts: {
      mint: sampleMint.publicKey,
      mintAuthority: payer.publicKey,
      tokenProgram: spl.TOKEN_PROGRAM_ID
    },
    signers:[payer]
  }
);

const [_pda, _nonce] = await anchor.web3.PublicKey.findProgramAddress(
  [anchor.utils.bytes.utf8.encode("test")],
  program.programId
);

const tx2 = await program.rpc.exchange(amountToBurn, amountToReceive, {
  accounts: {
    burnTokenAcct: burnTokenAccount,
    burnMint: burnMint.publicKey,
    tokenAcctOwner: arbitraryOwner.publicKey,
    tokenProgram: spl.TOKEN_PROGRAM_ID,
    receiveMint: sampleMint.publicKey,
    toReceiveTokenAcct: receiveTokenAccount,
    mintAuthority: _pda
  },
  signers: [arbitraryOwner]
});
```
In my tests, I call:
```
#[derive(Accounts)]
pub struct InitializeMint<'info> {
    #[account(mut)]
    pub mint: Account<'info, Mint>,
    #[account(signer)]
    pub mint_authority: AccountInfo<'info>,
    pub token_program: AccountInfo<'info>
}

#[derive(Accounts)]
pub struct Exchange<'info> {
    #[account(mut)]
    pub burn_token_acct: Account<'info, TokenAccount>,
    #[account(mut)]
    pub burn_mint: Account<'info, Mint>,
    #[account(signer)]
    pub token_acct_owner: AccountInfo<'info>,
    pub token_program: AccountInfo<'info>,
    #[account(mut)]
    pub receive_mint: Account<'info, Mint>,
    #[account(mut)]
    pub to_receive_token_acct: Account<'info, TokenAccount>,
    pub mint_authority: AccountInfo<'info>
}
```
I have:

```
pub fn exchange(ctx: Context<Exchange>, amount_to_burn: u64, amount_to_give: u64) -> ProgramResult {

    let cpi_accounts = token::Burn {
        mint: ctx.accounts.burn_mint.to_account_info(),
        to: ctx.accounts.burn_token_acct.to_account_info(),
        authority: ctx.accounts.token_acct_owner.to_account_info(),
    };
    let cpi_ctx = CpiContext::new(ctx.accounts.token_program.to_account_info(), cpi_accounts);
    token::burn(cpi_ctx, amount_to_burn)?;

    // token burnt at this point

    msg!("Token burnt, time to give them the new token");

    if ctx.accounts.mint_authority.key() != ctx.accounts.receive_mint.mint_authority.unwrap() {
        msg!("error");
        msg!("ctx.accounts.mint_authority: {:?}", ctx.accounts.mint_authority.key());
        msg!("ctx.accounts.receive_mint.mint_authority: {:?}", ctx.accounts.receive_mint.mint_authority);
        return Err(ErrorCode::InvalidOwner.into());

    let cpi_accounts = token::MintTo {
        mint: ctx.accounts.receive_mint.to_account_info(),
        to: ctx.accounts.to_receive_token_acct.to_account_info(),
        authority: ctx.accounts.mint_authority.to_account_info()
    };

    let cpi_program = ctx.accounts.token_program.to_account_info();
    let cpi_mint_tx = CpiContext::new(cpi_program, cpi_accounts);
    
    token::mint_to(cpi_mint_tx, 1)?;

    Ok(())
}

pub fn initialize_mint(ctx: Context<InitializeMint>) -> ProgramResult {

    let mint_accounts = SetAuthority {
        current_authority: ctx.accounts.mint_authority.to_account_info().clone(),
        account_or_mint: ctx.accounts.mint.to_account_info().clone(),
    };
    let cpi_program = ctx.accounts.token_program.to_account_info();
    let (pda, _authority_bump) =
        Pubkey::find_program_address(&[PDA_SEED], ctx.program_id);

    token::set_authority(
        CpiContext::new(cpi_program, mint_accounts),
        AuthorityType::MintTokens,
        Some(pda),
    )?;

    Ok(())
}
```
guys, whats this all about? ```    Program failed to complete: Access violation in stack frame -1 at address 0x1ffffe748 of size 8 by instruction #51372```
change [#error] to [#error_code]
what do i do if my instruction has two different bumps, and I can no longer specify each one with bump=my_bump. If the variable is named bump, i can just add it at the end of the #[account()] macro, but what if its not named bump?

eg:
```rust

#[derive(Accounts)]
#[instruction(
    bump_1: u8,
    bump_2: u8,
)]
pub struct Initialize<'info> {
....
```
Hi, I've deployed an Anchor program and I know the program-id
Is there a way to upload the idl from the onchain program using anchor-cli and the program-id?
ok the solution is to remove the solana cache
```
rm -rf ~/.cache/solana
```
In fact during an anchor build, the cli was downloading something I've done `CTRL-C` which has stopped the download and then since it's not working anymore
hi, I'm facing the following error
```
BPF SDK: /home/zu/.local/share/solana/install/releases/stable-7d2acbc9a3ddf7fb5131c72c8f12f367d4470b42/solana-release/bin/sdk/bpf
cargo-build-bpf child: rustup toolchain list -v
cargo-build-bpf child: cargo +bpf build --target bpfel-unknown-unknown --release
error: process didn't exit successfully: `rustc -vV` (signal: 7, SIGBUS: access to undefined memory)
```
Does anyone know how to get rid of it?
(I've tried adding the user whose account was initialized as a signer, as well as the mint PDA and the PDA used to fill/circumvent the role of mint authority. All are unknown.)
What i'm trying to do:

```
let (_pda, _authority_bump) =
    Pubkey::find_program_address(&["SEED"], ctx.program_id);

let (_pda, _authority_bump) =
    Pubkey::find_program_address(&[PDA_SEED], ctx.program_id);

if (_pda != ctx.accounts.receive_mint.key()) {
    msg!("error");
    return Err(ErrorCode::InvalidOwner.into());
}

let cpi_accounts = token::MintTo {
    mint: ctx.accounts.receive_mint.to_account_info(),
    to: ctx.accounts.to_receive_token_acct.to_account_info(),
    authority: _pda.to_account_info()
};
```
I want to use the PDA as the authority on the mint instruction but the current `_pda.to_account_info()` is giving me the error:

```
the method `to_account_info` exists for struct `anchor_lang::prelude::Pubkey`, but its trait bounds were not satisfied

method cannot be called on `anchor_lang::prelude::Pubkey` due to unsatisfied trait bounds

note: the following trait bounds were not satisfied:
      `anchor_lang::prelude::Pubkey: std::convert::AsRef<anchor_lang::prelude::AccountInfo<'_>>`
      which is required by `anchor_lang::prelude::Pubkey: anchor_lang::ToAccountInfo`rustc(E0599)
```
üëã is there a way to transform a PDA pubkey into account info?
e.g. if ctx.accounts.my_account.to_account_info().key() != "my_pubkey" {}
can a Pubkey be compared to a string?
Cool!
Thank you so much, it worked!!!!!
Alright boughta give this a spin 

```
let ix = update_metadata_accounts_v2(
            ctx.accounts.token_metadata_program.to_account_info().key(), 
            ctx.accounts.nft_metadata_account.to_account_info().key(),
            ctx.accounts.payer.to_account_info().key(),
            Some(ctx.accounts.artist_license.to_account_info().key()), 
            None,
            None, 
            Some(false),
        );
        let tx = invoke(&ix, &[
            ctx.accounts.token_metadata_program.to_account_info(),
            ctx.accounts.nft_metadata_account.to_account_info(),
            ctx.accounts.payer.to_account_info(),
            ctx.accounts.artist_license.to_account_info(), 

        ]);

        msg!("results: {}", tx.is_ok());
```
pray for me haha
It feels repetitive, but yeah, that's how you do it
Nope, no extra structs, just list them out
When I invoke it asks for instructions and accounts, if those are the instructions do I just relist the accounts again for accounts field? If so should I be wrapping it in an UpdateMetadataAccounts struct?
When I add a signer, I get an unknown signer error.
`signer privilege escalated` (so it's not a mutability issue)
Ok, so you're somehow not signing for something

Try posting the full program log, it will include a line with more info
I think I was initializing the account twice. Probably fixed, but since then I get an error in a future instruction trying to mint coins for that new account: `Cross-program invocation with unauthorized signer or writable account`
Ahhh thanks soo much Ill give it a shot ‚ù§Ô∏è
So you made your instruction already, just time to invoke it
Ah, sorry, no need to use the CpiContext stuff‚Äîjust use `anchor_lang::solana_program::program::invoke` or `invoke_signed` on that instruction
```
let ix = update_metadata_accounts_v2(
            ctx.accounts.token_metadata_program.to_account_info().key(), 
            ctx.accounts.nft_metadata_account.to_account_info().key(),
            ctx.accounts.payer.to_account_info().key(),
            Some(ctx.accounts.artist_license.to_account_info().key()), 
            None,
            None, 
            Some(false),
        );


         CpiContext::new( 
            ctx.accounts.token_metadata_program.to_account_info(), 
            ix,
          
        );
```
what I am currently working with
but I havent been able to succesfully call the cpi even haha, I either get errors constructing it like the one above or there is no sign of a cpi in the program logs and the metadata doesn't change
Just cpi the mpl_metadata_program to update the metadata of an nft passed in and owned by the signer
What are you trying to do more broadly?
bit clueless frankly
Does anyone know how I might implement to_account_metas on an isntruction? 

the trait bound `Instruction: anchor_lang::ToAccountInfos<'_>` is not satisfied
the trait `anchor_lang::ToAccountInfos<'_>` is not implemented for `Instruction`
Using those for now... and I get an error saying that an account or token is already in use.
To do that you'd use `token::mint` and `token::authority` instead of the `associated_token` versions.
But if you don't need it to be guessable etc., you can store it at whatever kind of address you want, it just won't be an associated token address
The point of an associated token address though is to be "obvious"/guessable, hence a PDA (in this case derived from the associated token progrma)
You can also store a token account at a raw pubkey if you want‚Äîjust depends on what you want to do
Ah. I was using a raw pubkey. That was probably it.
Using `spl.getAssociatedTokenAddress(...)`
That likely means that you aren't calculating the associated token address correctly on the client
That seems to yield some progress, but now I get an error saying that the instruction references an unknown account, and therefore a required account is missing.
`spl.ASSOCIATED_TOKEN_PROGRAM_ID`, from the spl library
Thanks; that builds. How do I get the associated token program ID in Typescript?
To use the `init` syntax for (associated) TokenAccounts, you also need to use `associated_token::mint = the_mint` and `associated_token::authority = the_owner_of_the_tokens`
The instruction struct that caused it:
The error:
can you paste the snippet?
No wait, I can't even use a wrapper: TokenAccount doesn't implement BorshSerialize.
Ended up attempting to do that instead, but face an error saying that TokenAccount has no function or associated item `default`. Do I need a wrapper to derive it, or am I missing something obvious again?
instead of creating a mint in typescript
yes, then you can just use the `import { createAssociatedTokenAccount } from '@solana/spl-token` export and just provide the mint pubkey as one of the arguments
you asked for typescript üòÜ
I might want to build the associated token account creation into my program though.
Ah. I'd like to use a program-owned mint, though; presumably I'd alter this to fetch the mint from my program instead of creating a fresh one?
I guess it allows u to half-specify your initialization of a struct, as I did here ?
```
    pub fn new(bump: u8) -> Self {
        Self { 
            last_update: LastUpdate::new(),
            ..Default::default()
        }
    }
```
why even use `Default`? What's it do
ah i see
<@!184073368679612416> 
```ts
import { Keypair } from '@solana/web3.js'
import { Token, TOKEN_PROGRAM_ID } from '@solana/spl-token'

const decimals: number = 5 // arbitrary number for testing

;(async () => {
  const wallet = Keypair.generate()

  const testMint = await Token.createMint(
    connection,
    wallet,
    wallet.publicKey,
    null,
    decimals,
    TOKEN_PROGRAM_ID
  )

  const testAccount = await testMint.createAssociatedTokenAccount(
    wallet.publicKey
  )

  await testMint.mintTo(
    testAccount.publicKey,
    wallet,
    [],
    amount * (10 ** decimals)
  )
})()
```
You'll have to impl Default for your account struct by hand if you want to avoid specifying space yourself
This is super dumb, but rust doesn't auto-implement traits for arbitrary array lengths very well
what's going on here?

Associated one. For testing purposes, I would like to make a dummy user's account, but a keypair alone does not suffice.
a program/pda owned or associated one?
Do I use `Spl.token().methods.initializeAccount()` somehow?
How do I initialize a TokenAccount from typescript?
any ideas?
```
            "--bind-address",
            "0.0.0.0",
            "--clone",
            "4bcFeLv4nydFrsZqV5CgwCVrPhkQKsXtzfy2KyMz7ozM",
            "--clone",
            "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
            "--clone",
            "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB",
            "--clone",
            "Amig8TisuLpzun8XyGfC5HJHHGUQEscjLgoTWsCCKihg",
            "--clone",
            "gLhY2arqFpmVGkpbBbTi3TeWbsWevA8dqrwbKacK3vJ",
            "--clone",
            "8ojYYusVjAKTB7tHjKb9oCBubhhU4vHQDNCcUAdg2ikb",
            "--clone",
            "DpxS9YTv7e7MD9USgniaG4G5n4gVGAk8HJ6p7AXDXcxq",
            "--clone",
            "8ojYYusVjAKTB7tHjKb9oCBubhhU4vHQDNCcUAdg2ikb",
            "--rpc-port",
            "8899",
            "--url",
            "m",
        ],
    }
[2022-03-01T22:18:47.846235000Z WARN  solana_perf] CUDA is disabled
[2022-03-01T22:18:47.864435000Z ERROR solana_faucet::faucet] Faucet failed to start: Address already in use (os error 48)
```
`anchor test` is failing saying a provided account isn't initialized, think that error is just masking an error in my program log
How can I access `spl-lending` from my anchor program? Does anchor come with it? Or do I need to add something to my cargo?
I can also report that this problems happens on both linux and mac m1.
Ah, that's exactly the problem. I should be using `Anchor.BN` for numeric arguments.
Ah, here we go. `Spl.token()` should apparently get the token program, but I'm somehow still getting a type error: `Number` is not assignable to `BN`.
thank you! that was it
I can import Spl and SplToken, but I'm not sure what I can do from there.
possibly because of this https://book.anchor-lang.com/chapter_3/CPIs.html#reloading-an-account
I need a bit of help understanding something... if I transfer tokens from 1 token account to another, it looks like the token account `amount` field does not get updated within the same transaction, it remains the same amount balance until the transaction is finished. Why is this the case? Is there any way to get an updated amount within the transaction to do further processing afterwards? some logs:

```
Program log: before yield_vault_amount: 10, deposit_vault_amount: 1
    Program SwaPpA9LAaLfeLi3a68M4DjnLqgtticKg6CnyNwgAC8 invoke [2]
    Program log: Instruction: Swap
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [3]
    Program log: Instruction: Transfer
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 3327 of 127952 compute units
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [3]
    Program log: Instruction: Transfer
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 3200 of 97739 compute units
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success
    Program SwaPpA9LAaLfeLi3a68M4DjnLqgtticKg6CnyNwgAC8 consumed 45760 of 139473 compute units
    Program SwaPpA9LAaLfeLi3a68M4DjnLqgtticKg6CnyNwgAC8 success
    Program log: after yield_vault_amount: 10, deposit_vault_amount: 1
```
But then i can only test half of my program
Okay reducing the size of the binary from 467K to 346K fixes the deployment failure to devnet..
Reiterating. I have an instruction struct with `token_program: Program<Info, Token>`, and I'd like to supply that part of the struct in TypeScript, which seems to have no way to access anchor_spl. Is there an anchor-ts function I'm missing?
how do i debug this?  `Error: Custom: Invalid blockhash
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.`
everything fine on localnet
ok, deployment breaks for my program, not for others. How can that be
10kb for accounts initialized via a CPI to the system program (e.g. when you use the `init` annotation, or any PDA). 10mb for general accounts
do you know what the cap is on data stored per account?
Could the deployment failures be a timeout related thing?
That's great to know, I appreciate it!
I'm actually not sure what you can do here besides just picking the lowest common version :/
Yeah, unfortunately anchor (as far as I know/understand it) just doesn't work well with multiple versions floating around; you run into annoying type mismatches like the above
the function called is part of `switchboard-v2 = "0.1.5"` which I believe depends on an older version of anchor. Is this possible?
ty!
32 bytes
ah makes sense, do you know what the rough size of a public key?
You can check your Cargo.lock file and look for anchor-lang
I wonder if you're accidentally depending on multiple different anchor versions
Any thoughts on this type mismatch? `expected struct anchor_lang::account::Account, found struct anchor_lang::prelude::Account`
So it's basically just linear in the size, plus a small fixed cost. Roughly though it's 7 sol/mb (for rent-exemption).
You can see the calculation here: https://github.com/solana-labs/solana/blob/master/sdk/program/src/rent.rs#L55
Interestingly, creating a fresh project, deploys first time.  But my old project, which is larger, but not big. Fails every time, it's on anchor 0.2.0.
How does rent change based off the amount of data stored on an account? E.g. if I have an account with 20 bytes vs. 200 bytes vs. 2000 bytes of data what would the relative costs be?
I'll try upgrading
0.22.1
Latest anchor cli at any rate doesn't seem to do that (works fine for me)
The stub project it creates has the old ProgramResult
Latest version of anchor changed, yeah. Use `Result<()>` instead
actually this may be just an anchor 0.22 issue
error[E0412]: cannot find type `ProgramResult` in this scope
I upgraded to solana 1.9.9 to try to fix this, but now anchor can't compile even a fresh ini project.
Afternoon!

I'm working off of switchboard's VRF  example to get some rng: (https://github.com/switchboard-xyz/vrf-cpi-example)

Right now I'm getting this error:
`expected struct anchor_lang::account::Account, found struct anchor_lang::prelude::Account`

in response to this function call:
```
        let vrf_request_randomness = VrfRequestRandomness {
            authority: ctx.accounts.authority.to_account_info(),
            ... other accounts ...
            escrow: ctx.accounts.escrow, <- Error
            payer_wallet: ctx.accounts.payer_wallet, <-Error
            ... other accounts ...
            token_program: ctx.accounts.token_program.to_account_info(),
        };
```

I think it's a versioning issue.

I see on their Cargo.toml they use `anchor-lang = "0.19.0"` and `anchor-spl = "0.19.0"`

I use `anchor-lang = "0.20.1"` and `anchor-spl = "0.20.1"`

any way to cast a `anchor_lang::account::Account` to a `anchor_lang::prelude::Account`?
Ok thanks!, I‚Äôll check out the rust docs to see if I can improve my understanding
You were running into a rust type error. Both suggested fixes work by converting one kind of potential error into the right kind of expected error.
They're equivalent.
Thanks! but not sure exactly what i'm supposed to do here, is this meant to be a better fix?
thanks, it compiled without error now, but could you explain a little why i had to do this?
are there any examples of how to call the cpi methods in the token-lending library? https://github.com/solana-labs/solana-program-library/tree/master/token-lending
Ah yeah good call!
<@!134416332509675520> <@!665112704553320473>
or the less annoying `.map(Into::into)`
Annoying but do `invoke(...)?; return Ok(());`
will check, thanks!
Can someone help point me in the right direction to investigate this? looks like a return type error but i don't understand what i'm reading in E0308, and i can't find anything in anchor lang documentation about the return type for program::invoke

The full code:
 `pub fn send_sol(ctx: Context<SendSol>, amount: u64) -> Result<()> {
        let ix = anchor_lang::solana_program::system_instruction::transfer(
            &ctx.accounts.from.key(),
            &ctx.accounts.to.key(),
            amount,
        );
        anchor_lang::solana_program::program::invoke(
            &ix,
            &[
                ctx.accounts.from.to_account_info(),
                ctx.accounts.to.to_account_info(),
            ],
        )
    }`
But see above, there was a discussion of how you may need to clone two accounts per program: the actual program_id account but *also* the upgradeable loader program data account
thanks!
```.toml
[[test.clone]] # or [[test.validator.clone]] maybe
address = LendZqTs7gn5CTSJU1jWKhKuVpjJGom45nnwPb2AMTi
```
The only potentially tricky issue with this error is that if you mess up your declare_id!, you can get spurious errors. (Anchor will check an incoming `Account<'info, OneOfYourAccounts>` against your declare_id!, not against your actual runtime program_id)
If i want to clone a program from mainnet for use on localnet, what do I need to put inot my anchor.toml?

something like

[programs.devnet]
spl-token-lending = "LendZqTs7gn5CTSJU1jWKhKuVpjJGom45nnwPb2AMTi"
?
No, no change between main/devnet. That error can get raised by any `Account<'info, Whatever>` in your program (any of them)


//////////////////////////////////////////////////////////////////////////////////////////

Built-into rust basically, you can use `.checked_add` etc.
Yeah, you can't get a keypair from phantom. But you can still sign the tx with phantom (it will prompt the pop-up etc.)
hey, is there a standard library for safe math for over/underflows on sol? i'm just doing basic addition and subtraction
How do I get a keypair from a provided Phantom wallet (which looks like this) to sign an Anchor instruction? Or do I have to somehow translate the Anchor instruction into a format usable by `signAndSendTransaction`?
Thanks a lot <@!134416332509675520>  for all your help last few weeks.
We were able to complete and submit our project on time for the Hackathon
The error is a bit confusing, but it's saying you can (maybe) get away with being lazy and not specifying `space = ` by instead adding `#[derive(Default)]` to that BuildAccount struct
You need to specify how much space to use for that `init` of the `BuildAccount`

Can you move your mouse and just post the struct?
hmmm, anybody know how to fix this error?
Not as far as I know
üëã is there a way to check in a solana program whether the call is occurring in devnet or mainnet?
e.g. 
```
pub fn exchange_with_transfer(
        ctx: Context<ExchangeWithTransfer>,
        amount_to_burn: u64,
        amount_to_give: u64,
    ) -> ProgramResult {

    // if mainnet do something, if devnet do somethign else

    ...
}
```
not the workspace specifically, but this:
```js
import idl from '../../../target/idl/idl.json';
const connection = new Connection("http://127.0.0.1:8899", confirmOptions);
const provider = new Provider(connection, wallet, confirmOptions);
// @ts-ignore
const program = new Program(idl, programID, provider);
```
I am developing with anchor-client 0.22.1, serum-multisig compiled with anchor-lang 0.21.0. But I did an `anchor expand` and saw that 0.21.0 does indeed have that trait implemented on its Accounts structs.

EDIT: Figured it out -- If you do not use the same version of anchor-lang that the contract was compiled with, it won't work.
Very odd behavior I'm getting:
```
acts.to_account_metas(None),
    |                          ^^^^^^^^^^^^^^^^ method not found in `serum_multisig::accounts::CreateMultisig`
help: the following trait is implemented but not in scope; perhaps add a `use` for it:
    |
1   | use anchor_lang::ToAccountMetas;
```

But I am using it, and getting unused import error:
```
warning: unused import: `anchor_lang::ToAccountMetas`
  --> src/api/multisig/mod.rs:14:5
   |
14 | use anchor_lang::ToAccountMetas;
```
Put the ones that have to be there no matter what in the regular accounts part, and the variable ones in remaining_accounts
how do you decide what to include in remaining accounts versus account?
has anyone tried to add anchor wokrspace to javascript project monorepo? (`NxJS` or `Turborepo`)?
ok, great - thx
No, remaining_accounts are actual accounts (they'll work fine)
sorry, bad nomenclature - I meant accounts - but I was thinking that if I was going to transfer to an account, it had to be included in the accounts context, not just in remaining accounts.
Use `remaining_accounts` (try searching the anchor repo for examples)
Addresses alone won't work (always have to pass any accounts you care about it, not just addresses)
What is a good way to handle an instruction to make transfers to a variable number of accounts? Set a max number, include accounts for each in the accounts context and pass in dummy addresses where necessary?
Maybe the the Base acount name? Maybe the struct I'll post it later probably to make sure
Borsh u8 is 1 byte
I'm away from my computer it's just something I ran into yesterday I'm thinking its a borsh u8 I'm missing  my app worked so I didn't think too much of it
The first 8 bytes of account storage are for the account discriminator (I thought you were asking about something else above‚Äîthe sighash is for the first 8 bytes of instruction data)
Can you post the struct you're wondering about?
Like for an `#[account]` struct?
Where the borsh serialized structs and data are
Actually, what do you mean by program data?
There are 4 bytes I'm wondering about I guess I'm able to parse program data if I offset by 12 it might be some u8 relating to something idk tho lol
The first 8 bytes are for the "sighash" (not sure where you're getting 12 from)
What do the first 12 bytes of program data hold?
Good stuff. Thank you for your time and knowledge.
So still no way for anchor to guess the right size
That size wouldn't be evident from the static type
variable size with fixed capacity
or perhaps we could limit ourselves to `Vec::with_capacity`
Yeah
for sure, but for options of fixed size things should be possible
It also can't possibly be automagic for e.g. vecs
okay cool will manually calculate space then
So yeah, in principle this ought to be automagic, but it's not right now
Because Account<'info, Whatever> uses borsh, so the calculation would have to sort of guess what borsh is going to do‚Äîanchor hacks that currently via Default, by just saying, uh, borsh, how big is it to serialize a default instance?
Yep‚Äîbut that's not how anchor works currently, and as far as I know it's not actually super easy to do that space calculation in anchor itself
ya that's not the full error but that's the only useful portion. I'm not specifying the space but I suppose my next question is surely the space can be auto calculated to the be the max of the `Option<Pubkey>` variants. it's variable but predictable what size these could be, so should just be max of all possible ones.
Just add `space = 1000` to wherever you're init-ing that account
The issue ought to be that you aren't manually specifying `space =` for some init
Can you post the full error? Feel like that can't be all of it
```
 = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`
    = note: this error originates in the derive macro `Accounts` (in Nightly builds, run with -Z macro-backtrace for more info)
```
If I remove `derive(Default)` from my account struct I get a complaint from the struct defining my context which uses `derive(Accounts)`.
I would say don't do that, it just doesn't really make sense to do
makes sense
yes
Since the Default value is empty (too short)
At any rate, relying on Default for variable-sized account things doesn't really make sense
Can't remember which version is latest
Are you deriving Default?
are we on 0.23 yet?
I'm on 0.22
(The latest version of anchor got rid of that feature, since people keep forgetting about it)
That's definitely a bug on your end then, you can't use Default for variable-length fields like Option, Vec, etc.
I'm not specifying the space to allocate
Are you sure you're allocating enough space?
You can use them fine, but they won't work well with Default space calculations
weird enough, I can use an `Option<u32>`, haha
I'm getting a `Failed to Serialize Account` error when I uncomment some `Option<Pubkey>`'s. Are you not allowed to use options for fields on an `#[account]` struct?
Aha got it, but after the deployment I will just need the public key and the upgrade authority private key only to redeploy right ?
You need that private key for your first deploy, because solana is going to create an account that lives at your program_id (and doing so, like with any other account, requires a signature)
guys, when i anchor init program, in my target folder there is a keypair json, i assume this is the private key from which the program id is derived, but in what cases is this program-name.keypair is used for, and isnt it useless if my upgrade authority is someother keypair or am i missing something ?
Sorry, still not quite sure what you're asking about‚Äîwhat do you need the declare_id for? Like, what are you trying to do?
Ah ok ok then my question would essentially be what do I use instead of declareId
Refactoring the codebase requires you to actually refactor it, lol üòõ If the current version works fine then refactoring is extra, annoying work
I think I'm unclear on what you want to do
Versus refactoring the codebase
What would be the potential downsides of doing this
You can always use `avm` to install an old version of the anchor cli
Yeah I was thinking the same might be worth it
Well if I have an old anchor version on a program that I want to run nowadays
In order to run what?
you learn many new thing through this
well you can do refactor if you want
What would be the solution in order to run this nowadays? refactor the code for anchor .20 or downgrade the solana version?
haha, make sense
Yeah, just fetch it the old-school way and see how big its data is, `program.provider.connection.getAccountInfo(theAddress)`
just curious üòú
is there any generic way to check the size of any account?
https://github.com/project-serum/anchor/blob/master/CHANGELOG.md#breaking-changes-1
Because they're using very old versions of anchor, which didn't have `declare_id!` yet: https://github.com/gopartyparrot/ido-pool/blob/prt/programs/ido-pool/Cargo.toml#L18
Hey can someone help me here. Anyone know why some codebase programs may not have a declare id in the lib.rs file?
for example here none of the programs have a declare id which is weird... https://github.com/gopartyparrot/parrot-ido https://github.com/gopartyparrot/ido-pool (this is the parrot ido platform) https://github.com/blockworks-foundation/ido-pool https://github.com/blockworks-foundation/mango-token-sale (this is the og mango markets ido platform)
aaah ok now it is making some sense
At any rate, that `size` is more like `defaultSize` (similar to what might happen in rust if you use Default and leave off the `space =` part)
18 = 8 for the discriminator bytes, 1 for the nonce, 8 for the threshold, and then (mistakenly) 1 for the vec
Also, fwiw, when I try the above I get `18`‚Äîwhich, actually, is a bug (the anchor ts code thinks vecs only take up 1 byte by default, but that's wrong, they take up 4)
That `program.account.newAccount.size` doesn't reflect how much you dynamically allocated (it can't, since it's a static thing and you can of course allocate however much you want‚Äîlike, suppose it somehow returned `200` here, but then the next time you did that instruction thing you changed your mind and wrote `201`)
this is the struct
```
#[account]
pub struct newAccount {
    owners: Vec<Pubkey>,
    threshold: u64,
    nonce: u8,
}```
I'm creating a new account with 200 bytes, but when I try to find the account size it is returning 20. Any idea why this is happing?
```
      preInstructions: [
        await program.account.newAccount.createInstruction(
          newAccount,
          200
        )
      ],
```

```bash
program.account.newAccount.size === 20
```
I see. Sounds fair. Ty
aah gotcha, thnxs king üëë
`await` has low precedence, need to do `(await fidnProgramAddress(...))[0]`
Don't think so (as far as I know no one has figured out a better way to do it)
``` rust
const programDataAddress = findProgramAddressSync([program.programId.toBytes()], new anchor.web3.PublicKey("BPFLoaderUpgradeab1e11111111111111111111111"))[0]```
``` rust 
const hello = await anchor.web3.PublicKey.findProgramAddress([program.programId.toBytes()], new anchor.web3.PublicKey("BPFLoaderUpgradeab1e11111111111111111111111"))[0]```
Why the 1st snippet works but 2nd didn't?
ohh I see gotcha. Thank you so much. 
Any plan for future changes on this ?
Big gotcha but there isn't really any great way to fix it
Ok, yeah, the problem is that you unfortunately can't use the instruction macro like that, it needs to match the order of your instruction fn arguments!
```rust
pub fn test(ctx: Context<Test>, amount: u64, lamports: u64, test_acc_bump: u8, mint_account_bump: u8) -> ProgramResult {
        msg!("Instruction Testing");
        ////.... code
}
```
```rust
#[derive(Accounts)]
#[instruction(test_acc_bump: u8, mint_account_bump:u8)]
pub struct Test<'info> {
  /// ..... everything goes in there
}```
Post the `#[instruction(...)]` part as well as the `pub fn your_instruction_name` signature
No, that's fine, but are you sure you're actually using the right bump for the init?
so I cant init in the same instruction i reckon and try to modify that account?
and you replied after that.
i thought about it. I was going to try creating account in different instruction and then pass it in this instruction
yes

You're also CPIing when you do that `init`
sure will do that
And in front end
```js
    // setup pda for minting
    const [pda_mint, bump_mint] = await PublicKey.findProgramAddress(
        [anchor.utils.bytes.utf8.encode("mint-authority")],
        escrowProgramId
    );
```
Can you post the full program log?
```rust
           let seeds:&[&[u8]; 2] = &[
                b"mint-authority",
                &[mint_account_bump]
            ];
            let signer = &[&seeds[..]];
            let cpi_accounts = MintTo {
                mint: ctx.accounts.mint_token_addr.to_account_info(),
                to: ctx.accounts.authority.to_account_info(),
                authority: ctx.accounts.token_authority.to_account_info(),
            };

            let cpi_program = ctx.accounts.token_program.to_account_info();
            let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer);
```
cpi for minto
```rust
pub struct Test<'info> {
   #[account(mut)]
   pub authority: Signer<'info>,
   #[account(
        init,
        seeds = [
            b"test",
            authority.key().to_bytes().as_ref(),
        ],
        bump = test_bump,
        payer = authority,
        space = Trove::LEN + 8
    )]
    pub testAcc: Account<'info, Test>
    #[account(
        seeds=[
            b"mint-authority"
        ],
        bump = mint_account_bump
    )]
    pub token_authority: AccountInfo<'info>,

    #[account(mut)]
    pub mint_token_addr: Account<'info, Mint>,

    pub pyth_sol_account: AccountInfo<'info>,

    pub system_program: Program<'info, System>,

    #[account(address = spl_token::ID)]
    pub token_program: AccountInfo<'info>,

    pub rent: Sysvar<'info, Rent>,
}
``` 
yes
thank god. Saviour is here!!
You're somehow not using the correct bump. Are you CPIing to something?
why is saying that ?
ü•≤
what is this error im getting while creating pda account through anchor ...
HI,
```Program failed to complete: Could not create program address with signer seeds: Provided seeds do not result in a valid address```
Or will I have to hand roll the definitions?
Is there a way to generate a cpi client from an anchor idl?
what should I be looking for when I see
```
Error: 3004: Failed to serialize the account
```
just check your thingy and make sure its same.
you account data should match the one in the IDL
I haven't managed to pass non-bumps without BN, so ```new anchor.BN(rewardDuration)```
Hello, I am running into this error:
```
Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: invalid account data for instruction
``` 
I am making my transaction like the following:
```
const txSig = await program.rpc.initializePool(
            poolNonce,
            rewardDuration,
            {
                accounts: {
                    authority: this.wallet.publicKey,
                    xTokenPoolVault: xTokenPoolVault,
                    xTokenDepositor: this.xTokenPubkey,
                    xTokenDepositAuthority: this.wallet.publicKey,
                    stakingMint: this.tokenPubkey,
                    stakingVault: stakingMintVault,
                    rewardAMint: this.rewardAPubkey,
                    rewardAVault: mintAVault,
                    rewardBMint: singleStake ? this.rewardAPubkey : this.rewardAPubkey,
                    rewardBVault: singleStake ? mintAVault : mintAVault,
                    poolSigner: poolSigner,
                    pool: poolKey,
                    tokenProgram: TOKEN_PROGRAM_ID,
                },
            }
        );
```
Would anyone be able to help me with this?
i can run other tx pretty simply..
gives me non base 58 error like for ??
Hi, So Im not able to sign in anchor tx like this ? ```rust
 signedTx = await wallet.signTransaction(tx);
```
8
Are the first 12 bytes of program data the account discriminator?
new api is less verbose - thx
```rust
const tx = program.state.instruction.test(new anchor.BN(amount),
        {
            accounts: {
                authority: wallet.publicKey,
                systemProgram: SystemProgram,
                tokenProgram: TOKEN_PROGRAM_ID,
                rent: SYSVAR_RENT_PUBKEY,
            }
        }
    );
```
if i want to add the anchor instruction to a transaction. Is this how I do it ?
``` 
#[account(
        mut,
        constraint = x_token_pool_vault.mint == X_STEP_TOKEN_MINT_PUBKEY.parse::<Pubkey>().unwrap(),
        constraint = x_token_pool_vault.owner == pool_signer.key(),
        constraint = x_token_pool_vault.amount == 0,
    )]
    x_token_pool_vault: Box<Account<'info, TokenAccount>>,
```
Currently it is set as this right now
Don't think there's a dynamic way to do that, at least as far as I know. You'd have to build two different versions of the program, one for devent one for mainnet, e.g. using cargo features: https://github.com/drift-labs/protocol-v1/blob/master/programs/clearing_house/src/lib.rs#L29
Assuming the vault account is a token account, you can just do e.g.
```.rs
#[account(
    init,
    payer = the_payer,
    token::mint = the_mint,
    token::authority = the_vault_itself,
    seeds = [b"the-vault"],
    bump,
)]
pub the_vault_itself: Account<'info, TokenAccount>
```
e.g. 
```
pub fn exchange_with_transfer(
        ctx: Context<ExchangeWithTransfer>,
        amount_to_burn: u64,
        amount_to_give: u64,
    ) -> ProgramResult {

    // if mainnet do something, if devnet do somethign else

    ...
}
```
üëã is there a way to check in a solana program whether the call is occurring in devnet or mainnet?
Would it be just my PDA that becomes the vault?
how would I store the vault account as one of my own PDAs?
I was just wanting to get the balance of a token account, but I think I see where I went wrong - I was using `AccountInfo` from `web3` instead of from `spl-token`.
Hmm, how are you seeing that it has type AccountInfo<T>? Not sure how you'd check that
Also fyi you're using an old version of the spl token library
~~Do you want to make a whole new mint?~~ [edit: sorry, misread] Which part are you asking about‚Äîthe `let token =` part or the `let tokenAccountInfo =` part?
also, how can I figure out what type `tokenAccountInfo` is. It is showing up as `AccountInfo` but it has a type `AccountInfo<T>`
is this the most efficient way to get a token account?
```js
      let token = new Token(
        program.provider.connection,
        mint.publicKey,
        TOKEN_PROGRAM_ID,
        payer
      );
      let tokenAccountInfo = await token.getOrCreateAssociatedAccountInfo(payer.publicKey);
```
How did you call that function?
Associated token addresses are for when you can't think of a good address to use‚Äîso you just base it off the mint + the owner. But if you can come up with a more natural name for address, then there's no point in using an associated token address, just use your own PDA.
But honestly, if you know you want the vault to be program-owned, there's kind of no point is storing it at an associated token address‚Äîyou can just store the vault account at one of your *own* PDAs.
Yeah, there's an optional argument to the getAssociatedTokenAddress function though that let's it work for off-curve addresses
If I want to create a vault that is program owned, would I be able to use the get associated token account using the pda? Since when I look into the method, I think it catches for if the owner if off curve, and if my understanding is correct pda is off curve is that correct?
```
export async function createAssociatedTokenAccount(
    program: anchor.Program<rewardPool>,
    payer: anchor.Wallet,
    mint: PublicKey,
    owner: PublicKey,
    programId = TOKEN_PROGRAM_ID,
    associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID
): Promise<PublicKey> {
    const associatedToken = await getAssociatedTokenAddress(mint, owner, false, programId, associatedTokenProgramId);
    console.log(associatedToken.toString());
    const transaction = new Transaction().add(
        createAssociatedTokenAccountInstruction(
            payer.publicKey,
            associatedToken,
            owner,
            mint,
            programId,
            associatedTokenProgramId
        )
    );

    console.log(program);
    await program.provider.send(transaction);

    return associatedToken;
}
```
How did you build the tx?
I am getting the following:
```
Error processing Instruction 0: incorrect program id for instruction 
    Program ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL invoke [1]
    Program log: Transfer 2039280 lamports to the associated token account
```
Is calling my own program for the program.provider.send(tx) wrong?
okay I will try it out. Thank you for the response
Instead of doing sendAndConfirmTransaction, just do e.g. `program.provider.send(theTx)`
No, but all you need to do is tweak this: https://github.com/solana-labs/solana-program-library/blob/master/token/js/src/actions/createAssociatedTokenAccount.ts
Are there any documentation on how I can do this on the client side?
Unfortunately you can't (this is an oversight imo in the js token lib‚Äîthey're accepting PRs to fix it though). You currently just have to copy the implementations of those functions and tweak them to work with a wallet adapter rather than that overly-restrictive `Signer` type they currently use.
How do I get the payer attribute from the client side? I want to make calls such as createAssociatedTokenAccount, or any calls in the Token library but they all require this payer attribute, however on the client side when I do useWallet(), or do (this.provider.wallet as NodeWallet).payer and it is null
probably somewhere inthe code you are still using the localhost provider, or in your anchor.toml you set cluster=local
Getting this error while the cluster url is set to devnet`Error: failed to get recent blockhash: FetchError: request to http://localhost:8899/`
Yep
Hi. ` AnchorError caused by account: vault. Error Code: AccountNotInitialized. Error Number: 3012. Error Message: The program expected this account to be already initialized.` receiving this error any ideas how to solve this?


//////////////////////////////////////////////////////////////////////////////////////////

This seems to be the result of passing a BN into an instruction as an argument; `new Anchor.BN()` is called on a number obtained by `parseInt`.
Any ideas as to what this error is a sign of? I think Phantom should prompt me for a signature at this point, but it does not.
Okey, thank you üôÇ
I'm not totally sure what that picture is showing, but the `.owner` field on the AccountInfo is always the *program* owner (which program is allowed to mutate the `.data` or spend the `.lamports`)
If you want to have an authority associated with the account, yeah, it would need to go in the account's data (the program owner of the account doesn't go in the data, it's its own separate field on the underlying AccountInfo)
I have been reviewing the bases and I have generated a doubt (maybe very silly), when a user generates an account that stores data (not PDA), this account has as owner the Smart contract that created it and also the authority is the user, this authority is stored in the data field of the account? This is the image that has generated me the doubt, to give some context. Maybe the image refers to a PDA.
Eh, you could write a slightly different version using `program.provider.connection.getAccountInfo`, but eh, your version is easier ü§∑‚Äç‚ôÇÔ∏è Not sure if there's anything simpler built-in
Hello üëã  does somebody know what wallet_limit and lauch_stages_info are in the accounts instruction from magic eden mint?
and maybe how to get them?
hey, how to check if account is owned by my program ? I of course can do like this and catch the error, but is there a better way?
np Alan, just poking around your github
Sorry, I don't
<@!134416332509675520> do you know any good stake/locking rewarder program implementations? Best thing I've found thus far is the anchor test timelock, but was wondering if there might be any alternates you know of?
Can I use type f64 for ui ?
Or `associated_token::` if you want to specifically use an associated token address for the account
You can init a token account in your program e.g. like this: https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo/src/lib.rs#L171, using the `token::mint` + `token::authority` macros
Can't do that in solana unfortunately‚Äîyou need to pass that account in from the client like all the other ones
so, working on a mod of the anchor escrow program. I want to create a token account within the escrow program itself, so looks like I need to use `anchor_spl::token::InitializeAccount`. How do I create a new keypair within Anchor? Looks like most implementations the pubkey is passed in from the web3 side. Not sure if there's a best practice reason for this, what's the idiomatic way of doing this?
Thought so. Okay thank you for the confirmation!
Nope, every individual token account only works with a single mint. You'd need multiple vaults if you want to use multiple tokens.
Conceptually speaking, I think it is not possible, but is there a workaround that I could make a token account receive two different mints?
Is it possible to have a token account (ATA) or in other words, a vault, to receive two different spl-tokens?
Ok thanks I'll look into this
That stack error might be easy to fix, try doing `Box<Account<'info, Whatever>>` a few times instead of `Account<'info, Whatever>` in the relevant derive(Accounts) struct
Have you tried installing v0.13.2 from a git checkout of the anchor source? Not sure if that will help given the submodule issue you mentioned yesterday
We are working on a clone of https://github.com/blockworks-foundation/ido-pool and trying to create our version of it. The problem is that the codebase is v0.13.2 whereas current standards are for v0.18.0 and up. Now after running anchor build for the first time, this error comes up:
thread 'main' panicked at 'Code not parseable: Error("payer must be provided when initializing an account")'
Now my best knowledge of this is due to pool_account being initialized without a payer here: https://github.com/blockworks-foundation/ido-pool/blob/81d3b1972617afd3f246a22c04fd24909e2bbe4b/programs/ido-pool/src/lib.rs#L194
Refactoring it with #[account(init, payer = distribution_authority)] does not ask because it throws another error. associated or seeds must be provided before payer


Now coming to working on the same repo on anchor v0.18 up
After doing all necessary refactoring to the best of my ability, anchor build succeeds. But all the tests fail with the error logs
Transaction simulation failed: Error processing Instruction 1: Program failed to complete
    Program 11111111111111111111111111111111 invoke [1]
    Program 11111111111111111111111111111111 success
    Program 6bmKfxkaEiySeRzrSpmrNRWMR7F8MT1S77963k6fcyDs invoke [1]
    Program 6bmKfxkaEiySeRzrSpmrNRWMR7F8MT1S77963k6fcyDs consumed 2605 of 200000 compute units
    Program failed to complete: Access violation in stack frame 3 at address 0x200003b90 of size 8 by instruction #12521
    Program 6bmKfxkaEiySeRzrSpmrNRWMR7F8MT1S77963k6fcyDs failed: Program failed to complete
Translating error Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 1: Program failed to complete


If we can figure out a way of running the v.13.2 anchor cli then all of our problems are solved but for some reason I've been going at it all night and the avm use 0.13.2 says the version doesn't exist so we need to find a workaround this
How to set custom rpc endpoint when `anchor deploy` in Anchor.toml? I try to set via solana config set --url but it still point to the default rpc of the cluster.
Does anyone know of a good repo using "solana_program_test" and anchor I can read through? I'm trying to write some simple unittests in rust
Thanks for the help though!
I think I have fixed by having to force delete all my node modules and rebuild again
did you tried `import * as SplToken from '@solana/spl-token'; SplToken.getMinimumBalanceForRentExemptAccount(...)` ?
Hello, I am trying to use functions defined in the @solana/spl-token program such as the 
```
getMinimumBalanceForRentExemptAccount
```
In my js file when I import it like 
```const { getMinimumBalanceForRentExemptAccount} = require("@solana/spl-token")```

I am able to use the function call.

However in my ts file, when I do the same, 
```import { getMinimumBalanceForRentExemptAccount} from '@solana/spl-token'; ```
I get an error message 
 ```Module '"@solana/spl-token"' has no exported member 'getMinimumBalanceForRentExemptAccount'.ts(2305)```

Could I get some help on this issue?
Reading through the Escrow example. Could someone explain how the second line works?
And what is happening here, I'm not sure where it is setting the owner to a PDA. What is the cpi_program and cpi_accounts?

```
 let (pda, _bump_seed) = Pubkey::find_program_address(&[ESCROW_PDA_SEED], ctx.program_id);
 token::set_authority(ctx.accounts.into(), AuthorityType::AccountOwner, Some(pda))?;


impl<'info> From<&mut InitializeEscrow<'info>>
    for CpiContext<'_, '_, '_, 'info, SetAuthority<'info>>
{
    fn from(accounts: &mut InitializeEscrow<'info>) -> Self {
        let cpi_accounts = SetAuthority {
            account_or_mint: accounts
                .initializer_deposit_token_account
                .to_account_info()
                .clone(),
            current_authority: accounts.initializer.to_account_info().clone(),
        };
        let cpi_program = accounts.token_program.to_account_info();
        CpiContext::new(cpi_program, cpi_accounts)
    }
}
```
And in same time do you know how to found a program id (on other project) ?
From a program id, can I see the entire code or just the IDL ?
Mmh let‚Äôs try
Yes
?
Latest version of that library I don't think has the export anymore (check the docs)
tysm
nice, and anchor_spl has a close_account cpi helper fn
ah I see, cool
They have a whole separate close instruction
Ah, `close` actually only works on accounts owned by your program. To close a token account you need to actually CPI to the token program
cool. So for an account with data the address provided here I assume sends SOL to SOL address. For closing a token account, do I need to provide token account address or is the SOL pubkey sufficient (and the ATA will be figured out + initialized if needed).
I'm actually not sure if anchor supports this in a safe way yet https://discord.com/channels/889577356681945098/889577399308656662/941767801759219783
So I see that there's a way to mark an account with `close`  to close at the end of an instruction, but is there a way to close only if some condition is true without exiting with an error? Do i need to create a separate instruction with `close` that I only call from another instruction if the condition is met?
Soooooo... Do you mean that if in my program I send the account to be deleted (the account that contains the data, and I don't know how to get it again with the all() method) and I check that the person who makes the request is the owner of the account, it's feasible?
Sure, you can delete data (it's still in the chain history I guess, but you can delete it/close account/etc.)
Btw <@!134416332509675520>, is it possible to delete a data in the blockchain ? Or we need to play with states active/inactive for show/hide a data ?
It's slightly weird, you send the sol (however you want, presumably system_instruction::transfer) to a token account with the wrapped sol mint as its mint, and then you have to invoke the https://github.com/solana-labs/solana-program-library/blob/master/token/program/src/instruction.rs#L1373 instruction to update the token account's balance, to reflect the new `sol` it has
Does anyone know how to convert SOL to wrapped SOL?
Ok sweet ty
Yep
Wow.. Thanks for your help üôÇ
It's surprisingly easy to do that‚Äîthat's why I asked you to rebuild, to make sure you would deploy the latest code
Does comparing Pubkeys work? For example would a check like for (i in list) { if new_pubkey == i {etc} } work like that (where list is a list of pubkeys)
I built my program the first time and I haven't changed anything in this program since I'm on the frontend. Even with my test.ts it worked. Why did I need to rebuild it?
Probably because you accidentally deployed a stale version of your code the last time you deployed
Why ?
fozeibgepzibgz
Its work
https://tenor.com/view/angry-anger-pixar-inside-out-aaah-gif-5628546
I rebuild/deploy and the program ID still the same
Ok I try
And I confirm the error come from the good program
One thing you might do though, just to check: rerun `anchor build`, and *then* redeploy
Ok, then I guess it could be some other account with the wrong program owner
They are same
Yes
You mean in my lib.rs ?
This is surprisingly easy to mess up
You need to make sure that the version you deployed has that exact same declare_id! as the *actual* runtime program id
In local ? I need to change it in local too ?
And that's what your declare_id! says too?

J'y penserai ! ‚ù§Ô∏è
It is a mystery. The declare_id! of my program is the same as when I initialized it with anchor init.

Then I deployed my program in devnet, and I got a new programID and this is the one I use
When in doubt you can switch (I don't speak super well but I read almost as well as I read english)
Haha sure
EZgezogi its better to explain in french for me haha but I need to learn english x)
Je parle fran√ßais üòõ Ou en tout cas je lis plut√¥t bien haha
You translate it for me ? lol
Probably wrong `declare_id!`
Mm, √ßa d√©pend, je sais pas ce qui se passe
I want the user wallet

Oh ! Finally not
Okey ! And do you know why I don't have the tx details ? Maybe I missed something
Yes üôÇ
This correct my problem. But is it normal and common to use it ?
I don't think so, that `wallet` isn't the right kind of thing
I have it
The point is to use `useAnchorWallet` so that you can build that nice `program` variable so that you can talk to your program
program.provider.wallet.publicKey only makes sense once you've already got your `program` set up (you don't yet)
I just try to understand the difference between use the anchor hook and the program.provider.wallet.publicKey who send me undefined
Like `const wallet = useAnchorWallet()`, then check if it's undefined
What do you mean?
I send the entire hook in the program ?
I'm not sure why it's returning undefined for you though
The idea is to use `useAnchorWallet` so you can set up that `program` variable
oh awesome thank you
Don't actually need to worry about that, since if the token transfer fails the whole tx will just roll back/abort
i am making a cpi to transfer tokens from one associated token account to another. how do i change the data on a separate data storage account only after the transfer has succeeded so i dont mark incorrect data by accident
That just complexify the idea. In my test.ts file I use program.provider.wallet.publicKey
But I need the { wallet } inside useWallet no ? I just need the publicKey ?
Just use it instead of `useWallet`
I don't really understand what I need to do with useAnchorWallet ?
You mean { publicKey } from useAnchorWallet ?
Oh ?
Ah, you need to use `useAnchorWallet`, not just the bare `useWallet`
But wallet only have this
What happens if you just log `wallet`
wallet.publicKey
or
program.provider.wallet.publicKey

return undefined yes
So that's returning undefined?
wallet from useWallet() hook
Meaning how is it defined?
Where is that `wallet` coming from?
Here is my full function, and the error appear on contentCreator
And I have the publicKey from useWallet, but if I use it I have an other error:
"this.wallet.signTransaction is not a function"
Hi! This code return me undefined for wallet and I don't understand why. I try to call my program and send data to the blockchain, and I need to send this wallet who is the wallet of the user.

Any idea ?
Do you think the serum discord could be useful?
ah this may be why the build fails on v0.13.2
You could maybe try installing directly from a git checkout of the anchor repo (checkout that tag, 0.13.2)
Ah. Bummer, not sure how to get around that
I get this when trying to install 0.13.2
Awesome thanks I'll come back if I have any issues
`avm use 0.13.2` should probably work
https://book.anchor-lang.com/chapter_2/installation.html#installing-using-anchor-version-manager-avm-recommended
Hmm ok I looked into the command avm but I couldn't figure out the syntax is it "anchor use (cli-version)"?
You can use `avm` for this now
You're probably going to need to install an older version of the anchor cli (matching the anchor-lang version)
I'm trying to run the ido-pools repo from blockworks but I keep running into this error when running anchor test for some reason
In your Cargo.toml, you need to add `features = ["no-entrypoint"]` maybe (try searchign the anchor repo for that)
e.g. attempting to use Anchor programs as crates, one from 0.22.0 and one from 0.21.0 causes a linking error during build:
```
~/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-program-1.10.0/src/entrypoint.rs:120: multiple definition of `entrypoint'; ~/.../target/debug/deps/libserum_multisig.rlib(serum_multisig.vgg80ip4xm3a9f1.rcgu.o):~/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-program-1.10.0/src/entrypoint.rs:120: first defined here
```
What is the "correct" way to consume Anchor programs in Rust client applications? My main hurdle is differing versions of anchor-lang in their respective dependencies.
that's mean 10000 bytes
PDA accounts have 10KB
Then if I want to init an account with the following account:
```
pub struct Pool {
    /// Priviledged account.
    pub authority: Pubkey,
    /// Nonce to derive the program-derived address owning the vaults.
    pub nonce: u8,
    /// Mint of the redeemable mint
    pub redeemable_mint: Pubkey,
    /// Mint of the token that can be staked.
    pub staking_mint: Pubkey,
    /// Vault to store staked tokens.
    pub staking_vault: Pubkey,
    // Mint of the ido token that can be staked.
    pub ido_mint: Pubkey,
    // Vault to store the ido staked tokens.
    pub iod_vault: Pubkey,
    /// Mint of the reward A token.
    pub reward_a_mint: Pubkey,
    /// Vault to store reward A tokens.
    pub reward_a_vault: Pubkey,
    /// Mint of the reward B token.
    pub reward_b_mint: Pubkey,
    /// Vault to store reward B tokens.
    pub reward_b_vault: Pubkey,
    /// The period which rewards are linearly distributed.
    pub reward_duration: u64,
    /// The timestamp at which the current reward period ends.
    pub reward_duration_end: u64,
    /// The last time reward states were updated.
    pub last_update_time: u64,
    /// Rate of reward A distribution.
    pub reward_a_rate: u64,
    /// Rate of reward B distribution.
    pub reward_b_rate: u64,
    /// Last calculated reward A per pool token.
    pub reward_a_per_token_stored: u128,
    /// Last calculated reward B per pool token.
    pub reward_b_per_token_stored: u128,
    /// Users staked
    pub user_stake_count: u32,
    /// authorized funders
    /// [] because short size, fixed account size, and ease of use on
    /// client due to auto generated account size property
    pub funders: [Pubkey; 4],
    //the version of the pool
    pub version: PoolVersion,
    //trailer for future use
    pub trailer: [u8; 31],
}
```
Then I would have to add up all of these? <-- is there a max limit of the size?
32 bytes
does anyone know the byte size of a pubkey?
Ok, I understand. Thank you!
well you can always use **discord search ** feature
Thank you, this is helpful. But I was wandering if there is also a channel where people post issues like: "     RangeError: Attempt to access memory outside buffer bounds"
for anchor related error :: https://docs.rs/anchor-lang/latest/src/anchor_lang/error.rs.html#22-170

Hello,
I am new with anchor and  in this community. Is there a channel where you can look for errors ? thank you
No, `ido_authority_watermelon` here refers to the actual `Account<'info, TokenAccount>` (so, a token account) right below
ya big seed energy
ah nvm source code answered it lol. so each element can only be 32 bytes maximum as well
No, the `init` attribute will take care of that for you
Just to clarify, your program can mutate any account it owns, no need for a signature (if you want to require a signature you'll have to write that logic into your program)
so basically i should be marking that account as #[account(signer,mut)]
is this the number of array elements to be passed in the seeds? because technically you could concatenate multiple buffers into one single element in that array, correct?
It will require that account's address to sign from the client (it will need to be a keypair address)
by not passing seeds to init it will create a normal account right ? if so does it not need the account to be passed in as a signer ?
https://github.com/solana-labs/solana/blob/37189f20c521809e9b8e20ca39ad62df1a9a4a81/sdk/program/src/pubkey.rs#L19
And yeah, like 0xDeep said, max is 16
These questions are easiest to answer by jumping to source
you can have max 16
in any case, I just need at least two pubkeys, so
ya there may be no max which would be sick
also no mention of max here: https://docs.solana.com/developing/programming-model/calling-between-programs#hash-based-generated-program-addresses
https://solanacookbook.com/core-concepts/pdas.html#generating-pdas also doesn't say anything about maximums. not entirely sure what kind of operation is taken over the input, but could well be that it's a hash operation, and thus allowing arbitrary lengths of seeds. really not sure here though
not sure about maximum unforatunately :/ if it's mission-critical, probably makes sense to just write a short unittest on it. otherwise some of the core devs here might know better
ah okay but how many seeds can one PDA have?

oh i see
aah me saying about the length of seed
i have many PDAs which have 2 pubkeys, and even more data on top of that (a serialized string, and an integer). not sure what the maximum is, but _definitely_ holds more than 1 pubkey
that'd be perfect
yea I was hoping I could use 2 pubkeys
are you sure? can't seeds contain 2 pubkeys, which already make it 64 bytes? or is something off with my logic?
cool, ty
yus
what is max num of bytes that can go into seeds? 32 bytes?
ah ok that makes sense and is what's happening here, thanks for the info!
The other thing that might be going on is that the `payer` account gets included automatically as a signer and if `payer` is the owner of those accounts, then the update instruction does include the signer.
Hey I have a noob question, but wanted to clarify this.
```
pub struct InitializePool<'info> {
    // IDO Authority accounts
    #[account(mut)]
    pub ido_authority: Signer<'info>,
    // Watermelon Doesn't have to be an ATA because it could be DAO controlled
    #[account(mut,
        constraint = ido_authority_watermelon.owner == ido_authority.key(),
        constraint = ido_authority_watermelon.mint == watermelon_mint.key())]
```
Looking at this, inside the constraint section, I see that ido_authority_watermelon**.owner** or ido_authority_watermelon**.mint**, I wanted to know where these owner and mint values come from? Is this just a predefined attribute that is found inside the type of Pubkey?
I'm not actually sure if you have to be an owner of an account to be able to update it - sorry I'm new. But in practice, I think you could make those pda accounts and then include a constraint in the update instruction to limit the accounts that can update.
cause I seem to be able to
Like for example I have a GameData account, which contains a is_game_complete and user_address field. So can anyone change those without a signature?
Only in ways that don't require a signature
But it allows me to change the data on the account? which feels illegal
I think it is because you can execute transactions that change the account without having to sign them, i.e., transfer tokens
In Anchor, why am I allowed to generate a mutable reference to an account that's passed in if that account is not a signer? Is it because the account was init through anchor?
awesome, thank you
macro will handle everytng for you
you can use anchor macro here `close=destination_account_that_will_receive_rent_exempt_cost`
what's the process for closing a pda account? if i just transfer the lamports out of it, will it immediately be garbage collected?
ehh, I get it, I just thought that it is mandatory to upload idls, so I need to find it in the bundled js üôÇ I hoped that we left behind that era...
and now you can fetch it anytime, form anywhere cuz now it is living on blockchain
when you do this `anchor idl init --filepath target/idl/some_xyz_program.json zdt9pYtp3pkKoZh2tL97QLfj2iT7GLqPmpRzbtm4a6c`
It will give you something like this `Idl account created: FE4kEKpaVftjriFbKvtAv8WJiU7cXdivBTwrUTkBEKXu`. This mean, now you have created a account on blockchian in this case solana, which store your IDL.
when you do `anchor build` it will genrate an IDL file, but it's json local file that lives on your computer not on blockchain, you need to upload it via `anchor idl init`
you need to manually upload your IDL in the blockchain.
you mean that `console.log(await Program.fetchIdl(new PublicKey("ArAA6CZC123yMJLUe4uisBEgvfuw2WEvex9iFmFCYiXv"), provider))` works only bcs ME initialized their idl, and my previous snippet is not working bcs monkelabs not? 

as I understand every uploaded program should have an idl in order to others could call it (or could generate frontend code), am I wrong here?
Huh. Instead of a prompt for a signer, I get this error...
what is the recommended way to deal with "IdlError: Type not found" is there a simple way to ignore those types client-side?
In order to use this method, an IDL must have been previously initialized
nope, I try to get it from onchain data only
had you previously ran `anchor idl init`
probably a noob question, but why `console.log(await Program.fetchIdl(new PublicKey("monke1YPHGc3oTmHu1aqepy87suBtys92a2MbonHTww"), provider))` returns with null? the given address indeed a program (solscan: https://solscan.io/account/monke1YPHGc3oTmHu1aqepy87suBtys92a2MbonHTww )
Ah, yeah, don't need the signers array (program.provider.wallet signs no matter what)
How do I do that? Do I simply not include a signers array when calling it, and Phantom will prompt for a signature anyway?


//////////////////////////////////////////////////////////////////////////////////////////

Hey! I was trying create a associated token account in program to receive NFT token, and I got `Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: An account required by the instruction is missing` when I call this program from front-end, I think I got something wrong in the cpi creation, hopefully someone could point that out for me üò¶
Hey, I try to add a validator in the integration tests (Typescript): how can I do that?
https://github.com/metaplex/metaplex/blob/23372a130ad017129365775b26c0a5485e0f00a1/rust/test/nft-candy-machine.ts#L486
Hey! I want to mint NFT in my Solana Program. Im currently reading candy machine source code and I'm confused <:Confused:827196894283431936> Why are they passing some instruction like initing mint if that can be done fully in Solana Program
okay m looking at it
You probably need to pass a BN someplace where you're using a raw js number
That's on the JS side, you aren't making it to the contract at all
this comes though
```
 Initializes the IDO pool:
     TypeError: src.toArrayLike is not a function
      at BNLayout.encode (node_modules/@project-serum/anchor/node_modules/@project-serum/borsh/dist/lib/index.js:35:37)
      at Structure.encode (node_modules/buffer-layout/lib/Layout.js:1272:26)
      at InstructionCoder._encode (node_modules/@project-serum/anchor/dist/cjs/coder/instruction.js:81:51)
      at InstructionCoder.encode (node_modules/@project-serum/anchor/dist/cjs/coder/instruction.js:70:21)
      at /mnt/c/FILES/Development/Web3Dev/Honey-Labs/shdw-ido-pool/node_modules/@project-serum/anchor/dist/cjs/program/namespace/index.js:32:97
      at ix (node_modules/@project-serum/anchor/dist/cjs/program/namespace/instruction.js:26:23)
      at txFn (node_modules/@project-serum/anchor/dist/cjs/program/namespace/transaction.js:13:20)
      at Object.rpc [as initializePool] (node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:8:24)
      at Context.<anonymous> (tests/ido-pool.js:97:27)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
```
okay so i fixed stuff.. now it just fails without any logs
Yeah, so go see where that InvalidParam gets used
okay... i see what u mean
```rs
#[error]
pub enum ErrorCode {
    #[msg("IDO must start in the future")]
    IdoFuture, //300, 0x12c
    #[msg("IDO times are non-sequential")]
    SeqTimes, //301, 0x12d
    #[msg("IDO has not started")]
    StartIdoTime, //302, 0x12e
    #[msg("Deposits period has ended")]
    EndDepositsTime, //303, 0x12f
    #[msg("IDO has ended")]
    EndIdoTime, //304, 0x130
    #[msg("IDO has not finished yet")]
    IdoNotOver, //305, 0x131
    #[msg("Insufficient USDC")]
    LowUsdc, //306, 0x132
    #[msg("Insufficient redeemable tokens")]
    LowRedeemable, //307, 0x133
    #[msg("USDC total and redeemable total don't match")]
    UsdcNotEqRedeem, //308, 0x134
    #[msg("Given nonce is invalid")]
    InvalidNonce, //309, 0x135
    #[msg("Invalid param")]
    InvalidParam, //310, 0x136
    #[msg("Cannot withdraw USDC after depositing")]
    UsdcWithdrawNotAllowed, //311, 0x137
    #[msg("Tokens still need to be redeemed")]
    WithdrawTokensNotAllowed, //311, 0x138
}
```
Try searching for `#[error]` in your code
Mm, you're gonna need to find it in order to say that there's no 11th error üòõ
where do i find that?
Can you show the error enum?
Fixed! That last "buffer" should have been capitalized!
okay... well this doesnt have a `11th` error.. am i missing something
0x136 = 310, and your own custom errors start at 300. So it's the 11th custom error.
```
Transaction simulation failed: Error processing Instruction 0: custom program error: 0x136
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS invoke [1]
    Program 11111111111111111111111111111111 invoke [2]
    Program 11111111111111111111111111111111 success
    Program log: Custom program error: 0x136
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS consumed 31468 of 200000 compute units
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS failed: custom program error: 0x136
Translating error Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: custom program error: 0x136
    at Connection.sendEncodedTransaction (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/shdw-ido-pool/node_modules/@project-serum/anchor/node_modules/@solana/web3.js/lib/index.cjs.js:4834:13)
    at processTicksAndRejections (node:internal/process/task_queues:96:5)
    at async Connection.sendRawTransaction (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/shdw-ido-pool/node_modules/@project-serum/anchor/node_modules/@solana/web3.js/lib/index.cjs.js:4795:20)
    at async Object.sendAndConfirmRawTransaction (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/shdw-ido-pool/node_modules/@project-serum/anchor/node_modules/@solana/web3.js/lib/index.cjs.js:6620:21)
    at async Provider.send (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/shdw-ido-pool/node_modules/@project-serum/anchor/dist/cjs/provider.js:84:22)
    at async Object.rpc [as initializePool] (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/shdw-ido-pool/node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:11:31)
    at async Context.<anonymous> (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/shdw-ido-pool/tests/ido-pool.js:97:9)
```
Can you post the full log?
couldn't find this error code: `0x136`
Ok, yeah, dunno, frontend js tooling is a mess ü§∑‚Äç‚ôÇÔ∏è
https://stackoverflow.com/questions/68707553/uncaught-referenceerror-buffer-is-not-defined has other ways to solve the same error, but only for webpack.
Nope. Same error.
Ran `yarn add buffer`; trying to see if that works.
I don't really understand how polyfill stuff works unfortunately, so not sure what you have to type to get it to work
At the top of my code, I had to add this.
Do you still get the error above if you add buffer though?
The class `BNLayout`. You know, earlier I had an error saying `Buffer is not defined` , which `yarn add buffer` did not fix on its own.
Worst case you can try polyfilling Buffer, `yarn add buffer` I think
Where is that code from?
Update: looks like this is where `toArrayLike` is called. Where exactly is `Buffer` supposed to be defined?
okay thanks for this!
And you haven't allocated enough space (try re-counting the total you'd need for that PoolAccount struct, pretty sure you're missing an 8)
0xa3 = 163
But in general you need to look for the code in the anchor source: https://github.com/project-serum/anchor/blob/v0.18.2/ts/src/error.ts#L83
You should get a checkout of the anchor source + the solana source (plus probably also the solana-program-library)
Google is unfortunately going to be pretty useless for solana dev, you need to just look at source code
i normally google.. couldnt find em in solana docs
it's 0.18.2
And what version of anchor-lang are you using?
Do you know how to search for those error codes?
```
Transaction simulation failed: Error processing Instruction 0: custom program error: 0xa3
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS invoke [1]
    Program 11111111111111111111111111111111 invoke [2]
    Program 11111111111111111111111111111111 success
    Program log: Custom program error: 0xa3
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS consumed 18829 of 200000 compute units
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS failed: custom program error: 0xa3
Translating error Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: custom program error: 0xa3
    at Connection.sendEncodedTransaction (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/shdw-ido-pool/node_modules/@project-serum/anchor/node_modules/@solana/web3.js/lib/index.cjs.js:4834:13)
    at processTicksAndRejections (node:internal/process/task_queues:96:5)
    at async Connection.sendRawTransaction (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/shdw-ido-pool/node_modules/@project-serum/anchor/node_modules/@solana/web3.js/lib/index.cjs.js:4795:20)
    at async Object.sendAndConfirmRawTransaction (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/shdw-ido-pool/node_modules/@project-serum/anchor/node_modules/@solana/web3.js/lib/index.cjs.js:6620:21)
    at async Provider.send (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/shdw-ido-pool/node_modules/@project-serum/anchor/dist/cjs/provider.js:84:22)
    at async Object.rpc [as initializePool] (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/shdw-ido-pool/node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:11:31)
    at async Context.<anonymous> (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/shdw-ido-pool/tests/ido-pool.js:97:9)
```
new error... ;-;
Yeah, not sure why you'd need it here
so i have to remove instructions?
The instruction creates an account there, and then you subsequently try to `init` an account again in that `derive(Accounts)` struct
The problem is that you're both using `init` on that `pool_account` as well as using that `instructions` array to do `poolAccount.createInstruction`. Why are you doing both?
well the code is there.. would u have a look at it if i send the link?
I don't know without seeing all of your code etc. Are you running a persistent validator in the background? There's an account at that address, so you presumably are accidentally init'ing it twice, or forgetting that you init'd it previously and it's hanging around, etc. Just need to think it through.
umm okay.. is there a fix to this? I know i havent initialized it before...
Ok, that's just an actual error üòõ You're apparently trying to init an account that already exists
Hey man, so I boxed the accounts, but a new error popped up
```
Transaction simulation failed: Error processing Instruction 1: custom program error: 0x0
    Program 11111111111111111111111111111111 invoke [1]
    Program 11111111111111111111111111111111 success
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS invoke [1]
    Program 11111111111111111111111111111111 invoke [2]
    Allocate: account Address { address: 6XCaEvM5dmGk4MJdhAxQYYvSuL6qcffWEjaeWz41jpP3, base: None } already in use
    Program 11111111111111111111111111111111 failed: custom program error: 0x0
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS consumed 11710 of 200000 compute units
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS failed: custom program error: 0x0
Translating error Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 1: custom program error: 0x0
    at Connection.sendEncodedTransaction (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/shdw-ido-pool/node_modules/@project-serum/anchor/node_modules/@solana/web3.js/lib/index.cjs.js:4834:13)
```
I assume no luck?
Try searching the discord‚Äîdoing so will show you how to clone that account into a local validator, one way via Anchor.toml https://discord.com/channels/889577356681945098/889702325231427584/946565378685956126
How to work with metaplex token metadata program: metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s on localnet? How to deploy it to the localnet?
Hard to answer that beyond just pointing you to the rust book (you're going to need to read most of it in order to do solana programming): https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html
`imp <'info> TransferWrapper <'info> {
    fn transfer_ctx(&self)-> CpiContext< '_, '_, '_, 'info, Transfer<'info>> {
        CpiContext::new(
            from: self.token_program.to_account_info(),
            Transfer {
                from: self.sender_token.to_account_info(),
                to: self.receiver_token.to_account_info(),
                authority: self.sender.to_account_info(),
            },
        )
    }
}`
what does that ":CpiContext< '_, '_, '_, 'info, Transfer<'info>> { " mean ?

although i have made this slight change because of some of the file sizes involved
it looks too much like a javascript library if you split every function into its own file, not a fan
any video lectures on Anchor_spl ?
haha Ok ManüòÅ
As much as I'm a single-file maxi myself, it is in fact allowed üòõ
You can use multiple files with anchor haha
so why there are multiple files?
No, it's using anchor
i think he's not using anchor. <@!248066053161222144>
it's too difficult to understand Anchor and rust. too low language
https://github.com/armaniferrante/auction-house
can you please share Link?
but i also have no idea
there is auction-house armani wrote up i think
Sorry, not sure, I don't do NFT stuff
is there any example of NFT market place using anchor? Except Candy Machine and MetaPlex. <@!134416332509675520>
it's probably `system_program::invoke_signed` or something like that
hey, how to fix this error?
i've been importing `use crate::consts::*;` but `use crate::lib::*` didn't work, so I guess `libr.rs` is just pure `crate`
that sort of makes sense i guess
yeh that works!
Does `crate::ID` work?
and i'm not able to do `mod lib` or any of the usual stuff to get access
`cannot find value ID in this scope`
it gives me this error
Related question, I can't seem to access `ID` from another file, even though `declare_id` is called in `lib.rs` / the main file in the crate
I'll make an issue about it maybe
ah ok
I think it currently still needs the CHECK (so, yeah, false positive)
or does it still need //Check
do you know if having a single constraint is enough to prevent the compile error?
Yeah think that's the best you can do atm
or do I just have to stick with 
```
  #[account(owner = ID)]
  pub this_account: UncheckedAccount<'info>
```
Is it possible to have 
```rust
   pub this_account: Account<'info>
```
essentially, I'm saying that it's not an uncheckedAccount, because I know that it's owned by the executing program but I don't want to deserialize the account
ok thx mate for the answer
If you want to store a token account at one of your own PDAs, you need to use `token::` rather than `associated_token::` (they're both token accounts, but the token:: version lets you pick the address)
ok ok thx
thx a lot yeah it's since the last week that I learn solana and I found the env pretty confused ahah
You don't have any choice over the address of an associated token address (but you do for a regular old token account)
So it's *already* got seeds, used with a different program
The whole point of an associated token address is that it's *already* a PDA, of a totally different program (the associated token program)
I think part of what you're confused about is that it doesn't make sense to try to use your own seeds with an associated token account
It's for creating an another token account like temporary that will be own later by the pda program
I don't know, would have to have your code to play with
Can you explain why you want to use `seeds = [...]` there for an associated token account?
ok but why the address return form unkown account belong to the user_token_account ?
That's why you get that missing account error, since the associated token stuff is like "where is the expected address?"
yeah that's the case
The `associated_token::` versions say you're trying to init an *associated* token account, with a specific associated token address
That's the problem, just switch it to `token::` instead
oh you think that this mess but it's it's not that the account that the errors occurs
Doesn't make sense to try to use seeds = [...] *and* the `associated_token::` stuff (I actually thought anchor would raise a compile error for that, hmm)
```rust
#[program]
pub mod nft_pool {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        let taker_account = &ctx.accounts.taker_account;
        let pda_escrow = &mut ctx.accounts.pda_escrow;
        pda_escrow.taker = taker_account.key();
        pda_escrow.bump = *ctx.bumps.get("escrow").unwrap();

        let user_token_account = &ctx.accounts.user_token_account;
        let pda_token_account = &ctx.accounts.pda_token_account;
        let user = &ctx.accounts.user;
        // first set the authority of the user_token_account to the pda_escrow
        let cpi_set_authority_accounts = SetAuthority {
            current_authority: user.to_account_info().clone(),
            account_or_mint: pda_token_account.to_account_info().clone(),
        };
        let token_program = &ctx.accounts.token_program.to_account_info();
        let cpi_ctx_set_authority =
            CpiContext::new(token_program.clone(), cpi_set_authority_accounts);

        token::set_authority(
            cpi_ctx_set_authority,
            AuthorityType::AccountOwner,
            Some(pda_escrow.key()),
        )?;

        let cpi_transfer_accounts = Transfer {
            from: user_token_account.to_account_info().clone(),
            to: pda_token_account.to_account_info().clone(),
            authority: user.to_account_info().clone(),
        };

        let cpi_ctx_transfer = CpiContext::new(token_program.clone(), cpi_transfer_accounts);
        token::transfer(cpi_ctx_transfer, 1 as u64)?;

        // then transfer the token to the user_token_account
        Ok(())
    }
}
```
Ah, ok, just change that from `associated_token::` to `token::`.
That's what that `init` + `associated_token::` stuff does
You're init-ing an associated token account right there, right?
it's the user_token_account that mess up
https://solscan.io/account/8kbp1cEVT1FRNRYriBw3PUuP2cELrHX5SFBeFKx7KbzH?cluster=devnet
hey, no the token account already exists
Are you trying to init an associated token account?
This is probably due to an incorrect associated token address
Instruction r√©f√©rence an unknown account
Hey anyone know what is the meaning of this error msg ?
You're running out of stack space. Easiest trick is to try Box'ing some accounts, do `Box<Account<'info, Whatever>>` a few times in your derive(Accounts) stuct.
Very interesting, yeah, I think this could definitely just be a bug in solana‚Äîthis has come up before but I haven't played with it myself. If you upgrade solana does it go away?
https://github.com/switchboard-xyz/switchboard-v2-example/blob/main/rust/anchor-feed-parser/tests/anchor-feed-parser.ts Is there a better example of use?
Can you use `associated_token::mint` with just a pubkey and not the actual account?

Based on the errors I'm getting and the example code it looks like it's the case that you actually need the mint itself and not just the pubkey
<https://github.com/project-serum/anchor/blob/58af625736eac53fd7dd789adfabbc6292c2f9bf/tests/misc/programs/misc/src/context.rs#L62>
https://switchboard.xyz/randomness
how make random number?
Hello, 
I am facing this error : "RangeError: Attempt to access memory outside buffer bounds" when I try "await serumCmn.getTokenAccount(provider, toPubKey);" Can anyone help ? Thank you
```js
// Atomically create the new account and initialize it with the program.
        await program.rpc.initializePool(
            watermelonIdoAmount,
            nonce,
            startIdoTs,
            endDepositsTs,
            endIdoTs,
            withdrawTs,
            {
                accounts: {
                    poolAccount: poolAccount.publicKey,
                    poolSigner,
                    distributionAuthority: provider.wallet.publicKey,
                    payer: provider.wallet.publicKey,
                    creatorWatermelon,
                    redeemableMint,
                    usdcMint,
                    watermelonMint,
                    poolWatermelon,
                    poolUsdc,
                    tokenProgram: TOKEN_PROGRAM_ID,
                    rent: anchor.web3.SYSVAR_RENT_PUBKEY,
                    clock: anchor.web3.SYSVAR_CLOCK_PUBKEY,
                    systemProgram: anchor.web3.SystemProgram.programId,
                },
                signers: [poolAccount],
                instructions: [
                    await program.account.poolAccount.createInstruction(
                        poolAccount
                    ),
                ],
            }
        );
```
The test:
```js
it("Initializes the IDO pool", async () => {
        // We use the watermelon mint address as the seed, could use something else though.
        const [_poolSigner, nonce] =
            await anchor.web3.PublicKey.findProgramAddress(
                [watermelonMint.toBuffer()],
                program.programId
            );
        poolSigner = _poolSigner;

        // Pool doesn't need a Redeemable SPL token account because it only
        // burns and mints redeemable tokens, it never stores them.
        redeemableMint = await createMint(provider, poolSigner);
        poolWatermelon = await createTokenAccount(
            provider,
            watermelonMint,
            poolSigner
        );
        poolUsdc = await createTokenAccount(provider, usdcMint, poolSigner);

        poolAccount = anchor.web3.Keypair.generate();
        const nowBn = new anchor.BN(Date.now() / 1000);
        startIdoTs = nowBn.add(new anchor.BN(5));
        endDepositsTs = nowBn.add(new anchor.BN(10));
        endIdoTs = nowBn.add(new anchor.BN(15));
        withdrawTs = nowBn.add(new anchor.BN(19));

        
```
```rs
#[account]
pub struct PoolAccount {
    pub redeemable_mint: Pubkey,
    pub pool_watermelon: Pubkey,
    pub watermelon_mint: Pubkey,
    pub pool_usdc: Pubkey,
    pub distribution_authority: Pubkey,
    pub nonce: u8,
    pub num_ido_tokens: u64,
    pub start_ido_ts: i64,
    pub end_deposits_ts: i64,
    pub end_ido_ts: i64,
    pub withdraw_melon_ts: i64,
}
```
```rs
#[derive(Accounts)]
pub struct InitializePool<'info> {
    #[account(init, payer = payer, space = 8 + 32 + 32 + 32 + 32 + 32 + 1 + 8 + 8 + 8 + 8)]
    pub pool_account: Box<Account<'info, PoolAccount>>,
    pub pool_signer: AccountInfo<'info>,
    #[account(
        constraint = redeemable_mint.mint_authority == COption::Some(*pool_signer.key),
        constraint = redeemable_mint.supply == 0
    )]
    pub redeemable_mint: Account<'info, Mint>,
    #[account(constraint = usdc_mint.decimals == redeemable_mint.decimals)]
    pub usdc_mint: Account<'info, Mint>,
    #[account(constraint = pool_watermelon.mint == *watermelon_mint.to_account_info().key)]
    pub watermelon_mint: Account<'info, Mint>,
    #[account(mut, constraint = pool_watermelon.owner == *pool_signer.key)]
    pub pool_watermelon: Account<'info, TokenAccount>,
    #[account(constraint = pool_usdc.owner == *pool_signer.key)]
    pub pool_usdc: Account<'info, TokenAccount>,
    #[account(signer)]
    pub distribution_authority: AccountInfo<'info>,
    #[account(signer)]
    pub payer: AccountInfo<'info>,
    #[account(mut)]
    pub creator_watermelon: Account<'info, TokenAccount>,
    #[account(constraint = token_program.key == &token::ID)]
    pub token_program: AccountInfo<'info>,
    pub rent: Sysvar<'info, Rent>,
    pub clock: Sysvar<'info, Clock>,
    pub system_program: Program<'info, System>,
}
```
```

        // Transfer Watermelon from creator to pool account.
        let cpi_accounts = Transfer {
            from: ctx.accounts.creator_watermelon.to_account_info(),
            to: ctx.accounts.pool_watermelon.to_account_info(),
            authority: ctx.accounts.payer.to_account_info(),
        };
        let cpi_program = ctx.accounts.token_program.clone();
        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
        token::transfer(cpi_ctx, num_ido_tokens_u64)?;

        Ok(())
```
The endpoint
```rust
pub fn initialize_pool(
        ctx: Context<InitializePool>,
        num_ido_tokens: String,
        nonce: u8,
        start_ido_ts: i64,
        end_deposits_ts: i64,
        end_ido_ts: i64,
        withdraw_melon_ts: i64,
    ) -> Result<()> {
        let num_ido_tokens_u64 = num_ido_tokens.parse::<u64>().unwrap();

        // msg!("Number of IDO Tokens {:?}", num_ido_tokens_u64);
        if !(start_ido_ts < end_deposits_ts
            && end_deposits_ts <= end_ido_ts
            && end_ido_ts <= withdraw_melon_ts)
        {
            return Err(ErrorCode::SeqTimes.into());
        }
        if num_ido_tokens_u64 == 0 {
            return Err(ErrorCode::InvalidParam.into());
        }

        let pool_account = &mut ctx.accounts.pool_account;
        if Pubkey::from_str(ALLOWED_DEPLOYER).unwrap() != *ctx.accounts.payer.to_account_info().key
        {
            return Err(ErrorCode::InvalidParam.into());
        }
        pool_account.redeemable_mint = *ctx.accounts.redeemable_mint.to_account_info().key;
        pool_account.pool_watermelon = *ctx.accounts.pool_watermelon.to_account_info().key;
        pool_account.watermelon_mint = ctx.accounts.pool_watermelon.mint;
        pool_account.pool_usdc = *ctx.accounts.pool_usdc.to_account_info().key;
        pool_account.distribution_authority = *ctx.accounts.distribution_authority.key;
        pool_account.nonce = nonce;
        pool_account.num_ido_tokens = num_ido_tokens_u64;
        pool_account.start_ido_ts = start_ido_ts;
        pool_account.end_deposits_ts = end_deposits_ts;
        pool_account.end_ido_ts = end_ido_ts;
        pool_account.withdraw_melon_ts = withdraw_melon_ts;

    }

```
GM folks... so I am having this error but I don't know why this is occuring.. can anyone help? The program logs:
```
Transaction simulation failed: Error processing Instruction 1: Program failed to complete
    Program 11111111111111111111111111111111 invoke [1]
    Program 11111111111111111111111111111111 success
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS invoke [1]
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS consumed 2790 of 200000 compute units
    Program failed to complete: Access violation in stack frame 3 at address 0x200003e00 of size 8 by instruction #13316
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS failed: Program failed to complete
Translating error Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 1: Program failed to complete
    at Connection.sendEncodedTransaction (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/shdw-ido-pool/node_modules/@project-serum/anchor/node_modules/@solana/web3.js/lib/index.cjs.js:4834:13)
    at processTicksAndRejections (node:internal/process/task_queues:96:5)
    at async Connection.sendRawTransaction (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/shdw-ido-pool/node_modules/@project-serum/anchor/node_modules/@solana/web3.js/lib/index.cjs.js:4795:20)
    at async Object.sendAndConfirmRawTransaction (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/shdw-ido-pool/node_modules/@project-serum/anchor/node_modules/@solana/web3.js/lib/index.cjs.js:6620:21)
    at async Provider.send (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/shdw-ido-pool/node_modules/@project-serum/anchor/dist/cjs/provider.js:84:22)
    at async Object.rpc [as initializePool] (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/shdw-ido-pool/node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:11:31)
    at async Context.<anonymous> (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/shdw-ido-pool/tests/ido-pool.js:97:9)
```
is there a function in web3: Connection that does this for you? (without deserializing it manually)
ctx.accounts.your_token_account.mint
is there a way to get the mint from an associated token account?
Hi team, I got an error of "Program log: AnchorError occurred. Error Code: . Error Number: 0. Error Message: ." when I use 3 AccountLoader() in my Solana program transactions, is there anyone who have seen this problem before? is there any potential bug related to AccountLoader()? thanks.
My anchor version is 0.22.0, and Solana version is 1.8.14
When creating the #[derive(Accounts)] struct for an instruction, does the order of accounts matter or affect anything?
Has anyone been able to resolve this error before, seems to be an issue with the rand and getrandom crates
Your Initialize struct looks ok. My guess is that the bug is elsewhere in your code.
Hey Im wobdering wha
What th√© meaning of this error msg
Awesome thank you!
thanks üôÇ
https://docs.rs/anchor-lang/latest/anchor_lang/prelude/derive.Accounts.html
Hey just wondering, where in the documentation is a description of all the anchor macros you can use, e.g stuff like `    #[account(
        mut,
        close = user
    )]
`
Yeah, think so, just specify multiple `--bpf-loader` args
can you load multiple programs to solana-test-validator with --bpf-loader? ive only seen examples of one program in a single validator session
But yeah, I miss how with solana when you get stuck you can just jump to source, read a little code, and then proactively unstick yourself. JS tooling stuff is just endless googling, fiddling with json files... ugh, not fun.
At any rate, that `new BN()` stuff should work, not sure yet why it's not in your case
Ouch.
I tried messing around with this a bit locally, and ugh, screwing around with frontend JS tooling is such a nightmare üò£
Oooh I got it
#[account] over a struct is short for [this thing is gonna get stored on-chain in an account]
`#[derive(Accounts)]` is short for `#[derive(AllTheAccountsYouPassToTheInstructionFromTheClient)]`
Thanks you
...
That last `TodoList` struct should say `#[account]` on top of it, not `#[derive(Accounts)]`
Hi ! My new error of the day. I don't understand what is the problem :/
Not sure, but some examples of CPI'ing to the token program in this repo: https://github.com/cqfd/quidproquo
Does anyone have recommendations for tutorials with explanations and example of how to use CPI with Anchor
I did not miss `yarn build`.
But at least this is probably not an Anchor thing if it's an error in bundle creation.
Unless I'm missing a step in the tutorial there?
https://create-react-app.dev/ . Running `yarn build` in case I missed it earlier; that might be the problem.
How are you bundling your code for the browser?
Asked on StackOverflow: https://stackoverflow.com/questions/71565287/arraytype-is-undefined-when-supplying-a-bn-as-an-argument-to-an-anchor-instructi
got it thx
avm install latest && avm use latest
How can I change my globally installed version of anchor on mac?
If so, that might be the reason for my error above. Could also make a thread for this so as not to get lost in the backlog.
it for not populate the discord channel
oh you mean the thread ?
don't know if this can help you
<@!350632015852208140>  it's when I run this code with ts-node that the error occurs
```typescript
const userTokenAccount = new anchor.web3.PublicKey(
    "8kbp1cEVT1FRNRYriBw3PUuP2cELrHX5SFBeFKx7KbzH"
  );

  const [pdaTokenAccount] = await anchor.web3.PublicKey.findProgramAddress(
    [
      user.toBuffer(),
      mint.toBuffer(),
      TOKEN_PROGRAM_ID.toBuffer(),
      anchor.utils.bytes.utf8.encode("token-seed"),
    ],
    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID
  );

  const rent = SYSVAR_RENT_PUBKEY;
  const tokenProgram = TOKEN_PROGRAM_ID;
  const associatedTokenProgram = SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID;
  const systemProgram = SystemProgram.programId;

  const signer = {
    secretKey: Uint8Array.from(privateKey),
    publicKey: provider.wallet.publicKey,
  };

  const ctxInitalizeAccounts = {
    accounts: {
      user,
      pdaEscrow,
      takerAccount,
      pdaTokenAccount,
      userTokenAccount,
      mint,
      rent,
      tokenProgram,
      associatedTokenProgram,
      systemProgram,
    },
  };

  const tx = await program.rpc.initialize(ctxInitalizeAccounts);

  console.log("Your tx signature: ", tx);
})();
```
```typescript
/*
    DEVNET TEST
*/
import * as anchor from "@project-serum/anchor";
import { Program } from "@project-serum/anchor";
import { NftPool } from "../target/types/nft_pool";
import { env } from "process";

const { SYSVAR_RENT_PUBKEY, SystemProgram } = anchor.web3;
const {
  ASSOCIATED_PROGRAM_ID: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,
  TOKEN_PROGRAM_ID,
} = anchor.utils.token;

(async () => {
  env.ANCHOR_WALLET = "/home/kima/.config/solana/id.json";
  env.ANCHOR_PROVIDER_URL = "https://api.devnet.solana.com";

  anchor.setProvider(anchor.Provider.env());

  const privateKey = JSON.parse(
    require("fs").readFileSync("/home/kima/.config/solana/id.json", "utf-8")
  );
  // get the provider
  const provider = anchor.getProvider();
  // get the idl
  const idl = JSON.parse(
    require("fs").readFileSync("./target/idl/nft_pool.json", "utf-8")
  );
  const programID = new anchor.web3.PublicKey(
    "4PN4rfDddrUGeBLaPL48pYzvUHJweokYKbgrBGLiEYPv"
  );

  // get the program
  const program = new anchor.Program(idl, programID) as Program<NftPool>;

  const user = provider.wallet.publicKey;
  const [pdaEscrow] = await anchor.web3.PublicKey.findProgramAddress(
    [anchor.utils.bytes.utf8.encode("escrow"), user.toBuffer()],
    programID
  );
  const takerAccount = new anchor.web3.PublicKey(
    "Ez7DWjDwjQuBjMMu5eUiVqxYfK1ECs4dgbPKdSvyFZp7"
  );
  const mint = new anchor.web3.PublicKey(
    "D9wi8R749wahcXkcwCfUDXTC5RibPisD1Gny1rqVsne4"
  );
```
hmm, not fully sure here :/
can you post the code as well?
yes I wrote it in ts and it check for me that all the account passed is publickey
can you print and double check that all of them are instantiated, publickeys?
in the typescript (or whatever you use)
it sounds like youre not passing in all accounts successfully
https://solscan.io/account/8kbp1cEVT1FRNRYriBw3PUuP2cELrHX5SFBeFKx7KbzH?cluster=devnet
don't know what you mean ?
```rust
#[derive(Accounts)]
pub struct Initialize<'info> {
    // initializer
    #[account(mut)]
    pub user: Signer<'info>,
    #[account(init, payer = user, seeds = [b"escrow", user.key().as_ref()], bump)]
    // pda_escrow for storing state and signing tx
    pub pda_escrow: Account<'info, EscrowAccount>,
    /// CHECK: read access to store the pubkey to the escrow account
    pub taker_account: UncheckedAccount<'info>,

    // the token account created using a specific seeds that belong to the calle
    #[account(init, payer = user, associated_token::authority = user, associated_token::mint = mint, seeds = [b"token-seed"], bump)]
    pub pda_token_account: Account<'info, TokenAccount>,

    #[account(mut)]
    pub user_token_account: Account<'info, TokenAccount>,

    #[account(mut)]
    pub mint: Account<'info, Mint>,

    pub rent: Sysvar<'info, Rent>,
    pub token_program: Program<'info, Token>,
    pub associated_token_program: Program<'info, AssociatedToken>,
    pub system_program: Program<'info, System>,
}
```
```
Transaction simulation failed: Error processing Instruction 0: An account required by the instruction is missing 
    Program 4PN4rfDddrUGeBLaPL48pYzvUHJweokYKbgrBGLiEYPv invoke [1]
    Program log: Instruction: Initialize
    Program 11111111111111111111111111111111 invoke [2]
    Program 11111111111111111111111111111111 success
    Instruction references an unknown account 8kbp1cEVT1FRNRYriBw3PUuP2cELrHX5SFBeFKx7KbzH
    Program 4PN4rfDddrUGeBLaPL48pYzvUHJweokYKbgrBGLiEYPv consumed 31340 of 200000 compute units
    Program 4PN4rfDddrUGeBLaPL48pYzvUHJweokYKbgrBGLiEYPv failed: An account required by the instruction is missing
 {
  logs: [
    'Program 4PN4rfDddrUGeBLaPL48pYzvUHJweokYKbgrBGLiEYPv invoke [1]',
    'Program log: Instruction: Initialize',
    'Program 11111111111111111111111111111111 invoke [2]',
    'Program 11111111111111111111111111111111 success',
    'Instruction references an unknown account 8kbp1cEVT1FRNRYriBw3PUuP2cELrHX5SFBeFKx7KbzH',
    'Program 4PN4rfDddrUGeBLaPL48pYzvUHJweokYKbgrBGLiEYPv consumed 31340 of 200000 compute units',
    'Program 4PN4rfDddrUGeBLaPL48pYzvUHJweokYKbgrBGLiEYPv failed: An account required by the instruction is missing'
  ]
}
```
like does solscan parse it correctly
can you put it in solscan?
yh got it
when I say short it it's for discord not on my code
have you checked that solscan accepts it for example?
maybe it's not so useful to short it like that
hmm weird
no I short it
just making sure I don't get this incorrectly
is this literally the string you use to create this account?
I think it's about the TokenAccount but cannot know why the simulate processing tell me it's an unknown account
---------------------------------------------------------------------------------------------------
```Rust
 pub user_token_account: Account<'info, TokenAccount>,```
```JavaScript
const userTokenAccount = new anchor.web3.PublicKey(
    "8kbp1cEVT1FRNR....SFBeFKx7KbzH"
  );```
Hey, why is the meaning of this error msg:  
```Instruction references an unknown account 8kbp1cEVT1FRNR....SFBeFKx7KbzH```
----------------------------------------------------------------------------------------------------
<@!134416332509675520> https://discord.com/channels/889577356681945098/889577399308656662/955574411635851264 Is it still the case that `toArrayLike` does not work from browser?
sick
PRs welcome though üôÇ
might add this in the next release
https://github.com/project-serum/anchor/issues/980
found the bug: didn't mark the account as mutable, but no error was thrown. is this intended behavior?  ^
i'm doing several identical program.rpc.ix() calls within the same it(...) in a typescript test, each which should be mutating data. Every tx is successful, but somehow the data is reverted to its original state by the time the next call happens:
```
  Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS invoke [1]
    Program log: Instruction: Unstake
    Program log: stake info key: BXjmAAEarSRj4EVrDy3eXZ5dDzL7ioagLMp8eW2a25Hh
    Program log: now: 2
    Program log: requested_unstake: false [READ HERE]
    Program log: requested_unstake_epoch: 0 [READ HERE]
    Program log: delay: 1
    Program log: stake_info.requested_unstake | (stake_policy.delay_period == 0): false
    Program log: setting request data
    Program log: requested_unstake: true [SET HERE]
    Program log: requested_unstake_epoch: 2 [SET HERE]
    Program log: delay: 1
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS consumed 36012 of 1400000 compute units
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS success
Transaction executed in slot 129:
  Signature: 3cMbPq7YfA9KbtdSrzseFdHbRt964akhseZkWRG2RzBGmssGTRZrZUiPtKiyB93yT6FePk9fuy8M6xVaZBbRycr2
  Status: Ok

  Log Messages:
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS invoke [1]
    Program log: Instruction: Unstake
    Program log: stake info key: BXjmAAEarSRj4EVrDy3eXZ5dDzL7ioagLMp8eW2a25Hh
    Program log: now: 4
    Program log: requested_unstake: false [READ HERE, somehow equal to original]
    Program log: requested_unstake_epoch: 0 [READ HERE, somehow equal to original]
    Program log: delay: 1
```
any idea what's going on? I'm on a local validator with `--slots-per-epoch 32`. never had an issue like this before
i have explicitly overwritten my .so file with the output of /verifiable to overcome the `binaries don't match` error
```anchor verify -p audius_data Fki7j8r4TAFzWxChaKRbCG3FC4tt8h8oqarRasRZBy8P --provider.cluster https://audius.rpcpool.com/ 

+ exit 0
cargo-build-bpf child: /root/.local/share/solana/install/releases/1.8.5/solana-release/bin/sdk/bpf/dependencies/bpf-tools/llvm/bin/llvm-readelf --dyn-symbols /workdir/docker-target/deploy/audius_data.so

To deploy this program:
  $ solana program deploy /workdir/docker-target/deploy/audius_data.so
The program address will default to this keypair (override with --program-id):
  /workdir/docker-target/deploy/audius_data-keypair.json
Copying out the build artifacts
Cleaning up the docker target directory
Removing the docker container
anchor-program
Extracting the IDL
Writing the IDL file
Writing the .ts file
Build success
Error: Account not found
```
hey all, am attempting to verify a program on mainnet but keep getting this result - has anyone overcome this?
To me it seems like it comes from the test side, maybe not providing the right accounts context ?
Maybe there is a better way to share such code examples, please enlighten me üòõ
Sorry for bloat messages
The output and error : 
```
 hashmaplike-sc
TX signature ihutuZ742k2JJDSkdwr4myqkPhMRpriSKMxTsiZNzBdfYpB6byX26LuJ6PisBe4V3L1JBbopteC97wqCk1bUW77
    ‚úî Is initialized! (418ms)
    1) Creates item


  1 passing (514ms)
  1 failing

  1) hashmaplike-sc
       Creates item:
     Error: unknown signer: CefvkEbCGuQPTb3G3y21o57Guu1a1jEzAGYuU69UWJZ3
      at Transaction._addSignature ...
```
and the tests : 

```ts
import * as anchor from "@project-serum/anchor";
import { Program } from "@project-serum/anchor";
import { HashmaplikeSc } from "../target/types/hashmaplike_sc";
import { PublicKey, Keypair, SystemProgram } from "@solana/web3.js";

describe("hashmaplike-sc", () => {
  // Configure the client to use the local cluster.
  const provider = anchor.Provider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.HashmaplikeSc as Program<HashmaplikeSc>;
  
  const hashmapAccount = Keypair.generate();
  const hashmapItemAccount = Keypair.generate();
  const key = Keypair.generate();

  it("Is initialized!", async () => {
    
    const tx = await program.rpc.initialize({
      accounts: {
        user: provider.wallet.publicKey,
        hashmap: hashmapAccount.publicKey,
        systemProgram: SystemProgram.programId,
      },
      signers: [hashmapAccount]
    });
    console.log("TX signature", tx);
  });

  it("Creates item", async () => {

    const [hashMapItemPDA, _] = await PublicKey
    .findProgramAddress(
      [
        anchor.utils.bytes.utf8.encode("stake"),
        provider.wallet.publicKey.toBuffer(),
        key.publicKey.toBytes(),
      ],
      program.programId
    );
    
    const tx = await program.rpc.createItem(key.publicKey, {
      accounts:{
        hashmap: hashmapAccount.publicKey,
        hashmapItem: hashMapItemPDA,
        user: provider.wallet.publicKey,
        systemProgram: SystemProgram.programId
      },
      signers:[hashmapItemAccount]
    });
    
    console.log("TX signature", tx);
    
  });

});
```
Hi everyone, I asked a question a couple of days ago on the solana tech server about implementing a hashmap like data structure on solana. 
I tried using PDAs to solve that as kindly advised there and now I stumble across an other problem that I can't understand.

I reproduced an example if anyone want to test, the rust :
```rust
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod hashmaplike_sc {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        Ok(())
    }

    pub fn create_item(ctx: Context<CreateItem>, key: Pubkey) -> Result<()> {
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {

    #[account(init, payer = user)]
    pub hashmap: Account<'info, HashMapAccount>,

    #[account(mut)]
    pub user: Signer<'info>,

    pub system_program: Program<'info, System>,

}

#[derive(Accounts)]
#[instruction(key: Pubkey)]
pub struct CreateItem<'info> {
    pub hashmap: Account<'info, HashMapAccount>,

    #[account(
        init, 
        payer = user, 
        seeds = [
            b"item", 
            user.key().as_ref(), 
            key.as_ref(), 
        ], 
        bump
    )]
    pub hashmap_item: Account<'info, HashMapItemAccount>,

    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,

}

#[account]
#[derive(Default)]
pub struct HashMapAccount {
    count: u32,
}

#[account]
#[derive(Default)]
pub struct HashMapItemAccount {
    value: u32,
}
```
(The error persists even if, instead of the result of `parseInt`, I supply a raw hardcoded number.)


//////////////////////////////////////////////////////////////////////////////////////////

hello, guy how can i send sol from pda ?
thanks <33
100% now!
Yep
OHHH I see the difference .
like you stiill start to have your unlocking but only can claim after this date
It's just an incentivization hack, that's all
It encourages you to work hard to make it to 1 year, since you're about to suddenly get a quarter of your equity allotment
That's just the scheme people use
why isn't the start after 1 year then?
why you start now and add delay of 1 year before it "actually" starts?

(thankns for info I think I get it)
The purpose of the cliff is to make sure you're incentivized to stick around for at least a year (/ the company is incentivized to boot you before the 1 year mark if you're not working out)
Using with vesting schedules there's a "cliff", where you don't actually get any of your vesting rewards until after the cliff. For example, lots of US tech companies have a 4 year vesting schedule with a "1 year cliff", meaning you actually don't vest any of your options until the 1 year mark after you join‚Äîthen you suddenly get 1/4 of your allotment. After the cliff point you vest more regularly, like every month or whatever.
just realizing this is not related to anchor specifically
<@!134416332509675520> 
I don't get what is cliffTS
because if I have a start date to start unlocking the tokens and then a duration, what is the cliff?
getAssociatedTokenAddress takes an optional argument to allow off-curve addresses (try jumping to source)
If I want an escrow ATA for a program what should I do?
Is it not possible to create an ATA for a PDA?
```
  const escrowAtaAddress = await Token.getAssociatedTokenAddress(
    ASSOCIATED_TOKEN_PROGRAM_ID,
    TOKEN_PROGRAM_ID,
    tokenMintAddress,
    escrowAddress
  );
```
Generates a non program address
Ok, I guess I'll just keep on and put back my code and have an other try.
Also as I get some of your time.?
Can I have an example of a CPI with an already pushed program?
Like I want to use Bonfida's token vesting program already uploaded.
but from backend how do I declare it? in the anchor.toml?
works ...
Mm, can you try running `BROWSER= anchor test`?


Yeah, just try running `anchor test` and see what happens
haven't tried tbh, the error caught me there, I'll try someting
Not sure, does the code work when you actually run it?
<@!134416332509675520>  anyb idea of where to look? thanks in advance üôÇ
And then pass them in as accounts‚Äîwhy do you need to fetch their account info at all on the client?
Sounds like you just need one call to look up the relevant pubkeys
Why would you need to call getAccountInfo multiple times? Or getMultipleAccounts at all?
Hi <@!134416332509675520>  i wanted to extend on this. So you're saying we can't store "AccountInfo" details on the program, but u can store the public keys. OK.

So lets say i store in my program the list of participants (basically a vector of public keys). I need to pay each of the participants a share of whats in the PDA escrow. Therefore i need to pass to my from the front end to the program via an RPC call, a vector of AccountInfos. 

So in order to do that, my front end first has to retrieve all the participant public keys from the program (do-able using program.account.XXX.fetch), iterate through the public key array.

IF i have 100 participants, rather than calling getAccountInfo 100 times, I think i could use call getMultipleAccounts once instead

Not really a question but thinking out loud.
If I don't mistake in your program you have to specify the length, try 8+8 instead of just 8
Facing this error while passing in the data. Data is type of u8 array of size 8


Hello guys, I don't get wht anchor.workspace isn't working?
I'm  using version 19.0
?
Can't see it in the flags, but is there any way to increase the timeout time
Seems to me like it happens when the size of the `.so` is larger than 400kb
Yeah, think this just happens sometimes, not sure
Seems like its a type of timeout
Anyone had an issue deploying to `devnet` with the following error?
```
Error: Custom: Invalid blockhash
```
much appreciated
Sure
alright noted! but where would the destination be? id have to use invoke_signed and a pda to hold the native sol, correct?
You'd use wrapped sol if you also need to support token transfers
If all you need to do is move sol then I would just use the vanilla system transfer.
for native sol transfers, would it be better to use the system instruction or would it be better to wrap sol? i see two approaches for doing this and i'm not sure which to use.
well this is kinda depressing tho, i wanted to setup my own validator later on..
yay that worked
let me try devnet i guess then
they just added hardware requirements for test validators
i guess i havent been doing anything wrong
:/
not too important tho, nvm if you didn't come across it üôÇ was just wondering if there was a cleaner way around this
basically just to calculate the `uiAmount` and `uiAmountString` attributes xD
ah sry, forgot to include decimals in the interface
Like, how would it know the number of decimals etc. to use?
What would you want that to do?
bcs rn I just re-create the object using the interface (creating the members is trivial, I'm just surprised there is not constructor for this interface)
and I was wondering if there was a "new TokenAmount" of some sort, which takes as input ```new TokenAmount(javascriptNumber)```
so basically TokenAmount https://solana-labs.github.io/solana-web3.js/modules.html#TokenAmount is just a typescript interface
Where is that object coming from? Not familiar with TokenAmount
when I have a `TokenAmount` object, and I want to modify it (based on some user's input), what is the best way to create a new TokenAmount object?

how can do this based on the amount of decimals and the floating point number in typescript?
Yeah, can probably just install over it
or should i just reinstall over it
any idea how to uninstall solana?
Sure!
can i dm?
Just to double check, do you even need to allocate an account there? Do you specifically need that account to be owned by your program etc.?
Ok, the problem is that `init` on `market_authority`, you need to specify how much space you want to allocate
here's the code: ```#[derive(Accounts)]
#[instruction(bump: InitMarketBumpSeeds)]
pub struct InitializeMarket<'info> {
    #[account(zero)]
    pub market: AccountLoader<'info, Market>,

    /// The account for storing quote tokens during swaps
    #[account(init,
        seeds = [
            market.key().as_ref()
        ],
        payer = owner,
        bump = bump.market_authority)]
    pub market_authority: AccountInfo<'info>,

    /// The account for storing quote tokens during swaps
    #[account(init,
        seeds = [
            b"dex-swap-tokens".as_ref(),
            market.key().as_ref()
        ],
        bump = bump.dex_swap_tokens,
        token::mint = quote_token_mint,
        token::authority = market_authority,
        payer = owner)]
    pub dex_swap_tokens: Account<'info, TokenAccount>,

    /// The account to use for placing orders on the DEX
    #[account(init,
        seeds = [
            b"dex-open-orders-a".as_ref(),
            market.key().as_ref()
        ],
        bump = bump.dex_open_orders_a,
        payer = owner,
        owner = dex::ID,
        space = std::mem::size_of::<OpenOrders>() + 12,
        rent_exempt = skip)]
    pub dex_open_orders_a: AccountInfo<'info>,

    /// The DEX market that can be used to trade the reserve asset
    pub dex_market_a: AccountInfo<'info>,

    /// The program for interacting with the DEX
    #[account(address = dex::ID)]
    pub dex_program: AccountInfo<'info>,

    #[account(mut)]
    pub nft_droplet_mint: AccountInfo<'info>,

    #[account(signer)]
    pub owner: AccountInfo<'info>,

    pub rent: Sysvar<'info, Rent>,

    pub system_program: AccountInfo<'info>,

    /// The mint for the market quote tokens
    pub quote_token_mint: AccountInfo<'info>,

    /// The program for interacting with the token.
    #[account(address = token::ID)]
    pub token_program: AccountInfo<'info>
}```
Anchor won't work until you can run `solana-test-validator` successfully
Ok, sorry, I haven't used wsl so not sure, but you're going to have to figure out how to get a working solana install
on windows 10
wsl
What kind of machine are you on?
Gonna have to reinstall
Yeah, your solana install is broken for some reason
:/


huh it instantly just said aborted
Does it actually run correctly?
What happens if you do `solana-test-validator`
Are you able to actually run a local validator at all?
so i havent changed anything
i didnt find anything like test.startup_wait in the anchor.toml
``Unable to get recent blockhash. Test validator does not look started. Check .anchor/test-ledger/test-ledger-log.txt for errors. Consider increasing [test.startup_wait] in Anchor.toml.``
What does it say? Post the error message
anchor test doesnt work either tho
Yeah, anchor test does, but anchor deploy requires an actual cluster to deploy to
it does it automatically
hey yeah
unless im blind
didnt see anything in the book
Yep üòõ
if im supposed to start one up
uhh i guess not
What does `lsof -i :8899` say?
Are you actually running a local validator?
and i have no idea what
so i think im just doing something wrong
ive tried setting up anchor on my laptop and pc both are getting this error
You definitely shouldn't need `AccountInfo` to implement Default
Can you post more of the surrounding code? Are you accidentally storing an `AccountInfo` inside of an `#[account]` struct or something?
so i anyways ended up doing Account<'info, TokenAccount> and now I'm getting now i am getting ```no function or associated item named `default` found for struct `anchor_lang::prelude::AccountInfo` in the current scope``` instead. any idea on this?
its testnet
what seems to be the problem here

Any idea, someone, please?
okay got it
Oh, no, you don't need to sign for the token account itself‚Äîyou need to sign for whoever has authority over the token account, the token account owner.
Other than the cluster in my Achor.toml file, I've changed nothing.
so that mean I will use the same seed and bump to sign the cpi transfer instruction for the PDA's TokenAccount?
yeah I checked that. I check with the solana cli to make sure it's the right address and that I have SOL on all networks.
Maybe check your Anchor.toml to make sure you're using the wallet you want to?
hi all. 
I'm getting some strange stuff. Using version 0.23 of anchor. 
I can build just fine
I can deploy to localhost just fine
I can deploy to Testnet just fine
when I deploy to Devnet I get this error:
Error: Account allocation failed: RPC response error -32002: Transaction simulation failed: This account may not be used to pay transaction fees
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.
Ok, if you want to sign for that address, then you need to use those seeds (and possibly re-calculate the bump with `find_program_address` if you forgot to store it somewhere)
a simple vault str and payer pubkey,if you mean the vault PDA
These are probably the most annoying rust lifetime errors üòõ One trick that I think will work is to just inline the `cpi_ctx` varible (don't make a separate variable for it, just stuff the rhs into `mint_to`)
Hey, getting strange error. Smthing with rust I guess. Interesting that I‚Äôm using authority_seeds without a problem at 88th line
That depends on on how you made the vault address! What seeds did you use?
I don't think this could have been working with an AccountInfo ü§î Since, yeah, those definitely don't know about mints etc.
Hey I am still struggling with pda signing for spl token transfer, I transferred some tokens to  to the vault PDA using the solana cli and it now hold some token, what seed and bump choice should be used for the program sign the transfer in this case?
https://lorisleiva.com/create-a-solana-dapp-from-scratch/our-first-instruction check out the "Guarding against invalid data" 

and then 
"https://lorisleiva.com/create-a-solana-dapp-from-scratch/testing-our-instruction" - How to use it in JS
Bump.
great!
Hey, any idea how I can add validators in integration tests (typescript)?
Hey so I need to do a transfer from one token account to another in my ts tests. Whats the best way to do this with the current apis?
hi everyone, how would one set a custom error to be used by a constraint? for example, if I wrote a custom error, how would I be able to use it when a constraint is violated?
not sure ,but try using anchor upgrade instead of anchor deploy
I'm a newb but maybe Anchor build/deploy again?
Hi Anchor community, I try to use Anchor to build an app today but encounter a problem. I build an `instruction` that has `#[account]` as one of its parameters. 
```
#[account]
pub struct ExampleAccount {
  name: String
}

pub fn set_data(ctx: Context<SetData>, data: ExampleAccount) -> Result<()> {}
```
But the problem is, I use this program as a CPI used from other programs. Therefore, the `account` struct used as a parameter is not compiled to IDL. What I mean is the compiled IDL has the instruction `set_data` with the declared parameter `ExampleAccount` but in the IDL, there is no definition for the type `ExampleAccount` and Anchor throws something like `Type ExampleAccount does not exist in the IDL`. Have anyone know how to resolve this issue?
Hey, whenever I run ```anchor deploy``` on the localnet, anchor always deploys my program from scratch. How can I fix this?
I don't think spl-token have anythin' such that. Metaplex dervied `print`(Copy of nft) term
I'm talking about Non Fungible Tokens(NFT's) with multiple supply. <@!717956950737813594>
i don't want to go through **MetaPlex** because its code is too lengthy and difficult to understand, so my major interest is go through **Anchor**.
is it so?
Ok I guess you are taking about `print`.
https://docs.metaplex.com/about/terminology
yeah copies of NFT's in Ethereum chain they are ERC1155 standard. <@!717956950737813594>
now i am getting ```no function or associated item named `default` found for struct `anchor_lang::prelude::AccountInfo` in the current scope``` instead. any help on this is appreciated!
okay so changed this to ```#[derive(Accounts)]
#[instruction(bump: InitMarketBumpSeeds)]
pub struct InitializeMarket<'info> {
    #[account(zero)]
    pub market: AccountLoader<'info, Market>,

    /// The account for storing quote tokens during swaps
    #[account(init,
        seeds = [
            market.key().as_ref()
        ],
        payer = owner,
        bump = bump.market_authority)]
    pub market_authority: AccountInfo<'info>,

    /// The account for storing quote tokens during swaps
    #[account(init,
        seeds = [
            b"dex-swap-tokens".as_ref(),
            market.key().as_ref()
        ],
        bump = bump.dex_swap_tokens,
        token::mint = quote_token_mint,
        token::authority = market_authority,
        payer = owner)]
    pub dex_swap_tokens: Account<'info, TokenAccount>,

    /// The account to use for placing orders on the DEX
    #[account(init,
        seeds = [
            b"dex-open-orders-a".as_ref(),
            market.key().as_ref()
        ],
        bump = bump.dex_open_orders_a,
        payer = owner,
        owner = dex::ID,
        space = std::mem::size_of::<OpenOrders>() + 12,
        rent_exempt = skip)]
    pub dex_open_orders_a: AccountInfo<'info>,

    /// The DEX market that can be used to trade the reserve asset
    pub dex_market_a: AccountInfo<'info>,

    /// The program for interacting with the DEX
    #[account(address = dex::ID)]
    pub dex_program: AccountInfo<'info>,

    #[account(mut)]
    pub nft_droplet_mint: AccountInfo<'info>,

    #[account(signer)]
    pub owner: AccountInfo<'info>,

    pub rent: Sysvar<'info, Rent>,

    pub system_program: AccountInfo<'info>,

    /// The mint for the market quote tokens
    pub quote_token_mint: AccountInfo<'info>,

    /// The program for interacting with the token.
    #[account(address = token::ID)]
    pub token_program: AccountInfo<'info>
}``` just to get rid of earlier error
wdym by copies of nft?
Means that "anchor_spl"  donot support multiple tokens(Copies oF NFT's) <@!717956950737813594>
NFT have max supply of 1
yeah you can, I think the only d/f b/w fungible and non-fungible is max-supply
can we use "anchor_spl" to create NFT or it is just for SPL tokens(Fungible) ?
maybe core devs can help here
Unfortunately not, sorry üôÇ
Hey thanks, yeah I figured that out but I just want to be doing AccountInfo which seemed to be working in the earlier anchor version. Would you happen to have any idea on that?
S'not mut or signer which are the normal constraints for a wallet
As a sanity check, the player wallet should be unchecked in case of an airdrop?
Dangit that constraint doesn't count as making it safe lol
I'm pretty sure, you know this, but posting it here anyway.
```Account<'info, TokenAccount>```
just curious üòÜ
`don't want to be doing that` any good bad reason for this?
Would the best constraint for 'this is a normal wallet account' be owner = sys?
and here's the error in more detail ```no field `mint` on type `anchor_lang::prelude::AccountInfo<'_>`
  --> programs/jet/src/instructions/init_market.rs:43:10
   |
43 | #[derive(Accounts)]
   |          ^^^^^^^^ unknown field
   |
   = note: available fields are: `key`, `is_signer`, `is_writable`, `lamports`, `data` ... and 3 others
   = note: this error originates in the derive macro `Accounts` (in Nightly builds, run with -Z macro-backtrace for more info)``` also i'm getting similar errors in a couple more places after changing to anchor v1.19.0 which goes away on deserialising to Account<'info, Whatever> but I don't want to be doing that instead just use AccountInfo which worked in anchor v1.18.2. any ideas on how i can go about this?
Here's the corresponding code: ```#[derive(Accounts)]
#[instruction(bump: InitMarketBumpSeeds)]
pub struct InitializeMarket<'info> {
    #[account(zero)]
    pub market: AccountLoader<'info, Market>,

    /// The account for storing quote tokens during swaps
    #[account(init,
        seeds = [
            market.key().as_ref()
        ],
        payer = owner,
        bump = bump.market_authority)]
    pub market_authority: AccountInfo<'info>,

    /// The account for storing quote tokens during swaps
    #[account(init,
        seeds = [
            b"dex-swap-tokens".as_ref(),
            market.key().as_ref()
        ],
        bump = bump.dex_swap_tokens,
        token::mint = bump.quote_token_mint,
        token::authority = market_authority,
        payer = owner)]
    pub dex_swap_tokens: AccountInfo<'info>,

    /// The account to use for placing orders on the DEX
    #[account(init,
        seeds = [
            b"dex-open-orders-a".as_ref(),
            market.key().as_ref()
        ],
        bump = bump.dex_open_orders_a,
        payer = owner,
        owner = dex::ID,
        space = std::mem::size_of::<OpenOrders>() + 12,
        rent_exempt = skip)]
    pub dex_open_orders_a: AccountInfo<'info>,

    /// The DEX market that can be used to trade the reserve asset
    pub dex_market_a: AccountInfo<'info>,

    /// The program for interacting with the DEX
    #[account(address = dex::ID)]
    pub dex_program: AccountInfo<'info>,

    #[account(mut)]
    pub nft_droplet_mint: AccountInfo<'info>,

    #[account(signer)]
    pub owner: AccountInfo<'info>,

    pub rent: Sysvar<'info, Rent>,

    pub system_program: AccountInfo<'info>,

    /// The program for interacting with the token.
    #[account(address = token::ID)]
    pub token_program: AccountInfo<'info>
}```
god bless dude
https://github.com/project-serum/anchor/blob/v0.18.2/ts/src/error.ts#L87
nope it's not, custom errors started from 6000+
`constraint = something`
0x8f = Raw constraints violated
300+ is starting of custom errors
jk decode it into decimal
decoded it means: `y0urm0m`
what is custom error 0x8f
üòõ
You still caused me to re-search which was helpful lol
kk
Ooo
i accidentally responded in the wrong chat
nah i wasn't talking about u
Oh maybe I left it limited to this channel whoops. I can Discord I swearz
Fucking discord search zzz lol, NOW it shows up for me >< Thank you üôÇ
oh then i have a different problem
I already solved it. There was a previous fix I did where I introduced `Buffer` as lowercase instead of capital.
Think I found a solution
What are you sending to anchor?
can someone help?
```cannot return value referencing temporary value returns a value referencing data owned by the current function```
Hey I am trying to make a token transfer from a PDA to another account and I know I need to use a CPI new_with_signer, but when I try to give it the signer_seeds i am getting an error
lol
damn same guy had the same issue 8 hours ago
~~Happy to post full program log if that's helpful, just would rather DM instead of scrub it :p~~

Oop, I see that this is known until anchor updates to spl v3, fair nuff
```error[E0425]: cannot find value `rent` in this scope
  --> programs/genesis-token/src/lib.rs:51:10
   |
51 | #[derive(Accounts)]
   |          ^^^^^^^^ not found in this scope
   |
   = note: this error originates in the derive macro `Accounts` (in Nightly builds, run with -Z macro-backtrace for more info)```
(localnet identifiers if any vultures out there ;D)

EDIT: This is known until anchor updates to v3 SPL. You need to pass in rent sysvar like olden times until then
```mod determinant_identifier {
    use super::*;
    declare_id!("FjZqqSHAVS6vB7J58pSKN1MAWmM4XQLXBithCCBDmNUG");
}

mod our_token_mint {
    use super::*;
    declare_id!("By4QvAng1aS3mjixCePXRYXZYL59fB2UCgU4PbyHVDhQ");
}


#[derive(Accounts)]
pub struct PurchaseFrozenOurToken<'info> {
    #[account(constraint = determinant_keypair.key == &determinant_identifier::ID)]
    pub determinant_keypair: Signer<'info>,
    #[account(mut)]
    pub player_wallet: Signer<'info>,
    #[account(
        init_if_needed,
        associated_token::mint = &our_token_mint::ID,
        associated_token::authority = player_wallet,
        payer = player_wallet,
        constraint = player_ata.amount == 0)]
    pub player_ata: Account<'info, TokenAccount>,
    #[account(constraint = token_program.key == &token::ID)]
    pub token_program: Program<'info, Token>,
    pub associated_token_program: Program<'info, AssociatedToken>,
    pub system_program: Program<'info, System>
}```
Mmm upon changing over to that, I'm getting an error I'm not finding here, in the doc, or on google at all
All works great now
Mmm yea the tooltips on the errors there / documentation on the combination of init_if_needed / associated_token wasn't quite clear to me, but you've been great ‚ù§Ô∏è
Baller
You don't need to do any init logic yourself for ATAs, just do `init_if_needed` + `associated_token::mint = ...` and `associated_token::authority = the_owner`
Probably just like TokenAccount::size or somethin
On another note (as I'm new and encountering all the delicious toys anchor has all at once), any chance there's a nice utility for space for an ATA?
Delightful! Thanks a bunch
Yeah, init_if_needed for ATAs works fine + is super convenient
(Also apologies if @ing is pass√© <3. Thanks for your tireless answers here :>)
<@!134416332509675520> I saw you recommended init for this use case but unsure if init_if_needed is acceptable.
Main reasoning being not forcing a second authorization popup to users for a getOrCreateATA precursor call
Is it alright to init_if_needed an ATA? I'm not seeing the vulnerability there :s. Assuming that's for custom program accounts rather than SPL
awesome this is exciting thank u ser
Ah, yeah, you probably want `decimal: u8`
either way, enough to get started, thanks again legend
That worked, awesome learned something new today. hmm, now im wondering if decimal needs to be BN (u64) or just u8 since max decimal is just 9? decimal is just needed for token transfers to make sure the right amount is being sent unless I just parse that from the frontend.
boooom
will try
makes a ton of sense lol
Cool cool
Yep
Yeah, map over it or whatever and convert those pubkey strings to actual PublicKeys
ok, so maybe JSON parse above, and then pass a new array with a new object with Pubkey type
Ohhhh
You need an actual PublicKey object in there, not a string
looks like there is only one other question around this in this discord and its kind of similar lol
I don't think JSON.parse is going to work on that string there
```
const sfbp = parseInt(sellerFeeBasisPoints, 10);
    console.log(configs);
    const walletKeyPair = loadWalletKey(keypair);
    const anchorProgram = await loadCoinFlipProgram(walletKeyPair, env, rpcUrl);

    let twdKey: anchor.web3.PublicKey;
    let fwdKey: anchor.web3.PublicKey;

    if (!treasuryWithdrawalDestination) {
      log.info("No treasury withdrawal dest detected, using keypair");
      twdKey = walletKeyPair.publicKey;
    } else {
      twdKey = new anchor.web3.PublicKey(treasuryWithdrawalDestination);
    }

    if (!feeWithdrawalDestination) {
      log.info("No fee withdrawal dest detected, using keypair");
      fwdKey = walletKeyPair.publicKey;
    } else {
      fwdKey = new anchor.web3.PublicKey(feeWithdrawalDestination);
    }

    const [myProgram, bump] = await getMyProgram(walletKeyPair.publicKey);
    const [feeAccount, feeAccountBump] =
      await getFeeAccount(coinFlip);
    const [treasury, treasuryBump] = await getTreasury(
      myProgram
    );
await anchorProgram.rpc.initialize(
      bump,
      feeAccountBump,
      treasuryBump,
      sfbp,
      JSON.parse(configs),
      {
        accounts: {
          payer: walletKeyPair.publicKey,
          authority: walletKeyPair.publicKey,
          feeWithdrawalDestination: fwdKey,
          treasuryWithdrawalDestination: twdKey,
          myProgram,
          feeAccount,
          treasury,
          systemProgram: anchor.web3.SystemProgram.programId,
        },
      }
    );
```
Can you show how you're trying to use it in JS?
Pubkey is fine
```
UnhandledPromiseRejectionWarning: TypeError: key.toBuffer is not a function
    at WrappedLayout.encoder (/Users/don/SourceCode/coin-flip/node_modules/@project-serum/borsh/src/index.ts:118:29)
    at WrappedLayout.encode (/Users/don/SourceCode/coin-flip/node_modules/@project-serum/borsh/src/index.ts:106:36)
    at Structure.encode (/Users/don/SourceCode/coin-flip/node_modules/buffer-layout/lib/Layout.js:1263:26)
    at /Users/don/SourceCode/coin-flip/node_modules/buffer-layout/lib/Layout.js:1113:25
    at Array.reduce (<anonymous>)
    at Sequence.encode (/Users/don/SourceCode/coin-flip/node_modules/buffer-layout/lib/Layout.js:1112:22)
    at Structure.encode (/Users/don/SourceCode/coin-flip/node_modules/buffer-layout/lib/Layout.js:1263:26)
    at WrappedLayout.encode (/Users/don/SourceCode/coin-flip/node_modules/@project-serum/borsh/src/index.ts:106:24)
    at Structure.encode (/Users/don/SourceCode/coin-flip/node_modules/buffer-layout/lib/Layout.js:1263:26)
    at BorshInstructionCoder._encode (/Users/don/SourceCode/coin-flip/node_modules/@project-serum/anchor/src/coder/borsh/instruction.ts:92:24)
```
can I still use Pubkey on that SPLConfig struct or does it have to be a Vec<u8> now? Running into this now
cool yea im trying that now, seemed to get me a little further
Ah, sorry, here you want `SPLConfig` to `#[derive(AnchorSerialize, AnchorDeserialize, Clone)]`, not `#[account]` (it's not directly an account, it's just going into the MyProgram account)
I think i see the issue tho
all the types seem to be present
hmm when calling the initialize function im getting the classic `IdlError: Type not found: {"type":{"defined":"SPLConfig"}}`

Im passing the json representation of the Vec<SPLConfig> into the params of the initialize function. Wondering if Im missing something. This is a sample im passing :

```'[{"mintKey": "BjKwSGuZFKjszgNPqRDYfkcvEi9kZvCHxP7PrewxAaoZ", "sellerFeeBasisPoints": 300, "burn": true, "decimal": 9 }, {"mintKey": "4Bzxa49sWP68uR7G1EN58doe4GMwnX4NmuSnTNMtN9NC", "sellerFeeBasisPoints": 500, "burn": true, "decimal": 9 }]'```
and the struct is 
```
#[account]
pub struct SPLConfig {
    pub mint_key: Pubkey,
    pub seller_fee_basis_points: u16,
    pub burn: bool,
    pub decimal: u64
}
```
Thats on the main program account obj
```
#[account]
pub struct MyProgram {
    pub spl_config: Vec<SPLConfig>
}
```
lol
thank u
https://tenor.com/view/dying-monkey-dying-gif-13123180
cool cool, ok going to try something, I added a few fields so im calculating if theres 20 configs, that would be around 864 üëÄ
signer of the txn thats transferring the token and the authority of the ata receiving the token
so basically the signer + authority of the ATA?
No, `#[account]` already uses borsh
authority of the ATA
Is the authority in spl_token transfer function the mint authority account?
Ok I see, so I wouldnt use #[account] since I need to deserialize with borsh? Or can I use AnchorDeserializer?
Each of those `Config` things would take 32 + 1 + 2 bytes using borsh, so a vec of them would take 4 (for the length of the vec) + N * (32 + 1 + 2) bytes.
It can be done, you just need to decide how many possible elements you want to support (at the moment you only get one shot to allocate account space, so you have to just pick a big-enough number)
When doing a transfer how do I set a return on this to see if it was successful or not>
actually I assume this cant be done?
That worked brooooü§òüèª
Ok
Try that
#[derive(Accounts)]
pub struct CreateVoter<'info> {
    pub registrar: AccountLoader<'info, Registrar>,

    #[account(
        init,
        seeds = [registrar.key().as_ref(), b"voter".as_ref(), voter_authority.key().as_ref()],
        bump,
        payer = payer,
        space = 8 + size_of::<Voter>(),
    )]
    pub voter: AccountLoader<'info, Voter>,

    /// The authority controling the voter. Must be the same as the
    /// governing_token_owner in the token owner record used with
    /// spl-governance.
    pub voter_authority: Signer<'info>,

    /// The voter weight record is the account that will be shown to spl-governance
    /// to prove how much vote weight the voter has. See update_voter_weight_record.
    #[account(
        init,
        seeds = [registrar.key().as_ref(), b"voter-weight-record".as_ref(), voter_authority.key().as_ref()],
        bump,
        payer = payer,
        space = size_of::<VoterWeightRecord>(),
    )]
    pub voter_weight_record: Box<Account<'info, VoterWeightRecord>>,
------------------------------------------
I would still be keeping the #[instruction(voter_bump: u8, voter_weight_record_bump: u8)] bit?
#[derive(Accounts)]
#[instruction(voter_bump: u8, voter_weight_record_bump: u8)]
pub struct CreateVoter<'info> {
    pub registrar: AccountLoader<'info, Registrar>,

    #[account(
        init,
        seeds = [registrar.key().as_ref(), b"voter".as_ref(), voter_authority.key().as_ref()],
        bump = voter_bump,
        payer = payer,
        space = 8 + size_of::<Voter>(),
    )]
    pub voter: AccountLoader<'info, Voter>,

    /// The authority controling the voter. Must be the same as the
    /// `governing_token_owner` in the token owner record used with
    /// spl-governance.
    pub voter_authority: Signer<'info>,

    /// The voter weight record is the account that will be shown to spl-governance
    /// to prove how much vote weight the voter has. See update_voter_weight_record.
    #[account(
        init,
        seeds = [registrar.key().as_ref(), b"voter-weight-record".as_ref(), voter_authority.key().as_ref()],
        bump = voter_weight_record_bump,
        payer = payer,
        space = size_of::<VoterWeightRecord>(),
    )]
    pub voter_weight_record: Box<Account<'info, VoterWeightRecord>>,
right that's the new way to do it
would anchor realize which bump goes where?
So here is the full line:
 #[account(init, 
        seeds = [b"seed_phrase".as_ref()], 
        space= YOUR SPACE,
        bump, 
        payer = user,)]
bump,
I get this error,  bump targets should not be provided with init. Please use bump without a target. How do I pass multiple bumps with init??
so on initialize, the Vec would be empty but when I call update, it would push new config structs to the vec or replace it entirely (if i cant simply push data to the vec)
If I want to add a Vec<T> on my program that I can push data to when calling an update handler (for example) what would be the best way to calculate size? T would be something like :

```
 pub struct Config {
  pub key: PublicKey,
  pub decimals: u8,  
  pub amount: u16,
}
```
Hello, I'm running into a strange problem here...I'm trying to deploy to devnet and I'm gettin an error: Error: Account allocation failed: RPC response error -32002: Transaction simulation failed: This account may not be used to pay transaction fees. when I'm on my localhost I do not have any problem. I've checked and there is a balance on my devnet wallet. I've searched around and I've found some answers where people have "Hard coded" devnet into the Anchor.toml file and that seems to have solved it. (no idea how that would help).. Any thoughts?
How does one convert the Buffer returned by `accountInfo.data` into usable data?
Works; thanks!
Just have to fetch it and see if there's an account there, e.g. `program.provider.connection.getAccountInfo(theAddress)`
How can I tell from Typescript whether an account has already been initialized, or otherwise prevent double-initializing?
uninstalling right after I get arch downloaded
and wanted to become a startup app
popups every 2 seconds and it wanted me to install chrome
holy shit bit torrent is annoying
that's a no bs completely from scratch os so it should be decent
might just go arch
I use a mac so I dunno üòõ My last computer ran pop os though (basically ubuntu), sure it's fine
which distro should I use this time <@!134416332509675520>
gaming
I liked using linux when I did, but poor gamign
it return me error: failed to compile anchor-cli v0.23.0 (https://github.com/project-serum/anchor#811a4cb3), intermediate artifacts can be found at /tmp/cargo-installGgaMcU
[23:20]
Anyone can help me ?
I might just bite the bullet and restart on a linux vm
Hello i have a problem when i try install anchor with this commands :  cargo install --git https://github.com/project-serum/anchor anchor-cli --locked
Pretty sure you're going to have to use the windows subsystem for linux stuff, WSL
damn
I dunno, sorry, I don't use windows so not sure what's up
this is wallet now
"E:/Boxez/gem-farm/GEML1jRuKGLgtegiBrLqFnKY43W2j1WbX9FWZsKRbgMg.json"

smh
Well, it's wrong üòõ
coz im used to it
You'll probably need a full filepath too
Why is it a \ and not a /?
that's the file path
But whatever you're trying to do there isn't valid toml
It's that funky \G in your wallet (not sure what that means)

Can you post your Anchor.toml then?
For future searchers, a possible fix for ```custom attribute panicked

help: message: removal index (is 0) should be < len (is 0)```

Make sure you're passing in your context to a program function if you're just stubbing stuff out?
I can't find B in that position in Anchor.toml

Not possible to skip that in solana
No matter what, you always have to pass in every account of interest from the client
no problem, I will try it now
(You need to pass in the associated token program too, but you also need to pass in the actual associated token *account*)
I was trying to create the token account for the program to receive the NFT
Are you doing this conditionally or something?
Also, just to double check‚Äîcan you not just skip all of this and use `init` + the `associated_token::mint` and `associated_token::authority` attributes?
You need to calculate that associated token address on the client and pass it in
Ok, I think the problem is that `associated_token` ought to be the actual token account, not the associated token *program*
how about this lol
Oh, sorry, I can't read ü§¶‚Äç‚ôÇÔ∏è
```
 let cpi_accounts = Transfer {
                    from: ctx.accounts.nft_token_account.to_account_info(),
                    to: ctx.accounts.vault_token_account.to_account_info(),
                    authority: ctx.accounts.nft_token_account.to_account_info(),
                };
                let cpi_context =
                    CpiContext::new(ctx.accounts.token_program.to_account_info(), cpi_accounts);

                anchor_spl::token::transfer(cpi_context, 1)?;
```
is that what you mean?
Ok, then how is that cpi_accounts variable defined? Are you actually passing all the relevant accounts?
Hi, I just did some search on the discord seems like that might be the problem , I have logged the address getting from the function and its did print out the the correct token address
https://solscan.io/account/Bo9Q6He7qzHoF2BXCBWZgeMK5xcM2K5VNQTTHRKUUDC7?cluster=devnet
That means you probably aren't calculating the associated token address correctly on the client
Can you show more of your code?
When running `anchor test`, 1/1 of my tests are passing, but .anchor/program-logs is empty. My function is literally just `msg!("Test");` What am I missing?
```no field `mint` on type `anchor_lang::prelude::AccountInfo<'_>``` any idea on this error that i'm getting after switching to v1.19.0? Anyway to get rid of this without deserialising?


//////////////////////////////////////////////////////////////////////////////////////////

for the program
will show you the key generated after the first build
solana address -k target/deploy/<program-name>-keypair.json
anchor keys list
hey, this is probably asked a lot, but how to know the address for declare_id when deploying to the devnet ?)
seems like soteria is better for non anchor programs because it mostly is checking unchecked accounts...is this true?

and anchor does a lot of this for you...or does it help w other things?
when we init an account with a dedicated struct
hey the sol dev, putting a #[derive(Default)] doens't work anymore we need to precise the space now with anchor 0.0.23
What do you mean? Not sure I understand your question
Hi does multiple programs in a single anchor contract repo generate multiple .so files in target/deploy from anchor build?
how do I transfer sol from token account who's owner is a PDA
also, when I use accountType.fetchMultiple, will it automatically set any account that is not of type `accountType` to null?
how can I fetch all accounts owned by a user, by modifying this line:
``` 
let response = await solbondProgram.account.accountType.all();
``` ? 

The documentations https://project-serum.github.io/anchor/ts/classes/AccountClient.html#all mentions a filter, but not sure if this is applicable here
I followed metaplex struct but it's not working  ü•≤ 
error: bump targets should not be provided with init. Please use bump without a target.
Kk sry. Not the issue I had then
only this
uhhh no there's no such thing
Is the final line of output an error about program address?
nope
seems like middle tests are not executing making this test failed. If you scroll up in console I think there would be some program logs
no program logs
just this
```
      AssertionError [ERR_ASSERTION]: The expression evaluated to a falsy value:

  assert.ok(poolWatermelonAccount.amount.eq(new anchor.BN(0)))

      + expected - actual

      -false
      +true
```

which i think means the test is not reaching the endpoint at all
what error you are getting in console ?
Like can we customize the candy machine to accept the other token ( other than SOL)
any idea on how can I take the NFT mint payment in some other tokens ?
`console.log()` them maybe?
what if i would like to check the output on successful tests?
they come up in the terminal itself.. on top of each failed test
i'm not seeing `.anchor/program-logs` after running `anchor test` . Any idea how to get these logs showing on each program run?
I console logged `firstUserRedeemable` and `secondDeposit`. (the params in endpoint calls)
both are similar bignumbers. but the endpoint is not being called at all in the failing test
```ts
    it("Exchanges second users Redeemable tokens for watermelon", async () => {
        secondUserWatermelon = await createTokenAccount(
            provider,
            watermelonMint,
            provider.wallet.publicKey
        );

        await program.rpc.exchangeRedeemableForWatermelon(secondDeposit, {
            accounts: {
                poolAccount: poolAccount.publicKey,
                poolSigner,
                redeemableMint,
                poolWatermelon,
                userAuthority: provider.wallet.publicKey,
                userWatermelon: secondUserWatermelon,
                userRedeemable: secondUserRedeemable,
                tokenProgram: TOKEN_PROGRAM_ID,
                clock: anchor.web3.SYSVAR_CLOCK_PUBKEY,
            },
        });

        poolWatermelonAccount = await getTokenAccount(provider, poolWatermelon);
        assert.ok(poolWatermelonAccount.amount.eq(new anchor.BN(0)));
    });
```
This test is failing
```ts
it("Exchanges user Redeemable tokens for watermelon", async () => {
        // Wait until the IDO has opened.
        if (Date.now() < withdrawTs.toNumber() * 1000) {
            await sleep(withdrawTs.toNumber() * 1000 - Date.now() + 2000);
        }
        let firstUserRedeemable = firstDeposit.sub(firstWithdrawal);
        userWatermelon = await createTokenAccount(
            provider,
            watermelonMint,
            provider.wallet.publicKey
        );

        await program.rpc.exchangeRedeemableForWatermelon(firstUserRedeemable, {
            accounts: {
                poolAccount: poolAccount.publicKey,
                poolSigner,
                redeemableMint,
                poolWatermelon,
                userAuthority: provider.wallet.publicKey,
                userWatermelon,
                userRedeemable,
                tokenProgram: TOKEN_PROGRAM_ID,
                clock: anchor.web3.SYSVAR_CLOCK_PUBKEY,
            },
        });

        poolWatermelonAccount = await getTokenAccount(provider, poolWatermelon);
        let redeemedWatermelon = firstUserRedeemable
            .mul(watermelonIdoAmount)
            .div(totalPoolUsdc);
        let remainingWatermelon = watermelonIdoAmount.sub(redeemedWatermelon);
        assert.ok(poolWatermelonAccount.amount.eq(remainingWatermelon));
        userWatermelonAccount = await getTokenAccount(provider, userWatermelon);
        assert.ok(userWatermelonAccount.amount.eq(redeemedWatermelon));
    });
```
This one is passing
GM folks. so one test is failing. but the weird fact is that there are 2 calls being made to the same endpoint in 2 different tests.. one is passing the other in failing
When I wanna deploy my program to mainnet, do I need to deploy it to my node?
for anyone interested: `new anchor.BN(program.account.yourAccount.accountField).toNumber()`
Got it
trying to read account data from client, it seems small numbers u64 are included raw in the BN array, but a large i64 (timestamp) comes out pretty scambled :/
How do you convert a BN back to a regular ts number?
because that's a solana tool which doesn't know about anchor concepts like the IDL
Why doesn't `solana program deploy` update the idl ü§î ?
alright, i'm trying to follow an anchor tutorial online but it's in an older version. I'm using latest version and running into issues with PDA and the breaking changes around bump. Anyone have a working example of using PDA with latest version of anchor I can take a look at?
<a:pogbanana:716423728203825172>  bullish on anchor!!!!

thanks <@!134416332509675520> üôÇ got my auction solana program up and running thanks to you:
‚ù§Ô∏è
please tell me there is a better way
For all the talk on how fast solana is, my unit tests are extremely slow (running with a local validator). Then I discovered commitment = processed and it got better but I still can't read a new account (like new NFT metadata) without having sleep(10 s) after the mint
I'm personally just funemployed atm and have a lot of free time to help on discords, but serum funds/employs other people
how is anchor funded? do u guys get grants from solana foundation?
nice job, you're the reason ive been looking fly for all these years
It's been a little while since I worked there but still friends with them
I used to be roommates with a bunch of people who worked there‚Äîone of them is the CTO and hired all of us as the first engineers haha
Hahaha üòÜ Yeah, I did
üòÆ
i shop there all the time
bro u used to work at grailed?
lmao
so maybe i just need to init it before with rpc
well that last constraint will never be true
im getting chewed up
this shit is wild
is there any step thru debugging with local testing
xD
Give it a rip
```
    #[account(
        init_if_needed,
        payer = seller,
        token::mint = item_mint,
        token::authority = seller,
        constraint = item_token_account.owner == seller.key() @ErrorCode::NotAuthorized, 
        constraint = item_token_account.amount == 1u64 @ErrorCode::AmountZero,
    )]
    pub item_token_account: Account<'info, TokenAccount>,
```
Can I have constraints still? Like this ^
Otherwise it just asserts that those other constraints indeed hold
It's just like the `init` attribute, but only inits if needed, yeah
```#[account(
        init_if_needed,
        payer = seller)]```

or do I need to do:

```
    #[account(
        init_if_needed,
        payer = seller,
        token::mint = <mint>,
        token::authority = <authority>,
    )]
```
üòÆ
There's also `init_if_needed` for this kind of situation
Possibly
so I have to do create ATA before calling my rpc function?
Account<'info, Whatever> expects an actual Whatever account, already initialized etc.
Ah, just because you use an ATA address doesn't mean there's an actual token account there
i dont understnad how something can not be a program account if you're deriving it from getATA or getProgramAccount functions
Is it possible Im generating associated token accounts wrong or something?
Just rebuild and deploy it again to be sure
Ah, sorry, hard to learn much there‚Äîbut if it works on devnet it's very likely that you accidentally deployed a stale .so file to wherever it's not working
Was this not useful?
(Usually doesn't really help much to box an AccountInfo)
Ah, Box currently doesn't work on AccountInfo, just Account
```
#[derive(Accounts)]
pub struct ExchangeWithTransfer<'info> {
    #[account(mut)]
    pub burn_token_acct: Box<Account<'info, TokenAccount>>, // token account with tokens to be burned
    #[account(mut)]
    pub burn_mint: Account<'info, Mint>, // mint of the token to be burned
    #[account(signer)]
    pub token_acct_owner: AccountInfo<'info>, // owner of the to be burned token acct
    pub token_program: Box<AccountInfo<'info>>, // SPL token prog
    pub token_mint: Box<Account<'info, Mint>>,
    #[account(mut)]
    pub escrow_token_acct: Box<Account<'info, TokenAccount>>, // escrow token account we are transferring out
    #[account(
        init, 
        payer = token_acct_owner, 
        associated_token::mint = token_mint,
        associated_token::authority = token_acct_owner)]
    pub receiver_token_acct: Box<Account<'info, TokenAccount>>, // token account we are transferring into
    #[account(mut)]
    pub global_tracker: Box<Account<'info, GlobalTracker>>, // global state to be updated
    #[account(mut)]
    pub exchange_info: Box<Account<'info, ExchangeInfo>>, // data acct where we store the mint to be transferred
    pub associated_token_program: Program<'info, AssociatedToken>,
    pub system_program: Program<'info, System>, // Solana sys prog
    pub rent: Sysvar<'info, Rent>,
}
```
That's some random other error, can you show me how you used Box?
hmm, what is the import i'm missing here?

```
Failed to resolve: use of undeclared crate or module `__client_accounts_box`
use of undeclared crate or module `__client_accounts_box`
```
If that doesn't work then you can try fancier things too
Just says "uh... ok stick this thing in the heap ü§û"
Yeah
That's just doing `<Box<Account<'info, ...>>`?
Out of stack space, can try maybe Box'ing some `Account<'info, Whatever>`s (easiest potential fix)
hmm, when I do that I now get:

```
Transaction simulation failed: Error processing Instruction 0: Program failed to complete 
    Program GpLZRedGz2uNoFXo24UxxfQivDvw3xSHzdGhTYFFKdSC invoke [1]
    Program GpLZRedGz2uNoFXo24UxxfQivDvw3xSHzdGhTYFFKdSC consumed 2505 of 200000 compute units
    Program failed to complete: Access violation in stack frame 3 at address 0x200003e60 of size 8 by instruction #16474
    Program GpLZRedGz2uNoFXo24UxxfQivDvw3xSHzdGhTYFFKdSC failed: Program failed to complete
```
and it works on devnet D:
i think
its weird cus non of the token accounts are correct
kk one sec
But post the actual error lol, not quite sure which one you're talking about
Yeah
i saw a bunch of people saying if declare_id is wrong then u might get non program errors
So why do you need to redeploy at all?
Surprisingly easy to forget to rebuild‚Äîif you skip that step then you end up just redeploying the *old* .so file
yeah but my initial deploy was the correct address
Yeah, you need to change it, *rebuild*, and only then redeploy
in `declare_id`
In the declare_id! ?
Like when u first deploy a program it might have the wrong address name so u redeploy
And not sure what you mean by always needing to redeploy ü§î
Easier if you post the full error
You'd have `associated_token::authority = your_wallet_that_you_passed_in`
Yep ^
You'd need to do the `associated_token::mint` + `associated_token::authority` attributes instead of `token::`
is there a way to initialize this with my walletPubkey as the authority?
Ok, right, that's an associated token address‚Äîa PDA
so I find the associated token account address, but it's not initialized
```
const nftATA = await PublicKey.findProgramAddress(
    [
      walletPublicKey.toBuffer(),
      spl.TOKEN_PROGRAM_ID.toBuffer(),
      nftExchangePubkey.toBuffer(),
    ],
    spl.ASSOCIATED_TOKEN_PROGRAM_ID
  );

let nftTokenAcct = nftATA[0];
```
Think I'm misunderstanding
I'm doing:
But why wouldn't you have the token account keypair?
Then you can't init a token account there
i don't have the token account keypair
You don't have to sign for the owner of the token account, you have to sign for the token account itself‚Äîfor its own address
The reason I'm redeploying is because I'm getting "not program account" errors. Do you always need to redeploy even if the address id in the rust code is correct?
Why wouldn't that work?
I'd use the SPL token program to create it, then pass it into my programs call
but if I want to init a token account that's owned by my wallet keypair (instead of the program), I can't do that via the anchor init syntax
You can, but you have to add the `seeds = [...], bump,` attributes so that anchor/your program can sign for the address
so if it's not a keypair, I can't create a token account like that
ah I see
In general though, you can alway check the generated IDL and see which accounts are expected to sign
Whenever you init an account in solana, at the end of the day its address needs to sign, either from the client if it's a keypair address or from within the program if it's a PDA
It signs for the wallet, not anything else
Not for receiverTokenAccount (is that a keypair address?)
doesn't phantom take care of that for you?
I am signing though
And you're initing a token account at a keypair address, so that address needs to sign from the client with the `signers: [...]` thing
imma just start reusing the same solana program address and switch executable code LOL
You don't want to specify space at all for the TokenAccount stuff
good lord
So, a 1.5 ish mb .so file would, yeah, be 20 ish sol
Yeah, rent exemption costs 7 sol / mb, and the upgradeable deployment process by default 2x's your original .so file size so you have room to grow
if I have:

```

#[derive(Accounts)]
pub struct ExchangeWithTransfer<'info> {
    #[account(mut)]
    pub burn_token_acct: Account<'info, TokenAccount>, // token account with tokens to be burned
    #[account(mut)]
    pub burn_mint: Account<'info, Mint>, // mint of the token to be burned
    #[account(signer)]
    pub token_acct_owner: AccountInfo<'info>, // owner of the to be burned token acct
    pub token_program: AccountInfo<'info>, // SPL token prog
    pub token_mint: Account<'info, Mint>,
    #[account(mut)]
    pub escrow_token_acct: Account<'info, TokenAccount>, // escrow token account we are transferring out
    #[account(
        init, 
        payer = token_acct_owner, 
        token::mint = token_mint,
        token::authority = token_acct_owner,
        space = 500)]
    pub receiver_token_acct: Account<'info, TokenAccount>, // token account we are transferring into
    #[account(mut)]
    pub global_tracker: Account<'info, GlobalTracker>, // global state to be updated
    #[account(mut)]
    pub exchange_info: Account<'info, ExchangeInfo>, // data acct where we store the mint to be transferred
    pub system_program: Program<'info, System>, // Solana sys prog
    pub rent: Sysvar<'info, Rent>,
}
```

and calling like so:

```
const tx2 = await program.rpc.exchangeWithTransfer(
    amountToBurn,
    amountToReceive,
    {
      accounts: {
        burnTokenAcct: burnTokenAcct.address,
        burnMint: burnMintPubkey,
        tokenAcctOwner: walletPublicKey,
        tokenProgram: spl.TOKEN_PROGRAM_ID,
        tokenMint: nftExchangePubkey,
        escrowTokenAcct: escrowedMakerTokens,
        receiverTokenAcct: nftTokenAcct, //nftTokenAcct.address,
        globalTracker: globalTrackerPDA,
        exchangeInfo: randomSelectionPDA,
        systemProgram: anchor.web3.SystemProgram.programId,
        rent: anchor.web3.SYSVAR_RENT_PUBKEY,
      },
    }
  );
```

Why am I getting:
```
Uncaught (in promise) Error: Signature verification failed
```
Lol
20 SOL to deploy <:LMAO:693902932709474341>
good thing i didnt try to deploy my own gemworks farm
So assuming nothing goes wrong, that temporary part finishes and you then get the sol back (even if it fails you can still get it back, just requires an extra command)
ouchies
No, it's because the deployment process actually temporarily uses that sol to store the new program code during the deployment process, can read more here: https://jstarry.notion.site/Program-deploys-29780c48794c47308d5f138074dd9838
is that cus the CLI tries to simulate and calculate costs?
probably my issue
ahh
Not much, though you annoyingly need to have roughly the original deploy cost in you wallet
You don't have to specify space at all actually, just do `token::mint = the_mint`, `token::authority = the_owner` etc. (or associated_token::)
on devnet it doesnt cost much
How much should it cost to update a solana program?
Does anchor use the deploy keypair automatically?
nbd just do the old model
SPL itself doesn't require it on latest
Need to pass in sysvar until anchor updates to v3 spl
```
declare_id!("5VzP....");
```
```
[programs.mainnet]
auction = "5VzP....."
```
Anyone know why when I deploy the mainnet and try again it tries to make a new program even though I've got the program address set?
what was your solution to this?
If I want to do:

```
#[account(
        init,
        payer = payer, space = ???)]
    pub receiver_token_acct: Account<'info, TokenAccount>, 
```
How much space does `init` a `TokenAccount` usually requier?
Can anyone have a look at this for me? https://discord.com/channels/889577356681945098/889584618372734977/956340459888861234
That's wild that msg'ing a pubkey costs 5% of the total compute budget üòÜ Damn
Ah, cool!
costs 200 vs ~11K when logging it with msg!
use the .log() function on Pubkey
Sanity check: you don't need to check a wallet's lamport balance so that is has enough for all the minutiae, the entire transaction will just fail if it would be overdrawn, yes?
mind if I dm you the code to see if we can make any optimizations?
Apparently converting pubkeys to strings is expensive
They actually can take a surprising amount unfortunately (I don't have great intuition though)
I am adding some print statements in my program - how much compute units does that take up?
Any easy tips/tricks to getting around:

```
index.browser.esm.js:7355 Transaction simulation failed: Error processing Instruction 0: Program failed to complete 
    Program GpLZRedGz2uNoFXo24UxxfQivDvw3xSHzdGhTYFFKdSC invoke [1]
    Program log: Instruction: ExchangeWithTransfer
    Program log: Burn mint account: 13KN77C3TFkFXYRbf39ZfTJAKBKX2nRKdH2UB1TqD396
    Program log: Token account to be burned: F8jC7HMDwwr2Qs1JgU6kLX57xSM6Ds3Ddw9D9yC3PfRw
    Program log: Token account owner: GFaWuwHEv7DPMP8VAZMrnHf1kDqSMEzWMf2iYwQH8ZJC
    Program log: Exchange Info mint address: 7KCD6vuYHXPuqn4N1CwnkYDHHpRvsGz9KfcGjLcB8T2G
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [2]
    Program log: Instruction: Burn
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 2632 of 137642 compute units
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success
    Program log: Token burnt, time to give them the NFT
    Program log: Mint account that we are transferring: 7KCD6vuYHXPuqn4N1CwnkYDHHpRvsGz9KfcGjLcB8T2G
    Program log: Transferring from escrow account: 89HmSEqVD72w8pxhAPQyVmrDHQVghiVx4sevWN8HA592
    Program log: To receiver token acct: A4YVmCqkdAWS1knQS1wEDZzLwRdcwkCWcf3mBdJMKAwh
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [2]
    Program log: Instruction: Transfer
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 2549 of 89883 compute units
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success
    Program GpLZRedGz2uNoFXo24UxxfQivDvw3xSHzdGhTYFFKdSC consumed 200000 of 200000 compute units
    Program failed to complete: exceeded maximum number of instructions allowed (200000) at instruction #33097
    Program GpLZRedGz2uNoFXo24UxxfQivDvw3xSHzdGhTYFFKdSC failed: Program failed to complete
```
`--skip-deploy` should only do what it says but I think it might also skip the local validator startup currently although that would be a bug
Does anyone use solnet (the C# library)?
Does skip-deploy also skips the validator anchor spins up, cause I was using anchor test --skip-local-validator alongside --skip-deploy and manuay deploying on local net
`anchor test --skip-deploy` (can run `anchor test --help` for more options)
hey, im testing my program on the localnet. If I make ```anchor test``` it deploys and tests everything, but it takes around 1-2 minutes. However, if I just change typescript test code (without touching program code) and run ```anchor test``` it again deploys program from scratch and again take around 1-2 minute. Im tired of waiting that long after changing even one line of code in tests. What can I do?
But it's still referencing the old one so I'll continue with what you're suggesting
Thanks I used solana program close
You can move/delete the existing keypair in `target/deploy`, and then anchor build will make a new one (then you annoyingly need to remember to update your declare_id! to match the new one‚Äîtry running `anchor keys list` to see what it looks like), and then *rebuild again*)
How can I change the program Id of a program?
thanks
oh wow worked
oh but it did not print log though, also it was always giving an error saying ``cannot read properties of undefined something fetch``
You're trying to init an account at an address that already has an account
This came after the earlier error got resolved
and i need to clear a bunch of them
I am using a linked list of accounts tho
Probably by using the `#[account(close = who_to_send_the_lamports_to)]` attribute
like clear its data and take whatever lamports it has
How do I "close"  a PDA account
thanks!
its a great tutorial, I will definitely recommend beginners
https://lorisleiva.com/create-a-solana-dapp-from-scratch/structuring-our-tweet-account
where is that chart from?
nice a new error 
```
Transaction error: TypeError: Cannot read properties of undefined (reading 'fetch')
```
got it
So if you want a max of 100 byte strings, you need 100 + 4
Yeah, it's *plus* 4 bytes for the length
okay yes I said it wrong
i remember seeing some chart ü§¶‚Äç‚ôÇÔ∏è
Usually a single character (usually, not always!) is 1 byte
Which is 8 bits
You measure space in bytes also
Why 4 bits per char?
Nope üòõ
also I was stuck on this and my actualy function for a week now and here I got a soln in a minute :)
i hope I made sense lel
50 chars == 50 * 4
1 char takes 4 bit
Sure
Why are you doing 50*4 ? What does multiplying by 4 mean?
okay trying once
buiild then deploy?
```
// Adding some useful constants for sizing properties.
const DISCRIMINATOR_LENGTH: usize = 8;
const PUBLIC_KEY_LENGTH: usize = 32;
const STRING_LENGTH_PREFIX: usize = 4;
// Stores the size of the string.
// 50 chars max
const NAME_LENGTH: usize = 50 * 4;
// 50 chars max
const USERNAME_LENGTH: usize = 50 * 4;
// 200 chars max
const BIO_LENGTH: usize = 200 * 4;
// 10 chars max
const RANKING_LENGTH: usize = 10 * 4;
// max around ~2500
const PROBLEM_SOLVED_LENGTH: usize = 4;
const ACCEPTANCE_RATE_LENGTH: usize = 4;
// max 5
const STARS_LENGTH: usize = 1;
const TIMESTAMP_LENGTH: usize = 8;

impl LeetCodeAccount {
    const LEN: usize = DISCRIMINATOR_LENGTH
        + PUBLIC_KEY_LENGTH
        + TIMESTAMP_LENGTH
        + STRING_LENGTH_PREFIX
        + USERNAME_LENGTH
        + STRING_LENGTH_PREFIX
        + NAME_LENGTH
        + STRING_LENGTH_PREFIX
        + BIO_LENGTH
        + STRING_LENGTH_PREFIX
        + RANKING_LENGTH
        + PROBLEM_SOLVED_LENGTH
        + ACCEPTANCE_RATE_LENGTH
        + STARS_LENGTH;
}
```
Just say 8 + 1000 for now
I was actually trying to do my other function with proper stuff but it kept failing so i did small
Heh, yeah, 8 + 8 isn't enough space üòõ
```
// Defined the structure of the LeetCode Account.
#[account]
pub struct LeetCodeAccount {
    pub owner: Pubkey,
    pub timestamp: i64,
    pub username: String,
    pub name: String,
    pub bio: String,
    pub ranking: String,
    pub problem_solved: i32,
    pub acceptance_rate: f32,
    // max 100.00
    pub stars: i8,
}
```
Can you post the actual LeetCodeAccount struct?
I can see a problem
Very unlikely that 8 + 8 is enough space for that account
```
    pub fn initialize(ctx: Context<Initialize>, bio: String) -> Result<()> {
        let profile: &mut Account<LeetCodeAccount> = &mut ctx.accounts.profile;
        profile.bio = bio;

        Ok(())
    }
#[derive(Accounts)]
pub struct Initialize<'info>{
    #[account(init, payer = author, space = 8+8)]
    pub profile: Account<'info, LeetCodeAccount>,
    #[account(mut)] // we are going to mutate the amount of money in their account.
    pub author: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```
Not an issue with your idl, it's with your rust code
okay wait
```
    {
      "name": "initialize",
      "accounts": [
        {
          "name": "profile",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "author",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "bio",
          "type": "string"
        }
      ]
    }
```
my IDL
Post some of your rust code for whatever account you're creating
i did not understand
Are you deriving Default or something?
oh
That error usually means you haven't allocated enough space
```
        try{
            await program.rpc.initialize("lol",{
                accounts: {
                    profile: baseAccount.publicKey,
                    author: provider.wallet.publicKey,
                    systemProgram: web3.SystemProgram.programId
                },
                signers: [baseAccount]
            });

            const account = await program.account.profile.fetch(baseAccount.publicKey);
            console.log("account:" , account);
        } catch (err){
            console.log("Transaction error:" , err);
        }
```
I keep getting this error, I am really not sure whats wrong.
I have checked my IDL million times, function too but :/
Please don't at-message unless it's urgent üôè
HI <@!501570363566587905> , how to to receive the payment inside a anchor program.

Use case : I want to build a merch store, which takes the payment in solana from user wallet while ordering
The only way to write data into an account owned by program X is to specifically ask program X to do it, so if you only provide one way to do it then that's the only way to do it
Nope, they'd have to go through that function
You don't need to activate anything for anchor-lang 0.18.2, just use `init_if_needed`
ty, but i cant enable that feature
I think it is already in prelude for the associated_token. init_if_needed you have to enable this feature in Cargo.toml first.
If I have a program that does the following:

```
pub fn randomize_exchange(ctx: Context<RandomizeExchange>) -> ProgramResult {
...
}

#[derive(Accounts)]
pub struct RandomizeExchange<'info> {
    #[account(
        init,
        payer = payer,
        seeds = [payer.key().as_ref(), burn_mint.key().as_ref()],
        bump,
        space = 100 // 32 * 2 to store accounts
    )]
    pub exchange_info: Account<'info, ExchangeInfo>, // data acct where we store the mint to be transferred
    pub system_program: Program<'info, System>, // Solana sys prog
    #[account(mut)]
    pub payer: Signer<'info>, // can only call from the payer who will be receiving the token related to the mint
}

#[account]
pub struct ExchangeInfo {
    pub mint_address: Pubkey,
}
```
Is there anyway for someone to construct an `ExchangeInfo` account without calling `randomize_exchange`? I don't have any other program instructions that initializes `ExchangeInfo` accounts
hey, where can I import initi_if_needed + associated_token from ?
thank you in advance
can you share an example code with me
yes, you can.
if your pda is funded you use invoked_signed to sign from the program


//////////////////////////////////////////////////////////////////////////////////////////

Hey guys any idea what this pools address is in the mango markets ido-frontend constants?
Dam thought that might of been it, but same error. Will continue the glass chewing
I just remembered this one. Great list https://github.com/avareum/awesome-solana <@709556204514574386>
no actually I think this is probably it. make sure anchor -V returns the same version as your crate is using
Yeah that was my original thought, so that shouldn't be triggering this init needs space error
or wait sorry, I got confused
most of the time this means your anchor cli is not updated
No, account(zero) expects it to be previously init'd
I could just initialize it within the program and see if I still get the error
Right got you. But I am calculating required space manually anyway and passing it in. So thought it should work. 

Unless it is because the zero account that I am initializing now doesn't know how much space it needs because the Default space isn't working any more?
Anchor got rid of the Default space thing (it's just super error prone and confuses beginners‚Äîif you really want to keep using it though it's pretty simple to do something analogous yourself)
Yeah all the inits that aren't TokenAccounts have space allocated. The only other thing I have is I pass a #[account(zero)] in and initialize with a separate instruction. 

But all of this was working fine on v0.22.1. Is there something about different about the latest version that is stricter on syntax? I thought previously providing space for a custom struct wasn't even specifically necessary if you included #[derive(Default)]
escrow, adding the other to my list üëç
great, thanks!
Yeah, don't need to add space to TokenAccount inits. Are you 100% positive that you aren't missing some other init though?
No, an UncheckedAccount is basically already just an AccountInfo (it's just a wrapper type, to give it a new name)
I have a program that is building fine on anchor v 0.22.1, but when I upgrade to 0.23.0 and try build it gives this error: 

```thread 'main' panicked at 'Code not parseable: Error("space must be provided with init")', lang/syn/src/idl/file.rs:352:58```

But all my inits have space provided, besides the TokenAccounts that I initialize, which if I try add a space, I get another error:

```thread 'main' panicked at 'Code not parseable: Error("space is not required for initializing an spl account")', lang/syn/src/idl/file.rs:352:58```

Anyone have a similar issue on v0.23.0?
is it expensive compute unit wise to convert an `unchecked account` to an `account info`?
oh hell yes. Thank you <@!347689664855015424>
https://lorisleiva.com/create-a-solana-dapp-from-scratch
What is lorisleiva? Paulx I am aware of but I'd like to learn more as well.
Have you gone through Paulx escrow and lorisleiva?
If they aren't PDAs those addresses would need to have signed from the client
Within your program you can only add signatures for PDAs derived from your program (that's what `invoke_signed` is for)
How to add more signatures to a CPI? I am having a creators arrays. Want to add multiple creators verified to the create_metadata_accounts_v2 instructions.
aight will do, thx!
Think you can search the anchor repo for examples (I can't remember the syntax)
assuming I have an object which has the owner's public key stored as part of the object (first 32 bytes)
No easy way to filter on the seeds for the address, no
also I guess my next question would be, how do I use the `MemcmpFilter` https://project-serum.github.io/anchor/ts/modules/web3.html#MemcmpFilter if I want to filter out the results
or is this some NP hard stuff where we cannot filter by the owner from the PDA
is there an easy way to add a filter that the owner pubkey must be part of the seed?
All accounts that the program owns (of that account type)
does the program ... fetchAll fetch all the accounts for a given usr, or literally all the accounts that this program owns?
best resources to continue learning? books / blogs / links? I've gone through the solana and anchor docs but want to continue reading more. So much I still don't understand and made everything "click"
Why is used as_ref() on the seeds on the PDA constraint? I understand is a method to convert something as a reference, but I don‚Äôt fully understand that
No I said I want to port solidity code to solana program in structural way
There's a documentation page somewhere but I can't always remember how to get to it from the main rust page and I can't seem to get it to pop up from a Google search
I still have trouble finding the official list of anchor errors
what tools you're using for to deploy Solidity code on solana Blockchain network?  <@!516253767314702346>
What things I need to keep in mind if I want to port a simple solidity smart contract to solana program like in solidity numbers are int256 here i64/u64. How the structure changes for libraries and unchecked block of code. If anyone can explain me in detail.
I meant having programs/contract1 and programs/contract2 in the same repo, I resolved it no worries. It was easy, just need to change Cargo.toml properly and then it creates contract1.so and contract2.so in target/deploy on anchor build
<@!784287013863948288> you can read about lifetimes here
https://doc.rust-lang.org/rust-by-example/scope/lifetime.html
Good day! When using `#[interface]` procmacro, whenever you want to implement it, all examples defined state on which an interface is going to be implemented like this
```
    #[state]
    pub struct Protocol;

    impl<'info> Interface<'info, ContextProtocol<'info>> for Protocol {
```
However, `#[state]` procmacro is marked deprecated. With what can I replace it then?
why we use `<'info>` on some structs and some struct are without `<'info>`
What is meaning of #[derive(Accounts)]
`Example: 
#[derive(Accounts)]
pub struct Increment<'info> {
    #[account(mut, has_one = authority)]
    pub counter: Account<'info, Counter>,
    pub authority: Signer<'info>,
}

#[account]
pub struct Counter {
    pub authority: Pubkey,
    pub count: u64,
}`
Does using a PDA make it that anyone can invoke it? If I want to be the only one able to invoke the program should I not use a PDA?
I can't run `anchor deploy`, my program is too big. Any recommendations?
i can't run `anchor deploy`, the txn keeps failing :/
here is the screenshot of the test validator running
and i need to run `solana-test-validator` in the `~` directory right ?
even i have the same error, but the test validator does run for me. but i still do get the error
https://book.anchor-lang.com/chapter_5/anchor-toml_reference.html#testvalidatorclone
[[test.validator.clone]] in Anchor.toml
mainly the `-c` option.
is there an anchor way to do this in the config? ```solana-test-validator -q -r -c ALP8SdU9oARYVLgLR7LrqMNCYBnhtnQz1cj6bwgwQmgj H6ARHf6YXhGYeQfUzQNGk6rDNnLBQKrenN712K4AQJEG --url https://api.mainnet-beta.solana.com```
cool cool - thanks for clearing it up!
Yes thats correct
yeah I get that, but in practice my assumption would be that the end-user wouldn't be expected to manage the account they pass into the program. as opposed to using a PDA where the user's pubkey can be one of the seeds so you can always retrieve data associated with them
regular accounts are persistent too, any account where the rent for it is payed will stay on chain
ok makes sense. so my understanding is that reg accounts are effectively temp buffers and PDAs are persistent
Hi sorry if its a silly question but what is the elliptic curve solana uses to derive its private keys? and how exactly is the pubkey/privkey calculated from the elliptic curve. i suppose which curve in particular and what does the pubkey represent in relation to the privkey.

Also, what do the seed phrases have to do with pub & privkey? I was under the assumption privkeys are some base number and pubkeys is like discrete log of that base.
PDA's are stored on chain as long as the rent for them is payed, which you can usually handle in creation
i think...
yeah I think PDAs are what I want then because if local storage is reset then the user loses their data
You can store these keypairs locally to access the program if thats what you mean, otherwise PDA's can be handled by lookup based off of what you are storing.
hi im a bit new to solana so have a noob question: since u have to pass in accounts to programs to handle data, accounts are basically key pairs? so if a user is passing in an account to hold their data, do they have to keep track of that key pair or else lose their data? or does the account the user pass in automatically becomes associated with the user and they can access it other ways?

like for the counter example on github, the vote account is created with the web3 client and passed into the vote program. but after that client is finished, you would no longer have access to that account, right? so do u actually just want to use PDAs when storing data a user expects to access in the future?
Does solana not take Hashmap types? Can't seem to get it to recognize it in the idl
I was looking for it too <@!326107472098099201> Thanks üôÇ
<@!689110395406909462> found it here
https://docs.rs/solana-sdk/latest/solana_sdk/macro.pubkey.html
ah, makes sense
??
i'd guess its a solana sdk macro not an anchor one

wait I can't find the macro
oh i didn't know there was a macro. very helpful
`Pubkey::from_str("asdasdfasdf").unwrap()` + `use std::str::FromStr;`, or if the string is static you can use the `pubkey!("asdfasdf")` macro
ok, I found it
Hi, is there a way determine an account size in  bytes?
I'd like to use `dataSize` option on my filter by I have hard time to calculate the account size in bytes.
And another question, when do I have to worry about rent? Every time I create a new account?
I assume I can't just do `Pubkey::new(&pubkey_string.to_bytes())`, or can I?
how can i create a pubkey const from a string containing the pubkey? I only see methods for bytes --> `Pubkey` struct
Hi ! I found a tutorial and I have a question. 

Why here we use the dereference * ? ctx is a reference ? Same for the author, why use * for the key ?
Hi, is there a nice way to manage a fixed size string in an account state?


//////////////////////////////////////////////////////////////////////////////////////////

only anchor test seems to start up the correct validator w/o doing some work inside anchor repo
i tried this and only get invalid block hash
Can I run anchor test on one specific program in the dir. Like I can for anchor build e.g.

```anchor build --program-name <program_name>```
Hey friends, what is the best way of changing account structure (or just extending) with  backward compatibility? Is there a best practice for it discussed somewhere? I just want to add 1 more field and change the logic in an instruction.
that sounds cool, i've definitely seen some people asking for it
ah yes, i see the Test.toml files
you have a dir with .ts files for each suite and a custom validator config for each suite
what i meant is, does it treat every .ts file in a folder as a separate test suite / runs a new validator for it
every *.ts file?
up to you!
what distinguishes one test suite from another?
startup one before each suite and then use a new one for the next
new validator for each test suite
separate validators?
what does that mean actually?
interesting but no, we're not trying to use separate validators for each test. Just to run different sets of failing tests
https://github.com/project-serum/anchor/pull/1681
just fyi. before you start building a lot of testing infra yourself, if your goal is to have separate validators, 0.24.0 will come with support for that
awesome, thanks!
anchor run <name>
nothing except `anchor test` works
```
[scripts]
test-long = "yarn run ts-mocha -t 1000000 tests-long/*.ts"
test = "yarn run ts-mocha -t 1000000 test-redeem/*.ts"
testNo = "yarn run ts-mocha -t 1000000 test-buy-no/*.ts"
```
i've tried adding other test scripts but it doesn't recognise them
how to run different test scripts in Anchor.toml?
Ok right so as the slothashes sysvar is too big to deserialize, you would not actually be able to use it in this fashion. I am just passing it through as an unchecked account, and checking its id is as expected within the program. Then borrowing the data as before and all is working as expected
Actually get this error if I try to use the slothashes sysvar in testing:

```Error processing Instruction 0: Unsupported sysvar```

Which has had a few explanations here, looks like the SlotHashes is too big too deserialize, so have to do it within the function I believe
Unless the types are misleading here, you don't need to do any deserialization (thought tbh that sounds weird to me and makes me wonder if this is actually how you're supposed to use this thing)
Yeah wait I realised its a bit different after getting the vector
You already have an actual read-to-go Vec here, no borsh stuff
What is `data` here?
So as I am not accessing a vector now, just a SlotHash type, this would change to :
```let most_recent = array_ref![data, 8, 8];```

Correct? As I drop the 4 bytes for the vector
Thanks! Will try that
So you could just do `recent_slothashes[0]` (it acts like a vec)
I haven't tried using SlotHashes before, but if you jump to source on it you'll see that it's actually just a wrapper around a Vec<SlotHash>
For now I have just updated the call to this:

```
    #[account(constraint = recent_slothashes.key() ==     sysvar::slot_hashes::ID @ MyError::IncorrectSlotHashesPubkey)]

    pub recent_slothashes: UncheckedAccount<'info>
```

Will see if it works
Trying to update my code from getting recent blockhashes to using the slothashes sysvar. When I try running this code:
```
        let data = recent_slothashes.data.borrow();
        let most_recent = array_ref![data, 12, 8];
```

I get this error:

```
no field `data` on type `&anchor_lang::prelude::Sysvar<'_, anchor_lang::prelude::SlotHashes>`
```

I am passing that recent_slothashes account in the program like this:

```pub recent_slothashes: Sysvar<'info, SlotHashes>```

Anyone know I can get the data out of the SlotHashes sysvar? Or can I just keep using the recent blockhashes sysvar?
Creating an account ultimately needs to talk to the system program, so you need to pass in the system program as an account
I think an easier way to think about it is that 1) at the end of the day, *every single account* that the transaction needs, needs to be passed in from the client, and 2) CPI'ing to a program requires access to that program's account, so you  have to pass it in from the client too!
So, to clarify, to initialise an Account from a CPI, it is necessary that the instruction (program layer 0) that initialises the Account of another program receives as argument the SystemProgram Account from the client (ts test), the Account belongs to the program (layer 1)
okey ty üôÇ
```
pub system_program: Program<'info, System>,
```
Not possible to convert a Pubkey to an AccountInfo dynamically like that (solana just doesn't work that way)
Yeah, you need to pass it in as an account from the client
You can provide the system program in instructions
How can I include the system_program on the context via CPI?
Would have been crystal clear if they had just said "compute units" instead of instructions üòõ
Yeah‚Äîkind of a funny log, in keeping with solana's tendency to use names that just aren't quite right lol
so yes
globally as well as in my dependencies
Yes
Are you sure you have installed the deps, including `typescript`?
‚òùÔ∏è
trying to test this, able to deploy succesfully
https://github.com/blockworks-foundation/voter-stake-registry
anchor test
What command are you running?
What am I doing wrong?
Hey, facing this error:
[ERROR] Cannot find module 'typescript'
Require stack:
- /Users/abhinavsharma/.npm/_npx/3c06c7c2e1894b1b/node_modules/ts-node/dist/index.js
- /Users/abhinavsharma/.npm/_npx/3c06c7c2e1894b1b/node_modules/ts-mocha/src/index.js
oh, is that just running out of CU?
What does this mean  
> 
> `Program returned error: exceeded maximum number of instructions allowed (91498) at instruction #140274"`
I think I get it, thank you
You're saying, "give me the bump for the `user_stats` account"
That `"user_stats"` string is actually referring to the name of the account in the derive(Accounts) struct (so, here it's `user_stats`)
Doesn't the handler function also need `user.key()`?
But then in the handler function it says
```user_stats.bump = *ctx.bumps.get("user_stats").unwrap()
```
Hi, a question about PDA section (PDA hashmaps subsection) in the book:

Seeds for the user_stats account are defined like:
```seeds = [b"user-stats", user.key().as_ref()], 
bump```
my code
```
            await program.rpc.initialize("lol", {
                accounts: {
                    profile: baseAccount.publicKey,
                    author: provider.wallet.publicKey,
                    systemProgram: web3.SystemProgram.programId
                },
                signers: [baseAccount]
            });

            const account = await program.account.leetCodeAccount.fetch(baseAccount.publicKey);
            console.log("account:", account, baseAccount, baseAccount.publicKey.toBase58());
```
how to get transaction id of a transaction that just happend?
privileges = whether theyre a signer or not, caller = master program, callee = puppet progran
Im trying to get involved. Any projects looking for interns? Shoot I would love to just be a fly on a wall for a good team  to see how things are made and how teams work. Bonus if you challenge me with a project.
On the CPI section of the Anchor book it says

```
CPIs extend the privileges of the caller to the callee.
```

Could someone clarify what it means when it says "privileges" and what the "caller" and "caller" are referring to?

I'm unsure if its referring to the Puppet Master Program, Puppet Program, Puppet Account, or User.
Hi Friends. I am trying to use PDA seeds to create an account. Somehow I have tried everything still I am getting error msg: 'The program could not deserialize the given instruction'. Not sure what wrong I am doing. Please advise. Following is my code. 
```#[program]
pub mod referal {
    use super::*;

    pub fn initialize(
        ctx: Context<Initialize>,
        bump: u8,
        refree: Pubkey,
        seed: String,
    ) -> ProgramResult {
        msg!("Seed: {}", seed);
        let base_account: &mut Account<BaseAccount> = &mut ctx.accounts.base_account;
        base_account.bump = bump;
        base_account.refree = refree;
        return Ok(());
    }
}

fn seed_bytes(seed: &str) -> &[u8] {
    msg!("Seed: {}", seed);
    seed.as_bytes()
}

#[derive(Accounts)]
#[instruction(bump:u8, seed: String)]
pub struct Initialize<'info> {
    #[account(
        seeds = [seed_bytes(&seed).as_ref()], 
        bump, init, payer = creator, space = 41)]
    pub base_account: Account<'info, BaseAccount>,
    #[account(mut)]
    pub creator: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[account]
#[derive(Default)]
pub struct BaseAccount {
    pub refree: Pubkey,
    pub bump: u8,
}```
Its a bug with the renaming the program. I fixed it by restarting the entire project.
Any idea <@!134416332509675520> ?
ty

Ctrl-C
how do I stop the validator....just ran it
just anchor test
How are you running the solana validator? Did you do `solana-test-validator` etc., or just `anchor test`?
transaction issue...
now a new error. holy crud
LOL
damn you camels
More üê´ errors, it's `systemProgram: SystemProgram.programId`

lol
its a different error now
wait
i did that too....didnt change. let me try again
Do `anchor.workspace.Calculatordapp`
That still has lowercase üòõ

The issue is that your `program` variable is undefined
Don't think so no, can you post the js code again?
noticed the name
could it be the keypair?

What's the full error?
test fails still. here is the toml
let me see
ohhhh that could be it
Changing that #[program] names will also require making the same change to your Anchor.toml
let me see if that works
Ok, then you'll have to do `anchor.workspace.Calculatordapp` (anchor isn't doing anything fancy, just camelcasing)
i renamed some stuff

hmmm let me see
So no
Your screenshot above says `calculator_dapp`
is it auto seperating it somehow?
calculatordapp is just the name of the program. I just made it a single word....
Yeah, JS code tends to expect CamelCase, so anchor uses it (even if it's kind of annoying/dumb)
is the spelling the issue?
appreciate you
let me see
Probably `const program = anchor.workspace.CalculatorDapp`
Anyone know how to fix this error?
I am just getting my hands dirty with Solana programming. Bear with me. üòÑ
Latest versions of anchor have switched to saying `Result<()>` instead of ProgramResult, but even the latest anchor version can't implement that `Create` thing for you üòõ
Ah, yeah, if you no longer have a keypair, then you can just rerun anchor build and you'll get a fresh one, and subsequent deploys will use it
Any help would be greatly appreciated.
Im so confused lol
does anyone know why I am getting these errors?
hey everyone so i‚Äôve been trying to work with PDAs & get a complete understanding of implementing them and i‚Äôm currently stuck on trying to execute this functionality where we can use a value from another account for the seed of the PDA. 

this picture is from Anchor‚Äôs twitter and I‚Äôve tried implementing the same thing, however I‚Äôm currently getting an error <address> ‚Äúsigner privelege escalated‚Äù. I previously i‚Äôve learned this error occurs when the findProgramAddress() pda in ts does not match the one defiend in Rust.

does anyone know how to properly use the findProgramAddress() function with types such as u8, u32, or u64? much thanks appreciated
For example I have an account which are PDA's of the program and want to find the current players account
Does anyone know how to find a specific PDA in the rust code
Would deleting the old keypair file and running `anchor build` fix it, generating a new keypair file?
(Which gave me an error when I tried to use that, making it clear that I should have a new keypair for the new program ID).
To what? The only file I have that has the same format is `id.json`.
Change the keypair in target/deploy
I successfully deployed a program but, thinking that something was wrong with my keypair when the devnet faucet was down, ran `solana-keygen new`.  Now I'd like to deploy a fresh copy of that program, under a new program ID. I tried changing the string in the ` declare_id` macro slightly, but it still thinks I'm trying to update the old program. What else do I need to do here?


//////////////////////////////////////////////////////////////////////////////////////////

`.toTwos` is saying that it's trying to use BN's method to convert to "two's complement" (how negative numbers are represented in bits/bytes)
Yep, that's right üëç
^ nvm, `new anchor.BN(0)` seems to work, lmk if that doesnt sound right
any tips on how to convert a js `Number` to rust `i64` from mocha tests? when i pass in `0` to a parameter that expects type `i64` i get this error: 

```
TypeError: src.toTwos is not a function
      at BNLayout.encode (node_modules/@project-serum/borsh/src/index.ts:58:17)
      at Structure.encode (node_modules/buffer-layout/lib/Layout.js:1263:26)
[..]
```
Box
```throw new Error('bad secret key size');
    ^

Error: bad secret key size
    at Function.nacl.sign.keyPair.fromSecretKey (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/Honey-IDO/honey-ido-pool/node_modules/tweetnacl/nacl-fast.js:2320:11)
    at Function.fromSecretKey (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/Honey-IDO/honey-ido-pool/node_modules/@project-serum/anchor/node_modules/@solana/web3.js/lib/index.cjs.js:5556:50)
    at getKeypair (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/Honey-IDO/honey-ido-pool/cli/index.js:31:47)
    at setProvider (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/Honey-IDO/honey-ido-pool/cli/index.js:46:27)
    at Object.<anonymous> (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/Honey-IDO/honey-ido-pool/cli/index.js:55:1)
    at Module._compile (node:internal/modules/cjs/loader:1101:14)
    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)
    at Module.load (node:internal/modules/cjs/loader:981:32)
    at Function.Module._load (node:internal/modules/cjs/loader:822:12)
    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)```
thanks for the help. knowing there's no codegen was helpful
```const fs = require("fs");
const anchor = require("@project-serum/anchor");

const account = anchor.web3.Keypair.generate();

fs.writeFileSync("./keypair.json", JSON.stringify(account));```
The file path is correct idk why it's throwing this error
Hey guys (<@!134416332509675520> ) I  created a keypair using anchor.web3.keypair.generate() but my program said Error: bad secret key size what could this mean potentially?
I tried to run the test and it actually worked but just gave an error in vs-code. I think it was a vs-code issue, i restarted it and it went away.
I'm confused why that would say 'NewMethod' and not `newMethod` or something like that
Can you literally show me a screenshot?
Property 'NewMethod' does not exist on type 'RpcNamespace<MyProject, {
Could you show me a screenshot or whatever of the actual error?
I'm using program.rpc.methodName where const program = anchor.workspace.MyProgram as Program<MyProgram>
If the IDL is really updated than the ts stuff should update automatically (it works by reading the IDL file‚Äîthere's no actual codegen at all)
Are you definitely using the updated IDL in your tests?
I see my updates in the IDL, but when trying to write the tests in ts* it doesn't recognize the new method i just added
Hey, I wanna get into solana smart contracts. Should I learn Rust or Anchor ?
What specifically isn't working?
All anchor generates is the IDL itself, it doesn't actually generate any typescript code
<@!134416332509675520> is there a command (or workaround) to regenerate the typescript that is derived from the IDL? I know it usually happens automatically when i run anchor build/deploy/test but sometimes it doesn't seem to work.
i think the problem with storing data in arweave is (afaik) you can't access that in your program
got it, so in general it's much cheaper to store data in arweave and on chain just store a reference to that right?
is there a command to regenerate the typescript that is derived from the IDL? I know it usually happens automatically but sometimes it doesn't seem to work.
You have a hard constraint that accounts can store 10mb at absolute max (accounts that live at program-derived addresses can only store 10kb). Besides that the constraint is just that storage on-chain costs on the order of $1/kb (bit less at the moment, but close enough), which adds up very quickly.
never mind, this helped me to understand that "basic-2" is actually what I was looking for: https://youtu.be/FmdPAwsqJC4?t=2435
Hi, I have a hard time understanding how to secure the modification of Accounts. As far as I can tell from the two example projects "basic-1" and "basic-2" both are insecure because all I need to know is the pub key in order to modify an account. I would expect that there is a check for the signer of a transaction and then only modify an account if the signer is the owner (of course the program is the real technical owner) of the account. Am I missing something?
state is just an account under the hood. but #[state] is very deprecated and we should just remove/replace that example
is there a general rule for how much data you should store in an account vs when to move it to something like arweave?
I have a question about example "basic-4" from the anchor repo

Can someone explain why the  #[state] can be under #[program] and can have a "count" that can be incremented?  I thought "state" had to be on a separate account and that programs don't hold state. 

```
#[program]
pub mod basic_4 {
    use super::*;

    #[state]
    pub struct Counter {
        pub authority: Pubkey,
        pub count: u64,
    }

    impl Counter {
        pub fn new(ctx: Context<Auth>) -> anchor_lang::Result<Self> {
            Ok(Self {
                authority: *ctx.accounts.authority.key,
                count: 0,
            })
        }

        pub fn increment(&mut self, ctx: Context<Auth>) -> anchor_lang::Result<()> {
            if &self.authority != ctx.accounts.authority.key {
                return Err(error!(ErrorCode::Unauthorized));
            }
            self.count += 1;
            Ok(())
        }
    }
}
```

https://github.com/project-serum/anchor/blob/master/examples/tutorial/basic-4/programs/basic-4/src/lib.rs
Not sure how complex I can get or if I would want everything running directly on the blockchain. For example, do I need to store tickets metadata on chain, or can i integrate aerweave to hold this data and limit rent burdens
also should i be passing String arguments here. For example if I want a user to see a welcome message then be asked a question?
is it ok to structure anchor code this way if you pass more than one argument?
Sure (I think I'm just not quite sure what you mean‚Äîhappy to look at an example though)
Can send an example your way if you‚Äôd like
I wrote my own trait for it. Just constructs an instance of the underlying struct given an account.
Can you say more? Not quite sure what you want to do
Is there a way to manually construct an Account from an instance of a struct with the account macro?
Hey guys, been going through all the chat history - any resources for learning how to send SPL tokens to an account ?
hey everyone üëã , brand new to anchor and currently learning about account constraints. 
i understand that `has_one` will ensure that the `target_account` fields match (one pub key), but i was wondering if there was a similar constraint that could apply to multiple keys? for example, suppose i wanted to create an account with a vector of public keys that could modify the account (i.e., any of the listed public keys could make certain txs). would it be better/possible to handle in the business logic?
Since if you already deployed the program the BPF Upgradable will use the new idl
Rerunning anchor build and anchor upgrade
Yea you can try deleting the target folder
Still doesn't work. Do I have to remove the .so file from `target/deploy` so `anchor build` generates a new one?
`anchor upgrade`
Brain is moving slow today, figured this should be a quick one. 
If an SPL token has anything other than 9 decimals, (1-8) whats the quickest way to calculate the actual amount you should be passing to the spl:transfer CPI? Either the amount gets passed in as u64 or calculate it in the contract if you are given the decimal values, but wondering what the actucal calculation would look like for like 5 decimals
(amount).mul(1_00_000) for example?
I removed an argument from one of my instructions and ran `anchor build` and `anchor deploy`, but for some reason that argument is still expected. Am I missing a step somewhere?
correct. `run` will only run your script. does almost nothing else. it only injects some env variables into the script


//////////////////////////////////////////////////////////////////////////////////////////

The you'll have to just yank the lamports manually, with `try_borrow_mut_lamports` (try searching discord, many examples)
its the executing program, not the system
But yeah, it's just a regular lamport transfer
Possibly, it depends on which program owns the account
is there a way for me to transfer the rent-exemption lamports out of an account then?
ok thank you
I guess so (not totally sure what you're situation is, but yeah, in solana there's no way to get around having to pass in the accounts you care about)
so i have to make a transaction then fetch the data then make another transaction all from the client?
Nope
i have an account that stores the pubkey of another account, is there a way to pass only the first account and modify many accounts in the same instruction?
What do you mean? You can do lots of CPIs if you want
Nope, have to pass in any accounts you care about from the client
or is there a way to get an Account struct from a pubkey within a rust instruction
is there a way to call many instructions within another instruction
If anyone finds this thread later, someone in the Solana discord responded that this could be a good use of PDAs, with the PDA storing necessary state info
unless you mean the tictactoe/puppet ones, no
Have you read through the anchor /examples and /tests?
any more intermediate resources
what should i do after i read the book
https://project-serum.github.io/anchor/tutorials/tutorial-2.html#defining-a-program
Any examples you can point me to? I think I have seen an owner constraint before...gotta find that
Write a constraint, or something that makes that owner sign the tx, etc.
Then you'd have to enforce that in your program
yoda
I want to see that way...master yod
So this is your program's fault lol, not the PDA's fault
If you don't want it to accept stuff from any wallet, you would need to write your program in such a way to enforce that üòõ
I made Spl governance the owner, and wanted only that to be able to edit the account
How are you expecting it to work?
Yep!
It just accepts my instructions from any wallet
You're init'ing an account there, yeah
```declare_id!("F8nQoxzzpdxyZy9EcK8yoPiEZHjYdixWhPUe4xaVwoHd");

#[program]
pub mod articlepublishing {
    use super::*;
    pub fn initialize(ctx: Context<Initialize>, publisher_account_bump: u8) -> ProgramResult {
        ctx.accounts.publisher_account.bump = publisher_account_bump;
        ctx.accounts.publisher_account.author = *ctx.accounts.author.key;
        msg!("Found bump {} & key {}",publisher_account_bump,*ctx.accounts.author.key);
        Ok(())
    }

    pub fn publish_article(ctx: Context<PublishArticle>, article_uri: String, draft_account: Pubkey) -> ProgramResult {
        let article_acc = &mut ctx.accounts.publisher_account;
        article_acc.articleuri = article_uri;
        article_acc.draftaccount = draft_account;
        article_acc.articlestate = 1;
        msg!("Found key {}",*ctx.accounts.author.key);
        Ok(())
    }
}

#[derive(Accounts)]
#[instruction(publisher_account_bump: u8)]
pub struct Initialize<'info> {   
#[account(init, seeds = [author.key().as_ref()], bump, payer = author, space = 8+8+566)]
publisher_account: Account<'info, ArticleState>,
#[account(mut)]
author: Signer<'info>,
system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct PublishArticle<'info> {
    #[account(mut, has_one=author)]
    publisher_account: Account<'info, ArticleState>,
    author: Signer<'info>,
    system_program: Program<'info, System>,
}

#[account]
#[derive(Default)]
pub struct ArticleState {
    articleuri: String,
    draftaccount: Pubkey,
    author: Pubkey,
    articlestate: u8,
    bump: u8,
}```
What do you mean? How so?
```#[derive(Accounts)]
#[instruction(publisher_account_bump: u8)]
pub struct Initialize<'info> {   
#[account(init, seeds = [author.key().as_ref()], bump, payer = author, space = 8+8+566)]
publisher_account: Account<'info, ArticleState>,
#[account(mut)]
author: Signer<'info>,
system_program: Program<'info, System>,
}```
My PDA is being modified, by any wallet here.
My bad I talk loose, that is what I meant
And also, invoke_signed doesn't "access control account manipulation", it calls some other program + signs for whatever PDAs you want to sign for
The security property for PDAs is that only the deriving program can sign for their address
No, `invoke` can't sign for a PDA (that's what `invoke_signed` is for)
So, invoke_signed in my program access controls account manipulation. If I use only invoke, my PDA can be manipulated by any wallet or signer
This means that when you use `invoke_signed`, you can only sign for the *current* program's derived addresses, not any other program's PDAs.
Yeah, anyone can generate a PDA, but note how the APIs for `findProgramAddress` and `invoke_signed` are different: `findProgramAddress` uses the seeds *and the deriving program id*, whereas `invoke_signed` only uses the seeds.
I believe (although correct me if wrong) that only a program can sign for its own PDAs when doing CPI... deriving a PDA just gives you an address but it doesn't allow signing
I don‚Äôt understand üò≠üò≠üò≠
If anyone can generate a PDA how is signing via a PDA kept secure or access controlled
what is `CpiContext` in anchor? <@!134416332509675520>
Yep, it's a lifetime‚Äîyou're going to just have to read the rust book: https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html
is `<'info>` is used for lifetime ? 
is yes then how it effects the life time of variables?
<@!134416332509675520>
Yea, I mean closing and recreating same account usign anchor client. So basically I need to find my way.  Thanks for your help.
Currently you unfortunately can't add additional space to an account (though this will hopefully change soon). You'd have to copy those accounts over to fresh addresses I guess.
should this not result in completely different hashes?
hello, how come they used different strings here (- and _)
I see, thanks, so what is the migrstion scenario here if there is no enought space? Should I just make 1 more method to loop through pdas and reallocate space using anchor client?
You basically just need to make sure the change is backwards-compatible. So, if you want to add a field, add it at the end of the struct so that borsh will continue to work with it (you'll have to have made sure you pre-allocated enough space though).
hi guys, how often does a transaction that has reached confirmation level "confirmed" fail? Does it happen often when the network or one program receives a lot of traffic?
`<'info>` is used for lifetime ? 
is yes then how it effects the life time of variables?
what should be my next steps after reading the anchor book?
ie not sol. random mints for use in our devNet/testnet deployments
Hey anyone built out a faucet setup for solana test tokens at all?
But can not modify the added data because the account data size was fixed already. I need to create a new Program Data Account. üò¶
I Solved this issue. 
The data was not removed. It was could not read because of the Struct's structure. 
So I added the new variable end of the Struct, not middle of the Structure, It works well.
I've found a link about this issue. I'm gonna test it. üò¶
https://blocksecteam.medium.com/secure-the-solana-ecosystem-3-program-upgrade-5590c746016
The program upgrading was successful but its account data seems removed all.
I tried just `anchor deploy` again from scratch by resetting the `test-ledger` directory. 
It just works well oddly this time without `anchor idl upgrade`.
Even I didn't overwrite newer IDL files into the Dapp.
Thanks, everyone üôÇ
I recommend using `msg!("account created")` in the instruction code.
And watching it from backend program using Websocket endpoint.
As your advice, I tried both `anchor ild upgrade -f <IDL_PATH> <PROGRAM_ID> --provider.wallet <OWNER_KEYPAIR_PATH>` and `anchor ild upgrade -f <IDL_PATH> <PROGRAM_ID> --provider.wallet <ACCOUNT_KEYPAIR_PATH>`.

However, I got the same error below :
```shell
Error: Error processing Instruction 0: custom program error: 0xbbf
# it is error 3007 "The given account is owned by a different program than expected"
```

Even I tried all from scratch, got same error message.
What am I missing?
Hello, any idea friends?
hey guys, is there any way to get in reattime or receive an event when an account is created in my program?
I couldn't find a crate for 0.23, but I tried 0.22 and it looks like that worked. Thanks!
Thx I'm going to do that!
You probably need to run `anchor idl upgrade`
I upgraded IDL on my Dapp copy from target directory. When I deployed the program only run command `anchor deploy`
Did you upgrade the IDL?
Hi guys, I have a question when upgrading a program. 
I added a variable of a Struct and redeployed it.
After that, I ran a command on my Dapp with an account used before upgrading, but it did not work. 
Is it impossible? 
Do I need to create a new account for the upgraded program?

The error message is:
```javascript
Transaction simulation failed: Error processing Instruction 0: custom program error: 0xbbb  Program <PROGRAM_BASE58> invoke [1] Program log: Instruction: Swap Program log: Custom program error: 0xbbb 
Program <PROGRAM_BASE58>
consumed 7021 of 1400000 compute units Program <PROGRAM_BASE58> failed: custom program error: 0xbbb
```

Before upgrade struct below:
```rust
#[account]
pub struct ProgramStatus {
    authority: Pubkey,
    amount u64
}
```

After upgrade struct below:
```rust
#[account]
pub struct ProgramStatus {
    authority: Pubkey,
    amount u64,
    is_working: bool // added
}
```

Thx
the docs you linked to are for 0.23 and I think older versions don't work for what you're trying to do
Use 0.23
0.18.0
What version of Anchor are you using?
exactly
Oh I see, you want to be able to implement AnchorSerialize/Deserialize on the structs so you can use them as Anchor accounts
Why do you need wrapper structs?
The project is an IRL event app, where people can host a Party and others can join as Guests. Joining a party requires some stake_in_lamports, with the idea being that after checking-in, the lamport pool will be evenly distributed among all checked-in guests (people who fail to check-in lose their stake). 

You can view the code I have so far here: https://github.com/Yihwan/party-irl/blob/poc/programs/party-irl/src/lib.rs

But I'm not sure how to handle the logic to "settle" a Party. I was hoping to do some kind of query within a settle_party method or similar that looks for all checked-in Guests, but I'm not sure if I have to pass in all the accounts to be transacted as args. If so, I suppose I could so a filtered query from the client, but not sure if that would open things up to vulnerabilities. 

Basically, any guidance on whether the premise of the app is feasible would be super helpful. Happy to try and figure out the implementation details as I go along, just want to get a sanity check on overall feasibility before I go too far down the wrong path.
I‚Äôm working on a toy project to help solidify my understanding of Solana/Rust (just got introduced to both last week).
Starting a thread so I don't pollute the channel. üòÖ
Quick sanity check on project feasibility
Check your Anchor.toml file's wallet matches your expectations
Hello all. I ran an anchor test, and the result has me confused.
This channel has been super helpful, so I wanted to share my WIP solution to one of the projects given at the Solana Bootcamp in NYC recently. This is my first time working with this tech stack, so I'm making lots of comments about beginner-level stuff. https://github.com/sfdz/exchange-booth
oh awesome, looks like i should've searched the discord for associated token account questions, thank you
You're getting a CPI signer privilege error because you're presumably passing in an associated token address from the client, but that's a PDA derived from a totally different program, the associated token program, not your own‚Äîso your program can't sign for its address
If you want to create an associated token account, instead get rid of those `seeds = [...]` and do `associated_token::mint` and `associated_token::authority` instead
hey, i'm getting this error:

```
Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account 
    Program 3mk9JnpeBbfdo58S4R4SMHy9m1sFENseiHCJCN9xSUZ1 invoke [1]
    Program log: Instruction: RedeemNft
    8HgicSXn9kSWQC3qJv6u4FCTwzJBkVCzrnZCqiK2adpx's signer privilege escalated
```
i've looked through the previous errors on the discord and was unable to solve my problem since i can't figure out why this error is happening. i've removed all cpi calls from the instruction, and isolated the ```8HgicSXn9kSWQC3qJv6u4FCTwzJBkVCzrnZCqiK2adpx``` address to this account:

```
#[account(init_if_needed,
        seeds = [
            redeemer.key().as_ref(),
            token_program.key().as_ref(),
            reserve_token_mint.key().as_ref(),
        ],
        bump,
        token::mint = reserve_token_mint,
        token::authority = redeemer,
        payer = redeemer,
    )]
    pub recipient_token_account: Box<Account<'info, TokenAccount>>,
```
the context of this is i'm trying to create an associated token account for a user in the anchor program, so it doesn't have to be created by them on the frontend


//////////////////////////////////////////////////////////////////////////////////////////

I‚Äôll give it another shot in a few
Why is `"signatures": [],` empty <:thonk:711735996726640652>
```return program.transaction.foo({
    accounts: {
        signer: signerKeypair.publicKey,
        ...(other accounts)
    },
    signers: [signerKeypair]
});

Returns:

{
    "signatures": [],
    "instructions": [
        {
            "keys": [
                {
                    "pubkey": "<SignerPubkey>",
                    "isWritable": true,
                    "isSigner": true
                },
                ...(other accounts)
            ],
            "programId": "<programId>",
            "data": {
                "type": "Buffer",
                "data": [
                    ...(data)
                ]
            }
        }
    ]
}```
Closing PDAs works fine (closing program is different though)
How are you closing it?
similar to how you deploy a program, close it and and cant redeploy to that same address
Yea I I just couldnt figure out how to close the account thats a PDA and able to reuse it, since I seem to run into that error everytime i try and close it and reuse
That error means you're trying to init an account at an address that already holds some other account
Yeah, you can close accounts in solana
Curious to see this because I run into this error a lot, ```Allocate: account Address { address: "somePDAAdress", base: None } already in use```
Hey how can i send myself some devnet usdc?
If I am not wrong, I think solana provides a way to remove data at a given address, and I think it also refunds us the rent fee as well
yea i tried this, same issue...
you can look at localnet txns with explorer.solana.com
i see you're using the idea of "rooms" kind of curious who this works, since im looking to allow users to create new games but when you initialize with a public key, that pda will already exist after youve done it once. Question for the group, is there a way to close a PDA after some arbitrary condition? Like basically revert the initialize handler
sure
Actually I am currently running on localnet, Will try to deploy on devnet and reach back to you
or shoot me the txHash, I'll check once
for devnet, it shows
But I dont think it shows any logs for  transactions on localnet or devnet
thanks, I will try that
I am not too sure about that. The tests which I have been running are working fine without any need to use confirmTransaction  there, but I will try and let you know
though one thing you can do is, check the txLog on solscan once, see if everything is working or not.
Possibly (I'm a little fuzzy tbh on when this is necessary)
does that mean, that I need to confirm transaction whenever I create a new account?
aah make sense now
This is simply `program.rpc`. I have wrapped the program object in a vueJS `ref` object. So have to use value to access the underlying `program` object
await program.provider.connection.confirmTransaction(thatThingsReturnValue)
What is `program.value.rpc` here, just curious. Haven't seen anything like this?
I am sorry, i am not getting you. Additional confirmation?
You probably need to wait for additional confirmation
Moreover, it is correctly fetching all the results after I refresh the site. It seems that until I refresh, it is unable to fetch the account
this is the `send_message` method in my rust program:-
```
 pub fn send_message(ctx: Context<SendMessage>, content: String, room_key: Pubkey) -> ProgramResult {
        let message = &mut ctx.accounts.message;
        let author = &ctx.accounts.author;
        let clock = Clock::get().unwrap();

        if content.chars().count() > 256 {
            return Err(ErrorCode::ContentTooLong.into());
        }

        message.author = *author.key;
        message.timestamp = clock.unix_timestamp;
        message.content = content;
        message.room = room_key;

        Ok(())
    }
```
and this is the `Context` 
```

#[derive(Accounts)]
pub struct SendMessage<'info> {
    #[account(init, payer = author, space = state::Message::LEN)]
    pub message: Account<'info, state::Message>,
    #[account(mut)]
    pub author: Signer<'info>,
    #[account(address = system_program::ID)]
    pub system_program: AccountInfo<'info>,
}

```
I tried some more things but I am not able to understand what is happening:-
```

    console.log(program.value.account.message.all())

    await program.value.rpc.sendMessage(content, roomPublicKey, {
        accounts: {
            message: message.publicKey,
            author: wallet.value.publicKey,
            systemProgram: web3.SystemProgram.programId,
        },
        signers: [message]
    })

    console.log(program.value.account.message.all())

 ```
It seems that the new account is not being created at all. Both the `console.log` statements show the exact same output
Just the ata yea balance is fine
makes sense, thanks!
You might want to check yourself if you want to have a chance to raise your own custom error etc.
Yeah, the tx will just fail/rollback if you invoke the token program.
why would you check the balance tho? the transfer instruction would just fail
Yea you‚Äôd want to check this. Plus you need to grab their ATA and it might not exist
not really, unless your logic depends on it
but you may want to catch that before it happens, or not
It will fail
it'll just fail
Yea I tried using authority and it gave the same error actually but I‚Äôll take a look again so just use authority instead of itself.key in initialize ? For all the pdas with seed
since, your other accounts depend on that, it may be causing problems
<@!270368441972555776> on the play instruction, the `rpbp` account is a PDA of seeds which are taken form inside itself `rpbp.authority.as_ref()`, have you tried writting it like in the other instruction? simply reffering to `authority` as it is also present
The tests run fine
Yeah tried doing that as well, it seems that it is unable to see that the account has been created.
And see the result
Try doing a message.all() first
Ive run into these problems before too
Might be a different seed
lol i know right
too much anchor for today
Yup, but It seems that it is not able to fetch my newly created account
nvm, misread
Let me see
on initialize your constraint is under the account???
Fetch gets accounts /pdas of your struct types
wait, i found ur problem
That‚Äôs what I‚Äôm trying to figure out but I‚Äôll keep looking at it. Thanks for suggesting <@!317013100371116032>
hello ! It seems that I am unable to understand how the `fetch` method works in anchor.
I have the following piece of code:-
```
export const sendMessage = async (content, roomPublicKey) => {
    const { wallet, program } = useWorkspace()
    const message = web3.Keypair.generate()

    await program.value.rpc.sendMessage(content, roomPublicKey, {
        accounts: {
            message: message.publicKey,
            author: wallet.value.publicKey,
            systemProgram: web3.SystemProgram.programId,
        },
        signers: [message]
    })

    try {
        console.log(message.publicKey.toBase58())
        const messageAccount = await program.value.account.message.fetch(message.publicKey)
        return new Chat(message.publicKey, messageAccount)
    } catch(err) {
        console.log(err);
    }
}
```
the `sendMessage` rpc is responsible for creating a new account, and I am simply fetching that new account, but I am unable to do so.

Moreover the tests which use similar code are working fine:-

```

    for (var i = 0; i <= 10; ++i) {
      const message = anchor.web3.Keypair.generate();
      await program.rpc.sendMessage('temp', room.publicKey, {
        accounts: {
          message: message.publicKey,
          author: program.provider.wallet.publicKey,
          systemProgram: anchor.web3.SystemProgram.programId,
        },
        signers: [
          message
        ],
      });

      const messageRes = await program.account.message.fetch(message.publicKey);
      assert.equal(messageRes.author.toBase58(), program.provider.wallet.publicKey.toBase58())
    }

```
Any help on this?
So not sure what‚Äôs different about the seed
Im using th√© exact same account I passed to initialize
specifically, this account: `rpbp_fee_account`
either your account is not a PDA or not one with those seeds, or it's not a PDA for that program you are calling
you are passing an account which apparently has to be a PDA of certain seeds
yes
Any ideas here?
I never tested it, but can we assume the maximum amount of unit variants is 256?
just make sure you don't have too many variants I guess
For unit variants yes
yep
is the space of an enum always equivalent to `u8`?
Okay, thank you!
Yeah, for when you don't know ahead of time the exact number
optional account provision?
What is the purpose of `remaining_accounts` then?
hmm, i guess i'll have to embrace long contexts then, thx
Nope, need to pass in *all* accounts from the client
if so, is this why `remaining_accounts` exist?
Or does my transaction need to include those accounts from the start?
Hey, quick question, is it possible to fetch an account info with just the public key when making a CPI?
I see. yes will try to come up with a nice solution template and share the code here üôÇ
Just send the tx the lower-level web3.js way
Ah, yeah, you can still test that just fine, I'm just saying that I'm not sure how to swap out a different provider.wallet (might be possible, can't remember)
sure, but it is always nice to have tests to verify that stuff again
Yeah. It's up to you to write your program with appropriate checks
I mean something like the `authority`mechanism of the basic-2 example. Isn't it that if this is missing, everyone could write to the account if they know the pubkey of the account?
The ways to do that in tests etc. are just for tests, e.g. you can clone an account from devnet/mainnet etc.
In general in solana, only the program that owns an account can write to its data
I have directory with secret keys and load them up for tests and top  up if necessary.
Thanks , that worked as far as submitting transaction, but that account was deployed via client and account address passed to the anchor program so it can't be processed within anchor checks as it is missing the first 8 designation bytes

```Error: 3001: No 8 byte discriminator was found on the account```

Accounts can only be modified by the owner and need to be zerod in, so I can't preload an account with 8 bytes.  

It seems that with anchor it has to be the program deploying and instantiating an account, is this true?

I know this is kind of a niche problem, to want to deploy an account using the client. I kind of just fixated on it as there doesn't seem to be any way to do it.
in my opinion such tests are crucial since I need to ensure that no data can me manipulated by other entities
that's also a good point. I was wondering why .rpc() is shown as deprecated
Or maybe with the new api, instead of doing `.rpc()` just do `.transaction()`? Haven't actually tried that
You can build a tx by doing `program.transaction.yourInstructionName`
Not sure there's actually a super easy way to do that, you might need to drop down to low-level web3.js to send/sign the tx etc.
thanks. In that case: how do I simulate two wallets in a test? the equivalent of two `provider.wallet` instances I mean.
You need to sign for `counter` though because in solana whenever you create an account, the account's address has to sign
`provider.wallet` actually signs no matter what, since it pays the tx fees, so you never need to include it in `signers` (in fact, in the browser you *can't*, since you don't have access to the wallet keypair).
Hi all, I have question regarding the tests in the `basic-2` project of the examples:
https://github.com/project-serum/anchor/blob/master/examples/tutorial/basic-2/tests/basic-2.js

Why do we sign the transaction with the `counter` keypair and not witht`provider.wallet`?
`provider.wallet` is assigned to the `user` account which is declared to be the signer of the 
transaction. So why does this not fail when we sign the transaction with `counter`. What also
confuses me is that in the IDL `counter` is also declared a signer of the transaction implicitly.
But assuming this, in my opinion it should still fail since in that case both: `counter` and 
`provider.wallet` should sign the transaction.
Another thing here: Where did `counter` get the funds to pay for the transaction? Is it implicitly
created with funds via `anchor.web3.Keypair.generate()` ?
is `program.addEventListener` works in react? 
i tested it with anchor test on nodejs, i am able to get the event, but not in react?
what is missing?
i could see the events being registed, but not firing

```
useEffect(() => {
    console.log('here program')
    if (!program) return;
    console.log('progam registered')

    program.addEventListener("EventData", (ev, slot) => {
      console.log('event')
      console.log(ev)
      console.log(slot)
    })
  }, [program])
```
Am I missing something?
Good day! I have a struct which I want to pass into an rpc, which contains `Option` inside it.
```
struct Foo { 
    bar: Option<u64>,
    baz: Option<u64>,
}
```
But when I try to pass it in any way written below I get an `Invalid option Foo` error:
```
program.foo({
  bar: BN(2),
  baz: BN(3),
})...
```
```
program.foo({
  bar: {
    some: BN(2),
  },
  baz: {
    some: BN(3),
  }
})
```
Oh, got it‚Äîyou can do `program.provider.send(thatTx)`
I was just wondering whether there is a function that does it within anchor, so I don't have to regenerate payer.secretkey (for sendAndConfirmTransaction(program.connection, transaction, [provider.wallet])) to submit it the standard way nor having to import solana/web3.js if for whatever reason in my design account gets made by the client.
Not sure I understand your question‚Äîhow do you want to use anchor to do that?
Is there a way to generate and deploy an account via client using anchor framework, rather than instructing the program on how to do it? Easy enough to do it in vanilla Solana TS, but can't find anywhere how to do this:

        const transaction = new Transaction().add(
            SystemProgram.createAccountWithSeed({
                fromPubkey: payer.publicKey,
                basePubkey: payer.publicKey,
                seed: GREETING_SEED,
                newAccountPubkey: greetedPubkey,
                lamports,
                space: GREETING_SIZE,
                programId,
            })
        );

        await sendAndConfirmTransaction(connection, transaction, [payer]);
i cheated a little
hows this
```rust
use anchor_lang::prelude::*;
use anchor_spl::token;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod vault {
    use super::*;

    pub fn transfer_wrapper(ctx: Context<TransferWrapper>, amount: u64) -> Result<()> {
        match token::transfer(ctx.accounts.transfer_ctx(), amount) {
            Ok(_) => Ok(()),
            Err(err) => Err(err),
        }
    }
}

#[derive(Accounts)]
pub struct TransferWrapper<'info> {
    pub authority: Signer<'info>,
    #[account(mut)]
    pub sender: Account<'info, token::TokenAccount>,
    #[account(mut)]
    pub reciever: Account<'info, token::TokenAccount>,
    pub mint: Account<'info, token::Mint>,
    pub token_program: Program<'info, token::Token>,
}

impl<'info> TransferWrapper<'info> {
    pub fn transfer_ctx (&self) -> CpiContext<'_, '_, '_, 'info, token::Transfer<'info>> {
        CpiContext::new(
            self.token_program.to_account_info(),
            token::Transfer {
                from: self.sender.to_account_info(),
                to: self.reciever.to_account_info(),
                authority: self.authority.to_account_info(),
            }
        )
    }
}```
Have you gone through any of the anchor escrow program tutorials? They would explain that
I thought maybe a vault where anyone can deposit or withdraw spl tokens, but i have no idea how to interact with spl tokens
Can someone suggest a simple beginner program for me to try making?
Sure!
as easy as this üôÇ thanks mate!
`your_account.reload()?;`
Hi folks, how can I get the updated data of an account after a CPI? I am doing a CPI swap and I need to know how many tokens I got.
Easier to understand it by just jumping to source I think (you'll need to have jump-to-source configured with your editor to make much progress with anchor/solana!)
I managed to get it working. The goal of the instruction is to airdrop tokens with CPI, but the account that I was passing in as the mint was missing `#[account(mut)]`. That was actually causing a `writable privilege escalated` error, the signer problem was a red herring because I also saw a `Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account` .
Oh sorry I misunderstood the question.
agenda was that how i can use `anchor_spl` functions and structs.
i'm seeking for tutorial or guide book. <@!252808943238119424>
add anchor-spl to your Cargo.toml
how i can use functionalities of `create anchor_spl` in my own code(NFT marketplace).
here is Link of `create anchor_spl` https://docs.rs/anchor-spl/latest/anchor_spl/all.html
for cross program invocations (CPIs)
https://book.anchor-lang.com/chapter_3/CPIs.html
https://github.com/project-serum/anchor/blob/master/tests/cpi-returns/programs/caller/src/lib.rs
what is `CpiContext` in anchor? <@!134416332509675520> <@!883714735864946718>
the seed constraints on the rpbp_fee_account are the exact same?
```Transaction simulation failed: Error processing Instruction 0: custom program error: 0x7d6 
    Program Ahs4nv515E2QTQPoqdpq2yiWSkco5ew1zPUXa89QZtsL invoke [1]
    Program log: Instruction: Play
    Program log: AnchorError caused by account: rpbp_fee_account. Error Code: ConstraintSeeds. Error Number: 2006. Error Message: A seeds constraint was violated.
    Program Ahs4nv515E2QTQPoqdpq2yiWSkco5ew1zPUXa89QZtsL consumed 12112 of 200000 compute units
    Program Ahs4nv515E2QTQPoqdpq2yiWSkco5ew1zPUXa89QZtsL failed: custom program error: 0x7d6```
Running into the classic `seed constraint was violated` . Not really sure how since the seeds are the same from init to this Play handler instruction. Anyone spot anything wrong here?
```

#[derive(Accounts)]
#[instruction(bump: u8, fee_account_bump: u8, treasury_bump: u8)]
pub struct Initialize<'info> {
    #[account(init, seeds=[PREFIX.as_bytes(), authority.key().as_ref()], bump, space=GAME_SIZE, payer=payer)]
    rpbp: Account<'info, GameInstance>,
    #[account(mut, 
        seeds=[PREFIX.as_bytes(), rpbp.key().as_ref(), FEE_ACCOUNT.as_bytes()], 
        bump=fee_account_bump
    )]
    ///CHECK:
    rpbp_fee_account: UncheckedAccount<'info>,
    #[account(mut, 
        seeds=[PREFIX.as_bytes(), rpbp.key().as_ref(), TREASURY.as_bytes()], 
        bump=treasury_bump
    )]
    ///CHECK:
    rpbp_treasury: UncheckedAccount<'info>,
    #[account(mut)]
    payer: Signer<'info>,
    ///CHECK:
    authority: UncheckedAccount<'info>,
    #[account(mut)]
    ///CHECK:
    fee_withdrawal_destination: UncheckedAccount<'info>,
    #[account(mut)]
    ///CHECK:
    treasury_withdrawal_destination: UncheckedAccount<'info>,
    system_program: Program<'info, System>,
    time: Sysvar<'info,Clock>,
}

#[derive(Accounts)]
#[instruction(fee_account_bump: u8, treasury_bump: u8)]
pub struct Play<'info> {
    #[account(mut)]
    wallet: Signer<'info>,
    #[account(mut, 
        seeds=[PREFIX.as_bytes(), rpbp.authority.as_ref()], 
        bump=rpbp.bump
    )]
    rpbp: Account<'info, GameInstance>,
    #[account(mut, 
        seeds=[PREFIX.as_bytes(), rpbp.key().as_ref(), FEE_ACCOUNT.as_bytes()], 
        bump=fee_account_bump
    )]
    ///CHECK:
    rpbp_fee_account: UncheckedAccount<'info>,
    #[account(mut, 
        seeds=[PREFIX.as_bytes(), rpbp.key().as_ref(), TREASURY.as_bytes()], 
        bump=treasury_bump
    )]
    ///CHECK:
    rpbp_treasury: UncheckedAccount<'info>,
    ///CHECK:
    authority: UncheckedAccount<'info>,
    #[account(address = sysvar::instructions::id())]
    ///CHECK:
    instruction_sysvar_account: UncheckedAccount<'info>,
    system_program: Program<'info, System>,
    time: Sysvar<'info,Clock>,
}
```
Hi. I'm reading about accounts in Anchor (https://project-serum.github.io/anchor/tutorials/tutorial-1.html#initialize-instruction) and have a question regarding this paragraph: "Without it, a program would be vulnerable to account injection attacks, where a malicious user specifies an account of an unexpected type, causing the program to do unexpected things." 
How do account discriminators in Anchor prevent injection attacks? Since anyone can initialize an account with the expected discriminator and pass it to an Anchor program.
Is it possible to view all the accounts (and data that is updated) before signing/approving a transaction?
SOLVED.

I had my provider wallet be the same keypair as my /target/deploy. This made it so that it was always in use
Running `anchor test --skip-local-validator` will always give me 

`Error: Account <insert pubkey> is not an upgradeable program or already in use`

No matter how many times I re-make `/target/deploy` and change anchor.toml and lib.rs. I'm running `solana-test-validator --no-bpf-jit` in another terminal.

Whats the issue?
Anyone can derive the pubkey for this PDA, but the private key can't exist. So the on-chain program is just allowed to flip the 'isSigner' bit for itself in a CPI, because solana can verify that the pubkey for that PDA is derivable from its address and that no hanky panky is going on. Clients can't be trusted.
(Disclaimer: I'm a newb and this is my best understanding :p)
A PDA does not have a private key, it can 'fake sign' only within the on-chain program.
No
Can you have a PDA sign for a transaction? Specifically client side
<:PB_pepesit_sad:769654458148847627>
At my last job one dude wrote this beautiful, user-friendly deployment tool, with multiple confirmations steps, cute emojis, etc. Miss it üò¢
Solana's deploy tools need some work, they're honestly pretty bad lol üòÜ
Yeah lol ü§¶‚Äç‚ôÇÔ∏è Maybe try running it on a local validator deploy first
maybe ill just let the 7 SOL rot, i don't want to accidently close the one lol
lol, sounds like high stakes roulette... maybe it works, or maybe it closes the program thats running lol
Like, at the end I guess
According to that output though you can just pass the program_id as an argument to the command
Hmm yeah running `solana program close --help` doesn't even include the `--programs` option lol
but i dont want to close both, jsut one.
no, i give it my keypair.. and that shows two programs that my keypair/authority owns
Does the `-k` argument not do what you want?
ok, so i have two programs.... hm, how do i close one üôÇ
yes, missed that. Thank you!
Looks like it's `solana program close --programs`
Justin discusses this here a bit down the page: https://jstarry.notion.site/Program-deploys-29780c48794c47308d5f138074dd9838
it says i need --buffers, but if i add that I don't think anything happens
I accidently deployed my program to a different address at mainnet. I'm trying to close it, is this the right command?

`solana program close -k target/deploy/program-keypair.json --authority /Users/me/wallets/my_wallet.json`
Oo delightful, ty
Sure, `program.transaction.yourInstructionFn`
Can I use anchor to emit a web3 transaction containing an instruction built up for a program from an idl, but not send it to solana? I.e. so I can send it to someone else to be signed.
Yes, every account has a program owner. Although it depends a bit on what you mean by "owner", since e.g. token accounts have both a program owner (the spl token program) as well as a logical "authority", the human/whatever that "owns" the tokens.
That actually looks about right, what was the full program log?
just need to be able to filter them or always guarantee im passing them in that order
yea im thinking ill just have to read the publickey list from that struct, then pass the accounts as remaining_accounts...
yeah I had similar problem with tokens. Had to make it a 2 hop solution (change data on rust and then fornt end calls with  account info using that changed data )
Or maybe I use `remaining_accounts` but I haven't used that before so. Ill take a look into it
is the rent epoch shorter for localnet?
If I have just the public key of the address I want to send to, do I need to pass it in the accountinfos array ?
```
invoke_signed(
                            &system_instruction::transfer(
                                &rpbp_treasury.key(),
                                &p.owner.key(),
                                amount,
                            ),
                            &[
                                rpbp_treasury.to_account_info(),
                                p.owner.as_ref().to_account_info(), //do I need to pass this?
                                system_program.to_account_info(),
                            ],
                            &[&rpbp_treasury_seeds],
                        )?;

```
Basically, I have a list of public keys and want to transfer sol, but since the list is stored on a struct in the program, I wont be able to get the account info at runtime. Would I need to maybe then get the struct and map the public keys on it as an input to the handler function instead? Or possibly need to rethink the approach.
like a PDA
no you can have an account be owned by a different account
has anyone managed to make CPI calls to the metaplex candy machine?
Accounts are always owned by a program right? they can only be owned by a program?
Its a boolean that I set to false in rust, but when I run the code and fetch the account using anchor in the client, it is set as true
I am getting this weird error where the data on one of my accounts is not being modified
Can someone confirm if my thought process makes any sense?

I created a mint account. Now I want my program to mint tokens of my mint on demand. To do that, I need to initialize a PDA in my program and assign that PDA to be the mint authority of the mint account. Once that is done, I can CPI the mint_to instruction from my program to create tokens.
https://github.com/0xcatrovacer/honey-ido-pool/blob/main/cli/index.js This is the file causing the error
https://explorer.solana.com/address/7TZqAhcqsPHoZ7sDAeUpDj5woKDDFMYGuX1bgoBsfGPv?cluster=devnet
which is happening due to this
   ``` redeemableMint = await serum.createMint(
        provider,
        poolSigner,
        mintInfo.decimals
    );```
poolSigner is the publicKey in itself and so publicKey.publicKey.toString() is not making sense
now poolSigner is being derived from a findProgramAddress call (the thing you do for PDAs) which returns the publicKey and the bump
 ```   const [_poolSigner, nonce] = await anchor.web3.PublicKey.findProgramAddress(
        [honeyMint.toBuffer()],
        program.programId
    );```
so how do i handle this?
The error has to do with this :
```TypeError: Cannot read properties of undefined (reading 'toString')
    at Transaction.partialSign (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/Honey-IDO/honey-ido-pool/node_modules/@solana/web3.js/lib/index.cjs.js:2715:36)
    at NodeWallet.signTransaction (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/Honey-IDO/honey-ido-pool/node_modules/@project-serum/anchor/dist/cjs/provider.js:161:12)
    at Provider.send (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/Honey-IDO/honey-ido-pool/node_modules/@project-serum/anchor/dist/cjs/provider.js:77:27)
    at processTicksAndRejections (node:internal/process/task_queues:96:5)
    at async Object.createMint (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/Honey-IDO/honey-ido-pool/node_modules/@project-serum/common/dist/lib/index.js:43:5)
    at async createInitPool (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/Honey-IDO/honey-ido-pool/cli/index.js:244:22)
```
Hey so I'm running into a weird js error when trying to deploy a pool for an IDO platform.
running ./init_pool.sh gives this error:
```- J7Jkz6P2ip5NjWES6vERtDfTwUYY2LQ1FhMXJ73BdAdby5jiw1G
YError: Invalid second argument. Expected string or boolean but received function.
    at c (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/Honey-IDO/honey-ido-pool/node_modules/yargs/build/index.cjs:1:2244)
    at /mnt/c/FILES/Development/Web3Dev/Honey-Labs/Honey-IDO/honey-ido-pool/node_modules/yargs/build/index.cjs:1:2096
    at Array.forEach (<anonymous>)
    at h (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/Honey-IDO/honey-ido-pool/node_modules/yargs/build/index.cjs:1:1993)
    at Bt.command (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/Honey-IDO/honey-ido-pool/node_modules/yargs/build/index.cjs:1:29503)
    at Object.<anonymous> (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/Honey-IDO/honey-ido-pool/cli/index.js:853:6)
    at Module._compile (node:internal/modules/cjs/loader:1101:14)
    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)
    at Module.load (node:internal/modules/cjs/loader:981:32)
    at Function.Module._load (node:internal/modules/cjs/loader:822:12)
args:  {
  _: [ 'init', '8DXSNpVJ5xHX7B49kCQVxMgQ2xPALEaZxN1H1sLFEebX' ],
  start_time: 1641218400,
  deposit_duration: 86400,
  withdraw_ts: 1641304800,
  'dry-run': false,
  dryRun: false,
  '$0': 'cli/index.js',
  usdc_mint: 'EvKdW6Jg7pc94Yp9FQzkqdehPLPrjq1itHuiXZgoVYeU',
  honey_mint: '8btRwS4Hk9aDWJVVfob23izQCd4RLfZaTGEq8y5jiw1G',
  honey_account: 'J7Jkz6P2ip5NjWES6vERtDfTwUYY2LQ1FhMXJ73BdAdb',
  honey_amount: 30000000
}
/mnt/c/FILES/Development/Web3Dev/Honey-Labs/Honey-IDO/honey-ido-pool/node_modules/@solana/web3.js/lib/index.cjs.js:2715
      const key = signer.publicKey.toString();
                                   ^```
I also have the bump stored on the Manager account. I tried doing signer_seeds: `&[&[&"manager".as_bytes(), user.key().as_ref(), &[manager.bump]]]` but that didn't work
I know that my seeds are `"manager"` and `user.key()` where user is the Signer
I'm trying to use `CpiContext::new_with_signer`, how should I define the `signer_seeds` for the PDA?
Isn't it the return value of that call?
does this error mean I would not get any tokens back so theres no point in swapping?
but no matter what amountIn I put it doesnt seem to matter i get that error
I think im hitting this case: https://github.com/solana-labs/solana-program-library/blob/95cd64ce022844d5ad2b2d4809c4b29c063162b3/token-swap/program/src/processor.rs#L404
Hi, having trouble understanding why I keep getting this error when trying to swap tokens on the orca amm in devnet:
```Given pool token amount results in zero trading tokens```
hi, @everyone
i'm new to Rust and new to this channel
am not sure if this is the right place for this kind of question, but...

our team is going to create a reward system for our NFT staking on Solana
can anyone tell me how to set up staking?
all i know is : `using cli for token creation`, `using genfarm for staking`
is it possible to do all this in code like on EVMs?
on EVMs we can set up our own staking mechanism using Solidity

can anyone help with this issue?
looking forward to hearing back.
Does anyone know how to fix?
I get failed to run custom build command for `ring v0.16.20` when trying to install anchor on my windows pc
<@!326107472098099201> ahhh ok nice - thanks Tom üôè
avm is the recommended method
For installing anchor on linux - should I install with pre-binaries w/npm or from source?


//////////////////////////////////////////////////////////////////////////////////////////

How can I read and parse account from a `Pubkey` inside the instruction code using Anchor?
How to write program to create pools like uniswap on solana? Is there any other program example that exists??
What is the difference between AccountInfo and Account ? And AccountInfo vs. UncheckedAccount?
try changing the variable name from `token` to something else
But I'm just importing the program code from the anchor library, it's the SPL token program.

I checked out the anchor source code and the token account struct is there.
you dont have a token struct defined in your anchor program code
<@!134416332509675520> üò¨ help out plox
I have the following code

```
  const tokenProgram = anchor.Spl.token();
  const token = await tokenProgram.account.token.fetch(
      tokenAccount.publicKey
    );
```
This keeps saying

```
Error: Invalid account name: token
```

What am I missing?
üëã if I have the publicKey of a token, I created, is there a way to retrieve that token with the publicKey? Not seeing anything in the `token.js` class in the SPL repo
Yea I already have the PDA check so should be fine.
Yeah when in doubt you should use `constraint =` etc.
Might be useful to have an account type for this which would also check that the lamports and space are 0 just to be extra pendantic. Because I think there are some accounts that are owned by the SystemProgram (like the BPF loader program I believe etc?) which could pass this check.
this works!! thanks so much alan
Have you read the createProgramAddress source?
There are multiple types of addresses in solana: true public key addresses (in the ed25519 cryptographic sense), program-derived addresses (see that link I just posted), and also this weird third kind that nobody uses anymore.
```
const seedsWithNonce = seeds.concat(Buffer.from([nonce]));
        address = await this.createProgramAddress(seedsWithNonce, programId);
```
I mean, it just looks like we are creating a new address if it doesn't exist here.
is there no difference between an account public key address vs. a program address?
https://discord.com/channels/889577356681945098/889702325231427584/939324164890845265
What's the deal with bump? Is there any resource where I can read// learn about it? üòû
I would suggest reading the source for findProgramAddress.
The address itself isn't, like, stored on-chain or anything (the account that may or may not live there is though)
Think of them as keys in a hash table‚Äîit's one thing to talk about whether anything is *stored* at that key (aka an account actually lives at that address) versus the key itself.
cool, thanks!
Yep. Addresses in solana are just 32 arbitrary bytes. You don't really "create" them, you "find" them.
You could say `that_pda: SystemAccount<'info>` to declare that this thing had better not have any data etc
With anchor version 0.22.0 the `AccountInfo` accounts are marked as unsafe and need to have a comment. I'm passing a PDA account which is to be used as mint authority (doesn't store any state). Is there anything else I am supposed to be using instead of `AccountInfo` for this? It seems silly to have to add a comment when the account doesn't store data and I already have the PDA check on it.
wait what? the address for a newly created mint exists even before I call `mint.createAccount`?
Addresses are totally independent of the account that may or may not live there, so the address exists no matter what (it's, like, a large number under the hood‚Äîthey all exist already)
I've got:
```
const mintATA = await PublicKey.findProgramAddress(
      [
        walletPubKey.toBuffer(),
        spl.TOKEN_PROGRAM_ID.toBuffer(),
        mintAccount.publicKey.toBuffer(),
      ],
      spl.ASSOCIATED_TOKEN_PROGRAM_ID
    )
```
In the debug console I see:
```
mintATA[0]
PublicKey¬†{_bn: BN}
mintATA[0].toString()
'BVHqVGSjCbD9HrUPG48gaUkX6Mn3buxSXTzQ58rrFdf4'
mintATA[1].toString()
'254'
mintAccount.publicKey.toString()
'5DF8aP9TP3e9vNWjivqnUQJz7LNHRNktejY4hmk5KFra'
```
I initialize a mint and never create an associated token account for the wallet present. Why is this function returning anything an address?

https://explorer.solana.com/address/5DF8aP9TP3e9vNWjivqnUQJz7LNHRNktejY4hmk5KFra/largest?cluster=devnet - mint account on devnet
As far as I know you have to mint however many tokens you care about and then unset the mint authority
Is there a way to limit the supply of an SPL token? Not seeing anything on the `createMint` function call:

```
/**
   * Create and initialize a token.
   *
   * @param connection The connection to use
   * @param payer Fee payer for transaction
   * @param mintAuthority Account or multisig that will control minting
   * @param freezeAuthority Optional account or multisig that can freeze token accounts
   * @param decimals Location of the decimal place
   * @param programId Optional token programId, uses the system programId by default
   * @return Token object for the newly minted token
   */
  static async createMint(
    connection: Connection,
    payer: Signer,
    mintAuthority: PublicKey,
    freezeAuthority: PublicKey | null,
    decimals: number,
    programId: PublicKey,
  ): Promise<Token> {
```
No... 

here's my created instruction, everything seems reasonable:
```
TransactionInstruction(keys=[AccountMeta(pubkey=AAakQsCYzHrj6C6CmCGdLtZnSeforiSWBm8q9N7W2yuQ, is_signer=True, is_writable=True), AccountMeta(pubkey=DyvogiyJaMnrVfT9cqAhnj5pNXRJeZT9rhJR2dALgWpV, is_signer=False, is_writable=True), AccountMeta(pubkey=Ak7DzaacxWwKLUFaKfntbcdcoKXzDk56aseSbqYT5MSy, is_signer=False, is_writable=False), AccountMeta(pubkey=G52Ki9ge7PzHHSswj4QXPUcaMYPVKEzgNoDvgN8iqTjg, is_signer=False, is_writable=True), AccountMeta(pubkey=GUuG7Soj4C9Zjx9qBqnfDZXLymeQP2cvHWLmqgY6QN5M, is_signer=True, is_writable=True), AccountMeta(pubkey=AG567t1EC9Eczwy26Qvd8rQcrgPzRg1q4vBe5LxjxgP3, is_signer=False, is_writable=False), AccountMeta(pubkey=SysvarRent111111111111111111111111111111111, is_signer=False, is_writable=False), AccountMeta(pubkey=11111111111111111111111111111111, is_signer=False, is_writable=False), AccountMeta(pubkey=AsW7LnXB9UA1uec9wi9MctYTgTz7YH9snhxd16GsFaGX, is_signer=False, is_writable=False)], program_id=7W8hRd8PqFQt5EZDHu9mmBhmiY4UPCcv9UuL86sYkm2K, data=b'o\x11\xb9\xfa<z&\xfe\xfc')
```

and then i just run
```python
    tx = Transaction().add(inx)
    await cpi_program.provider.send(tx)
```
hmm
One is a property purely of the address, one is a property of the account
So you have to keep the concepts of "can sign for this address" and "can mutate this account's data/spend its money" separate
You can totally write a program that owns an account, and mutates that account/spends that account's money without needing any signature
But this is just because the system program happens to be written that way
Yes‚Äîbut only because the system program happens to be written in such a way that it won't spend your account's money unless the address signs
Why is this not the same thing? If I have 1 SOL in my account and I want to send it to you, don't I need to sign that transaction?
Whether you need to sign for that address depends on what you're doing‚Äîfor instance, you need to sign for the address when you create an account there
The private key is relevant for signing for that address (not the same thing)
Nope
> Ah, .owner on an AccountInfo means the program owner of an account, the one and only program that's allowed to mutate that account's data or spend its money

Isn't that what the private key is for?
That's unfortunately totally different from the idea of a "logical owner" etc., like for a token account (solana names are generally kind of terrible lol)
Ah, `.owner` on an AccountInfo means the *program* owner of an account, the one and only program that's allowed to mutate that account's data or spend its money
Is this effectively a replacement for the account's keypair?
If I change the owner to the PDA, or another keyPair, can that keyPair sign obo this account?
This snippet:

```
const payer = anchor.web3.Keypair.generate();
    await helpers.airdropSol(payer, program.provider.connection);
    
    let accInfo = await anchor.getProvider().connection.getAccountInfo(payer.publicKey);

    assert.ok(accInfo);
```
In the debugger:
```
accInfo
{data: Buffer(0), executable: false, lamports: 2000000000, owner: PublicKey, rentEpoch: 0}
accInfo.owner
PublicKey {_bn: BN}
accInfo.owner.toString()
'11111111111111111111111111111111'
```
The owner is the System Program. Can the system program sign obo the this account?
Haha okay I'll make a PR if I can üò¨ for now will just pass in a redundant data I guess
Or make a PR
Can't remember, it may have used to work but accidentally stopped‚Äîbasically just pass in the mint üòõ
What do you mean by owner/authority here?
yeah ikr, there should be something like this. Do you mean this feature was added but not working yet?
üëã For a given acct, what is the relationship of its private key/key pair vs. the owner/authority?
I think this should work but currently doesn't :/
```
#[derive(Accounts)]
pub struct DepositTokens<'info> {
    #[account(init, payer=depositor, token::mint=mint, token::authority=depositor, space=16)]
    pub deposit_token_account: Account<'info, token::TokenAccount>,
    pub depositor: Signer<'info>,
    pub vault: Account<'info, Vault>,
    #[account(key=vault.mint)]
    pub mint: Account<'info, token::Mint>,
    pub token_program: Program<'info, token::Token>,
    pub system_program: Program<'info, System>,
}
```

Can I do something like the above, where the `mint` account gets populated automatically from the `vault.mint ` (whose type is Pubkey)? i.e. so that the user doesn't have to send the `mint` account for this instruction?
any ideas / resources on how to design cranks around this btw? i.e. make it permissionless as much as possible for anyone to be able to call this function, while still keeping it secure?
ohh this looks quite nice, let me try it out!!
hmm got it. thx a lot! üôÇ
Yeah, you'd have to make sure you're really invoking what you want to invoke (e.g. sign the request with an admin pubkey, or whatever)
so i guess one would have to make some checks on the instruction
Yucky, but you can do this kind of thing:
```.rs
pub fn pull_strings(ctx: Context<PullStrings>, data: u64) -> anchor_lang::Result<()> {
        let cpi_program = ctx.accounts.puppet_program.to_account_info();

        let cpi_accounts = puppet::cpi::accounts::SetData {
            puppet: ctx.accounts.puppet.to_account_info(),
            other_account: ctx.accounts.signer.to_account_info(),
        };

        use anchor_lang::InstructionData;
        let hmm = puppet::instruction::SetData { data: data };

        let ix = Instruction {
            program_id: cpi_program.key(),
            accounts: cpi_accounts
                .to_account_metas(None)
                .into_iter()
                .map(|mut meta| {
                    if meta.pubkey == ctx.accounts.signer.key() {
                        meta.is_signer = true;
                    }
                    meta
                })
                .collect(),
            data: hmm.data(),
        };

        invoke(
            &ix,
            &[
                ctx.accounts.puppet.to_account_info(),
                ctx.accounts.signer.to_account_info(),
            ],
        )?;

        Ok(())
    }
```
this could introduce serious serious injection attacks in general though, right?
Got it. I guess if you absolutely had to create an account in the client, the best way would be to set the owner/authority as the PDA - that way only the program itself can sign on behalf of the account. Could the keypair still be used to mutate the account data (after the PDA has been assigned as the authority) ?
Is there a way to limit the supply of an SPL token? Not seeing anything on the `createMint` function call:

```
/**
   * Create and initialize a token.
   *
   * @param connection The connection to use
   * @param payer Fee payer for transaction
   * @param mintAuthority Account or multisig that will control minting
   * @param freezeAuthority Optional account or multisig that can freeze token accounts
   * @param decimals Location of the decimal place
   * @param programId Optional token programId, uses the system programId by default
   * @return Token object for the newly minted token
   */
  static async createMint(
    connection: Connection,
    payer: Signer,
    mintAuthority: PublicKey,
    freezeAuthority: PublicKey | null,
    decimals: number,
    programId: PublicKey,
  ): Promise<Token> {
```
The project-serum multisig has an example of invoking a serialized instruction: https://github.com/project-serum/multisig
As long as you can turn it into an `Instruction`, then you can call `invoke_signed` on it
can it be some sort of serialized transaction that I send to the deriving program? or would i have to implement all the program-logic within the program?

to give some contect: I am trying to integrate the jupyter exchange. They don't have any on-chain SDK. they do have an off-chain SDK which returns instructions. 

I asked in their discord, and they said that it is possible to make the program sign these transactions
Yeah, probably. Also, if you create it on the client then you're apparently creating a whole bunch of them (one every time any client runs)
Is it safe to say that if we care about a keypair, we should never be creating it in the client code?
Basically, the only possible way to sign for a PDA is with `invoke_signed`
Store it someplace safe basically üòõ (Not on the client)
In the case where the keypair is relevant, what are best practices to keep this secure? feel free to point me to code snippets
Only the deriving program can sign for a PDA, so you'd ultimately need to send the instruction to the program and have it use invoke_signed on it
is it possible to sign an instruction, that had been created off-chain, by a PDA?
Hmm, yeah, that's a pretty low-level solana error. Are you invoking your contract in a funny way or something?
"Transaction failed to sanitize accounts offsets correctly implies that account locks are not taken for this TX, and should not be unlocked." What does that even mean ha..
Usually you sign once to create the account, and then subsequently the keypair is kind of irrelevant (again, unless your program does care for some reason about signatures from that address‚Äîin which case the keypair is indeed relevant)
But even if someone did know that keypair, it's probably not a big deal since once you sign for the account creation, you probably don't need to sign for that address again (probably, depends on what you're doing I guess)
But yeah, the client itself could maybe go figure it out somehow
You're generating that keypair from scratch in the client, so it'll be fresh every time
Ah makes sense. Slight follow up:

If I keep the keypair in my client code like so: `const mintAccount = Keypair.generate();` is this secure? How can I ensure that no one has access to this keypair?
(When you create an account that lives at a PDA, the program itself signs rather than the client)
Whenever you create an account, its address always needs to sign in solana
cuz I dont think your code has signed the transaction, prob you can use this api instead of the last 2 lines
```
await sendAndConfirmTransaction(program.provider.connection, transaction, [walletKeyPair])
```
Does the `mintAccount` also need to sign this transaction? How is that the case when we are just creating the account?
```
const [connection, provider] = await getProvider();
const program = new Program(idl, programID, provider);
const currentWallet = provider.wallet;

const walletPubKey = provider.wallet.publicKey;

enqueueSnackbar(`Creating a new mint..${provider.wallet.publicKey}`);

const mintAccount = Keypair.generate();
const transaction = new Transaction();
transaction.feePayer = walletPubKey;

const token = new spl.Token(
  connection,
  mintAccount.publicKey,
  spl.TOKEN_PROGRAM_ID,
  walletPubKey,
);

const balanceNeeded = await spl.Token.getMinBalanceRentForExemptMint(
  connection,
);

transaction.add(
  SystemProgram.createAccount({
    fromPubkey: walletPubKey,
    newAccountPubkey: mintAccount.publicKey,
    lamports: balanceNeeded,
    space: spl.MintLayout.span,
    programId: spl.TOKEN_PROGRAM_ID,
  }),
);

let signature = await program.provider.send(transaction);
let confirmation = await connection.confirmTransaction(signature);
```
Why is this giving me `Signature verification failed`?
this means I cannot rely on the `mpl-action-house` lib I suppose right
Ah, ok. You're going to have to figure out how to invoke that CPI and tweak the AccountMeta for that account so that it declares itself as a signer
yea so the handler accept > 1 accounts to be signer and depends on whose signer the account state changes will be different, one of the signer checks is here https://github.com/metaplex-foundation/metaplex-program-library/blob/master/auction-house/program/src/lib.rs#L905
Where does it end up requiring that thing to be a signer? Like, what goes wrong when it's not a signer?
https://github.com/metaplex-foundation/metaplex-program-library/blob/master/auction-house/program/src/lib.rs#L1070 here
I get: "Transaction failed to sanitize accounts offsets correctly"

when trying to run an instruction to a program I deployed to devnet

---
does anyone have any pointers on where to look?
How is it expecting that account to sign then?
It doesn't have a signer annotation?
the counterpart ctx for that rpc is declared as `UncheckedAccount`
*then* the signature will carry over
The program you're calling needs to declare that it wants that account to sign
but I also thought your statement was true.... cuz otherwise how do we carry the user's sig
Yeah, hmm, I guess I was just wrong about that this whole time! Shoot, my bad.
Interesting... yeah, I was like 99% sure that the signature carried over, but looks like it doesn't! I wonder if this changed in solana recently? Huh.
Hi alan, I just tried this doesnt seem to be the case, so I did
```
        let cpi_program = ctx.accounts.ah_program.to_account_info();
        let cpi_accounts = Sell {
            wallet: ctx.accounts.wallet.to_account_info(),
            token_account: ctx.accounts.token_account.to_account_info(),
            metadata: ctx.accounts.metadata.to_account_info(),
            authority: ctx.accounts.authority.to_account_info(),
            auction_house: ctx.accounts.auction_house.to_account_info(),
            auction_house_fee_account: ctx.accounts.auction_house_fee_account.to_account_info(),
            seller_trade_state: ctx.accounts.seller_trade_state.to_account_info(),
            free_seller_trade_state: ctx.accounts.free_seller_trade_state.to_account_info(),
            token_program: ctx.accounts.token_program.to_account_info(),
            system_program: ctx.accounts.system_program.to_account_info(),
            program_as_signer: ctx.accounts.program_as_signer.to_account_info(),
            rent: ctx.accounts.rent.to_account_info(),
        };
        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);

        msg!("CPI");
        mpl_auction_house::cpi::sell(
            cpi_ctx,
            trade_state_bump,
            free_trade_state_bump,
            program_as_signer_bump,
            price,
            amount,
        )?;
```
in my program, where `wallet` is indeed the signer (from the context of the current handler     `#[account(mut)] pub wallet: Signer<'info>` , then I try to log
```
        msg!("wallet is signer {}", wallet.to_account_info().is_signer);
```
in the counterparty program, it says a `false`
is there anything else Im missing to persist the signer status for the account?
Hey gusy, a quick question, when a program creates a PDA it is created with the rent exception, isn¬¥t it?
i used 'avm install latest'
quite long... not sure how to fix this issue.

Haha yeah that makes sense. Thanks.
I just have a local checkout of the codebase open in vscode and use text search!
That code snippet helped so much!! Thank you üò¨ Just curious, is there any way I can search through the codebase for specific function calls as an easy way to get reference code snippets?
Can you repost more of the error message? You can use triple back-quotes, `, to format things nicer
uninstalled anchor cli uninstalled avm, installed avm again and tried installing anchor latest version, getting this error , : For more information about this error, try `rustc --explain E0061`.
error: could not compile `spl-token` due to 3 previous errors
warning: build failed, waiting for other jobs to finish...
error: failed to compile `anchor-cli v0.22.1 (https://github.com/project-serum/anchor?tag=v0.22.1#b733610d)`, intermediate artifacts can be found at `/tmp/cargo-installO3BGHn`

Caused by:
  build failed
Error: Failed to install 0.22.1, is it a valid version?
You still have to pass the optional argument, just as `null`: https://github.com/project-serum/anchor/blob/master/tests/custom-coder/tests/custom-coder.ts#L24
Hmm, this is the IDL of that function

```
{
      name: "initializeMint";
      accounts: [
        {
          name: "mint";
          isMut: true;
          isSigner: false;
        },
        {
          name: "rent";
          isMut: false;
          isSigner: false;
        }
      ];
      args: [
        {
          name: "decimals";
          type: "u8";
        },
        {
          name: "mintAuthority";
          type: "publicKey";
        },
        {
          name: "freezeAuthority";
          type: {
            coption: "publicKey";
          };
        }
      ];
    }
```

So I added the other two args

```
tx = await tokenProgram.rpc.initializeMint(
      9,
      solvaultProgram.provider.wallet.publicKey,
      {
        accounts: {
          mint: mintAccount.publicKey,
        },
      }
    );
    console.log(tx);
```

But it's still failing with the same error. Any clues?
Kind of tricky error message, but I'm guessing you need to pass some extra arguments to that call, `initializeMint(something, somethingElse, { ... })`
how do I handle this
Ah, ok, bummer‚Äîyou unfortunately will probably have to pick just a single version :/
Hi,

I'm trying to create a mint account from anchor JS api, using the following code

```
tx = await tokenProgram.rpc.initializeMint({
      accounts: {
        mint: mintAccount.publicKey,
      },
    });
    console.log(tx);
```

But it's failing with the error
```
     Error: Invalid arguments: mint not provided.
```

What am I doing wrong?
Yeah. new_with_signers is for adding PDA signatures
and in the course of the CPI call, I can keep adding sigs with pda right?
Yep looks like there are two versions of anchor-lang in the cargo.lock file
The user's signature will indeed persist across the call
Hi there, is it possible to use user as signer when doing CPI call?
```
 let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
```
something like this already assumes the user's signature shall persist?
You can check by looking through your Cargo.lock file
Annoying trait errors like this can happen when you have multiple versions of anchor-lang floating around... is that possible here?
Can see an example here: https://github.com/cqfd/anchor-token-studies
https://github.com/jet-lab/jet-v1/blob/bd97a032b38f81ec4d76deae2246de755464fa27/programs/jet/src/instructions/borrow.rs#L99 maybe you can have a look at this
afaik gemfarm doesn't mint spl tokens but distributes deposited spl tokens, so you might not find what you are looking for there
I'm getting this error on .data() and it suggests to use anchor_lang::InstructionData despite me adding use anchor_lang::InstructionData which shows up as an unused import below weirdly. Any idea on why this is happening?```error[E0599]: no method named `data` found for struct `instruction::SwapTransitive` in the current scope
   --> programs/src/instructions/liquidate.rs:282:10
    |
282 |         .data(),
    |          ^^^^ method not found in `instruction::SwapTransitive`
    |
   ::: /.cargo/registry/src/github.com-1ecc6299db9ec823/anchor-lang-0.19.0/src/lib.rs:205:8
    |
205 |     fn data(&self) -> Vec<u8>;
    |        ---- the method is available for `instruction::SwapTransitive` here
    |
    = help: items from traits can only be used if the trait is in scope
    = note: the following trait is implemented but not in scope; perhaps add a `use` for it:
            `use anchor_lang::InstructionData;`

warning: unused import: `anchor_lang::InstructionData ```
Hello, I'm trying to implement instruction introspection in anchor.
I'm getting this error when I try to define account:
```
the trait bound `Instructions: anchor_lang::prelude::SolanaSysvar` is not satisfied
the trait `anchor_lang::prelude::SolanaSysvar` is not implemented for `Instructions`
```

Part of the program:
```
use anchor_lang::prelude::{*, Instructions};

#[derive(Accounts)]
pub struct Foo<'info> {
  instructions: Sysvar<'info, Instructions>
}
```
my program has mint authority over an spl token and I want to mint a certain amount to the user. been looking in the gemfarm codebase but can't find the exact piece where it mints the reward tokens
where can I find an example implementation of minting an spl token to a target address? how can I do that?
nvm, missing bump in seeds, if someone interested on solution:

```pub fn withdraw_fee_spl_instruction(
  ctx: Context<WithdrawFeeSPL>,
  _bump: u8,
  amount: u64,
) -> Result<()> {
  msg!("Withdrawing {} tokens from fee account to {}...", amount, ctx.accounts.destination.key());
  return transfer(
    CpiContext::new_with_signer(
      ctx.accounts.token_program.to_account_info(),
      Transfer {
        from: ctx.accounts.fee_treasury_ata.to_account_info(),
        to: ctx.accounts.destination_ata.to_account_info(),
        authority: ctx.accounts.fee_treasury.to_account_info(),
      },
      &[&[b"fee_treasury_spl".as_ref(), ctx.accounts.authority.key().as_ref(), &[ctx.accounts.fee_treasury.bump] <---- HERE]],
    ),
    amount,
  );
}```
Hey guys!

Im trying to transfer SPL Token from ATA which owns my PDA to Destination ATA

```#[derive(Accounts)]
#[instruction(_bump: u8, amount: u64)]
pub struct WithdrawFundsSPL<'info> {
  #[account(
    mut,
    seeds = [
      b"funds_spl".as_ref(),
      authority.key().as_ref(),
    ],
    bump = _bump,
    has_one = authority,
  )]
  pub funds: Account<'info, FundsSPL>,

  #[account(
    mut,
    associated_token::mint = mint,
    associated_token::authority = funds,
  )]
  pub funds_ata: Account<'info, TokenAccount>,

  pub mint: Account<'info, Mint>,

  #[account(
    init_if_needed,
    payer = authority,
    associated_token::mint = mint,
    associated_token::authority = destination,
  )]
  pub destination_ata: Account<'info, TokenAccount>,

  /// CHECK: Destination Account for Withdraw Funds
  pub destination: AccountInfo<'info>,

  #[account(mut)]
  pub authority: Signer<'info>,

  pub rent: Sysvar<'info, Rent>,

  pub token_program: Program<'info, Token>,

  pub associated_token_program: Program<'info, AssociatedToken>,

  pub system_program: Program<'info, System>,
}```

```pub fn withdraw_funds_spl_instruction(
  ctx: Context<WithdrawFundsSPL>,
  _bump: u8,
  amount: u64,
) -> Result<()> {
  return transfer(
    CpiContext::new_with_signer(
      ctx.accounts.token_program.to_account_info(),
      Transfer {
        from: ctx.accounts.funds_ata.to_account_info(),
        to: ctx.accounts.destination_ata.to_account_info(),
        authority: ctx.accounts.funds.to_account_info(),
      },
      &[&[b"funds_spl".as_ref(), &ctx.accounts.authority.key().as_ref()]],
    ),
    amount,
  );
}```

Gives me following error:
```PDA: Gp4zKwwvBRRGm2i7NTsLvFGTXaB8wYfHgffAJd4S4jYd
PDA ATA: 3SxUZCzoWpk6pvLKZe4BPnXPa5SwjX24txnZZQMDY9k5
Destination ATA: 8ZRqhf1GBCpVaRBCHEtJCQHRpc9y68U7jC5qtAssQ45D

Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account
    Program 8jUjUFViwpU8kbAxuw8RS7W5qh4NzzwfqJLyDpnyXZwj invoke [1]
    Program log: Instruction: WithdrawFundsSpl
    Gp4zKwwvBRRGm2i7NTsLvFGTXaB8wYfHgffAJd4S4jYd's signer privilege escalated
    Program 8jUjUFViwpU8kbAxuw8RS7W5qh4NzzwfqJLyDpnyXZwj consumed 38462 of 1400000 compute units
    Program 8jUjUFViwpU8kbAxuw8RS7W5qh4NzzwfqJLyDpnyXZwj failed: Cross-program invocation with unauthorized signer or writable account```
Thanks! I was miss understand about Signer.
It works beautifully, Thank you. üëç  üôè
You would have to just include a `Signer<'info>` account in your derive(Accounts) block.
But yeah, only your program can init an account at one of its PDAs, since only your program can sign for the address. So if you happen to know that your program enforces the kind of invariant above, then maybe you can skip the `constraint =` one.
Strictly speaking those constraints are totally independent of each other. The seeds one only affects the address (anyone can submit an address with the right seeds from the client), while the other one affects the account itself (only your program can write to that account).
Another question, is it ever possible for something other then the program to create a PDA in the same structure as the programs PDA  and used in the program as a PDA? My initial guess is that its not possible
Is there any value in adding a constraint for a value that is also used in the seeds for a PDA?

For example in this PDA `user_position.dca_period_id_before_deposit` is used in the seeds, but its also checked again in a constraint, seems like I dont need the additional constraint?
```
    #[account(
        has_one = vault,
        seeds = [
            b"vault_period".as_ref(),
            vault.key().as_ref(),
            user_position.dca_period_id_before_deposit.to_string().as_bytes().as_ref(),
        ],
        bump = vault_period_i.bump,
        constraint = vault_period_i.period_id == user_position.dca_period_id_before_deposit
    )]
    pub vault_period_i: Box<Account<'info, VaultPeriod>>,
```
Can I ask a simple question? 
I want to work the function by only specific users pool. 
How could get a pubkey of the contract method caller from outside (for example test program ) in the contract function? 
Passing user's pubkey by function parameter is not good idea.  
Is there a solution for this case? 
Thanks.
If so, whats the standard practice for handling this use case., Thanks
Hey guys, is there a way to resize a `#[account]` later on down the track after its been created and used and then needs to change?
nothing complicated, literally just building on the front end provided here: https://www.brianfriel.xyz/learning-how-to-build-on-solana/
where are you seeing this has happened to others?
Hmm, seems like this has been happening to other people, I'm not sure what the fix is supposed to be
Are you doing anything tricky with your bundling etc.?
when I do that I get:
```
 `VM82:1 Uncaught ReferenceError: spl is not defined
    at <anonymous>:1:1
```
I wonder what the issue is here
Thanks <@!134416332509675520>
My mistake.
I thought adding it to the `signers` array sufficed; I guess without modifying the struct it gives me that unknown signer error.
Ah. That's why.
So mark it as `that_account: Signer<'info>`
If it's a system program account then yeah, it needs to sign
So does it not need to sign? If it's sending sol then it probably needs to sign!
The account asking to mint tokens, and sending SOL in exchange. Similar idea to bass581's.
Nope.
The mint authority?
It is the minter here.
Are you creating an account there?
Ah, ok, so what is that account for? Do you actually need to sign for it for some reason?
Nope. A dummy account made with a generated keypair.
Which account? A PDA?
You would need to create a separate account (don't send sol to a program_id account, you can't get it back as far as I know!)
Done. Turns out it was the account I first suspected it would be, but that was an unknown signer when I added it to `signers` for some reason.
Hey everyone. I‚Äôm trying to develop an exchange type of program where a user can pay for tokens with SOL and vice versa. I was wondering, can an executable account receive SOL, or would I need to make a separate account to receive it?
Log them as `theAddress.toString()`
Tried that; none of them match, though I think I might be logging them incorrectly given the difference in length between these and the ones in the program logs.
Basically you just need to figure out what account isn't signing (e.g. try logging all of the account addresses in JS if you have to)
What is that instruction doing? Minting some tokens? Or doing a transfer?
Same seeds and bump as I successfully used earlier in a `new_with_signer` call. The format might be different here, but I assumed that if it were, I 'd get a type error instead of no effect.
Can you post how you're doing the `invoke_signed` part?
Do you know which account is 8YcM... ?
Added; I now have this error due to escalated signer privilege. Signing in the program with the mintHandler PDA using `invoke_signed` has no effect, and signing from the client with the test user initiating the transaction yields an unknown signer error.
Hmm, weird, what happens if you do `import * as spl from "@solana/spl-token";` and then use `spl.TOKEN_PROGRAM_ID`?
^ I can even click through the definition. the solana/spl-token is sitting in my `node_modules`...
In the browser console, I'm seeing:

```
TOKEN_PROGRAM_ID
VM2276:1 Uncaught ReferenceError: TOKEN_PROGRAM_ID is not defined
    at eval (eval at transferOwnership (Main.jsx:34:1), <anonymous>:1:1)
    at transferOwnership (Main.jsx:34:1)
```
üëã I've got an import in my javascript file: `import { TOKEN_PROGRAM_ID, AccountLayout, u64, Token, MintLayout } from "@solana/spl-token";`

In `package.json` I have

```
{
  "name": "app",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@material-ui/core": "^4.12.3",
    "@material-ui/icons": "^4.11.2",
    "@project-serum/anchor": "^0.16.1",
    "@solana/wallet-adapter-base": "^0.6.0",
    "@solana/wallet-adapter-material-ui": "^0.12.1",
    "@solana/wallet-adapter-react": "^0.12.0",
    "@solana/wallet-adapter-react-ui": "^0.4.1",
    "@solana/wallet-adapter-wallets": "^0.10.0",
    "@solana/web3.js": "^1.29.0",
    "@solana/spl-token": "^0.1.8",
    "@testing-library/jest-dom": "^5.11.4",
    "@testing-library/react": "^11.1.0",
    "@testing-library/user-event": "^12.1.10",
    "notistack": "^1.0.10",
    "react": "^17.0.2",
    "react-dom": "^17.0.2",
    "react-scripts": "4.0.3",
    "web-vitals": "^1.0.1"
  },
  "proxy": "http://localhost:3001",
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}
```
Does anyone know any examples with spl token staking using Anchor?
Ah. Thanks; trying that now.
In solana, whenever you do a CPI (here, to the system program), you need to *also* pass in that program itself as an account
So add a `system_program: Program<'info, System>` to your declare(Accounts)
(It has the zero address)
Oh, sorry, different problem‚Äîyou actually need to pass in the system_program as an account from the client

Post the transfer code and it'll probably be clear
Nothing got autofilled per-se, but if you have some `Pubkey` in a struct that you never initailized, it'll be the zero address
I don't think I ever explicitly used the zero address, and if it was used by `anchor_lang::solana_program` when I called it, I might want a way to make it not unknown anymore?
Best explanation is always jumping to source üòõ https://github.com/project-serum/anchor/blob/master/ts/src/provider.ts#L92
how does that get the wallet/user to sign?
But here you'd use `program.provider.send(theTx)`
https://github.com/solana-labs/solana-program-library/blob/master/token/js/src/actions/createMint.ts#L41
Yeah, it's kind of dumb but that's the current situation.
Also, got an example of submitting the tx directly?
you are saying that I need to repeat all of the following:

```
static async createMint(
    connection: Connection,
    payer: Signer,
    mintAuthority: PublicKey,
    freezeAuthority: PublicKey | null,
    decimals: number,
    programId: PublicKey,
  ): Promise<Token> {
    const mintAccount = Keypair.generate();
    const token = new Token(
      connection,
      mintAccount.publicKey,
      programId,
      payer,
    );

    ...

    return token;
  }
```

in my own javascript call? There's no other abstraction or method that wraps this?
Try jumping to source on that createMint call
any examples on 1/ recreating the instruction? and 2/ submitting a tx directly?
This is super irritating, but you actually need to just basically re-create the instruction issued by the `createMint` call, and submit a tx yourself
üëã I have a js code snippet that looks like:

```  
const wallet = useAnchorWallet();

async function setupTest() {
    const [connection, provider] = await getProvider();
    const program = new Program(idl, programID, provider);
    const currentWallet = provider.wallet;
 
    const walletPubKey = provider.wallet.publicKey;
    
    enqueueSnackbar(`Creating a new mint..${provider.wallet.publicKey}`);

    const mintA = await Token.createMint(
      program.provider.connection,
      wallet,
      walletPubKey,
      null,
      0,
      Token.TOKEN_PROGRAM_ID
    );

    const mintATokenAcct = await mintA.createAccount(walletPubKey);

    // doesn't work on devnet for some reason...
    // const airdropTx = await program.provider.connection.confirmTransaction(
    //   await program.provider.connection.requestAirdrop(wallet, 10000000000),
    //   "processed"
    // );

    let acct = await program.provider.connection.getAccountInfo(walletPubKey);

    enqueueSnackbar(`Done testing`);
  }
```
In the await `Token.createMint` call, the second argument is a `Signer`. How can I get my wallet to sign this transaction? Normally I'd pass a keypair through in my program tests, but struggling to figure out how i can do the same thing via a wallet signing
Doesn't seem like the airdrop works, the wallet balance stays constant. Is there a limitation around airdropping on devnet?
Have this snippet running on devnet:

```
const [connection, provider] = await getProvider();
    const program = new Program(idl, programID, provider);
    const wallet = provider.wallet.publicKey;
    
    enqueueSnackbar(`Airdropping a couple tokens to..${provider.wallet.publicKey}`);

    const airdropTx = await program.provider.connection.confirmTransaction(
      await program.provider.connection.requestAirdrop(wallet, 10000000000),
      "processed"
    );
```
Does this mean I failed to specify a required address and it got autofilled?
(Amusingly, in base58 zero prints as 1 ü§¶‚Äç‚ôÇÔ∏è)
Yep, that's the zero address
I tried to involve SOL transfers in my program, and got this error. Any idea why an account full of 1's was referenced? Some kind of default ID?
or `anchor deploy` getting this rpc request error?

```
Error: RPC request error: cluster version query failed: error sending request for url (http://0.0.0.0:8899/): error trying to connect: tcp connect error: Connection refused (os error 61)
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.
```
is there any reason, besides having a sporadic connection that `anchor test` wouldn't be able to periodically get the blockhash
ahh annoying, Ill stick to using spl-token then
Not as far as I know (all token stuff, more or less, goes in the spl library)
or is there an equivalent function to check if a token account exists and another to create one?
Nope
Hi, slightly related to this. I've been using `getOrCreateAssociatedTokenAccount` from `solana/spl-token` is there an equivalent to this in web3.js? It'll just be less things for me to import
You actually can't add solana-sdk as an on-chain dependency‚Äîit's only for use off-chain.
Yep, you can use `connection.getTokenAccountsByOwner`
Got this error when adding `solana-sdk` as a dependency. Any idea what's happening here?
üëã in web3.js is there a way to get all token accounts owned by a particular publicKey?
don't know whats worse having this in the test script or leaving the hardcoded keypair  üòÖ
had to copy paste this ```export default class NodeWallet implements Wallet {
  constructor(readonly payer: Keypair) {}

  static local(): NodeWallet {
    const process = require("process");
    const payer = Keypair.fromSecretKey(
      Buffer.from(
        JSON.parse(
          require("fs").readFileSync(process.env.ANCHOR_WALLET, {
            encoding: "utf-8",
          })
        )
      )
    );
    return new NodeWallet(payer);
  }```
and change ANCHOR_WALLET to MY_CUSTOM_ENV_VAR. Is there a function like NodeWallet.local() but can take in other env variables? I think it would be nice so people don't need to copy paste this json parsing part.

why is that happening
unable to resolve dependency tree
`MY_CUSTOM_ENV_VAR=path/to/some/wallet anchor test` and then go use `process.env` to make that keypair in your program
At any rate, you could always just use your own env variable
It's 100x easier than trying to rely on devnet
Oh‚ÄîI would 1000% recommend doing your testing locally
hmm last time I tried I kept on getting rate limited
```.js
await program.provider.connection.requestAirdrop(
      someUser.publicKey
      2 * anchor.web3.LAMPORTS_PER_SOL
    );
```
What trouble?
ya I need them to be specific, cause I've had some trouble airdropping
ohhh
`const someUser = anchor.web3.Keypair.generate();`
I'm saying just generate fresh ones‚Äîor do you specifically need them to be certain keypairs?
is there like some env variable or something where I can store them?
ya but I dont want to hardcode those keypairs in my test script
I would probably just make some fresh keypairs in the tests and then airdrop them some sol
Is the goal just to have some user wallets in your tests?
But using the signers and bump in `new_with_signer` fixes this error; I can dispense with the program ID being used in the seeds accordingly
?
Ah, ok, maybe that env var just doesn't do what you want
Guess I could have just dispensed with that.
hmm now im just getting `Error: Program's authority Some(2QqWUAdCfvbwVnkwSaVePnD5E5xpevZWo734JMqpY1eB) does not match authority provided 45vmGc9sVW52Tb4F77Xt3X5Ft1PVSzS3HAyno2E166zN` It has the same effect of changing the wallet address in anchor.toml
This was why.
Ah. Was unaware of that.


//////////////////////////////////////////////////////////////////////////////////////////

Good day! Is there a way to check which program called you?
sweet, I am using `to.be.rejected` in my Hardhat testing. Didn't notice that it is also awailable for Anchor testing.
Hello,
I am trying to create an account where to store some data. The thing is that I want to be used just by the connected wallet and even to encrypt the data stored. 
I am new to this and I imagine that I need the secretKey of the connected account, but that is not possible right ? 
Do you guys have any suggestions ?
Changing the owner of an ATA is pretty yucky, since you generally really expect person P's mint M ATA to be owned by person P. So I would rather transfer.
Also, what is the best practice for locking NFTs ? 
1) Changing ownership of user ATA to PDA
2) Transferring NFT from user ATA to PDA ATA
Ahhh ok
Can't do randomness on-chain like that, you'd have to use an oracle or something

how to fix deploy error?
hey, how can I fix this?
Please don't at-message unless it's really urgent üôè These are general rust questions that are probably best learned about by googling
Hi Team. I am planning to use Bonfida vesting program in my program. Any idea how I can make CPI calls to bonfida vesting contract without putting all of the bonfida program in my programs folder as puppet.
I'm using https://www.chaijs.com/plugins/chai-as-promised/ . It has `to.be.rejected` and `to.be.rejectedWith()` assertions
`#![deny(missing_docs)]
#![cfg_attr(not(test), forbid(unsafe_code))]`
what does that mean? Please explain. <@!252808943238119424> <@!831450660146642974>
does someone have an example on how to check for errors in a test case? I am using `expect(await .....).to.throw(AnchorError)` but the case is still marked as failed
correct ser
`Halted` is your custom error varient right?
gm, spot on. access control modifier validates a state property (in this case, `is_halted`, a bool representing a halted flag) is not true, and if it is it will throw the `Halted` error
look at the size of the .so, then solana rent <size-of-the-.so>, should be close
kind of
yes
Is there a way to know the deployment cost beforehand?
Hey guys! Is there any known way to generate typescript code from an IDL?
can confirm form here, `if http://state.is_halted { return Err(ErrorCode::Halted.into()); }` though <@!848333406849073202> could confirm more
It's just an error variant
Could you explain what the require!(!state.is_halted, Halted) part means? Specifically how to read/interpret the syntax, and what "Halted" is referring to?

From this thread
https://twitter.com/0xDEADBEEFx/status/1486331068085157894
how can i get the transaction id of a transaction that just happened?
the new version of anchor use Result<()>, I thkn the main reason here would be error-redesigning. 
https://github.com/project-serum/anchor/pull/1462
found a good one, Jet Protocol 
https://github.com/jet-lab/jet-v1
you need to include `use std::str::FromStr;`
hey, what's the problem here?
what's difference between `ProgramResult` & `Result<()>` ? 
<@!401712056543477761> <@!717956950737813594>
I saw an escrow program in the tests directory on the anchor github repository
found this one https://github.com/QuarryProtocol/quarry
I think you are asking about CPI? Those sort of actions are controlled by different programs, so you need to invoke them inside your own program to do that, that is called Cross-Program Invocation. There is a section in the book
What are some of the projects on Solana that use Anchor and are open source? I tried looking at Solend, but it looks like they're using vanilla Solana
that's what i thought too, but someone in another discord said that i'd hit compute limit after just a few "guests", but i don't know enough to confirm. üòÇ i think for now i will just set a `max_guests` or something on Party, so at least whoever creates one can control how much space to allocate. and just do the Vec<Pubkey> thing. this is just a toy app to learn anyway, thanks for rubber ducking with me though!
Not great/maybe super inefficient though.
And then filter etc.
Definitely not in the contract itself, but you can kinda do that on the client, using `program.account.books.all()` (hacky)
yep that's what i did initially. and then i got stumped because i realized you couldn't call smth like `author.books`  anywhere
Yeah, I guess it depends on what kind of access patterns you need. The literal translation of the diagram above would be to have each of the "many" accounts have a `Pubkey` that points at the account that "has" them.
most examples i run into are basically just storing all references in a Vec (https://imfeld.dev/writing/starting_with_solana_part04), or just as Pubkeys if it's just two addresses like in a typical escrow (https://paulx.dev/blog/2021/01/14/programming-on-solana-an-introduction/). so wasn't sure if that's just how it's done
yeah, basically. just not sure how to do in an anchor program since you have to pass in all accounts to transact. i thought maybe i could do some kind of client filter, but that's probably not very secure and i was told that it would take up too much compute anyway.
Do you want literally this kind of structure? https://guides.rubyonrails.org/association_basics.html#the-has-many-association
does anyone have any tips on how to model a "has many" relationship in Solana? i have a "Party" PDA, and a Party can have many "Guests." I could just store a Vec<Pubkey> in Party ... but that seems inefficient to have to pre-allocate that space (when i might not need it), and also just seems weird, at least from rel db perspective
I have a question for you guys ! I play a lot with anchor and i know how to store String integer etc but how can i manipulate real SOL. For example stake sol or juste create a smart contract that do something like  a escrow ? I didn't find doc that talk about transaction in smart contract.
I assumed partialSign had to be done first, and sign could then be done to finish. Just the reverse lol
For search purposes, ^ may help someone encountering `Signature verification failed`
<a:ScreamsExternally:469513828191961098>
Omfg sign obliterates existing signatures and partialSign doesn't
No, only the program can initialize an account there, because only the program can sign for that address
Is it possible to "squat" on PDAs? For example my program has an `initialize` instruction that creates a PDA  with seeds `["manager", caller.key()]`.
Can someone initialize that PDA in advance and prevent that caller from using the program?
You've done it again, that fixed it. Thanks!
No mutation
It gives you an *additional* byte
Oh, sorry, no, that's not how it works
`&[that_pubkey.as_ref(), &[the_bump]]`
That's how the bump is found, but you need to pass it separately‚Äîyou're mutating the rest of the seed
That way of passing/setting the bump almost definitely looks wrong to me‚Äîwhy are you setting seed_with_bump[31] = bump?
Are there any best practices or guidance for when to use a PDA vs a keypair for an account for your program to use?
Yeah I just tried it, doesn't seem to work. Not a big deal
damn I was afraid of this lol. Ty Ty
Checked Anchor docs and they don't explicitly say you can custom error with seeds check. But there are custom errors for other constraints using the @ symbol. I'd give it a shot with seeds and test to see what happens https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html
Don't think so, not as far as I can tell
No, no fancy way to do it as far as I'm aware. You'd have to either morph one context into the other (possibly painful), or just make a helper function that takes the common arguments and invoke it from both places, etc.
Hey all. If I wanted to re-use a function between two different Contexts, how would I do it? Currently using `impl` for one Context but not sure how I can re-use that in the same main function since it takes in a single Context<type>. 

i.e. `pub fn approve(Context<Approve>)` and `pub fn pay Context<Pay>` have nearly the same logic. Both need to transfer using the same accounts `from`, `to`  `authority` and `program`. 

Am I supposed to write a ::try_into() or something for both functions? Is there a way to do some kind of generic Context that works for only those two types?
How would one maintain a 1 to 1 relatinship across programs and their accounts?
Is there a way to return a custom error if a seeds constraint is violated?
I have a question for you guys ! I play a lot with anchor and i know how to store String integer etc but how can i manipulate real SOL. For example stake sol or juste create a smart contract that do something if we pay etc ? I didn't find doc that talk about transaction in smart contract.
sweet will do, thank u ser
I would try searching the anchor repo for examples, you actually have to pass a full "AccountMeta", not just a pubkey: { pubkey: theAddress, isWritable: ..., isSigner: ... }
Ah, no, I think you'd want to use the `.remainingAccounts([...])` API
passing in remaining_accounts like this btw

await program.methods
      .play(
       bump,
      'test',
      entryFee,
      rpbpTreasuryBump
      )
      .accounts({
          wallet: player7Wallet.publicKey,
          rpbp: rpbp,
          rpbpFeeAccount,
          rpbpTreasury,
          authority,
          instructionSysvarAccount: SYSVAR_INSTRUCTIONS_PUBKEY,
          systemProgram,
          time: SYSVAR_CLOCK_PUBKEY,
          //remaining_accounts
          playerPublicKeys,
          player2PublicKeys,
          player3PublicKeys,
          player4PublicKeys,
          player5PublicKeys,
          player6PublicKeys,
          player7PublicKeys
      });
lol no clue whats going on with formatting wth
sorry for the double ping, weird formatting issues
hey <@!134416332509675520> I see you've posed before that there are examples of passing remaining_accounts from the js side, but I havent been able to find any/a good way to parse out those remaining accounts. I've got my play handler with some logic to handle results 
I wanted to iterate the remaining_accounts so i can transfer spl or sol or whatever since I only have the publicKey info stored on my Game struct

```
pub fn play<'info>(
        ctx: Context<'_, '_, '_, 'info, Play<'info>> 
        ...
        let p_account: Vec<&AccountInfo> = remaining_accounts
                    .into_iter()
                    .filter(|r| r.key() == p.owner.key()).collect();
```
that was it, you the man!
That makes sense, I'll give that a try. Thanks!
You probably want to do `token::mint` and `token::authority`. What you have above says you want to use an *associated* token address, but you're not (ATAs are PDAs derived from the associated token program, but you're using a keypair address)
try calling provider.connection.signTransaction()
I'm building a transaction, signing it, then sending it to over the internet for someone else to sign
I don't want to rpc as I don't want to actually call the chain
yea youmight be meaning to to program.rpc or program.instruction
Mm, I think that `signers` arg just doesn't exist for `.transaction`
provider.connection.signTransaction(txn) would sign it
signatures might be null because the txn isnt executed and youre already passing the signers keypair, but youre not signing the txn by doing so
sorry not sure the context let me see
Just wanted to bump for cqfd, 0xDon, or anyone else who might know offhand why a signature isn't being added :). Thanks ‚ù§Ô∏è
my program was 0.23 but seems my avm was on 0.22.1
maybe it was avm?
wth is happening lol
Also my seed constraint error just magically disappeared...
ill give it a shot
awesome
But to close one of your own accounts, you can write an instruction and use the `#[account(close = who_to_send_the_lamports_to)` attribute over it in the derive(Accounts) struct
wanna just close it from the program, adding an ix to close something, essentially what im trying to achieve is allowing a user to create a game multiple times
yea
It's about which program owns the *account*, not about the address
PDAness isn't strictly relevant
Is there syntax for closing a PDA?
But wanted to give it a shot
Only the program that owns an account can close it
Its not so I figured it wouldnt work
Well, it depends on if its a token account
Ill add that ix
Cool cool
Ah, no
So ill need to add that fn in my program? Was using SPL
(You can't close one of your own accounts unless you specifically provide an instruction for doing so)
Ah,
Where is that createCloseAccountInstruction coming from? I guess you have a `pub fn close_account` in your program?
yea its definitely frustrating, im actually running into something similar right now lol
hmm.. I will probably need to some more time on this thing
Trying to close a PDA im assuming this is correct? But getting this:
`Error Message: 8 byte instruction identifier not provided.`
```const ix = createCloseAccountInstruction(rpbp, authority, authority, undefined, program.programId);
    const txn = new anchor.web3.Transaction();
    txn.recentBlockhash = (await provider.connection.getLatestBlockhash()).blockhash;
    txn.feePayer = authority;
    txn.add(ix);
    const txSigned = await provider.wallet.signTransaction(txn);
    const closeTxn = await provider.connection.sendRawTransaction(txSigned.serialize());
```
but the account get created but calling fetch says it doesnt
yea ive been seeing this a lot when running tests, im not exactly sure what the cause is
Aha! ty ‚ù§Ô∏è
Think you'd probably want to not use the implicit one at all (it's an optional third argument to that Program constructor)
Ty on the keypair.fromKey, that def sounds useful
How do I hook into the implicit provider that's being built when I do program = new Program(idl, programId) ?
i am not sure, it seems that nothing will happen until I just manually refresh everything. Moreover, since I am `await`ing on this function call, the only time I should see the error is when the promise will get resolved.
might be latency then
where are u getting the private key from? You can always Keypair.fromSeed or Keypair.fromKey
I think that the account is definitely being created, as proven by the fact that if I just refresh the page and fetch all the accounts, the new account comes up just fine.
Can we pass ANCHOR_WALLET into anchor not from a file referenced by an environment variable? From a security perspective, hoping to not leave a private key lying around on the file system.
no, still nothing.
provider.connection.confirmTransaction(tx, 'confirmed'); then call fetch
no, running this from a click handler from the front end
try doing this
are you running this code from a test?
ü•≤
changed my code to this:-
```

    const tx = await program.value.rpc.sendMessage(content, roomPublicKey, {
        accounts: {
            message: message.publicKey,
            author: wallet.value.publicKey,
            systemProgram: web3.SystemProgram.programId,
        },
        signers: [message]
    })

    console.log(tx);
    const messageAccount = await program.value.account.message.fetch(message.publicKey)

```
Was able to check the tx hash and It seems that the account is actually being created.
Notice that the account which I am not able to fetch is actually being created.
I found couple of interesting things
thanks for this


//////////////////////////////////////////////////////////////////////////////////////////

Ah, were you using auto bumps on non-init stuff?
i posted the log above. But I just also refactored it (by passing in the bumps as variables) to not use the auto bumps and I get about a 0.3% failure rate now instead of 5%.
Thanks you as always!
Yeah, bit more info here: https://github.com/project-serum/anchor/pull/1380
from: https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html
```
Use the seeds constraint together with bumpto create PDAs.
init uses find_program_address to calculate the pda so the bump value can be left empty.
```
nvm, I found the answer!
Hey all!

Just updated anchor, and I get an error when trying to init an account with a seed/bump. I can work around this, but I'm curious why we can't/shouldn't? It worked fine before
qq about the PDA docs here: https://book.anchor-lang.com/chapter_3/PDAs.html

```
pub struct UserStats {
  level: u16,
  name: String,
  authority: Pubkey
}
The authority would be the user the accounts belongs to.

This approach creates the following problem. It's easy to go from the user stats account to the user account address (just read the authority field) but if you just have the user account address (which is more likely), how do you find the user stats account? **You can't. **
```

couldn't you just filter on client by authority? probably be inefficient (maybe to the point of being impossible?)
how can i get slot hash of specific slot on-chain?
Anything else people do to increase the speed? Is Quicknode not fast enough?
I am using the same private RPC node for one client whose job it is to send a tx and another client whose job it is to verify the tx. Also using commitment: "proccessed"
Hey, what do people do to speed up txs
Yep, covered here: https://jstarry.notion.site/Program-deploys-29780c48794c47308d5f138074dd9838
one way to do that is to use close constraint
Is there a guide on how I can close a program and get its rent back?
Hello! Wanted to give some progress on this weird problem.. Finally I am able to fetch The account which I wanted to fetch, but I am not able to understand what is happening.. 
So the problem was here:-

I was creating a `Provider` object with  the following commitments:-
```

const preflightCommitment = 'processed';
const commitment = 'processed';
const programId = new PublicKey(idl.metadata.address);
let workspace = null;

export const useWorkspace = () => workspace;

export const initWorkspace = () => {
    const wallet = useAnchorWallet();
    const connection = new Connection('http://127.0.0.1:8899');
    const provider = computed(() => new Provider(connection, wallet.value, { preflightCommitment, commitment }))
    const program = computed(() => new Program(idl, programId, provider.value));

    workspace = {
        wallet, 
        connection, 
        provider,
        program
    };
}
```
This was actually giving the error that the account can not be fetched. 
But when I passed an empty object as the third parameter:-
```
    const provider = computed(() => new Provider(connection, wallet.value, { }))
```
i am able to fetch the account, in the correct manner, but it takes about 3-4 seconds for the changes to be reflected. Any details on what is happening here?

Try posting the program log, will have more info about where the compute is going
I have an instruction that succeeds 95% of the time. The other 5% it goes over the compute budget. There's 4 PDAs on the instruction. I'm guessing this variance is largely because sometimes it takes longer to find the PDAs (if not this what else can cause a high variance in compute?)  I'm using the new auto "bump" on my pda account specifications.  Should I be passing the bumps in from the client to reduce compute usage? If so what is the best way to do this in the most current version of Anchor ?
That one
Thanks but I don't think i was concerned about the authority variable. Its the [#account specifier that defines it as owned by the program, but is it the one on the State struct or the one on the variable state_account inside the Create struct ?
Authority is just a field, like count.
It has nothing to do with the authority. You are using "init" here, this will set the located account, here State to be owned by the program.
or this one?
so this specification defines it as owned by the program?
Program ownership is orthogonal to address stuff
The account is owned by the program because you specified its struct with `#[account]` on top
<@!134416332509675520> sorry to bug you again. Just looking for your response to my last question when you get a chance.
Yeah
the syncnative part
Can I do that from the typescript side of things?
You send actual real sol to a wrapped sol token account, and then poke the account with the syncnative instruction, so that its *wrapped* sol balance (its token balance) reflects the new native sol in the account.
It lets you convert actual real sol to "wrapped sol", the tokenified version of sol (sol is just sol, it's not an spl token‚Äîhence the idea of "wrapped sol", in case you wish sol were a token).
It's misnamed, yeah
```
// Send rent back to user if account is empty
        ctx.accounts.escrow_usdc.reload()?;
        if ctx.accounts.escrow_usdc.amount == 0 {
            let cpi_accounts = CloseAccount {
                account: ctx.accounts.escrow_usdc.to_account_info(),
                destination: ctx.accounts.user_authority.clone(),
                authority: ctx.accounts.ido_account.to_account_info(),
            };
            let cpi_program = ctx.accounts.token_program.to_account_info();
            let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer);
            token::close_account(cpi_ctx)?;
        }
```

Reference
https://github.com/project-serum/anchor/blob/master/tests/ido-pool/programs/ido-pool/src/lib.rs
If you close an account you need to be the owner. When closing an account you need to pass the "destination" account info, this account will receive the lamports of the closed accounts.
so how does account closing actually work, and which address is the sol balance sent to ? does it remember which account created it ? and upon closing transfer the balance to it or what ?
What does exactly sync-native do in the spl-token program? I don't really get the explanation that the CLI has
https://github.com/project-serum/anchor/blob/master/tests/pda-derivation/tests/typescript.spec.ts
Is there an example of this somewhere?
https://mobile.twitter.com/anchorlang/status/1491906358026907648/photo/1
Looking through the anchor tests and a bit confused when  "ctx: Context<'_, '_, '_," is needed and what it means. Could someone explain what the 3 blanks are referring to and how to interpret it? Googling says sometime about lifetimes in Rust, but I'm still confused about how to inteprete it in the Anchor programs after watching a few youtube videos about lifetimes
ah because of I forgot to update my client to 0.23.0. Thank you üòÖ
Hi, 
Is there a wait to get the transaction signature of a CPI ?
```
        let tx = anchor_lang::solana_program::program::invoke(
            &ix,
            &[
                ctx.accounts.player.to_account_info(),
                ctx.accounts.authority.to_account_info()
            ]
        ).unwrap();
```
(tx is only empty function ())
I try with newly created project and it has types. I think something wrong with our project LOL
shouldnt it be burn from? whatever prob just semantics
the to on the burn is throwing me off tho
<a:kek:886686729631825940>
that might be it lol
ope
can I ask the authority is an ATA instead of PDA?
this is normal
getting this error: ```EhvCuwkb583rS18gJ7DyDX8C8LjNBAcVHvJFEUiNuQFg's signer privilege escalated
    Program R9pH1xCAPNWcaTMggYBhduoXTTxqrtepQnHaTLjJrzT consumed 111261 of 200000 compute units
    Program R9pH1xCAPNWcaTMggYBhduoXTTxqrtepQnHaTLjJrzT failed: Cross-program invocation with unauthorized signer or writable account```
I think it has something to do with the to: field? for burn why is there a to:
trying to call burn on spl token thats owned by the PDA's token account :
```
let cpi_accounts = Burn {
            mint: mint.to_account_info(),
            to: program_fee_ata.to_account_info(),
            authority: program_fee_ata.to_account_info(),
        };
        let signer_seeds = &[&seeds[..]];
        let cpi_program = token_program.to_account_info();
        let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer_seeds);
        anchor_spl::token::burn(cpi_ctx, total_burn_fee)?;
```
I try to use `program.methods` but after my instruction the type became `any` which will lose the will of typescript is this normal?
so in the examples where you create the state account and update the counter, that is a keypair address account. But what makes that keypair account owned by the program?
No, in general you may need to do `ctx.accounts.that_account.reload()?`
How come the amount doesn't change before and after the transfer?
is: `ctx.accounts.SomeAccountName` not updated if I perform a transfer within a function?
Hmm. I didn‚Äôt realize that
the deployer would be referencing the wallet I created to deploy the program right?

am I bugging here or
Got it
You need any #[instruction(...)] thing to exactly match the order of the arguments in the actual `pub fn your_instruction` part (minus the ctx arg)
And double nope, the only way to mutate an account's data is to ask its owning program to do it‚Äîyou knowing the secret key doesn't let you edit the data however you want
Nope, the program doesn't need a signature to mutate an account it owns
if you wanted your program to modify data at the keypair address the client would have to know the keys right? If they have the keys they can in theory use them to edit the data however they want right?
So I guess in case I send him the bump, but I need to work with other instructions, I have to call the bump in the instruction. Am I wrong?
<@!134416332509675520> And also I have an instruction problem that can't be deserialized. I have seen other people and the help you have given, and I have been very careful about the order of my instruction.

My instruction is waiting:
A title and a content

I send it:
A bump, a title and a content

Except that the bump was removed from the instruction together earlier. And what surprises me the most is that I do another test with the same function and the same values inside, and it works ü•≤

Why he wait for u8 ? I specify its a u64, I necessary need to set u8 if I wanna use it in a seed ? So the counter can be greater than 255 üò¢
I mean, for example, your wallet address in phantom or whatever is a keypair address
How come?
Doesnt seem as secure as a pda
You have to just hope that the client remembered to sign for any relevant keypairs
You can't otherwise
With the `signers: [...]` thing
Has to be passed into the application?
How do you sign as a keypair then?
Or that's the only way to sign for a keypair address
Yeah, they can't
Im not even sure ive seen an example of a keypair address signing that wasnt passed in as a signer
Then there's the account size limitation: currently PDAs can only store accounts up to 10kb in size, vs 10mb for keypair addresses.
Are their other* limitations of pdas vs keypairs?
But PDAs are nice since you get to "name" the address in a potentially memorable way, whereas keypair addresses are random‚Äîit's up to someone to actually remember them.
The main fundamental difference is in how they're signed for: keypair addresses require the secret key, whereas PDAs can only be signed for by their deriving program. So if you care about how you sign for the address you'll be forced to use one or the other.
Are there any best practices or guidance for when to use a PDA vs a keypair for an account for your program to use?
I don't know if I should worry about that lmao
When I try to analyze programs, developed recently, I often see the notion of rent
Basically never
On the other hand in the many docs I see talk about rent, but in the tutorials they never mention it. At what point should I be interested in the rent?
Waiting for "blog_v0" and send "blofg_v0"...
Its work now üëç
Problem come from the seed !
Scroll up in that test output maybe
Damn I found the problem
In .anchor/program-logs
Mmh I just have this :
Streaming transaction logs mentioning Gy2T8gX6mcgVe57vxmMUg888iRTsLUtR8GDXpHHYox2W. Confirmed commitment
Find the full program log, that's just the stack trace
Also, try literally reading the source code for it
My last problem come from test. He waiting a signer or writable account. But I use a PDA so who is signer ?
Okey !
"Find a valid program address
Valid program addresses must fall off the ed25519 curve. This function iterates a nonce until it finds one that when combined with the seeds results in a valid program address."
Mm, no, that's not a super precise way to phrase it. Have you read the `Pubkey::find_program_address` source code? I would suggest doing that
By the way bump is the number of tries to find an address that is not a real wallet right?
Thanks you üôÇ
Got it
No, it's always a u8
And there are cases where the space for the bump is greater than 1?
Okey so if I use u64 I need to put 8 on space !
Yes I am boring with space, it takes time for me to get used to it
Nope. u8 = 8 bits = 1 byte. u16 = 16 bits = 2 bytes, u32 = 32 bits = 4 bytes, u64 = 64 bits = 8 bytes
Its always 1 for u8/16/32/64 ? lmao
Nope, 1 more guess üòà
I replaced count by u64, so not 1 but 4 ?
At any rate, you want space = 8 + 1 + 1 + 32
Mm, yes, though I'm not sure why you wrote bump = 2 ü§î
"Bump's are u8" so 1 byte. In my case I have two u8 no ?
Why 2?
So in my case, bump = 2 ?
No, the space is for the Blog struct itself
In my example there is a string + a key ! That's why I thought of 4 for the string + 3 (I don't know) + 32 for the key
According to that struct anyway, so if you want counts higher that 255 you need to use a bigger type, like a u16 (up to ~64 thousand), or a u32 (~4 billion) or a u64 (~ 16 * 10^18) etc.
post_count is also a single byte
Not quite‚Äîthe discriminator is 8, yep. Bump's are u8's, which always take 1 byte (that's what a u8 is‚Äîa byte)
Like this cold I would say:

discriminator = 8
bump = (7 + 32) (I don't know why 7 yet)
counter=4 (I suppose there will be no more than 9999)
account=32

So in total 83
At any rate, how much space do you think you need?
Well, doesn't really matter, it's just unnecessary, probably
Probably don't have any need to do that derive though (I would delete it)
post_count have a default value no ?
How come you're doing `#[derive(Default)]`?
(Yes I'll remove the instruction)
It looks like what you say anyway
In this case though the account is probably owned by your program, because it's a Blog‚Äîpresumably one of your own `#[account]` structs
The *address* is derived from the program, but that in general says nothing about program ownership
Crap
Totally different ideas
No, seeds are separate from program ownership
Well, I found a nice tutorial that mixes what I've understood so far but adds the PDA layer.
So I try to follow it, but I see that most of its code is already deprecated.

Now I want to initialize a new account, based on a structure that contains a bump, a counter (u32 I guess) and an account (32). This account will be, if I understand correctly, owned by the program thanks to the seed
You need to come up with something for the space üßÆ What have you tried so far?
Still have some errors. I don't know the space I need.. And I don't know why I have some errors on #[program]
Sure
I remove the instruction too ?
No equals sign after the bump when using `init`
Just do
```.rs
bump,
payer = user
```
(I use anchor 0.23.0)
I try to call like that
Btw I wanna try to builg my program and I have soooome errors ! Im totally lost. All problems come from the bump ?
Or what I understand is that this seed can be random, and if someone wants to use my program he can use the same seed to derive it, right?
I mean, if the Account<'info, Type> name is bob, the seed should be : b"bob" ?
Hi! I have a question about seeds : In this exemple, why we use b"vote_account" ? The string can be random ? Or the string == the account owned by the program ?
https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator
how to handle this correctly? I can put just ```?``` at the end and it disappears but idk what it's doing xD
If you're running `anchor test` and local validator at the same time, you're gonna have a bad time
I'll try it, thank you!
Via its AccountMeta stuff
I think what's happening is that if you don't specify `#[account(signer)]` or `Signer`, then you would need to go out of your way to mark that account from the calle*r* as a signer
Actually, right now I passed it as `AccountInfo` and checked inside a contract whether it is a signer or not, and the result is that it was, I'll verify one more time with an Anchor `Signer` account and if it doesn't work I'll try to build smallest reproducible example
Yes!
Mm, does the callee program specifically ask for that account to be a signer?
I am trying to call one Anchor program by another through an interface, however for some reason even though I do include `with_signer` with correct seeds, the callee doesn't see an account as signed, as if `invoke` instead of `invoke_signed` is called there somewhere


//////////////////////////////////////////////////////////////////////////////////////////

const token = await spl_token.getAssociatedTokenAddress(mint.publicKey, 
      provider.wallet.publicKey, false, spl.TOKEN_PROGRAM_ID,  spl.ASSOCIATED_TOKEN_PROGRAM_ID); like this?
`spl.getAssociatedTokenAddress`
You need to pass in a specific address for `token`
Ah, that's because you're not calculating the associated token address correctly on the client
Yes. I'm getting this error: Instruction references an unknown account 43kPG4Nk3qNTFdGSWaknBbVJ5RUJWUtK1kvgUJN5p4an
 Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: An account required by the instruction is missing
help please
Is that failing?
Is their any codeblock which can tell me how pools are created using solana anchor?
I think you have tried alot
```
‚ûú  solana-burn-token-for-token-v3 git:(main) ‚úó  solana airdrop 2 FdRVDHYNGDdBMeu5konejLNeiiG1DPJVdUv4hEiR9L4 --url https://api.devnet.solana.com
Requesting airdrop of 2 SOL
Error: airdrop request failed. This can happen when the rate limit is reached.
```
Anyone else having problems with solana airdrop on devnet?
the paulx escrow tutorial has a nice way of organizing things imo
I'm a single-file maxi myself lol, but yeah, you can look at open source repos and see a variety of approaches
You can basically do whatever you want‚Äîis there a particular way you'd like to organize things?
I‚Äôd like to reiterate this question. It seems all of the official examples also shove everything into lib.rs
Weird, haha, I wasn't expecting that‚Äîhow is that possible
Funny, it does exist on devnet üòõ Though it's not a program https://explorer.solana.com/address/Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS?cluster=devnet
That's the default anchor program_id, I would be surprised if you snagged that haha
That's your program's address on devnet?
`Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS`
Can you show me the address?
after making changes to `Anchor.toml` do I need to do anything to make sure its active? this is just a vanilla react app
no live validator, the program is 100% on devnet
Are you running with a live validator in the background/maybe didn't deploy?
It is, already gone through all the search results haha
Is your Anchor.toml's program_id right?
Also, is there an example on how to set up connection/provider on the client for Anchor? I'm running into this error and suspect it's because im using incompatible connection/provider set ups

```
Main.jsx:224 Uncaught (in promise) Error: failed to send transaction: Transaction simulation failed: This program may not be used for executing instructions
    at Connection.sendEncodedTransaction (connection.ts:3668:1)
    at async Connection.sendRawTransaction (connection.ts:3628:1)
    at async sendAndConfirmRawTransaction (send-and-confirm-raw-transaction.ts:27:1)
    at async Provider.send (provider.ts:114:1)
    at async Object.rpc [as initializeMint] (rpc.ts:19:1)
    at async createMintAndGrantAuthorityToPDA (Main.jsx:212:1)
```
makes sense
They require an actual explicit keypair (Signer is just a public/private key pair), which is way too strict
They ought to be doing something similar to what anchor is doing (probably, haven't thought about this a ton), and require an argument that conforms to an interface like
```.ts
export interface Wallet {
  signTransaction(tx: Transaction): Promise<Transaction>;
  signAllTransactions(txs: Transaction[]): Promise<Transaction[]>;
  publicKey: PublicKey;
}
```
Yeah, it's basically a shortcoming in the spl library‚Äîthey're using an overly specific/restrictive type, `Signer` (as usual haha Solana names just aren't quite right, `Signer` is definitely not the right name for that type)
apologies for asking so many questions, just trying to fully understand üòõ
ah so this is an explicit short coming of the SPL library? Why is it that their abstraction requires you to rewrite the code necessary to package instructions into the instruction and then make you call an explicit `program.provider.send(txn, ...)`?
Every solana tx requires at least one signature, for that reason
The wallet always needs to sign, since it pays the tx fees
does anchor do this with every RPC call? How does it make the distinction of when the wallet needs to sign vs. doesn't need to sign?
In the browser, this will pop up the phantom dialog, etc.
Yeah, anchor will trigger a call to ask the `provider.wallet` to sign
Is this because anchor implicitly takes care of that for you? I've noticed whenever I call an spl function that requires a `signer` or `keypair`, I need to wrap it in a `.send` call like so:

```
const mintTxn = new Transaction().add(
        spl.Token.createMintToInstruction(
          spl.TOKEN_PROGRAM_ID,
          token.publicKey,
          tokenAcct.address, 
          walletPublicKey, // this should be the authority over the mint
          [],
          1
        )
      );
let mintSig = await program.provider.send(mintTxn, []);
```
(otherwise there's an issue with the having the wallet sign)
It signs no matter what because it pays for the tx fees (requires a signature), and you can't add it to signers in general because doing so would require a keypair, and in the browser for example, using a phantom wallet or whatever, you just can't get access to a keypair (phantom will never give you the actual keypair)
The `provider.wallet` actually signs no matter what, no need to add it to `signers`
üëã how can I call an anchor program, and specify the signer (keypair) via the wallet adapter? I want to do something like this:

```
const walletPubKey = provider.wallet.publicKey;
    const tx = await program.rpc.initializeMint(
      {
        accounts: {
          mint: token.address,
          mintAuthority: walletPubKey,
          tokenProgram: spl.TOKEN_PROGRAM_ID
        },
        signers: // wallet keypair
      }
    );
```
Does anyone know what the difference between serum-dex and dex-v4 is?

https://github.com/Bonfida/dex-v4

https://github.com/project-serum/serum-dex.git
Have you tried?
Can I constrain a receiving ATA to a fixed address ? Something like so? I want the mint to only go to the hardcoded wallet.
```
 #[account(mut,
    associated_token::mint = mint,
    associated_token::authority = Pubkey::from_str("XXXX").unwrap())]
    burn_vault: Account<'info, TokenAccount>,
```
that was it, thank you -- really appreciate it
roger... will try to deploy again üôÇ
E.g. you might make a change and then re-deploy without first re-running anchor build
Ok, then it's likely a mixup with your deployment process (it's weird but it's so, so easy to mis-deploy)
yes, the tests work.
Do your changes work locally?
Are you using `#[instruction(...)]` etc?
(i obviously updated my client to add the new instruction)... hmm
updated it on chain, and now instructions to it get: InstructionDidNotDeserialize
Yep, that's fine (old clients will have to update obviously, but yeah, that's fine)
as in -- can I add an argument and then redeploy?
can you change the number of arguments an instruction takes after its already been deployed?
how do i re adjust it??
Trying to make sure I‚Äôm doing this right. So I am making an exchange type of program where a user can exchange sol for tokens and tokens for sol. Given this, I have made a token account for the user and both a token and separate account use to transfer sol by the exchange. The user can sign when they wish to transfer tokens and sol. The exchange sol account signs for transactions when paying the user in either tokens or sol. Would this be the right approach?
I have no idea what that 0.32 version is
So yeah, your path is screwed up or something
jokerssd@BP-desktop:/mnt/c/Users/runmi/Desktop/Anchor/anchor/examples/tutorial/basic-0$ sudo npm install --force  yarn
npm WARN using --force I sure hope you know what you are doing.

> yarn@1.22.17 preinstall /mnt/c/Users/runmi/Desktop/Anchor/anchor/examples/tutorial/basic-0/node_modules/yarn
> :; (node ./preinstall.js > /dev/null 2>&1 || true)

npm WARN basic-0@0.22.1 No description

+ yarn@1.22.17
updated 1 package and audited 1 package in 0.674s
found 0 vulnerabilities

jokerssd@BP-desktop:/mnt/c/Users/runmi/Desktop/Anchor/anchor/examples/tutorial/basic-0$ yarn --version
0.32+git
Could try running random stuff like `yarn --help` or `yarn --version`
How did you install yarn in the first place?
how do i check>>
Like, yarn should be the js package manager, I wonder if it's actually some random other program for you
I wonder if you just don't have the right yarn installed
jokerssd@BP-desktop:/mnt/c/Users/runmi/Desktop/Anchor/anchor/examples/tutorial/basic-0$ yarn
00h00m00s 0/0: : ERROR: There are no scenarios; must have at least one.
What if you just say `yarn`?
windows with WSL terminal
Are you running on windows or something?
getting this error
jokerssd@BP-desktop:/mnt/c/Users/runmi/Desktop/gif-portal-starter/rust$ yarn install
00h00m00s 0/0: : ERROR: [Errno 2] No such file or directory: 'install'
following the guide
have you deffo done it
Your guide has a similar step - https://lorisleiva.com/create-a-solana-dapp-from-scratch/getting-started-with-solana-and-anchor#install-yarn
I am referring to this guide tbh
<@!334752658038587413> https://project-serum.github.io/anchor/tutorials/tutorial-0.html#clone-the-repo
https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html found it!
i have tried the instalation  method on buildspace
and one from a https://lorisleiva.com/create-a-solana-dapp-from-scratch/getting-started-with-solana-and-anchor#install-rust
still cnanot work , deleted the whole folder adn retried for both
now testing the installation in anchor book
wat does this mean??
<@!334752658038587413>  have you deffo ran yarn in the anchor example folder
Usage: yarn [options]

yarn: error: no such option: -t
hihi im trying to follow the anchor start up guide on build space
but keep getting error on anchor test
<@!134416332509675520>  once again solved it, im being very daft today. Rubber duck debugging seems to be working though.
I'm actually not sure if there is (tbh I don't use the docs lol), I would suggest just searching the anchor repo for `mint::`, you'll see lots of examples.
Documentation for what, the `mint::` syntax?
can you point me to the documentation where this is? I'd like to learn more about it.
function + struct def
```rust
pub fn initialize(ctx: Context<Initialize>, data: u64) -> Result<()> {
  let my_account = &mut ctx.accounts.my_account;
  my_account.counter = data;
  Ok(())
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 8 + 8)]
    pub my_account: Account<'info, MyAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```
Can you post the rust side too? What does the `fn initialize` thing look like?
Seems to have an issue with this line `await program.rpc.initialize`
Boiled the unit down to this:
```javascript
const anchor = require("@project-serum/anchor");
const { SystemProgram } = anchor.web3;

describe("basic-1", () => {
  // Use a local provider.
  const provider = anchor.Provider.local();

  anchor.setProvider(provider);

  it.only('should do something', async () => {
    const program = anchor.workspace.Basic1;

    const myAccount = anchor.web3.Keypair.generate();

    await program.rpc.initialize({
      accounts: {
        myAccount: myAccount.publicKey,
        user: provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      },
      signers: [myAccount],
    });
  });
});
```
Can you post your code?
More silly basic questions,  `Error: Invalid arguments: myAccount not provided.` getting this when running the unit tests on the `basic_1` example
yep changing it to 82 and now i have a new error! this is progress
Try tracing through there to see where you're having problems.
Here's the code that actually runs when you try to initialize the mint (again, good exercise to learn how to find this stuff): https://github.com/solana-labs/solana-program-library/blob/master/token/program/src/processor.rs#L35
You can see here that mints are supposed to have length 82, exactly: https://github.com/solana-labs/solana-program-library/blob/master/token/program/src/state.rs#L37
Yeah, good exercise to try to do the mint initialization without any anchor involvement. At least one issue I see is that you aren't allocating the right amount of space to the account.
Ok. Ill try the way you suggested. Is there documentation on that?

Also I‚Äôve been bashing my head against a wall trying to get this mint initialize to work manually, do you know what I‚Äôm doing wrong?
But it's a good exercise to dig through the spl token program's source code and see exactly where that error is getting raised (you're going to have to learn how to do this eventually lol, just the nature of programming on solana).
Ah, you're not doing the mint initialization quite correctly‚Äîit would be easier to just let anchor do it for you:
```.rs
#[account(init, payer = user, mint::decimals = 0, mint::authority = whoever)]
pub mint: Account<'info, Mint>
```
<@!134416332509675520> any ideas? I posted program log for you üòÇ
Following the basic tutorial so hopefully nothing to crazy - https://project-serum.github.io/anchor/tutorials/tutorial-0.html#building-and-emitting-an-idl

**Edit** Doing this seemed to solve the issue:
```
‚ûú  basic-0 git:(master) ‚úó anchor deploy --program-name 6dsWCVKNM1u8PSrYgUB4dRffafaAnP9yULqQJHiAAqms
Deploying workspace: http://localhost:8899
```
`anchor deploy` presumably to a local network
Ok, how are you deploying?
```solana-cli 1.9.9 (src:450404f8; feat:3246413280)```
What version of solana are you using? `solana --version`
Ello all, any one getting this error when trying the basic_0 tutorial?
```error: Invalid value for '--program-id <PROGRAM_ID>': unrecognized signer source```
Because that lifetime happens to be the same lifetime used by the underlying AccountInfo structs that solana passes to your program, and they happen to call the lifetime `'info`.
But why does anchor use 'info instead of 'a, 'b ?
Hello guys. What codition a token need to be able to appear in this swap-ui example? Some token listed on raydium but I can not find them here
Hi <@!891024357026041907>, is there any way to transform a pubkey into account info?, i'm also searching an solution for this. can you please help me with this.
Any clue how to resolve this error message while using avm to install the latest anchor version.
Hi.
when you call program.rpc.someMethod() - it will be by default signed by provider.wallet.
In this case your transaction will be signed by signers: [tracker] AND provider.wallet.

If yoy want to test this behaviour you can use something like this:
```
  let instruction = program.instruction.initialize({
      accounts: {
        tracker: tracker.publicKey,
        authority: provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      }
    });
  // this should throw if your signers are not valid
  await signAndSend(new Transaction().add(instruction), [tracker, otherSigner], provider.connection)   

  export const signAndSend = async (
    tx: Transaction,
    signers: Array<Account | Keypair>,
    connection: Connection,
    opts?: ConfirmOptions
  ) => {
    tx.setSigners(...signers.map((s) => s.publicKey))
    const blockhash = await connection.getRecentBlockhash(
      opts?.commitment || Provider.defaultOptions().commitment
    )
    tx.recentBlockhash = blockhash.blockhash
    tx.partialSign(...signers)
    const rawTx = tx.serialize()
    return await sendAndConfirmRawTransaction(connection, rawTx, opts || Provider.defaultOptions())
  }

```
Hi! I've build a simple authorize counter. The test pass but I don't quite understand why it work.
Here's the test:
```
  const program = anchor.workspace.Tracker as Program<Tracker>;
  const tracker = anchor.web3.Keypair.generate();

  it("Is initialized!", async () => {
    // Add your test here.
    await program.rpc.initialize({
      accounts: {
        tracker: tracker.publicKey,
        authority: provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      },
      signers: [tracker],
    });
```

Here's the program:
```
    pub fn initialize(ctx: Context<InitializeTracker>) -> ProgramResult {
        let tracker = &mut ctx.accounts.tracker;
        let authority = &ctx.accounts.authority;

        tracker.counter = 0;
        tracker.authority = *authority.key;
        Ok(())
    }
```

Confuse here:
```
#[derive(Accounts)]
pub struct InitializeTracker<'info> {
    #[account(init, payer = authority, space = Tracker::LEN)]
    pub tracker: Account<'info, Tracker>,
    #[account(mut)]
    pub authority: Signer<'info>,
    pub system_program: Program<'info, System>
}
```

Question: in the struct, I indicate authority as the Signer. But on the test script, why does the test pass when the signers: [tracker]?
*I wrote 2 other test to check if the authority is the same, it pass as well. Indicating the authority was provider.wallet.public key.
What's the best way to convert returned Base64 encoded data  to JSON?
At any rate you don't need to init an account if all you want to do is store sol in it, yeah
Hmm, I'm actually honestly not sure what happens if you use `init` like that
(and removing the zero space)
Well, somehow, it does! Changing `init` to `mut` circumvents the error!
Can I see your instruction function?
But I'm not sure why that would cause the error you're getting
Huh. I'll try removing the init and see what that gets me.
is there any way you can calculate a transaction fee? The suggested method in the solana cookbook seems to deprecated‚Ä¶
Doesn't really make sense to initialize an account with zero space (you can just skip initializing it at all at that point) [edit: I guess maybe it could sometimes? hmm, still seems weird to me]
Which program owns the source account?
The sending account, `sol_handler`, was initialized here, so the program should own it, I think?
Getting this error when attempting to send SOL using CPI.
Damn, should hv done my homework! Just read the generics section of Rust Book and everything makes sense now üôÇ
Is there a convention for organizing anchor rust code? It seems like in the book they just stuff everything in lib.rs
You can generally just ignore it, but it's a rust thing: https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html
Btw, I have no idea what <'info> does haha
N/m, I was missing the <'info> after struct definition
How did you solve this?
when u deploy or run tests, u get the address. but just building omits it
^ answer to this is that it has the address with anchor test/deploy and loses it with anchor build
why is it that sometimes my IDL has an address at the bottom under "metadata", and sometimes it doesn't?
That only works for accounts you define yourself, within your own program, with the `#[account]` macro
Have you tried jumping to source?
^ ah nvm, the `Token` object is really just a wrapper, so you can just fill in the existing info to rewrap the existing account
Create mint returns a `Token` object. 

```
static async createMint(
    connection: Connection,
    payer: Signer,
    mintAuthority: PublicKey,
    freezeAuthority: PublicKey | null,
    decimals: number,
    programId: PublicKey,
  ): Promise<Token> {
```
Is there an existing method where, if I know the public key of the mint, I can get back the corresponding `Token` object?
you can't, you need to pass the account pubkey into the program rpc call's accounts input


//////////////////////////////////////////////////////////////////////////////////////////

'Program log: Instruction: MintNft', 'Program log: Custom program error: 0x7d6'
why am i hitting this error when trying to mint?
any one else getting this anchor installation error by trying to install the latest version using 'avm use latest ' command got the following error
```error: expected one of `:`, `@`, or `|`, found `)`
  --> /home/aaransol/.cargo/registry/src/github.com-1ecc6299db9ec823/spl-token-3.2.0/src/processor.rs:58:5
   |
57 |         owner: Option<&Pubkey>,s
   |                                 - expected one of `:`, `@`, or `|`
58 |     ) -> ProgramResult {
   |     ^ unexpected token
   |
   = note: anonymous parameters are removed in the 2018 edition (see RFC 1685)
help: if this is a parameter name, give it a type
   
57 |         owner: Option<&Pubkey>,s: TypeName
   |                                 ++++++++++
help: if this is a type, explicitly ignore the parameter name
   |
57 |         owner: Option<&Pubkey>,_: s
   |                                ++

   Compiling solana-clap-utils v1.8.5
error[E0061]: this function takes 3 arguments but 2 arguments were supplied
   --> /home/aaransol/.cargo/registry/src/github.com-1ecc6299db9ec823/spl-token-3.2.0/src/processor.rs:108:9
    |
108 |         Self::_process_initialize_account(accounts, None)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ --------  ---- supplied 2 arguments
    |         |
    |         expected 3 arguments
    |
note: associated function defined here
   --> /home/aaransol/.cargo/registry/src/github.com-1ecc6299db9ec823/spl-token-3.2.0/src/processor.rs:55:8
    |
55  |     fn _process_initialize_account(
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
56  |         accounts: &[AccountInfo],
    |         ------------------------
57  |         owner: Option<&Pubkey>,s
    |         ---------------------- -

error[E0061]: this function takes 3 arguments but 2 arguments were supplied
   --> /home/aaransol/.cargo/registry/src/github.com-1ecc6299db9ec823/spl-token-3.2.0/src/processor.rs:113:9
    |
113 |         Self::_process_initialize_account(accounts, Some(&owner))
    |         |
    |         expected 3```
How can I transfer custom tokens using anchor contracts? 

For example, a contract checks a users wallet for a particular token and transfers and sends it. I've been stuck on this
glad i could help
great, i'll try something like that
```json
"deploy:dev:build": "anchor build -- --features \"normalize-duration\"",
"deploy:prod:build": "anchor build -- --features \"mainnet normalize-duration\"",
```

I have a script like this that builds or deploys based on environment
this log message has listed the next steps for you, just read it and rerun
One of my dependencies in Cargo.toml needs a 'mainnet-beta' feature when building for mainnet, but doesn't when building for devnet. Is there anyway to have it automatically switch depending on my 'provider' ?
jokerssd@BP-desktop:~$ sudo npm install --global yarn
npm ERR! code EEXIST
npm ERR! path /usr/bin/yarnpkg
npm ERR! Refusing to delete /usr/bin/yarnpkg: ../lib/node_modules/corepack/dist/yarnpkg.js symlink target is not controlled by npm /usr/lib/node_modules/yarn
npm ERR! File exists: /usr/bin/yarnpkg
npm ERR! Remove the existing file and try again, or run npm
npm ERR! with --force to overwrite files recklessly.

npm ERR! A complete log of this run can be found in:
npm ERR!     /root/.npm/_logs/2022-03-05T13_09_22_220Z-debug.log
add sudo to your command
jokerssd@BP-desktop:~$ npm install --global yarn
npm WARN checkPermissions Missing write access to /usr/lib/node_modules/yarn
npm WARN checkPermissions Missing write access to /usr/lib/node_modules
npm ERR! code EACCES
npm ERR! syscall access
npm ERR! path /usr/lib/node_modules/yarn
npm ERR! errno -13
npm ERR! Error: EACCES: permission denied, access '/usr/lib/node_modules/yarn'
npm ERR!  [Error: EACCES: permission denied, access '/usr/lib/node_modules/yarn'] {
npm ERR!   errno: -13,
npm ERR!   code: 'EACCES',
npm ERR!   syscall: 'access',
npm ERR!   path: '/usr/lib/node_modules/yarn'
npm ERR! }
npm ERR!
npm ERR! The operation was rejected by your operating system.
npm ERR! It is likely you do not have the permissions to access this file as the current user
npm ERR!
npm ERR! If you believe this might be a permissions issue, please double-check the
npm ERR! permissions of the file and its containing directories, or try running
npm ERR! the command again as root/Administrator.

npm ERR! A complete log of this run can be found in:
npm ERR!     /home/jokerssd/.npm/_logs/2022-03-05T13_07_28_640Z-debug.log
yeah, this error is expected since you're not in a project scope or installing in a global scope.

So run `npm install --global yarn`
npm install yarn

> yarn@1.22.17 preinstall /home/jokerssd/node_modules/yarn
> :; (node ./preinstall.js > /dev/null 2>&1 || true)

npm WARN saveError ENOENT: no such file or directory, open '/home/jokerssd/package.json'
npm WARN enoent ENOENT: no such file or directory, open '/home/jokerssd/package.json'
npm WARN jokerssd No description
npm WARN jokerssd No repository field.
npm WARN jokerssd No README data
npm WARN jokerssd No license field.

+ yarn@1.22.17
added 1 package and audited 1 package in 0.497s
found 0 vulnerabilities

trying to but keep hitting earror on ubuntu
install yarn with npm. the yarn from apt is a different program
and sudo npm uninstall --force-g yarn dont work too
version is 0.32+git
my yarn is weird
hi may i know how to uninstall yarn from ubuntu?
I have an account that looks like this:
#[account]
pub struct ReportAccount {
    pub uri: String,
    pub authority: Pubkey,
    pub reportstatus: u8,
    pub votestatus: u8,
}

I want the program that initializes this to have access to the first 3 line items. The votestatus would be updated via a separate program only, this program would be handed ownership of to our governance.
Any ideas on how I would do this? I am thinking I initialize a copy in a cross program master for this. Any way to prevent that redundancy
Hi, how can PDA be initialized and passed as program account ( instruction fails with 3012, acc i'm passing is https://explorer.solana.com/address/8LjoZt5J4oEJpC7wgcz9DKwXwYiJuqySbE8yhJDAjxpS?cluster=devnet a PDA) and on the program, this account is defined as 

 pub authority: AccountInfo<'info>,

As i understand this anchr piece of code is raising this error:

 if info.owner == &system_program::ID && info.lamports() == 0 {
            return Err(ErrorCode::AccountNotInitialized.into());
        }

Any ideas what am i doing wrong?
even though I was accessing the relevant type using the module's namespace
on my `#[program]` attribute
`unresolved import 'crate'`
some sort of import error
I was getting an error even if I tried the latter
mod is like import I guess 
use is kind of like destruction from JS. If I didn‚Äôt put use error::*; I would have to write error::ErrorCode::(err message)
I've seen a lot of solana programs with just `pub mod x`
Any idea why I need both?
Yes
The code is a few months old, but you can import by mod and use
I was having some import errors and I think it's because I wasn't doing both `pub mod x` and `use x::*`
Ah thanks! This will be handy
https://github.com/regohiro/macroswap
Ah yes, and it's just stuffing everything into lib.rs of course
Here‚Äôs anchor version
https://github.com/project-serum/anchor/tree/master/tests/escrow
Unfortunately that tutorial isn't using anchor
quick question about the `MintInfo` struct:

```

/**
 * Information about the mint
 */
type MintInfo = {|
  /**
   * Optional authority used to mint new tokens. The mint authority may only be provided during
   * mint creation. If no mint authority is present then the mint has a fixed supply and no
   * further tokens may be minted.
   */
  mintAuthority: null | PublicKey,

  /**
   * Total supply of tokens
   */
  supply: u64,

  /**
   * Number of base 10 digits to the right of the decimal place
   */
  decimals: number,

  /**
   * Is this mint initialized
   */
  isInitialized: boolean,

  /**
   * Optional authority to freeze token accounts
   */
  freezeAuthority: null | PublicKey,
|};
```
wow... interesting, guess when SOL is 10x the price now, program deploys on mainnet $$$
definitely narrows the use cases
I know right, that's kind of the "dark side" of Solana.
And the rent-exemption rate is 7 sol/mb. So if you upload a couple hundred kbs with your first deploy, then yeah, ~4 sol is about what you're looking at.
The upgradeable deployment process defaults to having your first deploy reserve 2x the initial code size, so you can upgrade later.
It's for rent-exempting your program's code, which is generally in the 100s of kbs.
Why does each program deploy cost ~4 SOL? That's so expensive
Ah ok, thanks for the quick reply tho!
Unfortunately as far as I know this just doesn't work yet
Hi, how do I use type alias in anchor?
```
pub type EthereumAddress = [u8; 20];

mod my_program {
 .....
}

#[account]
pub struct Counter {
  pub signer_address: EthereumAddress,
  pub count: u64,
  pub nonce: u64
}
```

I'm getting this error when I instantiate idl 
```
IdlError: Type not found: {"name":"signerAddress","type":{"defined":"EthereumAddress"}}
```
Thanks man!!
So turns out i needed to mark payer as mutable. Is it because as they payer we decrement its lamports?
Have tried omitting #[account(signer)] from the acctAuthority variable, but that doesn't seem to work.  My guess that it's around the account init, of `escrowed_token_account` - but I've already gotten the payer to sign here ü§î
But seeing:
```
  solana-burn-token-for-token
Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS invoke [1]
    Program log: Instruction: InitializeTokenAcct
    B5tnm5qtGLThYuw9phtfwa2knSAUknrrjWwXZgBJ6jph's writable privilege escalated
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS consumed 9850 of 200000 compute units
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS failed: Cross-program invocation with unauthorized signer or writable account
    1) Token version: it passes authority to the PDA, mints and burns token


  0 passing (2s)
  1 failing

  1) solana-burn-token-for-token
       Token version: it passes authority to the PDA, mints and burns token:
     Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account
      at Connection.sendEncodedTransaction (node_modules/@solana/web3.js/src/connection.ts:3963:13)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at Connection.sendRawTransaction (node_modules/@solana/web3.js/src/connection.ts:3920:20)
      at sendAndConfirmRawTransaction (node_modules/@solana/web3.js/src/util/send-and-confirm-raw-transaction.ts:27:21)
      at Provider.send (node_modules/@project-serum/anchor/src/provider.ts:118:18)
      at Object.rpc [as initializeTokenAcct] (node_modules/@project-serum/anchor/src/program/namespace/rpc.ts:25:23)
```
Running:
```
const payer = anchor.web3.Keypair.generate();
    const sender = anchor.web3.Keypair.generate();

    await helpers.airdropSol(payer, program.provider.connection);

    const sampleMint = await spl.Token.createMint(
      program.provider.connection,
      payer,
      payer.publicKey,
      payer.publicKey,
      0,
      spl.TOKEN_PROGRAM_ID
    );

    const senderTokenAccount = await sampleMint.createAccount(sender.publicKey);
    await sampleMint.mintTo(senderTokenAccount, payer.publicKey, [], 1);

    const preInitTokenAcct = await sampleMint.getAccountInfo(senderTokenAccount);

    const [escrowedMakerTokens, escrowedMakerTokensBump] = await anchor.web3.PublicKey.findProgramAddress(
      [preInitTokenAcct.mint.toBuffer()],
      program.programId
    );

    const tx = await program.rpc.initializeTokenAcct({
      accounts: {
        tokenAcct: senderTokenAccount,
        tokenMint: sampleMint.publicKey,
        acctAuthority: sender.publicKey,
        tokenProgram: spl.TOKEN_PROGRAM_ID,
        escrowedTokenAcct: escrowedMakerTokens,
        payer: payer.publicKey,
        systemProgram: anchor.web3.SystemProgram.programId,
        rent: anchor.web3.SYSVAR_RENT_PUBKEY,
      },
      signers: [payer, sender]
    })
```
I've got:

```
 pub fn initialize_token_acct(ctx: Context<InitializeTokenAcct>) -> ProgramResult {
    Ok(())
}

#[derive(Accounts)]
pub struct InitializeTokenAcct<'info> {
    // #[account(mut)]
    pub token_acct: Account<'info, TokenAccount>,
    // #[account(mut)]
    pub token_mint: Account<'info, Mint>,
    #[account(signer)]
    pub acct_authority: AccountInfo<'info>,
    pub token_program: AccountInfo<'info>,
    // This is where we'll store the offer maker's tokens.
    #[account(
        init,
        payer = payer,
        seeds = [token_acct.mint.as_ref()],
        bump,
        token::mint = token_mint,
        // We want the program itself to have authority over the escrow token
        // account, so we need to use some program-derived address here. Well,
        // the escrow token account itself already lives at a program-derived
        // address, so we can set its authority to be its own address.
        token::authority = escrowed_token_acct,
    )]
    pub escrowed_token_acct: Account<'info, TokenAccount>,
    pub payer: Signer<'info>,
    pub system_program: Program<'info, System>,
    pub rent: Sysvar<'info, Rent>
}
```
nvm found this
or is that the account Im burning from
When you invoke the burn CPI from the token program it asks for a `to:` account? What does this mean? Am I burning to another account?
Bumping; I still have no idea how to get the proper balance.
It would unfortunately require updating the spl token program, not anchor itself‚Äîbut looks like that's going to happen soon-ish
Got it, seems like we still need it as of `anchor-lang = "0.21.0"` but guessing there's work to remove it
So in this case the token program just happens to need that account, so you gotta pass it in from the client per the usual solana rules.
It's kind of a legacy thing tbh, since you can now just dynamically do `Rent::get()?`, but you used to have to pass it in as an actual account so initialization stuff could figure out whether an account had enough lamports to be rent-exempt.
Makes sense. One follow up: what is the purpose of this `pub rent: Sysvar<'info, Rent>,` - seems like every init call requires it?
But basically, anchor uses the seeds + bump to CPI to the system program to make a token account, and then CPIs again to the token program to actually initialize the token account.
Little hard to read, but you can see the source here: https://github.com/project-serum/anchor/blob/master/lang/syn/src/codegen/accounts/constraints.rs#L344
üëã quick question about this: https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo/src/lib.rs#L170

```
// This is where we'll store the offer maker's tokens.
    #[account(
        init,
        payer = offer_maker,
        seeds = [offer.key().as_ref()],
        bump = escrowed_maker_tokens_bump,
        token::mint = maker_mint,
        // We want the program itself to have authority over the escrow token
        // account, so we need to use some program-derived address here. Well,
        // the escrow token account itself already lives at a program-derived
        // address, so we can set its authority to be its own address.
        token::authority = escrowed_maker_tokens,
    )]
    pub escrowed_maker_tokens: Account<'info, TokenAccount>,
```
How are these parameters in the account macro being used? i.e. I'm seeing this being called like so:
```
await program.rpc.make(
      escrowedMakerTokensBump,
      new anchor.BN(100),
      new anchor.BN(200),
      {
        accounts: {
          offer: offer.publicKey,
          offerMaker: program.provider.wallet.publicKey,
          offerMakersMakerTokens: offerMakersMakerTokens,
          escrowedMakerTokens: escrowedMakerTokens,
          makerMint: makerMint.publicKey,
          takerMint: takerMint.publicKey,
          tokenProgram: spl.TOKEN_PROGRAM_ID,
          rent: anchor.web3.SYSVAR_RENT_PUBKEY,
          systemProgram: anchor.web3.SystemProgram.programId,
      },
      signers: [offer]
    });
```
no additional instructions are being passed, so how are seeds, bump, etc. being used exactly? Documentation tells me:
`Seeds for the program derived address an AccountInfo struct represents. If bump is provided, then appends it to the seeds. On initialization, validates the given bump is the bump provided by Pubkey::find_program_address.`, but how exactly are these parameters being used/set?
+ corresponding issue: https://github.com/project-serum/anchor/issues/1387
check out this PR: https://github.com/project-serum/anchor/pull/1452#discussion_r809207430
Is this intended behavior? It's treating this as a compile error but it feels more like a compiler warning so it should finish and generate an idl for me. Anyway it does generate an idl if I deploy the program without commenting `/// CHECK:` above every use of UncheckedAccount
Ok I figured out the problem. It's because I was using `UncheckedAccount` without some comment on why checking is not necessary. So `anchor build` wasn't generating a fresh idl
how do I generate a new idl without deploying the program? Looks like `anchor upgrade` does generate a new idl--only anchor deploy does. I thought it used to be that anchor build will generate a new idl and populate it in `target/idl`
you might be able to "upgrade" it to a smaller buffer and close the previous buffer. Have never done that though
No, programs live forever
Can you "withdraw" the  `SOL` amount in a `Program Executable Data Account
` at a later stage if you no longer need the program?
The current number (too small) that I'm using for the balance is `*(*(ctx.accounts.minter_base..to_account_info().lamports).borrow_mut())` . That gives me a valid number, it seems, but one that is too small, as I can successfully send an amount of SOL equivalent to the lower bound this is getting compared to, as long as the error check is removed. There might be a cleaner way to get the balance though.
How do I get the account size in bytes for one of my PDA's?
perrrrrfect
You can actually already do `await program.account.thatAccountType.all()` üôÇ
nvm im stupid, source dived further and looks like it's straight sha256. in case anyone else is looking though I'll leave the messages
ok from source it looks like a hash of `account:<ident>` for each account. Is there a way to recreate this hash accurately from the client-side? Hoping to implement something like `get<AccountType>` which gets all accounts matching a certain type owned by the program.
Is there documentation on the account discriminator? I had added an enum to my accounts to tell them apart from RPC but just realized it seems Anchor does this automatically. How can I tell what the discriminator is for a given account type?
Helps get around issues with borrowing variables as well sometimes
It's a handy trick for sure
While this doesn't help my understanding per se, it is a cool trick that helped to solved my problem: https://discord.com/channels/889577356681945098/889702325231427584/944344169474822144
Hopefully someone can explain how you can avoid boxing when there's so many accounts and large data structs to be loaded that it doesn't work without box
https://twitter.com/0xsanny/status/1499503856228528140?s=20&t=3Ea5S2k-bt6C9_ay3O50Ow
Haha, I came to post the same thing but decided to discord search first
Nope. This is an account that holds SOL, and has no data.
is it a token account? Usually if I'm checking token balances I'd use something like: `ctx.accounts.token_account.amount`
How does one check the balance of an `AccountInfo`? I tried using `lamports`, but that seems to give me an amount that is too small.
i used anchor deploy on mainnet and it worked fine
Are there any resources on this/places in the Solana code I should look to learn more about stack frames and memory management in general? My anchor program is working but it feels really hacky bc I have no idea what is going on with how Solana/Rust/Anchor are managing the memory of my programs. Boxing accounts is the only thing that makes sense to me hahaha
Is it necessary to use a custom rpc to deploy a program to mainnet? 
Been seeing a lot of Invalid Blockhash errors deploying to devnet using `anchor deploy` and want to avoid those on mainnet
Could maybe try doing https://discord.com/channels/889577356681945098/889577399308656662/948261193540321340
üëç  (lol, yes)
<@!134416332509675520> I'm guessing the thumbs up is a yes? üò¢
Is the deployment cost on `devnet` a good estimation for deploying a program on `mainnet`?
Yeah
Got it . So in this case, we should create associated token accounts and _transfer_ tokens as opposed to changing the authority (best practice-wise)
Heh, as usual the names are slightly off in solana, but an associated token account is a regular old token account that happens to live at a special address, a PDA derived from the associated token program (totally different program from the token program).
what's the diff between a token account vs. associated token account?
But this is one reason why it's a bad idea to transfer ownership of an associated token account‚Äîit's quite surprising if the associated token account for mint M and person P is actually currently owned by some random other person Q.
Yep, can have as many as you want (only one *associated* token address though).
üëã can one address have multiple token accounts with the same mint? If not, what happens if an address already owns a token account and then I transfer ownership of a separate token account (with the same mint) to that address?
Here's an example: https://github.com/cqfd/anchor-token-studies/blob/main/programs/token-studies/src/lib.rs#L14
Thanks for clarifying!
You'd need to have an instruction that eventually uses `invoke_signed` etc. to do that mint to instruction
The only way for a PDA to sign something is by asking its deriving program to do so for you‚Äîit's not possible to sign for a PDA from the client
I have a mint authority that's owned by a PDA. I want to mint to a particular token account, my code is like so:

```
 const mintTxn = new Transaction().add(
        spl.Token.createMintToInstruction(
          spl.TOKEN_PROGRAM_ID,
          token.publicKey,
          tokenAcct.address, 
          _pda, // this should be the authority over the mint
          [],
          1
        )
      );
let mintSig = await program.provider.send(mintTxn, []);
```
Getting:
```
Uncaught (in promise) Error: Signature verification failed
    at Transaction.serialize (transaction.ts:583:1)
    at Provider.send (provider.ts:112:1)
    at async mintToWallet (Main.jsx:378:1)
```
How can I set this up so the PDA "signs" the transaction?


//////////////////////////////////////////////////////////////////////////////////////////

sorry. I was unclear. Basically the problem i am trying to solve is  - how can we mint token to a public key representing a users token account?
I know it needs accountinfo passed through ctx. But we can't store that on chain
Basic problem is token minting can (and almost always will) happen after a while  (user maybe be logged out/sleeping). SO how so we get accountinfo then? IIRC it can't be stored on chain on a vector.
The AccountMeta was just me trying to see if there is a way to get around this problem. And I think it has same problem.
The cli does let you send token to pubkey address. 
||spl-token mint AQoKYV7tYpTrFZN6P5oUufbQKAUr9mNYGe1TTJC9wajM 100||
Why can't we do it on chain?
An AccountMeta isn't the same thing as an AccountInfo, so I think I'm confused by your question
In rust or js?
how to convert a string into buffer?
how do we do this in anchor. as in pass pubkey and get accountinfo
#[allow(clippy::too_many_arguments)]
pub fn initialize_binary_option(
    program_id: Pubkey, // Address of deployed program
    pool_account: Pubkey, // Address of Upgrade Authority
    escrow_mint: Pubkey, // TBD
    escrow_account: Pubkey, // Unique per option [ generated by front-end SPL library ]
    long_token_mint: Pubkey, // Unique per option [ generated by front-end SPL library ]
    short_token_mint: Pubkey, // Unique per option [ generated by front-end SPL library ]
    mint_authority: Pubkey, // Fixed address [ generated/chosen by us ]
    update_authority: Pubkey, // Address of Upgrade Authority
    decimals: u8, // 2 = 100, 3 = 1000 [ only using 2 for now ]
    expiry:  u64, // Unix timestamp
    strike: u64, // strike_price
    strike_exponent: u64, // strike_price
    // underlying_asset_address: Pubkey, // Address of underlying asset [ from Pyth for now ]
) -> Instruction {
    Instruction {
        program_id,
        accounts: vec![
            AccountMeta::new(pool_account, true),
            AccountMeta::new_readonly(escrow_mint, false),
            AccountMeta::new(escrow_account, true),
            AccountMeta::new_readonly(long_token_mint, true),
            AccountMeta::new_readonly(short_token_mint, true),
            AccountMeta::new_readonly(mint_authority, true),
            AccountMeta::new_readonly(update_authority, true),
            AccountMeta::new_readonly(spl_token::id(), false),
            AccountMeta::new_readonly(solana_program::system_program::id(), false),
            AccountMeta::new_readonly(sysvar::rent::id(), false),
        ],
        data: BinaryOptionInstruction::InitializeBinaryOption(InitializeBinaryOptionArgs {
            decimals,
            expiry,
            strike,
            strike_exponent,
            
        })
        .try_to_vec()
        .unwrap(),
    }
}
So wondering if there is an anchor equivalent of AccountMeta::new(pubkey). 
In Solana/Rust implementation , one can pass pubkey and get AccountMeta to pass onto on chain instruction.
Redeploying does indeed need that much sol in your wallet, but you get it right back‚Äîit's only used for a temporary buffer while deploying.
Can you say more? What do you mean by best practices here?
Hi, I'm trying to deploy a program to an existing address (ie upgrading the program) - however when I run anchor deploy it wants to charge me for a full program deploy. If I close the program and reclaim the rent and deploy to a different address its much cheaper.

I've tried upgrade, maybe I did it wrong, but it didnt do what I wanted

I feel I must be missing something obvious - whats the command to deploy to an existing program please ?
What are the general best practices for integrating anchor ts with Phantom Wallet (through, e.g. `window.solana`)?
i searched through some history, putting things in helper functions did help -- thanks for previous responses üôÇ
commenting out a bunch of logging i was able to get it down below 4096, but some of that logging i kind of wanted. what other strategies can I use to drop it down?
what's a large stack variable?
When building I see this:
```Error: Function _ZN12drift_client12drift_client13open_position17h2330650942d4402fE Stack offset of 5432 exceeded max offset of 4096 by 1336 bytes, please minimize large stack variables```

and after deploying and calling the function, i got 
```> Program returned error: Access violation in stack frame 5 at address 0x200005ac8 of size 8 by instruction #9479```

Can anyone explain what this means?
It spins up a validator for you, but in doing so it injects your code
I want to get ideas here.
If I want to create a PDA mapping of let's say unique number => user pubkey, what's the best way to query the list (array) of unique numbers that user owns on the client side? 
My ideas are:
- Create a vector of unique numbers for each user. However, I think this is an expensive solution.
- Create an indexer and watch for events.
If I want to mainnet fork using test.validator.clone should I have a validator running in the background or can I do it without?
so without a local validator where does it run the code? On like block 1 of a new chain after deploying or something?
I personally never run a local validator in the background
If the validator is running in the background, anchor test just runs your tests against it (potentially annoying since you need to remember to deploy the latest version of your code)
Without a running validator, anchor/solana does some "genesis block" magic to inject the latest version of your code without strictly speaking deploying.
what's the difference between running `anchor test` while running a `solana-test-validator` in the background vs not running a local validator in the background?

I get different error codes.
errr update when i check avm's version it seems to be working
how can we find the current version of mainnet and devnet?
I am specifying the gateway IP for my docker network now, and I was successfully able to airdrop tokens. When I try a deploy however, I see transactions attempting to send repeatedly until the blockhash expires.
also i already added it to my path
i ran ```avm use latest``` but it gave me this and when i try to check my anchor version it tells me to run the command again... any advice?
Yeah, think this will be clearer if you go through the book/the examples https://project-serum.github.io/anchor/tutorials/tutorial-0.html
thank you
I've skimmed it, I'll go through it in more detail then
Have you gone through the anchor book? https://book.anchor-lang.com/
The thing that goes into `Ctx<...>`  has to derive(Accounts); the `#[account]` thing you have above is how you declare a single account on-chain with some data in that struct format stored there.
```.rs
#[derive(Accounts)]
pub struct SwapInfoCtx<'info> {
  pub swap_info_account: Account<'info, SwapInfo>
}
```
```error[E0432]: unresolved import `crate`
 --> programs/stableRead/src/lib.rs:5:1
  |
5 | #[program]
  | ^^^^^^^^^^ could not find `__client_accounts_swap_info` in the crate root
  |
  = note: this error originates in the attribute macro `program` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: no function or associated item named `try_accounts` found for struct `SwapInfo` in the current scope
  --> programs/stableRead/src/lib.rs:5:1
   |
5  | #[program]
   | ^^^^^^^^^^ function or associated item not found in `SwapInfo`
...
16 | pub struct SwapInfo {
   | ------------------- function or associated item `try_accounts` not found for this
   |
   = help: items from traits can only be used if the trait is implemented and in scope
   = note: the following trait defines an item `try_accounts`, perhaps you need to implement it:
           candidate #1: `anchor_lang::Accounts`
   = note: this error originates in the attribute macro `program` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the trait bound `SwapInfo: anchor_lang::Accounts<'_>` is not satisfied
  --> programs/stableRead/src/lib.rs:5:1
   |
5  | #[program]
   | ^^^^^^^^^^ the trait `anchor_lang::Accounts<'_>` is not implemented for `SwapInfo`
   |
note: required by `anchor_lang::context::Context::<'a, 'b, 'c, 'info, T>::new`
  --> /home/a/.local/share/cargo/registry/src/github.com-1ecc6299db9ec823/anchor-lang-0.20.1/src/context.rs:45:5
   |
45 | /     pub fn new(
46 | |         program_id: &'a Pubkey,
47 | |         accounts: &'b mut T,
48 | |         remaining_accounts: &'c [AccountInfo<'info>],
49 | |     ) -> Self {
   | |_____________^
   = note: this error originates in the attribute macro `program` (in Nightly builds, run with -Z macro-backtrace for more info)```

I think I'm missing something basic in my understanding of accounts.
So I have this code trying to read state data:
```
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod stable_read {
    use super::*;
    pub fn read(ctx: Context<SwapInfo>) -> ProgramResult {
        let data = &ctx.accounts.is_paused;
        msg!("isPaused?:{}", data);
        Ok(())
    }
}

#[account]
pub struct SwapInfo {
    /// Initialized state
    pub is_initialized: bool,

    /// Paused state
    pub is_paused: bool,

    pub nonce: u8,

}```

and I get this error from ```anchor build```:
Ah, that makes sense based on what my client is doing :p
So e.g. doing `anchor deploy -p asdfasdfasdfasdf` will also work (bug in anchor cli I guess)
Yeah think that's only for the program name
1 sec
Though hmm, maybe it is
I think it only does the program name‚Äîright, I don't think it's doing all three
kind of weird that the same flag is interpreting 3 different types of arguments
it also serves as an override for cluster and for wallet according to CLI
I thought the `-p` argument was for picking which program you wanted to deploy, not for specifying a network
I'm currently deploying an anchor program in a docker container to a localnet running in another docker container. The containers are able to network with one another on a custom network via docker-compose. Running `anchor deploy` results in a failure, but I succeed when I specify `anchor deploy -p http://localhost:8899`

My anchor.toml file has cluster set to localnet.

Any idea what I'm missing?
Oh nvm, it prints in the anchor console, not in the solana log
(finding example)
Why won't it work?
How can I log variables on program runtime? I can use msg! but it won't work if the program fails
Sure
inside the program
I can use msg! too right?
Similar to how you might be testing your own `program` in your existing anchor tests
Assuming you can load up the other program's IDL into `thatOtherProgram`
No, anchor already wrote it for you
Or if that's tricky to get working, you could use the lower-level `(await program.provider.connection.getAccountInfo(itsAddress)).data[9]`
fetch here is the function I write to read the necessary data?
`await thatOtherProgram.account.programInfo.fetch(itsAddress)`
ok, is there anyway to console.log() the variable I read while testing in anchor?
currently you cant deploy candy machines (for nfts) on devnet and they reckon its because teh devnet is struggling
yeh i think so
Like
```.rs
#[derive(Accounts)]
pub struct SomeInstruction<'info> {
  pub program_info_account: Account<'info, ProgramInfo>
}
```
No need to do a CPI, you can just pass that account into the other program
did u manage to fix this?
maybe devnet is havin some issues, Im unable to interact with it atm for some reason ://
In the EVM I would just do  ``bool data  = <address>.isPaused()``
Let's say this is in the program state of a different program
```pub struct ProgramInfo {
    pub is_paused: bool
}
```
How would I read this data from a program, do I need to a cross program invocation for just reading data?
ah, I see, ok
But that doesn't have anything to do with that `[test.validator]` Anchor.toml thing.
You can write unit tests in rust like
```.rs
#[test]
fn do_something() {
  ...
}
```
Which test keyword are you referring to?
how exactly do I incorporate the [test] keyword in my code? Is there any examples of using this pattern in code?
I'm trying to deploy, and `anchor deploy` succeeded, but for some reason I get an AccountNotFound error when trying to view the account newly generated by `solana-keygen`. Airdrop requests fail, and this error appears when I try to use an online faucet. What am I missing about the deployment process?
Np ‚ô•Ô∏è
Lol
u saved my life
thanks prask!!


//////////////////////////////////////////////////////////////////////////////////////////

I've noticed the mint authority pub key points to the edition pubkey from the mintNFTResponse object
üëã Have a question on metaplex NFTs. The metaplex discord isn't as active/helpful as here, so figured I'd ask here:

What is the relation between the edition vs. metadata vs. mint on an NFT? My understanding is that the mint is similar to a regular SPL token mint, the metadata is a derived address of the mint where the metadata is stored. I'm more confused about the edition and what the relation to metadata/mint is
```
‚ûú  myepicproject anchor --version
anchor-cli 0.22.1
```
thats not the anchor cli
```
"dependencies": {
        "@project-serum/anchor": "^0.22.1"
    },```
bug in `0.22.0` update the anchor cli to `0.22.1` and init a new workspace or adjust manually (see the changelog)
```
error[E0412]: cannot find type `ProgramResult` in this scope
 --> programs/myepicproject/src/lib.rs:8:58
  |
8 |   pub fn start_stuff_off(ctx: Context<StartStuffOff>) -> ProgramResult {
  |                                                          ^^^^^^^^^^^^^ not found in this scope
```
```
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod myepicproject {
  use super::*;
  pub fn start_stuff_off(ctx: Context<StartStuffOff>) -> ProgramResult {
    Ok(())
  }
}

#[derive(Accounts)]
pub struct StartStuffOff {}
```
Hello again,
Any idea why ProgramResult is not present in the scope ?
<@!134416332509675520> thanks for the help. you're the best
Yeah, that seems fine‚Äîthe existence of an account at the PDA with seeds = [wallet.key().as_ref()] would signal that your program had granted that wallet pubkey, and then you'd require the client to pass in both the PDA as well as a signature from the corresponding wallet.
<@!134416332509675520> would this approach work? Or is there some holes in this that I‚Äôm not thinking of?
Yeah, it's true that if you're changing the list frequently, then maybe it would be annoying to hardcode it. But you can update the list by just redeploying your program.
What if you wanted to update after it was deployed or if theres thousands for example. A hardcoded list doesn‚Äôt seem sustainable.
Why do you need to create a PDA per wallet? Why not just hardcode those wallet pubkeys into your program?
So if i wanted to create a list of whitelists wallets to have access to a "secret" function, i could create a PDA per wallet and then just lock down the function that creates the PDA with a constraint on the struct equal to an admin wallet, and constraint on the "secret" function that checks for that PDA?
Ok, that makes sense
Finding the address doesn't create anything
Anyone can find the address, but only your program can create the account that lives there
but i thought anyone can just create a PDA?
```.rs
#[derive(Accounts)]
pub struct InitThatPDA<'info> {
  #[account(address = ADMIN)]
  pub admin: Signer<'info>,

  #[account(init, ......)]
  pub that_pda: Account<'info, Whatever>
  ...
}
```
The instruction that initializes the account at the PDA would need to check that that ADMIN signed the tx
lets say i'm using a PDA to read some kind of value, how do i ensure that PDA was created by an ADMIN for example
What do you mean?
```.rs
const ADMIN: Pubkey = solana_program::pubkey!("adsfasdafsdadsf");
```
can you check if who signed an existing PDA?
So if those specific wallets are hardcoded etc., then you can just check in your program
The only option is to check that one of those wallets signs the tx
what are some best practices to ensuring a specific PDA is only created/updated by specific wallets?
hello, does anyone knows why 'anchor deploy' takes so much time(40m+) and still not done, what am I missing here ?
How do I constrain access to only one specific token mint or governance owner program? Is it recommended to hard code the account pubkey or some other way this is done?
It's working, ty mate
All right !
Yeah, that'll fix the problem
So sounds like no üòõ
oooooops !
```
‚ûú  myepicproject echo $PATH           
/Users/louis/.nvm/versions/node/v17.6.0/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Users/louis/.nvm/versions/node/v17.6.0/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/Users/louis/.cargo/bin```
I don't think that's related. There's a section in that document that tells you to add the solana/bin directory to your path, did you do that?
I'm following this document: https://github.com/buildspace/buildspace-projects/blob/main/Solana_And_Web3/en/Section_2/Resources/m1_setup.md
Ok, but on M1 there's nothing with bpf ? cause the validators command is `solana-test-validator --no-bpf-jit`
Yeah, so I would revisit the installation instructions
```‚ûú  myepicproject which cargo-build-bpf
cargo-build-bpf not found```
But `which cargo-build-bpf` needs to point to part of your solana install
Ah, you may need to just make sure your path is set up correctly (I don't remember how to do this, since I installed solana from source)
Solana-test-validators works and solana-keygen works too, that doesn't means anything ?
And I haven't got any errors during solana build
```
‚ûú  myepicproject solana --version
solana-cli 1.8.5 (src:devbuild; feat:52865992)
```
That means you haven't installed solana itself correctly
Hi,
I'm doing the buildspace tutorial and in the installation part on M1, something doesn't work.
Error:
```
‚ûú  myepicproject anchor test --skip-local-validator
error: no such subcommand: `build-bpf`
‚ûú  myepicproject which anchor                      
/Users/louis/.cargo/bin/anchor
```
<@!134416332509675520> Yes, it's true, but my **target/build** is in my **.gitignore** then each time I'm cloning my repo locally and after running **anchor build** a new keypair is generated (ok I can copy/paste the custom keypair to the target folder and it's gonna be okay), just wanted to know it we could specify it from anchor build directly (as we can do with **solana program ...** cmd)
It shouldn't be regenerating the keypair unless you accidentally keep deleting the one it deposits in `target/build`.
I would think its possible to do #1 but I‚Äôm not sure what‚Äôs best practice for a whitelist. Perhaps its not a single PDA account with a long list of WL accounts, but instead you build a pda for each WL address and check that instead? How do you ensure that the list can‚Äôt be tampered with?
hello, when I run anchor build a new **program-name-keypair.json** is generated each time.
How can I force anchor build to take a pre-generated keypair as an input this way I can reuse the same keypair each time?
storing each item in a separate account wouldn't work because I need the program to be able to iterate through an indefinite number of items
is it possible to increase the size of an account (e.g. for variable sized lists)?
assuming you care if people create token accounts for mint addresses not in the list
It's not secure at all to only do it on the client side
If I have a function that looks like this:
```
pub fn initialize_token_acct(ctx: Context<InitializeTokenAcct>) -> ProgramResult {
    msg!("Transferring tokens from: {:?}", ctx.accounts.token_acct.key());
    msg!("To: {:?}", ctx.accounts.escrowed_token_acct.key());

    let cpi_accounts = token::Transfer {
        from: ctx.accounts.token_acct.to_account_info(),
        to: ctx.accounts.escrowed_token_acct.to_account_info(),
        authority: ctx.accounts.acct_authority.to_account_info()
    };

    let cpi_program = ctx.accounts.token_program.to_account_info();
    let cpi_mint_tx = CpiContext::new(cpi_program, cpi_accounts);
    
    token::transfer(cpi_mint_tx, 1)?;

    Ok(())
}

#[derive(Accounts)]
pub struct InitializeTokenAcct<'info> {
    #[account(mut)]
    pub token_acct: Account<'info, TokenAccount>,
    #[account(mut)]
    pub token_mint: Account<'info, Mint>,
    #[account(signer)]
    pub acct_authority: AccountInfo<'info>,
    pub token_program: AccountInfo<'info>,
    // This is where we'll store the offer maker's tokens.
    #[account(
        init,
        payer = payer,
        seeds = [token_acct.mint.as_ref()],
        bump,
        token::mint = token_mint,
        token::authority = escrowed_token_acct,
    )]
    pub escrowed_token_acct: Account<'info, TokenAccount>,
    #[account(mut)]
    pub payer: Signer<'info>,
    pub system_program: Program<'info, System>,
    pub rent: Sysvar<'info, Rent>
}
```

But I want to set a constraint that this can only be run for a select set of token/mint addresses, what's the best way for me to do this? The approaches I see are:

1/ Keep a static list of mint addresses and do a check at the beginning of `initialize_token_acct` to see if the token/mint accounts passed are included in that static list. If not, terminate early

2/ On the client side, keep that static list, and don't make the program rpc call if the token/mint accounts aren't in that list
the problem is - it was an UnckechedAccount for a reason. I actually don't need to unwrap it into an object, which increases the number of operations. I just need an address
huh, that actually does work! thanks!
i think
`pub associated_with_parent_1_mint: Account<'info, TokenAccount>`
recreated my problem in a fresh project.
does that help a bit? üòâ 
```
use anchor_lang::prelude::*;
use anchor_spl::associated_token::AssociatedToken;
use anchor_spl::token::Mint;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod coin_playground {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(mut)]
    pub owner: Signer<'info>,

    #[account(mut)]
    pub parent_1_mint: Account<'info, Mint>,

    #[account(
    associated_token::mint = parent_1_mint,
    associated_token::authority = owner,
    )]
    pub associated_with_parent_1_mint: UncheckedAccount<'info>,

    pub associated_token_program: Program<'info, AssociatedToken>,
}
```
and error
```
error[E0277]: can't compare `&anchor_lang::prelude::Pubkey` with `anchor_lang::prelude::Pubkey`
  --> programs/coin-playground/src/lib.rs:16:10
   |
16 | #[derive(Accounts)]
   |          ^^^^^^^^ no implementation for `&anchor_lang::prelude::Pubkey == anchor_lang::prelude::Pubkey`
   |
   = help: the trait `PartialEq<anchor_lang::prelude::Pubkey>` is not implemented for `&anchor_lang::prelude::Pubkey`
   = note: this error originates in the derive macro `Accounts` (in Nightly builds, run with -Z macro-backtrace for more info)
```
Updating anchor cli worked!  Thank you so much for your help <@!784156219861762109>
btw. what `rustc` version do you have? if older than 1.59 - then update with `rustup update stable`
with those all up to date - try a new `anchor init`
anchor-cli 0.22.1
also - you may want to downgrade to 1.8 16 (or smth), because 1.9 is testnet only
anchor-cli
currently using solana-cli 1.9.9
ProgramResult got updated to Result<()>.
check out changelog for more details: https://github.com/project-serum/anchor/blob/master/CHANGELOG.md
and this tells me that your CLI is older than ur anchor version in the project
Anyone get a ```error[E0412]: cannot find type `ProgramResult` in this scope``` when running anchor build on a brand new project?
and I don't really know how to fix it üòÑ
and it still looks legit to me
interesting that it worked so far
```
   #[account(mut)]
    pub owner: Signer<'info>,
    #[account(mut)]
    pub parent_1_mint: Account<'info, Mint>,
#[account(
    associated_token::mint = parent_1_mint,
    associated_token::authority = owner,
)]
pub associated_with_parent_1_mint: UncheckedAccount<'info>,
```
with some trial and error I narrowed it down to
close
it might be a has_one constraint
i don' have an easy way to get that
that's the thing - there are none (not a single `&` in the whole file). so I was hoping that there simply is a way to get to the variable name that was checked.
pretty hard to tell without seeing the code, but probably a stray & somewhere in a constraint?
any chance you know something about this one? üòâ
ahhh, right. everything evolves so fast üòâ
ahh its because it was removed in favour of --skip-lint https://github.com/project-serum/anchor/pull/1482
but TBH - I decided that having some docs outside my head may not even be the worst idea ever, so I'll just write them up... üòâ
anchor build
what command are you running?
another one:
following this: `https://github.com/project-serum/anchor/pull/1452`
I pasted this into my `Anchor.toml`
```
[features]
safety_checks = false
```
but I'm still getting 
```
Please add a `/// CHECK:` doc comment explaining why no checks through types are necessary.
```
any idea why?
so now I'm getting this
```
  --> programs/combiner/src/domains/actions/breeding/breed_definition.rs:18:10
   |
18 | #[derive(Accounts)]
   |          ^^^^^^^^ no implementation for `&anchor_lang::prelude::Pubkey == anchor_lang::prelude::Pubkey`
   |
   = help: the trait `PartialEq<anchor_lang::prelude::Pubkey>` is not implemented for `&anchor_lang::prelude::Pubkey`
```
and I have >100 lines worth of definitions in that file.
is there any way to get the actual `name` of a field that resulted in this error?
Sort of, you can do `await program.rpc.thatAccountStructType.fetchMultiple` and just pass in multiple addresses.
Hi, I have an account that is used as a seed for multiple other PDAs (so there is a one to many relationship).
The seeds for the other accounts look something like this: `["tag", main.key(), number.toBytes()]`, where the number goes from 0 to e.g. 5.
Is there a good way for me to fetch all of these PDAs with one request?
that makes more sense, thanks üôÇ
So the constraint itself isn't composite, it's a constraint *on* a composite field.
You can only use `#[account(constraint = ...)]` on top of those, not other stuff like `#[account(mut)]` or whatever
That means you're using a composite field in your derive(Accounts) struct, something like `pub something: Something<'info>` (not one of the usual suspects, Account, AccountInfo, Signer, etc.)
thank you
ah, ok, that is perfect
```.rs
#[test]
fn serialization_example() {
    #[derive(AnchorDeserialize, Debug)]
    struct SwapInfo {
        is_initialized: bool,
        is_paused: bool,
        nonce: u8,
        something: u64,
    }

    let mut data = vec![1u8, 0, 254, 1, 2, 3, 0, 0, 0, 0, 0];

    let swap_info = SwapInfo::deserialize(&mut &data[..]);
    eprintln!("{:?}", swap_info);
}
```
```
12 | #[derive(Accounts)]
   |          ^^^^^^^^
   |
   = help: message: Invariant violation: composite constraints can only be raw or literals
```
what's a `composite constraint`?
For what it's worth that raw account data you posted above doesn't look like anchor to me
Ok, its written in anchor as well so I'm guessing borsh? How would I deserialize assuming borsh?
But your struct might be simple enough that you can just guess/try both or whatever
No. There are some standard choices, borsh and serde, but they're not the same thing so depends on how that other program works
hmm, so no in built rust library for that sort of thing?
yeah, I just removed some stuff to fit it in a small example, it has like 5 more u64 entries
This is why ideally you'd just depend on that other program's code as a dependency
In general there's no automagic way to do deserialization‚Äîit depends on how the original thing was serialized
Oh, ok, so SwapInfo has a bunch of other stuff in it?
nah, its more complicated, has a bunch of other data in the actual struct
Given that your struct is so simple, you could honestly just manually deserialize it if you're sure about the formatting of that data.
i removed some data
Just to make sure I'm understanding, looks like there's a bunch more data in there‚Äîdo you just not need it?
Like in the logs I get something like:
```Program log: raw data1:RefCell { value: [1, 0, 254, 200, 0, 0, 0, 0, 0, 0, 0, 200, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 140, 187, 27, 48, 177, 27, 15, 193] }
```
Which is (I guess) the account data I'm after (is_initialized, the nonce, etc.), just need to deserialize it now
Ok, that seems to work, how do I deserialize the type `Rc<RefCell<&'a mut [u8]>>` if I know it will have the form of a struct:
```
pub struct SwapInfo {
    pub is_initialized: bool,
    pub is_paused: bool,
    pub nonce: u8,
}
```
? Does that question make sense or am I misunderstanding something about rust types?
Thanks. Yeah I just want to make sure it's the empty-seed pda and not an arbitrary address.
Try doing `msg!("raw data1: {:?}", q);`
Secure check for what? It verifies that that main_pda has empty seeds, yeah.
I lack some rust type knowledge here:
```
#[program]
pub mod stable_read {
    use super::*;
    pub fn read(ctx: Context<SwapInfoCtx>) -> ProgramResult {
        let data = &ctx.accounts.swap_info_account;
        msg!("raw data:{}", data.owner);
        msg!("raw data1:{}",data.rent_epoch);
        //Having trouble converting this to a type I can display
        let q = data.deserialize_data();
        msg!("raw data1:{}", q);
        Ok(())
    }
}

#[derive(Accounts)]
pub struct SwapInfoCtx<'info> {
    ///CHECK: BASED
  pub swap_info_account: AccountInfo<'info>
}

#[account]
pub struct SwapInfo {
    /// Initialized state
    pub is_initialized: bool,

    /// Paused state
    pub is_paused: bool,

    /// Nonce used in program address
    /// The program address is created deterministically with the nonce,
    /// swap program id, and swap account pubkey.  This program address has
    /// authority over the swap's token A account, token B account, and pool
    /// token mint.
    pub nonce: u8,

}
```
I've tried a bunch of different things to convert the data to a type that can be logged but I'm not quite getting it:
``` --> programs/stableRead/src/lib.rs:14:30
   |
14 |         msg!("raw data1:{}", q);
   |                              ^ `Result<_, Box<bincode::error::ErrorKind>>` cannot be formatted with the default formatter
```
thanks that worked üôè 
I'm now fiddling with upgrade problems with my old program 
```
error: bump targets should not be provided with init. Please use bump without a target.
  --> programs/combiner/src/domains/config/initialize_combiner.rs:14:9
   |
14 |         bump = bump,
   |         ^^^^
```
I can see that it was a breaking change at some point, but can someone explain the reason behind it? one way or another the bump has to be passed on. just sometimes it's through context, sometimes it's not. doesn't feel very consistent
Yeah, but does this attribute suffice as a secure check?
The doc comment is because you're using UncheckedAccount (also for AccountInfo, same thing), not for the seeds part
I'm only doing this to use `main_pda` as the authority for the token account I'm creating in this instruction, which is all handled in the account init attribute
Is this the proper way to check the pda account provided?
```rust
    #[account(seeds=[], bump)]
    pub main_pda: UncheckedAccount<'info>
```
The compiler is telling me I need to add a doc comment so I just wanted to make sure
The 2021 edition of rust requires at least 1.56
Try upgrading that to a more recent version
```
$ rustc --version
rustc 1.54.0 (a178d0322 2021-07-26)
```
What version of rust are you using? `rustc --version`
hey.
I noticed that this question has been asked a number of times, but couldn't find any real answer, so I'll post it again... sorry.
thats what I did:
```
$ solana --version
solana-cli 1.8.16 (src:23af37fe; feat:1886190546)
$ anchor --version
anchor-cli 0.22.1
$ anchor init coin-playground
$ cd coin-playground/
$ anchor build
```
and the result is that
```
Failed to obtain package metadata: Error during execution of `cargo metadata`:     Updating crates.io index
 Downloading crates ...
error: failed to download `solana-sdk-macro v1.10.0`

Caused by:
  unable to get packages from source

Caused by:
  failed to parse manifest at `/home/wooha/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-sdk-macro-1.10.0/Cargo.toml`

Caused by:
  feature `edition2021` is required

  this Cargo does not support nightly features, but if you
  switch to nightly channel you can add
  `cargo-features = ["edition2021"]` to enable this feature
```
I checked solana releases and versions 1.9.x are generally considered testnet only and I have the latest mainnet version installed. this is the latest anchor version available in cargo.
but despite that - I am clearly doing something wrong and getting this error, so the question is: what am I doing wrong? üòÑ 
help please üôÇ
No, but failed tests do log to the console
Seems like passing tests only output logs to the file in .anchor? Is there a macro for outputting them to the console after the test or something?
Anyway to see the msg!() when running anchor test? I think it goes of in the background and only console logs from the .ts file are seen
thx
lmao, I see it now, things are starting to make sense
Try googling vim rust-analyzer
It's crucial to get your editor set up to do that, otherwise you're going to have a rough time
xdd ok
No, I'm saying that if you learn how to see how AccountInfo is defined, by jumping to its source, you'll see how to use it üòõ
Vim. Are you saying to redefine what AccountInfo means in anchor?
What editor are you using now?
ugh, any examples of that?
You should configure your editor so you can jump to the AccountInfo source, the definition of the type
what's that? I replaced Account -> AccountInfo on the dervied account
Have you tried jumping to source on the AccountInfo type?
```#[program]
pub mod stable_read {
    use super::*;
    pub fn read(ctx: Context<SwapInfoCtx>) -> ProgramResult {
        let data = &ctx.accounts.swap_info_account;
        msg!("raw data:{}", data);
        Ok(())
    }
}

#[derive(Accounts)]
pub struct SwapInfoCtx<'info> {
  pub swap_info_account: AccountInfo<'info>
}```

So I'm just trying to read the raw account data of the copied account with the above. How do I display it in say bytes? I get this error:
``` --> programs/stableRead/src/lib.rs:10:29
   |
10 |         msg!("raw data:{}", data);
   |                             ^^^^ `anchor_lang::prelude::AccountInfo<'_>` cannot be formatted with the default formatter
   |
```
Init a metaplex account? Don't think there's anything built-in yet for that
Gotcha. Is it possible to do with Anchor?
For example, anytime you `init` an associated token account you're doing this
Yes, but it would require CPIing to that other program (only that other program can sign for the account's address)
Is it possible to init a PDA for another program (metaplex)?
And then doing what you normally do in your own programs, `Account<'info, ThatAccountStruct>`
oh, I see xd
Assuming it's an anchor program, then yeah, adding a dependency to it üòõ
yeah
You mean for an account owned by another program?
like I define a struct I want to deserialize
Ah, I see, is there some built in way to deserialize in anchor?
Otherwise, yeah, you'd need to use `AccountInfo` and handle the deserialization manually yourself
Right, assuming it's an anchor program that's how you would ordinarily do it, via a Cargo dependency
I just want to read that data
If you want to be able to write `Account<'info, SwapInfo>` and have it work, you need to add that other program to your Cargo dependency and use its *own* SwapInfo struct, not your copy of it
do I replace Account with AccountInfo on the derived accounts?
Yea I think I misunderstood I was planning on getting the PDA and calling createTokenAccount but realized that would be wrong so I‚Äôll give this a shot and from the client side I‚Äôd just use the PDA to get the derived ATA to pass in
Ah, so that SwapInfo account is owned by some other program? Yeah, what you wrote above implies its supposed to be owned by your program (the `#[account]` part above the struct)
That could work, but what's the connection to initializing them on the client? I thought that's what we were talking about
I'm copying something from mainnet using test.validator.clone and trying to read that
Right but they still need to be initialized if you‚Äôre depositing or withdrawing SPL from them so I attempted to do so with init if needed is that correct?
the error log?
```
Transaction simulation failed: Error processing Instruction 0: custom program error: 0xbbf
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS invoke [1]
    Program log: Instruction: Read
    Program log: Custom program error: 0xbbf
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS consumed 2197 of 200000 compute units
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS failed: custom program error: 0xbbf
    1) Is initialized!


  0 passing (47ms)
  1 failing

  1) stableRead
       Is initialized!:
     Error: 3007: The given account is owned by a different program than expected
      at Function.parse (node_modules/@project-serum/anchor/src/error.ts:41:14)
      at Object.rpc [as read] (node_modules/@project-serum/anchor/src/program/namespace/rpc.ts:32:42)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
```
Can you post the full program log?
ATAs are token accounts that live at PDAs derived from a totally different program, the associated token program, so creating them doesn't require your own program to sign for anything (the address is a PDA, but not one of your PDAs)
So I attempted to do so with the atas not sure if they‚Äôre correct
<@!134416332509675520> 
```use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod stable_read {
    use super::*;
    pub fn read(ctx: Context<SwapInfoCtx>) -> ProgramResult {
        let data = &ctx.accounts.swap_info_account.is_paused;
        msg!("isPaused?:{}", data);
        Ok(())
    }
}

#[derive(Accounts)]
pub struct SwapInfoCtx<'info> {
  pub swap_info_account: Account<'info, SwapInfo>
}

#[account]
pub struct SwapInfo {
    /// Initialized state
    pub is_initialized: bool,

    /// Paused state
    pub is_paused: bool,

    /// Nonce used in program address
    /// The program address is created deterministically with the nonce,
    /// swap program id, and swap account pubkey.  This program address has
    /// authority over the swap's token A account, token B account, and pool
    /// token mint.
    pub nonce: u8,

}```
I think I'm getting error 3007 because the above requires my program (above) to own the account I'm reading from? Is this true? How do I fix it?
`my_game_fee_account` and `escrow_payment_account` are PDAs but I need to create ATAs for those so they can handle SPL transfers
Which PDA token account are you referring to? I only see associated_token accounts
like i have this struct so far, thought i could get the PDA token account client side and pass it in, but it may also need to be init_if_needed instead:
```
#[derive(Accounts)]
#[instruction(escrow_payment_bump: u8)]
pub struct DepositSpl<'info> {
    wallet: Signer<'info>,
    #[account(mut)]
    ///CHECK: 
    payment_account: UncheckedAccount<'info>,
    #[account(mut, seeds=[PREFIX.as_bytes(), coin_flip.key().as_ref(), wallet.key().as_ref()], bump=escrow_payment_bump)]
    ///CHECK: 
    escrow_payment_account: UncheckedAccount<'info>,
    #[account(seeds=[PREFIX.as_bytes(), my_game.creator.as_ref()], bump=my_game.bump, has_one=authority, has_one=coin_flip_fee_account, )]
    coin_flip: Account<'info, CoinFlip>,
    #[account(mut, seeds=[PREFIX.as_bytes(), my_game.key().as_ref(), FEE_ACCOUNT.as_bytes()], bump=my_game.fee_account_bump)]
    ///CHECK: 
    my_game_fee_account: UncheckedAccount<'info>,
    #[account(mut)]
    mint: Account<'info, Mint>,
    #[account(mut, associated_token::mint = mint, associated_token::authority = wallet)]
    token_account: Account<'info, TokenAccount>,
    #[account(
        mut,
        associated_token::mint = mint,
        associated_token::authority = my_game_fee_account,
    )]
    my_game_fee_ata: Account<'info, TokenAccount>,
    #[account(
        mut,
        associated_token::mint = mint,
        associated_token::authority = escrow_payment_account,
    )]
    escrow_payment_account_ata: Account<'info, TokenAccount>,
    token_program: Program<'info, Token>,
    ///CHECK:
    authority: UncheckedAccount<'info>,
    system_program: Program<'info, System>,
    rent: Sysvar<'info, Rent>,
}
```
can you create a PDA for a different program other than your own?
Hmm ok, then i might need to modify a few things.. will have to get back to this
any idea why I'm getting error 3007 here? The declareId seems ok
But at any rate creating a token account that lives at one of your program's PDAs requires invoking your program
Or maybe I misunderstood what you creating the token account client side
No, token program still requires passing the rent account, regardless of how you invoke it. Plus, unfortunately, creating an account ultimately requires a signature from the address, and for PDAs that's only possible by getting the deriving program to sign, so it isn't even possible to create a PDA token account from the client.
Can you get around this by creating the token account client side for the pda if it doesn‚Äôt exist?
The token program happens to be written in such a way that it requires an explicit rent account (newer programs don't need to do that anymore)
but not when creating other pdas
why do I need to include the Rent sysvar in the context accounts when creating a pda token account?
Yea I just saw that in the changelog
Ok, that means you should mark that payer with `#[account(mut)]`
Still confused on whats the problem with #program and initialize now tho
oh, ok, and after doing that its complaining about payer not being mutable `the payer specified for an init constraint must be mutable`, payer (see above) is `Signer<``info>`
https://github.com/project-serum/anchor/blob/master/CHANGELOG.md is usually a good source for migration information, e.g. ```lang: Providing bump = <target> targets with init will now error. On init only, it is required to use bump without a target and access the seed inside function handlers via ctx.bumps.get("<pda-account-name"). For subsequent seeds constraints (without init), it is recommended to store the bump on your account and use it as a bump = <target> target to minimize compute units used (#1380).```
This is saying to just replace all those `bump = some_bump,` with just `bump,`, no equals etc. Anchor will figure out the bumps for you now.
I guess curious what I‚Äôm missing or any tips on migration? Seems there are a ton of breaking changes
this all started happening after using latest anchor, trying to refactor the error codes and programresult now, but running into this
Then also seeing this now :
```
error[E0599]: no function or associated item named `try_accounts` found for struct `Initialize` in the current scope
   --> programs/my-game/src/lib.rs:21:1
    |
21  | #[program]
    | ^^^^^^^^^^ function or associated item not found in `Initialize<'_>`
...
442 | pub struct Initialize<'info> {
    | ---------------------------- function or associated item `try_accounts` not found for this
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `try_accounts`, perhaps you need to implement it:
            candidate #1: `anchor_lang::Accounts`
    = note: this error originates in the attribute macro `program` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the trait bound `Initialize<'_>: anchor_lang::Accounts<'_>` is not satisfied
  --> programs/my-game/src/lib.rs:21:1
   |
21 | #[program]
   | ^^^^^^^^^^ the trait `anchor_lang::Accounts<'_>` is not implemented for `Initialize<'_>`
   |
note: required by `anchor_lang::context::Context::<'a, 'b, 'c, 'info, T>::new`
  --> /Users/davidmaman/.cargo/registry/src/github.com-1ecc6299db9ec823/anchor-lang-0.22.1/src/context.rs:51:5
   |
51 | /     pub fn new(
52 | |         program_id: &'a Pubkey,
53 | |         accounts: &'b mut T,
54 | |         remaining_accounts: &'c [AccountInfo<'info>],
55 | |         bumps: BTreeMap<String, u8>,
56 | |     ) -> Self {
   | |_____________^
   = note: this error originates in the attribute macro `program` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: no method named `exit` found for struct `Initialize` in the current scope
   --> programs/my-game/src/lib.rs:21:1
    |
21  | #[program]
    | ^^^^^^^^^^ method not found in `Initialize<'_>`
...
442 | pub struct Initialize<'info> {
    | ---------------------------- method `exit` not found for this
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `exit`, perhaps you need to implement it:
            candidate #1: `anchor_lang::AccountsExit`
    = note: this error originates in the attribute macro `program` (in Nightly builds, run with -Z macro-backtrace for more info)
```
```
#[derive(Accounts)]
#[instruction(bump: u8, fee_account_bump: u8, treasury_bump: u8)]
pub struct Initialize<'info> {
    #[account(init, seeds=[PREFIX.as_bytes(), authority.key().as_ref()], bump=bump, space=MY_GAME_SIZE, payer=payer)]
    coin_flip: Account<'info, CoinFlip>,
    #[account(mut, seeds=[PREFIX.as_bytes(), my_game.key().as_ref(), FEE_ACCOUNT.as_bytes()], bump=fee_account_bump)]
    coin_flip_fee_account: UncheckedAccount<'info>,
    #[account(mut, seeds=[PREFIX.as_bytes(), my_game.key().as_ref(), TREASURY.as_bytes()], bump=treasury_bump)]
    my_game_treasury: UncheckedAccount<'info>,
    payer: Signer<'info>,
    authority: UncheckedAccount<'info>,
    #[account(mut)]
    fee_withdrawal_destination: UncheckedAccount<'info>,
    #[account(mut)]
    treasury_withdrawal_destination: UncheckedAccount<'info>,
    system_program: Program<'info, System>,
}
```
```bump targets should not be provided with init. Please use bump without a target.```
So im starting to see this. I have an account struct in initialize that utilizes bumps and was working find before upgrading to latest anchor
Almost there; it is enough apparently; the signer should be `anchor.getProvider().wallet.payer`, but for some reason Visual Studio is telling me that the type "Wallet" has no property "payer".
Wait, that's still not enough to be able to sign a transaction with the user's Phantom keypair. Though the URL here I think is just devnet.
Ah, looks like I can use `anchor.setProvider()`, but I need a connection endpoint URL for the connection... unless I'm missing something. Is there a default URL to use, or a way to get one?
Hi probably a weird question... my program in 1 instruction will init a PDA passed in by a user, in another instruction it will do validation on this PDA, is it possible an attacker could init a PDA without going through my program? Or is a property of a PDA that only my program can init it's own PDAs?
Ok, so I upgraded my version of anchor since apparently it does that automatically now, the error I get now is:
```  0 passing (47ms)
  1 failing

  1) stableRead
       Is initialized!:
     Error: 3007: The given account is owned by a different program than expected
```
Where can I find the method findProgramAddressSync?
So I'm reading through the discord:
Apparently I need to add the upgradeable cllone too? Like this:
```const programDataAddress = findProgramAddressSync(
      "SQDY9uoDoCbNq7F3HAHYYQZbrUzpKxDtdWLvYcqBLak",
      new anchor.web3.PublicKey("BPFLoaderUpgradeab1e11111111111111111111111")
    )[0];

    console.log(programDataAddress);```
And then add whatever address I get to the anchor toml?
The account is https://solscan.io/account/SQDY9uoDoCbNq7F3HAHYYQZbrUzpKxDtdWLvYcqBLak , which has some data so I would expect it to be initialized by my anchor toml
And the error I get after anchor test:
```  stableRead
hi
Transaction simulation failed: Error processing Instruction 0: custom program error: 0xbc4
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS invoke [1]
    Program log: Instruction: Read
    Program log: Custom program error: 0xbc4
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS consumed 2176 of 200000 compute units
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS failed: custom program error: 0xbc4
    1) Is initialized!


  0 passing (47ms)
  1 failing

  1) stableRead
       Is initialized!:
     Error: 3012: The program expected this account to be already initialized
```
This is my testing code:
```import * as anchor from '@project-serum/anchor';
import { Program } from '@project-serum/anchor';
import { stableRead } from '../target/types/stableRead';

describe('stableRead', () => {

  // Configure the client to use the local cluster.
  anchor.setProvider(anchor.Provider.env());

  const program = anchor.workspace.StableRead as Program<StableRead>;

  it('Is initialized!', async () => {
    // Add your test here.
    console.log("hi");
    const tx = await program.rpc.read({
      accounts:{
        swapInfoAccount:new anchor.web3.PublicKey("SQDY9uoDoCbNq7F3HAHYYQZbrUzpKxDtdWLvYcqBLak")
      }
    });


    console.log("Your transaction signature", tx);
  });
});
```
anyway to check if the clone is working properly?
This is in my anchor.toml:
```[test.validator]
url = "https://api.mainnet-beta.solana.com"
[[test.validator.clone]]
address = "SQDY9uoDoCbNq7F3HAHYYQZbrUzpKxDtdWLvYcqBLak"```
`cluster = "localnet"` in my Anchor.toml
Trying to run a basic client.js script for my program deployed on localnet. Being told `Error: ANCHOR_PROVIDER_URL is not defined` . `anchor test` works just fine
How one would generally go about it. I read through https://lorisleiva.com/create-a-solana-dapp-from-scratch/integrating-with-solana-wallets , for instance, but that seems specific to Vue.
If I have a function that looks like this:
```
pub fn initialize_token_acct(ctx: Context<InitializeTokenAcct>) -> ProgramResult {
    msg!("Transferring tokens from: {:?}", ctx.accounts.token_acct.key());
    msg!("To: {:?}", ctx.accounts.escrowed_token_acct.key());

    let cpi_accounts = token::Transfer {
        from: ctx.accounts.token_acct.to_account_info(),
        to: ctx.accounts.escrowed_token_acct.to_account_info(),
        authority: ctx.accounts.acct_authority.to_account_info()
    };

    let cpi_program = ctx.accounts.token_program.to_account_info();
    let cpi_mint_tx = CpiContext::new(cpi_program, cpi_accounts);
    
    token::transfer(cpi_mint_tx, 1)?;

    Ok(())
}

#[derive(Accounts)]
pub struct InitializeTokenAcct<'info> {
    #[account(mut)]
    pub token_acct: Account<'info, TokenAccount>,
    #[account(mut)]
    pub token_mint: Account<'info, Mint>,
    #[account(signer)]
    pub acct_authority: AccountInfo<'info>,
    pub token_program: AccountInfo<'info>,
    // This is where we'll store the offer maker's tokens.
    #[account(
        init,
        payer = payer,
        seeds = [token_acct.mint.as_ref()],
        bump,
        token::mint = token_mint,
        token::authority = escrowed_token_acct,
    )]
    pub escrowed_token_acct: Account<'info, TokenAccount>,
    #[account(mut)]
    pub payer: Signer<'info>,
    pub system_program: Program<'info, System>,
    pub rent: Sysvar<'info, Rent>
}
```

But I want to set a constraint that this can only be run for a select set of token/mint addresses, what's the best way for me to do this? The approaches I see are:

1/ Keep a static list of mint addresses and do a check at the beginning of `initialize_token_acct` to see if the token/mint accounts passed are included in that static list. If not, terminate early

2/ On the client side, keep that static list, and don't make the program rpc call if the token/mint accounts aren't in that list
You have to use that pubkey address and then pass it as an account to your program when you invoke it


//////////////////////////////////////////////////////////////////////////////////////////

Is anybody else having error with avm installation? I am running following command and receive following error
`cargo install --git https://github.com/project-serum/anchor avm --locked --force`
> failed to compile `avm v0.22.1 (https://github.com/project-serum/anchor#6dd0574c)`,
what is the last working version of Solana & Anchor-cli someone used to deploy Solana program to test net?
Hi All , I am working in scan to earn protocol . I have some doubt some question is the best approach to replicate this pattern using Anchor. The target of the protocol si monetize Scan action of the customer. For that when people scan product connect with a Master Product record . This MP has a metadata about product detail . After that the people could be win a NFTs with discount. Any advice is welcome
Hi, is it possible to forward local node time during anchor tests? thanx in advance
any suggestion on this anyone?
This is the current stack into the containerX - Solana and anchor  the setup step compile it .
Hi , I am develop a project to compile and install Solana Development stack into the container and & glyclt connect with container . please any comments or advice is welcome.  I am just testing on my laptop  https://github.com/glyfo/glyclt

There's only one change in the template, right? Getting 
```
missing generics for type alias `anchor_lang::Result`
```
running 0.22.1 via new version manager
Thanks, I deleted that code, when I was facing an error which was probably unrelated
from client
And then check `ctx.accounts.that_account.key() == THE_HARDCODED_KEY`
Passing it in is not an issue
Pass it in like any other account into your program
lol
How do this
And then verify in your program that it has the expected address
Ah, no, you have to pass that account in from the client
Been unable to find how people are calling the same into a function. the CPI call requires to_account_info and I am unable to get that from a hardcoded id
For your custom stuff, yeah, you need to have some way to hardcode the id
for the token program yes, but for my custom token?
You don't need to hardcode the token program's id yourself, since you're presumably already depending on its source
This is basically the point of `declare_id!`‚Äîit hardcodes the intended program id into the program text, which lets *other* programs depend on your code and see what your intended ID is.
use anchor_lang::prelude::*;
use anchor_spl::token::{Transfer, Mint, Token, TokenAccount};
/* use anchor_spl::token::accessor::amount;
use anchor_spl::associated_token::get_associated_token_address;
use solana_program::{instruction::Instruction, program::invoke_signed};

const NEWSTOKEN: Pubkey = solana_program::pubkey!("3qq7ExpwRRAAexGNpUVoFkiTfSB1uo8ezsbyAoxhyryo");
const TREASURY: Pubkey = solana_program::pubkey!("6kgSK2hFDjUCS3wafYYW2VSwkjETuqHdByWddwmytyp7");
const TOKEN_PROGRAM: Pubkey = solana_program::pubkey!("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
 */
const FEE_AMOUNT:u64 = 100000000;

declare_id!("3Z8eqLzepWH6UmqFyU9mDsjQp6QepLURqHSBFwmJLdCh");

#[program]
pub mod newsreport {
    use super::*;
    pub fn initialize(ctx: Context<Initialize>)  -> ProgramResult  {
        let report_acc = &mut ctx.accounts.report_account;
        report_acc.authority = *ctx.accounts.authority.key;
        report_acc.status = 0;
        anchor_spl::token::transfer(
            CpiContext::new(
                ctx.accounts.newstoken.to_account_info(),
                anchor_spl::token::Transfer {
                    from: ctx.accounts.from.to_account_info(),
                    to: ctx.accounts.treasury.to_account_info(),
                    authority: ctx.accounts.authority.to_account_info(),
                    },
                ),
                FEE_AMOUNT,
            )?;
        Ok(())
    }
Sharing my code
By hardcoding program ids üôÇ
how does a program verify another program without hardcoding program ids?
I see, well i guess i will wait that more apps became open sourced.
If you mean guess the seeds just based on the address, not really‚Äîthe address is a hash of the seeds + some other stuff, so can't really reverse-engineer that unless you have some clever way to guess the seeds/look at previous transactions where they were submitted as arguments, or something like that.
What do you mean by revert?
is it possible to revert the seed of an account if the idl is not provided ?
Hi Guys. I'm running `anchor test --skip-local-validator` but still getting this error:
`Error: failed to get recent blockhash: FetchError: request to http://localhost:8899/ failed, reason: connect ECONNREFUSED 127.0.0.1:8899`

The program is on devnet
Got it, thanks... would there be some way to verify with a hardcoded program ID in the program? I want to trigger an action only when the tokens of my XYZ mint are transferred from any account to treasury
BTreeMaps don't work either yet
No, unfortunately
Does anchor support the HashMap type? after running `anchor test`, I get the idl error ```Type not found: {"name":"judges","type":{"defined":"HashMap<Pubkey,u16>"}}```
In general, if there is a way to fix this, what would be the best way for all/general types?
Drift uses pyth
You can't in solana. If you want an AccountInfo, you need to pass that pubkey in from the client as an account.
Just do `*sInfo`
How would I to_account_info this?
"ctx: Context<Initialize> ", is it parameter ?
ok... nevermind... i was just missing `libudev-dev` package ü§¶
Hi everyone 
very new to Anchor and Solana... just tried to install `anchor-cli` as `avm use latest` asked me for but it doesnt succeed.

here's the error in my terminal:
```bash
error: failed to run custom build command for `hidapi v1.2.7`

Caused by:
  process didn't exit successfully: `/tmp/cargo-installtjmfyE/release/build/hidapi-6b926c95403ad6b5/build-script-build` (exit status: 101)
  --- stdout
  cargo:rerun-if-env-changed=LIBUDEV_NO_PKG_CONFIG
  ...
  ...
  ...
  --- stderr
  thread 'main' panicked at 'Unable to find libudev: `"pkg-config" "--libs" "--cflags" "libudev"` did not exit successfully: exit status: 1
  --- stderr
  Package libudev was not found in the pkg-config search path.
  Perhaps you should add the directory containing `libudev.pc'
  to the PKG_CONFIG_PATH environment variable
  No package 'libudev' found
  ', /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/hidapi-1.2.7/build.rs:53:54
  note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
warning: build failed, waiting for other jobs to finish...
error: failed to compile `anchor-cli v0.22.1 (https://github.com/project-serum/anchor?tag=v0.22.1#b733610d)`, intermediate artifacts can be found at `/tmp/cargo-installtjmfyE`

Caused by:
  build failed
Error: Failed to install 0.22.1, is it a valid version?
```

I've tried to find but there's no open issue on Github 
I guess it's just something I'm missing locally... but I do not understnad what exactly ü§∑‚Äç‚ôÇÔ∏è ??
When i deploy my solana program to devnet / testnet I am getting `Invalid blockhash error` .

My tools:
- `anchor-cli` - `0.21.0`
- `solana-cli` - `1.9.5`
anyone know any good open source codebases using pyth?
9  | #[program]
   | ^^^^^^^^^^ the trait `anchor_lang::Accounts<'_>` is not implemented for `Initialize<'_>`
   |
note: required by `anchor_lang::context::Context::<'a, 'b, 'c, 'info, T>::new`
  --> /root/.cargo/registry/src/github.com-1ecc6299db9ec823/anchor-lang-0.22.1/src/context.rs:51:5
   |
51 | /     pub fn new(
52 | |         program_id: &'a Pubkey,
53 | |         accounts: &'b mut T,
54 | |         remaining_accounts: &'c [AccountInfo<'info>],
55 | |         bumps: BTreeMap<String, u8>,
56 | |     ) -> Self {
   | |_____________^
   = note: this error originates in the attribute macro `program` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: no method named `exit` found for struct `Initialize` in the current scope
  --> programs/sol-poll/src/lib.rs:9:1
   |
9  | #[program]
   | ^^^^^^^^^^ method not found in `Initialize<'_>`
...
44 | pub struct Initialize<'info> {
   | ---------------------------- method `exit` not found for this
   |
   = help: items from traits can only be used if the trait is implemented and in scope
   = note: the following trait defines an item `exit`, perhaps you need to implement it:
           candidate #1: `anchor_lang::AccountsExit`
   = note: this error originates in the attribute macro `program` (in Nightly builds, run with -Z macro-backtrace for more info)

Some errors have detailed explanations: E0277, E0432, E0599.
For more information about an error, try `rustc --explain E0277`.
error: could not compile `sol-poll` due to 5 previous errors
'error: bump targets should not be provided with init. Please use bump without a target.
  --> programs/sol-poll/src/lib.rs:58:57
   |
58 |     #[account(init, seeds = [b"vote_account".as_ref()], bump = vote_account_bump, payer = user)]
   |                                                         ^^^^

error[E0432]: unresolved import `crate`
 --> programs/sol-poll/src/lib.rs:9:1
  |
9 | #[program]
  | ^^^^^^^^^^ could not find `__client_accounts_initialize` in the crate root
  |
  = note: this error originates in the attribute macro `program` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: no function or associated item named `try_accounts` found for struct `Initialize` in the current scope
  --> programs/sol-poll/src/lib.rs:9:1
   |
9  | #[program]
   | ^^^^^^^^^^ function or associated item not found in `Initialize<'_>`
...
44 | pub struct Initialize<'info> {
   | ---------------------------- function or associated item `try_accounts` not found for this
   |
   = help: items from traits can only be used if the trait is implemented and in scope
   = note: the following trait defines an item `try_accounts`, perhaps you need to implement it:
           candidate #1: `anchor_lang::Accounts`
   = note: this error originates in the attribute macro `program` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the trait bound `Initialize<'_>: anchor_lang::Accounts<'_>` is not satisfied
  --> programs/sol-poll/src/lib.rs:9:1
   |
running into this set of errors upgrading the program from version 0.16.0 to 0.22.1
when i run anchor build it throws this error 

```
anchor build
Only x86_64 / Linux distributed in NPM package right now.
Trying globally installed anchor.
BPF SDK: /Users/mp-haidera-pyse-403/.local/share/solana/install/releases/1.8.0/solana-release/bin/sdk/bpf
Running: rustup toolchain list -v
Running: cargo +bpf build --target bpfel-unknown-unknown --release
error: failed to download `solana-frozen-abi v1.9.2`

Caused by:
  unable to get packages from source

Caused by:
  failed to parse manifest at `/Users/mp-haidera-pyse-403/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-frozen-abi-1.9.2/Cargo.toml`

Caused by:
  feature `edition2021` is required

  consider adding `cargo-features = ["edition2021"]` to the manifest
```
dunno whats mpl-token-metadata, but spl programs seem to be there.
anchor test uses local blockchain, not devnet or testnet (unless otherwise configured)
on devnet and testnet you will have those programs deployed for sure
it seems that spl token is available for testing during anchor test. Do I every need to deploy SPL token contract? How about mpl-token-metadata ?
would this be different for devnet and testnet ?
Is it the same account as you use in `declare_id!`?
I'm hitting a wall with `anchor idl init` (localnet). It looks like it might be the same issue as https://github.com/project-serum/anchor/issues/1543 but afaict the program ID I'm passing is correct--unless I'm completely misunderstanding the command
```
const signers = [];
            if (gem_common_2.isKp(vaultOwner))
                signers.push(vaultOwner);
            console.log(`depositing ${gemAmount} gems into ${gemBox.toBase58()}, GDR ${GDR.toBase58()}`);
            const txSig = yield this.bankProgram.rpc.depositGem(vaultAuthBump, gemRarityBump, new anchor.BN(gemAmount), {
                accounts: {
                    bank,
                    vault,
                    owner: (0, gem_common_2.isKp(vaultOwner))
                        ? vaultOwner.publicKey
                        : vaultOwner,
                    // owner: vaultOwner,
                    authority: vaultAuth,
                    gemBox,
                    gemDepositReceipt: GDR,
                    gemSource,
                    gemMint,
                    gemRarity,
                    tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
                    systemProgram: web3_js_1.SystemProgram.programId,
                    rent: anchor.web3.SYSVAR_RENT_PUBKEY,
                },
                remainingAccounts,
                signers,
            });
            console.log("we are after the txSig");
```
Hello, I am trying to understand signers right here, and in the check for if keypair of the vault is there, I push the keypair as one of the signers, I keep getting the signers as being empty. 

I have also removed this if statement, and I get to the signature approval section, but after I sign the transaction, I am unable to read the signer's publicKey
So sInfo is of type: `Account<'info, SwapInfo>` . 
If I want to extract just the SwapInfo I believe `sInfo.account` would give it to me but it's private? How else can I log it?
Does my question make sense <@!134416332509675520> ?
Ok, made a bunch of progress. Any way to make the `account` field not private on an Account struct within anchor?
```error[E0616]: field `account` of struct `anchor_lang::prelude::Account` is private
  --> programs/stableTry/src/lib.rs:12:38
   |
12 |         msg!("raw data1:{:?}", sInfo.account);
   |                                      ^^^^^^^ private field
```
oh, the actual saber files are broken. Lmao. Thx anyway
```error: suffixes on a string literal are invalid```
Hey guys, i was trynna make the messengerapp and i got stuck in the end, i dont know what¬¥s happening fr, can someone help me please?
invalid suffix, anything come to mind?
also have this error in same place
```#[derive(Accounts)]
  |          ^^^^^^^^ invalid suffix `A````
Ok, I don't think I have enough info to help more, it might be something else‚Äîwhat you have above looks roughly ok, besides the Clone part
Ok, btw this is just the file from the Saber github. Wouldn't expect to need to modify it just to get deserialize working
You can send sol from one of your own accounts without doing any CPI
It's the only way to send sol from a system account
https://discord.com/channels/889577356681945098/889702325231427584/894622214824030289 explains it pretty well. Thank you
yeah. I was trying to impl program-owned SOL and not realizing that CPI is not the only why to send and receive SOL
But you definitely don't need the Clone/it won't work, so get rid of it
Can you also just be safe and get rid of that triple backslash comment
hmm, same problem still
Yeah, possibly‚Äîwhy are you allocating space for a system account?
I think it's because I have also used space =8 which means there data allocated
Get rid of that clone too lol
```#[derive(Accounts, Clone)]
pub struct InitToken<'info> {
    /// The token account for the pool's reserves of this token.
    pub reserve: AccountInfo<'info>,
    /// The token account for the fees associated with the token.
    pub fees: AccountInfo<'info>,
    /// The mint of the token.
    pub mint: AccountInfo<'info>,
}```
I mean how is that struct defined
I'm just trying to get the dependencies working to deserializer it
https://discord.com/channels/889577356681945098/889702325231427584/894622214824030289
I used 'owner = system.key' annotation
It's some other struct from the saber protocol
What is InitToken?
same thing happens if I change ```#[derive(Accounts, Clone)] -> #[derive(Accounts)]```
Mm, just get rid of it haha, it's not relevant in that context
or dependency?
oh is it expecting another import?
whats derive clone used for?
Can't derive Clone there
Do you know what might cause this error?
```
error: expected one of `.`, `?`, `]`, or an operator, found `" token of the swap.
"`
 --> /home/a/stable-swap/stable-swap-anchor/src/accounts.rs:6:10
  |
6 | #[derive(Accounts, Clone)]
  |          ^^^^^^^^ expected one of `.`, `?`, `]`, or an operator
  |
  = note: this error originates in the derive macro `Accounts` (in Nightly builds, run with -Z macro-backtrace for more info)
```
File just looks like this:
```
use anchor_lang::prelude::*;
/// Accounts for an [crate::initialize] instruction.
#[derive(Accounts, Clone)]
pub struct Initialize<'info> {
    #[account(signer)]
    pub swap: AccountInfo<'info>,
    pub swap_authority: AccountInfo<'info>,
    pub admin: AccountInfo<'info>,
    pub token_a: InitToken<'info>,
    pub token_b: InitToken<'info>,
    pub pool_mint: AccountInfo<'info>,
    pub output_lp: AccountInfo<'info>,
    pub token_program: AccountInfo<'info>,
}
```
Why do you think it's owned by the system program? I'm pretty sure it's not
Error when transfer SOL using CPI
---
Transfer: from must not carry data
---
Understanding that you would get if transfer from account NOT owned by System program, but in my case the account IS OWNED by system program,
but has a 8bytes space allocated. Could I ask why the error ?
Kind of don't think that should be necessary though
Maybe also/instead do
```.rs
use anchor_lang::Owner;
```
Can I show you my Cargo.toml for the main file
hmm, wait nevermind, still same issue
thx
lmao, ok, that did something
Even if traits have the same name etc., they're strictly speaking different if they come from different versions of the same crate
Unfortunately they're probably going to need to be the exact same version :/
one is >=0.22.0 one is 0.22.1
Are you using the exact same anchor-lang version in both crates?
<@!134416332509675520> am I missing something basic in rust? I have swapInfo implementing `Owner`:
```impl Owner for SwapInfo {
    fn owner() -> Pubkey {
        crate::ID
    }
}```
which then gets imported to my main file by a dependency from a cargo.toml file. After trying to compile the main file I get:
```error[E0277]: the trait bound `SwapInfo: Owner` is not satisfied
   --> programs/stableTry/src/lib.rs:20:26
    |
20  |   pub swap_info_account: Account<'info, SwapInfo>
    |                          ^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Owner` is not implemented for `SwapInfo`
    |
note: required by a bound in `anchor_lang::prelude::Account`
   --> /home/a/.local/share/cargo/registry/src/github.com-1ecc6299db9ec823/anchor-lang-0.22.1/src/accounts/account.rs:221:70
```
Is their something special about the keyword "trait" that I'm missing? Why doesn't it recognize the owner trait?
is there a way to declare space as a variable based on the size of an array?
For example if i'm going to declare an account that will contain an array, then is there a way to make space = "size of array"??
I don't know, try logging what whitelistAddress is I guess
What about this error message?
You have 256 chances, so the chance of not finding a suitable off-curve address is 1/2^256, which is unbelievably small.
No, there's a 50/50 chance *per bump choice* that it won't work
You said there is a 50/50 chance that they don't find it. If so, will there be an error message that shows up and I have the change the seed?
Think of PDAs as being a map/association/whatever from [seed1, seed2, ...] ==> the resulting address.
No, the seeds are arbitrary-ish chunks of bytes that "name" the address, and the bump is a single byte that makes sure the resulting address is off-curve
got it so the seeds are an arbitrary value that helps to find the bump that is "off-curve"?
And findProgramAddress finds something that's *not* on the ed25519 curve: https://discord.com/channels/889577356681945098/889702325231427584/939324164890845265
Seeds are an array of arbitrary (well, not too long) chunks of bytes
Once you upgrade to 0.22.1 try switch "ProgramResult" to "Result<()>"
I have a quick question regarding finding the "findProgramAddress" function. I understand that it is trying to find a valid program address on the ed25519 curve. So, when I give seeds to the findProgramAddress call, when I use nfts as a public key, I am able to retrieve its Uint8Array by using the <NFT publicKEY>.toBytes() function. However if I use a token address to do so, I get that it is not a function and an error message like above.

I checked the anchor source code and token mint address is used as one of the seeds with giving it a mint.toBuffer() function.
```
export async function associatedAddress({
  mint,
  owner,
}: {
  mint: PublicKey;
  owner: PublicKey;
}): Promise<PublicKey> {
  return (
    await PublicKey.findProgramAddress(
      [owner.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mint.toBuffer()],
      ASSOCIATED_PROGRAM_ID
    )
  )[0];
}
```

However, sometimes it is given a literal string, 
```
 const [redeemableMint, redeemableMintBump] =
      await anchor.web3.PublicKey.findProgramAddress(
        [Buffer.from(idoName), Buffer.from("redeemable_mint")],
        program.programId
      );
```
What is the difference between the two? And when are their use cases for the two?

Can you show the actual full error message?
Hello, I am working with gemworks and had a question regarding it. I was trying to use a function called "findWhitelistProofPDA"

```
export const findWhitelistProofPDA = async (
  bank: PublicKey,
  whitelistedAddress: PublicKey
) => {
  console.log("We are in the findWhiteListProofPDA", whitelistedAddress);
  return PublicKey.findProgramAddress(
    [Buffer.from('whitelist'), bank.toBytes(), whitelistedAddress.toBuffer()],
    GEM_BANK_PROG_ID
  );
};
```
However, something weird that I encountered is that on my front end when it reaches this line of code, I get an error message called, ```whitelistedAddress.toBytes()``` is not a function. However, no where in my code, I am able to see this since I changed the code from 
```whitelistaddress.toBuffer --> whitelistedAddress.toBytes()```. Could someone advise me why my changes are not being reflected properly?
thx
Yep, check out this part of the tutorial: https://project-serum.github.io/anchor/tutorials/tutorial-3.html
<@!134416332509675520> 
Any examples of adding an anchor project as a dependency so I can read account data from it?

Not sure with how to add dependencies in anchor / rust
The snippet you have there is a little confused, you would need to use `#[account]`, not derive(Accounts), and yeah, use a Pubkey for mint
Feel like you would need to store a Vec<MintConfiguration> tho
Then you would just have a handler only the program owner could call to add or update the structs
did you figure out a path forward for this? Im looking for something like this as well but also want to store configurations for each like 

```
#[derive(Accounts)] // or #[state] ?
pub struct MintConfiguration<'info> {
  mint: Account<'info, Mint>, //or just Pubkey
  fee: u16,
  mint_bump: u8,
}
```
Then get the PDA with this account struct to get the configuration for a certain mint. Not sure if this is good practice tho
Yeah, I should have explained further‚Äîthank you for actually writing it out üôè
I'm having problems with polling solana account data and data flashing back and force from old account to new account. Using `confirmed`
Is there a way to get the blockhash of the account data or anything?
to explain a bit more what he means - let me give you an example of SOL (but it doesn't really matter if it's SOL or any other currency):
- 1 SOL = 1_000_000_000 LAMPORTS (can be whatever you set, based on the decimals field)
- you define the transfer amounts in LAMPORTS (not in SOL)
- 1.2 SOL = 1_200_000_000 LAMPORTS

does that make sense?
All token balances are integers, so it doesn't really make sense to transfer floats.
Wouldn't 1.2 be more precise than 1?
so if a user would like to send spl-tokens, would you advise me to send via whole numbers? It is not possible to do an spl-transfer like 1.2?
You probably don't want to transfer any assets in floating point, it's not precise.
hello, is it possible to do token::transfer using f64 instead of u64? Currently it looks like it is using u64.
Does anyone know how to properly implement errors when they're defined in two different files? I'm facing an issue where one file's errors overwrite the other's in the IDL upon building, and therefore, the wrong error getting returned.
Has anyone played around with f32 vs f64 performance in terms of compute unit usage?  There's this: https://github.com/solana-labs/solana-program-library/tree/master/libraries/math for fixed-point vs f64 but nothing for f64 vs f32
won't affect most people I don't think
not a big deal really I just didn't know
it can't be. what it does is tell the tests where your program is located (it's just the program address).
Anchor add's it to your idl when you deploy via anchor deploy or anchor test but I had to add it manually when using solana program deploy
not quite sure what this field you pasted there does, but feels like something that can be configured with Anchor.toml maybe?
nothing it just doesn't add that metadata field to deploy so you can run tests via anchor run test if deploying that way
whats wrong with solana program deploy?
<:bagsLove:500156064507887618>

Nvm turns out that was the issue. Had to manually add my metadata to the idl and now it works:
I would if I could. Unfortunately deploying on mainnet-beta using the default rpc almost never works. I'm forced to use solana program deploy and use my own custom rpc to get deploy's to work.

Maybe the issue lies in there?
Try just `anchor test`
any ideas what this could be?

I have two tests that run fine on provider cluster devnet

Getting a weird issue when I run:
```
anchor run test
```
On mainnet-beta none of my tests run?
<@!134416332509675520> to continue on our previous conversation, what would a constraint look like that verifies that the signer is one in a list of valid signers?


//////////////////////////////////////////////////////////////////////////////////////////

Lol, i‚Äôll check that..
Ah, you're probably just using the wrong bump then
they look identical..
and this on the rust side
getting this on the typescript side
thx a lot, managed to print it!
ah nvm i'll see it on the error log.
oh also, if the transaction doesn't get through, where can I see the logs?
lol, alright
One silly hack you can do is
```.rs
space = {
    msg!("hmmmmmm {:?}", _index.to_le_bytes());
    8 + PositionAccoutnSaber::LEN
}
```
``` 
#[derive(Accounts)]
#[instruction(
    _bump_portfolio: u8,
    _bump_position: u8,
    _max_initial_token_a_amount: u64,
    _max_initial_token_b_amount: u64,
    _min_mint_amount: u64,
    _index: u32,
)]
pub struct ApprovePosition<'info> {

    #[account(mut)]
    pub owner: Signer<'info>,

    #[account(
        init_if_needed,
        payer = owner,
        space = 8 + PositionAccount::LEN,
        seeds = [
            owner.key().as_ref(),
            &_index.to_le_bytes(),
            seeds::USER_POSITION_STRING
        ],
        bump = _bump_position,
    )]
    pub position_pda: Box<Account<'info, PositionAccount>>,

```
Can you show me your derive(Accounts)?
whats the best way to print this on the rust side actually?
devnet is a bit clugged it seems, so trying to not push so msg! takes time
I didn't print it yet, I guess the next step üòÖ
or do any additional bytes get concetanated somewhere without me knowing xD
Have you checked that it does?
and then this here `Buffer.from([...bn.toArray("le", 4)])` is also supposed to return me 4 bytes, in the exact same order
Yep, that sounds fine
which returns me 4 bytes
but so the type ` _index: u32,`
needs to be serialized to `&_index.to_le_bytes(),`, right?
You just need to be really careful to make sure the byte are exactly the same
or any pointers on how to seed the PDA by some index?
any idea what / how else I could debug?
still getting some signature errors though.. I also tried this program completely without the "index" part. 

i.e. it was working fine when I just used owner.pubkey and SEED.POSITION_ACCOUNT as the seeds
ah ok, thx!
Yes
ah, so this is not bits, it's bytes?
u32 is 4 bytes, not 32
index is u32
Have to be very careful to use the right number of bytes
where I use 
``` 
bnTo8(bn: BN): Uint8Array {
        return Buffer.from([...bn.toArray("le", 32)])
    }
``` one of the previous messages in this discord to arrive at a buffer for the BN
What datatype is that index thing?
in typescript, I have this 
```
let [positionPDA, bumpPosition] = await PublicKey.findProgramAddress(
            [this.owner.publicKey.toBuffer(), indexAsBuffer, Buffer.from(anchor.utils.bytes.utf8.encode(SEED.POSITION_ACCOUNT_APPENDUM))],
            this.solbondProgram.programId
        ); 
```
in rust, I have this: 
```
seeds = [
            owner.key().as_ref(),
            &_index.to_le_bytes(),
            seeds::USER_POSITION_STRING
        ], 
```
hey guys, i'm having difficulty building more complex PDAs from seeds
Probably easiest way to check this is just by reading the anchor cli source: https://github.com/project-serum/anchor/blob/master/cli/src/lib.rs#L2142
Nope, you need to rerun anchor build before you deploy
For example, if I update my program (*.rs) code, and I run anchor deploy, will this catch my changes? Or do I need to run anchor build && anchor deploy for my changes to be picked up?
üëã have a question about the IDL vs. the .so file and anchor build/test/deploy. What sequence of commands do I need to run to have the most up to date .so file before I'm able to deploy? If the .so is up to date does this also mean my IDL is up to date?
How do I learn how to send spl token to an account? is there any github repo or tutorial??
Yuh, figured it out but tyvm, y‚Äôall are the best
Not a full keypair, no. You can do `new anchor.web3.PublicKey` if you want to use a known public key, but you can't figure out the secret key.
üëã For the purposes of testing in Anchor, is there a way to generate a keypair with the public key being a specific string?
Ahh got it thanks
So you're somehow using the wrong owner/mint combo
Which doesn't match the one in the link, 2ahEDcaprLwm3y1pka24Ub61GxXXGgq2WpWXjBdRftMv
By my calculations, using the accounts in that solscan link, the ATA address ought to be "9yHYp4u6gb9VuST7e9rx76xbkZxXhcjJiy3e9N8CKCAQ"
tokenAccount = await Token.getAssociatedTokenAddress(
        ASSOCIATED_TOKEN_PROGRAM_ID, 
        TOKEN_PROGRAM_ID,
        mintPublicKey,
        wallet
    );
(And it's probably not correct, hence the error you're getting)
That's the only way to check if it's correct‚Äîbut checking how you originally calculated it
Sure, but how did you originally calculate it?
I saved it somewhere in an account and then passing it in create instruction
But how are you calculating the address on the client?
How are you calculating it?
Why do you think it's correct?
Doesn't sound like it üòõ
I'm not sure why its throwing me the error but the associated address that I'm getting is correct.
That means you're not calculating an associated token address correctly
ah, solscan just makes it extra confusing
I would say just use the regular explorer: https://explorer.solana.com/address/EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v
yep, I plan on having a static list in my program.

```
static ALLOWED_MINTS: [Pubkey; 3] = [
        solana_program::pubkey!("")
    ];
```

and then doing a check as an anchor account macro constraint. Other option is to create a PDA for each allowed mint and checking if that PDA exists or not (if you wanted to do it programmatically)
quick bump here! reposting the question:

üëã For a given SPL token, is the token address the same thing as the mint? e.g. for USDC (https://solscan.io/token/EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v) the token address is `EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v`
Getting an error -> 

#1 Associated Token Account Program instruction
> Program log: Error: Associated address does not match seed derivation
> Program Associated Token Account Program  consumed 7542 of 200000 compute units
> Program returned error: Provided seeds do not result in a valid address
I think token accounts are the only special case
not default means:
1. owner =xx
2. TokenAcount 
Ôºü
Yep, "By default" (so not always)
https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html
"By default init sets the owner field of the created account to the currently executing program. Add the owner constraint to specify a different program owner."
At any rate, no, in the above case ownership is assigned to the spl token program
My version of that page doesn't say that
Where are you getting that quote from?
"account(init) would assign owner to the executing program." https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html

Is this always true in the following example ? (doesn't seem to be since TokenAccount is owned by spl token program.
```
#[derive(Accounts)]
#[instruction(vault_account_bump: u8, initializer_amount: u64)]
pub struct Initialize<'info> {
    #[account(
        init,
        seeds = [b"token-seed".as_ref()],
        bump,
        payer = initializer,
        token::mint = mint,
        token::authority = initializer,
    )]
    pub vault_account: Account<'info, TokenAccount>,
```
Why or why not?
Only for adding pda signatures
Hey <@!134416332509675520>  I have a question is invoke_signed used for pda as a signers only or it is also used for signing by the authority or the user as well
GOT IT Thanks
The ? implicitly does what you're trying to do with map_err (so the map_err part is unnecessary)
Just do `)?;`
Get rid of the map_err
<@!134416332509675520>
This is the Error

this is
Gotta show me the actual error
and is it not compulary to have that in an anchor function ? <@!134416332509675520> Sorry for asking noob questions
Ok but if i add Ok(()) then it gives error why
nice profile picture
The question mark sort of does an implicit map_err
No map_err at all
Oh, sorry, just do `)?;`
~~Just do `).map_err(Into::into)?;` (use the ? mark)~~
But what if i have multiple invoke sign in an Instruction
ohk it worked
Just have that be the last expression in your whole function
Get rid of the semicolon and the following Ok(()) part
It comes when i add map_err(Into::into)
When i try to add 
       ` invoke(
            &ix,
            &[
                ctx.accounts.metadata.clone(),
                ctx.accounts.mint.clone(),
                ctx.accounts.payer.clone(),
                ctx.accounts.payer.clone(),
                ctx.accounts.payer.clone(),
                ctx.accounts.system_program.to_account_info(),
                ctx.accounts.rent.to_account_info()
            ],
        ).map_err(Into::into);`
I am getting this error
Okay
No, unfortunately (custom deserialization doesn't really mesh with the IDL concept, since currently there's no way to specify how that deserialization should work for different clients)
anything I can derive to solve this?
I implemented Anchor Deserialize for one of the structs myself, but now the idl doesn't generates code for that struct type
hey guys, is the public key / program Id output by 
`anchor keys list`

the same as what is generated when you `anchor build / deploy`
Yes, it's in seconds since the "epoch", Jan 1 1970 (negative seconds for times before then)
Kind of goofy, but rename that `program_id` variable to something different
Why is this error comming
Hey <@!134416332509675520> i am getting this error
That means you're somehow trying to invoke an instruction in your program that doesn't actually exist. Often because you messed up deploying.
For reference, my file looks like this
```
[workspace]
members = [
    "programs/*"
]
```
anyone know why vscode linker gives this error on anchors main cargo.toml? 

```
build failed
error: could not compile `libsecp256k1-core`
```
Hi, how can I write account's data directly for testing purposes in Anchor JS test script?
whats this error mean? ```    Program log: AnchorError occurred. Error Code: InstructionFallbackNotFound. Error Number: 101. Error Message: Fallback functions are not supported.
```
Which tutorial are you talking about?
No
is the unix timestamp in seconds?
Use clock
how do I get current time in anchor/solana to store in an account?
I had a similar question and did some more digging around and found this tutorial on youtube. Pretty close to what you need and you might be able to take a few points off of it. Hope it helps
Hello, can someone point me to some documentation/tutorial on how to send spl tokens within anchor? 

I'm trying to create an endpoint that request some amount of an spl token to be transferred from the users wallet into another wallet, and if it was successful do something. TIA
Getting the follow error after I sign and approve,
```
Uncaught (in promise) TypeError: Cannot read properties of undefined (reading 'toString')
    at Transaction.partialSign (index.browser.esm.js?3ee8:2673:1)
```
Willing to compensate for your time. Please dm me. Have been at this for hours and can't seem to figure it out for some reason
Would anyone be able to spare 5 min to debug an issue that I am running into?
üëã For a given SPL token, is the token address the same thing as the mint? e.g. for USDC (https://solscan.io/token/EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v) the token address is `EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v`
thank you
Put `#[account(mut)]` over `user` in your `Initialize`
use anchor_lang::prelude::*;

declare_id!("Atb1sMsLSSuNicdiAXKPwy5ecRAnFacWXQxhw2iQBfo");

#[program]
mod crunchy_vs_smooth {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>, vote_account_bump: u8) -> Result<()> {
        ctx.accounts.vote_account.bump = vote_account_bump;
        Ok(())
    }

    pub fn vote_crunchy(ctx: Context<Vote>) -> Result<()> {
        ctx.accounts.vote_account.crunchy += 1;
        Ok(())
    }

    pub fn vote_smooth(ctx: Context<Vote>) -> Result<()> {
        ctx.accounts.vote_account.smooth += 1;
        Ok(())
    }

    pub fn vote_neutral(ctx: Context<Vote>) -> Result<()> {
        ctx.accounts.vote_account.neutral += 1;
        Ok(())
    }

}

#[derive(Accounts)]
#[instruction(vote_account_bump: u8)]
pub struct Initialize<'info> {
    #[account(init, seeds = [b"vote_account".as_ref()], bump, payer = user)]
    vote_account: Account<'info, VotingState>,
    user: Signer<'info>,
    system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct Vote<'info> {
    #[account(mut, seeds = [b"vote_account".as_ref()], bump = vote_account.bump)]
    vote_account: Account<'info, VotingState>,
}

#[account]
#[derive(Default)]
pub struct VotingState {
    crunchy: u64,
    smooth: u64,
    neutral: u64,
    bump: u8,
}

Without seeing more of the code, I can't be sure, but my guess is that you labeled `vote_account` somewhere as the `payer` in that `Accounts` derive, and it doesn't like that because the `vote_account` isn't signing
Hey does anyone know of any tutorials telling how to create and send payments to an address using anchor?
any idea how to address these as a result? error: the payer specified for an init constraint must be mutable.
  --> programs/sol-poll/src/lib.rs:62:5
   |
62 |     vote_account: Account<'info, VotingState>,
   |     ^^^^^^^^^^^^

error[E0432]: unresolved import `crate`
 --> programs/sol-poll/src/lib.rs:9:1
  |
9 | #[program]
  | ^^^^^^^^^^ could not find `__client_accounts_initialize` in the crate root
  |
  = note: this error originates in the attribute macro `program` (in Nightly builds, run with -Z macro-backtrace for more info)
I'm hitting a wall with `anchor idl init` (localnet). It looks like it might be the same issue as https://github.com/project-serum/anchor/issues/1543 but afaict the program ID I'm passing is correct--unless I'm completely misunderstanding the command. Is it the same account as is specified in `declare_id!`?
Now you can just say `bump` instead of `bump=some_var`
What is the bump account issue between versions?
error: bump targets should not be provided with init. Please use bump without a target.
  --> programs/sol-poll/src/lib.rs:58:57
   |
58 |     #[account(init, seeds = [b"vote_account".as_ref()], bump = vote_account_bump, payer = user)]
   |                                                         ^^^^
moving from 0.16.0 to 0.22.1
Like, say I want to deserialize some X into a Y, and it's implemented, how do I actually transform an instance of X into a Y?
How do you actually call deserialize on something in Rust?
Is there a way to send a transaction without a user signing for it? For example the user makes a transaction where they buy something, then I want to update a pda owned by the program with the transaction Id of the original purchase transaction. But if possible without the user having to sign for it again

Hey how do I change a wallet's sol balance like transfer to different wallet
I should pull from here am I worng??
any idea what im missing?
im running `anchor deploy` on the serum dex program targeting a `solana-test-validator`, but its not going to the desired address - i edited the `Anchor.toml` to have 
```[programs.localnet]
serum_dex = "9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin"```
but its still going to the address `3MYWDHjNojvKFqzXX89ioxccQUb3UQbyzam2d94xk3df` every time
grep'ed for that address in the dex repo and no hits
np thanks for the suggestion, I'm a Rust newbie, but taking a stab at some web API stuff in Rust, it's been half super fun, half super difficult hahaha
Oh, sorry, I was thinking in TS
Compiler complains when I try that:
```
let tx = Transaction::from(&bs58::decode(body.raw_msg).into_vec()?);
                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `solana_sdk::transaction::Transaction`, found `&Vec<u8>`
```
Think you can use `Transaction.from`
The Rust SDK has `tx.message.serialize()` if I want to serialize a `Transaction` into a signable message, but how would I deserialize that message back into the `Message` or `Transaction` object?
Thank you!
Ah that explains why it isn't working on 0.22.1 but works on 0.18.2
https://github.com/project-serum/anchor/blob/master/CHANGELOG.md#breaking-2
```
and when I put anchor keys list :

~/solyetis-staking-app-master/contracts/flexible_staking_contract$ anchor keys list
thread 'main' panicked at 'Code not parseable: Error("bump targets should not be provided with init. Please use bump without a target.")', lang/syn/src/idl/file.rs:357:58
note: run with RUST_BACKTRACE=1 environment variable to display a backtrace
```
Anyone seen this error?
against devnet, that is
`     Error: 429 Too Many Requests:  {"jsonrpc":"2.0","error":{"code": 429, "message":"Too many requests for a specific RPC call, contact your app developer or support@rpcpool.com."}, "id": "1c8441e1-b5aa-436d-8c09-0b27340af6f4" } `
Also, are folks getting this when running tests against devnet?  Did the rate limiting become tighter lately?
Ah did not realise the --help could be used on the subcommands too. cheers!
`anchor test --skip-deploy` (can run `anchor test --help` for more options)
Burn all of them? No, you'd have to loop over them or something
Is there a way to prevent anchor test from doing a deploy first?
üëã is there a function that exists to burn all NFTs in your wallet?
Trying to attach a recent block hash Rust-side to a `Transaction` before sending the unsigned `Message`.

Getting this compiler error. Weird paths it's referring to, but all I seem to need is some valid type annotation for the vec.
```
tx.partial_sign::<Vec<Keypair>>(&vec![], blockhash);
                  ^^^^^^^^^^^^ the trait `anchor_client::solana_sdk::signers::Signers` is not implemented for `Vec<anchor_client::solana_sdk::signature::Keypair>`
```


//////////////////////////////////////////////////////////////////////////////////////////

<<<<<<< HEAD
ok, so I have redeployed to mainnet several times with different ID after closing, and gone back and re-tested dev. One of my accounts seems to be owned by another program (I am inferring that because I have an instruction that initialises an account that *does* work - its a later instruction with a bunch of other accounts that fails)

could there be any differences between the macro that checks `account is owned by a different program` in dev/main ? 

is there any way to diagnose which account ? technically a bunch of my accounts can be owned by another program so I dont know why this isnt failing over all of them (unless it is and it just doesnt check in dev)
is there a minimum swap amount for the token-swap program? I am seeing this error:
```
Given pool token amount results in zero trading tokens
```

If I raise the amount_in and minimum_amount_out variables i dont see this error anymore, but just being an end user on Orca for example I can trade small amounts without issue
Have there been other reports of this?  Is this a network thing, or perhaps a solana version thing?
I got this error deploying todevnet about 2/3 of the time.  Today i get it every time.  `Error: Custom: Invalid blockhash
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.`
ahh got it
Not if you let it spin up a validator for you‚Äîit uses a "genesis block" trick to skip an actual deploy
doesn‚Äôt anchor test go through an anchor deploy though?
ok thanks!
idk wth I did anymore... thanks tho! Mistakes kinda costly lol
(And maybe rerun `anchor build` and then redeploy just to make sure)
Make sure your `declare_id!` matches the actual runtime program_id
You may have accidentally deleted the old one
hmm.. ok... the keypair.json in the deploy directory does have a different publicKey compared to the deployed program. Will that cause an issue ? 

also confused as to how that file can be different to the deployed program
At any rate, I don't know what's wrong with your anchor test spinup process, sorry!
Ah, yeah‚Äîdeploy only makes sense with respect to a running validator
i have to run a local test validator to deploy
```
Error: RPC request error: cluster version query failed: error sending request for url (http://0.0.0.0:8899/): error trying to connect: tcp connect error: Connection refused (os error 61)
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.
```
is there any other cause of the owned by different program issue ? can I debug the account that is owned incorrectly pls ?
anchor deploy is also now failing so perhaps it is related
yep! tried that, but the same problem occurs
I half deployed using anchor, but it took too long, so I had to switch to a different RPC and finish using solana program deploy...
Hi, am running into `The given account is owned by a different program`

reading the posts it generally relates to delcareId being different in the lib compared to what was deployed.

however I can see DrKZW91WAfgc1f6R3WNLj7UbwnfuJmii8PFtAucooqfh in the file. This is the same as the command line reported when deploying the program.
ok here's what i realize:

When running **anchor test ** my IDL file is populated (or repopulated with) the address metadata upon successful deployment (see image)

When running **anchor test --skip-deploy** those lines in the IDL on the address metadata **immediately disappear**, and although the program instructions seem to run successfully on devnet (CLI output seems ok and sol explorer instruction transactions have no error), the CLI outputs the last line as: `Error: Program address not found.`
Can you just get rid of all of the clones, just to narrow things down?

What does your `.anchor/test-ledger/validator.log` look like? (It might be too big to post)
still getting `Unable to get recent blockhash. Test validator does not look started. Check .anchor/test-ledger/test-ledger-log.txt for errors. Consider increasing [test.startup_wait] in Anchor.toml.`
yep! trying now
Can you try nuking your `.anchor` directory?
Unable to get recent blockhash. Test validator does not look started. Check .anchor/test-ledger/test-ledger-log.txt for errors. Consider increasing [test.startup_wait] in Anchor.toml.
it does look that way, but the validator still does not start
That sort of looks like it worked
What's the actual error message though?
(Debugging tip is to have a checkout of the solana codebase, searching it for `Failed to fetch {}` found that error
I removed a couple, but even so the test validator doesen't seem to start AND has no errors

```
[2022-03-01T16:12:43.456515000Z WARN  solana_perf] CUDA is disabled
[2022-03-01T16:12:43.478490000Z INFO  solana_faucet::faucet] Faucet started. Listening on: 0.0.0.0:9900
[2022-03-01T16:12:43.478513000Z INFO  solana_faucet::faucet] Faucet account address: AdTuv39i8piRGiSGMZpBdN1Faxxt17TuQKMy84nz5cb6
[2022-03-01T16:12:43.481265000Z INFO  solana_core::test_validator] Fetching Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB over RPC...
[2022-03-01T16:12:45.510993000Z INFO  solana_core::test_validator] Fetching EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v over RPC...
[2022-03-01T16:12:45.754411000Z INFO  solana_core::test_validator] Fetching 4bcFeLv4nydFrsZqV5CgwCVrPhkQKsXtzfy2KyMz7ozM over RPC...
[2022-03-01T16:12:46.008505000Z INFO  solana_core::test_validator] Fetching Amig8TisuLpzun8XyGfC5HJHHGUQEscjLgoTWsCCKihg over RPC...
[2022-03-01T16:12:46.257889000Z INFO  solana_core::test_validator] Fetching gLhY2arqFpmVGkpbBbTi3TeWbsWevA8dqrwbKacK3vJ over RPC...
[2022-03-01T16:12:46.513823000Z INFO  solana_core::test_validator] Fetching VMc13PVs9GBhL1hxXeF33XtaKVMjg8YyMMszGawFPS2 over RPC...
[2022-03-01T16:12:46.783379000Z INFO  solana_ledger::blockstore] Maximum open file descriptors: 500000
[2022-03-01T16:12:46.783442000Z INFO  solana_ledger::blockstore] Opening database at ".anchor/test-ledger/rocksdb"
[2022-03-01T16:12:47.071578000Z INFO  solana_ledger::blockstore] ".anchor/test-ledger/rocksdb" open took 288ms
```
You might have a busted account address in there
So maybe just comment out your `Anchor.toml`'s clone section
Ah, that error is coming from failing to clone some accounts
BUQDUjPtzSV2oznkWqn4BM71rsYSNMBuc7NCtEgL9RzQ
Hmm, what does `solana address` say for you?
at the very end
```[2022-03-01T16:07:32.254140000Z ERROR solana_core::test_validator] Failed to fetch BJb1uP68pEuvRojzM61JR49pNSodihorVk6TosVMsr74: AccountNotFound: pubkey=BJb1uP68pEuvRojzM61JR49pNSodihorVk6TosVMsr74```
pointed me to the validator log which says
Have you also read that test-ledger-log?
yea getting the same error even with a longer wait
right?
[test]
startup_wait = 100000
do i need to change a field in the toml for it to take longer to wait?
everytime i've changing the wait, it still doesn't load but I can try again
Did you try that test.startup_wait trick?
it does when i do so manually, but if i turn off the validator and then run anchor test i get `Unable to get recent blockhash. Test validator does not look started. Check .anchor/test-ledger/test-ledger-log.txt for errors. Consider increasing [test.startup_wait] in Anchor.toml.`
What happens if you turn off that validator then?
You can run `solana-test-validator` and see if it starts
to clarify, `anchor test` works fine as long as I have a `solana-test-validator` in  separate window
pretty sure yeah, my test instructions are appearing on sol explorer devnet, no errors seen on the instructions
weird, is there anyway I can check its installed correctly or incorreclty?
Solana works fine on M1 assuming you've installed it correctly (I use an M1 and anchor test spins a validator up just fine)
Are you sure you're running against devnet?
when doing this my test runs fine though, but the end of it it outputs an error line:
`Error: Program address not found.`
how can I get `anchor test` to spin up a local validator as it runs on an m1?
awesome thanks!
`anchor test --skip-deploy`
Is there a way to stop "anchor test" from redeploying the program when testing on devnet?
Ah ok, i understand now! Thanks
So you'll submit one big tx from the client, with at least two instructions: the secp256k1 instruction, plus your own program's instruction.
No (this is the irritating part) you'll have to issue that call as a separate instruction, from the client, and then within your own program you'll have to use instruction inspection to verify that the client really did submit that verification instruction.
By making verify signature call to secp256k1 program from my program?
Yeah (or at least I haven't heard anything about it not working)
also, does anchor 0.20 work with solana 1.9?
Cool, thanks üëç
You can verify on-chain, it's just ergonomically super irritating (that link explains how to do it on-chain using instruction inspection https://docs.solana.com/implemented-proposals/instruction_introspection)
In general you can see a bunch of other ones by searching the anchor repo for `#[account(zero)]`
The multisig test has an example: https://github.com/project-serum/anchor/blob/master/tests/multisig/tests/multisig.js#L32
Any examples on this?
Agh, according to this discussion, I don't think I can verify signature on-chain
https://discord.com/channels/428295358100013066/517163444747894795/943150095040405525
running 1.8 on devnet is flaky already, so i guess would be good to wait until mainnet also upgrades before deploying any programs on mainnet
hey guys, any idea when solana 1.9 comes to mainnet?
Thankyou sir. Ofcourse you had 8 in there as the previous example was a u64. This has been a good exercise in organising the order of bytes lol üòÖ
Thank you!
Perhaps this will be useful to you. I myself briefly got acquainted with this material when I studied the attack on Wormhole
https://docs.solana.com/ru/developing/runtime-facilities/programs#secp256k1-program
Is it possible to use Ed25519 or Secp256k1 crate in anchor/solana program? I want to verify a message signature on-chain.
`.clone()` is pretty much always just a "fuck it‚Äîgive me a break rust!" They're never really done for "interesting" reasons, just to make rust happy
after `anchor build` keypair is generated for the contract then 
`solana address --keypair ./target/deploy/anchor_escrow-keypair.json`
Thanks a lot for your advice! Yes, indeed, when serialized, it does not preserve the capacity of the vector (only the length + the data itself). Indeed, he makes the most simple steps.
Update: Solution was using "msg!("{:?}", string)" to print non-unicode chars such as null chars and used ".trim_matches(char::from(0));" to remove the null chars.
```let nft_type: &str = &*full_metadata_clone.data.name;

        msg!("{}", nft_type);
        msg!("{}", bronze_name);

        print_type_of(&bronze_name);
        print_type_of(&nft_type);

        if bronze_name == nft_type {
            new_uri.push_str("link");
            new_name.push_str("Silver Flathead");
        } else if silver_name == nft_type {
            new_uri.push_str("link");
            new_name.push_str("Unknown Legendary");
        } else {
            msg!("else hey");
        }
```  Why would this **if statement comparison not be working!**  Both bronze_name and nft_type types are &str and also logged as the same value. Seems to be logging "else hey" so i know the **if is returning false for some weird reason.** Thx for the help
it depends what you want to do
quarry protocol is in prod and much simpler for stake weighed emission
fixed with #![cfg(feature = "test-bpf")]
Hey guys what is the to_account_info() method used for in an account
hey Alan, has this been fixed? I seem to have run into a similar issue
How can I get a transaction before it's signed via the anchor typescript program API? I want to create multiple transactions then send them all to the wallet at once so there isn't multiple signature requests sent to the user's wallet
I'm trying to define an account, but am getting the following error:

```20 | #[derive(Accounts)]
   |          ^^^^^^^^ function or associated item not found in `User`
...
37 | pub struct User {
   | --------------- function or associated item `default` not found for this
   |
   = help: items from traits can only be used if the trait is implemented and in scope
   = note: the following trait defines an item `default`, perhaps you need to implement it:
           candidate #1: `Default`
```
I'm brand new to rust and anchor, and I've searched online, tried the documentation, and used rustc --explain, but I am still having trouble understanding. Code below. Any ideas?
```
#[derive(Accounts)]
pub struct CreateAccount<'info> {
    // Create account of type User and assign user's pubkey as the payer
    #[account(init, payer = owner)] // Need to add space = User::LEN?
    pub account: Account<'info, User>,

    // Define user as mutable - money in their account, profile data, etc.
    #[account(mut)]
    pub owner: Signer<'info>,

    // Ensure System Program is the official one from Solana.
    #[account(address = system_program::ID)]
    pub system_program: AccountInfo<'info> 
}

#[account]
pub struct User {
    pub pubkey: Pubkey,
    pub username: String,
    pub email: String,
    pub description: String,
    // benefits: Vec<String>,
}

impl User {
    const LEN: usize = DISCRIMINATOR_LENGTH
        + PUBKEY_LENGTH
        + STRING_LENGTH_PREFIX + USERNAME_LENGTH
        + STRING_LENGTH_PREFIX + EMAIL_LENGTH
        + STRING_LENGTH_PREFIX + DESCRIPTION_LENGTH;
        // + BENEFITS LENGTH
}

```
would token::set_authority() work to pass an NFT's update authority over to another account or do I have to go through the metaplex program?
This is how I thought I might throw togther a CPI to the metaplex metadata program 

```
CpiContext::new(
            ctx.accounts.nft_metadata_account.to_account_info(),
            update_metadata_accounts_v2(
                ctx.accounts.token_metadata_program.to_account_info().key(), 
                ctx.accounts.nft_metadata_account.to_account_info().key(), 
                ctx.accounts.payer.to_account_info().key(), 
                Some(ctx.accounts.artist_license.to_account_info().key()), 
                None, 
                None, 
                Some(false),
            )

        );
```
lol it doesnt even seem close...vscode is telling me ```the trait bound Instruction: anchor_lang::ToAccountInfos<'_> is not satisfied
the trait anchor_lang::ToAccountInfos<'_> is not implemented for Instruction```
given some account info how do I get the program which owns it in Rust?
in short you sign the transactions, not pass a keypair
This is a great read for how wallets are plugged in: https://github.com/solana-labs/wallet-adapter
üëã have a few super noob-y question: 

1/ when I hit approve via the phantom/sollet interface, what is going on here exactly? Am I passing through my keypair through the `web3.js` call?
2/ Is the idea behind a wallet approve that, given a public Key -> approve -> keyPair? Please point me to some code as a starting point!
so that no new tokens can be minted,
seems like avm is decoupled with anchor altogether. When I try `avm uninstall 0.22.0` and `anchor --version` it stays the same `0.22.0`
Why would you ever want to set the mint authority to be none here?
What am I looking for?
üëã Looking at some examples of some SPL instructions on anchor, why is it that we always need to clone the accounts? i.e.

```
let token_accounts = InitializeMint {
            mint: self.mint.clone(),
            rent: self.rent.to_account_info(),
        };
```
How do I use the token program from a `.ts` test file?
maybe missing `<'info>` in struct definition
check your $PATH
How do I load an older version of anchor? I tried `avm use 0.21.0` it installs but when I check `anchor --version` it's still the same `0.22.0`
I have an instruction in my program that I may want to call from other instructions within my same program, what is the idiomatic way to do this? do I still use CpiContext as if it was a different program?
What is the difference between UncheckedAccount and AccountInfo?
Any thoughts on this error:
```
error[E0107]: this trait takes 0 generic arguments but 1 generic argument was supplied
   --> programs/deltaone-protocol/src/instructions/attempt_liquidation.rs:26:34
    |
26  |     pub vault_lp_token_mint: Box<Account<'info, Mint>>,
    |                                  ^^^^^^^        ---- help: remove this generic argument
    |                                  |
    |                                  expected 0 generic arguments
```
Was just wondering if this repo is being maintained, as I saw the last commit for this was back in July
I saw that stake-v1 was deprecated
https://github.com/project-serum/stake-v2 Looking at spl-token staking, is this the best repo to go by?
This worked Finally! I can call my programs from android üî•
Got it  üëç  thanks dude
sighash is generally sha256("global:instruction_name")
I'm not sure what's going on in your program, but I'm just saying, expect it to be something simple/straightforward
You didn't write exactly what I wrote (what I wrote would have logged something different, with a `vs` in there, etc.)
but i wrote exactly what u specified and then it gave me that log message? is that expected?
also what hash is used sha256?
So what are the parameters for the sighash function? is it instruction:functionName
Basically, rust isn't doing anything tricky/sneaky here
Ok, are you sure the conditional isn't firing?
looks pretty similar...

Just log `msg!("{} vs {}", nft_name, other_name);`
Make your life easier and get rid of that DEBUG thing
so like the names seems the same but it doesn't format correctly, is that a sign taht it might be of a different type??
```Actual name
[DEBUG]Actual name```
and it logs
msg!("[DEBUG]{}", nft_type);
        msg!("[DEBUG]{}", other_name);
Lol
yeh yeh? i tried logging it and it kind of checks out kind of doesn't
I would try logging what the other string is
That's how you compare strings, so must be that the other string is different
I am trying to compare 2 strings in rust unsuccessfully. One is coming from the metaplex metadata.
Currently, it always returns false.
let metadata_full_account = &mut Metadata::from_account_info(&ctx.accounts.nft_metadata_account_5)?;

   let full_metadata_clone = metadata_full_account.clone();

   //this is the first string I am comparing
   let nft_name = full_metadata_clone.data.name;

   let other_string = String::from("some_string");

   if(nft_name == other_string){
    //do something
   }

Thanks for any help.
Looks like running `getProgramAccounts` on the token program times out
```
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: ClientError { request: Some(GetProgramAccounts), kind: Reqwest(reqwest::Error { kind: Request, url: Url { scheme: "https", cannot_be_a_base: false, username: "", password: None, host: Some(Domain("psytrbhymqlkfrhudd.dev.genesysgo.net")), port: Some(8899), path: "/", query: None, fragment: None }, source: TimedOut }) }', bot/src/recover.rs:28:10
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```
How does `getProgramAccounts` behave on a program with ~millions of accounts? Does it return a random subset, or does the request perhaps timeout?
If on the rust side it's a `u16`, then you'd want to do `count.toArrayLike(Buffer, 'le', 2)` since a u16 takes 2 bytes
Coming back to this problem from a while back. If I have a u16 number saved in a customised account (vault.count for example). How could I properly serialize the bytes on the rust and the client side? 

I tried this on the rust side:

``` seeds = [..., vault.count.to_le_bytes().as_ref()]
```
Then this on the client side:
```
const count = new anchor.BN(_count)
PublicKey.findProgramAddress(
  [..., count.toArrayLike(Buffer, 'le', 8)],
  ...)
```

But didn't work. Any other suggestions?
incorrect version of anchor-lang in programs Cargo.toml maybe?
I'm on anchor `0.22`
Any idea why this would happen or how to fix it?
Hello, I'm getting ```error: internal compiler error: expansion entered force mode without producing any errors
``` when I use the #[error_code] macro.  My rustc --version --verbose is rustc 1.59.0 (9d1b2106e 2022-02-23)
binary: rustc
commit-hash: 9d1b2106e23b1abd32fce1f17267604a5102f57a
commit-date: 2022-02-23
host: x86_64-apple-darwin
release: 1.59.0
LLVM version: 13.0.0
The usual way nowadays would be to use PDAs with static seeds, yeah
Unless there's a way I'm missing to track global accounts the program makes use of?
Ah. I guess I'll just have to use PDAs for everything, e.g. the mint, token program, etc.
But you can see lots of examples if you search through the anchor repo's old tests
Strictly speaking the whole macro is deprecated
What is the correct way to use the #[state] macro? When I tried to use it and later access the global state variables in it, I got errors saying that I can only use `self` in associated functions.
Would it be `Clock::get()?.slot`
how do i get the current block # from within the instruction handler?
yea i saw that, but I was ok with the slight difference in precision. thank you though!
Lol
For example, 2509377967226505829 in JS will actually be equal to 2509377967226505700, lol
That number is too big to be safely represented as a JS number, lol, and BN knows this/blows up
thank you!
`BN("12312412342342341324")`
This is a funny issue, you need to wrap the number in quotes
I'm trying to pass a big number into a test and it fails because "Error: Assertion Failed" as soon as it tries to create the BN
```ts
const ammUpdatedBaseAssetAmount = new BN(2509377967226505829);```

```
Error: Assertion failed
    at assert (/Users/user/crypto/cpi-example/node_modules/bn.js/lib/bn.js:6:21)
    at BN._initNumber (/Users/user/crypto/example/node_modules/bn.js/lib/bn.js:128:7)
```
Also was wondering if anyone noticed that `program.account.theAccountType.fetch` is returning the union type of all accounts rather than a specific account's type. Basically I'm getting a return type of `theAccountType | theOtherAccountType | theThirdAccountType` instead of just `theAccountType`. Maybe this is just some issue with the version of anchor I'm using? I've been using a script which always uses the latest anchor pushed
Nice! `fetchNullable` worked. I prefer that method so I'm not making 2 RPC calls
Or I think you can also just use `program.account.theAccountType.fetchNullable` ü§î
`await program.provider.connection.getAccountInfo(theAddress)`
How should I check if an account exists in TypeScript? The generated fetch method from the contract will just throw an error with no specific usable properties if the account doesn't exist. It doesn't make sense to parse the error message there
ur the best :)))
In your anchor.toml, do `mpl_token_metadata = { version = "...", features = ["no-entrypoint"] }`
Thanks; that should work.
`error: the #[global_allocator] in this crate conflicts with global allocator in: mpl_token_metadata`

does anyone know what this error means?
The way that would work is having mint::authority = some_pda_derived_from_your_program
Nope, every mint has an authority on it in solana. You could have your own program be the authority though, and let anyone ask your program to mint tokens.
Or am I misunderstanding the meaning of `mint::authority`?
What if I want anyone to be able to mint tokens, as https://medium.com/linum-labs/intro-to-bonding-curves-and-shapes-bf326bc4e11a ?
To init a mint, you'll need to also use the `mint::decimals =` and `mint::authority = ` attributes in there
Very simplistic so far; I haven't written anything more because the Mint type is giving me that error. Do I even need it?
https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html look at this page
the account docs are pretty good tbh, shows many examples
I just learned how to init some token accounts, associated token accounts, and token account PDAs
can u show ur struct
And my current attempt gives me the error:

```
No function or associated item named `default` found for struct `Mint` in the current scope. This error originates in the derive macro `Accounts`.
```
Google doesn't seem to turn up any.
Are there any good examples or tutorials for using `anchor_spl` to implement an SPL-like token?
i'll push a fix
oh, it's because the doc comment contains `Accounts`, the idl parser thinks its a `#[derive(Accounts)]`
definitely a bug though
it works for me without the doc comment
nope
You presumably didn't need that to be a doc comment right?
Or change it to a regular good old fashioned double slash lol
oh...
I'm saying just delete that triple comment, the `/// Accounts in context of...` part
will probably just do u128 for now, haha
is there any other way to store fixed size data?
hmm
Heh, not sure why yet it would be an issue, but it is ü§∑‚Äç‚ôÇÔ∏è Some kind of bug in anchor's IDL parsing
```rust
/// Accounts in context of initialize_vault instruction
#[account]
#[derive(Default)]
pub struct VaultInfo {

    /// Mint address of token A
    pub token_a: Pubkey,

    /// Mint address of token B
    pub token_b: Pubkey,

    pub vault_name: [u8; 20],
}
```
Actually yes
Nope
Do you have a `///` comment on top of that #[account] line?
is there anything different that has to be done for storing arrays in an acct in 0.22.0? currently trying via:
```rust
#[account]
#[derive(Default)]
pub struct VaultInfo {

    /// Mint address of token A
    pub token_a: Pubkey,

    /// Mint address of token B
    pub token_b: Pubkey,

    pub vault_name: [u8; 20],
```
which I'm 99% sure worked before but i'm getting an error  `thread 'main' panicked at 'Code not parseable: Error("invalid type")', lang/syn/src/idl/file.rs:357:58` . If i change the vault_name to a u8 the code compiles and runs (but obv can only store a u8)
üëã  Does anyone have an example here of how NFTs are collected? For example a series of web3 javascript calls to build up the mint, metadata, master edition, etc?
Thanks a lot, I tried to find it rust documentation ... but honestly I didn't know what to search
It's a rust thing (you can honestly kind of just ignore it if you want): https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html
Hello, I'm trying to work on a simple program to understand a bit more how anchor and rust works. I'm currently reading  some OS programs done with anchor. I see this notation a lot <'info ...  Can someone help me to understand what it does / refer (sorry for the n00b question) ?
Yeah, I'm importing a (deceptively large) struct from a different crate for simplicity and I think that's the issue. I'll probably just end up writing my own pared down version. Thanks for the help!
i would never have figured that out on my own
WOW thank you
You've blown your stack limit by a fair amount though, so I wonder if you have some big structs.
Not that I know of :/ You basically just have to think about it‚Äîthe basic situation is that in solana, each stack frame only gets 4kb of space, so if you e.g. have a large variable on the stack, like `let stuff = [0u8; 2000];`, that's a bad idea (you've just used up 2kb of your 4kb)
Is there any way to get more details about stack space as an output of anchor build (or cargo build-bpf)? I can see this very useful warning when I run anchor build on a program that exceeds the stack: `Function --- Stack offset of 5232 exceeded max offset of 4096 by 1136 bytes, please minimize large stack variables` and I'm trying to get an understanding of where the extra 1136 bytes are coming from. I've Boxed a few accounts but I want to get a deeper understanding of what I'm doing wrong
hello all has anyone been able to successfully  setup and build environment for farms locally from the https://github.com/solana-labs/solana-program-library/tree/master/farms. I get the following errors when trying to compile it with cargo build or cargo build-bpf.

```error: cannot find attribute `error` in this scope
  --> /home/kali/.cargo/registry/src/github.com-1ecc6299db9ec823/vipers-1.6.1/src/lib.rs:58:3
   |
58 | #[error(offset = 1100)]
   |   ^^^^^
   |
note: `error` is imported here, but it is a function-like macro
  --> /home/kali/.cargo/registry/src/github.com-1ecc6299db9ec823/vipers-1.6.1/src/lib.rs:10:5```
The issue is with serde on how rust compiler is confusing import as macro. any info on how to solve it new to anchor and rust programming. Thanks for the help. üôÇ
Get your point thanks!
No idea, sorry. I'm just saying that there's got to be some rust api to send transactions, and I expect it will mirror the JS/TS one
I can find this in the anchor book?
I am very confused.
Or in the anchor_lang in the rust book?
I will search for it
Hello, I am not quite understand why it's matter using canonical bump the example 7 in https://github.com/project-serum/sealevel-attacks/blob/master/programs/7-bump-seed-canonicalization/insecure/src/lib.rs,
 it seems more like an inappropriate seeds problem or the bump should saved inside the data field instead of passing it,  because in that example, both find_program_address or create_program_address are able to verify the given account is actually we want.
is this correct? Could you please explain a little bit? Thanks! <@!501570363566587905> <@!134416332509675520>
There's nothing front-end specific about that call, it just happens to be in JS/TS
There will be some analogue, yeah (presumably)
You mean in my rust program i put a Connection.sendrawtransaction(u8Array)?
Ok i will try when I get to my computer.
I have no idea that would work
Why wouldn't it work from the backend?
That's on front and and works but I want to trigger from backend
Mm, there's a method called `sendRawTransaction` on connection objects, have you tried that?
Any direction about u8 array raw transaction to send?
Ah, I'm saying that is sounds like your client needs to first fetch PDA1 just in order to be able to even know the address of PDA2.
Context 
The CTX.accounts.PDA2 for eg
The accounts passed in the context
What's a CTX?
1) So no need to provide PDA 1 as input?
How do you fetch data in an account that is not in CTX? 
But I have the struct of it.
2) after fetching this u8Array from PDA1, what function i use to send to Blockchain? Not sure where to find this info
Ah, you would just have to fetch PDA2, read the PDA1 key, and then fetch PDA1
(doing a durable nonce transaction)
1 ) tx.sign
2) tx.serialize
3) store in PDA1 as u8Array
4) store PDA1 Pubkey in PDA2 

5) from backend, i want to fetch the signed and serialized transaction and proceed with it (that is stored in PDA 1)
So maybe I'm misunderstanding your question
You would send a transaction in much the same way that your JS tests run
Ok and from the data in the account.
How do you send a raw transaction from backend?


//////////////////////////////////////////////////////////////////////////////////////////

Curious, if a CPI fail, would it always fail the caller transaction? Is it possible to act on the failure messages and do something to handle it?
Getting a lot of failed txn -

 Translating error Error: Transaction was not confirmed in 30.00 seconds. It is unknown if it succeeded or failed. Check signature 3jYVQFWYtrv89n9wdBMJzAXv5UsUT4rwdaSHZc3GjbWZiku63pVL1f5FPga9pCTAweGhZYRnUfWt9QezDFr5RdyZ using the Solana Explorer or CLI tools.

Is there anything I can do on my side to ensure it passes through ?
üëã What determines whether phantom shows a proper preview or this?
Even when I have my code structured like so:

```
const result = await mpl.actions.mintEditionFromMaster({
        connection,
        wallet: wallet,
        masterEditionMint: mintAddress,
        updateAuthority: walletPublicKey
      });

      // confirm transaction
      await program.provider.connection.getTransaction(result.txId, { commitment: "finalized" });

      // this actually contains a link the the master edition
      const editionData = await mplToken.Metadata.getEdition(connection, result.mint);
```

still getting some the issues occasionally. I guess this is just a limitation on the solana blockchain?
Hey <@!134416332509675520>  is there an anchor program using pyth-client. I wanted to use pyth-client to consume data in anchor. Can you please point me to a repo or a guide using it.
Calling `.to_account_info()` does a `.clone()` on the underlying AccountInfo for that account, which I wouldn't expect to be super expensive but it does have to do a little bit of work.
is it better for compute budget to create variables when you need to call to_account_info() in one function a few times, or just call  to_account_info() whenever you need it?
Yeah
to clarify you mean adding `await program.provider.connection.getTransaction(result)` between the mintEdition and getEdition calls?
Or `.getTransaction(result, { commitment: "finalized" })` to wait extra hard
You can try doing `await program.provider.connection.getTransaction(result)`
üëã I have a snippet of JS code like so:

```
const result = await mpl.actions.mintEditionFromMaster({
        connection,
        wallet: wallet,
        masterEditionMint: mintAddress,
        updateAuthority: walletPublicKey
      });

      // this actually contains a link the the master edition
      const editionData = setTimeout(await mplToken.Metadata.getEdition(connection, result.mint), 1000);
```
I find that the `Metadata.getEdition` call often fails with a `Unhandled Rejection (Error): Unable to find account: ` but when I use explorer with the account pubkey it's there. I suspect it takes a few seconds for block confirmation. Any ways you guys avoid the `Unhandled Rejection` errors?
im building an AMM is there any easy way to do it here? im trying to get it using RUST but im having trouble... was wondering if there was an easy way with Anchor.
post your error message
smart contract
Yep, https://jstarry.notion.site/Program-deploys-29780c48794c47308d5f138074dd9838#ed8a7e1fe88546aa9a0a3bd551de1ad6 covers this in the "Reclaiming buffer accounts" section
any way i can find out if my keypair has any leftover open buffers from failed deploys?
what are you deploying? - smart contracts seem to be all good for me
anyone had luck deploying to devnet or is it just me ?
right on... np
thank you for your help!
i believe so
problem solved tho?
so embarassing don't ask
caveman moment
hol up
can you post the whole code?
program.instruction.connect(...) seems to be calling it
how are you sending the tx?
like the request for me to sign
hmm... there's no error logs it just keeps posting multiple transactions every time
If that doesn't work either... post your error logs
thx ill take a look :0
I'm currently using the Methods Builder... Here's how it looks https://github.com/heavy-duty/platform/blob/master/apps/bulldozer-programs/tests/workspace.spec.ts#L78 if you replace `.rpc()` with `.instruction()` should give you a promise that resolves a `TransactionInstruction`
do you have any examples I could look at - they're still popping up and I've done something wrong
thank you very much!
try `program.instruction.<your-ix-name>` instead of `program.rpc`
how do I bundle up instructions to send them in a single transaction?
Using program.rpc.increment and transaction = new Transaction().
I'm currently trying:
```
let transaction = new Transaction()
for (let i = 0; i < 3; i++) {
        transaction.add(
            program.rpc.increment(
              ...
            )
            )
        )
    }
```
However that just triggers three tranasctions immedietely
Hi there, I started using #[access_control] for handling instructions pre-conditions, in contrast with the account `constraint` that's more of an invariant style of validation. But now I'm wondering...

1. Is there an alternative for `access_control` that runs `after` the instruction handler to deal with post-conditions?
2. Is it possible to turn `access_control` into an invariant rather than just a pre-condition check?

Thanks in advance
Thank you so much!!!
https://github.com/project-serum/anchor/blob/master/tests/ido-pool/programs/ido-pool/src/lib.rs#L83
Hello developers, could I get links about the example code of SPL-token transfer using the Anchor framework?
I've tried, but I could not find any example. 
TIA.
Hello, someone knows how to manage errors with account.subscribe (try/catch or errorCallback)?  For example, when an account is deleted. I'm getting Error: Invalid account discriminator (subscribe - https://github.com/project-serum/anchor/blob/b733610d/ts/src/program/namespace/account.ts#L234)
solana-keygen grind --help
How do you get a program address with a word at the beginning? For example `metaXXXXX‚Ä¶` in for the metaplex contract
nope i didn't, just exported from replit, but the npm start says "Could not find a required file"
did you create the app via `npx create-react-app app_name`? if so, check the package.json and find the `scripts` part. should have a `start` script there. defaults to `start: react-scripts start` which you can also execute by running `npm start`
i was working on replit, but now that i moved to vscode i cant figure it out why it isnt working
it doesn' work either
you need to run `yarn start` in a separate terminal
guys, does anyone know how to open localhost on react via vscode? im struggling with this
lol literally feel like 50% of the traffic in this channel has been me this past month
thanks a lot
Yep, anchor handles everything else for you
Nope, no need to sign (your program never requires a signature to mutate one of its own accounts)
The lamports are returned to the receiver and I don't have to worry about signing? Also, guessing I also don't need anything beyond `Ok(())` in the function itself?
<@!891024357026041907> this is the easiest way to close one of your own accounts
got an example of closing one of your own program's accounts?
(which requires asking the spl token program to do it for you, since the account is owned by the spl token program if it's a token account)
ah thanks for that clarification ü§¶‚Äç‚ôÇÔ∏è
The above code is how you'd close a token account
Ok, so the thing you're doing above involves the spl token program‚Äîthat's unrelated/not how you close one of your own accounts
^ so this is an account owned by my program
No it's defined:

```
#[account]
pub struct ExchangeInfo {
    pub mint_address: Pubkey
}
```
I thought it was just a regular account account
Is global_state a token account?
How come?
The authority should be my program here right? The account was created and owned by my program
```
let cpi_ctx = CpiContext::new_with_signer(
            ctx.accounts.program.to_account_info(),
            anchor_spl::token::CloseAccount {
                account: ctx.accounts.global_state.to_account_info(),
                destination: ctx.accounts.receiver.to_account_info(),
                authority: ctx.accounts.program.to_account_info(),
            },
            signer 
        );
```
Why do you need to access your own program though?
The accounts I'm trying to close are owned by my program. So wondering if there's an easier way to access it without having to explicitly pass in my own program in
Or, what are you trying to do?
Where are you trying to do that?
Yeah the issue here is you still need to set up an additional instruction/struct üòê
What's the right syntax to pass your own program as input? `ctx.program.to_account_info(),` doesn't seem to work
```
#[account(mut, close = receiver)]
pub data_account: Account<'info, MyData>,
#[account(mut)]
pub receiver: SystemAccount<'info>
```
https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html
Does this achieve what you intend to do?
At the end of the day you need to drain the account's lamports, and that requires asking the program to do it for you
Nope, requires an instruction
üëã is there a more automated way to close a custom program account? e.g. suppose I have:

```
#[derive(Accounts)]
pub struct RandomizeExchange<'info> {
    #[account(
        init,
        payer = payer,
        seeds = [payer.key().as_ref(), burn_mint.key().as_ref()],
        bump,
        space = 100 // 32 * 2 to store accounts
    )]
    pub exchange_info: Account<'info, ExchangeInfo>, 
    pub system_program: Program<'info, System>,
    #[account(mut)]
    pub global_thing: Account<'info, GlobalThing>,
    pub burn_mint: Account<'info, Mint>,
    #[account(mut)]
    pub payer: Signer<'info>,
}
```
Rather than writing a custom instruction to close `ExchangeInfo` is there a generic command that every program has to close all the `ExchangeInfo` account?
Is there a way to optimize this cost for short duration programs by not using rent-exempt
2 times because the first deploy doubles your space to give you room to grow
The cost is going to be (7 sol / mb) * (2 times .so file size)
Deploying to mainnet will be the same cost as deploying to devnet (or at least super super close, modulo tiny fee differences I guess)
I guess one thing you can do is just check if that program_id is already an account on-chain (like, in the explorer etc.)
```
‚ûú  solana-burn-token-for-token-v3 git:(main) ‚úó solana balance GFaWuwHEv7DPMP8VAZMrnHf1kDqSMEzWMf2iYwQH8ZJC
4.22231716 SOL
‚ûú  solana-burn-token-for-token-v3 git:(main) ‚úó anchor deploy --provider.cluster devnet
Deploying workspace: https://api.devnet.solana.com
Upgrade authority: /Users/pw/.config/solana/id.json
Deploying program "solana-burn-token-for-token-v3"...
Program path: /Users/pw/Documents/coding/solana-burn-token-for-token-v3/target/deploy/solana_burn_token_for_token_v3.so...
Program Id: GpLZRedGz2uNoFXo24UxxfQivDvw3xSHzdGhTYFFKdSC

Deploy success
‚ûú  solana-burn-token-for-token-v3 git:(main) ‚úó solana balance GFaWuwHEv7DPMP8VAZMrnHf1kDqSMEzWMf2iYwQH8ZJC
4.22021216 SOL
```
So upgrading a program doesn't cost any additional SOL, is there a way to check beforehand what the cost of deploying a program to mainnet will be? In other words, based of your *.so and idl and program ID is there a way to determine whether you are newly deploying a program vs. upgrading an existing one?
Ah, it was in spl_token::state::Mint, not in anchor_spl. Thank you!
And you'll have to do this annoying `mint.mint_authority == COption::Some(authority.key())` thing
Try jumping to source
`mint.mint_authority`
Hi, how can I get mint authority of a token mint account?

I'm trying to implement the following code but cannot get it to work.
```
#[account(constraint = mint.owner == authority.key())]
pub mint: Account<'info, Mint>,
```
Default way of writing your tests in JS/TS.
should i have it installed? what is it even used for?
im seeing a lot of people mentioning mocha, but the anchor website doesnt mention it when its walking you through setting up anchor
awesome, thank you
Starting to see this too, did you end up figuring this out?
üëã getting:

```
Error: Custom: Invalid blockhash
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.
``` 
when trying to deploy, is this because devnet is down? How can I check?
Are there any docker containers to keep all the versions in line?
It uses compute units to populate that cache (it has to call find_program_address), but afterwards it, yeah, caches them
does `ctx.bumps.get()` use compute units to find bumps?
Here https://docs.rs/anchor-lang/latest/anchor_lang/prelude/derive.Accounts.html (scroll down/search for init_if_needed)
`init_if_needed` requires that anchor-lang be imported with the init-if-needed cargo feature enabled. Carefully read the init_if_needed docs before using this feature to make sure you know how to protect yourself against re-initialization attacks. <- where can I find these docs? https://www.google.com/search?q=init+if+needed+anchor&oq=init+if+needed+anchor&aqs=chrome..69i57j33i160j33i160i395.4140j1j7&sourceid=chrome&ie=UTF-8 doesn't seem to have anything substantial
Thanks for the quick answer!
`camelCase("globalNftTracker", { pascalCase: true })` is "GlobalNftTracker", not GlobalNFTTracker
But the issue is here: https://github.com/project-serum/anchor/blob/master/ts/src/coder/borsh/accounts.ts#L98
Guess this should go in an anchor bug-report
üîÆ
wtf? what was causing this?
wow that works
Yep
As in:

```
#[account]
pub struct GlobalThing {
    pub used_items: Vec<bool>
}
```
And then do `program.account.globalThing.fetch(...)`
I guess that's saying we have actually init the account, question is why does `program.account.globalNftTracker.all()` return nothing and `await program.account.globalNftTracker.fetch(globalStateAcct);` give me `invalid account discrim..` hmm ü§î
Just to check, can you change the name of the struct to something simpler case-wise? Like `GlobalThing`
Ok cool
It's `{data: Buffer(1000), executable: false, lamports: 7850880, owner: PublicKey, rentEpoch: 0}` when I set `space = 1000`
(fwiw that won't really work for a dynamically-sized account)
I reset the space size to be `space = 8 + std::mem::size_of::<GlobalNFTTracker>(),`
When I do `await program.account.globalNftTracker.all();` it gives me nothing
Why does it only have length 32 though, rather than 1000?
so something exists when i fetch it
`{data: Buffer(32), executable: false, lamports: 1113600, owner: PublicKey, rentEpoch: 0}`
What do you get if you fetch the account the old-school way, `await program.provider.connection.getAccountInfo(globalStateAcct)`?
i've also checked that the `program.programId` is correct...
Per the program logs it looks like everything runs alright:

```
Streaming transaction logs mentioning ConhfBtNQGFLWuUAjpCs3U5ycQV22pgJMMRfUmete2zg. Confirmed commitment
Transaction executed in slot 6:
  Signature: 33kFBLkKv19ypnKitdhhNmpD6R8sp5njY9A1aBLsvLge7T365xxVTzF7K4MXhvhJ2m1PQm3kiMd2N2LwYm153aBK
  Status: Ok
  Log Messages:
    Program ConhfBtNQGFLWuUAjpCs3U5ycQV22pgJMMRfUmete2zg invoke [1]
    Program log: Instruction: InitializeTokenAcct
    Program 11111111111111111111111111111111 invoke [2]
    Program 11111111111111111111111111111111 success
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [2]
    Program log: Instruction: InitializeAccount
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 3384 of 185649 compute units
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success
    Program 11111111111111111111111111111111 invoke [2]
    Program 11111111111111111111111111111111 success
    Program log: Transferring tokens from: F3YfsXBDw182taRMUEuzqzMhiakcAZiDs5nxMHqsYkuJ
    Program log: To: CtvJRm99CEXMRgmdiLahqvDmxTGZuoJH4CEd3sDH5HSS
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [2]
    Program log: Instruction: Transfer
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 3200 of 147551 compute units
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success
    Program ConhfBtNQGFLWuUAjpCs3U5ycQV22pgJMMRfUmete2zg consumed 56836 of 200000 compute units
    Program ConhfBtNQGFLWuUAjpCs3U5ycQV22pgJMMRfUmete2zg succes
```
Seems like im initializing the account properly, I've added the necessary macros here
Running into: 
```
  1) solana-burn-token-for-token
       Token version: it passes authority to the PDA, mints and burns token:
     Error: Invalid account discriminator
```
What am I doing incorrectly here?
I've got:

```
#[derive(Accounts)]
pub struct InitializeTokenAcct<'info> {
    #[account(mut)]
    pub token_acct: Account<'info, TokenAccount>,
    #[account(mut)]
    pub token_mint: Account<'info, Mint>,
    #[account(signer)]
    pub acct_authority: AccountInfo<'info>,
    pub token_program: AccountInfo<'info>,
    // This is where we'll store the offer maker's tokens.
    #[account(
        init,
        payer = payer,
        seeds = [token_acct.mint.as_ref()],
        bump,
        token::mint = token_mint,
        token::authority = escrowed_token_acct,
    )]
    pub escrowed_token_acct: Account<'info, TokenAccount>,
    #[account(mut)]
    pub payer: Signer<'info>,
    #[account(
        init,
        payer = payer,
        seeds = [b"test".as_ref()],
        bump,
        space = 1000
    )]
    pub global_state: Account<'info, GlobalNFTTracker>,
    pub system_program: Program<'info, System>,
    pub rent: Sysvar<'info, Rent>
}

#[account]
#[derive(Default)]
pub struct GlobalNFTTracker {
    pub used_items: Vec<bool>
}
```

Calling this in a test like so:

```
const [escrowedMakerTokens, escrowedMakerTokensBump] = await anchor.web3.PublicKey.findProgramAddress(
      [preInitTokenAcct.mint.toBuffer()],
      program.programId
    );

const [globalStateAcct, _] = await anchor.web3.PublicKey.findProgramAddress(
  [Buffer.from("test")], program.programId
);

const tx = await program.rpc.initializeTokenAcct({
  accounts: {
    tokenAcct: senderTokenAccount,
    tokenMint: sampleMint.publicKey,
    acctAuthority: sender.publicKey,
    tokenProgram: spl.TOKEN_PROGRAM_ID,
    escrowedTokenAcct: escrowedMakerTokens,
    payer: payer.publicKey,
    globalState: globalStateAcct,
    systemProgram: anchor.web3.SystemProgram.programId,
    rent: anchor.web3.SYSVAR_RENT_PUBKEY,
  },
  signers: [payer, sender]
});

const globalStaetAccount = await program.account.globalNftTracker.fetch(
  globalStateAcct
);
```
Any associated token examples i could find?
was confused looking at an older program
ahh right thanks
That's what `Program<'info, System>` and `Program<'info, Token>` do for you
how do i apply these checks in the account attribute itself?
Hmm, I'm not sure actually. Is that a property of your solana install? Like when you run anchor build, anchor just kicks out to your solana toolchain‚Äîso I think it would depend on your solana install in the background.
Is there a way to know what solana bpf version a given anchor installation is using?
But anchor usually uses the term "authority" for that idea, since "owner" is annoyingly overloaded with program owner
Here `token::authority` will end up being the token's `.owner` field
That's just the syntax anchor has chosen, so basically just have to read the docs/have read the source before
üëã in your quidproquo program, you initialize an account like so:

```
#[account(
        init,
        payer = payer,
        seeds = [token_acct.mint.as_ref()],
        bump,
        token::mint = token_mint,
        // We want the program itself to have authority over the escrow token
        // account, so we need to use some program-derived address here. Well,
        // the escrow token account itself already lives at a program-derived
        // address, so we can set its authority to be its own address.
        token::authority = escrowed_token_acct,
    )]
pub escrowed_token_acct: Account<'info, TokenAccount>,
```
When you do this, how do you determine what the arguments are? How do you know you can add a `token::mint` and `token::authority`?  Looking at `TokenAccount` struct, we I don't see a `token::authority` object at all so wondering where this is going?


//////////////////////////////////////////////////////////////////////////////////////////

Don't think there's a super easy way to control the error, as far as I know
Have you tried running it?
got it, since `ctx.account.the_account` is `Account<TheStruct>`, `*` for deref gets to `TheStruct`
What would the error be? can we control the error messge by any means ?
Should work I think
```.rs
*ctx.accounts.the_account = TheStruct {
  ...
};
```
Do accounts need to have their properties updated individually or can you update from a struct?
Is it possible an associated token account which is generally linked with one wallet could be same for some other wallet ? I don't think so it should be the case but I'm facing some weird issue where a wallet transfer a token from his ATA to other account and then close his ATA and then if I try to find ATA for that wallet and mint I get different account altogether.
Oh. awesome!! Thanks. didn't know that
I tried but type error is not disappearing
It will fail on the second one (so it already enforces that you can only create the account once)
Have you tried running that instruction multiple times?
Argument of type '[{ metadataAccount: string; createdTimestamp: number; startTimestamp: number; endTimestamp: number; distributionTimestamp: number; nftPrice: number; participateSativPerTicketRatio: number; }, { ...; }]' is not assignable to parameter of type '[...(number | BN | TypeDef<{ name: "Data"; type: { kind: "struct"; fields: [{ name: "metadataAccount"; type: "publicKey"; }, { name: "createdTimestamp"; type: "i64"; }, { name: "startTimestamp"; type: "i64"; }, { ...; }, { ...; }, { ...; }, { ...; }]; }; } & { ...; }, Record<...>>)[], Context<...>]'.
  Type at position 0 in source is not compatible with type at position 0 in target.
    Type '{ metadataAccount: string; createdTimestamp: number; startTimestamp: number; endTimestamp: number; distributionTimestamp: number; nftPrice: number; participateSativPerTicketRatio: number; }' is not assignable to type 'number | BN | TypeDef<{ name: "Data"; type: { kind: "struct"; fields: [{ name: "metadataAccount"; type: "publicKey"; }, { name: "createdTimestamp"; type: "i64"; }, { name: "startTimestamp"; type: "i64"; }, { ...; }, { ...; }, { ...; }, { ...; }]; }; } & { ...; }, Record<...>>'.
      Types of property 'metadataAccount' are incompatible.
        Type 'string' is not assignable to type 'PublicKey'.ts(2345)
Thanks for your reply <@!134416332509675520> .

But would you please elaborate more on how I could use it in my use case below ?

```
#[derive(Accounts)]
pub struct CreateSubscription<'info> {
    // Create account of type Subscription and assign creator's pubkey as the payer
    #[account(init, seeds = [benefit.key().as_ref(), user.key().as_ref(), b"subscription".as_ref()], bump, payer = user, space = Subscription::LEN)]
    pub subscription: Account<'info, Subscription>,

    // Define user as mutable - money in their account
    #[account(mut)]
    pub user: Signer<'info>,

    // The benefit to which user wants to subscribe to
    pub benefit: Account<'info, Benefit>,

    // Ensure System Program is the official one from Solana
    pub system_program: Program<'info, System>,
}
```
How can I make sure, I don't create the subcription for the user if they already have one ?
can i ask you any sample code?
You just pass them as objects in JS/TS, with the right fields
Do I need to create the types or are they generated from the idl?
That error happens here, fwiw: https://github.com/project-serum/anchor/blob/master/cli/src/lib.rs#L2455
builds correctly but it's not able to deploy
That's my anchor TOML
```toml
[workspace]
members = ["programs/graph_program"]

[programs.mainnet]
graph_program = "grphSXQnjAoPXSG5p1aJ7ZFw2A1akqP3pkXvjfbSJef"

[programs.devnet]
graph_program = "grphSXQnjAoPXSG5p1aJ7ZFw2A1akqP3pkXvjfbSJef"

[registry]
url = "https://anchor.projectserum.com"

[provider]
cluster = "mainnet"
wallet = "./id.json"

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"
```
I think it may be related to the container not being able to read the deployer keypair
Is anything weird about your Anchor.toml file?
Thank you, I still don't get why this happens
```.rs
#[account(seeds = [... the seeds ... ], bump,)]
pub the_account: Account<'info. Whatever>
```
I was trying to figure out how to get access to the `AnchorDataV2` constructor in the client.

neither of these was it:
```js
const anchorDataV2 = new program.account.anchorDataV2({})
const anchorDataV2 = program.account.anchorDataV2.new({})
```
You can pass compound structs to you program, yeah, as long as they implement `AnchorSerialize, AnchorDeserialize, Clone` I think
Hey guys! How to check in anchor if an account exists with a particular PDA ? This is needed for validation in the program in rust.
I have this as an program instruction:
```rust
pub fn create_non_fungible(
        ctx: Context<CreateNonFungible>,
        data: AnchorDataV2,
        is_mutable: bool,
        max_supply: Option<u64>,
    ) -> Result<()> {
```
and want to create an `AnchorDataV2` object in the client to pass in to the program.

That gets defined in the program as "
```rust
#[derive(AnchorSerialize, AnchorDeserialize, PartialEq, Debug, Clone)]
pub struct AnchorDataV2 {
    /// The name of the asset
    pub name: String,
    /// The symbol for the asset
    pub symbol: String,
```
I was curious if that type was created in the client so that I could do something like:

```js
    const data = new AnchorDataV2 ({
      name: "Series",
      symbol: "NFT",
    });

const tx0 = await program.methods.createNonFungible(data, true, null)...
```
Can you show some code/pseudocode? Not sure what you mean
Can I create  an account object in the js client for accounts defined in the program? Does a type get created automatically or do I have to pass in the properties separately or recreate the type if I want to pass it in?
Is there any difference b/w token account or ATA ?
You can try -     
    var crankWallet = web3.Keypair.fromSecretKey([12,31,......]);
Signature verification failed when i use market.makeSettleFundsTransaction() with wrapped sol, why? any help, thanks
any idea how I can create a wallet from a keypair? 
I am currently trying to write this here
``` 
crankWallet = new anchor.Wallet(tmpKeypair);
``` 

but I'm getting

``` 
  Type 'NodeWallet' has no construct signatures.
```
but there may be multiple token accounts. the ATA is unique, but you can have other token accounts as well
associated token account yes
const accounts = await connection.getTokenAccountsByOwner(wallet, {mint: mintPublicKey}); Does this always give me one account?
can someone correct me - one mint address with one wallet would have one unique ATA ?
google??
Just in case some one is struggling to deploy on devnet, pls make sure
1. the key pair in anchor.toml has sufficient devnet SOL
2. upgrade solana to latest version (not sure if this helps)
3. make sure you are using the right proxy/vpn if necessaryÔºàuse solana balance to verify you could get a reponse)
OK, I manage to solve it: don't use api.google.devnet
Hi, sorry for the noob questions but my deployment failed with 'anchor deploy' due to timeout, I recovered the buffer with;

'solana-keygen recover

But when I tried again with:
solana program deploy --buffer recovery.json target/deploy/escrow.so

He tells me that the account not found (Pubkey: programIDPubkey), can someone help me with it ?

Thanks
^getting this error when trying to deploy the tictactoe example
Error: Account Aso---- is not an upgradable program or already in use
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: ""}.
it is super flaky actually... it just worked for once, and then not anymore

my IDL seems to show the account
Any idea why I'm getting
```
TypeError: Cannot read properties of undefined (reading 'fetch')
```

when I run 

```
let response = await this.solbondProgram.account.portfolioAccount.fetch(portfolioPDA); 
```  ?
The same happened to me because the internet blocked access to some sites here. So i changed the internet connection and it deployed fine. So, although its a rare case, I suggest you to try with different internet connection
Just in case some one is struggling to deploy on devnet, pls make sure
1. the key pair in anchor.toml has sufficient devnet SOL
2. upgrade solana to latest version (not sure if this helps)
3. make sure you are using the right proxy/vpn if necessaryÔºàuse solana balance to verify you could get a reponse)
devnet deploy failed
Just in case some one is struggling to deploy on devnet, pls make sure
1. the key pair in anchor.toml has sufficient devnet SOL
2. upgrade solana to latest version (not sure if this helps)
3. make sure you are using the right proxy/vpn if necessaryÔºàuse solana balance to verify you could get a reponse)
answering my own questions.. private functions are supposed to be implemented as impl fn in the struct used in the #[program] fns or can we can use separate pub mod and use them. New to Rust
basic-4 tutorial answered this ü§¶‚Äç‚ôÇÔ∏è 
https://github.com/project-serum/anchor/blob/master/examples/tutorial/basic-4/programs/basic-4/src/lib.rs
https://discord.com/channels/889577356681945098/889702325231427584/924850140341219349 check this out
<@!108582345895866368>  thank you for your advice. let me try to do it
you cannot do CPI of system program unless it's accounts owned by system program. In your case, the account is owned by your OWN program. So you need do the transfer without calling system program, directly change the lamports amount
Can we have private functions in the #[program] mod ? or do they all have to be pub and callable from outside?
Or do we have to resort to panics ?
Is it possible to return an error in the main function; I mean the 'initialize' function or any function of a program being called from outside?
Like returning Ok(()), can we return Err(CustomError::MyCustomError).
is it possible to disable the ///CHECK safety check? I understand what its trying to do but I literally just write "///CHECK asdf" and then go about my day
no clue sorry :/ haven't seen that one before - make sure your solana cli is up to date
This is instruction structure
```
#[derive(Accounts)]
pub struct SwapTokenToSOL<'info> {
    #[account(mut)]
    pub user_authority: Signer<'info>,
    // NOTE: this will also be SOL account.
    #[account(mut,
        seeds = [state_account.swap_name.as_ref()],
        bump= state_account.bumps.state_account
    )]
    pub state_account: Box<Account<'info, StateAccount>>,
    #[account(mut)]
    pub quote_mint: Account<'info,Mint>,
    #[account(
        mut,
        constraint = user_quote.owner == user_authority.key(),
        constraint = user_quote.mint == quote_mint.key()
    )]
    pub user_quote : Box<Account<'info, TokenAccount>>,
    #[account(
        mut,
        constraint = quote_pool.owner == state_account.key(),
        constraint = quote_pool.mint == quote_mint.key()
    )]
    pub quote_pool : Box<Account<'info, TokenAccount>>,
    // Programs and Sysvars
    pub system_program: Program<'info, System>,
    pub token_program: Program<'info, Token>,
    pub rent: Sysvar<'info, Rent>
}```

```
#[account]
#[derive(Default)]
pub struct StateAccount {
    pub swap_name: [u8; 10],
    pub bumps: SwapBumps,
    pub owner: Pubkey
    ...
}

```

```
#[derive(Accounts)]
#[instruction(swap_name: String, bumps: SwapBumps)]
pub struct Initialize<'info> {
    // Token program authority
    #[account(mut)]
    pub authority: Signer<'info>,
    // State Accounts
    #[account(init,
        seeds = [swap_name.as_bytes()],
        bump,
        payer = authority
    )]
    pub state_account: Box<Account<'info, StateAccount>>,
    ...
}
```
I am going to make my own simple swap  system.
"swap sol to token" works well but "swap token to sol" is not working. Here the problem is that the SOL transfer from program pool to user's wallet.

```Transaction simulation failed: Error processing Instruction 0: invalid program argument 
    Program 9jBjsXqKo6W54Hf65wrgR9k9AVYuCfDQQNUfygFtjWPJ invoke [1]
    Program log: Instruction: SwapTokenToSol
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [2]
    Program log: Instruction: Transfer
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 2643 of 186709 compute units
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success
    Program log: Sending Token: !!"1219073"!!
    Program 11111111111111111111111111111111 invoke [2]
    Transfer: `from` must not carry data
    Program 11111111111111111111111111111111 failed: invalid program argument
    Program 9jBjsXqKo6W54Hf65wrgR9k9AVYuCfDQQNUfygFtjWPJ consumed 22031 of 200000 compute units
    Program 9jBjsXqKo6W54Hf65wrgR9k9AVYuCfDQQNUfygFtjWPJ failed: invalid program argument```

This is code
```     let seeds = &[
            ctx.accounts.state_account.swap_name.as_ref(),
            &[ctx.accounts.state_account.bumps.state_account],
        ];
        let signer = &[&seeds[..]];
        msg!("Sending Token: !!{:?}!!", transfer_amount.to_string());

        invoke_signed(
            &system_instruction::transfer(
                ctx.accounts.state_account.to_account_info().key,
                ctx.accounts.user_authority.key,
                transfer_amount
            ),
            &[
                ctx.accounts.state_account.to_account_info().clone(),
                ctx.accounts.user_authority.to_account_info().clone(),
                ctx.accounts.system_program.to_account_info().clone()
            ],
            signer
        )?;```
Nice one, was doing something way most complex lol.
solana-cli 1.9.4 (src:8ce65878; feat:3258470607)
What's your local solana version? `solana -V`
This seems like a proper version of what a TS object should look like
still struggling to deploy on devnet 
```Error: RPC request error: cluster version query failed: error sending request for url (https://api.devnet.solana.com/)```
<@!341381788620423168> I think it would be something like
```
const fees = {
  tradeFeeNumerator: new anchor.BN(0),
  tradeFeeDenominator: new anchor.BN(0),
}
```
```
================================================================================
Recover the intermediate account's ephemeral keypair file with
`solana-keygen recover` and the following 12-word seed phrase:
================================================================================
crater witness mammal blush weather carbon element exit wait viable spice embark
================================================================================
To resume a deploy, pass the recovered keypair as the
[BUFFER_SIGNER] to `solana program deploy` or `solana write-buffer'.
Or to recover the account's lamports, pass it as the
[BUFFER_ACCOUNT_ADDRESS] argument to `solana program close`.
================================================================================
Error: error sending request for url (https://api.devnet.solana.com/): operation timed out
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.
```
or
```
=======================================================================
Recover the intermediate account's ephemeral keypair file with
`solana-keygen recover` and the following 12-word seed phrase:
=======================================================================
divide hungry pole shrimp bar movie truly source race hat foster census
=======================================================================
To resume a deploy, pass the recovered keypair as the
[BUFFER_SIGNER] to `solana program deploy` or `solana write-buffer'.
Or to recover the account's lamports, pass it as the
[BUFFER_ACCOUNT_ADDRESS] argument to `solana program close`.
=======================================================================
Error: Custom: Invalid blockhash
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.
```
deploy failed on devnet
In that case something along 
```{
  { x::u64 },
  { y::u64 }
}``` 
? I'm so bad at JS that you should not take my word though
Havn't tried this myself, but I believe as for enum, by creating an equivalent js object. Taking Hana article example rust side `pub enum Color { Black, White }` -> js side `{ Black: {} }`
Hey guys, I have this type that I am passing into an instruction as a param: ```#[derive(AnchorSerialize, AnchorDeserialize, Default, Clone, Debug)]
pub struct Fees {
    pub trade_fee_numerator: u64,
    /// Trade fee denominator
    pub trade_fee_denominator: u64,
}
``` And it generates as this in the IDL: ```  types: [
    {
      name: "Fees";
      type: {
        kind: "struct";
        fields: [
          {
            name: "tradeFeeNumerator";
            type: "u64";
          },
          {
            name: "tradeFeeDenominator";
            type: "u64";
          }
        ];
      };
    }
  ];
``` However for the life of me I cant seam to workout how do I use this type in my typescript tests?
created an issue for this. pls fill it with all information that you think might help us return a better error or fix the bug if there is one https://github.com/project-serum/anchor/issues/1594
Going to ask question here since I've tried Serum developer questions and was recommended to cross-post here:

I'm trying to open a new open orders account, swap, and close in the same transaction. Everything up to the close open orders instruction works, and then the close instructions breaks the TX. I'm getting error 42 which is TooManyOpenOrders, even though the Swap instruction should be settling all balances.

Example transaction here: https://explorer.solana.com/tx/3dBY3YB6NcuubAjw1FygyvqBqZTNEEeYPraBUzQUbURrV2qWXpHTXtb2ZKkL49g7qH74zVU53VngTFd2G2rgcstf

Code I think I am hitting is here: https://github.com/project-serum/serum-dex/blob/4d0a8dcdbff1706dd4447ab63f562c040c2b9e6f/dex/src/state.rs#L2304-L2318

I'm following the examples in the swap contract repo, does closeAccount not work in the same transaction?
It seems that Solana's programming model is not very similar to that of Ethereum.
I need much more trial and error. üôÇ
Thanks for the answer.
Not possible in solana, you have to pass that address in from the client as an account
Does anyone know how to get an instance of Account struct from a publicKey in anchor? Is it possible?
Can you say more? Strictly-speaking no, but I'm not quite sure what you're asking
Mm, probably (just try removing it and see if rust complains üòõ)
I'm getting this at the end of the anchor publish command, and I have my Anchor.toml there
are bumps required for creating PDAs?
Have some questions about Serum Swap, can anyone here help me out or should I ask in another channel?
?
Anyone gets this
`Workspace configuration error: No such file or directory (os error 2)`
running `anchor publish`
yes
Thanks. I've seen some code that does a .to_account_info().clone(), is that extra clone overkill?
Any good examples for the new bump requirements or generating a PDA. Thanks üôÇ
makes sense
Yeah, just do `let tx = new Transaction();` at the top, then `tx = new Transaction()` instead of trying to clear it
But I'm not sure, maybe you can mutate it or whatever (probably not a common use case)
I would just make a new tx (it's just a little data structure)
what i'm really trying to do here is:

```
const tx = new Transaction():
for each address:
  tx.add(...)
  if (tx.size() == 4) program.send(tx, ...); tx.clear(); // so I can keep going in this for loop
```
but not sure how to do the `.clear()` part, I just want an empty tx again
What would that do? Not sure what you mean
Anyway to clear a transaction object? e.g. 

```
const transaction = new Transaction();
transaction.add(...)
...
transaction.clear()? // how can I clear this transaction object
```
ok thanks I'll do that.
Looks like that call does a decent amount of work, so I doubt you can jam very many of them into a single tx (but you could try): https://github.com/metaplex-foundation/js/blob/main/src/actions/mintNFT.ts#L101
Try working through this tutorial: https://www.brianfriel.xyz/understanding-program-derived-addresses/
PDAs are "guessable"/obvious, you just use the same seeds on the client and the rust side
ok so that takes care of the rust side... 
How would I test it? as now the priceAccount PublicKey is not known to my tests as it's defined by the program??

it('Is initialized!', async () => {

    const tx = await program.rpc.initialize({
      accounts: {
        priceAccount: acc_kp.publicKey,
        user: anchor.getProvider().wallet.publicKey,
        systemProgram: SystemProgram.programId,
      },
      signers: [acc_kp]
    });
    console.log("Your transaction signature", tx);
  });

  it('can update price', async () => {
    const tx = await program.rpc.updatePrice(new BN(7862), {
      accounts: {
        priceAccount: acc_kp.publicKey,
        user: anchor.getProvider().wallet.publicKey
      },
      signers: [acc_kp]
    });
    console.log("Your transaction signature", tx);
  });
That would be how you'd use a PDA address, yeah (no Keypair.generate())
#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 8 // discriminator 
         + 8 // u64 for the price
         + 32// PubKey for the owner
        )]
    pub price_account: Account<'info, PriceAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}

******BECOMES*****

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, seeds = [b"crazy-seed-phrase", domain.as_bytes()], payer = user, space = 8 // discriminator 
         + 8 // u64 for the price
         + 32// PubKey for the owner
        )]
    pub price_account: Account<'info, PriceAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}
Is that how you do it?
actually I found this:
üëã is there a way to batch call the metaplex action `mintNFT`? E.g. instead of calling `mpl.actions
      .mintNFT` multiple times and having to approve the txn multiple times, i want to batch the instruction call
Basically I need to replace that first line with a acc_kp that is a PDA derived from a seed. I can't seem to find an example on how to do this..
Right that where I am now...

  const acc_kp = anchor.web3.Keypair.generate();

  it('Is initialized!', async () => {

    const tx = await program.rpc.initialize({
      accounts: {
        priceAccount: acc_kp.publicKey,
        user: anchor.getProvider().wallet.publicKey,
        systemProgram: SystemProgram.programId,
      },
      signers: [acc_kp]
    });
    console.log("Your transaction signature", tx);
  });

  it('can update price', async () => {
    const tx = await program.rpc.updatePrice(new BN(7862), {
      accounts: {
        priceAccount: acc_kp.publicKey,
        user: anchor.getProvider().wallet.publicKey
      },
      signers: [acc_kp]
    });
    console.log("Your transaction signature", tx);
  });
Yeah, but I think you still need to make sure that that user key is one you expect
then like this in the init:
pub fn initialize(ctx: Context<Initialize>) -> ProgramResult {
        let price_account = &mut ctx.accounts.price_account;
        price_account.price = 0;
        price_account.owner = ctx.accounts.user.key();
        Ok(())
    }
Oh derp was just about to type that‚Äîyep, that works
I had introduced an owner variable on the PriceAccount struct
~~The `.owner` of an account like the one you have above isn't what you think it is, it's the *program* that owns the account (so, your own program)~~
Almost
```.rs
#[derive(Accounts)]
pub struct UpdatePrice<'info> {
   #[account(mut, seeds = ["the-one-and-only-price-account"], bump)]
    pub price_account: Account<'info, PriceAccount>,

    #[account(address = SOME_KNOWN_ADMIN_ADDRESS)]
    pub user: Signer<'info>,
}
```
yeah nvm, figured this out
it will `console.log` the private key not the public key. You can put the output directly to phantom
I just tried it to double check and it works, the code: 
```ts
const kpArray = new Uint8Array(
    JSON.parse((await fs.readFile(process.env.KEYPAIR_PATH!)).toString())
  );

  const privateKey = bs58.encode(kpArray);
  console.log(privateKey);
```
And then make sure that the user.Key is the same PDA account that was used to make the program?
<@!134416332509675520> - So I can do something like this

#[derive(Accounts)]
pub struct UpdatePrice<'info> {
   #[account(mut, constraint = price_account.owner == user.key())]
    pub price_account: Account<'info, PriceAccount>,
    pub user: Signer<'info>,
}

#[account]
pub struct PriceAccount {
    pub price: u64,
    pub owner: Pubkey,
}
yeah thanks a lot! it should work!
ha lol
Answering catrovacer's question above
what do you mean double PDA?
Like, that's basically how you'd do it in Python haha
Yeah, the double PDA thing would work fine I think
yeah basically... thanks! i will think on this
I'll go break my head on that for a little while
Basically nothing really solana specific here, it's just a data structures problem
Alright thanks for pointing me in the right direction
I think you'd just have to use multiple PDAs for this, ["username", "qwerty"] --> a little account showing that qwerty is already taken, ["pubkey", asdfasdfasdf] -> a little account showing that that pubkey has already registered, etc.
<@!134416332509675520> Quite an old message lol. Is there anything i can do in anchor? or do i have to handle this in frontend only? Thanks!
but the problem was I didn't have lamports for the transaction...
Ah, no
Then I was trying something like this

  let seed = Uint8Array.from([70,60,102,100,70,60,102,100,70,60,102.....]);
  let accountFromSeed = anchor.web3.Keypair.fromSeed(seed);
But yeah, this would be better to do with a PDA and then have your instruction above only agree to init an account at that specific PDA address (so can only be done once)
Not wrong necessarily, just inconvenient
Which is obviously wrong.
anchor.web3.Keypair.generate(); is what I was using in my tests.
It's then up to you to write your program so that no one (or only some specific someones) can call any instructions that update that account
Very good, That's what I was looking for.
E.g. use a PDA with seeds = ["the-one-and-only-price-account"]
I don't want the price to be alterable by a bad actor and thus affect things.
Ok, then you'd just have to store that account at some address of your chosing
Yes sorry about that. I'm not 100% sure myself. 
So if I refine the question:

I need one PriceAccount That contains the price. I will then read this data from another program to make decisions.
Ok, what do you mean above by "(person)" then?
Yes. exactly!
Haha not sure what you're asking üòõ
Do you mean you only want there to exist one PriceAccount?
This is the code.
#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 8 // discriminator 
         + 8 // u64 for the price
         + 32// PubKey for the owner
        )]
    pub price_account: Account<'info, PriceAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct UpdatePrice<'info> {
   #[account(mut, constraint = user.key() == user.key())]
    pub price_account: Account<'info, PriceAccount>,
    pub user: Signer<'info>,
}

#[account]
pub struct PriceAccount {
    pub price: u64
}
Can you say more? What do you mean be "one person (account)"?
Really that matters less. I only want one person (account) to be allowed.
You can limit it to whoever you want‚ÄîI thought you wanted to limit it to the deployer of the program?
Who do you want to be able to update the state account?
So that's the update authority. Which correct me if I'm wrong affects the program. Does that also affect the state account?
Right, not there‚Äîlook at the rust side
https://github.com/project-serum/anchor/blob/master/tests/bpf-upgradeable-state/programs/bpf-upgradeable-state/src/lib.rs#L61
the test on line 107 I meant
Sorry, not line 107, that link you just posted üòõ
Yeah
Here? https://github.com/project-serum/anchor/blob/master/tests/bpf-upgradeable-state/programs/bpf-upgradeable-state/src/lib.rs
hmm, when I do this I get a different publickey than what's in my cli ü§î
Check out the rust half
line 107?
Basically, you force that one-and-only special person to sign the tx, and verify in your program that they did so
Right, that test has an example
<@!134416332509675520> - So I few things:
1 - I have no idea really what I'm talking about, so what I'm asking might not be possible.

2 - The problem I'm trying to solve is to have a piece of data in a state account (price) that can only be updated by one person.
This test has some examples of restricting access to the program creator: https://github.com/project-serum/anchor/blob/master/tests/bpf-upgradeable-state/tests/bpf-upgradable-state.ts
Think I'm not quite sure what you're asking‚Äîhow are you enforcing that only the program creator can invoke that instruction?
<@!134416332509675520> - Did you have a chance to check out my question? I'm sure I'm just not understanding something simple here... it's my first week on anchor/solana
How does one attach metadata to a regular spl-token (not nft) or is the process the same? I want things like symbol, name, pic etc.
Ah whoops üëç
The first half is actually the Private key.
Hey, not sure if u got an answer to this already, but as I understand it. The edition is a part of the metaplex standard that no one really uses or pays attention to. All nfts have a master edition, and for most that‚Äôs all they have.

However, metaplex does support creating any number of editions (other versions of the same nft) for any particular master edition. Editions have their own token mint but I believe the metadata is the same?

I haven‚Äôt looked in to this in a while, so I‚Äôm fuzzy on the details, but i hope that clarifies something.
and put it to Phantom
yeah you can ```ts
console.log(privateKey)
```
The private key is just half of the keypair.json file (think the second half)
<@!185605576162672641> Here you go:

#[account]
pub struct PriceAccount {
    pub price: u64
}
will this out, thanks!
yep
```ts
import * as bs58 from "bs58"
const privateKey = bs58.encode(bytesFromJSON)
```
Are you using the Phantom `Add / Connect Wallet` thing?
you need to convert the bytes into `base58`. You can `yarn add bs58` or `npm i bs58`
I have a keypair generated via the solana cli (stored in `~/my-solana-wallet/my-keypair.json`). Any easy steps to import this into phantom or any other online wallet? I've tried importing the output of `cat ~/my-solana-wallet/my-keypair.json` but that doesn't seem to work
oh that's interesting. Any reason why that might be the case?
thanks for the quick answers!
`program.instruction.initializeTokenAcct`, then add that instruction to a tx
Interestingly, this doesn't work (I thought it did too, but surprisingly it doesn't)‚Äîfailed CPIs immediately halt the whole transaction, without any way to recover from them (so their Result-y type is a lie lol, you can't actually match on it etc.)
yes you can call `program.instruction.initializeTokenAcct` and it will return `Instruction`
E.g. something like:

```
const transaction = new Transaction()

transaction.add(
  SystemProgram.createAccount({
    fromPubkey: payer,
    newAccountPubkey: mintAccount.publicKey,
    lamports: balanceNeeded,
    space: spl.MintLayout.span,
    programId: spl.TOKEN_PROGRAM_ID,
  }),
);

transaction.add(
  spl.Token.createInitMintInstruction(
    spl.TOKEN_PROGRAM_ID,
    mintAccount.publicKey,
    0,
    authority,
    authority,
  ),
);

await program.provider.send(transaction, [...]);
```
üëã suppose I my own program instruction: 

`program.rpc.initializeTokenAcct` and I want to call this multiple times. Is there a way to add this all into one transaction?
Can you provide the account struct for your update price instruction?
Hello I have a very simple question and I think the answer is too simple that I must be missing some fundamental concept here...

I have a program. this problem defines a priceAccount. The priceAccount has one properpty, the price. I can init this without a problem and I get a program Id to confirm that we are deployed to devnet. 

Next I have another instruction to update the price. I want this defined that only the owner of the program is allowed to update the price. I've tried to load the wallet of the program owner from the seed, but nothing seems to be working. 

When I look at the program account data I do have a ProgramData Address. This public key is not something that I've created and I don't know how I can get the private key of this account. In any case I don't think there are any lamports in the PDA account to be able to update the price anyways... 

where is my logic wrong?
Changing my provider commitment from `recent` to `finalized` fixes the issue, if anyone know why that would break Jest but not Mocha, I'd love to know
<@!222259920727310336> can't you just handle the `ProgramResult` from a CPI call?
hi everyone I have a somewhat basic question - is there a way to recover my instruction context given a transaction hash? I know we can do this manually by parsing accountKeys and comparing the order but that doesn't strike me as the best way to do this. It is very easy to decode arguments outside of the instructionContext using BorschInstructionCoder but I can't put my finger on how to map the accounts to the expected values in IDL other than manually
anyone faced this before?
`anchor deploy` is giving me this error 
```Blockhash expired. 5 retries remaining
Blockhash expired. 4 retries remaining```
It is a chain of errors that's happening
Context for this: The IDL for the Swap program is out of date in the SDK and I want to rebuild it from the program directly
~~Having trouble building the Serum Swap program from source. I've run `rustup` like it says in the guide, but having difficulties with building the DEX subdependency on this command:
```
cd deps/serum-dex/dex/ && cargo build-bpf && cd ../../../
```
`cargo build-bpf` keeps failing, do I need to install a utility globally for this to work?~~

Edit: Oh man, didn't have Solana Tools CLI installed, <a:smh:883157005571866674>
For anyone that has used Jest for testing, have you had issues with `Account does not exist`? 

The test work fine with chai.  When querying the blockchain, the account exists. It seems like it is an async issue specifically with Jest trying to fetch account data before it is confirmed on chain
very confused here, would appreciate any explanation of ^^
Solution:
```
#[account(
        init,
        payer = payer,
        seeds = [b"nfttracker".as_ref()],
        bump,
        space = 1200 // 24 * 32 * 2 to store accounts + some extra in case
    )]
```
Removing the `.as_ref()` in the seeds declaration fixes this ‚ùì
Will preface that this was happening after running an `anchor deploy`
üëã getting:

```
Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account 
    Program GpLZRedGz2uNoFXo24UxxfQivDvw3xSHzdGhTYFFKdSC invoke [1]
    Program log: Instruction: InitializeTracker
    7na4Cw6JrvoY5erxT4bA48kvDKR9LNs5adFCpMSgvn7e's signer privilege escalated
    Program GpLZRedGz2uNoFXo24UxxfQivDvw3xSHzdGhTYFFKdSC consumed 14831 of 200000 compute units
    Program GpLZRedGz2uNoFXo24UxxfQivDvw3xSHzdGhTYFFKdSC failed: Cross-program invocation with unauthorized signer or writable account
```
Program ID is correct, the PDA seed is correct, honestly not sure what the issue is here üò¶


//////////////////////////////////////////////////////////////////////////////////////////

the error is occuring in  ` sendAndConfirmTransaction()`
```js
 // let toAccount = web3.Keypair.generate();

      // const opts = {
      //   preflightCommitment: "processed",
      // };
      
      // const connection = new Connection(network, opts.preflightCommitment);

      const instruction  = w3.SystemProgram.transfer({
        fromPubKey: walletAddress,
        toPubKey: toAddress,
        lamports: LAMPORTS_PER_SOL
      });

      let payer = w3.Keypair.generate();
      console.log(payer)
      walletAccountInfo = await connection.getAccountInfo(payer.publicKey);
      console.log(walletAccountInfo)

      // let trans = await setWalletTransaction(instruction);
      let transaction = new Transaction();

      transaction.add(instruction)

      console.log(transaction, connection, baseAccount)
      console.log(walletAddress.toBase58())
      const signature = await sendAndConfirmTransaction(connection, transaction , [walletAddress])

      console.log("signature", signature);
      const balanceAfterPay = await connection.getAccountInfo(walletAddress);
      console.log("Balance after payment ",walletAccountInfo.lamports); ```
post peace of code which is throwing that
guys im getting this error
``` Couldnt pay  TypeError: Cannot read properties of undefined (reading 'toBase58')
    at transaction.ts:262:1
    at Array.sort (<anonymous>)
    at Transaction.compileMessage (transaction.ts:261:1)
    at Transaction._compile (transaction.ts:379:1)
    at Transaction.sign (transaction.ts:474:1)
    at Connection.sendTransaction (connection.ts:3886:1)
    at async sendAndConfirmTransaction (send-and-confirm-transaction.ts:30:1)
    at async payUser (App.js:230:1) ```
wasn't sure if that check was automatic
btw no need to add `owner = crate::ID` to `AccountLoader`
looks like idl got corrupt actually that may have been the problem
deleted the idl and regenned, same problem
but problem with deployment still exist üò¶ just get error  Error: Custom: Invalid blockhash
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.
oh, find, sorry
if i set "mut" for account whoch payer, i get error from compiler...
hey guys, i'm using achor 0.22.1 and solana-cli 1.9.12, when i do anchor build i get error at the end: thread 'main' panicked at 'Code not parseable: Error("the payer specified for an init constraint must be mutable.")', lang/syn/src/idl/file.rs:357:58 but my program compiled When i try to deploy it i get an error: Error: Custom: Invalid blockhash WHich problem??
ah damn, okay will have to look for a better way to test then, thanks
The validator itself doesn't expose a way to warp time as far as I know
The idea is that you just don't use an actual validator, you use a pure rust test
Ah, sorry, you'll have to run the whole test in rust
interesting, guess I can expose a test only instruction in my program to call this?
https://docs.rs/solana-program-test/latest/solana_program_test/struct.ProgramTestContext.html#method.warp_to_slot
Not that I know of. You can do it with the solana-program-test crate though
Is there a way to advance time in the test validator using anchor in an integration test?
Thanks got it working
Often happens because you ran out of space for that account
What does this error means
Error Code: AccountDidNotSerialize. Error Number: 3004. Error Message: Failed to serialize the account.
Are you sure you're using the latest version of the IDL in your client code?
Error Number: 3004
https://github.com/project-serum/anchor/issues/1157
wtf ? maybe try downgrading to lower version help? 
sh -c "$(curl -sSfL https://release.solana.com/v1.8.14/install)"
Thanks will check out
You would just do it all in javascript using solana's version of web3.js: https://spl.solana.com/token
I‚Äôm pretty new to solana and come from a background of solidity, so it‚Äôs pretty confusing for me
Then how can I do this?
If they pay them directly then it doesn't involve your smart contract.
tried marking every account `mut` and fails as well??
```rust
#[derive(Accounts)]
pub struct StartOrder<'info> {
    #[account(mut)]
    pub prism_etf_mint: Account<'info, Mint>,

    /// The Prism ETF [Account] that describes the assets being purchased
    #[account(seeds = [b"PrismEtf".as_ref(), &prism_etf_mint.key().to_bytes(), &beamsplitter.key().to_bytes()], bump = prism_etf.bump, has_one = weighted_tokens)]
    pub prism_etf: Box<Account<'info, PrismEtf>>,

    #[account(mut, seeds = [b"OrderState".as_ref(), &prism_etf_mint.key().to_bytes(), &orderer.key().to_bytes(), &beamsplitter.key().to_bytes()], bump = order_state.bump, has_one = transferred_tokens)]
    pub order_state: Box<Account<'info, OrderState>>,

    #[account(owner = crate::ID)]
    pub weighted_tokens: AccountLoader<'info, WeightedTokens>,

    #[account(owner = crate::ID, mut)]
    pub transferred_tokens: AccountLoader<'info, TransferredTokens>,

    /// The [Signer] of the tx and owner of the [Deposit] [Account]\
    pub orderer: Signer<'info>,

    /// The [TokenAccount] that recieves the Basket Tokens
    #[account(mut, associated_token::mint = prism_etf_mint, associated_token::authority = orderer)]
    pub orderer_etf_ata: Box<Account<'info, TokenAccount>>,

    /// The [Beamsplitter] [Account] that holds all of the Program's funds
    pub rent: Sysvar<'info, Rent>,

    #[account(
        seeds = [
            b"Beamsplitter".as_ref(),
        ],
        bump = beamsplitter.bump,
    )]
    pub beamsplitter: Box<Account<'info, Beamsplitter>>,

    pub associated_token_program: Program<'info, AssociatedToken>,

    pub token_program: Program<'info, Token>,
    /// The [System] program.
    pub system_program: Program<'info, System>,
}
```
instruction is empty still failing
it's a pda for ref, don't think that makes a diff though
is this a known bug
before it worked but state did not persist (obv), but after adding mut it errors out??
weirdly arises after I added mut to one of my accounts
getting 0x7d0 or 2000 : "A mut constraint was violated" but all accounts changed are marked mut
what if the user has to pay some money to another user
The CPI chapter in the anchor book (https://book.anchor-lang.com/chapter_3/CPIs.html) and a contract that uses the token program, such as https://github.com/ironaddicteddog/anchor-escrow/blob/master/programs/anchor-escrow/src/lib.rs
Are there any resources I can refer to?
Yes using anchor smart contract
Using an anchor smart contract? You'll want to use the anchor_spl crate to interface with solana's token program
Thanks
Are there any resources?
Guys how to transfer money from one account to another account using solana?
I think you want a default = [‚Äúcpi"]
It seems to have changed recently because the book makes no mention of additional changes being necessary
Yeah I have to do that too, but the default value of `cpi = ["no-entrypoint"]` prevents it from working with just that addition
in anchor.toml
```
[dependencies]
anchor-lang = { version = "0.22.1", features = ["init-if-needed"] }
```
this is how i enable the init if needed, might be the same?
How do I enable cpi in the `[features]` section of the cargo.toml of the callee? The defalt is `cpi = ["no-entrypoint"]` but I'm not sure what to change it to.
https://github.com/project-serum/anchor/issues/1157
anyone had successfuly deployed on devnet recently? what version of cli are you using?
Best way to parse Base64 data?
and ... keep failing again
init_if_needed doesnt skip the seed checks right?
Or you can just run it locally, with an actual live solana-test-validator in the background
Oh, lol, yeah
i was thinking just run the test on devnet
You mean clone it from devnet?
ok then devnet?
Not sure you can tbh
ok, so in my test I should just create that account
If you let anchor spin up a test for you, the "genesis" stuff it/solana does doesn't use the upgradeable loader at all
Unfortunately, depending on how you run your tests, you might not actually have an account that lives there
I was trying the admin setting setup from the tests:
```rust
#[derive(Accounts)]
pub struct AdminSettingsInit<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    #[account(init, seeds = ["admin".as_bytes()], bump, payer = payer)]
    pub admin_settings: Account<'info, AdminSettings>,
    #[account(constraint = program.programdata_address() == Some(program_data.key()))]
    pub program: Program<'info, crate::program::MyProgram>,
    // only the program update authority can initialize the admin settings account
    #[account(constraint = program_data.upgrade_authority_address == Some(payer.key()))]
    pub program_data: Account<'info, ProgramData>,
    pub system_program: Program<'info, System>,
}
```
I'm using this, but getting `Error Code: AccountNotInitialized`:
```js
    const [programData] = await anchor.web3.PublicKey.findProgramAddress([
      program.programId.toBuffer()
    ], new anchor.web3.PublicKey("BPFLoaderUpgradeab1e11111111111111111111111"));
```
is there a convenience method for the program data address?
https://github.com/project-serum/anchor/blob/master/lang/src/error.rs#L91
I'm getting `Runtime error: custom program error: 2015` when I try to execute my transaction, can I read somewhere what this means?
Thanks <@!134416332509675520> !
Ok, thanks!! I will try to do that
Try searching the anchor repo for `close =` for a bunch of examples
You'll need a whole separate instruction to close the account
No, in the derive(Accounts) for a separate instruction
Where do you use that attribute? When you run the app in the terminal?
ah! I didn't know that
Anchor has a `close = who_to_send_the_rent_to` attribute you can use
You'd have to close the account
yes
What does the PDAness of the address have to do with this?
So you want to be able to create it all over again?
Since it is a PDA, I don't find the way to have the app in the same state like in the beginning.
In the counter example, first you need to create the counter and then you can increase the value. I would like to find a way to start again with the process (creating the counter) to check some UX/UI stuff in the frontend.
Why wouldn't you be able to reset it to zero?
yes
How do you want to reset it? Not sure I'm understanding your question (you can of course have a separate instruction that resets the count to zero)
(Sorry, think I'm misunderstanding your question‚Äîreading again)
Ok, I will try to check that again because I expect the same too. Another question, let imagine I have a counter in a PDA Dapp, and the state at this moment is higher than 0 ( I've clicked the counter already a few times... ), is it possible to reset that counter? I mean with this to reset the state to the initial status.
I would definitely not expect validator state to be the same across separate clones of the same repo
But if you copied it over, it might work
I doubt that test ledger is in your git repo
Even cloning the project in another folder the ledger is the same?
Inside `.anchor/test-ledger`
Because I think the ledger is living right in your original folder, at least I think
```account.ts:154 Uncaught (in promise) Error: Account does not exist DWJaZaa8xh8PRTS2ts3i1vJi8ua4ku934z1jDkkTHuys```
I can explain it on another way. I have that project running, and as a PDA the state is persisting as I was expecting. ( running anchor build, anchor deploy and solana-test-validator). When I clone the project to another folder, If i do the same process I get that error:
All have to go in the #[program] module
Sounds like you want to just run a persistent validator? Or maybe you could restart the validator with an explicit ledger options (`solana-test-validator --help`)
can you put instructions in separate modules and import into the program module or do all instructions for a program have to be defined in the program module?
ah thanks, I forgot about that
<@!134416332509675520> do you have any suggestion for this? üôÇ
https://docs.rs/anchor-lang/latest/anchor_lang/prelude/derive.Accounts.html#instruction-attribute
How do I access instruction arguments in the accounts list struct attributes, e.g. for a user-defined seed in seeds=[...] when initializing a PDA?
possibly with the way things got packed together for the i32 it meant that a later test (which was just missing some inputs into the struct) was making it through
so it's not catching things there
I think the typescript code is a lil confused all around because of the Uint8Array -> [u8; 32] conversion
Yeah, is this definitely not weird? I'm not sure why you'd get a instruction deserialization error
weird that the i32 is working then!
Haha üòÅ
ü§¶‚Äç‚ôÄÔ∏è I'm going to go and sit in the shame corner
ahhh, I think I'm being incredibly dumb, and this is having an impact on an unrelated test
```
   60 #[derive(Clone, AnchorSerialize, AnchorDeserialize)]
   61 pub enum AccessType {
   62     Ardrive,
   63     Url,
   64     Pda,
   65 }
```
How is AccessType defined?
Ok I'm currently baffled by this a little. If I have a struct like this that I'm using as one of the function command inputs (ie `ext_append(ctx, data: ExtAppendData)`:
```
  436 #[derive(AnchorSerialize, AnchorDeserialize, Clone)]
  437 pub struct ExtAppendData {
  438     pub timestamp: i64,
  439     pub data_hash: [u8; 32],
  440     pub prev_hash: [u8; 32], 
  441     pub new_hash: [u8; 32],
  442     pub access_type: AccessType, 
  443     pub id: [u8; 32],      
  444 }
```

I get a 102 instruction deserialization error.

If I replace the `AccessType` with an `i32` it goes away. `String` has the same error. I thought enums had a well defined size? It's recognizing the enum on the typescript size, I get a different error when that is incorrect. Is there something else I need to do here so I can use a struct as a function argument?
sorry i should've specified rust client here. updated message to reflect this
well, I've created a repo with the code of this article https://www.brianfriel.xyz/understanding-program-derived-addresses/ . I run `anchor localnet` and the project is running, but if I stop that command in the terminal and I try to run it again, I get that error saying that the account is does not exists.
What do you mean by reset?
Is there a way to reset a PDA every time I start run the project.
```account.ts:154 Uncaught (in promise) Error: Account does not exist DWJaZaa8xh8PRTS2ts3i1vJi8ua4ku934z1jDkkTHuys```
Working with a PDA in localhost, if I stop the `anchor lotalnet`  and I try to run the program, I get this error:
Thank you, I think that is what I need
Sort of‚Äîsol itself isn't an spl token, so it doesn't strictly speaking have a mint, but there's the idea of "wrapped sol", which is exactly what you're talking about: a tokenized version of sol: https://explorer.solana.com/address/So11111111111111111111111111111111111111112
Is there a mint address that represents SOL? Would that make any sense?
any examples for writing a rust client for listening to a variety of events emitted from an anchor program?
okay i understand.. thanks! I just might have nudged you in multiple servers and channels. sorry about that üòÖ !
https://docs.rs/anchor-lang/latest/anchor_lang/prelude/derive.Accounts.html#instruction-attribute
But I don't think it has anything to do with deploy success/failure (IDL is an anchor-specific thing, and solana deploy doesn't care about it)
What does the `#[intruction()]` macro do?
I actually don't know why anchor sometimes decides to write the metadata section or not (I see where it happens in the code, but I don't know why we write/don't write it etc.)
is there any recommended anchor/solana cli/rust version people need to use for anchor build to work properly? I read somewhere solana-frozen-abi package and solana-cli should be the same version. a few weeks back `anchor build` was populating the metadata address.. It is not anymore (I might have changed the solana cli version somewhere in the middle)
Call `.to_account_info()` on it
Im trying the escrow program and it gets error using cpis (using Signer<'info>) idk much about that
Not much, `Signer` is a little bit nicer since it conveys the signer-ness right in the type
What is the difference between...? :
-------------------------------------
#[account(mut, signer)]
pub initializer: AccountInfo<'info>
-------------------------------------
#[account(mut)]
pub initializer: Signer<'info>
https://github.com/drift-labs/protocol-v1 has a bunch of examples
Anyone haver an example project of an Anchor program split into multiple files? Particularly with a state.rs file
is this something related with the new version?
stuff is not in the `.../idl/<projectname>.json` file after `Anchor build` ?
```"metadata": {
    "address": "Cco9Jh1g8w86iu1qzGYsLXuJKqoZMVGoaHE5yteLUbmF"
  }```
Hi everyone. A question about building in Anchor. Why the :
I tried to manually re-create the solution from anchor according to https://github.com/project-serum/anchor/pull/1363/files

```
export declare class CustomWallet extends NodeWallet {}
``` 

But calling `new CustomWallet(keypair)` still doesnt work... any idea what i could try next?
added some better error msgs here https://github.com/project-serum/anchor/pull/1603. Feel free to check out the PR already and tell me if it helped
This returns a keypair tho, right?
The key, judging by reading the code
Do you guys have an example of how is usually `anchor publish` run ? I think it fails to read a file


//////////////////////////////////////////////////////////////////////////////////////////

awesome, thanks for the clarification
The question mark is indeed what triggers the short-circuiting you want (so you need it)
i was getting a warning when trying to call it, i guess i left off the ?
What goes wrong?
here's another way i was trying: 
`pub fn verify_something2 (program_id: &Pubkey, account : &AccountInfo) -> Result<()> {
    if true { 
        return Err(error!(MyErrors::BadInput));
    }
    Ok(())
}`
That looks good so far, how are you using it?
`pub fn verify_something (program_id: &Pubkey, account : &AccountInfo) -> std::result::Result<(), ProgramError> {
    if true { 
        return Err(MyErrors::BadInput.into());
    }
    Ok(())
}`
What have you tried so far?
I'm trying to find an example of a sub function that returns an error (and stops the program) similar to the way you use return Err(error!(MyErrors::BadData)) in a main function.
Got it. This is helpful. Thanks a lot.
https://github.com/cqfd/quidproquo
<@!134416332509675520>
Yeah, guess so‚Äîat any rate, you won't have any way to asynchronously burn someone else's tokens
Oh great and burn issue will still exist. SO then use pda for token account instead of trader token account?
No, just the CHECK stuff
Unable to get beyond the 3007
Can someone share an example of a token transfer contract and client?
Yep
Ah I see. So make RPC call on chain.  Get the data and then make accounts from pubkey. Then call contract
It's definitely annoying to not be able to do it in a single request, but it's certainly possible to do it in 2
You can fetch that info from the chain, figure out which accounts are relevant, and *then* make your request to your contract
Yeah I feel our design may be not congruent with Solana paradigm.
Basically, when a match happens on OrderBook, we wont have accountinfo of token account. We will have all the info needed to get to it but it is all on chain. 
And IIRC i cant pass accountinfo of all traders via frontend cause there is a limit of how many you can pass.
I think I would need to take deeper dive into  how serum solved it. Probably will need 2-3 on chain programs to handle this. 
A nice thing would be to get pda account from key and seeds on chain (if program is the authority /owner) and write to it.
Thanks for indulging cqfd
that has other effects though right
anchor build --skip-lint
Is there anyway to ignore the ///CHECK errors?
but like alan said, you already have a key so no need to call `key()` anyway
fix is already merged, will be fixed with next release
It's a bug, yeah
Yeah, that could work
If this is the fix, why was it not an error in 0.20.1 but its an error in 0.21.0
Like so?
`    #[account(
        init,
        payer = initializer,
        mint::decimals = 9,
        mint::authority = long_mint_account,
        seeds = [
            oracle_asset_key.as_ref(),
            &expiry.to_le_bytes(),
            &strike.to_le_bytes(),
            &strike_exponent.to_le_bytes(),
            b"long"
        ], 
        bump = long_mint_bump
    )]
    pub long_mint_account: Account<'info, Mint>,`
But yeah, if you want to programmatically burn tokens (via program control), the way you'd do that is with a separate token account whose authority is a PDA
Just get rid of the `key()` thing, you've already got one apparently
Mm, not sure I understand your use case well enough, but sure, you could have another PDA to store tokens
Hi, Im running into and error that looks like this
```
error[E0599]: the method `key` exists for struct `anchor_lang::prelude::Pubkey`, but its trait bounds were not satisfied
   --> programs/squeeth/src/lib.rs:522:38
    |
522 |             vault.load()?.identifier.key().as_ref()
    |                                      ^^^ method cannot be called on `anchor_lang::prelude::Pubkey` due to unsatisfied trait bounds
    |
   ::: /Users/philpang/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-program-1.10.0/src/pubkey.rs:71:1
    |
71  | pub struct Pubkey(pub(crate) [u8; 32]);
    | ---------------------------------------
    | |
    | doesn't satisfy `_: AsRef<anchor_lang::prelude::AccountInfo<'_>>`
    | doesn't satisfy `anchor_lang::prelude::Pubkey: anchor_lang::Key`
    |
    = note: the following trait bounds were not satisfied:
            `anchor_lang::prelude::Pubkey: AsRef<anchor_lang::prelude::AccountInfo<'_>>`
            which is required by `anchor_lang::prelude::Pubkey: anchor_lang::Key`
```
after updating to 0.21.0. Ive seen other people running into this when searching the channel but non of their solutions worked for me
store what? We are storing sol in the escrow pda. Are you saying we store tokens there too?
Yeah, store them in an escrow token account whose authority is a PDA derived from your program
program owns the mint
like trader is the one that owns the assco token account
yes. Is there a way?
Sounds like you want those tokens to be under control of the program, not the trader
(Sorry, more dumb questions) which tokens are you burning?
well not 'just'. Is a big issue
just this issue
GUi etc is coming fine
Also 4 days before hackathon submission and we are scrambling üò¶
but we got stuck cause burn requires signature of trader
Alas no. Cause matching will happen on chain. SO will know the pubkey of the account on chain. How to get account from there will be the problem. I think we tried emitting the pubkey and converting into account.
The front end doesn't know which account?
yes but front end does not know the account and even if i could some how (using emit/event etc) I cant burn tokens without trader signature. Can I?
Ah, ok, yeah, you would need to pre-emptively fetch that order book account on the client and then use it to pass in the right accounts (definitely annoying)
so i was thinking to use pubkey of traders to make pda and write to that. But i still have the issue of missing accountinfo.
But at that time i  do not have account info of those two matched traders. I have their pubkey
So trying to do a binary option type of platform. The sample code in solana repo uses long_token_min and short-token_mint as a way to track the options in a user account. That is a cool way of doing this. But they pass both seller and buyer's accountinfo in the instruction.
I can't do that cause I don't know who buyer and seller are. Traders come. Enter order. Order sits in a orderbook (Vec) and matching happens when price matches. At that point i would like to  mint tokens to the two matching counter parties
Like, how else is your program getting invoked?
Can you say more about what's not working? Reading your question again, I think I'm not sure what you mean by when the user has "disconnected" from the program
üôÇ . ofc. That has been a pain point in designing the async app. Will necessitate postgresdb etc which i was hoping to avoid.  Or use pda as data stores and pay up lamports.
was hoping to use mint and burn tokens as db solution but that is not possible without accountinfo.
And there is no way to save accountinfo or a transaction on chain for later execution (when cerayin conditions are met)
No, you always need to pass in from the client any accounts you want to use
A noob question. To access account and write to it we need accountinfo to be passed from front end.
But can we use pda on chain to get account that we can write to (as in not accountinfo passed from front end).
Need a place to store data and change it after the user has disconneceted from program
Full variable name (it's just an expression that gets injected during codegen)
is there a shorthand ie ("this", "self", etc) in the constraints or do you have to use the full variable name?
you can also use `address` on the target instead of constraint. thats a little less verbose
yea the name isnt great. we'd be very happy to adjust the name. just havent found anything so far that encapsulates its function
ok I agree as well. constraint is a lot easier to read.  has_one seems like it was created by someone that wasn't a native/fluent english speaker (no offense). To me the phrase "has_one" means that the object has one (and only one) of something.
Personally I find the `constraint =` version easier to understand so I just use that one ü§∑‚Äç‚ôÇÔ∏è
Yep https://github.com/project-serum/anchor/blob/master/lang/syn/src/codegen/accounts/constraints.rs#L199
is has_one = whatever @error::xyz equivalent to constraint = this.whatever == whatever.key() @error::xyz ?
gm! I'm trying to deploy my first program with anchor, and I'm getting this error (an issue search in github didn't lead me to anything). Does anyone have any idea what I'm doing wrong here?

``` ‚ûú  myepicproject anchor deploy
Deploying workspace: https://api.devnet.solana.com
Upgrade authority: /Users/hugomn/.config/solana/id.json
Deploying program "myepicproject"...
Program path: /Users/hugomn/workspace/hugomn/solana/myepicproject/target/deploy/myepicproject.so...
=======================================================================
Recover the intermediate account's ephemeral keypair file with
`solana-keygen recover` and the following 12-word seed phrase:
=======================================================================
cat tunnel tunnel speed type rival journal hair coach report false bored
=======================================================================
To resume a deploy, pass the recovered keypair as the
[BUFFER_SIGNER] to `solana program deploy` or `solana write-buffer'.
Or to recover the account's lamports, pass it as the
[BUFFER_ACCOUNT_ADDRESS] argument to `solana program close`.
=======================================================================
Error: Deploying program failed: Error processing Instruction 1: custom program error: 0x1
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.
```
I thought that might be wishful thinking üòá
No (no way to do that in a general way)
are methods implemented on accounts in the program generated in the typescript client>
in case you weren't sure, i don't see it in the solana explorer either (not a solution just letting you know in case u thought its unique to your network)
hello! what's the preferred way of importing an idl into a client using typescript? i'm getting an incorrect type error when i try to initialize a new Program instance
can someone help me out here?
hey guys, I tried to deploy and it says success:

```
 $ÓÇ∞ anchor deploy --program-name 7xurYiJYztaosgqyCdtKer5MDmgJJHn2gPdtUthUXs6n
Deploying workspace: https://api.devnet.solana.com
Upgrade authority: /Users/0xonizuka/.config/solana/id.json
Deploy success
```

but why I can't see it in the Solana Explorer: https://explorer.solana.com/address/7xurYiJYztaosgqyCdtKer5MDmgJJHn2gPdtUthUXs6n?cluster=devnet
I was looking here but didnt find a list.
thanks! üôÇ
Think you want `connection.getTokenAccountsByOwner`
without iterating through all SPL-tokens, and making an RPC get-request every time
is there an easy way to get all the tokenAccounts that the user holds in his (phantom) wallet?
try solana 1.8.12
I think when you get bump we use account variable name instead of local variable name (comment instead of comment_account)
umm... what is the significance behind this?
```Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account
    Program 3NcczXqNpzUsp6c2pGqLNJMnUwScvZBXduj8f3sg6Qdz invoke [1]
    Program log: Instruction: AddComment
    GzStgSSy82mYhc847W871fkuQNuzGLtRqiuHkEPTzwMP's signer privilege escalated
    Program 3NcczXqNpzUsp6c2pGqLNJMnUwScvZBXduj8f3sg6Qdz consumed 15756 of 1400000 compute units
    Program 3NcczXqNpzUsp6c2pGqLNJMnUwScvZBXduj8f3sg6Qdz failed: Cross-program invocation with unauthorized signer or writable account
    1) can create comment```

new error
can you try `comment_account.bump = *ctx.bumps.get("comment").unwrap();`?
can anyone help?
I dont understand where I am going wrong
```rust
#[derive(Accounts)]
pub struct AddComment<'info> {
    #[account(init, seeds=[b"vibe_comment", commentor.key().as_ref(), vibe.key().as_ref()], bump, payer = commentor, space = Comment::LEN)]
    pub comment: Account<'info, Comment>,
    #[account(mut)]
    pub vibe: Account<'info, Vibe>,
    #[account(mut)]
    pub commentor: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[account]
pub struct Comment {
    pub vibe: Pubkey,
    pub commentor: Pubkey,
    pub comment: String,
    pub bump: u8,
}
```
endpoint
```rust
    pub fn add_comment(ctx: Context<AddComment>, comment: String) ->  Result<()>  {
        let comment_account = &mut ctx.accounts.comment;
        let commentor = &mut ctx.accounts.commentor;
        let vibe = &mut ctx.accounts.vibe;

        if comment.chars().count() > 150 {
            return Err(ErrorCode::CommentTooLong.into())
        }

        comment_account.vibe = vibe.key();
        comment_account.commentor = *commentor.key;
        comment_account.comment = comment;
        
        comment_account.bump = *ctx.bumps.get("comment_account").unwrap();

        vibe.comments += 1;

        Ok(())
    }
```
Test
```ts
it("can create comment", async () => {
        const vibe = anchor.web3.Keypair.generate();
        const author = program.provider.wallet;

        await program.rpc.createVibe("New Vibe", "Comment to be Added", {
            accounts: {
                vibe: vibe.publicKey,
                author: author.publicKey,
                systemProgram: anchor.web3.SystemProgram.programId,
            },
            signers: [vibe],
        });

        const [commentAccount, _] = await PublicKey.findProgramAddress(
            [
                anchor.utils.bytes.utf8.encode("vibe_comment"),
                author.publicKey.toBuffer(),
                vibe.publicKey.toBuffer(),
            ],
            program.programId
        );

        await program.rpc.addComment("New Comment", {
            accounts: {
                comment: commentAccount,
                vibe: vibe.publicKey,
                commentor: author.publicKey,
                systemProgram: SystemProgram.programId,
            },
        });

        const createdVibe = await program.account.vibe.fetch(vibe.publicKey);
        const createdComment = await program.account.comment.fetch(
            commentAccount
        );

        assert.equal(
            createdComment.commentor.toBase58(),
            author.publicKey.toBase58()
        );
        assert.equal(createdComment.comment, "New Comment");
        assert.equal(createdVibe.comments, 1);
    });
```
New day new error
```
Transaction simulation failed: Error processing Instruction 0: Program failed to complete
    Program 3NcczXqNpzUsp6c2pGqLNJMnUwScvZBXduj8f3sg6Qdz invoke [1]
    Program log: Instruction: AddComment
    Program 11111111111111111111111111111111 invoke [2]
    Program 11111111111111111111111111111111 success
    Program log: panicked at 'called `Option::unwrap()` on a `None` value', programs/solvibe-social/src/lib.rs:100:66
    Program 3NcczXqNpzUsp6c2pGqLNJMnUwScvZBXduj8f3sg6Qdz consumed 19383 of 1400000 compute units
    Program failed to complete: BPF program panicked
    Program 3NcczXqNpzUsp6c2pGqLNJMnUwScvZBXduj8f3sg6Qdz failed: Program failed to complete
    1) can create comment
```

I am trying out Anchor v0.22.1 and this error is occuring for some reason
borsh.io
anyone have a quick reference to the space each data type takes up?
`use anchor_lang::prelude::*`. Should just be `use anchor_lang::error_code`. This will fix it https://github.com/project-serum/anchor/pull/1610
Anyone know what I need to import in order for the #[error_code] instruction to compile?
ah, thanks
https://docs.rs/anchor-lang/latest/anchor_lang/prelude/derive.Accounts.html#spl-constraints
Thanks. Where in the anchor docs can I find the attribute arguments like `mint::decimals` needed to initialize accounts like Mint?
perfect, thanks!
Yeah
like the one in `target/deploy/<program_name>_keypair.json`
ok and the runtime program_id is determined by the program's associated keypair, right?
No, you do need to change it‚Äîit needs to exactly match your actual runtime program_id
so when i deploy a project to mainnet, i dont have to bother changing that default address? it'll just create a new random one for me and deploy the program to that?
Hmm, don't think anchor has an option for that, as far as I know‚Äîyou just need to change it yourself once you make your own keypair
yeah
You mean the Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS one?
how does one change the default deployment address that anchor generates for you when you create a new program?
The spl token program isn't an anchor program, so no discriminator. Also, if you want you can just let anchor make the mint for you: https://github.com/cqfd/anchor-token-studies/blob/main/programs/token-studies/src/lib.rs#L95
Oh actually I see there's a `Mint::LEN` property that I think gives me what I need. Would I need to add 8 for a discriminator or does anchor not add a discriminator to Mint accounts?
Or do I leave it up to the initialize_mint CPI to create the account and just pass it a PDA that hasn't been created yet?
I'm trying to create a program-owned token mint from within a smart contract. When creating the Mint account from a PDA, how much space do I need to allocate?
yes ) last 1.8 release work
For a quick solution I had to downgrade solana to `1.8.14`  and it worked like a charm for me. Try downgrading it and deploy again
Any reason not to store all data in JSON string that I can pass  and desearialize locally and then deserialize on Solana when necessary?
```let signedTrans = await window.solana.signTransaction(trans);``` I am using this now, but still im getting the same error...
i need the user to sign the transaction using phantom wallet
i am probably missing something out,  you may construct a new PublicKey object then toBase it if that is what u desire
```js
   const connectWallet = async () => {
    const { solana } = window;

    if (solana) {
      console.log("Wallet is found");
      const response = await solana.connect();
      console.log("Key is: ", response.publicKey.toString());
      console.log(response)
      setWalletAddress(response.publicKey);
      setWallet(response);
    }
  }; ```
the walletAddress is the public key i recieved when i connected the wallet
.toBase58() does not exist for walletAddress
guys can anyone help me solve this problem?


//////////////////////////////////////////////////////////////////////////////////////////

Any tips on how to debug `AccountDidNotDeserialize` errors? I added an account to a struct and now when I try to execute that instruction it states that it can't deserialize the account. There are other cases that seemingly look identical where things work as expected

```
    Program 6mn7W95E1C3SPn8KHsLXKsi2UhpEkvZhZLZ6QAZd5Dc9 invoke [1]
    Program log: Instruction: RequestResult
    Program log: AnchorError caused by account: vault_manager. Error Code: AccountDidNotDeserialize. Error Number: 3003. Error Message: Failed to deserialize the account.
```
So for that size program I think you'd need about 5 sol
You annoyingly need about the same amount as when you first deployed, but solana won't actually charge you for it
Deploying program failed: unable to confirm transaction. This can happen in situations such as transaction expiration and insufficient fee-payer funds. How much fund do I need to upgrade a program ? File size is 354 KB
by web3
How can I get buffer account from program address?
just realized that i'm not giving it a bump nvm
oops
Thank you. This fixed my issue.
Man this anchor bug took 8 hrs . 
On to chewing more glass üôÇ
is there a ticket for it?
may be i can help you fix it
yeah
Yeah, it's just doing nothing :/
seems like
But yeah, this is a bug in the anchor cli, it doesn't really realize when you feed it a program that it's confused about
which actually deployed the program
I end up using solana program deploy
i kind of gave up
```
 $ÓÇ∞ anchor deploy --program-name mynftproject
Deploying workspace: https://api.devnet.solana.com
Upgrade authority: /Users/0xonizuka/.config/solana/id.json
Deploy success
```

it shows this, but how do I check that it's deployed correctly.. things are running so fast though, skeptical if it's actually deployed
i tried that too
I think the --program-name argument is supposed to be the actual name of the program, not its program_id
is that because my directory path to the project contain spaces?
getting the same error on `anchor test`
can someone help me with this? https://github.com/project-serum/anchor/issues/1000#issuecomment-1066722199
Thanks üëç
Bumps are deterministic functions of the seeds
No
So it's not related to security or something like that?
Any of those three options is fine
You can certainly do it that way if you want
Oh, OK.
Ok, to elaborate: passing them in from the client is annoying
Really?
Or tried to at least
I just answered that üòõ
I know that: the question is: why store them inside the program state instead of just providing them from the client?
You need access to the bumps if your program wants to sign for one of those PDAs, so you basically have three options: stash the bumps in program state, pass them in from the client as instruction arguments, or recalculate them on the fly with `Pubkey::find_program_address` (which can cost a surprising amount of compute units).
I find that it's done a lot inside the Anchor code
Hey, why do people store the bump seeds in the program state?
any ideas?
hey guys, why am I getting this error:

```
error: Invalid value for '--program-id <PROGRAM_ID>': unrecognized signer source
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.
```
In solana, when you create an account you need to sign for the account's address. You're not doing that here: you need to add a `, signers: [this.newAccount]` to that call
I have the update function sorted, just don't know how to implement the custom type on either end
Does anyone know how to update a list with a custom data type such as a struct from the react front end so that it can compile
I think you should send newAccount to the signer anyway (try to change data field in that account maybe). AFAIK only the wallet that will be sign automatically
umm not sure about this. I dont know the best practices to handle this case. I think you can store your keypair somewhere and replace when target/deploy/*keypair after build for the first time but it is still extra step anyway.
Then I have to include the generated keypair in git for team members to run the tests without updating `declare_id!()`?
if you didn't mind to change the program id (for test purpose) then yes you have to change declare_id! and Anchor.toml to match the generated keypair.
But what does it have to do with the `declare_id!()`? Do I have to update the `declare_id!()` to match with the generated keypair?
Thanks for the answer. üôÇ 
The reason why the code has not a signer(s) parameter is that sends a transaction using a web browser-based wallet like Phantom.
In that case, as I know, no needed signer(s) because the provider will sign the transaction automatically.
you will get difference keypair. even if you delete target directory then build again in the same machine you still get different keypair
How keypairs `target/deploy/*-keypair.json`  are generated? If I `cargo clean && anchor build` in another machine, does Anchor generate the same keypair?
No clue if this is going to solve your problem, but for me it looks like you're not passing signer(s) to your RPC call.

```
accounts: {
  ...
},
signers: [this.newAccount]
```
Can I ask one fundamental question?

If I created a new account from a specific deployed program with SystemProgram, after that trying to create a new different account is not available?

Whenever I trying create a new account with new key-pairs, I can't create a new account with the same program.

Contract side is below:
```#[derive(Accounts)]
pub struct Create<'info> {
    #[account(init, payer = authority, space = 8 + ?)]
    pub program_status: Account<'info, Status>,
    #[account(mut)]
    pub authority: Signer<'info>,
    pub system_program: Program<'info, System>,
}```

Client side is below:
```await program.rpc.create({
    accounts: {
        programStatus : this.newAccount.publicKey,
        authority: this.wallet.publicKey,
        systemProgram: web3.SystemProgram.programId,
    },
});```

The new account part is `this.newAccount.publicKey` .
And the error message is `Error: Signature verification failed` .

Thank you for reading.
How to change rpc endpoint to custom one when deploying with Anchor? I cannot find the list of config that I can change in Anchor.toml. If it already have document for that please enlighten me
for passing data in, it looks like struct are ok, but only with primitive types as properties, i.e, no structs as properties of the struct that gets passed in as data? - this works - wasn't camelCase everywhere
Try upgrading anchor. I had an identical bug that was fixed by updating anchor to 0.22.1 and switching to the new bump syntax
Anyone know how i could adjust the clock of my local validator? it's off by 5 days
The problem was the default commitment level. I'm not sure why ours are different but adding `commitment: 'processed'` fixed it and now it's very speedy.

Example:
```
new anchor.Provider(connection, walletWrapper, {
        preflightCommitment: 'recent',
        commitment: 'processed'
    });
```
`TypeError: Cannot read properties of undefined (reading 'preflightCommitment')`
Looks like it's required.
whats the error?
It errors out. I just tried `'singleGossip'` and it takes the same amount of time.
what happens if u set it to undefined?
I just use the default & using anchor version 0.22.0
I set the preflightCommitment to: `preflightCommitment: 'recent'`
what is your commitment level? The default commitment works fine for me locally, and is pretty fast.
Is there a good way to optimize the speed of calls to: `program.rpc.SomeTransaction`?
Anything I try from the client takes about 15 sec locally and that seems pretty slow given Solana's speed. 

For example, from the docs: 
```
   const txSignature = await program.rpc.increment({
   accounts: {
      counter,
      authority,
   },
});
```

How do others handle this?
trader_mint_pda is getting privilige escalation
the front end is -
`    const trader_mint_seeds = [
      Buffer.from("foo")
    ]
    const [ trader_mint_pda, trader_mint_bump ] = await PublicKey.findProgramAddress(
      trader_mint_seeds,
      program.programId
    );`
i have dealt with a lot of this error in past but this time i am stumped
any ideas what I am missing.
for the pub trader_mint_pda: AccountInfo<'info>,
```pub struct OpenNewTrade<'info> {
    //TODO make sure trader has money
    #[account(
        signer,
        mut
    )]
    pub trader: AccountInfo<'info>,

    #[account(
        init,
        payer = trader,
        space = 16,
        seeds = [ b"foo".as_ref()],
        bump = trader_mint_bump,
    )]
    pub trader_mint_pda: AccountInfo<'info>,

    #[account(
        init_if_needed,
        payer = trader,
        associated_token::mint = long_mint_account,
        associated_token::authority = trader_mint_pda,
        
    )]
    pub trader_long_mint_account: Box<Account<'info, TokenAccount>>,

    #[account(
        init_if_needed,
        payer = trader,
        associated_token::mint = short_mint_account,
        associated_token::authority = trader_mint_pda,
      
    )]
    pub trader_short_mint_account: Box<Account<'info, TokenAccount>>,
    
    #[account(mut)]
    pub option_account: Box<Account<'info, OptionAccount>>,

    #[account(mut)]
    pub vault_account: Box<Account<'info, Mint>>,
    //Check if mints match
    #[account(mut)]
    pub long_mint_account: Box<Account<'info, Mint>>,
    #[account(mut)]
    pub short_mint_account: Box<Account<'info, Mint>>,
    pub associated_token_program: Program<'info, AssociatedToken>,
    pub token_program: Program<'info, Token>,
    pub rent: Sysvar<'info, Rent>,
    pub system_program: Program<'info, System>,```
Getting CPI unauthorized error or writable acoount. Not sure why. The account is not being used for anyhting yet.
Anyone know how to adjust the clock of my local validator? it's off by 5 days
yea, just add them one after another, separated by commas
is there a way to add multiple constraints on an account, each with their own error?
just logging for anyone searching discord: if you get  `Access violation in stack frame` and u are passing in a lot of accounts you can wrap the accounts in `Box<>` like `pub mint1: Box<Account<'info, Mint>>` to allocate directly on the heap and save stack space
anyone know? üòì
yes, it fixed, big thx!
thx, will try
You probably need to pass a `new anchor.BN(...)` instead of  JS number
I have a 4 arguments for my call and when create a call from test, i get TypeError: src.toArrayLike is not a function, but if comment any arg a get an error that i forget some account, where a problem? Thx
hey guys im doing a project with anchor but this question is a question unrelated to anchor hope someone can help me out üòõ for some reason i cant locate any projects that i create on ubuntu on my pc. anyone know why?
Unable to createassociatedtokenaccount
gg
theres a getBalance function
lol for future lurkers: https://github.com/solana-labs/solana-web3.js/blob/35f0608a8363d3878d045bdb09cdd13af696bc6b/src/connection.ts
how can we see balances of public keys when testing with anchor? i think we have to make a connection but not sure how to use the same details as the anchor.Provider.env()
Yeah, shouldn't matter, but you'll have to be consistent and do things like `theClientSideBN.toArrayLike(Buffer, 'le', 4)` (so 'le' for little-endian and 4 b/c it's a u32 = 4 bytes)
theoretically if it was a u32, i guess it doest matter either as long as its consistent? is there a best practice?
If it's only a single byte then it doesn't matter (endianness only applies when the number takes more than one byte)
beginner rust question. How do i pass an integer as one of the seeds to find_program_address, should it be a big-endian, little-endian etc?

```rust
            let authority_id: u8 = 0;
            let (authority, authority_nonce) = Pubkey::find_program_address(
                &[
                    ctx.accounts
                        .authority
                        .to_account_info()
                        .owner
                        .as_ref(),
                    &authority_id.to_be_bytes(),
                ],
```


//////////////////////////////////////////////////////////////////////////////////////////

This is coming from the other function that used that same context.  No compile time warning though.  This works fine with anchor 0.20.0
Looks like i spoke too soon.  
`    Program failed to complete: Access violation in stack frame 5 at address 0x200005000 of size 8 by instruction #59515`
Hi!

I am trying to validate an account (to which some SOL has to be transferred) as 

```
    #[account(mut)]
    pub creator_spl_account: Account<'info, TokenAccount>,
```

This account is created and airdropped some lamports on the tests.ts as

```
      const creatorsWalletKeypair = anchor.web3.Keypair.generate();
      let signature = await program.provider.connection.requestAirdrop(
        creatorsWalletKeypair.publicKey,
        1000000000 // 1 SOL ‚Äî or 1 billion lamports
      );
```

I am getting the following error:

```
Program log: AnchorError caused by account: creator_spl_account. Error Code: AccountOwnedByWrongProgram. Error Number: 3007. Error Message: The given account is owned by a different program than expected.
```

Is it right to validate it as a `TokenAccount` if only SOL is being sent to it ?
If so, is the `tokenAccount`created when we airdropped SOL for the first time ?

<@!134416332509675520>
That same context is used else where without error. (that offending func is a copy pasta).  I'll circle back on this later if i find anything interesting.  Removed it for now.
I have added cpi features to my Cargo.toml
do I need anything in my Anchor.toml
but I could not find the cpi crate when I try to compile:
```
error[E0433]: failed to resolve: could not find `cpi` in `stable_swap`
  --> programs/stableTry/src/lib.rs:31:22
   |
31 |         stable_swap::cpi::process_instruction(
   |                      ^^^ could not find `cpi` in `stable_swap`
```
Ok, I'm trying to figure out exactly why I can't find the cpi crate.
I'm trying to call the saber-swap program, process_instruction function:
```
//! Program entrypoint definitions
#![cfg(not(feature = "no-entrypoint"))]

use crate::{error::SwapError, processor::Processor};
use solana_program::{
    account_info::AccountInfo, entrypoint, entrypoint::ProgramResult,
    program_error::PrintProgramError, pubkey::Pubkey,
};

entrypoint!(process_instruction);
fn process_instruction<'a>(
    program_id: &Pubkey,
    accounts: &'a [AccountInfo<'a>],
    instruction_data: &[u8],
) -> ProgramResult {
    if let Err(error) = Processor::process(program_id, accounts, instruction_data) {
        // catch the error so we can print it
        error.print::<SwapError>();
        return Err(error);
    }
    Ok(())
}```
^This is the file in the saber-protocol  stable-swap-program/program/src/entrpoint.rs in this github: https://github.com/saber-hq/stable-swap

And this is what I'm trying to write, calling the stable-swap protocol:
 ```
use stable_swap::*;
#[program]
pub mod stable_try {
    use super::*;
    pub fn test(ctx: Context<SwapInfoCtx>) -> ProgramResult {
        let sInfo1 = *ctx.accounts.swap_info_account;
        let boolz = sInfo1.is_initialized;
        msg!("raw data1:{:?}", boolz);
        ////try to pause it and get an error
        //stable-swap program-id-key
        let idKey = "SSwpkEEcbUqx4vtoEByFjSkhKdCT862DNVb52nZg1UZ";
        let programID: Pubkey = idKey.parse().unwrap();
        stable_swap::cpi::process_instruction(
            &programID,
            &[ctx.accounts.ac1, ctx.accounts.ac2],
            &[102]
        );
        Ok(())
    }
}
#[derive(Accounts)]
pub struct SwapInfoCtx<'info> {
  pub swap_info_account: Account<'info, SwapInfo>,
  pub ac1: AccountInfo<'info>,
  pub ac2: AccountInfo<'info>
}```
Ah, it's from all the work anchor is doing to get that Context thing set up
hmm, removing that function avoids the error.  nothing wrong looking in that func to me though..
`    pub fn make_offer(_ctx: Context<BuyToken>) -> Result<()> {
        Ok(())
    }
`
This is the function complained about:
Maybe i'm not understanding exactly what the error means.
Why hard to believe?
This is the call stack?  This i find hard to believe..
THanks
Got it
account data is what I am after
You would have to pass that account in from the client
Or do I CPI the data into the program that neads to read, from the program to be read
From the client?
Only thing you can read in solana is account data, so you'd have to pass whatever account holds the data you care about into your program
How do i read data from a program inside a separate program?
Have to pass the account in from the client, no way around it
Nope
any way to convert publicKey type to AccountInfo type?
(which in general  will fail at runtime)
Mm, not actually sure if that will fail at runtime, but yeah, you're nearly completely out of stack space
should i be worried about this?  `Error: Function _ZN11marketplace9__private8__global10make_offer17h0acc83c64d41a369E Stack offset of 4096 exceeded max offset of 4096 by 0 bytes, please minimize large stack variables
`
ok got it compiling
`error: cannot find attribute `error` in this scope`
did the error stuff get switched around in the new anchor?
ah, thats it, thank you
And then later use a `&` if you need to
Like, just do `let Ac1: Pubkey = ac1.parse().unwrap();` to be explicit
Ah, make sure you're trying to get an actual `Pubkey`, not a `&Pubkey`
Double check you've added that use statement in an accessible place, should work (works for me)
hmm, still same error
`use std::str::FromStr;`
on the lines:
```
        //necessary accounts
        let ac1 =  "SQDY9uoDoCbNq7F3HAHYYQZbrUzpKxDtdWLvYcqBLak";
        let Ac1 =  ac1.parse().unwrap();
```
```error[E0277]: the trait bound `&anchor_lang::prelude::Pubkey: FromStr` is not satisfied
  --> programs/stableTry/src/lib.rs:25:24
   |
25 |         let Ac1 =  ac1.parse().unwrap();
   |                        ^^^^^ the trait `FromStr` is not implemented for `&anchor_lang::prelude::Pubkey`
   |
```
`"aasdfasdfasd".parse().unwrap()` should probably work here
I feel like I'm getting close. I'm trying to call "pause" this is what I have:
```
#[program]
pub mod stable_try {
    use super::*;
    pub fn test(ctx: Context<SwapInfoCtx>) -> ProgramResult {
        //try to pause it and get an error
        //stable-swap program-id-key
        let idKey = "SSwpkEEcbUqx4vtoEByFjSkhKdCT862DNVb52nZg1UZ";
        //necessary accounts
        let the_accounts = ["SQDY9uoDoCbNq7F3HAHYYQZbrUzpKxDtdWLvYcqBLak",
                        "AUMZDG77zj4G4Ex9bfB3TsNaCQLb1m3WTRM9Dmb6VUgU"];
        let signer_seed = "foo";

        //let ix = stable_swap_client::instruction::pause(ctx.accounts.swap.key, ctx.accounts.admin.key)?;
        let ix = stable_swap_client::instruction::pause(
            "SQDY9uoDoCbNq7F3HAHYYQZbrUzpKxDtdWLvYcqBLak",
            "AUMZDG77zj4G4Ex9bfB3TsNaCQLb1m3WTRM9Dmb6VUgU")?;
        solana_program::program::invoke_signed(&ix, &idKey, signer_seed)?;

        Ok(())
    }
}```
It doesn't compile. How do I convert an address string to a publicKey object?
been grinding w emacs and vim/tmux
yeah gotta install vscode too lol
Vscode has a slick way to automagically attach a node debugger if you run the tests from its built-in console
the describe and it keywords, guess i'll use ndb
nah its just anchor test
How are you running that code? In the browser?
um how would i use a debugger in this case lol only ever used gdb and c
Mm, not sure, can always try stepping through with a debugger though
sorry for interrupting but is there anything i can try in the meantime lol
But yeah, assume it's going to be something simple üòõ
Can try doing a `cargo clean` and then rebuild?
v odd
There is something different between the two program configs....but it;s not the lib.rs or the Cargo.toml.  Both identical now
New versions of anchor do make a type alias for that Result thing, but old ones don't‚Äîthat's why I thought it might be a version issue
I get a few weird errors:
`error[E0432]: unresolved import `crate`
  --> programs/fractions/src/lib.rs:16:1
   |
16 | #[program]
   | ^^^^^^^^^^ could not find `__client_accounts_list_token` in the crate root
`
Mm, not sure, but it will be something simple‚Äîa slightly different import, etc.
the anchor-lang version in Cargo.lock matches the versions in both Cargo.toml files. (though i had to downgrade the newly created program to the same version as my existing program)
i implemented my own transfer function and it works with the same parameters but really not sure why the system instruction doesn't üò¶
yup i did just a number first but added that out of desperation lol
and i've tried these console logs and they all work
```    console.log("investor", investor.publicKey.toBase58(), investor.secretKey);
    console.log("creatorTreasury", creatorTreasury.toBase58());```
That lamports amount should just be a number, fwiw (not sure if that's the issue though)
Investor is a keypair, creatorTreasury is a public key
``` const transaction = new Transaction().add(
      SystemProgram.transfer({
        fromPubKey: investor.publicKey,
        toPubKey: creatorTreasury,
        lamports: new anchor.BN(transferVal),
      })
    );

    await sendAndConfirmTransaction(
      provider.connection,
      transaction,
      [investor],
      {commitment: "confirmed"}
    );
```

I'm trying to use SystemProgram.transfer but keep getting ```TypeError: Cannot read properties of undefined (reading 'toBase58')```
Different anchor-lang versions (check the corresponding Cargo.lock files)
`error[E0107]: this enum takes 2 generic arguments but 1 generic argument was supplied
   --> programs/fractions/src/lib.rs:16:10
    |
16  |     ) -> Result<()> {
    |          ^^^^^^ -- supplied 1 generic argument
    |          |
    |          expected 2 generic arguments`
The second program i made today with `anchor new`.  Cargo.toml matches
how is it possible that the same code in two separate programs within a project compiles ok in one but not the other?
There's some random extra stuff happening in this example, but yeah: https://discord.com/channels/889577356681945098/889702325231427584/948964633094529064
any example on building the instruction?
It will be somewhat tricky to use though, since building the instruction is kinda tough
Sure
So I can use that instead?
if I understand correctly: I can import stuff with anchor to do calls, but it's also possible to do a raw invoke call using something like this:
https://docs.solana.com/developing/programming-model/calling-between-programs
Think ordinarily you'd let the wallet adapter stuff handle that for you, e.g. this kind of thing with `useConnection` (in react anyway): https://github.com/solana-labs/wallet-adapter#usage
Some of them are magically generated by anchor macros, so it's hard to see an actual list/you unfortunately can't jump to source on them :/
üëã quick question - what is the best practice for setting the network in Solana web.js? In the typescript code, I've been hardcoding the network as a constant, but want to change this dynamically based off the network the user has selected in their wallet (e.g. if they have devnet selected, change the typescript params to point to the devnet rpc url)
any way I could find all the things I'm importing when I use:
`use stable_swap::*;`
Like where can I find the list of crates I import with the above line?
Mm, I think that's all you should need to do
do I need to compile something to get a cpi module?
I noticed there's no module explicitly labelled cpi in the example either
yeah
Is that an anchor program?
So this line is in my cargo.toml for the contract I'm writing:
stable-swap = { path = "/home/a/stable-swap/stable-swap-program/program", features = ["cpi"] }
but I get an error that the cpi module can't be found:
```error[E0432]: unresolved import `stable_swap::cpi`
 --> programs/stableTry/src/lib.rs:6:18
  |
6 | use stable_swap::cpi::*;
  |                  ^^^ could not find `cpi` in `stable_swap`
 ```
How is the cpi module generated?
I'm also looking at figuring out how to do a CPI from this tutorial:
https://project-serum.github.io/anchor/tutorials/tutorial-3.html#defining-a-puppet-master-program

I think I missing the cpi crate somehow?
thank you
ah, that works
I would like to log just the account, just one variable, like is_initialized
Ah, try doing `**sInfo` instead
What's wrong with the log above?
with
```#[derive(Accounts)]
pub struct SwapInfoCtx<'info> {
    ///Check: based
  pub swap_info_account: Account<'info, SwapInfo>
}```
or actually a pointer to it:
```        let sInfo1 = &ctx.accounts.swap_info_account;```
Account<'info, SwapInfo>
Or, are you saying that's wrong?
What type is sInfo?
This gets logged:
```Program log: raw data1:Account { account: SwapInfo(SwapInfo { is_initialized: true, is_paused: false, nonce: 254, initial_amp_factor: 200, target_amp_factor: 200, start_ramp_ts: 0, stop_ramp_ts: 0, future_admin_deadline: 0, future_admin_key: 11111111111111111111111111111111, admin_key: AUMZDG77zj4G4Ex9bfB3TsNaCQLb1m3WTRM9Dmb6VUgU, token_a: SwapTokenInfo { reserves: GiehZ4X2uQjhEKuxSm3ACmEFrabxh3RTvjbLfLjw1xGX, mint: EgQ3yNtVhdHz7g1ZhjfGbxhFKMPPaFkz8QHXM5RBZBgi, admin_fees: nukUCjiUHV3XxsQGfigvxAHRLrJprpB45oQ2PHB1Bue, index: 0 }, token_b: SwapTokenInfo { reserves: rxDQYV77NKRKYxCjq4cECX3QQsiSyLv1T1FT2X3zNA2, mint: JEFFSQ3s8T3wKsvp4tnRAsUBW7Cqgnf8ukBZC4C8XBm1, admin_fees: EjFDsYacwgvHNWQR8eBRA4cFTDWxfeNrkgmdV3cjrMXH, index: 1 }, pool_mint: AVDuGckLavyLr5YifViaxnoveY6rwqDezHw5kiKiRQEC, fees: Fees { admin_trade_fee_numerator: 0, admin_trade_fee_denominator: 10000, admin_withdraw_fee_numerator: 0, admin_withdraw_fee_denominator: 10000, trade_fee_numerator: 4, trade_fee_denominator: 10000, withdraw_fee_numerator: 0, withdraw_fee_denominator: 10000 } }), info: AccountInfo { key: SQDY9uoDoCbNq7F3HAHYYQZbrUzpKxDtdWLvYcqBLak, owner: SSwpkEEcbUqx4vtoEByFjSkhKdCT862DNVb52nZg1UZ, is_signer: false, is_writable: false, executable: false, rent_epoch: 289, lamports: 3640080, data.len: 395, data: 0100fec800000000000000c800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, .. } }
```
That's not what I wrote üòõ `*sInfo` all by itself
```error[E0616]: field `account` of struct `anchor_lang::prelude::Account` is private
  --> programs/stableTry/src/lib.rs:15:40
   |
15 |         msg!("raw data1:{:?}", *sInfo1.account);
   |                                        ^^^^^^^ private field

```
same problem
Do `msg!("raw data1: {:?}", *sInfo);` instead
<@!134416332509675520> can you quickly check the above, any way to turn private variable to public?
noob q, so when I do `div` that has a remainder, it just returns the whole part? I should check here - thx
Can you say more? What kind of floor? bn.js only supports integers
what it a good way to do a floor calc with bn.js 4.11? Newer version looks like it has `divmod`
Forgot to mention that the program I'm interfacing with has an ABI so I can access all the necessary functions inside my program. I've just enabled the cpi feature and specified the crate name and that seems to be ok as is. Thanks for your help!
Great, thanks a lot!!
I was checking this out the other day https://github.com/project-serum/anchor/blob/master/tests/events/tests/events.js
Strictly speaking no, but in practice you might need to, yeah, because you need to be able to build the A instruction you want to invoke.
gm! üåû does anybody know if we need to care about referencing program A from program B's Cargo.toml file when doing a CPI if program A isn't yours? The docs say it's important but the example is only for 2 programs in your codebase.
Hmm could you elaborate, would really appreciate it üôè
Hello. I want to get some ideas here. 
I want to listen for events emitted from my program.
Is there something similar to TheGraph that I can easily index and query? Or do I have to build my own backend (NodeJS) and listen to raw events and put event info to database?
```
However, if you want to use the bump in your instruction, you can pass it in as instruction data and set the bump value like shown in the example, using the instruction_data attribute. Anchor will then check that the bump returned by find_program_address equals the bump in the instruction data.
```
ig
doc is not updated ser
yeah it works with `bump,` alone, but the docs seems to suggest differnet semantics
"Checks that given account is a PDA derived from the currently executing program, the seeds, and if provided, the bump. If not provided, anchor uses the canonical bump."
```#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(
        init, payer = payer,
        seeds = [b"example_seed".as_ref()],
        bump
    )]```
you don't need to pass bump in new version of anchor
bump = xx with `mut` works fine
is this example wrong in the docs? Use bump=xxx with ‚Äùinit", throw the following error :
"bump targets should not be provided with init. Please use bump without a target"
https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html
is this code example from the doc wrong?
```
#[derive(Accounts)]
#[instruction(bump: u8)]
pub struct Initialize<'info> {
    #[account(
        init, payer = payer,
        seeds = [b"example_seed".as_ref()], bump = bump
    )]
```
I used to face this error when I used another library that checked their account against their mainnet program id.
pretty sure I haven't labelled any accounts as `Account` that aren't owned by my program
my program_ids all match
`3007: The given account is owned by a different program than expected` getting this error
Yeah your right my bad
I thought mint always owned by token program. Did you mean mint authority? sorry If I'm wrong.
meaning if the mint owner is someone else it should just be passed in as AccountInfo instead?
does this lead the program concluding that the mint is owned by the program?
pub mint: Account<'info, Mint>,
when providing a token mint to a program
but if I try to get the account variable of the above, sInfo.account, I get the private thing
If I just log sInfo itself it works:
```
Program log: raw data1:Account { account: SwapInfo(SwapInfo { is_initialized: true, is_paused: false, nonce: 254, initial_amp_factor: 200, target_amp_factor: 200, start_ramp_ts: 0, stop_ramp_ts: 0, future_admin_deadline: 0, future_admin_key: 11111111111111111111111111111111, admin_key: AUMZDG77zj4G4Ex9bfB3TsNaCQLb1m3WTRM9Dmb6VUgU, token_a: SwapTokenInfo { reserves: GiehZ4X2uQjhEKuxSm3ACmEFrabxh3RTvjbLfLjw1xGX, mint: EgQ3yNtVhdHz7g1ZhjfGbxhFKMPPaFkz8QHXM5RBZBgi, admin_fees: nukUCjiUHV3XxsQGfigvxAHRLrJprpB45oQ2PHB1Bue, index: 0 }, token_b: SwapTokenInfo { reserves: rxDQYV77NKRKYxCjq4cECX3QQsiSyLv1T1FT2X3zNA2, mint: JEFFSQ3s8T3wKsvp4tnRAsUBW7Cqgnf8ukBZC4C8XBm1, admin_fees: EjFDsYacwgvHNWQR8eBRA4cFTDWxfeNrkgmdV3cjrMXH, index: 1 }, pool_mint: AVDuGckLavyLr5YifViaxnoveY6rwqDezHw5kiKiRQEC, fees: Fees { admin_trade_fee_numerator: 0, admin_trade_fee_denominator: 10000, admin_withdraw_fee_numerator: 0, admin_withdraw_fee_denominator: 10000, trade_fee_numerator: 4, trade_fee_denominator: 10000, withdraw_fee_numerator: 0, withdraw_fee_denominator: 10000 } }), info: AccountInfo { key: SQDY9uoDoCbNq7F3HAHYYQZbrUzpKxDtdWLvYcqBLak, owner: SSwpkEEcbUqx4vtoEByFjSkhKdCT862DNVb52nZg1UZ, is_signer: false, is_writable: false, executable: false, rent_epoch: 289, lamports: 3640080, data.len: 395, data: 0100fec800000000000000c800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, .. } }```
share `SwapInfo` struct code
are you talking about `pub`
Any way to make the account field not private on an Account struct within anchor?
```error[E0616]: field `account` of struct `anchor_lang::prelude::Account` is private
  --> programs/stableTry/src/lib.rs:12:38
   |
12 |         msg!("raw data1:{:?}", sInfo.account);
   |                                      ^^^^^^^ private field```
And sInfo is of type: Account<'info, SwapInfo> . 
If I want to extract just the SwapInfo I believe sInfo.account would give it to me but it's private? How else can I log it?
Does my question make sense?
any way to make the account field not private when reading data?
what kind of default validation is there for Account<'info, whatever> ?
what was your solution here?
Hi everyone, struggling to get my initialize PDA instruction to work properly.

Here's the clientside code:
```const [nftPDA, _meronBump] = await PublicKey.findProgramAddress(
      [
        anchor.utils.bytes.utf8.encode("nft-stats"),
        nftMint.toBuffer()
      ],
      program.programId
    )
  await program.rpc.createNftStats(1000, 1, nftMint.publicKey, {
      accounts: {
        signer: program.provider.wallet.publicKey,
        nftStats: nftPDA,
        systemProgram: SystemProgram.programId
      },
    })
```
Here's my validation struct:
```
#[derive(Accounts)]
#[instruction(nft: Pubkey)]
pub struct CreateNFTStats<'info> {
    #[account(mut)]
    pub signer: Signer<'info>,
    #[account(
        init,
        payer = signer,
        space = 8 + NFTStats::LEN,
        seeds = [b"nft-stats", nft.as_ref()], 
        bump
    )]
    pub nft_stats: Account<'info, NFTStats>,
    pub system_program: Program<'info, System>,
}
```

Here's the error stack from the program log:
```Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account 
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS invoke [1]
    Program log: Instruction: CreateNftStats
    7mLqFZLNDer9n2eXTw9rEzSFVDrne5nFvjxmkk4f99te's signer privilege escalated
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS consumed 11909 of 1400000 compute units
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS failed: Cross-program invocation with unauthorized signer or writable account```

No idea what i'm doing wrong
not so far no
I didn't know about it. Now, It works well. 
Thanks a lot! üôÇ
Thank you so much.
I got mistaken for I have tried passing the new account into the parameter and it was not working.
Now, it works well. üôÇ
Though in general that won't always work, since js numbers are too small (can't represent integers exactly over 2^53, so not big enough for all 64 bits)
I think you can just do `theU64.toNumber()`
unless you're storing an metric load of data on your account 1 or 2 sol should be enough to test this indefinitely - i'd just make a special case for this or surround the airdrop rpc call with a try-catch and ignore if it errors
I'm trying to write a program that plays around with nfts minted from a specific wallet, anyone know of any code examples for testing something like this? I'm struggling with minting an nft to a wallet read in from a file locally in typescript
üëã  Any easy way to convert between spl u64 to number in typescript?
Hey all, I'm facing an error when testing my program on devnet:
```Error: 429 Too Many Requests:  {"jsonrpc":"2.0","error":{"code": 429, "message":"Too many requests for a specific RPC call, contact your app developer or support@rpcpool.com."}, "id": "c6d2ff37-a65a-4aee-9e96-1f480d007570" } ```

In the tests, I'm creating 2 accounts and trying to airdrop 1 SOL to one of them so it can pay rent. I think it may be erring here, as I'm doing this a total of 4 times. Would anyone know how to work around this?
When you use init on an AccountInfo type account, how do you close the account and return rent to some user? If I use the close=user argument, it says "close must be on an Account, ProgramAccount, or Loader"
ok, can you please tell me if the flow below is ok then?
Create check account:
- Inits an escrow_check of type Check account - stores data relevant to the transaction
- Inits a vault account of type AccountInfo - stores SOL transferred from a player
Cashes check:
Gets both escrow_check and vault as mutable accounts and uses same seeds and bump used in create check to get PDA. The error occurs here, when I am trying to transfer the SOL from vault account to another player.
1. When using JS, if I run both in sequence I'm able to succeed.
2. If there is a delay between them, then it says escrow_check is not initialized
Not sure then, but the above code should be fine‚Äîso I would check to make sure you're not doing something else wrong someplace else
hmm yes the first test case that inits this account passed the test
Are you sure the first tx actually succeeded?
still getting the same error
```.js
await program.provider.connection.confirmTransaction(
  await program.rpc.doSomething(...),
  "confirmed" // or "finalized" if you want
);
```
sorry what does that mean? Like wait longer for some connection?
Ok, might need to wait for more confirmation
from TS yes. Even from JS it says "account not initialized"
In JS you mean?
So I do set some variables in the escrow_check account. But when I try to access this account from another function, it says "account does not exist"
Nope, though if you don't set anything on the escrow_check account it will get initialized as all zeros
Hi All - When you use init in the account struct like so, ``` #[account(init, 
        seeds=[b"escrow-seed".as_ref()], 
        bump, 
        payer=from, 
        space = 8 + std::mem::size_of::<Check>()
    )]
    escrow_check: Account<'info, Check>,```
Do you need to specifically create an account in the function implementation?
Nothing, the first version is just the new/cooler/easier way
did you end up figuring this out?
üëã anyone have a snippet of code handy in reading/parsing IDL in typescript?
what's the difference between using the clock like this `Clock::get().unwrap()` vs passing it in as an account `pub clock: Sysvar<'info, Clock>,`


//////////////////////////////////////////////////////////////////////////////////////////

Hey , so i have been writing tests for testing the record program in Anchor. So I wrote a test to check for the initialization of the record account so im facing this error -

https://github.com/Anurag5086/record-anchor/blob/master/tests/record-anchor.ts

this is the test which i have written
Hey guys! Is it possible to write the typescript client code in javascript? Would there be any major issues?
https://github.com/project-serum/anchor/issues/1002
I tried creating it with just one instruction that had an `args` property in the object that gets created from idl.json of:
```
      "args": [
        {
          "name": "data",
          "type": {
            "defined": "AdminSettings"
          }
        }
      ]
```
and am getting:
```
Type '{ name: string; accounts: ({ name: string; isMut: boolean; isSigner: boolean; pda?: undefined; } | { name: string; isMut: boolean; isSigner: boolean; pda: { seeds: { kind: string; type: string; path: string; }[]; }; })[]; args: { ...; }[]; } | { ...; } | { ...; }' is not assignable to type 'IdlInstruction'.
  Type '{ name: string; accounts: ({ name: string; isMut: boolean; isSigner: boolean; pda?: undefined; } | { name: string; isMut: boolean; isSigner: boolean; pda: { seeds: { kind: string; type: string; path: string; }[]; }; })[]; args: { ...; }[]; }' is not assignable to type 'IdlInstruction'.
    Types of property 'args' are incompatible.
      Type '{ name: string; type: string; }[]' is not assignable to type 'IdlField[]'.
        Type '{ name: string; type: string; }' is not assignable to type 'IdlField'.
          Types of property 'type' are incompatible.
            Type 'string' is not assignable to type 'IdlType'
```
but if I look at `IdlType` it includes "string" as one of the allowable types.
so the signers can be an array then within any given instruction? crazy
```js
import idl from '../../target/idl/idl.json';
const program = new Program(idl, programID, provider);
```
is saying:
```
Argument of type '{ version: string; name: string; instructions: ({ name: string; accounts: ({ name: string; isMut: boolean; isSigner: boolean; pda?: undefined; } | { name: string; isMut: boolean; isSigner: boolean; pda: { ...; }; })[]; args: { ...; }[]; } | { ...; } | { ...; })[]; accounts: ({ ...; } | { ...; })[]; types: ({ ...; } ...' is not assignable to parameter of type 'Idl'.
  Types of property 'instructions' are incompatible.
    Type '({ name: string; accounts: ({ name: string; isMut: boolean; isSigner: boolean; pda?: undefined; } | { name: string; isMut: boolean; isSigner: boolean; pda: { seeds: { kind: string; type: string; path: string; }[]; }; })[]; args: { ...; }[]; } | { ...; } | { ...; })[]' is not assignable to type 'IdlInstruction[]'.
      Type '{ name: string; accounts: ({ name: string; isMut: boolean; isSigner: boolean; pda?: undefined; } | { name: string; isMut: boolean; isSigner: boolean; pda: { seeds: { kind: string; type: string; path: string; }[]; }; })[]; args: { ...; }[]; } | { ...; } | { ...; }' is not assignable to type 'IdlInstruction'.
        Type '{ name: string; accounts: ({ name: string; isMut: boolean; isSigner: boolean; pda?: undefined; } | { name: string; isMut: boolean; isSigner: boolean; pda: { seeds: { kind: string; type: string; path: string; }[]; }; })[]; args: { ...; }[]; }' is not assignable to type 'IdlInstruction'.
          Types of property 'args' are incompatible.
            Type '{ name: string; type: string; }[]' is not assignable to type 'IdlField[]'.
              Type '{ name: string; type: string; }' is not assignable to type 'IdlField'.
```
How do I read the idl.json into the Idl type?
I want to create a vault where users can deposit spl (farm / lp) tokens with the "claim" method which will harvest rewards and transfer them to the address / charities, can you recommend me some place/libs to start ?
no
like in ethereum
solana question: each transaction can only have 1 signing account right?
the tests folder in the anchor repo is your friend: https://github.com/project-serum/anchor/tree/master/tests
thx
You're gonna need to give the rust book a read probably: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html
ok, what does .unwrap() do, is like an evaluation?
It seems to be returning a Result, not an Instruction, so you probably need to add a `?` at the end, or an `.unwrap()` if you're lazy
Do you have your editor set up to give you type information like that?
Check what the actual return type is of that function call
Thanks!
yeah, I'm using anchor for some things too, still learning rust though
I've used some stuff from ```stable_swap_anchor```, it's probably easier to work with if you're using anchor üëç
Are you familiar with saber?
I'm gonna try that ^
I'm just trying to get a feel for solana/rust, using the saber library.
Right now I'm just trying to get a failing transaction calling pause() on it
you probably want to import 
```
use anchor_lang::{
    
    solana_program::instruction::{Instruction},
};
```
Then 
```
let ix = Instruction {
//program_id,
//accountstuff,
//data_stuff
};
```
I might be able to help out more if you tell me what you're actually trying to do with saber haha
quick question:
```
stable_swap::instruction::pause(
            &c.arber.pubkey(),
            &c.payer.pubkey(),
            )
```
I'm trying to use the above to generate an instruction to execute but I get this error:
```error[E0308]: mismatched types
  --> src/main.rs:43:11
   |
43 |           &[stable_swap::instruction::pause(
   |  ___________^
44 | |             &c.arber.pubkey(),
45 | |             &c.payer.pubkey(),
46 | |         )
   | |_________^ expected struct `Instruction`, found enum `Result`
   |
   = note: expected struct `Instruction`
                found enum `Result<Instruction, ProgramError>```
How do I get the instruction from the enum? I don't know enough rust lol.
learning by doing is probably the best way. Also look through other project's source code if they're public. Metaplex, Saber, marinade-finance for example
Hello everyone! I am new to solana and have some background with Rust. How would you recommend I get started with Anchor? I've checked out the Anchor Book but it seems limited in scope.
0xbbb
Think you want to use https://solana-labs.github.io/wallet-adapter/modules/_solana_wallet_adapter_react.html#useAnchorWallet instead
Thanks, trying to hook that up like:
```js
    const { wallet } = useWallet();

    async function getProvider(): Promise<Provider | null> {
        if (wallet) {
            const network = "http://127.0.0.1:8899";
            const connection = new Connection(network, "confirmed");

            const provider = new Provider(
                connection, wallet, opts.preflightCommitment,
            );
            return provider;
        } else {
            return null;
        }

    };
```
but getting
```
Argument of type 'import("").Wallet' is not assignable to parameter of type 'import("/home/caleb/projects/mediamarket/node_modules/@project-serum/anchor/dist/cjs/provider").Wallet'.
  Type 'Wallet' is missing the following properties from type 'Wallet': signTransaction, signAllTransactions, publicKey
```
i will give it a try. cheers <@!134416332509675520>
Another way is to keep using `program.rpc.doSomething` but also add in the `preInstructions: [...]` and/or `postInstructions: [...]` arguments to the call
You can start building a tx with `program.transaction.initializePool(...)` and then `.add(...)` other ixs to it
`const ix1 = program.instruction.initializePool(<...>)` etc.
anchor sends its transaction to rpc like this:
```
const tx = await program.rpc.initializePool(<‚Ä¶>)
const tx = await program.rpc.fundPool(<‚Ä¶>)
```
how to combine multiple transactions into one tx?
ü§†  seems working now. thank you <@!134416332509675520>
okay
Just put it anywhere else in the file, not in the program mod
And define that outside of the `#[program]` mod
We can't help unless you actually say what the issue is
```
#[program]
pub mod my_protocol {
    use super::*;
    fn get_price(pyth_account: AccountInfo) -> Result<u64> {
        let pyth_price_info = &pyth_account;
        let pyth_price_data = &pyth_price_info.try_borrow_data()?;
        let pyth_price = pyth_client::cast::<pyth_client::Price>(pyth_price_data);
        let dest_price = pyth_price.agg.price as u64;
        Ok(dest_price)
    }

    pub fn my_function(ctx: Context<MyFunction>) -> Result<()> {
        let price = get_price(ctx.accounts.pyth_btc_account);
    }    
```
I did like this but getting issue.
Yep, just define it üòõ
Is there any way to define one function that will be called a lot in one program?
late reply but https://www.youtube.com/watch?v=ZLp7M64_pTU&list=PLrYlwHDZuXW0qfPc26qTQQwrt-e9p5DQe&index=14
Is there any way to identify which type an account belongs to? Let's say I use one seed for type types of accounts. Is there a way for me to distinguish which of the two types it is?
useWallet() using the "@solana/wallet-adapter-react" is pretty good if you're using react
Helo. Is there any diffirence between transfer nft and normal spl token with anchor-spl?
When you want the deserialization use the later one
Can sb tell me when to AccountInfo<'info> or Account<'info, x>
yeah you need to pass all the account
how do you connect a phantom wallet to an anchor program?
Say for example, Instruction X in Program A calls Instruction Y in Program B which needs access to Account M. Do we have to pass Account M in the accounts list when calling Instruction X ?
Do we have to specify all the accounts that will be touched by a CPI as well ?
Yeah, original funder is irrelevant‚Äîas WrRaThy said, all that matters is who can sign for the vault's address (only your program)
given that it's a PDA - only the program can transfer from this account. nothing else needed
Check this tutorial https://hackmd.io/@ironaddicteddog/solana-anchor-escrow
Hi - I am trying to transfer SOL (not tokens) from a "from" player to a vault account (a PDA). I then distribute this SOL from the vault to other wallets. I have the program sign for this transaction since the vault is at a program derived address. Now does the original "from" player still have any control over this vault account (since he paid the rent and all)? Do I need to transfer authority of this vault account like we do for Tokens? I am under the impression that native solana works different from the tokens.
Does anyone know of an open source vault-like program I may reference? simple deposit in exchange for receipt token functionality
NVM:

I've been using spl transfer function from anchor all this time ü§¶ 

Just found this and it works!!

https://stackoverflow.com/a/70574227
space wise
Whats the largest you can initialise a program at
ive done:
```typescript
const {
  Connection,
  sendAndConfirmTransaction,
  Keypair,
  Transaction,
  SystemProgram,
  PublicKey,
  TransactionInstruction,
} = require("@solana/web3.js");
const connection = new Connection("https://api.devnet.solana.com/");
const feePayer = new Keypair();
await connection.requestAirdrop(feePayer.publicKey, 2e9);
```

to airdrop myself SOL in tests before
Does anybody have a link to a repo with anchor program, wallet adapter and react app as an example of a good development set up they could share?
hello! new user to anchor here. the below is part of my solana code for the tictactoe example in the anchor book.
```rust
  #[account]
  pub struct GameState {
      pub turn: u64,
      pub grid: [[Option<Sign>; 3]; 3],
      pub status: Status,
  }

  #[derive(
      AnchorSerialize, AnchorDeserialize, FromPrimitive, ToPrimitive, Copy, Clone, PartialEq, Eq,
  )]
  pub enum Sign {
      X = 0,
      O = 1,
  }
```

in my typescript tests, i access the GameState account. 

```typescript

        switch (JSON.stringify(s.grid[i][j])) {
          case "null":
            break;
          case "{\"x\":{}}": { // this looks ugly!
            console.log(`X at ${i},${j}`);
            break;
          }
          default: {
            console.log(`didn't handle ${JSON.stringify(s.grid[i][j])}`);
            break;
```
however I think {x: {}} is an ugly way of representing Sign::X. I'm also a typescript noob so maybe there's an easy way to interact with this data. Is there some way to keep using the Sign enum in rust, but have some nice conversion in typescript? eg Sign::X in rust somehow converts to 'X' in typescript
<@!134416332509675520>  How would we create a `SystemAccount` in tests ?

Right now just doing the following to create:

```
      const creatorsWalletKeypair = anchor.web3.Keypair.generate();
      let signature = await program.provider.connection.requestAirdrop(
        creatorsWalletKeypair.publicKey,
        1000000000 // 1 SOL ‚Äî or 1 billion lamports
      );
```

and getting this errror:

```
    Program log: Instruction: Transfer
    Program log: Error: InvalidAccountData
```
I see.
Sol isn't a token, it's just sol
No, that doesn't sound like it's a token account, just a `pub create_spl_account: SystemAccount<'info>`
<@!134416332509675520> could you please help with this ? Thanks
Great <@!134416332509675520> Thanks
Not quite, since that only passes in one address (so only one account). You can instead do `account.random.all()` or `account.random.fetchMultiple` though
If there is an account with the following structure:

```
#[account]
pub struct Random {
    pub user: Pubkey,
    pub creator: Pubkey,
    pub expire_timestamp: i64,
    pub bump: u8
}
```

Can we fetch multiple `Random`s (having same user) with `anchor.account.random.fetch(userPubKey)`?
is it possible to cpi create a mint without passing in generated keypair as a signer?
hey, i want to create vault where anyone can deposit spl token and withdraw it at any time and specific user can call contract func which will use deposited tokens to  claim rewards (collateral pay), im newbie in solana ecosystem so can someone give me some info where to start or what i can use to develop that ?
fantastic, thanks much !
There is this IDO example:  
https://github.com/project-serum/anchor/tree/e04f144e1208f359ff24273f968ae61ba39dfb25/tests/ido-pool
hello, is there any ICO code using anchor I can fork and take as a base?
So I guess my question is, is there a method like:
`anchor.sendTransaction(programID, accounts, data)`
You can clone executable programs on solana using validator.clone right?
But I just have a PublicKey that I want to send to
Normally I'd do this if its in my anchor workspace:   const program = anchor.workspace.StableTry as Program<StableTry>;
<@!134416332509675520>  any tutorial on sending a transaction to an already deployed contract? I'm cloning a contract using anchor test and want to send a single transaction to it from the terminal
Can I use structs with anchor?
I can use Box<xxx> apparently, to put the accounts on the heap, rather than the stack..


//////////////////////////////////////////////////////////////////////////////////////////

How init_if_needed check that the account already init? only the owner and lamport?
Is there any opensource staking program made using anchor or Solana, just wanted to see how is staking implemented on solana
‚ù§Ô∏è
thanks buddy; I will it give it a go
https://github.com/switchboard-xyz/vrf-cpi-example/blob/main/programs/anchor-example/src/actions/request_result.rs#L16 found it
oh ok
I used to see someone call .load()? directly in the constraints but not fully sure. I tried to find the example that I saw but not found anymore. Maybe you can try that
is it possible to access the data of `AccountLoader` while defining the accounts? Basically I would love to use some values from the underlying data to define some constraints

e.g.

```
pub struct Deposit<'info> {
  #[account(mut)]
  pub state: AccountLoader<'info, State>,
  
  #[account(
    constraint = treasury.owner == state.user
    constraint = treasury.mint == state.token
  )]
  pub treasury: Box<Account<'info, TokenAccount>>,
}
```
hey guys
`getOrCreateAssociatedTokenAccount` sends the full tx signed an all for u but u just want the unsigned tx which u get them to sign themselves
i think u have to interface with phantom or some other solana wallet and basically give them the tx and have them sign it
I have a program which sends out a new token to the person who calls the one function. Now Im writing the webapp and have to create the token account for the user or get the address of the already existing token account. I do this like this:
`const new_token_acc = await getOrCreateAssociatedTokenAccount(
            connection,
            signerAccount,
            mint_address,
            signerAccount.publicKey
          );`

The problem is, that signer Account needs to be the Keypair of the user who is connected with the webapp. I think nobody would use a wallet which gives Keypairs to websites they connect with so Im obviously doing something wrong. Could someone please tell me how can get/create the token account for the user who connected with the webapp?
`bump = token_vault_bump` just becomes `bump`
Turns out I was using an outdated anchor version and just needed to change my bump
```pub struct CreateMangoAccount<'info> {
    #[account(constraint = vault.manager == manager.key())]
    pub vault: Account<'info, Vault>,
    #[account(mut)]
    pub unverified_mango_owner_pda: AccountInfo<'info>, // needs to be here since mango needs a parsed accountinfo, but using find_program_address on-chain only gives a pubkey
    #[account(mut)]
    pub unverified_mango_account_pda: AccountInfo<'info>, // ^^ as above
    #[account(mut)]
    pub manager: Signer<'info>,
    pub mango_program_id: AccountInfo<'info>,
    #[account(mut)]
    pub mango_group_ai: AccountInfo<'info>,
    pub system_program: Program<'info, System>,
}```
How did your account constraint look?
Anyone ever gotten this before? `thread 'main' panicked at 'Code not parseable: Error("bump targets should not be provided with init. Please use bump without a target.")'`?
How to Fix TestScript error <@!134416332509675520>  <@!665112704553320473>
is there a way to print some message on lib.rs so it'll appear on terminal when we run anchor test?
Since often using them is a sign you're doing something dumb
You just need to add a `/// CHECK: here's why I'm not being dumb...` comment in order to use an AccountInfo or an UncheckedAccount
yes but did't understand.
Did you read that link?
Error: 
        Struct field "vault_token_account" is unsafe, but is not documented.
        Please add a `/// CHECK:` doc comment explaining why no checks through types are necessary.
        See https://book.anchor-lang.com/chapter_3/the_accounts_struct.html#safety-checks for more information.

What Does that mean? <@!134416332509675520>
ah gotcha. thanks for the link
And no, solana tx fees don't work that way anyway: https://jstarry.notion.site/Transaction-Fees-f09387e6a8d84287aa16a34ecb58e239
That's just rust code‚Äîyou're already inside an instruction, not doing an additional one etc.
i always though every ix costs some money
running this ix on chain
What would you be paying for though?
this
transfer_from_account_we_own
What's an instruction call?
What do you mean?
not a big deal just curious
understood, Also a follow up. When we do it the try_borrow_mut_lamport way. We pay for instruction call? or just txn cost
But the higher level solana point is that asking the sytem program to move money only works if the system program actually owns the source account
thanks
man you are godsend
Something like
```.rs
fn transfer_from_account_we_own(
    src: &mut AccountInfo, // we better own this account though
    dst: &mut AccountInfo,
    amount: u64,
) -> ProgramResult {
    **src.try_borrow_mut_lamports()? = src
        .lamports()
        .checked_sub(amount)
        .ok_or(ProgramError::InvalidArgument)?;
    **dst.try_borrow_mut_lamports()? = dst
        .lamports()
        .checked_add(amount)
        .ok_or(ProgramError::InvalidArgument)?;
    Ok(())
}
```
so every account made suing `#[account()]` is owned by my program
You need to use `.try_borrow_mut_lamports()` and move the money yourself
You can't use the system program to do that transfer, since it's *your* account, not the sytem program's
So if that account that lives at that PDA has data, it's presumably an account that's owned by your program (a struct with `#[account]` on top of it)
is there a way to make it work
https://discord.com/channels/889577356681945098/889577399308656662/949784094378700830
invoke_signed
sorry this
```amount_to_refund = quantity * price * (10^constants::PRICE_EXPONENT as u64);
            let ix = system_instruction::transfer(
                ctx.accounts.vault_account.to_account_info().key,
                ctx.accounts.trader.to_account_info().key,
                amount_to_refund,
            );
        
            invoke_signed(
                &ix,
                &[
                    ctx.accounts.vault_account.to_account_info(),
                    ctx.accounts.trader.to_account_info(),
                    ctx.accounts.system_program.to_account_info(),
                ],
                &[&vault_seeds]

            )?;```
```let ix = system_instruction::transfer(
                ctx.accounts.vault_account.to_account_info().key,
                ctx.accounts.trader.to_account_info().key,
                amount_to_refund,
            );
        
            invoke(
                &ix,
                &[
                    ctx.accounts.vault_account.to_account_info(),
                    ctx.accounts.trader.to_account_info(),
                    ctx.accounts.system_program.to_account_info(),
                ],
            )?;```
A noob issue. Trying to transfer sol from PDA to user wallet in Rust on chain program.
Running intoo 'from' must not carry data.
Make sure your anchor-lang and anchor-spl dependencies use the exact same version
the trait bound `anchor_spl::token::MintTo<'info>: anchor_lang::ToAccountMetas` is not satisfied
   --> programs/DstageNFT/src/lib.rs:167:30
    |
167 |     pub fn mint_to(&self) -> CpiContext<'_, '_, '_, 'info, MintTo<'info>> {
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `anchor_lang::ToAccountMetas` is not implemented for `anchor_spl::token::MintTo<'info>`

<@!134416332509675520> Help Please
No, anchor doesn't support that directly‚Äîyou'll need to use the `remaining_accounts` feature (try searching the anchor repo for examples)
Ok I get it that i need to "pass it in as an account". So if i wanna pass in a  Vec <AcountInfo> / or basically a variable  number of AccountInfos, i will need to then put that  Vec<AccountInfo>  as one of the data items in my account context
0.2.0
What version does your yarn.lock say you're using?
Oh, but actually you ought to be able to import that
The newest version changed their APIs a bit
I had the `TypeError: fields must be array of Layout instances` Error so I cleared node_modules and reinstalled everything with yarn. Now Im getting this and Im super confused. Neither `getOrCreateAssociatedTokenAccount `nor `getOrCreateAssociatedAccountInfo `can be found in @solana/spl-token. Any Idead what im doing wrong?
Right, can't do it that way, you need to "pass it as an account" (in the `Participate` context thing, like the other accounts you pass there)
Hi , when i try to pass in a  <AccountInfo> as one of the instruction parameters, i get a program macro error, how do i pass in an AccountInfo?

`pub fn participate(ctx: Context<Participate>, stake: u64, lucky_num: u8, test:<AccountInfo>) -> ProgramResult {`
You have to add that as a dependency to your Cargo.toml
use anchor_spl::token::{
  |     ^^^^^^^^^^ use of undeclared crate or module `anchor_spl`
need solution?
`the_account_info.key`
hello how do i get the account address from an accountInfo?
oooo thanks. devnet is on v1.9.9 which includes the per tx limit right? would make sense why my txs are hitting a limit on localnet and devnet
Interestingly, it's currently per ix but the overall limit will soon be per tx: https://jstarry.notion.site/Transaction-Fees-f09387e6a8d84287aa16a34ecb58e239#67aeb39d8b2540019cb37792c6a2cd32
noob q: is there a limit of 200,000 compute units per tx or is it per ix?
You'd have to just verify in the program that the threshold has indeed been reached
Yeah, can't do that kind of dynamic account lookup in your program
So I guess the only way is fetch the PDA, check if the number of participant has reach the threshold. If yes, call the program and pass all accountInfo in? There's no getAccountInfo equivalent on Solana program right?
dmed my git repo since it has my irl name
Sure
would it be okay if i just posted my whole code? its simple but long
Yep. Can you post your `pub fn` instruction's signature too?
my point was the authority is the treasury account, which is a pda, since we're trying to sign with this pda, we need the seeds for the authority
thats the instruction thats messing up
```anchor_spl::token::mint_to(
                CpiContext::new_with_signer(
                    ctx.accounts.token_program.to_account_info(),
                    anchor_spl::token::MintTo {
                        mint: core_mint.to_account_info(),
                        to: core_deposit_wallet.to_account_info(),
                        authority: treasury.to_account_info(),
                    },
                    // &[&[b"core_mint".as_ref(), treasury.key().as_ref()]],
                    &[&[
                        b"treasury_account".as_ref(),
                        creator.key.as_ref(),
                        treasury.name.as_ref(),
                        &[treasury_bump],
                    ]],
                ),
                1,
            )?;
```
thats my contexts

At any rate, you need to know a PDA's bump in order to sign for it, e.g. here: https://github.com/cqfd/anchor-token-studies/blob/main/programs/token-studies/src/lib.rs#L22
Can you post some code? Not sure which situation you mean
okay i have been doing ,bump actually, but  should i be checking the mint bump or the authority bump for the actual signature?
(But you need to know the bump somehow in order to sign for that address, which is necessary here to init the mint)
(That's the old-school way, new-school is to just skip that part entirely and do `bump,`)
https://github.com/cqfd/anchor-token-studies/blob/main/programs/token-studies/src/lib.rs#L85
just to make sure, the bump i'm checking is the mint authority for the mint_to ix, so the treasury pda?
um i didn't realize we were every supposed to pass in the actual bump, just the seeds
Are you using the `#[instruction(...)]` macro to do that? (But yeah, just try doing `bump,` instead, that's actually how anchor now does things anyway)
I'm saying that on the client, you're apparently not passing the bump correctly to the rust side
Ah, yeah
but we're just checking the signature here not calculating a bump seed
well pdas are usually derived by decrementing the bump seed from 255 till its off the curve
What do you mean by not deriving a pda here?
ahhhh yeah ik how pdas are derived, but since we're not deriving a pda here, if the first bump doesn't work, it would be on the curve got it
So double check you're actually passing in that bump correctly (or do the lazy thing and just say `bump,`, no equals sign)
So sometimes you'll actually get lucky and produce an off-curve (but maybe incorrect) address, and sometimes it won't produce an off-curve address at all
Right, the way that can happen is kind of interesting‚Äîeach choice of bump has a 50/50 chance of working for a given choice of seeds
yeah that makes sense, but i was extremely lost when i was getting different errors when I didn't even modify the code
The second stack trace also means you're using the wrong bump, but this time it happens to be a "valid" bump, in that the resulting address is "off curve", but the resulting address doesn't match the actual PDA address you're trying to use
That first stack trace means that the bump you're trying to use is wrong, in the sense that it doesn't actually work as a bump‚Äîthe resulting address is "on the curve".
and i'm trying to run your old https://github.com/cqfd/anchor-token-studies/blob/main/programs/token-studies/src/lib.rs, but theres a bunch of errors like missing msg! logs amoung others, wondering if you ever ran into that
hey <@!134416332509675520> wanted to bump my question if you had time
Thanks a lot greatly appreciate it
```.rs
let ix = Instruction {
  program_id: c::id(),
  accounts: accounts,
  data: that_instruction_thing.data()
}
```
Thank you so much
1 sec, finding an example
What would you recommend to fix this.
Ah, ok, that isn't quite right‚Äîthat won't do anchor's "sighash" stuff correctly.
I am currently using this to this  
```let ix = Instruction::new_with_borsh(
        c::id(),
         &c::instruction::MyInstruction {
            _req_bump: req_bump,
            amount,
            a_bump,
            b_bump,
        },
        accounts,
    );
```
Well I do not but at the moment I am figuring out the problem.
How do I serialize the instruction that I think is the problem that is why its falling back to this
You ordinarily shouldn't need to do that‚Äîdo you deliberately want to have a catch-all fallback function like that?
That's unfortunately the only way to do it (storing the Pubkey). You'll then need to pass that account in from the client when you eventually want to use it as an AccountInfo.
Hi Thanks but this issue was solved by implementing a fallback i.e a function that takes raw entry poing args.
```rust
  pub fn fallback<'info>(
        program_id: &Pubkey,
        accounts: &[AccountInfo<'info>],
        data: &[u8],
    ) -> Result<()> {
        Ok(())
    }
```
something like this.
Hi! Is there a way to store accountInfo? I'm creating an escrow that include multiple accounts. The escrow will execute transfer once it reaching a certain number of account. For transfer we need the accountInfo, I'm currently storing only the address pubkey. How should I go about this?
is it possible to init an account and an ata for it with a single context?
```
#[account(mut)]
seller: Signer<'info>,
#[account(init, payer = seller, space=Order::LEN, seeds = [utils::ORDER_PREFIX.as_ref(), 
marketplace.order_count.to_le_bytes().as_ref()], bump)]
order: Account<'info, Order>,
#[account(init, payer = seller, associated_token::mint = nft_mint, associated_token::authority = order)]
order_nft_account: Account<'info, TokenAccount>,
```
make sure that you didn't call to the wrong program id. if not I'm sorry I dont know either
well I can see the instruction generated in the crate
maybe you call to not exist function
Hi is it possible to write tests in rust and while doing so I have come accross this error any way I could solve this?
finally, weirdly enough i keep getting two different stack traces, really not sure what to make of this
```anchor_spl::token::mint_to(
                CpiContext::new_with_signer(
                    ctx.accounts.token_program.to_account_info(),
                    anchor_spl::token::MintTo {
                        mint: core_mint.to_account_info(),
                        to: core_deposit_wallet.to_account_info(),
                        authority: treasury.to_account_info(),
                    },
                    // &[&[b"core_mint".as_ref(), treasury.key().as_ref()]],
                    &[&[
                        b"treasury_account".as_ref(),
                        creator.key.as_ref(),
                        treasury.name.as_ref(),
                    ]],
                ),
                1,
            )?;
```
where the seeds are supposed to be the signature for treasury (which is a pda), and thats how the treasury was inited to begin with
this is the cpi i'm trying to do:
this is my context struct

```#[account(init, payer = creator, seeds = [b"core_mint".as_ref(), treasury_account.key().as_ref()], bump, mint::decimals = 1, mint::authority = treasury_account.key(), mint::freeze_authority = treasury_account) ]
    pub core_mint: Account<'info, Mint>,```
man i've been stuck on getting my signature right for minting, and turns out this contraint fails?

```assert!(core_mint.mint_authority == COption::Some(*treasury_account.key));```
what's the syntax for skipping preflight?
Yeah I was looking at its implementation
```
(method) PublicKey.findProgramAddress(seeds: (Buffer | Uint8Array)[], programId: anchor.web3.PublicKey): Promise<[anchor.web3.PublicKey, number]>
```
And I wanted to respectively use the bump that is returned from this function as unique ids since it is a number. For example, every new unique user that interacts with my program will have a unique number associated to them.
dont quite understand your use case but it is reasonable to assume that different inputs to the `findProgramAddress` will return different outputs (it's a hash function under the hood).
Hey I have a quick question, is it safe to assume that all users will have a different program derived address when I use the findProgramAddress function? I am generating a list of users by id and was wondering if I could do that by using the findProgramAddress function and passing it by the user's publickey.

hi, in rust i have a enum, 
enum ActivityTypeEnum{
Airdrop,
BoxNormal,
..
}

//my pda account
pub struct activity{
header: ActivityTypeEnum
}

in ts side how to parse the value,
    {
      "name": "ActivityTypeEnum",
      "type": {
        "kind": "enum",
        "variants": [
          {
            "name": "Airdrop"
          },
          {
            "name": "BoxNormal"
          },
          {
            "name": "BoxEssence"
          }
        ]
      }
    },

const mp = await program.account.activity.fetch(activity);
const myenum = mp.header.ActivityTypeEnum ? this is not work, any help with much thanks?
Just `anchor build`?
How do you generate a new idl file?
Hi, if your able to would you be able to tell me how you achieved what you are explaining here? I'm trying to make something similar to this
#[account(init, payer = voting_owner, seeds = [
        b"voter_votes",
        voter_pubkey.as_ref(),
        voting_state.as_ref().key.as_ref(),
    ], bump = _voter_votes_bump_seed)]
Why need to put user's pubkey in the seeds. I know that seed + bump is PDA but will it affect anything if seed has user's pubkey inside ? Eg: #[account(init, payer = voting_owner, seeds = [
        b"voter_votes",
        voter_pubkey.as_ref(),
        voting_state.as_ref().key.as_ref(),
    ]
option takes up one byte https://borsh.io/ see the specification
https://doc.rust-lang.org/std/option/
Someone correct me if I'm wrong, but `Option<>` is a Rust idiom to basically say "this can be null"
does wrapping a pubkey in Option<> increase the space to store it?
What does account initialization mean?
Hey guys quick noob question, what does it mean when I'm getting this: `anchorpy.error.ProgramError: 3012: The program expected this account to be already initialized`?
yes, this is exactly what i was looking for! thank you üôÇ
I was on the same mission yesterday:
```js
import idl from '../../target/idl/idl.json';

const programID = new PublicKey("3Ee8Sx8cP4b91Sf7nyGWHDpfwxKB6Mv3e1KTAozwHXjF");
const confirmOptions: ConfirmOptions = {
    skipPreflight: false,
    commitment: "confirmed",
    preflightCommitment: "processed",
    maxRetries: 10
};

//https://dev.to/edge-and-node/the-complete-guide-to-full-stack-solana-development-with-react-anchor-rust-and-phantom-3291
//https://docs.phantom.app/integrating/displaying-your-app

export const App: FC = () => {
    return (
        <Theme>
            <Wallet>
                <Content />
            </Wallet>
        </Theme>
    );
};

export const Content: FC = () => {
    console.log(idl);

    const wallet = useAnchorWallet();

    async function getProvider(): Promise<Provider | null> {
        if (wallet) {
            const network = "http://127.0.0.1:8899";
            const connection = new Connection(network, confirmOptions);
            const provider = new Provider(
                connection, wallet, confirmOptions,
            );
            return provider;
        } else {
            return null;
        }
    };

    async function createGroup() {
        const provider = await getProvider()
        // @ts-ignore
        const program = new Program(idl, programID, provider);
        await program.methods.createGroup().accounts().rpc();
...
```
React.js or react.tsx which is better for anchor?
I want to write a webapp for a program i wrote but i struggle a bit with the client (never did webdev/ts/js before). 
`// Read the generated IDL.
const idl = JSON.parse(
  require("fs").readFileSync("./target/idl/basic_0.json", "utf8")
);`
This doesent work for the website because i cant use "fs" nor load local files.
Im now looking to create a ts client which i can use for my webapp. The book says this:
> The anchor typescript client can automatically parse this IDL and generate functions based on it. What this means is that each anchor program gets its own typescript client for free!

Could someone please tell me how i can get my ts client for my program?
I read somewhere that we cant create a nft by using a wrapper over candy machine program, but  we can in our own custom program directly Interact with the metaplex program and spl programs to create nfts, is there any example of this done on anchor ?, Create nft in an anchor program, a simple one, just to get a grasp o. How it all works.
Something like this? https://github.com/Arrowana/anchor-scaffold
Hi there! I am trying to start my project but when I wrote "anchor in it <project>" it throws me this message. I have Ubuntu (KDE neon) and node v17. 7.0. Thanks for the help
Hey is there an anchor react template that I can clone from GitHub? Spent many hours today trying to initialize an anchor provider from react and no luck üò¶
It was devnet before but I changed it to run it on localnet on this branch. And I am able to run tests on my local machine. Or maybe I am missing something ??
In this branch it is localnet: https://github.com/MikaelCarpenter/NFT-Club/tree/subscription
I don't think so, based on your Anchor.toml
Actually it is localnet
(I can't actually run your tests because of this)
Are you actually using fresh addresses each time?
Oh, you're running your tests on devnet?
And here is the subscription program: https://github.com/MikaelCarpenter/NFT-Club/blob/subscription/programs/nft-club/src/components/subscription.rs
Specifically talking about subscription tests: https://github.com/MikaelCarpenter/NFT-Club/blob/subscription/tests/subscription.ts
Here it is
https://github.com/MikaelCarpenter/NFT-Club/tree/subscription
Oh my bad: sure I will send.
Not enough code above to tell what's going wrong
I can't really help any more unless you send me a full github repo, sorry!
`CreateSubscription` has the following validator
```
    #[account(
        init, 
        // seeded with creatorPubKey + userPubKey + "subscription"
        seeds = [creator.key().as_ref(), user.key().as_ref(), b"subscription".as_ref()], 
        bump, 
        payer = user, 
        space = Subscription::LEN
    )]
    pub subscription: Account<'info, Subscription>,
```

And `UpdateSubscription`, this one:

```
#[account(seeds = [creator.key().as_ref(), user.key().as_ref(), b"subscription".as_ref()], bump)]
pub subscription: Account<'info, Subscription>,
```

First create is called and then update is called with the same pubkey
Not sure, but yeah, that's what that error means‚Äîyou'll just have to look through what your code is doing
This is how it is being run  in a tests file
```
      txn.add(
        program.instruction.createSubscription({
          accounts: {
            subscription: subscriptionPubKey,
            creator: creatorPubKey,
            creatorSolAccount: creatorsWalletKeypair.publicKey,
            user: userPubKey,
            systemProgram: anchor.web3.SystemProgram.programId,
            tokenProgram: TOKEN_PROGRAM_ID,
          },
          signers: [usersWalletKeypair],
        })
      );

      txn.add(
        program.instruction.updateSubscription({
          accounts: {
            subscription: subscriptionPubKey,
            creator: creatorPubKey,
            creatorSolAccount: creatorsWalletKeypair.publicKey,
            user: userPubKey,
            systemProgram: anchor.web3.SystemProgram.programId,
            tokenProgram: TOKEN_PROGRAM_ID,
          },
          signers: [usersWalletKeypair],
        })
      );
```
That's the only thing that that error means
Are you sure you aren't accidentally init'ing it somewhere else?
That's fine
But actually it is not init
```
#[account(seeds = [creator.key().as_ref(), user.key().as_ref(), b"subscription".as_ref()], bump)]
```

Is this also supposed to return the error ?
It means there's already an account there, but you're apparently trying to `init` another one
What does the error: `Allocate: account Address { address: B84QasHcaN4rz65sYm4myKDx4LvyTTFNijwhogYpK95B, base: None } already in use` mean ?
at the moment I'm just using a new arbitrary keypair in each thread since for rpc account requests it doesn't seem to matter
Sorry, misunderstood that
Ohhh
I can't send an Rc to a different thread at all, nor an AnchorClient for that reason
okay header now needs to be #[error_code] (in 0.21) as opposed to #[error] in prev versions (till 0.19)
how did you get it to compile? I'm still getting the "cannot find attribute `error` in this scope" when i try to compile
Can you just do
```.rs
let payer = Rc::new(payerKeypair);
let payer2 = payer.clone();
let payer3 = payer.clone();
```
(and doesn't seem to be clone on the secrets e.g.)
I'm trying to parallelize some RPC calls, but I'm having difficulty sharing the payer Keypair, which is Rc in the anchor client constructor


//////////////////////////////////////////////////////////////////////////////////////////

Weirdly even swapping for absolute path of run-integ-tests.sh doesn't work
<@!134416332509675520> Thanks for the link, I will continue to test and reseach on this topic maybe I missed something
Anchor isn't doing anything but pass those filters along to solana
According to the solana docs, they ought to already be ANDed together: https://docs.solana.com/developing/clients/jsonrpc-api#parameters-26
I'd like to have all account that match both `memcmp`
Hi, I'd like to apply to `memcmp` filter in `AND` logic like
I've tested this, but I have an `OR` logic like
```typescript
  const data = await program.account.proposalAccount.all([
    {
      memcmp: {
        offset: ProposalAccountOffset.Slug,
        bytes: stringToBytes(input),
      },
    },
    {
      memcmp: {
        offset: ProposalAccountOffset.State,
        bytes: proposalStateEtoBytes(ProposalStateE.funded),
      },
    },
  ]);
```
Mm, think something must be odd about the directory structure, etc. That error means that the shell can't find that executable
yep its there
Do you definitely have that `./scripts/run-integ-tests.sh` file?
```Failed to run test: ./scripts/run-integ-tests.sh: No such file or directory (os error 2)``` any idea on this error, also i have installed mocha globally?
anchor-cli is just released recently
May it an error of anchor-cli or solana-cli
invalid blockhash, interesting
Im using anchor-cli 0.22.0, solana-cli 1.9.13
This is another message

that still not enough?
I airdroped like 5 sol in my wallet
Get more balance then run the write buffer command it gave you
I've gotten this before when I didn't have enough balance in my wallet. You need 2x the rent cost b/c of the intermediate buffer cost.
and sol in my wallet decreased üò¶
I got this error when deploying my program to devnet, What does it mean üò¶
In my program, i have an account and an enhanced account (stores account + extra info). Is there a way to set the context struct to support either one of these, or do I need to make two different context structs?
we need only to run "anchor deploy" to update a smart contract right?
#[derive(Default)]

<@!134416332509675520>  what does mean that?
Can I throttle it its just for testing
This often happens when you ask for too many airdrops of SOL üôÇ
Hi. again I am trying to run tests on devnet . I get `Server responded with 429 Too Many Requests.  Retrying after 500ms delay...` anyway to solve this without storing keys locally?
Thanks figured it out appreciate the help üôå
You can configure that in Anchor.toml
Maybe push your program to devnet to check whether it's a local-only issue
found it but wouldn't help I think
I'm not sure how that command works
I am writing tests in rust and using solana-program-test
how to do that sorry
no i have not
My first guess is that the chain is not in the state your program expects. If you're testing locally, have you reset your validator?
so only one instruction creates the pda in the whole program so how might I fix this?
Sounds reasonable
Well I am not doing explicitly at least it a pda being init by the program?
It seems like you're trying to set the size of an account that already exists, which isn't allowed
Hi. Any info on `Account data resizing not supported yet: 0 -> 232. Consider making this test conditional on `#[cfg(feature = "test-bpf")]` solving this error?
Technically, you are better than me haha ! Im a perfect newbie. So you are not a newbie anymore
Thanks for kind words. üòä
No problem ! Some here are big boss ! You will be too one day üòä
IDK, I'm a pretty newbie here. haha.
If you know how üëÄ Why not ü•≤
No gem farm allowed üòÇ
Damn that perfect ! I have 1 of my 4 program now haha ‚ù§Ô∏è

Others are :
- Stake NFT (multi staking, with multiple GEN and $COIN reward and lock time)
- Inject liquidity pair in a pool $COIN/USDC for have a second token
- Stake the second token for being rewarded with the first token
Oh. And Token program is callable with Anchor. I got it. But, I see in the example about the need of create a swap pool ??? But we already have a pool for create the DEX $COIN/USDC. Did I missed something ?
I recommend you to check this repository out https://github.com/project-serum/anchor, especially `tests` directory.
Yes, the smart contract is just the on-chain program typically written in Rust. To swap tokens, you could invoke the Token Swap Program from your own code. https://spl.solana.com/token-swap
Hi ! I have a noob question‚Ä¶

A Smart Contract is only the RUST part?  Or are the algorithms in Web3 also considered as Smart Contract?  I ask this question because I was told that it was possible to do a token exchange ($COIN <-> UDSC for example) with a Smart Contract.  But I don't see how Rust/Anchor can do that ü§î
Found an example. This project has some custom client-side code that uses the oracle's idl
https://github.com/Synthetify/synthetify-protocol/blob/master/tests/oracleUtils.ts
are there any tools to help visualize accounts ?
How would you test oracle-dependent code locally? That is, how would you mock an oracle?
is there alternative to set local connection??
OK, it seems a more complicated issue than I thought.
is there better way to do this ```const provider = anchor.Provider.local();
```
i dont want to fix it on my webpack side
nah its anchor issue
I think it is about the node.js issue. 
Check to install Node.js well out and its related packages.
I recommend you re-installing the Node.js framework.
After that, delete the `node_modules` directory in your project directory and run the command `npm install` or `yarn` to install the related packages.
I need solution for that?
but i cant use it with vue
provider uses fs module in anchor
<@!943367070702243862>
Could you show the error messages?
Thanks a lot! 
You are saving my time again. 
It was because of the `#[account(mut)]`'. üòÖ
hi, how can i fix the fs module error that Im getting while using provider local for anchor in the client side ?
If you look at the full program log you'll see a line about so-and-so's writable privilege escalated
Error message is a little confusing, but you need to mark the `mint` as `#[account(mut)]` (the mint keeps track of its total extant supply, so burning tokens requires mutating the mint)
Can I get some advice on token transferring and burning in Anchor?

These two code block exists in the same function. 
The transfer is working, but the burn is not working.

What am I missing?

Do I need to sign to create CpiContext even I passed the token owner's account?

The transfering block is below:
```
let cpi_accounts = Transfer {
    from: ctx.accounts.user_token.to_account_info().clone(),
    to: ctx.accounts.token_acc.to_account_info().clone(),
    authority: ctx.accounts.authority.to_account_info().clone(),
};
let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
transfer(cpi_ctx, status.fee)?;
```

The burn block is below:
```
let cpi_accounts = Burn {
    mint: ctx.accounts.token_mint.to_account_info(),
    to: ctx.accounts.user_token.to_account_info(),
    authority: ctx.accounts.authority.to_account_info(),
};
let cpi_program = ctx.accounts.token_program.to_account_info();
let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
burn(cpi_ctx, amount)?;
```

The struct is below:
```
#[derive(Accounts)]
pub struct Swap<'info> {
    #[account(mut, constraint = user_token.owner == authority.key())]
    user_token: Account<'info, TokenAccount>,
    #[account(mut, constraint = user_token.mint == token_acc.mint)]
    token_acc: Account<'info, TokenAccount>,
    token_mint: Box<Account<'info, Mint>>,
    #[account(mut)]
    status: Account<'info, Status>,
    token_program: Program<'info, Token>,
    authority: Signer<'info>,
}
```

The Error message is below:
```
Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account
```
Thanks that seemed to fix it
Ill try that
This is the accounts I'm trying to init
So probably you need both: `signers: [lotteryAccount, vaultAccount]`
Their addresses (keypairs, really) need to sign
Which accounts are you initializing here?
That means you need to sign with something else
Seem to still be getting this error after removing the signers array
Right that makes sense
In general the `signers` array has to hold keypairs, not public keys (you need the actual private key to be able to sign‚Äîthe public half isn't enough)
You actually don't need that `signers` array at all here (the `provider.wallet` signs no matter what since it pays the tx fees)

Does anyone have any idea how to fix this issue? I'm passing the wallet pubkey from react into the signer which should be right
Cool! Yeah, the multisig program is definitely instructional to read
got it! thanks for clearing this all up
So no, I mean the token program exposes a way to do that‚Äîthe multisig program exposes a way to run any tx, but that tx needs to then go ask some other program/programs to do things they already know how to do
It's completely generic over what tx you want to do
All the multisig program does is just `invoke_signed` whatever transaction you want to run, it can be anything at all: https://github.com/project-serum/multisig/blob/master/programs/multisig/src/lib.rs#L186
"if you want to send a tx to mint some tokens, you can do that, because the token program exposes a way to do that" - do you mean the *multisig* program exposes a way to do that?
(But if it did have a `pub fn rescue_trapped_multisig_sol`, then you could)
I guess the way I'd phrase that is that if you want to send a tx to mint some tokens, you can do that, because the token program exposes a way to do that. But if you want to rescue that sol, the multisig program just doesn't provide that functionality‚Äîso doesn't matter what tx you send it to execute, it just doesn't have any way to do what you want it to do
Understood - so basically a txn for sending SOL needs making changes to data *inside* the account which is not possible. But a txn for minting tokens from the multisig, is possible directly from the existing code
At any rate, there just isn't any transaction you could submit that could rescue that sol, since the multisig program just doesn't provide an instruction to do it.
(Though in principle one could be added‚Äîthen you could rescue that sol)
And the multisig program just doesn't provide an instruction to do that.
The issue is that in solana, every account has a program owner, and only that program can decrement the account's sol or mutate its data‚Äîno other program has those rights. In this case, the multisig account (the one with the multisig data in it, that struct I linked above) is owned by the multisig program itself, so *only* the multisig program itself can decrement those lamports.
just one clarification - if the multisig code can enable any transaction through it then why can it not enable sending SOL held in the multisig account? (just trying to figure what makes this txn different)
Sweet big thanks for the help
thank you <@!134416332509675520>
its just this... sleep is important my friends
ctx.accounts.escrow_account.initializer_receive_token_account = *ctx.accounts.initializer_receive_token_account.to_account_info().key;
omg I am so dumb
That sets the `initializer_receive_token_account` variable (of type `Pubkey`) on the escrow_account struct
Yeah, it could even just be a `pub vault: SystemAccount<'info>`
Hey guys
Does somebody know what the following does exactly:
```
 ctx.accounts
            .escrow_account
            .initializer_receive_token_account = *ctx
            .accounts
            .initializer_receive_token_account
            .to_account_info()
            .key;
```
https://github.com/ironaddicteddog/anchor-escrow/blob/master/programs/anchor-escrow/src/lib.rs
its from this
I see, tysm! very helpful
Ok sweet thanks, can I just define the vault account as a regular account within the program then?
Assuming the source of the sol is the user's wallet etc.
You'd instead (probably, depends) use the system_instruction::transfer instruction to do the transfer
No, vanilla sol isn't a token at all, so no need for token accounts or mints of any kind
So Ive just been creating the account like this, because I want to transfer sol to the vault account by user, however is the mint parameter necessary if its just sol?
You can execute whatever kind of transaction you want
No, that's what the transaction stuff is for
Also, I'm actually looking to use the serum multisig code to make the multisig a mint_authority for a token. I'm guessing that I would have to write custom instructions in the existing code to enable minting from the multisig address?
No, I put it in the multisig account only. And I get what you're saying - the current multisig does not have an instruction to transfer SOL and hence the sol I sent to it is locked in that account forever
How do you want to do it? In your rust program? Via the cli, etc.?
What would be the process of transfering then in that case?
None, sol isn't a token actually, it's just sol
Say I want to transfer sol from one account to a PDA, what mint address would I use?
What is the address of the account like?
Or, wait, do mean you've put the sol in the multisig signer PDA?
But let me double check
So, assuming I'm reading the program right, that sol is locked in that multisig account forever-ish
The multisig program would need to provide an instruction for moving sol out of the multisig account (or closing it, etc.), but I don't see that it has one
I'm not super familiar with the serum multisig but I'm actually not sure that's possible‚Äîgenerally it's not a good idea to send sol to an account owned by a totally different program (rather than to a regular wallet account, owned by the system program)
yes, and i want to send the SOL from the multisig account to some other account
So the sol is in the multisig account itself? This thing? https://github.com/project-serum/multisig/blob/master/programs/multisig/src/lib.rs#L245
Hi, this is related to serum_multisig:
I'm trying to move SOL held in my multisig account by creating a transaction using the create_transaction method in the multisig code. However, I feel that create_transaction only allows to create transactions for methods that are already written in the serum_multisig program (for eg set_owners). Can someone confirm if I need to write a new method to the original serum_multisig code for transferring SOL?
Got this error when calling my Anchor program (which works fine when I use `anchor test`) from a React app. Any idea what this error means? Does it have to do with passing a BN into an instruction?
Also this? `InvalidRentPayingAccount`
I get this error? any ideas how to solve this.
HI. `Account data resizing not supported yet: 0 -> 232`
i have a question regarding seeds for PDA gen...
this works fine: 
```seeds = [b"123456", user.key().as_ref()],```
and then when using a string with the same valu from instruction args like this: 
``` seeds = [&block_id_string.as_bytes(), user.key().as_ref()],```
I get the error:
```Program failed to complete: Could not create program address with signer seeds: Length of the seed is too long for address generation```

although the string passed in instruction args, block_id_string = "123456"

i have an issue here:
https://github.com/project-serum/anchor/issues/1641


//////////////////////////////////////////////////////////////////////////////////////////

when anchor init's accounts, does it make them rent-exempt? 
in other words, does the init transaction include an instruction to send as much SOL to that account, as would be needed to make it rent-exempt?
"That" being this
<@!254789293267091458> Magic! That did the trick for me, thank you üôÇ
oops thanks
https://discord.com/channels/889577356681945098/889606719829835816/954754995985727578
GM folks. I am working on a project which uses anchor v0.13.2.. could anyone point me to where I can find anchor docs of that version?
How can I get spl token's decimals with @solana/spl-token?
yes, that was it - doing `use myanchorprogram::*` was messing it up. Just `myanchorprogram::id` without importing anything did the trick - üëç
Oh, just do `myanchorprogram::ID`, not `myanchorprogram::myanchorprogram::ID` etc.?
Hmm, weird, those are ostensibly both `pub` in the anchor macro source, not actually sure why they would end up being private
still saying private static - I found an example here to reverse engineer https://github.com/metaplex-foundation/metaplex-program-library/tree/master/auction-house/program
Just do `myanchorprogram::ID` instead maybe
I was trying to set up bpf tests in rust, but getting private function errors:
```rust
ProgramTest::new("myanchorprogram", myanchorprogram::myanchorprogram::id(), None)
```
```
error[E0603]: function `id` is private
  --> programs/myanchorprogram/tests/myanchorprogram.rs:5:63
   |
5  |     ProgramTest::new("myanchorprogram", myanchorprogram::myanchorprogram::id(), None)
   |                                                                           ^^ private function
```
So, it was zero because you were grabbing the first 8 bytes of that u64 which were probably all zeros
The arguments have to appear in the same order as in the function, but you can omit args after those that you need. So, should put all bumps and args used first and then any others
Hmm isee. Thank you.
No, instruction arguments all use borsh
Does anchor support that automatically or ?
Can I implement zero copy instead of clone for that ?
So sure will do that. Thank you so much.
Oh makes sense. Gotcha
But yeah, maybe being able to pass an account struct ought to work too
Try doing
```.rs
#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub struct YourArgument {
  name: String,
  foo: u8
}
```
It can, but not an account struct
So, its instruction doesn't take struct as its parameter ??
üëç
Thank you for your time brah
that would be lot easier. If you could do something like that tbh
It was my mistake, i was passing config as a parameter in the instruction... ü§ï I fixed it.
Oh sure. Just give me some time.
If there's an actual bug here anchor would like to know about it/fix it
No, the whole project
For idl ?
Can you just send me your code in a github link or whatever?
Coz I've other struct type build the same way. And they r working perfectly fine ..
Just doesn't work on the client side ...
And gives me new idl
It rebuilds fine
I wouldn't need that at this stage ... haha
Assume that this will have a simple explanation, it will make debugging easier.
What happens if you add it back and rebuild etc.?
Dafaq... ü•≤
üò∂
In my rust and created a new idl again..
It worked after I removed the config
Can you just post the whole idl file?
Copy what inside to the idl in my client side
Anchor deploy
Anchor build
You have to run something in order to produce it/update it once you make changes etc. How are you doing that?
Wym by building idl?
That part should be fine actually, how are you building the IDL?
i will try deleteing the config and see what happens and get back at u
i see. seems fair but sad.
```rust
#[account]
pub struct Config {
    pub bump: u8,
    pub is_initialized: bool,
    pub mint_account_authority: Pubkey,
    pub admin_account_authority: Pubkey,
}

impl Config {
    /// space = 8 + 1 + 32 + 32 
    pub const LEN: usize = size_of::<Config>() + 8;
}
```
It's generated automatically, but not in a super robust way yet lol
Ohh I didn't knew it would matter in my smart contract coz the idl was generated automatically
Ok, how is that Config type defined in your rust code?
ü•≤

this is literally everything
```js
const anchor = require("@project-serum/anchor");
import idl from "../utils/idl.json";

const provider = new anchor.Provider(connection, wallet, { commitment: "processed" });
anchor.setProvider(provider);

console.log(provider, "provider is working")
// Address of the deployed program
const programId = new anchor.web3.PublicKey(idl.metadata.address);

// Generate program client from IDL
console.log(idl)
const program = new anchor.Program(idl, programId);
```
i tallied it with the other idl examples
idk looks ok to me.
What does the idl look like if you log it etc.? Does it actually look ok?
Import idl from "./program.json";
Can you post more code? How is that idl thing defined?
Im Literally passing the idl from anchor  smart contract..
Did I fuck it up somewhere ?
Brah why is it giving me that error ü•≤
This error sucked in all me energyü•≤
It just doesn't do anything ...ü•≤
Coz im trying to use that with program.state.instruction.initialize () and add this to a tx
Oh yea, I looked at it. Thank you. That make sense.
No, it gives me undefined value for the program üò∂
It is recommended practice to prevent attack. I am not a good explainer so u can check cqfd's answer. üòÖ
Does your code work if you ignore that error?
Alas, closing accounts is surprisingly subtle in solana: https://discord.com/channels/889577356681945098/889606719829835816/954329783813144616
ü•¶
brah, why is it giving me error, when Im literally passing idl there??
Macro handles it
No, the discriminator isn't part of the address, it's part of the account's data. You can do
```.rs
use anchor_lang::Discriminator;
let bytes = TheAccountStruct::discriminator();
```
Hi, I literally have this on the  anchor client and its giving me error on this idk y.. 
```const program = new anchor.Program(idl, programId);```
when I pass the idl to the the anchor program .. it give me this error.
``is not assignable to parameter of type 'Idl'``
when you close the account will be deleted so? why would you require to delete the data
If I close PDA using anchor account attribute #[account(mut, seeds, bump, close=xxx, )], should I still clear data inside PDA? Or will it be handled by macro?
or do i do to just use await program.rpc.someinstruction??
Hi, while connecting to the smart contract throught client in anchor, can I add the instruction to the transaction and pass it through the sendconfirmation??
‚Äò‚Äô‚Äôyarn add ts-mocha‚Äô‚Äô‚Äô updating it to the latest one usually fixed that one for me
Still having issues with this. Looks like `$f9936ec00aa88bd7$exports` which is `anchor` never gets built by Parcel into my production build. I imported anchor by `import * as anchor from '@project-serum/anchor`

What configuration steps are needed from Parcel to support it? CRA is atrocious and I want to avoid using that if I can üòÖ
and I dont know how which variable to use for payer in that function
yeah and this is my getOrCreateAssociatedTokenAccount
This function is used to get all the token accounts of a User using the mint or the TOKEN_PROGRAM_ID
If the Token Account hasn't been created for that user than you have to call the getorCreateAssociatedToken Account function from the solana spl lib
<@!743130416801775687>
What is that function? I used getTokenAccountbyOwner but it return empty array if the user‚Äôve never added the token to wallet
Im still stuck with this error and do have mocha installed globally and the file does exist, changing to absolute path of file also results in same error. Any help on this will be appreciated.
Thanks!
https://switchboard.xyz/
There is no fixed way to do that everyone does it in their own way.
hi! is there a way to generate a random number in the program?
Use the web3 library to get the token accounts
Can you give me an example please
You need to construct the tx object and get it signed this way
`program.provider.send(tx,[mint]);` This is what i do when i am using anchor
I need to get token account of connected wallet from my app
But i need to get token account first
Yes
Are you using Anchor to sign tx ?
```
        space = {
            let space = (Game::LEN as u64).wrapping_add((max_participants as u64).wrapping_mul(Game::PACTICIPANT_LEN as u64)).try_into().unwrap();
            space
          })]
```
Got it to work. max_participants was 0. Not sure why this didn't work...
```
#[instruction(max_participants: u8)]
```

Update all argument
```
#[instruction(stake: u64, max_participants: u8, lucky_num: u8, vault_bump: u8)]
```
how to get this Signer object with wallet-adapter?
45000000049 is O(10^10) bytes. can you verify you are computing/requesting the right number of bytes by doing this and reporting back:

```rust
#[account(
  init, 
  payer = initializer, 
  space = {
    let space = Game::LEN + (max_participants * Game::PACTICIPANT_LEN);
    msg!(format!("requesting {} bytes for game_info", space));
    space
  },
)]
pub game_info: Account<'info, Game>,
```
I'm trying to set dynamic space allocation.
```#[derive(Accounts)]
#[instruction(max_participants: usize)]
pub struct Initialize<'info> {
    #[account(init, payer = initializer, 
        space = Game::LEN + (max_participants * Game::PACTICIPANT_LEN))]
    pub game_info: Account<'info, Game>,
    #[account(init, payer = initializer, space = Vault::LEN, seeds = [b"pubkey"], bump)]
    pub vault: Account<'info, Vault>,
    #[account(mut, constraint = initializer.lamports() >= game_info.stake)]
    pub initializer: Signer<'info>,
    pub system_program: Program <'info, System>
}```

However I'm having issue with max_participants, which I'm passing in as an argument.
When I manually set that amount to a fix integer. It works.

```
Transaction simulation failed: Error processing Instruction 0: custom program error: 0x3 
    Program 8BQunCRwyBZ3EaPP4bmCraTWhVvazrajNR3CtTM7P5rT invoke [1]
    Program log: Instruction: Initialize
    Program 11111111111111111111111111111111 invoke [2]
    Allocate: requested 45000000049, max allowed 10485760
    Program 11111111111111111111111111111111 failed: custom program error: 0x3
```

I'm getting this issue. Seems like max_participants is no deserialise? Any advice?
within a context, how can I easily get the 8 byte unique account identifier of an account? is it just the first 8 bytes of `account.key().to_bytes()`?
btw, what is in your Accounts struct that is creating the Accounts<never> ts type?
yes
By using `Account<'info, Mint>` in a context, does that assert that the token passed in is a mint account, i.e. cannot pass in a random pubkey
i think you need to handle the null for rewardBMint
This is the call I am making:
```
        const txSig = await this.poolProgram.rpc.initializePool(
            poolNonce,
            rewardDuration,
            {
                accounts: {
                    authority: this.provider.wallet.publicKey,
                    xTokenPoolVault: xTokenPoolVault,
                    xTokenDepositor: this.xTokenPubkey,
                    xTokenDepositAuthority: this.provider.wallet.publicKey,
                    stakingMint: stakingMintObject.publicKey,
                    stakingVault: stakingMintVault,
                    rewardAMint: mintAObject.publicKey,
                    rewardAVault: mintAVault,
                    rewardBMint: singleStake ? mintAObject.publicKey : null,
                    rewardBVault: singleStake ? mintAVault : mintBVault,
                    poolSigner: poolSigner,
                    pool: poolPubkey,
                    tokenProgram: TOKEN_PROGRAM_ID,
                },
                signers: [poolKeypair],
                instructions: [
                    await this.poolProgram.account.Pool.createInstruction(poolKeypair, ),
                ],
            }
        );
```
Hello, I am trying to interact with my rust program on the client side, but I constantly face this error:
```
Argument of type '[number, BN, { accounts: { authority: PublicKey; xTokenPoolVault: PublicKey; xTokenDepositor: PublicKey; xTokenDepositAuthority: PublicKey; ... 8 more ...; tokenProgram: PublicKey; }; signers: Keypair[]; instructions: TransactionInstruction[]; }]' is not assignable to parameter of type '[...(number | BN)[], Context<Accounts<{ name: "authority"; isMut: false; isSigner: false; } | { name: "xTokenPoolVault"; isMut: true; isSigner: false; } | { name: "xTokenDepositor"; isMut: true; isSigner: false; } | ... 9 more ... | { ...; }>>]'.
  Type at position 2 in source is not compatible with type at position 1 in target.
    The types of 'accounts.rewardBMint' are incompatible between these types.
      Type 'PublicKey | null' is not assignable to type 'Address | Accounts<never>'.
```
Could I get some help on this?
if i have 2 entry points with very similar account lists, is there a way to avoid duplicating the code?
hi all, saw a couple of mentions of this in here, but nothing that made it particularly clear to me what the cause was or the actions to resolve it ```gm-solana/tsconfig.json" needs an import assertion of type "json"``` Anyone happen to know? This is just gm-solana created with Anchor out of the box as a test. Only potential complicating factor I could think of is it's in Manjaro in WSL.
makes senses thanks
oh so its because it was init before already
Hey guys, calling `anchor build` does not generate the types file under /target/types for me. Only generated it for the first time i ran it, and did not update subsequently after running it. Does anyone know the solution to regenerating and updating the types file? Thanks so much!
Sounds like you're passing in an account that didn't need `init_if_needed` (was already init'd), but it has the wrong amount of space
The "train" is in a
#[derive(Accounts)]
#[instruction(vault_account_bump: u8)]
pub struct Initialize<'info> {
btw.
Happens since I am using 2 vectors, somehow
i get the error when I call it
Error Code: ConstraintSpace. Error Number: 2019. Error Message: A space 

Anybody knows what this means?
```
#[account(
            init_if_needed, 
            seeds = [initializer.key.as_ref()],
            bump,
            payer = initializer, 
            space = 2048
    )]
    pub train: Account<'info, Train>,

#[account]
pub struct Train {
    pub wolves: Vec<Pubkey>,
    pub wolves_time: Vec<i64>
}
```
how can i get unix timestamps of previous epoch start time?
thank you so much that did the trick
yea i didnt mark the payer as mut, let me see if that fixes it
~~But I guess there's no system program in that log, so nevermind~~ [edit: mm, not sure]
Every `init` is a CPI
You've forgotten to mark some account as mut (maybe the payer for an init?)

Can you post the error?
hey guys im getting this CPI error but I don't think I am calling another program, can someone help me out?
thanks! this clears that up for me
Then inside the .json file is

```json
{
    "name": "BitWhips S1AD - #187",
    "symbol": "BWTSLR",
    "description": "BitWhips S1 AirDrop - Teslerr",
    "seller_fee_basis_points": 1000,
    "image": "IMAGE LINK",
    "external_url": "www.bitwhips.io",
    "edition": 187,
    "attributes": [
        { "trait_type": "Backgrounds", "value": "Custom" },
        { "trait_type": "Treads", "value": "Custom" },
        { "trait_type": "Shadow", "value": "Custom" },
        { "trait_type": "Wheels", "value": "Custom" },
        { "trait_type": "Headlights", "value": "Custom" },
        { "trait_type": "Tint", "value": "Custom" },
        { "trait_type": "Bodys", "value": "Custom" },
        { "trait_type": "Line Art", "value": "Custom" },
        { "trait_type": "Plugs", "value": "Custom" },
        { "trait_type": "Accessories", "value": "Custom" },
        { "trait_type": "Ditto", "value": "Custom" },
        { "trait_type": "License Plate", "value": "Custom" }
    ],
    "properties": {
        "files": [
            {
                "uri": "IMAGE LINK",
                "type": "image/png"
            }
        ],
        "category": "image",
        "creators": [
            { "address": "blahblahblah", "share": 0, "verified": true },
        ]
    }
}
```
so then inside the json will be my image url?
```json
{
  "name": "BitWhips S1AD - #187",
  "symbol": "BWTSLR",
  "uri": "LINKTOJSON.json",
  "sellerFeeBasisPoints": 1000,
  "creators": [
    {
      "address": "blahblahblah",
      "verified": 0,
      "share": 0
    }
  ]
}
```
doh
ahh
What you have there is an image
the uri field needs to navigate to a JSON file with the image, name, symbol, and attributes as well.
that is my code btw for the metadata
```
// metadata params
        let data = DataV2 {
            name: "TEST_TICK".to_string(),
            symbol: "TEST".to_string(),
            uri: "https://emojipedia-us.s3.dualstack.us-west-1.amazonaws.com/thumbs/320/openmoji/292/admission-tickets_1f39f-fe0f.png".to_string(),
            seller_fee_basis_points: 0,
            creators: None,
            collection: Some(Collection {
                verified: false,
                key: ctx.accounts.collection_mint.key(),
            }),
            uses: None,
        };
```
ah, will it be on solscan though if im running on localhost?
Check the metadata on Solscan. I just had a mainnet mint where the metadata url actually navigated to a manifest of somesort from arweave, instead of the actual metadata + image.
hi all, I minted my own NFT on localnet using the metaplex program (cloned from devnet) and I can successfully mint it but in the phantom wallet the image never loads, has anyone else seen this before?
Getting this error in production in regards to this line here. Everything works in dev server just fine. Using parcel to build the app. I'm modifying a mint page to add some extra functions. User types a metaplex candy machine id and the site will load it so they can mint nfts from it. The mint page I took this function from uses @project-serum/anchor 0.14.0, while I'm now using 0.22.1. I figured since I'm using an updated version I may need to switch things up but not sure what needs to be changed. Any insight is appreciated!

Full function

```typescript
export const getCandyMachineState = async (
    anchorWallet: anchor.Wallet,
    candyMachineId: anchor.web3.PublicKey,
    connection: anchor.web3.Connection
): Promise<CandyMachineAccount> => {
    const provider = new anchor.Provider(connection, anchorWallet, {
        preflightCommitment: 'recent',
    });

    const idl = await anchor.Program.fetchIdl(CANDY_MACHINE_PROGRAM, provider);

    const program = new anchor.Program(idl, CANDY_MACHINE_PROGRAM, provider);

    const state: any = await program.account.candyMachine.fetch(candyMachineId);
    const itemsAvailable = state.data.itemsAvailable.toNumber();
    const itemsRedeemed = state.itemsRedeemed.toNumber();
    const itemsRemaining = itemsAvailable - itemsRedeemed;

    const presale =
        state.data.whitelistMintSettings &&
        state.data.whitelistMintSettings.presale &&
        (!state.data.goLiveDate || state.data.goLiveDate.toNumber() > new Date().getTime() / 1000);

    return {
        id: candyMachineId,
        program,
        state: {
            itemsAvailable,
            itemsRedeemed,
            itemsRemaining,
            isSoldOut: itemsRemaining === 0,
            isActive:
                (presale || state.data.goLiveDate?.toNumber() < new Date().getTime() / 1000) &&
                (state.data.endSettings
                    ? state.data.endSettings.endSettingType.date
                        ? state.data.endSettings.number.toNumber() > new Date().getTime() / 1000
                        : itemsRedeemed < state.data.endSettings.number.toNumber()
                    : true),
            isPresale: presale,
            goLiveDate: state.data.goLiveDate,
            treasury: state.wallet,
            tokenMint: state.tokenMint,
            gatekeeper: state.data.gatekeeper,
            endSettings: state.data.endSettings,
            whitelistMintSettings: state.data.whitelistMintSettings,
            hiddenSettings: state.data.hiddenSettings,
            price: state.data.price,
        },
    };
};
```
```Use this to clone an account from the test.validator.clone.url cluster to the cluster of your test. If address points to a program owned by the "BPF upgradeable loader", anchor (>= 0.23.0) will clone the program data account of the program for you automatically.```
this is from the anchor book, so we need to wait for anchor 0.23.0 for this feature ? until then we should clone both bpf upgradeable loader for example of the token metadata acc and the program data of token metadata ?
Ah yeah
<@!134416332509675520>
use the `pubkey!` macro though instead of doing `"..".parse()`
the anchor program id is the public key of the keypair generated when i did anchor init program_name, right ? if so where is this keypair privatekey / file wallet stored ?
it works like this. Thank you
thank you for your help. I new new to Rust. Thats why I can (am by the way) surely do silly mistakes due to not deep understanding. But I am learning. Your answer will surely help me understand better
(You should instead probably be doing `address = "bufford....".parse().unwrap()`)
In what way did it not work? That constraint definitely looks wrong to me, but in a way unrelated to the CHECK stuff
I tried something like this but it didn't work
yes, thank you. I read this. I just don't know how to check "address" for a string constant. I need to make a Pubkey from a string before that somehow
https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html
You can see all of the constraint here. For your use case it should be `address =`
<@!134416332509675520> That's right the logic of `memcmp` is already ANDed my bug was elsewhere üôÇ
if I expect a particular pubkey there
hey guys. Any options to check an account pubkey for a constant inside anchor contraints?
Hey! I'm facing an IDL issue while running anchor tests -
So for a while now i havent been able to  install ancohr it keeps giving the error that the build for spl token 3.2.0 failed, i have reinstalled solana and tried to reinstall anchor too but too no effect, it still gives the same error,


//////////////////////////////////////////////////////////////////////////////////////////

Why are you using the program id as one of the seeds? Not sure what the point of doing that is, since the program_id is already an ingredient in the PDA (under the hood it's already part of the sha256 hash)
Ah, ok, you have access to it as `ID`
The program ID was used as part of the seeds.
Ah, maybe you can just do `anchor test --provider.wallet path/to/wallet`
Yeah, seeds *plus* the right bump. You don't need to know the program id, only the seeds + bump.
Do I use the same seeds as the signer seeds as to generate the PDA? If so, how do I get the program ID outside of a macro?
doesnt work. I tried `console.log(anchor.Provider.env().wallet.publicKey.toString());` and its still not the same as the one in `ANCHOR_WALLET` . Am I setting it correctly I do `ANCHOR_WALLET=<path to keypair>`, do I have to run anything after to change it?
Ah, that might be it then. I've been using CpiContext::new instead.
You sign within the program when you do a CPI, using invoke_signed (or CpiContext::new_with_signer)
Recalling the signer escalation error I mentioned yesterday. I added the only non-PDA involved as a signer from the client, and got this error, saying that the signer is unknown. How do I sign using a PDA from within the program itself?
Use anchor.Provider.env() instead I think
small bump
What do you mean by marked unknown? Can you show an example?
PDAs can't sign from the client, but their deriving program can sign for them within the program itself.
Is there a way to use a PDA as a signer? In general, where can I find the rules for what sort of signers an instruction requires and why some signers are marked unknown?
Hi I have a question about anchor wallet. In `anchor.toml` I have this `wallet = "~/.config/solana/id.json"` which means that the program deployed is owned by this wallet. In my test I want other other than the one that owns the program eg. These wallets are meant to be users. Currently I just hardcode the private keys of these wallets on my test file, is there a better way to store them? I tried setting `ANCHOR_WALLET=<user_keypair>` .json but `anchor.provider.local()` seems to not get it
current set up only allows for fungible tokens as whitelist tokens
sup y'all, im trying to see if i can hack metaplex a bit so i can set multiple tokens as whitelist tokens (use nft collection as whitelist tokens, all with unique mint addresses) does anyone have any tips on where to look/what to potentially change?
https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html#instruction-attribute
üëã is there any good documentation on the `#instruction` macro? Can't seem to find anything here https://book.anchor-lang.com/
np
seems cleaner, thank you so much
which is usually what the program expects
to get the lamports equiv
yes
right... so basically i do something like? 
`new BN(1 * LAMPORTS_PER_SOL)`
use the LAMPORTS_PER_SOL variable in web3.js
Or normally I should create transaction and add accounts to it?
Try searching the anchor repo for `remainingAccounts:` lots of examples
would  best practice be to handle adding the zeros on the reactjs side or, to add the zeros on the program instruction side, or it don't matter?
Hey, is way to pass   ctx.remaining_accounts from typescript?
That's a million, not a billion üòõ
oh f me. so I want to send 1 sol i need to do a `new BN(1000000)` ?
So you're sending about a millionth of a sol
Sol is denominated in lamports, which are 1 billionth of a sol
HI Guys whats going on here? Trying to send 999 sol, but wallet is saying i'm trying to send a miniscule amount?

reactjs:
`await program.rpc.sendSol(new BN(999), {
        accounts: {
          from: provider.wallet.publicKey,
          to: destination,
          systemProgram: SystemProgram.programId,
        },
      });`

lib.rs:
`pub fn send_sol(ctx: Context<SendSol>, amount: u64) -> Result<()> {
        let ix = anchor_lang::solana_program::system_instruction::transfer(
            &ctx.accounts.from.key(),
            &ctx.accounts.to.key(),
            amount,
        );
        anchor_lang::solana_program::program::invoke(
            &ix,
            &[
                ctx.accounts.from.to_account_info(),
                ctx.accounts.to.to_account_info(),
            ],
        )?; return Ok(());`
`anchor idl init` (you can seem more options by doing `anchor idl --help`)
i deployed my program to devnet, but now i'm trying to use anchorpy to call it, and i get 
```IdlNotFoundError: IDL not found for program: 7W8hRd8PqFQt5EZDHu9mmBhmiY4UPCcv9UuL86sYkm2K```
how do i publish my idl on-chain?
yeah i called the program tmp lol
ok cool thanks
There ought to be a `target/deply/<your-program-name>-keypair.json` in there
Or just move it out of the way, up to you
so delete the `tmp-keypair.json` ?
You can delete/move the old one (it lives in target/deploy) and anchor/solana will automatically generate a new one.
is there a way to generate a new programID for deployment? i know only some Ids are valid right?
thanks for this! might save some pain in the future
I now have this and seems to .. work, thank you

`import { Program, Provider, web3, BN } from '@project-serum/anchor';
await program.rpc.sendSol(new BN(1), {`
Yeah. Alternative is to do `import * as anchor from "@project-serum/anchor";`
`anchor` is not defined in the import since you are destructuring the export object from the package
add `BN` to the import destructure, and use `new BN(1)`
I have this 
`import { Connection, PublicKey, clusterApiUrl } from '@solana/web3.js';
import { Program, Provider, web3 } from '@project-serum/anchor';`
can you show where you're importing the package?
You're apparently not importing it correctly
Hi Guys, in my reactjs front end i'm trying to pass in a "new anchor.BN(1)" to an RPC but am getting

`ReferenceError: anchor is not defined`

what am i missing here?
Still stuck, If anyone has any ideas!
There is no instruction logic
Ah my bad, i had some name clashes
`anchor build` should be building and generating IDLs for all listed programs in the `Anchor.toml` (defined in the workspace)
I added an entry under `[programs.localnet]` in the Anchor.toml
If i have two programs in my programs directory.  How do i get anchor to make the idl for the new one?  It seems to be compiling the binary, but not making the idl
Much appreciated, will give this a try later today, simplifies a lot
Just answered my own question haha
It doesnt
Why does it have to happen inside the program?
to fund creating that ATA
I guess it wouldnt matter, since anyone can be the payer
Otherwise you are saying you check from the client side if the PDA has an ATA, if not, create one (but i thought this had to happen inside the program)
Yes this is what ive been missing haha
Ahhhh
Oh, got it
Yes, I just removed all the program(instruction) logic and now it just return Ok(()),  but I am still getting the stack violation error
```.rs
#[account(
    init_if_needed,
    payer = somebody,
    associated_token::mint = the_mint_account,
    associated_token::owner = the_pda,
)]
pub the_ata: Account<'info, TokenAccount>
```
If you want
You can use `init_if_needed` with associated token addresses
Ahhh
Ah, no, you can't create the ATA within your instruction function‚Äîno matter what you'd have to pass in the account from the client
Yea I mean, i enter the Deposit function, and in there check if the PDA has an ATA for that passed in mint if not, create one, then deposit the passed in token
Basically a token account is just a token account, and token accounts can have whatever owner you want
Like in the handler
What do you mean by on the fly?
I posted a beefy thread above lol but it really boils down to the question I just asked
can I do this on the fly or should it be added to the attribute on the ix?
Doesn't matter if it has a sol balance‚Äîyou just need to make sure it has some token account, yeah.
Can i transfer any SPL token to a PDA that already has been initialized and contains a SOL balance? Or do I need to make sure that PDA has an ATA for that mint?
I'm saying just take a chunk of your instruction logic
I can't tell what I'm looking at there
ah, I just did this  in my instruction, Still getting stack violation
```rust
    ) -> Result<()> {
        Ok(())
```
should i still try with helper functions?
Alright, I will try this
Thank You
Can also add #[inline(never)] on top of the function to be extra sure rust will give you a fresh stack frame
Yeah, try moving some of the instruction function logic into a helper function, and then just invoke the helper function
24 accounts üòÖ
If so you can bundle up some of its logic into a helper function (this is a kind of silly trick, but doing so gives you access to a fresh 4kb stack frame)
Yes, it is long
Do you have a long instruction function?
Hey, I am getting   `Program failed to complete: Access violation in stack frame 5 at address 0x200005eb8 of size 8 by instruction #8602` I have boxed all the accounts I can what else is possible to deal with the problem
it works ! thank you so much.
cool!
Whoops, typo, `=0.9.1`
current dependencies in toml

```
[dependencies]
anchor-lang = "0.22.0"
anchor-spl = "0.22.0"
spl-token-lending = { git = "https://github.com/solana-labs/solana-program-library", version = "0.1.0", features = ["no-entrypoint"] }
uint = "=0,9.1"
```
```error: failed to select a version for the requirement `uint = "=0, ^9.1"`
candidate versions found which didn't match: 0.9.3, 0.9.2, 0.9.1, ...
location searched: crates.io index
required by package `splendor v0.1.0 (/repos/solanaRepos/splendorprotocol/programs/splendor)```
Note the extra equal sign!
Add an explicit dependency to your program's Cargo.toml:
```.toml
uint = "=0.9.1" # had a typo before, whoops
```
Urgh, I can't find the syntax I want, but at any rate you can do something like
```.toml
that_dependency = { version = "...", features = ["mainnet"] }
```
Getting this error with anchor build
```error: package `uint v0.9.3` cannot be built because it requires rustc 1.56.1 or newer, while the currently active rustc version is 1.56.0-dev
```
```{
  "compilerOptions": {
    "types": ["mocha", "chai"],
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015"],
    "target": "es5",
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "commonjs",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "incremental": true
  }
}```
What does you tsconfig.json look like?
Got it working for myself by changing `test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/unloc-nft-loan.ts"` to `test = "yarn run ts-mocha -t 1000000 tests/**/unloc-nft-loan.ts"`
Running `anchor test` results in:
`Module "file:///users/..../tsconfig.json" needs an import assertion of type "json"`
Any ideas whats wrong?
I can't remember the cargo syntax though :/
What I think you can do is say "build my program for mainnet" and it will automatically build that dependency with the mainnet declaration enabled
ah, think I follow the idea - I need to declare each account with the actual owner for the target deploy env - that correct ?
Ah, no‚Äîsorry, let me figure out the syntax to use
so here it is saying if its mainnet then assume dammHkt7jmytvbS3nHTxQNEcP59aE57nxwV21YdqEDN... and if not then AsW7LnXB9UA1uec9wi9MctYTgTz7YH9snhxd16GsFaGX. Are you saying I can use the same declare ID in my program ? (confused tho - wouldnt that mean I need the private key ?)
Here's an example of what I mean: https://github.com/drift-labs/protocol-v1/blob/master/programs/clearing_house/src/lib.rs#L31
What I would do is source-dive on any third party structs and just go see if you can find what program_id they're expecting
ok, thank you. Will follow up on that lead
You may need to build your code with a special `-- --features mainnet` or whatever flag to actually be able to run on mainnet
Ok, one possibility is that if you're using a third party struct, their code might use conditional compilation to declare multiple different declare_ids.
however I am still not understanding how it works in dev and not main.... Its becoming less and less likely its a simple user error - every deploy I've done in dev has worked... but mocing to prod always has this issue.

I dumped the program files from dev/main and they are identical
ok, thats clearer, thank you.... (and thanks for your patience explaining it)
Anchor checks for this condition with any `Account<'info, Whatever>`. The Whatever struct, in order to be usable with `Account`, has to declare what its expected program owner is (this happens automagically when you make an `#[account]` struct in your program: the resulting struct says "ok, I should be owned by whatever `declare_id!` says")
If the mint authority is that pda, then you aren't actually ever signing for the PDA within your `exchange` function (it's not enough to just pass the PDA in from the client, since anyone can do that! You need your program to proactively say "yes, I'm going to sign for this thing" by using `CpiContext::new_with_signers` for example)
You can just skip passing those bumps entirely! The `bump,` syntax means "anchor, figure it out for me".
Yep, works fine
Nope, this just isn't possible in solana‚Äîyou always have to pass any accounts of interest into the program from the client.
Hopefully im wrong? üòÑ
I know that the docs required building from source, so I'm guessing avm will not work
Dumbo question, does anyone use `avm` on Mac M1 chips? Does it work on it?
I am using Box<Account<'info, State>> where state is owned by a different program, and also AccountLoader<'info, Markets>, as an example of where I think its failing
any help greatly appreciated
Hi, I'm having some problems with AccountOwnedByWrongProgram. I'm pretty sure its to do with an account, not the declareId (i've redeployed a few times to check in dev/main). Confusingly the problem only shows up in mainnet.

Question please - how/when does the anchor macro that checks for AccountOwnedByWrongProgram run please ? For example I can tell it runs when I submit the transaction to my own Program... (because it barfs) - does it also run when doing CPI ? ie on entry to each anchor built program ? ( I assume it is because the invoked code uses AccountLoader for example)

If the checks are done on every program boundary how does one pass user accounts/state between programs without hitting this error?
Can we use BTreeMap in account like this ?  if can how much space to be define for init account ?
Has it ever happened to anyone that from one day to the next you run anchor test and it comes back as if it did not run any? (0 passing/0 executed, when they are programmed and yesterday they were working lmao)
<@!756621864113012896>
thats not correct. it means that you used the `executable` constraint and on an account and but the account you passed in was not `executable`. It's a specific constraint called "executable", not just any constraint. The error log should even tell you which account violated it if youre using `>0.22.0`
Got it thanks I'll look into it more closely
sample constraint https://github.com/Kriptikz/anchor-token-vault/blob/master/programs/anchor-token-vault/src/lib.rs#L138
One of the contraints on your ix struct is preventing the program from executing. typically passing a different signer than the authority or key mismatch. could be any of the contraints youve defined on your structs, so its hard to tell without seeing what contraints u have
anyone know what the following error means ` Error Code: ConstraintExecutable. Error Number: 2007. Error Message: An executable constraint was violated.`
then in order to execute the transfer: 
```
let total_fee = calculateFee(..); //u64
anchor_spl::token::transfer(
            CpiContext::new(
                token_program.to_account_info(),
                anchor_spl::token::Transfer {
                    from: associated_token_account.to_account_info(),
                    to: my_game_fee_account.to_account_info(),
                    authority: authority.to_account_info(),
                },
            ),
            total_fee,
        );
```
Basically I am trying to figure out if I need to create an entirely new program to support SPL integration or if I can just add SPL specific functions that basically do the same transfers but with specified SPL tokens. 

Current program structure: 
On program initialize a fee is set for all transactions,
PDAs are created for the treasury and fee accounts
And other information
Has several functions, Deposit, Play, Claim. 
Deposit, play and claim basically send all the necessary fees to the fee PDA and Claim with withdraw from the PDA treasury.
Currently these are all using the ```invoke_signed( &system_instruction::transfer(...``` way to transfer SOL.

Question 1: Would you suggest I basically clone the existing code, update the SOL transfers to SPL-transfers and deploy a new program? If I do this, would there a be a good way to control which SPL-Tokens are allowed for the Fee and Treasury PDAs?

Question 2: If I don't need to deploy a new program, how can I make it so the existing Treasury and Fee PDAs to accept the SPL-token mints passed in? Figured I would need to create some ATA for them to allow this to happen. If this isn't the case thats great. Also, if I wanted a different fee for SPL tokens, I would probably need to hardcode this since the SOL fee was set on initialize. I was thinking I could just add new properties to the Program struct and use the update function I have to then set the fee, but not sure if upgrading the contract will allow for this? 

Now for some code:

Current structs: 
```
#[derive(Accounts)]
#[instruction(escrow_payment_bump: u8)]
pub struct Deposit<'info> {
    wallet: Signer<'info>,
    #[account(mut)]
    payment_account: UncheckedAccount<'info>,
    #[account(mut, seeds=[PREFIX.as_bytes(), my_game.key().as_ref(), wallet.key().as_ref()], bump=escrow_payment_bump)]
    escrow_payment_account: UncheckedAccount<'info>,
    #[account(seeds=[PREFIX.as_bytes(), my_game.creator.as_ref()], bump=my_game.bump, has_one=authority, has_one=my_game_fee_account, )]
    my_game: Account<'info, MyGame>,
    #[account(mut, seeds=[PREFIX.as_bytes(), my_game.key().as_ref(), FEE_ACCOUNT.as_bytes()], bump=my_game.fee_account_bump)]
    my_game_fee_account: UncheckedAccount<'info>,
    authority: UncheckedAccount<'info>,
    system_program: Program<'info, System>,
}
```
Proposed SPL version:
```
#[derive(Accounts)]
#[instruction(escrow_payment_bump: u8)]
pub struct DepositSpl<'info> {
    wallet: Signer<'info>,
    #[account(mut)]
    payment_account: UncheckedAccount<'info>,
    #[account(mut, seeds=[PREFIX.as_bytes(), my_game.key().as_ref(), wallet.key().as_ref()], bump=escrow_payment_bump)]
    escrow_payment_account: UncheckedAccount<'info>,
    #[account(seeds=[PREFIX.as_bytes(), my_game.creator.as_ref()], bump=my_game.bump, has_one=authority, has_one=my_game_fee_account, )]
    my_game: Account<'info, MyGame>,
    #[account(mut, seeds=[PREFIX.as_bytes(), my_game.key().as_ref(), FEE_ACCOUNT.as_bytes()], bump=my_game.fee_account_bump)]
    my_game_fee_account: UncheckedAccount<'info>,
    #[account(mut)]
    mint: Account<'info, Mint>,
    #[account(mut, associated_token::mint = mint, associated_token::authority = wallet)]
    token_account: Account<'info, TokenAccount>,
    token_program: Program<'info, Token>,
    authority: UncheckedAccount<'info>,
    system_program: Program<'info, System>,
}
```
üò≠
Hey all, I have a couple existing programs that involve SOL transfers and looking to upgrade to allow SPL transfers. Was digging thought search history for a while and found some very useful information but looking for some guidance on how to proceed. Would it be recommended to upgrade the program if it involves changes I would like to make to the initialize function or can I do that via an existing update function (aka can I add properties to the main account struct for the program?
https://tenor.com/view/puppy-eyes-sorry-funny-animals-puppy-dog-eyes-gif-14502312
the "examples" folder in the anchor repo is a gold mine: https://github.com/project-serum/anchor/tree/master/tests
thanks for helping arma
make sure to hit "reply" to ppl
https://github.com/project-serum/anchor/blob/master/tests/escrow/programs/escrow/src/lib.rs#L28
or declare seed as const in the program and use find_progarm_address again to find the bump
got any code snippets/examples for this?
create a new program-owned account and store it in that
whats the best way for me to store the bump/signer seeds? I create these in the `initialize_mint` function but have no way to persist this state currently. Feel free to point me to any existing examples
Can i deserialize data differently based on a field? E.g.

```
pub struct Protocol {
    pub uuid: [u8; UUID_SIZE],    
    pub protocol_extra_data: [u8; 32],
}
```
Can I deserialize protocol_extra_data differently based on the value of `uuid`?
Can use try use CpiContext::new_with_signer and use seeds and bump as signer seeds? When you create mint to cpi context
My own error seems similar. Also, whenever I try to use either of the PDAs above, I cannot because they are lone Pubkeys, lacking a secret key.
Program logs end up giving me:

```
[PDA]'s signer privilege escalated
```

What am I doing wrong here? How can I avoid this error?? Thanks üôÇ
```
const tx = await program.rpc.initializeMint(
  {
    accounts: {
      mint: sampleMint.publicKey,
      mintAuthority: payer.publicKey,
      tokenProgram: spl.TOKEN_PROGRAM_ID
    },
    signers:[payer]
  }
);

const [_pda, _nonce] = await anchor.web3.PublicKey.findProgramAddress(
  [anchor.utils.bytes.utf8.encode("test")],
  program.programId
);

const tx2 = await program.rpc.exchange(amountToBurn, amountToReceive, {
  accounts: {
    burnTokenAcct: burnTokenAccount,
    burnMint: burnMint.publicKey,
    tokenAcctOwner: arbitraryOwner.publicKey,
    tokenProgram: spl.TOKEN_PROGRAM_ID,
    receiveMint: sampleMint.publicKey,
    toReceiveTokenAcct: receiveTokenAccount,
    mintAuthority: _pda
  },
  signers: [arbitraryOwner]
});
```
In my tests, I call:
```
#[derive(Accounts)]
pub struct InitializeMint<'info> {
    #[account(mut)]
    pub mint: Account<'info, Mint>,
    #[account(signer)]
    pub mint_authority: AccountInfo<'info>,
    pub token_program: AccountInfo<'info>
}

#[derive(Accounts)]
pub struct Exchange<'info> {
    #[account(mut)]
    pub burn_token_acct: Account<'info, TokenAccount>,
    #[account(mut)]
    pub burn_mint: Account<'info, Mint>,
    #[account(signer)]
    pub token_acct_owner: AccountInfo<'info>,
    pub token_program: AccountInfo<'info>,
    #[account(mut)]
    pub receive_mint: Account<'info, Mint>,
    #[account(mut)]
    pub to_receive_token_acct: Account<'info, TokenAccount>,
    pub mint_authority: AccountInfo<'info>
}
```
I have:

```
pub fn exchange(ctx: Context<Exchange>, amount_to_burn: u64, amount_to_give: u64) -> ProgramResult {

    let cpi_accounts = token::Burn {
        mint: ctx.accounts.burn_mint.to_account_info(),
        to: ctx.accounts.burn_token_acct.to_account_info(),
        authority: ctx.accounts.token_acct_owner.to_account_info(),
    };
    let cpi_ctx = CpiContext::new(ctx.accounts.token_program.to_account_info(), cpi_accounts);
    token::burn(cpi_ctx, amount_to_burn)?;

    // token burnt at this point

    msg!("Token burnt, time to give them the new token");

    if ctx.accounts.mint_authority.key() != ctx.accounts.receive_mint.mint_authority.unwrap() {
        msg!("error");
        msg!("ctx.accounts.mint_authority: {:?}", ctx.accounts.mint_authority.key());
        msg!("ctx.accounts.receive_mint.mint_authority: {:?}", ctx.accounts.receive_mint.mint_authority);
        return Err(ErrorCode::InvalidOwner.into());

    let cpi_accounts = token::MintTo {
        mint: ctx.accounts.receive_mint.to_account_info(),
        to: ctx.accounts.to_receive_token_acct.to_account_info(),
        authority: ctx.accounts.mint_authority.to_account_info()
    };

    let cpi_program = ctx.accounts.token_program.to_account_info();
    let cpi_mint_tx = CpiContext::new(cpi_program, cpi_accounts);
    
    token::mint_to(cpi_mint_tx, 1)?;

    Ok(())
}

pub fn initialize_mint(ctx: Context<InitializeMint>) -> ProgramResult {

    let mint_accounts = SetAuthority {
        current_authority: ctx.accounts.mint_authority.to_account_info().clone(),
        account_or_mint: ctx.accounts.mint.to_account_info().clone(),
    };
    let cpi_program = ctx.accounts.token_program.to_account_info();
    let (pda, _authority_bump) =
        Pubkey::find_program_address(&[PDA_SEED], ctx.program_id);

    token::set_authority(
        CpiContext::new(cpi_program, mint_accounts),
        AuthorityType::MintTokens,
        Some(pda),
    )?;

    Ok(())
}
```
guys, whats this all about? ```    Program failed to complete: Access violation in stack frame -1 at address 0x1ffffe748 of size 8 by instruction #51372```
change [#error] to [#error_code]
what do i do if my instruction has two different bumps, and I can no longer specify each one with bump=my_bump. If the variable is named bump, i can just add it at the end of the #[account()] macro, but what if its not named bump?

eg:
```rust

#[derive(Accounts)]
#[instruction(
    bump_1: u8,
    bump_2: u8,
)]
pub struct Initialize<'info> {
....
```
Hi, I've deployed an Anchor program and I know the program-id
Is there a way to upload the idl from the onchain program using anchor-cli and the program-id?
ok the solution is to remove the solana cache
```
rm -rf ~/.cache/solana
```
In fact during an anchor build, the cli was downloading something I've done `CTRL-C` which has stopped the download and then since it's not working anymore
hi, I'm facing the following error
```
BPF SDK: /home/zu/.local/share/solana/install/releases/stable-7d2acbc9a3ddf7fb5131c72c8f12f367d4470b42/solana-release/bin/sdk/bpf
cargo-build-bpf child: rustup toolchain list -v
cargo-build-bpf child: cargo +bpf build --target bpfel-unknown-unknown --release
error: process didn't exit successfully: `rustc -vV` (signal: 7, SIGBUS: access to undefined memory)
```
Does anyone know how to get rid of it?
(I've tried adding the user whose account was initialized as a signer, as well as the mint PDA and the PDA used to fill/circumvent the role of mint authority. All are unknown.)
What i'm trying to do:

```
let (_pda, _authority_bump) =
    Pubkey::find_program_address(&["SEED"], ctx.program_id);

let (_pda, _authority_bump) =
    Pubkey::find_program_address(&[PDA_SEED], ctx.program_id);

if (_pda != ctx.accounts.receive_mint.key()) {
    msg!("error");
    return Err(ErrorCode::InvalidOwner.into());
}

let cpi_accounts = token::MintTo {
    mint: ctx.accounts.receive_mint.to_account_info(),
    to: ctx.accounts.to_receive_token_acct.to_account_info(),
    authority: _pda.to_account_info()
};
```
I want to use the PDA as the authority on the mint instruction but the current `_pda.to_account_info()` is giving me the error:

```
the method `to_account_info` exists for struct `anchor_lang::prelude::Pubkey`, but its trait bounds were not satisfied

method cannot be called on `anchor_lang::prelude::Pubkey` due to unsatisfied trait bounds

note: the following trait bounds were not satisfied:
      `anchor_lang::prelude::Pubkey: std::convert::AsRef<anchor_lang::prelude::AccountInfo<'_>>`
      which is required by `anchor_lang::prelude::Pubkey: anchor_lang::ToAccountInfo`rustc(E0599)
```
üëã is there a way to transform a PDA pubkey into account info?
e.g. if ctx.accounts.my_account.to_account_info().key() != "my_pubkey" {}
can a Pubkey be compared to a string?
Cool!
Thank you so much, it worked!!!!!
Alright boughta give this a spin 

```
let ix = update_metadata_accounts_v2(
            ctx.accounts.token_metadata_program.to_account_info().key(), 
            ctx.accounts.nft_metadata_account.to_account_info().key(),
            ctx.accounts.payer.to_account_info().key(),
            Some(ctx.accounts.artist_license.to_account_info().key()), 
            None,
            None, 
            Some(false),
        );
        let tx = invoke(&ix, &[
            ctx.accounts.token_metadata_program.to_account_info(),
            ctx.accounts.nft_metadata_account.to_account_info(),
            ctx.accounts.payer.to_account_info(),
            ctx.accounts.artist_license.to_account_info(), 

        ]);

        msg!("results: {}", tx.is_ok());
```
pray for me haha
It feels repetitive, but yeah, that's how you do it
Nope, no extra structs, just list them out
When I invoke it asks for instructions and accounts, if those are the instructions do I just relist the accounts again for accounts field? If so should I be wrapping it in an UpdateMetadataAccounts struct?
When I add a signer, I get an unknown signer error.
`signer privilege escalated` (so it's not a mutability issue)
Ok, so you're somehow not signing for something

Try posting the full program log, it will include a line with more info
I think I was initializing the account twice. Probably fixed, but since then I get an error in a future instruction trying to mint coins for that new account: `Cross-program invocation with unauthorized signer or writable account`
Ahhh thanks soo much Ill give it a shot ‚ù§Ô∏è
So you made your instruction already, just time to invoke it
Ah, sorry, no need to use the CpiContext stuff‚Äîjust use `anchor_lang::solana_program::program::invoke` or `invoke_signed` on that instruction
```
let ix = update_metadata_accounts_v2(
            ctx.accounts.token_metadata_program.to_account_info().key(), 
            ctx.accounts.nft_metadata_account.to_account_info().key(),
            ctx.accounts.payer.to_account_info().key(),
            Some(ctx.accounts.artist_license.to_account_info().key()), 
            None,
            None, 
            Some(false),
        );


         CpiContext::new( 
            ctx.accounts.token_metadata_program.to_account_info(), 
            ix,
          
        );
```
what I am currently working with
but I havent been able to succesfully call the cpi even haha, I either get errors constructing it like the one above or there is no sign of a cpi in the program logs and the metadata doesn't change
Just cpi the mpl_metadata_program to update the metadata of an nft passed in and owned by the signer
What are you trying to do more broadly?
bit clueless frankly
Does anyone know how I might implement to_account_metas on an isntruction? 

the trait bound `Instruction: anchor_lang::ToAccountInfos<'_>` is not satisfied
the trait `anchor_lang::ToAccountInfos<'_>` is not implemented for `Instruction`
Using those for now... and I get an error saying that an account or token is already in use.
To do that you'd use `token::mint` and `token::authority` instead of the `associated_token` versions.
But if you don't need it to be guessable etc., you can store it at whatever kind of address you want, it just won't be an associated token address
The point of an associated token address though is to be "obvious"/guessable, hence a PDA (in this case derived from the associated token progrma)
You can also store a token account at a raw pubkey if you want‚Äîjust depends on what you want to do
Ah. I was using a raw pubkey. That was probably it.
Using `spl.getAssociatedTokenAddress(...)`
That likely means that you aren't calculating the associated token address correctly on the client
That seems to yield some progress, but now I get an error saying that the instruction references an unknown account, and therefore a required account is missing.
`spl.ASSOCIATED_TOKEN_PROGRAM_ID`, from the spl library
Thanks; that builds. How do I get the associated token program ID in Typescript?
To use the `init` syntax for (associated) TokenAccounts, you also need to use `associated_token::mint = the_mint` and `associated_token::authority = the_owner_of_the_tokens`
The instruction struct that caused it:
The error:
can you paste the snippet?
No wait, I can't even use a wrapper: TokenAccount doesn't implement BorshSerialize.
Ended up attempting to do that instead, but face an error saying that TokenAccount has no function or associated item `default`. Do I need a wrapper to derive it, or am I missing something obvious again?
instead of creating a mint in typescript
yes, then you can just use the `import { createAssociatedTokenAccount } from '@solana/spl-token` export and just provide the mint pubkey as one of the arguments
you asked for typescript üòÜ
I might want to build the associated token account creation into my program though.
Ah. I'd like to use a program-owned mint, though; presumably I'd alter this to fetch the mint from my program instead of creating a fresh one?
I guess it allows u to half-specify your initialization of a struct, as I did here ?
```
    pub fn new(bump: u8) -> Self {
        Self { 
            last_update: LastUpdate::new(),
            ..Default::default()
        }
    }
```
why even use `Default`? What's it do
ah i see
<@!184073368679612416> 
```ts
import { Keypair } from '@solana/web3.js'
import { Token, TOKEN_PROGRAM_ID } from '@solana/spl-token'

const decimals: number = 5 // arbitrary number for testing

;(async () => {
  const wallet = Keypair.generate()

  const testMint = await Token.createMint(
    connection,
    wallet,
    wallet.publicKey,
    null,
    decimals,
    TOKEN_PROGRAM_ID
  )

  const testAccount = await testMint.createAssociatedTokenAccount(
    wallet.publicKey
  )

  await testMint.mintTo(
    testAccount.publicKey,
    wallet,
    [],
    amount * (10 ** decimals)
  )
})()
```
You'll have to impl Default for your account struct by hand if you want to avoid specifying space yourself
This is super dumb, but rust doesn't auto-implement traits for arbitrary array lengths very well
what's going on here?

Associated one. For testing purposes, I would like to make a dummy user's account, but a keypair alone does not suffice.
a program/pda owned or associated one?
Do I use `Spl.token().methods.initializeAccount()` somehow?
How do I initialize a TokenAccount from typescript?
any ideas?
```
            "--bind-address",
            "0.0.0.0",
            "--clone",
            "4bcFeLv4nydFrsZqV5CgwCVrPhkQKsXtzfy2KyMz7ozM",
            "--clone",
            "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
            "--clone",
            "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB",
            "--clone",
            "Amig8TisuLpzun8XyGfC5HJHHGUQEscjLgoTWsCCKihg",
            "--clone",
            "gLhY2arqFpmVGkpbBbTi3TeWbsWevA8dqrwbKacK3vJ",
            "--clone",
            "8ojYYusVjAKTB7tHjKb9oCBubhhU4vHQDNCcUAdg2ikb",
            "--clone",
            "DpxS9YTv7e7MD9USgniaG4G5n4gVGAk8HJ6p7AXDXcxq",
            "--clone",
            "8ojYYusVjAKTB7tHjKb9oCBubhhU4vHQDNCcUAdg2ikb",
            "--rpc-port",
            "8899",
            "--url",
            "m",
        ],
    }
[2022-03-01T22:18:47.846235000Z WARN  solana_perf] CUDA is disabled
[2022-03-01T22:18:47.864435000Z ERROR solana_faucet::faucet] Faucet failed to start: Address already in use (os error 48)
```
`anchor test` is failing saying a provided account isn't initialized, think that error is just masking an error in my program log
How can I access `spl-lending` from my anchor program? Does anchor come with it? Or do I need to add something to my cargo?
I can also report that this problems happens on both linux and mac m1.
Ah, that's exactly the problem. I should be using `Anchor.BN` for numeric arguments.
Ah, here we go. `Spl.token()` should apparently get the token program, but I'm somehow still getting a type error: `Number` is not assignable to `BN`.
thank you! that was it
I can import Spl and SplToken, but I'm not sure what I can do from there.
possibly because of this https://book.anchor-lang.com/chapter_3/CPIs.html#reloading-an-account
I need a bit of help understanding something... if I transfer tokens from 1 token account to another, it looks like the token account `amount` field does not get updated within the same transaction, it remains the same amount balance until the transaction is finished. Why is this the case? Is there any way to get an updated amount within the transaction to do further processing afterwards? some logs:

```
Program log: before yield_vault_amount: 10, deposit_vault_amount: 1
    Program SwaPpA9LAaLfeLi3a68M4DjnLqgtticKg6CnyNwgAC8 invoke [2]
    Program log: Instruction: Swap
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [3]
    Program log: Instruction: Transfer
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 3327 of 127952 compute units
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [3]
    Program log: Instruction: Transfer
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 3200 of 97739 compute units
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success
    Program SwaPpA9LAaLfeLi3a68M4DjnLqgtticKg6CnyNwgAC8 consumed 45760 of 139473 compute units
    Program SwaPpA9LAaLfeLi3a68M4DjnLqgtticKg6CnyNwgAC8 success
    Program log: after yield_vault_amount: 10, deposit_vault_amount: 1
```
But then i can only test half of my program
Okay reducing the size of the binary from 467K to 346K fixes the deployment failure to devnet..
Reiterating. I have an instruction struct with `token_program: Program<Info, Token>`, and I'd like to supply that part of the struct in TypeScript, which seems to have no way to access anchor_spl. Is there an anchor-ts function I'm missing?
how do i debug this?  `Error: Custom: Invalid blockhash
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.`
everything fine on localnet
ok, deployment breaks for my program, not for others. How can that be
10kb for accounts initialized via a CPI to the system program (e.g. when you use the `init` annotation, or any PDA). 10mb for general accounts
do you know what the cap is on data stored per account?
Could the deployment failures be a timeout related thing?
That's great to know, I appreciate it!
I'm actually not sure what you can do here besides just picking the lowest common version :/
Yeah, unfortunately anchor (as far as I know/understand it) just doesn't work well with multiple versions floating around; you run into annoying type mismatches like the above
the function called is part of `switchboard-v2 = "0.1.5"` which I believe depends on an older version of anchor. Is this possible?
ty!
32 bytes
ah makes sense, do you know what the rough size of a public key?
You can check your Cargo.lock file and look for anchor-lang
I wonder if you're accidentally depending on multiple different anchor versions
Any thoughts on this type mismatch? `expected struct anchor_lang::account::Account, found struct anchor_lang::prelude::Account`
So it's basically just linear in the size, plus a small fixed cost. Roughly though it's 7 sol/mb (for rent-exemption).
You can see the calculation here: https://github.com/solana-labs/solana/blob/master/sdk/program/src/rent.rs#L55
Interestingly, creating a fresh project, deploys first time.  But my old project, which is larger, but not big. Fails every time, it's on anchor 0.2.0.
How does rent change based off the amount of data stored on an account? E.g. if I have an account with 20 bytes vs. 200 bytes vs. 2000 bytes of data what would the relative costs be?
I'll try upgrading
0.22.1
Latest anchor cli at any rate doesn't seem to do that (works fine for me)
The stub project it creates has the old ProgramResult
Latest version of anchor changed, yeah. Use `Result<()>` instead
actually this may be just an anchor 0.22 issue
error[E0412]: cannot find type `ProgramResult` in this scope
I upgraded to solana 1.9.9 to try to fix this, but now anchor can't compile even a fresh ini project.
Afternoon!

I'm working off of switchboard's VRF  example to get some rng: (https://github.com/switchboard-xyz/vrf-cpi-example)

Right now I'm getting this error:
`expected struct anchor_lang::account::Account, found struct anchor_lang::prelude::Account`

in response to this function call:
```
        let vrf_request_randomness = VrfRequestRandomness {
            authority: ctx.accounts.authority.to_account_info(),
            ... other accounts ...
            escrow: ctx.accounts.escrow, <- Error
            payer_wallet: ctx.accounts.payer_wallet, <-Error
            ... other accounts ...
            token_program: ctx.accounts.token_program.to_account_info(),
        };
```

I think it's a versioning issue.

I see on their Cargo.toml they use `anchor-lang = "0.19.0"` and `anchor-spl = "0.19.0"`

I use `anchor-lang = "0.20.1"` and `anchor-spl = "0.20.1"`

any way to cast a `anchor_lang::account::Account` to a `anchor_lang::prelude::Account`?
Ok thanks!, I‚Äôll check out the rust docs to see if I can improve my understanding
You were running into a rust type error. Both suggested fixes work by converting one kind of potential error into the right kind of expected error.
They're equivalent.
Thanks! but not sure exactly what i'm supposed to do here, is this meant to be a better fix?
thanks, it compiled without error now, but could you explain a little why i had to do this?
are there any examples of how to call the cpi methods in the token-lending library? https://github.com/solana-labs/solana-program-library/tree/master/token-lending
Ah yeah good call!
<@!134416332509675520> <@!665112704553320473>
or the less annoying `.map(Into::into)`
Annoying but do `invoke(...)?; return Ok(());`
will check, thanks!
Can someone help point me in the right direction to investigate this? looks like a return type error but i don't understand what i'm reading in E0308, and i can't find anything in anchor lang documentation about the return type for program::invoke

The full code:
 `pub fn send_sol(ctx: Context<SendSol>, amount: u64) -> Result<()> {
        let ix = anchor_lang::solana_program::system_instruction::transfer(
            &ctx.accounts.from.key(),
            &ctx.accounts.to.key(),
            amount,
        );
        anchor_lang::solana_program::program::invoke(
            &ix,
            &[
                ctx.accounts.from.to_account_info(),
                ctx.accounts.to.to_account_info(),
            ],
        )
    }`
But see above, there was a discussion of how you may need to clone two accounts per program: the actual program_id account but *also* the upgradeable loader program data account
thanks!
```.toml
[[test.clone]] # or [[test.validator.clone]] maybe
address = LendZqTs7gn5CTSJU1jWKhKuVpjJGom45nnwPb2AMTi
```
The only potentially tricky issue with this error is that if you mess up your declare_id!, you can get spurious errors. (Anchor will check an incoming `Account<'info, OneOfYourAccounts>` against your declare_id!, not against your actual runtime program_id)
If i want to clone a program from mainnet for use on localnet, what do I need to put inot my anchor.toml?

something like

[programs.devnet]
spl-token-lending = "LendZqTs7gn5CTSJU1jWKhKuVpjJGom45nnwPb2AMTi"
?
No, no change between main/devnet. That error can get raised by any `Account<'info, Whatever>` in your program (any of them)


//////////////////////////////////////////////////////////////////////////////////////////

Built-into rust basically, you can use `.checked_add` etc.
Yeah, you can't get a keypair from phantom. But you can still sign the tx with phantom (it will prompt the pop-up etc.)
hey, is there a standard library for safe math for over/underflows on sol? i'm just doing basic addition and subtraction
How do I get a keypair from a provided Phantom wallet (which looks like this) to sign an Anchor instruction? Or do I have to somehow translate the Anchor instruction into a format usable by `signAndSendTransaction`?
Thanks a lot <@!134416332509675520>  for all your help last few weeks.
We were able to complete and submit our project on time for the Hackathon
The error is a bit confusing, but it's saying you can (maybe) get away with being lazy and not specifying `space = ` by instead adding `#[derive(Default)]` to that BuildAccount struct
You need to specify how much space to use for that `init` of the `BuildAccount`

Can you move your mouse and just post the struct?
hmmm, anybody know how to fix this error?
Not as far as I know
üëã is there a way to check in a solana program whether the call is occurring in devnet or mainnet?
e.g. 
```
pub fn exchange_with_transfer(
        ctx: Context<ExchangeWithTransfer>,
        amount_to_burn: u64,
        amount_to_give: u64,
    ) -> ProgramResult {

    // if mainnet do something, if devnet do somethign else

    ...
}
```
not the workspace specifically, but this:
```js
import idl from '../../../target/idl/idl.json';
const connection = new Connection("http://127.0.0.1:8899", confirmOptions);
const provider = new Provider(connection, wallet, confirmOptions);
// @ts-ignore
const program = new Program(idl, programID, provider);
```
I am developing with anchor-client 0.22.1, serum-multisig compiled with anchor-lang 0.21.0. But I did an `anchor expand` and saw that 0.21.0 does indeed have that trait implemented on its Accounts structs.

EDIT: Figured it out -- If you do not use the same version of anchor-lang that the contract was compiled with, it won't work.
Very odd behavior I'm getting:
```
acts.to_account_metas(None),
    |                          ^^^^^^^^^^^^^^^^ method not found in `serum_multisig::accounts::CreateMultisig`
help: the following trait is implemented but not in scope; perhaps add a `use` for it:
    |
1   | use anchor_lang::ToAccountMetas;
```

But I am using it, and getting unused import error:
```
warning: unused import: `anchor_lang::ToAccountMetas`
  --> src/api/multisig/mod.rs:14:5
   |
14 | use anchor_lang::ToAccountMetas;
```
Put the ones that have to be there no matter what in the regular accounts part, and the variable ones in remaining_accounts
how do you decide what to include in remaining accounts versus account?
has anyone tried to add anchor wokrspace to javascript project monorepo? (`NxJS` or `Turborepo`)?
ok, great - thx
No, remaining_accounts are actual accounts (they'll work fine)
sorry, bad nomenclature - I meant accounts - but I was thinking that if I was going to transfer to an account, it had to be included in the accounts context, not just in remaining accounts.
Use `remaining_accounts` (try searching the anchor repo for examples)
Addresses alone won't work (always have to pass any accounts you care about it, not just addresses)
What is a good way to handle an instruction to make transfers to a variable number of accounts? Set a max number, include accounts for each in the accounts context and pass in dummy addresses where necessary?
Maybe the the Base acount name? Maybe the struct I'll post it later probably to make sure
Borsh u8 is 1 byte
I'm away from my computer it's just something I ran into yesterday I'm thinking its a borsh u8 I'm missing  my app worked so I didn't think too much of it
The first 8 bytes of account storage are for the account discriminator (I thought you were asking about something else above‚Äîthe sighash is for the first 8 bytes of instruction data)
Can you post the struct you're wondering about?
Like for an `#[account]` struct?
Where the borsh serialized structs and data are
Actually, what do you mean by program data?
There are 4 bytes I'm wondering about I guess I'm able to parse program data if I offset by 12 it might be some u8 relating to something idk tho lol
The first 8 bytes are for the "sighash" (not sure where you're getting 12 from)
What do the first 12 bytes of program data hold?
Good stuff. Thank you for your time and knowledge.
So still no way for anchor to guess the right size
That size wouldn't be evident from the static type
variable size with fixed capacity
or perhaps we could limit ourselves to `Vec::with_capacity`
Yeah
for sure, but for options of fixed size things should be possible
It also can't possibly be automagic for e.g. vecs
okay cool will manually calculate space then
So yeah, in principle this ought to be automagic, but it's not right now
Because Account<'info, Whatever> uses borsh, so the calculation would have to sort of guess what borsh is going to do‚Äîanchor hacks that currently via Default, by just saying, uh, borsh, how big is it to serialize a default instance?
Yep‚Äîbut that's not how anchor works currently, and as far as I know it's not actually super easy to do that space calculation in anchor itself
ya that's not the full error but that's the only useful portion. I'm not specifying the space but I suppose my next question is surely the space can be auto calculated to the be the max of the `Option<Pubkey>` variants. it's variable but predictable what size these could be, so should just be max of all possible ones.
Just add `space = 1000` to wherever you're init-ing that account
The issue ought to be that you aren't manually specifying `space =` for some init
Can you post the full error? Feel like that can't be all of it
```
 = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`
    = note: this error originates in the derive macro `Accounts` (in Nightly builds, run with -Z macro-backtrace for more info)
```
If I remove `derive(Default)` from my account struct I get a complaint from the struct defining my context which uses `derive(Accounts)`.
I would say don't do that, it just doesn't really make sense to do
makes sense
yes
Since the Default value is empty (too short)
At any rate, relying on Default for variable-sized account things doesn't really make sense
Can't remember which version is latest
Are you deriving Default?
are we on 0.23 yet?
I'm on 0.22
(The latest version of anchor got rid of that feature, since people keep forgetting about it)
That's definitely a bug on your end then, you can't use Default for variable-length fields like Option, Vec, etc.
I'm not specifying the space to allocate
Are you sure you're allocating enough space?
You can use them fine, but they won't work well with Default space calculations
weird enough, I can use an `Option<u32>`, haha
I'm getting a `Failed to Serialize Account` error when I uncomment some `Option<Pubkey>`'s. Are you not allowed to use options for fields on an `#[account]` struct?
Aha got it, but after the deployment I will just need the public key and the upgrade authority private key only to redeploy right ?
You need that private key for your first deploy, because solana is going to create an account that lives at your program_id (and doing so, like with any other account, requires a signature)
guys, when i anchor init program, in my target folder there is a keypair json, i assume this is the private key from which the program id is derived, but in what cases is this program-name.keypair is used for, and isnt it useless if my upgrade authority is someother keypair or am i missing something ?
Sorry, still not quite sure what you're asking about‚Äîwhat do you need the declare_id for? Like, what are you trying to do?
Ah ok ok then my question would essentially be what do I use instead of declareId
Refactoring the codebase requires you to actually refactor it, lol üòõ If the current version works fine then refactoring is extra, annoying work
I think I'm unclear on what you want to do
Versus refactoring the codebase
What would be the potential downsides of doing this
You can always use `avm` to install an old version of the anchor cli
Yeah I was thinking the same might be worth it
Well if I have an old anchor version on a program that I want to run nowadays
In order to run what?
you learn many new thing through this
well you can do refactor if you want
What would be the solution in order to run this nowadays? refactor the code for anchor .20 or downgrade the solana version?
haha, make sense
Yeah, just fetch it the old-school way and see how big its data is, `program.provider.connection.getAccountInfo(theAddress)`
just curious üòú
is there any generic way to check the size of any account?
https://github.com/project-serum/anchor/blob/master/CHANGELOG.md#breaking-changes-1
Because they're using very old versions of anchor, which didn't have `declare_id!` yet: https://github.com/gopartyparrot/ido-pool/blob/prt/programs/ido-pool/Cargo.toml#L18
Hey can someone help me here. Anyone know why some codebase programs may not have a declare id in the lib.rs file?
for example here none of the programs have a declare id which is weird... https://github.com/gopartyparrot/parrot-ido https://github.com/gopartyparrot/ido-pool (this is the parrot ido platform) https://github.com/blockworks-foundation/ido-pool https://github.com/blockworks-foundation/mango-token-sale (this is the og mango markets ido platform)
aaah ok now it is making some sense
At any rate, that `size` is more like `defaultSize` (similar to what might happen in rust if you use Default and leave off the `space =` part)
18 = 8 for the discriminator bytes, 1 for the nonce, 8 for the threshold, and then (mistakenly) 1 for the vec
Also, fwiw, when I try the above I get `18`‚Äîwhich, actually, is a bug (the anchor ts code thinks vecs only take up 1 byte by default, but that's wrong, they take up 4)
That `program.account.newAccount.size` doesn't reflect how much you dynamically allocated (it can't, since it's a static thing and you can of course allocate however much you want‚Äîlike, suppose it somehow returned `200` here, but then the next time you did that instruction thing you changed your mind and wrote `201`)
this is the struct
```
#[account]
pub struct newAccount {
    owners: Vec<Pubkey>,
    threshold: u64,
    nonce: u8,
}```
I'm creating a new account with 200 bytes, but when I try to find the account size it is returning 20. Any idea why this is happing?
```
      preInstructions: [
        await program.account.newAccount.createInstruction(
          newAccount,
          200
        )
      ],
```

```bash
program.account.newAccount.size === 20
```
I see. Sounds fair. Ty
aah gotcha, thnxs king üëë
`await` has low precedence, need to do `(await fidnProgramAddress(...))[0]`
Don't think so (as far as I know no one has figured out a better way to do it)
``` rust
const programDataAddress = findProgramAddressSync([program.programId.toBytes()], new anchor.web3.PublicKey("BPFLoaderUpgradeab1e11111111111111111111111"))[0]```
``` rust 
const hello = await anchor.web3.PublicKey.findProgramAddress([program.programId.toBytes()], new anchor.web3.PublicKey("BPFLoaderUpgradeab1e11111111111111111111111"))[0]```
Why the 1st snippet works but 2nd didn't?
ohh I see gotcha. Thank you so much. 
Any plan for future changes on this ?
Big gotcha but there isn't really any great way to fix it
Ok, yeah, the problem is that you unfortunately can't use the instruction macro like that, it needs to match the order of your instruction fn arguments!
```rust
pub fn test(ctx: Context<Test>, amount: u64, lamports: u64, test_acc_bump: u8, mint_account_bump: u8) -> ProgramResult {
        msg!("Instruction Testing");
        ////.... code
}
```
```rust
#[derive(Accounts)]
#[instruction(test_acc_bump: u8, mint_account_bump:u8)]
pub struct Test<'info> {
  /// ..... everything goes in there
}```
Post the `#[instruction(...)]` part as well as the `pub fn your_instruction_name` signature
No, that's fine, but are you sure you're actually using the right bump for the init?
so I cant init in the same instruction i reckon and try to modify that account?
and you replied after that.
i thought about it. I was going to try creating account in different instruction and then pass it in this instruction
yes

You're also CPIing when you do that `init`
sure will do that
And in front end
```js
    // setup pda for minting
    const [pda_mint, bump_mint] = await PublicKey.findProgramAddress(
        [anchor.utils.bytes.utf8.encode("mint-authority")],
        escrowProgramId
    );
```
Can you post the full program log?
```rust
           let seeds:&[&[u8]; 2] = &[
                b"mint-authority",
                &[mint_account_bump]
            ];
            let signer = &[&seeds[..]];
            let cpi_accounts = MintTo {
                mint: ctx.accounts.mint_token_addr.to_account_info(),
                to: ctx.accounts.authority.to_account_info(),
                authority: ctx.accounts.token_authority.to_account_info(),
            };

            let cpi_program = ctx.accounts.token_program.to_account_info();
            let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer);
```
cpi for minto
```rust
pub struct Test<'info> {
   #[account(mut)]
   pub authority: Signer<'info>,
   #[account(
        init,
        seeds = [
            b"test",
            authority.key().to_bytes().as_ref(),
        ],
        bump = test_bump,
        payer = authority,
        space = Trove::LEN + 8
    )]
    pub testAcc: Account<'info, Test>
    #[account(
        seeds=[
            b"mint-authority"
        ],
        bump = mint_account_bump
    )]
    pub token_authority: AccountInfo<'info>,

    #[account(mut)]
    pub mint_token_addr: Account<'info, Mint>,

    pub pyth_sol_account: AccountInfo<'info>,

    pub system_program: Program<'info, System>,

    #[account(address = spl_token::ID)]
    pub token_program: AccountInfo<'info>,

    pub rent: Sysvar<'info, Rent>,
}
``` 
yes
thank god. Saviour is here!!
You're somehow not using the correct bump. Are you CPIing to something?
why is saying that ?
ü•≤
what is this error im getting while creating pda account through anchor ...
HI,
```Program failed to complete: Could not create program address with signer seeds: Provided seeds do not result in a valid address```
Or will I have to hand roll the definitions?
Is there a way to generate a cpi client from an anchor idl?
what should I be looking for when I see
```
Error: 3004: Failed to serialize the account
```
just check your thingy and make sure its same.
you account data should match the one in the IDL
I haven't managed to pass non-bumps without BN, so ```new anchor.BN(rewardDuration)```
Hello, I am running into this error:
```
Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: invalid account data for instruction
``` 
I am making my transaction like the following:
```
const txSig = await program.rpc.initializePool(
            poolNonce,
            rewardDuration,
            {
                accounts: {
                    authority: this.wallet.publicKey,
                    xTokenPoolVault: xTokenPoolVault,
                    xTokenDepositor: this.xTokenPubkey,
                    xTokenDepositAuthority: this.wallet.publicKey,
                    stakingMint: this.tokenPubkey,
                    stakingVault: stakingMintVault,
                    rewardAMint: this.rewardAPubkey,
                    rewardAVault: mintAVault,
                    rewardBMint: singleStake ? this.rewardAPubkey : this.rewardAPubkey,
                    rewardBVault: singleStake ? mintAVault : mintAVault,
                    poolSigner: poolSigner,
                    pool: poolKey,
                    tokenProgram: TOKEN_PROGRAM_ID,
                },
            }
        );
```
Would anyone be able to help me with this?
i can run other tx pretty simply..
gives me non base 58 error like for ??
Hi, So Im not able to sign in anchor tx like this ? ```rust
 signedTx = await wallet.signTransaction(tx);
```
8
Are the first 12 bytes of program data the account discriminator?
new api is less verbose - thx
```rust
const tx = program.state.instruction.test(new anchor.BN(amount),
        {
            accounts: {
                authority: wallet.publicKey,
                systemProgram: SystemProgram,
                tokenProgram: TOKEN_PROGRAM_ID,
                rent: SYSVAR_RENT_PUBKEY,
            }
        }
    );
```
if i want to add the anchor instruction to a transaction. Is this how I do it ?
``` 
#[account(
        mut,
        constraint = x_token_pool_vault.mint == X_STEP_TOKEN_MINT_PUBKEY.parse::<Pubkey>().unwrap(),
        constraint = x_token_pool_vault.owner == pool_signer.key(),
        constraint = x_token_pool_vault.amount == 0,
    )]
    x_token_pool_vault: Box<Account<'info, TokenAccount>>,
```
Currently it is set as this right now
Don't think there's a dynamic way to do that, at least as far as I know. You'd have to build two different versions of the program, one for devent one for mainnet, e.g. using cargo features: https://github.com/drift-labs/protocol-v1/blob/master/programs/clearing_house/src/lib.rs#L29
Assuming the vault account is a token account, you can just do e.g.
```.rs
#[account(
    init,
    payer = the_payer,
    token::mint = the_mint,
    token::authority = the_vault_itself,
    seeds = [b"the-vault"],
    bump,
)]
pub the_vault_itself: Account<'info, TokenAccount>
```
e.g. 
```
pub fn exchange_with_transfer(
        ctx: Context<ExchangeWithTransfer>,
        amount_to_burn: u64,
        amount_to_give: u64,
    ) -> ProgramResult {

    // if mainnet do something, if devnet do somethign else

    ...
}
```
üëã is there a way to check in a solana program whether the call is occurring in devnet or mainnet?
Would it be just my PDA that becomes the vault?
how would I store the vault account as one of my own PDAs?
I was just wanting to get the balance of a token account, but I think I see where I went wrong - I was using `AccountInfo` from `web3` instead of from `spl-token`.
Hmm, how are you seeing that it has type AccountInfo<T>? Not sure how you'd check that
Also fyi you're using an old version of the spl token library
~~Do you want to make a whole new mint?~~ [edit: sorry, misread] Which part are you asking about‚Äîthe `let token =` part or the `let tokenAccountInfo =` part?
also, how can I figure out what type `tokenAccountInfo` is. It is showing up as `AccountInfo` but it has a type `AccountInfo<T>`
is this the most efficient way to get a token account?
```js
      let token = new Token(
        program.provider.connection,
        mint.publicKey,
        TOKEN_PROGRAM_ID,
        payer
      );
      let tokenAccountInfo = await token.getOrCreateAssociatedAccountInfo(payer.publicKey);
```
How did you call that function?
Associated token addresses are for when you can't think of a good address to use‚Äîso you just base it off the mint + the owner. But if you can come up with a more natural name for address, then there's no point in using an associated token address, just use your own PDA.
But honestly, if you know you want the vault to be program-owned, there's kind of no point is storing it at an associated token address‚Äîyou can just store the vault account at one of your *own* PDAs.
Yeah, there's an optional argument to the getAssociatedTokenAddress function though that let's it work for off-curve addresses
If I want to create a vault that is program owned, would I be able to use the get associated token account using the pda? Since when I look into the method, I think it catches for if the owner if off curve, and if my understanding is correct pda is off curve is that correct?
```
export async function createAssociatedTokenAccount(
    program: anchor.Program<rewardPool>,
    payer: anchor.Wallet,
    mint: PublicKey,
    owner: PublicKey,
    programId = TOKEN_PROGRAM_ID,
    associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID
): Promise<PublicKey> {
    const associatedToken = await getAssociatedTokenAddress(mint, owner, false, programId, associatedTokenProgramId);
    console.log(associatedToken.toString());
    const transaction = new Transaction().add(
        createAssociatedTokenAccountInstruction(
            payer.publicKey,
            associatedToken,
            owner,
            mint,
            programId,
            associatedTokenProgramId
        )
    );

    console.log(program);
    await program.provider.send(transaction);

    return associatedToken;
}
```
How did you build the tx?
I am getting the following:
```
Error processing Instruction 0: incorrect program id for instruction 
    Program ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL invoke [1]
    Program log: Transfer 2039280 lamports to the associated token account
```
Is calling my own program for the program.provider.send(tx) wrong?
okay I will try it out. Thank you for the response
Instead of doing sendAndConfirmTransaction, just do e.g. `program.provider.send(theTx)`
No, but all you need to do is tweak this: https://github.com/solana-labs/solana-program-library/blob/master/token/js/src/actions/createAssociatedTokenAccount.ts
Are there any documentation on how I can do this on the client side?
Unfortunately you can't (this is an oversight imo in the js token lib‚Äîthey're accepting PRs to fix it though). You currently just have to copy the implementations of those functions and tweak them to work with a wallet adapter rather than that overly-restrictive `Signer` type they currently use.
How do I get the payer attribute from the client side? I want to make calls such as createAssociatedTokenAccount, or any calls in the Token library but they all require this payer attribute, however on the client side when I do useWallet(), or do (this.provider.wallet as NodeWallet).payer and it is null
probably somewhere inthe code you are still using the localhost provider, or in your anchor.toml you set cluster=local
Getting this error while the cluster url is set to devnet`Error: failed to get recent blockhash: FetchError: request to http://localhost:8899/`
Yep
Hi. ` AnchorError caused by account: vault. Error Code: AccountNotInitialized. Error Number: 3012. Error Message: The program expected this account to be already initialized.` receiving this error any ideas how to solve this?


//////////////////////////////////////////////////////////////////////////////////////////

This seems to be the result of passing a BN into an instruction as an argument; `new Anchor.BN()` is called on a number obtained by `parseInt`.
Any ideas as to what this error is a sign of? I think Phantom should prompt me for a signature at this point, but it does not.
Okey, thank you üôÇ
I'm not totally sure what that picture is showing, but the `.owner` field on the AccountInfo is always the *program* owner (which program is allowed to mutate the `.data` or spend the `.lamports`)
If you want to have an authority associated with the account, yeah, it would need to go in the account's data (the program owner of the account doesn't go in the data, it's its own separate field on the underlying AccountInfo)
I have been reviewing the bases and I have generated a doubt (maybe very silly), when a user generates an account that stores data (not PDA), this account has as owner the Smart contract that created it and also the authority is the user, this authority is stored in the data field of the account? This is the image that has generated me the doubt, to give some context. Maybe the image refers to a PDA.
Eh, you could write a slightly different version using `program.provider.connection.getAccountInfo`, but eh, your version is easier ü§∑‚Äç‚ôÇÔ∏è Not sure if there's anything simpler built-in
Hello üëã  does somebody know what wallet_limit and lauch_stages_info are in the accounts instruction from magic eden mint?
and maybe how to get them?
hey, how to check if account is owned by my program ? I of course can do like this and catch the error, but is there a better way?
np Alan, just poking around your github
Sorry, I don't
<@!134416332509675520> do you know any good stake/locking rewarder program implementations? Best thing I've found thus far is the anchor test timelock, but was wondering if there might be any alternates you know of?
Can I use type f64 for ui ?
Or `associated_token::` if you want to specifically use an associated token address for the account
You can init a token account in your program e.g. like this: https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo/src/lib.rs#L171, using the `token::mint` + `token::authority` macros
Can't do that in solana unfortunately‚Äîyou need to pass that account in from the client like all the other ones
so, working on a mod of the anchor escrow program. I want to create a token account within the escrow program itself, so looks like I need to use `anchor_spl::token::InitializeAccount`. How do I create a new keypair within Anchor? Looks like most implementations the pubkey is passed in from the web3 side. Not sure if there's a best practice reason for this, what's the idiomatic way of doing this?
Thought so. Okay thank you for the confirmation!
Nope, every individual token account only works with a single mint. You'd need multiple vaults if you want to use multiple tokens.
Conceptually speaking, I think it is not possible, but is there a workaround that I could make a token account receive two different mints?
Is it possible to have a token account (ATA) or in other words, a vault, to receive two different spl-tokens?
Ok thanks I'll look into this
That stack error might be easy to fix, try doing `Box<Account<'info, Whatever>>` a few times instead of `Account<'info, Whatever>` in the relevant derive(Accounts) struct
Have you tried installing v0.13.2 from a git checkout of the anchor source? Not sure if that will help given the submodule issue you mentioned yesterday
We are working on a clone of https://github.com/blockworks-foundation/ido-pool and trying to create our version of it. The problem is that the codebase is v0.13.2 whereas current standards are for v0.18.0 and up. Now after running anchor build for the first time, this error comes up:
thread 'main' panicked at 'Code not parseable: Error("payer must be provided when initializing an account")'
Now my best knowledge of this is due to pool_account being initialized without a payer here: https://github.com/blockworks-foundation/ido-pool/blob/81d3b1972617afd3f246a22c04fd24909e2bbe4b/programs/ido-pool/src/lib.rs#L194
Refactoring it with #[account(init, payer = distribution_authority)] does not ask because it throws another error. associated or seeds must be provided before payer


Now coming to working on the same repo on anchor v0.18 up
After doing all necessary refactoring to the best of my ability, anchor build succeeds. But all the tests fail with the error logs
Transaction simulation failed: Error processing Instruction 1: Program failed to complete
    Program 11111111111111111111111111111111 invoke [1]
    Program 11111111111111111111111111111111 success
    Program 6bmKfxkaEiySeRzrSpmrNRWMR7F8MT1S77963k6fcyDs invoke [1]
    Program 6bmKfxkaEiySeRzrSpmrNRWMR7F8MT1S77963k6fcyDs consumed 2605 of 200000 compute units
    Program failed to complete: Access violation in stack frame 3 at address 0x200003b90 of size 8 by instruction #12521
    Program 6bmKfxkaEiySeRzrSpmrNRWMR7F8MT1S77963k6fcyDs failed: Program failed to complete
Translating error Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 1: Program failed to complete


If we can figure out a way of running the v.13.2 anchor cli then all of our problems are solved but for some reason I've been going at it all night and the avm use 0.13.2 says the version doesn't exist so we need to find a workaround this
How to set custom rpc endpoint when `anchor deploy` in Anchor.toml? I try to set via solana config set --url but it still point to the default rpc of the cluster.
Does anyone know of a good repo using "solana_program_test" and anchor I can read through? I'm trying to write some simple unittests in rust
Thanks for the help though!
I think I have fixed by having to force delete all my node modules and rebuild again
did you tried `import * as SplToken from '@solana/spl-token'; SplToken.getMinimumBalanceForRentExemptAccount(...)` ?
Hello, I am trying to use functions defined in the @solana/spl-token program such as the 
```
getMinimumBalanceForRentExemptAccount
```
In my js file when I import it like 
```const { getMinimumBalanceForRentExemptAccount} = require("@solana/spl-token")```

I am able to use the function call.

However in my ts file, when I do the same, 
```import { getMinimumBalanceForRentExemptAccount} from '@solana/spl-token'; ```
I get an error message 
 ```Module '"@solana/spl-token"' has no exported member 'getMinimumBalanceForRentExemptAccount'.ts(2305)```

Could I get some help on this issue?
Reading through the Escrow example. Could someone explain how the second line works?
And what is happening here, I'm not sure where it is setting the owner to a PDA. What is the cpi_program and cpi_accounts?

```
 let (pda, _bump_seed) = Pubkey::find_program_address(&[ESCROW_PDA_SEED], ctx.program_id);
 token::set_authority(ctx.accounts.into(), AuthorityType::AccountOwner, Some(pda))?;


impl<'info> From<&mut InitializeEscrow<'info>>
    for CpiContext<'_, '_, '_, 'info, SetAuthority<'info>>
{
    fn from(accounts: &mut InitializeEscrow<'info>) -> Self {
        let cpi_accounts = SetAuthority {
            account_or_mint: accounts
                .initializer_deposit_token_account
                .to_account_info()
                .clone(),
            current_authority: accounts.initializer.to_account_info().clone(),
        };
        let cpi_program = accounts.token_program.to_account_info();
        CpiContext::new(cpi_program, cpi_accounts)
    }
}
```
And in same time do you know how to found a program id (on other project) ?
From a program id, can I see the entire code or just the IDL ?
Mmh let‚Äôs try
Yes
?
Latest version of that library I don't think has the export anymore (check the docs)
tysm
nice, and anchor_spl has a close_account cpi helper fn
ah I see, cool
They have a whole separate close instruction
Ah, `close` actually only works on accounts owned by your program. To close a token account you need to actually CPI to the token program
cool. So for an account with data the address provided here I assume sends SOL to SOL address. For closing a token account, do I need to provide token account address or is the SOL pubkey sufficient (and the ATA will be figured out + initialized if needed).
I'm actually not sure if anchor supports this in a safe way yet https://discord.com/channels/889577356681945098/889577399308656662/941767801759219783
So I see that there's a way to mark an account with `close`  to close at the end of an instruction, but is there a way to close only if some condition is true without exiting with an error? Do i need to create a separate instruction with `close` that I only call from another instruction if the condition is met?
Soooooo... Do you mean that if in my program I send the account to be deleted (the account that contains the data, and I don't know how to get it again with the all() method) and I check that the person who makes the request is the owner of the account, it's feasible?
Sure, you can delete data (it's still in the chain history I guess, but you can delete it/close account/etc.)
Btw <@!134416332509675520>, is it possible to delete a data in the blockchain ? Or we need to play with states active/inactive for show/hide a data ?
It's slightly weird, you send the sol (however you want, presumably system_instruction::transfer) to a token account with the wrapped sol mint as its mint, and then you have to invoke the https://github.com/solana-labs/solana-program-library/blob/master/token/program/src/instruction.rs#L1373 instruction to update the token account's balance, to reflect the new `sol` it has
Does anyone know how to convert SOL to wrapped SOL?
Ok sweet ty
Yep
Wow.. Thanks for your help üôÇ
It's surprisingly easy to do that‚Äîthat's why I asked you to rebuild, to make sure you would deploy the latest code
Does comparing Pubkeys work? For example would a check like for (i in list) { if new_pubkey == i {etc} } work like that (where list is a list of pubkeys)
I built my program the first time and I haven't changed anything in this program since I'm on the frontend. Even with my test.ts it worked. Why did I need to rebuild it?
Probably because you accidentally deployed a stale version of your code the last time you deployed
Why ?
fozeibgepzibgz
Its work
https://tenor.com/view/angry-anger-pixar-inside-out-aaah-gif-5628546
I rebuild/deploy and the program ID still the same
Ok I try
And I confirm the error come from the good program
One thing you might do though, just to check: rerun `anchor build`, and *then* redeploy
Ok, then I guess it could be some other account with the wrong program owner
They are same
Yes
You mean in my lib.rs ?
This is surprisingly easy to mess up
You need to make sure that the version you deployed has that exact same declare_id! as the *actual* runtime program id
In local ? I need to change it in local too ?
And that's what your declare_id! says too?

J'y penserai ! ‚ù§Ô∏è
It is a mystery. The declare_id! of my program is the same as when I initialized it with anchor init.

Then I deployed my program in devnet, and I got a new programID and this is the one I use
When in doubt you can switch (I don't speak super well but I read almost as well as I read english)
Haha sure
EZgezogi its better to explain in french for me haha but I need to learn english x)
Je parle fran√ßais üòõ Ou en tout cas je lis plut√¥t bien haha
You translate it for me ? lol
Probably wrong `declare_id!`
Mm, √ßa d√©pend, je sais pas ce qui se passe
I want the user wallet

Oh ! Finally not
Okey ! And do you know why I don't have the tx details ? Maybe I missed something
Yes üôÇ
This correct my problem. But is it normal and common to use it ?
I don't think so, that `wallet` isn't the right kind of thing
I have it
The point is to use `useAnchorWallet` so that you can build that nice `program` variable so that you can talk to your program
program.provider.wallet.publicKey only makes sense once you've already got your `program` set up (you don't yet)
I just try to understand the difference between use the anchor hook and the program.provider.wallet.publicKey who send me undefined
Like `const wallet = useAnchorWallet()`, then check if it's undefined
What do you mean?
I send the entire hook in the program ?
I'm not sure why it's returning undefined for you though
The idea is to use `useAnchorWallet` so you can set up that `program` variable
oh awesome thank you
Don't actually need to worry about that, since if the token transfer fails the whole tx will just roll back/abort
i am making a cpi to transfer tokens from one associated token account to another. how do i change the data on a separate data storage account only after the transfer has succeeded so i dont mark incorrect data by accident
That just complexify the idea. In my test.ts file I use program.provider.wallet.publicKey
But I need the { wallet } inside useWallet no ? I just need the publicKey ?
Just use it instead of `useWallet`
I don't really understand what I need to do with useAnchorWallet ?
You mean { publicKey } from useAnchorWallet ?
Oh ?
Ah, you need to use `useAnchorWallet`, not just the bare `useWallet`
But wallet only have this
What happens if you just log `wallet`
wallet.publicKey
or
program.provider.wallet.publicKey

return undefined yes
So that's returning undefined?
wallet from useWallet() hook
Meaning how is it defined?
Where is that `wallet` coming from?
Here is my full function, and the error appear on contentCreator
And I have the publicKey from useWallet, but if I use it I have an other error:
"this.wallet.signTransaction is not a function"
Hi! This code return me undefined for wallet and I don't understand why. I try to call my program and send data to the blockchain, and I need to send this wallet who is the wallet of the user.

Any idea ?
Do you think the serum discord could be useful?
ah this may be why the build fails on v0.13.2
You could maybe try installing directly from a git checkout of the anchor repo (checkout that tag, 0.13.2)
Ah. Bummer, not sure how to get around that
I get this when trying to install 0.13.2
Awesome thanks I'll come back if I have any issues
`avm use 0.13.2` should probably work
https://book.anchor-lang.com/chapter_2/installation.html#installing-using-anchor-version-manager-avm-recommended
Hmm ok I looked into the command avm but I couldn't figure out the syntax is it "anchor use (cli-version)"?
You can use `avm` for this now
You're probably going to need to install an older version of the anchor cli (matching the anchor-lang version)
I'm trying to run the ido-pools repo from blockworks but I keep running into this error when running anchor test for some reason
In your Cargo.toml, you need to add `features = ["no-entrypoint"]` maybe (try searchign the anchor repo for that)
e.g. attempting to use Anchor programs as crates, one from 0.22.0 and one from 0.21.0 causes a linking error during build:
```
~/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-program-1.10.0/src/entrypoint.rs:120: multiple definition of `entrypoint'; ~/.../target/debug/deps/libserum_multisig.rlib(serum_multisig.vgg80ip4xm3a9f1.rcgu.o):~/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-program-1.10.0/src/entrypoint.rs:120: first defined here
```
What is the "correct" way to consume Anchor programs in Rust client applications? My main hurdle is differing versions of anchor-lang in their respective dependencies.
that's mean 10000 bytes
PDA accounts have 10KB
Then if I want to init an account with the following account:
```
pub struct Pool {
    /// Priviledged account.
    pub authority: Pubkey,
    /// Nonce to derive the program-derived address owning the vaults.
    pub nonce: u8,
    /// Mint of the redeemable mint
    pub redeemable_mint: Pubkey,
    /// Mint of the token that can be staked.
    pub staking_mint: Pubkey,
    /// Vault to store staked tokens.
    pub staking_vault: Pubkey,
    // Mint of the ido token that can be staked.
    pub ido_mint: Pubkey,
    // Vault to store the ido staked tokens.
    pub iod_vault: Pubkey,
    /// Mint of the reward A token.
    pub reward_a_mint: Pubkey,
    /// Vault to store reward A tokens.
    pub reward_a_vault: Pubkey,
    /// Mint of the reward B token.
    pub reward_b_mint: Pubkey,
    /// Vault to store reward B tokens.
    pub reward_b_vault: Pubkey,
    /// The period which rewards are linearly distributed.
    pub reward_duration: u64,
    /// The timestamp at which the current reward period ends.
    pub reward_duration_end: u64,
    /// The last time reward states were updated.
    pub last_update_time: u64,
    /// Rate of reward A distribution.
    pub reward_a_rate: u64,
    /// Rate of reward B distribution.
    pub reward_b_rate: u64,
    /// Last calculated reward A per pool token.
    pub reward_a_per_token_stored: u128,
    /// Last calculated reward B per pool token.
    pub reward_b_per_token_stored: u128,
    /// Users staked
    pub user_stake_count: u32,
    /// authorized funders
    /// [] because short size, fixed account size, and ease of use on
    /// client due to auto generated account size property
    pub funders: [Pubkey; 4],
    //the version of the pool
    pub version: PoolVersion,
    //trailer for future use
    pub trailer: [u8; 31],
}
```
Then I would have to add up all of these? <-- is there a max limit of the size?
32 bytes
does anyone know the byte size of a pubkey?
Ok, I understand. Thank you!
well you can always use **discord search ** feature
Thank you, this is helpful. But I was wandering if there is also a channel where people post issues like: "     RangeError: Attempt to access memory outside buffer bounds"
for anchor related error :: https://docs.rs/anchor-lang/latest/src/anchor_lang/error.rs.html#22-170

Hello,
I am new with anchor and  in this community. Is there a channel where you can look for errors ? thank you
No, `ido_authority_watermelon` here refers to the actual `Account<'info, TokenAccount>` (so, a token account) right below
ya big seed energy
ah nvm source code answered it lol. so each element can only be 32 bytes maximum as well
No, the `init` attribute will take care of that for you
Just to clarify, your program can mutate any account it owns, no need for a signature (if you want to require a signature you'll have to write that logic into your program)
so basically i should be marking that account as #[account(signer,mut)]
is this the number of array elements to be passed in the seeds? because technically you could concatenate multiple buffers into one single element in that array, correct?
It will require that account's address to sign from the client (it will need to be a keypair address)
by not passing seeds to init it will create a normal account right ? if so does it not need the account to be passed in as a signer ?
https://github.com/solana-labs/solana/blob/37189f20c521809e9b8e20ca39ad62df1a9a4a81/sdk/program/src/pubkey.rs#L19
And yeah, like 0xDeep said, max is 16
These questions are easiest to answer by jumping to source
you can have max 16
in any case, I just need at least two pubkeys, so
ya there may be no max which would be sick
also no mention of max here: https://docs.solana.com/developing/programming-model/calling-between-programs#hash-based-generated-program-addresses
https://solanacookbook.com/core-concepts/pdas.html#generating-pdas also doesn't say anything about maximums. not entirely sure what kind of operation is taken over the input, but could well be that it's a hash operation, and thus allowing arbitrary lengths of seeds. really not sure here though
not sure about maximum unforatunately :/ if it's mission-critical, probably makes sense to just write a short unittest on it. otherwise some of the core devs here might know better
ah okay but how many seeds can one PDA have?

oh i see
aah me saying about the length of seed
i have many PDAs which have 2 pubkeys, and even more data on top of that (a serialized string, and an integer). not sure what the maximum is, but _definitely_ holds more than 1 pubkey
that'd be perfect
yea I was hoping I could use 2 pubkeys
are you sure? can't seeds contain 2 pubkeys, which already make it 64 bytes? or is something off with my logic?
cool, ty
yus
what is max num of bytes that can go into seeds? 32 bytes?
ah ok that makes sense and is what's happening here, thanks for the info!
The other thing that might be going on is that the `payer` account gets included automatically as a signer and if `payer` is the owner of those accounts, then the update instruction does include the signer.
Hey I have a noob question, but wanted to clarify this.
```
pub struct InitializePool<'info> {
    // IDO Authority accounts
    #[account(mut)]
    pub ido_authority: Signer<'info>,
    // Watermelon Doesn't have to be an ATA because it could be DAO controlled
    #[account(mut,
        constraint = ido_authority_watermelon.owner == ido_authority.key(),
        constraint = ido_authority_watermelon.mint == watermelon_mint.key())]
```
Looking at this, inside the constraint section, I see that ido_authority_watermelon**.owner** or ido_authority_watermelon**.mint**, I wanted to know where these owner and mint values come from? Is this just a predefined attribute that is found inside the type of Pubkey?
I'm not actually sure if you have to be an owner of an account to be able to update it - sorry I'm new. But in practice, I think you could make those pda accounts and then include a constraint in the update instruction to limit the accounts that can update.
cause I seem to be able to
Like for example I have a GameData account, which contains a is_game_complete and user_address field. So can anyone change those without a signature?
Only in ways that don't require a signature
But it allows me to change the data on the account? which feels illegal
I think it is because you can execute transactions that change the account without having to sign them, i.e., transfer tokens
In Anchor, why am I allowed to generate a mutable reference to an account that's passed in if that account is not a signer? Is it because the account was init through anchor?
awesome, thank you
macro will handle everytng for you
you can use anchor macro here `close=destination_account_that_will_receive_rent_exempt_cost`
what's the process for closing a pda account? if i just transfer the lamports out of it, will it immediately be garbage collected?
ehh, I get it, I just thought that it is mandatory to upload idls, so I need to find it in the bundled js üôÇ I hoped that we left behind that era...
and now you can fetch it anytime, form anywhere cuz now it is living on blockchain
when you do this `anchor idl init --filepath target/idl/some_xyz_program.json zdt9pYtp3pkKoZh2tL97QLfj2iT7GLqPmpRzbtm4a6c`
It will give you something like this `Idl account created: FE4kEKpaVftjriFbKvtAv8WJiU7cXdivBTwrUTkBEKXu`. This mean, now you have created a account on blockchian in this case solana, which store your IDL.
when you do `anchor build` it will genrate an IDL file, but it's json local file that lives on your computer not on blockchain, you need to upload it via `anchor idl init`
you need to manually upload your IDL in the blockchain.
you mean that `console.log(await Program.fetchIdl(new PublicKey("ArAA6CZC123yMJLUe4uisBEgvfuw2WEvex9iFmFCYiXv"), provider))` works only bcs ME initialized their idl, and my previous snippet is not working bcs monkelabs not? 

as I understand every uploaded program should have an idl in order to others could call it (or could generate frontend code), am I wrong here?
Huh. Instead of a prompt for a signer, I get this error...
what is the recommended way to deal with "IdlError: Type not found" is there a simple way to ignore those types client-side?
In order to use this method, an IDL must have been previously initialized
nope, I try to get it from onchain data only
had you previously ran `anchor idl init`
probably a noob question, but why `console.log(await Program.fetchIdl(new PublicKey("monke1YPHGc3oTmHu1aqepy87suBtys92a2MbonHTww"), provider))` returns with null? the given address indeed a program (solscan: https://solscan.io/account/monke1YPHGc3oTmHu1aqepy87suBtys92a2MbonHTww )
Ah, yeah, don't need the signers array (program.provider.wallet signs no matter what)
How do I do that? Do I simply not include a signers array when calling it, and Phantom will prompt for a signature anyway?


//////////////////////////////////////////////////////////////////////////////////////////

Hey! I was trying create a associated token account in program to receive NFT token, and I got `Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: An account required by the instruction is missing` when I call this program from front-end, I think I got something wrong in the cpi creation, hopefully someone could point that out for me üò¶
Hey, I try to add a validator in the integration tests (Typescript): how can I do that?
https://github.com/metaplex/metaplex/blob/23372a130ad017129365775b26c0a5485e0f00a1/rust/test/nft-candy-machine.ts#L486
Hey! I want to mint NFT in my Solana Program. Im currently reading candy machine source code and I'm confused <:Confused:827196894283431936> Why are they passing some instruction like initing mint if that can be done fully in Solana Program
okay m looking at it
You probably need to pass a BN someplace where you're using a raw js number
That's on the JS side, you aren't making it to the contract at all
this comes though
```
 Initializes the IDO pool:
     TypeError: src.toArrayLike is not a function
      at BNLayout.encode (node_modules/@project-serum/anchor/node_modules/@project-serum/borsh/dist/lib/index.js:35:37)
      at Structure.encode (node_modules/buffer-layout/lib/Layout.js:1272:26)
      at InstructionCoder._encode (node_modules/@project-serum/anchor/dist/cjs/coder/instruction.js:81:51)
      at InstructionCoder.encode (node_modules/@project-serum/anchor/dist/cjs/coder/instruction.js:70:21)
      at /mnt/c/FILES/Development/Web3Dev/Honey-Labs/shdw-ido-pool/node_modules/@project-serum/anchor/dist/cjs/program/namespace/index.js:32:97
      at ix (node_modules/@project-serum/anchor/dist/cjs/program/namespace/instruction.js:26:23)
      at txFn (node_modules/@project-serum/anchor/dist/cjs/program/namespace/transaction.js:13:20)
      at Object.rpc [as initializePool] (node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:8:24)
      at Context.<anonymous> (tests/ido-pool.js:97:27)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
```
okay so i fixed stuff.. now it just fails without any logs
Yeah, so go see where that InvalidParam gets used
okay... i see what u mean
```rs
#[error]
pub enum ErrorCode {
    #[msg("IDO must start in the future")]
    IdoFuture, //300, 0x12c
    #[msg("IDO times are non-sequential")]
    SeqTimes, //301, 0x12d
    #[msg("IDO has not started")]
    StartIdoTime, //302, 0x12e
    #[msg("Deposits period has ended")]
    EndDepositsTime, //303, 0x12f
    #[msg("IDO has ended")]
    EndIdoTime, //304, 0x130
    #[msg("IDO has not finished yet")]
    IdoNotOver, //305, 0x131
    #[msg("Insufficient USDC")]
    LowUsdc, //306, 0x132
    #[msg("Insufficient redeemable tokens")]
    LowRedeemable, //307, 0x133
    #[msg("USDC total and redeemable total don't match")]
    UsdcNotEqRedeem, //308, 0x134
    #[msg("Given nonce is invalid")]
    InvalidNonce, //309, 0x135
    #[msg("Invalid param")]
    InvalidParam, //310, 0x136
    #[msg("Cannot withdraw USDC after depositing")]
    UsdcWithdrawNotAllowed, //311, 0x137
    #[msg("Tokens still need to be redeemed")]
    WithdrawTokensNotAllowed, //311, 0x138
}
```
Try searching for `#[error]` in your code
Mm, you're gonna need to find it in order to say that there's no 11th error üòõ
where do i find that?
Can you show the error enum?
Fixed! That last "buffer" should have been capitalized!
okay... well this doesnt have a `11th` error.. am i missing something
0x136 = 310, and your own custom errors start at 300. So it's the 11th custom error.
```
Transaction simulation failed: Error processing Instruction 0: custom program error: 0x136
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS invoke [1]
    Program 11111111111111111111111111111111 invoke [2]
    Program 11111111111111111111111111111111 success
    Program log: Custom program error: 0x136
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS consumed 31468 of 200000 compute units
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS failed: custom program error: 0x136
Translating error Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: custom program error: 0x136
    at Connection.sendEncodedTransaction (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/shdw-ido-pool/node_modules/@project-serum/anchor/node_modules/@solana/web3.js/lib/index.cjs.js:4834:13)
    at processTicksAndRejections (node:internal/process/task_queues:96:5)
    at async Connection.sendRawTransaction (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/shdw-ido-pool/node_modules/@project-serum/anchor/node_modules/@solana/web3.js/lib/index.cjs.js:4795:20)
    at async Object.sendAndConfirmRawTransaction (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/shdw-ido-pool/node_modules/@project-serum/anchor/node_modules/@solana/web3.js/lib/index.cjs.js:6620:21)
    at async Provider.send (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/shdw-ido-pool/node_modules/@project-serum/anchor/dist/cjs/provider.js:84:22)
    at async Object.rpc [as initializePool] (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/shdw-ido-pool/node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:11:31)
    at async Context.<anonymous> (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/shdw-ido-pool/tests/ido-pool.js:97:9)
```
Can you post the full log?
couldn't find this error code: `0x136`
Ok, yeah, dunno, frontend js tooling is a mess ü§∑‚Äç‚ôÇÔ∏è
https://stackoverflow.com/questions/68707553/uncaught-referenceerror-buffer-is-not-defined has other ways to solve the same error, but only for webpack.
Nope. Same error.
Ran `yarn add buffer`; trying to see if that works.
I don't really understand how polyfill stuff works unfortunately, so not sure what you have to type to get it to work
At the top of my code, I had to add this.
Do you still get the error above if you add buffer though?
The class `BNLayout`. You know, earlier I had an error saying `Buffer is not defined` , which `yarn add buffer` did not fix on its own.
Worst case you can try polyfilling Buffer, `yarn add buffer` I think
Where is that code from?
Update: looks like this is where `toArrayLike` is called. Where exactly is `Buffer` supposed to be defined?
okay thanks for this!
And you haven't allocated enough space (try re-counting the total you'd need for that PoolAccount struct, pretty sure you're missing an 8)
0xa3 = 163
But in general you need to look for the code in the anchor source: https://github.com/project-serum/anchor/blob/v0.18.2/ts/src/error.ts#L83
You should get a checkout of the anchor source + the solana source (plus probably also the solana-program-library)
Google is unfortunately going to be pretty useless for solana dev, you need to just look at source code
i normally google.. couldnt find em in solana docs
it's 0.18.2
And what version of anchor-lang are you using?
Do you know how to search for those error codes?
```
Transaction simulation failed: Error processing Instruction 0: custom program error: 0xa3
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS invoke [1]
    Program 11111111111111111111111111111111 invoke [2]
    Program 11111111111111111111111111111111 success
    Program log: Custom program error: 0xa3
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS consumed 18829 of 200000 compute units
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS failed: custom program error: 0xa3
Translating error Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: custom program error: 0xa3
    at Connection.sendEncodedTransaction (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/shdw-ido-pool/node_modules/@project-serum/anchor/node_modules/@solana/web3.js/lib/index.cjs.js:4834:13)
    at processTicksAndRejections (node:internal/process/task_queues:96:5)
    at async Connection.sendRawTransaction (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/shdw-ido-pool/node_modules/@project-serum/anchor/node_modules/@solana/web3.js/lib/index.cjs.js:4795:20)
    at async Object.sendAndConfirmRawTransaction (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/shdw-ido-pool/node_modules/@project-serum/anchor/node_modules/@solana/web3.js/lib/index.cjs.js:6620:21)
    at async Provider.send (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/shdw-ido-pool/node_modules/@project-serum/anchor/dist/cjs/provider.js:84:22)
    at async Object.rpc [as initializePool] (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/shdw-ido-pool/node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:11:31)
    at async Context.<anonymous> (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/shdw-ido-pool/tests/ido-pool.js:97:9)
```
new error... ;-;
Yeah, not sure why you'd need it here
so i have to remove instructions?
The instruction creates an account there, and then you subsequently try to `init` an account again in that `derive(Accounts)` struct
The problem is that you're both using `init` on that `pool_account` as well as using that `instructions` array to do `poolAccount.createInstruction`. Why are you doing both?
well the code is there.. would u have a look at it if i send the link?
I don't know without seeing all of your code etc. Are you running a persistent validator in the background? There's an account at that address, so you presumably are accidentally init'ing it twice, or forgetting that you init'd it previously and it's hanging around, etc. Just need to think it through.
umm okay.. is there a fix to this? I know i havent initialized it before...
Ok, that's just an actual error üòõ You're apparently trying to init an account that already exists
Hey man, so I boxed the accounts, but a new error popped up
```
Transaction simulation failed: Error processing Instruction 1: custom program error: 0x0
    Program 11111111111111111111111111111111 invoke [1]
    Program 11111111111111111111111111111111 success
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS invoke [1]
    Program 11111111111111111111111111111111 invoke [2]
    Allocate: account Address { address: 6XCaEvM5dmGk4MJdhAxQYYvSuL6qcffWEjaeWz41jpP3, base: None } already in use
    Program 11111111111111111111111111111111 failed: custom program error: 0x0
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS consumed 11710 of 200000 compute units
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS failed: custom program error: 0x0
Translating error Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 1: custom program error: 0x0
    at Connection.sendEncodedTransaction (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/shdw-ido-pool/node_modules/@project-serum/anchor/node_modules/@solana/web3.js/lib/index.cjs.js:4834:13)
```
I assume no luck?
Try searching the discord‚Äîdoing so will show you how to clone that account into a local validator, one way via Anchor.toml https://discord.com/channels/889577356681945098/889702325231427584/946565378685956126
How to work with metaplex token metadata program: metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s on localnet? How to deploy it to the localnet?
Hard to answer that beyond just pointing you to the rust book (you're going to need to read most of it in order to do solana programming): https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html
`imp <'info> TransferWrapper <'info> {
    fn transfer_ctx(&self)-> CpiContext< '_, '_, '_, 'info, Transfer<'info>> {
        CpiContext::new(
            from: self.token_program.to_account_info(),
            Transfer {
                from: self.sender_token.to_account_info(),
                to: self.receiver_token.to_account_info(),
                authority: self.sender.to_account_info(),
            },
        )
    }
}`
what does that ":CpiContext< '_, '_, '_, 'info, Transfer<'info>> { " mean ?

although i have made this slight change because of some of the file sizes involved
it looks too much like a javascript library if you split every function into its own file, not a fan
any video lectures on Anchor_spl ?
haha Ok ManüòÅ
As much as I'm a single-file maxi myself, it is in fact allowed üòõ
You can use multiple files with anchor haha
so why there are multiple files?
No, it's using anchor
i think he's not using anchor. <@!248066053161222144>
it's too difficult to understand Anchor and rust. too low language
https://github.com/armaniferrante/auction-house
can you please share Link?
but i also have no idea
there is auction-house armani wrote up i think
Sorry, not sure, I don't do NFT stuff
is there any example of NFT market place using anchor? Except Candy Machine and MetaPlex. <@!134416332509675520>
it's probably `system_program::invoke_signed` or something like that
hey, how to fix this error?
i've been importing `use crate::consts::*;` but `use crate::lib::*` didn't work, so I guess `libr.rs` is just pure `crate`
that sort of makes sense i guess
yeh that works!
Does `crate::ID` work?
and i'm not able to do `mod lib` or any of the usual stuff to get access
`cannot find value ID in this scope`
it gives me this error
Related question, I can't seem to access `ID` from another file, even though `declare_id` is called in `lib.rs` / the main file in the crate
I'll make an issue about it maybe
ah ok
I think it currently still needs the CHECK (so, yeah, false positive)
or does it still need //Check
do you know if having a single constraint is enough to prevent the compile error?
Yeah think that's the best you can do atm
or do I just have to stick with 
```
  #[account(owner = ID)]
  pub this_account: UncheckedAccount<'info>
```
Is it possible to have 
```rust
   pub this_account: Account<'info>
```
essentially, I'm saying that it's not an uncheckedAccount, because I know that it's owned by the executing program but I don't want to deserialize the account
ok thx mate for the answer
If you want to store a token account at one of your own PDAs, you need to use `token::` rather than `associated_token::` (they're both token accounts, but the token:: version lets you pick the address)
ok ok thx
thx a lot yeah it's since the last week that I learn solana and I found the env pretty confused ahah
You don't have any choice over the address of an associated token address (but you do for a regular old token account)
So it's *already* got seeds, used with a different program
The whole point of an associated token address is that it's *already* a PDA, of a totally different program (the associated token program)
I think part of what you're confused about is that it doesn't make sense to try to use your own seeds with an associated token account
It's for creating an another token account like temporary that will be own later by the pda program
I don't know, would have to have your code to play with
Can you explain why you want to use `seeds = [...]` there for an associated token account?
ok but why the address return form unkown account belong to the user_token_account ?
That's why you get that missing account error, since the associated token stuff is like "where is the expected address?"
yeah that's the case
The `associated_token::` versions say you're trying to init an *associated* token account, with a specific associated token address
That's the problem, just switch it to `token::` instead
oh you think that this mess but it's it's not that the account that the errors occurs
Doesn't make sense to try to use seeds = [...] *and* the `associated_token::` stuff (I actually thought anchor would raise a compile error for that, hmm)
```rust
#[program]
pub mod nft_pool {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        let taker_account = &ctx.accounts.taker_account;
        let pda_escrow = &mut ctx.accounts.pda_escrow;
        pda_escrow.taker = taker_account.key();
        pda_escrow.bump = *ctx.bumps.get("escrow").unwrap();

        let user_token_account = &ctx.accounts.user_token_account;
        let pda_token_account = &ctx.accounts.pda_token_account;
        let user = &ctx.accounts.user;
        // first set the authority of the user_token_account to the pda_escrow
        let cpi_set_authority_accounts = SetAuthority {
            current_authority: user.to_account_info().clone(),
            account_or_mint: pda_token_account.to_account_info().clone(),
        };
        let token_program = &ctx.accounts.token_program.to_account_info();
        let cpi_ctx_set_authority =
            CpiContext::new(token_program.clone(), cpi_set_authority_accounts);

        token::set_authority(
            cpi_ctx_set_authority,
            AuthorityType::AccountOwner,
            Some(pda_escrow.key()),
        )?;

        let cpi_transfer_accounts = Transfer {
            from: user_token_account.to_account_info().clone(),
            to: pda_token_account.to_account_info().clone(),
            authority: user.to_account_info().clone(),
        };

        let cpi_ctx_transfer = CpiContext::new(token_program.clone(), cpi_transfer_accounts);
        token::transfer(cpi_ctx_transfer, 1 as u64)?;

        // then transfer the token to the user_token_account
        Ok(())
    }
}
```
Ah, ok, just change that from `associated_token::` to `token::`.
That's what that `init` + `associated_token::` stuff does
You're init-ing an associated token account right there, right?
it's the user_token_account that mess up
https://solscan.io/account/8kbp1cEVT1FRNRYriBw3PUuP2cELrHX5SFBeFKx7KbzH?cluster=devnet
hey, no the token account already exists
Are you trying to init an associated token account?
This is probably due to an incorrect associated token address
Instruction r√©f√©rence an unknown account
Hey anyone know what is the meaning of this error msg ?
You're running out of stack space. Easiest trick is to try Box'ing some accounts, do `Box<Account<'info, Whatever>>` a few times in your derive(Accounts) stuct.
Very interesting, yeah, I think this could definitely just be a bug in solana‚Äîthis has come up before but I haven't played with it myself. If you upgrade solana does it go away?
https://github.com/switchboard-xyz/switchboard-v2-example/blob/main/rust/anchor-feed-parser/tests/anchor-feed-parser.ts Is there a better example of use?
Can you use `associated_token::mint` with just a pubkey and not the actual account?

Based on the errors I'm getting and the example code it looks like it's the case that you actually need the mint itself and not just the pubkey
<https://github.com/project-serum/anchor/blob/58af625736eac53fd7dd789adfabbc6292c2f9bf/tests/misc/programs/misc/src/context.rs#L62>
https://switchboard.xyz/randomness
how make random number?
Hello, 
I am facing this error : "RangeError: Attempt to access memory outside buffer bounds" when I try "await serumCmn.getTokenAccount(provider, toPubKey);" Can anyone help ? Thank you
```js
// Atomically create the new account and initialize it with the program.
        await program.rpc.initializePool(
            watermelonIdoAmount,
            nonce,
            startIdoTs,
            endDepositsTs,
            endIdoTs,
            withdrawTs,
            {
                accounts: {
                    poolAccount: poolAccount.publicKey,
                    poolSigner,
                    distributionAuthority: provider.wallet.publicKey,
                    payer: provider.wallet.publicKey,
                    creatorWatermelon,
                    redeemableMint,
                    usdcMint,
                    watermelonMint,
                    poolWatermelon,
                    poolUsdc,
                    tokenProgram: TOKEN_PROGRAM_ID,
                    rent: anchor.web3.SYSVAR_RENT_PUBKEY,
                    clock: anchor.web3.SYSVAR_CLOCK_PUBKEY,
                    systemProgram: anchor.web3.SystemProgram.programId,
                },
                signers: [poolAccount],
                instructions: [
                    await program.account.poolAccount.createInstruction(
                        poolAccount
                    ),
                ],
            }
        );
```
The test:
```js
it("Initializes the IDO pool", async () => {
        // We use the watermelon mint address as the seed, could use something else though.
        const [_poolSigner, nonce] =
            await anchor.web3.PublicKey.findProgramAddress(
                [watermelonMint.toBuffer()],
                program.programId
            );
        poolSigner = _poolSigner;

        // Pool doesn't need a Redeemable SPL token account because it only
        // burns and mints redeemable tokens, it never stores them.
        redeemableMint = await createMint(provider, poolSigner);
        poolWatermelon = await createTokenAccount(
            provider,
            watermelonMint,
            poolSigner
        );
        poolUsdc = await createTokenAccount(provider, usdcMint, poolSigner);

        poolAccount = anchor.web3.Keypair.generate();
        const nowBn = new anchor.BN(Date.now() / 1000);
        startIdoTs = nowBn.add(new anchor.BN(5));
        endDepositsTs = nowBn.add(new anchor.BN(10));
        endIdoTs = nowBn.add(new anchor.BN(15));
        withdrawTs = nowBn.add(new anchor.BN(19));

        
```
```rs
#[account]
pub struct PoolAccount {
    pub redeemable_mint: Pubkey,
    pub pool_watermelon: Pubkey,
    pub watermelon_mint: Pubkey,
    pub pool_usdc: Pubkey,
    pub distribution_authority: Pubkey,
    pub nonce: u8,
    pub num_ido_tokens: u64,
    pub start_ido_ts: i64,
    pub end_deposits_ts: i64,
    pub end_ido_ts: i64,
    pub withdraw_melon_ts: i64,
}
```
```rs
#[derive(Accounts)]
pub struct InitializePool<'info> {
    #[account(init, payer = payer, space = 8 + 32 + 32 + 32 + 32 + 32 + 1 + 8 + 8 + 8 + 8)]
    pub pool_account: Box<Account<'info, PoolAccount>>,
    pub pool_signer: AccountInfo<'info>,
    #[account(
        constraint = redeemable_mint.mint_authority == COption::Some(*pool_signer.key),
        constraint = redeemable_mint.supply == 0
    )]
    pub redeemable_mint: Account<'info, Mint>,
    #[account(constraint = usdc_mint.decimals == redeemable_mint.decimals)]
    pub usdc_mint: Account<'info, Mint>,
    #[account(constraint = pool_watermelon.mint == *watermelon_mint.to_account_info().key)]
    pub watermelon_mint: Account<'info, Mint>,
    #[account(mut, constraint = pool_watermelon.owner == *pool_signer.key)]
    pub pool_watermelon: Account<'info, TokenAccount>,
    #[account(constraint = pool_usdc.owner == *pool_signer.key)]
    pub pool_usdc: Account<'info, TokenAccount>,
    #[account(signer)]
    pub distribution_authority: AccountInfo<'info>,
    #[account(signer)]
    pub payer: AccountInfo<'info>,
    #[account(mut)]
    pub creator_watermelon: Account<'info, TokenAccount>,
    #[account(constraint = token_program.key == &token::ID)]
    pub token_program: AccountInfo<'info>,
    pub rent: Sysvar<'info, Rent>,
    pub clock: Sysvar<'info, Clock>,
    pub system_program: Program<'info, System>,
}
```
```

        // Transfer Watermelon from creator to pool account.
        let cpi_accounts = Transfer {
            from: ctx.accounts.creator_watermelon.to_account_info(),
            to: ctx.accounts.pool_watermelon.to_account_info(),
            authority: ctx.accounts.payer.to_account_info(),
        };
        let cpi_program = ctx.accounts.token_program.clone();
        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
        token::transfer(cpi_ctx, num_ido_tokens_u64)?;

        Ok(())
```
The endpoint
```rust
pub fn initialize_pool(
        ctx: Context<InitializePool>,
        num_ido_tokens: String,
        nonce: u8,
        start_ido_ts: i64,
        end_deposits_ts: i64,
        end_ido_ts: i64,
        withdraw_melon_ts: i64,
    ) -> Result<()> {
        let num_ido_tokens_u64 = num_ido_tokens.parse::<u64>().unwrap();

        // msg!("Number of IDO Tokens {:?}", num_ido_tokens_u64);
        if !(start_ido_ts < end_deposits_ts
            && end_deposits_ts <= end_ido_ts
            && end_ido_ts <= withdraw_melon_ts)
        {
            return Err(ErrorCode::SeqTimes.into());
        }
        if num_ido_tokens_u64 == 0 {
            return Err(ErrorCode::InvalidParam.into());
        }

        let pool_account = &mut ctx.accounts.pool_account;
        if Pubkey::from_str(ALLOWED_DEPLOYER).unwrap() != *ctx.accounts.payer.to_account_info().key
        {
            return Err(ErrorCode::InvalidParam.into());
        }
        pool_account.redeemable_mint = *ctx.accounts.redeemable_mint.to_account_info().key;
        pool_account.pool_watermelon = *ctx.accounts.pool_watermelon.to_account_info().key;
        pool_account.watermelon_mint = ctx.accounts.pool_watermelon.mint;
        pool_account.pool_usdc = *ctx.accounts.pool_usdc.to_account_info().key;
        pool_account.distribution_authority = *ctx.accounts.distribution_authority.key;
        pool_account.nonce = nonce;
        pool_account.num_ido_tokens = num_ido_tokens_u64;
        pool_account.start_ido_ts = start_ido_ts;
        pool_account.end_deposits_ts = end_deposits_ts;
        pool_account.end_ido_ts = end_ido_ts;
        pool_account.withdraw_melon_ts = withdraw_melon_ts;

    }

```
GM folks... so I am having this error but I don't know why this is occuring.. can anyone help? The program logs:
```
Transaction simulation failed: Error processing Instruction 1: Program failed to complete
    Program 11111111111111111111111111111111 invoke [1]
    Program 11111111111111111111111111111111 success
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS invoke [1]
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS consumed 2790 of 200000 compute units
    Program failed to complete: Access violation in stack frame 3 at address 0x200003e00 of size 8 by instruction #13316
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS failed: Program failed to complete
Translating error Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 1: Program failed to complete
    at Connection.sendEncodedTransaction (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/shdw-ido-pool/node_modules/@project-serum/anchor/node_modules/@solana/web3.js/lib/index.cjs.js:4834:13)
    at processTicksAndRejections (node:internal/process/task_queues:96:5)
    at async Connection.sendRawTransaction (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/shdw-ido-pool/node_modules/@project-serum/anchor/node_modules/@solana/web3.js/lib/index.cjs.js:4795:20)
    at async Object.sendAndConfirmRawTransaction (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/shdw-ido-pool/node_modules/@project-serum/anchor/node_modules/@solana/web3.js/lib/index.cjs.js:6620:21)
    at async Provider.send (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/shdw-ido-pool/node_modules/@project-serum/anchor/dist/cjs/provider.js:84:22)
    at async Object.rpc [as initializePool] (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/shdw-ido-pool/node_modules/@project-serum/anchor/dist/cjs/program/namespace/rpc.js:11:31)
    at async Context.<anonymous> (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/shdw-ido-pool/tests/ido-pool.js:97:9)
```
is there a function in web3: Connection that does this for you? (without deserializing it manually)
ctx.accounts.your_token_account.mint
is there a way to get the mint from an associated token account?
Hi team, I got an error of "Program log: AnchorError occurred. Error Code: . Error Number: 0. Error Message: ." when I use 3 AccountLoader() in my Solana program transactions, is there anyone who have seen this problem before? is there any potential bug related to AccountLoader()? thanks.
My anchor version is 0.22.0, and Solana version is 1.8.14
When creating the #[derive(Accounts)] struct for an instruction, does the order of accounts matter or affect anything?
Has anyone been able to resolve this error before, seems to be an issue with the rand and getrandom crates
Your Initialize struct looks ok. My guess is that the bug is elsewhere in your code.
Hey Im wobdering wha
What th√© meaning of this error msg
Awesome thank you!
thanks üôÇ
https://docs.rs/anchor-lang/latest/anchor_lang/prelude/derive.Accounts.html
Hey just wondering, where in the documentation is a description of all the anchor macros you can use, e.g stuff like `    #[account(
        mut,
        close = user
    )]
`
Yeah, think so, just specify multiple `--bpf-loader` args
can you load multiple programs to solana-test-validator with --bpf-loader? ive only seen examples of one program in a single validator session
But yeah, I miss how with solana when you get stuck you can just jump to source, read a little code, and then proactively unstick yourself. JS tooling stuff is just endless googling, fiddling with json files... ugh, not fun.
At any rate, that `new BN()` stuff should work, not sure yet why it's not in your case
Ouch.
I tried messing around with this a bit locally, and ugh, screwing around with frontend JS tooling is such a nightmare üò£
Oooh I got it
#[account] over a struct is short for [this thing is gonna get stored on-chain in an account]
`#[derive(Accounts)]` is short for `#[derive(AllTheAccountsYouPassToTheInstructionFromTheClient)]`
Thanks you
...
That last `TodoList` struct should say `#[account]` on top of it, not `#[derive(Accounts)]`
Hi ! My new error of the day. I don't understand what is the problem :/
Not sure, but some examples of CPI'ing to the token program in this repo: https://github.com/cqfd/quidproquo
Does anyone have recommendations for tutorials with explanations and example of how to use CPI with Anchor
I did not miss `yarn build`.
But at least this is probably not an Anchor thing if it's an error in bundle creation.
Unless I'm missing a step in the tutorial there?
https://create-react-app.dev/ . Running `yarn build` in case I missed it earlier; that might be the problem.
How are you bundling your code for the browser?
Asked on StackOverflow: https://stackoverflow.com/questions/71565287/arraytype-is-undefined-when-supplying-a-bn-as-an-argument-to-an-anchor-instructi
got it thx
avm install latest && avm use latest
How can I change my globally installed version of anchor on mac?
If so, that might be the reason for my error above. Could also make a thread for this so as not to get lost in the backlog.
it for not populate the discord channel
oh you mean the thread ?
don't know if this can help you
<@!350632015852208140>  it's when I run this code with ts-node that the error occurs
```typescript
const userTokenAccount = new anchor.web3.PublicKey(
    "8kbp1cEVT1FRNRYriBw3PUuP2cELrHX5SFBeFKx7KbzH"
  );

  const [pdaTokenAccount] = await anchor.web3.PublicKey.findProgramAddress(
    [
      user.toBuffer(),
      mint.toBuffer(),
      TOKEN_PROGRAM_ID.toBuffer(),
      anchor.utils.bytes.utf8.encode("token-seed"),
    ],
    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID
  );

  const rent = SYSVAR_RENT_PUBKEY;
  const tokenProgram = TOKEN_PROGRAM_ID;
  const associatedTokenProgram = SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID;
  const systemProgram = SystemProgram.programId;

  const signer = {
    secretKey: Uint8Array.from(privateKey),
    publicKey: provider.wallet.publicKey,
  };

  const ctxInitalizeAccounts = {
    accounts: {
      user,
      pdaEscrow,
      takerAccount,
      pdaTokenAccount,
      userTokenAccount,
      mint,
      rent,
      tokenProgram,
      associatedTokenProgram,
      systemProgram,
    },
  };

  const tx = await program.rpc.initialize(ctxInitalizeAccounts);

  console.log("Your tx signature: ", tx);
})();
```
```typescript
/*
    DEVNET TEST
*/
import * as anchor from "@project-serum/anchor";
import { Program } from "@project-serum/anchor";
import { NftPool } from "../target/types/nft_pool";
import { env } from "process";

const { SYSVAR_RENT_PUBKEY, SystemProgram } = anchor.web3;
const {
  ASSOCIATED_PROGRAM_ID: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,
  TOKEN_PROGRAM_ID,
} = anchor.utils.token;

(async () => {
  env.ANCHOR_WALLET = "/home/kima/.config/solana/id.json";
  env.ANCHOR_PROVIDER_URL = "https://api.devnet.solana.com";

  anchor.setProvider(anchor.Provider.env());

  const privateKey = JSON.parse(
    require("fs").readFileSync("/home/kima/.config/solana/id.json", "utf-8")
  );
  // get the provider
  const provider = anchor.getProvider();
  // get the idl
  const idl = JSON.parse(
    require("fs").readFileSync("./target/idl/nft_pool.json", "utf-8")
  );
  const programID = new anchor.web3.PublicKey(
    "4PN4rfDddrUGeBLaPL48pYzvUHJweokYKbgrBGLiEYPv"
  );

  // get the program
  const program = new anchor.Program(idl, programID) as Program<NftPool>;

  const user = provider.wallet.publicKey;
  const [pdaEscrow] = await anchor.web3.PublicKey.findProgramAddress(
    [anchor.utils.bytes.utf8.encode("escrow"), user.toBuffer()],
    programID
  );
  const takerAccount = new anchor.web3.PublicKey(
    "Ez7DWjDwjQuBjMMu5eUiVqxYfK1ECs4dgbPKdSvyFZp7"
  );
  const mint = new anchor.web3.PublicKey(
    "D9wi8R749wahcXkcwCfUDXTC5RibPisD1Gny1rqVsne4"
  );
```
hmm, not fully sure here :/
can you post the code as well?
yes I wrote it in ts and it check for me that all the account passed is publickey
can you print and double check that all of them are instantiated, publickeys?
in the typescript (or whatever you use)
it sounds like youre not passing in all accounts successfully
https://solscan.io/account/8kbp1cEVT1FRNRYriBw3PUuP2cELrHX5SFBeFKx7KbzH?cluster=devnet
don't know what you mean ?
```rust
#[derive(Accounts)]
pub struct Initialize<'info> {
    // initializer
    #[account(mut)]
    pub user: Signer<'info>,
    #[account(init, payer = user, seeds = [b"escrow", user.key().as_ref()], bump)]
    // pda_escrow for storing state and signing tx
    pub pda_escrow: Account<'info, EscrowAccount>,
    /// CHECK: read access to store the pubkey to the escrow account
    pub taker_account: UncheckedAccount<'info>,

    // the token account created using a specific seeds that belong to the calle
    #[account(init, payer = user, associated_token::authority = user, associated_token::mint = mint, seeds = [b"token-seed"], bump)]
    pub pda_token_account: Account<'info, TokenAccount>,

    #[account(mut)]
    pub user_token_account: Account<'info, TokenAccount>,

    #[account(mut)]
    pub mint: Account<'info, Mint>,

    pub rent: Sysvar<'info, Rent>,
    pub token_program: Program<'info, Token>,
    pub associated_token_program: Program<'info, AssociatedToken>,
    pub system_program: Program<'info, System>,
}
```
```
Transaction simulation failed: Error processing Instruction 0: An account required by the instruction is missing 
    Program 4PN4rfDddrUGeBLaPL48pYzvUHJweokYKbgrBGLiEYPv invoke [1]
    Program log: Instruction: Initialize
    Program 11111111111111111111111111111111 invoke [2]
    Program 11111111111111111111111111111111 success
    Instruction references an unknown account 8kbp1cEVT1FRNRYriBw3PUuP2cELrHX5SFBeFKx7KbzH
    Program 4PN4rfDddrUGeBLaPL48pYzvUHJweokYKbgrBGLiEYPv consumed 31340 of 200000 compute units
    Program 4PN4rfDddrUGeBLaPL48pYzvUHJweokYKbgrBGLiEYPv failed: An account required by the instruction is missing
 {
  logs: [
    'Program 4PN4rfDddrUGeBLaPL48pYzvUHJweokYKbgrBGLiEYPv invoke [1]',
    'Program log: Instruction: Initialize',
    'Program 11111111111111111111111111111111 invoke [2]',
    'Program 11111111111111111111111111111111 success',
    'Instruction references an unknown account 8kbp1cEVT1FRNRYriBw3PUuP2cELrHX5SFBeFKx7KbzH',
    'Program 4PN4rfDddrUGeBLaPL48pYzvUHJweokYKbgrBGLiEYPv consumed 31340 of 200000 compute units',
    'Program 4PN4rfDddrUGeBLaPL48pYzvUHJweokYKbgrBGLiEYPv failed: An account required by the instruction is missing'
  ]
}
```
like does solscan parse it correctly
can you put it in solscan?
yh got it
when I say short it it's for discord not on my code
have you checked that solscan accepts it for example?
maybe it's not so useful to short it like that
hmm weird
no I short it
just making sure I don't get this incorrectly
is this literally the string you use to create this account?
I think it's about the TokenAccount but cannot know why the simulate processing tell me it's an unknown account
---------------------------------------------------------------------------------------------------
```Rust
 pub user_token_account: Account<'info, TokenAccount>,```
```JavaScript
const userTokenAccount = new anchor.web3.PublicKey(
    "8kbp1cEVT1FRNR....SFBeFKx7KbzH"
  );```
Hey, why is the meaning of this error msg:  
```Instruction references an unknown account 8kbp1cEVT1FRNR....SFBeFKx7KbzH```
----------------------------------------------------------------------------------------------------
<@!134416332509675520> https://discord.com/channels/889577356681945098/889577399308656662/955574411635851264 Is it still the case that `toArrayLike` does not work from browser?
sick
PRs welcome though üôÇ
might add this in the next release
https://github.com/project-serum/anchor/issues/980
found the bug: didn't mark the account as mutable, but no error was thrown. is this intended behavior?  ^
i'm doing several identical program.rpc.ix() calls within the same it(...) in a typescript test, each which should be mutating data. Every tx is successful, but somehow the data is reverted to its original state by the time the next call happens:
```
  Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS invoke [1]
    Program log: Instruction: Unstake
    Program log: stake info key: BXjmAAEarSRj4EVrDy3eXZ5dDzL7ioagLMp8eW2a25Hh
    Program log: now: 2
    Program log: requested_unstake: false [READ HERE]
    Program log: requested_unstake_epoch: 0 [READ HERE]
    Program log: delay: 1
    Program log: stake_info.requested_unstake | (stake_policy.delay_period == 0): false
    Program log: setting request data
    Program log: requested_unstake: true [SET HERE]
    Program log: requested_unstake_epoch: 2 [SET HERE]
    Program log: delay: 1
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS consumed 36012 of 1400000 compute units
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS success
Transaction executed in slot 129:
  Signature: 3cMbPq7YfA9KbtdSrzseFdHbRt964akhseZkWRG2RzBGmssGTRZrZUiPtKiyB93yT6FePk9fuy8M6xVaZBbRycr2
  Status: Ok

  Log Messages:
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS invoke [1]
    Program log: Instruction: Unstake
    Program log: stake info key: BXjmAAEarSRj4EVrDy3eXZ5dDzL7ioagLMp8eW2a25Hh
    Program log: now: 4
    Program log: requested_unstake: false [READ HERE, somehow equal to original]
    Program log: requested_unstake_epoch: 0 [READ HERE, somehow equal to original]
    Program log: delay: 1
```
any idea what's going on? I'm on a local validator with `--slots-per-epoch 32`. never had an issue like this before
i have explicitly overwritten my .so file with the output of /verifiable to overcome the `binaries don't match` error
```anchor verify -p audius_data Fki7j8r4TAFzWxChaKRbCG3FC4tt8h8oqarRasRZBy8P --provider.cluster https://audius.rpcpool.com/ 

+ exit 0
cargo-build-bpf child: /root/.local/share/solana/install/releases/1.8.5/solana-release/bin/sdk/bpf/dependencies/bpf-tools/llvm/bin/llvm-readelf --dyn-symbols /workdir/docker-target/deploy/audius_data.so

To deploy this program:
  $ solana program deploy /workdir/docker-target/deploy/audius_data.so
The program address will default to this keypair (override with --program-id):
  /workdir/docker-target/deploy/audius_data-keypair.json
Copying out the build artifacts
Cleaning up the docker target directory
Removing the docker container
anchor-program
Extracting the IDL
Writing the IDL file
Writing the .ts file
Build success
Error: Account not found
```
hey all, am attempting to verify a program on mainnet but keep getting this result - has anyone overcome this?
To me it seems like it comes from the test side, maybe not providing the right accounts context ?
Maybe there is a better way to share such code examples, please enlighten me üòõ
Sorry for bloat messages
The output and error : 
```
 hashmaplike-sc
TX signature ihutuZ742k2JJDSkdwr4myqkPhMRpriSKMxTsiZNzBdfYpB6byX26LuJ6PisBe4V3L1JBbopteC97wqCk1bUW77
    ‚úî Is initialized! (418ms)
    1) Creates item


  1 passing (514ms)
  1 failing

  1) hashmaplike-sc
       Creates item:
     Error: unknown signer: CefvkEbCGuQPTb3G3y21o57Guu1a1jEzAGYuU69UWJZ3
      at Transaction._addSignature ...
```
and the tests : 

```ts
import * as anchor from "@project-serum/anchor";
import { Program } from "@project-serum/anchor";
import { HashmaplikeSc } from "../target/types/hashmaplike_sc";
import { PublicKey, Keypair, SystemProgram } from "@solana/web3.js";

describe("hashmaplike-sc", () => {
  // Configure the client to use the local cluster.
  const provider = anchor.Provider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.HashmaplikeSc as Program<HashmaplikeSc>;
  
  const hashmapAccount = Keypair.generate();
  const hashmapItemAccount = Keypair.generate();
  const key = Keypair.generate();

  it("Is initialized!", async () => {
    
    const tx = await program.rpc.initialize({
      accounts: {
        user: provider.wallet.publicKey,
        hashmap: hashmapAccount.publicKey,
        systemProgram: SystemProgram.programId,
      },
      signers: [hashmapAccount]
    });
    console.log("TX signature", tx);
  });

  it("Creates item", async () => {

    const [hashMapItemPDA, _] = await PublicKey
    .findProgramAddress(
      [
        anchor.utils.bytes.utf8.encode("stake"),
        provider.wallet.publicKey.toBuffer(),
        key.publicKey.toBytes(),
      ],
      program.programId
    );
    
    const tx = await program.rpc.createItem(key.publicKey, {
      accounts:{
        hashmap: hashmapAccount.publicKey,
        hashmapItem: hashMapItemPDA,
        user: provider.wallet.publicKey,
        systemProgram: SystemProgram.programId
      },
      signers:[hashmapItemAccount]
    });
    
    console.log("TX signature", tx);
    
  });

});
```
Hi everyone, I asked a question a couple of days ago on the solana tech server about implementing a hashmap like data structure on solana. 
I tried using PDAs to solve that as kindly advised there and now I stumble across an other problem that I can't understand.

I reproduced an example if anyone want to test, the rust :
```rust
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod hashmaplike_sc {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        Ok(())
    }

    pub fn create_item(ctx: Context<CreateItem>, key: Pubkey) -> Result<()> {
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {

    #[account(init, payer = user)]
    pub hashmap: Account<'info, HashMapAccount>,

    #[account(mut)]
    pub user: Signer<'info>,

    pub system_program: Program<'info, System>,

}

#[derive(Accounts)]
#[instruction(key: Pubkey)]
pub struct CreateItem<'info> {
    pub hashmap: Account<'info, HashMapAccount>,

    #[account(
        init, 
        payer = user, 
        seeds = [
            b"item", 
            user.key().as_ref(), 
            key.as_ref(), 
        ], 
        bump
    )]
    pub hashmap_item: Account<'info, HashMapItemAccount>,

    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,

}

#[account]
#[derive(Default)]
pub struct HashMapAccount {
    count: u32,
}

#[account]
#[derive(Default)]
pub struct HashMapItemAccount {
    value: u32,
}
```
(The error persists even if, instead of the result of `parseInt`, I supply a raw hardcoded number.)


//////////////////////////////////////////////////////////////////////////////////////////

hello, guy how can i send sol from pda ?
thanks <33
100% now!
Yep
OHHH I see the difference .
like you stiill start to have your unlocking but only can claim after this date
It's just an incentivization hack, that's all
It encourages you to work hard to make it to 1 year, since you're about to suddenly get a quarter of your equity allotment
That's just the scheme people use
why isn't the start after 1 year then?
why you start now and add delay of 1 year before it "actually" starts?

(thankns for info I think I get it)
The purpose of the cliff is to make sure you're incentivized to stick around for at least a year (/ the company is incentivized to boot you before the 1 year mark if you're not working out)
Using with vesting schedules there's a "cliff", where you don't actually get any of your vesting rewards until after the cliff. For example, lots of US tech companies have a 4 year vesting schedule with a "1 year cliff", meaning you actually don't vest any of your options until the 1 year mark after you join‚Äîthen you suddenly get 1/4 of your allotment. After the cliff point you vest more regularly, like every month or whatever.
just realizing this is not related to anchor specifically
<@!134416332509675520> 
I don't get what is cliffTS
because if I have a start date to start unlocking the tokens and then a duration, what is the cliff?
getAssociatedTokenAddress takes an optional argument to allow off-curve addresses (try jumping to source)
If I want an escrow ATA for a program what should I do?
Is it not possible to create an ATA for a PDA?
```
  const escrowAtaAddress = await Token.getAssociatedTokenAddress(
    ASSOCIATED_TOKEN_PROGRAM_ID,
    TOKEN_PROGRAM_ID,
    tokenMintAddress,
    escrowAddress
  );
```
Generates a non program address
Ok, I guess I'll just keep on and put back my code and have an other try.
Also as I get some of your time.?
Can I have an example of a CPI with an already pushed program?
Like I want to use Bonfida's token vesting program already uploaded.
but from backend how do I declare it? in the anchor.toml?
works ...
Mm, can you try running `BROWSER= anchor test`?


Yeah, just try running `anchor test` and see what happens
haven't tried tbh, the error caught me there, I'll try someting
Not sure, does the code work when you actually run it?
<@!134416332509675520>  anyb idea of where to look? thanks in advance üôÇ
And then pass them in as accounts‚Äîwhy do you need to fetch their account info at all on the client?
Sounds like you just need one call to look up the relevant pubkeys
Why would you need to call getAccountInfo multiple times? Or getMultipleAccounts at all?
Hi <@!134416332509675520>  i wanted to extend on this. So you're saying we can't store "AccountInfo" details on the program, but u can store the public keys. OK.

So lets say i store in my program the list of participants (basically a vector of public keys). I need to pay each of the participants a share of whats in the PDA escrow. Therefore i need to pass to my from the front end to the program via an RPC call, a vector of AccountInfos. 

So in order to do that, my front end first has to retrieve all the participant public keys from the program (do-able using program.account.XXX.fetch), iterate through the public key array.

IF i have 100 participants, rather than calling getAccountInfo 100 times, I think i could use call getMultipleAccounts once instead

Not really a question but thinking out loud.
If I don't mistake in your program you have to specify the length, try 8+8 instead of just 8
Facing this error while passing in the data. Data is type of u8 array of size 8


Hello guys, I don't get wht anchor.workspace isn't working?
I'm  using version 19.0
?
Can't see it in the flags, but is there any way to increase the timeout time
Seems to me like it happens when the size of the `.so` is larger than 400kb
Yeah, think this just happens sometimes, not sure
Seems like its a type of timeout
Anyone had an issue deploying to `devnet` with the following error?
```
Error: Custom: Invalid blockhash
```
much appreciated
Sure
alright noted! but where would the destination be? id have to use invoke_signed and a pda to hold the native sol, correct?
You'd use wrapped sol if you also need to support token transfers
If all you need to do is move sol then I would just use the vanilla system transfer.
for native sol transfers, would it be better to use the system instruction or would it be better to wrap sol? i see two approaches for doing this and i'm not sure which to use.
well this is kinda depressing tho, i wanted to setup my own validator later on..
yay that worked
let me try devnet i guess then
they just added hardware requirements for test validators
i guess i havent been doing anything wrong
:/
not too important tho, nvm if you didn't come across it üôÇ was just wondering if there was a cleaner way around this
basically just to calculate the `uiAmount` and `uiAmountString` attributes xD
ah sry, forgot to include decimals in the interface
Like, how would it know the number of decimals etc. to use?
What would you want that to do?
bcs rn I just re-create the object using the interface (creating the members is trivial, I'm just surprised there is not constructor for this interface)
and I was wondering if there was a "new TokenAmount" of some sort, which takes as input ```new TokenAmount(javascriptNumber)```
so basically TokenAmount https://solana-labs.github.io/solana-web3.js/modules.html#TokenAmount is just a typescript interface
Where is that object coming from? Not familiar with TokenAmount
when I have a `TokenAmount` object, and I want to modify it (based on some user's input), what is the best way to create a new TokenAmount object?

how can do this based on the amount of decimals and the floating point number in typescript?
Yeah, can probably just install over it
or should i just reinstall over it
any idea how to uninstall solana?
Sure!
can i dm?
Just to double check, do you even need to allocate an account there? Do you specifically need that account to be owned by your program etc.?
Ok, the problem is that `init` on `market_authority`, you need to specify how much space you want to allocate
here's the code: ```#[derive(Accounts)]
#[instruction(bump: InitMarketBumpSeeds)]
pub struct InitializeMarket<'info> {
    #[account(zero)]
    pub market: AccountLoader<'info, Market>,

    /// The account for storing quote tokens during swaps
    #[account(init,
        seeds = [
            market.key().as_ref()
        ],
        payer = owner,
        bump = bump.market_authority)]
    pub market_authority: AccountInfo<'info>,

    /// The account for storing quote tokens during swaps
    #[account(init,
        seeds = [
            b"dex-swap-tokens".as_ref(),
            market.key().as_ref()
        ],
        bump = bump.dex_swap_tokens,
        token::mint = quote_token_mint,
        token::authority = market_authority,
        payer = owner)]
    pub dex_swap_tokens: Account<'info, TokenAccount>,

    /// The account to use for placing orders on the DEX
    #[account(init,
        seeds = [
            b"dex-open-orders-a".as_ref(),
            market.key().as_ref()
        ],
        bump = bump.dex_open_orders_a,
        payer = owner,
        owner = dex::ID,
        space = std::mem::size_of::<OpenOrders>() + 12,
        rent_exempt = skip)]
    pub dex_open_orders_a: AccountInfo<'info>,

    /// The DEX market that can be used to trade the reserve asset
    pub dex_market_a: AccountInfo<'info>,

    /// The program for interacting with the DEX
    #[account(address = dex::ID)]
    pub dex_program: AccountInfo<'info>,

    #[account(mut)]
    pub nft_droplet_mint: AccountInfo<'info>,

    #[account(signer)]
    pub owner: AccountInfo<'info>,

    pub rent: Sysvar<'info, Rent>,

    pub system_program: AccountInfo<'info>,

    /// The mint for the market quote tokens
    pub quote_token_mint: AccountInfo<'info>,

    /// The program for interacting with the token.
    #[account(address = token::ID)]
    pub token_program: AccountInfo<'info>
}```
Anchor won't work until you can run `solana-test-validator` successfully
Ok, sorry, I haven't used wsl so not sure, but you're going to have to figure out how to get a working solana install
on windows 10
wsl
What kind of machine are you on?
Gonna have to reinstall
Yeah, your solana install is broken for some reason
:/


huh it instantly just said aborted
Does it actually run correctly?
What happens if you do `solana-test-validator`
Are you able to actually run a local validator at all?
so i havent changed anything
i didnt find anything like test.startup_wait in the anchor.toml
``Unable to get recent blockhash. Test validator does not look started. Check .anchor/test-ledger/test-ledger-log.txt for errors. Consider increasing [test.startup_wait] in Anchor.toml.``
What does it say? Post the error message
anchor test doesnt work either tho
Yeah, anchor test does, but anchor deploy requires an actual cluster to deploy to
it does it automatically
hey yeah
unless im blind
didnt see anything in the book
Yep üòõ
if im supposed to start one up
uhh i guess not
What does `lsof -i :8899` say?
Are you actually running a local validator?
and i have no idea what
so i think im just doing something wrong
ive tried setting up anchor on my laptop and pc both are getting this error
You definitely shouldn't need `AccountInfo` to implement Default
Can you post more of the surrounding code? Are you accidentally storing an `AccountInfo` inside of an `#[account]` struct or something?
so i anyways ended up doing Account<'info, TokenAccount> and now I'm getting now i am getting ```no function or associated item named `default` found for struct `anchor_lang::prelude::AccountInfo` in the current scope``` instead. any idea on this?
its testnet
what seems to be the problem here

Any idea, someone, please?
okay got it
Oh, no, you don't need to sign for the token account itself‚Äîyou need to sign for whoever has authority over the token account, the token account owner.
Other than the cluster in my Achor.toml file, I've changed nothing.
so that mean I will use the same seed and bump to sign the cpi transfer instruction for the PDA's TokenAccount?
yeah I checked that. I check with the solana cli to make sure it's the right address and that I have SOL on all networks.
Maybe check your Anchor.toml to make sure you're using the wallet you want to?
hi all. 
I'm getting some strange stuff. Using version 0.23 of anchor. 
I can build just fine
I can deploy to localhost just fine
I can deploy to Testnet just fine
when I deploy to Devnet I get this error:
Error: Account allocation failed: RPC response error -32002: Transaction simulation failed: This account may not be used to pay transaction fees
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.
Ok, if you want to sign for that address, then you need to use those seeds (and possibly re-calculate the bump with `find_program_address` if you forgot to store it somewhere)
a simple vault str and payer pubkey,if you mean the vault PDA
These are probably the most annoying rust lifetime errors üòõ One trick that I think will work is to just inline the `cpi_ctx` varible (don't make a separate variable for it, just stuff the rhs into `mint_to`)
Hey, getting strange error. Smthing with rust I guess. Interesting that I‚Äôm using authority_seeds without a problem at 88th line
That depends on on how you made the vault address! What seeds did you use?
I don't think this could have been working with an AccountInfo ü§î Since, yeah, those definitely don't know about mints etc.
Hey I am still struggling with pda signing for spl token transfer, I transferred some tokens to  to the vault PDA using the solana cli and it now hold some token, what seed and bump choice should be used for the program sign the transfer in this case?
https://lorisleiva.com/create-a-solana-dapp-from-scratch/our-first-instruction check out the "Guarding against invalid data" 

and then 
"https://lorisleiva.com/create-a-solana-dapp-from-scratch/testing-our-instruction" - How to use it in JS
Bump.
great!
Hey, any idea how I can add validators in integration tests (typescript)?
Hey so I need to do a transfer from one token account to another in my ts tests. Whats the best way to do this with the current apis?
hi everyone, how would one set a custom error to be used by a constraint? for example, if I wrote a custom error, how would I be able to use it when a constraint is violated?
not sure ,but try using anchor upgrade instead of anchor deploy
I'm a newb but maybe Anchor build/deploy again?
Hi Anchor community, I try to use Anchor to build an app today but encounter a problem. I build an `instruction` that has `#[account]` as one of its parameters. 
```
#[account]
pub struct ExampleAccount {
  name: String
}

pub fn set_data(ctx: Context<SetData>, data: ExampleAccount) -> Result<()> {}
```
But the problem is, I use this program as a CPI used from other programs. Therefore, the `account` struct used as a parameter is not compiled to IDL. What I mean is the compiled IDL has the instruction `set_data` with the declared parameter `ExampleAccount` but in the IDL, there is no definition for the type `ExampleAccount` and Anchor throws something like `Type ExampleAccount does not exist in the IDL`. Have anyone know how to resolve this issue?
Hey, whenever I run ```anchor deploy``` on the localnet, anchor always deploys my program from scratch. How can I fix this?
I don't think spl-token have anythin' such that. Metaplex dervied `print`(Copy of nft) term
I'm talking about Non Fungible Tokens(NFT's) with multiple supply. <@!717956950737813594>
i don't want to go through **MetaPlex** because its code is too lengthy and difficult to understand, so my major interest is go through **Anchor**.
is it so?
Ok I guess you are taking about `print`.
https://docs.metaplex.com/about/terminology
yeah copies of NFT's in Ethereum chain they are ERC1155 standard. <@!717956950737813594>
now i am getting ```no function or associated item named `default` found for struct `anchor_lang::prelude::AccountInfo` in the current scope``` instead. any help on this is appreciated!
okay so changed this to ```#[derive(Accounts)]
#[instruction(bump: InitMarketBumpSeeds)]
pub struct InitializeMarket<'info> {
    #[account(zero)]
    pub market: AccountLoader<'info, Market>,

    /// The account for storing quote tokens during swaps
    #[account(init,
        seeds = [
            market.key().as_ref()
        ],
        payer = owner,
        bump = bump.market_authority)]
    pub market_authority: AccountInfo<'info>,

    /// The account for storing quote tokens during swaps
    #[account(init,
        seeds = [
            b"dex-swap-tokens".as_ref(),
            market.key().as_ref()
        ],
        bump = bump.dex_swap_tokens,
        token::mint = quote_token_mint,
        token::authority = market_authority,
        payer = owner)]
    pub dex_swap_tokens: Account<'info, TokenAccount>,

    /// The account to use for placing orders on the DEX
    #[account(init,
        seeds = [
            b"dex-open-orders-a".as_ref(),
            market.key().as_ref()
        ],
        bump = bump.dex_open_orders_a,
        payer = owner,
        owner = dex::ID,
        space = std::mem::size_of::<OpenOrders>() + 12,
        rent_exempt = skip)]
    pub dex_open_orders_a: AccountInfo<'info>,

    /// The DEX market that can be used to trade the reserve asset
    pub dex_market_a: AccountInfo<'info>,

    /// The program for interacting with the DEX
    #[account(address = dex::ID)]
    pub dex_program: AccountInfo<'info>,

    #[account(mut)]
    pub nft_droplet_mint: AccountInfo<'info>,

    #[account(signer)]
    pub owner: AccountInfo<'info>,

    pub rent: Sysvar<'info, Rent>,

    pub system_program: AccountInfo<'info>,

    /// The mint for the market quote tokens
    pub quote_token_mint: AccountInfo<'info>,

    /// The program for interacting with the token.
    #[account(address = token::ID)]
    pub token_program: AccountInfo<'info>
}``` just to get rid of earlier error
wdym by copies of nft?
Means that "anchor_spl"  donot support multiple tokens(Copies oF NFT's) <@!717956950737813594>
NFT have max supply of 1
yeah you can, I think the only d/f b/w fungible and non-fungible is max-supply
can we use "anchor_spl" to create NFT or it is just for SPL tokens(Fungible) ?
maybe core devs can help here
Unfortunately not, sorry üôÇ
Hey thanks, yeah I figured that out but I just want to be doing AccountInfo which seemed to be working in the earlier anchor version. Would you happen to have any idea on that?
S'not mut or signer which are the normal constraints for a wallet
As a sanity check, the player wallet should be unchecked in case of an airdrop?
Dangit that constraint doesn't count as making it safe lol
I'm pretty sure, you know this, but posting it here anyway.
```Account<'info, TokenAccount>```
just curious üòÜ
`don't want to be doing that` any good bad reason for this?
Would the best constraint for 'this is a normal wallet account' be owner = sys?
and here's the error in more detail ```no field `mint` on type `anchor_lang::prelude::AccountInfo<'_>`
  --> programs/jet/src/instructions/init_market.rs:43:10
   |
43 | #[derive(Accounts)]
   |          ^^^^^^^^ unknown field
   |
   = note: available fields are: `key`, `is_signer`, `is_writable`, `lamports`, `data` ... and 3 others
   = note: this error originates in the derive macro `Accounts` (in Nightly builds, run with -Z macro-backtrace for more info)``` also i'm getting similar errors in a couple more places after changing to anchor v1.19.0 which goes away on deserialising to Account<'info, Whatever> but I don't want to be doing that instead just use AccountInfo which worked in anchor v1.18.2. any ideas on how i can go about this?
Here's the corresponding code: ```#[derive(Accounts)]
#[instruction(bump: InitMarketBumpSeeds)]
pub struct InitializeMarket<'info> {
    #[account(zero)]
    pub market: AccountLoader<'info, Market>,

    /// The account for storing quote tokens during swaps
    #[account(init,
        seeds = [
            market.key().as_ref()
        ],
        payer = owner,
        bump = bump.market_authority)]
    pub market_authority: AccountInfo<'info>,

    /// The account for storing quote tokens during swaps
    #[account(init,
        seeds = [
            b"dex-swap-tokens".as_ref(),
            market.key().as_ref()
        ],
        bump = bump.dex_swap_tokens,
        token::mint = bump.quote_token_mint,
        token::authority = market_authority,
        payer = owner)]
    pub dex_swap_tokens: AccountInfo<'info>,

    /// The account to use for placing orders on the DEX
    #[account(init,
        seeds = [
            b"dex-open-orders-a".as_ref(),
            market.key().as_ref()
        ],
        bump = bump.dex_open_orders_a,
        payer = owner,
        owner = dex::ID,
        space = std::mem::size_of::<OpenOrders>() + 12,
        rent_exempt = skip)]
    pub dex_open_orders_a: AccountInfo<'info>,

    /// The DEX market that can be used to trade the reserve asset
    pub dex_market_a: AccountInfo<'info>,

    /// The program for interacting with the DEX
    #[account(address = dex::ID)]
    pub dex_program: AccountInfo<'info>,

    #[account(mut)]
    pub nft_droplet_mint: AccountInfo<'info>,

    #[account(signer)]
    pub owner: AccountInfo<'info>,

    pub rent: Sysvar<'info, Rent>,

    pub system_program: AccountInfo<'info>,

    /// The program for interacting with the token.
    #[account(address = token::ID)]
    pub token_program: AccountInfo<'info>
}```
god bless dude
https://github.com/project-serum/anchor/blob/v0.18.2/ts/src/error.ts#L87
nope it's not, custom errors started from 6000+
`constraint = something`
0x8f = Raw constraints violated
300+ is starting of custom errors
jk decode it into decimal
decoded it means: `y0urm0m`
what is custom error 0x8f
üòõ
You still caused me to re-search which was helpful lol
kk
Ooo
i accidentally responded in the wrong chat
nah i wasn't talking about u
Oh maybe I left it limited to this channel whoops. I can Discord I swearz
Fucking discord search zzz lol, NOW it shows up for me >< Thank you üôÇ
oh then i have a different problem
I already solved it. There was a previous fix I did where I introduced `Buffer` as lowercase instead of capital.
Think I found a solution
What are you sending to anchor?
can someone help?
```cannot return value referencing temporary value returns a value referencing data owned by the current function```
Hey I am trying to make a token transfer from a PDA to another account and I know I need to use a CPI new_with_signer, but when I try to give it the signer_seeds i am getting an error
lol
damn same guy had the same issue 8 hours ago
~~Happy to post full program log if that's helpful, just would rather DM instead of scrub it :p~~

Oop, I see that this is known until anchor updates to spl v3, fair nuff
```error[E0425]: cannot find value `rent` in this scope
  --> programs/genesis-token/src/lib.rs:51:10
   |
51 | #[derive(Accounts)]
   |          ^^^^^^^^ not found in this scope
   |
   = note: this error originates in the derive macro `Accounts` (in Nightly builds, run with -Z macro-backtrace for more info)```
(localnet identifiers if any vultures out there ;D)

EDIT: This is known until anchor updates to v3 SPL. You need to pass in rent sysvar like olden times until then
```mod determinant_identifier {
    use super::*;
    declare_id!("FjZqqSHAVS6vB7J58pSKN1MAWmM4XQLXBithCCBDmNUG");
}

mod our_token_mint {
    use super::*;
    declare_id!("By4QvAng1aS3mjixCePXRYXZYL59fB2UCgU4PbyHVDhQ");
}


#[derive(Accounts)]
pub struct PurchaseFrozenOurToken<'info> {
    #[account(constraint = determinant_keypair.key == &determinant_identifier::ID)]
    pub determinant_keypair: Signer<'info>,
    #[account(mut)]
    pub player_wallet: Signer<'info>,
    #[account(
        init_if_needed,
        associated_token::mint = &our_token_mint::ID,
        associated_token::authority = player_wallet,
        payer = player_wallet,
        constraint = player_ata.amount == 0)]
    pub player_ata: Account<'info, TokenAccount>,
    #[account(constraint = token_program.key == &token::ID)]
    pub token_program: Program<'info, Token>,
    pub associated_token_program: Program<'info, AssociatedToken>,
    pub system_program: Program<'info, System>
}```
Mmm upon changing over to that, I'm getting an error I'm not finding here, in the doc, or on google at all
All works great now
Mmm yea the tooltips on the errors there / documentation on the combination of init_if_needed / associated_token wasn't quite clear to me, but you've been great ‚ù§Ô∏è
Baller
You don't need to do any init logic yourself for ATAs, just do `init_if_needed` + `associated_token::mint = ...` and `associated_token::authority = the_owner`
Probably just like TokenAccount::size or somethin
On another note (as I'm new and encountering all the delicious toys anchor has all at once), any chance there's a nice utility for space for an ATA?
Delightful! Thanks a bunch
Yeah, init_if_needed for ATAs works fine + is super convenient
(Also apologies if @ing is pass√© <3. Thanks for your tireless answers here :>)
<@!134416332509675520> I saw you recommended init for this use case but unsure if init_if_needed is acceptable.
Main reasoning being not forcing a second authorization popup to users for a getOrCreateATA precursor call
Is it alright to init_if_needed an ATA? I'm not seeing the vulnerability there :s. Assuming that's for custom program accounts rather than SPL
awesome this is exciting thank u ser
Ah, yeah, you probably want `decimal: u8`
either way, enough to get started, thanks again legend
That worked, awesome learned something new today. hmm, now im wondering if decimal needs to be BN (u64) or just u8 since max decimal is just 9? decimal is just needed for token transfers to make sure the right amount is being sent unless I just parse that from the frontend.
boooom
will try
makes a ton of sense lol
Cool cool
Yep
Yeah, map over it or whatever and convert those pubkey strings to actual PublicKeys
ok, so maybe JSON parse above, and then pass a new array with a new object with Pubkey type
Ohhhh
You need an actual PublicKey object in there, not a string
looks like there is only one other question around this in this discord and its kind of similar lol
I don't think JSON.parse is going to work on that string there
```
const sfbp = parseInt(sellerFeeBasisPoints, 10);
    console.log(configs);
    const walletKeyPair = loadWalletKey(keypair);
    const anchorProgram = await loadCoinFlipProgram(walletKeyPair, env, rpcUrl);

    let twdKey: anchor.web3.PublicKey;
    let fwdKey: anchor.web3.PublicKey;

    if (!treasuryWithdrawalDestination) {
      log.info("No treasury withdrawal dest detected, using keypair");
      twdKey = walletKeyPair.publicKey;
    } else {
      twdKey = new anchor.web3.PublicKey(treasuryWithdrawalDestination);
    }

    if (!feeWithdrawalDestination) {
      log.info("No fee withdrawal dest detected, using keypair");
      fwdKey = walletKeyPair.publicKey;
    } else {
      fwdKey = new anchor.web3.PublicKey(feeWithdrawalDestination);
    }

    const [myProgram, bump] = await getMyProgram(walletKeyPair.publicKey);
    const [feeAccount, feeAccountBump] =
      await getFeeAccount(coinFlip);
    const [treasury, treasuryBump] = await getTreasury(
      myProgram
    );
await anchorProgram.rpc.initialize(
      bump,
      feeAccountBump,
      treasuryBump,
      sfbp,
      JSON.parse(configs),
      {
        accounts: {
          payer: walletKeyPair.publicKey,
          authority: walletKeyPair.publicKey,
          feeWithdrawalDestination: fwdKey,
          treasuryWithdrawalDestination: twdKey,
          myProgram,
          feeAccount,
          treasury,
          systemProgram: anchor.web3.SystemProgram.programId,
        },
      }
    );
```
Can you show how you're trying to use it in JS?
Pubkey is fine
```
UnhandledPromiseRejectionWarning: TypeError: key.toBuffer is not a function
    at WrappedLayout.encoder (/Users/don/SourceCode/coin-flip/node_modules/@project-serum/borsh/src/index.ts:118:29)
    at WrappedLayout.encode (/Users/don/SourceCode/coin-flip/node_modules/@project-serum/borsh/src/index.ts:106:36)
    at Structure.encode (/Users/don/SourceCode/coin-flip/node_modules/buffer-layout/lib/Layout.js:1263:26)
    at /Users/don/SourceCode/coin-flip/node_modules/buffer-layout/lib/Layout.js:1113:25
    at Array.reduce (<anonymous>)
    at Sequence.encode (/Users/don/SourceCode/coin-flip/node_modules/buffer-layout/lib/Layout.js:1112:22)
    at Structure.encode (/Users/don/SourceCode/coin-flip/node_modules/buffer-layout/lib/Layout.js:1263:26)
    at WrappedLayout.encode (/Users/don/SourceCode/coin-flip/node_modules/@project-serum/borsh/src/index.ts:106:24)
    at Structure.encode (/Users/don/SourceCode/coin-flip/node_modules/buffer-layout/lib/Layout.js:1263:26)
    at BorshInstructionCoder._encode (/Users/don/SourceCode/coin-flip/node_modules/@project-serum/anchor/src/coder/borsh/instruction.ts:92:24)
```
can I still use Pubkey on that SPLConfig struct or does it have to be a Vec<u8> now? Running into this now
cool yea im trying that now, seemed to get me a little further
Ah, sorry, here you want `SPLConfig` to `#[derive(AnchorSerialize, AnchorDeserialize, Clone)]`, not `#[account]` (it's not directly an account, it's just going into the MyProgram account)
I think i see the issue tho
all the types seem to be present
hmm when calling the initialize function im getting the classic `IdlError: Type not found: {"type":{"defined":"SPLConfig"}}`

Im passing the json representation of the Vec<SPLConfig> into the params of the initialize function. Wondering if Im missing something. This is a sample im passing :

```'[{"mintKey": "BjKwSGuZFKjszgNPqRDYfkcvEi9kZvCHxP7PrewxAaoZ", "sellerFeeBasisPoints": 300, "burn": true, "decimal": 9 }, {"mintKey": "4Bzxa49sWP68uR7G1EN58doe4GMwnX4NmuSnTNMtN9NC", "sellerFeeBasisPoints": 500, "burn": true, "decimal": 9 }]'```
and the struct is 
```
#[account]
pub struct SPLConfig {
    pub mint_key: Pubkey,
    pub seller_fee_basis_points: u16,
    pub burn: bool,
    pub decimal: u64
}
```
Thats on the main program account obj
```
#[account]
pub struct MyProgram {
    pub spl_config: Vec<SPLConfig>
}
```
lol
thank u
https://tenor.com/view/dying-monkey-dying-gif-13123180
cool cool, ok going to try something, I added a few fields so im calculating if theres 20 configs, that would be around 864 üëÄ
signer of the txn thats transferring the token and the authority of the ata receiving the token
so basically the signer + authority of the ATA?
No, `#[account]` already uses borsh
authority of the ATA
Is the authority in spl_token transfer function the mint authority account?
Ok I see, so I wouldnt use #[account] since I need to deserialize with borsh? Or can I use AnchorDeserializer?
Each of those `Config` things would take 32 + 1 + 2 bytes using borsh, so a vec of them would take 4 (for the length of the vec) + N * (32 + 1 + 2) bytes.
It can be done, you just need to decide how many possible elements you want to support (at the moment you only get one shot to allocate account space, so you have to just pick a big-enough number)
When doing a transfer how do I set a return on this to see if it was successful or not>
actually I assume this cant be done?
That worked brooooü§òüèª
Ok
Try that
#[derive(Accounts)]
pub struct CreateVoter<'info> {
    pub registrar: AccountLoader<'info, Registrar>,

    #[account(
        init,
        seeds = [registrar.key().as_ref(), b"voter".as_ref(), voter_authority.key().as_ref()],
        bump,
        payer = payer,
        space = 8 + size_of::<Voter>(),
    )]
    pub voter: AccountLoader<'info, Voter>,

    /// The authority controling the voter. Must be the same as the
    /// governing_token_owner in the token owner record used with
    /// spl-governance.
    pub voter_authority: Signer<'info>,

    /// The voter weight record is the account that will be shown to spl-governance
    /// to prove how much vote weight the voter has. See update_voter_weight_record.
    #[account(
        init,
        seeds = [registrar.key().as_ref(), b"voter-weight-record".as_ref(), voter_authority.key().as_ref()],
        bump,
        payer = payer,
        space = size_of::<VoterWeightRecord>(),
    )]
    pub voter_weight_record: Box<Account<'info, VoterWeightRecord>>,
------------------------------------------
I would still be keeping the #[instruction(voter_bump: u8, voter_weight_record_bump: u8)] bit?
#[derive(Accounts)]
#[instruction(voter_bump: u8, voter_weight_record_bump: u8)]
pub struct CreateVoter<'info> {
    pub registrar: AccountLoader<'info, Registrar>,

    #[account(
        init,
        seeds = [registrar.key().as_ref(), b"voter".as_ref(), voter_authority.key().as_ref()],
        bump = voter_bump,
        payer = payer,
        space = 8 + size_of::<Voter>(),
    )]
    pub voter: AccountLoader<'info, Voter>,

    /// The authority controling the voter. Must be the same as the
    /// `governing_token_owner` in the token owner record used with
    /// spl-governance.
    pub voter_authority: Signer<'info>,

    /// The voter weight record is the account that will be shown to spl-governance
    /// to prove how much vote weight the voter has. See update_voter_weight_record.
    #[account(
        init,
        seeds = [registrar.key().as_ref(), b"voter-weight-record".as_ref(), voter_authority.key().as_ref()],
        bump = voter_weight_record_bump,
        payer = payer,
        space = size_of::<VoterWeightRecord>(),
    )]
    pub voter_weight_record: Box<Account<'info, VoterWeightRecord>>,
right that's the new way to do it
would anchor realize which bump goes where?
So here is the full line:
 #[account(init, 
        seeds = [b"seed_phrase".as_ref()], 
        space= YOUR SPACE,
        bump, 
        payer = user,)]
bump,
I get this error,  bump targets should not be provided with init. Please use bump without a target. How do I pass multiple bumps with init??
so on initialize, the Vec would be empty but when I call update, it would push new config structs to the vec or replace it entirely (if i cant simply push data to the vec)
If I want to add a Vec<T> on my program that I can push data to when calling an update handler (for example) what would be the best way to calculate size? T would be something like :

```
 pub struct Config {
  pub key: PublicKey,
  pub decimals: u8,  
  pub amount: u16,
}
```
Hello, I'm running into a strange problem here...I'm trying to deploy to devnet and I'm gettin an error: Error: Account allocation failed: RPC response error -32002: Transaction simulation failed: This account may not be used to pay transaction fees. when I'm on my localhost I do not have any problem. I've checked and there is a balance on my devnet wallet. I've searched around and I've found some answers where people have "Hard coded" devnet into the Anchor.toml file and that seems to have solved it. (no idea how that would help).. Any thoughts?
How does one convert the Buffer returned by `accountInfo.data` into usable data?
Works; thanks!
Just have to fetch it and see if there's an account there, e.g. `program.provider.connection.getAccountInfo(theAddress)`
How can I tell from Typescript whether an account has already been initialized, or otherwise prevent double-initializing?
uninstalling right after I get arch downloaded
and wanted to become a startup app
popups every 2 seconds and it wanted me to install chrome
holy shit bit torrent is annoying
that's a no bs completely from scratch os so it should be decent
might just go arch
I use a mac so I dunno üòõ My last computer ran pop os though (basically ubuntu), sure it's fine
which distro should I use this time <@!134416332509675520>
gaming
I liked using linux when I did, but poor gamign
it return me error: failed to compile anchor-cli v0.23.0 (https://github.com/project-serum/anchor#811a4cb3), intermediate artifacts can be found at /tmp/cargo-installGgaMcU
[23:20]
Anyone can help me ?
I might just bite the bullet and restart on a linux vm
Hello i have a problem when i try install anchor with this commands :  cargo install --git https://github.com/project-serum/anchor anchor-cli --locked
Pretty sure you're going to have to use the windows subsystem for linux stuff, WSL
damn
I dunno, sorry, I don't use windows so not sure what's up
this is wallet now
"E:/Boxez/gem-farm/GEML1jRuKGLgtegiBrLqFnKY43W2j1WbX9FWZsKRbgMg.json"

smh
Well, it's wrong üòõ
coz im used to it
You'll probably need a full filepath too
Why is it a \ and not a /?
that's the file path
But whatever you're trying to do there isn't valid toml
It's that funky \G in your wallet (not sure what that means)

Can you post your Anchor.toml then?
For future searchers, a possible fix for ```custom attribute panicked

help: message: removal index (is 0) should be < len (is 0)```

Make sure you're passing in your context to a program function if you're just stubbing stuff out?
I can't find B in that position in Anchor.toml

Not possible to skip that in solana
No matter what, you always have to pass in every account of interest from the client
no problem, I will try it now
(You need to pass in the associated token program too, but you also need to pass in the actual associated token *account*)
I was trying to create the token account for the program to receive the NFT
Are you doing this conditionally or something?
Also, just to double check‚Äîcan you not just skip all of this and use `init` + the `associated_token::mint` and `associated_token::authority` attributes?
You need to calculate that associated token address on the client and pass it in
Ok, I think the problem is that `associated_token` ought to be the actual token account, not the associated token *program*
how about this lol
Oh, sorry, I can't read ü§¶‚Äç‚ôÇÔ∏è
```
 let cpi_accounts = Transfer {
                    from: ctx.accounts.nft_token_account.to_account_info(),
                    to: ctx.accounts.vault_token_account.to_account_info(),
                    authority: ctx.accounts.nft_token_account.to_account_info(),
                };
                let cpi_context =
                    CpiContext::new(ctx.accounts.token_program.to_account_info(), cpi_accounts);

                anchor_spl::token::transfer(cpi_context, 1)?;
```
is that what you mean?
Ok, then how is that cpi_accounts variable defined? Are you actually passing all the relevant accounts?
Hi, I just did some search on the discord seems like that might be the problem , I have logged the address getting from the function and its did print out the the correct token address
https://solscan.io/account/Bo9Q6He7qzHoF2BXCBWZgeMK5xcM2K5VNQTTHRKUUDC7?cluster=devnet
That means you probably aren't calculating the associated token address correctly on the client
Can you show more of your code?
When running `anchor test`, 1/1 of my tests are passing, but .anchor/program-logs is empty. My function is literally just `msg!("Test");` What am I missing?
```no field `mint` on type `anchor_lang::prelude::AccountInfo<'_>``` any idea on this error that i'm getting after switching to v1.19.0? Anyway to get rid of this without deserialising?


//////////////////////////////////////////////////////////////////////////////////////////

for the program
will show you the key generated after the first build
solana address -k target/deploy/<program-name>-keypair.json
anchor keys list
hey, this is probably asked a lot, but how to know the address for declare_id when deploying to the devnet ?)
seems like soteria is better for non anchor programs because it mostly is checking unchecked accounts...is this true?

and anchor does a lot of this for you...or does it help w other things?
when we init an account with a dedicated struct
hey the sol dev, putting a #[derive(Default)] doens't work anymore we need to precise the space now with anchor 0.0.23
What do you mean? Not sure I understand your question
Hi does multiple programs in a single anchor contract repo generate multiple .so files in target/deploy from anchor build?
how do I transfer sol from token account who's owner is a PDA
also, when I use accountType.fetchMultiple, will it automatically set any account that is not of type `accountType` to null?
how can I fetch all accounts owned by a user, by modifying this line:
``` 
let response = await solbondProgram.account.accountType.all();
``` ? 

The documentations https://project-serum.github.io/anchor/ts/classes/AccountClient.html#all mentions a filter, but not sure if this is applicable here
I followed metaplex struct but it's not working  ü•≤ 
error: bump targets should not be provided with init. Please use bump without a target.
Kk sry. Not the issue I had then
only this
uhhh no there's no such thing
Is the final line of output an error about program address?
nope
seems like middle tests are not executing making this test failed. If you scroll up in console I think there would be some program logs
no program logs
just this
```
      AssertionError [ERR_ASSERTION]: The expression evaluated to a falsy value:

  assert.ok(poolWatermelonAccount.amount.eq(new anchor.BN(0)))

      + expected - actual

      -false
      +true
```

which i think means the test is not reaching the endpoint at all
what error you are getting in console ?
Like can we customize the candy machine to accept the other token ( other than SOL)
any idea on how can I take the NFT mint payment in some other tokens ?
`console.log()` them maybe?
what if i would like to check the output on successful tests?
they come up in the terminal itself.. on top of each failed test
i'm not seeing `.anchor/program-logs` after running `anchor test` . Any idea how to get these logs showing on each program run?
I console logged `firstUserRedeemable` and `secondDeposit`. (the params in endpoint calls)
both are similar bignumbers. but the endpoint is not being called at all in the failing test
```ts
    it("Exchanges second users Redeemable tokens for watermelon", async () => {
        secondUserWatermelon = await createTokenAccount(
            provider,
            watermelonMint,
            provider.wallet.publicKey
        );

        await program.rpc.exchangeRedeemableForWatermelon(secondDeposit, {
            accounts: {
                poolAccount: poolAccount.publicKey,
                poolSigner,
                redeemableMint,
                poolWatermelon,
                userAuthority: provider.wallet.publicKey,
                userWatermelon: secondUserWatermelon,
                userRedeemable: secondUserRedeemable,
                tokenProgram: TOKEN_PROGRAM_ID,
                clock: anchor.web3.SYSVAR_CLOCK_PUBKEY,
            },
        });

        poolWatermelonAccount = await getTokenAccount(provider, poolWatermelon);
        assert.ok(poolWatermelonAccount.amount.eq(new anchor.BN(0)));
    });
```
This test is failing
```ts
it("Exchanges user Redeemable tokens for watermelon", async () => {
        // Wait until the IDO has opened.
        if (Date.now() < withdrawTs.toNumber() * 1000) {
            await sleep(withdrawTs.toNumber() * 1000 - Date.now() + 2000);
        }
        let firstUserRedeemable = firstDeposit.sub(firstWithdrawal);
        userWatermelon = await createTokenAccount(
            provider,
            watermelonMint,
            provider.wallet.publicKey
        );

        await program.rpc.exchangeRedeemableForWatermelon(firstUserRedeemable, {
            accounts: {
                poolAccount: poolAccount.publicKey,
                poolSigner,
                redeemableMint,
                poolWatermelon,
                userAuthority: provider.wallet.publicKey,
                userWatermelon,
                userRedeemable,
                tokenProgram: TOKEN_PROGRAM_ID,
                clock: anchor.web3.SYSVAR_CLOCK_PUBKEY,
            },
        });

        poolWatermelonAccount = await getTokenAccount(provider, poolWatermelon);
        let redeemedWatermelon = firstUserRedeemable
            .mul(watermelonIdoAmount)
            .div(totalPoolUsdc);
        let remainingWatermelon = watermelonIdoAmount.sub(redeemedWatermelon);
        assert.ok(poolWatermelonAccount.amount.eq(remainingWatermelon));
        userWatermelonAccount = await getTokenAccount(provider, userWatermelon);
        assert.ok(userWatermelonAccount.amount.eq(redeemedWatermelon));
    });
```
This one is passing
GM folks. so one test is failing. but the weird fact is that there are 2 calls being made to the same endpoint in 2 different tests.. one is passing the other in failing
When I wanna deploy my program to mainnet, do I need to deploy it to my node?
for anyone interested: `new anchor.BN(program.account.yourAccount.accountField).toNumber()`
Got it
trying to read account data from client, it seems small numbers u64 are included raw in the BN array, but a large i64 (timestamp) comes out pretty scambled :/
How do you convert a BN back to a regular ts number?
because that's a solana tool which doesn't know about anchor concepts like the IDL
Why doesn't `solana program deploy` update the idl ü§î ?
alright, i'm trying to follow an anchor tutorial online but it's in an older version. I'm using latest version and running into issues with PDA and the breaking changes around bump. Anyone have a working example of using PDA with latest version of anchor I can take a look at?
<a:pogbanana:716423728203825172>  bullish on anchor!!!!

thanks <@!134416332509675520> üôÇ got my auction solana program up and running thanks to you:
‚ù§Ô∏è
please tell me there is a better way
For all the talk on how fast solana is, my unit tests are extremely slow (running with a local validator). Then I discovered commitment = processed and it got better but I still can't read a new account (like new NFT metadata) without having sleep(10 s) after the mint
I'm personally just funemployed atm and have a lot of free time to help on discords, but serum funds/employs other people
how is anchor funded? do u guys get grants from solana foundation?
nice job, you're the reason ive been looking fly for all these years
It's been a little while since I worked there but still friends with them
I used to be roommates with a bunch of people who worked there‚Äîone of them is the CTO and hired all of us as the first engineers haha
Hahaha üòÜ Yeah, I did
üòÆ
i shop there all the time
bro u used to work at grailed?
lmao
so maybe i just need to init it before with rpc
well that last constraint will never be true
im getting chewed up
this shit is wild
is there any step thru debugging with local testing
xD
Give it a rip
```
    #[account(
        init_if_needed,
        payer = seller,
        token::mint = item_mint,
        token::authority = seller,
        constraint = item_token_account.owner == seller.key() @ErrorCode::NotAuthorized, 
        constraint = item_token_account.amount == 1u64 @ErrorCode::AmountZero,
    )]
    pub item_token_account: Account<'info, TokenAccount>,
```
Can I have constraints still? Like this ^
Otherwise it just asserts that those other constraints indeed hold
It's just like the `init` attribute, but only inits if needed, yeah
```#[account(
        init_if_needed,
        payer = seller)]```

or do I need to do:

```
    #[account(
        init_if_needed,
        payer = seller,
        token::mint = <mint>,
        token::authority = <authority>,
    )]
```
üòÆ
There's also `init_if_needed` for this kind of situation
Possibly
so I have to do create ATA before calling my rpc function?
Account<'info, Whatever> expects an actual Whatever account, already initialized etc.
Ah, just because you use an ATA address doesn't mean there's an actual token account there
i dont understnad how something can not be a program account if you're deriving it from getATA or getProgramAccount functions
Is it possible Im generating associated token accounts wrong or something?
Just rebuild and deploy it again to be sure
Ah, sorry, hard to learn much there‚Äîbut if it works on devnet it's very likely that you accidentally deployed a stale .so file to wherever it's not working
Was this not useful?
(Usually doesn't really help much to box an AccountInfo)
Ah, Box currently doesn't work on AccountInfo, just Account
```
#[derive(Accounts)]
pub struct ExchangeWithTransfer<'info> {
    #[account(mut)]
    pub burn_token_acct: Box<Account<'info, TokenAccount>>, // token account with tokens to be burned
    #[account(mut)]
    pub burn_mint: Account<'info, Mint>, // mint of the token to be burned
    #[account(signer)]
    pub token_acct_owner: AccountInfo<'info>, // owner of the to be burned token acct
    pub token_program: Box<AccountInfo<'info>>, // SPL token prog
    pub token_mint: Box<Account<'info, Mint>>,
    #[account(mut)]
    pub escrow_token_acct: Box<Account<'info, TokenAccount>>, // escrow token account we are transferring out
    #[account(
        init, 
        payer = token_acct_owner, 
        associated_token::mint = token_mint,
        associated_token::authority = token_acct_owner)]
    pub receiver_token_acct: Box<Account<'info, TokenAccount>>, // token account we are transferring into
    #[account(mut)]
    pub global_tracker: Box<Account<'info, GlobalTracker>>, // global state to be updated
    #[account(mut)]
    pub exchange_info: Box<Account<'info, ExchangeInfo>>, // data acct where we store the mint to be transferred
    pub associated_token_program: Program<'info, AssociatedToken>,
    pub system_program: Program<'info, System>, // Solana sys prog
    pub rent: Sysvar<'info, Rent>,
}
```
That's some random other error, can you show me how you used Box?
hmm, what is the import i'm missing here?

```
Failed to resolve: use of undeclared crate or module `__client_accounts_box`
use of undeclared crate or module `__client_accounts_box`
```
If that doesn't work then you can try fancier things too
Just says "uh... ok stick this thing in the heap ü§û"
Yeah
That's just doing `<Box<Account<'info, ...>>`?
Out of stack space, can try maybe Box'ing some `Account<'info, Whatever>`s (easiest potential fix)
hmm, when I do that I now get:

```
Transaction simulation failed: Error processing Instruction 0: Program failed to complete 
    Program GpLZRedGz2uNoFXo24UxxfQivDvw3xSHzdGhTYFFKdSC invoke [1]
    Program GpLZRedGz2uNoFXo24UxxfQivDvw3xSHzdGhTYFFKdSC consumed 2505 of 200000 compute units
    Program failed to complete: Access violation in stack frame 3 at address 0x200003e60 of size 8 by instruction #16474
    Program GpLZRedGz2uNoFXo24UxxfQivDvw3xSHzdGhTYFFKdSC failed: Program failed to complete
```
and it works on devnet D:
i think
its weird cus non of the token accounts are correct
kk one sec
But post the actual error lol, not quite sure which one you're talking about
Yeah
i saw a bunch of people saying if declare_id is wrong then u might get non program errors
So why do you need to redeploy at all?
Surprisingly easy to forget to rebuild‚Äîif you skip that step then you end up just redeploying the *old* .so file
yeah but my initial deploy was the correct address
Yeah, you need to change it, *rebuild*, and only then redeploy
in `declare_id`
In the declare_id! ?
Like when u first deploy a program it might have the wrong address name so u redeploy
And not sure what you mean by always needing to redeploy ü§î
Easier if you post the full error
You'd have `associated_token::authority = your_wallet_that_you_passed_in`
Yep ^
You'd need to do the `associated_token::mint` + `associated_token::authority` attributes instead of `token::`
is there a way to initialize this with my walletPubkey as the authority?
Ok, right, that's an associated token address‚Äîa PDA
so I find the associated token account address, but it's not initialized
```
const nftATA = await PublicKey.findProgramAddress(
    [
      walletPublicKey.toBuffer(),
      spl.TOKEN_PROGRAM_ID.toBuffer(),
      nftExchangePubkey.toBuffer(),
    ],
    spl.ASSOCIATED_TOKEN_PROGRAM_ID
  );

let nftTokenAcct = nftATA[0];
```
Think I'm misunderstanding
I'm doing:
But why wouldn't you have the token account keypair?
Then you can't init a token account there
i don't have the token account keypair
You don't have to sign for the owner of the token account, you have to sign for the token account itself‚Äîfor its own address
The reason I'm redeploying is because I'm getting "not program account" errors. Do you always need to redeploy even if the address id in the rust code is correct?
Why wouldn't that work?
I'd use the SPL token program to create it, then pass it into my programs call
but if I want to init a token account that's owned by my wallet keypair (instead of the program), I can't do that via the anchor init syntax
You can, but you have to add the `seeds = [...], bump,` attributes so that anchor/your program can sign for the address
so if it's not a keypair, I can't create a token account like that
ah I see
In general though, you can alway check the generated IDL and see which accounts are expected to sign
Whenever you init an account in solana, at the end of the day its address needs to sign, either from the client if it's a keypair address or from within the program if it's a PDA
It signs for the wallet, not anything else
Not for receiverTokenAccount (is that a keypair address?)
doesn't phantom take care of that for you?
I am signing though
And you're initing a token account at a keypair address, so that address needs to sign from the client with the `signers: [...]` thing
imma just start reusing the same solana program address and switch executable code LOL
You don't want to specify space at all for the TokenAccount stuff
good lord
So, a 1.5 ish mb .so file would, yeah, be 20 ish sol
Yeah, rent exemption costs 7 sol / mb, and the upgradeable deployment process by default 2x's your original .so file size so you have room to grow
if I have:

```

#[derive(Accounts)]
pub struct ExchangeWithTransfer<'info> {
    #[account(mut)]
    pub burn_token_acct: Account<'info, TokenAccount>, // token account with tokens to be burned
    #[account(mut)]
    pub burn_mint: Account<'info, Mint>, // mint of the token to be burned
    #[account(signer)]
    pub token_acct_owner: AccountInfo<'info>, // owner of the to be burned token acct
    pub token_program: AccountInfo<'info>, // SPL token prog
    pub token_mint: Account<'info, Mint>,
    #[account(mut)]
    pub escrow_token_acct: Account<'info, TokenAccount>, // escrow token account we are transferring out
    #[account(
        init, 
        payer = token_acct_owner, 
        token::mint = token_mint,
        token::authority = token_acct_owner,
        space = 500)]
    pub receiver_token_acct: Account<'info, TokenAccount>, // token account we are transferring into
    #[account(mut)]
    pub global_tracker: Account<'info, GlobalTracker>, // global state to be updated
    #[account(mut)]
    pub exchange_info: Account<'info, ExchangeInfo>, // data acct where we store the mint to be transferred
    pub system_program: Program<'info, System>, // Solana sys prog
    pub rent: Sysvar<'info, Rent>,
}
```

and calling like so:

```
const tx2 = await program.rpc.exchangeWithTransfer(
    amountToBurn,
    amountToReceive,
    {
      accounts: {
        burnTokenAcct: burnTokenAcct.address,
        burnMint: burnMintPubkey,
        tokenAcctOwner: walletPublicKey,
        tokenProgram: spl.TOKEN_PROGRAM_ID,
        tokenMint: nftExchangePubkey,
        escrowTokenAcct: escrowedMakerTokens,
        receiverTokenAcct: nftTokenAcct, //nftTokenAcct.address,
        globalTracker: globalTrackerPDA,
        exchangeInfo: randomSelectionPDA,
        systemProgram: anchor.web3.SystemProgram.programId,
        rent: anchor.web3.SYSVAR_RENT_PUBKEY,
      },
    }
  );
```

Why am I getting:
```
Uncaught (in promise) Error: Signature verification failed
```
Lol
20 SOL to deploy <:LMAO:693902932709474341>
good thing i didnt try to deploy my own gemworks farm
So assuming nothing goes wrong, that temporary part finishes and you then get the sol back (even if it fails you can still get it back, just requires an extra command)
ouchies
No, it's because the deployment process actually temporarily uses that sol to store the new program code during the deployment process, can read more here: https://jstarry.notion.site/Program-deploys-29780c48794c47308d5f138074dd9838
is that cus the CLI tries to simulate and calculate costs?
probably my issue
ahh
Not much, though you annoyingly need to have roughly the original deploy cost in you wallet
You don't have to specify space at all actually, just do `token::mint = the_mint`, `token::authority = the_owner` etc. (or associated_token::)
on devnet it doesnt cost much
How much should it cost to update a solana program?
Does anchor use the deploy keypair automatically?
nbd just do the old model
SPL itself doesn't require it on latest
Need to pass in sysvar until anchor updates to v3 spl
```
declare_id!("5VzP....");
```
```
[programs.mainnet]
auction = "5VzP....."
```
Anyone know why when I deploy the mainnet and try again it tries to make a new program even though I've got the program address set?
what was your solution to this?
If I want to do:

```
#[account(
        init,
        payer = payer, space = ???)]
    pub receiver_token_acct: Account<'info, TokenAccount>, 
```
How much space does `init` a `TokenAccount` usually requier?
Can anyone have a look at this for me? https://discord.com/channels/889577356681945098/889584618372734977/956340459888861234
That's wild that msg'ing a pubkey costs 5% of the total compute budget üòÜ Damn
Ah, cool!
costs 200 vs ~11K when logging it with msg!
use the .log() function on Pubkey
Sanity check: you don't need to check a wallet's lamport balance so that is has enough for all the minutiae, the entire transaction will just fail if it would be overdrawn, yes?
mind if I dm you the code to see if we can make any optimizations?
Apparently converting pubkeys to strings is expensive
They actually can take a surprising amount unfortunately (I don't have great intuition though)
I am adding some print statements in my program - how much compute units does that take up?
Any easy tips/tricks to getting around:

```
index.browser.esm.js:7355 Transaction simulation failed: Error processing Instruction 0: Program failed to complete 
    Program GpLZRedGz2uNoFXo24UxxfQivDvw3xSHzdGhTYFFKdSC invoke [1]
    Program log: Instruction: ExchangeWithTransfer
    Program log: Burn mint account: 13KN77C3TFkFXYRbf39ZfTJAKBKX2nRKdH2UB1TqD396
    Program log: Token account to be burned: F8jC7HMDwwr2Qs1JgU6kLX57xSM6Ds3Ddw9D9yC3PfRw
    Program log: Token account owner: GFaWuwHEv7DPMP8VAZMrnHf1kDqSMEzWMf2iYwQH8ZJC
    Program log: Exchange Info mint address: 7KCD6vuYHXPuqn4N1CwnkYDHHpRvsGz9KfcGjLcB8T2G
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [2]
    Program log: Instruction: Burn
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 2632 of 137642 compute units
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success
    Program log: Token burnt, time to give them the NFT
    Program log: Mint account that we are transferring: 7KCD6vuYHXPuqn4N1CwnkYDHHpRvsGz9KfcGjLcB8T2G
    Program log: Transferring from escrow account: 89HmSEqVD72w8pxhAPQyVmrDHQVghiVx4sevWN8HA592
    Program log: To receiver token acct: A4YVmCqkdAWS1knQS1wEDZzLwRdcwkCWcf3mBdJMKAwh
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [2]
    Program log: Instruction: Transfer
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 2549 of 89883 compute units
    Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success
    Program GpLZRedGz2uNoFXo24UxxfQivDvw3xSHzdGhTYFFKdSC consumed 200000 of 200000 compute units
    Program failed to complete: exceeded maximum number of instructions allowed (200000) at instruction #33097
    Program GpLZRedGz2uNoFXo24UxxfQivDvw3xSHzdGhTYFFKdSC failed: Program failed to complete
```
`--skip-deploy` should only do what it says but I think it might also skip the local validator startup currently although that would be a bug
Does anyone use solnet (the C# library)?
Does skip-deploy also skips the validator anchor spins up, cause I was using anchor test --skip-local-validator alongside --skip-deploy and manuay deploying on local net
`anchor test --skip-deploy` (can run `anchor test --help` for more options)
hey, im testing my program on the localnet. If I make ```anchor test``` it deploys and tests everything, but it takes around 1-2 minutes. However, if I just change typescript test code (without touching program code) and run ```anchor test``` it again deploys program from scratch and again take around 1-2 minute. Im tired of waiting that long after changing even one line of code in tests. What can I do?
But it's still referencing the old one so I'll continue with what you're suggesting
Thanks I used solana program close
You can move/delete the existing keypair in `target/deploy`, and then anchor build will make a new one (then you annoyingly need to remember to update your declare_id! to match the new one‚Äîtry running `anchor keys list` to see what it looks like), and then *rebuild again*)
How can I change the program Id of a program?
thanks
oh wow worked
oh but it did not print log though, also it was always giving an error saying ``cannot read properties of undefined something fetch``
You're trying to init an account at an address that already has an account
This came after the earlier error got resolved
and i need to clear a bunch of them
I am using a linked list of accounts tho
Probably by using the `#[account(close = who_to_send_the_lamports_to)]` attribute
like clear its data and take whatever lamports it has
How do I "close"  a PDA account
thanks!
its a great tutorial, I will definitely recommend beginners
https://lorisleiva.com/create-a-solana-dapp-from-scratch/structuring-our-tweet-account
where is that chart from?
nice a new error 
```
Transaction error: TypeError: Cannot read properties of undefined (reading 'fetch')
```
got it
So if you want a max of 100 byte strings, you need 100 + 4
Yeah, it's *plus* 4 bytes for the length
okay yes I said it wrong
i remember seeing some chart ü§¶‚Äç‚ôÇÔ∏è
Usually a single character (usually, not always!) is 1 byte
Which is 8 bits
You measure space in bytes also
Why 4 bits per char?
Nope üòõ
also I was stuck on this and my actualy function for a week now and here I got a soln in a minute :)
i hope I made sense lel
50 chars == 50 * 4
1 char takes 4 bit
Sure
Why are you doing 50*4 ? What does multiplying by 4 mean?
okay trying once
buiild then deploy?
```
// Adding some useful constants for sizing properties.
const DISCRIMINATOR_LENGTH: usize = 8;
const PUBLIC_KEY_LENGTH: usize = 32;
const STRING_LENGTH_PREFIX: usize = 4;
// Stores the size of the string.
// 50 chars max
const NAME_LENGTH: usize = 50 * 4;
// 50 chars max
const USERNAME_LENGTH: usize = 50 * 4;
// 200 chars max
const BIO_LENGTH: usize = 200 * 4;
// 10 chars max
const RANKING_LENGTH: usize = 10 * 4;
// max around ~2500
const PROBLEM_SOLVED_LENGTH: usize = 4;
const ACCEPTANCE_RATE_LENGTH: usize = 4;
// max 5
const STARS_LENGTH: usize = 1;
const TIMESTAMP_LENGTH: usize = 8;

impl LeetCodeAccount {
    const LEN: usize = DISCRIMINATOR_LENGTH
        + PUBLIC_KEY_LENGTH
        + TIMESTAMP_LENGTH
        + STRING_LENGTH_PREFIX
        + USERNAME_LENGTH
        + STRING_LENGTH_PREFIX
        + NAME_LENGTH
        + STRING_LENGTH_PREFIX
        + BIO_LENGTH
        + STRING_LENGTH_PREFIX
        + RANKING_LENGTH
        + PROBLEM_SOLVED_LENGTH
        + ACCEPTANCE_RATE_LENGTH
        + STARS_LENGTH;
}
```
Just say 8 + 1000 for now
I was actually trying to do my other function with proper stuff but it kept failing so i did small
Heh, yeah, 8 + 8 isn't enough space üòõ
```
// Defined the structure of the LeetCode Account.
#[account]
pub struct LeetCodeAccount {
    pub owner: Pubkey,
    pub timestamp: i64,
    pub username: String,
    pub name: String,
    pub bio: String,
    pub ranking: String,
    pub problem_solved: i32,
    pub acceptance_rate: f32,
    // max 100.00
    pub stars: i8,
}
```
Can you post the actual LeetCodeAccount struct?
I can see a problem
Very unlikely that 8 + 8 is enough space for that account
```
    pub fn initialize(ctx: Context<Initialize>, bio: String) -> Result<()> {
        let profile: &mut Account<LeetCodeAccount> = &mut ctx.accounts.profile;
        profile.bio = bio;

        Ok(())
    }
#[derive(Accounts)]
pub struct Initialize<'info>{
    #[account(init, payer = author, space = 8+8)]
    pub profile: Account<'info, LeetCodeAccount>,
    #[account(mut)] // we are going to mutate the amount of money in their account.
    pub author: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```
Not an issue with your idl, it's with your rust code
okay wait
```
    {
      "name": "initialize",
      "accounts": [
        {
          "name": "profile",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "author",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "bio",
          "type": "string"
        }
      ]
    }
```
my IDL
Post some of your rust code for whatever account you're creating
i did not understand
Are you deriving Default or something?
oh
That error usually means you haven't allocated enough space
```
        try{
            await program.rpc.initialize("lol",{
                accounts: {
                    profile: baseAccount.publicKey,
                    author: provider.wallet.publicKey,
                    systemProgram: web3.SystemProgram.programId
                },
                signers: [baseAccount]
            });

            const account = await program.account.profile.fetch(baseAccount.publicKey);
            console.log("account:" , account);
        } catch (err){
            console.log("Transaction error:" , err);
        }
```
I keep getting this error, I am really not sure whats wrong.
I have checked my IDL million times, function too but :/
Please don't at-message unless it's urgent üôè
HI <@!501570363566587905> , how to to receive the payment inside a anchor program.

Use case : I want to build a merch store, which takes the payment in solana from user wallet while ordering
The only way to write data into an account owned by program X is to specifically ask program X to do it, so if you only provide one way to do it then that's the only way to do it
Nope, they'd have to go through that function
You don't need to activate anything for anchor-lang 0.18.2, just use `init_if_needed`
ty, but i cant enable that feature
I think it is already in prelude for the associated_token. init_if_needed you have to enable this feature in Cargo.toml first.
If I have a program that does the following:

```
pub fn randomize_exchange(ctx: Context<RandomizeExchange>) -> ProgramResult {
...
}

#[derive(Accounts)]
pub struct RandomizeExchange<'info> {
    #[account(
        init,
        payer = payer,
        seeds = [payer.key().as_ref(), burn_mint.key().as_ref()],
        bump,
        space = 100 // 32 * 2 to store accounts
    )]
    pub exchange_info: Account<'info, ExchangeInfo>, // data acct where we store the mint to be transferred
    pub system_program: Program<'info, System>, // Solana sys prog
    #[account(mut)]
    pub payer: Signer<'info>, // can only call from the payer who will be receiving the token related to the mint
}

#[account]
pub struct ExchangeInfo {
    pub mint_address: Pubkey,
}
```
Is there anyway for someone to construct an `ExchangeInfo` account without calling `randomize_exchange`? I don't have any other program instructions that initializes `ExchangeInfo` accounts
hey, where can I import initi_if_needed + associated_token from ?
thank you in advance
can you share an example code with me
yes, you can.
if your pda is funded you use invoked_signed to sign from the program


//////////////////////////////////////////////////////////////////////////////////////////

Hey guys any idea what this pools address is in the mango markets ido-frontend constants?
Dam thought that might of been it, but same error. Will continue the glass chewing
I just remembered this one. Great list https://github.com/avareum/awesome-solana <@709556204514574386>
no actually I think this is probably it. make sure anchor -V returns the same version as your crate is using
Yeah that was my original thought, so that shouldn't be triggering this init needs space error
or wait sorry, I got confused
most of the time this means your anchor cli is not updated
No, account(zero) expects it to be previously init'd
I could just initialize it within the program and see if I still get the error
Right got you. But I am calculating required space manually anyway and passing it in. So thought it should work. 

Unless it is because the zero account that I am initializing now doesn't know how much space it needs because the Default space isn't working any more?
Anchor got rid of the Default space thing (it's just super error prone and confuses beginners‚Äîif you really want to keep using it though it's pretty simple to do something analogous yourself)
Yeah all the inits that aren't TokenAccounts have space allocated. The only other thing I have is I pass a #[account(zero)] in and initialize with a separate instruction. 

But all of this was working fine on v0.22.1. Is there something about different about the latest version that is stricter on syntax? I thought previously providing space for a custom struct wasn't even specifically necessary if you included #[derive(Default)]
escrow, adding the other to my list üëç
great, thanks!
Yeah, don't need to add space to TokenAccount inits. Are you 100% positive that you aren't missing some other init though?
No, an UncheckedAccount is basically already just an AccountInfo (it's just a wrapper type, to give it a new name)
I have a program that is building fine on anchor v 0.22.1, but when I upgrade to 0.23.0 and try build it gives this error: 

```thread 'main' panicked at 'Code not parseable: Error("space must be provided with init")', lang/syn/src/idl/file.rs:352:58```

But all my inits have space provided, besides the TokenAccounts that I initialize, which if I try add a space, I get another error:

```thread 'main' panicked at 'Code not parseable: Error("space is not required for initializing an spl account")', lang/syn/src/idl/file.rs:352:58```

Anyone have a similar issue on v0.23.0?
is it expensive compute unit wise to convert an `unchecked account` to an `account info`?
oh hell yes. Thank you <@!347689664855015424>
https://lorisleiva.com/create-a-solana-dapp-from-scratch
What is lorisleiva? Paulx I am aware of but I'd like to learn more as well.
Have you gone through Paulx escrow and lorisleiva?
If they aren't PDAs those addresses would need to have signed from the client
Within your program you can only add signatures for PDAs derived from your program (that's what `invoke_signed` is for)
How to add more signatures to a CPI? I am having a creators arrays. Want to add multiple creators verified to the create_metadata_accounts_v2 instructions.
aight will do, thx!
Think you can search the anchor repo for examples (I can't remember the syntax)
assuming I have an object which has the owner's public key stored as part of the object (first 32 bytes)
No easy way to filter on the seeds for the address, no
also I guess my next question would be, how do I use the `MemcmpFilter` https://project-serum.github.io/anchor/ts/modules/web3.html#MemcmpFilter if I want to filter out the results
or is this some NP hard stuff where we cannot filter by the owner from the PDA
is there an easy way to add a filter that the owner pubkey must be part of the seed?
All accounts that the program owns (of that account type)
does the program ... fetchAll fetch all the accounts for a given usr, or literally all the accounts that this program owns?
best resources to continue learning? books / blogs / links? I've gone through the solana and anchor docs but want to continue reading more. So much I still don't understand and made everything "click"
Why is used as_ref() on the seeds on the PDA constraint? I understand is a method to convert something as a reference, but I don‚Äôt fully understand that
No I said I want to port solidity code to solana program in structural way
There's a documentation page somewhere but I can't always remember how to get to it from the main rust page and I can't seem to get it to pop up from a Google search
I still have trouble finding the official list of anchor errors
what tools you're using for to deploy Solidity code on solana Blockchain network?  <@!516253767314702346>
What things I need to keep in mind if I want to port a simple solidity smart contract to solana program like in solidity numbers are int256 here i64/u64. How the structure changes for libraries and unchecked block of code. If anyone can explain me in detail.
I meant having programs/contract1 and programs/contract2 in the same repo, I resolved it no worries. It was easy, just need to change Cargo.toml properly and then it creates contract1.so and contract2.so in target/deploy on anchor build
<@!784287013863948288> you can read about lifetimes here
https://doc.rust-lang.org/rust-by-example/scope/lifetime.html
Good day! When using `#[interface]` procmacro, whenever you want to implement it, all examples defined state on which an interface is going to be implemented like this
```
    #[state]
    pub struct Protocol;

    impl<'info> Interface<'info, ContextProtocol<'info>> for Protocol {
```
However, `#[state]` procmacro is marked deprecated. With what can I replace it then?
why we use `<'info>` on some structs and some struct are without `<'info>`
What is meaning of #[derive(Accounts)]
`Example: 
#[derive(Accounts)]
pub struct Increment<'info> {
    #[account(mut, has_one = authority)]
    pub counter: Account<'info, Counter>,
    pub authority: Signer<'info>,
}

#[account]
pub struct Counter {
    pub authority: Pubkey,
    pub count: u64,
}`
Does using a PDA make it that anyone can invoke it? If I want to be the only one able to invoke the program should I not use a PDA?
I can't run `anchor deploy`, my program is too big. Any recommendations?
i can't run `anchor deploy`, the txn keeps failing :/
here is the screenshot of the test validator running
and i need to run `solana-test-validator` in the `~` directory right ?
even i have the same error, but the test validator does run for me. but i still do get the error
https://book.anchor-lang.com/chapter_5/anchor-toml_reference.html#testvalidatorclone
[[test.validator.clone]] in Anchor.toml
mainly the `-c` option.
is there an anchor way to do this in the config? ```solana-test-validator -q -r -c ALP8SdU9oARYVLgLR7LrqMNCYBnhtnQz1cj6bwgwQmgj H6ARHf6YXhGYeQfUzQNGk6rDNnLBQKrenN712K4AQJEG --url https://api.mainnet-beta.solana.com```
cool cool - thanks for clearing it up!
Yes thats correct
yeah I get that, but in practice my assumption would be that the end-user wouldn't be expected to manage the account they pass into the program. as opposed to using a PDA where the user's pubkey can be one of the seeds so you can always retrieve data associated with them
regular accounts are persistent too, any account where the rent for it is payed will stay on chain
ok makes sense. so my understanding is that reg accounts are effectively temp buffers and PDAs are persistent
Hi sorry if its a silly question but what is the elliptic curve solana uses to derive its private keys? and how exactly is the pubkey/privkey calculated from the elliptic curve. i suppose which curve in particular and what does the pubkey represent in relation to the privkey.

Also, what do the seed phrases have to do with pub & privkey? I was under the assumption privkeys are some base number and pubkeys is like discrete log of that base.
PDA's are stored on chain as long as the rent for them is payed, which you can usually handle in creation
i think...
yeah I think PDAs are what I want then because if local storage is reset then the user loses their data
You can store these keypairs locally to access the program if thats what you mean, otherwise PDA's can be handled by lookup based off of what you are storing.
hi im a bit new to solana so have a noob question: since u have to pass in accounts to programs to handle data, accounts are basically key pairs? so if a user is passing in an account to hold their data, do they have to keep track of that key pair or else lose their data? or does the account the user pass in automatically becomes associated with the user and they can access it other ways?

like for the counter example on github, the vote account is created with the web3 client and passed into the vote program. but after that client is finished, you would no longer have access to that account, right? so do u actually just want to use PDAs when storing data a user expects to access in the future?
Does solana not take Hashmap types? Can't seem to get it to recognize it in the idl
I was looking for it too <@!326107472098099201> Thanks üôÇ
<@!689110395406909462> found it here
https://docs.rs/solana-sdk/latest/solana_sdk/macro.pubkey.html
ah, makes sense
??
i'd guess its a solana sdk macro not an anchor one

wait I can't find the macro
oh i didn't know there was a macro. very helpful
`Pubkey::from_str("asdasdfasdf").unwrap()` + `use std::str::FromStr;`, or if the string is static you can use the `pubkey!("asdfasdf")` macro
ok, I found it
Hi, is there a way determine an account size in  bytes?
I'd like to use `dataSize` option on my filter by I have hard time to calculate the account size in bytes.
And another question, when do I have to worry about rent? Every time I create a new account?
I assume I can't just do `Pubkey::new(&pubkey_string.to_bytes())`, or can I?
how can i create a pubkey const from a string containing the pubkey? I only see methods for bytes --> `Pubkey` struct
Hi ! I found a tutorial and I have a question. 

Why here we use the dereference * ? ctx is a reference ? Same for the author, why use * for the key ?
Hi, is there a nice way to manage a fixed size string in an account state?


//////////////////////////////////////////////////////////////////////////////////////////

only anchor test seems to start up the correct validator w/o doing some work inside anchor repo
i tried this and only get invalid block hash
Can I run anchor test on one specific program in the dir. Like I can for anchor build e.g.

```anchor build --program-name <program_name>```
Hey friends, what is the best way of changing account structure (or just extending) with  backward compatibility? Is there a best practice for it discussed somewhere? I just want to add 1 more field and change the logic in an instruction.
that sounds cool, i've definitely seen some people asking for it
ah yes, i see the Test.toml files
you have a dir with .ts files for each suite and a custom validator config for each suite
what i meant is, does it treat every .ts file in a folder as a separate test suite / runs a new validator for it
every *.ts file?
up to you!
what distinguishes one test suite from another?
startup one before each suite and then use a new one for the next
new validator for each test suite
separate validators?
what does that mean actually?
interesting but no, we're not trying to use separate validators for each test. Just to run different sets of failing tests
https://github.com/project-serum/anchor/pull/1681
just fyi. before you start building a lot of testing infra yourself, if your goal is to have separate validators, 0.24.0 will come with support for that
awesome, thanks!
anchor run <name>
nothing except `anchor test` works
```
[scripts]
test-long = "yarn run ts-mocha -t 1000000 tests-long/*.ts"
test = "yarn run ts-mocha -t 1000000 test-redeem/*.ts"
testNo = "yarn run ts-mocha -t 1000000 test-buy-no/*.ts"
```
i've tried adding other test scripts but it doesn't recognise them
how to run different test scripts in Anchor.toml?
Ok right so as the slothashes sysvar is too big to deserialize, you would not actually be able to use it in this fashion. I am just passing it through as an unchecked account, and checking its id is as expected within the program. Then borrowing the data as before and all is working as expected
Actually get this error if I try to use the slothashes sysvar in testing:

```Error processing Instruction 0: Unsupported sysvar```

Which has had a few explanations here, looks like the SlotHashes is too big too deserialize, so have to do it within the function I believe
Unless the types are misleading here, you don't need to do any deserialization (thought tbh that sounds weird to me and makes me wonder if this is actually how you're supposed to use this thing)
Yeah wait I realised its a bit different after getting the vector
You already have an actual read-to-go Vec here, no borsh stuff
What is `data` here?
So as I am not accessing a vector now, just a SlotHash type, this would change to :
```let most_recent = array_ref![data, 8, 8];```

Correct? As I drop the 4 bytes for the vector
Thanks! Will try that
So you could just do `recent_slothashes[0]` (it acts like a vec)
I haven't tried using SlotHashes before, but if you jump to source on it you'll see that it's actually just a wrapper around a Vec<SlotHash>
For now I have just updated the call to this:

```
    #[account(constraint = recent_slothashes.key() ==     sysvar::slot_hashes::ID @ MyError::IncorrectSlotHashesPubkey)]

    pub recent_slothashes: UncheckedAccount<'info>
```

Will see if it works
Trying to update my code from getting recent blockhashes to using the slothashes sysvar. When I try running this code:
```
        let data = recent_slothashes.data.borrow();
        let most_recent = array_ref![data, 12, 8];
```

I get this error:

```
no field `data` on type `&anchor_lang::prelude::Sysvar<'_, anchor_lang::prelude::SlotHashes>`
```

I am passing that recent_slothashes account in the program like this:

```pub recent_slothashes: Sysvar<'info, SlotHashes>```

Anyone know I can get the data out of the SlotHashes sysvar? Or can I just keep using the recent blockhashes sysvar?
Creating an account ultimately needs to talk to the system program, so you need to pass in the system program as an account
I think an easier way to think about it is that 1) at the end of the day, *every single account* that the transaction needs, needs to be passed in from the client, and 2) CPI'ing to a program requires access to that program's account, so you  have to pass it in from the client too!
So, to clarify, to initialise an Account from a CPI, it is necessary that the instruction (program layer 0) that initialises the Account of another program receives as argument the SystemProgram Account from the client (ts test), the Account belongs to the program (layer 1)
okey ty üôÇ
```
pub system_program: Program<'info, System>,
```
Not possible to convert a Pubkey to an AccountInfo dynamically like that (solana just doesn't work that way)
Yeah, you need to pass it in as an account from the client
You can provide the system program in instructions
How can I include the system_program on the context via CPI?
Would have been crystal clear if they had just said "compute units" instead of instructions üòõ
Yeah‚Äîkind of a funny log, in keeping with solana's tendency to use names that just aren't quite right lol
so yes
globally as well as in my dependencies
Yes
Are you sure you have installed the deps, including `typescript`?
‚òùÔ∏è
trying to test this, able to deploy succesfully
https://github.com/blockworks-foundation/voter-stake-registry
anchor test
What command are you running?
What am I doing wrong?
Hey, facing this error:
[ERROR] Cannot find module 'typescript'
Require stack:
- /Users/abhinavsharma/.npm/_npx/3c06c7c2e1894b1b/node_modules/ts-node/dist/index.js
- /Users/abhinavsharma/.npm/_npx/3c06c7c2e1894b1b/node_modules/ts-mocha/src/index.js
oh, is that just running out of CU?
What does this mean  
> 
> `Program returned error: exceeded maximum number of instructions allowed (91498) at instruction #140274"`
I think I get it, thank you
You're saying, "give me the bump for the `user_stats` account"
That `"user_stats"` string is actually referring to the name of the account in the derive(Accounts) struct (so, here it's `user_stats`)
Doesn't the handler function also need `user.key()`?
But then in the handler function it says
```user_stats.bump = *ctx.bumps.get("user_stats").unwrap()
```
Hi, a question about PDA section (PDA hashmaps subsection) in the book:

Seeds for the user_stats account are defined like:
```seeds = [b"user-stats", user.key().as_ref()], 
bump```
my code
```
            await program.rpc.initialize("lol", {
                accounts: {
                    profile: baseAccount.publicKey,
                    author: provider.wallet.publicKey,
                    systemProgram: web3.SystemProgram.programId
                },
                signers: [baseAccount]
            });

            const account = await program.account.leetCodeAccount.fetch(baseAccount.publicKey);
            console.log("account:", account, baseAccount, baseAccount.publicKey.toBase58());
```
how to get transaction id of a transaction that just happend?
privileges = whether theyre a signer or not, caller = master program, callee = puppet progran
Im trying to get involved. Any projects looking for interns? Shoot I would love to just be a fly on a wall for a good team  to see how things are made and how teams work. Bonus if you challenge me with a project.
On the CPI section of the Anchor book it says

```
CPIs extend the privileges of the caller to the callee.
```

Could someone clarify what it means when it says "privileges" and what the "caller" and "caller" are referring to?

I'm unsure if its referring to the Puppet Master Program, Puppet Program, Puppet Account, or User.
Hi Friends. I am trying to use PDA seeds to create an account. Somehow I have tried everything still I am getting error msg: 'The program could not deserialize the given instruction'. Not sure what wrong I am doing. Please advise. Following is my code. 
```#[program]
pub mod referal {
    use super::*;

    pub fn initialize(
        ctx: Context<Initialize>,
        bump: u8,
        refree: Pubkey,
        seed: String,
    ) -> ProgramResult {
        msg!("Seed: {}", seed);
        let base_account: &mut Account<BaseAccount> = &mut ctx.accounts.base_account;
        base_account.bump = bump;
        base_account.refree = refree;
        return Ok(());
    }
}

fn seed_bytes(seed: &str) -> &[u8] {
    msg!("Seed: {}", seed);
    seed.as_bytes()
}

#[derive(Accounts)]
#[instruction(bump:u8, seed: String)]
pub struct Initialize<'info> {
    #[account(
        seeds = [seed_bytes(&seed).as_ref()], 
        bump, init, payer = creator, space = 41)]
    pub base_account: Account<'info, BaseAccount>,
    #[account(mut)]
    pub creator: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[account]
#[derive(Default)]
pub struct BaseAccount {
    pub refree: Pubkey,
    pub bump: u8,
}```
Its a bug with the renaming the program. I fixed it by restarting the entire project.
Any idea <@!134416332509675520> ?
ty

Ctrl-C
how do I stop the validator....just ran it
just anchor test
How are you running the solana validator? Did you do `solana-test-validator` etc., or just `anchor test`?
transaction issue...
now a new error. holy crud
LOL
damn you camels
More üê´ errors, it's `systemProgram: SystemProgram.programId`

lol
its a different error now
wait
i did that too....didnt change. let me try again
Do `anchor.workspace.Calculatordapp`
That still has lowercase üòõ

The issue is that your `program` variable is undefined
Don't think so no, can you post the js code again?
noticed the name
could it be the keypair?

What's the full error?
test fails still. here is the toml
let me see
ohhhh that could be it
Changing that #[program] names will also require making the same change to your Anchor.toml
let me see if that works
Ok, then you'll have to do `anchor.workspace.Calculatordapp` (anchor isn't doing anything fancy, just camelcasing)
i renamed some stuff

hmmm let me see
So no
Your screenshot above says `calculator_dapp`
is it auto seperating it somehow?
calculatordapp is just the name of the program. I just made it a single word....
Yeah, JS code tends to expect CamelCase, so anchor uses it (even if it's kind of annoying/dumb)
is the spelling the issue?
appreciate you
let me see
Probably `const program = anchor.workspace.CalculatorDapp`
Anyone know how to fix this error?
I am just getting my hands dirty with Solana programming. Bear with me. üòÑ
Latest versions of anchor have switched to saying `Result<()>` instead of ProgramResult, but even the latest anchor version can't implement that `Create` thing for you üòõ
Ah, yeah, if you no longer have a keypair, then you can just rerun anchor build and you'll get a fresh one, and subsequent deploys will use it
Any help would be greatly appreciated.
Im so confused lol
does anyone know why I am getting these errors?
hey everyone so i‚Äôve been trying to work with PDAs & get a complete understanding of implementing them and i‚Äôm currently stuck on trying to execute this functionality where we can use a value from another account for the seed of the PDA. 

this picture is from Anchor‚Äôs twitter and I‚Äôve tried implementing the same thing, however I‚Äôm currently getting an error <address> ‚Äúsigner privelege escalated‚Äù. I previously i‚Äôve learned this error occurs when the findProgramAddress() pda in ts does not match the one defiend in Rust.

does anyone know how to properly use the findProgramAddress() function with types such as u8, u32, or u64? much thanks appreciated
For example I have an account which are PDA's of the program and want to find the current players account
Does anyone know how to find a specific PDA in the rust code
Would deleting the old keypair file and running `anchor build` fix it, generating a new keypair file?
(Which gave me an error when I tried to use that, making it clear that I should have a new keypair for the new program ID).
To what? The only file I have that has the same format is `id.json`.
Change the keypair in target/deploy
I successfully deployed a program but, thinking that something was wrong with my keypair when the devnet faucet was down, ran `solana-keygen new`.  Now I'd like to deploy a fresh copy of that program, under a new program ID. I tried changing the string in the ` declare_id` macro slightly, but it still thinks I'm trying to update the old program. What else do I need to do here?


//////////////////////////////////////////////////////////////////////////////////////////

`.toTwos` is saying that it's trying to use BN's method to convert to "two's complement" (how negative numbers are represented in bits/bytes)
Yep, that's right üëç
^ nvm, `new anchor.BN(0)` seems to work, lmk if that doesnt sound right
any tips on how to convert a js `Number` to rust `i64` from mocha tests? when i pass in `0` to a parameter that expects type `i64` i get this error: 

```
TypeError: src.toTwos is not a function
      at BNLayout.encode (node_modules/@project-serum/borsh/src/index.ts:58:17)
      at Structure.encode (node_modules/buffer-layout/lib/Layout.js:1263:26)
[..]
```
Box
```throw new Error('bad secret key size');
    ^

Error: bad secret key size
    at Function.nacl.sign.keyPair.fromSecretKey (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/Honey-IDO/honey-ido-pool/node_modules/tweetnacl/nacl-fast.js:2320:11)
    at Function.fromSecretKey (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/Honey-IDO/honey-ido-pool/node_modules/@project-serum/anchor/node_modules/@solana/web3.js/lib/index.cjs.js:5556:50)
    at getKeypair (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/Honey-IDO/honey-ido-pool/cli/index.js:31:47)
    at setProvider (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/Honey-IDO/honey-ido-pool/cli/index.js:46:27)
    at Object.<anonymous> (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/Honey-IDO/honey-ido-pool/cli/index.js:55:1)
    at Module._compile (node:internal/modules/cjs/loader:1101:14)
    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)
    at Module.load (node:internal/modules/cjs/loader:981:32)
    at Function.Module._load (node:internal/modules/cjs/loader:822:12)
    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)```
thanks for the help. knowing there's no codegen was helpful
```const fs = require("fs");
const anchor = require("@project-serum/anchor");

const account = anchor.web3.Keypair.generate();

fs.writeFileSync("./keypair.json", JSON.stringify(account));```
The file path is correct idk why it's throwing this error
Hey guys (<@!134416332509675520> ) I  created a keypair using anchor.web3.keypair.generate() but my program said Error: bad secret key size what could this mean potentially?
I tried to run the test and it actually worked but just gave an error in vs-code. I think it was a vs-code issue, i restarted it and it went away.
I'm confused why that would say 'NewMethod' and not `newMethod` or something like that
Can you literally show me a screenshot?
Property 'NewMethod' does not exist on type 'RpcNamespace<MyProject, {
Could you show me a screenshot or whatever of the actual error?
I'm using program.rpc.methodName where const program = anchor.workspace.MyProgram as Program<MyProgram>
If the IDL is really updated than the ts stuff should update automatically (it works by reading the IDL file‚Äîthere's no actual codegen at all)
Are you definitely using the updated IDL in your tests?
I see my updates in the IDL, but when trying to write the tests in ts* it doesn't recognize the new method i just added
Hey, I wanna get into solana smart contracts. Should I learn Rust or Anchor ?
What specifically isn't working?
All anchor generates is the IDL itself, it doesn't actually generate any typescript code
<@!134416332509675520> is there a command (or workaround) to regenerate the typescript that is derived from the IDL? I know it usually happens automatically when i run anchor build/deploy/test but sometimes it doesn't seem to work.
i think the problem with storing data in arweave is (afaik) you can't access that in your program
got it, so in general it's much cheaper to store data in arweave and on chain just store a reference to that right?
is there a command to regenerate the typescript that is derived from the IDL? I know it usually happens automatically but sometimes it doesn't seem to work.
You have a hard constraint that accounts can store 10mb at absolute max (accounts that live at program-derived addresses can only store 10kb). Besides that the constraint is just that storage on-chain costs on the order of $1/kb (bit less at the moment, but close enough), which adds up very quickly.
never mind, this helped me to understand that "basic-2" is actually what I was looking for: https://youtu.be/FmdPAwsqJC4?t=2435
Hi, I have a hard time understanding how to secure the modification of Accounts. As far as I can tell from the two example projects "basic-1" and "basic-2" both are insecure because all I need to know is the pub key in order to modify an account. I would expect that there is a check for the signer of a transaction and then only modify an account if the signer is the owner (of course the program is the real technical owner) of the account. Am I missing something?
state is just an account under the hood. but #[state] is very deprecated and we should just remove/replace that example
is there a general rule for how much data you should store in an account vs when to move it to something like arweave?
I have a question about example "basic-4" from the anchor repo

Can someone explain why the  #[state] can be under #[program] and can have a "count" that can be incremented?  I thought "state" had to be on a separate account and that programs don't hold state. 

```
#[program]
pub mod basic_4 {
    use super::*;

    #[state]
    pub struct Counter {
        pub authority: Pubkey,
        pub count: u64,
    }

    impl Counter {
        pub fn new(ctx: Context<Auth>) -> anchor_lang::Result<Self> {
            Ok(Self {
                authority: *ctx.accounts.authority.key,
                count: 0,
            })
        }

        pub fn increment(&mut self, ctx: Context<Auth>) -> anchor_lang::Result<()> {
            if &self.authority != ctx.accounts.authority.key {
                return Err(error!(ErrorCode::Unauthorized));
            }
            self.count += 1;
            Ok(())
        }
    }
}
```

https://github.com/project-serum/anchor/blob/master/examples/tutorial/basic-4/programs/basic-4/src/lib.rs
Not sure how complex I can get or if I would want everything running directly on the blockchain. For example, do I need to store tickets metadata on chain, or can i integrate aerweave to hold this data and limit rent burdens
also should i be passing String arguments here. For example if I want a user to see a welcome message then be asked a question?
is it ok to structure anchor code this way if you pass more than one argument?
Sure (I think I'm just not quite sure what you mean‚Äîhappy to look at an example though)
Can send an example your way if you‚Äôd like
I wrote my own trait for it. Just constructs an instance of the underlying struct given an account.
Can you say more? Not quite sure what you want to do
Is there a way to manually construct an Account from an instance of a struct with the account macro?
Hey guys, been going through all the chat history - any resources for learning how to send SPL tokens to an account ?
hey everyone üëã , brand new to anchor and currently learning about account constraints. 
i understand that `has_one` will ensure that the `target_account` fields match (one pub key), but i was wondering if there was a similar constraint that could apply to multiple keys? for example, suppose i wanted to create an account with a vector of public keys that could modify the account (i.e., any of the listed public keys could make certain txs). would it be better/possible to handle in the business logic?
Since if you already deployed the program the BPF Upgradable will use the new idl
Rerunning anchor build and anchor upgrade
Yea you can try deleting the target folder
Still doesn't work. Do I have to remove the .so file from `target/deploy` so `anchor build` generates a new one?
`anchor upgrade`
Brain is moving slow today, figured this should be a quick one. 
If an SPL token has anything other than 9 decimals, (1-8) whats the quickest way to calculate the actual amount you should be passing to the spl:transfer CPI? Either the amount gets passed in as u64 or calculate it in the contract if you are given the decimal values, but wondering what the actucal calculation would look like for like 5 decimals
(amount).mul(1_00_000) for example?
I removed an argument from one of my instructions and ran `anchor build` and `anchor deploy`, but for some reason that argument is still expected. Am I missing a step somewhere?
correct. `run` will only run your script. does almost nothing else. it only injects some env variables into the script


//////////////////////////////////////////////////////////////////////////////////////////

The you'll have to just yank the lamports manually, with `try_borrow_mut_lamports` (try searching discord, many examples)
its the executing program, not the system
But yeah, it's just a regular lamport transfer
Possibly, it depends on which program owns the account
is there a way for me to transfer the rent-exemption lamports out of an account then?
ok thank you
I guess so (not totally sure what you're situation is, but yeah, in solana there's no way to get around having to pass in the accounts you care about)
so i have to make a transaction then fetch the data then make another transaction all from the client?
Nope
i have an account that stores the pubkey of another account, is there a way to pass only the first account and modify many accounts in the same instruction?
What do you mean? You can do lots of CPIs if you want
Nope, have to pass in any accounts you care about from the client
or is there a way to get an Account struct from a pubkey within a rust instruction
is there a way to call many instructions within another instruction
If anyone finds this thread later, someone in the Solana discord responded that this could be a good use of PDAs, with the PDA storing necessary state info
unless you mean the tictactoe/puppet ones, no
Have you read through the anchor /examples and /tests?
any more intermediate resources
what should i do after i read the book
https://project-serum.github.io/anchor/tutorials/tutorial-2.html#defining-a-program
Any examples you can point me to? I think I have seen an owner constraint before...gotta find that
Write a constraint, or something that makes that owner sign the tx, etc.
Then you'd have to enforce that in your program
yoda
I want to see that way...master yod
So this is your program's fault lol, not the PDA's fault
If you don't want it to accept stuff from any wallet, you would need to write your program in such a way to enforce that üòõ
I made Spl governance the owner, and wanted only that to be able to edit the account
How are you expecting it to work?
Yep!
It just accepts my instructions from any wallet
You're init'ing an account there, yeah
```declare_id!("F8nQoxzzpdxyZy9EcK8yoPiEZHjYdixWhPUe4xaVwoHd");

#[program]
pub mod articlepublishing {
    use super::*;
    pub fn initialize(ctx: Context<Initialize>, publisher_account_bump: u8) -> ProgramResult {
        ctx.accounts.publisher_account.bump = publisher_account_bump;
        ctx.accounts.publisher_account.author = *ctx.accounts.author.key;
        msg!("Found bump {} & key {}",publisher_account_bump,*ctx.accounts.author.key);
        Ok(())
    }

    pub fn publish_article(ctx: Context<PublishArticle>, article_uri: String, draft_account: Pubkey) -> ProgramResult {
        let article_acc = &mut ctx.accounts.publisher_account;
        article_acc.articleuri = article_uri;
        article_acc.draftaccount = draft_account;
        article_acc.articlestate = 1;
        msg!("Found key {}",*ctx.accounts.author.key);
        Ok(())
    }
}

#[derive(Accounts)]
#[instruction(publisher_account_bump: u8)]
pub struct Initialize<'info> {   
#[account(init, seeds = [author.key().as_ref()], bump, payer = author, space = 8+8+566)]
publisher_account: Account<'info, ArticleState>,
#[account(mut)]
author: Signer<'info>,
system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct PublishArticle<'info> {
    #[account(mut, has_one=author)]
    publisher_account: Account<'info, ArticleState>,
    author: Signer<'info>,
    system_program: Program<'info, System>,
}

#[account]
#[derive(Default)]
pub struct ArticleState {
    articleuri: String,
    draftaccount: Pubkey,
    author: Pubkey,
    articlestate: u8,
    bump: u8,
}```
What do you mean? How so?
```#[derive(Accounts)]
#[instruction(publisher_account_bump: u8)]
pub struct Initialize<'info> {   
#[account(init, seeds = [author.key().as_ref()], bump, payer = author, space = 8+8+566)]
publisher_account: Account<'info, ArticleState>,
#[account(mut)]
author: Signer<'info>,
system_program: Program<'info, System>,
}```
My PDA is being modified, by any wallet here.
My bad I talk loose, that is what I meant
And also, invoke_signed doesn't "access control account manipulation", it calls some other program + signs for whatever PDAs you want to sign for
The security property for PDAs is that only the deriving program can sign for their address
No, `invoke` can't sign for a PDA (that's what `invoke_signed` is for)
So, invoke_signed in my program access controls account manipulation. If I use only invoke, my PDA can be manipulated by any wallet or signer
This means that when you use `invoke_signed`, you can only sign for the *current* program's derived addresses, not any other program's PDAs.
Yeah, anyone can generate a PDA, but note how the APIs for `findProgramAddress` and `invoke_signed` are different: `findProgramAddress` uses the seeds *and the deriving program id*, whereas `invoke_signed` only uses the seeds.
I believe (although correct me if wrong) that only a program can sign for its own PDAs when doing CPI... deriving a PDA just gives you an address but it doesn't allow signing
I don‚Äôt understand üò≠üò≠üò≠
If anyone can generate a PDA how is signing via a PDA kept secure or access controlled
what is `CpiContext` in anchor? <@!134416332509675520>
Yep, it's a lifetime‚Äîyou're going to just have to read the rust book: https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html
is `<'info>` is used for lifetime ? 
is yes then how it effects the life time of variables?
<@!134416332509675520>
Yea, I mean closing and recreating same account usign anchor client. So basically I need to find my way.  Thanks for your help.
Currently you unfortunately can't add additional space to an account (though this will hopefully change soon). You'd have to copy those accounts over to fresh addresses I guess.
should this not result in completely different hashes?
hello, how come they used different strings here (- and _)
I see, thanks, so what is the migrstion scenario here if there is no enought space? Should I just make 1 more method to loop through pdas and reallocate space using anchor client?
You basically just need to make sure the change is backwards-compatible. So, if you want to add a field, add it at the end of the struct so that borsh will continue to work with it (you'll have to have made sure you pre-allocated enough space though).
hi guys, how often does a transaction that has reached confirmation level "confirmed" fail? Does it happen often when the network or one program receives a lot of traffic?
`<'info>` is used for lifetime ? 
is yes then how it effects the life time of variables?
what should be my next steps after reading the anchor book?
ie not sol. random mints for use in our devNet/testnet deployments
Hey anyone built out a faucet setup for solana test tokens at all?
But can not modify the added data because the account data size was fixed already. I need to create a new Program Data Account. üò¶
I Solved this issue. 
The data was not removed. It was could not read because of the Struct's structure. 
So I added the new variable end of the Struct, not middle of the Structure, It works well.
I've found a link about this issue. I'm gonna test it. üò¶
https://blocksecteam.medium.com/secure-the-solana-ecosystem-3-program-upgrade-5590c746016
The program upgrading was successful but its account data seems removed all.
I tried just `anchor deploy` again from scratch by resetting the `test-ledger` directory. 
It just works well oddly this time without `anchor idl upgrade`.
Even I didn't overwrite newer IDL files into the Dapp.
Thanks, everyone üôÇ
I recommend using `msg!("account created")` in the instruction code.
And watching it from backend program using Websocket endpoint.
As your advice, I tried both `anchor ild upgrade -f <IDL_PATH> <PROGRAM_ID> --provider.wallet <OWNER_KEYPAIR_PATH>` and `anchor ild upgrade -f <IDL_PATH> <PROGRAM_ID> --provider.wallet <ACCOUNT_KEYPAIR_PATH>`.

However, I got the same error below :
```shell
Error: Error processing Instruction 0: custom program error: 0xbbf
# it is error 3007 "The given account is owned by a different program than expected"
```

Even I tried all from scratch, got same error message.
What am I missing?
Hello, any idea friends?
hey guys, is there any way to get in reattime or receive an event when an account is created in my program?
I couldn't find a crate for 0.23, but I tried 0.22 and it looks like that worked. Thanks!
Thx I'm going to do that!
You probably need to run `anchor idl upgrade`
I upgraded IDL on my Dapp copy from target directory. When I deployed the program only run command `anchor deploy`
Did you upgrade the IDL?
Hi guys, I have a question when upgrading a program. 
I added a variable of a Struct and redeployed it.
After that, I ran a command on my Dapp with an account used before upgrading, but it did not work. 
Is it impossible? 
Do I need to create a new account for the upgraded program?

The error message is:
```javascript
Transaction simulation failed: Error processing Instruction 0: custom program error: 0xbbb  Program <PROGRAM_BASE58> invoke [1] Program log: Instruction: Swap Program log: Custom program error: 0xbbb 
Program <PROGRAM_BASE58>
consumed 7021 of 1400000 compute units Program <PROGRAM_BASE58> failed: custom program error: 0xbbb
```

Before upgrade struct below:
```rust
#[account]
pub struct ProgramStatus {
    authority: Pubkey,
    amount u64
}
```

After upgrade struct below:
```rust
#[account]
pub struct ProgramStatus {
    authority: Pubkey,
    amount u64,
    is_working: bool // added
}
```

Thx
the docs you linked to are for 0.23 and I think older versions don't work for what you're trying to do
Use 0.23
0.18.0
What version of Anchor are you using?
exactly
Oh I see, you want to be able to implement AnchorSerialize/Deserialize on the structs so you can use them as Anchor accounts
Why do you need wrapper structs?
The project is an IRL event app, where people can host a Party and others can join as Guests. Joining a party requires some stake_in_lamports, with the idea being that after checking-in, the lamport pool will be evenly distributed among all checked-in guests (people who fail to check-in lose their stake). 

You can view the code I have so far here: https://github.com/Yihwan/party-irl/blob/poc/programs/party-irl/src/lib.rs

But I'm not sure how to handle the logic to "settle" a Party. I was hoping to do some kind of query within a settle_party method or similar that looks for all checked-in Guests, but I'm not sure if I have to pass in all the accounts to be transacted as args. If so, I suppose I could so a filtered query from the client, but not sure if that would open things up to vulnerabilities. 

Basically, any guidance on whether the premise of the app is feasible would be super helpful. Happy to try and figure out the implementation details as I go along, just want to get a sanity check on overall feasibility before I go too far down the wrong path.
I‚Äôm working on a toy project to help solidify my understanding of Solana/Rust (just got introduced to both last week).
Starting a thread so I don't pollute the channel. üòÖ
Quick sanity check on project feasibility
Check your Anchor.toml file's wallet matches your expectations
Hello all. I ran an anchor test, and the result has me confused.
This channel has been super helpful, so I wanted to share my WIP solution to one of the projects given at the Solana Bootcamp in NYC recently. This is my first time working with this tech stack, so I'm making lots of comments about beginner-level stuff. https://github.com/sfdz/exchange-booth
oh awesome, looks like i should've searched the discord for associated token account questions, thank you
You're getting a CPI signer privilege error because you're presumably passing in an associated token address from the client, but that's a PDA derived from a totally different program, the associated token program, not your own‚Äîso your program can't sign for its address
If you want to create an associated token account, instead get rid of those `seeds = [...]` and do `associated_token::mint` and `associated_token::authority` instead
hey, i'm getting this error:

```
Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account 
    Program 3mk9JnpeBbfdo58S4R4SMHy9m1sFENseiHCJCN9xSUZ1 invoke [1]
    Program log: Instruction: RedeemNft
    8HgicSXn9kSWQC3qJv6u4FCTwzJBkVCzrnZCqiK2adpx's signer privilege escalated
```
i've looked through the previous errors on the discord and was unable to solve my problem since i can't figure out why this error is happening. i've removed all cpi calls from the instruction, and isolated the ```8HgicSXn9kSWQC3qJv6u4FCTwzJBkVCzrnZCqiK2adpx``` address to this account:

```
#[account(init_if_needed,
        seeds = [
            redeemer.key().as_ref(),
            token_program.key().as_ref(),
            reserve_token_mint.key().as_ref(),
        ],
        bump,
        token::mint = reserve_token_mint,
        token::authority = redeemer,
        payer = redeemer,
    )]
    pub recipient_token_account: Box<Account<'info, TokenAccount>>,
```
the context of this is i'm trying to create an associated token account for a user in the anchor program, so it doesn't have to be created by them on the frontend


//////////////////////////////////////////////////////////////////////////////////////////

I‚Äôll give it another shot in a few
Why is `"signatures": [],` empty <:thonk:711735996726640652>
```return program.transaction.foo({
    accounts: {
        signer: signerKeypair.publicKey,
        ...(other accounts)
    },
    signers: [signerKeypair]
});

Returns:

{
    "signatures": [],
    "instructions": [
        {
            "keys": [
                {
                    "pubkey": "<SignerPubkey>",
                    "isWritable": true,
                    "isSigner": true
                },
                ...(other accounts)
            ],
            "programId": "<programId>",
            "data": {
                "type": "Buffer",
                "data": [
                    ...(data)
                ]
            }
        }
    ]
}```
Closing PDAs works fine (closing program is different though)
How are you closing it?
similar to how you deploy a program, close it and and cant redeploy to that same address
Yea I I just couldnt figure out how to close the account thats a PDA and able to reuse it, since I seem to run into that error everytime i try and close it and reuse
That error means you're trying to init an account at an address that already holds some other account
Yeah, you can close accounts in solana
Curious to see this because I run into this error a lot, ```Allocate: account Address { address: "somePDAAdress", base: None } already in use```
Hey how can i send myself some devnet usdc?
If I am not wrong, I think solana provides a way to remove data at a given address, and I think it also refunds us the rent fee as well
yea i tried this, same issue...
you can look at localnet txns with explorer.solana.com
i see you're using the idea of "rooms" kind of curious who this works, since im looking to allow users to create new games but when you initialize with a public key, that pda will already exist after youve done it once. Question for the group, is there a way to close a PDA after some arbitrary condition? Like basically revert the initialize handler
sure
Actually I am currently running on localnet, Will try to deploy on devnet and reach back to you
or shoot me the txHash, I'll check once
for devnet, it shows
But I dont think it shows any logs for  transactions on localnet or devnet
thanks, I will try that
I am not too sure about that. The tests which I have been running are working fine without any need to use confirmTransaction  there, but I will try and let you know
though one thing you can do is, check the txLog on solscan once, see if everything is working or not.
Possibly (I'm a little fuzzy tbh on when this is necessary)
does that mean, that I need to confirm transaction whenever I create a new account?
aah make sense now
This is simply `program.rpc`. I have wrapped the program object in a vueJS `ref` object. So have to use value to access the underlying `program` object
await program.provider.connection.confirmTransaction(thatThingsReturnValue)
What is `program.value.rpc` here, just curious. Haven't seen anything like this?
I am sorry, i am not getting you. Additional confirmation?
You probably need to wait for additional confirmation
Moreover, it is correctly fetching all the results after I refresh the site. It seems that until I refresh, it is unable to fetch the account
this is the `send_message` method in my rust program:-
```
 pub fn send_message(ctx: Context<SendMessage>, content: String, room_key: Pubkey) -> ProgramResult {
        let message = &mut ctx.accounts.message;
        let author = &ctx.accounts.author;
        let clock = Clock::get().unwrap();

        if content.chars().count() > 256 {
            return Err(ErrorCode::ContentTooLong.into());
        }

        message.author = *author.key;
        message.timestamp = clock.unix_timestamp;
        message.content = content;
        message.room = room_key;

        Ok(())
    }
```
and this is the `Context` 
```

#[derive(Accounts)]
pub struct SendMessage<'info> {
    #[account(init, payer = author, space = state::Message::LEN)]
    pub message: Account<'info, state::Message>,
    #[account(mut)]
    pub author: Signer<'info>,
    #[account(address = system_program::ID)]
    pub system_program: AccountInfo<'info>,
}

```
I tried some more things but I am not able to understand what is happening:-
```

    console.log(program.value.account.message.all())

    await program.value.rpc.sendMessage(content, roomPublicKey, {
        accounts: {
            message: message.publicKey,
            author: wallet.value.publicKey,
            systemProgram: web3.SystemProgram.programId,
        },
        signers: [message]
    })

    console.log(program.value.account.message.all())

 ```
It seems that the new account is not being created at all. Both the `console.log` statements show the exact same output
Just the ata yea balance is fine
makes sense, thanks!
You might want to check yourself if you want to have a chance to raise your own custom error etc.
Yeah, the tx will just fail/rollback if you invoke the token program.
why would you check the balance tho? the transfer instruction would just fail
Yea you‚Äôd want to check this. Plus you need to grab their ATA and it might not exist
not really, unless your logic depends on it
but you may want to catch that before it happens, or not
It will fail
it'll just fail
Yea I tried using authority and it gave the same error actually but I‚Äôll take a look again so just use authority instead of itself.key in initialize ? For all the pdas with seed
since, your other accounts depend on that, it may be causing problems
<@!270368441972555776> on the play instruction, the `rpbp` account is a PDA of seeds which are taken form inside itself `rpbp.authority.as_ref()`, have you tried writting it like in the other instruction? simply reffering to `authority` as it is also present
The tests run fine
Yeah tried doing that as well, it seems that it is unable to see that the account has been created.
And see the result
Try doing a message.all() first
Ive run into these problems before too
Might be a different seed
lol i know right
too much anchor for today
Yup, but It seems that it is not able to fetch my newly created account
nvm, misread
Let me see
on initialize your constraint is under the account???
Fetch gets accounts /pdas of your struct types
wait, i found ur problem
That‚Äôs what I‚Äôm trying to figure out but I‚Äôll keep looking at it. Thanks for suggesting <@!317013100371116032>
hello ! It seems that I am unable to understand how the `fetch` method works in anchor.
I have the following piece of code:-
```
export const sendMessage = async (content, roomPublicKey) => {
    const { wallet, program } = useWorkspace()
    const message = web3.Keypair.generate()

    await program.value.rpc.sendMessage(content, roomPublicKey, {
        accounts: {
            message: message.publicKey,
            author: wallet.value.publicKey,
            systemProgram: web3.SystemProgram.programId,
        },
        signers: [message]
    })

    try {
        console.log(message.publicKey.toBase58())
        const messageAccount = await program.value.account.message.fetch(message.publicKey)
        return new Chat(message.publicKey, messageAccount)
    } catch(err) {
        console.log(err);
    }
}
```
the `sendMessage` rpc is responsible for creating a new account, and I am simply fetching that new account, but I am unable to do so.

Moreover the tests which use similar code are working fine:-

```

    for (var i = 0; i <= 10; ++i) {
      const message = anchor.web3.Keypair.generate();
      await program.rpc.sendMessage('temp', room.publicKey, {
        accounts: {
          message: message.publicKey,
          author: program.provider.wallet.publicKey,
          systemProgram: anchor.web3.SystemProgram.programId,
        },
        signers: [
          message
        ],
      });

      const messageRes = await program.account.message.fetch(message.publicKey);
      assert.equal(messageRes.author.toBase58(), program.provider.wallet.publicKey.toBase58())
    }

```
Any help on this?
So not sure what‚Äôs different about the seed
Im using th√© exact same account I passed to initialize
specifically, this account: `rpbp_fee_account`
either your account is not a PDA or not one with those seeds, or it's not a PDA for that program you are calling
you are passing an account which apparently has to be a PDA of certain seeds
yes
Any ideas here?
I never tested it, but can we assume the maximum amount of unit variants is 256?
just make sure you don't have too many variants I guess
For unit variants yes
yep
is the space of an enum always equivalent to `u8`?
Okay, thank you!
Yeah, for when you don't know ahead of time the exact number
optional account provision?
What is the purpose of `remaining_accounts` then?
hmm, i guess i'll have to embrace long contexts then, thx
Nope, need to pass in *all* accounts from the client
if so, is this why `remaining_accounts` exist?
Or does my transaction need to include those accounts from the start?
Hey, quick question, is it possible to fetch an account info with just the public key when making a CPI?
I see. yes will try to come up with a nice solution template and share the code here üôÇ
Just send the tx the lower-level web3.js way
Ah, yeah, you can still test that just fine, I'm just saying that I'm not sure how to swap out a different provider.wallet (might be possible, can't remember)
sure, but it is always nice to have tests to verify that stuff again
Yeah. It's up to you to write your program with appropriate checks
I mean something like the `authority`mechanism of the basic-2 example. Isn't it that if this is missing, everyone could write to the account if they know the pubkey of the account?
The ways to do that in tests etc. are just for tests, e.g. you can clone an account from devnet/mainnet etc.
In general in solana, only the program that owns an account can write to its data
I have directory with secret keys and load them up for tests and top  up if necessary.
Thanks , that worked as far as submitting transaction, but that account was deployed via client and account address passed to the anchor program so it can't be processed within anchor checks as it is missing the first 8 designation bytes

```Error: 3001: No 8 byte discriminator was found on the account```

Accounts can only be modified by the owner and need to be zerod in, so I can't preload an account with 8 bytes.  

It seems that with anchor it has to be the program deploying and instantiating an account, is this true?

I know this is kind of a niche problem, to want to deploy an account using the client. I kind of just fixated on it as there doesn't seem to be any way to do it.
in my opinion such tests are crucial since I need to ensure that no data can me manipulated by other entities
that's also a good point. I was wondering why .rpc() is shown as deprecated
Or maybe with the new api, instead of doing `.rpc()` just do `.transaction()`? Haven't actually tried that
You can build a tx by doing `program.transaction.yourInstructionName`
Not sure there's actually a super easy way to do that, you might need to drop down to low-level web3.js to send/sign the tx etc.
thanks. In that case: how do I simulate two wallets in a test? the equivalent of two `provider.wallet` instances I mean.
You need to sign for `counter` though because in solana whenever you create an account, the account's address has to sign
`provider.wallet` actually signs no matter what, since it pays the tx fees, so you never need to include it in `signers` (in fact, in the browser you *can't*, since you don't have access to the wallet keypair).
Hi all, I have question regarding the tests in the `basic-2` project of the examples:
https://github.com/project-serum/anchor/blob/master/examples/tutorial/basic-2/tests/basic-2.js

Why do we sign the transaction with the `counter` keypair and not witht`provider.wallet`?
`provider.wallet` is assigned to the `user` account which is declared to be the signer of the 
transaction. So why does this not fail when we sign the transaction with `counter`. What also
confuses me is that in the IDL `counter` is also declared a signer of the transaction implicitly.
But assuming this, in my opinion it should still fail since in that case both: `counter` and 
`provider.wallet` should sign the transaction.
Another thing here: Where did `counter` get the funds to pay for the transaction? Is it implicitly
created with funds via `anchor.web3.Keypair.generate()` ?
is `program.addEventListener` works in react? 
i tested it with anchor test on nodejs, i am able to get the event, but not in react?
what is missing?
i could see the events being registed, but not firing

```
useEffect(() => {
    console.log('here program')
    if (!program) return;
    console.log('progam registered')

    program.addEventListener("EventData", (ev, slot) => {
      console.log('event')
      console.log(ev)
      console.log(slot)
    })
  }, [program])
```
Am I missing something?
Good day! I have a struct which I want to pass into an rpc, which contains `Option` inside it.
```
struct Foo { 
    bar: Option<u64>,
    baz: Option<u64>,
}
```
But when I try to pass it in any way written below I get an `Invalid option Foo` error:
```
program.foo({
  bar: BN(2),
  baz: BN(3),
})...
```
```
program.foo({
  bar: {
    some: BN(2),
  },
  baz: {
    some: BN(3),
  }
})
```
Oh, got it‚Äîyou can do `program.provider.send(thatTx)`
I was just wondering whether there is a function that does it within anchor, so I don't have to regenerate payer.secretkey (for sendAndConfirmTransaction(program.connection, transaction, [provider.wallet])) to submit it the standard way nor having to import solana/web3.js if for whatever reason in my design account gets made by the client.
Not sure I understand your question‚Äîhow do you want to use anchor to do that?
Is there a way to generate and deploy an account via client using anchor framework, rather than instructing the program on how to do it? Easy enough to do it in vanilla Solana TS, but can't find anywhere how to do this:

        const transaction = new Transaction().add(
            SystemProgram.createAccountWithSeed({
                fromPubkey: payer.publicKey,
                basePubkey: payer.publicKey,
                seed: GREETING_SEED,
                newAccountPubkey: greetedPubkey,
                lamports,
                space: GREETING_SIZE,
                programId,
            })
        );

        await sendAndConfirmTransaction(connection, transaction, [payer]);
i cheated a little
hows this
```rust
use anchor_lang::prelude::*;
use anchor_spl::token;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod vault {
    use super::*;

    pub fn transfer_wrapper(ctx: Context<TransferWrapper>, amount: u64) -> Result<()> {
        match token::transfer(ctx.accounts.transfer_ctx(), amount) {
            Ok(_) => Ok(()),
            Err(err) => Err(err),
        }
    }
}

#[derive(Accounts)]
pub struct TransferWrapper<'info> {
    pub authority: Signer<'info>,
    #[account(mut)]
    pub sender: Account<'info, token::TokenAccount>,
    #[account(mut)]
    pub reciever: Account<'info, token::TokenAccount>,
    pub mint: Account<'info, token::Mint>,
    pub token_program: Program<'info, token::Token>,
}

impl<'info> TransferWrapper<'info> {
    pub fn transfer_ctx (&self) -> CpiContext<'_, '_, '_, 'info, token::Transfer<'info>> {
        CpiContext::new(
            self.token_program.to_account_info(),
            token::Transfer {
                from: self.sender.to_account_info(),
                to: self.reciever.to_account_info(),
                authority: self.authority.to_account_info(),
            }
        )
    }
}```
Have you gone through any of the anchor escrow program tutorials? They would explain that
I thought maybe a vault where anyone can deposit or withdraw spl tokens, but i have no idea how to interact with spl tokens
Can someone suggest a simple beginner program for me to try making?
Sure!
as easy as this üôÇ thanks mate!
`your_account.reload()?;`
Hi folks, how can I get the updated data of an account after a CPI? I am doing a CPI swap and I need to know how many tokens I got.
Easier to understand it by just jumping to source I think (you'll need to have jump-to-source configured with your editor to make much progress with anchor/solana!)
I managed to get it working. The goal of the instruction is to airdrop tokens with CPI, but the account that I was passing in as the mint was missing `#[account(mut)]`. That was actually causing a `writable privilege escalated` error, the signer problem was a red herring because I also saw a `Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account` .
Oh sorry I misunderstood the question.
agenda was that how i can use `anchor_spl` functions and structs.
i'm seeking for tutorial or guide book. <@!252808943238119424>
add anchor-spl to your Cargo.toml
how i can use functionalities of `create anchor_spl` in my own code(NFT marketplace).
here is Link of `create anchor_spl` https://docs.rs/anchor-spl/latest/anchor_spl/all.html
for cross program invocations (CPIs)
https://book.anchor-lang.com/chapter_3/CPIs.html
https://github.com/project-serum/anchor/blob/master/tests/cpi-returns/programs/caller/src/lib.rs
what is `CpiContext` in anchor? <@!134416332509675520> <@!883714735864946718>
the seed constraints on the rpbp_fee_account are the exact same?
```Transaction simulation failed: Error processing Instruction 0: custom program error: 0x7d6 
    Program Ahs4nv515E2QTQPoqdpq2yiWSkco5ew1zPUXa89QZtsL invoke [1]
    Program log: Instruction: Play
    Program log: AnchorError caused by account: rpbp_fee_account. Error Code: ConstraintSeeds. Error Number: 2006. Error Message: A seeds constraint was violated.
    Program Ahs4nv515E2QTQPoqdpq2yiWSkco5ew1zPUXa89QZtsL consumed 12112 of 200000 compute units
    Program Ahs4nv515E2QTQPoqdpq2yiWSkco5ew1zPUXa89QZtsL failed: custom program error: 0x7d6```
Running into the classic `seed constraint was violated` . Not really sure how since the seeds are the same from init to this Play handler instruction. Anyone spot anything wrong here?
```

#[derive(Accounts)]
#[instruction(bump: u8, fee_account_bump: u8, treasury_bump: u8)]
pub struct Initialize<'info> {
    #[account(init, seeds=[PREFIX.as_bytes(), authority.key().as_ref()], bump, space=GAME_SIZE, payer=payer)]
    rpbp: Account<'info, GameInstance>,
    #[account(mut, 
        seeds=[PREFIX.as_bytes(), rpbp.key().as_ref(), FEE_ACCOUNT.as_bytes()], 
        bump=fee_account_bump
    )]
    ///CHECK:
    rpbp_fee_account: UncheckedAccount<'info>,
    #[account(mut, 
        seeds=[PREFIX.as_bytes(), rpbp.key().as_ref(), TREASURY.as_bytes()], 
        bump=treasury_bump
    )]
    ///CHECK:
    rpbp_treasury: UncheckedAccount<'info>,
    #[account(mut)]
    payer: Signer<'info>,
    ///CHECK:
    authority: UncheckedAccount<'info>,
    #[account(mut)]
    ///CHECK:
    fee_withdrawal_destination: UncheckedAccount<'info>,
    #[account(mut)]
    ///CHECK:
    treasury_withdrawal_destination: UncheckedAccount<'info>,
    system_program: Program<'info, System>,
    time: Sysvar<'info,Clock>,
}

#[derive(Accounts)]
#[instruction(fee_account_bump: u8, treasury_bump: u8)]
pub struct Play<'info> {
    #[account(mut)]
    wallet: Signer<'info>,
    #[account(mut, 
        seeds=[PREFIX.as_bytes(), rpbp.authority.as_ref()], 
        bump=rpbp.bump
    )]
    rpbp: Account<'info, GameInstance>,
    #[account(mut, 
        seeds=[PREFIX.as_bytes(), rpbp.key().as_ref(), FEE_ACCOUNT.as_bytes()], 
        bump=fee_account_bump
    )]
    ///CHECK:
    rpbp_fee_account: UncheckedAccount<'info>,
    #[account(mut, 
        seeds=[PREFIX.as_bytes(), rpbp.key().as_ref(), TREASURY.as_bytes()], 
        bump=treasury_bump
    )]
    ///CHECK:
    rpbp_treasury: UncheckedAccount<'info>,
    ///CHECK:
    authority: UncheckedAccount<'info>,
    #[account(address = sysvar::instructions::id())]
    ///CHECK:
    instruction_sysvar_account: UncheckedAccount<'info>,
    system_program: Program<'info, System>,
    time: Sysvar<'info,Clock>,
}
```
Hi. I'm reading about accounts in Anchor (https://project-serum.github.io/anchor/tutorials/tutorial-1.html#initialize-instruction) and have a question regarding this paragraph: "Without it, a program would be vulnerable to account injection attacks, where a malicious user specifies an account of an unexpected type, causing the program to do unexpected things." 
How do account discriminators in Anchor prevent injection attacks? Since anyone can initialize an account with the expected discriminator and pass it to an Anchor program.
Is it possible to view all the accounts (and data that is updated) before signing/approving a transaction?
SOLVED.

I had my provider wallet be the same keypair as my /target/deploy. This made it so that it was always in use
Running `anchor test --skip-local-validator` will always give me 

`Error: Account <insert pubkey> is not an upgradeable program or already in use`

No matter how many times I re-make `/target/deploy` and change anchor.toml and lib.rs. I'm running `solana-test-validator --no-bpf-jit` in another terminal.

Whats the issue?
Anyone can derive the pubkey for this PDA, but the private key can't exist. So the on-chain program is just allowed to flip the 'isSigner' bit for itself in a CPI, because solana can verify that the pubkey for that PDA is derivable from its address and that no hanky panky is going on. Clients can't be trusted.
(Disclaimer: I'm a newb and this is my best understanding :p)
A PDA does not have a private key, it can 'fake sign' only within the on-chain program.
No
Can you have a PDA sign for a transaction? Specifically client side
<:PB_pepesit_sad:769654458148847627>
At my last job one dude wrote this beautiful, user-friendly deployment tool, with multiple confirmations steps, cute emojis, etc. Miss it üò¢
Solana's deploy tools need some work, they're honestly pretty bad lol üòÜ
Yeah lol ü§¶‚Äç‚ôÇÔ∏è Maybe try running it on a local validator deploy first
maybe ill just let the 7 SOL rot, i don't want to accidently close the one lol
lol, sounds like high stakes roulette... maybe it works, or maybe it closes the program thats running lol
Like, at the end I guess
According to that output though you can just pass the program_id as an argument to the command
Hmm yeah running `solana program close --help` doesn't even include the `--programs` option lol
but i dont want to close both, jsut one.
no, i give it my keypair.. and that shows two programs that my keypair/authority owns
Does the `-k` argument not do what you want?
ok, so i have two programs.... hm, how do i close one üôÇ
yes, missed that. Thank you!
Looks like it's `solana program close --programs`
Justin discusses this here a bit down the page: https://jstarry.notion.site/Program-deploys-29780c48794c47308d5f138074dd9838
it says i need --buffers, but if i add that I don't think anything happens
I accidently deployed my program to a different address at mainnet. I'm trying to close it, is this the right command?

`solana program close -k target/deploy/program-keypair.json --authority /Users/me/wallets/my_wallet.json`
Oo delightful, ty
Sure, `program.transaction.yourInstructionFn`
Can I use anchor to emit a web3 transaction containing an instruction built up for a program from an idl, but not send it to solana? I.e. so I can send it to someone else to be signed.
Yes, every account has a program owner. Although it depends a bit on what you mean by "owner", since e.g. token accounts have both a program owner (the spl token program) as well as a logical "authority", the human/whatever that "owns" the tokens.
That actually looks about right, what was the full program log?
just need to be able to filter them or always guarantee im passing them in that order
yea im thinking ill just have to read the publickey list from that struct, then pass the accounts as remaining_accounts...
yeah I had similar problem with tokens. Had to make it a 2 hop solution (change data on rust and then fornt end calls with  account info using that changed data )
Or maybe I use `remaining_accounts` but I haven't used that before so. Ill take a look into it
is the rent epoch shorter for localnet?
If I have just the public key of the address I want to send to, do I need to pass it in the accountinfos array ?
```
invoke_signed(
                            &system_instruction::transfer(
                                &rpbp_treasury.key(),
                                &p.owner.key(),
                                amount,
                            ),
                            &[
                                rpbp_treasury.to_account_info(),
                                p.owner.as_ref().to_account_info(), //do I need to pass this?
                                system_program.to_account_info(),
                            ],
                            &[&rpbp_treasury_seeds],
                        )?;

```
Basically, I have a list of public keys and want to transfer sol, but since the list is stored on a struct in the program, I wont be able to get the account info at runtime. Would I need to maybe then get the struct and map the public keys on it as an input to the handler function instead? Or possibly need to rethink the approach.
like a PDA
no you can have an account be owned by a different account
has anyone managed to make CPI calls to the metaplex candy machine?
Accounts are always owned by a program right? they can only be owned by a program?
Its a boolean that I set to false in rust, but when I run the code and fetch the account using anchor in the client, it is set as true
I am getting this weird error where the data on one of my accounts is not being modified
Can someone confirm if my thought process makes any sense?

I created a mint account. Now I want my program to mint tokens of my mint on demand. To do that, I need to initialize a PDA in my program and assign that PDA to be the mint authority of the mint account. Once that is done, I can CPI the mint_to instruction from my program to create tokens.
https://github.com/0xcatrovacer/honey-ido-pool/blob/main/cli/index.js This is the file causing the error
https://explorer.solana.com/address/7TZqAhcqsPHoZ7sDAeUpDj5woKDDFMYGuX1bgoBsfGPv?cluster=devnet
which is happening due to this
   ``` redeemableMint = await serum.createMint(
        provider,
        poolSigner,
        mintInfo.decimals
    );```
poolSigner is the publicKey in itself and so publicKey.publicKey.toString() is not making sense
now poolSigner is being derived from a findProgramAddress call (the thing you do for PDAs) which returns the publicKey and the bump
 ```   const [_poolSigner, nonce] = await anchor.web3.PublicKey.findProgramAddress(
        [honeyMint.toBuffer()],
        program.programId
    );```
so how do i handle this?
The error has to do with this :
```TypeError: Cannot read properties of undefined (reading 'toString')
    at Transaction.partialSign (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/Honey-IDO/honey-ido-pool/node_modules/@solana/web3.js/lib/index.cjs.js:2715:36)
    at NodeWallet.signTransaction (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/Honey-IDO/honey-ido-pool/node_modules/@project-serum/anchor/dist/cjs/provider.js:161:12)
    at Provider.send (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/Honey-IDO/honey-ido-pool/node_modules/@project-serum/anchor/dist/cjs/provider.js:77:27)
    at processTicksAndRejections (node:internal/process/task_queues:96:5)
    at async Object.createMint (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/Honey-IDO/honey-ido-pool/node_modules/@project-serum/common/dist/lib/index.js:43:5)
    at async createInitPool (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/Honey-IDO/honey-ido-pool/cli/index.js:244:22)
```
Hey so I'm running into a weird js error when trying to deploy a pool for an IDO platform.
running ./init_pool.sh gives this error:
```- J7Jkz6P2ip5NjWES6vERtDfTwUYY2LQ1FhMXJ73BdAdby5jiw1G
YError: Invalid second argument. Expected string or boolean but received function.
    at c (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/Honey-IDO/honey-ido-pool/node_modules/yargs/build/index.cjs:1:2244)
    at /mnt/c/FILES/Development/Web3Dev/Honey-Labs/Honey-IDO/honey-ido-pool/node_modules/yargs/build/index.cjs:1:2096
    at Array.forEach (<anonymous>)
    at h (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/Honey-IDO/honey-ido-pool/node_modules/yargs/build/index.cjs:1:1993)
    at Bt.command (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/Honey-IDO/honey-ido-pool/node_modules/yargs/build/index.cjs:1:29503)
    at Object.<anonymous> (/mnt/c/FILES/Development/Web3Dev/Honey-Labs/Honey-IDO/honey-ido-pool/cli/index.js:853:6)
    at Module._compile (node:internal/modules/cjs/loader:1101:14)
    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)
    at Module.load (node:internal/modules/cjs/loader:981:32)
    at Function.Module._load (node:internal/modules/cjs/loader:822:12)
args:  {
  _: [ 'init', '8DXSNpVJ5xHX7B49kCQVxMgQ2xPALEaZxN1H1sLFEebX' ],
  start_time: 1641218400,
  deposit_duration: 86400,
  withdraw_ts: 1641304800,
  'dry-run': false,
  dryRun: false,
  '$0': 'cli/index.js',
  usdc_mint: 'EvKdW6Jg7pc94Yp9FQzkqdehPLPrjq1itHuiXZgoVYeU',
  honey_mint: '8btRwS4Hk9aDWJVVfob23izQCd4RLfZaTGEq8y5jiw1G',
  honey_account: 'J7Jkz6P2ip5NjWES6vERtDfTwUYY2LQ1FhMXJ73BdAdb',
  honey_amount: 30000000
}
/mnt/c/FILES/Development/Web3Dev/Honey-Labs/Honey-IDO/honey-ido-pool/node_modules/@solana/web3.js/lib/index.cjs.js:2715
      const key = signer.publicKey.toString();
                                   ^```
I also have the bump stored on the Manager account. I tried doing signer_seeds: `&[&[&"manager".as_bytes(), user.key().as_ref(), &[manager.bump]]]` but that didn't work
I know that my seeds are `"manager"` and `user.key()` where user is the Signer
I'm trying to use `CpiContext::new_with_signer`, how should I define the `signer_seeds` for the PDA?
Isn't it the return value of that call?
does this error mean I would not get any tokens back so theres no point in swapping?
but no matter what amountIn I put it doesnt seem to matter i get that error
I think im hitting this case: https://github.com/solana-labs/solana-program-library/blob/95cd64ce022844d5ad2b2d4809c4b29c063162b3/token-swap/program/src/processor.rs#L404
Hi, having trouble understanding why I keep getting this error when trying to swap tokens on the orca amm in devnet:
```Given pool token amount results in zero trading tokens```
hi, @everyone
i'm new to Rust and new to this channel
am not sure if this is the right place for this kind of question, but...

our team is going to create a reward system for our NFT staking on Solana
can anyone tell me how to set up staking?
all i know is : `using cli for token creation`, `using genfarm for staking`
is it possible to do all this in code like on EVMs?
on EVMs we can set up our own staking mechanism using Solidity

can anyone help with this issue?
looking forward to hearing back.
Does anyone know how to fix?
I get failed to run custom build command for `ring v0.16.20` when trying to install anchor on my windows pc
<@!326107472098099201> ahhh ok nice - thanks Tom üôè
avm is the recommended method
For installing anchor on linux - should I install with pre-binaries w/npm or from source?


//////////////////////////////////////////////////////////////////////////////////////////

How can I read and parse account from a `Pubkey` inside the instruction code using Anchor?
How to write program to create pools like uniswap on solana? Is there any other program example that exists??
What is the difference between AccountInfo and Account ? And AccountInfo vs. UncheckedAccount?
try changing the variable name from `token` to something else
But I'm just importing the program code from the anchor library, it's the SPL token program.

I checked out the anchor source code and the token account struct is there.
you dont have a token struct defined in your anchor program code
<@!134416332509675520> üò¨ help out plox
I have the following code

```
  const tokenProgram = anchor.Spl.token();
  const token = await tokenProgram.account.token.fetch(
      tokenAccount.publicKey
    );
```
This keeps saying

```
Error: Invalid account name: token
```

What am I missing?
üëã if I have the publicKey of a token, I created, is there a way to retrieve that token with the publicKey? Not seeing anything in the `token.js` class in the SPL repo
Yea I already have the PDA check so should be fine.
Yeah when in doubt you should use `constraint =` etc.
Might be useful to have an account type for this which would also check that the lamports and space are 0 just to be extra pendantic. Because I think there are some accounts that are owned by the SystemProgram (like the BPF loader program I believe etc?) which could pass this check.
this works!! thanks so much alan
Have you read the createProgramAddress source?
There are multiple types of addresses in solana: true public key addresses (in the ed25519 cryptographic sense), program-derived addresses (see that link I just posted), and also this weird third kind that nobody uses anymore.
```
const seedsWithNonce = seeds.concat(Buffer.from([nonce]));
        address = await this.createProgramAddress(seedsWithNonce, programId);
```
I mean, it just looks like we are creating a new address if it doesn't exist here.
is there no difference between an account public key address vs. a program address?
https://discord.com/channels/889577356681945098/889702325231427584/939324164890845265
What's the deal with bump? Is there any resource where I can read// learn about it? üòû
I would suggest reading the source for findProgramAddress.
The address itself isn't, like, stored on-chain or anything (the account that may or may not live there is though)
Think of them as keys in a hash table‚Äîit's one thing to talk about whether anything is *stored* at that key (aka an account actually lives at that address) versus the key itself.
cool, thanks!
Yep. Addresses in solana are just 32 arbitrary bytes. You don't really "create" them, you "find" them.
You could say `that_pda: SystemAccount<'info>` to declare that this thing had better not have any data etc
With anchor version 0.22.0 the `AccountInfo` accounts are marked as unsafe and need to have a comment. I'm passing a PDA account which is to be used as mint authority (doesn't store any state). Is there anything else I am supposed to be using instead of `AccountInfo` for this? It seems silly to have to add a comment when the account doesn't store data and I already have the PDA check on it.
wait what? the address for a newly created mint exists even before I call `mint.createAccount`?
Addresses are totally independent of the account that may or may not live there, so the address exists no matter what (it's, like, a large number under the hood‚Äîthey all exist already)
I've got:
```
const mintATA = await PublicKey.findProgramAddress(
      [
        walletPubKey.toBuffer(),
        spl.TOKEN_PROGRAM_ID.toBuffer(),
        mintAccount.publicKey.toBuffer(),
      ],
      spl.ASSOCIATED_TOKEN_PROGRAM_ID
    )
```
In the debug console I see:
```
mintATA[0]
PublicKey¬†{_bn: BN}
mintATA[0].toString()
'BVHqVGSjCbD9HrUPG48gaUkX6Mn3buxSXTzQ58rrFdf4'
mintATA[1].toString()
'254'
mintAccount.publicKey.toString()
'5DF8aP9TP3e9vNWjivqnUQJz7LNHRNktejY4hmk5KFra'
```
I initialize a mint and never create an associated token account for the wallet present. Why is this function returning anything an address?

https://explorer.solana.com/address/5DF8aP9TP3e9vNWjivqnUQJz7LNHRNktejY4hmk5KFra/largest?cluster=devnet - mint account on devnet
As far as I know you have to mint however many tokens you care about and then unset the mint authority
Is there a way to limit the supply of an SPL token? Not seeing anything on the `createMint` function call:

```
/**
   * Create and initialize a token.
   *
   * @param connection The connection to use
   * @param payer Fee payer for transaction
   * @param mintAuthority Account or multisig that will control minting
   * @param freezeAuthority Optional account or multisig that can freeze token accounts
   * @param decimals Location of the decimal place
   * @param programId Optional token programId, uses the system programId by default
   * @return Token object for the newly minted token
   */
  static async createMint(
    connection: Connection,
    payer: Signer,
    mintAuthority: PublicKey,
    freezeAuthority: PublicKey | null,
    decimals: number,
    programId: PublicKey,
  ): Promise<Token> {
```
No... 

here's my created instruction, everything seems reasonable:
```
TransactionInstruction(keys=[AccountMeta(pubkey=AAakQsCYzHrj6C6CmCGdLtZnSeforiSWBm8q9N7W2yuQ, is_signer=True, is_writable=True), AccountMeta(pubkey=DyvogiyJaMnrVfT9cqAhnj5pNXRJeZT9rhJR2dALgWpV, is_signer=False, is_writable=True), AccountMeta(pubkey=Ak7DzaacxWwKLUFaKfntbcdcoKXzDk56aseSbqYT5MSy, is_signer=False, is_writable=False), AccountMeta(pubkey=G52Ki9ge7PzHHSswj4QXPUcaMYPVKEzgNoDvgN8iqTjg, is_signer=False, is_writable=True), AccountMeta(pubkey=GUuG7Soj4C9Zjx9qBqnfDZXLymeQP2cvHWLmqgY6QN5M, is_signer=True, is_writable=True), AccountMeta(pubkey=AG567t1EC9Eczwy26Qvd8rQcrgPzRg1q4vBe5LxjxgP3, is_signer=False, is_writable=False), AccountMeta(pubkey=SysvarRent111111111111111111111111111111111, is_signer=False, is_writable=False), AccountMeta(pubkey=11111111111111111111111111111111, is_signer=False, is_writable=False), AccountMeta(pubkey=AsW7LnXB9UA1uec9wi9MctYTgTz7YH9snhxd16GsFaGX, is_signer=False, is_writable=False)], program_id=7W8hRd8PqFQt5EZDHu9mmBhmiY4UPCcv9UuL86sYkm2K, data=b'o\x11\xb9\xfa<z&\xfe\xfc')
```

and then i just run
```python
    tx = Transaction().add(inx)
    await cpi_program.provider.send(tx)
```
hmm
One is a property purely of the address, one is a property of the account
So you have to keep the concepts of "can sign for this address" and "can mutate this account's data/spend its money" separate
You can totally write a program that owns an account, and mutates that account/spends that account's money without needing any signature
But this is just because the system program happens to be written that way
Yes‚Äîbut only because the system program happens to be written in such a way that it won't spend your account's money unless the address signs
Why is this not the same thing? If I have 1 SOL in my account and I want to send it to you, don't I need to sign that transaction?
Whether you need to sign for that address depends on what you're doing‚Äîfor instance, you need to sign for the address when you create an account there
The private key is relevant for signing for that address (not the same thing)
Nope
> Ah, .owner on an AccountInfo means the program owner of an account, the one and only program that's allowed to mutate that account's data or spend its money

Isn't that what the private key is for?
That's unfortunately totally different from the idea of a "logical owner" etc., like for a token account (solana names are generally kind of terrible lol)
Ah, `.owner` on an AccountInfo means the *program* owner of an account, the one and only program that's allowed to mutate that account's data or spend its money
Is this effectively a replacement for the account's keypair?
If I change the owner to the PDA, or another keyPair, can that keyPair sign obo this account?
This snippet:

```
const payer = anchor.web3.Keypair.generate();
    await helpers.airdropSol(payer, program.provider.connection);
    
    let accInfo = await anchor.getProvider().connection.getAccountInfo(payer.publicKey);

    assert.ok(accInfo);
```
In the debugger:
```
accInfo
{data: Buffer(0), executable: false, lamports: 2000000000, owner: PublicKey, rentEpoch: 0}
accInfo.owner
PublicKey {_bn: BN}
accInfo.owner.toString()
'11111111111111111111111111111111'
```
The owner is the System Program. Can the system program sign obo the this account?
Haha okay I'll make a PR if I can üò¨ for now will just pass in a redundant data I guess
Or make a PR
Can't remember, it may have used to work but accidentally stopped‚Äîbasically just pass in the mint üòõ
What do you mean by owner/authority here?
yeah ikr, there should be something like this. Do you mean this feature was added but not working yet?
üëã For a given acct, what is the relationship of its private key/key pair vs. the owner/authority?
I think this should work but currently doesn't :/
```
#[derive(Accounts)]
pub struct DepositTokens<'info> {
    #[account(init, payer=depositor, token::mint=mint, token::authority=depositor, space=16)]
    pub deposit_token_account: Account<'info, token::TokenAccount>,
    pub depositor: Signer<'info>,
    pub vault: Account<'info, Vault>,
    #[account(key=vault.mint)]
    pub mint: Account<'info, token::Mint>,
    pub token_program: Program<'info, token::Token>,
    pub system_program: Program<'info, System>,
}
```

Can I do something like the above, where the `mint` account gets populated automatically from the `vault.mint ` (whose type is Pubkey)? i.e. so that the user doesn't have to send the `mint` account for this instruction?
any ideas / resources on how to design cranks around this btw? i.e. make it permissionless as much as possible for anyone to be able to call this function, while still keeping it secure?
ohh this looks quite nice, let me try it out!!
hmm got it. thx a lot! üôÇ
Yeah, you'd have to make sure you're really invoking what you want to invoke (e.g. sign the request with an admin pubkey, or whatever)
so i guess one would have to make some checks on the instruction
Yucky, but you can do this kind of thing:
```.rs
pub fn pull_strings(ctx: Context<PullStrings>, data: u64) -> anchor_lang::Result<()> {
        let cpi_program = ctx.accounts.puppet_program.to_account_info();

        let cpi_accounts = puppet::cpi::accounts::SetData {
            puppet: ctx.accounts.puppet.to_account_info(),
            other_account: ctx.accounts.signer.to_account_info(),
        };

        use anchor_lang::InstructionData;
        let hmm = puppet::instruction::SetData { data: data };

        let ix = Instruction {
            program_id: cpi_program.key(),
            accounts: cpi_accounts
                .to_account_metas(None)
                .into_iter()
                .map(|mut meta| {
                    if meta.pubkey == ctx.accounts.signer.key() {
                        meta.is_signer = true;
                    }
                    meta
                })
                .collect(),
            data: hmm.data(),
        };

        invoke(
            &ix,
            &[
                ctx.accounts.puppet.to_account_info(),
                ctx.accounts.signer.to_account_info(),
            ],
        )?;

        Ok(())
    }
```
this could introduce serious serious injection attacks in general though, right?
Got it. I guess if you absolutely had to create an account in the client, the best way would be to set the owner/authority as the PDA - that way only the program itself can sign on behalf of the account. Could the keypair still be used to mutate the account data (after the PDA has been assigned as the authority) ?
Is there a way to limit the supply of an SPL token? Not seeing anything on the `createMint` function call:

```
/**
   * Create and initialize a token.
   *
   * @param connection The connection to use
   * @param payer Fee payer for transaction
   * @param mintAuthority Account or multisig that will control minting
   * @param freezeAuthority Optional account or multisig that can freeze token accounts
   * @param decimals Location of the decimal place
   * @param programId Optional token programId, uses the system programId by default
   * @return Token object for the newly minted token
   */
  static async createMint(
    connection: Connection,
    payer: Signer,
    mintAuthority: PublicKey,
    freezeAuthority: PublicKey | null,
    decimals: number,
    programId: PublicKey,
  ): Promise<Token> {
```
The project-serum multisig has an example of invoking a serialized instruction: https://github.com/project-serum/multisig
As long as you can turn it into an `Instruction`, then you can call `invoke_signed` on it
can it be some sort of serialized transaction that I send to the deriving program? or would i have to implement all the program-logic within the program?

to give some contect: I am trying to integrate the jupyter exchange. They don't have any on-chain SDK. they do have an off-chain SDK which returns instructions. 

I asked in their discord, and they said that it is possible to make the program sign these transactions
Yeah, probably. Also, if you create it on the client then you're apparently creating a whole bunch of them (one every time any client runs)
Is it safe to say that if we care about a keypair, we should never be creating it in the client code?
Basically, the only possible way to sign for a PDA is with `invoke_signed`
Store it someplace safe basically üòõ (Not on the client)
In the case where the keypair is relevant, what are best practices to keep this secure? feel free to point me to code snippets
Only the deriving program can sign for a PDA, so you'd ultimately need to send the instruction to the program and have it use invoke_signed on it
is it possible to sign an instruction, that had been created off-chain, by a PDA?
Hmm, yeah, that's a pretty low-level solana error. Are you invoking your contract in a funny way or something?
"Transaction failed to sanitize accounts offsets correctly implies that account locks are not taken for this TX, and should not be unlocked." What does that even mean ha..
Usually you sign once to create the account, and then subsequently the keypair is kind of irrelevant (again, unless your program does care for some reason about signatures from that address‚Äîin which case the keypair is indeed relevant)
But even if someone did know that keypair, it's probably not a big deal since once you sign for the account creation, you probably don't need to sign for that address again (probably, depends on what you're doing I guess)
But yeah, the client itself could maybe go figure it out somehow
You're generating that keypair from scratch in the client, so it'll be fresh every time
Ah makes sense. Slight follow up:

If I keep the keypair in my client code like so: `const mintAccount = Keypair.generate();` is this secure? How can I ensure that no one has access to this keypair?
(When you create an account that lives at a PDA, the program itself signs rather than the client)
Whenever you create an account, its address always needs to sign in solana
cuz I dont think your code has signed the transaction, prob you can use this api instead of the last 2 lines
```
await sendAndConfirmTransaction(program.provider.connection, transaction, [walletKeyPair])
```
Does the `mintAccount` also need to sign this transaction? How is that the case when we are just creating the account?
```
const [connection, provider] = await getProvider();
const program = new Program(idl, programID, provider);
const currentWallet = provider.wallet;

const walletPubKey = provider.wallet.publicKey;

enqueueSnackbar(`Creating a new mint..${provider.wallet.publicKey}`);

const mintAccount = Keypair.generate();
const transaction = new Transaction();
transaction.feePayer = walletPubKey;

const token = new spl.Token(
  connection,
  mintAccount.publicKey,
  spl.TOKEN_PROGRAM_ID,
  walletPubKey,
);

const balanceNeeded = await spl.Token.getMinBalanceRentForExemptMint(
  connection,
);

transaction.add(
  SystemProgram.createAccount({
    fromPubkey: walletPubKey,
    newAccountPubkey: mintAccount.publicKey,
    lamports: balanceNeeded,
    space: spl.MintLayout.span,
    programId: spl.TOKEN_PROGRAM_ID,
  }),
);

let signature = await program.provider.send(transaction);
let confirmation = await connection.confirmTransaction(signature);
```
Why is this giving me `Signature verification failed`?
this means I cannot rely on the `mpl-action-house` lib I suppose right
Ah, ok. You're going to have to figure out how to invoke that CPI and tweak the AccountMeta for that account so that it declares itself as a signer
yea so the handler accept > 1 accounts to be signer and depends on whose signer the account state changes will be different, one of the signer checks is here https://github.com/metaplex-foundation/metaplex-program-library/blob/master/auction-house/program/src/lib.rs#L905
Where does it end up requiring that thing to be a signer? Like, what goes wrong when it's not a signer?
https://github.com/metaplex-foundation/metaplex-program-library/blob/master/auction-house/program/src/lib.rs#L1070 here
I get: "Transaction failed to sanitize accounts offsets correctly"

when trying to run an instruction to a program I deployed to devnet

---
does anyone have any pointers on where to look?
How is it expecting that account to sign then?
It doesn't have a signer annotation?
the counterpart ctx for that rpc is declared as `UncheckedAccount`
*then* the signature will carry over
The program you're calling needs to declare that it wants that account to sign
but I also thought your statement was true.... cuz otherwise how do we carry the user's sig
Yeah, hmm, I guess I was just wrong about that this whole time! Shoot, my bad.
Interesting... yeah, I was like 99% sure that the signature carried over, but looks like it doesn't! I wonder if this changed in solana recently? Huh.
Hi alan, I just tried this doesnt seem to be the case, so I did
```
        let cpi_program = ctx.accounts.ah_program.to_account_info();
        let cpi_accounts = Sell {
            wallet: ctx.accounts.wallet.to_account_info(),
            token_account: ctx.accounts.token_account.to_account_info(),
            metadata: ctx.accounts.metadata.to_account_info(),
            authority: ctx.accounts.authority.to_account_info(),
            auction_house: ctx.accounts.auction_house.to_account_info(),
            auction_house_fee_account: ctx.accounts.auction_house_fee_account.to_account_info(),
            seller_trade_state: ctx.accounts.seller_trade_state.to_account_info(),
            free_seller_trade_state: ctx.accounts.free_seller_trade_state.to_account_info(),
            token_program: ctx.accounts.token_program.to_account_info(),
            system_program: ctx.accounts.system_program.to_account_info(),
            program_as_signer: ctx.accounts.program_as_signer.to_account_info(),
            rent: ctx.accounts.rent.to_account_info(),
        };
        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);

        msg!("CPI");
        mpl_auction_house::cpi::sell(
            cpi_ctx,
            trade_state_bump,
            free_trade_state_bump,
            program_as_signer_bump,
            price,
            amount,
        )?;
```
in my program, where `wallet` is indeed the signer (from the context of the current handler     `#[account(mut)] pub wallet: Signer<'info>` , then I try to log
```
        msg!("wallet is signer {}", wallet.to_account_info().is_signer);
```
in the counterparty program, it says a `false`
is there anything else Im missing to persist the signer status for the account?
Hey gusy, a quick question, when a program creates a PDA it is created with the rent exception, isn¬¥t it?
i used 'avm install latest'
quite long... not sure how to fix this issue.

Haha yeah that makes sense. Thanks.
I just have a local checkout of the codebase open in vscode and use text search!
That code snippet helped so much!! Thank you üò¨ Just curious, is there any way I can search through the codebase for specific function calls as an easy way to get reference code snippets?
Can you repost more of the error message? You can use triple back-quotes, `, to format things nicer
uninstalled anchor cli uninstalled avm, installed avm again and tried installing anchor latest version, getting this error , : For more information about this error, try `rustc --explain E0061`.
error: could not compile `spl-token` due to 3 previous errors
warning: build failed, waiting for other jobs to finish...
error: failed to compile `anchor-cli v0.22.1 (https://github.com/project-serum/anchor?tag=v0.22.1#b733610d)`, intermediate artifacts can be found at `/tmp/cargo-installO3BGHn`

Caused by:
  build failed
Error: Failed to install 0.22.1, is it a valid version?
You still have to pass the optional argument, just as `null`: https://github.com/project-serum/anchor/blob/master/tests/custom-coder/tests/custom-coder.ts#L24
Hmm, this is the IDL of that function

```
{
      name: "initializeMint";
      accounts: [
        {
          name: "mint";
          isMut: true;
          isSigner: false;
        },
        {
          name: "rent";
          isMut: false;
          isSigner: false;
        }
      ];
      args: [
        {
          name: "decimals";
          type: "u8";
        },
        {
          name: "mintAuthority";
          type: "publicKey";
        },
        {
          name: "freezeAuthority";
          type: {
            coption: "publicKey";
          };
        }
      ];
    }
```

So I added the other two args

```
tx = await tokenProgram.rpc.initializeMint(
      9,
      solvaultProgram.provider.wallet.publicKey,
      {
        accounts: {
          mint: mintAccount.publicKey,
        },
      }
    );
    console.log(tx);
```

But it's still failing with the same error. Any clues?
Kind of tricky error message, but I'm guessing you need to pass some extra arguments to that call, `initializeMint(something, somethingElse, { ... })`
how do I handle this
Ah, ok, bummer‚Äîyou unfortunately will probably have to pick just a single version :/
Hi,

I'm trying to create a mint account from anchor JS api, using the following code

```
tx = await tokenProgram.rpc.initializeMint({
      accounts: {
        mint: mintAccount.publicKey,
      },
    });
    console.log(tx);
```

But it's failing with the error
```
     Error: Invalid arguments: mint not provided.
```

What am I doing wrong?
Yeah. new_with_signers is for adding PDA signatures
and in the course of the CPI call, I can keep adding sigs with pda right?
Yep looks like there are two versions of anchor-lang in the cargo.lock file
The user's signature will indeed persist across the call
Hi there, is it possible to use user as signer when doing CPI call?
```
 let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
```
something like this already assumes the user's signature shall persist?
You can check by looking through your Cargo.lock file
Annoying trait errors like this can happen when you have multiple versions of anchor-lang floating around... is that possible here?
Can see an example here: https://github.com/cqfd/anchor-token-studies
https://github.com/jet-lab/jet-v1/blob/bd97a032b38f81ec4d76deae2246de755464fa27/programs/jet/src/instructions/borrow.rs#L99 maybe you can have a look at this
afaik gemfarm doesn't mint spl tokens but distributes deposited spl tokens, so you might not find what you are looking for there
I'm getting this error on .data() and it suggests to use anchor_lang::InstructionData despite me adding use anchor_lang::InstructionData which shows up as an unused import below weirdly. Any idea on why this is happening?```error[E0599]: no method named `data` found for struct `instruction::SwapTransitive` in the current scope
   --> programs/src/instructions/liquidate.rs:282:10
    |
282 |         .data(),
    |          ^^^^ method not found in `instruction::SwapTransitive`
    |
   ::: /.cargo/registry/src/github.com-1ecc6299db9ec823/anchor-lang-0.19.0/src/lib.rs:205:8
    |
205 |     fn data(&self) -> Vec<u8>;
    |        ---- the method is available for `instruction::SwapTransitive` here
    |
    = help: items from traits can only be used if the trait is in scope
    = note: the following trait is implemented but not in scope; perhaps add a `use` for it:
            `use anchor_lang::InstructionData;`

warning: unused import: `anchor_lang::InstructionData ```
Hello, I'm trying to implement instruction introspection in anchor.
I'm getting this error when I try to define account:
```
the trait bound `Instructions: anchor_lang::prelude::SolanaSysvar` is not satisfied
the trait `anchor_lang::prelude::SolanaSysvar` is not implemented for `Instructions`
```

Part of the program:
```
use anchor_lang::prelude::{*, Instructions};

#[derive(Accounts)]
pub struct Foo<'info> {
  instructions: Sysvar<'info, Instructions>
}
```
my program has mint authority over an spl token and I want to mint a certain amount to the user. been looking in the gemfarm codebase but can't find the exact piece where it mints the reward tokens
where can I find an example implementation of minting an spl token to a target address? how can I do that?
nvm, missing bump in seeds, if someone interested on solution:

```pub fn withdraw_fee_spl_instruction(
  ctx: Context<WithdrawFeeSPL>,
  _bump: u8,
  amount: u64,
) -> Result<()> {
  msg!("Withdrawing {} tokens from fee account to {}...", amount, ctx.accounts.destination.key());
  return transfer(
    CpiContext::new_with_signer(
      ctx.accounts.token_program.to_account_info(),
      Transfer {
        from: ctx.accounts.fee_treasury_ata.to_account_info(),
        to: ctx.accounts.destination_ata.to_account_info(),
        authority: ctx.accounts.fee_treasury.to_account_info(),
      },
      &[&[b"fee_treasury_spl".as_ref(), ctx.accounts.authority.key().as_ref(), &[ctx.accounts.fee_treasury.bump] <---- HERE]],
    ),
    amount,
  );
}```
Hey guys!

Im trying to transfer SPL Token from ATA which owns my PDA to Destination ATA

```#[derive(Accounts)]
#[instruction(_bump: u8, amount: u64)]
pub struct WithdrawFundsSPL<'info> {
  #[account(
    mut,
    seeds = [
      b"funds_spl".as_ref(),
      authority.key().as_ref(),
    ],
    bump = _bump,
    has_one = authority,
  )]
  pub funds: Account<'info, FundsSPL>,

  #[account(
    mut,
    associated_token::mint = mint,
    associated_token::authority = funds,
  )]
  pub funds_ata: Account<'info, TokenAccount>,

  pub mint: Account<'info, Mint>,

  #[account(
    init_if_needed,
    payer = authority,
    associated_token::mint = mint,
    associated_token::authority = destination,
  )]
  pub destination_ata: Account<'info, TokenAccount>,

  /// CHECK: Destination Account for Withdraw Funds
  pub destination: AccountInfo<'info>,

  #[account(mut)]
  pub authority: Signer<'info>,

  pub rent: Sysvar<'info, Rent>,

  pub token_program: Program<'info, Token>,

  pub associated_token_program: Program<'info, AssociatedToken>,

  pub system_program: Program<'info, System>,
}```

```pub fn withdraw_funds_spl_instruction(
  ctx: Context<WithdrawFundsSPL>,
  _bump: u8,
  amount: u64,
) -> Result<()> {
  return transfer(
    CpiContext::new_with_signer(
      ctx.accounts.token_program.to_account_info(),
      Transfer {
        from: ctx.accounts.funds_ata.to_account_info(),
        to: ctx.accounts.destination_ata.to_account_info(),
        authority: ctx.accounts.funds.to_account_info(),
      },
      &[&[b"funds_spl".as_ref(), &ctx.accounts.authority.key().as_ref()]],
    ),
    amount,
  );
}```

Gives me following error:
```PDA: Gp4zKwwvBRRGm2i7NTsLvFGTXaB8wYfHgffAJd4S4jYd
PDA ATA: 3SxUZCzoWpk6pvLKZe4BPnXPa5SwjX24txnZZQMDY9k5
Destination ATA: 8ZRqhf1GBCpVaRBCHEtJCQHRpc9y68U7jC5qtAssQ45D

Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account
    Program 8jUjUFViwpU8kbAxuw8RS7W5qh4NzzwfqJLyDpnyXZwj invoke [1]
    Program log: Instruction: WithdrawFundsSpl
    Gp4zKwwvBRRGm2i7NTsLvFGTXaB8wYfHgffAJd4S4jYd's signer privilege escalated
    Program 8jUjUFViwpU8kbAxuw8RS7W5qh4NzzwfqJLyDpnyXZwj consumed 38462 of 1400000 compute units
    Program 8jUjUFViwpU8kbAxuw8RS7W5qh4NzzwfqJLyDpnyXZwj failed: Cross-program invocation with unauthorized signer or writable account```
Thanks! I was miss understand about Signer.
It works beautifully, Thank you. üëç  üôè
You would have to just include a `Signer<'info>` account in your derive(Accounts) block.
But yeah, only your program can init an account at one of its PDAs, since only your program can sign for the address. So if you happen to know that your program enforces the kind of invariant above, then maybe you can skip the `constraint =` one.
Strictly speaking those constraints are totally independent of each other. The seeds one only affects the address (anyone can submit an address with the right seeds from the client), while the other one affects the account itself (only your program can write to that account).
Another question, is it ever possible for something other then the program to create a PDA in the same structure as the programs PDA  and used in the program as a PDA? My initial guess is that its not possible
Is there any value in adding a constraint for a value that is also used in the seeds for a PDA?

For example in this PDA `user_position.dca_period_id_before_deposit` is used in the seeds, but its also checked again in a constraint, seems like I dont need the additional constraint?
```
    #[account(
        has_one = vault,
        seeds = [
            b"vault_period".as_ref(),
            vault.key().as_ref(),
            user_position.dca_period_id_before_deposit.to_string().as_bytes().as_ref(),
        ],
        bump = vault_period_i.bump,
        constraint = vault_period_i.period_id == user_position.dca_period_id_before_deposit
    )]
    pub vault_period_i: Box<Account<'info, VaultPeriod>>,
```
Can I ask a simple question? 
I want to work the function by only specific users pool. 
How could get a pubkey of the contract method caller from outside (for example test program ) in the contract function? 
Passing user's pubkey by function parameter is not good idea.  
Is there a solution for this case? 
Thanks.
If so, whats the standard practice for handling this use case., Thanks
Hey guys, is there a way to resize a `#[account]` later on down the track after its been created and used and then needs to change?
nothing complicated, literally just building on the front end provided here: https://www.brianfriel.xyz/learning-how-to-build-on-solana/
where are you seeing this has happened to others?
Hmm, seems like this has been happening to other people, I'm not sure what the fix is supposed to be
Are you doing anything tricky with your bundling etc.?
when I do that I get:
```
 `VM82:1 Uncaught ReferenceError: spl is not defined
    at <anonymous>:1:1
```
I wonder what the issue is here
Thanks <@!134416332509675520>
My mistake.
I thought adding it to the `signers` array sufficed; I guess without modifying the struct it gives me that unknown signer error.
Ah. That's why.
So mark it as `that_account: Signer<'info>`
If it's a system program account then yeah, it needs to sign
So does it not need to sign? If it's sending sol then it probably needs to sign!
The account asking to mint tokens, and sending SOL in exchange. Similar idea to bass581's.
Nope.
The mint authority?
It is the minter here.
Are you creating an account there?
Ah, ok, so what is that account for? Do you actually need to sign for it for some reason?
Nope. A dummy account made with a generated keypair.
Which account? A PDA?
You would need to create a separate account (don't send sol to a program_id account, you can't get it back as far as I know!)
Done. Turns out it was the account I first suspected it would be, but that was an unknown signer when I added it to `signers` for some reason.
Hey everyone. I‚Äôm trying to develop an exchange type of program where a user can pay for tokens with SOL and vice versa. I was wondering, can an executable account receive SOL, or would I need to make a separate account to receive it?
Log them as `theAddress.toString()`
Tried that; none of them match, though I think I might be logging them incorrectly given the difference in length between these and the ones in the program logs.
Basically you just need to figure out what account isn't signing (e.g. try logging all of the account addresses in JS if you have to)
What is that instruction doing? Minting some tokens? Or doing a transfer?
Same seeds and bump as I successfully used earlier in a `new_with_signer` call. The format might be different here, but I assumed that if it were, I 'd get a type error instead of no effect.
Can you post how you're doing the `invoke_signed` part?
Do you know which account is 8YcM... ?
Added; I now have this error due to escalated signer privilege. Signing in the program with the mintHandler PDA using `invoke_signed` has no effect, and signing from the client with the test user initiating the transaction yields an unknown signer error.
Hmm, weird, what happens if you do `import * as spl from "@solana/spl-token";` and then use `spl.TOKEN_PROGRAM_ID`?
^ I can even click through the definition. the solana/spl-token is sitting in my `node_modules`...
In the browser console, I'm seeing:

```
TOKEN_PROGRAM_ID
VM2276:1 Uncaught ReferenceError: TOKEN_PROGRAM_ID is not defined
    at eval (eval at transferOwnership (Main.jsx:34:1), <anonymous>:1:1)
    at transferOwnership (Main.jsx:34:1)
```
üëã I've got an import in my javascript file: `import { TOKEN_PROGRAM_ID, AccountLayout, u64, Token, MintLayout } from "@solana/spl-token";`

In `package.json` I have

```
{
  "name": "app",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@material-ui/core": "^4.12.3",
    "@material-ui/icons": "^4.11.2",
    "@project-serum/anchor": "^0.16.1",
    "@solana/wallet-adapter-base": "^0.6.0",
    "@solana/wallet-adapter-material-ui": "^0.12.1",
    "@solana/wallet-adapter-react": "^0.12.0",
    "@solana/wallet-adapter-react-ui": "^0.4.1",
    "@solana/wallet-adapter-wallets": "^0.10.0",
    "@solana/web3.js": "^1.29.0",
    "@solana/spl-token": "^0.1.8",
    "@testing-library/jest-dom": "^5.11.4",
    "@testing-library/react": "^11.1.0",
    "@testing-library/user-event": "^12.1.10",
    "notistack": "^1.0.10",
    "react": "^17.0.2",
    "react-dom": "^17.0.2",
    "react-scripts": "4.0.3",
    "web-vitals": "^1.0.1"
  },
  "proxy": "http://localhost:3001",
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}
```
Does anyone know any examples with spl token staking using Anchor?
Ah. Thanks; trying that now.
In solana, whenever you do a CPI (here, to the system program), you need to *also* pass in that program itself as an account
So add a `system_program: Program<'info, System>` to your declare(Accounts)
(It has the zero address)
Oh, sorry, different problem‚Äîyou actually need to pass in the system_program as an account from the client

Post the transfer code and it'll probably be clear
Nothing got autofilled per-se, but if you have some `Pubkey` in a struct that you never initailized, it'll be the zero address
I don't think I ever explicitly used the zero address, and if it was used by `anchor_lang::solana_program` when I called it, I might want a way to make it not unknown anymore?
Best explanation is always jumping to source üòõ https://github.com/project-serum/anchor/blob/master/ts/src/provider.ts#L92
how does that get the wallet/user to sign?
But here you'd use `program.provider.send(theTx)`
https://github.com/solana-labs/solana-program-library/blob/master/token/js/src/actions/createMint.ts#L41
Yeah, it's kind of dumb but that's the current situation.
Also, got an example of submitting the tx directly?
you are saying that I need to repeat all of the following:

```
static async createMint(
    connection: Connection,
    payer: Signer,
    mintAuthority: PublicKey,
    freezeAuthority: PublicKey | null,
    decimals: number,
    programId: PublicKey,
  ): Promise<Token> {
    const mintAccount = Keypair.generate();
    const token = new Token(
      connection,
      mintAccount.publicKey,
      programId,
      payer,
    );

    ...

    return token;
  }
```

in my own javascript call? There's no other abstraction or method that wraps this?
Try jumping to source on that createMint call
any examples on 1/ recreating the instruction? and 2/ submitting a tx directly?
This is super irritating, but you actually need to just basically re-create the instruction issued by the `createMint` call, and submit a tx yourself
üëã I have a js code snippet that looks like:

```  
const wallet = useAnchorWallet();

async function setupTest() {
    const [connection, provider] = await getProvider();
    const program = new Program(idl, programID, provider);
    const currentWallet = provider.wallet;
 
    const walletPubKey = provider.wallet.publicKey;
    
    enqueueSnackbar(`Creating a new mint..${provider.wallet.publicKey}`);

    const mintA = await Token.createMint(
      program.provider.connection,
      wallet,
      walletPubKey,
      null,
      0,
      Token.TOKEN_PROGRAM_ID
    );

    const mintATokenAcct = await mintA.createAccount(walletPubKey);

    // doesn't work on devnet for some reason...
    // const airdropTx = await program.provider.connection.confirmTransaction(
    //   await program.provider.connection.requestAirdrop(wallet, 10000000000),
    //   "processed"
    // );

    let acct = await program.provider.connection.getAccountInfo(walletPubKey);

    enqueueSnackbar(`Done testing`);
  }
```
In the await `Token.createMint` call, the second argument is a `Signer`. How can I get my wallet to sign this transaction? Normally I'd pass a keypair through in my program tests, but struggling to figure out how i can do the same thing via a wallet signing
Doesn't seem like the airdrop works, the wallet balance stays constant. Is there a limitation around airdropping on devnet?
Have this snippet running on devnet:

```
const [connection, provider] = await getProvider();
    const program = new Program(idl, programID, provider);
    const wallet = provider.wallet.publicKey;
    
    enqueueSnackbar(`Airdropping a couple tokens to..${provider.wallet.publicKey}`);

    const airdropTx = await program.provider.connection.confirmTransaction(
      await program.provider.connection.requestAirdrop(wallet, 10000000000),
      "processed"
    );
```
Does this mean I failed to specify a required address and it got autofilled?
(Amusingly, in base58 zero prints as 1 ü§¶‚Äç‚ôÇÔ∏è)
Yep, that's the zero address
I tried to involve SOL transfers in my program, and got this error. Any idea why an account full of 1's was referenced? Some kind of default ID?
or `anchor deploy` getting this rpc request error?

```
Error: RPC request error: cluster version query failed: error sending request for url (http://0.0.0.0:8899/): error trying to connect: tcp connect error: Connection refused (os error 61)
There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: "", stderr: "" }.
```
is there any reason, besides having a sporadic connection that `anchor test` wouldn't be able to periodically get the blockhash
ahh annoying, Ill stick to using spl-token then
Not as far as I know (all token stuff, more or less, goes in the spl library)
or is there an equivalent function to check if a token account exists and another to create one?
Nope
Hi, slightly related to this. I've been using `getOrCreateAssociatedTokenAccount` from `solana/spl-token` is there an equivalent to this in web3.js? It'll just be less things for me to import
You actually can't add solana-sdk as an on-chain dependency‚Äîit's only for use off-chain.
Yep, you can use `connection.getTokenAccountsByOwner`
Got this error when adding `solana-sdk` as a dependency. Any idea what's happening here?
üëã in web3.js is there a way to get all token accounts owned by a particular publicKey?
don't know whats worse having this in the test script or leaving the hardcoded keypair  üòÖ
had to copy paste this ```export default class NodeWallet implements Wallet {
  constructor(readonly payer: Keypair) {}

  static local(): NodeWallet {
    const process = require("process");
    const payer = Keypair.fromSecretKey(
      Buffer.from(
        JSON.parse(
          require("fs").readFileSync(process.env.ANCHOR_WALLET, {
            encoding: "utf-8",
          })
        )
      )
    );
    return new NodeWallet(payer);
  }```
and change ANCHOR_WALLET to MY_CUSTOM_ENV_VAR. Is there a function like NodeWallet.local() but can take in other env variables? I think it would be nice so people don't need to copy paste this json parsing part.

why is that happening
unable to resolve dependency tree
`MY_CUSTOM_ENV_VAR=path/to/some/wallet anchor test` and then go use `process.env` to make that keypair in your program
At any rate, you could always just use your own env variable
It's 100x easier than trying to rely on devnet
Oh‚ÄîI would 1000% recommend doing your testing locally
hmm last time I tried I kept on getting rate limited
```.js
await program.provider.connection.requestAirdrop(
      someUser.publicKey
      2 * anchor.web3.LAMPORTS_PER_SOL
    );
```
What trouble?
ya I need them to be specific, cause I've had some trouble airdropping
ohhh
`const someUser = anchor.web3.Keypair.generate();`
I'm saying just generate fresh ones‚Äîor do you specifically need them to be certain keypairs?
is there like some env variable or something where I can store them?
ya but I dont want to hardcode those keypairs in my test script
I would probably just make some fresh keypairs in the tests and then airdrop them some sol
Is the goal just to have some user wallets in your tests?
But using the signers and bump in `new_with_signer` fixes this error; I can dispense with the program ID being used in the seeds accordingly
?
Ah, ok, maybe that env var just doesn't do what you want
Guess I could have just dispensed with that.
hmm now im just getting `Error: Program's authority Some(2QqWUAdCfvbwVnkwSaVePnD5E5xpevZWo734JMqpY1eB) does not match authority provided 45vmGc9sVW52Tb4F77Xt3X5Ft1PVSzS3HAyno2E166zN` It has the same effect of changing the wallet address in anchor.toml
This was why.
Ah. Was unaware of that.


//////////////////////////////////////////////////////////////////////////////////////////

Good day! Is there a way to check which program called you?
sweet, I am using `to.be.rejected` in my Hardhat testing. Didn't notice that it is also awailable for Anchor testing.
Hello,
I am trying to create an account where to store some data. The thing is that I want to be used just by the connected wallet and even to encrypt the data stored. 
I am new to this and I imagine that I need the secretKey of the connected account, but that is not possible right ? 
Do you guys have any suggestions ?
Changing the owner of an ATA is pretty yucky, since you generally really expect person P's mint M ATA to be owned by person P. So I would rather transfer.
Also, what is the best practice for locking NFTs ? 
1) Changing ownership of user ATA to PDA
2) Transferring NFT from user ATA to PDA ATA
Ahhh ok
Can't do randomness on-chain like that, you'd have to use an oracle or something

how to fix deploy error?
hey, how can I fix this?
Please don't at-message unless it's really urgent üôè These are general rust questions that are probably best learned about by googling
Hi Team. I am planning to use Bonfida vesting program in my program. Any idea how I can make CPI calls to bonfida vesting contract without putting all of the bonfida program in my programs folder as puppet.
I'm using https://www.chaijs.com/plugins/chai-as-promised/ . It has `to.be.rejected` and `to.be.rejectedWith()` assertions
`#![deny(missing_docs)]
#![cfg_attr(not(test), forbid(unsafe_code))]`
what does that mean? Please explain. <@!252808943238119424> <@!831450660146642974>
does someone have an example on how to check for errors in a test case? I am using `expect(await .....).to.throw(AnchorError)` but the case is still marked as failed
correct ser
`Halted` is your custom error varient right?
gm, spot on. access control modifier validates a state property (in this case, `is_halted`, a bool representing a halted flag) is not true, and if it is it will throw the `Halted` error
look at the size of the .so, then solana rent <size-of-the-.so>, should be close
kind of
yes
Is there a way to know the deployment cost beforehand?
Hey guys! Is there any known way to generate typescript code from an IDL?
can confirm form here, `if http://state.is_halted { return Err(ErrorCode::Halted.into()); }` though <@!848333406849073202> could confirm more
It's just an error variant
Could you explain what the require!(!state.is_halted, Halted) part means? Specifically how to read/interpret the syntax, and what "Halted" is referring to?

From this thread
https://twitter.com/0xDEADBEEFx/status/1486331068085157894
how can i get the transaction id of a transaction that just happened?
the new version of anchor use Result<()>, I thkn the main reason here would be error-redesigning. 
https://github.com/project-serum/anchor/pull/1462
found a good one, Jet Protocol 
https://github.com/jet-lab/jet-v1
you need to include `use std::str::FromStr;`
hey, what's the problem here?
what's difference between `ProgramResult` & `Result<()>` ? 
<@!401712056543477761> <@!717956950737813594>
I saw an escrow program in the tests directory on the anchor github repository
found this one https://github.com/QuarryProtocol/quarry
I think you are asking about CPI? Those sort of actions are controlled by different programs, so you need to invoke them inside your own program to do that, that is called Cross-Program Invocation. There is a section in the book
What are some of the projects on Solana that use Anchor and are open source? I tried looking at Solend, but it looks like they're using vanilla Solana
that's what i thought too, but someone in another discord said that i'd hit compute limit after just a few "guests", but i don't know enough to confirm. üòÇ i think for now i will just set a `max_guests` or something on Party, so at least whoever creates one can control how much space to allocate. and just do the Vec<Pubkey> thing. this is just a toy app to learn anyway, thanks for rubber ducking with me though!
Not great/maybe super inefficient though.
And then filter etc.
Definitely not in the contract itself, but you can kinda do that on the client, using `program.account.books.all()` (hacky)
yep that's what i did initially. and then i got stumped because i realized you couldn't call smth like `author.books`  anywhere
Yeah, I guess it depends on what kind of access patterns you need. The literal translation of the diagram above would be to have each of the "many" accounts have a `Pubkey` that points at the account that "has" them.
most examples i run into are basically just storing all references in a Vec (https://imfeld.dev/writing/starting_with_solana_part04), or just as Pubkeys if it's just two addresses like in a typical escrow (https://paulx.dev/blog/2021/01/14/programming-on-solana-an-introduction/). so wasn't sure if that's just how it's done
yeah, basically. just not sure how to do in an anchor program since you have to pass in all accounts to transact. i thought maybe i could do some kind of client filter, but that's probably not very secure and i was told that it would take up too much compute anyway.
Do you want literally this kind of structure? https://guides.rubyonrails.org/association_basics.html#the-has-many-association
does anyone have any tips on how to model a "has many" relationship in Solana? i have a "Party" PDA, and a Party can have many "Guests." I could just store a Vec<Pubkey> in Party ... but that seems inefficient to have to pre-allocate that space (when i might not need it), and also just seems weird, at least from rel db perspective
I have a question for you guys ! I play a lot with anchor and i know how to store String integer etc but how can i manipulate real SOL. For example stake sol or juste create a smart contract that do something like  a escrow ? I didn't find doc that talk about transaction in smart contract.
I assumed partialSign had to be done first, and sign could then be done to finish. Just the reverse lol
For search purposes, ^ may help someone encountering `Signature verification failed`
<a:ScreamsExternally:469513828191961098>
Omfg sign obliterates existing signatures and partialSign doesn't
No, only the program can initialize an account there, because only the program can sign for that address
Is it possible to "squat" on PDAs? For example my program has an `initialize` instruction that creates a PDA  with seeds `["manager", caller.key()]`.
Can someone initialize that PDA in advance and prevent that caller from using the program?
You've done it again, that fixed it. Thanks!
No mutation
It gives you an *additional* byte
Oh, sorry, no, that's not how it works
`&[that_pubkey.as_ref(), &[the_bump]]`
That's how the bump is found, but you need to pass it separately‚Äîyou're mutating the rest of the seed
That way of passing/setting the bump almost definitely looks wrong to me‚Äîwhy are you setting seed_with_bump[31] = bump?
Are there any best practices or guidance for when to use a PDA vs a keypair for an account for your program to use?
Yeah I just tried it, doesn't seem to work. Not a big deal
damn I was afraid of this lol. Ty Ty
Checked Anchor docs and they don't explicitly say you can custom error with seeds check. But there are custom errors for other constraints using the @ symbol. I'd give it a shot with seeds and test to see what happens https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html
Don't think so, not as far as I can tell
No, no fancy way to do it as far as I'm aware. You'd have to either morph one context into the other (possibly painful), or just make a helper function that takes the common arguments and invoke it from both places, etc.
Hey all. If I wanted to re-use a function between two different Contexts, how would I do it? Currently using `impl` for one Context but not sure how I can re-use that in the same main function since it takes in a single Context<type>. 

i.e. `pub fn approve(Context<Approve>)` and `pub fn pay Context<Pay>` have nearly the same logic. Both need to transfer using the same accounts `from`, `to`  `authority` and `program`. 

Am I supposed to write a ::try_into() or something for both functions? Is there a way to do some kind of generic Context that works for only those two types?
How would one maintain a 1 to 1 relatinship across programs and their accounts?
Is there a way to return a custom error if a seeds constraint is violated?
I have a question for you guys ! I play a lot with anchor and i know how to store String integer etc but how can i manipulate real SOL. For example stake sol or juste create a smart contract that do something if we pay etc ? I didn't find doc that talk about transaction in smart contract.
sweet will do, thank u ser
I would try searching the anchor repo for examples, you actually have to pass a full "AccountMeta", not just a pubkey: { pubkey: theAddress, isWritable: ..., isSigner: ... }
Ah, no, I think you'd want to use the `.remainingAccounts([...])` API
passing in remaining_accounts like this btw

await program.methods
      .play(
       bump,
      'test',
      entryFee,
      rpbpTreasuryBump
      )
      .accounts({
          wallet: player7Wallet.publicKey,
          rpbp: rpbp,
          rpbpFeeAccount,
          rpbpTreasury,
          authority,
          instructionSysvarAccount: SYSVAR_INSTRUCTIONS_PUBKEY,
          systemProgram,
          time: SYSVAR_CLOCK_PUBKEY,
          //remaining_accounts
          playerPublicKeys,
          player2PublicKeys,
          player3PublicKeys,
          player4PublicKeys,
          player5PublicKeys,
          player6PublicKeys,
          player7PublicKeys
      });
lol no clue whats going on with formatting wth
sorry for the double ping, weird formatting issues
hey <@!134416332509675520> I see you've posed before that there are examples of passing remaining_accounts from the js side, but I havent been able to find any/a good way to parse out those remaining accounts. I've got my play handler with some logic to handle results 
I wanted to iterate the remaining_accounts so i can transfer spl or sol or whatever since I only have the publicKey info stored on my Game struct

```
pub fn play<'info>(
        ctx: Context<'_, '_, '_, 'info, Play<'info>> 
        ...
        let p_account: Vec<&AccountInfo> = remaining_accounts
                    .into_iter()
                    .filter(|r| r.key() == p.owner.key()).collect();
```
that was it, you the man!
That makes sense, I'll give that a try. Thanks!
You probably want to do `token::mint` and `token::authority`. What you have above says you want to use an *associated* token address, but you're not (ATAs are PDAs derived from the associated token program, but you're using a keypair address)
try calling provider.connection.signTransaction()
I'm building a transaction, signing it, then sending it to over the internet for someone else to sign
I don't want to rpc as I don't want to actually call the chain
yea youmight be meaning to to program.rpc or program.instruction
Mm, I think that `signers` arg just doesn't exist for `.transaction`
provider.connection.signTransaction(txn) would sign it
signatures might be null because the txn isnt executed and youre already passing the signers keypair, but youre not signing the txn by doing so
sorry not sure the context let me see
Just wanted to bump for cqfd, 0xDon, or anyone else who might know offhand why a signature isn't being added :). Thanks ‚ù§Ô∏è
my program was 0.23 but seems my avm was on 0.22.1
maybe it was avm?
wth is happening lol
Also my seed constraint error just magically disappeared...
ill give it a shot
awesome
But to close one of your own accounts, you can write an instruction and use the `#[account(close = who_to_send_the_lamports_to)` attribute over it in the derive(Accounts) struct
wanna just close it from the program, adding an ix to close something, essentially what im trying to achieve is allowing a user to create a game multiple times
yea
It's about which program owns the *account*, not about the address
PDAness isn't strictly relevant
Is there syntax for closing a PDA?
But wanted to give it a shot
Only the program that owns an account can close it
Its not so I figured it wouldnt work
Well, it depends on if its a token account
Ill add that ix
Cool cool
Ah, no
So ill need to add that fn in my program? Was using SPL
(You can't close one of your own accounts unless you specifically provide an instruction for doing so)
Ah,
Where is that createCloseAccountInstruction coming from? I guess you have a `pub fn close_account` in your program?
yea its definitely frustrating, im actually running into something similar right now lol
hmm.. I will probably need to some more time on this thing
Trying to close a PDA im assuming this is correct? But getting this:
`Error Message: 8 byte instruction identifier not provided.`
```const ix = createCloseAccountInstruction(rpbp, authority, authority, undefined, program.programId);
    const txn = new anchor.web3.Transaction();
    txn.recentBlockhash = (await provider.connection.getLatestBlockhash()).blockhash;
    txn.feePayer = authority;
    txn.add(ix);
    const txSigned = await provider.wallet.signTransaction(txn);
    const closeTxn = await provider.connection.sendRawTransaction(txSigned.serialize());
```
but the account get created but calling fetch says it doesnt
yea ive been seeing this a lot when running tests, im not exactly sure what the cause is
Aha! ty ‚ù§Ô∏è
Think you'd probably want to not use the implicit one at all (it's an optional third argument to that Program constructor)
Ty on the keypair.fromKey, that def sounds useful
How do I hook into the implicit provider that's being built when I do program = new Program(idl, programId) ?
i am not sure, it seems that nothing will happen until I just manually refresh everything. Moreover, since I am `await`ing on this function call, the only time I should see the error is when the promise will get resolved.
might be latency then
where are u getting the private key from? You can always Keypair.fromSeed or Keypair.fromKey
I think that the account is definitely being created, as proven by the fact that if I just refresh the page and fetch all the accounts, the new account comes up just fine.
Can we pass ANCHOR_WALLET into anchor not from a file referenced by an environment variable? From a security perspective, hoping to not leave a private key lying around on the file system.
no, still nothing.
provider.connection.confirmTransaction(tx, 'confirmed'); then call fetch
no, running this from a click handler from the front end
try doing this
are you running this code from a test?
ü•≤
changed my code to this:-
```

    const tx = await program.value.rpc.sendMessage(content, roomPublicKey, {
        accounts: {
            message: message.publicKey,
            author: wallet.value.publicKey,
            systemProgram: web3.SystemProgram.programId,
        },
        signers: [message]
    })

    console.log(tx);
    const messageAccount = await program.value.account.message.fetch(message.publicKey)

```
Was able to check the tx hash and It seems that the account is actually being created.
Notice that the account which I am not able to fetch is actually being created.
I found couple of interesting things
thanks for this


//////////////////////////////////////////////////////////////////////////////////////////

Ah, were you using auto bumps on non-init stuff?
i posted the log above. But I just also refactored it (by passing in the bumps as variables) to not use the auto bumps and I get about a 0.3% failure rate now instead of 5%.
Thanks you as always!
Yeah, bit more info here: https://github.com/project-serum/anchor/pull/1380
from: https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html
```
Use the seeds constraint together with bumpto create PDAs.
init uses find_program_address to calculate the pda so the bump value can be left empty.
```
nvm, I found the answer!
Hey all!

Just updated anchor, and I get an error when trying to init an account with a seed/bump. I can work around this, but I'm curious why we can't/shouldn't? It worked fine before
qq about the PDA docs here: https://book.anchor-lang.com/chapter_3/PDAs.html

```
pub struct UserStats {
  level: u16,
  name: String,
  authority: Pubkey
}
The authority would be the user the accounts belongs to.

This approach creates the following problem. It's easy to go from the user stats account to the user account address (just read the authority field) but if you just have the user account address (which is more likely), how do you find the user stats account? **You can't. **
```

couldn't you just filter on client by authority? probably be inefficient (maybe to the point of being impossible?)
how can i get slot hash of specific slot on-chain?
Anything else people do to increase the speed? Is Quicknode not fast enough?
I am using the same private RPC node for one client whose job it is to send a tx and another client whose job it is to verify the tx. Also using commitment: "proccessed"
Hey, what do people do to speed up txs
Yep, covered here: https://jstarry.notion.site/Program-deploys-29780c48794c47308d5f138074dd9838
one way to do that is to use close constraint
Is there a guide on how I can close a program and get its rent back?
Hello! Wanted to give some progress on this weird problem.. Finally I am able to fetch The account which I wanted to fetch, but I am not able to understand what is happening.. 
So the problem was here:-

I was creating a `Provider` object with  the following commitments:-
```

const preflightCommitment = 'processed';
const commitment = 'processed';
const programId = new PublicKey(idl.metadata.address);
let workspace = null;

export const useWorkspace = () => workspace;

export const initWorkspace = () => {
    const wallet = useAnchorWallet();
    const connection = new Connection('http://127.0.0.1:8899');
    const provider = computed(() => new Provider(connection, wallet.value, { preflightCommitment, commitment }))
    const program = computed(() => new Program(idl, programId, provider.value));

    workspace = {
        wallet, 
        connection, 
        provider,
        program
    };
}
```
This was actually giving the error that the account can not be fetched. 
But when I passed an empty object as the third parameter:-
```
    const provider = computed(() => new Provider(connection, wallet.value, { }))
```
i am able to fetch the account, in the correct manner, but it takes about 3-4 seconds for the changes to be reflected. Any details on what is happening here?

Try posting the program log, will have more info about where the compute is going
I have an instruction that succeeds 95% of the time. The other 5% it goes over the compute budget. There's 4 PDAs on the instruction. I'm guessing this variance is largely because sometimes it takes longer to find the PDAs (if not this what else can cause a high variance in compute?)  I'm using the new auto "bump" on my pda account specifications.  Should I be passing the bumps in from the client to reduce compute usage? If so what is the best way to do this in the most current version of Anchor ?
That one
Thanks but I don't think i was concerned about the authority variable. Its the [#account specifier that defines it as owned by the program, but is it the one on the State struct or the one on the variable state_account inside the Create struct ?
Authority is just a field, like count.
It has nothing to do with the authority. You are using "init" here, this will set the located account, here State to be owned by the program.
or this one?
so this specification defines it as owned by the program?
Program ownership is orthogonal to address stuff
The account is owned by the program because you specified its struct with `#[account]` on top
<@!134416332509675520> sorry to bug you again. Just looking for your response to my last question when you get a chance.
Yeah
the syncnative part
Can I do that from the typescript side of things?
You send actual real sol to a wrapped sol token account, and then poke the account with the syncnative instruction, so that its *wrapped* sol balance (its token balance) reflects the new native sol in the account.
It lets you convert actual real sol to "wrapped sol", the tokenified version of sol (sol is just sol, it's not an spl token‚Äîhence the idea of "wrapped sol", in case you wish sol were a token).
It's misnamed, yeah
```
// Send rent back to user if account is empty
        ctx.accounts.escrow_usdc.reload()?;
        if ctx.accounts.escrow_usdc.amount == 0 {
            let cpi_accounts = CloseAccount {
                account: ctx.accounts.escrow_usdc.to_account_info(),
                destination: ctx.accounts.user_authority.clone(),
                authority: ctx.accounts.ido_account.to_account_info(),
            };
            let cpi_program = ctx.accounts.token_program.to_account_info();
            let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer);
            token::close_account(cpi_ctx)?;
        }
```

Reference
https://github.com/project-serum/anchor/blob/master/tests/ido-pool/programs/ido-pool/src/lib.rs
If you close an account you need to be the owner. When closing an account you need to pass the "destination" account info, this account will receive the lamports of the closed accounts.
so how does account closing actually work, and which address is the sol balance sent to ? does it remember which account created it ? and upon closing transfer the balance to it or what ?
What does exactly sync-native do in the spl-token program? I don't really get the explanation that the CLI has
https://github.com/project-serum/anchor/blob/master/tests/pda-derivation/tests/typescript.spec.ts
Is there an example of this somewhere?
https://mobile.twitter.com/anchorlang/status/1491906358026907648/photo/1
Looking through the anchor tests and a bit confused when  "ctx: Context<'_, '_, '_," is needed and what it means. Could someone explain what the 3 blanks are referring to and how to interpret it? Googling says sometime about lifetimes in Rust, but I'm still confused about how to inteprete it in the Anchor programs after watching a few youtube videos about lifetimes
ah because of I forgot to update my client to 0.23.0. Thank you üòÖ
Hi, 
Is there a wait to get the transaction signature of a CPI ?
```
        let tx = anchor_lang::solana_program::program::invoke(
            &ix,
            &[
                ctx.accounts.player.to_account_info(),
                ctx.accounts.authority.to_account_info()
            ]
        ).unwrap();
```
(tx is only empty function ())
I try with newly created project and it has types. I think something wrong with our project LOL
shouldnt it be burn from? whatever prob just semantics
the to on the burn is throwing me off tho
<a:kek:886686729631825940>
that might be it lol
ope
can I ask the authority is an ATA instead of PDA?
this is normal
getting this error: ```EhvCuwkb583rS18gJ7DyDX8C8LjNBAcVHvJFEUiNuQFg's signer privilege escalated
    Program R9pH1xCAPNWcaTMggYBhduoXTTxqrtepQnHaTLjJrzT consumed 111261 of 200000 compute units
    Program R9pH1xCAPNWcaTMggYBhduoXTTxqrtepQnHaTLjJrzT failed: Cross-program invocation with unauthorized signer or writable account```
I think it has something to do with the to: field? for burn why is there a to:
trying to call burn on spl token thats owned by the PDA's token account :
```
let cpi_accounts = Burn {
            mint: mint.to_account_info(),
            to: program_fee_ata.to_account_info(),
            authority: program_fee_ata.to_account_info(),
        };
        let signer_seeds = &[&seeds[..]];
        let cpi_program = token_program.to_account_info();
        let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer_seeds);
        anchor_spl::token::burn(cpi_ctx, total_burn_fee)?;
```
I try to use `program.methods` but after my instruction the type became `any` which will lose the will of typescript is this normal?
so in the examples where you create the state account and update the counter, that is a keypair address account. But what makes that keypair account owned by the program?
No, in general you may need to do `ctx.accounts.that_account.reload()?`
How come the amount doesn't change before and after the transfer?
is: `ctx.accounts.SomeAccountName` not updated if I perform a transfer within a function?
Hmm. I didn‚Äôt realize that
the deployer would be referencing the wallet I created to deploy the program right?

am I bugging here or
Got it
You need any #[instruction(...)] thing to exactly match the order of the arguments in the actual `pub fn your_instruction` part (minus the ctx arg)
And double nope, the only way to mutate an account's data is to ask its owning program to do it‚Äîyou knowing the secret key doesn't let you edit the data however you want
Nope, the program doesn't need a signature to mutate an account it owns
if you wanted your program to modify data at the keypair address the client would have to know the keys right? If they have the keys they can in theory use them to edit the data however they want right?
So I guess in case I send him the bump, but I need to work with other instructions, I have to call the bump in the instruction. Am I wrong?
<@!134416332509675520> And also I have an instruction problem that can't be deserialized. I have seen other people and the help you have given, and I have been very careful about the order of my instruction.

My instruction is waiting:
A title and a content

I send it:
A bump, a title and a content

Except that the bump was removed from the instruction together earlier. And what surprises me the most is that I do another test with the same function and the same values inside, and it works ü•≤

Why he wait for u8 ? I specify its a u64, I necessary need to set u8 if I wanna use it in a seed ? So the counter can be greater than 255 üò¢
I mean, for example, your wallet address in phantom or whatever is a keypair address
How come?
Doesnt seem as secure as a pda
You have to just hope that the client remembered to sign for any relevant keypairs
You can't otherwise
With the `signers: [...]` thing
Has to be passed into the application?
How do you sign as a keypair then?
Or that's the only way to sign for a keypair address
Yeah, they can't
Im not even sure ive seen an example of a keypair address signing that wasnt passed in as a signer
Then there's the account size limitation: currently PDAs can only store accounts up to 10kb in size, vs 10mb for keypair addresses.
Are their other* limitations of pdas vs keypairs?
But PDAs are nice since you get to "name" the address in a potentially memorable way, whereas keypair addresses are random‚Äîit's up to someone to actually remember them.
The main fundamental difference is in how they're signed for: keypair addresses require the secret key, whereas PDAs can only be signed for by their deriving program. So if you care about how you sign for the address you'll be forced to use one or the other.
Are there any best practices or guidance for when to use a PDA vs a keypair for an account for your program to use?
I don't know if I should worry about that lmao
When I try to analyze programs, developed recently, I often see the notion of rent
Basically never
On the other hand in the many docs I see talk about rent, but in the tutorials they never mention it. At what point should I be interested in the rent?
Waiting for "blog_v0" and send "blofg_v0"...
Its work now üëç
Problem come from the seed !
Scroll up in that test output maybe
Damn I found the problem
In .anchor/program-logs
Mmh I just have this :
Streaming transaction logs mentioning Gy2T8gX6mcgVe57vxmMUg888iRTsLUtR8GDXpHHYox2W. Confirmed commitment
Find the full program log, that's just the stack trace
Also, try literally reading the source code for it
My last problem come from test. He waiting a signer or writable account. But I use a PDA so who is signer ?
Okey !
"Find a valid program address
Valid program addresses must fall off the ed25519 curve. This function iterates a nonce until it finds one that when combined with the seeds results in a valid program address."
Mm, no, that's not a super precise way to phrase it. Have you read the `Pubkey::find_program_address` source code? I would suggest doing that
By the way bump is the number of tries to find an address that is not a real wallet right?
Thanks you üôÇ
Got it
No, it's always a u8
And there are cases where the space for the bump is greater than 1?
Okey so if I use u64 I need to put 8 on space !
Yes I am boring with space, it takes time for me to get used to it
Nope. u8 = 8 bits = 1 byte. u16 = 16 bits = 2 bytes, u32 = 32 bits = 4 bytes, u64 = 64 bits = 8 bytes
Its always 1 for u8/16/32/64 ? lmao
Nope, 1 more guess üòà
I replaced count by u64, so not 1 but 4 ?
At any rate, you want space = 8 + 1 + 1 + 32
Mm, yes, though I'm not sure why you wrote bump = 2 ü§î
"Bump's are u8" so 1 byte. In my case I have two u8 no ?
Why 2?
So in my case, bump = 2 ?
No, the space is for the Blog struct itself
In my example there is a string + a key ! That's why I thought of 4 for the string + 3 (I don't know) + 32 for the key
According to that struct anyway, so if you want counts higher that 255 you need to use a bigger type, like a u16 (up to ~64 thousand), or a u32 (~4 billion) or a u64 (~ 16 * 10^18) etc.
post_count is also a single byte
Not quite‚Äîthe discriminator is 8, yep. Bump's are u8's, which always take 1 byte (that's what a u8 is‚Äîa byte)
Like this cold I would say:

discriminator = 8
bump = (7 + 32) (I don't know why 7 yet)
counter=4 (I suppose there will be no more than 9999)
account=32

So in total 83
At any rate, how much space do you think you need?
Well, doesn't really matter, it's just unnecessary, probably
Probably don't have any need to do that derive though (I would delete it)
post_count have a default value no ?
How come you're doing `#[derive(Default)]`?
(Yes I'll remove the instruction)
It looks like what you say anyway
In this case though the account is probably owned by your program, because it's a Blog‚Äîpresumably one of your own `#[account]` structs
The *address* is derived from the program, but that in general says nothing about program ownership
Crap
Totally different ideas
No, seeds are separate from program ownership
Well, I found a nice tutorial that mixes what I've understood so far but adds the PDA layer.
So I try to follow it, but I see that most of its code is already deprecated.

Now I want to initialize a new account, based on a structure that contains a bump, a counter (u32 I guess) and an account (32). This account will be, if I understand correctly, owned by the program thanks to the seed
You need to come up with something for the space üßÆ What have you tried so far?
Still have some errors. I don't know the space I need.. And I don't know why I have some errors on #[program]
Sure
I remove the instruction too ?
No equals sign after the bump when using `init`
Just do
```.rs
bump,
payer = user
```
(I use anchor 0.23.0)
I try to call like that
Btw I wanna try to builg my program and I have soooome errors ! Im totally lost. All problems come from the bump ?
Or what I understand is that this seed can be random, and if someone wants to use my program he can use the same seed to derive it, right?
I mean, if the Account<'info, Type> name is bob, the seed should be : b"bob" ?
Hi! I have a question about seeds : In this exemple, why we use b"vote_account" ? The string can be random ? Or the string == the account owned by the program ?
https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator
how to handle this correctly? I can put just ```?``` at the end and it disappears but idk what it's doing xD
If you're running `anchor test` and local validator at the same time, you're gonna have a bad time
I'll try it, thank you!
Via its AccountMeta stuff
I think what's happening is that if you don't specify `#[account(signer)]` or `Signer`, then you would need to go out of your way to mark that account from the calle*r* as a signer
Actually, right now I passed it as `AccountInfo` and checked inside a contract whether it is a signer or not, and the result is that it was, I'll verify one more time with an Anchor `Signer` account and if it doesn't work I'll try to build smallest reproducible example
Yes!
Mm, does the callee program specifically ask for that account to be a signer?
I am trying to call one Anchor program by another through an interface, however for some reason even though I do include `with_signer` with correct seeds, the callee doesn't see an account as signed, as if `invoke` instead of `invoke_signed` is called there somewhere


//////////////////////////////////////////////////////////////////////////////////////////

const token = await spl_token.getAssociatedTokenAddress(mint.publicKey, 
      provider.wallet.publicKey, false, spl.TOKEN_PROGRAM_ID,  spl.ASSOCIATED_TOKEN_PROGRAM_ID); like this?
`spl.getAssociatedTokenAddress`
You need to pass in a specific address for `token`
Ah, that's because you're not calculating the associated token address correctly on the client
Yes. I'm getting this error: Instruction references an unknown account 43kPG4Nk3qNTFdGSWaknBbVJ5RUJWUtK1kvgUJN5p4an
 Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: An account required by the instruction is missing
help please
Is that failing?
Is their any codeblock which can tell me how pools are created using solana anchor?
I think you have tried alot
```
‚ûú  solana-burn-token-for-token-v3 git:(main) ‚úó  solana airdrop 2 FdRVDHYNGDdBMeu5konejLNeiiG1DPJVdUv4hEiR9L4 --url https://api.devnet.solana.com
Requesting airdrop of 2 SOL
Error: airdrop request failed. This can happen when the rate limit is reached.
```
Anyone else having problems with solana airdrop on devnet?
the paulx escrow tutorial has a nice way of organizing things imo
I'm a single-file maxi myself lol, but yeah, you can look at open source repos and see a variety of approaches
You can basically do whatever you want‚Äîis there a particular way you'd like to organize things?
I‚Äôd like to reiterate this question. It seems all of the official examples also shove everything into lib.rs
Weird, haha, I wasn't expecting that‚Äîhow is that possible
Funny, it does exist on devnet üòõ Though it's not a program https://explorer.solana.com/address/Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS?cluster=devnet
That's the default anchor program_id, I would be surprised if you snagged that haha
That's your program's address on devnet?
`Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS`
Can you show me the address?
after making changes to `Anchor.toml` do I need to do anything to make sure its active? this is just a vanilla react app
no live validator, the program is 100% on devnet
Are you running with a live validator in the background/maybe didn't deploy?
It is, already gone through all the search results haha
Is your Anchor.toml's program_id right?
Also, is there an example on how to set up connection/provider on the client for Anchor? I'm running into this error and suspect it's because im using incompatible connection/provider set ups

```
Main.jsx:224 Uncaught (in promise) Error: failed to send transaction: Transaction simulation failed: This program may not be used for executing instructions
    at Connection.sendEncodedTransaction (connection.ts:3668:1)
    at async Connection.sendRawTransaction (connection.ts:3628:1)
    at async sendAndConfirmRawTransaction (send-and-confirm-raw-transaction.ts:27:1)
    at async Provider.send (provider.ts:114:1)
    at async Object.rpc [as initializeMint] (rpc.ts:19:1)
    at async createMintAndGrantAuthorityToPDA (Main.jsx:212:1)
```
makes sense
They require an actual explicit keypair (Signer is just a public/private key pair), which is way too strict
They ought to be doing something similar to what anchor is doing (probably, haven't thought about this a ton), and require an argument that conforms to an interface like
```.ts
export interface Wallet {
  signTransaction(tx: Transaction): Promise<Transaction>;
  signAllTransactions(txs: Transaction[]): Promise<Transaction[]>;
  publicKey: PublicKey;
}
```
Yeah, it's basically a shortcoming in the spl library‚Äîthey're using an overly specific/restrictive type, `Signer` (as usual haha Solana names just aren't quite right, `Signer` is definitely not the right name for that type)
apologies for asking so many questions, just trying to fully understand üòõ
ah so this is an explicit short coming of the SPL library? Why is it that their abstraction requires you to rewrite the code necessary to package instructions into the instruction and then make you call an explicit `program.provider.send(txn, ...)`?
Every solana tx requires at least one signature, for that reason
The wallet always needs to sign, since it pays the tx fees
does anchor do this with every RPC call? How does it make the distinction of when the wallet needs to sign vs. doesn't need to sign?
In the browser, this will pop up the phantom dialog, etc.
Yeah, anchor will trigger a call to ask the `provider.wallet` to sign
Is this because anchor implicitly takes care of that for you? I've noticed whenever I call an spl function that requires a `signer` or `keypair`, I need to wrap it in a `.send` call like so:

```
const mintTxn = new Transaction().add(
        spl.Token.createMintToInstruction(
          spl.TOKEN_PROGRAM_ID,
          token.publicKey,
          tokenAcct.address, 
          walletPublicKey, // this should be the authority over the mint
          [],
          1
        )
      );
let mintSig = await program.provider.send(mintTxn, []);
```
(otherwise there's an issue with the having the wallet sign)
It signs no matter what because it pays for the tx fees (requires a signature), and you can't add it to signers in general because doing so would require a keypair, and in the browser for example, using a phantom wallet or whatever, you just can't get access to a keypair (phantom will never give you the actual keypair)
The `provider.wallet` actually signs no matter what, no need to add it to `signers`
üëã how can I call an anchor program, and specify the signer (keypair) via the wallet adapter? I want to do something like this:

```
const walletPubKey = provider.wallet.publicKey;
    const tx = await program.rpc.initializeMint(
      {
        accounts: {
          mint: token.address,
          mintAuthority: walletPubKey,
          tokenProgram: spl.TOKEN_PROGRAM_ID
        },
        signers: // wallet keypair
      }
    );
```
Does anyone know what the difference between serum-dex and dex-v4 is?

https://github.com/Bonfida/dex-v4

https://github.com/project-serum/serum-dex.git
Have you tried?
Can I constrain a receiving ATA to a fixed address ? Something like so? I want the mint to only go to the hardcoded wallet.
```
 #[account(mut,
    associated_token::mint = mint,
    associated_token::authority = Pubkey::from_str("XXXX").unwrap())]
    burn_vault: Account<'info, TokenAccount>,
```
that was it, thank you -- really appreciate it
roger... will try to deploy again üôÇ
E.g. you might make a change and then re-deploy without first re-running anchor build
Ok, then it's likely a mixup with your deployment process (it's weird but it's so, so easy to mis-deploy)
yes, the tests work.
Do your changes work locally?
Are you using `#[instruction(...)]` etc?
(i obviously updated my client to add the new instruction)... hmm
updated it on chain, and now instructions to it get: InstructionDidNotDeserialize
Yep, that's fine (old clients will have to update obviously, but yeah, that's fine)
as in -- can I add an argument and then redeploy?
can you change the number of arguments an instruction takes after its already been deployed?
how do i re adjust it??
Trying to make sure I‚Äôm doing this right. So I am making an exchange type of program where a user can exchange sol for tokens and tokens for sol. Given this, I have made a token account for the user and both a token and separate account use to transfer sol by the exchange. The user can sign when they wish to transfer tokens and sol. The exchange sol account signs for transactions when paying the user in either tokens or sol. Would this be the right approach?
I have no idea what that 0.32 version is
So yeah, your path is screwed up or something
jokerssd@BP-desktop:/mnt/c/Users/runmi/Desktop/Anchor/anchor/examples/tutorial/basic-0$ sudo npm install --force  yarn
npm WARN using --force I sure hope you know what you are doing.

> yarn@1.22.17 preinstall /mnt/c/Users/runmi/Desktop/Anchor/anchor/examples/tutorial/basic-0/node_modules/yarn
> :; (node ./preinstall.js > /dev/null 2>&1 || true)

npm WARN basic-0@0.22.1 No description

+ yarn@1.22.17
updated 1 package and audited 1 package in 0.674s
found 0 vulnerabilities

jokerssd@BP-desktop:/mnt/c/Users/runmi/Desktop/Anchor/anchor/examples/tutorial/basic-0$ yarn --version
0.32+git
Could try running random stuff like `yarn --help` or `yarn --version`
How did you install yarn in the first place?
how do i check>>
Like, yarn should be the js package manager, I wonder if it's actually some random other program for you
I wonder if you just don't have the right yarn installed
jokerssd@BP-desktop:/mnt/c/Users/runmi/Desktop/Anchor/anchor/examples/tutorial/basic-0$ yarn
00h00m00s 0/0: : ERROR: There are no scenarios; must have at least one.
What if you just say `yarn`?
windows with WSL terminal
Are you running on windows or something?
getting this error
jokerssd@BP-desktop:/mnt/c/Users/runmi/Desktop/gif-portal-starter/rust$ yarn install
00h00m00s 0/0: : ERROR: [Errno 2] No such file or directory: 'install'
following the guide
have you deffo done it
Your guide has a similar step - https://lorisleiva.com/create-a-solana-dapp-from-scratch/getting-started-with-solana-and-anchor#install-yarn
I am referring to this guide tbh
<@!334752658038587413> https://project-serum.github.io/anchor/tutorials/tutorial-0.html#clone-the-repo
https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html found it!
i have tried the instalation  method on buildspace
and one from a https://lorisleiva.com/create-a-solana-dapp-from-scratch/getting-started-with-solana-and-anchor#install-rust
still cnanot work , deleted the whole folder adn retried for both
now testing the installation in anchor book
wat does this mean??
<@!334752658038587413>  have you deffo ran yarn in the anchor example folder
Usage: yarn [options]

yarn: error: no such option: -t
hihi im trying to follow the anchor start up guide on build space
but keep getting error on anchor test
<@!134416332509675520>  once again solved it, im being very daft today. Rubber duck debugging seems to be working though.
I'm actually not sure if there is (tbh I don't use the docs lol), I would suggest just searching the anchor repo for `mint::`, you'll see lots of examples.
Documentation for what, the `mint::` syntax?
can you point me to the documentation where this is? I'd like to learn more about it.
function + struct def
```rust
pub fn initialize(ctx: Context<Initialize>, data: u64) -> Result<()> {
  let my_account = &mut ctx.accounts.my_account;
  my_account.counter = data;
  Ok(())
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 8 + 8)]
    pub my_account: Account<'info, MyAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```
Can you post the rust side too? What does the `fn initialize` thing look like?
Seems to have an issue with this line `await program.rpc.initialize`
Boiled the unit down to this:
```javascript
const anchor = require("@project-serum/anchor");
const { SystemProgram } = anchor.web3;

describe("basic-1", () => {
  // Use a local provider.
  const provider = anchor.Provider.local();

  anchor.setProvider(provider);

  it.only('should do something', async () => {
    const program = anchor.workspace.Basic1;

    const myAccount = anchor.web3.Keypair.generate();

    await program.rpc.initialize({
      accounts: {
        myAccount: myAccount.publicKey,
        user: provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      },
      signers: [myAccount],
    });
  });
});
```
Can you post your code?
More silly basic questions,  `Error: Invalid arguments: myAccount not provided.` getting this when running the unit tests on the `basic_1` example
yep changing it to 82 and now i have a new error! this is progress
Try tracing through there to see where you're having problems.
Here's the code that actually runs when you try to initialize the mint (again, good exercise to learn how to find this stuff): https://github.com/solana-labs/solana-program-library/blob/master/token/program/src/processor.rs#L35
You can see here that mints are supposed to have length 82, exactly: https://github.com/solana-labs/solana-program-library/blob/master/token/program/src/state.rs#L37
Yeah, good exercise to try to do the mint initialization without any anchor involvement. At least one issue I see is that you aren't allocating the right amount of space to the account.
Ok. Ill try the way you suggested. Is there documentation on that?

Also I‚Äôve been bashing my head against a wall trying to get this mint initialize to work manually, do you know what I‚Äôm doing wrong?
But it's a good exercise to dig through the spl token program's source code and see exactly where that error is getting raised (you're going to have to learn how to do this eventually lol, just the nature of programming on solana).
Ah, you're not doing the mint initialization quite correctly‚Äîit would be easier to just let anchor do it for you:
```.rs
#[account(init, payer = user, mint::decimals = 0, mint::authority = whoever)]
pub mint: Account<'info, Mint>
```
<@!134416332509675520> any ideas? I posted program log for you üòÇ
Following the basic tutorial so hopefully nothing to crazy - https://project-serum.github.io/anchor/tutorials/tutorial-0.html#building-and-emitting-an-idl

**Edit** Doing this seemed to solve the issue:
```
‚ûú  basic-0 git:(master) ‚úó anchor deploy --program-name 6dsWCVKNM1u8PSrYgUB4dRffafaAnP9yULqQJHiAAqms
Deploying workspace: http://localhost:8899
```
`anchor deploy` presumably to a local network
Ok, how are you deploying?
```solana-cli 1.9.9 (src:450404f8; feat:3246413280)```
What version of solana are you using? `solana --version`
Ello all, any one getting this error when trying the basic_0 tutorial?
```error: Invalid value for '--program-id <PROGRAM_ID>': unrecognized signer source```
Because that lifetime happens to be the same lifetime used by the underlying AccountInfo structs that solana passes to your program, and they happen to call the lifetime `'info`.
But why does anchor use 'info instead of 'a, 'b ?
Hello guys. What codition a token need to be able to appear in this swap-ui example? Some token listed on raydium but I can not find them here
Hi <@!891024357026041907>, is there any way to transform a pubkey into account info?, i'm also searching an solution for this. can you please help me with this.
Any clue how to resolve this error message while using avm to install the latest anchor version.
Hi.
when you call program.rpc.someMethod() - it will be by default signed by provider.wallet.
In this case your transaction will be signed by signers: [tracker] AND provider.wallet.

If yoy want to test this behaviour you can use something like this:
```
  let instruction = program.instruction.initialize({
      accounts: {
        tracker: tracker.publicKey,
        authority: provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      }
    });
  // this should throw if your signers are not valid
  await signAndSend(new Transaction().add(instruction), [tracker, otherSigner], provider.connection)   

  export const signAndSend = async (
    tx: Transaction,
    signers: Array<Account | Keypair>,
    connection: Connection,
    opts?: ConfirmOptions
  ) => {
    tx.setSigners(...signers.map((s) => s.publicKey))
    const blockhash = await connection.getRecentBlockhash(
      opts?.commitment || Provider.defaultOptions().commitment
    )
    tx.recentBlockhash = blockhash.blockhash
    tx.partialSign(...signers)
    const rawTx = tx.serialize()
    return await sendAndConfirmRawTransaction(connection, rawTx, opts || Provider.defaultOptions())
  }

```
Hi! I've build a simple authorize counter. The test pass but I don't quite understand why it work.
Here's the test:
```
  const program = anchor.workspace.Tracker as Program<Tracker>;
  const tracker = anchor.web3.Keypair.generate();

  it("Is initialized!", async () => {
    // Add your test here.
    await program.rpc.initialize({
      accounts: {
        tracker: tracker.publicKey,
        authority: provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      },
      signers: [tracker],
    });
```

Here's the program:
```
    pub fn initialize(ctx: Context<InitializeTracker>) -> ProgramResult {
        let tracker = &mut ctx.accounts.tracker;
        let authority = &ctx.accounts.authority;

        tracker.counter = 0;
        tracker.authority = *authority.key;
        Ok(())
    }
```

Confuse here:
```
#[derive(Accounts)]
pub struct InitializeTracker<'info> {
    #[account(init, payer = authority, space = Tracker::LEN)]
    pub tracker: Account<'info, Tracker>,
    #[account(mut)]
    pub authority: Signer<'info>,
    pub system_program: Program<'info, System>
}
```

Question: in the struct, I indicate authority as the Signer. But on the test script, why does the test pass when the signers: [tracker]?
*I wrote 2 other test to check if the authority is the same, it pass as well. Indicating the authority was provider.wallet.public key.
What's the best way to convert returned Base64 encoded data  to JSON?
At any rate you don't need to init an account if all you want to do is store sol in it, yeah
Hmm, I'm actually honestly not sure what happens if you use `init` like that
(and removing the zero space)
Well, somehow, it does! Changing `init` to `mut` circumvents the error!
Can I see your instruction function?
But I'm not sure why that would cause the error you're getting
Huh. I'll try removing the init and see what that gets me.
is there any way you can calculate a transaction fee? The suggested method in the solana cookbook seems to deprecated‚Ä¶
Doesn't really make sense to initialize an account with zero space (you can just skip initializing it at all at that point) [edit: I guess maybe it could sometimes? hmm, still seems weird to me]
Which program owns the source account?
The sending account, `sol_handler`, was initialized here, so the program should own it, I think?
Getting this error when attempting to send SOL using CPI.
Damn, should hv done my homework! Just read the generics section of Rust Book and everything makes sense now üôÇ
Is there a convention for organizing anchor rust code? It seems like in the book they just stuff everything in lib.rs
You can generally just ignore it, but it's a rust thing: https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html
Btw, I have no idea what <'info> does haha
N/m, I was missing the <'info> after struct definition
How did you solve this?
when u deploy or run tests, u get the address. but just building omits it
^ answer to this is that it has the address with anchor test/deploy and loses it with anchor build
why is it that sometimes my IDL has an address at the bottom under "metadata", and sometimes it doesn't?
That only works for accounts you define yourself, within your own program, with the `#[account]` macro
Have you tried jumping to source?
^ ah nvm, the `Token` object is really just a wrapper, so you can just fill in the existing info to rewrap the existing account
Create mint returns a `Token` object. 

```
static async createMint(
    connection: Connection,
    payer: Signer,
    mintAuthority: PublicKey,
    freezeAuthority: PublicKey | null,
    decimals: number,
    programId: PublicKey,
  ): Promise<Token> {
```
Is there an existing method where, if I know the public key of the mint, I can get back the corresponding `Token` object?
you can't, you need to pass the account pubkey into the program rpc call's accounts input


//////////////////////////////////////////////////////////////////////////////////////////

'Program log: Instruction: MintNft', 'Program log: Custom program error: 0x7d6'
why am i hitting this error when trying to mint?
any one else getting this anchor installation error by trying to install the latest version using 'avm use latest ' command got the following error
```error: expected one of `:`, `@`, or `|`, found `)`
  --> /home/aaransol/.cargo/registry/src/github.com-1ecc6299db9ec823/spl-token-3.2.0/src/processor.rs:58:5
   |
57 |         owner: Option<&Pubkey>,s
   |                                 - expected one of `:`, `@`, or `|`
58 |     ) -> ProgramResult {
   |     ^ unexpected token
   |
   = note: anonymous parameters are removed in the 2018 edition (see RFC 1685)
help: if this is a parameter name, give it a type
   
57 |         owner: Option<&Pubkey>,s: TypeName
   |                                 ++++++++++
help: if this is a type, explicitly ignore the parameter name
   |
57 |         owner: Option<&Pubkey>,_: s
   |                                ++

   Compiling solana-clap-utils v1.8.5
error[E0061]: this function takes 3 arguments but 2 arguments were supplied
   --> /home/aaransol/.cargo/registry/src/github.com-1ecc6299db9ec823/spl-token-3.2.0/src/processor.rs:108:9
    |
108 |         Self::_process_initialize_account(accounts, None)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ --------  ---- supplied 2 arguments
    |         |
    |         expected 3 arguments
    |
note: associated function defined here
   --> /home/aaransol/.cargo/registry/src/github.com-1ecc6299db9ec823/spl-token-3.2.0/src/processor.rs:55:8
    |
55  |     fn _process_initialize_account(
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
56  |         accounts: &[AccountInfo],
    |         ------------------------
57  |         owner: Option<&Pubkey>,s
    |         ---------------------- -

error[E0061]: this function takes 3 arguments but 2 arguments were supplied
   --> /home/aaransol/.cargo/registry/src/github.com-1ecc6299db9ec823/spl-token-3.2.0/src/processor.rs:113:9
    |
113 |         Self::_process_initialize_account(accounts, Some(&owner))
    |         |
    |         expected 3```
How can I transfer custom tokens using anchor contracts? 

For example, a contract checks a users wallet for a particular token and transfers and sends it. I've been stuck on this
glad i could help
great, i'll try something like that
```json
"deploy:dev:build": "anchor build -- --features \"normalize-duration\"",
"deploy:prod:build": "anchor build -- --features \"mainnet normalize-duration\"",
```

I have a script like this that builds or deploys based on environment
this log message has listed the next steps for you, just read it and rerun
One of my dependencies in Cargo.toml needs a 'mainnet-beta' feature when building for mainnet, but doesn't when building for devnet. Is there anyway to have it automatically switch depending on my 'provider' ?
jokerssd@BP-desktop:~$ sudo npm install --global yarn
npm ERR! code EEXIST
npm ERR! path /usr/bin/yarnpkg
npm ERR! Refusing to delete /usr/bin/yarnpkg: ../lib/node_modules/corepack/dist/yarnpkg.js symlink target is not controlled by npm /usr/lib/node_modules/yarn
npm ERR! File exists: /usr/bin/yarnpkg
npm ERR! Remove the existing file and try again, or run npm
npm ERR! with --force to overwrite files recklessly.

npm ERR! A complete log of this run can be found in:
npm ERR!     /root/.npm/_logs/2022-03-05T13_09_22_220Z-debug.log
add sudo to your command
jokerssd@BP-desktop:~$ npm install --global yarn
npm WARN checkPermissions Missing write access to /usr/lib/node_modules/yarn
npm WARN checkPermissions Missing write access to /usr/lib/node_modules
npm ERR! code EACCES
npm ERR! syscall access
npm ERR! path /usr/lib/node_modules/yarn
npm ERR! errno -13
npm ERR! Error: EACCES: permission denied, access '/usr/lib/node_modules/yarn'
npm ERR!  [Error: EACCES: permission denied, access '/usr/lib/node_modules/yarn'] {
npm ERR!   errno: -13,
npm ERR!   code: 'EACCES',
npm ERR!   syscall: 'access',
npm ERR!   path: '/usr/lib/node_modules/yarn'
npm ERR! }
npm ERR!
npm ERR! The operation was rejected by your operating system.
npm ERR! It is likely you do not have the permissions to access this file as the current user
npm ERR!
npm ERR! If you believe this might be a permissions issue, please double-check the
npm ERR! permissions of the file and its containing directories, or try running
npm ERR! the command again as root/Administrator.

npm ERR! A complete log of this run can be found in:
npm ERR!     /home/jokerssd/.npm/_logs/2022-03-05T13_07_28_640Z-debug.log
yeah, this error is expected since you're not in a project scope or installing in a global scope.

So run `npm install --global yarn`
npm install yarn

> yarn@1.22.17 preinstall /home/jokerssd/node_modules/yarn
> :; (node ./preinstall.js > /dev/null 2>&1 || true)

npm WARN saveError ENOENT: no such file or directory, open '/home/jokerssd/package.json'
npm WARN enoent ENOENT: no such file or directory, open '/home/jokerssd/package.json'
npm WARN jokerssd No description
npm WARN jokerssd No repository field.
npm WARN jokerssd No README data
npm WARN jokerssd No license field.

+ yarn@1.22.17
added 1 package and audited 1 package in 0.497s
found 0 vulnerabilities

trying to but keep hitting earror on ubuntu
install yarn with npm. the yarn from apt is a different program
and sudo npm uninstall --force-g yarn dont work too
version is 0.32+git
my yarn is weird
hi may i know how to uninstall yarn from ubuntu?
I have an account that looks like this:
#[account]
pub struct ReportAccount {
    pub uri: String,
    pub authority: Pubkey,
    pub reportstatus: u8,
    pub votestatus: u8,
}

I want the program that initializes this to have access to the first 3 line items. The votestatus would be updated via a separate program only, this program would be handed ownership of to our governance.
Any ideas on how I would do this? I am thinking I initialize a copy in a cross program master for this. Any way to prevent that redundancy
Hi, how can PDA be initialized and passed as program account ( instruction fails with 3012, acc i'm passing is https://explorer.solana.com/address/8LjoZt5J4oEJpC7wgcz9DKwXwYiJuqySbE8yhJDAjxpS?cluster=devnet a PDA) and on the program, this account is defined as 

 pub authority: AccountInfo<'info>,

As i understand this anchr piece of code is raising this error:

 if info.owner == &system_program::ID && info.lamports() == 0 {
            return Err(ErrorCode::AccountNotInitialized.into());
        }

Any ideas what am i doing wrong?
even though I was accessing the relevant type using the module's namespace
on my `#[program]` attribute
`unresolved import 'crate'`
some sort of import error
I was getting an error even if I tried the latter
mod is like import I guess 
use is kind of like destruction from JS. If I didn‚Äôt put use error::*; I would have to write error::ErrorCode::(err message)
I've seen a lot of solana programs with just `pub mod x`
Any idea why I need both?
Yes
The code is a few months old, but you can import by mod and use
I was having some import errors and I think it's because I wasn't doing both `pub mod x` and `use x::*`
Ah thanks! This will be handy
https://github.com/regohiro/macroswap
Ah yes, and it's just stuffing everything into lib.rs of course
Here‚Äôs anchor version
https://github.com/project-serum/anchor/tree/master/tests/escrow
Unfortunately that tutorial isn't using anchor
quick question about the `MintInfo` struct:

```

/**
 * Information about the mint
 */
type MintInfo = {|
  /**
   * Optional authority used to mint new tokens. The mint authority may only be provided during
   * mint creation. If no mint authority is present then the mint has a fixed supply and no
   * further tokens may be minted.
   */
  mintAuthority: null | PublicKey,

  /**
   * Total supply of tokens
   */
  supply: u64,

  /**
   * Number of base 10 digits to the right of the decimal place
   */
  decimals: number,

  /**
   * Is this mint initialized
   */
  isInitialized: boolean,

  /**
   * Optional authority to freeze token accounts
   */
  freezeAuthority: null | PublicKey,
|};
```
wow... interesting, guess when SOL is 10x the price now, program deploys on mainnet $$$
definitely narrows the use cases
I know right, that's kind of the "dark side" of Solana.
And the rent-exemption rate is 7 sol/mb. So if you upload a couple hundred kbs with your first deploy, then yeah, ~4 sol is about what you're looking at.
The upgradeable deployment process defaults to having your first deploy reserve 2x the initial code size, so you can upgrade later.
It's for rent-exempting your program's code, which is generally in the 100s of kbs.
Why does each program deploy cost ~4 SOL? That's so expensive
Ah ok, thanks for the quick reply tho!
Unfortunately as far as I know this just doesn't work yet
Hi, how do I use type alias in anchor?
```
pub type EthereumAddress = [u8; 20];

mod my_program {
 .....
}

#[account]
pub struct Counter {
  pub signer_address: EthereumAddress,
  pub count: u64,
  pub nonce: u64
}
```

I'm getting this error when I instantiate idl 
```
IdlError: Type not found: {"name":"signerAddress","type":{"defined":"EthereumAddress"}}
```
Thanks man!!
So turns out i needed to mark payer as mutable. Is it because as they payer we decrement its lamports?
Have tried omitting #[account(signer)] from the acctAuthority variable, but that doesn't seem to work.  My guess that it's around the account init, of `escrowed_token_account` - but I've already gotten the payer to sign here ü§î
But seeing:
```
  solana-burn-token-for-token
Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS invoke [1]
    Program log: Instruction: InitializeTokenAcct
    B5tnm5qtGLThYuw9phtfwa2knSAUknrrjWwXZgBJ6jph's writable privilege escalated
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS consumed 9850 of 200000 compute units
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS failed: Cross-program invocation with unauthorized signer or writable account
    1) Token version: it passes authority to the PDA, mints and burns token


  0 passing (2s)
  1 failing

  1) solana-burn-token-for-token
       Token version: it passes authority to the PDA, mints and burns token:
     Error: failed to send transaction: Transaction simulation failed: Error processing Instruction 0: Cross-program invocation with unauthorized signer or writable account
      at Connection.sendEncodedTransaction (node_modules/@solana/web3.js/src/connection.ts:3963:13)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
      at Connection.sendRawTransaction (node_modules/@solana/web3.js/src/connection.ts:3920:20)
      at sendAndConfirmRawTransaction (node_modules/@solana/web3.js/src/util/send-and-confirm-raw-transaction.ts:27:21)
      at Provider.send (node_modules/@project-serum/anchor/src/provider.ts:118:18)
      at Object.rpc [as initializeTokenAcct] (node_modules/@project-serum/anchor/src/program/namespace/rpc.ts:25:23)
```
Running:
```
const payer = anchor.web3.Keypair.generate();
    const sender = anchor.web3.Keypair.generate();

    await helpers.airdropSol(payer, program.provider.connection);

    const sampleMint = await spl.Token.createMint(
      program.provider.connection,
      payer,
      payer.publicKey,
      payer.publicKey,
      0,
      spl.TOKEN_PROGRAM_ID
    );

    const senderTokenAccount = await sampleMint.createAccount(sender.publicKey);
    await sampleMint.mintTo(senderTokenAccount, payer.publicKey, [], 1);

    const preInitTokenAcct = await sampleMint.getAccountInfo(senderTokenAccount);

    const [escrowedMakerTokens, escrowedMakerTokensBump] = await anchor.web3.PublicKey.findProgramAddress(
      [preInitTokenAcct.mint.toBuffer()],
      program.programId
    );

    const tx = await program.rpc.initializeTokenAcct({
      accounts: {
        tokenAcct: senderTokenAccount,
        tokenMint: sampleMint.publicKey,
        acctAuthority: sender.publicKey,
        tokenProgram: spl.TOKEN_PROGRAM_ID,
        escrowedTokenAcct: escrowedMakerTokens,
        payer: payer.publicKey,
        systemProgram: anchor.web3.SystemProgram.programId,
        rent: anchor.web3.SYSVAR_RENT_PUBKEY,
      },
      signers: [payer, sender]
    })
```
I've got:

```
 pub fn initialize_token_acct(ctx: Context<InitializeTokenAcct>) -> ProgramResult {
    Ok(())
}

#[derive(Accounts)]
pub struct InitializeTokenAcct<'info> {
    // #[account(mut)]
    pub token_acct: Account<'info, TokenAccount>,
    // #[account(mut)]
    pub token_mint: Account<'info, Mint>,
    #[account(signer)]
    pub acct_authority: AccountInfo<'info>,
    pub token_program: AccountInfo<'info>,
    // This is where we'll store the offer maker's tokens.
    #[account(
        init,
        payer = payer,
        seeds = [token_acct.mint.as_ref()],
        bump,
        token::mint = token_mint,
        // We want the program itself to have authority over the escrow token
        // account, so we need to use some program-derived address here. Well,
        // the escrow token account itself already lives at a program-derived
        // address, so we can set its authority to be its own address.
        token::authority = escrowed_token_acct,
    )]
    pub escrowed_token_acct: Account<'info, TokenAccount>,
    pub payer: Signer<'info>,
    pub system_program: Program<'info, System>,
    pub rent: Sysvar<'info, Rent>
}
```
nvm found this
or is that the account Im burning from
When you invoke the burn CPI from the token program it asks for a `to:` account? What does this mean? Am I burning to another account?
Bumping; I still have no idea how to get the proper balance.
It would unfortunately require updating the spl token program, not anchor itself‚Äîbut looks like that's going to happen soon-ish
Got it, seems like we still need it as of `anchor-lang = "0.21.0"` but guessing there's work to remove it
So in this case the token program just happens to need that account, so you gotta pass it in from the client per the usual solana rules.
It's kind of a legacy thing tbh, since you can now just dynamically do `Rent::get()?`, but you used to have to pass it in as an actual account so initialization stuff could figure out whether an account had enough lamports to be rent-exempt.
Makes sense. One follow up: what is the purpose of this `pub rent: Sysvar<'info, Rent>,` - seems like every init call requires it?
But basically, anchor uses the seeds + bump to CPI to the system program to make a token account, and then CPIs again to the token program to actually initialize the token account.
Little hard to read, but you can see the source here: https://github.com/project-serum/anchor/blob/master/lang/syn/src/codegen/accounts/constraints.rs#L344
üëã quick question about this: https://github.com/cqfd/quidproquo/blob/main/programs/quidproquo/src/lib.rs#L170

```
// This is where we'll store the offer maker's tokens.
    #[account(
        init,
        payer = offer_maker,
        seeds = [offer.key().as_ref()],
        bump = escrowed_maker_tokens_bump,
        token::mint = maker_mint,
        // We want the program itself to have authority over the escrow token
        // account, so we need to use some program-derived address here. Well,
        // the escrow token account itself already lives at a program-derived
        // address, so we can set its authority to be its own address.
        token::authority = escrowed_maker_tokens,
    )]
    pub escrowed_maker_tokens: Account<'info, TokenAccount>,
```
How are these parameters in the account macro being used? i.e. I'm seeing this being called like so:
```
await program.rpc.make(
      escrowedMakerTokensBump,
      new anchor.BN(100),
      new anchor.BN(200),
      {
        accounts: {
          offer: offer.publicKey,
          offerMaker: program.provider.wallet.publicKey,
          offerMakersMakerTokens: offerMakersMakerTokens,
          escrowedMakerTokens: escrowedMakerTokens,
          makerMint: makerMint.publicKey,
          takerMint: takerMint.publicKey,
          tokenProgram: spl.TOKEN_PROGRAM_ID,
          rent: anchor.web3.SYSVAR_RENT_PUBKEY,
          systemProgram: anchor.web3.SystemProgram.programId,
      },
      signers: [offer]
    });
```
no additional instructions are being passed, so how are seeds, bump, etc. being used exactly? Documentation tells me:
`Seeds for the program derived address an AccountInfo struct represents. If bump is provided, then appends it to the seeds. On initialization, validates the given bump is the bump provided by Pubkey::find_program_address.`, but how exactly are these parameters being used/set?
+ corresponding issue: https://github.com/project-serum/anchor/issues/1387
check out this PR: https://github.com/project-serum/anchor/pull/1452#discussion_r809207430
Is this intended behavior? It's treating this as a compile error but it feels more like a compiler warning so it should finish and generate an idl for me. Anyway it does generate an idl if I deploy the program without commenting `/// CHECK:` above every use of UncheckedAccount
Ok I figured out the problem. It's because I was using `UncheckedAccount` without some comment on why checking is not necessary. So `anchor build` wasn't generating a fresh idl
how do I generate a new idl without deploying the program? Looks like `anchor upgrade` does generate a new idl--only anchor deploy does. I thought it used to be that anchor build will generate a new idl and populate it in `target/idl`
you might be able to "upgrade" it to a smaller buffer and close the previous buffer. Have never done that though
No, programs live forever
Can you "withdraw" the  `SOL` amount in a `Program Executable Data Account
` at a later stage if you no longer need the program?
The current number (too small) that I'm using for the balance is `*(*(ctx.accounts.minter_base..to_account_info().lamports).borrow_mut())` . That gives me a valid number, it seems, but one that is too small, as I can successfully send an amount of SOL equivalent to the lower bound this is getting compared to, as long as the error check is removed. There might be a cleaner way to get the balance though.
How do I get the account size in bytes for one of my PDA's?
perrrrrfect
You can actually already do `await program.account.thatAccountType.all()` üôÇ
nvm im stupid, source dived further and looks like it's straight sha256. in case anyone else is looking though I'll leave the messages
ok from source it looks like a hash of `account:<ident>` for each account. Is there a way to recreate this hash accurately from the client-side? Hoping to implement something like `get<AccountType>` which gets all accounts matching a certain type owned by the program.
Is there documentation on the account discriminator? I had added an enum to my accounts to tell them apart from RPC but just realized it seems Anchor does this automatically. How can I tell what the discriminator is for a given account type?
Helps get around issues with borrowing variables as well sometimes
It's a handy trick for sure
While this doesn't help my understanding per se, it is a cool trick that helped to solved my problem: https://discord.com/channels/889577356681945098/889702325231427584/944344169474822144
Hopefully someone can explain how you can avoid boxing when there's so many accounts and large data structs to be loaded that it doesn't work without box
https://twitter.com/0xsanny/status/1499503856228528140?s=20&t=3Ea5S2k-bt6C9_ay3O50Ow
Haha, I came to post the same thing but decided to discord search first
Nope. This is an account that holds SOL, and has no data.
is it a token account? Usually if I'm checking token balances I'd use something like: `ctx.accounts.token_account.amount`
How does one check the balance of an `AccountInfo`? I tried using `lamports`, but that seems to give me an amount that is too small.
i used anchor deploy on mainnet and it worked fine
Are there any resources on this/places in the Solana code I should look to learn more about stack frames and memory management in general? My anchor program is working but it feels really hacky bc I have no idea what is going on with how Solana/Rust/Anchor are managing the memory of my programs. Boxing accounts is the only thing that makes sense to me hahaha
Is it necessary to use a custom rpc to deploy a program to mainnet? 
Been seeing a lot of Invalid Blockhash errors deploying to devnet using `anchor deploy` and want to avoid those on mainnet
Could maybe try doing https://discord.com/channels/889577356681945098/889577399308656662/948261193540321340
üëç  (lol, yes)
<@!134416332509675520> I'm guessing the thumbs up is a yes? üò¢
Is the deployment cost on `devnet` a good estimation for deploying a program on `mainnet`?
Yeah
Got it . So in this case, we should create associated token accounts and _transfer_ tokens as opposed to changing the authority (best practice-wise)
Heh, as usual the names are slightly off in solana, but an associated token account is a regular old token account that happens to live at a special address, a PDA derived from the associated token program (totally different program from the token program).
what's the diff between a token account vs. associated token account?
But this is one reason why it's a bad idea to transfer ownership of an associated token account‚Äîit's quite surprising if the associated token account for mint M and person P is actually currently owned by some random other person Q.
Yep, can have as many as you want (only one *associated* token address though).
üëã can one address have multiple token accounts with the same mint? If not, what happens if an address already owns a token account and then I transfer ownership of a separate token account (with the same mint) to that address?
Here's an example: https://github.com/cqfd/anchor-token-studies/blob/main/programs/token-studies/src/lib.rs#L14
Thanks for clarifying!
You'd need to have an instruction that eventually uses `invoke_signed` etc. to do that mint to instruction
The only way for a PDA to sign something is by asking its deriving program to do so for you‚Äîit's not possible to sign for a PDA from the client
I have a mint authority that's owned by a PDA. I want to mint to a particular token account, my code is like so:

```
 const mintTxn = new Transaction().add(
        spl.Token.createMintToInstruction(
          spl.TOKEN_PROGRAM_ID,
          token.publicKey,
          tokenAcct.address, 
          _pda, // this should be the authority over the mint
          [],
          1
        )
      );
let mintSig = await program.provider.send(mintTxn, []);
```
Getting:
```
Uncaught (in promise) Error: Signature verification failed
    at Transaction.serialize (transaction.ts:583:1)
    at Provider.send (provider.ts:112:1)
    at async mintToWallet (Main.jsx:378:1)
```
How can I set this up so the PDA "signs" the transaction?


//////////////////////////////////////////////////////////////////////////////////////////

sorry. I was unclear. Basically the problem i am trying to solve is  - how can we mint token to a public key representing a users token account?
I know it needs accountinfo passed through ctx. But we can't store that on chain
Basic problem is token minting can (and almost always will) happen after a while  (user maybe be logged out/sleeping). SO how so we get accountinfo then? IIRC it can't be stored on chain on a vector.
The AccountMeta was just me trying to see if there is a way to get around this problem. And I think it has same problem.
The cli does let you send token to pubkey address. 
||spl-token mint AQoKYV7tYpTrFZN6P5oUufbQKAUr9mNYGe1TTJC9wajM 100||
Why can't we do it on chain?
An AccountMeta isn't the same thing as an AccountInfo, so I think I'm confused by your question
In rust or js?
how to convert a string into buffer?
how do we do this in anchor. as in pass pubkey and get accountinfo
#[allow(clippy::too_many_arguments)]
pub fn initialize_binary_option(
    program_id: Pubkey, // Address of deployed program
    pool_account: Pubkey, // Address of Upgrade Authority
    escrow_mint: Pubkey, // TBD
    escrow_account: Pubkey, // Unique per option [ generated by front-end SPL library ]
    long_token_mint: Pubkey, // Unique per option [ generated by front-end SPL library ]
    short_token_mint: Pubkey, // Unique per option [ generated by front-end SPL library ]
    mint_authority: Pubkey, // Fixed address [ generated/chosen by us ]
    update_authority: Pubkey, // Address of Upgrade Authority
    decimals: u8, // 2 = 100, 3 = 1000 [ only using 2 for now ]
    expiry:  u64, // Unix timestamp
    strike: u64, // strike_price
    strike_exponent: u64, // strike_price
    // underlying_asset_address: Pubkey, // Address of underlying asset [ from Pyth for now ]
) -> Instruction {
    Instruction {
        program_id,
        accounts: vec![
            AccountMeta::new(pool_account, true),
            AccountMeta::new_readonly(escrow_mint, false),
            AccountMeta::new(escrow_account, true),
            AccountMeta::new_readonly(long_token_mint, true),
            AccountMeta::new_readonly(short_token_mint, true),
            AccountMeta::new_readonly(mint_authority, true),
            AccountMeta::new_readonly(update_authority, true),
            AccountMeta::new_readonly(spl_token::id(), false),
            AccountMeta::new_readonly(solana_program::system_program::id(), false),
            AccountMeta::new_readonly(sysvar::rent::id(), false),
        ],
        data: BinaryOptionInstruction::InitializeBinaryOption(InitializeBinaryOptionArgs {
            decimals,
            expiry,
            strike,
            strike_exponent,
            
        })
        .try_to_vec()
        .unwrap(),
    }
}
So wondering if there is an anchor equivalent of AccountMeta::new(pubkey). 
In Solana/Rust implementation , one can pass pubkey and get AccountMeta to pass onto on chain instruction.
Redeploying does indeed need that much sol in your wallet, but you get it right back‚Äîit's only used for a temporary buffer while deploying.
Can you say more? What do you mean by best practices here?
Hi, I'm trying to deploy a program to an existing address (ie upgrading the program) - however when I run anchor deploy it wants to charge me for a full program deploy. If I close the program and reclaim the rent and deploy to a different address its much cheaper.

I've tried upgrade, maybe I did it wrong, but it didnt do what I wanted

I feel I must be missing something obvious - whats the command to deploy to an existing program please ?
What are the general best practices for integrating anchor ts with Phantom Wallet (through, e.g. `window.solana`)?
i searched through some history, putting things in helper functions did help -- thanks for previous responses üôÇ
commenting out a bunch of logging i was able to get it down below 4096, but some of that logging i kind of wanted. what other strategies can I use to drop it down?
what's a large stack variable?
When building I see this:
```Error: Function _ZN12drift_client12drift_client13open_position17h2330650942d4402fE Stack offset of 5432 exceeded max offset of 4096 by 1336 bytes, please minimize large stack variables```

and after deploying and calling the function, i got 
```> Program returned error: Access violation in stack frame 5 at address 0x200005ac8 of size 8 by instruction #9479```

Can anyone explain what this means?
It spins up a validator for you, but in doing so it injects your code
I want to get ideas here.
If I want to create a PDA mapping of let's say unique number => user pubkey, what's the best way to query the list (array) of unique numbers that user owns on the client side? 
My ideas are:
- Create a vector of unique numbers for each user. However, I think this is an expensive solution.
- Create an indexer and watch for events.
If I want to mainnet fork using test.validator.clone should I have a validator running in the background or can I do it without?
so without a local validator where does it run the code? On like block 1 of a new chain after deploying or something?
I personally never run a local validator in the background
If the validator is running in the background, anchor test just runs your tests against it (potentially annoying since you need to remember to deploy the latest version of your code)
Without a running validator, anchor/solana does some "genesis block" magic to inject the latest version of your code without strictly speaking deploying.
what's the difference between running `anchor test` while running a `solana-test-validator` in the background vs not running a local validator in the background?

I get different error codes.
errr update when i check avm's version it seems to be working
how can we find the current version of mainnet and devnet?
I am specifying the gateway IP for my docker network now, and I was successfully able to airdrop tokens. When I try a deploy however, I see transactions attempting to send repeatedly until the blockhash expires.
also i already added it to my path
i ran ```avm use latest``` but it gave me this and when i try to check my anchor version it tells me to run the command again... any advice?
Yeah, think this will be clearer if you go through the book/the examples https://project-serum.github.io/anchor/tutorials/tutorial-0.html
thank you
I've skimmed it, I'll go through it in more detail then
Have you gone through the anchor book? https://book.anchor-lang.com/
The thing that goes into `Ctx<...>`  has to derive(Accounts); the `#[account]` thing you have above is how you declare a single account on-chain with some data in that struct format stored there.
```.rs
#[derive(Accounts)]
pub struct SwapInfoCtx<'info> {
  pub swap_info_account: Account<'info, SwapInfo>
}
```
```error[E0432]: unresolved import `crate`
 --> programs/stableRead/src/lib.rs:5:1
  |
5 | #[program]
  | ^^^^^^^^^^ could not find `__client_accounts_swap_info` in the crate root
  |
  = note: this error originates in the attribute macro `program` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: no function or associated item named `try_accounts` found for struct `SwapInfo` in the current scope
  --> programs/stableRead/src/lib.rs:5:1
   |
5  | #[program]
   | ^^^^^^^^^^ function or associated item not found in `SwapInfo`
...
16 | pub struct SwapInfo {
   | ------------------- function or associated item `try_accounts` not found for this
   |
   = help: items from traits can only be used if the trait is implemented and in scope
   = note: the following trait defines an item `try_accounts`, perhaps you need to implement it:
           candidate #1: `anchor_lang::Accounts`
   = note: this error originates in the attribute macro `program` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the trait bound `SwapInfo: anchor_lang::Accounts<'_>` is not satisfied
  --> programs/stableRead/src/lib.rs:5:1
   |
5  | #[program]
   | ^^^^^^^^^^ the trait `anchor_lang::Accounts<'_>` is not implemented for `SwapInfo`
   |
note: required by `anchor_lang::context::Context::<'a, 'b, 'c, 'info, T>::new`
  --> /home/a/.local/share/cargo/registry/src/github.com-1ecc6299db9ec823/anchor-lang-0.20.1/src/context.rs:45:5
   |
45 | /     pub fn new(
46 | |         program_id: &'a Pubkey,
47 | |         accounts: &'b mut T,
48 | |         remaining_accounts: &'c [AccountInfo<'info>],
49 | |     ) -> Self {
   | |_____________^
   = note: this error originates in the attribute macro `program` (in Nightly builds, run with -Z macro-backtrace for more info)```

I think I'm missing something basic in my understanding of accounts.
So I have this code trying to read state data:
```
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod stable_read {
    use super::*;
    pub fn read(ctx: Context<SwapInfo>) -> ProgramResult {
        let data = &ctx.accounts.is_paused;
        msg!("isPaused?:{}", data);
        Ok(())
    }
}

#[account]
pub struct SwapInfo {
    /// Initialized state
    pub is_initialized: bool,

    /// Paused state
    pub is_paused: bool,

    pub nonce: u8,

}```

and I get this error from ```anchor build```:
Ah, that makes sense based on what my client is doing :p
So e.g. doing `anchor deploy -p asdfasdfasdfasdf` will also work (bug in anchor cli I guess)
Yeah think that's only for the program name
1 sec
Though hmm, maybe it is
I think it only does the program name‚Äîright, I don't think it's doing all three
kind of weird that the same flag is interpreting 3 different types of arguments
it also serves as an override for cluster and for wallet according to CLI
I thought the `-p` argument was for picking which program you wanted to deploy, not for specifying a network
I'm currently deploying an anchor program in a docker container to a localnet running in another docker container. The containers are able to network with one another on a custom network via docker-compose. Running `anchor deploy` results in a failure, but I succeed when I specify `anchor deploy -p http://localhost:8899`

My anchor.toml file has cluster set to localnet.

Any idea what I'm missing?
Oh nvm, it prints in the anchor console, not in the solana log
(finding example)
Why won't it work?
How can I log variables on program runtime? I can use msg! but it won't work if the program fails
Sure
inside the program
I can use msg! too right?
Similar to how you might be testing your own `program` in your existing anchor tests
Assuming you can load up the other program's IDL into `thatOtherProgram`
No, anchor already wrote it for you
Or if that's tricky to get working, you could use the lower-level `(await program.provider.connection.getAccountInfo(itsAddress)).data[9]`
fetch here is the function I write to read the necessary data?
`await thatOtherProgram.account.programInfo.fetch(itsAddress)`
ok, is there anyway to console.log() the variable I read while testing in anchor?
currently you cant deploy candy machines (for nfts) on devnet and they reckon its because teh devnet is struggling
yeh i think so
Like
```.rs
#[derive(Accounts)]
pub struct SomeInstruction<'info> {
  pub program_info_account: Account<'info, ProgramInfo>
}
```
No need to do a CPI, you can just pass that account into the other program
did u manage to fix this?
maybe devnet is havin some issues, Im unable to interact with it atm for some reason ://
In the EVM I would just do  ``bool data  = <address>.isPaused()``
Let's say this is in the program state of a different program
```pub struct ProgramInfo {
    pub is_paused: bool
}
```
How would I read this data from a program, do I need to a cross program invocation for just reading data?
ah, I see, ok
But that doesn't have anything to do with that `[test.validator]` Anchor.toml thing.
You can write unit tests in rust like
```.rs
#[test]
fn do_something() {
  ...
}
```
Which test keyword are you referring to?
how exactly do I incorporate the [test] keyword in my code? Is there any examples of using this pattern in code?
I'm trying to deploy, and `anchor deploy` succeeded, but for some reason I get an AccountNotFound error when trying to view the account newly generated by `solana-keygen`. Airdrop requests fail, and this error appears when I try to use an online faucet. What am I missing about the deployment process?
Np ‚ô•Ô∏è
Lol
u saved my life
thanks prask!!


//////////////////////////////////////////////////////////////////////////////////////////

I've noticed the mint authority pub key points to the edition pubkey from the mintNFTResponse object
üëã Have a question on metaplex NFTs. The metaplex discord isn't as active/helpful as here, so figured I'd ask here:

What is the relation between the edition vs. metadata vs. mint on an NFT? My understanding is that the mint is similar to a regular SPL token mint, the metadata is a derived address of the mint where the metadata is stored. I'm more confused about the edition and what the relation to metadata/mint is
```
‚ûú  myepicproject anchor --version
anchor-cli 0.22.1
```
thats not the anchor cli
```
"dependencies": {
        "@project-serum/anchor": "^0.22.1"
    },```
bug in `0.22.0` update the anchor cli to `0.22.1` and init a new workspace or adjust manually (see the changelog)
```
error[E0412]: cannot find type `ProgramResult` in this scope
 --> programs/myepicproject/src/lib.rs:8:58
  |
8 |   pub fn start_stuff_off(ctx: Context<StartStuffOff>) -> ProgramResult {
  |                                                          ^^^^^^^^^^^^^ not found in this scope
```
```
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod myepicproject {
  use super::*;
  pub fn start_stuff_off(ctx: Context<StartStuffOff>) -> ProgramResult {
    Ok(())
  }
}

#[derive(Accounts)]
pub struct StartStuffOff {}
```
Hello again,
Any idea why ProgramResult is not present in the scope ?
<@!134416332509675520> thanks for the help. you're the best
Yeah, that seems fine‚Äîthe existence of an account at the PDA with seeds = [wallet.key().as_ref()] would signal that your program had granted that wallet pubkey, and then you'd require the client to pass in both the PDA as well as a signature from the corresponding wallet.
<@!134416332509675520> would this approach work? Or is there some holes in this that I‚Äôm not thinking of?
Yeah, it's true that if you're changing the list frequently, then maybe it would be annoying to hardcode it. But you can update the list by just redeploying your program.
What if you wanted to update after it was deployed or if theres thousands for example. A hardcoded list doesn‚Äôt seem sustainable.
Why do you need to create a PDA per wallet? Why not just hardcode those wallet pubkeys into your program?
So if i wanted to create a list of whitelists wallets to have access to a "secret" function, i could create a PDA per wallet and then just lock down the function that creates the PDA with a constraint on the struct equal to an admin wallet, and constraint on the "secret" function that checks for that PDA?
Ok, that makes sense
Finding the address doesn't create anything
Anyone can find the address, but only your program can create the account that lives there
but i thought anyone can just create a PDA?
```.rs
#[derive(Accounts)]
pub struct InitThatPDA<'info> {
  #[account(address = ADMIN)]
  pub admin: Signer<'info>,

  #[account(init, ......)]
  pub that_pda: Account<'info, Whatever>
  ...
}
```
The instruction that initializes the account at the PDA would need to check that that ADMIN signed the tx
lets say i'm using a PDA to read some kind of value, how do i ensure that PDA was created by an ADMIN for example
What do you mean?
```.rs
const ADMIN: Pubkey = solana_program::pubkey!("adsfasdafsdadsf");
```
can you check if who signed an existing PDA?
So if those specific wallets are hardcoded etc., then you can just check in your program
The only option is to check that one of those wallets signs the tx
what are some best practices to ensuring a specific PDA is only created/updated by specific wallets?
hello, does anyone knows why 'anchor deploy' takes so much time(40m+) and still not done, what am I missing here ?
How do I constrain access to only one specific token mint or governance owner program? Is it recommended to hard code the account pubkey or some other way this is done?
It's working, ty mate
All right !
Yeah, that'll fix the problem
So sounds like no üòõ
oooooops !
```
‚ûú  myepicproject echo $PATH           
/Users/louis/.nvm/versions/node/v17.6.0/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Users/louis/.nvm/versions/node/v17.6.0/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/Users/louis/.cargo/bin```
I don't think that's related. There's a section in that document that tells you to add the solana/bin directory to your path, did you do that?
I'm following this document: https://github.com/buildspace/buildspace-projects/blob/main/Solana_And_Web3/en/Section_2/Resources/m1_setup.md
Ok, but on M1 there's nothing with bpf ? cause the validators command is `solana-test-validator --no-bpf-jit`
Yeah, so I would revisit the installation instructions
```‚ûú  myepicproject which cargo-build-bpf
cargo-build-bpf not found```
But `which cargo-build-bpf` needs to point to part of your solana install
Ah, you may need to just make sure your path is set up correctly (I don't remember how to do this, since I installed solana from source)
Solana-test-validators works and solana-keygen works too, that doesn't means anything ?
And I haven't got any errors during solana build
```
‚ûú  myepicproject solana --version
solana-cli 1.8.5 (src:devbuild; feat:52865992)
```
That means you haven't installed solana itself correctly
Hi,
I'm doing the buildspace tutorial and in the installation part on M1, something doesn't work.
Error:
```
‚ûú  myepicproject anchor test --skip-local-validator
error: no such subcommand: `build-bpf`
‚ûú  myepicproject which anchor                      
/Users/louis/.cargo/bin/anchor
```
<@!134416332509675520> Yes, it's true, but my **target/build** is in my **.gitignore** then each time I'm cloning my repo locally and after running **anchor build** a new keypair is generated (ok I can copy/paste the custom keypair to the target folder and it's gonna be okay), just wanted to know it we could specify it from anchor build directly (as we can do with **solana program ...** cmd)
It shouldn't be regenerating the keypair unless you accidentally keep deleting the one it deposits in `target/build`.
I would think its possible to do #1 but I‚Äôm not sure what‚Äôs best practice for a whitelist. Perhaps its not a single PDA account with a long list of WL accounts, but instead you build a pda for each WL address and check that instead? How do you ensure that the list can‚Äôt be tampered with?
hello, when I run anchor build a new **program-name-keypair.json** is generated each time.
How can I force anchor build to take a pre-generated keypair as an input this way I can reuse the same keypair each time?
storing each item in a separate account wouldn't work because I need the program to be able to iterate through an indefinite number of items
is it possible to increase the size of an account (e.g. for variable sized lists)?
assuming you care if people create token accounts for mint addresses not in the list
It's not secure at all to only do it on the client side
If I have a function that looks like this:
```
pub fn initialize_token_acct(ctx: Context<InitializeTokenAcct>) -> ProgramResult {
    msg!("Transferring tokens from: {:?}", ctx.accounts.token_acct.key());
    msg!("To: {:?}", ctx.accounts.escrowed_token_acct.key());

    let cpi_accounts = token::Transfer {
        from: ctx.accounts.token_acct.to_account_info(),
        to: ctx.accounts.escrowed_token_acct.to_account_info(),
        authority: ctx.accounts.acct_authority.to_account_info()
    };

    let cpi_program = ctx.accounts.token_program.to_account_info();
    let cpi_mint_tx = CpiContext::new(cpi_program, cpi_accounts);
    
    token::transfer(cpi_mint_tx, 1)?;

    Ok(())
}

#[derive(Accounts)]
pub struct InitializeTokenAcct<'info> {
    #[account(mut)]
    pub token_acct: Account<'info, TokenAccount>,
    #[account(mut)]
    pub token_mint: Account<'info, Mint>,
    #[account(signer)]
    pub acct_authority: AccountInfo<'info>,
    pub token_program: AccountInfo<'info>,
    // This is where we'll store the offer maker's tokens.
    #[account(
        init,
        payer = payer,
        seeds = [token_acct.mint.as_ref()],
        bump,
        token::mint = token_mint,
        token::authority = escrowed_token_acct,
    )]
    pub escrowed_token_acct: Account<'info, TokenAccount>,
    #[account(mut)]
    pub payer: Signer<'info>,
    pub system_program: Program<'info, System>,
    pub rent: Sysvar<'info, Rent>
}
```

But I want to set a constraint that this can only be run for a select set of token/mint addresses, what's the best way for me to do this? The approaches I see are:

1/ Keep a static list of mint addresses and do a check at the beginning of `initialize_token_acct` to see if the token/mint accounts passed are included in that static list. If not, terminate early

2/ On the client side, keep that static list, and don't make the program rpc call if the token/mint accounts aren't in that list
the problem is - it was an UnckechedAccount for a reason. I actually don't need to unwrap it into an object, which increases the number of operations. I just need an address
huh, that actually does work! thanks!
i think
`pub associated_with_parent_1_mint: Account<'info, TokenAccount>`
recreated my problem in a fresh project.
does that help a bit? üòâ 
```
use anchor_lang::prelude::*;
use anchor_spl::associated_token::AssociatedToken;
use anchor_spl::token::Mint;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod coin_playground {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(mut)]
    pub owner: Signer<'info>,

    #[account(mut)]
    pub parent_1_mint: Account<'info, Mint>,

    #[account(
    associated_token::mint = parent_1_mint,
    associated_token::authority = owner,
    )]
    pub associated_with_parent_1_mint: UncheckedAccount<'info>,

    pub associated_token_program: Program<'info, AssociatedToken>,
}
```
and error
```
error[E0277]: can't compare `&anchor_lang::prelude::Pubkey` with `anchor_lang::prelude::Pubkey`
  --> programs/coin-playground/src/lib.rs:16:10
   |
16 | #[derive(Accounts)]
   |          ^^^^^^^^ no implementation for `&anchor_lang::prelude::Pubkey == anchor_lang::prelude::Pubkey`
   |
   = help: the trait `PartialEq<anchor_lang::prelude::Pubkey>` is not implemented for `&anchor_lang::prelude::Pubkey`
   = note: this error originates in the derive macro `Accounts` (in Nightly builds, run with -Z macro-backtrace for more info)
```
Updating anchor cli worked!  Thank you so much for your help <@!784156219861762109>
btw. what `rustc` version do you have? if older than 1.59 - then update with `rustup update stable`
with those all up to date - try a new `anchor init`
anchor-cli 0.22.1
also - you may want to downgrade to 1.8 16 (or smth), because 1.9 is testnet only
anchor-cli
currently using solana-cli 1.9.9
ProgramResult got updated to Result<()>.
check out changelog for more details: https://github.com/project-serum/anchor/blob/master/CHANGELOG.md
and this tells me that your CLI is older than ur anchor version in the project
Anyone get a ```error[E0412]: cannot find type `ProgramResult` in this scope``` when running anchor build on a brand new project?
and I don't really know how to fix it üòÑ
and it still looks legit to me
interesting that it worked so far
```
   #[account(mut)]
    pub owner: Signer<'info>,
    #[account(mut)]
    pub parent_1_mint: Account<'info, Mint>,
#[account(
    associated_token::mint = parent_1_mint,
    associated_token::authority = owner,
)]
pub associated_with_parent_1_mint: UncheckedAccount<'info>,
```
with some trial and error I narrowed it down to
close
it might be a has_one constraint
i don' have an easy way to get that
that's the thing - there are none (not a single `&` in the whole file). so I was hoping that there simply is a way to get to the variable name that was checked.
pretty hard to tell without seeing the code, but probably a stray & somewhere in a constraint?
any chance you know something about this one? üòâ
ahhh, right. everything evolves so fast üòâ
ahh its because it was removed in favour of --skip-lint https://github.com/project-serum/anchor/pull/1482
but TBH - I decided that having some docs outside my head may not even be the worst idea ever, so I'll just write them up... üòâ
anchor build
what command are you running?
another one:
following this: `https://github.com/project-serum/anchor/pull/1452`
I pasted this into my `Anchor.toml`
```
[features]
safety_checks = false
```
but I'm still getting 
```
Please add a `/// CHECK:` doc comment explaining why no checks through types are necessary.
```
any idea why?
so now I'm getting this
```
  --> programs/combiner/src/domains/actions/breeding/breed_definition.rs:18:10
   |
18 | #[derive(Accounts)]
   |          ^^^^^^^^ no implementation for `&anchor_lang::prelude::Pubkey == anchor_lang::prelude::Pubkey`
   |
   = help: the trait `PartialEq<anchor_lang::prelude::Pubkey>` is not implemented for `&anchor_lang::prelude::Pubkey`
```
and I have >100 lines worth of definitions in that file.
is there any way to get the actual `name` of a field that resulted in this error?
Sort of, you can do `await program.rpc.thatAccountStructType.fetchMultiple` and just pass in multiple addresses.
Hi, I have an account that is used as a seed for multiple other PDAs (so there is a one to many relationship).
The seeds for the other accounts look something like this: `["tag", main.key(), number.toBytes()]`, where the number goes from 0 to e.g. 5.
Is there a good way for me to fetch all of these PDAs with one request?
that makes more sense, thanks üôÇ
So the constraint itself isn't composite, it's a constraint *on* a composite field.
You can only use `#[account(constraint = ...)]` on top of those, not other stuff like `#[account(mut)]` or whatever
That means you're using a composite field in your derive(Accounts) struct, something like `pub something: Something<'info>` (not one of the usual suspects, Account, AccountInfo, Signer, etc.)
thank you
ah, ok, that is perfect
```.rs
#[test]
fn serialization_example() {
    #[derive(AnchorDeserialize, Debug)]
    struct SwapInfo {
        is_initialized: bool,
        is_paused: bool,
        nonce: u8,
        something: u64,
    }

    let mut data = vec![1u8, 0, 254, 1, 2, 3, 0, 0, 0, 0, 0];

    let swap_info = SwapInfo::deserialize(&mut &data[..]);
    eprintln!("{:?}", swap_info);
}
```
```
12 | #[derive(Accounts)]
   |          ^^^^^^^^
   |
   = help: message: Invariant violation: composite constraints can only be raw or literals
```
what's a `composite constraint`?
For what it's worth that raw account data you posted above doesn't look like anchor to me
Ok, its written in anchor as well so I'm guessing borsh? How would I deserialize assuming borsh?
But your struct might be simple enough that you can just guess/try both or whatever
No. There are some standard choices, borsh and serde, but they're not the same thing so depends on how that other program works
hmm, so no in built rust library for that sort of thing?
yeah, I just removed some stuff to fit it in a small example, it has like 5 more u64 entries
This is why ideally you'd just depend on that other program's code as a dependency
In general there's no automagic way to do deserialization‚Äîit depends on how the original thing was serialized
Oh, ok, so SwapInfo has a bunch of other stuff in it?
nah, its more complicated, has a bunch of other data in the actual struct
Given that your struct is so simple, you could honestly just manually deserialize it if you're sure about the formatting of that data.
i removed some data
Just to make sure I'm understanding, looks like there's a bunch more data in there‚Äîdo you just not need it?
Like in the logs I get something like:
```Program log: raw data1:RefCell { value: [1, 0, 254, 200, 0, 0, 0, 0, 0, 0, 0, 200, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 140, 187, 27, 48, 177, 27, 15, 193] }
```
Which is (I guess) the account data I'm after (is_initialized, the nonce, etc.), just need to deserialize it now
Ok, that seems to work, how do I deserialize the type `Rc<RefCell<&'a mut [u8]>>` if I know it will have the form of a struct:
```
pub struct SwapInfo {
    pub is_initialized: bool,
    pub is_paused: bool,
    pub nonce: u8,
}
```
? Does that question make sense or am I misunderstanding something about rust types?
Thanks. Yeah I just want to make sure it's the empty-seed pda and not an arbitrary address.
Try doing `msg!("raw data1: {:?}", q);`
Secure check for what? It verifies that that main_pda has empty seeds, yeah.
I lack some rust type knowledge here:
```
#[program]
pub mod stable_read {
    use super::*;
    pub fn read(ctx: Context<SwapInfoCtx>) -> ProgramResult {
        let data = &ctx.accounts.swap_info_account;
        msg!("raw data:{}", data.owner);
        msg!("raw data1:{}",data.rent_epoch);
        //Having trouble converting this to a type I can display
        let q = data.deserialize_data();
        msg!("raw data1:{}", q);
        Ok(())
    }
}

#[derive(Accounts)]
pub struct SwapInfoCtx<'info> {
    ///CHECK: BASED
  pub swap_info_account: AccountInfo<'info>
}

#[account]
pub struct SwapInfo {
    /// Initialized state
    pub is_initialized: bool,

    /// Paused state
    pub is_paused: bool,

    /// Nonce used in program address
    /// The program address is created deterministically with the nonce,
    /// swap program id, and swap account pubkey.  This program address has
    /// authority over the swap's token A account, token B account, and pool
    /// token mint.
    pub nonce: u8,

}
```
I've tried a bunch of different things to convert the data to a type that can be logged but I'm not quite getting it:
``` --> programs/stableRead/src/lib.rs:14:30
   |
14 |         msg!("raw data1:{}", q);
   |                              ^ `Result<_, Box<bincode::error::ErrorKind>>` cannot be formatted with the default formatter
```
thanks that worked üôè 
I'm now fiddling with upgrade problems with my old program 
```
error: bump targets should not be provided with init. Please use bump without a target.
  --> programs/combiner/src/domains/config/initialize_combiner.rs:14:9
   |
14 |         bump = bump,
   |         ^^^^
```
I can see that it was a breaking change at some point, but can someone explain the reason behind it? one way or another the bump has to be passed on. just sometimes it's through context, sometimes it's not. doesn't feel very consistent
Yeah, but does this attribute suffice as a secure check?
The doc comment is because you're using UncheckedAccount (also for AccountInfo, same thing), not for the seeds part
I'm only doing this to use `main_pda` as the authority for the token account I'm creating in this instruction, which is all handled in the account init attribute
Is this the proper way to check the pda account provided?
```rust
    #[account(seeds=[], bump)]
    pub main_pda: UncheckedAccount<'info>
```
The compiler is telling me I need to add a doc comment so I just wanted to make sure
The 2021 edition of rust requires at least 1.56
Try upgrading that to a more recent version
```
$ rustc --version
rustc 1.54.0 (a178d0322 2021-07-26)
```
What version of rust are you using? `rustc --version`
hey.
I noticed that this question has been asked a number of times, but couldn't find any real answer, so I'll post it again... sorry.
thats what I did:
```
$ solana --version
solana-cli 1.8.16 (src:23af37fe; feat:1886190546)
$ anchor --version
anchor-cli 0.22.1
$ anchor init coin-playground
$ cd coin-playground/
$ anchor build
```
and the result is that
```
Failed to obtain package metadata: Error during execution of `cargo metadata`:     Updating crates.io index
 Downloading crates ...
error: failed to download `solana-sdk-macro v1.10.0`

Caused by:
  unable to get packages from source

Caused by:
  failed to parse manifest at `/home/wooha/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-sdk-macro-1.10.0/Cargo.toml`

Caused by:
  feature `edition2021` is required

  this Cargo does not support nightly features, but if you
  switch to nightly channel you can add
  `cargo-features = ["edition2021"]` to enable this feature
```
I checked solana releases and versions 1.9.x are generally considered testnet only and I have the latest mainnet version installed. this is the latest anchor version available in cargo.
but despite that - I am clearly doing something wrong and getting this error, so the question is: what am I doing wrong? üòÑ 
help please üôÇ
No, but failed tests do log to the console
Seems like passing tests only output logs to the file in .anchor? Is there a macro for outputting them to the console after the test or something?
Anyway to see the msg!() when running anchor test? I think it goes of in the background and only console logs from the .ts file are seen
thx
lmao, I see it now, things are starting to make sense
Try googling vim rust-analyzer
It's crucial to get your editor set up to do that, otherwise you're going to have a rough time
xdd ok
No, I'm saying that if you learn how to see how AccountInfo is defined, by jumping to its source, you'll see how to use it üòõ
Vim. Are you saying to redefine what AccountInfo means in anchor?
What editor are you using now?
ugh, any examples of that?
You should configure your editor so you can jump to the AccountInfo source, the definition of the type
what's that? I replaced Account -> AccountInfo on the dervied account
Have you tried jumping to source on the AccountInfo type?
```#[program]
pub mod stable_read {
    use super::*;
    pub fn read(ctx: Context<SwapInfoCtx>) -> ProgramResult {
        let data = &ctx.accounts.swap_info_account;
        msg!("raw data:{}", data);
        Ok(())
    }
}

#[derive(Accounts)]
pub struct SwapInfoCtx<'info> {
  pub swap_info_account: AccountInfo<'info>
}```

So I'm just trying to read the raw account data of the copied account with the above. How do I display it in say bytes? I get this error:
``` --> programs/stableRead/src/lib.rs:10:29
   |
10 |         msg!("raw data:{}", data);
   |                             ^^^^ `anchor_lang::prelude::AccountInfo<'_>` cannot be formatted with the default formatter
   |
```
Init a metaplex account? Don't think there's anything built-in yet for that
Gotcha. Is it possible to do with Anchor?
For example, anytime you `init` an associated token account you're doing this
Yes, but it would require CPIing to that other program (only that other program can sign for the account's address)
Is it possible to init a PDA for another program (metaplex)?
And then doing what you normally do in your own programs, `Account<'info, ThatAccountStruct>`
oh, I see xd
Assuming it's an anchor program, then yeah, adding a dependency to it üòõ
yeah
You mean for an account owned by another program?
like I define a struct I want to deserialize
Ah, I see, is there some built in way to deserialize in anchor?
Otherwise, yeah, you'd need to use `AccountInfo` and handle the deserialization manually yourself
Right, assuming it's an anchor program that's how you would ordinarily do it, via a Cargo dependency
I just want to read that data
If you want to be able to write `Account<'info, SwapInfo>` and have it work, you need to add that other program to your Cargo dependency and use its *own* SwapInfo struct, not your copy of it
do I replace Account with AccountInfo on the derived accounts?
Yea I think I misunderstood I was planning on getting the PDA and calling createTokenAccount but realized that would be wrong so I‚Äôll give this a shot and from the client side I‚Äôd just use the PDA to get the derived ATA to pass in
Ah, so that SwapInfo account is owned by some other program? Yeah, what you wrote above implies its supposed to be owned by your program (the `#[account]` part above the struct)
That could work, but what's the connection to initializing them on the client? I thought that's what we were talking about
I'm copying something from mainnet using test.validator.clone and trying to read that
Right but they still need to be initialized if you‚Äôre depositing or withdrawing SPL from them so I attempted to do so with init if needed is that correct?
the error log?
```
Transaction simulation failed: Error processing Instruction 0: custom program error: 0xbbf
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS invoke [1]
    Program log: Instruction: Read
    Program log: Custom program error: 0xbbf
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS consumed 2197 of 200000 compute units
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS failed: custom program error: 0xbbf
    1) Is initialized!


  0 passing (47ms)
  1 failing

  1) stableRead
       Is initialized!:
     Error: 3007: The given account is owned by a different program than expected
      at Function.parse (node_modules/@project-serum/anchor/src/error.ts:41:14)
      at Object.rpc [as read] (node_modules/@project-serum/anchor/src/program/namespace/rpc.ts:32:42)
      at processTicksAndRejections (node:internal/process/task_queues:96:5)
```
Can you post the full program log?
ATAs are token accounts that live at PDAs derived from a totally different program, the associated token program, so creating them doesn't require your own program to sign for anything (the address is a PDA, but not one of your PDAs)
So I attempted to do so with the atas not sure if they‚Äôre correct
<@!134416332509675520> 
```use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod stable_read {
    use super::*;
    pub fn read(ctx: Context<SwapInfoCtx>) -> ProgramResult {
        let data = &ctx.accounts.swap_info_account.is_paused;
        msg!("isPaused?:{}", data);
        Ok(())
    }
}

#[derive(Accounts)]
pub struct SwapInfoCtx<'info> {
  pub swap_info_account: Account<'info, SwapInfo>
}

#[account]
pub struct SwapInfo {
    /// Initialized state
    pub is_initialized: bool,

    /// Paused state
    pub is_paused: bool,

    /// Nonce used in program address
    /// The program address is created deterministically with the nonce,
    /// swap program id, and swap account pubkey.  This program address has
    /// authority over the swap's token A account, token B account, and pool
    /// token mint.
    pub nonce: u8,

}```
I think I'm getting error 3007 because the above requires my program (above) to own the account I'm reading from? Is this true? How do I fix it?
`my_game_fee_account` and `escrow_payment_account` are PDAs but I need to create ATAs for those so they can handle SPL transfers
Which PDA token account are you referring to? I only see associated_token accounts
like i have this struct so far, thought i could get the PDA token account client side and pass it in, but it may also need to be init_if_needed instead:
```
#[derive(Accounts)]
#[instruction(escrow_payment_bump: u8)]
pub struct DepositSpl<'info> {
    wallet: Signer<'info>,
    #[account(mut)]
    ///CHECK: 
    payment_account: UncheckedAccount<'info>,
    #[account(mut, seeds=[PREFIX.as_bytes(), coin_flip.key().as_ref(), wallet.key().as_ref()], bump=escrow_payment_bump)]
    ///CHECK: 
    escrow_payment_account: UncheckedAccount<'info>,
    #[account(seeds=[PREFIX.as_bytes(), my_game.creator.as_ref()], bump=my_game.bump, has_one=authority, has_one=coin_flip_fee_account, )]
    coin_flip: Account<'info, CoinFlip>,
    #[account(mut, seeds=[PREFIX.as_bytes(), my_game.key().as_ref(), FEE_ACCOUNT.as_bytes()], bump=my_game.fee_account_bump)]
    ///CHECK: 
    my_game_fee_account: UncheckedAccount<'info>,
    #[account(mut)]
    mint: Account<'info, Mint>,
    #[account(mut, associated_token::mint = mint, associated_token::authority = wallet)]
    token_account: Account<'info, TokenAccount>,
    #[account(
        mut,
        associated_token::mint = mint,
        associated_token::authority = my_game_fee_account,
    )]
    my_game_fee_ata: Account<'info, TokenAccount>,
    #[account(
        mut,
        associated_token::mint = mint,
        associated_token::authority = escrow_payment_account,
    )]
    escrow_payment_account_ata: Account<'info, TokenAccount>,
    token_program: Program<'info, Token>,
    ///CHECK:
    authority: UncheckedAccount<'info>,
    system_program: Program<'info, System>,
    rent: Sysvar<'info, Rent>,
}
```
can you create a PDA for a different program other than your own?
Hmm ok, then i might need to modify a few things.. will have to get back to this
any idea why I'm getting error 3007 here? The declareId seems ok
But at any rate creating a token account that lives at one of your program's PDAs requires invoking your program
Or maybe I misunderstood what you creating the token account client side
No, token program still requires passing the rent account, regardless of how you invoke it. Plus, unfortunately, creating an account ultimately requires a signature from the address, and for PDAs that's only possible by getting the deriving program to sign, so it isn't even possible to create a PDA token account from the client.
Can you get around this by creating the token account client side for the pda if it doesn‚Äôt exist?
The token program happens to be written in such a way that it requires an explicit rent account (newer programs don't need to do that anymore)
but not when creating other pdas
why do I need to include the Rent sysvar in the context accounts when creating a pda token account?
Yea I just saw that in the changelog
Ok, that means you should mark that payer with `#[account(mut)]`
Still confused on whats the problem with #program and initialize now tho
oh, ok, and after doing that its complaining about payer not being mutable `the payer specified for an init constraint must be mutable`, payer (see above) is `Signer<``info>`
https://github.com/project-serum/anchor/blob/master/CHANGELOG.md is usually a good source for migration information, e.g. ```lang: Providing bump = <target> targets with init will now error. On init only, it is required to use bump without a target and access the seed inside function handlers via ctx.bumps.get("<pda-account-name"). For subsequent seeds constraints (without init), it is recommended to store the bump on your account and use it as a bump = <target> target to minimize compute units used (#1380).```
This is saying to just replace all those `bump = some_bump,` with just `bump,`, no equals etc. Anchor will figure out the bumps for you now.
I guess curious what I‚Äôm missing or any tips on migration? Seems there are a ton of breaking changes
this all started happening after using latest anchor, trying to refactor the error codes and programresult now, but running into this
Then also seeing this now :
```
error[E0599]: no function or associated item named `try_accounts` found for struct `Initialize` in the current scope
   --> programs/my-game/src/lib.rs:21:1
    |
21  | #[program]
    | ^^^^^^^^^^ function or associated item not found in `Initialize<'_>`
...
442 | pub struct Initialize<'info> {
    | ---------------------------- function or associated item `try_accounts` not found for this
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `try_accounts`, perhaps you need to implement it:
            candidate #1: `anchor_lang::Accounts`
    = note: this error originates in the attribute macro `program` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the trait bound `Initialize<'_>: anchor_lang::Accounts<'_>` is not satisfied
  --> programs/my-game/src/lib.rs:21:1
   |
21 | #[program]
   | ^^^^^^^^^^ the trait `anchor_lang::Accounts<'_>` is not implemented for `Initialize<'_>`
   |
note: required by `anchor_lang::context::Context::<'a, 'b, 'c, 'info, T>::new`
  --> /Users/davidmaman/.cargo/registry/src/github.com-1ecc6299db9ec823/anchor-lang-0.22.1/src/context.rs:51:5
   |
51 | /     pub fn new(
52 | |         program_id: &'a Pubkey,
53 | |         accounts: &'b mut T,
54 | |         remaining_accounts: &'c [AccountInfo<'info>],
55 | |         bumps: BTreeMap<String, u8>,
56 | |     ) -> Self {
   | |_____________^
   = note: this error originates in the attribute macro `program` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: no method named `exit` found for struct `Initialize` in the current scope
   --> programs/my-game/src/lib.rs:21:1
    |
21  | #[program]
    | ^^^^^^^^^^ method not found in `Initialize<'_>`
...
442 | pub struct Initialize<'info> {
    | ---------------------------- method `exit` not found for this
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `exit`, perhaps you need to implement it:
            candidate #1: `anchor_lang::AccountsExit`
    = note: this error originates in the attribute macro `program` (in Nightly builds, run with -Z macro-backtrace for more info)
```
```
#[derive(Accounts)]
#[instruction(bump: u8, fee_account_bump: u8, treasury_bump: u8)]
pub struct Initialize<'info> {
    #[account(init, seeds=[PREFIX.as_bytes(), authority.key().as_ref()], bump=bump, space=MY_GAME_SIZE, payer=payer)]
    coin_flip: Account<'info, CoinFlip>,
    #[account(mut, seeds=[PREFIX.as_bytes(), my_game.key().as_ref(), FEE_ACCOUNT.as_bytes()], bump=fee_account_bump)]
    coin_flip_fee_account: UncheckedAccount<'info>,
    #[account(mut, seeds=[PREFIX.as_bytes(), my_game.key().as_ref(), TREASURY.as_bytes()], bump=treasury_bump)]
    my_game_treasury: UncheckedAccount<'info>,
    payer: Signer<'info>,
    authority: UncheckedAccount<'info>,
    #[account(mut)]
    fee_withdrawal_destination: UncheckedAccount<'info>,
    #[account(mut)]
    treasury_withdrawal_destination: UncheckedAccount<'info>,
    system_program: Program<'info, System>,
}
```
```bump targets should not be provided with init. Please use bump without a target.```
So im starting to see this. I have an account struct in initialize that utilizes bumps and was working find before upgrading to latest anchor
Almost there; it is enough apparently; the signer should be `anchor.getProvider().wallet.payer`, but for some reason Visual Studio is telling me that the type "Wallet" has no property "payer".
Wait, that's still not enough to be able to sign a transaction with the user's Phantom keypair. Though the URL here I think is just devnet.
Ah, looks like I can use `anchor.setProvider()`, but I need a connection endpoint URL for the connection... unless I'm missing something. Is there a default URL to use, or a way to get one?
Hi probably a weird question... my program in 1 instruction will init a PDA passed in by a user, in another instruction it will do validation on this PDA, is it possible an attacker could init a PDA without going through my program? Or is a property of a PDA that only my program can init it's own PDAs?
Ok, so I upgraded my version of anchor since apparently it does that automatically now, the error I get now is:
```  0 passing (47ms)
  1 failing

  1) stableRead
       Is initialized!:
     Error: 3007: The given account is owned by a different program than expected
```
Where can I find the method findProgramAddressSync?
So I'm reading through the discord:
Apparently I need to add the upgradeable cllone too? Like this:
```const programDataAddress = findProgramAddressSync(
      "SQDY9uoDoCbNq7F3HAHYYQZbrUzpKxDtdWLvYcqBLak",
      new anchor.web3.PublicKey("BPFLoaderUpgradeab1e11111111111111111111111")
    )[0];

    console.log(programDataAddress);```
And then add whatever address I get to the anchor toml?
The account is https://solscan.io/account/SQDY9uoDoCbNq7F3HAHYYQZbrUzpKxDtdWLvYcqBLak , which has some data so I would expect it to be initialized by my anchor toml
And the error I get after anchor test:
```  stableRead
hi
Transaction simulation failed: Error processing Instruction 0: custom program error: 0xbc4
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS invoke [1]
    Program log: Instruction: Read
    Program log: Custom program error: 0xbc4
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS consumed 2176 of 200000 compute units
    Program Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS failed: custom program error: 0xbc4
    1) Is initialized!


  0 passing (47ms)
  1 failing

  1) stableRead
       Is initialized!:
     Error: 3012: The program expected this account to be already initialized
```
This is my testing code:
```import * as anchor from '@project-serum/anchor';
import { Program } from '@project-serum/anchor';
import { stableRead } from '../target/types/stableRead';

describe('stableRead', () => {

  // Configure the client to use the local cluster.
  anchor.setProvider(anchor.Provider.env());

  const program = anchor.workspace.StableRead as Program<StableRead>;

  it('Is initialized!', async () => {
    // Add your test here.
    console.log("hi");
    const tx = await program.rpc.read({
      accounts:{
        swapInfoAccount:new anchor.web3.PublicKey("SQDY9uoDoCbNq7F3HAHYYQZbrUzpKxDtdWLvYcqBLak")
      }
    });


    console.log("Your transaction signature", tx);
  });
});
```
anyway to check if the clone is working properly?
This is in my anchor.toml:
```[test.validator]
url = "https://api.mainnet-beta.solana.com"
[[test.validator.clone]]
address = "SQDY9uoDoCbNq7F3HAHYYQZbrUzpKxDtdWLvYcqBLak"```
`cluster = "localnet"` in my Anchor.toml
Trying to run a basic client.js script for my program deployed on localnet. Being told `Error: ANCHOR_PROVIDER_URL is not defined` . `anchor test` works just fine
How one would generally go about it. I read through https://lorisleiva.com/create-a-solana-dapp-from-scratch/integrating-with-solana-wallets , for instance, but that seems specific to Vue.
If I have a function that looks like this:
```
pub fn initialize_token_acct(ctx: Context<InitializeTokenAcct>) -> ProgramResult {
    msg!("Transferring tokens from: {:?}", ctx.accounts.token_acct.key());
    msg!("To: {:?}", ctx.accounts.escrowed_token_acct.key());

    let cpi_accounts = token::Transfer {
        from: ctx.accounts.token_acct.to_account_info(),
        to: ctx.accounts.escrowed_token_acct.to_account_info(),
        authority: ctx.accounts.acct_authority.to_account_info()
    };

    let cpi_program = ctx.accounts.token_program.to_account_info();
    let cpi_mint_tx = CpiContext::new(cpi_program, cpi_accounts);
    
    token::transfer(cpi_mint_tx, 1)?;

    Ok(())
}

#[derive(Accounts)]
pub struct InitializeTokenAcct<'info> {
    #[account(mut)]
    pub token_acct: Account<'info, TokenAccount>,
    #[account(mut)]
    pub token_mint: Account<'info, Mint>,
    #[account(signer)]
    pub acct_authority: AccountInfo<'info>,
    pub token_program: AccountInfo<'info>,
    // This is where we'll store the offer maker's tokens.
    #[account(
        init,
        payer = payer,
        seeds = [token_acct.mint.as_ref()],
        bump,
        token::mint = token_mint,
        token::authority = escrowed_token_acct,
    )]
    pub escrowed_token_acct: Account<'info, TokenAccount>,
    #[account(mut)]
    pub payer: Signer<'info>,
    pub system_program: Program<'info, System>,
    pub rent: Sysvar<'info, Rent>
}
```

But I want to set a constraint that this can only be run for a select set of token/mint addresses, what's the best way for me to do this? The approaches I see are:

1/ Keep a static list of mint addresses and do a check at the beginning of `initialize_token_acct` to see if the token/mint accounts passed are included in that static list. If not, terminate early

2/ On the client side, keep that static list, and don't make the program rpc call if the token/mint accounts aren't in that list
You have to use that pubkey address and then pass it as an account to your program when you invoke it


//////////////////////////////////////////////////////////////////////////////////////////

Is anybody else having error with avm installation? I am running following command and receive following error
`cargo install --git https://github.com/project-serum/anchor avm --locked --force`
> failed to compile `avm v0.22.1 (https://github.com/project-serum/anchor#6dd0574c)`,
what is the last working version of Solana & Anchor-cli someone used to deploy Solana program to test net?
Hi All , I am working in scan to earn protocol . I have some doubt some question is the best approach to replicate this pattern using Anchor. The target of the protocol si monetize Scan action of the customer. For that when people scan product connect with a Master Product record . This MP has a metadata about product detail . After that the people could be win a NFTs with discount. Any advice is welcome
Hi, is it possible to forward local node time during anchor tests? thanx in advance
any suggestion on this anyone?
This is the current stack into the containerX - Solana and anchor  the setup step compile it .
Hi , I am develop a project to compile and install Solana Development stack into the container and & glyclt connect with container . please any comments or advice is welcome.  I am just testing on my laptop  https://github.com/glyfo/glyclt

There's only one change in the template, right? Getting 
```
missing generics for type alias `anchor_lang::Result`
```
running 0.22.1 via new version manager
Thanks, I deleted that code, when I was facing an error which was probably unrelated
from client
And then check `ctx.accounts.that_account.key() == THE_HARDCODED_KEY`
Passing it in is not an issue
Pass it in like any other account into your program
lol
How do this
And then verify in your program that it has the expected address
Ah, no, you have to pass that account in from the client
Been unable to find how people are calling the same into a function. the CPI call requires to_account_info and I am unable to get that from a hardcoded id
For your custom stuff, yeah, you need to have some way to hardcode the id
for the token program yes, but for my custom token?
You don't need to hardcode the token program's id yourself, since you're presumably already depending on its source
This is basically the point of `declare_id!`‚Äîit hardcodes the intended program id into the program text, which lets *other* programs depend on your code and see what your intended ID is.
use anchor_lang::prelude::*;
use anchor_spl::token::{Transfer, Mint, Token, TokenAccount};
/* use anchor_spl::token::accessor::amount;
use anchor_spl::associated_token::get_associated_token_address;
use solana_program::{instruction::Instruction, program::invoke_signed};

const NEWSTOKEN: Pubkey = solana_program::pubkey!("3qq7ExpwRRAAexGNpUVoFkiTfSB1uo8ezsbyAoxhyryo");
const TREASURY: Pubkey = solana_program::pubkey!("6kgSK2hFDjUCS3wafYYW2VSwkjETuqHdByWddwmytyp7");
const TOKEN_PROGRAM: Pubkey = solana_program::pubkey!("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
 */
const FEE_AMOUNT:u64 = 100000000;

declare_id!("3Z8eqLzepWH6UmqFyU9mDsjQp6QepLURqHSBFwmJLdCh");

#[program]
pub mod newsreport {
    use super::*;
    pub fn initialize(ctx: Context<Initialize>)  -> ProgramResult  {
        let report_acc = &mut ctx.accounts.report_account;
        report_acc.authority = *ctx.accounts.authority.key;
        report_acc.status = 0;
        anchor_spl::token::transfer(
            CpiContext::new(
                ctx.accounts.newstoken.to_account_info(),
                anchor_spl::token::Transfer {
                    from: ctx.accounts.from.to_account_info(),
                    to: ctx.accounts.treasury.to_account_info(),
                    authority: ctx.accounts.authority.to_account_info(),
                    },
                ),
                FEE_AMOUNT,
            )?;
        Ok(())
    }
Sharing my code
By hardcoding program ids üôÇ
how does a program verify another program without hardcoding program ids?
I see, well i guess i will wait that more apps became open sourced.
If you mean guess the seeds just based on the address, not really‚Äîthe address is a hash of the seeds + some other stuff, so can't really reverse-engineer that unless you have some clever way to guess the seeds/look at previous transactions where they were submitted as arguments, or something like that.
What do you mean by revert?
is it possible to revert the seed of an account if the idl is not provided ?
Hi Guys. I'm running `anchor test --skip-local-validator` but still getting this error:
`Error: failed to get recent blockhash: FetchError: request to http://localhost:8899/ failed, reason: connect ECONNREFUSED 127.0.0.1:8899`

The program is on devnet
Got it, thanks... would there be some way to verify with a hardcoded program ID in the program? I want to trigger an action only when the tokens of my XYZ mint are transferred from any account to treasury
BTreeMaps don't work either yet
No, unfortunately
Does anchor support the HashMap type? after running `anchor test`, I get the idl error ```Type not found: {"name":"judges","type":{"defined":"HashMap<Pubkey,u16>"}}```
In general, if there is a way to fix this, what would be the best way for all/general types?
Drift uses pyth
You can't in solana. If you want an AccountInfo, you need to pass that pubkey in from the client as an account.
Just do `*sInfo`
How would I to_account_info this?
"ctx: Context<Initialize> ", is it parameter ?
ok... nevermind... i was just missing `libudev-dev` package ü§¶
Hi everyone 
very new to Anchor and Solana... just tried to install `anchor-cli` as `avm use latest` asked me for but it doesnt succeed.

here's the error in my terminal:
```bash
error: failed to run custom build command for `hidapi v1.2.7`

Caused by:
  process didn't exit successfully: `/tmp/cargo-installtjmfyE/release/build/hidapi-6b926c95403ad6b5/build-script-build` (exit status: 101)
  --- stdout
  cargo:rerun-if-env-changed=LIBUDEV_NO_PKG_CONFIG
  ...
  ...
  ...
  --- stderr
  thread 'main' panicked at 'Unable to find libudev: `"pkg-config" "--libs" "--cflags" "libudev"` did not exit successfully: exit status: 1
  --- stderr
  Package libudev was not found in the pkg-config search path.
  Perhaps you should add the directory containing `libudev.pc'
  to the PKG_CONFIG_PATH environment variable
  No package 'libudev' found
  ', /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/hidapi-1.2.7/build.rs:53:54
  note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
warning: build failed, waiting for other jobs to finish...
error: failed to compile `anchor-cli v0.22.1 (https://github.com/project-serum/anchor?tag=v0.22.1#b733610d)`, intermediate artifacts can be found at `/tmp/cargo-installtjmfyE`

Caused by:
  build failed
Error: Failed to install 0.22.1, is it a valid version?
```

I've tried to find but there's no open issue on Github 
I guess it's just something I'm missing locally... but I do not understnad what exactly ü§∑‚Äç‚ôÇÔ∏è ??
When i deploy my solana program to devnet / testnet I am getting `Invalid blockhash error` .

My tools:
- `anchor-cli` - `0.21.0`
- `solana-cli` - `1.9.5`
anyone know any good open source codebases using pyth?
9  | #[program]
   | ^^^^^^^^^^ the trait `anchor_lang::Accounts<'_>` is not implemented for `Initialize<'_>`
   |
note: required by `anchor_lang::context::Context::<'a, 'b, 'c, 'info, T>::new`
  --> /root/.cargo/registry/src/github.com-1ecc6299db9ec823/anchor-lang-0.22.1/src/context.rs:51:5
   |
51 | /     pub fn new(
52 | |         program_id: &'a Pubkey,
53 | |         accounts: &'b mut T,
54 | |         remaining_accounts: &'c [AccountInfo<'info>],
55 | |         bumps: BTreeMap<String, u8>,
56 | |     ) -> Self {
   | |_____________^
   = note: this error originates in the attribute macro `program` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: no method named `exit` found for struct `Initialize` in the current scope
  --> programs/sol-poll/src/lib.rs:9:1
   |
9  | #[program]
   | ^^^^^^^^^^ method not found in `Initialize<'_>`
...
44 | pub struct Initialize<'info> {
   | ---------------------------- method `exit` not found for this
   |
   = help: items from traits can only be used if the trait is implemented and in scope
   = note: the following trait defines an item `exit`, perhaps you need to implement it:
           candidate #1: `anchor_lang::AccountsExit`
   = note: this error originates in the attribute macro `program` (in Nightly builds, run with -Z macro-backtrace for more info)

Some errors have detailed explanations: E0277, E0432, E0599.
For more information about an error, try `rustc --explain E0277`.
error: could not compile `sol-poll` due to 5 previous errors
'error: bump targets should not be provided with init. Please use bump without a target.
  --> programs/sol-poll/src/lib.rs:58:57
   |
58 |     #[account(init, seeds = [b"vote_account".as_ref()], bump = vote_account_bump, payer = user)]
   |                                                         ^^^^

error[E0432]: unresolved import `crate`
 --> programs/sol-poll/src/lib.rs:9:1
  |
9 | #[program]
  | ^^^^^^^^^^ could not find `__client_accounts_initialize` in the crate root
  |
  = note: this error originates in the attribute macro `program` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: no function or associated item named `try_accounts` found for struct `Initialize` in the current scope
  --> programs/sol-poll/src/lib.rs:9:1
   |
9  | #[program]
   | ^^^^^^^^^^ function or associated item not found in `Initialize<'_>`
...
44 | pub struct Initialize<'info> {
   | ---------------------------- function or associated item `try_accounts` not found for this
   |
   = help: items from traits can only be used if the trait is implemented and in scope
   = note: the following trait defines an item `try_accounts`, perhaps you need to implement it:
           candidate #1: `anchor_lang::Accounts`
   = note: this error originates in the attribute macro `program` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the trait bound `Initialize<'_>: anchor_lang::Accounts<'_>` is not satisfied
  --> programs/sol-poll/src/lib.rs:9:1
   |
running into this set of errors upgrading the program from version 0.16.0 to 0.22.1
when i run anchor build it throws this error 

```
anchor build
Only x86_64 / Linux distributed in NPM package right now.
Trying globally installed anchor.
BPF SDK: /Users/mp-haidera-pyse-403/.local/share/solana/install/releases/1.8.0/solana-release/bin/sdk/bpf
Running: rustup toolchain list -v
Running: cargo +bpf build --target bpfel-unknown-unknown --release
error: failed to download `solana-frozen-abi v1.9.2`

Caused by:
  unable to get packages from source

Caused by:
  failed to parse manifest at `/Users/mp-haidera-pyse-403/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-frozen-abi-1.9.2/Cargo.toml`

Caused by:
  feature `edition2021` is required

  consider adding `cargo-features = ["edition2021"]` to the manifest
```
dunno whats mpl-token-metadata, but spl programs seem to be there.
anchor test uses local blockchain, not devnet or testnet (unless otherwise configured)
on devnet and testnet you will have those programs deployed for sure
it seems that spl token is available for testing during anchor test. Do I every need to deploy SPL token contract? How about mpl-token-metadata ?
would this be different for devnet and testnet ?
Is it the same account as you use in `declare_id!`?
I'm hitting a wall with `anchor idl init` (localnet). It looks like it might be the same issue as https://github.com/project-serum/anchor/issues/1543 but afaict the program ID I'm passing is correct--unless I'm completely misunderstanding the command
```
const signers = [];
            if (gem_common_2.isKp(vaultOwner))
                signers.push(vaultOwner);
            console.log(`depositing ${gemAmount} gems into ${gemBox.toBase58()}, GDR ${GDR.toBase58()}`);
            const txSig = yield this.bankProgram.rpc.depositGem(vaultAuthBump, gemRarityBump, new anchor.BN(gemAmount), {
                accounts: {
                    bank,
                    vault,
                    owner: (0, gem_common_2.isKp(vaultOwner))
                        ? vaultOwner.publicKey
                        : vaultOwner,
                    // owner: vaultOwner,
                    authority: vaultAuth,
                    gemBox,
                    gemDepositReceipt: GDR,
                    gemSource,
                    gemMint,
                    gemRarity,
                    tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
                    systemProgram: web3_js_1.SystemProgram.programId,
                    rent: anchor.web3.SYSVAR_RENT_PUBKEY,
                },
                remainingAccounts,
                signers,
            });
            console.log("we are after the txSig");
```
Hello, I am trying to understand signers right here, and in the check for if keypair of the vault is there, I push the keypair as one of the signers, I keep getting the signers as being empty. 

I have also removed this if statement, and I get to the signature approval section, but after I sign the transaction, I am unable to read the signer's publicKey
So sInfo is of type: `Account<'info, SwapInfo>` . 
If I want to extract just the SwapInfo I believe `sInfo.account` would give it to me but it's private? How else can I log it?
Does my question make sense <@!134416332509675520> ?
Ok, made a bunch of progress. Any way to make the `account` field not private on an Account struct within anchor?
```error[E0616]: field `account` of struct `anchor_lang::prelude::Account` is private
  --> programs/stableTry/src/lib.rs:12:38
   |
12 |         msg!("raw data1:{:?}", sInfo.account);
   |                                      ^^^^^^^ private field
```
oh, the actual saber files are broken. Lmao. Thx anyway
```error: suffixes on a string literal are invalid```
Hey guys, i was trynna make the messengerapp and i got stuck in the end, i dont know what¬¥s happening fr, can someone help me please?
invalid suffix, anything come to mind?
also have this error in same place
```#[derive(Accounts)]
  |          ^^^^^^^^ invalid suffix `A````
Ok, I don't think I have enough info to help more, it might be something else‚Äîwhat you have above looks roughly ok, besides the Clone part
Ok, btw this is just the file from the Saber github. Wouldn't expect to need to modify it just to get deserialize working
You can send sol from one of your own accounts without doing any CPI
It's the only way to send sol from a system account
https://discord.com/channels/889577356681945098/889702325231427584/894622214824030289 explains it pretty well. Thank you
yeah. I was trying to impl program-owned SOL and not realizing that CPI is not the only why to send and receive SOL
But you definitely don't need the Clone/it won't work, so get rid of it
Can you also just be safe and get rid of that triple backslash comment
hmm, same problem still
Yeah, possibly‚Äîwhy are you allocating space for a system account?
I think it's because I have also used space =8 which means there data allocated
Get rid of that clone too lol
```#[derive(Accounts, Clone)]
pub struct InitToken<'info> {
    /// The token account for the pool's reserves of this token.
    pub reserve: AccountInfo<'info>,
    /// The token account for the fees associated with the token.
    pub fees: AccountInfo<'info>,
    /// The mint of the token.
    pub mint: AccountInfo<'info>,
}```
I mean how is that struct defined
I'm just trying to get the dependencies working to deserializer it
https://discord.com/channels/889577356681945098/889702325231427584/894622214824030289
I used 'owner = system.key' annotation
It's some other struct from the saber protocol
What is InitToken?
same thing happens if I change ```#[derive(Accounts, Clone)] -> #[derive(Accounts)]```
Mm, just get rid of it haha, it's not relevant in that context
or dependency?
oh is it expecting another import?
whats derive clone used for?
Can't derive Clone there
Do you know what might cause this error?
```
error: expected one of `.`, `?`, `]`, or an operator, found `" token of the swap.
"`
 --> /home/a/stable-swap/stable-swap-anchor/src/accounts.rs:6:10
  |
6 | #[derive(Accounts, Clone)]
  |          ^^^^^^^^ expected one of `.`, `?`, `]`, or an operator
  |
  = note: this error originates in the derive macro `Accounts` (in Nightly builds, run with -Z macro-backtrace for more info)
```
File just looks like this:
```
use anchor_lang::prelude::*;
/// Accounts for an [crate::initialize] instruction.
#[derive(Accounts, Clone)]
pub struct Initialize<'info> {
    #[account(signer)]
    pub swap: AccountInfo<'info>,
    pub swap_authority: AccountInfo<'info>,
    pub admin: AccountInfo<'info>,
    pub token_a: InitToken<'info>,
    pub token_b: InitToken<'info>,
    pub pool_mint: AccountInfo<'info>,
    pub output_lp: AccountInfo<'info>,
    pub token_program: AccountInfo<'info>,
}
```
Why do you think it's owned by the system program? I'm pretty sure it's not
Error when transfer SOL using CPI
---
Transfer: from must not carry data
---
Understanding that you would get if transfer from account NOT owned by System program, but in my case the account IS OWNED by system program,
but has a 8bytes space allocated. Could I ask why the error ?
Kind of don't think that should be necessary though
Maybe also/instead do
```.rs
use anchor_lang::Owner;
```
Can I show you my Cargo.toml for the main file
hmm, wait nevermind, still same issue
thx
lmao, ok, that did something
Even if traits have the same name etc., they're strictly speaking different if they come from different versions of the same crate
Unfortunately they're probably going to need to be the exact same version :/
one is >=0.22.0 one is 0.22.1
Are you using the exact same anchor-lang version in both crates?
<@!134416332509675520> am I missing something basic in rust? I have swapInfo implementing `Owner`:
```impl Owner for SwapInfo {
    fn owner() -> Pubkey {
        crate::ID
    }
}```
which then gets imported to my main file by a dependency from a cargo.toml file. After trying to compile the main file I get:
```error[E0277]: the trait bound `SwapInfo: Owner` is not satisfied
   --> programs/stableTry/src/lib.rs:20:26
    |
20  |   pub swap_info_account: Account<'info, SwapInfo>
    |                          ^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Owner` is not implemented for `SwapInfo`
    |
note: required by a bound in `anchor_lang::prelude::Account`
   --> /home/a/.local/share/cargo/registry/src/github.com-1ecc6299db9ec823/anchor-lang-0.22.1/src/accounts/account.rs:221:70
```
Is their something special about the keyword "trait" that I'm missing? Why doesn't it recognize the owner trait?
is there a way to declare space as a variable based on the size of an array?
For example if i'm going to declare an account that will contain an array, then is there a way to make space = "size of array"??
I don't know, try logging what whitelistAddress is I guess
What about this error message?
You have 256 chances, so the chance of not finding a suitable off-curve address is 1/2^256, which is unbelievably small.
No, there's a 50/50 chance *per bump choice* that it won't work
You said there is a 50/50 chance that they don't find it. If so, will there be an error message that shows up and I have the change the seed?
Think of PDAs as being a map/association/whatever from [seed1, seed2, ...] ==> the resulting address.
No, the seeds are arbitrary-ish chunks of bytes that "name" the address, and the bump is a single byte that makes sure the resulting address is off-curve
got it so the seeds are an arbitrary value that helps to find the bump that is "off-curve"?
And findProgramAddress finds something that's *not* on the ed25519 curve: https://discord.com/channels/889577356681945098/889702325231427584/939324164890845265
Seeds are an array of arbitrary (well, not too long) chunks of bytes
Once you upgrade to 0.22.1 try switch "ProgramResult" to "Result<()>"
I have a quick question regarding finding the "findProgramAddress" function. I understand that it is trying to find a valid program address on the ed25519 curve. So, when I give seeds to the findProgramAddress call, when I use nfts as a public key, I am able to retrieve its Uint8Array by using the <NFT publicKEY>.toBytes() function. However if I use a token address to do so, I get that it is not a function and an error message like above.

I checked the anchor source code and token mint address is used as one of the seeds with giving it a mint.toBuffer() function.
```
export async function associatedAddress({
  mint,
  owner,
}: {
  mint: PublicKey;
  owner: PublicKey;
}): Promise<PublicKey> {
  return (
    await PublicKey.findProgramAddress(
      [owner.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mint.toBuffer()],
      ASSOCIATED_PROGRAM_ID
    )
  )[0];
}
```

However, sometimes it is given a literal string, 
```
 const [redeemableMint, redeemableMintBump] =
      await anchor.web3.PublicKey.findProgramAddress(
        [Buffer.from(idoName), Buffer.from("redeemable_mint")],
        program.programId
      );
```
What is the difference between the two? And when are their use cases for the two?

Can you show the actual full error message?
Hello, I am working with gemworks and had a question regarding it. I was trying to use a function called "findWhitelistProofPDA"

```
export const findWhitelistProofPDA = async (
  bank: PublicKey,
  whitelistedAddress: PublicKey
) => {
  console.log("We are in the findWhiteListProofPDA", whitelistedAddress);
  return PublicKey.findProgramAddress(
    [Buffer.from('whitelist'), bank.toBytes(), whitelistedAddress.toBuffer()],
    GEM_BANK_PROG_ID
  );
};
```
However, something weird that I encountered is that on my front end when it reaches this line of code, I get an error message called, ```whitelistedAddress.toBytes()``` is not a function. However, no where in my code, I am able to see this since I changed the code from 
```whitelistaddress.toBuffer --> whitelistedAddress.toBytes()```. Could someone advise me why my changes are not being reflected properly?
thx
Yep, check out this part of the tutorial: https://project-serum.github.io/anchor/tutorials/tutorial-3.html
<@!134416332509675520> 
Any examples of adding an anchor project as a dependency so I can read account data from it?

Not sure with how to add dependencies in anchor / rust
The snippet you have there is a little confused, you would need to use `#[account]`, not derive(Accounts), and yeah, use a Pubkey for mint
Feel like you would need to store a Vec<MintConfiguration> tho
Then you would just have a handler only the program owner could call to add or update the structs
did you figure out a path forward for this? Im looking for something like this as well but also want to store configurations for each like 

```
#[derive(Accounts)] // or #[state] ?
pub struct MintConfiguration<'info> {
  mint: Account<'info, Mint>, //or just Pubkey
  fee: u16,
  mint_bump: u8,
}
```
Then get the PDA with this account struct to get the configuration for a certain mint. Not sure if this is good practice tho
Yeah, I should have explained further‚Äîthank you for actually writing it out üôè
I'm having problems with polling solana account data and data flashing back and force from old account to new account. Using `confirmed`
Is there a way to get the blockhash of the account data or anything?
to explain a bit more what he means - let me give you an example of SOL (but it doesn't really matter if it's SOL or any other currency):
- 1 SOL = 1_000_000_000 LAMPORTS (can be whatever you set, based on the decimals field)
- you define the transfer amounts in LAMPORTS (not in SOL)
- 1.2 SOL = 1_200_000_000 LAMPORTS

does that make sense?
All token balances are integers, so it doesn't really make sense to transfer floats.
Wouldn't 1.2 be more precise than 1?
so if a user would like to send spl-tokens, would you advise me to send via whole numbers? It is not possible to do an spl-transfer like 1.2?
You probably don't want to transfer any assets in floating point, it's not precise.
hello, is it possible to do token::transfer using f64 instead of u64? Currently it looks like it is using u64.
Does anyone know how to properly implement errors when they're defined in two different files? I'm facing an issue where one file's errors overwrite the other's in the IDL upon building, and therefore, the wrong error getting returned.
Has anyone played around with f32 vs f64 performance in terms of compute unit usage?  There's this: https://github.com/solana-labs/solana-program-library/tree/master/libraries/math for fixed-point vs f64 but nothing for f64 vs f32
won't affect most people I don't think
not a big deal really I just didn't know
it can't be. what it does is tell the tests where your program is located (it's just the program address).
Anchor add's it to your idl when you deploy via anchor deploy or anchor test but I had to add it manually when using solana program deploy
not quite sure what this field you pasted there does, but feels like something that can be configured with Anchor.toml maybe?
nothing it just doesn't add that metadata field to deploy so you can run tests via anchor run test if deploying that way
whats wrong with solana program deploy?
<:bagsLove:500156064507887618>

Nvm turns out that was the issue. Had to manually add my metadata to the idl and now it works:
I would if I could. Unfortunately deploying on mainnet-beta using the default rpc almost never works. I'm forced to use solana program deploy and use my own custom rpc to get deploy's to work.

Maybe the issue lies in there?
Try just `anchor test`
any ideas what this could be?

I have two tests that run fine on provider cluster devnet

Getting a weird issue when I run:
```
anchor run test
```
On mainnet-beta none of my tests run?
<@!134416332509675520> to continue on our previous conversation, what would a constraint look like that verifies that the signer is one in a list of valid signers?


//////////////////////////////////////////////////////////////////////////////////////////

Lol, i‚Äôll check that..
Ah, you're probably just using the wrong bump then
they look identical..
and this on the rust side
getting this on the typescript side
thx a lot, managed to print it!
ah nvm i'll see it on the error log.
oh also, if the transaction doesn't get through, where can I see the logs?
lol, alright
One silly hack you can do is
```.rs
space = {
    msg!("hmmmmmm {:?}", _index.to_le_bytes());
    8 + PositionAccoutnSaber::LEN
}
```
``` 
#[derive(Accounts)]
#[instruction(
    _bump_portfolio: u8,
    _bump_position: u8,
    _max_initial_token_a_amount: u64,
    _max_initial_token_b_amount: u64,
    _min_mint_amount: u64,
    _index: u32,
)]
pub struct ApprovePosition<'info> {

    #[account(mut)]
    pub owner: Signer<'info>,

    #[account(
        init_if_needed,
        payer = owner,
        space = 8 + PositionAccount::LEN,
        seeds = [
            owner.key().as_ref(),
            &_index.to_le_bytes(),
            seeds::USER_POSITION_STRING
        ],
        bump = _bump_position,
    )]
    pub position_pda: Box<Account<'info, PositionAccount>>,

```
Can you show me your derive(Accounts)?
whats the best way to print this on the rust side actually?
devnet is a bit clugged it seems, so trying to not push so msg! takes time
I didn't print it yet, I guess the next step üòÖ
or do any additional bytes get concetanated somewhere without me knowing xD
Have you checked that it does?
and then this here `Buffer.from([...bn.toArray("le", 4)])` is also supposed to return me 4 bytes, in the exact same order
Yep, that sounds fine
which returns me 4 bytes
but so the type ` _index: u32,`
needs to be serialized to `&_index.to_le_bytes(),`, right?
You just need to be really careful to make sure the byte are exactly the same
or any pointers on how to seed the PDA by some index?
any idea what / how else I could debug?
still getting some signature errors though.. I also tried this program completely without the "index" part. 

i.e. it was working fine when I just used owner.pubkey and SEED.POSITION_ACCOUNT as the seeds
ah ok, thx!
Yes
ah, so this is not bits, it's bytes?
u32 is 4 bytes, not 32
index is u32
Have to be very careful to use the right number of bytes
where I use 
``` 
bnTo8(bn: BN): Uint8Array {
        return Buffer.from([...bn.toArray("le", 32)])
    }
``` one of the previous messages in this discord to arrive at a buffer for the BN
What datatype is that index thing?
in typescript, I have this 
```
let [positionPDA, bumpPosition] = await PublicKey.findProgramAddress(
            [this.owner.publicKey.toBuffer(), indexAsBuffer, Buffer.from(anchor.utils.bytes.utf8.encode(SEED.POSITION_ACCOUNT_APPENDUM))],
            this.solbondProgram.programId
        ); 
```
in rust, I have this: 
```
seeds = [
            owner.key().as_ref(),
            &_index.to_le_bytes(),
            seeds::USER_POSITION_STRING
        ], 
```
hey guys, i'm having difficulty building more complex PDAs from seeds
Probably easiest way to check this is just by reading the anchor cli source: https://github.com/project-serum/anchor/blob/master/cli/src/lib.rs#L2142
Nope, you need to rerun anchor build before you deploy
For example, if I update my program (*.rs) code, and I run anchor deploy, will this catch my changes? Or do I need to run anchor build && anchor deploy for my changes to be picked up?
üëã have a question about the IDL vs. the .so file and anchor build/test/deploy. What sequence of commands do I need to run to have the most up to date .so file before I'm able to deploy? If the .so is up to date does this also mean my IDL is up to date?
How do I learn how to send spl token to an account? is there any github repo or tutorial??
Yuh, figured it out but tyvm, y‚Äôall are the best
Not a full keypair, no. You can do `new anchor.web3.PublicKey` if you want to use a known public key, but you can't figure out the secret key.
üëã For the purposes of testing in Anchor, is there a way to generate a keypair with the public key being a specific string?
Ahh got it thanks
So you're somehow using the wrong owner/mint combo
Which doesn't match the one in the link, 2ahEDcaprLwm3y1pka24Ub61GxXXGgq2WpWXjBdRftMv
By my calculations, using the accounts in that solscan link, the ATA address ought to be "9yHYp4u6gb9VuST7e9rx76xbkZxXhcjJiy3e9N8CKCAQ"
tokenAccount = await Token.getAssociatedTokenAddress(
        ASSOCIATED_TOKEN_PROGRAM_ID, 
        TOKEN_PROGRAM_ID,
        mintPublicKey,
        wallet
    );
(And it's probably not correct, hence the error you're getting)
That's the only way to check if it's correct‚Äîbut checking how you originally calculated it
Sure, but how did you originally calculate it?
I saved it somewhere in an account and then passing it in create instruction
But how are you calculating the address on the client?
How are you calculating it?
Why do you think it's correct?
Doesn't sound like it üòõ
I'm not sure why its throwing me the error but the associated address that I'm getting is correct.
That means you're not calculating an associated token address correctly
ah, solscan just makes it extra confusing
I would say just use the regular explorer: https://explorer.solana.com/address/EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v
yep, I plan on having a static list in my program.

```
static ALLOWED_MINTS: [Pubkey; 3] = [
        solana_program::pubkey!("")
    ];
```

and then doing a check as an anchor account macro constraint. Other option is to create a PDA for each allowed mint and checking if that PDA exists or not (if you wanted to do it programmatically)
quick bump here! reposting the question:

üëã For a given SPL token, is the token address the same thing as the mint? e.g. for USDC (https://solscan.io/token/EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v) the token address is `EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v`
Getting an error -> 

#1 Associated Token Account Program instruction
> Program log: Error: Associated address does not match seed derivation
> Program Associated Token Account Program  consumed 7542 of 200000 compute units
> Program returned error: Provided seeds do not result in a valid address
I think token accounts are the only special case
not default means:
1. owner =xx
2. TokenAcount 
Ôºü
Yep, "By default" (so not always)
https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html
"By default init sets the owner field of the created account to the currently executing program. Add the owner constraint to specify a different program owner."
At any rate, no, in the above case ownership is assigned to the spl token program
My version of that page doesn't say that
Where are you getting that quote from?
"account(init) would assign owner to the executing program." https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html

Is this always true in the following example ? (doesn't seem to be since TokenAccount is owned by spl token program.
```
#[derive(Accounts)]
#[instruction(vault_account_bump: u8, initializer_amount: u64)]
pub struct Initialize<'info> {
    #[account(
        init,
        seeds = [b"token-seed".as_ref()],
        bump,
        payer = initializer,
        token::mint = mint,
        token::authority = initializer,
    )]
    pub vault_account: Account<'info, TokenAccount>,
```
Why or why not?
Only for adding pda signatures
Hey <@!134416332509675520>  I have a question is invoke_signed used for pda as a signers only or it is also used for signing by the authority or the user as well
GOT IT Thanks
The ? implicitly does what you're trying to do with map_err (so the map_err part is unnecessary)
Just do `)?;`
Get rid of the map_err
<@!134416332509675520>
This is the Error

this is
Gotta show me the actual error
and is it not compulary to have that in an anchor function ? <@!134416332509675520> Sorry for asking noob questions
Ok but if i add Ok(()) then it gives error why
nice profile picture
The question mark sort of does an implicit map_err
No map_err at all
Oh, sorry, just do `)?;`
~~Just do `).map_err(Into::into)?;` (use the ? mark)~~
But what if i have multiple invoke sign in an Instruction
ohk it worked
Just have that be the last expression in your whole function
Get rid of the semicolon and the following Ok(()) part
It comes when i add map_err(Into::into)
When i try to add 
       ` invoke(
            &ix,
            &[
                ctx.accounts.metadata.clone(),
                ctx.accounts.mint.clone(),
                ctx.accounts.payer.clone(),
                ctx.accounts.payer.clone(),
                ctx.accounts.payer.clone(),
                ctx.accounts.system_program.to_account_info(),
                ctx.accounts.rent.to_account_info()
            ],
        ).map_err(Into::into);`
I am getting this error
Okay
No, unfortunately (custom deserialization doesn't really mesh with the IDL concept, since currently there's no way to specify how that deserialization should work for different clients)
anything I can derive to solve this?
I implemented Anchor Deserialize for one of the structs myself, but now the idl doesn't generates code for that struct type
hey guys, is the public key / program Id output by 
`anchor keys list`

the same as what is generated when you `anchor build / deploy`
Yes, it's in seconds since the "epoch", Jan 1 1970 (negative seconds for times before then)
Kind of goofy, but rename that `program_id` variable to something different
Why is this error comming
Hey <@!134416332509675520> i am getting this error
That means you're somehow trying to invoke an instruction in your program that doesn't actually exist. Often because you messed up deploying.
For reference, my file looks like this
```
[workspace]
members = [
    "programs/*"
]
```
anyone know why vscode linker gives this error on anchors main cargo.toml? 

```
build failed
error: could not compile `libsecp256k1-core`
```
Hi, how can I write account's data directly for testing purposes in Anchor JS test script?
whats this error mean? ```    Program log: AnchorError occurred. Error Code: InstructionFallbackNotFound. Error Number: 101. Error Message: Fallback functions are not supported.
```
Which tutorial are you talking about?
No
is the unix timestamp in seconds?
Use clock
how do I get current time in anchor/solana to store in an account?
I had a similar question and did some more digging around and found this tutorial on youtube. Pretty close to what you need and you might be able to take a few points off of it. Hope it helps
Hello, can someone point me to some documentation/tutorial on how to send spl tokens within anchor? 

I'm trying to create an endpoint that request some amount of an spl token to be transferred from the users wallet into another wallet, and if it was successful do something. TIA
Getting the follow error after I sign and approve,
```
Uncaught (in promise) TypeError: Cannot read properties of undefined (reading 'toString')
    at Transaction.partialSign (index.browser.esm.js?3ee8:2673:1)
```
Willing to compensate for your time. Please dm me. Have been at this for hours and can't seem to figure it out for some reason
Would anyone be able to spare 5 min to debug an issue that I am running into?
üëã For a given SPL token, is the token address the same thing as the mint? e.g. for USDC (https://solscan.io/token/EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v) the token address is `EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v`
thank you
Put `#[account(mut)]` over `user` in your `Initialize`
use anchor_lang::prelude::*;

declare_id!("Atb1sMsLSSuNicdiAXKPwy5ecRAnFacWXQxhw2iQBfo");

#[program]
mod crunchy_vs_smooth {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>, vote_account_bump: u8) -> Result<()> {
        ctx.accounts.vote_account.bump = vote_account_bump;
        Ok(())
    }

    pub fn vote_crunchy(ctx: Context<Vote>) -> Result<()> {
        ctx.accounts.vote_account.crunchy += 1;
        Ok(())
    }

    pub fn vote_smooth(ctx: Context<Vote>) -> Result<()> {
        ctx.accounts.vote_account.smooth += 1;
        Ok(())
    }

    pub fn vote_neutral(ctx: Context<Vote>) -> Result<()> {
        ctx.accounts.vote_account.neutral += 1;
        Ok(())
    }

}

#[derive(Accounts)]
#[instruction(vote_account_bump: u8)]
pub struct Initialize<'info> {
    #[account(init, seeds = [b"vote_account".as_ref()], bump, payer = user)]
    vote_account: Account<'info, VotingState>,
    user: Signer<'info>,
    system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct Vote<'info> {
    #[account(mut, seeds = [b"vote_account".as_ref()], bump = vote_account.bump)]
    vote_account: Account<'info, VotingState>,
}

#[account]
#[derive(Default)]
pub struct VotingState {
    crunchy: u64,
    smooth: u64,
    neutral: u64,
    bump: u8,
}

Without seeing more of the code, I can't be sure, but my guess is that you labeled `vote_account` somewhere as the `payer` in that `Accounts` derive, and it doesn't like that because the `vote_account` isn't signing
Hey does anyone know of any tutorials telling how to create and send payments to an address using anchor?
any idea how to address these as a result? error: the payer specified for an init constraint must be mutable.
  --> programs/sol-poll/src/lib.rs:62:5
   |
62 |     vote_account: Account<'info, VotingState>,
   |     ^^^^^^^^^^^^

error[E0432]: unresolved import `crate`
 --> programs/sol-poll/src/lib.rs:9:1
  |
9 | #[program]
  | ^^^^^^^^^^ could not find `__client_accounts_initialize` in the crate root
  |
  = note: this error originates in the attribute macro `program` (in Nightly builds, run with -Z macro-backtrace for more info)
I'm hitting a wall with `anchor idl init` (localnet). It looks like it might be the same issue as https://github.com/project-serum/anchor/issues/1543 but afaict the program ID I'm passing is correct--unless I'm completely misunderstanding the command. Is it the same account as is specified in `declare_id!`?
Now you can just say `bump` instead of `bump=some_var`
What is the bump account issue between versions?
error: bump targets should not be provided with init. Please use bump without a target.
  --> programs/sol-poll/src/lib.rs:58:57
   |
58 |     #[account(init, seeds = [b"vote_account".as_ref()], bump = vote_account_bump, payer = user)]
   |                                                         ^^^^
moving from 0.16.0 to 0.22.1
Like, say I want to deserialize some X into a Y, and it's implemented, how do I actually transform an instance of X into a Y?
How do you actually call deserialize on something in Rust?
Is there a way to send a transaction without a user signing for it? For example the user makes a transaction where they buy something, then I want to update a pda owned by the program with the transaction Id of the original purchase transaction. But if possible without the user having to sign for it again

Hey how do I change a wallet's sol balance like transfer to different wallet
I should pull from here am I worng??
any idea what im missing?
im running `anchor deploy` on the serum dex program targeting a `solana-test-validator`, but its not going to the desired address - i edited the `Anchor.toml` to have 
```[programs.localnet]
serum_dex = "9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin"```
but its still going to the address `3MYWDHjNojvKFqzXX89ioxccQUb3UQbyzam2d94xk3df` every time
grep'ed for that address in the dex repo and no hits
np thanks for the suggestion, I'm a Rust newbie, but taking a stab at some web API stuff in Rust, it's been half super fun, half super difficult hahaha
Oh, sorry, I was thinking in TS
Compiler complains when I try that:
```
let tx = Transaction::from(&bs58::decode(body.raw_msg).into_vec()?);
                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `solana_sdk::transaction::Transaction`, found `&Vec<u8>`
```
Think you can use `Transaction.from`
The Rust SDK has `tx.message.serialize()` if I want to serialize a `Transaction` into a signable message, but how would I deserialize that message back into the `Message` or `Transaction` object?
Thank you!
Ah that explains why it isn't working on 0.22.1 but works on 0.18.2
https://github.com/project-serum/anchor/blob/master/CHANGELOG.md#breaking-2
```
and when I put anchor keys list :

~/solyetis-staking-app-master/contracts/flexible_staking_contract$ anchor keys list
thread 'main' panicked at 'Code not parseable: Error("bump targets should not be provided with init. Please use bump without a target.")', lang/syn/src/idl/file.rs:357:58
note: run with RUST_BACKTRACE=1 environment variable to display a backtrace
```
Anyone seen this error?
against devnet, that is
`     Error: 429 Too Many Requests:  {"jsonrpc":"2.0","error":{"code": 429, "message":"Too many requests for a specific RPC call, contact your app developer or support@rpcpool.com."}, "id": "1c8441e1-b5aa-436d-8c09-0b27340af6f4" } `
Also, are folks getting this when running tests against devnet?  Did the rate limiting become tighter lately?
Ah did not realise the --help could be used on the subcommands too. cheers!
`anchor test --skip-deploy` (can run `anchor test --help` for more options)
Burn all of them? No, you'd have to loop over them or something
Is there a way to prevent anchor test from doing a deploy first?
üëã is there a function that exists to burn all NFTs in your wallet?
Trying to attach a recent block hash Rust-side to a `Transaction` before sending the unsigned `Message`.

Getting this compiler error. Weird paths it's referring to, but all I seem to need is some valid type annotation for the vec.
```
tx.partial_sign::<Vec<Keypair>>(&vec![], blockhash);
                  ^^^^^^^^^^^^ the trait `anchor_client::solana_sdk::signers::Signers` is not implemented for `Vec<anchor_client::solana_sdk::signature::Keypair>`
```


//////////////////////////////////////////////////////////////////////////////////////////

=======
>>>>>>> 20bea11087240cc616c020a0810cf4b960b99b41
